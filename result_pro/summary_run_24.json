{
  "run_index": 24,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 391,
  "generation_or_validation_failure_count": 48,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[5,1,2,3,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[5, 1, 2, 3, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳結果列表。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    # 從標準輸入讀取所有程式碼，並執行\n    code = sys.stdin.read()\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation after each line. Use arrows etc. No actual code. Should simulate using random module, function roll_dice(n) returns list of results. Steps: import random, define function, create list, loop n times, append random.randint(1,6), return list. End.\n\nFollow format. Use \"Start\", \"End\". Include \"Decision:\" maybe none needed. Just simple. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import 模組 random // 導入隨機數模組  \n→ Step 2: 定義函數 roll_dice(n) // 建立擲骰子函數，接收擲次數  \n→ Step 3: 建立空串列 results // 用於存放每次擲骰的結果  \n→ Step 4: For i from 1 to n // 依序擲 n 次  \n    → Step 5: random.randint(1,6) → result // 產生 1~6 的隨機數  \n    → Step 6: Append result 到 results // 把結果存進串列  \n→ Step 7: Return results // 回傳所有擲骰結果的串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行時間，並回傳秒數（四捨五入到小數點 3 位）\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    # 讀取全部輸入，並直接執行\n    code = sys.stdin.read()\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. We need to include Start, End, Decision, etc. The function measure_time(func, *args) to measure time. Use time module. Steps: import time, define function, get start, call func(*args) to get result, get end, compute elapsed, round to 3 decimal, return result. Virtual code may include steps like \"Step 1: Import time module\". Also decision? Not necessary. But maybe if we want to check if args? But not necessary. Just simple steps. Let's produce a sequential virtual code:\n\nStart\n→ Step 1: Import time module\n→ Step 2: Define function measure_time(func, *args)\n    → Step 3: Record start_time = current time\n    → Step 4: Execute target function: result = func(*args)\n    → Step 5: Record end_time = current time\n    → Step 6: Compute elapsed = end_time - start_time\n    → Step 7: Round elapsed to 3 decimal places: rounded_time = round(elapsed, 3)\n    → Step 8: Return result, rounded_time\nEnd\n\nBut we need to be careful: The function should return the result of func? The requirement: \"回傳結果 (四捨五入到小數點 3 位)\" Could interpret that the function returns the elapsed time. But maybe returns the result of func? Let's interpret: \"測量函數 func 執行所需的秒數，並回傳結果\" maybe return elapsed time. The phrase \"結果\" ambiguous. But likely return elapsed time. Could also return both result and elapsed time. But keep simple: return rounded elapsed time. So Step 8: return rounded_time.\n\nThus the virtual code should reflect that.\n\nMake sure each line ends with // explanation. Use arrow. Use \"→\" arrow preceding each step, but indentation for nested steps inside function. Use indentation to show nested.\n\nWe'll output each line as requested.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入 time 以獲取時間戳  \n→ Step 2: Define function measure_time(func, *args) // 建立測時函式，接收目標函式與可變參數  \n    → Step 3: Record start_time = current time // 紀錄呼叫前的起始時間  \n    → Step 4: Execute target function: result = func(*args) // 執行傳入的函式並取得結果  \n    → Step 5: Record end_time = current time // 紀錄呼叫後的結束時間  \n    → Step 6: Compute elapsed = end_time - start_time // 計算執行所耗費的秒數  \n    → Step 7: Round elapsed to 3 decimal places: rounded_time = round(elapsed, 3) // 四捨五入到小數點 3 位  \n    → Step 8: Return rounded_time // 回傳測量結果  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"apple\",\"grape\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'apple', 'grape', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取所有輸入，雖然此題不需要用到，但依規定須從 stdin 讀取\n    _ = sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 新增單一元素\n    fruits.add('orange')\n\n    # 一次新增多個元素\n    fruits.update(['grape', 'melon'])\n\n    # 移除存在的元素（不存在會拋出 KeyError）\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的元素，安全忽略\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. The task: create set, add, update, remove, discard, print. Use Start, End, Decision? Not necessary. Just simple steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols. Use \"→\" for step lines. Use \"Start\" \"End\". No actual code. Just virtual. Provide for each operation. Use proper indentation maybe. Example: \"→ Step 1: 創建集合 fruits = {'apple', 'banana'} // 初始化集合\". Then add, update, remove, discard, print. Provide explanations. Use \"End\". Provide arrow. Use \"Decision\" maybe not needed. Keep consistent with format. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建集合 fruits = {'apple', 'banana'} // 初始化集合  \n→ Step 2: 呼叫 fruits.add('orange') // 新增元素 'orange'  \n→ Step 3: 呼叫 fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'  \n→ Step 4: 呼叫 fruits.remove('banana') // 移除元素 'banana'，若不存在會拋錯  \n→ Step 5: 呼叫 fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'，不會錯誤  \n→ Step 6: 輸出 fruits // 顯示最終集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.76TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.76 TWD'"
        }
      ],
      "generated_code": "import requests\nimport sys\n\ndef fetch_rate() -> float | None:\n    \"\"\"\n    取得美元對台幣的匯率，成功則回傳浮點數，失敗回傳 None。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()                     # 若 HTTP 狀態不是 200，拋出例外\n        data = response.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取指令，若為「按下「更新匯率」按鈕」則取得匯率並輸出到標準輸出。\n    \"\"\"\n    # 讀取整個 stdin，並去除首尾空白\n    command = sys.stdin.read().strip()\n\n    if command == \"按下「更新匯率」按鈕\":\n        rate = fetch_rate()\n        if rate is None:\n            print(\"更新失敗，請檢查網路連線\")\n        else:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n    else:\n        # 任何非預期指令皆不輸出任何內容\n        pass\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with line by line steps. Should be in Traditional Chinese. Use virtual code syntax: Start, Decision, Yes→, No→, arrows, etc. The code should use requests module, tkinter. The code steps: import modules, create Tk root, set up label, button. Define function to fetch rate: use requests.get, parse JSON, extract TWD. Update label. Bind button to function. Mainloop.\n\nWe need to provide for each line: \"虛擬碼步驟 // 解釋\". Use \"Start // 程式開始執行\" etc.\n\nLet's craft steps.\n\nWe need to avoid actual code, only pseudo steps.\n\nWe need to use arrow \"→\" for sequential steps, \"Decision:\" with Yes→ No→.\n\nWe need to produce steps like:\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter, json // 導入需要的模組\n→ Step 2: Create Tk root window // 建立主視窗\n→ Step 3: Set window title to 'USD to TWD Rate' // 設定視窗標題\n→ Step 4: Create Label widget to display rate // 建立顯示匯率的標籤\n→ Step 5: Pack the label // 放置標籤\n→ Step 6: Define function fetch_rate() // 定義獲取匯率的函式\n    → Step 6.1: Send GET request to API URL // 發送 GET 請求\n    → Decision: If response status OK? // 檢查回應是否成功\n        Yes → Step 6.2: Parse JSON from response // 解析 JSON\n        → Step 6.3: Extract TWD rate // 取出 TWD 匯率\n        → Step 6.4: Update label text with rate // 更新標籤文字\n        No  → Step 6.5: Update label text with error message // 顯示錯誤訊息\n→ Step 7: Create Button widget with text 'Refresh' and command fetch_rate // 建立更新按鈕\n→ Step 8: Pack the button // 放置按鈕\n→ Step 9: Call fetch_rate() once to show initial rate // 初次呼叫以顯示匯率\n→ Step 10: Start Tk mainloop // 開始 GUI 事件迴圈\nEnd // 程式執行結束\n\nNeed to ensure each line ends with // 解釋. Use Chinese explanation. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests, tkinter, json // 導入需要的模組  \n→ Step 2: Create Tk root window // 建立主視窗  \n→ Step 3: Set window title to 'USD to TWD Rate' // 設定視窗標題  \n→ Step 4: Create Label widget to display rate // 建立顯示匯率的標籤  \n→ Step 5: Pack the label // 放置標籤  \n→ Step 6: Define function fetch_rate() // 定義獲取匯率的函式  \n    → Step 6.1: Send GET request to API URL // 發送 GET 請求  \n    → Decision: If response status OK? // 檢查回應是否成功  \n        Yes → Step 6.2: Parse JSON from response // 解析 JSON  \n        → Step 6.3: Extract TWD rate // 取出 TWD 匯率  \n        → Step 6.4: Update label text with rate // 更新標籤文字  \n        No  → Step 6.5: Update label text with error message // 顯示錯誤訊息  \n→ Step 7: Create Button widget with text 'Refresh' and command fetch_rate // 建立更新按鈕  \n→ Step 8: Pack the button // 放置按鈕  \n→ Step 9: Call fetch_rate() once to show initial rate // 初次呼叫以顯示匯率  \n→ Step 10: Start Tk mainloop // 開始 GUI 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[0,0],[1,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [0, 0], [1, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        \"\"\"初始化 m 行 n 列的二元矩阵。\"\"\"\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols   # 总格数\n        self.remaining = self.total    # 仍可翻转的格数\n        self.map = {}                  # 映射表，键为随机下标，值为实际格号\n\n    def flip(self):\n        \"\"\"\n        随机挑选一个尚未翻转的格子，翻转为 1，并返回其坐标。\n        \"\"\"\n        # 生成 0 .. remaining-1 范围内的随机整数\n        r = random.randint(0, self.remaining - 1)\n        # 取得 r 对应的实际格号（如果已经被映射则取映射值）\n        val = self.map.get(r, r)\n        # 取得当前最后一个可用格的实际格号\n        last_val = self.map.get(self.remaining - 1, self.remaining - 1)\n        # 把 r 位置映射为 last_val，完成“交换”\n        self.map[r] = last_val\n        # 该格子已被翻转\n        self.remaining -= 1\n        # 把格号转换为二维坐标\n        row = val // self.cols\n        col = val % self.cols\n        return [row, col]\n\n    def reset(self):\n        \"\"\"将所有格子恢复为 0。\"\"\"\n        self.remaining = self.total\n        self.map.clear()\n\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 解析输入为两组列表：操作列表和参数列表\n    data = ast.literal_eval('[' + raw + ']')\n    ops, args = data\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)\n        elif op == \"flip\":\n            results.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            results.append(None)\n\n    # 用 JSON 输出，None 会被转换为 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. We need to design algorithm for random flip with equal probability among zeros. Classic solution: maintain list of available indices (or use mapping from 1..m*n-1). Use reservoir? Actually typical: Use an array of size m*n, initially identity mapping. When flipping, pick random index r from 0 to remaining-1. Map r to value v = mapping.get(r, r). Map last index to mapping.get(remaining-1, remaining-1). Update mapping[r] = last value. Decrement remaining. Return coordinates via divmod. Reset clears mapping and remaining.\n\nWe need to present pseudocode with Start, End, Decision. We'll create methods: Constructor, flip, reset. We must use minimal random calls: one per flip.\n\nWe need to describe algorithm steps. Provide virtual code for class and methods. Use Start, End, Decision, etc. Provide line-by-line.\n\nLet's plan pseudocode structure:\n\n- Start // initialize object\n- → Step: Set m, n\n- → Step: total = m*n\n- → Step: remaining = total\n- → Step: mapping = empty map // dictionary for mapping indexes\n\n- flip() method:\n    Start // flip called\n    → Decision: If remaining == 0? // no zeros left\n        No → Step: throw exception or return null\n    → Step: r = random(0, remaining-1) // one random call\n    → Step: val = mapping.get(r, r) // get mapped value or r\n    → Step: last = mapping.get(remaining-1, remaining-1) // value at last index\n    → Step: mapping[r] = last // swap\n    → Step: remaining -= 1\n    → Step: row = val / n\n    → Step: col = val % n\n    → Step: return [row, col]\n    End // flip done\n\n- reset() method:\n    Start // reset called\n    → Step: remaining = m*n\n    → Step: mapping.clear()\n    End\n\nWe should output as lines of virtual code with comment after //.\n\nWe need to show decision structure for reset maybe not needed. Just one decision for remaining==0.\n\nUse arrow \"→\" for steps.\n\nLet's write lines:\n\nStart // 程式開始執行\n\n→ Step: 初始化 m, n, total, remaining, mapping // 設定矩陣大小與映射表\n\n→ End // 初始化完成\n\nBut the Start and End for constructor? Might treat constructor as part of class definition. But we can provide separate sections.\n\nBetter: Provide pseudo-code for class with methods.\n\nLet's produce:\n\nStart // 定義 Solution 類別\n→ Constructor: Solution(m, n) // 建構子\n    → Step: this.m = m // 設定行數\n    → Step: this.n = n // 設定列數\n    → Step: this.total = m * n // 總格數\n    → Step: this.remaining = this.total // 仍可翻轉的格數\n    → Step: this.map = {} // 空映射表\n    → End // 建構子結束\n\n→ Method: flip() // 產生隨機 0 的索引並翻轉\n    → Step: if this.remaining == 0 // 若無可翻轉格\n        → No → Step: return null // 或拋出例外\n    → Step: r = randomInt(0, this.remaining - 1) // 產生隨機整數\n    → Step: val = this.map.get(r, r) // 取得對應值\n    → Step: lastVal = this.map.get(this.remaining - 1, this.remaining - 1) // 取得最後一個位置的值\n    → Step: this.map[r] = lastVal // 將 r 對應改為 lastVal\n    → Step: this.remaining -= 1 // 可翻轉格數減一\n    → Step: row = Math.floor(val / this.n) // 計算行\n    → Step: col = val % this.n // 計算列\n    → Step: return [row, col] // 回傳座標\n    → End // flip 結束\n\n→ Method: reset() // 重置矩陣\n    → Step: this.remaining = this.total // 重新設為總格數\n    → Step: this.map.clear() // 清空映射表\n    → End // reset 結束\n\nEnd // 程式結束\n\nBut we need line-by-line with arrow at each line, and comment after //.\n\nWe need to follow the format: \"虛擬碼步驟 [space] // 解釋\".\n\nSo each line like \"Start // 程式開始執行\".\n\nWe need to include arrows \"→\" at beginning of lines after Start? In sample, they used \"→\" for steps. We'll mimic.\n\nWe need to include decisions with indentation? In sample, they used indentation under Decision. But we can keep simple.\n\nWe will produce the virtual code with indentation for decisions.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: 定義 Solution 類別 // 宣告整個類別\n    → Constructor: Solution(m, n) // 建構子，傳入行列數\n        → Step: this.m = m // 設定行數\n        → Step: this.n = n // 設定列數\n        → Step: this.total = m * n // 計算總格數\n        → Step: this.remaining = this.total // 可翻轉格數初始化為總格數\n        → Step: this.map = {} // 建立空映射表，鍵為索引，值為對應的格號\n        → End // 建構子結束\n    → Method: flip() // 取得隨機 0 的索引並翻轉為 1\n        → Decision: this.remaining == 0? // 檢查是否還有 0\n            Yes → Step: return null // 沒有可翻轉格，回傳 null 或拋出例外\n            No  → Step: r = randomInt(0, this.remaining - 1) // 產生 0~remaining-1 的隨機整數\n            → Step: val = this.map.get(r, r) // 若 r 已映射則取映射值，否則取 r 本身\n            → Step: lastVal = this.map.get(this.remaining - 1, this.remaining - 1) // 取得最後一個位置的值\n            → Step: this.map[r] = lastVal // 把 r 的位置映射到 lastVal，完成“交換”\n            → Step: this.remaining -= 1 // 可翻轉格數減一\n            → Step: row = Math.floor(val / this.n) // 將格號轉回行座標\n            → Step: col = val % this.n // 將格號轉回列座標\n            → Step: return [row, col] // 回傳隨機選取的 (i, j)\n        → End // flip 方法結束\n    → Method: reset() // 重置所有格為 0\n        → Step: this.remaining = this.total // 可翻轉格數重新設為總格數\n        → Step: this.map.clear() // 清空映射表，恢復初始狀態\n        → End // reset 方法結束\nEnd // 程式結束\n```"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx73vy9az.py\", line 51, in <module>\n    obj.buildDict(arg)\n  File \"/tmp/tmpx73vy9az.py\", line 13, in buildDict\n    pattern = word[:i] + '*' + word[i+1:]\n              ~~~~~~~~~^~~~~\nTypeError: can only concatenate list (not \"str\") to list"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MagicDictionary:\n    def __init__(self):\n        # pattern (word with one char replaced by '*') -> set of words having that pattern\n        self.pattern_to_words = {}\n\n    def buildDict(self, dictionary):\n        self.pattern_to_words.clear()\n        for word in dictionary:\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                self.pattern_to_words.setdefault(pattern, set()).add(word)\n\n    def search(self, searchWord):\n        for i in range(len(searchWord)):\n            pattern = searchWord[:i] + '*' + searchWord[i+1:]\n            words_set = self.pattern_to_words.get(pattern)\n            if not words_set:\n                continue\n            for w in words_set:\n                if w != searchWord:  # must change exactly one character\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Separate the commands and arguments lists\n    if '\\n' in data:\n        commands_str, args_str = data.splitlines()\n    else:\n        # Single line containing both lists\n        idx = data.find(']')\n        commands_str = data[:idx+1]\n        args_str = data[idx+2:].strip()  # skip comma and space\n\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            result.append(None)\n        elif cmd == \"buildDict\":\n            obj.buildDict(arg)\n            result.append(None)\n        elif cmd == \"search\":\n            res = obj.search(arg)\n            result.append(res)\n\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The user wants a virtual code solution for the MagicDictionary problem. Use arrow notation, decisions, etc. Each line: virtual code step + space + // explanation. Need to design the data structure: maybe use a hash map of patterns or a Trie. Let's use map from pattern to count. For each word, for each position replace char with '*', store pattern count. Search: for each position replace char with '*', if pattern exists and either (1) pattern count>1 or (2) original word not exactly same (i.e., the word is different from searchWord), then return true. But we need to ensure exactly one character change. Use this logic.\n\nWe need to produce the virtual code lines describing steps: Start, building dictionary, search logic.\n\nLet's craft lines. Each step may involve loops.\n\nWe need to show steps for constructor, buildDict, search. Use arrow for loops, decisions.\n\nLet's produce: \nStart // program start\n→ Step 1: Define class MagicDictionary // class definition\n→ Step 2: Declare map patternCount // to store patterns and counts\n→ Step 3: Define constructor // initialize map\n→ Step 4: Define buildDict(dictionary) // process each word\n    → Loop for each word in dictionary // iterate words\n        → Loop for each index i in word length // iterate positions\n            → Create pattern by replacing char at i with '*'\n            → Increment patternCount[pattern]\n→ Step 5: Define search(searchWord) // search logic\n    → Loop for each index i in searchWord length\n        → Create pattern by replacing char at i with '*'\n        → If patternCount contains pattern\n            → Decision: if patternCount[pattern] > 1 or searchWord != pattern.replace('*', original char)\n                → Return true\n    → Return false\nEnd // program end\n\nWe need each line with \"→\" or \"Start\". Use indentation for decision branches? Use Yes/No arrows.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: Define class MagicDictionary // 建立類別\n→ Step 2: Declare map patternCount // 用於儲存模式與出現次數\n→ Step 3: Define constructor MagicDictionary() // 建構子，初始化 map\n→ Step 4: Define buildDict(dictionary) // 建立字典\n    → Loop for each word in dictionary // 逐字處理\n        → Loop for each position i in word // 逐字符\n            → Create pattern by replacing character at i with '*'\n            → Increment patternCount[pattern] // 記錄模式出現次數\n→ Step 5: Define search(searchWord) // 查詢功能\n    → Loop for each position i in searchWord // 逐字符\n        → Create pattern by replacing character at i with '*'\n        → Decision: patternCount contains pattern? // 是否有此模式\n            → Yes → Decision: patternCount[pattern] > 1 OR searchWord != pattern with '*' replaced? // 確認是否符合改一個字母\n                → Yes → Return true // 找到符合的字\n                → No → Continue // 檢查下一個位置\n            → No → Continue // 模式不存在，檢查下一個位置\n    → Return false // 沒有符合的字\nEnd // 程式執行結束\n\nBut each line must be single virtual code line: we cannot combine multiple actions into one line. We need to break each into separate lines. The \"Decision:\" line may have nested arrows. Let's produce:\n\nStart // 程式開始執行\n→ Class MagicDictionary // 定義類別\n→ Variable patternCount : Map<string, int> // 模式對應出現次數\n→ Constructor MagicDictionary() // 初始化\n    → patternCount = empty map // 清空 map\n→ Method buildDict(dictionary) // 建立字典\n    → Loop word in dictionary // 逐字\n        → Loop i from 0 to word.length-1 // 逐位置\n            → pattern = word with character at i replaced by '*'\n            → Increment patternCount[pattern] // 記錄模式\n→ Method search(searchWord) // 查詢\n    → Loop i from 0 to searchWord.length-1 // 逐位置\n        → pattern = searchWord with character at i replaced by '*'\n        → Decision: patternCount contains pattern? // 有無此模式\n            → Yes → Decision: patternCount[pattern] > 1 OR searchWord != pattern with '*' replaced? // 判斷是否可改一個字母\n                → Yes → Return true // 成功\n                → No → Continue // 檢查下一個位置\n            → No → Continue // 無此模式，檢查下一個位置\n    → Return false // 所有位置都未成功\nEnd // 程式結束\n\nBut we need to keep each line separate, using \"→\". The indentation can be shown as spaces.\n\nLet's ensure we follow \"虛擬碼步驟\" plus comment. Use Chinese.\n\nWe might need to include arrow for loops? The sample shows arrow for each step including loops. Use \"→\" for each line. Use \"Decision:\" line. Provide nested branches using \"Yes →\" and \"No →\" etc.\n\nWe must not output actual code. Provide only virtual code and explanations.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MagicDictionary // 建立類別  \n→ Variable patternCount : Map<string, int> // 用於儲存「字母位置替換成 *」的模式與出現次數  \n→ Constructor MagicDictionary() // 初始化建構子  \n    → patternCount = empty map // 清空並準備儲存模式  \n→ Method buildDict(dictionary) // 建立字典  \n    → Loop word in dictionary // 逐字處理  \n        → Loop i from 0 to word.length-1 // 逐個字符位置  \n            → pattern = word with character at i replaced by '*' // 產生模式  \n            → Increment patternCount[pattern] // 記錄此模式出現次數  \n→ Method search(searchWord) // 查詢功能  \n    → Loop i from 0 to searchWord.length-1 // 逐個字符位置  \n        → pattern = searchWord with character at i replaced by '*' // 產生搜尋模式  \n        → Decision: patternCount contains pattern? // 是否存在此模式  \n            → Yes → Decision: patternCount[pattern] > 1 OR searchWord != pattern with '*' replaced? // 確認是否能改一個字母得到字典中的單詞  \n                → Yes → Return true // 找到符合的單詞，立即返回  \n                → No → Continue // 該位置不符合，繼續檢查下一個位置  \n            → No → Continue // 模式不存在，繼續檢查下一個位置  \n    → Return false // 所有位置都未能匹配，返回 false  \nEnd // 程式執行結束"
    },
    {
      "title": "Next Greater Element I",
      "source_file": "Leetcode/leetcode496.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjd0m73ez.py\", line 27, in <module>\n    nums1 = ast.literal_eval(nums1_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqzsbjtmz.py\", line 27, in <module>\n    nums1 = ast.literal_eval(nums1_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextGreaterElement(self, nums1, nums2):\n        stack = []\n        next_greater = {}\n\n        for num in nums2:\n            while stack and num > stack[-1]:\n                prev = stack.pop()\n                next_greater[prev] = num\n            stack.append(num)\n\n        return [next_greater.get(x, -1) for x in nums1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入字串拆成兩部分並解析成列表\n    parts = data.split(',', 1)\n    nums1_part = parts[0].split('=', 1)[1].strip()\n    nums2_part = parts[1].split('=', 1)[1].strip()\n\n    nums1 = ast.literal_eval(nums1_part)\n    nums2 = ast.literal_eval(nums2_part)\n\n    result = Solution().nextGreaterElement(nums1, nums2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm. The requirement: generate step-by-step virtual code, each line with \"虛擬碼步驟 // 解釋\". Use arrow notation. We need to produce solution for next greater element for subset problem.\n\nWe need to produce algorithm: Use stack to compute next greater element for all elements in nums2. Use a hash map mapping value to its next greater. Then iterate over nums1 to map.\n\nWe need to write virtual code line by line with decisions. Provide explanation after each line.\n\nWe must not output actual code, just pseudo-steps.\n\nLet's produce:\n\nStart\n→ Step 1: Create empty stack // For tracking indices of nums2\n→ Step 2: Create empty map nextGreater // key: element, value: next greater element\n\nNow iterate over nums2 indices i from 0 to n-1:\n→ Decision: For each element nums2[i], while stack not empty and nums2[i] > nums2[stack.top()]\n   Yes → Step 3: Pop index from stack // Found next greater for popped element\n        → Step 4: Set nextGreater[nums2[poppedIndex]] = nums2[i] // Map popped to current\n   No → End inner loop\n\n→ Step 5: Push i onto stack // current index may have next greater later\n\nAfter loop:\n→ Step 6: For any remaining indices in stack, set nextGreater[nums2[remainingIndex]] = -1 // No greater\n\nNow produce answer array:\n→ Step 7: Create ans array of same length as nums1\n→ For each index i from 0 to nums1.length-1:\n    → Step 8: val = nums1[i]\n    → Step 9: ans[i] = nextGreater[val] // Retrieve from map (may be -1)\n\nReturn ans.\n\nWe need to format as virtual steps with arrow and decisions.\n\nLet's produce with lines.\n\nAlso we might need to include Start and End. Provide each step with arrow \"→\". Also \"Decision:\" lines.\n\nLet's structure:\n\nStart\n→ Step 1: Initialize empty stack S\n→ Step 2: Initialize empty map M\n\n→ Step 3: For each index i from 0 to nums2.length-1\n    → Decision: While S not empty and nums2[i] > nums2[S.top()]\n        Yes → Step 4: idx = S.pop()\n              → Step 5: M[nums2[idx]] = nums2[i]\n        No → End while\n    → Step 6: S.push(i)\n\n→ Step 7: While S not empty\n    → Step 8: idx = S.pop()\n    → Step 9: M[nums2[idx]] = -1\n\n→ Step 10: Initialize ans array of length nums1.length\n→ Step 11: For each index i from 0 to nums1.length-1\n    → Step 12: ans[i] = M[nums1[i]] // M has -1 if none\n\nEnd\n\nAdd explanations after each line.\n\nAlso may add Decision: If M[nums1[i]] exists? but mapping ensures -1.\n\nNow produce final answer.\n\nEnsure each line ends with // explanation.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 S // 用於追蹤尚未找到下一個更大元素的索引  \n→ Step 2: 初始化空映射 M // key: 數值, value: 下一個更大元素（或 -1）  \n\n→ Step 3: 依序遍歷 nums2 的索引 i (0 → nums2.length-1)  \n  Decision: 是否存在棧頂索引且 nums2[i] 大於 nums2[S.top()]？ // 判斷是否為更大元素  \n   Yes → Step 4: idx ← S.pop() // 從棧中取出索引  \n    → Step 5: M[nums2[idx]] ← nums2[i] // 將該索引對應的數值映射到當前更大元素  \n   No → End while // 內層迴圈結束  \n  → Step 6: S.push(i) // 把當前索引推入棧，等待其下一個更大元素  \n\n→ Step 7: 迴圈結束後，棧中還有剩餘索引  \n  Decision: 是否還有索引剩餘？ // 若棧非空  \n   Yes → Step 8: idx ← S.pop() // 取出索引  \n    → Step 9: M[nums2[idx]] ← -1 // 沒有更大元素，設為 -1  \n   No → End while  \n\n→ Step 10: 初始化答案陣列 ans，長度等於 nums1.length  \n→ Step 11: 依序遍歷 nums1 的索引 i (0 → nums1.length-1)  \n  → Step 12: ans[i] ← M[nums1[i]] // 從映射中取出對應的下一個更大元素（若無則為 -1）  \n\nEnd // 程式執行結束，返回 ans"
    },
    {
      "title": "Find K Closest Elements",
      "source_file": "Leetcode/leetcode658.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2iek0_kq.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmp2iek0_kq.py\", line 47, in main\n    arr = ast.literal_eval(val)\n          ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmparog0odd.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmparog0odd.py\", line 47, in main\n    arr = ast.literal_eval(val)\n          ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport bisect\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        \"\"\"回傳距離 x 最接近的 k 個數字，結果已升序排序\"\"\"\n        # 找到 x 的插入位置\n        idx = bisect.bisect_left(arr, x)\n        left = idx - 1          # 左邊指標\n        right = idx             # 右邊指標\n        result = []\n\n        # 從左右兩側擴展，挑選 k 個最接近的元素\n        for _ in range(k):\n            if left >= 0 and right < len(arr):\n                # 同時兩側都有候選，依照距離和數值大小選擇\n                if abs(arr[left] - x) <= abs(arr[right] - x):\n                    result.append(arr[left])\n                    left -= 1\n                else:\n                    result.append(arr[right])\n                    right += 1\n            elif left >= 0:      # 右側已越界，僅左側可取\n                result.append(arr[left])\n                left -= 1\n            else:               # 左側已越界，僅右側可取\n                result.append(arr[right])\n                right += 1\n\n        # 由於 arr 本身已排序，result 也會保持升序\n        return sorted(result)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，例如: 'arr = [1,2,3,4,5], k = 4, x = 3'\n    parts = [p.strip() for p in data.split(',')]\n    arr = k = x = None\n    for part in parts:\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        if key == 'arr':\n            arr = ast.literal_eval(val)\n        elif key == 'k':\n            k = int(val)\n        elif key == 'x':\n            x = int(val)\n\n    sol = Solution()\n    result = sol.findClosestElements(arr, k, x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line with explanation. We need to provide algorithm for k closest integers to x in sorted array arr. Approach: binary search to find insertion point of x, then use two pointers expand left and right to pick k elements. Output sorted ascending, which can be achieved by sorting the final list or by selecting from left side. Since arr sorted, we can maintain two pointers and pick closest, then return sorted subarray from left to right after selection. Could also use binary search to find left boundary.\n\nSimpler: Use binary search to find position idx such that arr[idx] <= x < arr[idx+1] (i.e., lower bound). Then set left=idx, right=idx+1. Then for i in 1..k: compare left>=0 and right<n. If left>=0 and right<n: compare |arr[left]-x| <= |arr[right]-x| choose left; else choose right. Adjust pointers. After k selections, the selected indices range from left+1 to right-1 maybe. Return arr[left+1 .. right-1] sorted ascending (already ascending). Or collect results and sort.\n\nLet's produce virtual code lines. Include Start, End, Decision. Use arrow. Each line with // explanation.\n\nMake sure each line has virtual code step and explanation. We'll produce algorithm steps.\n\nLet's craft:\n\nStart\n→ Step 1: 定義 n = arr.length // array length\n→ Step 2: BinarySearch: 找到左側索引 leftIdx 使 arr[leftIdx] <= x 且 arr[leftIdx+1] > x\n    Decision: x 小於 arr[0]? // x 在最左邊\n        Yes → left = -1 ; right = 0 // 右側開始索引\n        No  → Decision: x 大於等於 arr[n-1]? // x 在最右邊\n            Yes → left = n-1 ; right = n // 左側開始索引\n            No → BinarySearch for position\n                → Step 3: left = 0 ; right = n-1 ; while left <= right: mid = (left+right)//2 ; if arr[mid] == x: leftIdx=mid ; break ; elif arr[mid] < x: left=mid+1 ; else: right=mid-1 ; leftIdx=right // 最接近小於等於 x 的索引\n→ Step 4: left = leftIdx ; right = leftIdx + 1 // 初始化左右指針\n→ Step 5: result = empty list // 存放最近的 k 個數\n→ Decision: 迭代次數 count < k? // 需要再挑選\n    While count < k:\n        → Decision: left >= 0 且 right < n? // 都在範圍內\n            Yes → Decision: |arr[left]-x| <= |arr[right]-x|? // 左右距離比較\n                Yes → result.append(arr[left]) ; left -= 1\n                No  → result.append(arr[right]) ; right += 1\n            No → Decision: left >= 0? // 只剩左側\n                Yes → result.append(arr[left]) ; left -= 1\n                No  → result.append(arr[right]) ; right += 1\n        → count += 1\n→ Step 6: result.sort() // 排序升序\n→ End\n\nNeed to output each line with arrow. Use \"Decision:\" for condition checks. Use \"Yes →\" \"No →\". The algorithm includes loops and condition checks. Provide each line with explanation.\n\nLet's ensure each line is properly spaced. Use \"→\" before step name. Each line after \"→\" is the virtual code, then a space then \"// explanation\".\n\nWe should avoid actual code, just pseudo steps. Provide \"Start\", \"End\".\n\nWe can also embed loops: \"→ Decision: count < k?\" with inner logic. But maybe simpler: \"→ While count < k:\" is acceptable as step? The format says use arrows and Decision, not necessarily While. But we can use \"Decision:\" for while. Example: \"Decision: count < k?\".\n\nInside we need to indent decisions? We can show nested decisions. Use proper indentation? The sample shows indentation by spaces. We'll replicate.\n\nLet's produce final output.\n\nAlso ensure we include \"Step 1\" etc. Provide consistent numbering. Use \"Step 1:\", \"Step 2:\", etc. Also \"Step 3:\" inside binary search. For loops we might use \"While\" step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 n = arr.length // 取得陣列長度\n→ Step 2: BinarySearch: 找到左側索引 leftIdx 使 arr[leftIdx] ≤ x 且 arr[leftIdx+1] > x\n    Decision: x 小於 arr[0]? // x 在最左邊\n        Yes → leftIdx = -1 ; rightIdx = 0 // 右側指標開始於 0\n        No  → Decision: x 大於等於 arr[n-1]? // x 在最右邊\n            Yes → leftIdx = n-1 ; rightIdx = n // 左側指標開始於 n-1\n            No → Step 3: left = 0 ; right = n-1 ; // 初始化二分搜尋\n                While left ≤ right: // 進行二分搜尋\n                    → Step 4: mid = (left + right) // 2\n                    → Decision: arr[mid] == x? // 找到精確值\n                        Yes → leftIdx = mid ; Break\n                        No → Decision: arr[mid] < x? // arr[mid] 小於 x\n                            Yes → left = mid + 1 ; leftIdx = mid\n                            No  → right = mid - 1 ; leftIdx = right\n→ Step 5: left = leftIdx ; right = leftIdx + 1 // 初始化左右指標\n→ Step 6: result = empty list // 用來存放最近的 k 個數\n→ Step 7: count = 0 // 已選取的數量\n→ Decision: count < k? // 需要再挑選\n    While count < k:\n        → Decision: left >= 0 且 right < n? // 兩邊都在範圍內\n            Yes → Decision: |arr[left]-x| ≤ |arr[right]-x|? // 左右距離比較\n                Yes → result.append(arr[left]) ; left -= 1\n                No  → result.append(arr[right]) ; right += 1\n            No → Decision: left >= 0? // 只剩左側\n                Yes → result.append(arr[left]) ; left -= 1\n                No  → result.append(arr[right]) ; right += 1\n        → count += 1\n→ Step 8: result.sort() // 將選出的 k 個數按升序排列\nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8yt05m1r.py\", line 42, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8yt05m1r.py\", line 19, in __init__\n    self.lookup[key] = weight  # 只保留最大索引\n    ~~~~~~~~~~~^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass WordFilter:\n    def __init__(self, words):\n        \"\"\"\n        建構子，將所有單字依前綴與後綴組合做哈希存儲。\n        key 為 (prefix, suffix)，value 為最大索引。\n        \"\"\"\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):          # 前綴長度\n                pref = word[:i]\n                for j in range(L + 1):      # 後綴起始位置\n                    suff = word[j:]\n                    key = (pref, suff)\n                    self.lookup[key] = weight  # 只保留最大索引\n\n    def f(self, prefix, suffix):\n        \"\"\"\n        查詢具有給定前綴和後綴的單字最大索引。\n        若不存在則回傳 -1。\n        \"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\nif __name__ == \"__main__\":\n    \"\"\"\n    主程式讀取 stdin，預期輸入格式為兩個 JSON 風格的資料片段\n    以逗號分隔，例如：\n        [[\"apple\"]], [\"a\", \"e\"]\n    先將整個輸入包裝成外層列表，利用 ast.literal_eval 解析。\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n    # 轉成外層列表後解析\n    data = ast.literal_eval('[' + raw + ']')\n    words, query = data[0], data[1]\n    pref, suff = query[0], query[1]\n    wf = WordFilter(words)\n    print(wf.f(pref, suff))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to design a data structure for word filter. We must generate line-by-line pseudocode with explanation. Use Start, Decision, etc. Should not produce actual code.\n\nWe need to outline algorithm: use trie for prefixes and suffixes, combine with indices. Or use hash map of (prefix, suffix) to max index. But efficient: Build trie for prefixes storing indices, suffix reversed trie for suffix. For query, traverse prefix trie to node, suffix reversed trie to node, then need intersection of indices: we can store in each node a list of indices sorted descending. Intersection by two pointers. Simpler: precompute mapping from combined prefix+suffix string to max index using hashing: for each word, for all prefixes and suffixes store max index. Complexity O(n*len^2). Might be okay for constraints? We'll produce generic approach using trie.\n\nWe'll write steps: Start, Build prefix trie, Build suffix trie, Query method: traverse prefix node, traverse suffix node, get index lists, find max common.\n\nOk produce lines with virtual code.\n\nLet's craft pseudocode:\n\nStart\n→ Step: Initialize WordFilter with words array // constructor\n\n→ Step: For each word with index i\n    → Step: Insert word into PrefixTrie, at each node store list of indices (sorted descending)\n    → Step: Insert reversed word into SuffixTrie, at each node store list of indices\n\n→ End of construction\n\n→ Step: Define f(pref, suff)\n    → Decision: if pref not in PrefixTrie nodes? // if no node\n        → Step: Return -1\n    → Step: Traverse pref to nodeP\n    → Decision: if suff not in SuffixTrie nodes? // reversed suff\n        → Step: Return -1\n    → Step: Traverse reversed suff to nodeS\n    → Step: Get listA = nodeP.indices\n    → Step: Get listB = nodeS.indices\n    → Step: Initialize i=0, j=0, best=-1\n    → Decision: while i < len(listA) and j < len(listB)\n        → Decision: if listA[i] == listB[j]\n            → Step: best = listA[i] // since descending, first match is max\n            → Step: break\n        → Decision: if listA[i] > listB[j]\n            → Step: i +=1\n        → Decision: else\n            → Step: j +=1\n    → Step: Return best\n\nEnd\n\nAdd comments. Use arrow.\n\nMake sure each line ends with `// explanation`. Use spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step: WordFilter(words) // 建構子，接收單字陣列\n\n→ Decision: 逐一處理每個單字\n    → Step: 將單字插入前綴 Trie，並於每個節點保存索引清單 // 前綴Trie存儲可用索引\n    → Step: 將單字反轉後插入後綴 Trie，並於每個節點保存索引清單 // 後綴Trie同樣存索引\n\n→ End // 建構完成\n\n→ Step: f(pref, suff) // 查詢方法，輸入前綴pref與後綴suff\n\n→ Decision: 是否存在前綴節點\n    → Yes → Step: 走到前綴Trie中對應pref的節點nodeP\n    → No  → Step: 返回 -1 // 沒有此前綴的單字\n\n→ Decision: 是否存在後綴節點\n    → Yes → Step: 走到後綴Trie中對應reverse(suff)的節點nodeS\n    → No  → Step: 返回 -1 // 沒有此後綴的單字\n\n→ Step: listA ← nodeP.indices // 前綴節點保存的索引清單（降序）\n→ Step: listB ← nodeS.indices // 後綴節點保存的索引清單（降序）\n\n→ Step: i ← 0 // 前綴索引指標\n→ Step: j ← 0 // 後綴索引指標\n→ Step: best ← -1 // 最終答案\n\n→ Decision: 當 i < len(listA) 且 j < len(listB) 時\n    → Decision: 若 listA[i] == listB[j]\n        → Step: best ← listA[i] // 由於清單降序，首次相等即最大\n        → Step: 跳出迴圈\n    → Decision: 若 listA[i] > listB[j]\n        → Step: i ← i + 1 // 前綴索引更大，向後移動\n    → Decision: 否則\n        → Step: j ← j + 1 // 後綴索引更大，向後移動\n\n→ Step: 返回 best // 若未找到則仍為 -1\n\nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar III",
      "source_file": "Leetcode/leetcode732.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv1uaatnt.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpv1uaatnt.py\", line 36, in main\n    ops = json.loads(lines[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 68 (char 67)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCalendarThree:\n    \"\"\"\n    記錄所有事件的起止時間，使用差分映射來快速計算重疊數。\n    \"\"\"\n    def __init__(self):\n        # 每個時間點的變化量，+1 表示開始，-1 表示結束\n        self.points = {}\n\n    def book(self, start: int, end: int) -> int:\n        # 在開始時間增加一次\n        self.points[start] = self.points.get(start, 0) + 1\n        # 在結束時間減少一次\n        self.points[end] = self.points.get(end, 0) - 1\n\n        # 將所有時間點按時間升序排列\n        times = sorted(self.points.keys())\n        cur = 0          # 當前重疊數\n        max_booking = 0  # 最大重疊數\n        # 遍歷所有時間點，累加變化量，更新最大值\n        for t in times:\n            cur += self.points[t]\n            if cur > max_booking:\n                max_booking = cur\n        return max_booking\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入分成兩行：操作名稱列表和參數列表\n    lines = data.splitlines()\n    ops = json.loads(lines[0])\n    args = json.loads(lines[1])\n\n    res = []\n    calendar = None\n    # 逐一執行操作\n    for op, a in zip(ops, args):\n        if op == \"MyCalendarThree\":\n            calendar = MyCalendarThree()\n            res.append(None)          # constructor 的結果為 null\n        elif op == \"book\":\n            # a 可能是一個列表，例如 [10, 20]\n            result = calendar.book(*a)\n            res.append(result)\n        else:\n            # 若有其他操作，直接忽略\n            res.append(None)\n\n    # 輸出結果，將 None 轉換成 JSON 中的 null\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines for implementing MyCalendarThree. Use structure with Start, Decision, End. Each line with virtual code + // explanation. It's like pseudo-code but not actual code. Should cover initialization, book method with interval tree or sweep line. Use incremental approach: maintain a map of time points with delta counts. For each booking, update map and track max. Steps: add start with +1, end with -1, sort keys, accumulate, track max. Provide algorithm steps. Provide explanation per line. Need to output sequentially. We'll produce virtual code for class definition, constructor, book method, and logic. Provide steps. Let's write. Use virtual code lines like:\n\nStart\n→ Class MyCalendarThree // 定義 MyCalendarThree 類別\n→ Constructor MyCalendarThree() // 初始化\n    → Step 1: 建立空的時間點差分映射 points // 用於記錄每個時間點的變化\n→ Method int book(start, end) // 新增一個事件\n    → Step 2: points[start] += 1 // 在開始時間增加一次\n    → Step 3: points[end] -= 1 // 在結束時間減少一次\n    → Step 4: sortedTimes = keys(points) sorted ascending // 將時間點排序\n    → Step 5: cur = 0, maxBooking = 0 // 初始化計數\n    → Decision: 是否遍歷 sortedTimes? // 進行掃描\n        Yes → Loop over t in sortedTimes:\n            → Step 6: cur += points[t] // 更新當前重疊數\n            → Step 7: if cur > maxBooking: maxBooking = cur // 更新最大值\n        No → ...\n    → Step 8: return maxBooking // 回傳目前最大重疊\nEnd\n\nNeed to maintain state across bookings: we cannot recompute entire after each book because O(N^2). But virtual code can show incremental scanning each time? For simplicity, use sweep each book. Provide steps accordingly. Also maintain map. Provide explanation. Let's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Class MyCalendarThree // 定義 MyCalendarThree 類別\n    → Constructor MyCalendarThree() // 初始化\n        → Step 1: 建立空的時間點差分映射 points // 用於記錄每個時間點的變化量\n→ Method int book(start, end) // 新增一個事件\n    → Step 2: points[start] += 1 // 在開始時間增加一次計數\n    → Step 3: points[end] -= 1 // 在結束時間減少一次計數\n    → Step 4: sortedTimes = keys(points) sorted ascending // 將所有時間點按時間升序排列\n    → Step 5: cur = 0, maxBooking = 0 // 初始化當前重疊數與最大重疊數\n    → Decision: 是否遍歷 sortedTimes? // 進行掃描\n        Yes → Loop over t in sortedTimes:\n            → Step 6: cur += points[t] // 更新目前重疊數\n            → Step 7: if cur > maxBooking then maxBooking = cur // 若更大則更新最大值\n        No  → // 若沒有時間點則直接返回 0（此情況不會發生）\n    → Step 8: return maxBooking // 回傳目前最大 k‑booking 數\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets_with_dup(nums):\n    \"\"\"Return all unique subsets of nums, handling duplicates.\"\"\"\n    nums.sort()\n    res = [[]]\n    for num in nums:\n        new_subsets = []\n        for subset in res:\n            new_subsets.append(subset + [num])\n        res += new_subsets\n    # Remove duplicate subsets\n    unique_res = []\n    seen = set()\n    for subset in res:\n        t = tuple(subset)\n        if t not in seen:\n            seen.add(t)\n            unique_res.append(subset)\n    return unique_res\n\ndef parse_input(data):\n    \"\"\"Parse the input string to extract the list of integers.\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # Find the first '[' and the last ']' to isolate the list\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        # If no brackets, try to evaluate the whole string\n        return ast.literal_eval(data)\n    list_str = data[start:end+1]\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = subsets_with_dup(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code description of algorithm to generate all subsets without duplicates from integer array possibly containing duplicates. Classic approach: sort array, backtrack skipping duplicates. We'll produce steps: Start, sort array, define result, define backtrack function, iterate, add subset, recursion, etc.\n\nWe must produce each line as: \"虛擬碼步驟 // 解釋\". Use arrow characters. For backtracking function we may express as steps within indentation. Use \"→\" for step lines, \"Decision:\" for conditional. We should ensure no actual code; just pseudocode.\n\nWe need to follow format exactly: each line includes the pseudocode then a space then \"// explanation\".\n\nLet's produce.\n\nWe start: Start // 程式開始執行\n\n→ Step 1: Sort nums // 先將輸入陣列升序，方便後續去重\n\n→ Step 2: Initialize result as empty list // 用來儲存所有子集\n\n→ Step 3: Define function Backtrack(start, currentSubset) // 递归回溯，start 为下一次迭代起点\n\n→ Decision: 若 start == length(nums) // 如果已處理完所有元素\n\n    Yes → Step 4: Append copy of currentSubset to result // 將當前子集加入結果\n\n    No  → Decision: 迭代 i from start to length(nums)-1\n\n        Yes → Step 5: If i > start AND nums[i] == nums[i-1] → Skip // 跳過重複元素以避免重複子集\n\n        No  → Step 6: Append nums[i] to currentSubset // 選取當前元素\n\n        No  → Step 7: Call Backtrack(i+1, currentSubset) // 進一步遞歸\n\n        No  → Step 8: Remove last element from currentSubset // 回溯，撤回選取\n\n→ Step 9: Call Backtrack(0, empty list) // 開始回溯\n\n→ Step 10: Return result // 輸出所有子集\n\nEnd // 程式執行結束\n\nBut we need to use arrows and Decision formatting exactly. The example shows indentations maybe optional. They use \"Decision:\" with indent.\n\nWe need to ensure each line uses the correct syntax: Use \"Decision:\" for condition, and then \"Yes →\" and \"No →\" indented lines. The pseudocode lines inside decisions: maybe \"→ Step 5: ...\" etc. Provide each line with comment.\n\nLet's produce lines accordingly.\n\nBut ensure each line ends with comment after space. The example uses \"Start // 程式開始執行\". For arrow lines, they use \"→ Step 1: ...\" etc. For Decision: \"→ Decision: 如果數字大於 0?\" and then indented lines. We'll mimic.\n\nWe must produce exactly lines; we can't use extra indentation spaces? The example shows indenting by 4 spaces before Yes and No lines.\n\nWe can replicate similar style: use 4 spaces before Yes/No lines.\n\nOk produce. Ensure no code; only pseudocode. Provide explanation.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort(nums) // 將輸入陣列升序排列，方便後續去除重複子集\n→ Step 2: Initialize result as empty list // 用於存放所有子集\n→ Step 3: Define function Backtrack(start, currentSubset) // 以遞迴方式構造子集\n→ Decision: 若 start == length(nums) // 判斷是否已處理完所有元素\n    Yes → Step 4: Append copy of currentSubset to result // 把目前子集加入結果\n    No  → Decision: 迭代 i from start to length(nums)-1 // 從剩餘元素中挑選\n        Yes → Step 5: If i > start AND nums[i] == nums[i-1] → Skip // 跳過重複元素，避免重複子集\n        No  → Step 6: Append nums[i] to currentSubset // 選擇當前元素\n        No  → Step 7: Call Backtrack(i+1, currentSubset) // 進一步遞迴\n        No  → Step 8: Remove last element from currentSubset // 回溯，撤銷選擇\n→ Step 9: Call Backtrack(0, empty list) // 從起始位置開始回溯\n→ Step 10: Return result // 返回所有唯一子集\nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n        return ''.join(res[::-1])\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        return\n    num1, num2 = nums[0], nums[1]\n    solution = Solution()\n    print(solution.addStrings(num1, num2))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for adding two numbers represented as strings, no big int, no integer conversion. It's classic addition algorithm: iterate from end of strings, sum digits with carry, build result reversed. Then reverse result. Should output steps.\n\nWe need to output each line with arrow, explanation. Use virtual code syntax: Start, Step X, Decision, etc. Use arrows →. Format each line: \"虛擬碼步驟 // 解釋\". Example uses \"→ Step 1: ...\". Let's produce.\n\nWe'll produce:\n\nStart // 開始\n→ Step 1: 設定 i ← length(num1)-1, j ← length(num2)-1, carry ← 0, result ← 空字串 // 初始化指標、進位與結果\n→ Step 2: 建立空字串 resBuilder 用於儲存相加後的每一位，先往後面追加\n→ Decision: 若 i >= 0 或 j >= 0 或 carry > 0? // 循環條件\n    Yes → Step 3: 取 digit1 ← (i>=0 ? num1[i]-'0' : 0) // 取得 num1 的當前位，若已經到頭則取 0\n    → Step 4: 取 digit2 ← (j>=0 ? num2[j]-'0' : 0) // 取得 num2 的當前位\n    → Step 5: sum ← digit1 + digit2 + carry // 計算總和\n    → Step 6: carry ← sum / 10 // 新的進位\n    → Step 7: resBuilder.append(sum % 10) // 把餘數追加到結果\n    → Step 8: i ← i - 1 // 移動 num1 指標\n    → Step 9: j ← j - 1 // 移動 num2 指標\n    → Decision: 循環回到 Decision? // 這行其實無需再次顯示，but we can show loop\n    No → Step 10: 把 resBuilder 反轉得到 finalResult // 反轉得到正確順序\n    → Step 11: return finalResult // 回傳結果\nEnd // 程式結束\n\nBut we need to ensure each line arrow. For loops, we might express as Decision and Yes branch includes loop. But we can't use code loops. We can use Decision with Yes pointing back? We can express using \"→ Decision: ...\" and then Yes → Step 3 ... but to represent loop, we might use \"→ Decision: ...\" then inside we end with \"→ Decision: 循環?\" etc. Maybe easier: Use a while loop representation: Decision: i>=0 OR j>=0 OR carry>0? Yes → ...; No → ...; then inside yes we eventually go back to Decision. But we can't literally go back; we can indicate that after Step 9 we go back to Decision. Use arrow \"→ Decision:\" again.\n\nLet's produce like:\n\nStart // 程式開始執行\n→ Step 1: i ← len(num1)-1, j ← len(num2)-1, carry ← 0, res ← \"\" // 初始化指標、進位與結果\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位要相加\n    Yes → Step 2: d1 ← (i >= 0 ? num1[i] - '0' : 0) // 取得 num1 的當前位數\n    → Step 3: d2 ← (j >= 0 ? num2[j] - '0' : 0) // 取得 num2 的當前位數\n    → Step 4: sum ← d1 + d2 + carry // 計算兩位相加與進位\n    → Step 5: carry ← sum / 10 // 更新進位\n    → Step 6: res ← res + (sum % 10) // 將當前位數字追加至 res（此處以字符串形式追加）\n    → Step 7: i ← i - 1 // 移動 num1 指標\n    → Step 8: j ← j - 1 // 移動 num2 指標\n    → Decision: i >= 0 OR j >= 0 OR carry > 0? // 循環回到判斷條件\n        Yes → … // 迴圈繼續\n        No  → Step 9: result ← reverse(res) // 把結果字串反轉得到正確順序\n            → Step 10: return result // 回傳加總結果\nEnd // 程式結束\n\nWe need to show \"…\". But we should not use ellipsis? Maybe we can show that Yes branch goes back to Decision. But to maintain clear, we can show \"Yes → Step 2\" again? That would cause recursion. Instead we can just show that we go back to Decision step. Could use \"Yes → Decision:\" again. But that might be confusing. But it's acceptable.\n\nLet's produce final lines.\n\nMake sure each line ends with comment. Use Chinese explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← len(num1)-1, j ← len(num2)-1, carry ← 0, res ← \"\" // 初始化指標、進位與結果字串  \n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還有位需要相加  \n Yes → Step 2: d1 ← (i >= 0 ? num1[i] - '0' : 0) // 取得 num1 的當前位數，若已經到頭則取 0  \n  → Step 3: d2 ← (j >= 0 ? num2[j] - '0' : 0) // 取得 num2 的當前位數，若已經到頭則取 0  \n  → Step 4: sum ← d1 + d2 + carry // 計算兩位相加與進位  \n  → Step 5: carry ← sum / 10 // 更新進位值  \n  → Step 6: res ← res + (sum % 10) // 把當前位數字追加至結果字串（此處以字符串形式追加）  \n  → Step 7: i ← i - 1 // 移動 num1 指標  \n  → Step 8: j ← j - 1 // 移動 num2 指標  \n  → Decision: i >= 0 OR j >= 0 OR carry > 0? // 循環回到判斷條件  \n   Yes → … // 迴圈繼續，返回上一步的判斷  \n   No → Step 9: result ← reverse(res) // 把結果字串反轉得到正確順序  \n    → Step 10: return result // 回傳加總結果  \n No  → // 這裡不會發生，因為條件為 False 時會走到 No 分支，直接結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport json\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"\n    先把每個值對應到所有索引的位置，然後在 pick 時\n    直接隨機挑一個索引回傳。\n    \"\"\"\n    def __init__(self, nums):\n        # 建立 value -> 索引列表 的映射\n        self.index_map = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.index_map[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑一個符合 target 的索引\n        return random.choice(self.index_map[target])\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 由於輸入是兩個列表用逗號分隔，將它包成一個 tuple 以便 literal_eval\n    # 例如: [\"Solution\",\"pick\"], [[ [1,2,3] ], [2]] 變成 (\"...\", \"...\") 的形式\n    try:\n        commands, arguments = ast.literal_eval(f\"({data})\")\n    except Exception as e:\n        # 若解析失敗直接輸出空結果\n        print(\"[]\")\n        return\n\n    result = []\n    obj = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            # arg 是一個包含數組的列表，例如 [[1,2,3]]\n            obj = Solution(arg[0])\n            result.append(None)          # constructor 回傳 null\n        elif cmd == \"pick\":\n            # arg 是目標值，例如 [3]\n            res = obj.pick(arg[0])\n            result.append(res)\n\n    # 用 json.dumps 讓 None 變成 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for this problem. Provide steps like initialization, building map from value to list of indices. Then pick method: generate random number between 0 and len-1 then return that index. Use start/end and decisions. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 indexMap // 用來儲存每個數值對應的索引清單  \n→ Decision: 是否已經收到 nums 陣列? // 檢查是否有輸入陣列  \n    Yes → Step 2: 對 nums 進行一次遍歷  \n        → For i = 0 到 nums.length-1:  \n            → Decision: nums[i] 是否已在 indexMap? // 檢查該數值是否已出現  \n                Yes → Step 3: 將 i 加入 indexMap[nums[i]] 的清單 // 追加新索引  \n                No  → Step 4: 建立 indexMap[nums[i]] 為新清單，並加入 i // 新數值第一次遇到  \n→ Step 5: 完成初始化，索引清單已建立完畢  \nEnd // 初始化結束  \n\nStart // pick(target) 呼叫  \n→ Step 6: 取得 indices = indexMap[target] // 取出所有對應索引清單  \n→ Step 7: 產生隨機整數 r 在範圍 [0, indices.length-1] // 隨機選取一個位置  \n→ Step 8: 回傳 indices[r] // 將對應索引回傳  \nEnd // pick(target) 結束"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nGot (Norm):      '[1,10,11,12,13]'\n--- (Raw) ---\nRaw Expected: '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nRaw Got:      '[1, 10, 11, 12, 13]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    \"\"\"\n    Return all numbers from 1 to n sorted in lexicographical order.\n    Uses O(n) time and O(1) extra space (aside from the result list).\n    \"\"\"\n    result = []\n    cur = 1\n    while cur <= n:\n        result.append(cur)\n        # Try to go deeper in the lexicographical tree\n        if cur * 10 <= n:\n            cur *= 10\n        else:\n            # If current number is not ending with 9 and we can increment\n            if cur % 10 != 9 and cur + 1 <= n:\n                cur += 1\n            else:\n                # Move up until we can increment\n                while cur % 10 == 9:\n                    cur //= 10\n                cur += 1\n    return result\n\ndef main():\n    data = sys.stdin.read()\n    # Extract the first integer from the input (handles formats like \"n = 13\" or just \"13\")\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group(0))\n    result = lexical_order(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code for algorithm to return all numbers in [1,n] sorted lexicographically. O(n) time, O(1) extra space. We can use a \"lexicographic DFS\" that prints numbers from 1 to n in lex order by iteratively generating next number. Approach: start from 1, while cur <= n: output cur, if cur *10 <= n: cur*=10; else if cur%10 !=9 and cur+1 <= n: cur+=1; else: while (cur/10)%10==9: cur/=10; cur/=10; cur+=1. This runs O(n). O(1) space.\n\nWe produce pseudocode line by line. Use virtual code arrows. We'll produce steps: Start, Set cur=1, Decision: cur<=n? Yes-> output cur; Next: Decision: cur*10 <= n? Yes-> cur*=10; else: Decision: cur%10 !=9 and cur+1 <= n? Yes-> cur+=1; else: Decision: cur%10==9? No?? Actually we need to climb up. Use while loop to handle incrementing after trailing 9's. So algorithm steps.\n\nWe need each line with explanation comment. Use arrow indent.\n\nLet's produce.\n\nUse \"Start\" line.\n\nThen \"→ Step 1: Set cur = 1 // 初始數字\" etc.\n\nWe need decision for cur <= n? If no, End.\n\nWithin yes, we need output cur.\n\nThen after output, we need to compute next cur.\n\nDecision: if cur *10 <= n? Yes -> cur = cur *10 else:\n\nDecision: if cur %10 !=9 and cur +1 <= n? Yes -> cur = cur +1 else:\n\nLoop: While cur%10 ==9: cur = cur/10; then cur = cur +1. But we also need to check if cur>n after loop? In typical algorithm, after adjusting, we check again loop. But we can integrate into decision: else -> while cur%10 ==9: cur = cur /10; cur +=1; after that continue.\n\nBut we need to produce virtual code line by line.\n\nWe need to use decision constructs.\n\nLet's structure as:\n\nStart\n→ Step 1: cur = 1\n→ Decision: cur <= n? \n    Yes → Step 2: Output cur\n          Decision: cur *10 <= n?\n              Yes → Step 3: cur = cur *10\n              No  → Decision: cur %10 !=9 AND cur +1 <= n?\n                    Yes → Step 4: cur = cur +1\n                    No  → Step 5: While cur %10 ==9: cur = cur /10\n                             Step 6: cur = cur +1\n    No → End\n\nAfter each step, we need to loop back to decision. But we cannot express loop easily; we can have \"→ Decision: cur <= n?\" again after step 6. But we need to use arrow back. Use \"→\" for loops maybe: After step 6, go back to Decision: cur <= n? . But using \"→\" at each line, we can just write again: \"→ Decision: cur <= n?\".\n\nAlternatively use \"→\" at start of loop: after step 6, \"→ Decision: cur <= n?\" again. So we can produce.\n\nBut we need each line with explanation.\n\nMake sure arrow lines represent control flow. Use \"→ Decision:\" lines.\n\nWe also need to handle O(1) space: no recursion. So algorithm uses iterative.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: cur = 1 // 設定初始數字為 1  \n→ Decision: cur <= n? // 檢查目前數字是否還在範圍內  \n    Yes → Step 2: Output cur // 輸出目前數字  \n          Decision: cur * 10 <= n? // 若將數字乘 10 後仍不超過 n，則進一步向下遞進  \n              Yes → Step 3: cur = cur * 10 // 進入下一個十位數  \n              No  → Decision: (cur % 10 != 9) AND (cur + 1 <= n)? // 若尾數不是 9 且加 1 仍在範圍，直接遞增  \n                    Yes → Step 4: cur = cur + 1 // 直接遞增至下一個字典序數字  \n                    No  → Step 5: While cur % 10 == 9: cur = cur / 10 // 把尾數為 9 的部分往上一層去  \n                         Step 6: cur = cur + 1 // 再遞增一次以得到下一個合法數字  \n    No → End // 若 cur 超過 n，結束程式  \n\n// 從 Step 6 之後再回到 Decision: cur <= n?，形成整個迴圈，直至所有數字被輸出。"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef findLUSlength(strs):\n    \"\"\"\n    找到陣列中「唯一」字串的最大長度。若不存在唯一字串則回傳 -1。\n    \"\"\"\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n\n    max_len = -1\n    for s in strs:\n        if freq[s] == 1 and len(s) > max_len:\n            max_len = len(s)\n    return max_len\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個資料，並轉換為 Python 列表\n    data = sys.stdin.read().strip()\n    if not data:\n        strs = []\n    else:\n        strs = ast.literal_eval(data)   # 解析形如 '[\"aba\",\"cdc\",\"eae\"]' 的字串\n\n    result = findLUSlength(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. The problem: longest uncommon subsequence length between strings. Known solution: If there's a string that is unique (no other string equal to it), then answer is length of longest unique string; otherwise -1. Because the longest uncommon subsequence can be the whole string itself if it's unique, else impossible.\n\nSo algorithm: Count occurrences of each string. For each string, if its count is 1, record its length; keep maximum. If maximum remains -1, output -1. else output maximum length.\n\nWe need virtual code, each line with explanation, using arrows, decisions etc. We'll structure: Start → Step 1: input array strs // ... etc. Then compute map counts. Then decision: if any unique string exists? etc.\n\nWe produce step-by-step.\n\nLet's outline:\n\nStart\n→ Step 1: Read array strs\n→ Step 2: Create dictionary countMap // count occurrences\n→ Step 3: For each string s in strs: increment countMap[s]\n→ Decision: 是否有至少一個唯一字符串? // If there is at least one string with count 1\n    Yes → Step 4: 計算最大長度 of strings with count 1\n        → Step 5: maxLen = -1\n        → For each string s in strs:\n            → Decision: countMap[s] == 1?\n                Yes → Step 6: Update maxLen = max(maxLen, length(s))\n        → Step 7: Output maxLen\n    No  → Step 8: Output -1\nEnd\n\nBut we need each line with \"→\". We also need indentation for decisions. The format sample uses indentation: decision lines show \"Decision:\" then indent Yes→, No→. Let's follow.\n\nWe need to produce all lines with explanation.\n\nAlso might include Step 2 to 3: counting.\n\nAlso maybe we can use \"for each\" arrow.\n\nLet's craft lines.\n\nImportant: Each line must include \"虛擬碼步驟\" + space + comment.\n\nWe'll use Chinese comments.\n\nLet's produce.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 strs // 從使用者或環境取得字串陣列\n→ Step 2: 建立字典 countMap // 用來統計每個字串出現次數\n→ Step 3: 逐個字串 s 於 strs 中:\n    → Count = countMap.get(s, 0) + 1 // 取得目前次數並加 1\n    → countMap[s] = Count // 更新字典\n→ Decision: 是否存在至少一個唯一字串 (countMap[s] == 1) ?\n    Yes → Step 4: 初始化 maxLen = -1 // 用來儲存最大的唯一字串長度\n    → Step 5: 逐個字串 s 於 strs 中:\n        → Decision: countMap[s] == 1 ?\n            Yes → Step 6: maxLen = max(maxLen, length(s)) // 更新最大長度\n            No  → Step 7: 跳過 // 不是唯一字串不做處理\n    → Step 8: 輸出 maxLen // 回傳最大長度\n    No  → Step 9: 輸出 -1 // 沒有唯一字串，無法形成不常見子序列\nEnd // 程式執行結束\n\nBut we need each line with explanation after comment. Also indent decisions properly.\n\nThe sample uses indentation like:\n\nDecision: ...\n    Yes → ...\n    No  → ...\n\nWe'll produce same.\n\nAlso each line is \"虛擬碼步驟\" which includes arrow or text. Provide comment after space.\n\nLet's write each line.\n\nLine1: Start // 程式開始執行\n\nLine2: → Step 1: 取得輸入陣列 strs // 從使用者或環境取得字串陣列\n\nLine3: → Step 2: 建立字典 countMap // 用來統計每個字串出現次數\n\nLine4: → Step 3: 逐個字串 s 於 strs 中: // 進入迴圈對每個字串進行計數\n\nLine5:     → Count = countMap.get(s, 0) + 1 // 取得目前次數並加 1\n\nLine6:     → countMap[s] = Count // 更新字典\n\nLine7: → Decision: 是否存在至少一個唯一字串 (countMap[s] == 1)? // 檢查是否有只出現一次的字串\n\nLine8:     Yes → Step 4: 初始化 maxLen = -1 // 用於儲存最大的唯一字串長度\n\nLine9:     → Step 5: 逐個字串 s 於 strs 中: // 重新遍歷陣列尋找唯一字串\n\nLine10:         → Decision: countMap[s] == 1? // 判斷此字串是否唯一\n\nLine11:             Yes → Step 6: maxLen = max(maxLen, length(s)) // 更新最大長度\n\nLine12:             No  → Step 7: 跳過 // 不是唯一字串不處理\n\nLine13:     → Step 8: 輸出 maxLen // 回傳最大的唯一字串長度\n\nLine14:     No  → Step 9: 輸出 -1 // 無唯一字串，無法得到不常見子序列\n\nLine15: End // 程式執行結束\n\nCheck formatting: each line must include \"→\" if it is a step, decisions lines have \"Decision:\" and indent Yes→ etc.\n\nWe should include \"→\" before Step lines. For decision we have \"Decision:\" as shown.\n\nIndentation: The sample uses 4 spaces before Yes→ and No→ lines. We'll do 4 spaces.\n\nAlso ensure each line has comment after space.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 strs // 從使用者或環境取得字串陣列\n→ Step 2: 建立字典 countMap // 用來統計每個字串出現次數\n→ Step 3: 逐個字串 s 於 strs 中: // 進入迴圈對每個字串進行計數\n    → Count = countMap.get(s, 0) + 1 // 取得目前次數並加 1\n    → countMap[s] = Count // 更新字典\n→ Decision: 是否存在至少一個唯一字串 (countMap[s] == 1)? // 檢查是否有只出現一次的字串\n    Yes → Step 4: 初始化 maxLen = -1 // 用於儲存最大的唯一字串長度\n    → Step 5: 逐個字串 s 於 strs 中: // 重新遍歷陣列尋找唯一字串\n        → Decision: countMap[s] == 1? // 判斷此字串是否唯一\n            Yes → Step 6: maxLen = max(maxLen, length(s)) // 更新最大長度\n            No  → Step 7: 跳過 // 不是唯一字串不處理\n    → Step 8: 輸出 maxLen // 回傳最大的唯一字串長度\n    No  → Step 9: 輸出 -1 // 無唯一字串，無法得到不常見子序列\nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      \"['CCCCCAAAAA', 'AAAAACCCCC']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):          # 10‑letter window\n            seq = s[i:i + 10]\n            if seq in seen:\n                repeated.add(seq)           # already seen -> repeated\n            else:\n                seen.add(seq)               # first time seen\n        return list(repeated)\n\ndef main():\n    # Read entire stdin, extract only A/C/G/T characters\n    data = sys.stdin.read()\n    dna = ''.join(re.findall(r'[ACGT]', data.upper()))\n\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(dna)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find all 10-letter-long substrings that occur more than once in a given DNA string. Should output in any order. Need to produce line-by-line virtual code with explanations. Use Start, End, Decision, arrow etc.\n\nWe need to design algorithm: given string s. Approach: use sliding window of length 10, maintain hash map of counts. For each substring s[i:i+10], increment count; after iteration, collect those with count>1. Complexity O(n). Implementation steps:\n\n- Start\n- Step 1: Get input string s\n- Step 2: Initialize dictionary counts empty\n- Step 3: If length s <10 → return empty list // cannot have 10-letter substring\n- Step 4: For i from 0 to len(s)-10 inclusive:\n    - Step 5: sub = s[i:i+10]\n    - Step 6: counts[sub] = counts.get(sub,0)+1\n- Step 7: Initialize result list\n- Step 8: For each sub, count in counts:\n    - Decision: if count >1?\n        Yes → add sub to result\n- End return result\n\nWe need to use arrow \"→\". Also use indentation maybe via spaces.\n\nWe also need to ensure each line ends with // 解釋/說明.\n\nWe must not output actual code, just virtual steps. Use virtual arrow.\n\nWe can denote loops and decisions accordingly.\n\nProbably like:\n\nStart // 程式開始執行\n→ Input s // 取得 DNA 字串\n→ Initialize counts = {} // 建立字典來記錄子字串出現次數\n→ Decision: len(s) < 10? // 檢查字串長度是否足夠\n    Yes → Return [] // 若不足 10，直接返回空清單\n    No → // 繼續\n→ For i = 0 to len(s)-10:\n    → sub = s[i:i+10] // 取得長度為10的子字串\n    → If sub in counts? // 檢查是否已存在\n        Yes → counts[sub] += 1 // 進位\n        No  → counts[sub] = 1 // 初始化\n→ Initialize result = [] // 用於儲存重複子字串\n→ For each sub, cnt in counts:\n    → Decision: cnt > 1? // 檢查是否出現多次\n        Yes → Append sub to result // 加入結果\n        No  → // 不做任何事\n→ Return result // 輸出所有重複的 10 字母子字串\nEnd // 程式結束\n\nBut we need arrow for decision lines.\n\nBetter structure:\n\nStart\n→ Step 1: Input s\n→ Step 2: Initialize counts = {} // dictionary\n→ Decision: If len(s) < 10? // length check\n    Yes → Step 3: Return [] // no possible substrings\n    No  → Step 4: // continue\n→ For i in range(0, len(s)-10+1): // loop\n    → Step 5: sub = s[i:i+10]\n    → Step 6: If sub in counts? \n        Yes → counts[sub] = counts[sub] + 1\n        No  → counts[sub] = 1\n→ Step 7: Initialize result = [] \n→ For sub, cnt in counts.items():\n    → Decision: cnt > 1?\n        Yes → result.append(sub)\n        No  → // nothing\n→ Step 8: Return result\nEnd\n\nBut the requirement: \"虛擬碼步驟\" each line with arrow \"→\" for steps. For decision we need \"Decision:\" and nested Yes / No lines. So structure must follow format.\n\nWe can produce something like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 s // 讀入 DNA 序列\n→ Step 2: 建立空字典 counts // 用來計算子字串出現次數\n→ Decision: 如果 len(s) < 10? // 先檢查字串長度是否足夠\n    Yes → Step 3: 返回空列表 // 若不足 10，直接結束\n    No  → // 繼續以下步驟\n→ For i 從 0 到 len(s)-10: // 滑動窗口遍歷\n    → Step 4: sub = s[i:i+10] // 取得 10 長度子字串\n    → Decision: sub 是否已在 counts? // 檢查是否已計數\n        Yes → counts[sub] = counts[sub] + 1 // 增加計數\n        No  → counts[sub] = 1 // 初始計數\n→ Step 5: 建立空列表 result // 用於儲存重複的子字串\n→ For sub, cnt 在 counts.items(): // 遍歷所有子字串\n    → Decision: cnt > 1? // 檢查是否多次出現\n        Yes → result.append(sub) // 加入結果\n        No  → // 不做任何事\n→ Step 6: 返回 result // 輸出所有重複的 10 字母子字串\nEnd // 程式結束\n\nWe must maintain arrow for each step. Use \"→\". For decision lines use \"Decision:\" then Yes →, No → lines.\n\nWe should include a Step number for clarity? Not necessary but fine.\n\nMake sure no actual code, just virtual.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 讀入 DNA 序列  \n→ Step 2: 建立空字典 counts // 用來計算子字串出現次數  \n→ Decision: 如果 len(s) < 10? // 先檢查字串長度是否足夠  \n Yes → Step 3: 返回空列表 // 若不足 10，直接結束  \n No  → // 繼續以下步驟  \n→ For i 從 0 到 len(s)-10: // 滑動窗口遍歷  \n → Step 4: sub = s[i:i+10] // 取得 10 長度子字串  \n → Decision: sub 是否已在 counts? // 檢查是否已計數  \n  Yes → counts[sub] = counts[sub] + 1 // 增加計數  \n  No  → counts[sub] = 1 // 初始計數  \n→ Step 5: 建立空列表 result // 用於儲存重複的子字串  \n→ For sub, cnt 在 counts.items(): // 遍歷所有子字串  \n → Decision: cnt > 1? // 檢查是否多次出現  \n  Yes → result.append(sub) // 加入結果  \n  No  → // 不做任何事  \n→ Step 6: 返回 result // 輸出所有重複的 10 字母子字串  \nEnd // 程式結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"回溯法產生所有排列，使用原地交換以節省空間\"\"\"\n        res = []\n\n        def backtrack(start):\n            # 若已經到達最後一個位置，說明已經形成一個完整排列\n            if start == len(nums):\n                # 把目前的排列加到結果中，須複製一份\n                res.append(nums[:])\n                return\n            # 從 start 開始嘗試每一個未交換過的位置\n            for i in range(start, len(nums)):\n                # 交換元素，將 nums[i] 放到 start\n                nums[start], nums[i] = nums[i], nums[start]\n                # 進行下一層遞迴\n                backtrack(start + 1)\n                # 回溯：恢復交換前的狀態\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，去掉多餘的空白\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        sys.exit(0)\n\n    # 找到第一個 '['，並提取包含方括號的子字串\n    try:\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        nums_str = data[start:end]\n        nums = ast.literal_eval(nums_str)\n    except (ValueError, SyntaxError):\n        # 若無法解析，則直接輸出空列表\n        print(\"[]\")\n        sys.exit(0)\n\n    # 呼叫解法\n    solution = Solution()\n    result = solution.permute(nums)\n\n    # 用 json.dumps 產生無空格的列表字串，符合範例輸出格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo steps) line by line, with comment explaining each line. Use Start, End, Decision:, arrows. Use no actual code. Must be in Traditional Chinese. Provide algorithm to generate permutations using recursion/backtracking.\n\nPseudo steps: start, input array, create result list, define backtrack function with current permutation and used flags. In recursion: if length equals n, add copy to result. Else iterate over elements, if not used, mark used, add to current, backtrack, unmark, pop. After defining, call backtrack. Return result. End.\n\nWe need each line with // explanation. Use arrow arrows. Also decision blocks.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 獲取使用者輸入的整數陣列\n→ Step 2: 初始化空列表 result // 用於存放所有排列\n→ Step 3: 初始化空列表 current // 用於構建當前排列\n→ Step 4: 初始化布林列表 used 之長度為 nums.length，全部設為 false // 標記元素是否已被加入 current\n→ Decision: 如果 nums 為空? // 判斷是否需要處理空輸入\n    Yes → Step 5: 輸出 result // 空輸入直接返回空列表\n    No  → Step 6: 定義遞歸函式 backtrack // 建立回溯函式\n        → Step 6a: 如果 current 長度等於 nums 長度? // 判斷是否已完成一個排列\n            Yes → Step 6a1: 將 current 複製加入 result // 完整排列加入結果\n            No  → Step 6a2: 針對每個索引 i 從 0 到 nums.length-1 // 嘗試每個尚未使用的元素\n                → Decision: 如果 used[i] 為真? // 判斷元素是否已被使用\n                    Yes → Step 6a2a: 跳過 // 已使用則不考慮\n                    No  → Step 6a2b: 設置 used[i] 為真 // 標記為已使用\n                        → Step 6a2b1: 將 nums[i] 加入 current // 將元素加入當前排列\n                        → Step 6a2b2: 呼叫 backtrack() // 進行下一層遞歸\n                        → Step 6a2b3: 從 current 移除最後一個元素 // 回溯\n                        → Step 6a2b4: 設置 used[i] 為假 // 取消使用標記\n    → Step 7: 呼叫 backtrack() // 開始回溯\n→ Step 8: 返回 result // 回傳所有排列\nEnd // 程式執行結束\n\nWe need to format with arrows and comments. Use 虛擬碼步驟. Provide comment after space. Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 獲取使用者輸入的整數陣列  \n→ Step 2: 初始化空列表 result // 用於存放所有排列  \n→ Step 3: 初始化空列表 current // 用於構建當前排列  \n→ Step 4: 初始化布林列表 used 之長度為 nums.length，全部設為 false // 標記元素是否已被加入 current  \n→ Decision: 如果 nums 為空? // 判斷是否需要處理空輸入  \n Yes → Step 5: 輸出 result // 空輸入直接返回空列表  \n No → Step 6: 定義遞歸函式 backtrack // 建立回溯函式  \n  → Step 6a: 如果 current 長度等於 nums 長度? // 判斷是否已完成一個排列  \n   Yes → Step 6a1: 將 current 複製加入 result // 完整排列加入結果  \n   No → Step 6a2: 針對每個索引 i 從 0 到 nums.length-1 // 嘗試每個尚未使用的元素  \n    → Decision: 如果 used[i] 為真? // 判斷元素是否已被使用  \n     Yes → Step 6a2a: 跳過 // 已使用則不考慮  \n     No → Step 6a2b: 設置 used[i] 為真 // 標記為已使用  \n      → Step 6a2b1: 將 nums[i] 加入 current // 將元素加入當前排列  \n      → Step 6a2b2: 呼叫 backtrack() // 進行下一層遞歸  \n      → Step 6a2b3: 從 current 移除最後一個元素 // 回溯  \n      → Step 6a2b4: 設置 used[i] 為假 // 取消使用標記  \n → Step 7: 呼叫 backtrack() // 開始回溯  \n→ Step 8: 返回 result // 回傳所有排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Ransom Note",
      "source_file": "Leetcode/leetcode383.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    \"\"\"檢查 ransomNote 是否能由 magazine 的字母構成。\"\"\"\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        # 統計 ransomNote 與 magazine 的字母頻率\n        ransom_count = Counter(ransomNote)\n        magazine_count = Counter(magazine)\n\n        # 逐一檢查 ransomNote 所需字母是否足夠\n        for char, needed in ransom_count.items():\n            if needed > magazine_count.get(char, 0):\n                return False\n        return True\n\ndef main() -> None:\n    \"\"\"\n    主函式：從標準輸入讀取兩行資料\n    第一行為 ransomNote，第二行為 magazine，\n    並輸出結果為 'true' 或 'false'（小寫）。\n    \"\"\"\n    # 讀取並去除換行符\n    ransomNote = sys.stdin.readline().rstrip('\\n')\n    magazine = sys.stdin.readline().rstrip('\\n')\n\n    sol = Solution()\n    result = sol.canConstruct(ransomNote, magazine)\n\n    # 依題目要求輸出小寫字串\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo code step by step with explanation comments. No real code. Use Start, Decision etc. Need to use arrow. We need to check if ransomNote can be constructed from letters in magazine, each letter used once.\n\nPseudo algorithm: count letters in magazine, iterate ransomNote, decrement counts, if any count missing -> false. At end true.\n\nWrite steps: Start, Step1: Count letters in magazine → store freq. Step2: For each char in ransomNote → if freq[char] <=0 -> return false. Else decrement. After loop, return true. End.\n\nUse pseudo steps with arrows.\n\nWe must keep each line with \"虛擬碼步驟\" + space + \"// 解釋\". Use Start, End, Decision. For loop, we might use Decision inside.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空字典 freq 用於統計 magazine 中每個字母的出現次數 // 建立字母頻率表  \n→ Step 2: 對 magazine 中的每個字母 c 做以下操作  \n  → freq[c] ← freq.get(c, 0) + 1 // 依序累加頻率  \n→ Decision: 是否已經完成對 magazine 的遍歷？  \n  Yes → Step 3: 對 ransomNote 中的每個字母 d 做以下操作  \n    → Decision: freq.get(d, 0) 是否為 0？ // 檢查 d 是否還可用  \n     Yes → Return False // d 沒有足夠字母，無法組成 ransomNote  \n     No  → freq[d] ← freq[d] - 1 // 使用一個 d，減少頻率  \n→ Decision: ransomNote 是否已遍歷完？  \n  Yes → Return True // 所有字母都成功使用，能組成 ransomNote  \n  No  → 迴圈繼續  \nEnd // 程式執行結束"
    },
    {
      "title": "Sliding Window Maximum",
      "source_file": "Leetcode/leetcode239.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeffrkecr.py\", line 58, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpeffrkecr.py\", line 51, in parse_input\n    nums = ast.literal_eval(nums_str)   # 轉成真正的 list\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums or k == 0:\n            return []\n\n        deq = deque()\n        res = []\n\n        for i in range(len(nums)):\n            # 移除離開窗口的索引\n            while deq and deq[0] < i - k + 1:\n                deq.popleft()\n            # 移除比目前元素小的索引，保持遞減\n            while deq and nums[deq[-1]] < nums[i]:\n                deq.pop()\n            deq.append(i)\n\n            # 窗口已滿時加入最大值\n            if i >= k - 1:\n                res.append(nums[deq[0]])\n\n        return res\n\ndef parse_input(input_str):\n    \"\"\"\n    從輸入字串中解析出 nums 列表與 k 整數\n    \"\"\"\n    # 先去掉所有空白，方便正則表達式\n    clean = re.sub(r'\\s+', '', input_str)\n\n    # 匹配 nums = [....]\n    nums_match = re.search(r'nums=([^,]+)', clean)\n    k_match = re.search(r'k=([^,\\s]+)', clean)\n\n    if not nums_match or not k_match:\n        raise ValueError(\"Invalid input format\")\n\n    nums_str = nums_match.group(1)\n    k_str = k_match.group(1)\n\n    nums = ast.literal_eval(nums_str)   # 轉成真正的 list\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.maxSlidingWindow(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line, no actual code, just steps with comments. The problem: sliding window maximum. Use deque to maintain max. Steps: Start, initialize deque, result array, iterate i from 0 to n-1: remove indices outside window, add current index, maintain decreasing order, after first k-1, record max. End.\n\nWe need to use arrows and decisions. We must format exactly: each line: \"虛擬碼步驟 // 解釋\". Use \"→\" for next step. Provide decisions with \"Decision:\".\n\nMake sure to use Start and End. We need to include steps of algorithm. No actual code, but pseudo. Use \"Index i\", \"deque\" etc.\n\nLet's produce. Ensure each line has a single step. Use arrow to show flow. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空 Deque 以儲存窗口內元素的索引 // 用於快速取得最大值  \n→ Step 2: 建立空陣列 result 用於存放每個窗口的最大值 // 結果輸出  \n→ Step 3: 迭代 i 從 0 到 nums.length-1 // 逐一處理每個元素  \n    Decision: i >= k-1? // 窗口已滿，開始記錄最大值  \n        Yes → Step 4: 若 deque.front() <= i-k, 移除 deque.front() // 移除已離開窗口的索引  \n        No  → No action // 窗口未滿，跳過移除步驟  \n    Decision: deque 內索引對應的值 <= nums[i]? // 保持 deque 內值遞減  \n        Yes → Step 5: 逐一從 deque 尾部移除索引，直至條件不成立 // 移除較小值  \n        No  → No action // 當前值已大於等於尾部值  \n    Step 6: 將 i 加入 deque 尾部 // 添加新索引  \n    Decision: i >= k-1? // 窗口已滿，可輸出最大值  \n        Yes → Step 7: 把 nums[deque.front()] 加入 result // 最大值即為窗口內最大  \n        No  → No action // 窗口未滿，不記錄  \nEnd // 程式執行結束，返回 result陣列"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # Move the last element to the spot of the removed element\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.data)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入包成一個外層列表，方便直接解析成兩個子列表\n    ops_and_args = ast.literal_eval('[' + data + ']')\n    ops, args = ops_and_args[0], ops_and_args[1]\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)  # constructor returns null\n        elif op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n\n    # 將結果格式化成 LeetCode 風格輸出\n    out = '['\n    for i, val in enumerate(results):\n        if i:\n            out += ', '\n        if val is None:\n            out += 'null'\n        elif isinstance(val, bool):\n            out += 'true' if val else 'false'\n        else:\n            out += str(val)\n    out += ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing RandomizedCollection. We need to list steps. Probably show initialization, insert, remove, getRandom. Use Start/End/Decision. Provide explanation. Use arrow \"→\". Use Yes→, No→ for decisions. Each line is a step.\n\nWe should structure like pseudo code. Provide each step as line with explanation after //.\n\nWe need to show algorithm: Use vector to store values, and unordered_map<int, unordered_set<int>> to map val to set of indices. In insert: add to vector, add index to map set. If val not existed before return true else false. Remove: check if val present in map. If not return false. Else get an index from set, remove it from set, swap last element in vector to that index, update map sets accordingly, pop_back. Return true. getRandom: pick random index from vector and return element.\n\nWe need to present as steps in a flowchart style: Start → Step 1: initialize data structures → etc. Might break into methods: insert, remove, getRandom.\n\nThe user didn't ask to output entire class code, just virtual code steps for implementing functions. So we should produce a flowchart-like pseudo for the whole class. Let's produce a Start for constructor, insert, remove, getRandom.\n\nWe should maintain a counter for current size.\n\nLet's produce lines.\n\nWe must keep each line as \"虛擬碼步驟 // 解釋\". Use arrows accordingly. Might include \"Decision:\" lines. Provide each step.\n\nWe should cover all functions. Provide pseudo algorithm.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Initialize array A as empty list // 用於存放所有元素\n→ Step 2: Initialize map M as empty dictionary of sets // 存放每個值對應的索引集合\n→ Step 3: Initialize size S = 0 // 元素總數\nEnd // 建構完成\n\nThen Insert function:\n\nStart // 插入開始\n→ Step 1: If val not in M, create empty set for val // 方便記錄索引\n→ Step 2: Append val to A // 把新元素放入列表\n→ Step 3: Add index S to M[val] // 索引加入對應集合\n→ Step 4: Increment S // 更新總數\n→ Decision: 是否是第一次插入 val? // 判斷是否已存在\n    Yes → Step 5: Return true // 第一次插入\n    No  → Step 6: Return false // 重複插入\nEnd // 插入結束\n\nRemove function:\n\nStart // 移除開始\n→ Decision: val 是否在 M? // 判斷是否存在\n    No  → Step 1: Return false // 沒有該值\n    Yes → Step 2: 取 M[val] 中任一索引 idx // 取一個要刪除的位置\n→ Step 3: 取 A[last] 和 lastIndex = S-1 // 最後一個元素與其索引\n→ Decision: idx == lastIndex? // 要刪除的位置是最後一個嗎？\n    Yes → Step 4: 刪除 A[idx] // 直接刪除最後元素\n    No  → Step 5: 交換 A[idx] 與 A[last] // 將最後元素移到待刪位置\n        → Step 6: 更新 M[A[idx]]：移除 lastIndex，加入 idx // 更新被移動元素的索引集合\n→ Step 7: 從 M[val] 刪除 idx // 刪除被移除元素的索引\n→ Step 8: 如果 M[val] 變空，刪除 M[val] // 清理空集合\n→ Step 9: A.pop_back() // 刪除最後元素\n→ Step 10: S-- // 更新總數\n→ Step 11: Return true // 成功移除\nEnd // 移除結束\n\nGetRandom function:\n\nStart // 隨機取得\n→ Step 1: 生成隨機整數 r 在 0..S-1 // 隨機索引\n→ Step 2: Return A[r] // 回傳隨機元素\nEnd // getRandom 結束\n\nAlso mention average O(1). But not necessary.\n\nWe need each line separate with // explanation. Use arrow \"→\". For decisions, use \"Decision:\" with indentation? They want \"Decision:\" lines and then Yes →, No →. Let's format accordingly.\n\nWe must ensure each line is separate. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 A 為空列表 // 用於儲存所有元素\n→ Step 2: 初始化 M 為空字典，每個鍵對應索引集合 // 用於追蹤同一值在 A 的位置\n→ Step 3: 初始化 S = 0 // 元素總數\nEnd // 建構完成\n\nStart // insert(val) 開始\n→ Decision: 是否已在 M 中存在 val？ // 判斷是否第一次插入\n    Yes → Step 1: 為 val 創建空集合 M[val] // 方便存儲索引\n    No  → Step 1: 跳過 // 直接使用現有集合\n→ Step 2: 把 val 加入 A，索引為 S // 把新元素放到末尾\n→ Step 3: 把索引 S 加入 M[val] // 記錄該值的位置\n→ Step 4: S++ // 更新總數\n→ Decision: val 是否第一次出現？ // 依此決定回傳值\n    Yes → Step 5: Return true // 第一次插入，返回 true\n    No  → Step 6: Return false // 重複插入，返回 false\nEnd // insert 完成\n\nStart // remove(val) 開始\n→ Decision: val 是否存在於 M？ // 判斷是否要移除\n    No  → Step 1: Return false // 沒有此值，移除失敗\n    Yes → Step 2: 從 M[val] 隨機取一個索引 idx // 要刪除的位置\n→ Step 3: 記錄 lastIdx = S-1, lastVal = A[lastIdx] // 最後一個元素及其索引\n→ Decision: idx == lastIdx? // 要刪除的位置是否是最後一個？\n    Yes → Step 4: 直接刪除 A[idx] // 刪除最後元素\n    No  → Step 5: A[idx] = lastVal // 把最後元素搬到 idx 位置\n        → Step 6: 更新 M[lastVal]：移除 lastIdx，加入 idx // 更新移動元素的索引集合\n→ Step 7: 從 M[val] 移除 idx // 移除被刪除元素的索引\n→ Decision: M[val] 是否變為空？ // 清理空集合\n    Yes → Step 8: 刪除 M[val] // 移除空集合鍵\n    No  → Step 8: 跳過\n→ Step 9: A.pop_back() // 刪除最後元素\n→ Step 10: S-- // 更新總數\n→ Step 11: Return true // 成功移除\nEnd // remove 完成\n\nStart // getRandom() 開始\n→ Step 1: 隨機產生整數 r，範圍 0 ~ S-1 // 隨機索引\n→ Step 2: Return A[r] // 回傳該索引的元素\nEnd // getRandom 完成"
    },
    {
      "title": "Remove K Digits",
      "source_file": "Leetcode/leetcode402.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"1432219\", k = 3",
          "expected_output": "\"1219\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz_br3tm7.py\", line 23, in <module>\n    k = int(data[1]) if len(data) > 1 else 0\n        ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '='"
        },
        {
          "example_index": 1,
          "input": "num = \"10200\", k = 1",
          "expected_output": "\"200\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpt52h_meb.py\", line 23, in <module>\n    k = int(data[1]) if len(data) > 1 else 0\n        ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '='"
        },
        {
          "example_index": 2,
          "input": "num = \"10\", k = 2",
          "expected_output": "\"0\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9aim_zu1.py\", line 23, in <module>\n    k = int(data[1]) if len(data) > 1 else 0\n        ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '='"
        }
      ],
      "generated_code": "import sys\n\ndef remove_k_digits(num: str, k: int) -> str:\n    stack = []\n    for digit in num:\n        while k > 0 and stack and stack[-1] > digit:\n            stack.pop()\n            k -= 1\n        stack.append(digit)\n\n    while k > 0:\n        stack.pop()\n        k -= 1\n\n    result = ''.join(stack).lstrip('0')\n    return result if result else \"0\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().split()\n    if not data:\n        sys.exit()\n    num = data[0]\n    k = int(data[1]) if len(data) > 1 else 0\n    print(remove_k_digits(num, k))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: Remove K digits from a numeric string to produce the smallest possible integer.\n\nWe must generate line-by-line virtual code with explanation after each line. Use the format: \"虛擬碼步驟 // 解釋\".\n\nWe need to include structure with Start, Decision, etc.\n\nWe should produce steps: input string num, integer k; iterate over digits, maintain stack or string builder; for each digit, while k>0 and stack not empty and top>current digit, pop stack and decrement k; push current digit; after loop, if k>0, remove last k digits; build result string by trimming leading zeros; if result empty, output \"0\"; else output result.\n\nLet's produce lines accordingly.\n\nWe need to use the arrow → for steps, Decision: for conditional, Yes → etc.\n\nWe can use variable names: numStr, k, stack, digit, result.\n\nWe must keep each line minimal but clear.\n\nLet's structure:\n\nStart\n\n→ Step 1: numStr ← input string num // capture input\n\n→ Step 2: k ← input integer k // capture input\n\n→ Step 3: stack ← empty list // use list as stack for digits\n\n→ Decision: 遍歷 numStr 中每個 digit? // iterate over each digit\n\n    Yes → Step 4: digit ← current char // current digit\n\n    → Decision: k>0 AND stack 非空 AND top(stack)>digit? // check if we should pop\n\n        Yes → Step 5: pop top(stack); k ← k-1 // remove bigger digit\n\n        No  → Step 6: push digit onto stack // keep current digit\n\n→ Decision: k>0? // after loop, still need to remove extra digits\n\n    Yes → Step 7: remove last k digits from stack // pop from end\n\n→ Step 8: result ← concatenate stack elements into string // build result\n\n→ Decision: result 為全零? // check leading zeros\n\n    Yes → Step 9: result ← '0' // all zeros -> 0\n\n    No  → Step 10: strip leading zeros from result // remove leading zeros\n\n→ End // output result\n\nBut we need to incorporate building result string, stripping leading zeros.\n\nBetter to add a step for trimming leading zeros.\n\nAlso, we need to output result; but in virtual code we may just note that we output.\n\nLet's produce detailed steps. Also maybe include decision for trimming leading zeros: while result starts with '0', remove first char; if result empty, set to '0'.\n\nLet's produce final answer accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: numStr ← input string num // 取得輸入的數字字串  \n→ Step 2: k ← input integer k // 取得要移除的位數  \n→ Step 3: stack ← empty list // 用列表模擬棧，存放待保留的數字  \n\n→ Decision: 是否還有位數可處理？ // 逐位遍歷 numStr  \n    Yes → Step 4: digit ← current char of numStr // 取得目前處理的數字  \n    → Decision: k > 0 且 stack 不是空且 stack.top > digit? // 檢查是否可以把前一個更大的數字刪掉  \n        Yes → Step 5: pop stack.top(); k ← k - 1 // 刪除更大的數字，減少剩餘刪除數  \n        No  → Step 6: push digit onto stack // 目前數字保持在棧中  \n\n→ Decision: k > 0? // 迴圈結束後還剩餘刪除數  \n    Yes → Step 7: remove last k digits from stack // 從棧尾刪除多餘位數  \n    No  → // 無需額外刪除  \n\n→ Step 8: result ← concatenate all elements of stack into string // 重新組合剩餘數字  \n→ Decision: result 是否為空？ // 檢查是否全部被刪除  \n    Yes → Step 9: result ← \"0\" // 若空則結果為 0  \n    No  → Step 10: result ← strip leading zeros from result // 去除前導 0  \n\n→ End // 輸出最小可能的整數結果 (result)"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj334zg6g.py\", line 38, in <module>\n    params = ast.literal_eval(dict_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x76debf12b650>"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyjwyb94q.py\", line 38, in <module>\n    params = ast.literal_eval(dict_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7e0c16827650>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list[str]) -> int:\n        # 若目標基因不在基因庫，無法完成突變\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])   # (目前基因, 已經做的突變數)\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            # 逐位產生所有可能的突變\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i+1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        # 將「var = value」轉換成「var: value」以符合字典語法\n        dict_str = \"{\" + data.replace('=', ':') + \"}\"\n        params = ast.literal_eval(dict_str)\n        startGene = params.get('startGene')\n        endGene = params.get('endGene')\n        bank = params.get('bank', [])\n        solution = Solution()\n        result = solution.minMutation(startGene, endGene, bank)\n        print(result)\n    else:\n        print(-1)",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for the algorithm to find minimum mutations. Likely BFS. Steps: start, if endGene in bank? BFS queue from startGene, visited set. For each gene, generate all possible mutations by changing each position to A/C/G/T. If new gene in bank and not visited, add to queue with level+1. If reached endGene return level. If queue empty return -1. Ensure we consider starting gene maybe not in bank. Use visited to avoid loops.\n\nWe must produce each line with virtual code and comment. Use arrow formatting.\n\nLet's create lines: Start, if endGene not in bank => return -1? Actually if not in bank it's impossible. But some solutions allow endGene not in bank? Problem states bank contains all valid mutations; need to end at endGene which must be valid, so if not in bank return -1.\n\nThen initialize queue, visited, level 0. BFS loop until queue empty: pop gene, level. If gene equals endGene return level. For each pos 0-7, for each nucleotide in 'ACGT', if new != gene[pos], newGene = replace char. If newGene in bank and not visited: add to queue, visited.\n\nIf loop ends return -1.\n\nEdge: startGene==endGene return 0.\n\nAlso need to handle bank as set for O(1) lookup.\n\nLet's produce pseudocode lines accordingly.\n\nUse \"Step 1:\" etc. For BFS loop maybe \"Decision:\".\n\nWe'll produce each line with comment after //.\n\nLet's craft.\n\nUse indentation with arrow maybe? The example uses indentation but we can simply use arrow to indicate flow.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: If startGene == endGene return 0 // 已經是目標基因，無需突變\n→ Decision: If endGene not in bank? // 目標基因必須存在於基因庫\n    Yes → Step 2: Return -1 // 若不存在，無法達成\n    No  → Step 3: 初始化 BFS 結構 // 準備廣度優先搜尋\n→ Step 3: Create queue Q // 儲存待探索基因字串\n→ Step 4: Enqueue (startGene, 0) into Q // 起點，突變數為 0\n→ Step 5: Create visited set V; add startGene // 避免重複探索\n→ Step 6: Create set B from bank // 快速查找\n→ Decision: While Q not empty? // 循環搜尋\n    Yes → Step 7: Dequeue (current, steps) from Q // 取得當前節點\n    → Decision: If current == endGene? // 是否到達終點\n        Yes → Step 8: Return steps // 最小突變數已找到\n        No  → Step 9: For i from 0 to 7? // 逐位置產生突變\n            → For each nucleotide in ['A','C','G','T']? // 替換字符\n                → Decision: If nucleotide != current[i]? // 確保有變化\n                    Yes → Step 10: newGene = replace current at i with nucleotide // 生成新基因\n                    → Decision: If newGene in B and newGene not in V? // 必須有效且未訪問\n                        Yes → Step 11: Enqueue (newGene, steps+1) into Q // 加入隊列\n                        → Step 12: Add newGene to V // 標記已訪問\n                    No  → // 其他情況不處理\n                No  → // 同字符不作處理\n    No  → Step 13: Return -1 // 队列耗盡，無法達成\nEnd // 程式執行結束\n\nNeed to keep indentation? Example uses indentation under Decision. We'll mimic. Ensure each line has arrow? They used \"→\" at start of each step. For decisions, they used \"Decision:\" and indent Yes/No with arrow. Let's replicate style: We'll start with \"Start\" no arrow? Example had \"Start\" with no arrow. Then \"→ Step 1:\" etc. Good.\n\nWe'll produce as lines. Let's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: If startGene == endGene return 0 // 已經是目標基因，無需突變\n→ Decision: 如果 endGene 不在 bank? // 目標基因必須存在於基因庫\n    Yes → Step 2: Return -1 // 若不存在，無法達成\n    No  → Step 3: 初始化 BFS 結構 // 準備廣度優先搜尋\n→ Step 3: 創建佇列 Q // 儲存待探索基因字串\n→ Step 4: 把 (startGene, 0) 加入 Q // 起點，突變數為 0\n→ Step 5: 創建集合 V，加入 startGene // 避免重複探索\n→ Step 6: 創建集合 B，等於 bank // 快速查找有效基因\n→ Decision: 當 Q 不為空? // 循環搜尋\n    Yes → Step 7: 從 Q 取出 (current, steps) // 取得當前節點\n    → Decision: 如果 current == endGene? // 是否到達終點\n        Yes → Step 8: Return steps // 最小突變數已找到\n        No  → Step 9: 對 i 從 0 到 7 做循環 // 逐位置產生突變\n            → For 每個 nucleotide 在 ['A','C','G','T']? // 替換字符\n                → Decision: 如果 nucleotide != current[i]? // 確保有變化\n                    Yes → Step 10: newGene = 將 current 在位置 i 替換為 nucleotide // 生成新基因\n                    → Decision: 如果 newGene 在 B 且 newGene 不在 V? // 必須有效且未訪問\n                        Yes → Step 11: 把 (newGene, steps+1) 加入 Q // 加入隊列\n                        → Step 12: 把 newGene 加入 V // 標記已訪問\n                    No  → // 不處理\n                No  → // 同字符不作處理\n    No  → Step 13: Return -1 // 队列耗盡，無法達成\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass MedianFinder:\n    \"\"\"\n    用兩個堆實現中位數查找：\n    - small: 大小最大堆（以負數存儲，實際為最大堆）\n    - large: 最小堆\n    \"\"\"\n    def __init__(self):\n        self.small = []  # 大小最大堆（負數）\n        self.large = []  # 最小堆\n\n    def addNum(self, num: int) -> None:\n        \"\"\"\n        把新數字加入結構，並保持兩堆大小差不超過 1。\n        \"\"\"\n        # 先把數放進 small，之後再調整\n        heapq.heappush(self.small, -num)\n\n        # 如果 small 的最大值大於 large 的最小值，需要交換\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡兩堆大小\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        \"\"\"\n        根據兩堆大小返回中位數。\n        \"\"\"\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef parse_input(s: str):\n    \"\"\"\n    解析類似 LeetCode 的輸入格式：\n    '[\"MedianFinder\", \"addNum\", ...], [[], [1], ...]'\n    返回兩個列表：ops, args\n    \"\"\"\n    s = s.strip()\n    # 找到第一個 ']'，把前面作為 ops 列表\n    first_end = s.find(']')\n    ops_str = s[:first_end + 1]\n    rest = s[first_end + 2:].strip()  # 跳過 '], '\n    args_str = rest\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            results.append(None)  # LeetCode 使用 null\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            results.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            results.append(median)\n        else:\n            # 若有未知操作，可忽略或拋出錯誤\n            results.append(None)\n\n    # 將 None 轉換為 'null'，保持與 LeetCode 輸出格式一致\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MedianFinder with addNum and findMedian. Use two heaps: max-heap for lower half, min-heap for upper half. Steps: initialization, addNum: push to appropriate heap, rebalance if size diff >1, findMedian: if same size return avg, else return top of larger heap. Provide lines with virtual code. No real code. Use arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立兩個空堆 MaxHeap 與 MinHeap // 用來分別存儲左半與右半的數值  \n→ Step 2: 建構函式 MedianFinder() // 初始化時兩個堆皆空  \n\n// addNum 方法  \n→ Step 3: 函式 addNum(num) // 接收新數字  \n    → Decision: 如果 MaxHeap 为空或 num <= MaxHeap.top()? // 判斷新數字是否屬於左半區  \n        Yes → Step 4: MaxHeap.push(num) // 新數字放入 MaxHeap  \n        No  → Step 5: MinHeap.push(num) // 新數字放入 MinHeap  \n\n    → Decision: 如果 MaxHeap.size() > MinHeap.size() + 1? // 左半多一個以上  \n        Yes → Step 6: MinHeap.push(MaxHeap.pop()) // 取左半最大值移到右半  \n    → Decision: 如果 MinHeap.size() > MaxHeap.size() + 1? // 右半多一個以上  \n        Yes → Step 7: MaxHeap.push(MinHeap.pop()) // 取右半最小值移到左半  \n\n// findMedian 方法  \n→ Step 8: 函式 findMedian() // 返回目前的中位數  \n    → Decision: 如果 MaxHeap.size() == MinHeap.size()? // 數量相同  \n        Yes → Step 9: Return (MaxHeap.top() + MinHeap.top()) / 2.0 // 兩邊最大/最小值平均  \n        No  → Decision: 如果 MaxHeap.size() > MinHeap.size()? // 左半較多  \n            Yes → Step 10: Return MaxHeap.top() // 左半最大值即中位數  \n            No  → Step 11: Return MinHeap.top() // 右半最小值即中位數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find K-th Smallest Pair Distance",
      "source_file": "Leetcode/leetcode719.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,1], k = 1",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3j78073c.py\", line 28, in <module>\n    exec(data, {}, local_vars)          # parse input like \"nums = [...], k = ...\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [1,3,1], k = 1\n    ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1], k = 2",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsfccyl5t.py\", line 28, in <module>\n    exec(data, {}, local_vars)          # parse input like \"nums = [...], k = ...\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [1,1,1], k = 2\n    ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "nums = [1,6,1], k = 3",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdi16_8p2.py\", line 28, in <module>\n    exec(data, {}, local_vars)          # parse input like \"nums = [...], k = ...\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [1,6,1], k = 3\n    ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def smallestDistancePair(self, nums, k):\n        nums.sort()\n        # Helper: count pairs with distance <= mid\n        def count_pairs(mid):\n            count = 0\n            left = 0\n            for right in range(len(nums)):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            return count\n\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            if count_pairs(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    local_vars = {}\n    exec(data, {}, local_vars)          # parse input like \"nums = [...], k = ...\"\n    nums = local_vars['nums']\n    k = local_vars['k']\n    result = Solution().smallestDistancePair(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find kth smallest pair distance. Standard solution: sort array, binary search on distance, count pairs <= mid. Steps: sort, binary search left=0, right= max-min, while left<right: mid=(left+right)//2, count pairs <=mid, if count>=k then right=mid else left=mid+1. Return left.\n\nNeed to produce virtual code line by line with explanation. Use arrow structure. We can include Start, End. Use \"Decision:\" lines. Provide steps.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: Sort nums ascending // order the numbers\n→ Step 2: Initialize left = 0 // minimum possible distance\n→ Step 3: Initialize right = nums[last] - nums[first] // maximum possible distance\n→ Decision: While left < right? // loop until search space narrowed\n    Yes → Step 4: mid = (left + right) / 2 // middle distance candidate\n    → Step 5: count = CountPairsWithDistanceAtMost(mid) // count pairs <= mid\n    → Decision: if count >= k? // enough pairs within this distance\n        Yes → Step 6: right = mid // search lower half\n        No  → Step 7: left = mid + 1 // search upper half\n    No → End // loop finished\n→ Step 8: Return left // smallest distance with at least k pairs\n\nNeed CountPairsWithDistanceAtMost(mid) subroutine: two-pointer.\n\nDefine:\n→ Step 9: CountPairsWithDistanceAtMost(mid):\n    → Start\n    → Step 10: count = 0\n    → Step 11: j = 0\n    → Decision: For i from 0 to n-1? // iterate each i\n        Yes → Step 12: while j < n and nums[j] - nums[i] <= mid: j++ // move j\n        → Step 13: count += (j - i - 1) // number of valid pairs with i\n    → End\n    → Return count\n\nBut we need to output line by line. Might embed subroutine lines after.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先把陣列排好順序  \n→ Step 2: left = 0 // 可能的最小距離  \n→ Step 3: right = nums[nums.length - 1] - nums[0] // 可能的最大距離  \n\n→ Decision: 是否還有搜尋空間? (left < right) // 需要繼續二分搜尋  \n    Yes → Step 4: mid = (left + right) / 2 // 計算中間距離  \n    → Step 5: count = CountPairsWithDistanceAtMost(mid) // 計算距離 ≤ mid 的對數  \n    → Decision: count >= k? // 判斷對數是否足夠  \n        Yes → Step 6: right = mid // 將搜尋區間縮小到較小距離  \n        No  → Step 7: left = mid + 1 // 搜尋區間移到較大距離  \n    No → End // 搜尋結束，left 即為答案  \n\n→ Step 8: Return left // 回傳第 k 小的距離  \n\n---  \n**CountPairsWithDistanceAtMost(subroutine)**  \nStart // 子程式開始  \n→ Step 9: count = 0 // 初始化計數  \n→ Step 10: j = 0 // 第二指標起始位置  \n→ Decision: i 迴圈 (0 ≤ i < nums.length) // 對每個 i 進行計算  \n    Yes → Step 11: while j < nums.length and nums[j] - nums[i] ≤ mid: j++ // 移動 j 直到距離超過 mid  \n    → Step 12: count += (j - i - 1) // 把所有 j 在 i 之後且距離 ≤ mid 的對數加入 count  \n    No → // i 迴圈結束  \nEnd // 子程式結束  \n→ Return count // 傳回符合條件的對數  \n---  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmcl1fn2f.py\", line 70, in <module>\n    intervals, new_interval = parse_input()\n                              ^^^^^^^^^^^^^\n  File \"/tmp/tmpmcl1fn2f.py\", line 54, in parse_input\n    intervals = ast.literal_eval(lists[0])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo94cg09z.py\", line 70, in <module>\n    intervals, new_interval = parse_input()\n                              ^^^^^^^^^^^^^\n  File \"/tmp/tmpo94cg09z.py\", line 54, in parse_input\n    intervals = ast.literal_eval(lists[0])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def insert(self, intervals, new_interval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals\n        and merge if necessary.\n        \"\"\"\n        result = []\n        added = False\n\n        for s, e in intervals:\n            if e < new_interval[0]:\n                # Current interval ends before new_interval starts.\n                result.append([s, e])\n            elif s > new_interval[1]:\n                # Current interval starts after new_interval ends.\n                if not added:\n                    result.append(new_interval)\n                    added = True\n                result.append([s, e])\n            else:\n                # Overlap – merge into new_interval.\n                new_interval[0] = min(new_interval[0], s)\n                new_interval[1] = max(new_interval[1], e)\n\n        if not added:\n            result.append(new_interval)\n\n        return result\n\ndef parse_input():\n    \"\"\"\n    Parse stdin for two interval lists.\n    Accepts:\n      - Two separate lines, each containing a list.\n      - One line containing 'intervals = [...] , newInterval = [...]'.\n      - Lines starting with the variable names.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], []\n\n    intervals = []\n    new_interval = []\n\n    lines = data.splitlines()\n    if len(lines) == 1:\n        # Attempt to extract both lists from a single line\n        lists = re.findall(r'\\[[^\\]]+\\]', lines[0])\n        if len(lists) >= 2:\n            intervals = ast.literal_eval(lists[0])\n            new_interval = ast.literal_eval(lists[1])\n    else:\n        for line in lines:\n            if line.startswith('intervals'):\n                m = re.search(r'\\[[^\\]]+\\]', line)\n                if m:\n                    intervals = ast.literal_eval(m.group())\n            elif line.startswith('newInterval'):\n                m = re.search(r'\\[[^\\]]+\\]', line)\n                if m:\n                    new_interval = ast.literal_eval(m.group())\n\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    intervals, new_interval = parse_input()\n    sol = Solution()\n    merged = sol.insert(intervals, new_interval)\n    print(merged)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for merging intervals with insertion. Provide line by line explanation. Use Start, End, Decision, arrow. Provide steps.\n\nWe need to create new array result. Iterate intervals, compare start positions relative to newInterval. Add intervals that end before newInterval.start, add newInterval when its position fits, merge overlapping intervals.\n\nWe need to think algorithm: For each interval [s, e] in intervals:\n\n- if e < newInterval.start: add [s, e] to result (no overlap, earlier)\n- else if s > newInterval.end: if newInterval not added yet, add newInterval, then add [s, e], continue. If already added, just add [s, e].\n- else overlapping: merge: newInterval.start = min(newInterval.start, s); newInterval.end = max(newInterval.end, e);\n\nAfter loop, if newInterval not added, add it.\n\nReturn result.\n\nWe need to produce virtual code lines: Start, Step to initialize result, Step to set flag added false, Step to loop over intervals (maybe Step: For each interval in intervals). Use Decision for comparisons.\n\nWe must include [space] before // explanation.\n\nAlso arrow after each step? The example uses arrow before step. Use same formatting. Eg: → Step 1: 初始化 result = [] // 建立新陣列.\n\nLet's produce lines.\n\nAlso we must not produce actual code but pseudocode lines.\n\nWe should include decision blocks indented? In example, they indent decisions. We can do similar: indent decisions and subsequent steps with spaces.\n\nLet's produce.\n\nWe also need to handle flag for added. Let's call newAdded = False.\n\nImplement loop: for each interval.\n\nWithin loop: Decision: if interval.end < newInterval.start? Yes -> add interval.\n\nElse if interval.start > newInterval.end? Yes -> if not newAdded: add newInterval; set newAdded True; add interval. Else add interval.\n\nElse: overlapping -> merge: newInterval.start = min(newInterval.start, interval.start); newInterval.end = max(newInterval.end, interval.end).\n\nAfter loop: Decision: if not newAdded? Yes -> add newInterval.\n\nReturn result.\n\nLet's produce lines accordingly. Use Start and End.\n\nAdd comments.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← [] // 建立用於儲存合併後區間的新陣列  \n→ Step 2: newAdded ← False // 標記 newInterval 是否已被加入結果  \n→ Step 3: For each interval in intervals // 逐一處理原始區間  \n   Decision: interval.end < newInterval.start? // 判斷區間是否完全在 newInterval 前  \n    Yes → Step 4: result.Add(interval) // 直接加入，無重疊  \n    No  → Decision: interval.start > newInterval.end? // 判斷區間是否完全在 newInterval 後  \n      Yes → Decision: newAdded? // 檢查 newInterval 是否已加入  \n       Yes → Step 5: result.Add(interval) // 直接加入，newInterval 已處理  \n       No  → Step 6: result.Add(newInterval) // 加入 newInterval  \n         newAdded ← True  \n         Step 7: result.Add(interval) // 再加入原始區間  \n         // newInterval 已加入且位置已確定  \n         No → Step 8: // 兩區間有重疊，合併  \n          newInterval.start ← Min(newInterval.start, interval.start)  \n          newInterval.end ← Max(newInterval.end, interval.end)  \n→ Decision: newAdded? // 迴圈結束後檢查 newInterval 是否已加入  \n   Yes → // 已加入，無需再處理  \n   No  → Step 9: result.Add(newInterval) // 加入未加入的 newInterval  \nEnd // 程式執行結束，回傳 result（已自動排序且無重疊）"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nINF = 10**9\n\ndef collapse(board: str) -> str:\n    \"\"\"\n    Repeatedly remove groups of 3 or more consecutive same-colored balls.\n    \"\"\"\n    changed = True\n    while changed:\n        changed = False\n        new_board = []\n        i = 0\n        n = len(board)\n        while i < n:\n            j = i + 1\n            while j < n and board[j] == board[i]:\n                j += 1\n            if j - i >= 3:\n                changed = True\n                i = j\n                continue\n            new_board.append(board[i:j])\n            i = j\n        board = \"\".join(new_board)\n    return board\n\ndef dfs(board: str, hand_counts: Counter, memo: dict) -> int:\n    \"\"\"\n    Return the minimum number of insertions needed to clear `board`\n    using the balls in `hand_counts`. Return INF if impossible.\n    \"\"\"\n    if not board:\n        return 0\n    key = (board, tuple(sorted(hand_counts.items())))\n    if key in memo:\n        return memo[key]\n    ans = INF\n    n = len(board)\n    for i in range(n + 1):\n        for color in hand_counts:\n            if hand_counts[color] == 0:\n                continue\n            # Count same-colored balls to the left and right of position i\n            left = i - 1\n            right = i\n            while left >= 0 and board[left] == color:\n                left -= 1\n            while right < n and board[right] == color:\n                right += 1\n            if left == i - 1 and right == i:\n                # No same-colored neighbors\n                total = 1\n            else:\n                total = (i - 1 - left) + (right - i) + 1\n            if total < 3:\n                # Inserting this ball does not trigger any removal\n                continue\n            # Insert the ball and collapse\n            new_board = board[:i] + color + board[i:]\n            collapsed = collapse(new_board)\n            new_hand = hand_counts.copy()\n            new_hand[color] -= 1\n            res = dfs(collapsed, new_hand, memo)\n            if res != INF:\n                ans = min(ans, res + 1)\n    memo[key] = ans\n    return ans\n\ndef solve(board: str, hand: str) -> int:\n    hand_counts = Counter(hand)\n    res = dfs(board, hand_counts, {})\n    return -1 if res == INF else res\n\ndef parse_input() -> (str, str):\n    data = sys.stdin.read()\n    # Try to find quoted strings first\n    quotes = re.findall(r'\"([^\"]*)\"', data)\n    if len(quotes) >= 2:\n        return quotes[0], quotes[1]\n    # Fallback to split tokens\n    tokens = data.strip().split()\n    if len(tokens) >= 2:\n        return tokens[0], tokens[1]\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    board, hand = parse_input()\n    result = solve(board, hand)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps. Not actual code but structured algorithm. Provide steps to solve Zuma minimal insertions problem. Use recursion/backtracking with memoization. Outline steps: start, function solve(board, hand), if board empty return 0. If hand empty return INF. Use state representation. For each unique ball color in hand >0: try inserting into board between any positions where group of same color could be formed. But simpler: iterate over positions to compress consecutive same color groups. Standard solution: For each group, if group length + hand count >=3, remove group by using required balls. Then recursively solve. Use memoization dictionary keyed by board+hand. Complexity. We'll produce pseudo steps.\n\nWe need line-by-line pseudo code with comments. Use Start, End, Decision, arrows. Let's produce. Use steps like:\n\nStart\n→ Step: Define function minInsertions(board, hand)\n→ Decision: If board empty? Yes → Return 0 No → Continue\n→ Step: Sort hand? Actually we will use counts.\n→ Step: Memo key = board + hand counts\n→ Decision: If key in memo? Yes → Return memo[key] No → Continue\n→ Step: Set minAns = INF\n→ For each position i from 0 to len(board)\n   -> Determine group start i..j with same color\n   -> Let color = board[i], groupLen = j-i\n   -> Need = max(0, 3-groupLen)\n   -> If hand has at least need of color\n      -> newHand = hand minus need of color\n      -> newBoard = board with group removed + possibly merge\n      -> Recursively compute res = minInsertions(newBoard, newHand)\n      -> If res != INF: minAns = min(minAns, res + need)\n-> After loop, memo[key] = minAns if < INF else INF\n-> Return minAns\n\nFinally after function call, if result >= INF return -1 else result.\n\nWe will write in pseudo format lines with arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Function minInsertions(board, hand) // 定義遞迴函式，計算最少插入數  \n→ Decision: 如果 board 為空? // 檢查是否已經清空桌面  \n  Yes → Return 0 // 若無球則已成功，無需再插入  \n  No  → 進行後續計算  \n\n→ Step: 轉換 hand 為字典 color → 數量 // 方便快速查詢各顏色剩餘球數  \n\n→ Step: 建立 memo 鍵 = board + hand 數量的串列 // 用於記錄已計算的子問題結果  \n\n→ Decision: 如果 memo 中已存在鍵?  \n  Yes → Return memo[key] // 直接回傳已知結果  \n  No  → 繼續  \n\n→ Step: 初始化 minAns = ∞ // 用於追蹤目前子問題的最小插入數  \n\n→ For i from 0 to len(board) // 遍歷所有可能插入位置  \n  → Step: 找到從 i 開始的連續相同顏色區塊的終點 j  \n  → Step: color = board[i] // 區塊顏色  \n  → Step: groupLen = j - i // 區塊長度  \n  → Step: need = max(0, 3 - groupLen) // 此區塊需補幾顆才能消除  \n\n  → Decision: 如果 hand[color] >= need?  \n    Yes → // 可以使用手牌補足此區塊  \n     → Step: newHand = copy(hand)  \n      → newHand[color] -= need // 消耗相應顏色球  \n     → Step: newBoard = board[0:i] + board[j:] // 把區塊從桌面移除  \n     → Step: // 循環消除後再回傳  \n      → Step: res = minInsertions(newBoard, newHand) // 進一步遞迴  \n      → Decision: 如果 res != ∞?  \n        Yes → minAns = min(minAns, res + need) // 更新全局最小值  \n        No  → 什麼也不做  \n      → End  \n     → End  \n    No → // 手牌不足，無法補足此區塊，跳過  \n  → End  \n\n→ Step: memo[key] = minAns // 將結果記錄到備忘錄  \n→ Return minAns  \n\n→ Function solve(boardStr, handStr) // 主入口函式  \n  → Step: handCounts = 將 handStr 轉為字典 color → 數量  \n  → Step: result = minInsertions(boardStr, handCounts)  \n  → Decision: 如果 result == ∞?  \n    Yes → Return -1 // 無法清空桌面  \n    No  → Return result // 最少插入數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "K Inverse Pairs Array",
      "source_file": "Leetcode/leetcode629.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkrrivqjg.py\", line 40, in <module>\n    n, k = map(int, data[:2])\n    ^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx8fw83w7.py\", line 40, in <module>\n    n, k = map(int, data[:2])\n    ^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\ndef count_inverse_pairs(n: int, k: int) -> int:\n    \"\"\"Return the number of permutations of 1..n with exactly k inversion pairs.\"\"\"\n    # If k is larger than the maximum possible inversions, answer is 0.\n    if k > n * (n - 1) // 2:\n        return 0\n\n    # dp_prev[j] = number of permutations of first i-1 numbers with j inversions\n    dp_prev = [0] * (k + 1)\n    dp_prev[0] = 1\n\n    for i in range(1, n + 1):\n        # Compute prefix sums of dp_prev to allow O(1) range sums\n        pre = [0] * (k + 1)\n        pre[0] = dp_prev[0]\n        for j in range(1, k + 1):\n            pre[j] = (pre[j - 1] + dp_prev[j]) % MOD\n\n        dp_cur = [0] * (k + 1)\n        for j in range(k + 1):\n            if j < i:\n                # All j inversions can be formed by placing i at any position\n                dp_cur[j] = pre[j]\n            else:\n                # Subtract the cases where i is placed too far left\n                dp_cur[j] = (pre[j] - pre[j - i] + MOD) % MOD\n\n        dp_prev = dp_cur\n\n    return dp_prev[k] % MOD\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().split()\n    if not data:\n        sys.exit(0)\n    n, k = map(int, data[:2])\n    result = count_inverse_pairs(n, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: Count number of permutations of 1..n with exactly k inversion pairs. Classic DP: dp[n][k] = sum_{i=0}^{min(k, n-1)} dp[n-1][k-i]. Use prefix sums for O(n*k). Mod 1e9+7.\n\nWe produce virtual code lines with explanation. Each line with virtual code and comment. Use Start, End, Decision, etc. Use arrow \"→\". For loops etc. Use \"For\" structure maybe. Provide step-by-step. Use variable names.\n\nLet's create:\n\nStart\n→ Input: n, k // 讀取 n 和 k\n→ Initialize dp array of size (n+1) x (k+1) with zeros // dp[i][j]\n→ Set dp[0][0] = 1 // 0 numbers, 0 inversions\n→ For i from 1 to n // iterate number of elements\n    → For j from 0 to k // current inversion count\n        → Decision: if j == 0? // compute sum quickly\n            Yes → dp[i][j] = dp[i-1][j] // only i-1 permutations\n            No  → Compute sum = prefix sum of dp[i-1][j] to dp[i-1][j-(i-1)]\n                → Use prefix array to get in O(1)\n                → dp[i][j] = sum mod M\nBut need virtual code steps.\n\nWe should produce step-by-step with prefix sum: compute prefix array pre[j] = pre[j-1] + dp[i-1][j]; then dp[i][j] = pre[j] - pre[max(j-i, -1)].\n\nLet's produce.\n\nAlso need final answer dp[n][k] mod M.\n\nMake sure to include decisions and loops.\n\nAlso we need to adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrow after each step: \"→\" or \"→ Step\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: n, k // 讀取整數 n（元素個數）與 k（目標逆序數）  \n→ Constant: M = 10^9 + 7 // 模數，用於取模  \n→ Initialize dp[0…n][0…k] ← 0 // dp[i][j] 代表前 i 個數字組成的排列中恰好 j 個逆序對的數量  \n→ Set dp[0][0] ← 1 // 0 個數字且 0 個逆序對只有一種空排列  \n→ For i ← 1 to n // 遍歷元素個數 i  \n    → // 先計算上一層的前綴和 pre[j] = Σ_{t=0}^{j} dp[i-1][t]  \n    → Initialize pre[0…k] ← 0  \n    → pre[0] ← dp[i-1][0]  \n    → For j ← 1 to k  \n        → pre[j] ← (pre[j-1] + dp[i-1][j]) mod M // 前綴和累加，保持取模  \n    → For j ← 0 to k // 計算 dp[i][j]  \n        → Decision: if j < i? // 當逆序對數小於 i 時，只需考慮 j 個逆序對  \n            Yes → dp[i][j] ← pre[j] // 所有前綴和均可使用  \n            No  → // j ≥ i，需排除多餘的 i 個位置  \n                → low ← j - i // 需要從 pre[j] 中減去 pre[low]  \n                → dp[i][j] ← (pre[j] - pre[low] + M) mod M // 保證非負並取模  \n→ Output: dp[n][k] // 目標排列數量（取模後）  \nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqsw3wo0r.py\", line 62, in <module>\n    main()\n  File \"/tmp/tmpqsw3wo0r.py\", line 50, in main\n    raise ValueError(\"Input format error. Expected 'matrix = [...], k = ...'\")\nValueError: Input format error. Expected 'matrix = [...], k = ...'"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp13g6y9o7.py\", line 62, in <module>\n    main()\n  File \"/tmp/tmp13g6y9o7.py\", line 50, in main\n    raise ValueError(\"Input format error. Expected 'matrix = [...], k = ...'\")\nValueError: Input format error. Expected 'matrix = [...], k = ...'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        n = len(matrix)\n\n        # 取矩陣的最小值和最大值作為搜尋區間\n        low, high = matrix[0][0], matrix[n-1][n-1]\n\n        # 透過二分搜尋「值」的方式找出第 k 小的元素\n        while low < high:\n            mid = (low + high) // 2\n            cnt = self._count_le(matrix, mid)\n\n            if cnt < k:          # 目前 count 還不到 k，必須往大一點的數字尋找\n                low = mid + 1\n            else:                # count 足夠，向小一點的數字收縮\n                high = mid\n\n        return low\n\n    def _count_le(self, matrix, x):\n        \"\"\"\n        計算矩陣中 <= x 的元素個數。\n        由於矩陣每行每列都是升序，可從左下角開始\n        逐行遍歷，每一步決定往右或往上移動。\n        \"\"\"\n        n = len(matrix)\n        i, j = n - 1, 0  # 從最後一行第一列開始\n        cnt = 0\n\n        while i >= 0 and j < n:\n            if matrix[i][j] <= x:\n                cnt += i + 1          # 同一列中從 0 到 i 的所有元素都 <= x\n                j += 1                # 移到右邊\n            else:\n                i -= 1                # 移到上一行\n\n        return cnt\n\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n\n    # 以正則表達式提取 matrix 與 k\n    m = re.search(r'matrix\\s*=\\s*(\\[[\\[\\],\\s\\-]*\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)', raw)\n    if not m:\n        raise ValueError(\"Input format error. Expected 'matrix = [...], k = ...'\")\n\n    matrix_str, k_str = m.group(1), m.group(2)\n    matrix = eval(matrix_str)          # 轉成 Python 內建資料結構\n    k = int(k_str)\n\n    solution = Solution()\n    result = solution.kthSmallest(matrix, k)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for finding k-th smallest in sorted matrix with better than O(n^2) memory. Use binary search on value range with count <= x. Pseudocode step-by-step. Provide each line with explanation. Use Start, End, Decision, arrow. Also use Yes →, No →. Use virtual code. We'll produce steps:\n\nStart\n→ Step 1: Determine n from matrix size // get dimension\n→ Step 2: Set low = matrix[0][0] // smallest element\n→ Step 3: Set high = matrix[n-1][n-1] // largest element\n→ Decision: While low < high? // loop until converge\n    Yes → Step 4: Set mid = (low + high) // 2 // middle value\n    → Step 5: count = CountLessOrEqual(mid) // count elements <= mid\n    → Decision: if count < k? // if not enough elements\n        Yes → low = mid + 1 // move lower bound up\n        No → high = mid // move upper bound down\nEnd // low is kth smallest\n\nNeed helper CountLessOrEqual:\nStart CountLessOrEqual(x)\n→ Step 1: count = 0\n→ Step 2: i = n-1 // start from bottom-left\n→ Step 3: j = 0\n→ Decision: while i >= 0 and j < n? // traverse\n    Yes → Decision: if matrix[i][j] <= x?\n        Yes → count += i+1 // all above are <= x\n        → j += 1 // move right\n        No → i -= 1 // move up\n    No → Return count\nEnd\n\nBut need to structure using Decision and Yes/No. Provide each line as virtual code. Let's format properly.\n\nWe'll produce main algorithm, then helper function. We'll separate. Use arrows. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← 行列維度(matrix) // 取得矩陣大小  \n→ Step 2: low ← matrix[0][0] // 最小值  \n→ Step 3: high ← matrix[n-1][n-1] // 最大值  \n→ Decision: while low < high? // 迭代直至找到精確值  \n    Yes → Step 4: mid ← (low + high) // 2 // 中間值  \n    → Step 5: count ← CountLessOrEqual(mid) // 計算 ≤ mid 的元素數量  \n    → Decision: if count < k? // 是否還不足 k 個元素  \n        Yes → low ← mid + 1 // 向上調整 lower bound  \n        No  → high ← mid // 向下調整 upper bound  \nEnd // low 為第 k 小元素  \n\nFunction CountLessOrEqual(x) // 辅助計數函数  \nStart  \n→ Step 1: count ← 0 // 初始化計數  \n→ Step 2: i ← n-1 // 從最後一行開始  \n→ Step 3: j ← 0 // 從第一列開始  \n→ Decision: while i >= 0 and j < n? // 逐行遍歷  \n    Yes → Decision: if matrix[i][j] <= x? // 小於等於目標值  \n        Yes → count ← count + (i + 1) // 上方所有元素均 ≤ x  \n        → j ← j + 1 // 右移列  \n        No  → i ← i - 1 // 上移行  \n    No → Return count // 完成計數  \nEnd  \nEnd // 程式執行結束"
    },
    {
      "title": "Strange Printer",
      "source_file": "Leetcode/leetcode664.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef strange_printer(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    # dp[i][j] = minimal turns to print s[i..j]\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n-1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i+1, n):\n            # Worst case: print s[i] separately then s[i+1..j]\n            dp[i][j] = 1 + dp[i+1][j]\n            # Try merging s[i] with a later same character\n            for k in range(i+1, j+1):\n                if s[k] == s[i]:\n                    if k == j:\n                        # s[i] and s[j] same, can merge, no extra turn\n                        dp[i][j] = min(dp[i][j], dp[i+1][j-1])\n                    else:\n                        dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k+1][j])\n    return dp[0][n-1]\n\ndef parse_input(content: str) -> str:\n    \"\"\"\n    Extract the string value from input content.\n    Handles formats like:\n        s = \"aaabbb\"\n    or just\n        aaabbb\n    \"\"\"\n    # Look for a quoted string\n    m = re.search(r'\\\"([^\"]*)\\\"', content)\n    if m:\n        return m.group(1)\n    # If no quotes, strip whitespace and return\n    return content.strip()\n\ndef main():\n    data = sys.stdin.read()\n    s = parse_input(data)\n    result = strange_printer(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps with arrow and explanation. The algorithm: Strange Printer problem known as DP. We'll produce steps: Start, initialize DP array, fill base, iterate over lengths, nested loops, update dp[i][j] = min(dp[i][k]+dp[k+1][j] - (s[k]==s[j]?1:0)). Or use typical solution: dp[i][j] = min over k between i and j-1 of dp[i][k]+dp[k+1][j] - (s[k]==s[j]?1:0). But we need step-by-step pseudocode with explanation each line.\n\nWe should produce step lines like:\nStart // program start\n→ Input string s // read s\n→ n = length(s) // number of characters\n→ Create 2D array dp[n][n] // dp[i][j] minimal turns to print s[i..j]\n→ For i from 0 to n-1: dp[i][i] = 1 // single char needs one turn\n→ For len from 2 to n:\n    → For i from 0 to n-len:\n        j = i + len - 1\n        → dp[i][j] = dp[i][j-1] + 1 // init with worst case: print j separately\n        → For k from i to j-1:\n            If s[k] == s[j]:\n                temp = dp[i][k] + dp[k+1][j-1] // same char can merge\n            else:\n                temp = dp[i][k] + dp[k+1][j]\n            → If temp < dp[i][j]: dp[i][j] = temp // update min\n→ Return dp[0][n-1] // answer\n→ End\n\nBut each line must have virtual code step with explanation. We need to use arrow format: \"→\" preceding each step, or \"Decision:\" etc.\n\nLet's produce pseudocode with indentation: maybe use spaces or indent lines with nested loops as indented lines. The example uses indentation.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Input s // 取得輸入字串\n→ n ← length(s) // 字串長度\n→ Create dp[n][n] // 2D DP 陣列\n→ For i from 0 to n-1:\n    dp[i][i] ← 1 // 單字元需一回\n→ For len from 2 to n:\n    → For i from 0 to n - len:\n        j ← i + len - 1\n        → dp[i][j] ← dp[i][j-1] + 1 // 先假設最後一個字元獨立列印\n        → For k from i to j-1:\n            If s[k] = s[j] Then:\n                temp ← dp[i][k] + dp[k+1][j-1] // 同字符可合併\n            Else:\n                temp ← dp[i][k] + dp[k+1][j] // 不合併\n            → If temp < dp[i][j] Then:\n                dp[i][j] ← temp // 更新最小值\n→ Answer ← dp[0][n-1] // 最終答案\n→ Return Answer // 輸出結果\nEnd // 程式結束\n\nBut we must keep \"虛擬碼步驟\" with arrow for each line. Indent lines within loops with maybe two spaces.\n\nWe should use Chinese explanation.\n\nMake sure each line includes a space between code and comment. Use // for comment.\n\nThe example used \"Start\" without arrow. Then each subsequent line started with \"→\". We'll do that. Use \"Decision:\" for if conditions. Use \"If\" with \"Yes →\" etc? The example uses \"Decision:\" then Yes/No. But we can also use \"If\" statements as decisions. They asked to use arrow and structure: Use虛擬碼的箭頭 (→, Yes →, No →) and structure (Start, End, Decision:). So we might need to use \"Decision:\" for the if conditions. Example: \"Decision: 如果 s[k] = s[j]?\" with Yes →, No →. Let's adapt accordingly.\n\nLet's rewrite loops accordingly.\n\nPseudo:\n\nStart // 程式開始執行\n→ Input s // 取得輸入字串\n→ n ← length(s) // 字串長度\n→ Create dp[n][n] // 2D DP 陣列\n→ For i from 0 to n-1:\n    → dp[i][i] ← 1 // 單字元需一回\n→ For len from 2 to n:\n    → For i from 0 to n - len:\n        → j ← i + len - 1\n        → dp[i][j] ← dp[i][j-1] + 1 // 初始化為最壞情況\n        → For k from i to j-1:\n            → Decision: 如果 s[k] = s[j]?\n                Yes → temp ← dp[i][k] + dp[k+1][j-1] // 同字符可合併\n                No  → temp ← dp[i][k] + dp[k+1][j] // 不合併\n            → Decision: temp < dp[i][j] ?\n                Yes → dp[i][j] ← temp // 更新最小值\n→ Answer ← dp[0][n-1] // 最終答案\n→ Return Answer // 輸出結果\nEnd // 程式結束\n\nCheck formatting: each line has code then space then comment.\n\nWe need to ensure each step preceded by \"→\" except Start and End. Indentation maybe 4 spaces before lines inside loops. The example didn't indent inside loops, just nested using spaces in indentation. Use two spaces for nested? Use four spaces.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Input s // 取得輸入字串\n→ n ← length(s) // 字串長度\n→ Create dp[n][n] // 2D DP 陣列，用於存儲子問題答案\n→ For i from 0 to n-1:\n    → dp[i][i] ← 1 // 單一字元只需一次印刷\n→ For len from 2 to n:\n    → For i from 0 to n - len:\n        → j ← i + len - 1 // 右端點\n        → dp[i][j] ← dp[i][j-1] + 1 // 初始值：將 s[j] 單獨印刷\n        → For k from i to j-1:\n            → Decision: s[k] = s[j] ?\n                Yes → temp ← dp[i][k] + dp[k+1][j-1] // 同字符可合併，右端不再額外加一\n                No  → temp ← dp[i][k] + dp[k+1][j] // 必須額外印一次\n            → Decision: temp < dp[i][j] ?\n                Yes → dp[i][j] ← temp // 更新為更小的印刷次數\n→ Answer ← dp[0][n-1] // 整個字串的最小印刷次數\n→ Return Answer // 輸出結果\nEnd // 程式結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null,null,null,false,false,false]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null, null, null, false, false, false]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = 0\n        while i < len(self.ranges) and self.ranges[i][1] <= left:\n            i += 1\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    data = sys.stdin.read()\n    commands = [cmd.strip() for cmd in data.replace('\\n', ';').split(';') if cmd.strip()]\n    results = []\n    obj = None\n\n    # Regex to extract method call: .method(arg1, arg2)\n    pattern = re.compile(r'\\.(\\w+)\\((.*?)\\)')\n\n    for cmd in commands:\n        if cmd.startswith('RangeModule'):\n            # Constructor\n            obj = RangeModule()\n            results.append(None)\n            continue\n\n        if obj is None:\n            continue  # No object yet\n\n        match = pattern.search(cmd)\n        if not match:\n            continue  # Not a method call\n        method_name, args_str = match.groups()\n        args = [int(arg.strip()) for arg in args_str.split(',')] if args_str else []\n\n        if method_name == 'queryRange':\n            res = getattr(obj, method_name)(*args)\n            results.append(res)\n        else:\n            getattr(obj, method_name)(*args)\n            results.append(None)\n\n    # Convert results to required output format\n    out = []\n    for val in results:\n        if val is None:\n            out.append('null')\n        elif val is True:\n            out.append('true')\n        elif val is False:\n            out.append('false')\n        else:\n            out.append(str(val))\n    print(f'[{\", \".join(out)}]')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for implementing a RangeModule class with operations: init, addRange, queryRange, removeRange. Use virtual code with arrows. No actual code, just steps. Must be in Traditional Chinese. Each line: 虛擬碼步驟 + space + // 解釋. Use arrows. Use structure: Start, End, Decision: etc. Provide each step. Likely design uses interval tree or sorted list. Simplest: maintain sorted list of non-overlapping intervals. Steps for add: find position, merge overlaps, insert. For query: iterate intervals. For remove: split intervals. Provide pseudocode. Let's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 RangeModule 類別 // 定義資料結構\n→ Step 2: 初始化 intervals 為空排序清單 // 存放已追蹤的半開區間\n→ Step 3: 定義 addRange(left, right) 方法 // 新增區間\n→ Decision: 是否有 intervals 與 [left, right) 重疊? // 判斷是否需要合併\n    Yes → Step 4: 找到所有重疊區間的索引範圍 [i, j] // i 是第一個重疊區間，j 是最後一個\n    No  → Step 5: 插入 [left, right) 到適當位置並保持排序 // 直接插入，無重疊\n→ Step 6: 合併重疊區間：newLeft = min(left, intervals[i].left), newRight = max(right, intervals[j].right) // 計算合併後的左、右端點\n→ Step 7: 從 i 到 j 的區間刪除並插入 [newLeft, newRight) // 更新 intervals\n→ Step 8: End addRange // 完成新增\n→ Step 9: 定義 queryRange(left, right) 方法 // 查詢區間\n→ Decision: intervals 是否包含 [left, right) 的完整範圍? // 檢查是否所有數字被追蹤\n    Yes → Step 10: 回傳 true // 完全被追蹤\n    No  → Step 11: 回傳 false // 仍有未被追蹤的數字\n→ Step 12: End queryRange // 完成查詢\n→ Step 13: 定義 removeRange(left, right) 方法 // 移除區間\n→ Decision: 是否有 intervals 與 [left, right) 重疊? // 判斷是否需要分割\n    Yes → Step 14: 找到所有重疊區間的索引範圍 [i, j] // i 是第一個重疊區間，j 是最後一個\n    No  → Step 15: End removeRange // 無重疊，直接返回\n→ Step 16: 處理左端區間：若 intervals[i].left < left 则保留 [intervals[i].left, left) // 左側不被移除的部分\n→ Step 17: 處理右端區間：若 intervals[j].right > right 则保留 [right, intervals[j].right) // 右側不被移除的部分\n→ Step 18: 刪除從 i 到 j 的所有區間 // 刪除重疊區間\n→ Step 19: 插入保留的左端區間（若存在） // 保留左側\n→ Step 20: 插入保留的右端區間（若存在） // 保留右側\n→ End removeRange // 完成移除\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_ucskpkf.py\", line 74, in <module>\n    commands = json.loads(data[0])\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    \"\"\"環狀雙端佇列實作\"\"\"\n\n    def __init__(self, k: int):\n        \"\"\"初始化容量為 k 的雙端佇列\"\"\"\n        self.k = k\n        self.buf = [0] * k          # 用於儲存元素的陣列\n        self.head = 0               # 指向目前前端元素的位置\n        self.count = 0              # 已填入元素的數量\n\n    def insertFront(self, value: int) -> bool:\n        \"\"\"在前端插入元素\"\"\"\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k   # 往前移動前端指標（環形）\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        \"\"\"在後端插入元素\"\"\"\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k   # 後端實際位置\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        \"\"\"刪除前端元素\"\"\"\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k   # 往後移動前端指標\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        \"\"\"刪除後端元素\"\"\"\n        if self.count == 0:\n            return False\n        self.count -= 1                       # 後端指標自動向前\n        return True\n\n    def getFront(self) -> int:\n        \"\"\"取得前端元素\"\"\"\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        \"\"\"取得後端元素\"\"\"\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        \"\"\"判斷是否為空\"\"\"\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        \"\"\"判斷是否已滿\"\"\"\n        return self.count == self.k\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    result = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args)\n            result.append(None)\n        elif cmd == \"insertFront\":\n            result.append(obj.insertFront(*args))\n        elif cmd == \"insertLast\":\n            result.append(obj.insertLast(*args))\n        elif cmd == \"deleteFront\":\n            result.append(obj.deleteFront(*args))\n        elif cmd == \"deleteLast\":\n            result.append(obj.deleteLast(*args))\n        elif cmd == \"getFront\":\n            result.append(obj.getFront(*args))\n        elif cmd == \"getRear\":\n            result.append(obj.getRear(*args))\n        elif cmd == \"isEmpty\":\n            result.append(obj.isEmpty(*args))\n        elif cmd == \"isFull\":\n            result.append(obj.isFull(*args))\n        else:\n            result.append(None)\n\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a circular deque. Each line: virtual code step + // explanation. Use Start, End, Decision. No actual code. Should design initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Use steps. We'll produce a flowchart-like pseudocode. We'll mention internal array, front, rear indices, count. Use actions. Provide explanation each line.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCircularDeque 類別 // 建立資料結構的類別框架\n→ Step 2: 宣告成員變數：容量 k、陣列 buffer、前指標 front、後指標 rear、已填數量 size // 存放核心資料與狀態\n→ Decision: 進入建構子 MyCircularDeque(k) ? // 準備初始化\n    Yes → Step 3: 設定 this.k = k // 記錄最大容量\n    → Step 4: 建立 buffer = new Array(k) // 為元素預留空間\n    → Step 5: 設定 front = 0, rear = 0, size = 0 // 初始化指標與計數\n    → End // 建構子完成\n→ Decision: 執行 insertFront(x) ? // 進行前端插入\n    Yes →\n        → Decision: 是否已滿? isFull()? // 檢查是否可容納新元素\n            Yes → Step 6: 回傳 false // 無法插入，已滿\n            No →\n                → Step 7: front = (front - 1 + k) % k // 往前移動前指標（環形）\n                → Step 8: buffer[front] = x // 放入新元素\n                → Step 9: size += 1 // 更新已填數量\n                → Step 10: 回傳 true // 插入成功\n    No →\n→ Decision: 執行 insertLast(x) ? // 進行後端插入\n    Yes →\n        → Decision: 是否已滿? isFull()?\n            Yes → Step 11: 回傳 false // 無法插入，已滿\n            No →\n                → Step 12: buffer[rear] = x // 放入新元素\n                → Step 13: rear = (rear + 1) % k // 往後移動後指標（環形）\n                → Step 14: size += 1 // 更新已填數量\n                → Step 15: 回傳 true // 插入成功\n    No →\n→ Decision: 執行 deleteFront() ? // 刪除前端元素\n    Yes →\n        → Decision: 是否為空? isEmpty()?\n            Yes → Step 16: 回傳 false // 無法刪除，空\n            No →\n                → Step 17: front = (front + 1) % k // 往後移動前指標\n                → Step 18: size -= 1 // 更新已填數量\n                → Step 19: 回傳 true // 刪除成功\n    No →\n→ Decision: 執行 deleteLast() ? // 刪除後端元素\n    Yes →\n        → Decision: 是否為空? isEmpty()?\n            Yes → Step 20: 回傳 false // 無法刪除，空\n            No →\n                → Step 21: rear = (rear - 1 + k) % k // 往前移動後指標（環形）\n                → Step 22: size -= 1 // 更新已填數量\n                → Step 23: 回傳 true // 刪除成功\n    No →\n→ Decision: 執行 getFront() ? // 取得前端值\n    Yes →\n        → Decision: 是否為空? isEmpty()?\n            Yes → Step 24: 回傳 -1 // 空時返回 -1\n            No →\n                → Step 25: 回傳 buffer[front] // 返回前端元素\n    No →\n→ Decision: 執行 getRear() ? // 取得後端值\n    Yes →\n        → Decision: 是否為空? isEmpty()?\n            Yes → Step 26: 回傳 -1 // 空時返回 -1\n            No →\n                → Step 27: idx = (rear - 1 + k) % k // 後端實際位置\n                → Step 28: 回傳 buffer[idx] // 返回後端元素\n    No →\n→ Decision: 執行 isEmpty() ? // 判斷是否為空\n    Yes →\n        → Step 29: 回傳 (size == 0) // 若計數為零則為空\n    No →\n→ Decision: 執行 isFull() ? // 判斷是否為滿\n    Yes →\n        → Step 30: 回傳 (size == k) // 若計數等於容量則為滿\n    No →\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptmtad0ap.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmptmtad0ap.py\", line 44, in main\n    result = complex_number_multiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptmtad0ap.py\", line 26, in complex_number_multiply\n    a_real, a_imag = parse_complex(a)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptmtad0ap.py\", line 17, in parse_complex\n    imag_part = int(s[sep_index:])\n                ^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '+-1'"
        }
      ],
      "generated_code": "import sys\n\ndef parse_complex(s: str):\n    \"\"\"將 'real+imaginaryi' 字串解析為 (real, imaginary) 整數對\"\"\"\n    s = s.strip().strip('\"')  # 移除外部引號與空白\n    if s.endswith('i'):\n        s = s[:-1]          # 去掉末尾的 'i'\n    # 找到實部與虛部之間的分隔符號，從索引 1 開始尋找 '+' 或 '-'\n    sep_index = None\n    for i in range(1, len(s)):\n        if s[i] in '+-':\n            sep_index = i\n            break\n    if sep_index is None:\n        raise ValueError(f\"無法解析複數字串: {s}\")\n    real_part = int(s[:sep_index])\n    imag_part = int(s[sep_index:])\n    return real_part, imag_part\n\ndef format_complex(real: int, imag: int) -> str:\n    \"\"\"將實部、虛部轉回 'real+imaginaryi' 的字串格式\"\"\"\n    return f\"{real}+{imag}i\"\n\ndef complex_number_multiply(a: str, b: str) -> str:\n    \"\"\"計算兩個複數字串相乘並回傳結果字串\"\"\"\n    a_real, a_imag = parse_complex(a)\n    b_real, b_imag = parse_complex(b)\n\n    # (a+bi)(c+di) = (ac - bd) + (ad + bc)i\n    real_part = a_real * b_real - a_imag * b_imag\n    imag_part = a_real * b_imag + a_imag * b_real\n\n    return format_complex(real_part, imag_part)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 以逗號分隔兩個複數字串，若逗號被空格或換行包住則改用空白分隔\n    parts = [p.strip() for p in data.replace(',', ' ').split()]\n    if len(parts) < 2:\n        raise ValueError(\"輸入格式錯誤，應包含兩個複數字串\")\n    num1, num2 = parts[0], parts[1]\n    result = complex_number_multiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Let's design algorithm:\n\n1. Start\n2. Parse complex string into real and imaginary integers for num1 and num2\n3. Multiply: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i\n4. Format result string as \"real+imaginaryi\"\n5. End\n\nParsing: string format \"real+imaginaryi\" but imaginary may be negative? They said imaginary part integer in range [-100,100], but string could be \"3-4i\"? Typically format is \"real+imaginaryi\" with plus sign always? Could be \"3-4i\". We'll parse by removing trailing 'i', find plus or minus between real and imaginary.\n\nWe'll produce steps.\n\nLet's write virtual code:\n\nStart // program start\n→ Step 1: input num1, num2 // receive two complex strings\n→ Step 2: ParseComplex(num1) → a, b // get real and imaginary parts of num1\n→ Step 3: ParseComplex(num2) → c, d // get real and imaginary parts of num2\n→ Step 4: realResult = a * c - b * d // compute real part of product\n→ Step 5: imagResult = a * d + b * c // compute imaginary part of product\n→ Step 6: resultString = FormatComplex(realResult, imagResult) // create output string\n→ End // finish\n\nNow need to detail ParseComplex and FormatComplex as separate steps:\n\nWe'll include sub-steps:\n\nStep 2: ParseComplex(num) → realPart, imagPart\n  → Remove trailing 'i'\n  → Find position of '+' or '-' (except the first char if negative real)\n  → Split into realStr and imagStr\n  → Convert to integer\n  → Return\n\nSimilarly FormatComplex:\n\nStep 6: FormatComplex(real, imag)\n  → If imag >= 0 → sign '+'\n  → Else sign '-' (imag is negative, but string includes '-')\n  → result = real + sign + abs(imag) + 'i'\n  → Return\n\nAlso handle zero imaginary? They want \"real+0i\" probably.\n\nWe'll produce line-by-line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 `num1` 與 `num2` // 從使用者處取得兩個複數字串  \n→ Step 2: ParseComplex(`num1`) → `a`, `b` // 解析第一個複數，取得實部 `a` 與虛部 `b`  \n&nbsp;&nbsp;→ Remove trailing `'i'` from `num1` // 去除字串最後的 i  \n&nbsp;&nbsp;→ Find the position of the separator `'+'` or `'-'` (excluding a leading `-`) // 找出實部與虛部之間的符號  \n&nbsp;&nbsp;→ Split into `realStr` 和 `imagStr` // 將字串分成實部和虛部兩段  \n&nbsp;&nbsp;→ Convert `realStr` → integer `a` // 把實部字串轉成整數  \n&nbsp;&nbsp;→ Convert `imagStr` → integer `b` // 把虛部字串轉成整數  \n→ Step 3: ParseComplex(`num2`) → `c`, `d` // 解析第二個複數，取得實部 `c` 與虛部 `d`  \n&nbsp;&nbsp;→（同 Step 2 的子步驟，處理 `num2`）  \n→ Step 4: `realResult` = `a * c - b * d` // 計算乘法結果的實部 (ac - bd)  \n→ Step 5: `imagResult` = `a * d + b * c` // 計算乘法結果的虛部 (ad + bc)  \n→ Step 6: FormatComplex(`realResult`, `imagResult`) → `resultString` // 將結果轉成字串格式  \n&nbsp;&nbsp;→ If `imagResult` ≥ 0 → `sign` = `'+'`  \n&nbsp;&nbsp;→ Else → `sign` = `'-'`  \n&nbsp;&nbsp;→ `absImag` = absolute value of `imagResult` // 取得虛部的正整數值  \n&nbsp;&nbsp;→ `resultString` = `realResult` + `sign` + `absImag` + `'i'` // 組成 \"real+imagi\"  \n→ End // 程式執行結束\n\n> 這段虛擬碼逐行說明了從輸入複數字串解析到計算乘積再格式化輸出的完整流程。"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"找出所有內容重複的檔案路徑，返回以列表組成的列表。\"\"\"\n        content_map = defaultdict(list)  # content -> list of full paths\n\n        for path in paths:\n            parts = path.split()          # 第一段是目錄，後面是檔案描述\n            root = parts[0]\n            for file_info in parts[1:]:\n                # 解析檔名與內容\n                name, content = file_info.split('(')\n                content = content[:-1]  # 去掉最後的 ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # 只保留重複出現的內容\n        return [paths for paths in content_map.values() if len(paths) > 1]\n\ndef main():\n    # 讀取 stdin，並解析成 Python 的 list\n    raw_input = sys.stdin.read().strip()\n    if raw_input.startswith(\"paths\"):\n        # 形如 'paths = [ ... ]'\n        _, list_str = raw_input.split(\"=\", 1)\n        paths = ast.literal_eval(list_str.strip())\n    else:\n        # 直接給 list 字串\n        paths = ast.literal_eval(raw_input)\n\n    solution = Solution()\n    duplicate_groups = solution.findDuplicate(paths)\n    print(duplicate_groups)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find duplicate files. Provide step-by-step algorithm in plain virtual code lines with explanations. No actual code. Format: line with virtual code and // explanation. Use arrows. Need to parse input list, map content to file paths, group duplicates. Also final output groups. We'll produce steps like:\n\nStart\n→ Step 1: Initialize map contentToPaths as empty dictionary // map content to list of file paths\n→ Step 2: For each pathString in paths // iterate over each directory info\n    → Decision: If pathString contains spaces? // split into directory and files\n        Yes → Step 3: Split pathString by spaces // get directory part and file parts\n        No  → Step 4: (should not happen) skip // just in case\n    → Step 5: For each filePart in fileParts // process each file\n        → Step 6: Parse filePart to get fileName and content // find '(' and ')'\n        → Step 7: Build fullPath = directory + \"/\" + fileName // construct full path\n        → Step 8: If content not in map, add empty list // ensure entry\n        → Step 9: Append fullPath to map[content] // store path\n→ Step 10: Initialize result as empty list // list of duplicate groups\n→ Decision: If map size 0? // nothing to process\n    No → Step 11: For each content, pathsList in map\n        → Decision: If length(pathsList) > 1? // only duplicates\n            Yes → Step 12: Append pathsList to result // add group\n            No  → Step 13: continue // skip\n→ End // return result\n\nBut need to output \"返回結果\" step: maybe Step 14: Return result // output groups\n\nAdd comments. Use arrow syntax. Use Indentation? Use arrows with decisions.\n\nLet's write each line with virtual code and comment.\n\nWe'll produce maybe 15 lines.\n\nWe should be careful with syntax: \"→ Step X: ...\" Each line with arrow. Use \"Decision:\" for decisions. Use indentation for nested lines: maybe indent 4 spaces? In example they indent under Decision. We'll do similarly.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 contentToPaths // 用來將檔案內容對應到所有相同內容的檔案路徑  \n→ Step 2: 對於每一個 inputPathString in paths // 逐一處理每個目錄資訊字串  \n    → Decision: inputPathString 是否含有空白？ // 判斷是否能被分割成目錄與檔案清單  \n        Yes → Step 3: 分割 inputPathString 為 directoryPart 與 fileParts // 以空格為分隔符，第一段為目錄路徑，其餘為檔案描述  \n        No → Step 4: 跳過此行 // 若格式不符，直接忽略  \n    → Step 5: 對於每一個 filePart in fileParts // 逐一處理每個檔案描述  \n        → Step 6: 從 filePart 找出 '(' 與 ')' 的位置，提取 fileName 與 fileContent // 解析檔名與內容  \n        → Step 7: 組合 fullPath = directoryPart + \"/\" + fileName // 得到完整檔案路徑  \n        → Decision: contentToPaths 是否已包含 key fileContent？  \n            Yes → Step 8: 直接將 fullPath 加入 contentToPaths[fileContent] 的清單  \n            No → Step 9: 建立新清單 contentToPaths[fileContent] = [fullPath] // 若是第一次遇到此內容  \n→ Step 10: 建立空清單 result // 用於儲存重複檔案組別  \n→ Decision: contentToPaths 是否為空？  \n    Yes → Step 11: 結束程式，返回空列表 // 沒有任何檔案資訊  \n    No → Step 12: 對於每一個 content, pathsList in contentToPaths // 逐一檢查內容對應的路徑清單  \n        → Decision: len(pathsList) > 1？ // 是否至少有兩個檔案相同  \n            Yes → Step 13: 把 pathsList 加入 result // 將重複檔案組別加入結果  \n            No → Step 14: 繼續 // 跳過非重複的檔案  \n→ Step 15: Return result // 回傳所有重複檔案路徑的組別  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[6]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[6]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[10,3]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[10, 3]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,2,8]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 2, 8]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport random\n\ndef rand7() -> int:\n    \"\"\"模擬給定的 rand7 API，產生 1~7 的均勻隨機整數。\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"使用 rand7 產生 1~10 的均勻隨機整數。\"\"\"\n        while True:\n            # 兩次呼叫 rand7，產生 1~49 的均勻分布\n            a = rand7()\n            b = rand7()\n            num = (a - 1) * 7 + b          # 1 ~ 49\n            if num <= 40:                  # 只保留 1~40 的區間\n                return 1 + (num - 1) % 10  # 轉成 1~10\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 n，呼叫 rand10 n 次，並輸出結果列表。\"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    solver = Solution()\n    result = [solver.rand10() for _ in range(n)]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for rand10() using rand7(). Standard approach: generate a uniform in 1..49 via two rand7 calls (7*7). Then if result <= 40 use mod 10. Else discard and repeat. Use rejection sampling. Let's craft pseudocode lines.\n\nStart rand10 function: generate x = (rand7() - 1) * 7 + (rand7() - 1) + 1? Actually we can map 1..49. Use: a = rand7(); b = rand7(); x = (a - 1)*7 + b; // x in 0..48, then add 1 to get 1..49. Then if x <= 40, return (x % 10) + 1; else repeat.\n\nImplement loop until success. Use While True. Let's produce steps.\n\nAlso we need explain each line. Use virtual arrows and decisions.\n\nLet's write:\n\nStart // begin function rand10\n→ Step 1: 從 rand7() 取得第一個隨機數 a // a ∈ [1,7]\n→ Step 2: 從 rand7() 取得第二個隨機數 b // b ∈ [1,7]\n→ Step 3: 計算 x = (a-1)*7 + b // x ∈ [1,49]\n→ Decision: 是否 x ≤ 40? // 判斷是否在可接受區間\n    Yes → Step 4: 回傳 (x mod 10) + 1 // 產生 1..10\n    No  → Step 5: 重複 Step 1-4 // 拒絕重試\nEnd // 結束\n\nBut we need to show loop. Could use While True. Show decision at loop start: Decision: 是否已得到有效值? else repeat. Let's craft more formal.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 循環開始 // 進入重試循環\n    → Decision: 是否已生成有效的 rand10? // 檢查是否有結果\n        No  → Step 2: a ← rand7() // 取得第一個隨機數\n        No  → Step 3: b ← rand7() // 取得第二個隨機數\n        No  → Step 4: x ← (a-1)*7 + b // 組合成 1..49\n        No  → Decision: x ≤ 40? // 檢查是否可接受\n            Yes → Step 5: result ← (x mod 10) + 1 // 轉成 1..10\n            Yes → Step 6: 回傳 result // 回傳成功結果\n            No  → Step 7: 重新回到 Step 1 // 重新嘗試\nEnd // 程式執行結束\n\nBut maybe better to show loop as while true. Use Decision: 成功? else repeat.\n\nSimplify:\n\nStart\n→ Loop: // 重試直到成功\n    → Step 1: a ← rand7()\n    → Step 2: b ← rand7()\n    → Step 3: x ← (a-1)*7 + b\n    → Decision: x ≤ 40?\n        Yes → Step 4: return (x mod 10) + 1\n        No  → No → // 失敗，循環重試\nEnd\n\nWe need each line with arrow. Use \"→\" before each line. Indentation maybe.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Loop: // 進入重試循環，直到得到有效結果\n    → Step 1: a ← rand7() // 取得第一個隨機數 a，範圍 1~7\n    → Step 2: b ← rand7() // 取得第二個隨機數 b，範圍 1~7\n    → Step 3: x ← (a-1)*7 + b // 組合成 1~49 的隨機數 x\n    → Decision: x ≤ 40? // 判斷 x 是否落在可接受區間\n        Yes → Step 4: result ← (x mod 10) + 1 // 轉換為 1~10 的隨機數\n        Yes → Step 5: return result // 回傳成功結果並結束循環\n        No  → No → // x > 40，拒絕此樣本，重回 Loop 重新嘗試\nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        # 計算兩點之距離平方\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        # 兩兩計算距離平方\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n\n        # 判斷四條邊長相等且正，兩條對角線長相等且為 2 倍邊長\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 從輸入中提取所有整數\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) != 8:\n        print(\"false\")\n        sys.exit(0)\n\n    p1 = [nums[0], nums[1]]\n    p2 = [nums[2], nums[3]]\n    p3 = [nums[4], nums[5]]\n    p4 = [nums[6], nums[7]]\n\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to determine if four points form a square. Steps: compute all pairwise distances squared, sort, check 4 equal small distances >0, and 2 equal large distances, and large = 2*small. Also verify all distances are >0. The input order arbitrary. So we produce pseudo algorithm.\n\nWe need to output line by line virtual code steps with explanation. Use arrows and decisions. Format:\n\nStart // 程式開始執行\n→ Step 1: 讀取四個點 p1, p2, p3, p4 // 取得輸入\n→ Step 2: 建立空陣列 distances // 用來存距離平方\n→ Step 3: 對每一對點計算距離平方並加入 distances // 兩兩計算\n→ Step 4: 排序 distances // 方便分辨小長和大長\n→ Decision: distances長度是否為6? // 應有6個距離\n    Yes → Continue\n    No  → Step 5: 回傳 False // 不是四點\n→ Decision: 最小四個距離是否相等且>0? // 检查四条边\n    Yes → Continue\n    No  → Step 6: 回傳 False // 不是四边相等\n→ Decision: 最後兩個距離是否相等? // 检查對角线相等\n    Yes → Continue\n    No  → Step 7: 回傳 False\n→ Decision: 兩個大距離是否等於2倍小距離? // 直角验证\n    Yes → Step 8: 回傳 True\n    No  → Step 9: 回傳 False\nEnd\n\nBut need to use decision nodes with arrows Yes→, No→.\n\nWe also need to compute distances: 6 combos: p1-p2, p1-p3, p1-p4, p2-p3, p2-p4, p3-p4.\n\nPseudo code: Use for loops.\n\nWe can break into steps: For each pair: compute dx,dy; dist_sq = dx*dx+dy*dy; add to array.\n\nThen sort.\n\nThen checks.\n\nWe need to use \"Step\" numbering maybe.\n\nWe need to include explanation after //.\n\nMake sure each line ends with explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取四個點 p1, p2, p3, p4 // 取得輸入座標  \n→ Step 2: 初始化空陣列 distances // 用來儲存兩兩點之距離平方  \n→ Step 3: 迭代所有 6 個點對  \n→   Decision: 當前對為 (pi, pj)? // 判斷是第幾對點  \n→     Yes → Step 4: 計算 dx = pi.x - pj.x, dy = pi.y - pj.y // 求座標差  \n→     Yes → Step 5: 計算 dist_sq = dx*dx + dy*dy // 距離平方  \n→     Yes → Step 6: 將 dist_sq 加入 distances // 存進陣列  \n→ Step 7: 對 distances 進行排序 // 使相等距離相鄰  \n→ Decision: distances 長度是否為 6? // 應有六個距離  \n→   Yes → Continue // 符合數量  \n→   No  → Step 8: 回傳 False // 不是四點或重複點  \n→ Decision: 前四個距離是否相等且大於 0? // 四邊長相等且非零  \n→   Yes → Continue  \n→   No  → Step 9: 回傳 False // 不是正方形的邊長  \n→ Decision: 最後兩個距離是否相等? // 對角線長度相等  \n→   Yes → Continue  \n→   No  → Step 10: 回傳 False // 不是正方形的對角線  \n→ Decision: 最後兩個距離是否等於 2 倍前四個距離? // 直角檢查  \n→   Yes → Step 11: 回傳 True // 四邊相等且角度 90°，為正方形  \n→   No  → Step 12: 回傳 False // 角度非 90°  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnha10pxk.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpnha10pxk.py\", line 13, in main\n    raise ValueError(\"輸入格式不正確，應包含 price、special、needs 三個列表\")\nValueError: 輸入格式不正確，應包含 price、special、needs 三個列表"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpftvk38bl.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpftvk38bl.py\", line 13, in main\n    raise ValueError(\"輸入格式不正確，應包含 price、special、needs 三個列表\")\nValueError: 輸入格式不正確，應包含 price、special、needs 三個列表"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom functools import lru_cache\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找出所有形如 [ ... ] 的子字串\n    lists = re.findall(r'\\[[^\\]]*\\]', data)\n    if len(lists) != 3:\n        raise ValueError(\"輸入格式不正確，應包含 price、special、needs 三個列表\")\n    price = ast.literal_eval(lists[0])\n    special = ast.literal_eval(lists[1])\n    needs = ast.literal_eval(lists[2])\n\n    n = len(price)\n\n    @lru_cache(maxsize=None)\n    def dfs(curr_needs: tuple[int, ...]) -> int:\n        # 先算不使用任何特價的價格\n        cost = sum(curr_needs[i] * price[i] for i in range(n))\n\n        # 嘗試所有特價方案\n        for offer in special:\n            # 檢查此特價能否使用\n            new_needs = []\n            for i in range(n):\n                if curr_needs[i] < offer[i]:\n                    break\n                new_needs.append(curr_needs[i] - offer[i])\n            else:  # 所有項目都能扣除\n                offer_cost = offer[-1] + dfs(tuple(new_needs))\n                if offer_cost < cost:\n                    cost = offer_cost\n        return cost\n\n    result = dfs(tuple(needs))\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We need to design algorithm: state space DP with memoization. We'll implement DFS with memo. Represent needs as tuple. For each state, compute cost without offers. Then try offers if applicable. Use recursion. We'll output pseudocode lines.\n\nLet's produce steps: Start, input price, needs, special. We'll use DFS function with memo dict. Steps: define DFS(state). Base: cost= sum(state[i]*price[i]). Then loop offers: check if offer can be applied: for each item j, state[j] >= offer[j]. If yes, newState = state[j]-offer[j]. Recurse: cost = min(cost, offerPrice + DFS(newState)). End loops. Return cost. Then call DFS(initialNeeds). End. Also include memoization: store result for state. Also mention using tuple for key.\n\nWe need to output each line of virtual code. Let's produce around maybe 30-40 lines. Use arrow formatting.\n\nWe must include \"虛擬碼步驟\" + space + comment. Each line. Use arrow \"→\" for steps, \"Decision:\" for condition, \"Yes →\", \"No →\" for branches. We'll structure as described. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Load input: price[], needs[], special[][] // 取得物品價格、需求數量及特價資訊  \n→ Define memo: dict // 用於記錄已計算狀態的最低價格  \n\n→ Define DFS(state: tuple[int]) → int // 以需求向量為鍵的遞迴函式  \n    → Decision: 是否已存在 memo[state]?  \n        Yes → Return memo[state] // 若已計算，直接回傳  \n        No  → Continue  \n\n    → Step: 計算不使用任何特價時的價格  \n        cost ← Σ state[i] * price[i] // 逐項乘以價格求和  \n\n    → For each offer in special: // 逐一嘗試每個特價方案  \n        → Step: 判斷此特價能否套用於當前需求  \n        → Decision: 對所有項目 j: state[j] ≥ offer[j]?  \n            Yes →  \n                → Step: 建立新需求向量 newState  \n                newState[j] ← state[j] - offer[j] for all j // 減去特價包含的數量  \n                → Step: 取得套用此特價後的價格  \n                offerCost ← offer[n] + DFS(newState) // 特價價格加遞迴結果  \n                → Decision: offerCost < cost?  \n                    Yes → cost ← offerCost // 若更便宜則更新  \n                    No  → // 保持現有 cost  \n            No  → // 特價不適用，跳過  \n\n    → memo[state] ← cost // 儲存結果  \n    → Return cost // 返回此需求向量的最低價格  \n\n→ 初始需求向量 initState ← tuple(needs) // 轉成可哈希的元組  \n→ 最終結果 ← DFS(initState) // 取得購買全部需求的最低費用  \n→ Output 最終結果 // 顯示最小花費  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar II",
      "source_file": "Leetcode/leetcode731.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpge3osoaz.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpge3osoaz.py\", line 54, in main\n    res = calendar.book(start, end)\n          ^^^^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'book'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCalendarTwo:\n    def __init__(self):\n        self.booked = []   # 存放所有已預訂的區間\n        self.overlaps = [] # 存放所有雙重重疊的區間\n\n    def book(self, start: int, end: int) -> bool:\n        # 先檢查是否會產生三重預訂\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n        # 若沒問題，將新的雙重重疊區間加入 overlaps\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n        # 最後把這個事件加入已預訂區間\n        self.booked.append((start, end))\n        return True\n\ndef parse_input():\n    \"\"\"解析 stdin，取得 ops 與 args 的兩個列表。\"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return [], []\n    # 先嘗試直接分割為兩行\n    lines = raw.splitlines()\n    if len(lines) >= 2:\n        ops_str = lines[0].strip()\n        args_str = lines[1].strip()\n    else:\n        # 單行輸入：兩個列表以 '],' 分隔\n        split_idx = raw.find('],')\n        if split_idx == -1:\n            ops_str, args_str = raw, '[]'\n        else:\n            ops_str = raw[:split_idx + 1].strip()\n            args_str = raw[split_idx + 2:].strip()\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n    return ops, args\n\ndef main():\n    ops, args = parse_input()\n    results = [None]  # 第一個操作為建構子，對應輸出 null\n    calendar = None\n    for i, op in enumerate(ops[1:], 1):\n        if op == \"MyCalendarTwo\":\n            calendar = MyCalendarTwo()\n            results.append(None)  # 建構子對應 null\n        elif op == \"book\":\n            start, end = args[i]\n            res = calendar.book(start, end)\n            results.append(res)\n        else:\n            # 若未處理的操作，直接輸出 None\n            results.append(None)\n    # 將結果轉成 JSON 風格的字串並輸出\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MyCalendarTwo. We should output line by line, each line with virtual code step followed by // explanation. Use Start, End, Decision, etc. We cannot output actual code. Provide logic: maintain intervals and double bookings. Approach: store all events, maintain double bookings. On book: iterate over existing events, count overlaps, if any overlap leads to triple, reject. Simpler: keep two lists: intervals and overlapping intervals (double). On booking, check triple: for each interval in double, if overlaps with new event => triple, reject. Else, add to intervals; then for each existing interval, if overlaps new event, add overlapped interval to double. Provide steps.\n\nWe need to output in virtual code. Provide high-level algorithm. Use arrow structure.\n\nLet's produce:\n\nStart\n→ Initialize empty list events\n→ Initialize empty list overlaps\n→ Function book(start, end)\n    → For each (s, e) in overlaps\n        → Decision: if overlap between [start,end) and [s,e) exists? \n            Yes → Return false // triple booking\n            No → Continue\n    → For each (s, e) in events\n        → Decision: if overlap between [start,end) and [s,e) exists?\n            Yes → Determine overlapped interval [max(start,s), min(end,e))\n            → Add overlapped interval to overlaps\n            No → Continue\n    → Add [start,end) to events\n    → Return true\nEnd\n\nAdd explanation comments.\n\nLet's produce with virtual code arrow. Each line: \"Start // 程式開始\". Each arrow line: \"→ Step ... // ...\".\n\nNeed to use Decision: if condition? Then Yes → ... No → ... Format.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始\n→ Initialize events ← [] // 儲存所有已加入的單一事件區間\n→ Initialize overlaps ← [] // 儲存所有已知的雙重重疊區間\n\n→ Function book(start, end) // 嘗試新增事件 [start, end)\n    → Decision: 是否有現有雙重區間與新事件重疊? // 檢查是否會產生三重預訂\n        Yes → Return false // 重疊即代表三重預訂，拒絕新增\n        No  → // 若無即可進行下一步檢查\n    → For each (s, e) in events // 檢查新事件與所有已存在單一事件的重疊\n        → Decision: [start, end) 與 [s, e) 是否有重疊? // 判斷區間交集是否非空\n            Yes → Compute overlapStart ← max(start, s)\n                 Compute overlapEnd   ← min(end,   e)\n                 Add [overlapStart, overlapEnd) to overlaps // 記錄新增的雙重區間\n            No  → // 不重疊，無需處理\n    → Add [start, end) to events // 將新事件正式加入\n    → Return true // 成功新增，未產生三重預訂\n\nEnd // 程式結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmponrpc5gj.py\", line 44, in <module>\n    args_list = ast.literal_eval(data[1])    # 例如 [[],[\"foo\",\"bar\",1],[\"foo\",1],...]\n                                 ~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\nfrom collections import defaultdict\nimport ast\n\nclass TimeMap:\n    \"\"\"\n    時間基礎鍵值資料結構\n    以每個 key 對應一個時間戳和值的升序列表\n    \"\"\"\n    def __init__(self):\n        # key -> [(timestamp, value), ...]\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        \"\"\"\n        將 key 在給定 timestamp 時存入 value\n        \"\"\"\n        # 直接把 (timestamp, value) 加到對應列表\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        \"\"\"\n        取得 <= timestamp 的最大時間戳對應值\n        若無，回傳空字串\n        \"\"\"\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 在 (timestamp, chr(127)) 位置右側，確保找到第一個 > timestamp 的位置\n        idx = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if idx == 0:\n            return \"\"\n        return arr[idx - 1][1]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取兩行：操作列表與參數列表\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    ops = ast.literal_eval(data[0])          # 例如 [\"TimeMap\",\"set\",\"get\",...]\n    args_list = ast.literal_eval(data[1])    # 例如 [[],[\"foo\",\"bar\",1],[\"foo\",1],...]\n\n    tm = None\n    output = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"TimeMap\":\n            tm = TimeMap()\n            output.append(None)              # 初始化不輸出任何值\n        elif op == \"set\":\n            # set(key, value, timestamp)\n            tm.set(*args)\n            output.append(None)\n        elif op == \"get\":\n            # get(key, timestamp)\n            result = tm.get(*args)\n            output.append(result)\n        else:\n            # 若有其他操作，直接忽略或可自行處理\n            output.append(None)\n\n    # 以 JSON 格式輸出結果，None 會轉成 null\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step. The user wants a design of time-based key-value data structure, like Leetcode 981 TimeMap. We need to produce pseudocode with steps: Start, End, Decision, etc. Should be line-by-line, each line \"虛擬碼步驟 // 解釋\". Use arrow, etc. No actual code, only structure. Must include the TimeMap class and its methods, including data structure.\n\nWe need to produce virtual code. Steps: initialization of a map from key to list of (timestamp, value). set: append. get: binary search. Should include decision steps.\n\nWe need to follow the format exactly: \"Start // 程式開始執行\", etc. So the output will be a list of lines each with a virtual code step and explanation.\n\nLet's design:\n\nStart\n→ Step 1: 定義 TimeMap 類 // 定義類別\n→ Step 2: 宣告 data: Map<string, List<(int, string)>> // 記錄每個鍵的時間戳和值\nTimeMap() // 建構子\n→ Step 3: 初始化 data 為空 Map // 建構子內容\n\nset(key, value, timestamp)\n→ Step 4: 如果 data 中不存在 key，則建立空 List // 初始化\n→ Step 5: 將 (timestamp, value) 加入 key 對應的 List // 存入\n→ Step 6: 確保 List 按時間戳升序 // 由於插入按時間順序，可忽略\n\nget(key, timestamp)\n→ Step 7: 如果 data 中不存在 key，則返回 \"\" // 無值\n→ Step 8: 取得 List<...> list = data[key] // 取得列表\n→ Decision: list 是否為空？ // 判斷\n    Yes → Return \"\" // 空列表\n    No → Proceed\n\n→ Step 9: 使用二分搜尋找最大索引 i 使得 list[i].timestamp <= timestamp // 查找\n→ Decision: 是否找到符合條件的索引？ // 判斷\n    Yes → Return list[i].value // 回傳對應值\n    No → Return \"\" // 之前沒有任何時間戳\n\nEnd\n\nBut must use arrows and decision lines.\n\nLet's produce each line following the example. Each line must be one step. We can include multi-level decision. Use \"Decision:\".\n\nWe must incorporate \"→ Decision:\" line.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 定義 TimeMap 類 // 定義類別\n→ Step 2: 宣告 data: Map<string, List<(int, string)>> // 儲存每個鍵的時間戳和值\n→ TimeMap() // 建構子\n    → Step 3: 初始化 data 為空 Map // 建構子內容\n→ void set(String key, String value, int timestamp) // set 方法\n    → Step 4: 若 data 中不存在 key，建立空 List // 初始化該鍵\n    → Step 5: 將 (timestamp, value) 添加到 data[key] 的 List // 存入\n→ String get(String key, int timestamp) // get 方法\n    → Step 6: 若 data 中不存在 key，返回 \"\" // 無對應鍵\n    → Step 7: list ← data[key] // 取得該鍵的時間戳列表\n    → Decision: list 是否為空？ // 判斷\n        Yes → Return \"\" // 空列表，返回空字串\n        No  → Proceed\n    → Step 8: 使用二分搜尋找到最大索引 i，使 list[i].timestamp <= timestamp // 搜尋\n    → Decision: 是否找到符合條件的索引？ // 判斷\n        Yes → Return list[i].value // 返回對應值\n        No  → Return \"\" // 沒有小於等於 timestamp 的時間戳，返回空字串\nEnd // 程式執行結束\n\nBut we need each line separate with arrow? The example shows each line starts with \"→\". For nested lines, maybe indent.\n\nWe need to maintain format: \"虛擬碼步驟 [空格] // 解釋\". Each line can have \"→\" arrow before the step. For decisions, \"→ Decision:\".\n\nWe should not output code, just structure.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TimeMap 類 // 定義類別  \n→ Step 2: 宣告 data: Map<string, List<(int, string)>> // 儲存每個鍵對應的時間戳和值列表  \n→ TimeMap() // 建構子  \n    → Step 3: 初始化 data 為空 Map // 建構子內部操作  \n→ void set(String key, String value, int timestamp) // set 方法宣告  \n    → Step 4: 若 data 中不存在 key，建立空 List // 為新鍵初始化列表  \n    → Step 5: 將 (timestamp, value) 添加到 data[key] 的 List // 存入值與時間戳  \n→ String get(String key, int timestamp) // get 方法宣告  \n    → Step 6: 若 data 中不存在 key，返回 \"\" // 無此鍵直接回傳空字串  \n    → Step 7: list ← data[key] // 取得該鍵的時間戳列表  \n    → Decision: list 是否為空？ // 判斷列表是否有資料  \n        Yes → Return \"\" // 空列表，回傳空字串  \n        No  → Proceed // 列表非空，繼續搜尋  \n    → Step 8: 使用二分搜尋找到最大索引 i，使 list[i].timestamp <= timestamp // 查找符合條件的時間戳  \n    → Decision: 是否找到符合條件的索引？ // 判斷搜尋結果  \n        Yes → Return list[i].value // 回傳對應值  \n        No  → Return \"\" // 沒有小於等於 timestamp 的時間戳，回傳空字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"Reorder nums into wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3] ...\"\"\"\n        n = len(nums)\n        for i in range(n - 1):\n            if i % 2 == 0:\n                # Even index: should be less than the next element\n                if nums[i] >= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            else:\n                # Odd index: should be greater than the next element\n                if nums[i] <= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    # Extract the list of integers from the input\n    match = re.search(r'\\[([^\\]]*)\\]', data)\n    if match:\n        nums_str = match.group(1).strip()\n        if nums_str:\n            nums = [int(x.strip()) for x in nums_str.split(',')]\n        else:\n            nums = []\n    else:\n        nums = []\n\n    # Perform wiggle sort\n    solution = Solution()\n    solution.wiggleSort(nums)\n\n    # Output the resulting list\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format. The requirement: reorder array into wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3]... Standard approach: sort and then swap adjacent pairs? Actually common solution: iterate i from 0 to n-2: if (i%2==0 && nums[i] >= nums[i+1]) swap; else if (i%2==1 && nums[i] <= nums[i+1]) swap. That ensures pattern. Or use sort then pair high-low. We'll use simple swapping approach.\n\nWe need to output line by line with \"Start\" and \"End\" etc. Use arrow \"→\". Provide explanation after //.\n\nWe need to output code steps: reading array? The function signature? We can show steps: Start; Step 1: Determine length n; Step 2: For i from 0 to n-2: ... etc. Then End.\n\nLet's produce virtual steps. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow arrow.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 取得陣列長度 n = nums.Length // 取得輸入陣列的長度\n→ Step 2: 對 i 從 0 到 n-2 逐一迭代 // 準備進行相鄰元素比較與交換\n    → Decision: 如果 i 為偶數? // 判斷索引是否為偶數，決定比較符號\n        Yes → Decision: 若 nums[i] ≥ nums[i+1]? // 偶數索引需小於下一個，若不滿足則交換\n            Yes → Step 3: 交換 nums[i] 與 nums[i+1] // 交換以確保 nums[i] < nums[i+1]\n            No  → No op // 已符合條件，無需交換\n        No  → Decision: 若 nums[i] ≤ nums[i+1]? // 奇數索引需大於下一個，若不滿足則交換\n            Yes → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以確保 nums[i] > nums[i+1]\n            No  → No op // 已符合條件，無需交換\n→ Step 5: 輸出/返回修改後的 nums // 結束時陣列已達到wiggle排列\nEnd // 程式執行結束\n\nMake sure each line has arrow and explanation. For nested decisions, we can indent? The example uses indentation with tab. We'll replicate that.\n\nAlso we need \"No op\" step? But they didn't specify. We could just skip. But keep as \"No op\" to indicate nothing happens. Or we can skip those lines. Simpler: don't include No op lines. Instead just not add step. But the example uses Yes and No branches. But we can show No branch with \"No → No op\". Keep.\n\nAlso Step numbers maybe incremental. Use Step 1, Step 2, etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n = nums.Length // 取得輸入陣列的長度  \n→ Step 2: 對 i 從 0 到 n-2 逐一迭代 // 準備進行相鄰元素比較與交換  \n → Decision: i 為偶數? // 判斷索引是否為偶數，決定比較符號  \n  Yes → Decision: 若 nums[i] ≥ nums[i+1]? // 偶數索引需小於下一個，若不滿足則交換  \n   Yes → Step 3: 交換 nums[i] 與 nums[i+1] // 交換以確保 nums[i] < nums[i+1]  \n   No  → No op // 已符合條件，無需交換  \n  No  → Decision: 若 nums[i] ≤ nums[i+1]? // 奇數索引需大於下一個，若不滿足則交換  \n   Yes → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以確保 nums[i] > nums[i+1]  \n   No  → No op // 已符合條件，無需交換  \n→ Step 5: 輸出/返回修改後的 nums // 結束時陣列已達到 wiggle 排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      '[\"dogcatsdog\", \"catsdogcats\", \"ratcatdogcat\"]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # Sort words by length (shorter first) so that when we check a word,\n        # all possible component words are already in the set.\n        words.sort(key=len)\n        word_set = set()          # set of words that can be used as components\n        result = []\n\n        # Helper function that uses DP to check if a word can be formed\n        # by concatenating at least two words from word_set.\n        def can_form(word: str) -> bool:\n            n = len(word)\n            dp = [False] * (n + 1)\n            dp[0] = True  # empty prefix is always reachable\n            for i in range(1, n + 1):\n                for j in range(i):\n                    if not dp[j]:\n                        continue\n                    if word[j:i] in word_set:\n                        dp[i] = True\n                        break\n            return dp[n]\n\n        for word in words:\n            if not word:  # skip empty strings if any\n                continue\n            if can_form(word):\n                result.append(word)\n            word_set.add(word)\n\n        return result\n\ndef main():\n    # Read all input from stdin.  The input may be like:\n    # words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # If the input starts with \"words\", strip that part.\n    if data.startswith(\"words\"):\n        _, _, rest = data.partition(\"=\")\n        data = rest.strip()\n    # Safely parse the list using ast.literal_eval.\n    try:\n        words = ast.literal_eval(data)\n    except Exception as e:\n        # If parsing fails, exit silently.\n        return\n    # Ensure we have a list of strings.\n    if not isinstance(words, list):\n        return\n\n    solution = Solution()\n    concatenated_words = solution.findAllConcatenatedWordsInADict(words)\n    # Print the result as a JSON array to match expected double‑quote format.\n    print(json.dumps(concatenated_words))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the problem: given array of strings words (no duplicates), return all concatenated words in the list. A concatenated word is comprised of at least two shorter words from the list. Need virtual code steps, line by line, with explanation. Must use Start, End, Decision, arrow, etc. Provide algorithm: sort by length, use set for prefix search, DP to check if word can be formed by concatenation. Steps: Start, Sort words by length ascending. Initialize result list, word set. For each word in sorted list: if canForm(word, set): add to result; add word to set. canForm uses DP. Decision inside canForm: for each i from 1 to len-1, if substring[0:i] in set and DP[i] true then DP[i+len(substring)] etc. But we need virtual code. So we break into steps: Step 1: Sort words by length. Step 2: Initialize result, set. Step 3: For each word in sorted list, check canForm. Step 4: If canForm true, add to result. Step 5: Add word to set. Step 6: End.\n\nThe canForm function: Step 1: Initialize boolean array dp length+1 false, dp[0]=true. Step 2: For i from 1 to len(word): for j from 0 to i: if dp[j] true and substring j-i in set: dp[i]=true break. Step 3: Return dp[len]. But virtual code line by line.\n\nWe can structure with decisions: Decision: If i==len? etc. But simpler: We'll write pseudocode lines. Use arrow for loops: → For each word: ...; inside loops.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". So need to keep simple.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 words 按字串長度升序排序 // 先處理較短的字，方便後續判斷  \n→ Step 2: 建立空集合 wordSet 及空列表 result // wordSet 用於快速查找子字串，result 存放最終答案  \n→ For each word in sorted words: // 逐一檢查每個字串  \n  Decision: 如果 canForm(word, wordSet) 為 True? // 判斷此字是否可由兩個以上短字串組成  \n   Yes → Step 3: 把 word 加入 result // 是連接詞，加入結果集  \n   No  → // 不是連接詞，什麼都不做  \n  End Decision  \n  Step 4: 把 word 加入 wordSet // 無論是否連接詞，都加入集合供後續檢查使用  \n→ End For  \n→ End // 程式執行結束  \n\n// ---------- canForm 函式 ----------  \nStart canForm(word, wordSet) // 函式開始  \n→ Step 5: 建立布林陣列 dp，長度為 word.length + 1，並把 dp[0] 設為 True // dp[i] 表示前 i 個字可否被拆解  \n→ For i from 1 to word.length: // 逐個位置檢查  \n  Decision: 如果 dp[i] 已經為 True? // 已經找到可拆解方式，直接跳過  \n   Yes → Continue // 進入下一個 i  \n   No  → // 尚未確認，可嘗試拆分  \n    For j from 0 to i-1: // 嘗試所有前綴位置 j  \n     Decision: 如果 dp[j] 為 True 且 word[j:i] 在 wordSet? // 前綴可拆解且後綴在集合  \n      Yes → Step 6: 設置 dp[i] 為 True，Break inner loop // 找到合法拆分，結束內層迴圈  \n      No  → // 不合法，繼續嘗試下一個 j  \n    End Decision  \n    End For  \n  End Decision  \n→ End For  \n→ Decision: 如果 dp[word.length] 為 True? // 整個字可拆解  \n  Yes → Return True // 是連接詞  \n  No  → Return False // 不是連接詞  \n→ End Decision  \n→ End // canForm 函式結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            if parent.setdefault(x, x) != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root_first = find(first_email)\n                root_email = find(email)\n                parent[root_email] = root_first\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n        return result\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if raw_input.startswith(\"accounts\"):\n        idx = raw_input.find('[')\n        raw_input = raw_input[idx:]\n    try:\n        accounts = ast.literal_eval(raw_input)\n    except Exception:\n        accounts = []\n\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for merging accounts problem. Use arrow steps. Provide explanation. Let's craft algorithm: use DSU or graph. We'll produce generic algorithm.\n\nStep1: initialize mapping email->name, graph adjacency. Step2: for each account, connect emails. Step3: DFS each component to gather emails. Step4: sort and output. Provide Start/End.\n\nLet's produce lines. Use \"→\" to indicate action. Provide explanation comments.\n\nWe must follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrow.\n\nLet's write.\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 emailToName // 用於儲存每個 email 與對應姓名\n→ Step 2: 建立空字典 graph (email → set of connected emails) // 用於存儲 email 關係\n→ Decision: 是否有帳戶資料? // 檢查輸入是否為空\n    Yes → Step 3: 對於每個帳戶 account in accounts: // 逐個處理帳戶\n        → Step 4: 取 name = account[0] // 第一個字串為姓名\n        → Step 5: 對於每個 email in account[1:]: // 後續為 email\n            → Step 6: emailToName[email] = name // 紀錄 email 對應姓名\n            → Step 7: 若 email 未在 graph 中, graph[email] = empty set // 初始化\n        → Decision: 是否至少有兩個 email? // 判斷是否需要連結\n            Yes → Step 8: email1 = account[1] // 取第一個 email 作為基準\n            → For each email in account[2:]: // 從第二個 email 開始\n                → Step 9: graph[email1].add(email) // 連結 email1 與 email\n                → Step 10: graph[email].add(email1) // 連結反向\n            No  → // 只有一個 email, 無需連結\n→ Step 11: 建立空集合 visited // 追蹤已訪問 email\n→ Step 12: 建立空列表 mergedAccounts // 儲存合併後帳戶\n→ Decision: 是否有未訪問的 email? // 遍歷所有 email\n    Yes → Step 13: 若 email not in visited: // 找到未訪問的 email\n        → Step 14: 建立空列表 componentEmails // 收集同一個連通分量的 email\n        → Step 15: 建立堆疊 stack = [email] // DFS 開始\n        → Decision: 是否有堆疊元素? // DFS\n            Yes → Step 16: cur = stack.pop()\n                → Decision: cur 是否已訪問? // 判斷\n                    Yes → // 跳過\n                    No  → Step 17: visited.add(cur) // 標記已訪問\n                            → Step 18: componentEmails.add(cur) // 收集 email\n                            → Step 19: 將 cur 的鄰居加入堆疊\n            No  → // DFS 完成\n        → Step 20: 取 name = emailToName[componentEmails[0]] // 取任意 email 的姓名\n        → Step 21: 將 componentEmails 排序\n        → Step 22: mergedAccounts.append([name] + componentEmails) // 加入合併帳戶\n    No  → // 所有 email 都已訪問\n→ Step 23: 回傳 mergedAccounts // 輸出結果\nEnd // 程式執行結束\n\nCheck format: each line must have virtual code step then space then comment. Use arrows inside? For decision branches we use indentation? They used in example indentation. We can indent lines under Decision. But keep same format. Ensure each line follows pattern: \"虛擬碼步驟 // 解釋\". For nested, still each line separate. So we need to indent lines for decision branches? In example they did indentation. Let's follow same style: indent lines after Decision with spaces. But each line still has virtual code then comment. Use \"    Yes → ...\" etc. We'll replicate.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空字典 emailToName // 用於儲存每個 email 與對應姓名\n→ Step 2: 建立空字典 graph (email → set of connected emails) // 用於存儲 email 關係\n→ Decision: 是否有帳戶資料? // 檢查輸入是否為空\n    Yes → Step 3: 對於每個帳戶 account in accounts: // 逐個處理帳戶\n        → Step 4: 取 name = account[0] // 第一個字串為姓名\n        → Step 5: 對於每個 email in account[1:]: // 後續為 email\n            → Step 6: emailToName[email] = name // 紀錄 email 對應姓名\n            → Step 7: 若 email 未在 graph 中, graph[email] = empty set // 初始化\n        → Decision: 是否至少有兩個 email? // 判斷是否需要連結\n            Yes → Step 8: email1 = account[1] // 取第一個 email 作為基準\n            → For each email in account[2:]: // 從第二個 email 開始\n                → Step 9: graph[email1].add(email) // 連結 email1 與 email\n                → Step 10: graph[email].add(email1) // 連結反向\n            No  → // 只有一個 email, 無需連結\n→ Step 11: 建立空集合 visited // 追蹤已訪問 email\n→ Step 12: 建立空列表 mergedAccounts // 儲存合併後帳戶\n→ Decision: 是否有未訪問的 email? // 遍歷所有 email\n    Yes → Step 13: 若 email not in visited: // 找到未訪問的 email\n        → Step 14: 建立空列表 componentEmails // 收集同一個連通分量的 email\n        → Step 15: 建立堆疊 stack = [email] // DFS 開始\n        → Decision: 是否有堆疊元素? // DFS\n            Yes → Step 16: cur = stack.pop()\n                → Decision: cur 是否已訪問? // 判斷\n                    Yes → // 跳過\n                    No  → Step 17: visited.add(cur) // 標記已訪問\n                            → Step 18: componentEmails.add(cur) // 收集 email\n                            → Step 19: 將 cur 的鄰居加入堆疊\n            No  → // DFS 完成\n        → Step 20: 取 name = emailToName[componentEmails[0]] // 取任意 email 的姓名\n        → Step 21: 將 componentEmails 排序\n        → Step 22: mergedAccounts.append([name] + componentEmails) // 加入合併帳戶\n    No  → // 所有 email 都已訪問\n→ Step 23: 回傳 mergedAccounts // 輸出結果\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[None,6,1,1,1,0,6,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[None, 6, 1, 1, 1, 0, 6, 0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        \"\"\"\n        建構子：將可用範圍 [0, n-1] 中不在 blacklist 的數字映射。\n        \"\"\"\n        self.size = n - len(blacklist)          # 可用數字個數\n        self.mapping = {}                       # 黑名單中落於 [0, size-1] 的數字映射到合法高值\n        black_set = set(blacklist)\n        last = n - 1                            # 從最高數字開始尋找合法高值\n        for b in blacklist:\n            if b < self.size:                   # 只需要映射低範圍的黑名單\n                while last in black_set:        # 跳過高範圍的黑名單\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        \"\"\"\n        隨機挑選一個合法數字。\n        \"\"\"\n        idx = random.randint(0, self.size - 1)  # 只呼叫一次 random\n        return self.mapping.get(idx, idx)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取兩行，第一行是方法名稱列表，第二行是對應的參數列表\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    methods = ast.literal_eval(data[0])        # e.g. [\"Solution\", \"pick\", \"pick\"]\n    args_list = ast.literal_eval(data[1])      # e.g. [[7, [2, 3, 5]], [], [], ...]\n\n    instance = None\n    outputs = []\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            instance = Solution(*args)\n            outputs.append(None)               # 建構子對應輸出 None\n        else:\n            # 呼叫實例方法，並將結果加入輸出列表\n            result = getattr(instance, method)(*args)\n            outputs.append(result)\n\n    print(outputs)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for algorithm: given n and blacklist, we need to pick random integer from [0, n-1] not in blacklist. Want minimal random calls. Known solution: map blacklisted numbers in [0, n-1] that are in [0, n-m-1] (where m = len(blacklist)) to whitelist numbers in [n-m, n-1] that are not blacklisted. Build mapping dictionary from blacklisted in low range to allowed in high range. Then pick random from [0, n-m-1] and map if in dict. Complexity O(m) preprocess, O(1) pick.\n\nWe need to produce step-by-step pseudo-code lines with explanation, no actual code. Use Start, End, Decision. Provide each line: \"Step X: ...\" etc.\n\nLet's produce algorithm description:\n\nStart\n\n→ Step 1: Set m = length(blacklist) // number of blacklisted elements\n\n→ Step 2: Compute whiteCount = n - m // number of valid integers\n\n→ Step 3: Initialize empty map M // for remapping\n\n→ Step 4: Initialize pointer w = n - 1 // start from highest value\n\n→ Step 5: For each b in blacklist:\n\n    Decision: If b < whiteCount? // low-range blacklisted?\n\n        Yes → While w in blacklist: decrement w // skip blacklisted high values\n\n        Yes → M[b] = w // map low b to valid high w\n\n        Yes → w = w - 1\n\n        No → // b is in high range; ignore\n\n→ Step 6: Define pick() method:\n\n    → Step 6.1: Generate r = random integer in [0, whiteCount - 1] // one random call\n\n    → Step 6.2: Decision: If r in M? // check mapping\n\n        Yes → Return M[r] // mapped to allowed high value\n\n        No  → Return r // r itself is allowed\n\nEnd\n\nNeed to present each line with \"虛擬碼步驟\" and explanation.\n\nMake sure each line includes arrow and explanation. Use proper arrow formatting. Use \"→\" for continuation. For decisions, indent.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: m = length(blacklist) // 取得黑名單長度\n\n→ Step 2: whiteCount = n - m // 有效整數個數\n\n→ Step 3: M = empty map // 建立映射表\n\n→ Step 4: w = n - 1 // 從最高數字開始\n\n→ Step 5: For each b in blacklist: // 迭代黑名單\n\n    Decision: b < whiteCount? // 是否低於有效範圍\n\n        Yes → While w in blacklist: w = w - 1 // 找到一個未被黑名單的高值\n\n        Yes → M[b] = w // 建立映射\n\n        Yes → w = w - 1 // 移動指標\n\n        No  → // b 在高範圍，無需映射\n\n→ Step 6: Define pick(): // pick 方法\n\n    → Step 6.1: r = randomInt(0, whiteCount - 1) // 產生一個隨機整數\n\n    → Step 6.2: Decision: r in M? // 檢查是否需要映射\n\n        Yes → Return M[r] // 返回映射後的合法數字\n\n        No  → Return r // r 本身已合法\n\nEnd // 程式結束\n\nMake sure each line ends with // explanation.\n\nAlso use \"Start\" and \"End\" labels.\n\nWe should keep line numbers? Not necessary.\n\nAlso ensure to use arrow \"→\" after step. For decision lines, indent with spaces.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m = length(blacklist) // 取得黑名單長度  \n→ Step 2: whiteCount = n - m // 估算可用整數個數  \n→ Step 3: M = empty map // 建立黑名單到合法數字的映射表  \n→ Step 4: w = n - 1 // 從最高數字開始尋找可用值  \n→ Step 5: For each b in blacklist: // 逐一處理黑名單中的數字  \n&nbsp;&nbsp;Decision: b < whiteCount? // 判斷 b 是否落在可用範圍內  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → While w in blacklist: w = w - 1 // 找到一個未被黑名單覆蓋的高值  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → M[b] = w // 將低值 b 映射到高值 w  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → w = w - 1 // 指標往下移動，準備下一個映射  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → // b 已在高範圍，無需映射，直接略過  \n→ Step 6: Define pick(): // 定義選取隨機數字的方法  \n&nbsp;&nbsp;→ Step 6.1: r = randomInt(0, whiteCount - 1) // 一次隨機呼叫，產生合法範圍內的整數  \n&nbsp;&nbsp;→ Step 6.2: Decision: r in M? // 判斷是否需要映射  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return M[r] // 透過映射取得合法數字  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Return r // r 本身已合法，直接返回  \nEnd // 程式結束執行"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.4968330608360257,-0.4133115970604428],[-0.5865431770367067,0.5242202115156406],[0.0006003367861898048,-0.6639906562596182]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.4968330608360257, -0.4133115970604428], [-0.5865431770367067, 0.5242202115156406], [0.0006003367861898048, -0.6639906562596182]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport math\nimport json\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # Generate a random point uniformly inside the circle\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行是方法名稱列表，第二行是對應的參數列表\n    methods = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    obj = None\n    outputs = []\n\n    for method, args in zip(methods, args_list):\n        if method == 'Solution':\n            obj = Solution(*args)\n            outputs.append(None)  # Constructor returns null\n        elif method == 'randPoint':\n            result = obj.randPoint()\n            outputs.append(result)\n\n    # 使用 json.dumps 來輸出，None 會轉成 null，數字保持浮點格式\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating random point inside a circle uniformly. Steps: initialize radius, center. randPoint: generate random radius r with sqrt uniform [0,1] times radius. Generate angle θ uniform [0,2π). Compute x = center_x + r cosθ, y = center_y + r sinθ. Return [x,y].\n\nWe must produce step-by-step virtual code, each line with // explanation. Use Start, End, Decision: arrows etc. Should include the class definition and methods. No actual code. Use virtual steps.\n\nWe need to describe initialization and randPoint. Use steps. Use \"Start\" at beginning of class? We can start with Start, Step: create class. But structure: Start, Step: define class. Inside, Step: store radius and center. Then randPoint method: Step: generate random uniform variable u, v; compute r = sqrt(u)*radius; angle = 2π*v; compute coordinates; return. Should we include decisions? Not needed. But maybe we can show if statement: if radius 0? Not necessary.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n\n→ Step 1: 定義類別 Solution // 建立Solution類別\n\n→ Step 2: 在建構子中存儲 radius, x_center, y_center // 初始化圓的參數\n\n→ Step 3: 定義方法 randPoint() // 生成隨機點\n\n→ Step 4: 產生兩個均勻隨機數 u, v 在 [0,1) // 用於生成半徑和角度\n\n→ Step 5: 計算 r = sqrt(u) * radius // 調整半徑以保持面積均勻分布\n\n→ Step 6: 計算 θ = 2π * v // 隨機角度\n\n→ Step 7: 計算 x = x_center + r * cos(θ) // 轉換為座標\n\n→ Step 8: 計算 y = y_center + r * sin(θ) // 轉換為座標\n\n→ Step 9: 回傳 [x, y] // 結果\n\nEnd // 程式執行結束\n\nBut maybe we need to include virtual code for class definition? We can treat each step as part of virtual code. We'll output lines exactly with the format. Provide arrows only for steps.\n\nNo actual code. So it's okay.\n\nWe might include \"Decision\" but not necessary.\n\nWe should ensure each line has exactly the format: \"虛擬碼步驟 // 解釋\". So \"Start // 程式開始執行\" etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 在建構子中存儲 radius、x_center、y_center // 初始化圓的半徑與中心座標  \n→ Step 3: 定義方法 randPoint() // 產生隨機點的函式  \n→ Step 4: 產生兩個均勻隨機數 u、v，範圍 [0,1) // 用於生成半徑與角度  \n→ Step 5: 計算 r = sqrt(u) * radius // 調整半徑以確保面積均勻分佈  \n→ Step 6: 計算 θ = 2π * v // 隨機角度  \n→ Step 7: 計算 x = x_center + r * cos(θ) // 轉換為座標系中的 X  \n→ Step 8: 計算 y = y_center + r * sin(θ) // 轉換為座標系中的 Y  \n→ Step 9: 回傳 [x, y] // 給出隨機點  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[2,2,_,_]'\nGot (Norm):      '2,nums=[2,2,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '2, nums = [2,2,_,_]'\nRaw Got:      \"2, nums = [2, 2, '_', '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,3,0,4,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,\"_\",\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,3,0,4,_,_,_]'\nRaw Got:      \"5, nums = [0, 1, 3, 0, 4, '_', '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除 nums 中所有等於 val 的元素，並返回新長度 k。\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中提取 nums 列表與 val 整數。\n    輸入範例：'nums = [3,2,2,3], val = 3'\n    \"\"\"\n    # 取出 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not nums_match:\n        raise ValueError(\"Missing nums list in input\")\n    nums_str = nums_match.group(1)\n    nums = eval(nums_str)  # 轉成 list\n\n    # 取出 val 整數\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if not val_match:\n        raise ValueError(\"Missing val in input\")\n    val = int(val_match.group(1))\n\n    return nums, val\n\ndef format_output(nums, k):\n    \"\"\"\n    產生符合範例格式的輸出字串。\n    例：'2, nums = [2,2,_,_]'\n    \"\"\"\n    display = []\n    for i in range(len(nums)):\n        if i < k:\n            display.append(nums[i])\n        else:\n            display.append('_')\n    return f\"{k}, nums = {display}\"\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    nums, val = parse_input(raw)\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n    out = format_output(nums, k)\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line with explanations, following format.\n\nTask: Remove element val from array in-place and return new length k.\n\nAlgorithm typical two-pointer: keep index writeIndex, iterate readIndex. If nums[read]!=val, set nums[writeIndex]=nums[read]; increment writeIndex. After loop return writeIndex.\n\nWe must produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 writeIndex = 0 // ...\n→ Step 2: 循環遍歷 nums // ...\n    → Decision: 如果 nums[read] ≠ val? // ...\n        Yes → Step 3: nums[writeIndex] = nums[read] // ...\n             → Step 4: writeIndex++ // ...\n    No → // 不做任何事\n...\n\nAfter loop return writeIndex.\n\nWe should produce virtual code lines only, no actual code. Use arrow and labels. Also include End. Also need to mention that remaining elements are irrelevant.\n\nLet's produce step by step:\n\nStart\n→ Step 1: 設定 writeIndex = 0 // write pointer\n→ Step 2: 針對每個元素 nums[read] 循環 // read pointer\n    → Decision: nums[read] != val? // 檢查是否要保留\n        Yes → Step 3: nums[writeIndex] = nums[read] // 將元素搬到寫指標位置\n        → Step 4: writeIndex++ // 移動寫指標\n        No → // 若等於 val，直接跳過\n→ Step 5: 回傳 writeIndex // 新長度 k\nEnd\n\nNeed to follow exact format: each line \"虛擬碼步驟 [空格] // 解釋/說明\"\n\nAlso indentation not necessary but maybe we show arrow within.\n\nWe need to include Start, End.\n\nWe need to use \"Decision:\" structure. Should show Yes →, No →.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 writeIndex = 0 // 初始化寫指標，指向下一個可放置元素的位置\n→ Step 2: 針對每個元素 nums[read] 循環 // read 指標從 0 遍歷整個陣列\n    → Decision: nums[read] != val? // 判斷當前元素是否需要保留\n        Yes → Step 3: nums[writeIndex] = nums[read] // 把非 val 元素搬到寫指標位置\n        → Step 4: writeIndex++ // 移動寫指標至下一個位置\n        No  → // 若元素為 val，直接跳過，寫指標不變\n→ Step 5: 回傳 writeIndex // writeIndex 即為新陣列長度 k\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,1,3],[1,2,3],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 1, 3], [1, 2, 3], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    \"\"\"\n    提供 reset 與 shuffle 的功能，使用 Fisher‑Yates 洗牌演算法確保所有排列等機率。\n    \"\"\"\n    def __init__(self, nums):\n        # 先將傳入的陣列做深拷貝，避免外部修改影響內部狀態\n        self.original = list(nums)\n        self.current = list(nums)\n\n    def reset(self):\n        \"\"\"重設陣列回原始順序，並回傳重設後的陣列\"\"\"\n        self.current = list(self.original)\n        return self.current\n\n    def shuffle(self):\n        \"\"\"隨機打亂陣列，並回傳打亂後的陣列\"\"\"\n        shuffled = list(self.current)\n        n = len(shuffled)\n        # Fisher‑Yates 洗牌\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\n\ndef main():\n    # 讀取整個輸入，預期為 \"commands, arguments\" 兩個列表之間以逗號分隔\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 將輸入包裝成一個元組，使用 literal_eval 進行安全解析\n    try:\n        commands, arguments = ast.literal_eval(f'({raw})')\n    except Exception:\n        # 若解析失敗，直接退出\n        return\n\n    results = []\n    obj = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            # 建立新的物件\n            obj = Solution(arg[0])  # arg 會是 [nums]\n            results.append(None)  # 依照 LeetCode 規範返回 null\n        elif cmd == \"reset\":\n            res = obj.reset()\n            results.append(res)\n        elif cmd == \"shuffle\":\n            res = obj.shuffle()\n            results.append(res)\n        else:\n            # 未知指令，視為 None\n            results.append(None)\n\n    # 將結果輸出為 JSON，None 會轉為 null\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Use Start, End, Decision, etc. We need to include class structure and methods.\n\nWe'll describe initialization storing original array, shuffle using Fisher-Yates.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 定義私有變數原始陣列 originalNums, 目前陣列 currentNums // 用於保存原始順序與當前順序  \n→ Step 3: 定義建構子 Solution(nums) // 初始化時設定陣列  \n  → Step 4: originalNums ← 複製 nums // 复制原始数组  \n  → Step 5: currentNums ← 複製 nums // 初始化当前数组为原始数组  \n→ Step 6: 定義方法 reset() // 重置陣列  \n  → Step 7: currentNums ← 複製 originalNums // 恢复到原始順序  \n  → Step 8: 返回 currentNums // 返回重置后的数组  \n→ Step 9: 定義方法 shuffle() // 隨機打亂陣列  \n  → Step 10: len ← currentNums.length // 獲取陣列長度  \n  → Decision: 需要進行 Fisher-Yates 交換？ // 檢查是否需要進行交換  \n   Yes → Loop i from len-1 down to 1 // 從尾到頭進行迴圈  \n     → Step 11: randIdx ← 隨機數 0 到 i  // 隨機選取交換位置  \n     → Step 12: temp ← currentNums[i] // 暫存 i 處元素  \n     → Step 13: currentNums[i] ← currentNums[randIdx] // 把隨機位置元素放到 i 處  \n     → Step 14: currentNums[randIdx] ← temp // 把 i 處元素放到隨機位置  \n     → Step 15: 迴圈結束 // 迴圈結束  \n     → Step 16: 返回 currentNums // 返回打亂後的陣列  \n   No  → Step 17: 返回 currentNums // 若長度 <=1，直接返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\ndef parse_input(data: str):\n    \"\"\"Extract list from a string like 'nums = [1,2,3]'.\"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    list_str = data[start:end+1]\n    return ast.literal_eval(list_str)\n\ndef format_subsets(subsets):\n    \"\"\"Return string representation without spaces, e.g., '[[],[1],[2]]'.\"\"\"\n    parts = []\n    for sub in subsets:\n        if not sub:\n            parts.append('[]')\n        else:\n            parts.append('[' + ','.join(map(str, sub)) + ']')\n    return '[' + ','.join(parts) + ']'\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    nums = parse_input(raw)\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(format_subsets(result))",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for generating power set. Use Start, Decision, etc. No actual code. Each line: Virtual code step + space + // explanation. Format: `→ Step X: ... // ...`. Use Start and End. Need to handle recursion or iterative. Let's design iterative using bitmask or backtracking. Provide pseudocode. Provide steps like: Start, initialize result, define backtrack(index, current). Decision: if index == length, add copy. Else: Decision: include element? Yes → add element, backtrack(index+1,...); No → skip, backtrack(index+1,...). End. Also handle output. Provide explanation per line.\n\nMake sure to include lines for initialization of result, starting backtrack, and final return. Use arrow and decisions. Provide explanation comments in Chinese. Ensure each line has `//` comment. Provide only lines.\n\nLet's produce.\n\nAlso we might need to explain using bitmask? But I'll use backtracking because easier.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: 定義空陣列 subsets 以存放所有子集 // 初始化結果容器\n→ Step 2: 呼叫遞迴函式 backtrack(0, []) // 從索引 0 開始搜尋\n→ Decision: 在 backtrack(index, current) 中，若 index == nums.length? // 判斷是否已處理完所有元素\n    Yes → Step 3: subsets.append(current.copy()) // 加入目前子集到結果\n    No  → Step 4: Decision: 是否將 nums[index] 加入 current? // 選擇是否包含當前元素\n        Yes → Step 5: current.append(nums[index]) // 加入元素\n        → Step 6: backtrack(index+1, current) // 進入下一層遞迴\n        → Step 7: current.pop() // 回溯，移除剛加入的元素\n        No  → Step 8: backtrack(index+1, current) // 不包含元素，直接遞迴\n→ Step 9: Return subsets // 回傳所有子集\nEnd // 程式結束\n\nBut we need each line as separate line with arrow. Should be careful to format: For decisions, indent.\n\nAlso each line must be: `→ Step ...` for actions. For decisions, use `Decision:`. For example: `→ Decision: ...` or `Decision: ...`? According to example: `→ Decision: 如果數字大於 0?` and inside we indent with `Yes → ...` and `No  → ...`. So we can follow that.\n\nSo produce lines:\n\nStart // 程式開始執行\n→ Step 1: subsets = [] // 初始化結果容器\n→ Step 2: backtrack(0, []) // 開始遞迴\n→ Decision: index == len(nums)? // 判斷是否已遍歷完所有元素\n    Yes → Step 3: subsets.append(copy_of_current) // 加入子集\n    No  → Decision: include_current? // 決定是否包含 nums[index]\n        Yes → Step 4: current.append(nums[index]) // 加入元素\n        → Step 5: backtrack(index+1, current) // 遞迴\n        → Step 6: current.pop() // 回溯\n        No  → Step 7: backtrack(index+1, current) // 跳過元素遞迴\n→ Step 8: return subsets // 回傳結果\nEnd // 程式結束\n\nBut need \"Step\" numbers sequentially. For the decisions inside we don't need Step numbers? In example they don't have Step numbers for decisions inside. They use \"Decision:\" lines. So we can just keep that.\n\nAlso need to include Step 1 for initialization. Step 2 for start recursion. Then decisions etc.\n\nAlso we need to show \"copy_of_current\" maybe using \"current.copy()\". Use explanation.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: subsets = [] // 初始化結果容器，用於存放所有子集  \n→ Step 2: backtrack(0, []) // 從索引 0 開始遞迴搜尋  \n→ Decision: index == len(nums)? // 判斷是否已處理完所有元素  \n&nbsp;&nbsp;&nbsp;Yes → Step 3: subsets.append(current.copy()) // 把目前子集的複製加入結果  \n&nbsp;&nbsp;&nbsp;No → Decision: 是否包含 nums[index]? // 決定是否把當前元素加入子集  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: current.append(nums[index]) // 加入元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: backtrack(index+1, current) // 遞迴至下一層  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: current.pop() // 回溯，移除剛加入的元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: backtrack(index+1, current) // 不包含元素，直接遞迴  \n→ Step 8: return subsets // 回傳所有生成的子集  \nEnd // 程式結束"
    },
    {
      "title": "Course Schedule",
      "source_file": "Leetcode/leetcode207.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpknssamk4.py\", line 38, in <module>\n    prerequisites = ast.literal_eval(prereqs_str)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk5w_led6.py\", line 38, in <module>\n    prerequisites = ast.literal_eval(prereqs_str)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        \n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n        \n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n        \n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return visited == numCourses\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().replace('\\n', '').replace('\\r', '')\n    if not data:\n        sys.exit(0)\n    # Expected format: numCourses = X, prerequisites = [[...]]\n    parts = data.split(',')\n    num_courses_part = parts[0].strip()\n    prereqs_part = parts[1].strip()\n\n    numCourses = int(num_courses_part.split('=')[1].strip())\n    prereqs_str = prereqs_part.split('=')[1].strip()\n    prerequisites = ast.literal_eval(prereqs_str)\n\n    result = Solution().canFinish(numCourses, prerequisites)\n    print('true' if result else 'false')",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for determining if all courses can be finished given prerequisites. This is essentially checking if graph has cycle. Approach: build adjacency list, perform DFS or Kahn's algorithm. Provide virtual steps.\n\nUse Start, Decision, End. Show reading inputs, building graph, performing topological sort using Kahn's algorithm. Provide step lines.\n\nWe need to output only virtual code steps with explanation per line.\n\nWe'll produce:\n\nStart\n→ Step 1: Read numCourses and prerequisites array // get inputs\n→ Step 2: Initialize adjacency list and indegree array // prepare graph\n→ Step 3: For each pair [a,b] in prerequisites: add edge b->a and increment indegree[a] // build graph\n→ Decision: Check if any indegree > 0? (no need; proceed)\n→ Step 4: Initialize queue with courses having indegree 0 // start nodes\n→ Step 5: Set visitedCount = 0 // counter of courses processed\n→ Decision: While queue not empty? // process queue\n    Yes → Step 6: Dequeue course u // pop\n    → Step 7: Increment visitedCount // count processed\n    → Step 8: For each neighbor v of u: decrement indegree[v]; if indegree[v]==0 enqueue v // propagate\n    No  → End of loop\n→ Decision: visitedCount == numCourses? // all courses processed?\n    Yes → Step 9: Return true // can finish\n    No  → Step 10: Return false // cycle detected\nEnd\n\nMake sure to include arrow '→' and 'Decision:' lines.\n\nAlso include indentation to show nested steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 numCourses 與 prerequisites 陣列 // 取得課程數量與先修關係  \n→ Step 2: 初始化 adjacencyList[0…numCourses-1] 與 indegree[0…numCourses-1] 為 0 // 建立圖與入度  \n→ Step 3: 對於每個 pair [a,b] 在 prerequisites:  \n&nbsp;&nbsp;→ Add edge b → a to adjacencyList  \n&nbsp;&nbsp;→ indegree[a]++ // 記錄 a 的入度  \n→ Step 4: 建立 queue 并將所有 indegree[i]==0 的課程加入 queue // 從無依賴課程開始  \n→ Step 5: 設置 visitedCount = 0 // 已完成課程計數  \n→ Decision: queue 是否非空? // 需要處理課程  \n&nbsp;&nbsp;Yes → Step 6: Dequeue 頂點 u // 取出一個課程  \n&nbsp;&nbsp;→ Step 7: visitedCount++ // 計入已完成  \n&nbsp;&nbsp;→ Step 8: 對於每個鄰居 v 在 adjacencyList[u]:  \n&nbsp;&nbsp;&nbsp;&nbsp;→ indegree[v]-- // 解除一個依賴  \n&nbsp;&nbsp;&nbsp;&nbsp;→ 若 indegree[v]==0，則 enqueue v // 新課程可以開始  \n&nbsp;&nbsp;No → End // 迴圈結束  \n→ Decision: visitedCount == numCourses? // 是否所有課程都已完成？  \n&nbsp;&nbsp;Yes → Step 9: 回傳 true // 可完成所有課程  \n&nbsp;&nbsp;No  → Step 10: 回傳 false // 存在循環，無法完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 0, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將輸入包裝成一個有效的 JSON 陣列\n    wrapped = \"[\" + data + \"]\"\n    methods, args_list = json.loads(wrapped)\n\n    results = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            func = getattr(obj, method)\n            results.append(func(*args))\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to implement this function pickIndex. Need to include initialization precomputing prefix sums. Provide pickIndex logic: generate random number between 1 and total sum, binary search or linear search to find index where cumulative >= random. Provide steps. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End. Use Decision etc. Should include steps for constructor and pickIndex. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空陣列 prefix // 儲存前綴和  \n→ Step 2: 初始化 totalSum = 0 // 儲存 w 的總和  \n→ Step 3: Decision: w 是否為空? // 檢查輸入是否有效  \n    Yes → Step 4: Throw Exception 'Empty array' // 如果 w 為空，拋出錯誤  \n    No → Step 5: For i from 0 to w.length - 1 // 迭代 w 的每個元素  \n        → Step 6: totalSum += w[i] // 累加總和  \n        → Step 7: Append totalSum to prefix // 將累加值加入前綴和陣列  \n→ Step 8: Store totalSum 和 prefix 於物件狀態 // 以備 pickIndex 使用  \nEnd // 初始設定完成  \n\nStart // pickIndex() 開始執行  \n→ Step 9: 隨機產生一個整數 r 在 [1, totalSum] 之間 // 確保包含所有權重區間  \n→ Step 10: Decision: 使用二分搜尋找最小索引 i 使 prefix[i] >= r  \n    Yes → Step 11: Return i // 找到對應索引，返回給呼叫者  \n    No  → Step 12: Return -1 // 這裡理論上不會發生，作為安全備案  \nEnd // pickIndex() 執行結束"
    }
  ]
}