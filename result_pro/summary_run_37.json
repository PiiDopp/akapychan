{
  "run_index": 37,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 390,
  "generation_or_validation_failure_count": 49,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,1,4,5,1]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 1, 4, 5, 1]'"
        }
      ],
      "generated_code": "import random\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳所有結果的列表。\n\n    參數:\n        n (int): 擲骰的次數\n    返回:\n        list[int]: 每次擲骰得到的 1~6 整數\n    \"\"\"\n    results = []\n    for _ in range(n):\n        # random.randint(1, 6) 會產生 1~6 的整數\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼，並執行\n    import sys\n    user_code = sys.stdin.read()\n    # 執行使用者輸入的程式碼，`roll_dice` 在 globals() 已被定義\n    exec(user_code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with comments. No actual code, just pseudo. Use arrows. Should include import random. Then function definition, etc. Must follow format. Let's produce.\n\nWe need to start with Start. Then arrow to import random. Then arrow to define function roll_dice(n). Inside, initialize list. For loop from 1 to n. Inside loop: generate random int 1-6 using random.randint. Append to list. After loop, return list. End.\n\nUse Decision maybe not needed. We can include for loop as Step. Use arrow: Step 1: Define function. Step 2: Initialize results list. Step 3: For each roll. Step 4: Generate random int. Step 5: Append. Step 6: Return results.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Import random // 引入 random 模組以便產生隨機數\n→ Function: roll_dice(n) // 定義函數，參數 n 為擲骰次數\n    → Step 1: results ← [] // 建立空列表儲存每次擲骰結果\n    → Step 2: For i in 1 to n // 逐次擲骰\n        → Step 3: roll_value ← random.randint(1, 6) // 產生 1~6 的隨機整數\n        → Step 4: results.append(roll_value) // 將結果加入列表\n    → Step 5: Return results // 回傳所有擲骰結果的列表\nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行時間並回傳四捨五入到小數點三位的秒數。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    import sys\n    # 從標準輸入讀取整個程式碼，並執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with explanation, using arrows etc. Need to include \"Start\" and \"End\". We need to write a function measure_time(func, *args) that measures time, returns result rounded to 3 decimal places. Use time module.\n\nWe must produce virtual code steps line by line. For each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe should use arrow \"→\" and Decision. Probably we should include function definition start, import, then inside. We'll produce lines like:\n\nStart\n→ Step 1: 導入 time 模組 // 引入時間測量模組\n→ Step 2: 定義函數 measure_time(func, *args) // 定義測量時間的函數\n    → Step 3: 獲取開始時間 start_time = time.time() // 記錄開始時刻\n    → Step 4: 呼叫 func(*args) 並將結果存入 result // 執行傳入函數並取得結果\n    → Step 5: 獲取結束時間 end_time = time.time() // 記錄結束時刻\n    → Step 6: 計算耗時 elapsed = end_time - start_time // 取得執行時間差\n    → Step 7: 四捨五入時間 rounded_time = round(elapsed, 3) // 四捨五入到小數點三位\n    → Decision: 是否需要返回結果和時間？ // \n        Yes → Step 8: 返回 rounded_time, result // 返回時間與結果\n        No → Step 8: 返回 rounded_time // 若僅返回時間\n→ End // 函式結束\n\nBut we need to decide: spec says \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\" - likely means return elapsed time, not result? Actually \"並回傳結果\" ambiguous; maybe returns both? Could be returning the rounded time. Let's interpret: function should return elapsed time rounded to 3 decimal places. But maybe also return result? The spec says \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\" I think \"結果\" refers to elapsed time. So return the rounded elapsed time.\n\nThus no need to return result. So we produce Step 8: 返回 rounded_time // 回傳測量到的秒數\n\nWe need to mention function returns a float.\n\nLet's produce the steps accordingly.\n\nUse \"Start\" and \"End\".\n\nWe should not produce actual code but just virtual steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 導入 time 模組 // 引入 Python 的時間測量模組\n→ Step 2: 定義函數 measure_time(func, *args) // 建立測量時間的函式\n    → Step 3: start_time ← time.time() // 記錄開始時刻\n    → Step 4: result ← func(*args) // 執行傳入的函式並取得其返回值\n    → Step 5: end_time ← time.time() // 記錄結束時刻\n    → Step 6: elapsed ← end_time - start_time // 計算執行時間差\n    → Step 7: rounded ← round(elapsed, 3) // 四捨五入到小數點三位\n    → Step 8: 返回 rounded // 回傳測量到的秒數\nEnd // 程式執行結束\n\nBut we might need to use arrow notation properly: \"→\" after each line. Use \"Step\" names.\n\nAlso use \"Decision\" if needed. Not needed.\n\nOk.\n\nAlso we may include step numbers.\n\nLet's produce each line.\n\nLet's final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 導入 time 模組 // 引入 Python 的時間測量模組  \n→ Step 2: 定義函數 measure_time(func, *args) // 建立測量時間的函式  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3: start_time ← time.time() // 記錄開始時刻  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: result ← func(*args) // 執行傳入的函式並取得其返回值  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: end_time ← time.time() // 記錄結束時刻  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: elapsed ← end_time - start_time // 計算執行時間差  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: rounded ← round(elapsed, 3) // 四捨五入到小數點三位  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: 返回 rounded // 回傳測量到的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      '無（程式內建立）的分數是0'\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      '無（程式內建立） 的分數是 0'"
        }
      ],
      "generated_code": "class Student:\n    def __init__(self, name, score):\n        \"\"\"\n        建構子：接收姓名與分數，並存入物件屬性\n        \"\"\"\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        \"\"\"\n        印出學生姓名與分數\n        \"\"\"\n        print(f\"{self.name} 的分數是 {self.score}\")\n\n\ndef parse_input(lines):\n    \"\"\"\n    解析輸入，產生學生資料\n    允許以下兩種情況：\n    1. 空輸入：使用預設資料 (Alice 90, Bob 80)\n    2. 有輸入：每一行代表一位學生，格式為「姓名 分數」\n    \"\"\"\n    students = []\n\n    if not lines:\n        # 預設資料\n        students.append((\"Alice\", 90))\n        students.append((\"Bob\", 80))\n        return students\n\n    for line in lines:\n        if not line.strip():\n            continue  # 忽略空行\n        parts = line.strip().split()\n        # 名字可能包含空格，分數應為最後一項\n        score_part = parts[-1]\n        name_part = \" \".join(parts[:-1])\n        try:\n            score = int(score_part)\n        except ValueError:\n            # 若最後一項不是數字，則整行視為名字，分數預設為 0\n            name_part = line.strip()\n            score = 0\n        students.append((name_part, score))\n    return students\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 從標準輸入讀取所有行\n    raw_input = sys.stdin.read()\n    input_lines = raw_input.strip().splitlines()\n\n    # 解析成學生資料\n    student_data = parse_input(input_lines)\n\n    # 建立 Student 物件並顯示資訊\n    for name, score in student_data:\n        student = Student(name, score)\n        student.show_info()",
      "virtual_code": "Thinking...\nThe user wants a step-by-step pseudocode with explanations. Must use Start, End, Decision, etc. It's simple. Use \"虛擬碼步驟\" and comments. Must not output actual code. Provide steps:\n\nStart\n→ Define Class Student\n→ Step: Define __init__(self, name, score)\n→ Step: self.name = name\n→ Step: self.score = score\n→ Step: Define show_info(self)\n→ Step: Output f\"{self.name} 的分數是 {self.score}\"\n→ End of Class\n\nThen create instances:\n→ Step: s1 = Student(\"Alice\", 90)\n→ Step: s1.show_info()\n→ Step: s2 = Student(\"Bob\", 75)\n→ Step: s2.show_info()\nEnd\n\nBut need to include \"虛擬碼步驟\" phrase. Format: \"虛擬碼步驟 // 解釋\". Each line. Use arrows.\n\nSo:\n\nStart // 程式開始執行\n→ Define Class Student // 定義 Student 類別\n    → Step: 定義 __init__(self, name, score) // 建構子，接收姓名與分數\n        → Step: self.name = name // 儲存姓名屬性\n        → Step: self.score = score // 儲存分數屬性\n    → Step: 定義 show_info(self) // 定義顯示資訊方法\n        → Step: 輸出 f\"{self.name} 的分數是 {self.score}\" // 顯示姓名與分數\nEnd // End of Class\n\nBut we need \"End\" for the class? They used \"End\" for program. Might just end program. But we can add \"End Class Student\" but not necessary.\n\nLet's produce steps:\n\nStart // 程式開始執行\n→ Step: 定義 Class Student // 建立 Student 類別\n    → Step: 定義 __init__(self, name, score) // 初始化姓名與分數\n        → Step: self.name = name // 設定姓名屬性\n        → Step: self.score = score // 設定分數屬性\n    → Step: 定義 show_info(self) // 定義顯示資訊方法\n        → Step: 輸出 \"{self.name} 的分數是 {self.score}\" // 輸出姓名與分數\n→ Step: 建立物件 s1 = Student(\"Alice\", 90) // 創建第一個學生物件\n→ Step: s1.show_info() // 呼叫第一個物件的顯示方法\n→ Step: 建立物件 s2 = Student(\"Bob\", 75) // 創建第二個學生物件\n→ Step: s2.show_info() // 呼叫第二個物件的顯示方法\nEnd // 程式執行結束\n\nBut need use arrow \"→\" before each step. Yes. Each line with arrow then \"虛擬碼步驟\". Use indentation? The example shows indentation for decisions. We can indent lines under class definition? Use two spaces maybe.\n\nBetter to use indentation to show hierarchy. Use arrow at each line, but for steps under class, indent. Let's produce:\n\nStart // 程式開始執行\n→ Step: 定義 Class Student // 建立 Student 類別\n    → Step: 定義 __init__(self, name, score) // 初始化姓名與分數\n        → Step: self.name = name // 儲存姓名屬性\n        → Step: self.score = score // 儲存分數屬性\n    → Step: 定義 show_info(self) // 定義顯示資訊方法\n        → Step: 輸出 \"{self.name} 的分數是 {self.score}\" // 顯示姓名與分數\n→ Step: 建立物件 s1 = Student(\"Alice\", 90) // 創建第一個學生物件\n→ Step: s1.show_info() // 呼叫第一個物件的顯示方法\n→ Step: 建立物件 s2 = Student(\"Bob\", 75) // 創建第二個學生物件\n→ Step: s2.show_info() // 呼叫第二個物件的顯示方法\nEnd // 程式執行結束\n\nBut maybe include \"End\" after class? The example only uses End for program. It's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義 Class Student // 建立 Student 類別  \n  → Step: 定義 __init__(self, name, score) // 初始化姓名與分數  \n    → Step: self.name = name // 儲存姓名屬性  \n    → Step: self.score = score // 儲存分數屬性  \n  → Step: 定義 show_info(self) // 定義顯示資訊方法  \n    → Step: 輸出 \"{self.name} 的分數是 {self.score}\" // 顯示姓名與分數  \n→ Step: 建立物件 s1 = Student(\"Alice\", 90) // 創建第一個學生物件  \n→ Step: s1.show_info() // 呼叫第一個物件的顯示方法  \n→ Step: 建立物件 s2 = Student(\"Bob\", 75) // 創建第二個學生物件  \n→ Step: s2.show_info() // 呼叫第二個物件的顯示方法  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\nfrom tkinter import ttk\n\n# 取得美元兌台幣匯率，回傳浮點數，失敗時回傳 None\ndef get_rate():\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()                     # 任何非 200 的狀態碼都會拋例外\n        data = r.json()\n        rate = data['rates']['TWD']              # 取出 TWD 匯率\n        return float(rate)\n    except Exception:\n        return None\n\n# 在 tkinter 視窗中顯示匯率\ndef create_gui():\n    win = tk.Tk()\n    win.title('美元兌台幣匯率')\n\n    label = ttk.Label(win, text='請按下「更新匯率」按鈕', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label():\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f'目前美元匯率：約 {rate:.4f} TWD')\n        else:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    ttk.Button(win, text='更新匯率', command=update_label).pack(pady=5)\n\n    win.mainloop()\n\n# 主程式入口：讀取 stdin，處理並輸出結果；之後啟動 GUI\nif __name__ == '__main__':\n    # 讀取標準輸入\n    input_line = sys.stdin.readline().strip()\n    # 若輸入為「按下「更新匯率」按鈕」等文字，則執行匯率查詢並列印\n    if '更新匯率' in input_line:\n        rate = get_rate()\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate:.4f} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n    else:\n        # 若輸入不符合預期，僅輸出提示\n        print('未偵測到更新匯率指令')\n\n    # 啟動 tkinter GUI（若測試環境允許）\n    try:\n        create_gui()\n    except tk.TclError:\n        # 在無 GUI 環境下忽略錯誤\n        pass",
      "virtual_code": "Thinking...\nWe need to output line by line virtual code with explanations, using arrow symbols, no actual code. Use requests, tkinter, button, etc. Steps: Start, import modules, create main window, create label, create button with command to fetch rate, fetch function calls requests.get, parse JSON, get TWD, update label, handle errors, end. Use decision. Provide in Chinese. Use virtual code arrow. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests 與 tkinter 模組 // 準備 HTTP 請求和 GUI  \n→ Step 2: 建立主視窗 root // tkinter 視窗容器  \n→ Step 3: 建立顯示匯率的 Label，初始文字為 \"匯率：載入中...\" // 用來顯示結果  \n→ Step 4: 建立按鈕 btn，文字為 \"更新匯率\" // 使用者點擊更新  \n→ Step 5: 定義函式 fetch_rate() // 執行 API 呼叫並更新 Label  \n     → Decision: 是否可以連線至 https://api.exchangerate-api.com/v4/latest/USD?  \n       Yes → Step 6: 使用 requests.get 發送 GET 請求 // 取得 JSON  \n       No → Step 7: Label.text 設為 \"連線失敗，請稍後再試\" // 顯示錯誤  \n           \n        Yes → Decision: JSON 解析成功?  \n          Yes → Step 8: 從回傳資料中取出 rates.TWD // 取得匯率  \n            → Step 9: Label.text 設為 \"1 USD = {TWD} TWD\" // 顯示匯率  \n                     // 用戶看到最新匯率  \n             No → Step 10: Label.text 設為 \"解析失敗，請檢查回傳格式\" // 解析錯誤  \n                       \n        No → Step 11: Label.text 設為 \"請求失敗，HTTP 狀態碼: {status_code}\" // 顯示錯誤碼  \n→ Step 12: 把 fetch_rate 绑到 btn.command // 點擊按鈕時執行  \n→ Step 13: 在主循環中顯示視窗 root.mainloop() // 進入事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy9xygkd5.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmpy9xygkd5.py\", line 33, in main\n    commands = ast.literal_eval(m.group(1))\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], []\n                                                           ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport re\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Attempt to parse the two lists from the input\n    m = re.match(r'\\s*(\\[.*\\])\\s*,\\s*(\\[.*\\])\\s*', data)\n    if m:\n        commands = ast.literal_eval(m.group(1))\n        arguments = ast.literal_eval(m.group(2))\n    else:\n        # Fallback: split on the first comma\n        parts = data.split(',', 1)\n        commands = ast.literal_eval(parts[0].strip())\n        arguments = ast.literal_eval(parts[1].strip())\n\n    result = []\n    obj = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            result.append(None)\n        elif cmd == \"flip\":\n            res = obj.flip()\n            result.append(res)\n        elif cmd == \"reset\":\n            obj.reset()\n            result.append(None)\n        else:\n            result.append(None)\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution algorithm explanation for the described problem: randomly pick an index (i,j) with matrix[i][j]==0, flip to 1. All zero indices equally likely. Need minimize random calls, optimize time/space. Implementation: typical solution using reservoir or mapping. Approach: treat all cells as list of indices 0 to m*n-1. Keep a mapping from index to value for used positions. Initially mapping empty. Keep a counter of remaining zeros count, say total = m*n. In flip: decrement total, generate random r in [0,total). Then pick index = mapping.getOrDefault(r, r). Similarly, get last = mapping.getOrDefault(total, total). Update mapping[r] = last. Return coordinates [index/m, index % n]. In reset: clear mapping and set total=m*n.\n\nNow produce virtual code step by step. We'll output each line: \"Start // 程式開始執行\". Then the initialization steps etc. We need to produce virtual code for class methods. But the user expects a sequence of virtual code lines representing algorithm. It might need to show entire class with constructor, flip, reset. We will produce each step.\n\nWe need to use arrow syntax for steps and decisions. Example from prompt: `→ Step 1: ...`. Use `Decision: ...`. Use `Yes →`, `No →`.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 m, n, total = m * n // 設置矩陣尺寸及剩餘零值數量\n\n→ Step 2: 建立空的映射 map // 用於追蹤已選索引的映射\n\n→ Step 3: 定義 flip() 方法 // 隨機挑選並翻轉一個零\n\n→   Decision: 檢查 total 是否 > 0? // 確保仍有零可選\n\n        Yes → Step 4: total = total - 1 // 選擇一個空位置，減少剩餘數\n\n        → Step 5: r = random(0, total) // 隨機產生 0~total-1\n\n        → Step 6: idx = map.getOrDefault(r, r) // 取得實際索引\n\n        → Step 7: last = map.getOrDefault(total, total) // 取得最後可用索引\n\n        → Step 8: map.put(r, last) // 更新映射，將 r 指向 last\n\n        → Step 9: return [idx / n, idx % n] // 返回行列座標\n\n        No → Step 10: return [] // 或拋出異常，無剩餘零\n\n→ Step 11: 定義 reset() 方法 // 重置矩陣\n\n→   Step 12: clear map // 清空映射\n\n→   Step 13: total = m * n // 重新設定剩餘零數\n\nEnd // 程式執行結束\n\nBut the requirement says \"逐行\" and each line must contain \"虛擬碼步驟\" + space + comment. Should include arrows. We'll produce like:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 m, n, total = m * n // 設置矩陣尺寸及剩餘零值數量\n\n→ Step 2: map = {} // 建立空映射\n\n... etc.\n\nBut they also want decision branches. For decision, maybe like:\n\n→ Decision: total > 0? // 檢查是否還有零可翻轉\n\nYes → Step X: ...\n\nNo → Step Y: ...\n\nHowever, each line must be separate. For decision branch, we need to indent? The example had indentation. We can include indentation by spaces. Eg:\n\n→ Decision: total > 0? // 檢查是否還有零可翻轉\n\n    Yes → Step 4: total = total - 1 // ...\n\n    No  → Step 10: return [] // 沒有剩餘零\n\nWe need to keep consistent indentation. Provide each line separate. Should ensure each line ends with comment.\n\nLet's craft.\n\nAlso need to mention random calls: each flip calls random once. We need to mention that.\n\nWe also need to mention that mapping uses O(k) space where k is number of flips, at most m*n.\n\nWe may need to include explanation of mapping. Provide details.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 m, n, total = m * n // 設定矩陣尺寸與剩餘 0 的總數  \n→ Step 2: map = {} // 建立一個空的映射，用於追蹤已選擇的索引  \n→ Step 3: 定義 flip() 方法 // 隨機挑選並翻轉一個 0  \n\n  → Decision: total > 0? // 確認還有 0 可被翻轉  \n   Yes → Step 4: total = total - 1 // 先減少剩餘 0 的數量  \n    → Step 5: r = randomInt(0, total) // 產生 0~total-1 的隨機數，僅一次呼叫 random  \n    → Step 6: idx = map.getOrDefault(r, r) // 若 r 在映射中則取映射值，否則取 r 本身  \n    → Step 7: last = map.getOrDefault(total, total) // 取得最後一個可用索引的映射值或其自身  \n    → Step 8: map.put(r, last) // 把 r 的映射指向 last，確保未來不再重複  \n    → Step 9: return [idx / n, idx % n] // 把一次維度的索引轉換回 (row, col)  \n   No  → Step 10: return [] // 若 total 為 0，表示所有位置已被翻轉，返回空或拋錯誤  \n\n→ Step 11: 定義 reset() 方法 // 重置整個矩陣  \n  → Step 12: map.clear() // 清空映射，釋放空間  \n  → Step 13: total = m * n // 重新設定剩餘 0 的數量  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn9rnsc3u.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpn9rnsc3u.py\", line 38, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmpn9rnsc3u.py\", line 9, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the input into two lists: commands and arguments\n    idx = data.find('],')\n    commands_str = data[:idx+1]\n    args_str = data[idx+2:]\n    commands = json.loads(commands_str)\n    args = json.loads(args_str)\n\n    obj = None\n    results = []\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif cmd == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)\n        elif cmd == \"search\":\n            res = obj.search(arg)\n            results.append(res)\n        else:\n            # Unknown command, ignore or handle as needed\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanations. Virtual code lines with arrows, decisions, etc. Should not output real code. Should follow format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Should be line by line. Need to design data structure and operations. We can use a hash map grouping words by length, storing them. For search, we iterate over characters, change each to a wildcard pattern, check if any word matches with exactly one difference. Implementation: For each word in dict same length, count differences. If count ==1 return true. else false. But can also use dictionary of patterns: For each word, generate all patterns with one wildcard replaced, map to set of words. For search, generate patterns and check if any pattern maps to a set with word count >0, but ensure not same word? Actually we need exactly one character change, so searchWord itself must not be in dictionary. For pattern approach, we can check if pattern exists and corresponding set has size>1 or (size==1 and word not equal). But simpler: brute force.\n\nWe'll produce pseudocode for class with init, buildDict, search. Include data structures: dictionary set, maybe length map.\n\nWe'll produce pseudocode lines.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ MagicDictionary // 建立 MagicDictionary 物件  \n    → 成員變數: dictionarySet ← 空集合 // 用來存放所有單字  \n    → 成員變數: lengthMap ← 空映射 // key: 字長, value: 所有相同長度字的集合  \n→ End // 物件初始化完成  \n\nStart // buildDict(String[] dictionary)  \n    → Decision: dictionary 是否為空? // 檢查輸入是否為空  \n        Yes → End // 若空則直接結束  \n        No  →  \n            → For each word in dictionary: // 遍歷所有單字  \n                → dictionarySet ← dictionarySet ∪ {word} // 加入全集合  \n                → If lengthMap 未含 key word.length: // 若長度映射不存在  \n                    → lengthMap[word.length] ← 空集合 // 建立新集合  \n                → lengthMap[word.length] ← lengthMap[word.length] ∪ {word} // 加入同長度集合  \n    → End // 建立完成  \n\nStart // bool search(String searchWord)  \n    → Decision: searchWord.length 不在 lengthMap? // 若無同長度字  \n        Yes → Return False // 無法改一字匹配  \n        No  →  \n            → countMatches ← 0 // 記錄可改一字匹配的字數  \n            → For each word in lengthMap[searchWord.length]: // 遍歷同長度字  \n                → diffCount ← 0 // 差異字元數  \n                → For i from 0 to searchWord.length-1: // 逐字元比較  \n                    → Decision: searchWord[i] ≠ word[i]? // 是否不同  \n                        Yes → diffCount ← diffCount + 1  \n                        No  → // 無變動  \n                → Decision: diffCount == 1? // 恰好一字不同  \n                    Yes → countMatches ← countMatches + 1  \n                    No  → // 不是一字不同  \n            → Decision: countMatches > 0? // 至少一個符合  \n                Yes → Return True  \n                No  → Return False  \n    → End // 搜尋結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Reverse Words in a String III",
      "source_file": "Leetcode/leetcode557.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"Let's take LeetCode contest\"",
          "expected_output": "\"s'teL ekat edoCteeL tsetnoc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 's\"teLekatedoCteeLtsetnoc'\nGot (Norm):      's=s\"teL\"ekatedoCteeL\"tsetnoc'\n--- (Raw) ---\nRaw Expected: '\"s\\'teL ekat edoCteeL tsetnoc\"'\nRaw Got:      's = s\\'teL\" ekat edoCteeL \"tsetnoc'"
        },
        {
          "example_index": 1,
          "input": "s = \"Mr Ding\"",
          "expected_output": "\"rM gniD\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'rMgniD'\nGot (Norm):      's=rM\"\"gniD'\n--- (Raw) ---\nRaw Expected: '\"rM gniD\"'\nRaw Got:      's = rM\" \"gniD'"
        }
      ],
      "generated_code": "import sys\n\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    反轉字串中每個單字的字元順序，保留空白及原始單字順序。\n    \"\"\"\n    result = []\n    word = []\n    for ch in s:\n        if ch == ' ':\n            if word:                     # 將目前單字反轉並加入結果\n                result.append(''.join(reversed(word)))\n                word = []                # 清空緩衝\n            result.append(ch)            # 加入空白\n        else:\n            word.append(ch)               # 收集單字字元\n    if word:                             # 最後一個單字\n        result.append(''.join(reversed(word)))\n    return ''.join(result)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入，保留除結尾換行外的所有字元\n    raw_input = sys.stdin.read().rstrip('\\n')\n    # 直接處理輸入字串\n    output = reverse_words(raw_input)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, each line with virtual code and comment. The requirement: given a string s, reverse order of characters in each word within a sentence while preserving whitespace and initial word order. So we need to parse string, identify words (sequences of non-space characters), reverse each word, keep spaces as is. The virtual code steps: Start, maybe get input string, iterate over characters, build new string, using maybe a buffer for word, when space encountered, flush reversed word, append space, etc. Finally output result. Also need to preserve whitespace: so multiple spaces remain as is.\n\nWe need to use virtual code arrow lines. Use \"Start\", \"→ Step X\", \"Decision:\" etc. Each line includes comment after //.\n\nLet's craft a stepwise algorithm.\n\n1. Start\n2. Input string s\n3. Initialize empty result string res, empty word buffer word\n4. For each character ch in s:\n   a. Decision: if ch is space? If Yes: append reversed(word) to res, append ch, clear word. If No: append ch to word buffer.\n5. After loop, Decision: if word buffer not empty? Yes: append reversed(word) to res.\n6. Output res\n7. End\n\nBut we need to produce virtual code lines. Use \"→\" and maybe \"Decision:\". Provide comments.\n\nAlso we need to preserve whitespace including multiple spaces: we handle spaces individually. That works.\n\nEdge cases: leading/trailing spaces? We handle them.\n\nOk produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: s // 取得輸入字串  \n→ Initialise: res = \"\" // 儲存最終結果  \n→ Initialise: word = \"\" // 暫存目前處理的單字  \n→ For each character ch in s // 遍歷字串的每個字元  \n  Decision: ch 為空白字元? // 判斷是否為空格  \n   Yes → Append: reverse(word) to res // 將目前單字反轉後加入結果  \n    Append: ch to res // 加入空格保持原有空白  \n    Reset: word = \"\" // 清空單字緩衝  \n   No  → Append: ch to word // 非空白，加入單字緩衝  \n→ After loop: Decision: word 非空? // 檢查最後一個單字是否未處理  \n  Yes → Append: reverse(word) to res // 將最後單字反轉後加入結果  \n→ Output: res // 輸出處理後的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(res[::-1])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 將輸入中所有數字串列出來，這樣能處理「num1 = \"11\", num2 = \"123\"」等格式\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        parts = data.strip().split()\n        num1, num2 = parts[0], parts[1] if len(parts) > 1 else \"\"\n\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output pseudocode step-by-step for adding two numbers as strings, no big integers, no int conversion. Use manual addition from end to front. Provide explanation per line. Use structure: Start, Decision, Yes/No, etc. Output in Chinese (繁體). We'll create lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化指標 i = length(num1)-1, j = length(num2)-1, carry = 0, result = \"\" // 設定兩數索引和進位\n→ Step 2: While i >= 0 或 j >= 0 或 carry > 0: // 只要還有數字或進位就繼續\n    → Substep: 取值 a = i>=0 ? num1[i] - '0' : 0 // 若索引有效取該位數字，否則 0\n    → Substep: 取值 b = j>=0 ? num2[j] - '0' : 0 // 同上\n    → Substep: sum = a + b + carry // 兩位數加進位\n    → Substep: result = (sum % 10) + result // 將個位數加到結果前面\n    → Substep: carry = sum / 10 // 更新進位\n    → Substep: i--, j-- // 移動索引\n→ End // 輸出結果\n\nWe need to adhere to format: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows. We may need to indent steps but still maintain format.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Set i = length(num1) - 1, j = length(num2) - 1, carry = 0, result = \"\" // 初始化索引、進位與結果字串\n→ Decision: While i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還需進行相加\n    Yes → Step 2: a = i >= 0 ? num1[i] - '0' : 0 // 取得 num1 的當前位數，若已經越界則為 0\n    Yes → Step 3: b = j >= 0 ? num2[j] - '0' : 0 // 取得 num2 的當前位數，若已經越界則為 0\n    Yes → Step 4: sum = a + b + carry // 計算兩位數加進位的和\n    Yes → Step 5: result = (sum % 10) + result // 把個位數放到結果前面\n    Yes → Step 6: carry = sum / 10 // 更新進位\n    Yes → Step 7: i = i - 1, j = j - 1 // 移動索引到下一位\n    No → // 循環結束\n→ End // 輸出 result\n\nBut need structure: Use Decision: Yes → ... No → ... The lines inside decision can be indented with spaces. We also need to include \"End\" after loop. Also we need to output final result step: Step 8: Return result // 回傳相加後的字串\n\nLet's craft more formal.\n\nI'll produce lines with proper indent.\n\nWe must keep each line with a single arrow at start of line maybe. For lines inside decision, we can use spaces indentation and arrow.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: i = length(num1) - 1, j = length(num2) - 1, carry = 0, result = \"\" // 初始化索引、進位與結果字串\n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還需要繼續相加\n    Yes → Step 2: a = i >= 0 ? num1[i] - '0' : 0 // 取得 num1 當前位數，若已越界則為 0\n    Yes → Step 3: b = j >= 0 ? num2[j] - '0' : 0 // 取得 num2 當前位數，若已越界則為 0\n    Yes → Step 4: sum = a + b + carry // 計算兩位數加進位\n    Yes → Step 5: result = (sum % 10) + result // 將個位數加到結果前面\n    Yes → Step 6: carry = sum / 10 // 更新進位\n    Yes → Step 7: i = i - 1, j = j - 1 // 移動索引\n    No  → // 結束循環\n→ Step 8: Return result // 回傳最終相加結果\n\nBut we need to show End after return maybe. Also maybe we need to show End after program.\n\nLet's produce:\n\nEnd // 程式結束\n\nMake sure each line ends with // 解釋.\n\nAlso we might need to include Step 0 maybe.\n\nBetter to maintain simple.\n\nI'll produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = length(num1) - 1, j = length(num2) - 1, carry = 0, result = \"\" // 初始化索引、進位與結果字串  \n→ Decision: i >= 0 OR j >= 0 OR carry > 0? // 判斷是否還需要繼續相加  \n  Yes → Step 2: a = i >= 0 ? num1[i] - '0' : 0 // 取得 num1 的當前位數，若已越界則為 0  \n  Yes → Step 3: b = j >= 0 ? num2[j] - '0' : 0 // 取得 num2 的當前位數，若已越界則為 0  \n  Yes → Step 4: sum = a + b + carry // 計算兩位數加進位  \n  Yes → Step 5: result = (sum % 10) + result // 將個位數加到結果前面  \n  Yes → Step 6: carry = sum / 10 // 更新進位  \n  Yes → Step 7: i = i - 1, j = j - 1 // 移動索引到下一位  \n  No  → // 迴圈結束，已無位數可加  \n→ Step 8: Return result // 回傳最終相加結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立每個目標值對應的索引列表\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選取對應目標值的索引\n        return random.choice(self.num_indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：第一部分是命令列表，第二部分是參數列表\n    s = data\n    bracket_level = 0\n    i = 0\n    while i < len(s):\n        if s[i] == '[':\n            bracket_level += 1\n        elif s[i] == ']':\n            bracket_level -= 1\n            if bracket_level == 0:\n                break\n        i += 1\n\n    commands_str = s[:i+1]\n    args_str = s[i+2:].strip()  # 跳過逗號和空格\n\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    sol = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            sol = Solution(arg[0])  # arg 為 [nums]\n            result.append(None)\n        elif cmd == \"pick\":\n            result.append(sol.pick(arg[0]))\n        else:\n            # 若有其他方法，直接忽略或可自行擴充\n            result.append(None)\n\n    # 輸出結果，使用 JSON 以符合 LeetCode 格式（None -> null）\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. So we need to design algorithm: store mapping from target to list of indices, then pick random from that list. The constructor iterates array and populate map. pick selects random index from list. The virtual code should be line by line, using arrow and decision. Not actual code. Provide explanation. Use Start, End, Decision: etc. Should show mapping etc. Let's produce steps.\n\nPossible structure:\n\nStart\n→ Step 1: 建立空映射 Map targetToIndices // 存儲目標到索引列表\n→ Decision: 遍歷 nums 從 i=0 到 nums.length-1? // 為每個索引建立映射\n    Yes → Step 2: 將索引 i 加入 targetToIndices[nums[i]] // 將索引存入對應目標的列表\n    No → ...\n→ Step 3: 完成建構 // 完成初始化\n→ Step 4: pick(target) // 呼叫 pick 方法\n→ Step 5: 從 targetToIndices[target] 取列表 list // 獲取目標的所有索引\n→ Decision: list 長度 > 0? // 確保有索引\n    Yes → Step 6: 隨機選取 list[ random(0, list.length-1) ] // 隨機選中索引\n    No → Step 7: 返回 -1 // 雖然假設存在，備用\n→ End\n\nBut they might want method-specific steps.\n\nWe need to output each line with \"虛擬碼步驟\" and comment.\n\nLet's format each line.\n\nUse \"Start\" and \"End\" tags. The arrow lines show steps.\n\nWe need to use \"→\" arrow and \"Decision:\" lines with \"Yes →\" \"No →\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空的哈希表 targetToIndices // 用來儲存每個目標值對應的所有索引\n→ Decision: 遍歷 nums 陣列? // 為每個元素建立映射\n    Yes → Step 2: 取得元素值 val = nums[i] // 讀取當前索引的值\n    Yes → Step 3: 若 targetToIndices 不包含 val，則新增空列表 // 初始化對應的索引列表\n    Yes → Step 4: 將 i 加入 targetToIndices[val] // 將索引存入對應列表\n    No  → Step 5: 完成建構 // 迴圈結束\n→ End // 建構完成\n\nBut we need a line per step. Provide lines.\n\nMaybe better to group steps: For readability, we can keep multiple lines.\n\nLet's produce final.\n\nWe'll also include the pick method steps.\n\nWe need to show method call.\n\nBetter to structure as:\n\nStart\n→ Step 1: 架構 Solution(nums) // 建構函式\n→ Step 2: 建立 targetToIndices 映射 // ...\n→ Decision: i < nums.length? // ...\n   Yes -> Step 3: ...\n   No -> Step 4: ...\n→ End\n\nThen method pick:\n\nStart\n→ Step 1: Retrieve list = targetToIndices[target] // ...\n→ Decision: list 不是空? // ...\n   Yes -> Step 2: 隨機 index = randomInt(0, list.length-1) // ...\n   Yes -> Step 3: return list[index] // ...\n   No  -> Step 4: return -1 // ...\n→ End\n\nBut the requirement: \"虛擬碼步驟\" each line. Let's produce all lines.\n\nUse \"Start\" at top. Then we can show the constructor and pick.\n\nMaybe combine: Show Start, then Step 1: constructor, then Step 2: pick, etc. But to keep order, we can show the class skeleton.\n\nLet's produce a linear flow representing the whole algorithm. We'll treat constructor and pick as separate flows.\n\nWe might need to use \"Decision:\" lines for loops.\n\nWill produce like:\n\nStart // 程式開始執行\n→ Step 1: Solution(nums)  // 建構函式入口\n→ Step 2: targetToIndices ← 空映射 // 初始化儲存結構\n→ Decision: i < nums.length? // 遍歷陣列\n    Yes → Step 3: val ← nums[i] // 讀取元素值\n    Yes → Step 4: 若 targetToIndices 不含 val 則 targetToIndices[val] ← 空列表\n    Yes → Step 5: targetToIndices[val].append(i) // 將索引存入對應列表\n    No  → Step 6: 完成建構 // 迴圈結束\n→ End // 建構完成\n\nStart // pick 方法開始\n→ Step 7: list ← targetToIndices[target] // 取得目標的索引列表\n→ Decision: list 長度 > 0? // 確認存在\n    Yes → Step 8: randIdx ← 隨機整數(0, list.length-1) // 產生隨機位置\n    Yes → Step 9: return list[randIdx] // 回傳隨機索引\n    No  → Step 10: return -1 // 安全回傳，實際上不會發生\n→ End // pick 方法結束\n\nThis is okay.\n\nBut the requirement: \"逐行輸出，每行必須包含虛擬碼步驟 + 空格 + // 解釋/說明\".\n\nLet's produce each line accordingly.\n\nWill ensure each line uses arrow and decision.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Solution(nums)  // 建構函式入口  \n→ Step 2: targetToIndices ← 空映射  // 初始化儲存結構  \n→ Decision: i < nums.length?  // 遍歷陣列  \n&nbsp;&nbsp;Yes → Step 3: val ← nums[i]  // 讀取元素值  \n&nbsp;&nbsp;Yes → Step 4: 若 targetToIndices 不含 val 則 targetToIndices[val] ← 空列表  // 初始化對應索引列表  \n&nbsp;&nbsp;Yes → Step 5: targetToIndices[val].append(i)  // 將索引存入對應列表  \n&nbsp;&nbsp;No  → Step 6: 完成建構  // 迴圈結束  \nEnd // 建構完成  \n\nStart // pick 方法開始  \n→ Step 7: list ← targetToIndices[target]  // 取得目標的索引列表  \n→ Decision: list 長度 > 0?  // 確認存在  \n&nbsp;&nbsp;Yes → Step 8: randIdx ← 隨機整數(0, list.length-1)  // 產生隨機位置  \n&nbsp;&nbsp;Yes → Step 9: return list[randIdx]  // 回傳隨機索引  \n&nbsp;&nbsp;No  → Step 10: return -1  // 安全回傳，實際上不會發生  \nEnd // pick 方法結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[0,1],[1,0],[2,3],[4,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[0, 1], [1, 0], [2, 3], [4, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立「反轉字串 → 原索引」對照表，方便快速查找\n        rev_map = {word[::-1]: idx for idx, word in enumerate(words)}\n        result_set = set()\n\n        for i, word in enumerate(words):\n            length = len(word)\n            for split in range(length + 1):\n                prefix = word[:split]\n                suffix = word[split:]\n\n                # 情況1：prefix 為回文，尋找 suffix 的反轉\n                if prefix == prefix[::-1]:\n                    j = rev_map.get(suffix)\n                    if j is not None and j != i:\n                        result_set.add((i, j))\n\n                # 情況2：suffix 為回文，尋找 prefix 的反轉\n                # 注意 split != length，避免重複處理空字串\n                if split != length and suffix == suffix[::-1]:\n                    j = rev_map.get(prefix)\n                    if j is not None and j != i:\n                        result_set.add((j, i))\n\n        # 將結果轉換為列表形式\n        return [list(pair) for pair in result_set]\n\n\ndef main():\n    # 從標準輸入讀取整行資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 處理形如 'words = [\"a\",\"b\"]' 的輸入\n    if '=' in raw_input:\n        _, rhs = raw_input.split('=', 1)\n        raw_input = rhs.strip()\n\n    # 使用安全的 literal_eval 解析 Python 列表\n    words = ast.literal_eval(raw_input)\n\n    sol = Solution()\n    pairs = sol.palindromePairs(words)\n    # 為了輸出穩定順序，可按字典序排序\n    pairs.sort()\n    print(pairs)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm. Need O(total length). Classic solution: build hashmap of reversed words, check splits. Provide virtual steps. Use Start, Decision etc. Provide line by line. Let's produce algorithm outline: Build map word -> index. For each word, for each split position, prefix, suffix, if prefix palindrome then need reversed suffix in map. And vice versa. Also handle empty string special case. Ensure no duplicate pairs. Use set to avoid duplicates. Provide steps. Output in requested format.\n\nLet's produce lines:\n\nStart // start\n→ Step 1: 建立字典 reversedMap 以字串反轉為 key, index 為 value // 建立反轉字典\n→ Step 2: 建立結果 list palindromePairs // 用來存所有對\n→ Decision: 若 words 為空? // 檢查輸入\n    No  → … (continue)\nThen for each word i:\n→ Step 3: 取得 word, len\n→ Step 4: For split from 0 to len:\n→ Decision: split==len? // last case suffix empty\n    Yes → // 处理空后缀\n    No → // normal split\nInside splits: check prefix palindrome, suffix palindrome, look up reversed. Also check if reverse of word exists and not same index. Also special empty string case.\n\nWe'll keep simple but include key logic.\n\nAlso need O(total length) loops.\n\nProvide explanation comments.\n\nLet's craft steps.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化字典 reversedMap ← 空映射 // 建立「反轉字串 → 原字串索引」對照表\n→ Decision: words 為空? // 檢查輸入是否為空陣列\n    Yes → End // 空輸入直接結束\n    No  → // 繼續處理\n\n→ Step 2: 建立結果集合 result ← 空集合 // 用於儲存所有符合條件的 (i, j) 位置\n→ Step 3: 建立空字串特殊處理索引 emptyIndex ← -1 // 追蹤空字串所在位置\n\n→ Step 4: for 每個索引 i 與字串 word 於 words\n    // 建立字典\n    → Step 5: 將 reverse(word) 與 i 存入 reversedMap // 方便後續快速查詢\n    → Decision: word 為空字串?\n        Yes → emptyIndex ← i // 記錄空字串位置\n        No  → // 何事\n\n→ Step 6: for 每個索引 i 與字串 word 於 words\n    → Step 7: length ← word.length\n    → Step 8: for splitIdx 取值 0 至 length\n        // splitIdx 為分割點，prefix = word[0:splitIdx], suffix = word[splitIdx:]\n        → Decision: splitIdx == length?\n            Yes → // suffix 為空字串\n                → Step 9: 如果 emptyIndex != -1 且 emptyIndex != i\n                    → Step 10: 添加 (i, emptyIndex) 及 (emptyIndex, i) 到 result // 空字串 + 任何字串皆為回文\n                → No → // 無空字串，不作處理\n            No  → // 正常分割\n                → Step 11: prefix ← word.substring(0, splitIdx)\n                → Step 12: suffix ← word.substring(splitIdx)\n                → Decision: prefix 為回文?\n                    Yes →\n                        → Step 13: reverseSuffix ← reverse(suffix)\n                        → Decision: reversedMap 中是否有 reverseSuffix 且索引 j != i?\n                            Yes →\n                                → Step 14: 添加 (j, i) 到 result // suffix+prefix 形成回文\n                            No  → // 無對應\n                    No  → // prefix 不是回文，跳過此分割\n\n                → Decision: suffix 為回文?\n                    Yes →\n                        → Step 15: reversePrefix ← reverse(prefix)\n                        → Decision: reversedMap 中是否有 reversePrefix 且索引 j != i?\n                            Yes →\n                                → Step 16: 添加 (i, j) 到 result // prefix+suffix 形成回文\n                            No  → // 無對應\n                    No  → // suffix 不是回文，跳過此分割\n\n→ End // 程式執行結束，result 為所有符合條件的 (i, j) 對集合。"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplzod0wv3.py\", line 67, in <module>\n    main()\n  File \"/tmp/tmplzod0wv3.py\", line 32, in main\n    ops = ast.literal_eval(lines[0])\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x708b40626990>"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\ndef main():\n    # 讀取全部輸入，去除空行\n    lines = [line.strip() for line in sys.stdin if line.strip() != '']\n    if not lines:\n        return\n\n    # 解析兩個列表：操作名稱與對應參數\n    ops = ast.literal_eval(lines[0])\n    args = ast.literal_eval(lines[1])\n\n    output = []\n    queue = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyQueue\":\n            queue = MyQueue()\n            output.append(None)\n        elif op == \"push\":\n            queue.push(arg[0])\n            output.append(None)\n        elif op == \"pop\":\n            output.append(queue.pop())\n        elif op == \"peek\":\n            output.append(queue.peek())\n        elif op == \"empty\":\n            output.append(queue.empty())\n        else:\n            # 忽略未知操作\n            output.append(None)\n\n    # 轉換輸出為 LeetCode 格式：null, true, false\n    formatted = []\n    for val in output:\n        if val is None:\n            formatted.append(\"null\")\n        elif isinstance(val, bool):\n            formatted.append(\"true\" if val else \"false\")\n        else:\n            formatted.append(str(val))\n    print(f\"[{', '.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line with explanation. The requirement: implement a queue using two stacks, with operations push, pop, peek, empty.\n\nWe should produce virtual code steps that outline the logic, not actual code. Each line must have a virtual code step and comment. Must use arrow \"→\" and Decision: etc. Use Start and End.\n\nProbably show initialization: two stacks in, out. Provide operations: push: push to stack_in. pop: if stack_out empty, transfer all from stack_in to stack_out; then pop from stack_out. peek similar but just top. empty: return stack_in empty and stack_out empty.\n\nWe need to structure as a class. Virtual steps maybe like:\n\nStart // 初始化\n→ Step 1: Create stack_in // 存放進隊列的元素\n→ Step 2: Create stack_out // 存放出隊列的元素\n\nDefine push:\n→ Step 1: push x onto stack_in // 把元素放入進站\n...\n\nDefine pop:\n→ Decision: If stack_out empty? // 是否需要轉移\n    Yes → Step: while stack_in not empty: pop from stack_in and push onto stack_out // 轉移\n    No  →\n→ Step: pop from stack_out // 返回最前面元素\n\nDefine peek similar but top instead of pop.\n\nDefine empty:\n→ Step: return stack_in empty AND stack_out empty // 判斷是否空\n\nWe need to produce line-by-line, so maybe separate each step with new line. Use \"Start\" and \"End\" around overall class? Possibly we treat the class as whole: Start MyQueue // start definition. Then steps inside. But they want to show virtual steps of implementation, not code structure.\n\nMaybe present pseudo-code like:\n\nStart // 定義 MyQueue 類別\n→ Step 1: Initialize stack_in // 進入堆疊\n→ Step 2: Initialize stack_out // 出口堆疊\n\n→ Method push(x):\n    → Step: push x onto stack_in // 把 x 放進進入堆疊\n\n→ Method pop():\n    → Decision: 如果 stack_out 為空? // 判斷是否需要轉移\n        Yes → While stack_in 非空: pop from stack_in, push onto stack_out // 轉移所有元素\n        No →\n    → Step: pop from stack_out // 從出口堆疊取出\n    → Return the popped value\n\n→ Method peek():\n    → Decision: stack_out 為空?\n        Yes → While stack_in 非空: pop from stack_in, push onto stack_out\n        No →\n    → Step: peek top of stack_out // 取得最前面元素\n    → Return the value\n\n→ Method empty():\n    → Decision: stack_in empty AND stack_out empty?\n        Yes → Return true\n        No  → Return false\n\nEnd // MyQueue 定義結束\n\nBut we need each line as \"虛擬碼步驟 [空格] // 解釋\". Use arrow for lines inside decisions. For decisions we need indent.\n\nProbably produce as:\n\nStart // 程式開始執行\n→ Step 1: Initialize stack_in // 用來存放 push 進來的元素\n→ Step 2: Initialize stack_out // 用來存放 pop/peek 的元素\n\n→ Method push(x):\n    → Step 3: stack_in.push(x) // 把新元素推到進入堆疊頂端\n\n→ Method pop():\n    → Decision: If stack_out.empty()?\n        Yes → Step 4: While not stack_in.empty(): stack_out.push(stack_in.pop()) // 轉移所有元素\n        No  →\n    → Step 5: return stack_out.pop() // 從出口堆疊頂端取出最前面的元素\n\n→ Method peek():\n    → Decision: If stack_out.empty()?\n        Yes → Step 6: While not stack_in.empty(): stack_out.push(stack_in.pop()) // 轉移\n        No  →\n    → Step 7: return stack_out.top() // 取得出口堆疊頂端元素但不移除\n\n→ Method empty():\n    → Decision: If stack_in.empty() AND stack_out.empty()?\n        Yes → Step 8: return true // Queue 空\n        No  → Step 9: return false // Queue 非空\n\nEnd // 程式結束\n\nWe must ensure each line includes the virtual code and comment. Use arrow for each step. Indent for decision branches. Use \"→ Decision:\" etc.\n\nWe also must not output actual code. So we must not show any real language syntax. Just descriptive steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize stack_in // 建立用於 push 的堆疊  \n→ Step 2: Initialize stack_out // 建立用於 pop/peek 的堆疊  \n\n→ Method push(x): // 定義 push 操作  \n    → Step 3: stack_in.push(x) // 把新元素推到進入堆疊頂端  \n\n→ Method pop(): // 定義 pop 操作  \n    → Decision: 如果 stack_out 為空? // 判斷是否需要將元素轉移到出口堆疊  \n        Yes → Step 4: while stack_in 不是空: stack_out.push(stack_in.pop()) // 轉移所有元素  \n        No  →  \n    → Step 5: return stack_out.pop() // 從出口堆疊頂端取出最前面的元素  \n\n→ Method peek(): // 定義 peek 操作  \n    → Decision: 如果 stack_out 為空? // 判斷是否需要將元素轉移到出口堆疊  \n        Yes → Step 6: while stack_in 不是空: stack_out.push(stack_in.pop()) // 轉移所有元素  \n        No  →  \n    → Step 7: return stack_out.top() // 取得出口堆疊頂端元素但不移除  \n\n→ Method empty(): // 定義 empty 操作  \n    → Decision: 如果 stack_in 為空 且 stack_out 為空? // 檢查兩個堆疊是否皆空  \n        Yes → Step 8: return true // Queue 為空  \n        No  → Step 9: return false // Queue 非空  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Best Time to Buy and Sell Stock IV",
      "source_file": "Leetcode/leetcode188.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9kri2egb.py\", line 34, in <module>\n    prices = ast.literal_eval(parts[1].split(\"=\")[1])\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp608orfkb.py\", line 34, in <module>\n    prices = ast.literal_eval(parts[1].split(\"=\")[1])\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef max_profit(k, prices):\n    n = len(prices)\n    if n == 0:\n        return 0\n    # If k is large enough, treat as unlimited transactions\n    if k >= n // 2:\n        profit = 0\n        for i in range(1, n):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit\n\n    # DP with O(k) memory (buy/sell arrays)\n    buy = [-10**18] * (k + 1)\n    sell = [0] * (k + 1)\n\n    for price in prices:\n        for t in range(1, k + 1):\n            buy[t] = max(buy[t], sell[t - 1] - price)   # buy at current day\n            sell[t] = max(sell[t], buy[t] + price)      # sell at current day\n    return sell[k]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Expected format: \"k = X, prices = [a,b,c]\"\n    parts = data.replace(\" \", \"\").split(\",\")\n    k = int(parts[0].split(\"=\")[1])\n    prices = ast.literal_eval(parts[1].split(\"=\")[1])\n\n    result = max_profit(k, prices)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: maximum profit with at most k transactions. This is classic DP: dp[i][j][0/1] or use two arrays. Provide steps. Each line with arrow and explanation. Use structure: Start, → Step etc. Decision nodes.\n\nWe must output in Traditional Chinese. Provide virtual steps.\n\nLet's write:\n\nStart\n→ Step 1: 獲取股票價格陣列 prices 及交易上限 k // 取得輸入資料\n→ Step 2: 若 k >= n/2 則直接計算所有上漲差額 // 當交易數足夠多可視為無限制\n    Yes → Step 3: 初始化 profit = 0 // 累計最大利潤\n    → 迴圈 i 從 1 到 n-1\n        Yes → profit += max(0, prices[i] - prices[i-1]) // 每次上漲加總\n    End\n    No → Step 4: 初始化 dp 資料結構 // k 次交易的 DP\n    → 建立 two 2D arrays buy[0..k], sell[0..k] 初始化\n        buy[t] = -∞, sell[t] = 0\n    → 迴圈 i 從 0 到 n-1\n        → 迴圈 t 從 1 到 k\n            Yes → buy[t] = max(buy[t], sell[t-1] - prices[i]) // 買進\n            Yes → sell[t] = max(sell[t], buy[t] + prices[i]) // 賣出\n    → Step 5: 回傳 sell[k] // 最大利潤\nEnd\n\nWe must format with arrows and explanations. Each line separate. Use 虛擬碼步驟 plus explanation. Use arrows for steps. For decisions use Decision:... with Yes→ and No→ lines.\n\nLet's craft.\n\nAlso include Start, End. Use indentation for nested decision.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得股票價格陣列 prices 與交易上限 k // 讀取輸入資料  \n→ Decision: 是否 k 大於等於 n/2? // 判斷交易次數是否足夠多  \n Yes → Step 2: 初始化 profit = 0 // 先設為 0  \n  → 迴圈 i 由 1 迭代到 n-1  \n   Yes → profit += max(0, prices[i] - prices[i-1]) // 每天若價格上漲，累加利潤  \n  → Step 3: 回傳 profit // 完成無限制交易情形  \n No → Step 4: 初始化 DP 陣列 buy[1..k] 與 sell[1..k] // 設置 DP 變數  \n  → 迴圈 t 從 1 到 k  \n   Yes → buy[t] = -∞ // 初始購買價格設為負無限  \n   Yes → sell[t] = 0 // 初始銷售利潤為 0  \n → 迴圈 i 從 0 到 n-1  \n  → 迴圈 t 從 1 到 k  \n   Yes → buy[t] = max(buy[t], sell[t-1] - prices[i]) // 以第 t-1 次交易的銷售利潤加上買入成本更新 buy  \n   Yes → sell[t] = max(sell[t], buy[t] + prices[i]) // 以當前持股價格更新 sell  \n → Step 5: 回傳 sell[k] // 回傳最多 k 次交易的最大利潤  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import json\nimport sys\n\ndef find_lus_length(strs):\n    \"\"\"返回陣列中最長的非公共子序列長度，若不存在則回傳 -1\"\"\"\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n\n    max_len = -1\n    for s in strs:\n        if freq[s] == 1:                # 只考慮唯一出現的字串\n            if len(s) > max_len:\n                max_len = len(s)\n    return max_len\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，預期為 JSON 陣列，例如 [\"aba\",\"cdc\",\"eae\"]\n    try:\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # 若不是合法 JSON，嘗試使用 eval（不建議在實際環境中使用）\n        strs = eval(data)\n\n    result = find_lus_length(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanation. Problem: longest uncommon subsequence length. Known solution: if all strings equal, answer -1 else find longest string that is not a subsequence of any other string. But the common solution: return length of longest string that is not equal to any other string; if duplicates exist and all strings same length, answer -1. But careful: condition is uncommon subsequence, not necessarily entire string. But known Leetcode 1444: Longest Uncommon Subsequence II. Approach: if there is any string that is not equal to any other string, then the longest such string's length is answer. Because the string itself is a subsequence of itself, but if it is not equal to any other string, it's not a subsequence of others. However need to confirm: If string A is not equal to any other string, is it guaranteed that A is not a subsequence of any other string? Not always. For example, A=\"ab\", B=\"abcd\". A is a subsequence of B. But A != B. But we need an uncommon subsequence between array. We need a string S that is subsequence of exactly one string and not subsequence of others. The string itself qualifies if it is not subsequence of others. So we need to check subsequence relation. But the known solution is that answer is the length of the longest string that is not equal to any other string. Wait Leetcode 1444 says: if all strings same length, answer -1 else longest string that is not equal to any other string. But the logic: if there are duplicates, the duplicate string can't be the uncommon subsequence because it's a subsequence of the duplicate. But if a string is unique (no duplicate), we need to check if it is a subsequence of any other string. But since other strings have length >=? No guarantee. But known solution states that the longest unique string will always be not subsequence of any other? Let's test: strings: [\"ab\",\"abcd\"]. \"abcd\" unique but \"abcd\" is not subsequence of \"ab\" (since longer). So unique string longer than others can't be subsequence of others because it's longer. But if unique string shorter: [\"abc\",\"ab\"] => \"abc\" unique, \"abc\" not subsequence of \"ab\" because longer. So unique longer or equal? If equal length but unique: then can't be subsequence because equal length but different content: cannot be subsequence? Actually subsequence of equal length string must be equal. So if content differs, not subsequence. So indeed unique string that isn't equal to any other will not be a subsequence of any other. Thus answer is length of longest unique string. If all strings equal, answer -1. So we can use that logic.\n\nThus algorithm:\n\n- Count frequencies of strings.\n- Find max length among strings with freq 1.\n- If none, return -1.\n\nNow produce virtual code steps. We'll produce step by step with virtual arrows.\n\nOk.\n\nMake sure each line has explanation. Use Start, End, Decision.\n\nWe need to not output actual code. Use virtual code.\n\nLet's craft:\n\nStart\n\n→ Step 1: 建立空字典 freq // 用於統計每個字串出現次數\n\n→ Step 2: 對於每個 str in strs:\n        ←   freq[str] = freq.get(str,0)+1 // 更新計數\n\nBut we need virtual code lines, not actual code. So we can use pseudo.\n\nWe should follow formatting: \"虛擬碼步驟 [space] // 解釋\"\n\nWe'll create line numbers? Not needed.\n\nMake sure to use arrow and decision.\n\nLet's produce.\n\nWe can use \"→\" to indicate next step. Indent for nested decisions.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化字典 freq // 用於統計每個字串的出現頻率\n\n→ Step 2: 對每個字串 str 在 strs:\n    ← freq[str] = freq.get(str, 0) + 1 // 更新頻率\n\n→ Step 3: 初始化變數 maxLen = -1 // 儲存目前找到的最大長度\n\n→ Step 4: 對每個字串 str 在 strs:\n    ← Decision: 是否 freq[str] == 1? // 只考慮唯一出現的字串\n        Yes →\n            ← lenStr = length(str) // 取得字串長度\n            ← Decision: lenStr > maxLen? // 是否比目前最大長度更長\n                Yes → maxLen = lenStr // 更新最大長度\n                No → // 無變更\n        No → // 跳過重複字串\n\n→ Step 5: Decision: maxLen == -1? // 若未找到任何唯一字串\n    Yes → End // 回傳 -1 (程式結束)\n    No →\n        ← Output maxLen // 回傳最大長度\n        → End // 程式結束\n\nBut need to be more explicit: Step 5 outputs -1. But we can't output actual code, but we can mention output.\n\nWe might combine Step 5 as \"→ Step 5: 回傳 maxLen\" but if -1 indicates no unique. But to reflect decision, we can say:\n\n→ Step 5: Decision: maxLen == -1?\n    Yes → Step 5a: 回傳 -1 // 沒有不重複字串，無 uncommon subsequence\n    No  → Step 5b: 回傳 maxLen // 有不重複字串，回傳其長度\n\nAnd then End.\n\nLet's produce final output accordingly. Ensure each line is virtual code with explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化字典 freq // 用於統計每個字串的出現頻率\n→ Step 2: 對每個字串 str 在 strs:\n    ← freq[str] = freq.get(str, 0) + 1 // 更新頻率\n→ Step 3: 初始化變數 maxLen = -1 // 儲存目前找到的最大長度\n→ Step 4: 對每個字串 str 在 strs:\n    ← Decision: 是否 freq[str] == 1? // 只考慮唯一出現的字串\n        Yes →\n            ← lenStr = length(str) // 取得字串長度\n            ← Decision: lenStr > maxLen? // 是否比目前最大長度更長\n                Yes → maxLen = lenStr // 更新最大長度\n                No  → // 無變更\n        No  → // 跳過重複字串\n→ Step 5: Decision: maxLen == -1?\n    Yes → Step 5a: 回傳 -1 // 沒有不重複字串，無 uncommon subsequence\n    No  → Step 5b: 回傳 maxLen // 有不重複字串，回傳其長度\nEnd // 程式執行結束"
    },
    {
      "title": "Subarray Product Less Than K",
      "source_file": "Leetcode/leetcode713.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [10,5,2,6], k = 100",
          "expected_output": "8",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '8'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:\n        # 如果 k <= 1，任何正整數產品都不可能小於 k，直接回傳 0\n        if k <= 1:\n            return 0\n        prod = 1          # 目前滑動窗口內元素的乘積\n        left = 0          # 左指標\n        result = 0        # 總計數\n        for right, val in enumerate(nums):\n            prod *= val                 # 將右指標元素加入窗口\n            while prod >= k:            # 若乘積已不小於 k，收縮窗口\n                prod //= nums[left]     # 移除左端元素\n                left += 1               # 左指標右移\n            result += right - left + 1  # 以 right 為結尾的合法子陣列數\n        return result\n\ndef parse_input() -> (List[int], int):\n    \"\"\"\n    從 stdin 讀取資料，並解析出 nums 與 k。\n    允許輸入類似 'nums = [10,5,2,6], k = 100' 的格式。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], 0\n\n    # 先把整行分成兩部分\n    parts = data.split(',')\n    nums_part = parts[0]\n    k_part = parts[1] if len(parts) > 1 else ''\n\n    # 抽取列表內容\n    nums_match = re.search(r'\\[(.*?)\\]', nums_part)\n    if nums_match:\n        nums_str = nums_match.group(1)\n        # 用逗號分隔後轉為整數\n        nums = [int(x) for x in nums_str.split(',') if x.strip()]\n    else:\n        nums = []\n\n    # 抽取 k 的值\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', k_part)\n    if k_match:\n        k = int(k_match.group(1))\n    else:\n        k = 0\n\n    return nums, k\n\ndef main():\n    nums, k = parse_input()\n    solution = Solution()\n    answer = solution.numSubarrayProductLessThanK(nums, k)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for sliding window product < k count. Use typical algorithm.\n\nNeed to output step-by-step. Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols.\n\nLet's produce:\n\nStart // program start\n\n→ Step 1: if k <= 1 then return 0 // product cannot be less than k\n\n→ Step 2: Initialize product = 1, left = 0, result = 0 // window variables\n\n→ Step 3: For right from 0 to len(nums)-1 // iterate over array\n\n    → Step 3a: Multiply product by nums[right] // expand window\n\n    → Decision: While product >= k and left <= right // shrink window\n\n        → Step 3b: Divide product by nums[left] // remove leftmost\n\n        → Step 3c: left += 1 // move left pointer\n\n    → Step 3d: result += right - left + 1 // count subarrays ending at right\n\n→ Step 4: Return result // final count\n\nEnd\n\nWe need to ensure \"虛擬碼步驟\" each line. Use the arrows. For Decision, indent.\n\nWe'll output exactly per format. Use \"Start\", \"End\".\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 若 k <= 1 則回傳 0 // 產品無法小於 k，直接結束  \n→ Step 2: 設定 product = 1, left = 0, result = 0 // 初始化滑動窗口變數  \n→ Step 3: 從右指標 0 遍歷到 nums.length-1  \n    → Step 3a: product = product * nums[right] // 擴展窗口，加入新元素  \n    → Decision: 當 product >= k 且 left <= right 時  \n        → Step 3b: product = product / nums[left] // 收縮窗口，移除左端元素  \n        → Step 3c: left += 1 // 左指標右移  \n    → Step 3d: result = result + (right - left + 1) // 計算以 right 為結尾的合法子陣列數  \n→ Step 4: 回傳 result // 結束計算並回傳答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of a list of distinct integers.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])  # Append a copy of the current permutation\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # Swap to fix element at position `start`\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # Backtrack: restore original order\n\n        backtrack(0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list part from input like \"nums = [1,2,3]\"\n    idx = data.find('[')\n    if idx == -1:\n        nums = []\n    else:\n        nums_str = data[idx:]\n        nums = ast.literal_eval(nums_str)\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all permutations of array nums. Use recursion or backtracking. Provide step by step with Start, Decision, End. Use virtual arrows. For each line, provide explanation after //. Use virtual code only, no actual code. So we need to produce steps. Ensure lines like \"→ Step 1: 初始化\" etc. Provide each step. The final solution must include the full algorithm in virtual pseudocode.\n\nMake sure it's line by line, with arrows and decisions.\n\nLet's produce:\n\nStart\n→ Step 1: 定義遞迴函數 backtrack(current, remaining) // 用於生成排列\n→ Decision: 如果 remaining 為空? // 檢查是否已排列完\n    Yes → Step 2: 將 current 加入結果集合 // 存儲一個完整排列\n    No  → Decision: 循環遍歷 remaining 中每個元素 i\n        Yes → Step 3: 創建 new_current = current + i // 選取一個元素\n        → Step 4: 創建 new_remaining = remaining - i // 去除已選元素\n        → Step 5: 呼叫 backtrack(new_current, new_remaining) // 進一步遞迴\nEnd\n\nBut need to incorporate Start and End. Also maybe mention input and output.\n\nWe need to use \"Start\" and \"End\". Also we may need to call backtrack initially with empty current and full nums. So add Step 0: 初始化 results empty; Step 1: 呼叫 backtrack([], nums). Provide explanation. Then inside backtrack. Provide decision for base case. Provide loop.\n\nEnsure each line has // explanation. Use arrow →.\n\nWe must follow the format exactly: line like \"Start // 程式開始執行\". So each line: Virtual code step + space + // explanation.\n\nAlso we need to show arrow lines with \"→\".\n\nFor decision lines: \"Decision:\" and then indent Yes and No with arrow.\n\nWe need to indent? In example they indent with 4 spaces? Let's replicate similar.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 0: 定義空結果陣列 results // 用於存放所有排列\n→ Step 1: 呼叫 backtrack([], nums) // 從空序列開始遞迴\n→ Function: backtrack(current, remaining) // 遞迴函數\n    → Decision: 如果 remaining 為空? // 已完成一個排列\n        Yes → Step 2: 將 current 加入 results // 存入結果\n        No  → Decision: 循環遍歷 remaining 中每個元素 i // 選擇下一個\n            Yes → Step 3: new_current = current + i // 將 i 加入當前排列\n            → Step 4: new_remaining = remaining - i // 移除已選元素\n            → Step 5: 呼叫 backtrack(new_current, new_remaining) // 進行遞迴\nEnd // 程式執行結束\n\nBut we need to use arrow syntax for Decision and Yes/No. The example uses:\n\nDecision: 如果數字大於 0? \n    Yes → Step 2: ...\n    No  → Decision: ...\n\nSo we should format similarly. We can use \"Decision:\" followed by a condition.\n\nAlso we need to ensure no actual code. So \"new_current = current + i\" is pseudo. That's fine.\n\nBut we must ensure each line has \"虛擬碼步驟 [space] // 解釋/說明\".\n\nThus we need to write something like:\n\nStart // 程式開始執行\n→ Step 0: 定義空結果陣列 results // 用於存放所有排列\n→ Step 1: 呼叫 backtrack([], nums) // 從空序列開始遞迴\n→ Function: backtrack(current, remaining) // 遞迴函數\n    → Decision: 如果 remaining 為空? // 已完成一個排列\n        Yes → Step 2: 將 current 加入 results // 存入結果\n        No  → Decision: 循環遍歷 remaining 中每個元素 i // 選擇下一個\n            Yes → Step 3: new_current = current + i // 將 i 加入當前排列\n            → Step 4: new_remaining = remaining - i // 移除已選元素\n            → Step 5: 呼叫 backtrack(new_current, new_remaining) // 進行遞迴\nEnd // 程式執行結束\n\nBut we need to check indentation: In example, they use indentation for decision branches. So we can indent with 4 spaces for Yes and No lines, as they used 4 spaces. Also they used \"Yes →\" and \"No  →\" lines. For inner Decision, we also need Yes→ and No→? Actually after No, they create another Decision. For \"No\" branch, we might not need Yes/No inside? Actually it's \"Decision: 循環遍歷 remaining 中每個元素 i\" and then Yes lines for each iteration? But it's a loop, not a yes/no. The example uses Decision for yes/no but we can use Loop: But to keep within format, we can keep \"Decision:\" with \"Yes →\" and \"No →\"? But for loop we can't use yes/no. The format might be flexible.\n\nBetter: Use \"Decision:\" for the base case, then \"Loop:\" for iteration. But they didn't specify a Loop type. We can use \"Decision:\" with \"Yes →\" to handle base case, \"No  →\" for recursion. Inside No, we can just describe the loop. Or we can use \"Decision:\" for base case and then just loop inside.\n\nBut to keep consistent, we can write:\n\n→ Decision: 如果 remaining 為空? // 已完成排列\n    Yes → Step 2: 將 current 加入 results // 存入結果\n    No  → Step 3: 對於每個元素 i 在 remaining 中 // 選擇下一個\n        → Step 4: new_current = current + i // 加入 i\n        → Step 5: new_remaining = remaining - i // 去除 i\n        → Step 6: 呼叫 backtrack(new_current, new_remaining) // 進一步遞迴\n\nBut \"Step 3: 對於每個元素 i 在 remaining 中\" is a loop, not a decision. We can still treat as a step.\n\nBut the example uses decision branches with Yes/No. For the loop, we don't need decision.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 0: 定義空結果陣列 results // 用於存放所有排列\n→ Step 1: 呼叫 backtrack([], nums) // 開始遞迴\n→ Function: backtrack(current, remaining) // 遞迴函數\n    → Decision: 如果 remaining 為空? // 已完成一個排列\n        Yes → Step 2: 將 current 加入 results // 存入結果\n        No  → Step 3: 對於每個元素 i 在 remaining 中 // 開始選取\n            → Step 4: new_current = current + i // 加入 i\n            → Step 5: new_remaining = remaining - i // 去除 i\n            → Step 6: 呼叫 backtrack(new_current, new_remaining) // 進行遞迴\nEnd // 程式執行結束\n\nThat seems fine.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\". So each line:\n\nStart // 程式開始執行\n→ Step 0: 定義空結果陣列 results // 用於存放所有排列\n→ Step 1: 呼叫 backtrack([], nums) // 開始遞迴\n→ Function: backtrack(current, remaining) // 遞迴函數\n    → Decision: 如果 remaining 為空? // 已完成一個排列\n        Yes → Step 2: 將 current 加入 results // 存入結果\n        No  → Step 3: 對於每個元素 i 在 remaining 中 // 開始選取\n            → Step 4: new_current = current + i // 加入 i\n            → Step 5: new_remaining = remaining - i // 去除 i\n            → Step 6: 呼叫 backtrack(new_current, new_remaining) // 進行遞迴\nEnd // 程式執行結束\n\nCheck formatting: Indentation inside function. But the example didn't indent the \"Step\" lines inside function. But we can use indent for clarity.\n\nBut must follow \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe must not include actual code; but we used \"=\" assignment; that's okay as pseudocode.\n\nShould we mention \"返回 results\"? At end? Actually after recursion, we return results. We can add Step 7: 返回 results after backtrack finishes. But it's inside main. Let's add after Step 1 maybe:\n\n→ Step 2: 返回 results // 完成後返回所有排列\n\nBut the order: We call backtrack, then after it completes, we return results. So:\n\nStart\n→ Step 0: 定義空結果陣列 results\n→ Step 1: 呼叫 backtrack([], nums)\n→ Step 2: 返回 results\n→ Function: backtrack...\n\nBut Step 2 appears before function definition. In pseudocode, we can define function before calling. But it's okay to show function definition earlier. Usually define before use. But we can keep function defined at top. But for clarity, we can first define function, then call.\n\nLet's restructure:\n\nStart // 程式開始執行\n→ Function: backtrack(current, remaining) // 遞迴函數\n    → Decision: 如果 remaining 為空? // 已完成一個排列\n        Yes → Step 1: 將 current 加入 results // 存入結果\n        No  → Step 2: 對於每個元素 i 在 remaining 中 // 開始選取\n            → Step 3: new_current = current + i // 加入 i\n            → Step 4: new_remaining = remaining - i // 去除 i\n            → Step 5: 呼叫 backtrack(new_current, new_remaining) // 進行遞迴\n→ Step 0: 定義空結果陣列 results // 用於存放所有排列\n→ Step 1: 呼叫 backtrack([], nums) // 開始遞迴\n→ Step 2: 返回 results // 完成後返回所有排列\nEnd // 程式執行結束\n\nBut numbering duplicates. Let's use unique names: use Step for steps outside function, and inside function use Step for internal steps. But Step numbers can repeat; it's fine.\n\nWe need to ensure each line ends with // explanation.\n\nAlso, we used \"→ Function:\" which might be okay. The example didn't show function keyword. But we can keep.\n\nBetter to keep same style: Use \"→ Step 1:\" for all steps. But function definition maybe separate line: \"→ Step 0: 定義遞迴函數 backtrack\" // So we can incorporate.\n\nLet's produce final version:\n\nStart // 程式開始執行\n→ Step 0: 定義空結果陣列 results // 用於存放所有排列\n→ Step 1: 定義遞迴函數 backtrack(current, remaining) // 遞迴核心\n    → Decision: 如果 remaining 為空? // 已完成一個排列\n        Yes → Step 2: 將 current 加入 results // 存入結果\n        No  → Step 3: 對於每個元素 i 在 remaining 中 // 開始選取\n            → Step 4: new_current = current + i // 加入 i\n            → Step 5: new_remaining = remaining - i // 去除 i\n            → Step 6: 呼叫 backtrack(new_current, new_remaining) // 進行遞迴\n→ Step 7: 呼叫 backtrack([], nums) // 從空序列開始遞迴\n→ Step 8: 返回 results // 完成後返回所有排列\nEnd // 程式執行結束\n\nCheck duplicates: Step 0 defined results, Step 1 define function, Step 2 inside function, Step 3 loop, Step 4-6 recursion, Step 7 call, Step 8 return.\n\nYes.\n\nMake sure we didn't output actual code like loops, but we used \"對於每個元素 i 在 remaining 中\" as loop. It's okay.\n\nWe might also want to show \"for each i in remaining\" but it's fine.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 定義空結果陣列 results // 用於存放所有排列  \n→ Step 1: 定義遞迴函數 backtrack(current, remaining) // 遞迴核心  \n  → Decision: 如果 remaining 為空? // 已完成一個排列  \n   Yes → Step 2: 將 current 加入 results // 存入結果  \n   No  → Step 3: 對於每個元素 i 在 remaining 中 // 開始選取  \n     → Step 4: new_current = current + i // 加入 i  \n     → Step 5: new_remaining = remaining - i // 去除 i  \n     → Step 6: 呼叫 backtrack(new_current, new_remaining) // 進行遞迴  \n→ Step 7: 呼叫 backtrack([], nums) // 從空序列開始遞迴  \n→ Step 8: 返回 results // 完成後返回所有排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 用 list 儲存所有元素，方便隨機存取\n        self.data = []\n        # 用 dict 將元素值對應到該值所在 indices 的集合\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，若為第一次插入回傳 True，否則 False。\"\"\"\n        self.data.append(val)\n        idx = len(self.data) - 1\n        self.idx_map[val].add(idx)\n        # 如果集合大小為 1，表示這是第一次插入該值\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一次該值，若存在回傳 True，否則 False。\"\"\"\n        if not self.idx_map[val]:\n            return False\n        # 任取一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n        # 把最後一個元素移到要刪除的位置\n        self.data[remove_idx] = last_val\n        # 更新最後一個元素的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n        # 刪除陣列最後元素\n        self.data.pop()\n        # 如果某個值的索引集合已空，則可選擇刪除鍵（不必要）\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素。\"\"\"\n        return random.choice(self.data)\n\ndef main():\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        return\n    # 解析為兩個列表，利用 ast.literal_eval 解析安全的 Python 表達式\n    ops, args = ast.literal_eval(f\"({input_text})\")\n    rc = RandomizedCollection()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            results.append(None)\n        elif op == \"insert\":\n            # arg 為 [val]\n            results.append(rc.insert(arg[0]))\n        elif op == \"remove\":\n            # arg 為 [val]\n            results.append(rc.remove(arg[0]))\n        elif op == \"getRandom\":\n            # arg 為 []\n            results.append(rc.getRandom())\n        else:\n            # 若有其他不定義的操作，直接忽略\n            results.append(None)\n\n    # 將結果轉為 LeetCode 風格的輸出字串\n    out_parts = []\n    for v in results:\n        if v is None:\n            out_parts.append(\"null\")\n        elif isinstance(v, bool):\n            out_parts.append(\"true\" if v else \"false\")\n        else:\n            out_parts.append(str(v))\n    print(f\"[{', '.join(out_parts)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanation. The pseudocode should reflect design: use vector/list for values and hashmap value->set of indices. Insert: push_back, add index to map; return true if new. Remove: if map empty return false; get an index from set; get last element; move last to that index; update maps; pop_back; return true.\n\nAlso getRandom: pick random index from vector.\n\nWe need to produce each line with `虛擬碼步驟` then space then `// 解釋/說明`. Use arrows and structure. The code structure: Start, class definition, constructor, insert, remove, getRandom. Since we are to generate pseudocode line by line, maybe treat each method as block with internal steps.\n\nWe need to avoid actual code. Use steps: `Step: ...`. Use arrows.\n\nLet's produce.\n\nWe'll write: Start, → Define RandomizedCollection // class definition. Then inside, define data structures: vector values, map val->set indices.\n\nInsert: → Step 1: Append val to values vector // O(1) push back. → Step 2: Add new index to map set // O(1). → Decision: if val previously absent? // check map size before insertion? Actually we can check before adding: if map contains val and set empty? We'll just decide after adding: check if set size ==1? // Means new. → Yes -> return true. No -> return false.\n\nRemove: → Decision: If map[val] empty? // No occurrence. No -> return false. Yes -> Step: pick an index idx from map[val] // any. Step: get last element lastVal = values.back() // last. Step: replace values[idx] = lastVal // move. Step: update map[lastVal]: remove old last index, add idx if idx != last index. Step: remove idx from map[val] // popped. If map[val] empty after removal -> delete entry. Step: pop_back values. Return true.\n\ngetRandom: → Step: pick random i between 0 and values.size()-1 // using random function. → Return values[i].\n\nEnd.\n\nWe need arrow structure: Start, → Decision, Yes →, No →.\n\nWill produce each step line.\n\nLet's produce pseudocode lines accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Define RandomizedCollection // 宣告 RandomizedCollection 類別\n    → Data: values ← 空陣列 // 儲存所有元素，支持 O(1) 隨機存取\n    → Data: indicesMap ← 空字典 // key: 元素值, value: 存在該值的索引集合\n\n→ Constructor RandomizedCollection() // 初始化\n    → 設定 values ← [] // 空陣列\n    → 設定 indicesMap ← {} // 空字典\n→ End // 建構子結束\n\n→ Method insert(val) : bool // 插入元素\n    → Step 1: idx ← values.length // 取得新元素將要插入的位置索引\n    → Step 2: values.append(val) // 將 val 加入陣列末尾\n    → Step 3: 若 indicesMap 沒有 key val 則 indicesMap[val] ← 空集合 // 初始化集合\n    → Step 4: indicesMap[val].add(idx) // 把新索引加入集合\n    → Decision: 如果 indicesMap[val] 的大小 == 1? // 判斷是否為第一次插入該值\n        Yes → Return true // 真正新增元素\n        No  → Return false // 只新增複本，並回傳 false\n\n→ Method remove(val) : bool // 刪除單一元素\n    → Decision: 如果 indicesMap 沒有 key val 或 indicesMap[val] 為空? // 沒有該值\n        No → Return false // 無法刪除\n        Yes → // 有待刪除的元素\n            → Step 1: idx ← indicesMap[val].任意取一個索引 // 任取\n            → Step 2: lastIdx ← values.length - 1 // 最後一個元素的索引\n            → Step 3: lastVal ← values[lastIdx] // 取得最後一個元素值\n            → Step 4: values[idx] ← lastVal // 把最後一個元素移到要刪除的位置\n            → Step 5: indicesMap[lastVal].remove(lastIdx) // 移除 lastVal 原本在最後的位置\n            → Step 6: 若 idx != lastIdx 則 indicesMap[lastVal].add(idx) // 將移動後的位置加入集合\n            → Step 7: indicesMap[val].remove(idx) // 移除要刪除元素的索引\n            → Step 8: 若 indicesMap[val] 為空 則 刪除 indicesMap[val] // 清理空集合\n            → Step 9: values.pop() // 刪除陣列最後元素\n            → Return true // 刪除成功\n\n→ Method getRandom() : int // 隨機取元素\n    → Step 1: n ← values.length // 取得陣列長度\n    → Step 2: r ← random_integer(0, n-1) // 產生 0~n-1 的隨機整數\n    → Return values[r] // 以隨機索引回傳元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpaicloe57.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmpaicloe57.py\", line 46, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[], [1], [2], [], [3], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # 小堆 (max-heap) 用負數存儲\n        self.small = []  # 所有小於等於中位數的數字\n        # 大堆 (min-heap) 用正數存儲\n        self.large = []  # 所有大於等於中位數的數字\n\n    def addNum(self, num: int) -> None:\n        # 把新數加入小堆\n        heapq.heappush(self.small, -num)\n\n        # 保證所有小堆中的數字都 <= 所有大堆中的數字\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡兩個堆，確保大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：兩個列表，分別是操作名稱和參數\n    # 例如：\"[\\\"MedianFinder\\\", \\\"addNum\\\", \\\"addNum\\\", \\\"findMedian\\\", \\\"addNum\\\", \\\"findMedian\\\"], [[], [1], [2], [], [3], []]\"\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'\n    args_str = '[' + parts[1]\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            res.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            res.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            res.append(median)\n\n    # 將結果轉為 Leetcode 風格輸出，None 用 null 表示\n    out = '[' + ', '.join('null' if v is None else str(v) for v in res) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step: The class MedianFinder: initialization: two heaps: maxHeap for lower half, minHeap for upper half. When adding number: push into maxHeap, then balance. For findMedian: if size equal, return avg of tops, else top of larger heap. Let's produce stepwise.\n\nWe must adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe need to include Start and End. Also decision nodes.\n\nLet's outline steps: Start → Step: Initialize MedianFinder → Step: addNum logic → Step: findMedian logic. We can separate methods.\n\nSo produce something like:\n\nStart // 程式開始執行\n→ Step: 定義 MedianFinder 類別 // 宣告類別\n    → Step: 初始化 maxHeap 與 minHeap // 兩個堆\n    → Step: 初始化 sizes // 兩個堆的大小\n→ Decision: addNum 方法\n    → Step: 將 num 加入 maxHeap // 把新數放進左半部\n    → Decision: maxHeap 大於 minHeap? // 確保兩堆平衡\n        Yes → Step: 將 maxHeap.top() 移到 minHeap // 轉移\n    → Decision: minHeap 大於 maxHeap? // 再次檢查\n        Yes → Step: 將 minHeap.top() 移到 maxHeap // 轉移\n→ Decision: findMedian 方法\n    → Decision: maxHeap.size() 等於 minHeap.size()? // 數量相等\n        Yes → Step: 取兩堆頂並計算平均 // 取得中位數\n        No → Decision: maxHeap.size() 大於 minHeap.size()? // 判斷哪堆較大\n            Yes → Step: 回傳 maxHeap.top() // 中位數\n            No  → Step: 回傳 minHeap.top() // 中位數\nEnd // 程式執行結束\n\nWe should add explanatory comments in Chinese.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義 MedianFinder 類別 // 宣告類別並準備成員  \n    → Step: 初始化 maxHeap 與 minHeap // maxHeap 為大根堆，minHeap 為小根堆  \n    → Step: 初始化 heapSize 為 0 // 追蹤總數量  \n\n→ Step: 定義 addNum(num) 方法 // 新增元素到資料結構  \n    → Step: 將 num 放入 maxHeap // 暫時放入左半部  \n    → Decision: maxHeap.size() > minHeap.size() + 1? // 確保最大堆不比最小堆多兩個以上  \n        Yes → Step: 取 maxHeap.top() 並移至 minHeap // 轉移最大值到右半部  \n    → Decision: minHeap.size() > maxHeap.size() + 1? // 確保最小堆不比最大堆多兩個以上  \n        Yes → Step: 取 minHeap.top() 並移至 maxHeap // 轉移最小值到左半部  \n    → Step: heapSize++ // 更新總數量  \n\n→ Step: 定義 findMedian() 方法 // 回傳目前中位數  \n    → Decision: maxHeap.size() == minHeap.size()? // 數量相等，兩堆皆平衡  \n        Yes → Step: median ← (maxHeap.top() + minHeap.top()) / 2.0 // 兩個中位數平均  \n    → Decision: maxHeap.size() > minHeap.size()? // 左半部較多  \n        Yes → Step: median ← maxHeap.top() // 取左半部頂點  \n        No  → Step: median ← minHeap.top() // 取右半部頂點  \n    → Step: 返回 median // 結果返回  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmparl7r69_.py\", line 62, in <module>\n    result = sol.insert(intervals, new_interval)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmparl7r69_.py\", line 11, in insert\n    while i < n and intervals[i][1] < newInterval[0]:\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5x1wgqff.py\", line 62, in <module>\n    result = sol.insert(intervals, new_interval)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5x1wgqff.py\", line 11, in insert\n    while i < n and intervals[i][1] < newInterval[0]:\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Add the merged interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如:\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    的字串，回傳 (intervals, newInterval)。\n    \"\"\"\n    # 移除所有空白字元以簡化處理\n    data = re.sub(r'\\s+', '', data)\n\n    # 取得 intervals 部分\n    match_int = re.search(r'intervals=([\\[\\]\\d,]+)', data)\n    if not match_int:\n        raise ValueError(\"無法找到 intervals\")\n    intervals = eval(match_int.group(1))\n\n    # 取得 newInterval 部分\n    match_new = re.search(r'newInterval=([\\[\\]\\d,]+)', data)\n    if not match_new:\n        raise ValueError(\"無法找到 newInterval\")\n    new_interval = eval(match_new.group(1))\n\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    intervals, new_interval = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.insert(intervals, new_interval)\n\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output pseudocode steps for merging intervals. Use virtual code lines with arrow etc. Provide explanation after each line. Must be in Traditional Chinese. No actual code, just structure. Use Start, End, Decision: etc.\n\nWe need to insert newInterval into sorted list of non-overlapping intervals and merge as needed. Steps: initialize result list, iterate intervals, compare newInterval start with current interval end to decide placement. Use merging logic: while intervals overlap, merge into newInterval. Then after loop, append newInterval. Then append remaining intervals.\n\nWe must produce step-by-step virtual code lines. Probably about 15 lines. Use arrows.\n\nLet's create pseudocode:\n\nStart\n→ Step 1: Initialize merged list empty // 建立結果陣列\n→ Step 2: Initialize i = 0 // 指標遍歷 intervals\n→ Decision: 是否 i < len(intervals)? // 判斷是否還有未處理區間\n    Yes → Step 3: If intervals[i].end < newInterval.start? // 當前區間完全在新區間之前\n        Yes → Step 4: Append intervals[i] to merged // 直接加入結果\n            No  → Decision: 是否 intervals[i].start > newInterval.end? // 當前區間完全在新區間之後\n                Yes → Step 5: Append newInterval to merged // 將新區間加入\n                    No → Step 6: Merge newInterval and intervals[i] into newInterval // 兩區間重疊，合併\n            No → Step 7: i += 1 // 移動到下一個區間\n    No → Step 8: Append newInterval to merged // 若所有區間都已處理，將新區間加入\n→ Decision: 是否 i < len(intervals)? // 是否還有剩餘區間\n    Yes → Step 9: Append intervals[i] to merged // 追加剩餘區間\n        No → End // 程式結束\nBut we need a better loop structure.\n\nMaybe:\n\nStart\n→ Step 1: merged = [] // 建立結果列表\n→ Step 2: i = 0 // 初始索引\n→ Decision: i < intervals.length? // 是否有未處理區間\n    Yes → Decision: intervals[i].end < newInterval.start? // 前區間在新區間之前\n        Yes → Step 3: merged.append(intervals[i]) // 加入前區間\n            No → Decision: intervals[i].start > newInterval.end? // 前區間在新區間之後\n                Yes → Step 4: merged.append(newInterval) // 加入新區間\n                    No → Step 5: Merge intervals[i] into newInterval // 合併\n                No → Step 6: i += 1 // 進行下一個區間\n    No → Step 7: merged.append(newInterval) // 所有區間都已檢查，加入新區間\n→ Step 8: While i < intervals.length: // 將剩餘區間加入\n    → Step 9: merged.append(intervals[i]) // 追加\n    → Step 10: i += 1\nEnd\n\nBut we need to handle that after merging, we continue loop? Let's produce clear algorithm: Use three phases: add all before newInterval, merge overlapping, add all after.\n\nSimplify:\n\nStart\n→ Step 1: merged = [] // 結果陣列\n→ Step 2: i = 0 // 指標\n→ Decision: i < len(intervals)? // 循環前\n    Yes → Step 3: If intervals[i].end < newInterval.start? // 前區間結束在新區間開始前\n        Yes → Step 4: merged.append(intervals[i]) // 加入前區間\n            No → Decision: intervals[i].start > newInterval.end? // 前區間開始在新區間結束後\n                Yes → Step 5: merged.append(newInterval) // 加入新區間\n                    No → Step 6: newInterval = [min(newInterval.start, intervals[i].start), max(newInterval.end, intervals[i].end)] // 合併\n                No → Step 7: i += 1 // 繼續檢查下一個區間\n    No → Step 8: merged.append(newInterval) // 所有區間處理完畢，加入新區間\n→ Decision: i < len(intervals)? // 若仍有剩餘區間\n    Yes → Step 9: merged.append(intervals[i]) // 加入剩餘區間\n        No → End\n\nBut we also need loop after step 9? Actually we need while.\n\nLet's produce more standard pseudocode:\n\nStart\n→ Step 1: merged = [] // 結果陣列\n→ Step 2: i = 0 // 索引\n→ Decision: i < len(intervals)? // 判斷是否還有區間\n    Yes → Decision: intervals[i].end < newInterval.start? // 前區間在新區間之前\n        Yes → Step 3: merged.append(intervals[i]) // 加入前區間\n            No → Decision: intervals[i].start > newInterval.end? // 前區間在新區間之後\n                Yes → Step 4: merged.append(newInterval) // 加入新區間\n                    No → Step 5: newInterval = merge(newInterval, intervals[i]) // 合併兩區間\n                No → Step 6: i += 1 // 繼續\n    No → Step 7: merged.append(newInterval) // 新區間還未加入\n→ Decision: i < len(intervals)? // 是否還有區間\n    Yes → Step 8: merged.append(intervals[i]) // 加入剩餘區間\n        No → End\n\nBut we need loop for step 8: while i < len(intervals). We'll produce loop.\n\nSimplify final pseudocode:\n\nStart\n→ Step 1: merged = [] // 初始結果陣列\n→ Step 2: i = 0 // 指向 intervals\n→ Decision: i < len(intervals)? // 是否還有未處理區間\n    Yes → Decision: intervals[i].end < newInterval.start? // 整個區間在新區間之前\n        Yes → Step 3: merged.append(intervals[i]) // 加入前區間\n            No → Decision: intervals[i].start > newInterval.end? // 整個區間在新區間之後\n                Yes → Step 4: merged.append(newInterval) // 加入新區間\n                    No → Step 5: newInterval = [min(newInterval.start, intervals[i].start), max(newInterval.end, intervals[i].end)] // 合併\n                No → Step 6: i += 1 // 移到下一個區間\n    No → Step 7: merged.append(newInterval) // 所有區間已檢查，加入新區間\n→ Step 8: While i < len(intervals): // 將剩餘區間加入\n    → Step 9: merged.append(intervals[i]) // 加入\n    → Step 10: i += 1\nEnd\n\nLet's produce each line with arrow and explanation.\n\nMake sure each line ends with // 解釋.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: merged = [] // 建立空的結果陣列\n→ Step 2: i = 0 // 初始化索引，用於遍歷 intervals\n→ Decision: i < len(intervals)? // 判斷是否還有未處理的區間\n    Yes → Decision: intervals[i].end < newInterval.start? // 現有區間完全在新區間之前\n        Yes → Step 3: merged.append(intervals[i]) // 將前區間直接加入結果\n            No → Decision: intervals[i].start > newInterval.end? // 現有區間完全在新區間之後\n                Yes → Step 4: merged.append(newInterval) // 把新區間插入結果\n                    No → Step 5: newInterval = [min(newInterval.start, intervals[i].start), max(newInterval.end, intervals[i].end)] // 合併重疊區間\n                No → Step 6: i += 1 // 前往下一個區間\n    No → Step 7: merged.append(newInterval) // 所有原始區間已檢查完，將新區間加入結果\n→ Step 8: While i < len(intervals): // 循環將剩餘的區間直接加入\n    → Step 9: merged.append(intervals[i]) // 加入當前剩餘區間\n    → Step 10: i += 1 // 移動到下一個\nEnd // 程式執行結束，返回 merged\n\n（以上虛擬碼步驟描述了插入新區間並合併重疊的整個流程。）"
    },
    {
      "title": "Find the Closest Palindrome",
      "source_file": "Leetcode/leetcode564.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = \"1\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '\"2\"'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        length = len(n)\n        num = int(n)\n        candidates = set()\n\n        # 1. 10^length + 1  (e.g., 100...001)\n        candidates.add(str(10 ** length + 1))\n        # 2. 10^(length-1) - 1  (e.g., 99...9, only if length > 1)\n        if length > 1:\n            candidates.add(str(10 ** (length - 1) - 1))\n\n        # 3. Palindromes derived from the prefix\n        prefix_len = (length + 1) // 2\n        prefix = int(n[:prefix_len])\n        for delta in (0, -1, 1):\n            new_prefix = prefix + delta\n            if new_prefix <= 0 or new_prefix >= 10 ** prefix_len:\n                # skip invalid prefixes (leading zero or too many digits)\n                continue\n            new_prefix_str = str(new_prefix)\n            if length % 2 == 0:\n                # even length: mirror the whole prefix\n                palin = new_prefix_str + new_prefix_str[::-1]\n            else:\n                # odd length: mirror all but the last digit of the prefix\n                palin = new_prefix_str + new_prefix_str[:-1][::-1]\n            candidates.add(palin)\n\n        # 4. Exclude the original number itself\n        candidates.discard(n)\n\n        # 5. Find the best candidate\n        best = None\n        best_diff = None\n        for cand in candidates:\n            if cand == n:\n                continue\n            cand_val = int(cand)\n            if cand_val < 0:  # ignore negative numbers\n                continue\n            diff = abs(cand_val - num)\n            if best_diff is None or diff < best_diff or (diff == best_diff and cand_val < int(best)):\n                best = cand\n                best_diff = diff\n\n        return best\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    # Extract the string inside double quotes if present\n    if 'n' in data:\n        first_quote = data.find('\"')\n        last_quote = data.rfind('\"')\n        if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n            n = data[first_quote + 1:last_quote]\n        else:\n            # fallback: remove 'n = ' and surrounding quotes\n            parts = data.split('=')[-1].strip()\n            n = parts.strip('\"')\n    else:\n        n = data.strip('\"')\n\n    solution = Solution()\n    result = solution.nearestPalindromic(n)\n    print(f'\"{result}\"')",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm to find nearest palindrome to integer string n, excluding itself. If tie, return smaller.\n\nNeed step-by-step, each line with arrow and explanation. Use Start, Decision, End.\n\nWe need to design algorithm. We can compute nearest palindrome by generating candidates: same length, length-1, length+1. Classic LeetCode problem.\n\nSo steps: input string n. If length 1: return n-1 or n+1? The nearest palindrome to single digit excluding itself: 0? But consider 9? nearest palindrome is 8 or 10? 10 is not palindrome? Actually 10 not palindrome. So for single digit, answer is n-1 if n>0 else 1? For 0, nearest palindrome is 1? But 0 itself is palindrome, but exclude itself. So for 0, nearest palindrome is 1 (difference 1). For 1, nearest is 0 or 2? 0 diff 1, 2 diff 1, choose smaller: 0. Good. So algorithm for length 1: return string of n-1 unless n==0 then 1. But we can general algorithm.\n\nGeneral algorithm: create candidate list: \n- all 9's of length-1: e.g., 99...9 \n- 10...01 of length+1: 100...001\n- palindrome formed by prefix of n, same length: get prefix = n[0:ceil(len/2)], convert to int, then create palindrome by mirroring. \n- Also prefix-1 and prefix+1 mirrored. \nCompute absolute diff for each candidate excluding itself. Select min diff; if tie choose smaller numeric value.\n\nImplement pseudocode.\n\nWe must produce line by line.\n\nLet's plan steps:\n\nStart\n→ Step: Read input string n\n→ Step: If length of n == 1: compute special case\n    → Step: Convert to int digit\n    → Decision: If digit == 0: Candidate = \"1\" else Candidate = str(digit-1) if digit>0\n    → Step: Return Candidate\n→ Step: Determine length L\n→ Step: Initialize empty candidate list C\n→ Step: Add 10^L + 1 palindrome: e.g., \"1\" + zeros(L-1) + \"1\" // produce string\n→ Step: Add 10^(L-1) - 1 palindrome: e.g., string of L-1 9's\n→ Step: Compute prefix length: P = (L+1)//2\n→ Step: prefix = first P digits of n\n→ Step: For delta in [0, -1, +1]:\n    → Step: new_prefix = prefix + delta\n    → Decision: If new_prefix has leading zero or length mismatch? skip\n    → Step: build palindrome by mirroring new_prefix to length L\n    → Step: add to C\n→ Step: For each candidate in C:\n    → Decision: If candidate == n: skip\n    → Step: compute abs diff with n\n    → Keep track of best: smaller diff or tie smaller value\n→ End: Return best candidate string\n\nNeed to produce each line with arrow and comment.\n\nAlso need to produce lines for loops and decisions properly.\n\nLet's produce pseudocode lines:\n\nStart // 程式開始執行\n→ Step: Input n // 讀取輸入字串 n\n→ Decision: 如果 n 長度 == 1? // 特殊情況處理\n    Yes → Step: digit = int(n) // 轉換為整數\n    Yes → Decision: 如果 digit == 0? // 0 的最近回文是 1\n        Yes → Step: best = \"1\" // 回傳 1\n        No  → Step: best = str(digit - 1) // 回傳前一個數字\n    Yes → Step: Return best // 結束特殊情況\n    No  → Step: L = len(n) // 總長度\n→ Step: C = [] // 建立候選集合\n→ Step: C.append( \"1\" + \"0\"*(L-1) + \"1\" ) // L+1 長度的 100...001\n→ Step: If L > 1: C.append( \"9\"*(L-1) ) // L-1 長度的 99...9\n→ Step: P = (L+1)//2 // 前半段長度\n→ Step: prefix = int(n[:P]) // 取前半段數字\n→ Decision: For delta in [0, -1, +1]: // 三種前半段變化\n    Yes → Step: new_prefix = prefix + delta\n    Yes → Decision: new_prefix 可能有前導零或長度不符? // 若新前半段為負或長度大於 P, 跳過\n        Yes → Step: continue\n    Yes → Step: if L % 2 == 0:\n        Yes → Step: pal = str(new_prefix) + str(new_prefix)[::-1]\n        No  → Step: pal = str(new_prefix) + str(new_prefix)[-2::-1] // 反轉除最後一位\n    Yes → Step: C.append(pal) // 加入候選\n→ Step: best = None\n→ Step: best_diff = None\n→ Step: For cand in C: // 逐一評估候選\n    Yes → Decision: if cand == n: continue // 排除自己\n        Yes → Step: diff = abs(int(cand) - int(n))\n        Yes → Decision: if best_diff is None or diff < best_diff or (diff == best_diff and int(cand) < int(best)):\n            Yes → Step: best = cand\n            Yes → Step: best_diff = diff\n→ End // 程式執行結束\n→ Step: Return best // 輸出最近回文\n\nBut we need each line with arrow, not indentation? The example uses indentations with arrow at beginning of each line. We need to show arrow at each line, maybe using indentation with arrows.\n\nWe should use \"→\" arrow before each step. For decisions, we show \"Decision:\" and then Yes/No arrow indent.\n\nWe should keep consistent formatting.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: Input n // 讀取輸入字串 n\n→ Decision: 如果 n 長度 == 1? // 特殊情況處理\n    Yes → Step: digit = int(n) // 轉換為整數\n    Yes → Decision: 如果 digit == 0? // 0 的最近回文是 1\n        Yes → Step: best = \"1\" // 回傳 1\n        No  → Step: best = str(digit - 1) // 回傳前一個數字\n    Yes → Step: Return best // 結束特殊情況\n    No  → Step: L = len(n) // 總長度\n→ Step: C = [] // 建立候選集合\n→ Step: C.append( \"1\" + \"0\"*(L-1) + \"1\" ) // L+1 長度的 100…001\n→ Decision: 如果 L > 1? // 加入 L-1 長度的 99…9\n    Yes → Step: C.append( \"9\"*(L-1) )\n→ Step: P = (L+1)//2 // 前半段長度\n→ Step: prefix = int(n[:P]) // 取前半段數字\n→ Decision: For delta in [0, -1, +1]: // 三種前半段變化\n    Yes → Step: new_prefix = prefix + delta\n    Yes → Decision: 如果 new_prefix <= 0 or new_prefix >= 10**P? // 前導零或長度不符\n        Yes → Step: continue // 跳過此候選\n    Yes → Decision: 如果 L % 2 == 0? // 偶數長度\n        Yes → Step: pal = str(new_prefix) + str(new_prefix)[::-1] // 直接鏡像\n        No  → Step: pal = str(new_prefix) + str(new_prefix)[-2::-1] // 只鏡像除最後一位\n    Yes → Step: C.append(pal) // 加入候選\n→ Step: best = None // 最佳候選\n→ Step: best_diff = None // 最小差距\n→ Step: For cand in C: // 評估每個候選\n    Yes → Decision: 如果 cand == n? // 排除自身\n        Yes → Step: continue\n    Yes → Step: diff = abs(int(cand) - int(n))\n    Yes → Decision: 如果 best_diff is None or diff < best_diff or (diff == best_diff and int(cand) < int(best))? // 比較差距或大小\n        Yes → Step: best = cand\n        Yes → Step: best_diff = diff\n→ End // 程式執行結束\n→ Step: Return best // 輸出最近回文字串"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp8wtd4ql.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpp8wtd4ql.py\", line 39, in main\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 76 (char 75)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"\n    LRU Cache implementation using OrderedDict.\n    Operations get and put run in O(1) average time.\n    \"\"\"\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # Move key to the end to mark it as recently used\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            # Remove the first item (least recently used)\n            self.cache.popitem(last=False)\n\ndef main() -> None:\n    \"\"\"\n    Reads input from stdin, processes LRUCache operations,\n    and prints the results as a JSON array.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Input format: two JSON arrays: operations and arguments\n    ops, args = json.loads(data)\n    results = []\n    cache = None\n\n    for op, arg in zip(ops, args):\n        if op == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            value = cache.get(arg[0])\n            results.append(value)\n\n    # Output as JSON to match expected 'null' representation\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with comments. The virtual code should describe design of LRUCache, including initialization, get, put operations, using a hashmap and a doubly linked list. Provide steps. Must use virtual code syntax with arrows and structure.\n\nWe need to generate virtual code lines, each line: \"虛擬碼步驟 // 解釋\". The lines can include arrows →, Decision etc.\n\nWe need to outline design. Let's produce something like:\n\nStart\n→ Define class LRUCache\n    → Data members: capacity, map (key->node), head, tail sentinel nodes for doubly linked list\n    → Constructor: set capacity, create head/tail, connect them\n→ Method get(key)\n    → Decision: key in map?\n        Yes → Move node to front (most recently used)\n             → Return node.value\n        No → Return -1\n→ Method put(key, value)\n    → Decision: key in map?\n        Yes → Update node.value; Move node to front\n        No → Create new node; Add to map; Add node to front\n             → Decision: size > capacity?\n                 Yes → Remove tail.prev (least recently used) from list and map\nEnd\n\nBut we need to show steps line by line, with arrows.\n\nWe need to show the virtual code lines: maybe each line can start with \"→\" or \"Decision:\" etc.\n\nLet's produce a more detailed step-by-step.\n\nWe also need to ensure each line ends with // comment. Let's start with \"Start\".\n\nWe'll output:\n\nStart // 程式開始\n→ Define class LRUCache // 定義 LRUCache 類別\n    → Data members: capacity // 最大容量\n    → Data members: map // HashMap  key → Node\n    → Data members: head, tail // 雙向鏈表哨兵節點\n→ Constructor LRUCache(capacity)\n    → Set this.capacity = capacity\n    → Create head = new Node(0,0)\n    → Create tail = new Node(0,0)\n    → Link head.next = tail, tail.prev = head\n→ Method get(key)\n    → Decision: key exists in map?\n        Yes → node = map[key]\n             → Move node to front // 更新為最近使用\n             → Return node.value\n        No → Return -1 // 缺失返回 -1\n→ Method put(key, value)\n    → Decision: key exists in map?\n        Yes → node = map[key]\n             → node.value = value\n             → Move node to front\n        No → Create node = new Node(key, value)\n             → map[key] = node\n             → Add node to front\n             → Decision: map.size > capacity?\n                 Yes → lru = tail.prev\n                      → Remove lru from list\n                      → Delete map[lru.key]\nEnd // 程式結束\n\nWe need to ensure arrows and indentation properly. Each line must contain arrow or indentation.\n\nBut the instruction says \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\" So we should follow that. Use Decision: block.\n\nMaybe we need to format:\n\nStart // 程式開始\n→ Class LRUCache // 定義 LRUCache\n    → Data members: capacity, map, head, tail // 主要資料\n→ Constructor(capacity) // 初始化\n    → Set capacity\n    → Create head, tail\n    → Link head <-> tail\n→ Method get(key) // 取得值\n    → Decision: key in map?\n        Yes → node = map[key]\n             → MoveToFront(node)\n             → Return node.value\n        No  → Return -1\n→ Method put(key, value) // 插入或更新\n    → Decision: key in map?\n        Yes → node = map[key]\n             → node.value = value\n             → MoveToFront(node)\n        No  → node = new Node(key, value)\n             → map[key] = node\n             → AddToFront(node)\n             → Decision: map.size > capacity?\n                 Yes → lru = tail.prev\n                      → RemoveNode(lru)\n                      → Delete map[lru.key]\nEnd // 程式結束\n\nBut each line must have arrow at beginning? Example: \"→ Decision: ...\" or \"    → ...\" etc. Indentation may use spaces.\n\nLet's produce lines as required.\n\nAlso ensure each line has a comment after space: \"// ...\"\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Class LRUCache // 定義 LRUCache 類別  \n&nbsp;&nbsp;→ Data members: capacity, map, head, tail // 主要資料：容量、哈希表、哨兵節點  \n→ Constructor(capacity) // 初始化 LRUCache  \n&nbsp;&nbsp;→ Set this.capacity = capacity // 設定最大容量  \n&nbsp;&nbsp;→ Create head = new Node(0,0) // 哨兵頭節點  \n&nbsp;&nbsp;→ Create tail = new Node(0,0) // 哨兵尾節點  \n&nbsp;&nbsp;→ Link head.next = tail, tail.prev = head // 形成空雙向鏈表  \n→ Method get(key) // 取得鍵對應的值  \n&nbsp;&nbsp;→ Decision: key exists in map? // 檢查鍵是否已存在  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → node = map[key] // 取得節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ MoveToFront(node) // 標記為最近使用  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Return node.value // 回傳值  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Return -1 // 鍵不存在，回傳 -1  \n→ Method put(key, value) // 插入或更新鍵值對  \n&nbsp;&nbsp;→ Decision: key exists in map? // 檢查鍵是否已存在  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → node = map[key] // 取得節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ node.value = value // 更新值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ MoveToFront(node) // 標記為最近使用  \n&nbsp;&nbsp;&nbsp;&nbsp;No → node = new Node(key, value) // 新建節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ map[key] = node // 加入哈希表  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ AddToFront(node) // 插入最前面  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: map.size > capacity? // 是否超出容量  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → lru = tail.prev // 最舊節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ RemoveNode(lru) // 從鏈表移除  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Delete map[lru.key] // 從哈希表刪除  \nEnd // 程式結束"
    },
    {
      "title": "Find the Difference",
      "source_file": "Leetcode/leetcode389.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkdv070lh.py\", line 38, in <module>\n    main()\n  File \"/tmp/tmpkdv070lh.py\", line 33, in main\n    added_char = find_added(s, t)\n                 ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkdv070lh.py\", line 11, in find_added\n    return chr(diff)\n           ^^^^^^^^^\nValueError: chr() arg not in range(0x110000)"
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbqcxn1di.py\", line 38, in <module>\n    main()\n  File \"/tmp/tmpbqcxn1di.py\", line 33, in main\n    added_char = find_added(s, t)\n                 ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbqcxn1di.py\", line 11, in find_added\n    return chr(diff)\n           ^^^^^^^^^\nValueError: chr() arg not in range(0x110000)"
        }
      ],
      "generated_code": "import sys\n\ndef find_added(s: str, t: str) -> str:\n    \"\"\"\n    找出 t 中多出的那個字母。\n    方法：將兩個字串的 ASCII 總和相減，即可得到多出的字母的 ASCII 值。\n    \"\"\"\n    sum_s = sum(ord(ch) for ch in s)\n    sum_t = sum(ord(ch) for ch in t)\n    diff = sum_t - sum_s\n    return chr(diff)\n\ndef main() -> None:\n    # 讀取所有輸入，將空行忽略\n    lines = [line.strip() for line in sys.stdin.read().splitlines() if line.strip()]\n    \n    if len(lines) >= 2:\n        s, t = lines[0], lines[1]\n    elif len(lines) == 1:\n        # 可能一次輸入兩個字串，中間用空白分隔\n        parts = lines[0].split()\n        if len(parts) >= 2:\n            s, t = parts[0], parts[1]\n        else:\n            # 無法解析輸入\n            print(\"Invalid input\")\n            return\n    else:\n        # 沒有足夠的輸入\n        print(\"Invalid input\")\n        return\n\n    added_char = find_added(s, t)\n    # 根據範例輸出，需在字元外加雙引號\n    print(f'\"{added_char}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that explain algorithm: find extra letter between t and s. Approach: count frequency difference or sum ASCII values difference.\n\nWe will output in required format: each line \"虛擬碼步驟 // 解釋\" with arrows. Use Start, End, Decision. Provide step-by-step. Use lines like \"Start // 程式開始執行\". Use \"→ Step 1: 初始化變量\" etc.\n\nWe need to provide algorithm: input strings s, t. Compute sum of ASCII codes difference: sum(t) - sum(s) gives ASCII of added char. Or count difference: build frequency map.\n\nLet's choose sum method. Provide steps: sumS ← 0; sumT ← 0; for each char in s sumS += ord(char). for each char in t sumT += ord(char). added = chr(sumT - sumS). Output added.\n\nAlso handle if t contains all characters of s plus one extra.\n\nLet's produce virtual code. Include Decision for if t length = s length +1. But assumption holds.\n\nLet's produce lines.\n\nLet's produce as: \nStart // start\n→ Step 1: 計算 s 的字母碼總和 // ...\n→ Step 2: 計算 t 的字母碼總和 // ...\n→ Step 3: 計算差值 // ...\n→ Step 4: 轉換差值為字符 // ...\n→ Step 5: 回傳新增字母 // ...\nEnd // end\n\nBut we need to use arrow syntax: \"→ Step 1: ...\". For decisions maybe not needed. Could add decision: if len(t) == len(s)+1? etc.\n\nBut instructions: \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\". So we should include a Decision maybe for verifying length.\n\nLet's create:\n\nStart // 程式開始\n→ Step 1: 取得輸入字串 s, t // 獲取兩個字串\n→ Decision: t 的長度是否等於 s 的長度 + 1? // 確認 t 多一個字母\n    Yes → Step 2: 計算 s 的字母碼總和 // ...\n    No  → Step 3: 回報錯誤 // ...\n→ Step 3: 計算 t 的字母碼總和 // ...\n→ Step 4: 取得差值 diff = sumT - sumS // ...\n→ Step 5: 將 diff 轉為字符 added = chr(diff) // ...\n→ Step 6: 回傳 added // ...\nEnd // 程式結束\n\nBut need to align numbering. Also step numbers may skip after decision. Could rename after decision accordingly. Use consistent numbering.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s 與 t // 從使用者取得兩個字串  \n→ Decision: t 的長度是否等於 s 的長度 + 1? // 確認 t 比 s 多一個字母  \n  Yes → Step 2: 計算 s 的字母碼總和 sumS ← 0; 逐個字元 c ∈ s sumS ← sumS + ord(c) // 求 s 的 ASCII 總和  \n  No  → Step 3: 回報錯誤訊息並終止 // 若長度不符，無法執行  \n→ Step 4: 計算 t 的字母碼總和 sumT ← 0; 逐個字元 c ∈ t sumT ← sumT + ord(c) // 求 t 的 ASCII 總和  \n→ Step 5: 取得差值 diff ← sumT - sumS // 差值即為新增字母的 ASCII 代碼  \n→ Step 6: 轉換差值為字元 added ← chr(diff) // 取得真正的新增字母  \n→ Step 7: 回傳 added // 回傳結果給使用者  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        print(\"[]\")\n        return\n    lines = data.strip().splitlines()\n    results = []\n    rng = None\n    for line in lines:\n        line = line.strip().rstrip(';')\n        if not line:\n            continue\n        if \"new RangeModule\" in line:\n            rng = RangeModule()\n            results.append(None)\n            continue\n        m = re.search(r'(\\w+)\\(([^)]*)\\)', line)\n        if not m:\n            continue\n        method, args_str = m.group(1), m.group(2)\n        args = [int(x.strip()) for x in args_str.split(',')] if args_str else []\n        if rng is None:\n            continue\n        if method == 'addRange':\n            rng.addRange(*args)\n            results.append(None)\n        elif method == 'removeRange':\n            rng.removeRange(*args)\n            results.append(None)\n        elif method == 'queryRange':\n            res = rng.queryRange(*args)\n            results.append(res)\n    out_parts = []\n    for r in results:\n        if r is None:\n            out_parts.append(\"null\")\n        elif isinstance(r, bool):\n            out_parts.append(\"true\" if r else \"false\")\n        else:\n            out_parts.append(str(r))\n    print(\"[\" + \", \".join(out_parts) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo code steps. The problem: design a RangeModule. We need to produce virtual code lines explaining data structure and operations. Likely we will use a balanced BST or intervals list. Provide step-by-step: initialize with empty list. addRange merges intervals. queryRange checks coverage. removeRange splits intervals. We will output each step with explanation.\n\nWe must use arrow notation and decisions.\n\nLet's produce a pseudo algorithm for the class methods.\n\nWe'll start with Start. Then steps: define class. Then Start for constructor. Then Step for addRange. Steps for merging: find position. Use intervals list. Provide decision steps for overlapping.\n\nSame for queryRange: iterate.\n\nRemoveRange: split.\n\nWe need to keep within format: each line: \"虛擬碼步驟 // 解釋\". So each line we will produce one line of pseudo code and comment.\n\nWe need to produce sequential lines, not grouping inside functions? Possibly we produce one pseudo code block showing the methods sequentially.\n\nWe'll start with Start. Then Step 1: Define class RangeModule // Data structure with list of intervals.\n\nThen Step 2: Define intervals list // store as sorted list of [start,end)\n\nThen constructor: Step 3: Initialize intervals to empty list // no ranges tracked.\n\nThen addRange: Step 4: Function addRange(left,right) // add half-open interval\n\nWithin addRange: Step 5: Find first interval that might overlap using binary search // position i where end > left\n\nStep 6: Initialize new_start = left, new_end = right\n\nStep 7: Decision: If intervals[i] exists and intervals[i].start <= right? // overlapping\n\nBut we need to merge all overlapping intervals: While i < size and intervals[i].start <= new_end:\n\n- Update new_start = min(new_start, intervals[i].start)\n- Update new_end = max(new_end, intervals[i].end)\n- Remove intervals[i]\n\nEnd While\n\nThen Step 8: Insert [new_start,new_end] at position i // keep sorted\n\nSimilarly queryRange: Function queryRange(left,right):\n\nStep: Find interval that might cover left using binary search: find i where intervals[i].end > left.\n\nDecision: If i == size or intervals[i].start > left: return false\n\nElse: check if intervals[i].end >= right: return true else return false\n\nRemoveRange: similar to add but subtract.\n\nImplementation details: Remove: find first overlapping interval i.\n\nWhile i < size and intervals[i].start < right:\n\n- If intervals[i].end <= left: i++ // no overlap\n\n- Else if intervals[i].start < left and intervals[i].end > right: // interval contains removal range fully\n\n   split into [start,left] and [right,end] by adjusting.\n\n- Else if intervals[i].start < left and intervals[i].end <= right: // overlap left side\n\n   adjust end to left\n\n- Else if intervals[i].start >= left and intervals[i].end > right: // overlap right side\n\n   adjust start to right\n\n- Else // fully inside removal range\n\n   remove interval\n\n   i++ etc\n\nEnd While\n\nSimplify: we can handle by iterating and building new list.\n\nBut we just produce pseudocode steps. Let's produce concise steps.\n\nWe need to be careful about each line: \"Step X: ...\" each line separate. For loops, decisions use indentation maybe? But we must keep one line per step. Use indentation via spaces? It's allowed to show hierarchical decisions with indent.\n\nBetter: Use Step, Decision with indentation lines. For each decision, we use nested lines.\n\nLet's produce:\n\nStart // start program\n\n→ Step 1: Define class RangeModule // container for range operations\n\n→ Step 2: Define intervals as sorted list of [start,end) // store tracked ranges\n\n→ Step 3: Constructor RangeModule() // initialize empty list\n\n    → Step 3.1: intervals ← [] // empty\n\n→ Step 4: Function addRange(left,right) // add new interval\n\n    → Step 4.1: i ← lower_bound(intervals, left) // first interval with end > left\n\n    → Step 4.2: new_start ← left\n\n    → Step 4.3: new_end ← right\n\n    → Step 4.4: Decision: While i < size(intervals) and intervals[i].start ≤ new_end\n\n        → Step 4.4.1: new_start ← min(new_start, intervals[i].start)\n\n        → Step 4.4.2: new_end ← max(new_end, intervals[i].end)\n\n        → Step 4.4.3: Remove intervals[i] // overlapping interval\n\n    → Step 4.5: Insert [new_start,new_end] at position i // keep sorted\n\n→ Step 5: Function queryRange(left,right) // check full coverage\n\n    → Step 5.1: i ← upper_bound(intervals, left) - 1 // interval that might contain left\n\n    → Step 5.2: Decision: If i < 0 or intervals[i].end ≤ left\n\n        → Step 5.2.1: return false // left not covered\n\n    → Step 5.3: Decision: If intervals[i].end ≥ right\n\n        → Step 5.3.1: return true // fully covered\n\n        → Step 5.3.2: return false // not fully covered\n\n→ Step 6: Function removeRange(left,right) // remove interval\n\n    → Step 6.1: i ← lower_bound(intervals, left) // first interval that may overlap\n\n    → Step 6.2: Decision: While i < size(intervals) and intervals[i].start < right\n\n        → Step 6.2.1: Decision: If intervals[i].end ≤ left\n\n            → Step 6.2.1.1: i++ // no overlap, move on\n\n        → Step 6.2.2: Decision: If intervals[i].start < left and intervals[i].end > right\n\n            → Step 6.2.2.1: intervals[i].end ← left // keep left part\n\n            → Step 6.2.2.2: Insert [right, intervals[i].end] at position i+1 // keep right part\n\n            → Step 6.2.2.3: Break // removal done\n\n        → Step 6.2.3: Decision: If intervals[i].start < left and intervals[i].end ≤ right\n\n            → Step 6.2.3.1: intervals[i].end ← left // truncate right side\n\n            → Step 6.2.3.2: i++ // move to next\n\n        → Step 6.2.4: Decision: If intervals[i].start ≥ left and intervals[i].end > right\n\n            → Step 6.2.4.1: intervals[i].start ← right // truncate left side\n\n            → Step 6.2.4.2: i++ // move on\n\n        → Step 6.2.5: Decision: If intervals[i].start ≥ left and intervals[i].end ≤ right\n\n            → Step 6.2.5.1: Remove intervals[i] // fully covered by removal\n\n            → Step 6.2.5.2: // i remains same because list shrinks\n\n    → Step 6.3: // end while loop\n\nEnd // end program\n\nBut need to format exactly: each line with \"虛擬碼步驟 // 解釋\". Indentation for nested steps might use spaces before the code line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class RangeModule // 建立範圍模組的資料結構  \n→ Step 2: Define intervals as sorted list of [start, end) // 儲存已追蹤的半開區間，保持排序  \n→ Step 3: Constructor RangeModule() // 初始化空集合  \n  → Step 3.1: intervals ← [] // 無任何區間被追蹤  \n→ Step 4: Function addRange(left, right) // 新增半開區間 [left, right)  \n  → Step 4.1: i ← lower_bound(intervals, left) // 找到第一個 end > left 的區間位置  \n  → Step 4.2: new_start ← left  \n  → Step 4.3: new_end ← right  \n  → Step 4.4: Decision: While i < size(intervals) and intervals[i].start ≤ new_end  \n    → Step 4.4.1: new_start ← min(new_start, intervals[i].start) // 合併左端  \n    → Step 4.4.2: new_end ← max(new_end, intervals[i].end) // 合併右端  \n    → Step 4.4.3: Remove intervals[i] // 刪除已重疊區間  \n  → Step 4.5: Insert [new_start, new_end] at position i // 插入合併後的新區間，保持排序  \n→ Step 5: Function queryRange(left, right) // 查詢區間 [left, right) 是否完全被追蹤  \n  → Step 5.1: i ← upper_bound(intervals, left) - 1 // 找到可能包含 left 的區間  \n  → Step 5.2: Decision: If i < 0 or intervals[i].end ≤ left  \n    → Step 5.2.1: return false // left 不在任何已追蹤區間內  \n  → Step 5.3: Decision: If intervals[i].end ≥ right  \n    → Step 5.3.1: return true // 完全被追蹤  \n    → Step 5.3.2: return false // 未完全被追蹤  \n→ Step 6: Function removeRange(left, right) // 移除區間 [left, right) 的追蹤  \n  → Step 6.1: i ← lower_bound(intervals, left) // 找到第一個可能重疊的區間  \n  → Step 6.2: Decision: While i < size(intervals) and intervals[i].start < right  \n    → Step 6.2.1: Decision: If intervals[i].end ≤ left  \n      → Step 6.2.1.1: i++ // 無重疊，移至下一個  \n    → Step 6.2.2: Decision: If intervals[i].start < left and intervals[i].end > right  \n      → Step 6.2.2.1: intervals[i].end ← left // 保留左側部分  \n      → Step 6.2.2.2: Insert [right, intervals[i].end] at position i+1 // 保留右側部分  \n      → Step 6.2.2.3: Break // 已完成移除  \n    → Step 6.2.3: Decision: If intervals[i].start < left and intervals[i].end ≤ right  \n      → Step 6.2.3.1: intervals[i].end ← left // 截斷右側  \n      → Step 6.2.3.2: i++ // 移至下一個  \n    → Step 6.2.4: Decision: If intervals[i].start ≥ left and intervals[i].end > right  \n      → Step 6.2.4.1: intervals[i].start ← right // 截斷左側  \n      → Step 6.2.4.2: i++ // 移至下一個  \n    → Step 6.2.5: Decision: If intervals[i].start ≥ left and intervals[i].end ≤ right  \n      → Step 6.2.5.1: Remove intervals[i] // 完全被移除的區間  \n      → Step 6.2.5.2: // i 位置保持不變，因為列表已收縮  \n  → Step 6.3: // 迴圈結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprvtpn70u.py\", line 63, in <module>\n    ops = json.loads(data[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k          # 存放元素的循環緩衝區\n        self.head = 0               # 指向隊列前端的指標\n        self.count = 0              # 當前隊列中的元素數量\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    ops = json.loads(data[0].strip())\n    args_list = json.loads(data[1].strip())\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args)\n            results.append(None)            # 建構子不返回值，輸出 null\n        else:\n            method = getattr(obj, op)\n            res = method(*args)\n            results.append(res)\n\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a circular double-ended queue. Use steps, decisions, arrows. No actual code. Provide each line with \"虛擬碼步驟 // 解釋\". Format: e.g., \"Start // 程式開始執行\". Use Chinese. We'll break down initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nWe should produce a high-level algorithm.\n\nLet's outline:\n\nStart\n→ Step: Define class MyCircularDeque\n→ Step: Set capacity k\n→ Step: Initialize array of size k\n→ Step: Set front index to 0\n→ Step: Set rear index to -1\n→ Step: Set count to 0\n\nOperations:\n\ninsertFront():\n→ Decision: if count == k? // full\n    Yes → return false\n    No → front = (front - 1 + k) % k\n         arr[front] = value\n         count++\n         return true\n\nBut we need to pass value? The function signature boolean insertFront(int value). Should include value.\n\ninsertLast similar: rear = (rear + 1) % k\n\ndeleteFront:\n→ Decision: if count == 0? // empty\n    Yes → return false\n    No → front = (front + 1) % k\n         count--\n         return true\n\ndeleteLast:\n→ Decision: if count == 0? \n    Yes → return false\n    No → rear = (rear - 1 + k) % k\n         count--\n         return true\n\ngetFront:\n→ Decision: if count == 0? \n    Yes → return -1\n    No → return arr[front]\n\ngetRear:\n→ Decision: if count == 0? \n    Yes → return -1\n    No → return arr[rear]\n\nisEmpty:\n→ Decision: if count == 0? \n    Yes → return true\n    No → return false\n\nisFull:\n→ Decision: if count == k? \n    Yes → return true\n    No → return false\n\nEnd\n\nWe need to show each step.\n\nWe should start with Start, End.\n\nWe need to include arrow → for each step.\n\nLet's produce a line for class definition, but it's conceptual. Maybe Step 1: Declare class MyCircularDeque // Class declaration\n\nWe should show initialization as part of constructor.\n\nWe need to produce each step.\n\nLet's generate.\n\nWe'll use \"Step 1:\", \"Step 2:\" etc. Ensure each line ends with // explanation.\n\nAlso, for decisions, indent under Decision. But we have to produce each line with arrow and text. Indentation can be just spaces.\n\nWe need to ensure no actual code, just virtual steps. Let's proceed.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 宣告類別 MyCircularDeque // 定義雙端佇列的類別\n→ Step 2: 定義私有變數 capacity, data, front, rear, count // 存放容量、資料陣列、前後指標與元素計數\n→ Step 3: 建構子 MyCircularDeque(int k) // 初始化佇列\n    → Step 4: capacity ← k // 設定最大容量\n    → Step 5: data ← 新陣列長度 k // 建立儲存空間\n    → Step 6: front ← 0 // 前指標起始位置\n    → Step 7: rear ← -1 // 後指標起始位置（空佇列時不指向任何元素）\n    → Step 8: count ← 0 // 初始元素數為 0\n→ Step 9: insertFront(int value) // 前插入方法\n    → Decision: 若 count = capacity? // 檢查佇列是否已滿\n        Yes → return false // 若滿，插入失敗\n        No  → front ← (front - 1 + capacity) % capacity // 前指標向前移動\n             → data[front] ← value // 存入新值\n             → count ← count + 1 // 元素計數加 1\n             → return true // 插入成功\n→ Step 10: insertLast(int value) // 後插入方法\n    → Decision: 若 count = capacity? // 檢查佇列是否已滿\n        Yes → return false // 若滿，插入失敗\n        No  → rear ← (rear + 1) % capacity // 後指標向後移動\n             → data[rear] ← value // 存入新值\n             → count ← count + 1 // 元素計數加 1\n             → return true // 插入成功\n→ Step 11: deleteFront() // 前刪除方法\n    → Decision: 若 count = 0? // 檢查佇列是否為空\n        Yes → return false // 若空，刪除失敗\n        No  → front ← (front + 1) % capacity // 前指標向後移動\n             → count ← count - 1 // 元素計數減 1\n             → return true // 刪除成功\n→ Step 12: deleteLast() // 後刪除方法\n    → Decision: 若 count = 0? // 檢查佇列是否為空\n        Yes → return false // 若空，刪除失敗\n        No  → rear ← (rear - 1 + capacity) % capacity // 後指標向前移動\n             → count ← count - 1 // 元素計數減 1\n             → return true // 刪除成功\n→ Step 13: getFront() // 取得前端值\n    → Decision: 若 count = 0? // 檢查佇列是否為空\n        Yes → return -1 // 空佇列回傳 -1\n        No  → return data[front] // 回傳前端元素\n→ Step 14: getRear() // 取得後端值\n    → Decision: 若 count = 0? // 檢查佇列是否為空\n        Yes → return -1 // 空佇列回傳 -1\n        No  → return data[rear] // 回傳後端元素\n→ Step 15: isEmpty() // 判斷佇列是否為空\n    → Decision: 若 count = 0? // 檢查計數\n        Yes → return true // 為空\n        No  → return false // 不為空\n→ Step 16: isFull() // 判斷佇列是否已滿\n    → Decision: 若 count = capacity? // 檢查計數是否等於容量\n        Yes → return true // 已滿\n        No  → return false // 未滿\nEnd // 程式執行結束"
    },
    {
      "title": "Distinct Subsequences",
      "source_file": "Leetcode/leetcode115.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        if n == 0:                     # 空子序列只有一種\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 1                       # dp[0] 代表匹配空子序列\n        for i in range(1, m + 1):\n            # 從後往前更新，避免覆寫前 i-1 的結果\n            for j in range(n, 0, -1):\n                if s[i - 1] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        return dp[n]\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 1. 先嘗試按行分割\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        s, t = lines[0].strip(), lines[1].strip()\n    else:\n        # 2. 嘗試以空格分割\n        parts = data.split()\n        if len(parts) >= 2:\n            s, t = parts[0], parts[1]\n        else:\n            # 3. 從帶引號的字串中抽取\n            matches = re.findall(r'\"([^\"]*)\"', data)\n            if len(matches) >= 2:\n                s, t = matches[0], matches[1]\n            else:\n                # 4. 若還是沒有找到，直接當作整段文字\n                s, t = data, ''\n\n    result = Solution().numDistinct(s, t)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm to count distinct subsequences of s that equal t. Classic DP: dp[i][j] number of ways first i chars of s produce first j chars of t. Base dp[0][0]=1, dp[i][0]=1 for all i. For i>0, j>0: if s[i-1]==t[j-1], dp[i][j] = dp[i-1][j-1]+dp[i-1][j], else dp[i][j] = dp[i-1][j]. Complexity O(len(s)*len(t)). Use 1D DP optimized: previous row dp[j], iterate i. Or 2D.\n\nWe need to produce virtual code step by step, line by line, with explanation. The output must use virtual code arrows etc. So produce something like:\n\nStart // 開始\n\n→ Step 1: 設定 m = s.length, n = t.length // 取得長度\n\n→ Step 2: 初始化 dp 陣列長度 n+1 // dp[j] 表示前 i 個 s 對應 t 的 j 個字元的次數\n\n→ Decision: 如果 n==0? // t 為空\n\n    Yes → Step 3: 回傳 1 // 空字串為任何 s 的一個子序列\n\n    No → Step 4: // 初始化 dp[0] = 1 其餘 0\n\n...\n\nProceed.\n\nWe need to output each line with virtual code and explanation. We'll use arrows: \"→\".\n\nUse \"Decision:\" lines with Yes → and No →.\n\nAlso start with \"Start\" and end with \"End\".\n\nOk produce.\n\nBe careful to include step numbers? Not necessary but helpful. The sample shows \"Step 1:\" etc. We can use Step numbers.\n\nMake sure each line includes virtual code step and comment with explanation.\n\nLet's craft.\n\nWe might need loops, conditions, assignments.\n\nWe can use pseudocode.\n\nLet's produce.\n\nWe need to cover DP array initialization, loops over s, inner loop over t in reverse order to update dp.\n\nAlgorithm:\n\n- m = s.length, n = t.length\n- If n==0 return 1\n- dp = array[n+1] with dp[0]=1, others 0\n- For i from 1 to m:\n    For j from n downto 1:\n        If s[i-1]==t[j-1]:\n            dp[j] = dp[j] + dp[j-1]\n- Return dp[n]\n\nWe'll produce virtual code accordingly.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← length(s) // 取得 s 的長度  \n→ Step 2: n ← length(t) // 取得 t 的長度  \n→ Decision: n = 0? // t 為空串的特殊情況  \n  Yes → Step 3: return 1 // 空字串是任何字串的唯一子序列  \n  No  → // 繼續進行 DP 計算  \n→ Step 4: 初始化 dp[0…n] 為 0 // dp[j] 代表前 i 個 s 產生前 j 個 t 的次數  \n→ Step 5: dp[0] ← 1 // 空 t 只需要一次 (不取任何字元)  \n→ Step 6: For i ← 1 to m: // 遍歷 s 的每個字元  \n  → Step 7: For j ← n downto 1: // 從最後一個 t 字元往前更新，以免覆蓋前一個 i 的結果  \n    → Decision: s[i-1] = t[j-1]? // 判斷目前字元是否匹配  \n      Yes → Step 8: dp[j] ← dp[j] + dp[j-1] // 匹配：加上使用此字元的方案與不使用此字元的方案  \n      No  → Step 9: dp[j] ← dp[j] // 不匹配：保持原值（不使用此字元）  \n→ Step 10: return dp[n] // dp[n] 為完整 t 的子序列總數  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        content_map = defaultdict(list)\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # remove trailing ')'\n                content_map[content].append(f\"{root}/{name}\")\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list literal from the input\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        paths = []\n    else:\n        list_str = data[start:end+1]\n        try:\n            paths = ast.literal_eval(list_str)\n        except Exception:\n            paths = []\n\n    solution = Solution()\n    duplicates = solution.findDuplicate(paths)\n    print(duplicates)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with explanation. We need to parse input list of directory info strings, build mapping content to file paths, then collect duplicates. Provide steps.\n\nThe virtual code should use arrow \"→\". We'll produce steps: Start, Step 1: initialize map, Step 2: iterate over paths, Step 3: split string into directory and files, Step 4: iterate files, Step 5: parse file name and content, Step 6: build full path, Step 7: add to map, Step 8: after processing, collect values with size>1, Step 9: output list, End.\n\nAdd decision? Might have decision to skip if map size? Not necessary. But we can include Decision: if current content not in map? but we can just map with array. Use Decision: if key exists? Maybe.\n\nWill produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立 hash 表 contentToPaths // 用於將內容對應到檔案路徑\n→ Step 2: 針對輸入的每個 directory info 字串進行迴圈 // 逐一處理每個目錄資訊\n    → Decision: 取得此字串的 directory 路徑與檔案列表 // 解析字串\n        Yes → Step 3: 分割字串，取得目錄路徑 dirPath 與檔案描述 listFiles // 分割\n        No  → … // Not needed maybe\n    → Step 4: 針對 listFiles 內的每個檔案描述進行迴圈 // 逐一處理檔案\n        → Decision: 解析檔案名稱與內容 // 拆解\n            Yes → Step 5: 取得 fileName 與 content // \n        → Step 6: 建立完整路徑 fullPath = dirPath + \"/\" + fileName // \n        → Step 7: 若 content 存在於 hash 表，將 fullPath 加入對應陣列；否則新增陣列 // \n→ Step 8: 建立結果列表 result // \n→ Decision: 針對 hash 表中每個內容對應的檔案路徑陣列做判斷\n    Yes → Decision: 只保留路徑陣列長度 >= 2 // 有重複內容\n        Yes → Step 9: 將此陣列加入 result // \n        No  → Step 10: 跳過 // \n→ Step 11: 回傳 result // 輸出重複檔案路徑分組\nEnd // 程式結束\n\nBut need to maintain structure with arrow and indent. Use \"Decision:\" with Yes / No. We need to keep each line separate. Use \"→\" for next step. Indentation indicates hierarchical.\n\nLet's craft carefully. Also note that each line includes \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的 hash 表 contentToPaths  // 用於將檔案內容映射到其完整路徑  \n→ Step 2: 針對輸入的每個 directory info 字串 info 進行迴圈 // 逐一處理每個目錄資訊  \n    → Decision: 從 info 取得目錄路徑 dirPath 與檔案描述陣列 fileInfos // 分離路徑與檔案資料  \n        Yes → Step 3: 使用空格分隔，取得 dirPath 與 fileInfos // 例如「root/d1」與「f1.txt(f1_content)」等  \n    → Step 4: 針對 fileInfos 陣列中的每個檔案描述 fileInfo 進行迴圈 // 逐一處理每個檔案  \n        → Decision: 解析檔案名稱 fileName 與內容 content 從 fileInfo // 以括號分割  \n            Yes → Step 5: 取得 fileName 與 content // 如「f1.txt」與「f1_content」  \n        → Step 6: 建立完整路徑 fullPath = dirPath + \"/\" + fileName // 形成「root/d1/f1.txt」  \n        → Decision: content 是否已存在於 contentToPaths  \n            Yes → Step 7: 將 fullPath 加入 contentToPaths[content] 陣列中 // 添加到已存在的列表  \n            No  → Step 8: 建立新陣列 contentToPaths[content] = [fullPath] // 初始化並加入首個路徑  \n→ Step 9: 建立空陣列 result 用於儲存重複檔案組別 // 結果集合  \n→ Decision: 遍歷 contentToPaths 的每個 key-value 對 (content, paths)  \n    Yes → Decision: paths 陣列長度是否大於等於 2 // 至少兩個檔案才算重複  \n        Yes → Step 10: 將 paths 陣列推入 result // 加入重複組別  \n        No  → Step 11: 跳過此內容 // 非重複不加入結果  \n→ Step 12: 回傳 result // 輸出所有重複檔案的路徑分組  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,true,false,true,null,true]'\nGot (Norm):      '[None,None,True,False,True,None,True]'\n--- (Raw) ---\nRaw Expected: '[null, null, true, false, true, null, true]'\nRaw Got:      '[None, None, True, False, True, None, True]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        sys.exit()\n\n    # Split the two lists in the input\n    parts = data.split('],', 1)\n    ops_part = parts[0].strip()\n    args_part = parts[1].strip() if len(parts) > 1 else '[]'\n\n    # Ensure proper brackets\n    if not ops_part.endswith(']'):\n        ops_part += ']'\n    if not args_part.startswith('['):\n        args_part = '[' + args_part\n\n    # Convert string representations to Python objects\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    result = []\n    trie = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Trie\":\n            trie = Trie()\n            result.append(None)\n        elif op == \"insert\":\n            trie.insert(arg[0])\n            result.append(None)\n        elif op == \"search\":\n            result.append(trie.search(arg[0]))\n        elif op == \"startsWith\":\n            result.append(trie.startsWith(arg[0]))\n        else:\n            # Unknown operation, skip\n            result.append(None)\n\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation for implementing Trie class with constructor, insert, search, startsWith. Should be line-by-line with arrow style. Use virtual code structure.\n\nWe must not output real code. Use pseudo steps. Probably something like:\n\nStart\n→ Step 1: Define TrieNode class // node with children map and isEnd flag\n→ Step 2: Trie() -> create root node // init root\n→ Step 3: insert(word) -> current=root // iterate chars\n    → for each char c in word:\n        → if current.children does not contain c: add new TrieNode // add child\n        → current = current.children[c] // move\n    → after loop: current.isEnd = true // mark word end\n→ Step 4: search(word) -> current=root\n    → for each char c in word:\n        → if child not exists: return false\n        → current = child\n    → return current.isEnd\n→ Step 5: startsWith(prefix) -> current=root\n    → for each char c in prefix:\n        → if child not exists: return false\n        → current = child\n    → return true\nEnd\n\nNeed to use virtual code arrows: \"→\" etc. Provide comment. Use indentation for decision? Not needed except for loops. Just linear.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode 類別 // 每個節點包含子節點字典與是否為單字結尾的標誌\n→ Step 2: Trie() → 建立 root 節點 // 初始化 Trie 時創建一個空根節點\n→ Step 3: insert(word) → current ← root // 開始從根節點遍歷輸入字串\n    → For each character c in word:\n        → Decision: current.children 是否包含 c? // 檢查子節點是否已存在\n            Yes → current ← current.children[c] // 移動到已存在的子節點\n            No  → current.children[c] ← new TrieNode() // 新增子節點\n                 → current ← current.children[c] // 移動到新創建的節點\n    → current.isEnd ← true // 標記此節點為單字結尾\n→ Step 4: search(word) → current ← root // 開始從根節點尋找單字\n    → For each character c in word:\n        → Decision: current.children 是否包含 c? // 檢查子節點是否存在\n            Yes → current ← current.children[c] // 移動到子節點\n            No  → return false // 若不存在即查不到該單字\n    → return current.isEnd // 若到達結尾節點且 isEnd 為真則為已插入的單字\n→ Step 5: startsWith(prefix) → current ← root // 開始從根節點尋找前綴\n    → For each character c in prefix:\n        → Decision: current.children 是否包含 c? // 檢查子節點是否存在\n            Yes → current ← current.children[c] // 移動到子節點\n            No  → return false // 若不存在即不存在此前綴\n    → return true // 所有字元均可遍歷完畢，表示至少有一個單字以此前綴開始\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[7,8]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[7, 8]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[10,4,2]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[10, 4, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\ndef rand7():\n    # 隨機產生 1~7 的整數，模擬題目給的 API\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        產生 1~10 的均勻隨機數。使用兩次 rand7() 產生 1~49 的均勻分佈，\n        只接受 1~40 的範圍，將其映射到 1~10。超出 40 的結果重新嘗試。\n        \"\"\"\n        while True:\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    # 從標準輸入讀取內容，範例輸入形如 \"n = 3\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入中的數字 n\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step. The task: given rand7() uniform [1,7], implement rand10() uniform [1,10] using only rand7(). Standard approach: generate base-7 numbers to get 49 possibilities, then map to 10. For 49, we can use two calls: r1 = rand7(); r2 = rand7(); value = (r1-1)*7 + r2; // 1-49. If value <= 40, return (value-1)%10+1. Else reject and repeat. That ensures uniform distribution.\n\nWe need to output virtual code line by line. Use Start, End, Decision, Yes/No arrows.\n\nSo produce:\n\nStart\n→ Step 1: 定義函式 rand10() // 函式入口\n→ Decision: 循環 until return? Use loop: While True\n    → Step 2: 生成 r1 = rand7() // 第一個隨機數\n    → Step 3: 生成 r2 = rand7() // 第二個隨機數\n    → Step 4: value = (r1 - 1) * 7 + r2 // 合併為 1~49\n    → Decision: 如果 value <= 40?\n        Yes → Step 5: result = ((value - 1) % 10) + 1 // 映射到 1~10\n            → Step 6: return result // 結束\n        No  → Step 7: 跳回 while 迴圈 // 重試\nEnd\n\nBut we need to maintain structure: maybe use Decision: if value <= 40? Yes-> ... No-> ...; use arrow.\n\nAlso we need arrow from Step 7 to While start. Might be okay.\n\nLet's produce each line accordingly.\n\nWe must not output real code but virtual code with arrow signs. Each line with \"虛擬碼步驟 // 解釋\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 開始建立 rand10 函式\n→ Step 2: while True // 無限循環直到返回結果\n    → Step 3: r1 = rand7() // 產生第一個 1~7 的隨機數\n    → Step 4: r2 = rand7() // 產生第二個 1~7 的隨機數\n    → Step 5: value = (r1 - 1) * 7 + r2 // 轉換為 1~49 的整數\n    → Decision: 如果 value <= 40? // 判斷是否在可接受範圍\n        Yes → Step 6: result = ((value - 1) % 10) + 1 // 映射到 1~10\n            → Step 7: return result // 返回統一分布的隨機數\n        No  → Step 8: 進行下一次迴圈 // value > 40 時重新嘗試\nEnd // 程式執行結束\n\nBut we need to ensure arrows with indentation.\n\nThe format: Use arrow →, Decision: etc.\n\nLet's craft carefully.\n\nUse \"Start\" and \"End\" lines. Indentation for inner lines maybe using spaces. But we should preserve arrow formatting.\n\nLet's write each line:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 建立 rand10 函式入口\n→ Step 2: while True // 無限迴圈，直到產生合法結果\n    → Step 3: r1 = rand7() // 產生第一個 1~7 的隨機數\n    → Step 4: r2 = rand7() // 產生第二個 1~7 的隨機數\n    → Step 5: value = (r1 - 1) * 7 + r2 // 組合為 1~49\n    → Decision: 是否 value <= 40? // 判斷是否可映射\n        Yes → Step 6: result = ((value - 1) % 10) + 1 // 將 1~40 映射到 1~10\n            → Step 7: return result // 返回結果\n        No  → Step 8: 重新進入 while // value > 40 時重試\nEnd // 程式結束\n\nWe might need to maintain \"Yes →\" and \"No →\" indentation. Use spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 rand10() // 建立 rand10 函式入口  \n→ Step 2: while True // 無限迴圈，直到產生合法結果  \n → Step 3: r1 = rand7() // 產生第一個 1~7 的隨機數  \n → Step 4: r2 = rand7() // 產生第二個 1~7 的隨機數  \n → Step 5: value = (r1 - 1) * 7 + r2 // 組合為 1~49 的整數  \n → Decision: 是否 value <= 40? // 判斷是否可映射  \n  Yes → Step 6: result = ((value - 1) % 10) + 1 // 將 1~40 映射到 1~10  \n   → Step 7: return result // 返回統一分布的隨機數  \n  No  → Step 8: 重新進入 while // value > 40 時重試  \nEnd // 程式結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8tr8vu1b.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmp8tr8vu1b.py\", line 30, in main\n    parts = json.loads(data)\n            ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 54 (char 53)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\nfrom collections import defaultdict\n\nclass TimeMap:\n    def __init__(self):\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right finds insertion point to keep order\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i - 1][1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # The input format is two JSON arrays separated by a comma.\n    # Example: '[\"TimeMap\",\"set\",\"get\"],[[],[\"foo\",\"bar\",1],[\"foo\",1]]'\n    # Use json.loads to parse both parts.\n    parts = json.loads(data)\n    commands, args_list = parts[0], parts[1]\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"TimeMap\":\n            obj = TimeMap()\n            results.append(None)          # constructor returns null\n        elif cmd == \"set\":\n            key, value, ts = args\n            obj.set(key, value, ts)\n            results.append(None)          # set returns null\n        elif cmd == \"get\":\n            key, ts = args\n            val = obj.get(key, ts)\n            results.append(val)           # get returns a string\n        else:\n            # Unknown command, skip or handle error\n            results.append(None)\n\n    # Convert Python None to JSON null for output\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for this requirement. So we will design TimeMap with data structure: dictionary mapping key to list of (timestamp, value) sorted by timestamp. set: append. get: binary search. We'll produce step-by-step pseudo-code. We'll need to include Start, End, Decision, etc. The requirement: \"逐行產生對應的虛擬碼\" meaning each step. Provide explanation after each line. Use arrow arrow. Use Start, End.\n\nWe'll structure like:\n\nStart\n→ Step: initialize TimeMap // create empty dictionary\n→ Method: set\n   → Step: if key not in map, add empty list\n   → Append (timestamp, value) to list\n→ Method: get\n   → Step: if key not in map, return \"\"\n   → Step: binary search timestamp in list\n   → Decision: if found exact match?\n       Yes -> return corresponding value\n       No -> find last timestamp <= given\n   → Step: return value or \"\" \nEnd\n\nBut need more granular lines. For binary search, we can illustrate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 TimeMap // 建立時間映射類別\n    → Step 1.1: 初始化內部字典 map // key -> [ (timestamp, value) ] \n→ Method 1: set(key, value, timestamp)\n    → Step 2: 如果 key 不在 map 中，創建空列表 // 保證後續可直接插入\n    → Step 3: 將 (timestamp, value) 追加到 map[key] 列表 // 時間遞增假設\n→ Method 2: get(key, timestamp)\n    → Step 4: 如果 key 不在 map 中，返回 \"\" // 無此 key\n    → Step 5: 取得對應的列表 lst = map[key] // 準備搜尋\n    → Step 6: 初始化 left = 0, right = lst.length - 1 // 二分搜尋範圍\n    → Step 7: 變數 resIndex = -1 // 記錄最近時間戳\n    → Decision: while left <= right?\n        Yes → Step 8: mid = (left + right) / 2 // 計算中間索引\n        → Step 9: 如果 lst[mid].timestamp <= timestamp\n            → Yes → Step 10: resIndex = mid // 可能答案更新\n            → Yes → Step 11: left = mid + 1 // 搜尋更大時間戳\n            → No → Step 12: right = mid - 1 // 搜尋更小時間戳\n        No  → End of loop\n    → Decision: 如果 resIndex != -1 ?\n        Yes → Step 13: 返回 lst[resIndex].value // 找到合適的值\n        No  → Step 14: 返回 \"\" // 無可用時間戳\nEnd // 程式執行結束\n\nBut we need arrow formatting: \"→\" for steps. For decision, \"Decision:\" etc. We'll use proper indent and indent for sub steps.\n\nAlso we need to include \"Yes →\" and \"No →\". For binary search while loop, it's a Decision.\n\nWe can include loops: \"Loop:\"? Not defined but we can use Decision for while. Maybe better: \"While left <= right:\" with steps inside. But to match format, we use Decision: while condition.\n\nLet's produce final. Ensure each line has \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 TimeMap // 建立時間映射類別\n    → Step 1.1: 初始化內部字典 map // key -> [ (timestamp, value) ] 的映射表\n→ Method 1: set(key, value, timestamp) // 設定 key 的值在指定時間戳\n    → Step 2: 如果 key 不在 map 中，創建空列表 // 保證後續可以直接追加\n    → Step 3: 將 (timestamp, value) 追加到 map[key] 列表 // 假設時間戳遞增，保持順序\n→ Method 2: get(key, timestamp) // 取得在給定時間戳前最近的值\n    → Step 4: 如果 key 不在 map 中，返回 \"\" // 無此 key 時直接返回空字串\n    → Step 5: 取得對應的列表 lst = map[key] // 準備進行搜尋\n    → Step 6: 初始化 left = 0, right = lst.length - 1 // 設定二分搜尋的左右邊界\n    → Step 7: 初始化 resIndex = -1 // 用來記錄最近時間戳的索引\n    → Decision: 左右邊界是否重疊？ // 判斷是否還有元素可以搜尋\n        Yes → Step 8: mid = (left + right) / 2 // 計算中間索引\n        → Step 9: 如果 lst[mid].timestamp <= timestamp\n            Yes → Step 10: resIndex = mid // 更新最近時間戳索引\n            Yes → Step 11: left = mid + 1 // 尋找更大的時間戳\n            No  → Step 12: right = mid - 1 // 尋找更小的時間戳\n        No  → End of loop // 搜尋結束\n    → Decision: resIndex 是否有效？\n        Yes → Step 13: 返回 lst[resIndex].value // 找到符合條件的值\n        No  → Step 14: 返回 \"\" // 沒有可用時間戳，返回空字串\nEnd // 程式執行結束"
    },
    {
      "title": "Design HashMap",
      "source_file": "Leetcode/leetcode706.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]",
          "expected_output": "[null, null, null, 1, -1, null, 1, null, -1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,-1,null,1,null,-1]'\nGot (Norm):      '[None,None,None,1,-1,None,1,None,-1]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, -1, null, 1, null, -1]'\nRaw Got:      '[None, None, None, 1, -1, None, 1, None, -1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyHashMap:\n    def __init__(self):\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def put(self, key: int, value: int) -> None:\n        h = self._hash(key)\n        for i, (k, v) in enumerate(self.buckets[h]):\n            if k == key:\n                self.buckets[h][i] = (key, value)\n                return\n        self.buckets[h].append((key, value))\n\n    def get(self, key: int) -> int:\n        h = self._hash(key)\n        for k, v in self.buckets[h]:\n            if k == key:\n                return v\n        return -1\n\n    def remove(self, key: int) -> None:\n        h = self._hash(key)\n        for i, (k, _) in enumerate(self.buckets[h]):\n            if k == key:\n                self.buckets[h].pop(i)\n                return\n\nif __name__ == \"__main__\":\n    # 讀取輸入\n    ops_line = sys.stdin.readline().strip()\n    args_line = sys.stdin.readline().strip()\n    if not ops_line or not args_line:\n        sys.exit(0)\n\n    ops = ast.literal_eval(ops_line)\n    args = ast.literal_eval(args_line)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyHashMap\":\n            obj = MyHashMap()\n            results.append(None)\n        elif op == \"put\":\n            obj.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            results.append(obj.get(arg[0]))\n        elif op == \"remove\":\n            obj.remove(arg[0])\n            results.append(None)\n\n    # 輸出結果\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a HashMap from scratch, without built-in hash table libraries, with methods MyHashMap(), put, get, remove. Provide virtual code lines with explanations. Use arrow syntax. Each line: \"虛擬碼步驟 // 解釋\". Must use Start, End, Decision. Let's design algorithm: Use array of buckets, each bucket is linked list of nodes (key, value). Use simple hash function: key modulo capacity. Provide dynamic resizing? Not necessary but could. Provide basic functions.\n\nLet's output sequential steps: Start, initialize capacity, array. Put: compute index, traverse bucket, if key found update, else add node at head. Get: compute index, traverse bucket, return value or -1. Remove: compute index, traverse, maintain prev, delete node. End.\n\nWe need to produce each step, each line with explanation. Probably include separate steps for class definition? Virtual code: \"Start // 程式開始執行\" then \"→ Step 1: 定義 MyHashMap 類別 // 宣告類別\" etc. But we need to include code for methods.\n\nLet's produce structure:\n\nStart\n→ Step 1: 定義 MyHashMap() // 建構子\n    → Step 1.1: 設定初始容量 cap = 16 // 初始桶數\n    → Step 1.2: 建立 buckets = array of Node[cap] // 桶陣列\n→ Step 2: 定義 put(key, value) // 插入或更新\n    → Step 2.1: index = hash(key) // 取得桶索引\n    → Step 2.2: node = buckets[index] // 取桶頭\n    → Decision: node 為 null? // 桶是否空\n        Yes → Step 2.3: buckets[index] = new Node(key, value) // 新增節點\n        No → Step 2.4: prev = null\n        → Step 2.5: while node != null\n            → Decision: node.key == key? // 同鍵?\n                Yes → Step 2.6: node.value = value // 更新值\n                → Step 2.7: return\n                No  → Step 2.8: prev = node\n                → Step 2.9: node = node.next\n            → End While\n        → Step 2.10: prev.next = new Node(key, value) // 尾部新增\n→ Step 3: 定義 get(key) // 取得值\n    → Step 3.1: index = hash(key)\n    → Step 3.2: node = buckets[index]\n    → Decision: node 為 null? // 桶空\n        Yes → Step 3.3: return -1\n        No  → Step 3.4: while node != null\n            → Decision: node.key == key?\n                Yes → Step 3.5: return node.value\n                No  → Step 3.6: node = node.next\n            → End While\n        → Step 3.7: return -1\n→ Step 4: 定義 remove(key) // 刪除鍵\n    → Step 4.1: index = hash(key)\n    → Step 4.2: node = buckets[index]\n    → Step 4.3: prev = null\n    → Decision: node 為 null? // 桶空\n        Yes → Step 4.4: return\n        No  → Step 4.5: while node != null\n            → Decision: node.key == key?\n                Yes → Decision: prev 為 null?\n                    Yes → Step 4.6: buckets[index] = node.next // 刪除頭節點\n                    No  → Step 4.7: prev.next = node.next // 刪除中間或尾節點\n                No  → Step 4.8: prev = node\n                → Step 4.9: node = node.next\n            → End While\n→ Step 5: 定義 hash(key) // 簡單 hash\n    → Step 5.1: return key mod capacity // 取模\n→ End // 程式結束\n\nBut need to include Node class maybe. Also maybe need to mention Node definition. Let's incorporate Step 0: 定義 Node 內部類別.\n\nLet's produce final output lines accordingly. Ensure each line has arrow formatting. Use \"→\" for normal steps, \"→ Decision:\" for decision. Use \"Yes →\" and \"No →\".\n\nNeed to maintain proper indentation? Not necessary but okay.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 定義 Node 類別 // 節點儲存 key、value 與 next  \n→ Step 1: 定義 MyHashMap() // 建構子  \n    → Step 1.1: 設定初始容量 cap = 16 // 桶數量  \n    → Step 1.2: 建立 buckets = array of Node[cap] // 桶陣列  \n→ Step 2: 定義 put(key, value) // 插入或更新鍵值對  \n    → Step 2.1: index = hash(key) // 計算鍵的桶索引  \n    → Step 2.2: node = buckets[index] // 取得桶頭節點  \n    → Decision: node 為 null? // 桶是否為空  \n        Yes → Step 2.3: buckets[index] = new Node(key, value) // 新增節點  \n        No → Step 2.4: prev = null // 初始化前驅節點  \n            → Step 2.5: while node != null // 遍歷鏈表  \n                → Decision: node.key == key? // 同鍵？  \n                    Yes → Step 2.6: node.value = value // 更新值  \n                    → Step 2.7: return // 完成  \n                    No → Step 2.8: prev = node // 移動前驅  \n                    → Step 2.9: node = node.next // 移動至下一節點  \n                → End While  \n            → Step 2.10: prev.next = new Node(key, value) // 尾部新增節點  \n→ Step 3: 定義 get(key) // 取得鍵對應的值  \n    → Step 3.1: index = hash(key) // 計算桶索引  \n    → Step 3.2: node = buckets[index] // 取得桶頭  \n    → Decision: node 為 null? // 桶空？  \n        Yes → Step 3.3: return -1 // 沒有對應鍵  \n        No → Step 3.4: while node != null // 遍歷鏈表  \n            → Decision: node.key == key? // 找到鍵？  \n                Yes → Step 3.5: return node.value // 返回值  \n                No  → Step 3.6: node = node.next // 進一步搜尋  \n            → End While  \n        → Step 3.7: return -1 // 未找到鍵  \n→ Step 4: 定義 remove(key) // 刪除鍵值對  \n    → Step 4.1: index = hash(key) // 計算桶索引  \n    → Step 4.2: node = buckets[index] // 取得桶頭  \n    → Step 4.3: prev = null // 前驅節點  \n    → Decision: node 為 null? // 桶空？  \n        Yes → Step 4.4: return // 無須處理  \n        No → Step 4.5: while node != null // 遍歷鏈表  \n            → Decision: node.key == key? // 找到鍵？  \n                Yes → Decision: prev 為 null? // 刪除頭節點？  \n                    Yes → Step 4.6: buckets[index] = node.next // 更新桶頭  \n                    No  → Step 4.7: prev.next = node.next // 刪除中間或尾節點  \n                No  → Step 4.8: prev = node // 移動前驅  \n                → Step 4.9: node = node.next // 移動至下一節點  \n            → End While  \n→ Step 5: 定義 hash(key) // 簡易 hash 函式  \n    → Step 5.1: return key mod cap // 取模得到桶索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplzs2gn20.py\", line 32, in <module>\n    exec(input_data, {}, env)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmoxthd3n.py\", line 32, in <module>\n    exec(input_data, {}, env)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcm8vvyyy.py\", line 32, in <module>\n    exec(input_data, {}, env)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    env = {}\n    exec(input_data, {}, env)\n    equations = env.get('equations', [])\n    values = env.get('values', [])\n    queries = env.get('queries', [])\n\n    solution = Solution()\n    ans = solution.calcEquation(equations, values, queries)\n    formatted = \"[\" + \",\".join(f\"{x:.5f}\" for x in ans) + \"]\"\n    print(formatted)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for evaluating division queries using equations array of pairs and values. Standard problem: Evaluate Division (Leetcode 399). Use union-find or graph DFS. Virtual code: Start, Build graph, For each query: if either variable not in graph => -1.0 else compute via DFS or DSU.\n\nWe produce line-by-line virtual code with arrows and comments.\n\nWe need to obey format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows: →, Yes →, No →, Decision: etc.\n\nStart and End.\n\nWe should show building graph: create adjacency map variable -> list of (neighbor, weight). Then for each query, if not in map -> return -1.0; else DFS.\n\nUse stack or recursion. We'll show Decision: if visited or no path.\n\nLet's craft steps:\n\nStart\n→ Build adjacency map from equations and values\n    → For each i from 0 to len(equations)-1\n        → Add edge equations[i][0] -> equations[i][1] weight values[i]\n        → Add reverse edge equations[i][1] -> equations[i][0] weight 1/values[i]\n→ Initialize result array\n→ For each query index j\n    → Decision: if query[0] not in map or query[1] not in map? // variable missing\n        Yes → result[j] = -1.0 // cannot determine\n        No  → Decision: if query[0] == query[1]? // same variable\n            Yes → result[j] = 1.0\n            No  → Perform DFS to find product\n                → Call DFS(query[0], query[1], visited=set())\n                → If path found return product else -1.0\n→ End\n\nDFS pseudo:\n\n→ Function DFS(current, target, visited)\n    → Mark visited add current\n    → If current == target: return 1.0\n    → For each neighbor, weight in adjacency[current]\n        → If neighbor not in visited\n            → Decision: result = DFS(neighbor, target, visited)? // recursion\n                Yes → return weight * result\n                No  → continue\n    → Return -1.0 // no path\n\nWe should include steps for DFS as nested functions maybe separate block.\n\nWe need to keep format.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Build adjacency map // 建立變量之間的圖，存放除法關係  \n    → For each i from 0 to equations.length-1 // 逐個處理給定的等式  \n        → Add edge equations[i][0] → equations[i][1] weight values[i] // Ai / Bi = values[i]  \n        → Add reverse edge equations[i][1] → equations[i][0] weight 1/values[i] // Bi / Ai 的倒數  \n→ Initialize result array // 用來儲存所有查詢的答案  \n→ For each query index j from 0 to queries.length-1 // 處理每個查詢  \n    → Decision: 如果 query[j][0] 或 query[j][1] 不在圖中? // 變量未定義  \n        Yes → result[j] = -1.0 // 無法確定答案  \n        No  → Decision: 若 query[j][0] == query[j][1]? // 相同變量  \n            Yes → result[j] = 1.0 // 任何變量除以自己等於 1  \n            No  → Call DFS to compute product // 需要搜尋路徑  \n                → DFS(query[j][0], query[j][1], visited=set()) → 計算除法值  \n                → If DFS 返回 -1.0 → result[j] = -1.0  \n                → Else → result[j] = DFS 的返回值  \n→ End // 程式執行結束  \n\n// ---------- DFS 內部函式 ----------  \n→ Function DFS(current, target, visited) // 計算 current / target 的值  \n    → visited.add(current) // 標記已訪問  \n    → Decision: 若 current == target? // 找到目標變量  \n        Yes → return 1.0 // 除以自己  \n        No  → For each (neighbor, weight) in adjacency[current] // 探索鄰接節點  \n            → Decision: 若 neighbor 不在 visited?  \n                Yes → result = DFS(neighbor, target, visited) // 递归计算  \n                    → Decision: 若 result != -1.0?  \n                        Yes → return weight * result // 乘上邊權重  \n                        No  → Continue // 試下一條路徑  \n            → Continue // 若已訪問，跳過  \n    → return -1.0 // 無法從 current 到達 target"
    },
    {
      "title": "Delete and Earn",
      "source_file": "Leetcode/leetcode740.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[3,4,2]",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '9'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '9'"
        },
        {
          "example_index": 1,
          "input": "[2,2,3,3,3,4]",
          "expected_output": "9",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '9'\nGot (Norm):      '17'\n--- (Raw) ---\nRaw Expected: '9'\nRaw Got:      '17'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef delete_and_earn(nums):\n    \"\"\"Return maximum points obtainable from the given list.\"\"\"\n    if not nums:\n        return 0\n    freq = Counter(nums)\n    unique_vals = sorted(freq)\n    prev_val = None\n    prev_dp = 0   # dp for the previous non‑adjacent value\n    curr_dp = 0   # dp for the current value\n\n    for val in unique_vals:\n        points = val * freq[val]\n        if prev_val is None or val != prev_val + 1:\n            # No conflict with previous value\n            curr_dp = prev_dp + points\n        else:\n            # Conflict: choose best between skipping or taking this value\n            curr_dp = max(prev_dp, curr_dp + points)\n        prev_dp, prev_val = curr_dp, val\n\n    return prev_dp\n\nif __name__ == \"__main__\":\n    # Read entire stdin, strip whitespace, and parse as Python literal\n    input_data = sys.stdin.read().strip()\n    nums = ast.literal_eval(input_data) if input_data else []\n    result = delete_and_earn(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code (like pseudocode) for the problem: \"Delete and Earn\" similar to Leetcode 740. Provide line-by-line with comments. Must follow format: each line: `虛擬碼步驟 // 解釋/說明`. Use arrow → etc. Should not output real code. Must be structured as Start, Decision, etc.\n\nWe need to produce algorithm: Count frequencies, treat as DP similar to House Robber: sort unique values, accumulate points, dp[i] = max(dp[i-1], dp[i-2] + value*count). Use map. But produce virtual code lines. Each line should be step, with arrow.\n\nLet's produce steps:\n\nStart // program start\n\n→ Step 1: Create frequency map of nums // count occurrences\n\n→ Step 2: Extract sorted unique values from map keys // sorted ascending\n\n→ Decision: If list empty? // handle trivial case\n\n    Yes → Step 3: Return 0 // no points\n\n    No  → Continue\n\n→ Step 4: Initialize prevVal = None, prevPoints = 0, currPoints = 0 // DP variables\n\n→ Loop over each value val in sorted unique values:\n\n    → Step 5: Calculate valPoints = val * freq[val] // points for this value\n\n    → Decision: If prevVal is None or val != prevVal + 1? // not adjacent\n\n        Yes → Step 6: currPoints = prevPoints + valPoints // can take both\n\n        No  → Step 7: currPoints = max(prevPoints, currPoints + valPoints) // choose best\n\n    → Step 8: Update prevPoints = currPoints // shift DP\n\n    → Step 9: Update prevVal = val\n\nEnd // return prevPoints\n\nWe need to add step of return at end: → Step 10: Return prevPoints\n\nNeed to use arrow for decisions and Yes/No.\n\nLet's craft lines accordingly.\n\nWe also need to maintain each line's structure: Start, Decision, etc. Might need indent.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 建立 nums 的頻率映射 // 計算每個數字出現次數\n\n→ Step 2: 從映射中取得排序後的唯一值列表 // 方便依次處理\n\n→ Decision: 列表是否為空？ // 判斷是否有數字可處理\n\n    Yes → Step 3: 回傳 0 // 沒有數字時點數為 0\n\n    No  → \n\n→ Step 4: 初始化 prevVal = None, prevPoints = 0, currPoints = 0 // DP 變數\n\n→ Loop: 對於每個 val 在排序後的唯一值列表中\n\n    → Step 5: 計算 valPoints = val * freq[val] // 取此值時可獲得的總點數\n\n    → Decision: prevVal 為 None 或 val != prevVal + 1？ // 檢查是否相鄰\n\n        Yes → Step 6: currPoints = prevPoints + valPoints // 兩個值不相鄰，可直接累加\n\n        No  → Step 7: currPoints = max(prevPoints, currPoints + valPoints) // 選擇不取或取\n\n    → Step 8: 更新 prevPoints = currPoints // 將本輪結果移至上一輪\n\n    → Step 9: 更新 prevVal = val // 記錄當前值\n\n→ Step 10: 回傳 prevPoints // 最終最大點數\n\nEnd // 程式結束\n\nBut must use arrow syntax: \"→\" at beginning of each line. Indentation? In sample they indent within Decision.\n\nWe'll produce accordingly.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\". Use Chinese explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立 nums 的頻率映射 // 計算每個數字出現的次數\n→ Step 2: 從映射中取得排序後的唯一值列表 // 方便依次處理\n→ Decision: 列表是否為空？ // 判斷是否有數字可處理\n    Yes → Step 3: 回傳 0 // 沒有數字時點數為 0\n    No  → // 繼續\n→ Step 4: 初始化 prevVal = None, prevPoints = 0, currPoints = 0 // DP 變數\n→ Loop: 對於每個 val 在排序後的唯一值列表中\n    → Step 5: 計算 valPoints = val * freq[val] // 取此值時可獲得的總點數\n    → Decision: prevVal 為 None 或 val != prevVal + 1？ // 檢查是否相鄰\n        Yes → Step 6: currPoints = prevPoints + valPoints // 兩個值不相鄰，可直接累加\n        No  → Step 7: currPoints = max(prevPoints, currPoints + valPoints) // 選擇不取或取\n    → Step 8: 更新 prevPoints = currPoints // 將本輪結果移至上一輪\n    → Step 9: 更新 prevVal = val // 記錄當前值\n→ Step 10: 回傳 prevPoints // 最終最大點數\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"cat\",\"dog\",\"rat\",\"cats\",\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\",\"hippopotamuses\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      '[\"cat\",\"dog\",\"rat\",\"cats\",\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\",\"hippopotamuses\"]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"cat\",\"dog\",\"catdog\"]",
          "expected_output": "[\"catdog\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catdog\"]'\nGot (Norm):      '[\"cat\",\"dog\",\"catdog\"]'\n--- (Raw) ---\nRaw Expected: '[\"catdog\"]'\nRaw Got:      '[\"cat\",\"dog\",\"catdog\"]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 先建立一個字串集合，用來快速查找\n        word_set = set(words)\n        # 按長度升序排序，短字串先判斷，方便 DP\n        words_sorted = sorted(words, key=len)\n        result = []\n\n        for word in words_sorted:\n            if not word:\n                continue\n\n            # 使用動態規劃判斷 word 是否能由其他字串拼成\n            dp = [False] * (len(word) + 1)\n            dp[0] = True\n            for i in range(1, len(word) + 1):\n                for j in range(0, i):\n                    if not dp[j]:\n                        continue\n                    # 子字串是否在集合中\n                    if word[j:i] in word_set:\n                        dp[i] = True\n                        break\n            # 若能拼成且至少用到兩個單詞\n            if dp[len(word)]:\n                # 檢查是否由至少兩個單詞拼成\n                # 若 dp[ len(word) ] 為 True，並且字串本身不在集合中\n                # (因為我們在判斷時已把當前字串剔除，所以只要 dp 為 True 就代表至少兩個單詞)\n                result.append(word)\n\n            # 把目前字串加入集合，供之後的判斷使用\n            word_set.add(word)\n\n        return result\n\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 移除可能的前置變數名，例如 \"words = \"\n    if raw.lower().startswith(\"words\"):\n        # 找到等號後面\n        pos = raw.find(\"=\")\n        if pos != -1:\n            raw = raw[pos + 1:].strip()\n\n    # 將字串轉成 Python list\n    try:\n        words = eval(raw, {\"__builtins__\": None}, {})\n    except Exception:\n        # 若解析失敗，直接輸出空列表\n        print(\"[]\")\n        return\n\n    # 確保得到的是 list of str\n    if not isinstance(words, list):\n        print(\"[]\")\n        return\n    words = [str(w) for w in words]\n\n    sol = Solution()\n    res = sol.findAllConcatenatedWordsInADict(words)\n\n    # 輸出與範例一致的格式：雙引號包裹的字串\n    formatted = \"[\" + \",\".join(f'\"{w}\"' for w in res) + \"]\"\n    print(formatted)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code algorithm for the problem: given array words, find all concatenated words. Use trie or DP with set. We need to output step by step with explanations. Provide each line in format: virtual code step + space + // explanation.\n\nWe need to produce steps like: Start, build set, sort by length, for each word, check if can be formed by other words via DP, etc. We'll use decision and loops.\n\nWe need to obey formatting: each line with virtual code and explanation comment. Use arrow etc. Let's produce.\n\nWe should include steps: Build set, sort words by length ascending. For each word in sorted words, check if it can be formed by other words using DP: dp[0] = true, for i in range(1, len(word)+1): for j in range(0,i): if dp[j] and word[j:i] in set, dp[i] = true break. If dp[len(word)] true, add to result. Add word to set. End.\n\nWe'll produce as virtual code. Use Start, End, Decision, loops. Use → arrow.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: words ← 輸入的字串陣列 // 取得所有字串  \n→ Step 2: wordSet ← 空集合 // 用來儲存已檢查過的字串  \n→ Step 3: sortedWords ← words 按字串長度升序排序 // 短字串先檢查  \n→ Step 4: result ← 空列表 // 儲存所有可拼接字串  \n→ Decision: for 每個 word 在 sortedWords? // 逐一處理每個字串  \n  Yes → Step 5: canForm ← false // 是否能被拼接  \n  → Step 6: dp ← 陣列長度 word.length + 1，初值 false；dp[0] ← true // DP 陣列，dp[i] 代表前 i 個字可否拼接  \n  → Decision: i ← 1 到 word.length? // 遍歷字串長度  \n   Yes → Decision: j ← 0 到 i? // 找分割點  \n     Yes → Decision: dp[j] 為 true AND word[j:i] 在 wordSet? // 子字串是否已存在  \n       Yes → Step 7: dp[i] ← true // 以此分割點拼接成功  \n       Yes → Step 8: canForm ← true // 至少找到一種方式  \n       Yes → Decision: 跳出內層迴圈 // 不再檢查其他 j  \n     No  → Decision: 繼續下一個 j  \n   No  → Decision: 繼續下一個 i  \n  → Decision: canForm 為 true? // 判斷整個字串是否可拼接  \n   Yes → Step 9: result ← result 加入 word // 收集結果  \n   No  → 死角 // 不加入  \n  → Step 10: wordSet ← wordSet 加入 word // 把此字加入集合，供後續字串使用  \n  → Decision: 繼續下一個 word  \n→ End // 程式執行結束，返回 result"
    },
    {
      "title": "Longest Palindromic Subsequence",
      "source_file": "Leetcode/leetcode516.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\n\ndef longest_palindrome_subseq(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    # 由右往左填表，保證 dp[i+1][j-1], dp[i+1][j], dp[i][j-1] 已經計算\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    # 讀取輸入字串，去除前後空白和換行\n    s = sys.stdin.readline().strip()\n    result = longest_palindrome_subseq(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. Use virtual code style with Start, End, Decision, etc. Use arrows. Need to handle algorithm: Longest Palindromic Subsequence length. Classic DP: dp[i][j] longest length in s[i..j]. Use 2D DP. But we can produce algorithm steps: initialize dp[i][i]=1; iterate length from 2 to n; if s[i]==s[j] dp[i][j] = dp[i+1][j-1] +2 else dp[i][j] = max(dp[i+1][j], dp[i][j-1]). Finally answer dp[0][n-1].\n\nWe need to produce pseudo-code lines with explanation after comment. Also can include decisions: if s[i]==s[j]. We can represent loops: For length=2 to n: For i=0 to n-length: j=i+length-1. Use loops.\n\nWe need to use arrow for each step: \"→\" preceding each line. Format: \"Start // 程式開始執行\".\n\nWe also need to embed decision blocks: \"Decision:\" lines with Yes/No arrows.\n\nSo we produce:\n\nStart\n→ Initialize n = length(s) // 取得字串長度\n→ Create 2D array dp[n][n] // 用於存儲子問題結果\n→ For i=0 to n-1:\n    → dp[i][i] = 1 // 單個字符是回文子序列長度 1\n→ For length = 2 to n:\n    → For i = 0 to n - length:\n        → j = i + length - 1 // 計算子字串結尾位置\n        → Decision: s[i] == s[j] ?\n            Yes → dp[i][j] = dp[i+1][j-1] + 2 // 匹配時加 2\n            No  → dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取較長的子序列\n→ Result = dp[0][n-1] // 最長回文子序列長度\n→ End\n\nAlso maybe include variable assignment lines: e.g., \"→ dp[i][j] = ...\" etc. Provide explanation after comment.\n\nEnsure every line starts with \"→\" except Start and End? In example, Start has no arrow. But we can follow pattern: \"Start\" line no arrow. All subsequent steps with arrow. At decisions, use indent? They used \"Decision:\" lines with indent, and \"Yes →\" etc. So follow that style.\n\nWe need to be careful with indentation: Use tab or spaces. We can indent decision block. Provide explanation comments after \"//\". For decision lines, we put \"// 檢查字符是否相等\" etc. And for Yes/No lines, explanation. For loops, explanation.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ n = length(s) // 取得字串長度\n→ dp = 2D array of size n x n // 用於存儲子問題結果\n→ For i = 0 to n-1:\n    → dp[i][i] = 1 // 單個字符本身就是回文子序列，長度為 1\n→ For length = 2 to n:\n    → For i = 0 to n - length:\n        → j = i + length - 1 // 子字串的結尾索引\n        → Decision: s[i] == s[j] // 檢查兩端字符是否相同\n            Yes → dp[i][j] = dp[i+1][j-1] + 2 // 匹配時長度加 2\n            No  → dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取兩種子情況中較長者\n→ Result = dp[0][n-1] // 最長回文子序列的長度\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    data = re.sub(r'^accounts\\s*=\\s*', '', data)\n    accounts = ast.literal_eval(data)\n    sol = Solution()\n    result = sol.accountsMerge(accounts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for merging accounts using virtual code. We'll produce line-by-line steps with explanation after //.\n\nWe should design algorithm: union-find by email. Steps: map email->id, map id->name, union when same name appears in same person. Actually typical solution: for each account, connect all emails in that account via union. Use DSU. Then group emails by root. Output sorted emails per root with name from any email's name.\n\nWe'll produce pseudo-code.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\". Use arrows: Start, End, Decision: with Yes →, No →.\n\nLet's outline:\n\nStart\n→ Step 1: 初始化 DSU parent map // 建立每個 email 的父節點\n→ Step 2: 初始化 name map // 將 email 轉到其擁有者名稱\n→ Step 3: For 每個帳戶 in accounts // 逐筆處理\n    → Step 3.1: 取得帳戶名 name = accounts[i][0]\n    → Step 3.2: For email in accounts[i][1:] // 逐個 email\n        → Decision: email 是否已在 parent? // 判斷是否第一次遇到\n            Yes → Step 3.2a: parent[email] = email // 設定父節點\n            No  → (no action)\n        → Step 3.2b: name[email] = name // 記錄名稱\n    → Decision: accounts[i] 的第一個 email 是否已存在？ // 為 union 目的\n        Yes → Step 3.3: union(firstEmail, email) // 對所有 email 進行 union\n        No  → (no action)\n→ Step 4: 建立組合 map root -> set of emails\n    → For 每個 email in parent keys\n        → root = find(email)\n        → Step 4a: group[root].add(email)\n→ Step 5: 建立結果 list\n    → For 每個 root, emails in group\n        → Step 5a: name = name[any email in group]\n        → Step 5b: sortedEmails = sort(emails)\n        → Step 5c: result.append([name] + sortedEmails)\n→ End\n\nWe need to ensure virtual code arrow format.\n\nAdd Decision with Yes →, No →. Might need to indent under Decision.\n\nAlso show union, find as separate steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 parent = {} // 建立 email → 父節點的映射  \n→ Step 2: 初始化 name = {} // 建立 email → 擁有者名稱的映射  \n→ Step 3: For 每個帳戶 accounts[i] in accounts // 逐筆處理帳戶  \n  → Step 3.1: name_i = accounts[i][0] // 取得此帳戶的姓名  \n  → Step 3.2: For 每個 email in accounts[i][1:] // 處理帳戶中的所有 email  \n    → Decision: email 是否存在於 parent? // 判斷是否第一次遇到此 email  \n     Yes → Step 3.2a: parent[email] = email // 設定初始父節點為自己  \n     No → (無操作) // 已存在，保持父節點  \n    → Step 3.2b: name[email] = name_i // 記錄此 email 的姓名  \n  → Decision: accounts[i] 中是否至少有一個 email? // 準備 union  \n    Yes → Step 3.3: firstEmail = accounts[i][1]  \n     → For 每個 email in accounts[i][1:]  \n      → Step 3.3a: union(firstEmail, email) // 將同一帳戶內的 email union 起來  \n    No → (無操作) // 無 email，跳過  \n→ Step 4: 初始化 groups = {} // 根 → email 集合  \n  → For 每個 email in parent.keys()  \n    → root = find(email) // 取得該 email 的代表根  \n    → Decision: root 是否已在 groups?  \n     Yes → groups[root].add(email) // 加入現有集合  \n     No  → groups[root] = {email} // 新建集合  \n→ Step 5: 初始化 result = [] // 最終合併後的帳戶列表  \n  → For 每個 root, emails in groups  \n    → name_root = name[next(iter(emails))] // 取得任意一個 email 的姓名  \n    → sorted_emails = sort(emails) // 對 email 進行字典序排序  \n    → Step 5a: result.append([name_root] + sorted_emails) // 形成合併後帳戶格式  \n→ End // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps501p2ge.py\", line 40, in <module>\n    args_list = ast.literal_eval(lists[1])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport json\n\nclass MyCalendar:\n    \"\"\"簡單的日曆，避免重複預訂。\"\"\"\n\n    def __init__(self):\n        # 用 list 儲存已預訂的時間區間 (start, end)\n        self.bookings = []\n\n    def book(self, start, end):\n        \"\"\"\n        若新事件與現有事件不重疊，則加入並回傳 True；\n        否則不加入並回傳 False。\n        \"\"\"\n        for s, e in self.bookings:\n            # 半開區間重疊條件：新起點 < 現有結束且新結束 > 現有起點\n            if start < e and end > s:\n                return False\n        # 無重疊，將新事件加入\n        self.bookings.append((start, end))\n        return True\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 以正則表達式抓取兩個列表：命令列表和對應參數列表\n    lists = re.findall(r'\\[.*?\\]', data, re.DOTALL)\n    if len(lists) < 2:\n        # 若格式不符，直接結束\n        sys.exit(0)\n\n    # 轉成 Python 物件\n    commands = ast.literal_eval(lists[0])\n    args_list = ast.literal_eval(lists[1])\n\n    # 結果列表，對於 \"MyCalendar\" 這個初始化不回傳任何值，用 None 表示\n    results = []\n    cal = None\n\n    for i, cmd in enumerate(commands):\n        if i == 0:  # 第一次是初始化\n            cal = MyCalendar()\n            results.append(None)\n            continue\n\n        if cmd == \"book\":\n            start, end = args_list[i]\n            success = cal.book(start, end)\n            results.append(success)\n        else:\n            # 若未來擴充其他指令，可在此處處理\n            results.append(None)\n\n    # 使用 json.dumps 以正確的 JSON 風格輸出結果\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for implementing a MyCalendar class with book method, ensuring no double booking. Need to output in Chinese, following format. We must avoid actual code. Just steps with arrow and explanation.\n\nWe can design algorithm: use an array/list of intervals, when book called, iterate existing intervals check overlap; if none overlap, add and return true; else false.\n\nWe should include class initialization, book method, overlap check, adding interval.\n\nLet's produce steps:\n\nStart\n→ Step 1: Initialize empty interval list // create storage for events\n→ Step 2: Define book(start, end) // method signature\n→ Decision: For each interval in list // iterate\n    → Decision: If current interval overlaps with [start,end)? // check overlap\n        → Step 3: Return false // cannot add\n→ Step 4: Append [start,end] to list // add event\n→ Step 5: Return true // added successfully\nEnd\n\nAlso include description of overlap: condition: start < existing.end && end > existing.start.\n\nWe'll mention that.\n\nLet's produce formatted lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立一個空的事件列表 events // 用來儲存已預訂的時間區間\n→ Step 2: 定義方法 book(startTime, endTime) // 接收新事件的起止時間\n→ Decision: 對於 events 中的每個已存在 interval // 遍歷所有已預訂事件\n    → Decision: 若 startTime < interval.end AND endTime > interval.start? // 判斷新事件是否與已存在事件重疊\n        Yes → Step 3: 返回 false // 重疊則拒絕預訂\n        No  →  // 仍在迴圈中檢查下一個事件\n→ Step 4: 把 [startTime, endTime] 加入 events // 無重疊則將新事件加入列表\n→ Step 5: 返回 true // 成功預訂\nEnd // 程式執行結束"
    },
    {
      "title": "First Bad Version",
      "source_file": "Leetcode/leetcode278.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "actual_output_or_error": "File \"/tmp/tmpon39a1zp.py\", line 30\n    n, global bad_version_val = nums[0], nums[1]\n       ^^^^^^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "actual_output_or_error": "File \"/tmp/tmplqpjuqfz.py\", line 30\n    n, global bad_version_val = nums[0], nums[1]\n       ^^^^^^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\n\n# 模擬 API：根據輸入的 bad 版本號來判斷\nbad_version = None\n\ndef isBadVersion(version: int) -> bool:\n    \"\"\"返回版本是否為壞版（>= bad_version）。\"\"\"\n    return version >= bad_version\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        \"\"\"使用二分搜尋找出第一個壞版。\"\"\"\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 n 與 bad 版本，輸出第一個壞版本。\"\"\"\n    data = sys.stdin.read()\n    # 取得所有整數，第一個為 n，第二個為 bad\n    nums = [int(x) for x in data.replace(',', ' ').split() if x.isdigit() or (x and x[0] == '-' and x[1:].isdigit())]\n    if len(nums) < 2:\n        print(\"Invalid input\")\n        return\n    n, global bad_version_val = nums[0], nums[1]\n    global bad_version\n    bad_version = bad_version_val\n\n    ans = Solution().firstBadVersion(n)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese (繁體). Use arrow syntax. We need to include \"Start\", \"End\". Use decision nodes. It's binary search. Steps: set left=1, right=n, while left<right, mid=(left+right)//2, if isBadVersion(mid) then right=mid else left=mid+1. After loop, left is first bad. Return left. Need to produce each line with explanation. Also the function definition, maybe \"Function FindFirstBadVersion(n)\" as a step. Use arrow for each step. Also include calls to API.\n\nLet's produce:\n\nStart\n→ Function FindFirstBadVersion(n) // 開始尋找\n→ Step 1: 設置 left=1, right=n // 初始化搜尋範圍\n→ Decision: while left < right? // 繼續搜尋直到範圍縮小到單一版本\n    Yes → Step 2: mid = (left + right) // 2 // 計算中間版本\n    → Decision: isBadVersion(mid)? // 判斷中間版本是否為壞版\n        Yes → Step 3: right = mid // 若壞版，將右邊界移至 mid\n        No  → Step 4: left = mid + 1 // 若好版，將左邊界移至 mid+1\n→ End while\n→ Step 5: return left // left 即為第一個壞版\nEnd // 程式結束\n\nBut need to use proper indentation? Not necessary but maintain arrow lines.\n\nMake sure to add \"→ Decision: while left < right?\" maybe \"Decision: left < right?\" with Yes and No. Actually in flowcharts, decision leads to loop or exit. We'll express.\n\nLet's format exactly as requested: each line \"虛擬碼步驟\" + space + \"// 解釋\". We'll use \"Start\", \"End\".\n\nAlso need to include function start: \"Function FindFirstBadVersion(n)\" maybe.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function FindFirstBadVersion(n) // 開始尋找第一個壞版本  \n→ Step 1: left = 1, right = n // 初始化搜尋範圍  \n→ Decision: left < right? // 是否還有多個版本可檢查  \n  Yes → Step 2: mid = (left + right) // 2 // 計算中間版本  \n   → Decision: isBadVersion(mid)? // 判斷中間版本是否為壞版  \n    Yes → Step 3: right = mid // 壞版，將右邊界移到 mid  \n    No  → Step 4: left = mid + 1 // 好版，將左邊界移到 mid+1  \n  No  → Step 5: return left // 只剩一個版本，返回它作為第一個壞版  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,0,6,6,0,0,0,1]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 0, 6, 6, 0, 0, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # 可用數量\n        self.size = n - len(blacklist)\n        # 黑名單集合，方便 O(1) 判斷\n        black_set = set(blacklist)\n        # 存放映射：將小於 size 的黑名單映射到合法值\n        self.mapping = {}\n        # 從最大的合法索引開始尋找\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                # 找到一個不在黑名單中的 last\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # 隨機產生合法範圍內的索引\n        idx = random.randint(0, self.size - 1)\n        # 若映射表有對應，返回映射後的值，否則直接返回 idx\n        return self.mapping.get(idx, idx)\n\ndef main():\n    # 讀取兩行輸入\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n    ops = ast.literal_eval(lines[0].strip())\n    args_list = ast.literal_eval(lines[1].strip())\n\n    results = []\n    instance = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            # 初始化 Solution 對象\n            n, blacklist = args[0], args[1]\n            instance = Solution(n, blacklist)\n            results.append(None)\n        elif op == \"pick\":\n            # 執行 pick，並記錄結果\n            results.append(instance.pick())\n\n    # 格式化輸出，將 None 轉為 null\n    output = '[' + ', '.join('null' if v is None else str(v) for v in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Provide algorithm: map from [0, n-1] to allowed numbers. Preprocess: B size m. Compute allowed size = n-m. Build map for blacklisted numbers less than allowedSize to the largest allowed numbers >= allowedSize. In pick: generate k=random[0,allowedSize-1]; if k in map then return map[k] else return k.\n\nWe should output step by step pseudocode. We'll include initialization steps, mapping logic, pick logic. Use structure: Start, Steps, Decision, End. Provide explanation after each line. Avoid actual code. Use arrows etc. Provide lines. We'll use \"→\" arrow each step.\n\nLet's craft:\n\nStart\n→ Step 1: 存儲 n 與 blacklist // 保存輸入參數\n→ Step 2: 計算 allowedSize = n - blacklist.size // 可選範圍大小\n→ Step 3: 建立空的映射 table // 用於映射黑名單內的索引到合法值\n→ Step 4: 將 blacklist 的值放入集合 B // 方便 O(1) 查詢\n→ Decision: 是否有黑名單值小於 allowedSize? // 需要映射\n    Yes → Step 5: 初始化一個指針 last = n-1 // 從最右邊尋找合法值\n        → Decision: last 在 B? // 確保 last 為合法\n            Yes → last-- → 再次判斷 // 迭代直到找到合法\n            No  → Step 6: 將小於 allowedSize 的黑名單元素 i 映射到 last // i → last\n                → last-- // 更新指針\n                → Decision: 是否還有小於 allowedSize 的黑名單元素? // 重複\n                    Yes → 回到 Step 5\n                    No  → 退出映射建立\n    No  → 直接跳過映射建立 // 無需映射\n→ Step 7: 定義 pick() 函數\n    → Step 7.1: 生成 k = random(0, allowedSize-1) // 隨機索引\n    → Decision: k 是否在映射表中? // 檢查是否為黑名單映射\n        Yes → Step 7.2: 返回 table[k] // 轉換為合法值\n        No  → Step 7.3: 返回 k // 直接合法值\nEnd\n\nNeed to be line by line with arrow. Let's format.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 存儲輸入參數 n 與 blacklist // 保存題目給定的數值\n→ Step 2: 計算 allowedSize = n - blacklist.size // 允許取值的總數\n→ Step 3: 建立空的映射 table // 用於將黑名單內的索引映射到合法值\n→ Step 4: 將 blacklist 的所有值加入集合 B // 以 O(1) 查詢是否為黑名單\n→ Decision: 是否存在黑名單元素 i < allowedSize? // 需要建立映射\n    Yes → Step 5: 設定指針 last = n - 1 // 從最大值開始尋找合法值\n        → Decision: last 是否在 B? // 檢查 last 是否為黑名單\n            Yes → last-- // 若是，移動到下一個更小的值\n            No  → Step 6: 將 i（黑名單元素且 i < allowedSize）映射到 last // i → last\n                → last-- // 指針移動\n                → Decision: 是否還有 i < allowedSize 待映射? // 是否繼續\n                    Yes → 回到 Step 5 // 針對下個 i\n                    No  → 跳出映射建立流程\n    No  → 跳過映射建立 // 無需處理\n→ Step 7: 定義 pick() 函數\n    → Step 7.1: 產生隨機索引 k = random(0, allowedSize - 1) // 在合法索引範圍內隨機\n    → Decision: k 是否在映射表中? // 判斷 k 是否為黑名單映射\n        Yes → Step 7.2: 返回 table[k] // 轉換成合法值\n        No  → Step 7.3: 返回 k // 直接返回合法索引\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp61hvq9r.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmpp61hvq9r.py\", line 41, in main\n    commands = json.loads(data[0])\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 45 (char 44)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    __slots__ = ('children', 'sum')\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_map = {}\n\n    def insert(self, key: str, val: int) -> None:\n        # 計算值的差，便於更新整棵樹\n        old_val = self.key_map.get(key, 0)\n        diff = val - old_val\n        self.key_map[key] = val\n\n        node = self.root\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += diff\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main():\n    data = [line.strip() for line in sys.stdin if line.strip()]\n    if not data:\n        return\n    # 第一行是命令列表，第二行是對應參數列表\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    result = []\n    obj = None\n\n    for i, cmd in enumerate(commands):\n        if cmd == \"MapSum\":\n            obj = MapSum()\n            result.append(None)\n        elif cmd == \"insert\":\n            key, val = args_list[i]\n            obj.insert(key, val)\n            result.append(None)\n        elif cmd == \"sum\":\n            prefix = args_list[i][0]\n            result.append(obj.sum(prefix))\n        else:\n            # 若有其他命令，直接跳過\n            result.append(None)\n\n    # 輸出結果，使用 JSON 格式以得到 null、數字等正確表示\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for design of a map with prefix sum functionality. This is typical of MapSum problem. We need to design class MapSum with insert and sum. Use a trie with cumulative sum at nodes. Keep map of key to value to handle overrides. Virtual code: start, create root, etc. We'll produce steps: Start, initialize map, root node, insert method: check old value, difference, update key map, traverse trie updating node sums. sum method: traverse trie according to prefix, return node sum. End.\n\nWe need to produce virtual code lines with arrows and decisions.\n\nLet's outline:\n\nStart\n→ Initialize MapSum\n    → root = new Node\n    → keyToValMap = empty map\n\nInsert(key, val)\n    → oldVal = keyToValMap.get(key) or 0\n    → diff = val - oldVal\n    → keyToValMap.put(key, val)\n    → node = root\n    → For each char ch in key\n        → if node.children[ch] not exist -> create\n        → node = node.children[ch]\n        → node.sum += diff\n    // no decisions inside loop except node creation\n\nSum(prefix)\n    → node = root\n    → For each char ch in prefix\n        → if node.children[ch] not exist -> return 0\n        → node = node.children[ch]\n    → return node.sum\n\nEnd\n\nBut need to include Start and End. Use Decision only if necessary: check node child existence.\n\nWe must write line by line. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow characters. Ensure each line has a comment.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Initialize MapSum // 建立 MapSum 物件\n    → root = new TrieNode // Trie 根節點\n    → keyMap = {} // 儲存 key 到 value 的映射\nEnd // 程式結束\n\nBut need separate for insert, sum. We can produce separate blocks for methods with Start and End inside class? Let's just show steps for class methods as part of algorithm flow.\n\nBetter: Provide class structure: MapSum { constructor; insert; sum }. Provide virtual steps for each method.\n\nWe'll include \"Start\" at the beginning of algorithm demonstration.\n\nLet's craft:\n\nStart // 程式開始\n→ Class MapSum\n    → Constructor: root = new TrieNode; keyMap = {}\n    → Method insert(key, val)\n        → oldVal = keyMap[key] or 0\n        → diff = val - oldVal\n        → keyMap[key] = val\n        → node = root\n        → For each char c in key\n            → If node.children[c] == null → node.children[c] = new TrieNode\n            → node = node.children[c]\n            → node.sum += diff\n    → Method sum(prefix)\n        → node = root\n        → For each char c in prefix\n            → If node.children[c] == null → return 0\n            → node = node.children[c]\n        → return node.sum\nEnd // 程式結束\n\nBut we need decision arrows for if node.children[c] null. Use Decision: If node.children[c] == null? Yes → create node; No → nothing.\n\nAlso need to use \"→\" arrow.\n\nLet's craft more detailed:\n\nStart // 程式開始執行\n→ Class MapSum // 定義 MapSum 類別\n    → Constructor // 初始化\n        → root = new TrieNode // Trie 根節點\n        → keyMap = {} // key → value 映射\n    → Method insert(key, val) // 插入或覆寫鍵值對\n        → oldVal = keyMap[key] or 0 // 取得舊值\n        → diff = val - oldVal // 差值，用於更新樹\n        → keyMap[key] = val // 更新映射\n        → node = root // 從根開始遍歷\n        → For each char c in key // 遍歷鍵\n            → Decision: node.children[c] 存在嗎? // 判斷子節點是否存在\n                Yes → node = node.children[c] // 直接進入\n                No  → node.children[c] = new TrieNode // 建立新節點\n                      node = node.children[c] // 進入新節點\n            → node.sum += diff // 更新此節點的累積和\n    → Method sum(prefix) // 回傳前綴的總和\n        → node = root // 從根開始\n        → For each char c in prefix\n            → Decision: node.children[c] 存在嗎?\n                Yes → node = node.children[c] // 進入下一節點\n                No  → return 0 // 前綴不存在，和為 0\n        → return node.sum // 返回累積和\nEnd // 程式結束\n\nNeed to format each line with arrow. Use \"→\" before each step.\n\nWe need to produce line by line. Each line must contain virtual code step plus comment. We must include \"Decision:\" lines.\n\nSo final output will be multiple lines. Let's produce accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MapSum // 定義 MapSum 類別  \n    → Constructor // 初始化物件  \n        → root = new TrieNode // 創建 Trie 根節點  \n        → keyMap = {} // 建立 key→value 映射表  \n    → Method insert(key, val) // 插入或覆寫鍵值對  \n        → oldVal = keyMap[key] or 0 // 取得舊值（若不存在則為 0）  \n        → diff = val - oldVal // 計算差值，用於更新 Trie  \n        → keyMap[key] = val // 更新映射表  \n        → node = root // 從根節點開始遍歷  \n        → For each char c in key // 逐字符處理鍵  \n            → Decision: node.children[c] 是否存在? // 判斷子節點是否已存在  \n                Yes → node = node.children[c] // 存在時直接進入  \n                No → node.children[c] = new TrieNode // 不存在時創建節點  \n                 → node = node.children[c] // 進入新創建的節點  \n            → node.sum += diff // 在此節點更新累積和  \n    → Method sum(prefix) // 取得以 prefix 為前綴的所有鍵的值總和  \n        → node = root // 從根節點開始  \n        → For each char c in prefix // 逐字符向下走  \n            → Decision: node.children[c] 是否存在? // 判斷前綴是否存在  \n                Yes → node = node.children[c] // 存在時進入下一節點  \n                No → return 0 // 前綴不存在，直接回傳 0  \n        → return node.sum // 返回該前綴節點的累積和  \nEnd // 程式結束執行"
    },
    {
      "title": "Single Number II",
      "source_file": "Leetcode/leetcode137.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '99'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '99'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        \"\"\"\n        這裡使用位元運算的「一次、兩次」技巧。\n        ones 记录每个位出现一次的情况，twos 记录出现两次的情况。\n        通过更新这两个位掩码，最终只剩下出现一次的数。\n        \"\"\"\n        ones, twos = 0, 0\n        for num in nums:\n            # 更新出现两次的位元：先 XOR，再排除已经出现一次的位元\n            twos = (twos ^ num) & ~ones\n            # 更新出现一次的位元：先 XOR，再排除已经出现两次的位元\n            ones = (ones ^ num) & ~twos\n        return ones\n\ndef parse_input(data: str):\n    \"\"\"\n    解析输入字符串，支持两种常见格式：\n    1. nums = [1,2,3]\n    2. [1,2,3]\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    if '=' in data:\n        # 取等号右边的部分\n        _, right = data.split('=', 1)\n        data = right.strip()\n    try:\n        # 使用 ast.literal_eval 进行安全评估\n        return ast.literal_eval(data)\n    except Exception:\n        # 如果解析失败，返回空列表\n        return []\n\nif __name__ == \"__main__\":\n    # 从标准输入读取所有内容\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    solution = Solution()\n    result = solution.singleNumber(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines for algorithm: find single number when all others appear three times. Use bitwise trick: maintain two bitmasks ones and twos. For each num: ones = (ones XOR num) & ~twos; twos = (twos XOR num) & ~ones; After loop answer is ones.\n\nWe need to produce virtual code steps with Start, Step lines, Decision, etc. Since it's linear and constant space, no extra structures. Provide explanation. Let's produce steps: Start, Input array, Initialize ones=0, twos=0, Loop through each num: Step: update twos, update ones, continue. End.\n\nWe can include Decision? There's no decision inside loop except bitwise updates. But we can show update steps with arrow.\n\nWe'll produce lines like:\n\nStart // 程式開始\n\n→ Step 1: 讀取陣列 nums // 取得輸入\n\n→ Step 2: 初始化 ones = 0, twos = 0 // 用來累積位元統計\n\n→ Step 3: 循環遍歷 nums 中的每個數字 num // 每個元素處理一次\n\n    → Step 4: twos = (twos XOR num) & ~ones // 計算出現次數為2的位元\n\n    → Step 5: ones = (ones XOR num) & ~twos // 計算出現次數為1的位元\n\nEnd // 程式結束，ones 為唯一不重複的數\n\nBut need to indicate that after loop, ones contains answer. Could add Step 6: 回傳 ones // 結果\n\nLet's include that.\n\nMake sure each line is separate.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums // 取得需要處理的數字清單  \n→ Step 2: 初始化 ones = 0, twos = 0 // 用於記錄出現一次與兩次的位元  \n→ Step 3: 循環遍歷 nums 中的每個數字 num // 每個元素處理一次  \n  → Step 4: twos = (twos XOR num) & ~ones // 更新出現兩次的位元，排除已經出現一次的位元  \n  → Step 5: ones = (ones XOR num) & ~twos // 更新出現一次的位元，排除已經出現兩次的位元  \n→ Step 6: 回傳 ones // ones 即為唯一只出現一次的數字  \nEnd // 程式執行結束，已取得答案"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.6192951532518826,0.5788426736223864],[0.5897775683064117,-0.6311694369736484],[0.6792694379563746,0.09632360843796986]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.6192951532518826, 0.5788426736223864], [0.5897775683064117, -0.6311694369736484], [0.6792694379563746, 0.09632360843796986]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 使用極座標隨機生成點\n        r = self.radius * math.sqrt(random.random())  # sqrt 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    # 從標準輸入讀取兩行：方法名列表和對應參數列表\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        return\n    funcs = json.loads(data[0])\n    args = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for func, arg in zip(funcs, args):\n        if func == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)  # 建構子不回傳任何值\n        else:\n            method = getattr(obj, func)\n            result = method(*arg)\n            results.append(result)\n\n    # 將結果輸出為 JSON 格式，None 會自動轉為 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Not actual code, but pseudocode. For generating uniform random point inside circle: algorithm: choose radius sqrt(random)*R, angle uniform 0-2π. Then compute x = center_x + r*cosθ, y = center_y + r*sinθ. So steps: initialize radius, center, maybe pre-calc something? Implementation of randPoint: generate random u in [0,1], r = sqrt(u)*radius; theta = random*2π; compute x,y.\n\nNeed to produce steps with Start, End, Decision: maybe not many decisions.\n\nLet's produce step-by-step:\n\nStart\n→ Step 1: Store radius, center_x, center_y in object // initialize\n→ End\n\nrandPoint function:\n\nStart\n→ Step 1: Generate random u in [0,1] // uniform random\n→ Step 2: Compute r = sqrt(u) * radius // radius scaled for uniform distribution\n→ Step 3: Generate random θ in [0, 2π) // uniform angle\n→ Step 4: Compute x = center_x + r * cos(θ) // x coordinate\n→ Step 5: Compute y = center_y + r * sin(θ) // y coordinate\n→ Step 6: Return [x, y] // output\nEnd\n\nBut we need to include decisions maybe for boundary? Not needed.\n\nLet's produce the pseudocode with arrows.\n\nOk produce each line.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set radius ← input radius // 取得圓半徑  \n→ Step 2: Set center_x ← input x_center // 取得圓心 X 座標  \n→ Step 3: Set center_y ← input y_center // 取得圓心 Y 座標  \nEnd // 初始化完成  \n\nStart // randPoint() 執行  \n→ Step 1: Generate u ← RandomUniform(0, 1) // 產生 0~1 的均勻隨機數  \n→ Step 2: Compute r ← sqrt(u) * radius // 將半徑按均勻分佈縮放  \n→ Step 3: Generate θ ← RandomUniform(0, 2π) // 產生 0~2π 的均勻角度  \n→ Step 4: Compute x ← center_x + r * cos(θ) // 計算隨機點 X 座標  \n→ Step 5: Compute y ← center_y + r * sin(θ) // 計算隨機點 Y 座標  \n→ Step 6: Return [x, y] // 傳回隨機點  \nEnd // randPoint() 執行結束"
    },
    {
      "title": "Continuous Subarray Sum",
      "source_file": "Leetcode/leetcode523.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[23,2,4,6,7], 6",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpifzlnk2g.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpifzlnk2g.py\", line 41, in main\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpifzlnk2g.py\", line 30, in parse_input\n    nums = ast.literal_eval(arr_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [23\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[23,2,6,4,7], 6",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj9dsf9a2.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpj9dsf9a2.py\", line 41, in main\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpj9dsf9a2.py\", line 30, in parse_input\n    nums = ast.literal_eval(arr_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [23\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "[23,2,6,4,7], 13",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqkh0lgo9.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpqkh0lgo9.py\", line 41, in main\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqkh0lgo9.py\", line 30, in parse_input\n    nums = ast.literal_eval(arr_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [23\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkSubarraySum(self, nums, k):\n        # Map from remainder (or total when k==0) to earliest index\n        mod_map = {0: -1}\n        total = 0\n        for i, num in enumerate(nums):\n            total += num\n            if k != 0:\n                total %= k\n            if total in mod_map:\n                if i - mod_map[total] > 1:\n                    return True\n            else:\n                mod_map[total] = i\n        return False\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form: '[1,2,3], 6' or '1 2 3\\n6'\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], 0\n    # Try split by the first comma\n    if ',' in data:\n        arr_part, k_part = data.split(',', 1)\n        nums = ast.literal_eval(arr_part.strip())\n        k = int(k_part.strip())\n    else:\n        # Assume space or newline separated values\n        parts = data.replace('\\n', ' ').split()\n        nums = [int(x) for x in parts[:-1]]\n        k = int(parts[-1])\n    return nums, k\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    result = Solution().checkSubarraySum(nums, k)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudo-code step-by-step. The problem: check if array has subarray length >=2 with sum % k == 0. Approach: maintain cumulative sum mod k, store first occurrence of each mod. For each index, if same mod seen before and distance >=2 then true. Also consider k==0 special: need subarray with sum==0 of length>=2. Use cumulative sum; if any two same cumulative sums at distance>=2? Actually sum zero if cumulative sums equal. So same logic with mod? If k==0 we treat mod not defined; we can directly check any subarray sum zero length>=2: maintain map of cumulative sum to first index. When encountering same sum again with diff >=2 => true.\n\nLet's produce pseudocode lines.\n\nStart. Input nums, k. Create map rem_index = {}. Compute cum_sum=0. For i from 0 to len(nums)-1:\n cum_sum += nums[i]\n if k!=0: rem = cum_sum mod k\n else: rem = cum_sum (sum)\n If rem in rem_index:\n   if i - rem_index[rem] >=2: return true\n else: rem_index[rem] = i\n // but we also need to store earliest occurrence; only store if not already present\n // If not found, store.\n After loop, return false.\n\nBut we need to store earliest occurrence: So at each step, if rem not in map: set map[rem]=i\n\nAlso we need handle zero sum subarray for k==0: similar.\n\nEdge cases: negative k? mod negative? Use absolute maybe. but we can treat k==0 separately.\n\nLet's produce pseudocode lines with comments.\n\nAlso ensure use arrow and decision structure.\n\nWe'll use Decision to check k==0 or not.\n\nStart // 程式開始執行\n→ Step 1: 初始化 cum_sum ← 0 // 累積和\n→ Step 2: 初始化 map ← 空映射 // 以餘數為鍵，存最早出現的索引\n→ Decision: k 等於 0? // 判斷 k 是否為 0\n    Yes → Step 3a: 使用 cum_sum 作為鍵來檢查重複 // k 為 0 時以總和作鍵\n    No  → Step 3b: 計算 rem ← cum_sum mod k // k 非 0 時以餘數作鍵\n\nBut we need a loop. We'll maybe not use Decision inside loop; just treat k==0 before loop or inside loop. Simpler: inside loop we compute rem appropriately based on k.\n\nLet's produce pseudocode:  \n\nStep 3: for i in 0..len(nums)-1:\n    cum_sum ← cum_sum + nums[i]\n    if k == 0:\n        key ← cum_sum\n    else:\n        key ← cum_sum mod k\n    if key 在 map 中:\n        if i - map[key] ≥ 2:\n            return true\n    else:\n        map[key] ← i\n\nAfter loop return false.\n\nBut need to produce lines step by step with arrows.\n\nLet's produce pseudo-code lines:\n\nStart // 程式開始執行\n→ Step 1: cum_sum ← 0 // 初始化累積和\n→ Step 2: map ← 空映射 // 存儲餘數/總和與其第一次出現的索引\n→ Step 3: for i 從 0 到 nums.length-1 做:\n    → Step 3a: cum_sum ← cum_sum + nums[i] // 加入當前元素\n    → Step 3b: Decision: k 等於 0? // 判斷 k 是否為 0\n        Yes → Step 3b1: key ← cum_sum // k 為 0 時以總和作為鍵\n        No  → Step 3b2: key ← cum_sum mod k // k 非 0 時以餘數作鍵\n    → Step 3c: Decision: key 是否已存在於 map? // 檢查是否已看到相同鍵\n        Yes → Step 3c1: if i - map[key] ≥ 2: return true // 位置距離≥2，找到有效子陣列\n        No  → Step 3c2: map[key] ← i // 第一個出現，記錄索引\n→ Step 4: return false // 沒有符合條件的子陣列\n\nEnd // 程式執行結束\n\nMake sure each line is one statement. Also include arrow indent maybe with tab? But specification: use arrow (→) for each step. For decisions, use Decision: and indent.\n\nAlso include the comment after space.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: cum_sum ← 0 // 初始化累積和\n→ Step 2: map ← 空映射 // 用來儲存餘數/總和與其第一次出現的索引\n→ Step 3: for i 從 0 到 nums.length-1 做:\n    → Step 3a: cum_sum ← cum_sum + nums[i] // 加入目前元素\n    → Decision: k 等於 0? // 判斷 k 是否為 0\n        Yes → Step 3b1: key ← cum_sum // k 為 0 時以總和作為鍵\n        No  → Step 3b2: key ← cum_sum mod k // k 非 0 時以餘數作鍵\n    → Decision: key 是否已存在於 map? // 檢查是否已看到相同鍵\n        Yes → Step 3c1: if i - map[key] ≥ 2 then return true // 位置距離 ≥ 2，找到有效子陣列\n        No  → Step 3c2: map[key] ← i // 第一個出現，記錄索引\n→ Step 4: return false // 沒有符合條件的子陣列\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[1,2,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [1, 2, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 先把原始陣列複製一份，以備 reset 使用\n        self.original = list(nums)\n        # 工作陣列現在等於原始陣列\n        self.nums = list(nums)\n\n    def reset(self):\n        # 重新把 nums 重新設為原始陣列的複本\n        self.nums = list(self.original)\n        return self.nums\n\n    def shuffle(self):\n        # Fisher–Yates 洗牌\n        n = len(self.nums)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        return self.nums\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如\n        '[\"Solution\", \"shuffle\"], [[[1, 2, 3]], []]'\n    的字串，回傳兩個 list。\n    \"\"\"\n    depth = 0\n    sep = None\n    for idx, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            sep = idx\n            break\n    if sep is None:\n        raise ValueError(\"Invalid input format\")\n    ops_str = data[:sep].strip()\n    args_str = data[sep + 1:].strip()\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    ops, args = parse_input(raw)\n\n    outputs = []\n    sol = None\n    for op, arg in zip(ops, args):\n        if op == 'Solution':\n            sol = Solution(arg[0])\n            outputs.append(None)\n        elif op == 'reset':\n            outputs.append(sol.reset())\n        elif op == 'shuffle':\n            outputs.append(sol.shuffle())\n        else:\n            outputs.append(None)  # 若有未知操作則輸出 None\n    # 使用 json.dumps 以得到 null 代表 None\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing Solution class with methods constructor, reset, shuffle. The problem: shuffle uniformly random. We'll produce steps for constructor: store original array and copy. reset: return original copy. shuffle: use Fisher-Yates shuffle on a copy of original array. We'll output step by step. Use Start End, Decision, arrow etc. Each line: \"虛擬碼步驟 // 解釋\". Provide maybe pseudo-code inside. Since we need \"逐行\" output. We'll generate lines accordingly.\n\nLet's craft.\n\nStart\n→ Step 1: 定義 class Solution // 定義 Solution 類別\n→ Step 2: 定義成員變數 original, nums // 存放原始陣列與工作陣列\n→ Step 3: Constructor: Input nums // 初始化\n    → Step 4: Set this.original = copy(nums) // 取得原始陣列複本\n    → Step 5: Set this.nums = copy(nums) // 設定工作陣列為原始陣列複本\n→ Step 6: Method reset() // 重置陣列\n    → Step 7: Set this.nums = copy(this.original) // 重新複製原始陣列\n    → Step 8: Return this.nums // 回傳重置後陣列\n→ Step 9: Method shuffle() // 隨機打亂陣列\n    → Step 10: For i from 0 to len-1\n        → Step 11: Randomly pick j between i and len-1\n        → Step 12: Swap this.nums[i] with this.nums[j] // Fisher-Yates swap\n    → Step 13: Return this.nums // 回傳打亂後陣列\nEnd\n\nNeed to use arrows and decisions? We can incorporate decisions not necessary. Use arrows →. Provide explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 class Solution // 建立 Solution 類別  \n→ Step 2: 定義成員變數 original, nums // 用於儲存原始陣列與工作陣列  \n→ Step 3: Constructor: Input nums // 建構子，接受輸入陣列  \n    → Step 4: Set this.original = copy(nums) // 先複製原始陣列，作為重置時使用  \n    → Step 5: Set this.nums = copy(nums) // 也複製一份作為目前工作陣列  \n→ Step 6: Method reset() // 重置陣列的方法  \n    → Step 7: Set this.nums = copy(this.original) // 把工作陣列重新設為原始陣列的複本  \n    → Step 8: Return this.nums // 回傳已重置的陣列  \n→ Step 9: Method shuffle() // 隨機打亂陣列的方法  \n    → Step 10: For i from 0 to len-1 // 從第一個位置開始遍歷  \n        → Step 11: Randomly pick j between i and len-1 // 隨機選擇從 i 到最後一個位置的索引  \n        → Step 12: Swap this.nums[i] with this.nums[j] // Fisher‑Yates 交換，確保每個排列等可能  \n    → Step 13: Return this.nums // 回傳打亂後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Comments",
      "source_file": "Leetcode/leetcode722.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"ab\"]'\nGot (Norm):      '[\"b\"]'\n--- (Raw) ---\nRaw Expected: '[\"ab\"]'\nRaw Got:      \"['b']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n        for line in source:\n            i = 0\n            new_line = []\n            while i < len(line):\n                if not in_block:\n                    # Check for block comment start\n                    if i + 1 < len(line) and line[i] == '/' and line[i+1] == '*':\n                        in_block = True\n                        i += 2\n                        continue\n                    # Check for line comment\n                    if i + 1 < len(line) and line[i] == '/' and line[i+1] == '/':\n                        break\n                    # Normal character\n                    new_line.append(line[i])\n                    i += 1\n                else:\n                    # Inside block comment, look for end\n                    if i + 1 < len(line) and line[i] == '*' and line[i+1] == '/':\n                        in_block = False\n                        i += 2\n                    else:\n                        i += 1\n            if new_line and not in_block:\n                res.append(\"\".join(new_line))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Expect format: source = [ ... ]\n    _, _, src_str = data.partition('=')\n    source = ast.literal_eval(src_str.strip())\n    solution = Solution()\n    result = solution.removeComments(source)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps to remove comments from C++ source. It's basically LeetCode problem \"Remove Comments\". We need to produce step-by-step pseudocode, not actual code. The user wants virtual code with comments, each line ends with // explanation. Must not output real code. Use arrows, Start, End, Decision etc. So we produce algorithm: iterate through lines, maintain insideBlock flag, build output line. For each char, check start of comment, handle block and line. Provide final removal.\n\nWe'll produce pseudocode: Start, initialize result list, insideBlock = False. For each line index, process line. Use pointer i. Use currentLine string builder. While i < len(line): if insideBlock: check for \"*/\" -> end block, set insideBlock False, skip both chars, i +=2 else i++ (skip inside). else: not inside block: check if line comment \"//\": break loop (ignore rest). else if block start \"/*\": insideBlock = True, skip both, i +=2. else: add char to currentLine, i++. After loop, if currentLine not empty: append to result. After all lines: return result. Also note: after block comment ends, the rest of line may have code; but since we continue loop after closing, it will add rest to currentLine.\n\nWe must also handle empty lines after removal: skip adding. At end, return result.\n\nNow produce lines with virtual code step-by-step. Use indentation with arrow and decisions. Each line with explanation after //.\n\nLet's craft.\n\nStart\n\n→ Step 1: Initialize result list // 建立空結果列表\n→ Step 2: insideBlock ← False // 是否在區塊註解中\n→ Step 3: For each line in source // 逐行處理\n    → Step 4: current ← \"\" // 用於累積去註解後的字元\n    → Step 5: i ← 0 // 字元指標\n    → Step 6: While i < length(line) // 逐字檢查\n        → Decision: 如果 insideBlock? // 判斷是否已進入區塊註解\n            Yes → Step 7: If line[i:i+2] == \"*/\"? // 判斷結束標記\n                    Yes → insideBlock ← False; i += 2 // 結束區塊註解\n                    No → i += 1 // 仍在區塊內，跳過字元\n            No  → Decision: 如果 line[i:i+2] == \"//\"? // 判斷行註解\n                    Yes → Break // 跳過剩餘字元\n                    No  → Decision: 如果 line[i:i+2] == \"/*\"? // 判斷區塊開始\n                            Yes → insideBlock ← True; i += 2 // 進入區塊註解\n                            No  → Step 8: current ← current + line[i] // 加入正常字元\n                                    i += 1 // 移動到下一個字元\n    → Decision: 如果 current != \"\"? // 取得非空行\n        Yes → Append current to result // 加入結果\n        No  → // 忽略空行\nEnd // 完成去除註解\n\nAlso need to mention implicit newline removal via block comments: when block comment spans multiple lines, we skip them, not adding newline.\n\nShould mention that after block comment ends within a line, we continue scanning rest of line.\n\nAdd explanation lines accordingly.\n\nWe should not output actual code. Use pseudocode.\n\nOk produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize result ← [] // 建立空結果列表  \n→ Step 2: insideBlock ← False // 標記是否處於區塊註解內  \n→ Step 3: For each line in source // 逐行處理  \n  → Step 4: current ← \"\" // 用於累積去註解後的字元  \n  → Step 5: i ← 0 // 字元指標  \n  → Step 6: While i < length(line) // 逐字檢查  \n    → Decision: insideBlock? // 判斷是否已進入區塊註解  \n     Yes → Step 7: If line[i:i+2] == \"*/\"? // 判斷區塊結束標記  \n       Yes → insideBlock ← False; i += 2 // 結束區塊註解，跳過兩字元  \n       No → i += 1 // 仍在區塊內，忽略此字元  \n     No → Decision: line[i:i+2] == \"//\"? // 判斷行註解開始  \n       Yes → Break // 跳過整行剩餘字元  \n       No → Decision: line[i:i+2] == \"/*\"? // 判斷區塊註解開始  \n        Yes → insideBlock ← True; i += 2 // 進入區塊註解，跳過兩字元  \n        No → Step 8: current ← current + line[i] // 加入正常字元  \n          i += 1 // 移動到下一個字元  \n  → Decision: current != \"\"? // 取得非空行  \n    Yes → Append current to result // 加入結果列表  \n    No → // 忽略空行（已被註解移除的行）  \nEnd // 程式執行結束，結果已存於 result 中，回傳此列表。"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    \"\"\"\n    產生 nums 的所有子集 (冪集合)。\n    使用回溯法，遞迴時把目前子集的副本加入結果。\n    \"\"\"\n    result = []\n\n    def backtrack(start, path):\n        # 把目前子集加入結果\n        result.append(path[:])\n\n        # 從 start 開始，嘗試加入每個元素\n        for i in range(start, len(nums)):\n            path.append(nums[i])          # 選取元素\n            backtrack(i + 1, path)        # 進入下一層\n            path.pop()                    # 回溯，取消選取\n\n    backtrack(0, [])\n    return result\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        # 沒有輸入時不輸出任何東西\n        sys.exit(0)\n\n    # 解析輸入，預期格式為：nums = [1,2,3]\n    try:\n        # 只取等號右側的內容作為 Python 表達式\n        _, expr = raw_input.split('=', 1)\n        nums = ast.literal_eval(expr.strip())\n    except Exception as e:\n        # 若解析失敗，直接結束\n        sys.exit(1)\n\n    # 計算所有子集並輸出\n    result = subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of a unique integer array. It's essentially the power set. We need to output virtual code step-by-step with comments. No actual code. Use virtual code with arrows and decisions. It's typical backtracking. Each step: Start, input array, recursion, add subset to result, backtrack, return result, End. Provide explanation for each line. Let's produce.\n\nWe should use structure: Start, Step 1: Input array, Step 2: Define result list, Step 3: Define backtrack function, Step 4: Add current subset to result, Step 5: Loop over elements starting from index, add element, call backtrack, remove element. Then initial call, return result, End.\n\nAdd decision points? Not many decisions. We can have a Decision for loop condition. But it's fine to just use steps. But requirement says use Decision: and Yes/No arrow. Might include decision to check if index equals length. But we can embed in loop.\n\nLet's structure: Start, Step 1: Get nums, Step 2: Initialize result, Step 3: Define backtrack(current, start). Step 4: Add copy of current to result. Step 5: Decision: start == len(nums)? No: loop i from start to len-1. Step 6: Yes → Step 7: current.append(nums[i]) // choose, Step 8: backtrack(current, i+1) // recursion, Step 9: current.pop() // backtrack, Step 10: End of loop, Step 11: Return result. End.\n\nWe need to embed decision lines: Decision: if start == len(nums)? Actually we don't need. We can just loop. But can include Decision: has more elements? Let's do Decision: if start < len(nums)? Yes → loop, No → return. We'll incorporate.\n\nLet's produce final virtual code accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入唯一元素陣列 nums // 取得輸入的整數陣列\n→ Step 2: 初始化結果 list subsets = [] // 用於儲存所有子集\n→ Step 3: 定義遞迴函式 backtrack(current, start) // current 為目前的子集，start 為可選擇的起始索引\n    → Step 4: 將 current 的副本加入 subsets // 把目前子集存入結果\n    → Decision: start < len(nums) ? // 是否還有未處理的元素可加入\n        Yes → Step 5: 循環 i 從 start 到 len(nums)-1\n            → Step 6: current.append(nums[i]) // 選取元素\n            → Step 7: backtrack(current, i+1) // 以遞迴方式處理後續元素\n            → Step 8: current.pop() // 取消選取，回溯到前一步\n        No  → Step 9: 直接返回 // 無更多元素，結束此路徑\n→ Step 10: 呼叫 backtrack([], 0) // 從空子集開始遞迴\n→ Step 11: 回傳 subsets // 返回所有子集\nEnd // 程式執行結束"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[5],null,null,[6,5],null,[5]]'\nGot (Norm):      '[null,[5],null,null,[6,5],null,[5]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [5], null, null, [6, 5], null, [5]]'\nRaw Got:      '[null, [5], null, null, [6, 5], null, [5]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)        # userId -> list of (time, tweetId)\n        self.following = defaultdict(set)     # userId -> set of followeeIds\n\n    def postTweet(self, userId, tweetId):\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # a user always follows himself\n        if userId not in self.following[userId]:\n            self.following[userId].add(userId)\n\n    def follow(self, followerId, followeeId):\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId, followeeId):\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\n    def getNewsFeed(self, userId):\n        res = []\n        if userId not in self.following:\n            return res\n        heap = []\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid, [])\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # eval safely because input follows Python literal syntax\n    ops, args = eval(data, {}, {})\n    twitter = Twitter()\n    output = []\n    for op, arg in zip(ops, args):\n        if op == \"postTweet\":\n            twitter.postTweet(*arg)\n            output.append(None)\n        elif op == \"follow\":\n            twitter.follow(*arg)\n            output.append(None)\n        elif op == \"unfollow\":\n            twitter.unfollow(*arg)\n            output.append(None)\n        elif op == \"getNewsFeed\":\n            output.append(twitter.getNewsFeed(*arg))\n    # Convert Python None to JSON null\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. This is design of a Twitter class with methods: init, postTweet, getNewsFeed, follow, unfollow. We need to give pseudo code for data structures and operations. We'll produce a high-level algorithm. Must use arrows, Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". Let's produce something like:\n\nStart // 程式開始\n→ Step 1: 定義 class Twitter // 建立 Twitter 類別\n→ Step 2: 初始化 tweetTime, followers, tweetList, userTweets // 變數初始化\n...\n\nWe need to cover each method. Provide pseudo steps for each method. Might be best to structure as pseudo code of class with methods, but each line still has arrow? Probably yes. Let's produce a block for class definition then methods, each line with arrow.\n\nWe'll do:\n\nStart // 程式開始\n→ Step 1: 定義類別 Twitter // 建立 Twitter 類別\n→ Step 2: 成員變數: currentTime ← 0 // 時間戳記，遞增\n→ Step 3: followersMap ← 空字典 // key: userId, value: 設集合 followers\n→ Step 4: tweetsMap ← 空字典 // key: userId, value: 列表 tweetId\n→ Step 5: tweetsTimeMap ← 空字典 // key: tweetId, value: 發布時間\n\nMethod: Twitter() // constructor\n→ Step 6: // 初始化所有資料結構\n    followersMap ← 空字典\n    tweetsMap ← 空字典\n    tweetsTimeMap ← 空字典\n    currentTime ← 0\nEnd\n\nMethod: postTweet(userId, tweetId)\n→ Step 7: // 若用戶不存在，建立空集合\n    If userId not in followersMap Then followersMap[userId] ← 空集合\n    If userId not in tweetsMap Then tweetsMap[userId] ← 空列表\n→ Step 8: currentTime ← currentTime + 1 // 時間戳更新\n→ Step 9: tweetsMap[userId].append(tweetId) // 加入使用者的貼文\n→ Step 10: tweetsTimeMap[tweetId] ← currentTime // 記錄時間\n\nMethod: follow(followerId, followeeId)\n→ Step 11: // 若跟隨者不存在，初始化\n    If followerId not in followersMap Then followersMap[followerId] ← 空集合\n→ Step 12: followersMap[followerId].add(followeeId) // 加入關注\n\nMethod: unfollow(followerId, followeeId)\n→ Step 13: If followerId in followersMap Then\n    followersMap[followerId].remove(followeeId) // 移除關注\n\nMethod: getNewsFeed(userId)\n→ Step 14: // 收集關注的用戶和自己\n    usersToCheck ← followersMap.get(userId, 空集合) ∪ {userId}\n→ Step 15: // 建立最小堆或優先佇列，最多 10 個\n    feed ← 空最小堆（按時間戳排序）\n→ Step 16: For each u in usersToCheck Do\n    If u in tweetsMap Then\n        For each t in tweetsMap[u] Do\n            If feed.size < 10 Then feed.push((tweetsTimeMap[t], t))\n            Else If tweetsTimeMap[t] > feed.peek().time Then\n                feed.pop()\n                feed.push((tweetsTimeMap[t], t))\n→ Step 17: result ← 空列表\n→ Step 18: While feed not empty Do\n    result.prepend(feed.pop().tweetId) // 取出最舊，先加到前面\n→ Step 19: Return result\n\nEnd\n\nBut we need to follow output format: each line: \"虛擬碼步驟 [space] // 解釋\". We also need arrows '→' for steps, 'Decision:' maybe. Use Start/End.\n\nLet's produce line by line. I'll incorporate indentation and decision.\n\nBe mindful to keep each line separate. Use \"Decision:\" lines for conditionals.\n\nLet's craft:\n\nStart // 程式開始\n\n→ Step 1: 定義類別 Twitter // 建立 Twitter 類別\n\n→ Step 2: 成員變數 currentTime ← 0 // 時間戳記，遞增\n\n→ Step 3: 成員變數 followersMap ← 空字典 // key: userId, value: follower 集合\n\n→ Step 4: 成員變數 tweetsMap ← 空字典 // key: userId, value: tweetId 列表\n\n→ Step 5: 成員變數 tweetsTimeMap ← 空字典 // key: tweetId, value: 發布時間\n\n→ Step 6: 方法 Twitter() // 建構子\n\n    → Decision: 若 followersMap 為空? // 初始化資料結構\n        Yes → followersMap ← 空字典 // 建立 followers 連結表\n        No  → 無操作\n\n    → Decision: 若 tweetsMap 為空? // 初始化貼文存儲\n        Yes → tweetsMap ← 空字典\n        No  → 無操作\n\n    → Decision: 若 tweetsTimeMap 為空?\n        Yes → tweetsTimeMap ← 空字典\n        No  → 無操作\n\n    → currentTime ← 0 // 重置時間戳\n\nEnd // 建構子結束\n\n→ Step 7: 方法 postTweet(userId, tweetId) // 發布貼文\n\n    → Decision: 若 userId 不在 followersMap? // 確保使用者資料存在\n        Yes → followersMap[userId] ← 空集合\n        No  → 無操作\n\n    → Decision: 若 userId 不在 tweetsMap? // 初始化使用者貼文列表\n        Yes → tweetsMap[userId] ← 空列表\n        No  → 無操作\n\n    → currentTime ← currentTime + 1 // 時間戳遞增\n\n    → tweetsMap[userId].append(tweetId) // 加入貼文\n\n    → tweetsTimeMap[tweetId] ← currentTime // 記錄時間\n\nEnd // 發布貼文結束\n\n→ Step 8: 方法 follow(followerId, followeeId) // 追蹤使用者\n\n    → Decision: 若 followerId 不在 followersMap? // 初始化追蹤集合\n        Yes → followersMap[followerId] ← 空集合\n        No  → 無操作\n\n    → followersMap[followerId].add(followeeId) // 加入追蹤\n\nEnd // 追蹤結束\n\n→ Step 9: 方法 unfollow(followerId, followeeId) // 取關\n\n    → Decision: 若 followerId 在 followersMap? // 確認存在\n        Yes → followersMap[followerId].remove(followeeId) // 移除追蹤\n        No  → 無操作\n\nEnd // 取關結束\n\n→ Step 10: 方法 getNewsFeed(userId) // 取得新聞動態\n\n    → usersToCheck ← followersMap.get(userId, 空集合) ∪ {userId} // 取得自己與追蹤者\n\n    → feed ← 空最小堆（按時間戳排序） // 儲存最近貼文，容量10\n\n    → For each u in usersToCheck Do // 遍歷所有相關使用者\n        → Decision: 若 u 在 tweetsMap? // 有貼文才處理\n            Yes → For each t in tweetsMap[u] Do\n                → Decision: 若 feed.size < 10? // 堆未滿\n                    Yes → feed.push((tweetsTimeMap[t], t)) // 加入\n                    No  → Decision: 若 tweetsTimeMap[t] > feed.peek().time? // 新貼文更新\n                        Yes → feed.pop() // 去除最舊\n                        → feed.push((tweetsTimeMap[t], t)) // 加入新貼文\n                        No  → 無操作\n                → No → 無操作\n            No → 無操作\n\n    → result ← 空列表 // 儲存最終結果\n\n    → While feed not empty Do\n        → result.prepend(feed.pop().tweetId) // 取出最舊，放在前面，得到最新順序\n\n    → Return result // 回傳結果\n\nEnd // 取得新聞動態結束\n\nEnd // 程式執行結束\n\nWe need to ensure each line begins with '→' except Start and End. But decision lines have 'Decision:'. In the example, they show Decision lines with indentation. So I need to maintain that. Also each line includes \" // 解釋\". We'll produce accordingly. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 定義類別 Twitter // 建立 Twitter 類別\n\n→ Step 2: 成員變數 currentTime ← 0 // 時間戳記，遞增\n\n→ Step 3: 成員變數 followersMap ← 空字典 // key: userId, value: 追蹤者集合\n\n→ Step 4: 成員變數 tweetsMap ← 空字典 // key: userId, value: tweetId 列表\n\n→ Step 5: 成員變數 tweetsTimeMap ← 空字典 // key: tweetId, value: 發布時間\n\n→ Step 6: 方法 Twitter() // 建構子\n\n  → Decision: 若 followersMap 為空? // 初始化資料結構\n    Yes → followersMap ← 空字典 // 建立追蹤連結表\n    No  → 無操作\n\n  → Decision: 若 tweetsMap 為空? // 初始化貼文存儲\n    Yes → tweetsMap ← 空字典\n    No  → 無操作\n\n  → Decision: 若 tweetsTimeMap 為空? // 初始化時間映射\n    Yes → tweetsTimeMap ← 空字典\n    No  → 無操作\n\n  → currentTime ← 0 // 重置時間戳\n\nEnd // 建構子結束\n\n→ Step 7: 方法 postTweet(userId, tweetId) // 發布貼文\n\n  → Decision: 若 userId 不在 followersMap? // 確保使用者資料存在\n    Yes → followersMap[userId] ← 空集合\n    No  → 無操作\n\n  → Decision: 若 userId 不在 tweetsMap? // 初始化使用者貼文列表\n    Yes → tweetsMap[userId] ← 空列表\n    No  → 無操作\n\n  → currentTime ← currentTime + 1 // 時間戳遞增\n\n  → tweetsMap[userId].append(tweetId) // 加入貼文\n\n  → tweetsTimeMap[tweetId] ← currentTime // 記錄時間\n\nEnd // 發布貼文結束\n\n→ Step 8: 方法 follow(followerId, followeeId) // 追蹤使用者\n\n  → Decision: 若 followerId 不在 followersMap? // 初始化追蹤集合\n    Yes → followersMap[followerId] ← 空集合\n    No  → 無操作\n\n  → followersMap[followerId].add(followeeId) // 加入追蹤\n\nEnd // 追蹤結束\n\n→ Step 9: 方法 unfollow(followerId, followeeId) // 取關\n\n  → Decision: 若 followerId 在 followersMap? // 確認存在\n    Yes → followersMap[followerId].remove(followeeId) // 移除追蹤\n    No  → 無操作\n\nEnd // 取關結束\n\n→ Step 10: 方法 getNewsFeed(userId) // 取得新聞動態\n\n  → usersToCheck ← followersMap.get(userId, 空集合) ∪ {userId} // 取得自己與追蹤者\n\n  → feed ← 空最小堆（按時間戳排序） // 儲存最近貼文，容量10\n\n  → For each u in usersToCheck Do // 遍歷所有相關使用者\n    → Decision: 若 u 在 tweetsMap? // 有貼文才處理\n      Yes → For each t in tweetsMap[u] Do\n        → Decision: 若 feed.size < 10? // 堆未滿\n          Yes → feed.push((tweetsTimeMap[t], t)) // 加入\n          No  → Decision: 若 tweetsTimeMap[t] > feed.peek().time? // 新貼文更新\n            Yes → feed.pop() // 去除最舊\n            → feed.push((tweetsTimeMap[t], t)) // 加入新貼文\n            No  → 無操作\n          No → 無操作\n      No → 無操作\n\n  → result ← 空列表 // 儲存最終結果\n\n  → While feed not empty Do\n    → result.prepend(feed.pop().tweetId) // 取出最舊，放在前面，得到最新順序\n\n  → Return result // 回傳結果\n\nEnd // 取得新聞動態結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2qdr4xjo.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmp2qdr4xjo.py\", line 22, in main\n    commands = json.loads(raw_input[0])\n               ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 49 (char 48)"
        }
      ],
      "generated_code": "import json\nimport sys\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列，prefix_sums[i] 代表前 i 個元素的總和\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    # 讀取全部輸入，並以換行分割\n    raw_input = sys.stdin.read().strip().splitlines()\n    if not raw_input:\n        return\n\n    # 第一行為方法名稱列表，第二行為相對應的參數列表\n    commands = json.loads(raw_input[0])\n    arguments = json.loads(raw_input[1])\n\n    results = []\n    obj = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"NumArray\":\n            # arg 為 [[num1, num2, ...]]，取第一個元素作為陣列\n            obj = NumArray(arg[0])\n            results.append(None)          # 與 LeetCode 風格相同，建構器回傳 null\n        elif cmd == \"sumRange\":\n            res = obj.sumRange(arg[0], arg[1])\n            results.append(res)\n\n    # 輸出結果，使用 json.dumps 可自動將 None 轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementing the NumArray class with sumRange using prefix sums. Provide step by step in the format: Start, etc. Each line with \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Provide multiple lines. Should include initialization, building prefix array, sumRange logic. Use decisions if needed. Probably no decisions needed, just compute.\n\nWe need to be careful to use \"Start\" and \"End\". For constructor: Step 1: store array and compute prefix sums.\n\nFor sumRange: compute prefix[right+1] - prefix[left].\n\nWe'll produce virtual code lines.\n\nLet's produce:\n\nStart\n→ Step 1: 建立 NumArray 類別並初始化 nums 與 prefix // 存儲原始陣列與前綴和\n→ Step 2: 建立 prefix 陣列長度為 nums.Length + 1 // 為方便計算前綴和\n→ Step 3: prefix[0] ← 0 // 前綴和的起始值\n→ Step 4: 循環 i 從 0 到 nums.Length - 1\n    → Step 5: prefix[i+1] ← prefix[i] + nums[i] // 更新前綴和\nEnd // 建構完成\n\nStart\n→ Step 1: 定義 sumRange(left, right) 方法 // 接收查詢區間\n→ Step 2: 檢查 left 與 right 是否在有效範圍內\n    Yes → (continue)\n    No  → Throw exception 或返回 0 // 防止非法索引\n→ Step 3: result ← prefix[right+1] - prefix[left] // 取得區間總和\n→ Step 4: 返回 result // 結果回傳\nEnd // 方法結束\n\nWe need to include decisions. Also we can include \"Decision:\" lines. Use \"Decision:\" format. Use \"Yes →\" \"No →\". Provide explanation. Good.\n\nLet's format.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 NumArray 類別並初始化 nums 與 prefix // 存儲原始陣列與前綴和\n→ Step 2: 建立 prefix 陣列長度為 nums.Length + 1 // 為方便計算前綴和\n→ Step 3: prefix[0] ← 0 // 前綴和的起始值\n→ Step 4: 循環 i 從 0 到 nums.Length - 1\n    → Step 5: prefix[i+1] ← prefix[i] + nums[i] // 更新前綴和\nEnd // 建構完成\n\nStart // sumRange 方法開始執行\n→ Step 1: 定義 sumRange(left, right) 方法 // 接收查詢區間\n→ Decision: left 與 right 是否在有效範圍內? // 防止非法索引\n    Yes → Step 2: (繼續) // 兩個索引合法\n    No  → Step 3: 返回 0 或拋出例外 // 失敗時返回預設值\n→ Step 4: result ← prefix[right+1] - prefix[left] // 取得區間總和\n→ Step 5: 返回 result // 結果回傳\nEnd // 方法結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,3,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, 3, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        \"\"\"Increase frequency of key and reposition it.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current freq list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next freq list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used, LRU if tie\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Parse the input format: two lists, e.g. '[\"LFUCache\", ...], [[2], ...]'\n    ops, args = ast.literal_eval(data)\n    results = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            res = cache.get(arg[0])\n            results.append(res)\n    print(repr(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The design: Use hash map key->node (with freq, value). And freq map freq->ordered dict (or linked list) of keys to support O(1) LRU per freq. Need minFreq variable. Steps: constructor, get, put, increaseFreq, removeNode, evict. We'll produce pseudocode with arrows.\n\nMake sure each line ends with // 解釋/說明. Use virtual arrows. We'll produce lines. Use indentation with spaces for nested blocks? In sample they used indentation for decision branches. We'll follow.\n\nLet's produce: Start, then Step 1: initialize capacity, capacity>0 else 0. Initialize maps, minFreq=0. Then get(key): check if key not exist return -1 else increase freq and return value. Put(key,val): if capacity==0 return. If key exists: update value and increase freq. Else if size==capacity: evict. Then insert new node with freq=1, update freqMap[1] list, minFreq=1. End. Provide explanation each line.\n\nAlso include helper functions: increaseFreq(node) updates node's freq: remove from old freq list, add to new freq list; update minFreq if needed. Evict: from freqMap[minFreq] list pop first (LRU) node, delete from key map. Use ordered structure: we can represent as queue or doubly linked list; in pseudocode just use list with push_back and pop_front.\n\nWe'll produce line by line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 LFUCache(capacity) // 設定容量並建立必要資料結構\n    → Decision: 如果 capacity <= 0? // 檢查容量是否合法\n        Yes → End // 若容量為 0 或負數，直接結束建構\n        No  →  // 進行資料結構初始化\n            → Step 2: 建立 keyMap ← 空哈希表 // 存放 key → node 的映射\n            → Step 3: 建立 freqMap ← 空哈希表 // 存放 freq → 順序表（LRU）\n            → Step 4: 建立 minFreq ← 0 // 目前最小使用頻率\nEnd // 建構完成\n\nStart // 程式開始執行\n→ Step 5: get(key) // 取得 key 的值\n    → Decision: 如果 keyMap 中不存在 key? // 檢查 key 是否在快取\n        Yes → Step 6: return -1 // 未找到，回傳 -1\n        No  →  // 找到 key，執行頻率遞增並回傳值\n            → Step 7: node ← keyMap[key] // 取得節點\n            → Step 8: increaseFreq(node) // 更新頻率\n            → Step 9: return node.value // 回傳存儲的值\nEnd // get 執行結束\n\nStart // 程式開始執行\n→ Step 10: put(key, value) // 插入或更新 key/value\n    → Decision: 如果 capacity == 0? // 無容量時直接返回\n        Yes → End // 結束函式\n        No  →  // 進行後續處理\n            → Decision: keyMap 中是否已存在 key? // 檢查是否更新已有鍵\n                Yes →  // 已存在，更新 value 並遞增頻率\n                    → Step 11: node ← keyMap[key]\n                    → Step 12: node.value ← value\n                    → Step 13: increaseFreq(node)\n                No  →  // 新鍵，需先檢查是否滿載\n                    → Decision: keyMap.size() == capacity? // 是否需要驅除\n                        Yes → Step 14: evict() // 驅除 LFU/ LRU 鍵\n                        No  →  // 直接插入\n                    → Step 15: node ← 新節點(key, value, freq=1)\n                    → Step 16: keyMap[key] ← node\n                    → Step 17: freqMap[1].push_back(node) // 加入頻率 1 的 LRU 列表\n                    → Step 18: minFreq ← 1 // 最小頻率重設為 1\nEnd // put 執行結束\n\nStart // 處理頻率遞增\n→ Step 19: increaseFreq(node) // 將節點頻率從 f 變為 f+1\n    → Step 20: f ← node.freq\n    → Step 21: node.freq ← f + 1\n    → Step 22: freqMap[f].remove(node) // 從舊頻率列表移除\n    → Decision: freqMap[f] 為空? // 判斷舊頻率列表是否被清空\n        Yes → Step 23: delete freqMap[f] // 若空，移除整個頻率項目\n        No  →  // 留下列表\n    → Step 24: freqMap[f+1].push_back(node) // 加入新頻率列表\n    → Decision: minFreq == f 且 freqMap[f] 為空? // 更新 minFreq\n        Yes → Step 25: minFreq ← f + 1\n        No  →  // 不變\nEnd // increaseFreq 執行結束\n\nStart // 驅除 LFU/ LRU 鍵\n→ Step 26: targetList ← freqMap[minFreq] // 取得最小頻率的 LRU 列表\n    → Step 27: node ← targetList.front() // 取出最舊（最不常用）節點\n    → Step 28: targetList.pop_front() // 從列表移除\n    → Decision: targetList 為空? // 若此頻率列表已空\n        Yes → Step 29: delete freqMap[minFreq] // 刪除整個頻率項目\n        No  →  // 留下列表\n    → Step 30: delete keyMap[node.key] // 從 keyMap 中移除對應鍵\nEnd // evict 執行結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpndn6de92.py\", line 34, in <module>\n    obj = Solution(w)\n          ^^^^^^^^^^^\n  File \"/tmp/tmpndn6de92.py\", line 11, in __init__\n    for weight in w:\nTypeError: 'int' object is not iterable"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuha_ldp0.py\", line 34, in <module>\n    obj = Solution(w)\n          ^^^^^^^^^^^\n  File \"/tmp/tmpuha_ldp0.py\", line 11, in __init__\n    for weight in w:\nTypeError: 'int' object is not iterable"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"建立前綴和陣列，用以快速找出隨機索引。\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機產生 1~total 的數字，然後用二分搜尋找對應的索引。\"\"\"\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並轉成 Python 物件\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    ops, args = eval(data)  # 例: ops = [\"Solution\",\"pickIndex\"], args = [[[1]],[]]\n\n    result = []\n    obj = None\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            # args[0][i] 為 [[w]]，取出 w\n            w = args[0][i][0]\n            obj = Solution(w)\n            result.append(None)          # 建構子不回傳值，使用 None 代表 null\n        elif op == \"pickIndex\":\n            idx = obj.pickIndex()\n            result.append(idx)\n        else:\n            # 若有其他方法，可在此處擴充\n            result.append(None)\n\n    # 輸出結果，None 會被轉成 JSON 的 null\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for a function that picks index weighted by array w. Likely we precompute prefix sums and then use random number. Steps: Start, compute prefix sums, store sum. pickIndex: generate random number in [0, sum-1] or [0, sum) and binary search in prefix sums to find index. Use decision structure maybe. We'll produce pseudo code lines with comments. Use arrow \"→\". Must be sequential lines.\n\nWe need to include both initialization (constructor) and pickIndex function. Provide steps. No real code.\n\nLet's output in the required format.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 w // 取得權重資料\n→ Step 2: 初始化 prefixSum[0] = w[0] // 建立前綴和陣列的第一個元素\n→ Decision: w.length > 1? // 判斷陣列是否超過一個元素\n    Yes → Loop i from 1 to w.length-1\n        → Step 3: prefixSum[i] = prefixSum[i-1] + w[i] // 計算前綴和\n    No  → // 只一個元素，前綴和即為該元素\n→ Step 4: totalWeight = prefixSum[w.length-1] // 總權重\n→ End // 建構完成，準備進行隨機選取\n\nStart // pickIndex() 開始\n→ Step 5: r = Random(0, totalWeight-1) // 產生 0~totalWeight-1 的隨機整數\n→ Decision: 二分搜尋於 prefixSum 找到最小索引 i 使 prefixSum[i] > r // 用二分搜尋定位權重區間\n    Yes → Step 6: return i // 回傳找到的索引\n    No  → Step 7: return w.length-1 // 若未找到（理論上不會發生），回傳最後一個索引\nEnd // pickIndex() 執行結束"
    },
    {
      "title": "Cracking the Safe",
      "source_file": "Leetcode/leetcode753.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef crack_safe(n: int, k: int) -> str:\n    # Special case when n == 1: each single digit is a password\n    if n == 1:\n        return ''.join(map(str, range(k)))\n\n    seen = set()\n    result = []\n\n    def dfs(node: str):\n        \"\"\"Depth‑first search to build a De Bruijn sequence.\"\"\"\n        for d in map(str, range(k)):\n            nxt = node + d\n            if nxt not in seen:\n                seen.add(nxt)\n                dfs(nxt[1:])          # remove the first character to keep length n-1\n                result.append(d)      # record the edge when backtracking\n\n    start = '0' * (n - 1)           # start node of the De Bruijn graph\n    dfs(start)\n    return ''.join(result) + start  # linearise the cycle\n\ndef main() -> None:\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(numbers) < 2:\n        return\n    n, k = numbers[0], numbers[1]\n    answer = crack_safe(n, k)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines that solve the problem: given n and k, generate minimal length string over digits 0..k-1 that contains all possible sequences of length n as contiguous substring. This is classic De Bruijn sequence of order n over alphabet size k. Minimal length is k^n + n -1? Actually De Bruijn sequence is length k^n, and when we consider wrap-around to get all sequences, but if we want linear string that contains all sequences as substrings, we can take De Bruijn sequence and then add first n-1 characters at end to allow all sequences to appear linearly, but minimal length required for linear string is k^n + n -1. However we could produce sequence of length k^n + n -1. The algorithm: construct De Bruijn graph of dimension n-1 nodes (strings length n-1), edges labelled by digits, each node has k outgoing edges, representing next n-digit sequence. Find Eulerian cycle, output labels. Then append first n-1 digits to end.\n\nThus pseudo-code: Build adjacency list for graph nodes (k^(n-1)). Use Hierholzer algorithm. Then produce sequence. Output as string.\n\nWe need to output virtual code lines each with explanation.\n\nLet's craft.\n\nWe'll include steps: compute number of nodes, create node list, adjacency generation, iterative stack, etc.\n\nLet's produce code lines.\n\nWe should not output actual code but pseudo-code with arrows.\n\nLet's produce line numbers maybe not necessary but we follow format: Start, then → Step, etc.\n\nLet's write:\n\nStart // Start algorithm\n→ Step 1: Compute alphabet digits 0..k-1 // define possible digits\n→ Step 2: If n == 1, output all digits as string and End // trivial case\n→ Step 3: Construct all nodes: each node is a string of length n-1 over alphabet // nodes represent context\n→ Step 4: For each node, for each digit d in alphabet, create directed edge node → next_node where next_node = suffix of (node + d) of length n-1 // edge label d\n→ Step 5: Initialize empty stack and path list // for Hierholzer\n→ Step 6: Push start_node (string of n-1 zeros) onto stack // start at lexicographically smallest\n→ Decision: While stack not empty? // continue until stack empty\n    → Yes → Step 7: Let current = top of stack\n    → Decision: If current has unused outgoing edges? // check adjacency list\n        → Yes → Step 8: Pick an unused edge (digit d) from current, remove it, push target node onto stack, append digit d to path // record traversal\n        → No → Step 9: Pop current from stack, if stack not empty, append label of edge that led to current to result list // backtrack\n    → No → End // finished\n→ Step 10: Reverse result list to get order of digits in Eulerian cycle // path from cycle\n→ Step 11: Append the first n-1 digits of start_node to end of result // linearize\n→ Step 12: Output the concatenated string // minimal unlocking string\nEnd // algorithm finished\n\nBut we need to follow arrow format and explanation after each line.\n\nWe need to include indentation for decisions. We need to include arrow markers Yes → and No →.\n\nLet's craft lines with indentation.\n\nRemember each line: \"虛擬碼步驟 [space] // 解釋\".\n\nWe'll use spaces between steps, arrows. We'll include indentation as in example.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define alphabet digits as 0 … k‑1 // 設定可能的數字集合  \n→ Step 2: If n == 1, output concatenation of all digits and End // n=1 時直接輸出最短序列  \n→ Step 3: Generate all nodes: every string of length n-1 over the alphabet // 節點代表前 n‑1 個數字  \n→ Step 4: For each node, for each digit d in alphabet, create edge node → nextNode where nextNode = suffix((node + d), n-1) with label d // 建立所有有向邊  \n→ Step 5: Initialise empty stack S and empty list path // 用於 Hierholzer 演算法  \n→ Step 6: Push startNode = string of (n-1) zeros onto S // 從最小節點開始  \n→ Decision: S is not empty? // 判斷是否完成遍歷  \n  Yes → Step 7: Let cur = top of S // 取得堆疊頂部節點  \n  Decision: cur has unused outgoing edges? // 檢查是否還有邊可走  \n   Yes → Step 8: Pick an unused edge (label d) from cur, remove it, push target onto S, append d to path // 走一條邊並記錄數字  \n   No → Step 9: Pop cur from S, if S not empty, append label of edge that led to cur to result // 回溯並記錄路徑  \n  No → End // 所有節點已遍歷完畢  \n→ Step 10: Reverse path to obtain the order of digits in the Eulerian cycle // 逆轉以得到正確順序  \n→ Step 11: Append the first (n-1) digits of startNode to the end of the reversed path // 轉成線性序列  \n→ Step 12: Concatenate startNode with the reversed path and output the string // 得到最短解鎖序列  \nEnd // 程式執行結束"
    }
  ]
}