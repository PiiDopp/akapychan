{
  "run_index": 30,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 401,
  "generation_or_validation_failure_count": 38,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,3,4,2,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 3, 4, 2, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入的所有內容，並直接執行它\n    code = sys.stdin.read()\n    # 用 exec 執行輸入的程式碼，允許呼叫 roll_dice\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output line-by-line virtual code steps with explanations. Use Start, End, Decision: with arrows. Need to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow →, etc. For function roll_dice(n). Steps: start, define function, initialize list, loop n times, generate random int 1-6, append, end loop, return list, end function. Use Start for program start? Since only function definition, maybe Start then function definition. We'll produce steps.\n\nMake sure each line is separate. Use arrow before each step after Start? Format example shows Start line, then arrow for each step. So we can do:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 roll_dice(n) // 宣告函式以擲骰\n→ Step 2: 初始化 empty_list ← [] // 用於儲存所有擲骰結果\n→ Step 3: for i from 1 to n: // 重複 n 次\n    → Step 4: result ← random.randint(1, 6) // 產生 1-6 的隨機數\n    → Step 5: empty_list.append(result) // 將結果加入列表\n→ Step 6: return empty_list // 回傳所有結果\nEnd // 程式結束\n\nBut must adhere to format: each line must contain arrow before step, and include explanation after // . Use arrow with step numbers.\n\nAlso we need Decision? No decision here.\n\nLet's produce.\n\nWe need \"虛擬碼步驟\" maybe \"Step 1: ...\" So line: \"→ Step 1: 定義函式 roll_dice(n)\" etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 roll_dice(n) // 宣告一個接受整數 n 的函式，用來擲 n 次骰子  \n→ Step 2: 初始化 results ← [] // 建立空列表以儲存每次擲骰的結果  \n→ Step 3: for i from 1 to n: // 迴圈 n 次，執行擲骰動作  \n  → Step 4: result ← random.randint(1, 6) // 產生 1~6 的隨機整數，模擬一次擲骰  \n  → Step 5: results.append(result) // 將擲出的數字加入結果列表  \n→ Step 6: return results // 回傳包含所有擲骰結果的列表  \nEnd // 程式結束執行"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    start = time.time()\n    result = func(*args)\n    end = time.time()\n    return round(end - start, 3), result\n\ndef main():\n    code = sys.stdin.read()\n    # Provide measure_time in local namespace\n    local_ns = {'measure_time': lambda f,*a: round(time.time()-time.time(),3)} # no",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for measuring time of a function using time module. Steps: Start, import time, define function measure_time(func, *args), record start time, call func(*args) capture result, record end time, compute elapsed = end - start, round to 3 decimals, return result and elapsed. End. Each line with arrow. Need to include explanation. Should be sequential. Use Decision? Probably not. Just sequential steps.\n\nLet's produce:\n\nStart // program start\n→ Import time module // bring time functions\n→ Step 1: Define function measure_time(func, *args) // declare function\n→ Step 2: start_time ← time.time() // get start time\n→ Step 3: result ← func(*args) // execute target function\n→ Step 4: end_time ← time.time() // get end time\n→ Step 5: elapsed ← end_time - start_time // calculate duration\n→ Step 6: elapsed ← round(elapsed, 3) // round to 3 decimals\n→ Step 7: return result, elapsed // return value and duration\nEnd // program finish\n\nAdd arrow notation as specified: \"→\" for each step. Use 'Start', 'End'. For function definition maybe use Step? They didn't restrict, but we can use Step. Let's follow. Ensure each line has explanation after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import time module // 匯入 time 模組以使用時間函式  \n→ Step 1: Define function measure_time(func, *args) // 宣告 measure_time 函式，接受目標函式與任意參數  \n→ Step 2: start_time ← time.time() // 取得執行開始的時間戳  \n→ Step 3: result ← func(*args) // 執行目標函式並儲存回傳值  \n→ Step 4: end_time ← time.time() // 取得執行結束的時間戳  \n→ Step 5: elapsed ← end_time - start_time // 計算耗時秒數  \n→ Step 6: elapsed ← round(elapsed, 3) // 將耗時四捨五入至小數點 3 位  \n→ Step 7: return result, elapsed // 回傳函式結果及測得的時間  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"grape\",\"orange\",\"melon\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'grape', 'orange', 'melon'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（若有輸入會被忽略，因為此題不需要任何輸入）\n    sys.stdin.read()\n    \n    # 建立集合並執行指定操作\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')\n    fruits.update(['grape', 'melon'])\n    fruits.remove('banana')\n    fruits.discard('pineapple')\n    \n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines following the specified format. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision if needed, but here no decisions. Just steps. Use arrows: \"→ Step X: ...\". We'll create steps: 1. Start. 2. Initialize fruits. 3. Add orange. 4. Update grape, melon. 5. Remove banana. 6. Discard pineapple. 7. Output fruits. 8. End.\n\nUse arrow before each step: \"→ Step 1: ...\". After Start, no arrow? The example shows \"Start // ...\". We'll use \"Start // 程式開始執行\". Then arrow lines. Finally End.\n\nEnsure no code, just virtual steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits = {'apple', 'banana'} // 建立集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'（不存在則不錯誤）  \n→ Step 6: output fruits // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.76TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.76 TWD'"
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef fetch_rate() -> float | None:\n    \"\"\"\n    取得 USD 對 TWD 的匯率，若失敗回傳 None。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        data = response.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\n\ndef create_gui() -> None:\n    \"\"\"\n    建立 tkinter 視窗，顯示匯率，按下「更新匯率」按鈕時重新取得並顯示最新匯率。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update_rate() -> None:\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    tk.Button(win, text=\"更新匯率\", command=update_rate).pack(pady=5)\n\n    win.mainloop()\n\n\nif __name__ == \"__main__\":\n    \"\"\"\n    主程式區塊：從標準輸入讀取資料，若收到「按下「更新匯率」按鈕」\n    的訊息則取得匯率並輸出；否則啟動 tkinter GUI。\n    \"\"\"\n    # 讀取所有輸入並去除首尾空白\n    input_text = sys.stdin.read().strip()\n\n    if input_text == \"按下「更新匯率」按鈕\":\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        # 如果沒有符合條件的輸入，就啟動 GUI\n        create_gui()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code lines, each line with explanation. Must use virtual code style with arrows etc. For tkinter UI, button triggers fetch from requests, parse JSON, display rate. Use Start, End. Use Decision if needed.\n\nWe should produce lines like:\nStart // 開始\n→ Import requests, tkinter, json // 匯入模組\n→ Create main window // 建立 tkinter 視窗\n→ Add Label to show rate // 設置顯示匯率的標籤\n→ Define function fetch_rate // 定義抓取匯率的函式\n    → Request API URL // 向 API 送請求\n    → If response OK? // 檢查回傳\n        Yes → Parse JSON // 解析\n        → Extract TWD rate // 取出台幣匯率\n        → Update label text // 顯示\n        No → Update label error // 顯示錯誤\n→ Add Button，command=fetch_rate // 按鈕觸發函式\n→ Run mainloop // 執行 GUI\nEnd // 結束\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow symbol for steps. For decisions use Decision: If etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import modules requests, tkinter, json // 匯入所需模組  \n→ Create main window Tk() // 建立 tkinter 視窗  \n→ Set window title '美元兌台幣匯率' // 設定視窗標題  \n→ Create Label rate_label with empty text // 設置顯示匯率的標籤  \n→ Pack rate_label into window // 將標籤加入視窗  \n→ Define function fetch_rate(): // 定義抓取匯率的函式  \n  → Request API URL 'https://api.exchangerate-api.com/v4/latest/USD' // 向 API 送請求  \n  → Decision: 如果 response.status_code == 200? // 檢查回傳是否成功  \n    Yes → Parse response JSON // 解析 JSON  \n     → Extract TWD rate from data['rates']['TWD'] // 取出台幣匯率  \n     → Update rate_label text to f'1 USD = {rate} TWD' // 顯示匯率  \n    No → Update rate_label text to '取得匯率失敗' // 顯示錯誤訊息  \n→ Create Button '更新匯率' with command=fetch_rate // 建立按鈕並綁定函式  \n→ Pack Button into window // 將按鈕加入視窗  \n→ Call fetch_rate() once to initialise // 程式啟動時先抓一次匯率  \n→ Run mainloop() // 啟動 tkinter 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    \"\"\"\n    A set that supports insert, remove, and getRandom in average O(1) time.\n    Uses a list to store values and a dict to map value -> index in the list.\n    \"\"\"\n    def __init__(self):\n        self.val_to_index = {}   # value -> index in values list\n        self.values = []         # list of current values\n\n    def insert(self, val: int) -> bool:\n        \"\"\"Insert val if not present. Return True if inserted, False otherwise.\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"Remove val if present. Return True if removed, False otherwise.\"\"\"\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[idx] = last_val            # Move last element to idx\n        self.val_to_index[last_val] = idx      # Update its index\n        self.values.pop()                      # Remove last element\n        del self.val_to_index[val]             # Remove mapping\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"Return a random element from the set.\"\"\"\n        return random.choice(self.values)\n\n\ndef main():\n    # Read entire input\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # Wrap the two lists in brackets so json.loads can parse them as a list of two lists\n    try:\n        ops, args = json.loads('[' + raw + ']')\n    except json.JSONDecodeError:\n        # Fallback: try splitting manually\n        split_index = raw.find('],')\n        ops_str = raw[:split_index + 1]\n        args_str = raw[split_index + 2:]\n        ops = json.loads(ops_str)\n        args = json.loads(args_str)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            results.append(None)\n        elif op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n        else:\n            # Unknown operation; ignore or raise error\n            pass\n\n    # Convert results to the desired output format: null/true/false for None/booleans\n    def to_str(v):\n        if v is None:\n            return 'null'\n        if v is True:\n            return 'true'\n        if v is False:\n            return 'false'\n        return str(v)\n\n    output = '[' + ', '.join(to_str(v) for v in results) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. No actual code. Each line with \"虛擬碼步驟 // 解釋\". Use arrows. For class implementation. We need to show logic: using hashmap + array list. Steps: Start class, constructor, insert, remove, getRandom. Each step described. Use decisions. Provide per line.\n\nLet's craft:\n\nStart\n→ Step: Initialize empty hash map val_to_index // store value to its index in list\n→ Step: Initialize empty array list elements // store current values\nInsert val:\n→ Decision: 如果 val 不在 map? // check if val present\n    Yes → Step: Append val to elements // add to end\n    Yes → Step: Map val to index len(elements)-1 // record index\n    Yes → Step: Return true // inserted\n    No  → Step: Return false // already present\nRemove val:\n→ Decision: 如果 val 在 map? // check existence\n    Yes → Step: 找到索引 idx = map[val] // index of val\n    Yes → Step: 找到最後一個元素 last = elements[-1] // last element\n    Yes → Step: 替換 elements[idx] = last // move last to idx\n    Yes → Step: 更新 map[last] = idx // update index\n    Yes → Step: 刪除最後一個元素 elements.pop() // remove last\n    Yes → Step: 刪除 map[val] // remove entry\n    Yes → Step: Return true // removed\n    No  → Step: Return false // not present\ngetRandom:\n→ Step: 生成隨機索引 r = randomInt(0, len(elements)-1) // 隨機\n→ Step: Return elements[r] // 返回隨機值\nEnd\n\nWe need to add \"Start\" and \"End\" as per format. Use arrows. Provide each line.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 hash map val_to_index // 用來儲存每個值對應的陣列索引  \n→ Step: 初始化 array list elements // 用來儲存所有目前存在的值  \n\nInsert(val):  \n→ Decision: 如果 val 不在 val_to_index? // 檢查值是否已存在  \n Yes → Step: 將 val 加到 elements 的尾端 // 插入新值  \n Yes → Step: 設定 val_to_index[val] = elements 的最後一個索引 // 紀錄位置  \n Yes → Step: 回傳 true // 成功插入  \n No  → Step: 回傳 false // 已存在，無須插入  \n\nRemove(val):  \n→ Decision: 如果 val 在 val_to_index? // 檢查值是否存在  \n Yes → Step: 取得 idx = val_to_index[val] // 找到要移除的索引  \n Yes → Step: 取得 last = elements[-1] // 取得陣列最後一個值  \n Yes → Step: 把 elements[idx] 改為 last // 用最後一個值覆蓋要移除的位置  \n Yes → Step: 更新 val_to_index[last] = idx // 更新最後一個值的新索引  \n Yes → Step: 刪除 elements[-1] // 刪除陣列最後一個元素  \n Yes → Step: 刪除 val_to_index[val] // 刪除該值的映射  \n Yes → Step: 回傳 true // 成功移除  \n No  → Step: 回傳 false // 值不存在，無法移除  \n\nGetRandom():  \n→ Step: 產生隨機索引 r = RandomInt(0, len(elements)-1) // 隨機選擇一個索引  \n→ Step: 回傳 elements[r] // 返回對應的值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, m_rows, n_cols):\n        self.m = m_rows\n        self.n = n_cols\n        self.total = m_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        # Pick a random remaining index\n        r = random.randint(0, self.total - 1)\n        # Get the actual index that r refers to\n        idx = self.flipped.get(r, r)\n        # Decrease the pool of remaining indices\n        self.total -= 1\n        # Map the used index to the last available one\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # Convert back to 2D coordinates\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.flipped.clear()\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two lists: commands and arguments\n    idx = data.find('],')\n    if idx == -1:\n        # In case there is no comma separator, treat entire input as one list\n        commands = ast.literal_eval(data)\n        args_list = []\n    else:\n        list1_str = data[:idx + 1]\n        list2_str = data[idx + 2:].strip()\n        commands = ast.literal_eval(list1_str)\n        args_list = ast.literal_eval(list2_str)\n\n    outputs = []\n    sol = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            sol = Solution(*args)\n            outputs.append(None)\n        elif cmd == \"flip\":\n            outputs.append(sol.flip())\n        elif cmd == \"reset\":\n            sol.reset()\n            outputs.append(None)\n        else:\n            # Unsupported command; skip or raise error\n            outputs.append(None)\n\n    # Use json.dumps to output with 'null' instead of 'None'\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code with explanations. The algorithm: Use reservoir sampling approach: maintain list of available indices? But we want minimal random calls. Classic solution: Use mapping from flat index to actual coordinate. Use an integer counter 'remaining' = m*n - flips. At flip: pick random integer r in [0, remaining-1], decrement remaining. Map r to actual index: if mapping contains r use mapped value else r. Then set mapping[remaining] = value mapped from r (or r if no mapping). Then return coordinates mapping to 2D. Reset: clear mapping and set remaining=m*n.\n\nWe need to output virtual code lines: Start, then steps: initialize m,n, mapping empty, remaining=m*n. Then flip logic: if remaining==0? etc. Use Decision for remaining==0. Then random call. Then mapping steps. Then decrement. Then compute coordinates. Return. Reset: clear mapping, remaining=m*n.\n\nLet's produce virtual code accordingly. Use lines like:\n\nStart // 程式開始\n→ Step 1: 初始化 m, n, remaining = m*n, mapping = 空映射 // 設定初始值\n→ Decision: remaining == 0? // 檢查是否所有位置已被翻轉\n    Yes → Step 2: 回傳 空 // 代表無可翻轉位置\n    No  → Step 3: r = 隨機整數 [0, remaining-1] // 選取隨機索引\n→ Step 4: idx = mapping.get(r, r) // 取得實際索引\n→ Step 5: mapping[remaining-1] = mapping.get(remaining-1, remaining-1) // 交換\n→ Step 6: mapping[r] = mapping.get(remaining-1, remaining-1) // 更新映射\n→ Step 7: remaining = remaining - 1 // 減少剩餘可選數\n→ Step 8: i = idx / n, j = idx % n // 轉換為 (i,j)\n→ Step 9: 回傳 [i, j] // 回傳翻轉座標\n→ End // flip 完成\n\nReset:\n\nStart // reset 開始\n→ Step 1: mapping = 空映射 // 清空映射\n→ Step 2: remaining = m*n // 重置剩餘計數\n→ End // reset 完成\n\nBut need to include reset method inside class. Probably need separate block.\n\nLet's produce virtual code for whole class:\n\nStart // 程式開始\n→ Step 1: 定義變數 m, n, remaining, mapping // 初始化必要變數\n→ Step 2: 建構子 Solution(m, n)： // 初始化\n    → m = m_input, n = n_input, remaining = m*n, mapping = 空映射 // 設定大小與映射\n→ Step 3: 方法 flip() // 翻轉隨機索引\n    → Decision: remaining == 0?\n        Yes → Step 3.1: 回傳 空 // 無剩餘\n        No  → Step 3.2: r = 隨機整數 [0, remaining-1]\n    → Step 3.3: idx = mapping.get(r, r)\n    → Step 3.4: mapping[remaining-1] = mapping.get(remaining-1, remaining-1)\n    → Step 3.5: mapping[r] = mapping.get(remaining-1, remaining-1)\n    → Step 3.6: remaining -= 1\n    → Step 3.7: i = idx / n, j = idx % n\n    → Step 3.8: 回傳 [i, j]\n→ Step 4: 方法 reset() // 重置\n    → mapping = 空映射\n    → remaining = m*n\n→ End // 程式結束\n\nBut we need line by line with arrow. Use indentation. Use \"Decision:\" lines etc.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 m, n, remaining, mapping // 初始化必要變數  \n→ Step 2: 建構子 Solution(m, n)： // 初始化矩陣大小與映射  \n    → m = m_input, n = n_input, remaining = m*n, mapping = 空映射 // 設定初始計數與空映射  \n→ Step 3: 方法 flip() // 隨機翻轉一個 0 為 1  \n    → Decision: remaining == 0? // 檢查是否已無可翻轉的 0  \n        Yes → Step 3.1: 回傳 空 // 無剩餘位置可翻轉  \n        No  → Step 3.2: r = 隨機整數 [0, remaining-1] // 隨機選取一個可用索引  \n    → Step 3.3: idx = mapping.get(r, r) // 取得實際扁平索引  \n    → Step 3.4: mapping[remaining-1] = mapping.get(remaining-1, remaining-1) // 將最後一個可用索引映射到 r  \n    → Step 3.5: mapping[r] = mapping.get(remaining-1, remaining-1) // 更新 r 的映射值  \n    → Step 3.6: remaining = remaining - 1 // 減少剩餘可用位置計數  \n    → Step 3.7: i = idx / n, j = idx % n // 將扁平索引轉換為 (i, j)  \n    → Step 3.8: 回傳 [i, j] // 回傳翻轉後的位置  \n→ Step 4: 方法 reset() // 重設矩陣為全 0  \n    → mapping = 空映射 // 清空所有映射  \n    → remaining = m*n // 重置剩餘可用位置計數  \nEnd // 程式結束執行"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6281s5ga.py\", line 73, in <module>\n    main()\n  File \"/tmp/tmp6281s5ga.py\", line 60, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmp6281s5ga.py\", line 24, in buildDict\n    pattern = word[:i] + '*' + word[i+1:]\n              ~~~~~~~~~^~~~~\nTypeError: can only concatenate list (not \"str\") to list"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    \"\"\"\n    用模式映射 (pattern map) 來實作 MagicDictionary。\n    將每個單字中每一個位置用 '*' 取代，得到一個模式，\n    這個模式對應到所有在字典中擁有相同模式的單字。\n    搜尋時只要檢查輸入字串在每個位置改成 '*' 後是否在\n    模式映射中，且相應的單字不等於原字串，即可判定可改一字\n    毫符合條件。\n    \"\"\"\n    def __init__(self):\n        # pattern -> set of words that match this pattern\n        self.pattern_map = {}\n\n    def buildDict(self, dictionary):\n        \"\"\"建立字典，填充模式映射。\"\"\"\n        self.pattern_map.clear()\n        for word in dictionary:\n            length = len(word)\n            for i in range(length):\n                pattern = word[:i] + '*' + word[i+1:]\n                self.pattern_map.setdefault(pattern, set()).add(word)\n\n    def search(self, searchWord):\n        \"\"\"判斷是否能改一個字元使之符合字典中的某個單字。\"\"\"\n        length = len(searchWord)\n        for i in range(length):\n            pattern = searchWord[:i] + '*' + searchWord[i+1:]\n            if pattern in self.pattern_map:\n                for candidate in self.pattern_map[pattern]:\n                    if candidate != searchWord:\n                        return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包裝成 JSON 形式，方便解析\n    # 原始格式為兩個列表，中間以逗號分隔\n    # 例如: [\"MagicDictionary\", \"buildDict\", \"search\"], [[], [[\"hello\"]], [\"hell\"]]\n    wrapped = '[' + data + ']'\n    try:\n        ops, args = ast.literal_eval(wrapped)\n    except Exception as e:\n        print(f\"解析輸入失敗: {e}\")\n        return\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif op == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)\n        elif op == \"search\":\n            res = obj.search(arg)\n            results.append(res)\n        else:\n            # 若有其他未知指令，可忽略或處理\n            results.append(None)\n\n    # 使用 json.dumps 以符合 LeetCode 的輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for building a MagicDictionary and searching. Probably using Trie or hash map of patterns. We'll present algorithm. Virtual code lines. Use arrows, Decision. Provide explanation. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 MagicDictionary 類別 // 定義字典物件\n→ Decision: 初始化時有資料結構可存放字元模式? // 檢查是否需要額外結構\n    Yes → Step 2: 建立 hashMap<字串, List<字串>> patternMap // 以字串模式為鍵，值為符合該模式的單詞\n    No  → Step 3: 建立 Trie 樹 // 若不使用模式，可改為前綴樹方式\n→ Step 4: 建構建字典方法 buildDict(dictionary) // 接收單詞陣列\n    → For each word in dictionary\n        → Step 5: 對每個字元位置 i\n            → Step 6: 生成 pattern = word[0..i-1] + '*' + word[i+1..] // 用 '*' 代表可改變位置\n            → Step 7: patternMap[pattern] 加入 word // 把原單詞加入對應模式列表\n→ Step 8: 建構搜尋方法 search(searchWord) // 接收待測字串\n    → Step 9: For each index i in searchWord\n        → Step 10: 生成 pattern = searchWord[0..i-1] + '*' + searchWord[i+1..] // 產生改一字元後的模式\n        → Step 11: Decision: patternMap 內有此 pattern? // 檢查是否存在可匹配模式\n            Yes → Step 12: 取出 patternMap[pattern] 列表\n                → For each candidateWord in 列表\n                    → Step 13: Decision: candidateWord != searchWord? // 確保不是原字串本身\n                        Yes → Step 14: Return true // 找到符合條件的單詞，搜尋成功\n                        No  → Step 15: 繼續下一個 candidateWord\n            No  → Step 16: 繼續下一個 i\n    → Step 17: Return false // 所有位置皆未符合條件\nEnd // 程式執行結束"
    },
    {
      "title": "Bulb Switcher II",
      "source_file": "Leetcode/leetcode672.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, presses = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp11db07ai.py\", line 45, in <module>\n    data = list(map(int, sys.stdin.read().split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwqnijngi.py\", line 45, in <module>\n    data = list(map(int, sys.stdin.read().split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_4e99k4v.py\", line 45, in <module>\n    data = list(map(int, sys.stdin.read().split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        }
      ],
      "generated_code": "import sys\n\ndef count_states(n: int, presses: int) -> int:\n    \"\"\"\n    Count distinct final bulb states after exactly `presses` button presses.\n    \"\"\"\n    # All possible parity combinations of the 4 buttons (0: even, 1: odd)\n    reachable_states = set()\n\n    for parity in range(16):          # 0000 to 1111\n        required = bin(parity).count('1')  # number of buttons that must be pressed an odd number of times\n\n        # Check if this parity pattern can be achieved with exactly `presses` presses\n        if presses < required or (presses - required) % 2 != 0:\n            continue\n\n        # Start with all bulbs on\n        bulbs = [1] * n\n\n        # Button 1: flip all bulbs\n        if parity & 1:\n            bulbs = [1 - b for b in bulbs]\n\n        # Button 2: flip even-labelled bulbs (2,4,6,...)\n        if parity & 2:\n            for i in range(1, n, 2):   # 0‑based index 1 corresponds to bulb 2\n                bulbs[i] = 1 - bulbs[i]\n\n        # Button 3: flip odd-labelled bulbs (1,3,5,...)\n        if parity & 4:\n            for i in range(0, n, 2):   # 0‑based index 0 corresponds to bulb 1\n                bulbs[i] = 1 - bulbs[i]\n\n        # Button 4: flip bulbs with label j = 3k + 1 (1,4,7,10,...)\n        if parity & 8:\n            for i in range(0, n, 3):   # 0‑based index 0 corresponds to bulb 1\n                bulbs[i] = 1 - bulbs[i]\n\n        # Use a tuple as an immutable representation of the bulb configuration\n        reachable_states.add(tuple(bulbs))\n\n    return len(reachable_states)\n\nif __name__ == \"__main__\":\n    data = list(map(int, sys.stdin.read().split()))\n    if len(data) < 2:\n        sys.exit()\n    n, presses = data[0], data[1]\n    result = count_states(n, presses)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: counting distinct final states of bulbs after exactly 'presses' button presses, starting all on, buttons operations as defined. We must output each line of virtual code with explanation comment.\n\nWe need to design algorithm: We have 4 buttons, each is an operation over n bits. Starting all 1. After a sequence of presses, each button can be pressed any number of times. Since pressing same button twice cancels (flipping twice), effectively each button pressed parity times (0 or 1). But due to order independence (operations commute?), flipping is XOR operation; composition is XOR of button masks. So final state depends only on which subset of buttons pressed (mod 2). However we have constraint exactly 'presses' total presses, not just parity. So we need to count number of distinct final states achievable with exactly 'presses' presses. Since each press can be any button, total parity vector of presses must satisfy sum of counts equal presses. Let counts c1..c4. Then parity vector p_i = c_i mod 2. We need to count distinct resulting state vectors among all possible parity combinations achievable with some counts summing to presses. Since pressing more than once same button cancels, but we may still use extra presses to adjust parity? Example: to achieve a particular parity vector, we can allocate some counts such that parity matches and sum equals presses. That requires that presses - sum(p_i) must be even (since we can add pairs of same button). So condition: presses >= sum(p_i) and (presses - sum(p_i)) even. Also presses could be less than sum(p_i) cannot. So for each parity vector of 4 bits, if there exists nonnegative counts meeting conditions, then that parity vector is achievable. Thus number of distinct final states equals number of distinct resulting bulb states from those achievable parity vectors. Since state depends only on parity vector, we just need to count distinct results from parity vectors satisfying above.\n\nWe also need to compute the resulting bulb states for each parity vector. Each button has mask: button1 flips all n bulbs: mask1 = all 1s. button2 flips even: mask2 has 1s at even indices. button3 flips odd: mask3 has 1s at odd indices. button4 flips indices j ≡1 mod3: mask4 positions 1,4,7,...\n\nThus final state = initial all 1 XOR (p1*mask1) XOR (p2*mask2) XOR (p3*mask3) XOR (p4*mask4). Since initial all 1s, XOR with mask1 flips all bits if p1=1. Equivalent to compute state vector bits.\n\nWe need to count unique resulting states. But we don't need to output them; just number. Approach: For each of 16 parity vectors, check if achievable. For each achievable, compute resulting state bitstring maybe as tuple of length n. n can be large? Constraints unspecified. But we can derive unique states count maybe via reasoning rather than enumerating n bits. Since masks are linear combinations over GF(2). Distinct states correspond to distinct resulting mask = p1*mask1 ⊕ p2*mask2 ⊕ p3*mask3 ⊕ p4*mask4. We can think of mapping parity vector to resulting mask. There are at most 16 possible masks. We just need to count how many unique masks are achievable with given presses. So algorithm:\n\n- For each parity vector (0..15):\n   - compute sum of bits s = popcount(parity)\n   - if presses >= s and (presses - s) % 2 == 0:\n        compute resulting mask: XOR of corresponding masks.\n        add to set.\n\nFinally output size of set.\n\nWe must produce virtual code steps with comments. Not actual code. Use Start, Decision, etc. Provide lines for algorithm steps.\n\nLet's produce lines:\n\nStart\n→ Read n, presses\n→ Initialize mask1, mask2, mask3, mask4 (conceptually) // describe how to build masks\n→ Create empty set result_masks\n→ For each parity from 0 to 15:\n    → Extract bits p1,p2,p3,p4\n    → Compute s = popcount(parity)\n    → Decision: if presses >= s and (presses - s) even? // Check feasibility\n        Yes → Compute final_mask = (p1?mask1:0) XOR (p2?mask2:0) XOR (p3?mask3:0) XOR (p4?mask4:0)\n        → Add final_mask to set\n        No → skip\n→ End with output size of set.\n\nBut we might also explain building masks: mask1: all 1s. mask2: 1 at even positions etc. For virtual code we just mention conceptual building.\n\nEdge cases: n large; but we only need representation of mask maybe as pattern. Since we don't output mask, we can treat mask as description: e.g., mask1 = all positions; mask2 = even; etc. When XOR, we can compute a resulting description: combination of conditions. For counting distinct states, we can consider parity of each bulb position determined by formula.\n\nBut for virtual code, just keep concept of mask as set of positions. Use set operations.\n\nSo produce virtual code lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read n, presses // 取得燈號總數及按鍵總次數  \n→ Define mask1 = set of all 1..n // Button1 反轉所有燈  \n→ Define mask2 = set of even indices 2,4,…,n // Button2 反轉偶數號燈  \n→ Define mask3 = set of odd indices 1,3,…,n // Button3 反轉奇數號燈  \n→ Define mask4 = set of indices 1,4,7,10,… (j ≡ 1 (mod 3)) // Button4 反轉 1 mod 3 號燈  \n→ Initialize empty set result_masks // 存放不同的最終燈狀態  \n→ For parity from 0 to 15: // 4 位元代表 4 按鈕的奇偶按壓次數  \n  → Extract bits p1, p2, p3, p4 from parity // p1: Button1 的奇偶性 …  \n  → Compute s = popcount(parity) // 需要至少 s 次按壓才能得到此奇偶組合  \n  → Decision: if presses ≥ s AND (presses – s) is even? // 能否配合額外成對按壓達到總次數  \n   Yes → Compute final_mask = (p1?mask1:∅) XOR (p2?mask2:∅) XOR (p3?mask3:∅) XOR (p4?mask4:∅) // 取得最終燈的開關集合  \n    → Add final_mask to result_masks // 將此獨特狀態記錄下來  \n   No → // 此奇偶組合不可達到，跳過  \n→ End // 完成所有奇偶組合的檢查  \n→ Output size(result_masks) // 回傳可得到的不同燈狀態總數\n\n這段虛擬碼說明了從輸入、定義按鈕影響集合、檢查可行奇偶組合、計算最終狀態、以及最後統計獨特結果的完整流程。"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8x_wal9v.py\", line 41, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8x_wal9v.py\", line 19, in __init__\n    self.lookup[(p, s)] = idx  # keep the latest (largest) index\n    ~~~~~~~~~~~^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        \"\"\"\n        words: List[str] - words in the dictionary\n        Build a lookup table mapping (prefix, suffix) -> highest index.\n        \"\"\"\n        self.lookup = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            # Generate all prefixes (including empty string)\n            prefixes = [word[:i] for i in range(L + 1)]\n            # Generate all suffixes (including empty string)\n            suffixes = [word[j:] for j in range(L + 1)]\n            for p in prefixes:\n                for s in suffixes:\n                    self.lookup[(p, s)] = idx  # keep the latest (largest) index\n\n    def f(self, prefix, suffix):\n        \"\"\"\n        Return the index of the word with the given prefix and suffix.\n        If none, return -1.\n        \"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # The input is expected to be two JSON-like arrays separated by a comma.\n    # Wrap the whole string in parentheses so that ast.literal_eval can parse it as a tuple.\n    try:\n        words, query = ast.literal_eval('(' + data + ')')\n        prefix, suffix = query\n    except Exception as e:\n        # If parsing fails, print -1 and exit\n        print(-1)\n        sys.exit(0)\n    wf = WordFilter(words)\n    result = wf.f(prefix, suffix)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps in Chinese with explanation, line by line. It's a design of WordFilter class with prefix-suffix search. The algorithm: precompute for each word all prefix-suffix combos? Usually solution uses trie with combined key. Virtual code will outline initialization building trie for prefix+suffix mapping to index, f method traversal. Provide explanation. Use Start End etc.\n\nWe produce virtual code lines. Let's produce:\n\nStart\n→ Step 1: Define WordFilter class // 初始化\n→ Step 2: Declare TrieNode root // 主要資料結構\n→ Step 3: For each word in words array with index i // 迭代單詞\n    → Step 4: For each prefix length p from 0 to len(word)\n        → Step 5: For each suffix length s from 0 to len(word)\n            → Step 6: key = prefix + \"#\" + suffix // 分隔符\n            → Step 7: Insert key into trie, set node.weight = i // 儲存最大索引\n→ Step 8: End of constructor // 完成預處理\n\nFor f:\n→ Step 9: f(pref, suff)\n    → Step 10: node = root\n    → Step 11: For each char c in pref\n        → Step 12: if child exists → node = child else return -1\n    → Step 13: For each char c in suff\n        → Step 14: if child exists → node = child else return -1\n    → Step 15: return node.weight // index\n\nBut to follow prefix-suffix combined, better to traverse with combined key. We'll produce a combined string pref + \"#\" + suff and traverse trie.\n\nLet's craft steps.\n\nEnsure we use arrows etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 WordFilter 類別 // 建立主要資料結構\n→ Step 2: 宣告 TrieNode root 作為樹根 // 用於快速搜尋\n→ Step 3: WordFilter(string[] words) // 建構子\n    → Step 4: 對於每個 word 以及其索引 i 在 words 中\n        → Step 5: 生成所有前綴 pre 從空字串到整個 word\n            → Step 6: 生成所有後綴 suf 從空字串到整個 word\n                → Step 7: key ← pre + \"#\" + suf // 使用分隔符避免衝突\n                → Step 8: node ← root\n                → Step 9: 對於 key 中的每個字元 c\n                    → Step 10: 若 node 沒有 child[c] 則建立新節點\n                    → Step 11: node ← node.child[c]\n                → Step 12: node.weight ← i // 儲存此組合對應的最大索引\n→ Step 13: End // 建構子結束，所有前綴-後綴組合已索引化\n→ Step 14: f(string pref, string suff) // 查詢方法\n    → Step 15: key ← pref + \"#\" + suff // 組成搜尋鍵\n    → Step 16: node ← root\n    → Step 17: 對於 key 中的每個字元 c\n        → Step 18: 若 node 沒有 child[c] 則回傳 -1 // 無對應單詞\n        → Step 19: node ← node.child[c]\n    → Step 20: 回傳 node.weight // 最後節點儲存的最大索引，若不存在則為 -1\nEnd // 程式執行結束"
    },
    {
      "title": "Parse Lisp Expression",
      "source_file": "Leetcode/leetcode736.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe8pc8kg4.py\", line 90, in <module>\n    result = solution.evaluate(expr)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe8pc8kg4.py\", line 71, in evaluate\n    value, _ = eval_tokens(tokens, 0, [{}])  # start with global scope\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe8pc8kg4.py\", line 55, in eval_tokens\n    val, idx = eval_tokens(tokens, idx + 1, env_stack)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe8pc8kg4.py\", line 66, in eval_tokens\n    raise ValueError(f\"Undefined variable: {token}\")\nValueError: Undefined variable: mult"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfcqsbump.py\", line 90, in <module>\n    result = solution.evaluate(expr)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfcqsbump.py\", line 71, in evaluate\n    value, _ = eval_tokens(tokens, 0, [{}])  # start with global scope\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfcqsbump.py\", line 55, in eval_tokens\n    val, idx = eval_tokens(tokens, idx + 1, env_stack)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfcqsbump.py\", line 66, in eval_tokens\n    raise ValueError(f\"Undefined variable: {token}\")\nValueError: Undefined variable: add"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"Evaluate a Lisp‑like expression and return its integer value.\"\"\"\n        # Tokenize the input string into a list of tokens.\n        def tokenize(s: str):\n            tokens = []\n            i, n = 0, len(s)\n            while i < n:\n                if s[i] in '()':\n                    tokens.append(s[i])\n                    i += 1\n                elif s[i] == ' ':\n                    i += 1\n                else:\n                    j = i\n                    while j < n and s[j] not in ' ()':\n                        j += 1\n                    tokens.append(s[i:j])\n                    i = j\n            return tokens\n\n        # Recursive evaluation of the token list.\n        def eval_tokens(tokens, idx, env_stack):\n            token = tokens[idx]\n            if token == '(':\n                op = tokens[idx + 1]\n                if op == 'add':\n                    val1, idx = eval_tokens(tokens, idx + 2, env_stack)\n                    val2, idx = eval_tokens(tokens, idx, env_stack)\n                    idx += 1          # skip ')'\n                    return val1 + val2, idx\n                elif op == 'mult':\n                    val1, idx = eval_tokens(tokens, idx + 2, env_stack)\n                    val2, idx = eval_tokens(tokens, idx, env_stack)\n                    idx += 1          # skip ')'\n                    return val1 * val2, idx\n                elif op == 'let':\n                    env_stack.append({})          # new local scope\n                    idx += 2\n                    while True:\n                        if tokens[idx] == ')':   # nothing left\n                            idx += 1\n                            break\n                        # If the next token is ')' then the current token\n                        # is the final expression of the let.\n                        if idx + 1 < len(tokens) and tokens[idx + 1] == ')':\n                            val, idx = eval_tokens(tokens, idx, env_stack)\n                            idx += 1\n                            break\n                        # Otherwise we have a variable assignment.\n                        var = tokens[idx]\n                        val, idx = eval_tokens(tokens, idx + 1, env_stack)\n                        env_stack[-1][var] = val\n                    env_stack.pop()               # exit the let scope\n                    return val, idx\n            else:\n                # Integer literal or variable reference.\n                if token[0].isalpha():\n                    # lookup variable from innermost to outermost scope\n                    for scope in reversed(env_stack):\n                        if token in scope:\n                            return scope[token], idx + 1\n                    raise ValueError(f\"Undefined variable: {token}\")\n                else:\n                    return int(token), idx + 1\n\n        tokens = tokenize(expression)\n        value, _ = eval_tokens(tokens, 0, [{}])  # start with global scope\n        return value\n\nif __name__ == \"__main__\":\n    # Read entire input; it may contain a variable assignment line.\n    data = sys.stdin.read().strip()\n\n    # Extract the expression string inside quotes, if present.\n    match = re.search(r'\\\"(.+?)\\\"', data, re.DOTALL)\n    if match:\n        expr = match.group(1)\n    else:\n        # If no quotes, use the whole line after an '=' if present.\n        if '=' in data:\n            expr = data.split('=', 1)[1].strip()\n        else:\n            expr = data\n\n    solution = Solution()\n    result = solution.evaluate(expr)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudocode) for evaluating Lisp-like expression. Not actual code, but step-by-step with explanations. Each line includes virtual code step + space + // explanation. Use Start, End, Decision, → arrows, Yes→ No→. Provide step-by-step algorithm: parse expression, recursion, handle let, add, mult, integer, variable lookup with scope stack. We must include handling of scope via stack of dictionaries.\n\nWe need to output sequential steps. Since it's a virtual code, we can use generic steps: Start, parse expression, function eval(expr, env). Use recursion. We need to illustrate decisions: if token is '(' then check next token: let/add/mult; else if token is integer; else variable. For let: loop through pairs, update env stack, evaluate inner expr with new env, then restore. Use scope stack.\n\nWe can produce steps with indentation using arrow and decisions. Provide explanatory comments.\n\nLet's produce something like:\n\nStart\n→ Step 1: Initialize global scope stack with empty dictionary // store variable bindings\n→ Step 2: Call Eval on root expression with current scope // evaluate the whole expression\n→ Function Eval(expr, scopeStack) // evaluate an expression given scope stack\n   → Decision: 如果 expr 為 整數字串? // check if token is a number\n       Yes → Return 整數值 // return parsed integer\n       No  → Decision: 如果 expr 為 '('? // expression in parentheses\n           Yes → Parse the inner tokens // split by spaces while respecting nested parentheses\n                → Token 1: op // operator\n                → Decision: op 為 'add'?\n                    Yes → Eval e1 and e2 recursively, sum, return // addition\n                    No  → Decision: op 為 'mult'?\n                         Yes → Eval e1 and e2, product, return // multiplication\n                         No  → Decision: op 為 'let'?\n                              Yes → Handle let\n                                   → Initialize new scope dictionary\n                                   → Push onto scopeStack // new local scope\n                                   → For each pair (var, expr) except last\n                                         → Eval expr with current scopeStack\n                                         → Bind var to value in top scope\n                                   → Eval the final expr with scopeStack // value of let\n                                   → Pop top scopeStack // exit let scope\n                                   → Return value\n                                   No  → Error // should not happen\n                              No  → Error // invalid operator\n           No  → Decision: expr 為 變數?\n                Yes → Lookup value from innermost to outermost scopeStack\n                     → Return found value\n                No  → Error // invalid token\n→ End\n\nNeed to ensure each line has virtual code step and comment. Use arrows and decisions accordingly. Use nested steps with indentation maybe using spaces. Provide each line as separate. Use `→` to show continuation. Use `Decision:` to indicate branching.\n\nLet's write out final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立全域作用域堆疊 `scopeStack`，並放入一個空字典 // 用於儲存變數映射  \n→ Step 2: 呼叫 `Eval(rootExpr, scopeStack)` 以計算整個表達式的值 // 進入遞迴評估  \n→ Function Eval(expr, scopeStack) // 評估單一表達式  \n    → Decision: expr 是否為整數字串? // 檢查是否為直接數字  \n        Yes → Return 整數值 // 解析並返回  \n        No  → Decision: expr 是否以 '(' 開頭? // 判斷是否為括號表達式  \n            Yes → Parse the token sequence inside the parentheses into list `tokens`  \n                → Token 1 = `op` // 第一個 token 是操作符  \n                → Decision: op 為 'add'?  \n                    Yes →  \n                        → Value1 = Eval(tokens[1], scopeStack) // 先評估 e1  \n                        → Value2 = Eval(tokens[2], scopeStack) // 再評估 e2  \n                        → Return Value1 + Value2 // 加總後回傳  \n                    No → Decision: op 為 'mult'?  \n                        Yes →  \n                            → Value1 = Eval(tokens[1], scopeStack)  \n                            → Value2 = Eval(tokens[2], scopeStack)  \n                            → Return Value1 * Value2 // 乘積後回傳  \n                        No → Decision: op 為 'let'?  \n                            Yes →  \n                                → Push a new empty dict `localScope` onto `scopeStack` // 開啟新作用域  \n                                → For each pair (var, expr) in `tokens[1:-1]` with step 2:  \n                                    → BoundValue = Eval(expr, scopeStack) // 先評估表達式  \n                                    → localScope[var] = BoundValue // 把值存入最新作用域  \n                                → Result = Eval(tokens[-1], scopeStack) // 評估 let 最後的表達式  \n                                → Pop `localScope` from `scopeStack` // 結束 let 的作用域  \n                                → Return Result // 回傳 let 的結果  \n                            No → Error // 未識別的操作符，理論上不會發生  \n                    No → Decision: expr 是否為變數名? // 檢查是否為變數引用  \n                        Yes →  \n                            → 從 `scopeStack` 的最頂層向下搜尋，直到找到 `expr` 的值  \n                            → Return 找到的值 // 變數值回傳  \n                        No → Error // 無法辨識的 token，理論上不會發生  \n→ End // 程式執行結束"
    },
    {
      "title": "Min Cost Climbing Stairs",
      "source_file": "Leetcode/leetcode746.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[10,15,20]",
          "expected_output": "15",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '15'\nGot (Norm):      '25'\n--- (Raw) ---\nRaw Expected: '15'\nRaw Got:      '25'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minCostClimbingStairs(self, cost):\n        \"\"\"Return the minimum cost to reach the top of the staircase.\"\"\"\n        n = len(cost)\n        if n == 0:\n            return 0\n\n        # dp[i] 表示到達第 i 階（i 可能是 0 或 n）所需的最小成本\n        dp = [0] * (n + 1)\n        dp[0] = 0          # 站在地面，成本為 0\n        dp[1] = cost[0]    # 只上第一階梯時的最小成本\n\n        # 逐步計算到達每一步的最小成本\n        for i in range(2, n + 1):\n            dp[i] = min(dp[i - 1] + cost[i - 1],  # 從前一步走\n                        dp[i - 2] + cost[i - 2])  # 從前兩步走\n\n        return dp[n]\n\ndef main():\n    # 讀取標準輸入，並轉換成 Python 列表\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        return\n    cost = ast.literal_eval(data)\n\n    sol = Solution()\n    result = sol.minCostClimbingStairs(cost)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: minimum cost to climb stairs, DP. Steps: start, initialize dp array length n+1, dp[0]=0, dp[1]=cost[0], or better start from bottom two steps. Classic solution: compute min cost to reach top (index n). DP recurrence: dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]) for i from 2 to n. Return dp[n]. Provide step-by-step pseudocode with decision arrows? We just need virtual code. Use Start, End. Provide each line. Let's produce lines:\n\nStart // 程式開始執行\n→ Step 1: n ← length(cost) // 取得階梯總數\n→ Step 2: dp[0] ← 0 // 到達基底不需支付\n→ Step 3: dp[1] ← cost[0] // 只上第一階梯的最小成本\n→ Decision: n <= 1? // 如果只有一階梯，直接返回\n    Yes → Step 4: Return dp[n] // 回傳結果\n    No  →\n→ Step 5: For i from 2 to n: // 逐步計算到達每一步的最小成本\n    →   dp[i] ← min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) // 選擇上一或前一階梯的最小成本\n→ Step 6: Return dp[n] // 返回到達頂端的最小成本\nEnd // 程式結束\n\nBut we need to use arrow format for loops? In the example they used \"Step\" lines. For loops can be represented as \"Step X: For i from ...\". Provide explanation. Let's produce.\n\nAlso might need to show Decision block for start from index 0 or 1? In algorithm we consider both. But our DP includes base cases.\n\nLet's output lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(cost) // 取得階梯總數  \n→ Step 2: dp[0] ← 0 // 到達起點不需支付任何費用  \n→ Step 3: dp[1] ← cost[0] // 只上第一階梯的最小成本  \n→ Decision: n <= 1? // 若階梯只有一級，直接回傳結果  \n    Yes → Step 4: Return dp[n] // 結束並回傳最小成本  \n    No  →  \n→ Step 5: For i from 2 to n: // 逐步計算到達每一步的最小成本  \n    →   dp[i] ← min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]) // 選擇上一或前一階梯的最佳路徑  \n→ Step 6: Return dp[n] // 回傳到達頂端的最小成本  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"\n    這個類別的目的是在給定的整數陣列中，隨機挑選出目標值所在的索引。\n    若目標值出現在陣列多次，則每個索引的機率必須相等。\n    \"\"\"\n    def __init__(self, nums):\n        \"\"\"\n        建構子，接收整數陣列並保存在物件中。\n        \"\"\"\n        self.nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        隨機挑選一個 nums[i] == target 的索引 i。\n        透過「儲存樣本」(reservoir sampling) 的技巧，使每個索引出現的機率相等。\n        \"\"\"\n        result = -1        # 初始化結果\n        count = 0          # 目前為止遇到目標值的數量\n\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1                      # 有目標值時計數 +1\n                # 產生 0 ~ count-1 的隨機數，若為 0 則更新結果\n                if random.randint(0, count - 1) == 0:\n                    result = i\n\n        return result\n\n\ndef main():\n    \"\"\"\n    這個 main 區塊負責從 stdin 讀取資料、執行指令並將結果輸出。\n    調用方式符合 LeetCode 的「序列化執行」格式。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把輸入分成兩部分：指令清單和對應的參數\n    # 例： '[\"Solution\", \"pick\", \"pick\"], [[[1, 2, 3]], [3], [1]]'\n    parts = data.split('],', 1)\n    commands_part = parts[0] + ']'            # 補上第一個方括號的結尾\n    args_part = parts[1]                      # 第二部分已經是合法的 JSON 陣列\n\n    commands = json.loads(commands_part)\n    args = json.loads(args_part)\n\n    obj = None\n    outputs = []\n\n    for idx, cmd in enumerate(commands):\n        if cmd == 'Solution':\n            # 建構子只有一個參數，為整數陣列\n            obj = Solution(args[idx][0])\n            outputs.append(None)             # 建構子對應的輸出是 None (null)\n        elif cmd == 'pick':\n            # pick 方法只有一個參數，為目標數值\n            outputs.append(obj.pick(args[idx][0]))\n        else:\n            # 如有其他指令，略過或拋出錯誤\n            raise ValueError(f\"Unknown command: {cmd}\")\n\n    # 使用 json.dumps 讓 None 轉成 null，符合 LeetCode 的輸出格式\n    print(json.dumps(outputs))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, each line with explanation, no actual code. Virtual code includes arrows, Start, End, Decision. Should reflect algorithm: For pick, iterate array and use reservoir sampling. Use variables count, result. For initialization, store array reference. Provide steps accordingly. Ensure to output in Chinese. Let's produce steps.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Store the input array nums in a class field // 在類別中保存傳入的整數陣列\n→ Step 2: Define pick(target) method // 定義 pick 方法以接收目標值\n    → Step 3: Initialize result = -1 // 先設置回傳索引為 -1\n    → Step 4: Initialize count = 0 // 記錄目前遇到目標值的個數\n    → Step 5: For each index i from 0 to nums.length-1 // 遍歷整個陣列\n        → Decision: nums[i] == target? // 判斷當前元素是否為目標值\n            Yes → Step 6: Increment count // 有目標值時 count 加 1\n            Yes → Step 7: Generate a random integer r in [0, count-1] // 隨機產生一個範圍在 0 到 count-1 的數字\n            Yes → Decision: r == 0? // 判斷 r 是否為 0\n                Yes → Step 8: Set result = i // 如果 r 為 0，則把結果更新為當前索引\n                No  → // 不更新，保持之前的結果\n    → Step 9: Return result // 回傳最終選出的索引\nEnd // 程式執行結束"
    },
    {
      "title": "Smallest Good Base",
      "source_file": "Leetcode/leetcode483.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = \"4681\"",
          "expected_output": "\"8\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '4680'\n--- (Raw) ---\nRaw Expected: '\"8\"'\nRaw Got:      '4680'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport re\n\ndef smallest_good_base(n_str: str) -> str:\n    n = int(n_str)\n    # 最大可能的指數 m 取 log2(n)，因為 2^m <= n\n    max_m = n.bit_length()  # 等同於 floor(log2(n)) + 1\n\n    for m in range(max_m, 1, -1):\n        # 基數 k 的上限可用 n 的 m 次根的向下取整\n        # 但為了簡化，直接將上限設為 n-1（最壞情況）\n        left, right = 2, int(n ** (1.0 / m)) + 1\n        while left <= right:\n            k = (left + right) // 2\n            # 計算 1 + k + k^2 + ... + k^(m-1) = (k^m - 1) / (k - 1)\n            # 這裡直接使用整數計算，避免浮點誤差\n            try:\n                s = (pow(k, m) - 1) // (k - 1)\n            except OverflowError:\n                # 如果指數過大，k^m 會溢出，直接調整搜尋區間\n                s = n + 1\n            if s == n:\n                return str(k)\n            elif s < n:\n                left = k + 1\n            else:\n                right = k - 1\n\n    # 若沒有找到，最小的合法基數是 n-1（n = 1 + (n-1)）\n    return str(n - 1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取第一個數字，支持形如 n = \"13\" 的格式\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n_str = nums[0]\n    result = smallest_good_base(n_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode to find smallest good base for a given integer n represented as a string. Good base means representation of n in base k consists only of digits 1. So n = 1 + k + k^2 + ... + k^{m} for some m>=1. So n = (k^{m+1} - 1)/(k-1). For given n string, we need find minimal k>=2 integer.\n\nApproach: Because n may be large up to 10^18? string length. We can iterate possible exponent m from log2(n) downwards? The minimal base tends to be n-1 for m=1 (n=1 + k). For larger m, base smaller. So we can check m from log2(n) down to 2. For each m, solve k from polynomial equation: k^m + k^{m-1} + ... + 1 = n. Use binary search on k in [2, floor(n^(1/m)) +1]. If found, return k. If none found, return n-1.\n\nWe need pseudocode lines. Each line: step with explanation. Use arrow, decision.\n\nLet's produce. Use \"Start\", \"End\". Use Decision nodes. Use loops.\n\nWe should treat n as big integer string: convert to BigInteger or maybe use Python's arbitrary. In pseudocode, we can assume BigInteger operations.\n\nLet's produce.\n\nWe'll produce pseudocode:\n\nStart\n→ Step 1: Convert string n to big integer N // parse input\n→ Step 2: Compute max_m = floor(log2(N)) // maximum possible exponent\n→ For m from max_m down to 2:\n    → Step: Compute high = floor(N ** (1/m)) // upper bound of base\n    → Step: Binary search k in [2, high]\n        → Decision: if power_sum(k,m) == N → return k\n        → else adjust low/high\n→ End: return N-1 // fallback\n\nWe need to include power_sum function: sum_{i=0}^m k^i. For large numbers, we can compute iteratively with overflow checks.\n\nLet's produce detailed lines.\n\nWe must use \"Decision:\" etc.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 n，並轉為大整數 N // 取得數值  \n→ Step 2: 計算最大可能指數 max_m = ⌊log₂(N)⌋ // 最高位數  \n→ Decision: 若 max_m < 2?  \n  Yes → Step 3: 回傳 N - 1 // 只剩兩個數位的情況  \n  No  → Continue // 進一步搜尋  \n→ For m 從 max_m 降到 2： // 依指數從大到小嘗試  \n  → Step 4: 計算 upper = ⌊N^{1/m}⌋ // 基數上限  \n  → Decision: 若 upper < 2?  \n    Yes → Next m // 無合法基數，跳至下一個 m  \n    No  →  \n     → Step 5: 設 low = 2, high = upper // Binary search 範圍  \n     → While low ≤ high：  \n       → Decision: mid = (low + high) // 2 // 取中間值  \n        → Step 6: 計算 sum = 1  \n        → Step 7: 用迴圈 i 1 到 m：  \n           sum = sum * mid + 1 // 逐次累加 k^i + … + 1  \n           若 sum > N → 跳出迴圈  \n        → Decision: sum == N?  \n           Yes → Step 8: 回傳 mid // 找到最小基數  \n           No → Decision: sum < N?  \n             Yes → low = mid + 1 // 搜尋較大基數  \n             No  → high = mid - 1 // 搜尋較小基數  \n→ Step 9: 若迴圈結束仍未找到 → 回傳 N - 1 // 無法分解成全 1，使用最小合法基數  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,1,false]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, 1, false]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\nif __name__ == \"__main__\":\n    # 讀取所有非空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not lines:\n        sys.exit(0)\n\n    # 第一行為操作序列，第二行為參數序列\n    ops_line = lines[0]\n    args_line = lines[1] if len(lines) > 1 else \"[]\"\n\n    try:\n        ops = json.loads(ops_line)\n        args = json.loads(args_line)\n    except json.JSONDecodeError:\n        print(\"[]\")\n        sys.exit(0)\n\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyQueue\":\n            obj = MyQueue()\n            res.append(None)\n        elif op == \"push\":\n            obj.push(arg[0])\n            res.append(None)\n        elif op == \"pop\":\n            res.append(obj.pop())\n        elif op == \"peek\":\n            res.append(obj.peek())\n        elif op == \"empty\":\n            res.append(obj.empty())\n        else:\n            res.append(None)\n\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing a FIFO queue using two stacks, with push, pop, peek, empty. We should produce line by line virtual code with explanation. Use Start, End, Decision, arrow. We need to include steps to define class, constructor, two stacks, push operation, pop operation, peek, empty.\n\nWe'll need to show logic: for push, push onto stack1. For pop/peek, if stack2 empty, transfer all from stack1 to stack2. Then pop/peek from stack2.\n\nAlso include decisions.\n\nWe'll produce a structured flow. Use steps. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision.\n\nProbably we start with Start, then define class, initialize stacks. Then show methods.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyQueue 類別 // 建立 queue 類\n→ Step 2: 宣告 stack1, stack2 為空堆疊 // 兩個堆疊作為儲存結構\n→ Step 3: 建構子: 初始化 stack1, stack2 // 構造時建立堆疊\n→ Decision: 方法 push? // 進入 push 函式\n    Yes → Step 4: push(x) // 進入 push 直譯\n        → Step 5: stack1.push(x) // 把元素壓入 stack1，維持 FIFO 逆序\n→ Decision: 方法 pop? // 進入 pop 函式\n    Yes → Step 6: pop() // 進入 pop 直譯\n        → Decision: stack2.isEmpty()? // 檢查 stack2 是否為空\n            Yes → Step 7: 將 stack1 的所有元素轉移到 stack2\n                → Step 8: while !stack1.isEmpty() do\n                    → Step 9: temp = stack1.pop()\n                    → Step 10: stack2.push(temp)\n            No → // stack2 非空，直接跳過\n        → Step 11: return stack2.pop() // 從 stack2 弹出前端元素\n→ Decision: 方法 peek? // 進入 peek 函式\n    Yes → Step 12: peek() // 進入 peek 直譯\n        → Decision: stack2.isEmpty()? // 檢查 stack2 是否為空\n            Yes → Step 13: 將 stack1 的所有元素轉移到 stack2\n                → Step 14: while !stack1.isEmpty() do\n                    → Step 15: temp = stack1.pop()\n                    → Step 16: stack2.push(temp)\n            No → // stack2 非空\n        → Step 17: return stack2.peek() // 取得前端元素\n→ Decision: 方法 empty? // 進入 empty 函式\n    Yes → Step 18: empty() // 進入 empty 直譯\n        → Decision: stack1.isEmpty() AND stack2.isEmpty()? // 若兩堆疊皆空\n            Yes → Step 19: return true // queue 為空\n            No  → Step 20: return false // queue 非空\nEnd // 程式執行結束\n\nBut we need to maintain the format: \"虛擬碼步驟 [space] // 解釋\". For Decision lines, we might write \"Decision: if stack2.isEmpty()?\".\n\nMake sure each line ends with \"// 解釋\". Provide arrow lines with \"→\". The example uses indentation to show hierarchy. Let's replicate.\n\nAlso each step maybe numbered for clarity but not necessary. Use steps.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyQueue 類別 // 建立 queue 類  \n→ Step 2: 宣告 stack1, stack2 為空堆疊 // 用兩個堆疊作為儲存結構  \n→ Step 3: 建構子: 初始化 stack1, stack2 // 構造時建立堆疊  \n→ Decision: 執行 push? // 進入 push 函式  \n  Yes → Step 4: push(x) // 進入 push 直譯  \n   → Step 5: stack1.push(x) // 把元素壓入 stack1，維持 FIFO 逆序  \n→ Decision: 執行 pop? // 進入 pop 函式  \n  Yes → Step 6: pop() // 進入 pop 直譯  \n   → Decision: stack2.isEmpty()? // 檢查 stack2 是否為空  \n    Yes → Step 7: 將 stack1 的所有元素轉移到 stack2  \n     → Step 8: while !stack1.isEmpty() do  \n      → Step 9: temp = stack1.pop()  \n      → Step 10: stack2.push(temp)  \n    No → // stack2 非空，直接跳過  \n    → Step 11: return stack2.pop() // 從 stack2 弹出前端元素  \n→ Decision: 執行 peek? // 進入 peek 函式  \n  Yes → Step 12: peek() // 進入 peek 直譯  \n   → Decision: stack2.isEmpty()? // 檢查 stack2 是否為空  \n    Yes → Step 13: 將 stack1 的所有元素轉移到 stack2  \n     → Step 14: while !stack1.isEmpty() do  \n      → Step 15: temp = stack1.pop()  \n      → Step 16: stack2.push(temp)  \n    No → // stack2 非空  \n    → Step 17: return stack2.peek() // 取得前端元素  \n→ Decision: 執行 empty? // 進入 empty 函式  \n  Yes → Step 18: empty() // 進入 empty 直譯  \n   → Decision: stack1.isEmpty() AND stack2.isEmpty()? // 若兩堆疊皆空  \n    Yes → Step 19: return true // queue 為空  \n    No  → Step 20: return false // queue 非空  \nEnd // 程式執行結束"
    },
    {
      "title": "Maximum Length of Repeated Subarray",
      "source_file": "Leetcode/leetcode718.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findLength(self, nums1, nums2):\n        \"\"\"\n        計算兩個整數陣列的最長公共子陣列長度。\n        使用 2 行 DP 只佔 O(min(n, m)) 的額外記憶體。\n        \"\"\"\n        m, n = len(nums1), len(nums2)\n        # 先確保 n 是較短的長度，這樣 prevRow 的長度更小\n        if n > m:\n            nums1, nums2 = nums2, nums1\n            m, n = n, m\n        prev_row = [0] * (n + 1)\n        max_len = 0\n        for i in range(1, m + 1):\n            current = 0\n            # 這裡用 current 代替 dp[i][j]，不必建立完整的 2D 陣列\n            for j in range(1, n + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    current = prev_row[j - 1] + 1\n                    if current > max_len:\n                        max_len = current\n                else:\n                    current = 0\n                prev_row[j] = current\n        return max_len\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串轉換成字典 {'nums1': [...], 'nums2': [...]}。\n    假設輸入格式為: nums1 = [...], nums2 = [...]\n    \"\"\"\n    # 清除多餘空白並去除換行\n    data = data.strip()\n    # 把 '=' 改成 ':' 方便 dict 解析\n    data = data.replace('=', ':')\n    # 將整段文字放入 dict(...)\n    try:\n        parsed = eval(f\"dict({data})\")\n        return parsed.get('nums1', []), parsed.get('nums2', [])\n    except Exception:\n        # 若解析失敗，回傳空列表\n        return [], []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums1, nums2 = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findLength(nums1, nums2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm to find longest common subarray between two arrays of integers. This is classic Longest Common Subarray (Longest Common Substring) problem. Approach: DP with 2D table; time O(n*m). Or use binary search with hashing; but simpler: DP.\n\nGiven two arrays nums1 length n, nums2 length m. DP[i][j] = length of longest common suffix ending at i-1, j-1. So iterate i from 1..n, j from 1..m, if nums1[i-1]==nums2[j-1] then DP[i][j] = DP[i-1][j-1] + 1, update maxLen. else DP[i][j] = 0. Use 2 rows to save memory.\n\nWe need virtual code with lines like:\n\nStart\n→ Input arrays\n→ Initialize variables\n→ For i loop\n→ For j loop\n→ Decision equality\n→ Update dp, max\n→ End loops\n→ Output max\n\nAlso explanation lines.\n\nWe need to use arrow style: Start, End, Decision. Each line with virtual code step and comment.\n\nLet's produce. Use \"→\" arrow to indicate next step.\n\nLet's structure:\n\nStart\n→ Input: nums1, nums2 // 接收兩個整數陣列\n→ Declare: n = length(nums1), m = length(nums2) // 取得陣列長度\n→ Initialize: prevRow = array of zeros length m+1 // 前一列 DP\n→ Initialize: maxLen = 0 // 最大長度\n→ For i from 1 to n:\n    → For j from 1 to m:\n        → Decision: if nums1[i-1] == nums2[j-1] ?\n            Yes → current = prevRow[j-1] + 1 // 更新長度\n            No → current = 0 // 無相同結尾\n        → Update prevRow[j] = current // 取代上一列\n        → Decision: if current > maxLen ?\n            Yes → maxLen = current // 更新最大長\n        → End of inner\n    → End of outer\n→ Output: maxLen // 回傳結果\nEnd\n\nBut need to use \"Decision:\" lines with arrow Yes→, No→. Also we may use \"Step:\" lines.\n\nWe need to use arrow before each step, e.g. \"→ Step: ...\" or \"→ Decision:\".\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Input: nums1, nums2 // 接收兩個整數陣列\n→ Declare: n = length(nums1), m = length(nums2) // 取得陣列長度\n→ Initialize: prevRow = array of zeros length m+1 // 用來儲存前一列 DP 值\n→ Initialize: maxLen = 0 // 目前已發現的最大子陣列長度\n→ For i from 1 to n: // 逐行遍歷第一個陣列\n    → For j from 1 to m: // 逐列遍歷第二個陣列\n        → Decision: if nums1[i-1] == nums2[j-1]? // 判斷兩個元素是否相同\n            Yes → current = prevRow[j-1] + 1 // 有相同，延長子陣列長度\n            No  → current = 0 // 不相同，子陣列長度歸零\n        → Update: prevRow[j] = current // 更新 DP 表中的值\n        → Decision: if current > maxLen? // 檢查是否得到更長的子陣列\n            Yes → maxLen = current // 更新最大長度\n        → End // 內層迴圈結束\n    → End // 外層迴圈結束\n→ Output: maxLen // 回傳找到的最大長度\nEnd // 程式執行結束"
    },
    {
      "title": "Subarray Product Less Than K",
      "source_file": "Leetcode/leetcode713.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [10,5,2,6], k = 100",
          "expected_output": "8",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjo9i7rl0.py\", line 41, in <module>\n    nums, k = parse_input(raw)\n              ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjo9i7rl0.py\", line 29, in parse_input\n    nums = ast.literal_eval(expr.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [10\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3], k = 0",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo5ablcu8.py\", line 41, in <module>\n    nums, k = parse_input(raw)\n              ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpo5ablcu8.py\", line 29, in parse_input\n    nums = ast.literal_eval(expr.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums, k):\n        \"\"\"Return the count of contiguous subarrays with product < k.\"\"\"\n        if k <= 1:\n            return 0\n        prod = 1\n        left = 0\n        count = 0\n        for right, val in enumerate(nums):\n            prod *= val\n            while prod >= k and left <= right:\n                prod //= nums[left]\n                left += 1\n            count += right - left + 1\n        return count\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form 'nums = [...], k = ...'.\"\"\"\n    nums = []\n    k = 0\n    parts = data.split(',')\n    for part in parts:\n        part = part.strip()\n        if part.startswith('nums'):\n            _, expr = part.split('=', 1)\n            nums = ast.literal_eval(expr.strip())\n        elif part.startswith('k'):\n            _, expr = part.split('=', 1)\n            k = int(expr.strip())\n    return nums, k\n\nif __name__ == \"__main__\":\n    # Read all input\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    nums, k = parse_input(raw)\n    sol = Solution()\n    result = sol.numSubarrayProductLessThanK(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with step by step, using Start, End, Decision. The requirement: \"Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.\" So we need sliding window approach.\n\nWe output lines like:\n\nStart\n→ Step 1: Initialize left = 0, product = 1, count = 0\n→ Step 2: Iterate right from 0 to len(nums)-1\n→ Decision: If product * nums[right] < k?\n  Yes → Step 3: product *= nums[right]; count += right - left + 1\n  No  → Step 4: While product * nums[right] >= k and left <= right\n        → Step 5: product /= nums[left]; left += 1\n        → Decision: After loop, if product * nums[right] < k\n            Yes → Step 6: product *= nums[right]; count += right - left + 1\n            No  → Step 7: (shouldn't happen if k>1)\nEnd\n\nBut we must ensure that we correctly handle product updates.\n\nWe need to output each step with arrow, e.g., \"→ Step X: ...\".\n\nAlso use Decision arrows: \"Decision: ...?\" with Yes/No.\n\nWe need to ensure we don't produce actual code. So no actual code. Just pseudo steps.\n\nWe need to produce lines with explanation comments.\n\nLet's produce.\n\nWe need to be careful: In sliding window, we maintain product of window [left, right]. For each right, we multiply product by nums[right]. While product >= k and left <= right, we divide product by nums[left] and increment left. After adjusting, number of subarrays ending at right with product < k is right - left + 1. So we add that to count.\n\nEdge case: k <= 1: answer 0.\n\nLet's produce the virtual code accordingly.\n\nUse \"Start // 程式開始執行\" etc.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, product = 1, count = 0 // 初始化滑動視窗指標與統計變數\n→ Step 2: 如果 k <= 1? // 特殊情況，任何子陣列產品都不會 < k\n    Yes → Step 3: return 0 // 直接返回結果\n    No  → Step 4: 進入主迴圈\n→ Step 5: For right from 0 to len(nums)-1 // 逐一擴大右端\n→ Step 6: product *= nums[right] // 把新元素加入窗口\n→ Decision: product < k? // 判斷當前窗口是否已符合條件\n    Yes → Step 7: count += right - left + 1 // 所有以 right 為結尾、符合條件的子陣列數\n    No  → Step 8: While product >= k and left <= right // 需要收縮左端直到條件滿足\n        → Step 9: product /= nums[left] // 去除最左側元素\n        → Step 10: left += 1 // 左端指標右移\n        → Decision: product < k? // 收縮後再次檢查\n            Yes → Step 11: count += right - left + 1 // 更新計數\n            No  → Step 12: 重新進入 While 迴圈\n    // 迴圈結束後，已經處理完當前 right\nEnd // 程式執行結束\n\nWe might need to close braces, but just pseudo.\n\nMake sure each line has arrow or Start/End etc. Also use \"Yes →\" and \"No →\" accordingly.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 left = 0, product = 1, count = 0 // 設定滑動窗口起始點與統計變數  \n→ Step 2: 如果 k <= 1? // 特殊情況，任何子陣列的乘積都不可能小於 k  \n    Yes → Step 3: return 0 // 直接回傳結果，結束程式  \n    No  → Step 4: 進入主迴圈 // k 大於 1，才能進行窗口滑動  \n→ Step 5: For right from 0 to len(nums)-1 // 逐個擴大右端指標  \n→ Step 6: product *= nums[right] // 把新元素納入窗口乘積  \n→ Decision: product < k? // 判斷現在窗口乘積是否已滿足條件  \n    Yes → Step 7: count += right - left + 1 // 所有以 right 為結尾且滿足條件的子陣列數量  \n    No  → Step 8: While product >= k and left <= right // 必須收縮左端直到乘積小於 k  \n        → Step 9: product /= nums[left] // 先移除最左側元素的影響  \n        → Step 10: left += 1 // 左端指標右移  \n        → Decision: product < k? // 收縮後再次檢查  \n            Yes → Step 11: count += right - left + 1 // 更新計數，結束本次 right 的處理  \n            No  → Step 12: 重新進入 While 迴圈 // 繼續收縮直至滿足條件  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> list[str]:\n        \"\"\"\n        找出 DNA 字串中所有重複出現的 10 字長子字串。\n        \"\"\"\n        seen = set()\n        repeated = set()\n        n = len(s)\n        if n < 10:\n            return []\n        for i in range(n - 9):\n            seq = s[i:i + 10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取字串，處理後將結果輸出到標準輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    # 從輸入中擷取第一個單引號或雙引號之間的內容\n    match = re.search(r\"['\\\"](.*?)['\\\"]\", data)\n    if not match:\n        # 若無符合格式，直接使用整個輸入\n        s = data.strip()\n    else:\n        s = match.group(1)\n    sol = Solution()\n    result = sol.findRepeatedDnaSequences(s)\n    # 使用 json.dumps 以符合範例格式輸出\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step that solves the problem: find all 10-letter-long substrings that appear more than once in a string s. Use typical algorithm: sliding window, hash set. Steps: Start, input s, length n, if n<10 return empty list. Use seen set for substrings seen once, duplicates set for results. Iterate i 0..n-10 inclusive, substring s[i:i+10], if in seen: add to duplicates, else add to seen. After loop, output duplicates list. End.\n\nWe need each line as \"虛擬碼步驟 // 解釋\". Use arrows and Decision blocks.\n\nLet's produce:\n\nStart\n→ Step 1: 定義變數 n = length of s // 取得字串長度\n→ Decision: 如果 n < 10? // 判斷字串是否足夠長\n    Yes → Step 2: 回傳空列表 // 字串短於 10 無法產生 10 字長子字串\n    No  → Step 3: 建立空集合 seen, duplicates // 兩個集合用於儲存已見子字串與重複結果\n→ Step 4: 從 i = 0 到 i <= n-10 進行迴圈 // 遍歷所有可能的 10 字長子字串\n    → Step 5: substring = s[i:i+10] // 取得目前的 10 字長子字串\n    → Decision: 如果 substring 在 seen? // 檢查是否已出現\n        Yes → Step 6: 將 substring 加入 duplicates // 已見則加入重複集合\n        No  → Step 7: 將 substring 加入 seen // 未見則加入 seen 集合\n→ Step 8: 將 duplicates 轉為列表並回傳 // 回傳所有重複的 10 字長子字串\nEnd\n\nMake sure each line with arrow. Let's output each line accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 n = s.length // 取得 DNA 字串長度\n→ Decision: 如果 n < 10? // 判斷字串是否足夠長以產生 10 字長子字串\n    Yes → Step 2: 回傳空列表 // DNA 字串太短，無重複 10 字長子字串\n    No  → Step 3: 建立空集合 seen, duplicates // 用於儲存已見子字串與重複結果\n→ Step 4: 從 i = 0 到 i <= n-10 進行迴圈 // 逐一檢查所有可能的 10 字長子字串\n    → Step 5: substring = s.substring(i, i+10) // 取得當前 10 字長子字串\n    → Decision: 如果 substring 在 seen? // 檢查此子字串是否已出現\n        Yes → Step 6: 將 substring 加入 duplicates // 若已見，加入重複集合\n        No  → Step 7: 將 substring 加入 seen // 若未見，加入 seen 集合\n→ Step 8: 回傳 duplicates 轉為列表 // 輸出所有重複的 10 字長子字串\nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"返回 nums 的所有排列\"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])  # 取得目前排列的複製\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 反覆交換回原位置\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 解析輸入，預期格式為 \"nums = [1,2,3]\" 或僅 \"[1,2,3]\"\n    if \"=\" in raw:\n        _, nums_str = raw.split(\"=\", 1)\n    else:\n        nums_str = raw\n\n    nums_str = nums_str.strip()\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all permutations of a distinct integers array. We need to write line by line, each line with \"虛擬碼步驟\" then space then comment. Use arrows and Decision. So we must design algorithm: backtracking. Steps: Start, Step: initialize result list, Step: define backtrack(current perm, used boolean array). Or we can use recursion. Represent steps: call backtrack with empty list, mark used, iterate through nums, if not used, add to perm, mark used, recurse, then unmark and pop. When perm size equals nums length, add copy to result. Then return result. Provide virtual code.\n\nWe must keep each line distinct. For decision: if current perm length == nums length, then add to result. Also decision for if element used? etc.\n\nWe need to output in Traditional Chinese comments.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入 nums 和空結果列表 result // 設定輸入與結果容器\n→ Step 2: 定義布林陣列 used，長度為 nums 之長度，全部 false // 追蹤哪些元素已被使用\n→ Step 3: 呼叫 Backtrack(空列表 current) // 開始遞迴\n→ Backtrack(current) // 遞迴函式開始\n    → Decision: 如果 current 長度 == nums 長度? // 判斷是否已形成完整排列\n        Yes → Step 4: 把 current 的副本加入 result // 完整排列加入結果\n        No  → Step 5: 為每個 index i 從 0 到 nums 長度-1 做\n            → Decision: 如果 used[i] 為 false? // 檢查元素是否已使用\n                Yes → Step 6: 將 nums[i] 加到 current // 添加元素到當前排列\n                → Step 7: 設置 used[i] = true // 標記元素已使用\n                → Step 8: 呼叫 Backtrack(current) // 繼續遞迴\n                → Step 9: 設置 used[i] = false // 取消標記，回溯\n                → Step 10: 從 current 移除最後一個元素 // 回到上一層\n                No  → Step 11: 繼續迴圈 // 跳過已使用元素\n    // 遞迴結束\n→ End // 程式執行結束\n\nWe need each line as separate line, with arrow or decision. Also use arrow for substeps inside decision? Use indentation.\n\nBetter to produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空列表 // 用來儲存所有排列\n→ Step 2: 初始化 used 為布林陣列，長度為 nums 長度，初始值 false // 標記元素是否已使用\n→ Step 3: 呼叫 Backtrack(空列表 current) // 開始遞迴\n→ Backtrack(current) // 定義遞迴函式\n    → Decision: 如果 current 長度 == nums 長度? // 檢查是否已得到完整排列\n        Yes → Step 4: 把 current 的拷貝加入 result // 完整排列加入結果\n        No  → Step 5: 循環 i 從 0 到 nums 長度-1\n            → Decision: if used[i] 為 false? // 檢查該元素是否未使用\n                Yes → Step 6: current.append(nums[i]) // 加入元素\n                → Step 7: used[i] = true // 標記已使用\n                → Step 8: 呼叫 Backtrack(current) // 進行下一層遞迴\n                → Step 9: used[i] = false // 回溯，取消標記\n                → Step 10: current.pop() // 移除最後一個元素\n                No  → Step 11: 繼續迴圈 // 跳過已使用元素\n    // Backtrack 完成\n→ End // 程式執行結束\n\nWe need to ensure each line includes \"虛擬碼步驟\" with arrow.\n\nWe should produce each line like:\n\nStart // 程式開始執行\n→ Step 1: ...\n\nThe \"Decision:\" line is separate. Indentation: For nested steps we might need indent arrows? According to example, indentation is shown with tab? The example uses spaces before the arrow. We'll use indentation with spaces.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用來儲存所有排列  \n→ Step 2: 初始化 used 為布林陣列，長度為 nums 長度，初始值 false // 標記元素是否已使用  \n→ Step 3: 呼叫 Backtrack(空列表 current) // 開始遞迴  \n→ Backtrack(current) // 定義遞迴函式  \n&nbsp;&nbsp;→ Decision: 如果 current 長度 == nums 長度? // 檢查是否已得到完整排列  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: 把 current 的拷貝加入 result // 完整排列加入結果  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5: 循環 i 從 0 到 nums 長度-1 // 對每個元素嘗試  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 如果 used[i] 為 false? // 檢查該元素是否未使用  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: current.append(nums[i]) // 加入元素到當前排列  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: used[i] = true // 標記已使用  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: 呼叫 Backtrack(current) // 進行下一層遞迴  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 9: used[i] = false // 回溯，取消標記  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: current.pop() // 移除最後一個元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 11: 繼續迴圈 // 跳過已使用元素  \n&nbsp;&nbsp; // Backtrack 完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5ct0lqqa.py\", line 86, in <module>\n    main()\n  File \"/tmp/tmp5ct0lqqa.py\", line 65, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [1], [1], [2], [], [1], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的列表\n        self.data = []\n        # 每個值對應的索引集合\n        self.idx_map = {}\n\n    def insert(self, val):\n        # 判斷是否為新元素\n        is_new = val not in self.idx_map\n        # 若為新元素，初始化集合\n        if is_new:\n            self.idx_map[val] = set()\n        # 新元素的索引\n        idx = len(self.data)\n        self.data.append(val)\n        self.idx_map[val].add(idx)\n        return is_new\n\n    def remove(self, val):\n        # 若值不存在，直接返回 False\n        if val not in self.idx_map or not self.idx_map[val]:\n            return False\n        # 取出要移除的索引\n        remove_idx = self.idx_map[val].pop()\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n        # 如果不是最後一個，交換\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].remove(last_idx)\n            self.idx_map[last_val].add(remove_idx)\n        # 移除最後一個元素\n        self.data.pop()\n        # 若集合變空，刪除鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.data)\n\ndef main():\n    # 讀取所有輸入\n    raw = sys.stdin.read()\n    raw = raw.strip()\n    if not raw:\n        return\n    # 盡量將輸入拆成兩個列表\n    if ',' in raw:\n        # 分割第一個列表與第二個列表\n        parts = raw.split('],', 1)\n        ops_str = parts[0] + ']'\n        args_str = '[' + parts[1].lstrip()\n    else:\n        # 兩行輸入\n        lines = [line.strip() for line in raw.splitlines() if line.strip()]\n        ops_str, args_str = lines[0], lines[1]\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)\n        elif op == \"insert\":\n            res = obj.insert(arg[0])\n            result.append(res)\n        elif op == \"remove\":\n            res = obj.remove(arg[0])\n            result.append(res)\n        elif op == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n    # 輸出符合 JSON 格式的結果\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a pseudocode step-by-step for the RandomizedCollection class implementation. Each line: \"虛擬碼步驟 // 解釋\". Use arrow, Decision, etc. Must not output actual code. So we need to describe algorithm: use vector/list for values, map from value to set of indices. For insert: add to vector, add index to set, return true if new. For remove: if not present return false; get an index from set, swap with last element in vector, update mapping for moved element, pop back, remove index from set of removed value; if set empty delete key. getRandom: pick random index in vector and return value.\n\nWe need to output steps for class initialization and each function. Provide decision points. Let's produce lines.\n\nStructure: Start -> Step 1: Initialize data structures. Then function definitions each as substeps? Might use nested.\n\nWe should produce pseudocode flow for each method. The output is a single list of steps. It's okay to use indentation? They didn't specify but we can use indentation via spaces. Use arrows for each step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 dataList ← 空列表 // 存放所有元素\n→ Step 2: 定義 idxMap ← 空映射(value → 設集合) // 儲存每個值的索引集合\n→ Step 3: 定義 RandomizedCollection() // 建構子\n    → Decision: 先前資料已初始化? // 確保初始化一次\n        Yes → End // 已初始化，直接返回\n        No  → Step 4: dataList ← [] // 重新初始化列表\n            Step 5: idxMap ← {} // 重新初始化映射\n→ Function insert(val)\n    → Decision: val 是否在 idxMap? // 判斷是否為新元素\n        Yes → Step 6: isNew ← False\n        No  → Step 7: isNew ← True; idxMap[val] ← 空集合\n    → Step 8: index ← dataList.size() // 新元素的索引\n    → Step 9: dataList.append(val) // 加入列表\n    → Step 10: idxMap[val].add(index) // 記錄索引\n    → Step 11: return isNew // 回傳是否為新元素\n→ Function remove(val)\n    → Decision: val 是否在 idxMap? // 檢查元素是否存在\n        Yes → \n            → Decision: idxMap[val] 是否為空? // 處理不存在的情況\n                Yes → Step 12: return False\n                No  →\n                    → Step 13: idxToRemove ← 任意取 idxMap[val] 中的索引\n                    → Step 14: lastIndex ← dataList.size() - 1\n                    → Step 15: lastVal ← dataList[lastIndex]\n                    → Decision: idxToRemove ≠ lastIndex? // 是否需要交換\n                        Yes → \n                            → Step 16: dataList[idxToRemove] ← lastVal // 覆蓋\n                            → Step 17: idxMap[lastVal].remove(lastIndex) // 更新被移動元素的索引\n                            → Step 18: idxMap[lastVal].add(idxToRemove) // 新索引加入\n                        No → // 直接移除，不需交換\n                            // 無需更新\n                    → Step 19: dataList.pop_back() // 刪除最後元素\n                    → Step 20: idxMap[val].remove(idxToRemove) // 刪除被移除元素的索引\n                    → Decision: idxMap[val] 是否為空? // 是否需要刪除鍵\n                        Yes → Step 21: delete idxMap[val]\n                    → Step 22: return True\n        No  → Step 23: return False\n→ Function getRandom()\n    → Step 24: randomIndex ← random 0 ~ dataList.size()-1\n    → Step 25: return dataList[randomIndex] // 隨機取值\nEnd // 程式執行結束\n\nNeed to ensure we use correct syntax \"→ Decision:\" etc. The indentation may be represented with tabs or spaces; but not mandatory.\n\nLet's format as per example. Use \"Start\" line etc. Use \"→ Step X:\" lines. For decisions use \"Decision:\". Ensure we include arrow and then each decision block.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: dataList ← 空列表 // 用來儲存所有元素  \n→ Step 2: idxMap ← 空映射(value → 設集合) // 用來記錄每個值在 dataList 中的索引集合  \n\n→ Step 3: RandomizedCollection() // 建構子  \n  → Decision: 已初始化? // 防止重複初始化  \n   Yes → End // 已有資料結構，直接返回  \n   No  → Step 4: dataList ← [] // 初始化空列表  \n    Step 5: idxMap ← {} // 初始化空映射  \n\n→ Function insert(val)  \n  → Decision: val 是否在 idxMap? // 判斷是否為新元素  \n   Yes → Step 6: isNew ← False  \n   No  → Step 7: isNew ← True; idxMap[val] ← 空集合  \n  → Step 8: index ← dataList.size() // 新元素的索引  \n  → Step 9: dataList.append(val) // 把值加入列表  \n  → Step 10: idxMap[val].add(index) // 記錄索引  \n  → Step 11: return isNew // 回傳是否為全新元素  \n\n→ Function remove(val)  \n  → Decision: val 是否在 idxMap? // 檢查是否存在  \n   Yes →  \n    → Decision: idxMap[val] 是否為空? // 確認有可移除的項目  \n     Yes → Step 12: return False  \n     No  →  \n      → Step 13: idxToRemove ← 任意取 idxMap[val] 中的索引  \n      → Step 14: lastIndex ← dataList.size() - 1  \n      → Step 15: lastVal ← dataList[lastIndex]  \n      → Decision: idxToRemove ≠ lastIndex? // 判斷是否需要交換  \n       Yes →  \n        → Step 16: dataList[idxToRemove] ← lastVal // 用最後一項覆蓋  \n        → Step 17: idxMap[lastVal].remove(lastIndex) // 移除舊索引  \n        → Step 18: idxMap[lastVal].add(idxToRemove) // 加入新索引  \n       No → // 直接刪除，不需要交換  \n        // 無需更新  \n       → Step 19: dataList.pop_back() // 刪除最後元素  \n       → Step 20: idxMap[val].remove(idxToRemove) // 移除被刪除元素的索引  \n       → Decision: idxMap[val] 是否為空? // 判斷是否要刪除鍵  \n        Yes → Step 21: delete idxMap[val]  \n        No  → // 留下空集合  \n       → Step 22: return True  \n    No  → Step 23: return False  \n\n→ Function getRandom()  \n  → Step 24: randomIndex ← random 0 ~ dataList.size()-1 // 隨機索引  \n  → Step 25: return dataList[randomIndex] // 返回隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7r_i9bp3.py\", line 35, in <module>\n    params = ast.literal_eval(dict_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x781a563275d0>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp7r_i9bp3.py\", line 37, in <module>\n    raise ValueError(f\"Invalid input format: {e}\")\nValueError: Invalid input format: malformed node or string on line 1: <ast.Name object at 0x781a563275d0>"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6gzp_8f8.py\", line 35, in <module>\n    params = ast.literal_eval(dict_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7a0b532275d0>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp6gzp_8f8.py\", line 37, in <module>\n    raise ValueError(f\"Invalid input format: {e}\")\nValueError: Invalid input format: malformed node or string on line 1: <ast.Name object at 0x7a0b532275d0>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list[str]) -> int:\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n            for i in range(len(current)):\n                for g in genes:\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Convert input string into a dictionary\n    dict_str = \"{\" + data.replace(\"=\", \":\") + \"}\"\n    try:\n        params = ast.literal_eval(dict_str)\n    except Exception as e:\n        raise ValueError(f\"Invalid input format: {e}\")\n\n    startGene = params.get(\"startGene\")\n    endGene = params.get(\"endGene\")\n    bank = params.get(\"bank\", [])\n\n    solution = Solution()\n    result = solution.minMutation(startGene, endGene, bank)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line, with virtual code and comments. Use arrow →, Decision: etc. We need to solve problem: find minimum mutations from startGene to endGene, each mutation changes one char, resulting gene must be in bank. Standard BFS shortest path. If not found return -1. So pseudocode: Start; load bank into set; if endGene not in set then return -1? Actually could still be found via bank? The problem: If endGene not in bank, cannot reach? Actually typical Leetcode problem: need to find path only if intermediate genes in bank, including end. So if endGene not in bank, return -1. So we implement BFS. Use queue of (gene, steps). visited set. While queue not empty: pop; if gene==endGene return steps; for each pos in 0..7: for each ch in 'ACGT': if ch != gene[pos] => newGene; if newGene in bankSet and not visited: add to queue with steps+1; visited add. End loop. After loop return -1.\n\nWe need to provide lines like \"→ Step: Initialize...\" etc.\n\nMake sure each line has \"虛擬碼步驟\" and comment.\n\nWe must not output actual code, just virtual code.\n\nLet's produce step-by-step:\n\nStart // start\n→ Step 1: bankSet ← Convert bank list to Set // 方便快速查詢\n→ Step 2: If endGene not in bankSet then return -1 // 必須在銀行才能到達\n→ Step 3: visited ← Empty Set // 已探索基因\n→ Step 4: queue ← [(startGene, 0)] // 開始基因與步數\n→ Decision: queue 是否為空? // 檢查是否還有基因待處理\n    No  → Step 5: currentGene, steps ← queue.dequeue() // 取出下一個基因\n    No  → Step 6: If currentGene == endGene then return steps // 到達目標\n    No  → Step 7: For i from 0 to 7:\n        No  →     For ch in ['A','C','G','T']:\n        No  →         If ch != currentGene[i] then\n        No  →             newGene ← currentGene[0:i] + ch + currentGene[i+1:] // 替換字符\n        No  →             If newGene in bankSet and newGene not in visited then\n        No  →                 visited.add(newGene)\n        No  →                 queue.enqueue((newGene, steps+1)) // 加入隊列\n    No  → Decision: queue 是否為空? // 重新檢查\n        Yes → End // 所有可能已探索完畢，無路徑\n        No → Repeat\n\nBut we need each line as separate, with arrow indent. We need to maintain arrow indentation as per format. We need to be careful to use \"Decision:\" line with Yes → ... No → ... indentation.\n\nAlso we need to include line numbers? Not necessary. But we need to produce in order.\n\nLet's produce final output. Use virtual code lines. Ensure each line ends with comment. For Decision lines, indent sub-lines appropriately. Use indentation with spaces. The example shows indent 4 spaces before Yes → and No → lines. We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: bankSet ← Convert bank list to Set // 建立可快速查詢的集合  \n→ Decision: 是否有 endGene 在 bankSet? // 檢查目標是否在基因庫  \n  Yes → End // 如果不在，直接結束並回傳 -1  \n  No  → Step 2: visited ← Empty Set // 追蹤已探索的基因  \n→ Step 3: queue ← [(startGene, 0)] // 初始化 BFS 隊列，步數為 0  \n→ Decision: queue 是否為空? // 是否還有待處理的基因  \n  Yes → End // 全部探索完畢，回傳 -1  \n  No  → Step 4: currentGene, steps ← queue.dequeue() // 取出下一個基因  \n  No  → Decision: currentGene == endGene? // 是否已到達目標  \n    Yes → End // 回傳已完成的步數  \n    No  → Step 5: For i from 0 to 7: // 遍歷每個位置  \n      Decision: 有無其他字元可以替換? // 選擇不同的字母  \n       Yes → Step 6: For ch in ['A','C','G','T']:  \n         Decision: ch ≠ currentGene[i]? // 確保真的改變  \n          Yes → Step 7: newGene ← currentGene[0:i] + ch + currentGene[i+1:] // 產生新基因  \n           Decision: newGene 在 bankSet 且未被訪問? // 只能用合法且未探索的基因  \n            Yes → Step 8: visited.add(newGene) // 標記已探索  \n             Step 9: queue.enqueue((newGene, steps + 1)) // 加入下一層搜尋  \n            No  → // 跳過不合法或已探索的基因  \n            No  → // 針對每個位置完成迴圈  \n            No  → // 結束內層迴圈  \n            No  → // 結束外層迴圈  \n            No  → // 返回到 Decision: queue 是否為空? 的判斷  \n            No → // 重新檢查是否有剩餘基因待處理  \n            Yes → End // 所有可能已探索完畢，無路徑，結束程式"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        # small: max-heap (store negatives)\n        # large: min-heap\n        self.small = []\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        if self.large and -self.small[0] > self.large[0]:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # parse commands and arguments\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        commands = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n    else:\n        # single line: split between two lists\n        idx = data.find('], [')\n        if idx != -1:\n            cmd_str = data[:idx+1]\n            args_str = data[idx+2:]\n            commands = ast.literal_eval(cmd_str.strip())\n            args = ast.literal_eval(args_str.strip())\n        else:\n            # fallback\n            commands = ast.literal_eval(data)\n            args = []\n\n    result = []\n    obj = None\n    for cmd, param in zip(commands, args):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(param[0])\n            result.append(None)\n        elif cmd == \"findMedian\":\n            median = obj.findMedian()\n            result.append(median)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for implementing MedianFinder class with methods: constructor, addNum, findMedian. Approach: maintain two heaps: max-heap for lower half, min-heap for upper half. Balanced such that size difference <=1. For median: if sizes equal, median is average of top of both heaps; else median is top of larger heap.\n\nWe produce step-by-step virtual code. Use Start, End, Decision. Provide explanation. The output should be lines with code and comments.\n\nWe'll show class definition, init, methods.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MedianFinder 類別 // 建立類別容器\n→ Step 2: 初始化兩個堆: maxHeap (大根堆) 與 minHeap (小根堆) // 用於分隔數值\n→ Step 3: Constructor: 新增空堆並設定大小差異為 0 // 準備資料結構\n→ Step 4: addNum 方法: 將新數字插入適當堆 // 添加數值\n    → Decision: 若 maxHeap 为空 或 num ≤ maxHeap.top? // 判斷放在哪個堆\n        Yes → Step 5: maxHeap.push(num) // 插入至大根堆\n        No  → Step 6: minHeap.push(num) // 插入至小根堆\n    → Step 7: 平衡堆: 若 maxHeap.size > minHeap.size + 1? // 調整大小\n        Yes → Step 8: minHeap.push(maxHeap.top()); maxHeap.pop(); // 移至另一堆\n        No  → Decision: 若 minHeap.size > maxHeap.size? // 另一種調整\n            Yes → Step 9: maxHeap.push(minHeap.top()); minHeap.pop(); // 移回\n    → Step 10: End addNum // 完成添加\n→ Step 11: findMedian 方法: 計算中位數 // 回傳中位數\n    → Decision: 若 maxHeap.size == minHeap.size? // 同樣大小\n        Yes → Step 12: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均\n        No  → Step 13: median = maxHeap.size > minHeap.size ? maxHeap.top() : minHeap.top(); // 大堆頂\n    → Step 14: return median // 回傳結果\nEnd // 程式執行結束\n\nWe need to incorporate Start, End, Decision. Provide explanation after //.\n\nAlso note that we might include comments about heap operations.\n\nEnsure each line has code and comment. Use arrows for steps, but we also need to indent for nested decisions. Provide consistent style.\n\nWe may show \"→\" for all steps, indent for nested. Provide lines.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MedianFinder 類別 // 建立類別容器  \n→ Step 2: 初始化兩個堆: maxHeap (大根堆) 與 minHeap (小根堆) // 用於分隔數值  \n→ Step 3: Constructor: 新增空堆並設定大小差異為 0 // 準備資料結構  \n→ Step 4: addNum 方法: 將新數字插入適當堆 // 添加數值  \n  → Decision: 若 maxHeap 為空 或 num ≤ maxHeap.top()? // 判斷放在哪個堆  \n    Yes → Step 5: maxHeap.push(num) // 插入至大根堆  \n    No  → Step 6: minHeap.push(num) // 插入至小根堆  \n  → Step 7: 平衡堆: 若 maxHeap.size > minHeap.size + 1? // 調整大小  \n    Yes → Step 8: minHeap.push(maxHeap.top()); maxHeap.pop(); // 移至另一堆  \n    No  → Decision: 若 minHeap.size > maxHeap.size? // 另一種調整  \n      Yes → Step 9: maxHeap.push(minHeap.top()); minHeap.pop(); // 移回  \n  → Step 10: End addNum // 完成添加  \n→ Step 11: findMedian 方法: 計算中位數 // 回傳中位數  \n  → Decision: 若 maxHeap.size == minHeap.size? // 同樣大小  \n    Yes → Step 12: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均  \n    No  → Step 13: median = maxHeap.size > minHeap.size ? maxHeap.top() : minHeap.top(); // 大堆頂  \n  → Step 14: return median // 回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfg4gcur8.py\", line 81, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfg4gcur8.py\", line 72, in parse_input\n    new_interval = ast.literal_eval(new_interval_str)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ,   [2,5]\n    ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpq8epekfs.py\", line 81, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpq8epekfs.py\", line 72, in parse_input\n    new_interval = ast.literal_eval(new_interval_str)\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ,   [4,8]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a list of non-overlapping, sorted intervals\n        and merge if necessary.\n        \"\"\"\n        res = []\n        i = 0\n        n = len(intervals)\n\n        # 1. Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            res.append(intervals[i])\n            i += 1\n\n        # 2. Merge all intervals that overlap with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # 3. Add the merged (or original) new interval\n        res.append(newInterval)\n\n        # 4. Add the remaining intervals\n        while i < n:\n            res.append(intervals[i])\n            i += 1\n\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input format:\n        intervals = [[...], [...], ...], newInterval = [a, b]\n    and return the two lists.\n    \"\"\"\n    # Find the first '[' which starts the outer list of intervals\n    start_idx = data.find('[')\n    if start_idx == -1:\n        raise ValueError(\"Invalid input: no '[' found\")\n\n    # Find the matching closing bracket for the outer list\n    count = 0\n    end_idx = None\n    for i in range(start_idx, len(data)):\n        if data[i] == '[':\n            count += 1\n        elif data[i] == ']':\n            count -= 1\n            if count == 0:\n                end_idx = i\n                break\n    if end_idx is None:\n        raise ValueError(\"Invalid input: unmatched brackets\")\n\n    intervals_str = data[start_idx:end_idx + 1]\n\n    # Everything after the outer list belongs to the new interval part\n    rest = data[end_idx + 1:]\n\n    # Remove the variable name and equal sign\n    rest = rest.replace('newInterval', '').replace('=', '').strip()\n\n    # The rest should be a list representation\n    new_interval_str = rest\n\n    intervals = ast.literal_eval(intervals_str)\n    new_interval = ast.literal_eval(new_interval_str)\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    intervals, new_interval = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce step-by-step pseudocode for insertion/merge intervals. Use Start, Decision, arrows. Provide line-by-line. Each line: \"虛擬碼步驟 // 解釋\". Let's design algorithm:\n\n- Input: intervals list sorted, newInterval.\n- Result array res.\n- For each interval in intervals:\n   - If interval.end < newInterval.start: no overlap, interval before new -> add to res.\n   - Else if interval.start > newInterval.end: no overlap, interval after new -> add newInterval (if not yet added), then add interval, and set flag added=true; and for remaining intervals, just append.\n   - Else overlap: merge: newInterval.start = min(newInterval.start, interval.start); newInterval.end = max(newInterval.end, interval.end).\n- After loop, if newInterval not added, append it.\n- Return res.\n\nNeed to maintain \"added\" flag.\n\nAlso need to handle empty intervals.\n\nLet's produce virtual code:\n\nStart // 程式開始執行\n→ Step 1: Initialize res as empty list // 結果集合\n→ Step 2: Set added = false // 標記是否已加入新區間\n→ Decision: 如果 intervals 為空? // 檢查是否有原始區間\n    Yes → Step 3: 將 newInterval 加入 res // 空時直接插入\n    No  → Step 4: 對 intervals 中每個 interval 進行迭代 // 處理每個區間\n        → Step 5: Decision: interval.end < newInterval.start? // 前面不重疊\n            Yes → Step 6: res.append(interval) // 將原區間加入結果\n            No  → Decision: interval.start > newInterval.end? // 後面不重疊\n                Yes → Decision: added? // 是否已加入新區間\n                    Yes → Step 7: res.append(interval) // 直接加入原區間\n                    No  → Step 8: res.append(newInterval) // 加入新區間\n                        → Step 9: res.append(interval) // 加入原區間\n                        → Step 10: added = true // 標記已加入\n                No  → Step 11: newInterval.start = min(newInterval.start, interval.start) // 合併起始\n                    → Step 12: newInterval.end = max(newInterval.end, interval.end) // 合併結束\n        → End // loop\n→ Decision: added? // 是否已加入新區間\n    Yes → Step 13: End // 完成\n    No  → Step 14: res.append(newInterval) // 若最後仍未加入，加入\n→ End // 返回 res\n\nBut need to follow format: use Start, End, Decision. Provide each line with arrow and step label.\n\nAlso we need to mention returning res at end. Provide Step 15: return res // 結果\n\nLet's write accordingly. Ensure each line ends with // 解釋. Use arrow to indicate sequence. Use Decision: lines inside indentation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: res ← empty list // 建立結果區間集合  \n→ Step 2: added ← false // 標記是否已把 newInterval 加入 res  \n→ Decision: intervals 为空? // 檢查是否有原始區間  \n  Yes → Step 3: res.append(newInterval) // 空陣列時直接加入新區間  \n  No  → Step 4: for each interval in intervals do // 逐一處理每個區間  \n    → Decision: interval.end < newInterval.start? // 前面完全不重疊  \n      Yes → Step 5: res.append(interval) // 直接加入原區間  \n      No  → Decision: interval.start > newInterval.end? // 後面完全不重疊  \n        Yes → Decision: added? // 已經加入新區間了嗎？  \n          Yes → Step 6: res.append(interval) // 直接加入後續區間  \n          No  → Step 7: res.append(newInterval) // 先加入新區間  \n           → Step 8: res.append(interval) // 再加入當前原區間  \n           → Step 9: added ← true // 標記已插入  \n        No  → Step 10: newInterval.start ← min(newInterval.start, interval.start) // 合併起始點  \n          → Step 11: newInterval.end ← max(newInterval.end, interval.end) // 合併結束點  \n    → End // for loop 結束  \n→ Decision: added? // 最後判斷是否已把 newInterval 加入  \n  Yes → Step 12: // 已加入，不再需要加  \n  No  → Step 13: res.append(newInterval) // 若仍未加入，最後加入  \n→ Step 14: return res // 回傳插入且合併後的區間集合  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    outputs = []\n    module_var = None\n    modules = {}\n    for line in data:\n        line = line.strip()\n        if not line:\n            continue\n        if \"=\" in line:\n            # initialization line\n            var_part = line.split('=')[0].strip()\n            parts = var_part.split()\n            var_name = parts[-1]\n            modules[var_name] = RangeModule()\n            module_var = var_name\n            outputs.append(\"null\")\n        elif \".addRange(\" in line:\n            idx = line.find(\"addRange(\")\n            args = line[idx+len(\"addRange(\"): line.find(\")\", idx)]\n            left, right = map(int, args.split(\",\"))\n            modules[module_var].addRange(left, right)\n            outputs.append(\"null\")\n        elif \".removeRange(\" in line:\n            idx = line.find(\"removeRange(\")\n            args = line[idx+len(\"removeRange(\"): line.find(\")\", idx)]\n            left, right = map(int, args.split(\",\"))\n            modules[module_var].removeRange(left, right)\n            outputs.append(\"null\")\n        elif \".queryRange(\" in line:\n            idx = line.find(\"queryRange(\")\n            args = line[idx+len(\"queryRange(\"): line.find(\")\", idx)]\n            left, right = map(int, args.split(\",\"))\n            res = modules[module_var].queryRange(left, right)\n            outputs.append(\"true\" if res else \"false\")\n        # ignore any other lines\n    print(\"[\" + \", \".join(outputs) + \"]\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step of design, not actual code. Provide algorithm design. Provide high-level steps: using sorted list of intervals or BST. Use intervals merging, queries. Steps: initialize list, addRange: merge overlapping, removeRange: split intervals, queryRange: check coverage.\n\nWe must output line by line with \"虛擬碼步驟\" + space + comment. Use arrows. Provide Start, End. Include decisions. Should describe data structure and operations. Provide clear steps.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 定義 RangeModule 類別 // 建立類別以封裝範圍管理\n→ Step 2: 在建構子中初始化空的區間列表 intervals // 以升序存放已追蹤的半開區間\n→ Decision: 需要快速搜尋與合併區間？ // 判斷是否使用平衡樹或列表\n    Yes → Step 3: 選擇使用 SortedList / Balanced BST 以保持區間排序 // 選擇更高效的資料結構\n    No  → Step 3: 使用簡單列表並每次掃描 // 低效但簡單實作\n\nProceed to addRange:\n\n→ Step 4: addRange(left, right) // 進行區間加入操作\n→ Step 5: 在 intervals 中尋找第一個與 [left,right) 重疊或相鄰的區間 // 以保持區間不重複\n→ Step 6: 合併所有重疊或相鄰區間，形成新區間 [newLeft,newRight] // 更新區間範圍\n→ Step 7: 刪除被合併的舊區間，插入新區間到正確位置 // 保持列表排序\n\nremoveRange:\n\n→ Step 8: removeRange(left, right) // 進行區間移除\n→ Step 9: 找到所有與 [left,right) 重疊的區間 // 需要檢查左側與右側剩餘\n→ Step 10: 對每個重疊區間：\n        → Decision: 是否整個區間被移除？ // 判斷區間位置\n            Yes → Step 11: 刪除該區間 // 完全覆蓋\n            No  → Step 12: 若左側仍有未被移除部分 → Step 13: 插入左側剩餘區間\n            No  → Step 14: 若右側仍有未被移除部分 → Step 15: 插入右側剩餘區間\n→ Step 16: 確保列表仍排序且無重疊\n\nqueryRange:\n\n→ Step 17: queryRange(left, right) // 查詢是否完全被追蹤\n→ Step 18: 在 intervals 中尋找包含 left 的區間 // 以確認左端點是否被追蹤\n→ Step 19: Decision: 是否存在區間且區間右端 >= right？\n            Yes → Step 20: 返回 true // 完全覆蓋\n            No  → Step 21: 返回 false // 未被覆蓋\n\nEnd // 程式執行結束\n\nBut need step-by-step per line with comment. Should include arrows. Might need indentation for decisions.\n\nLet's produce with proper format. Use \"Start\" line.\n\nAlso maybe need to include method definitions and internal functions.\n\nMake each line simple.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 RangeModule 類別 // 建立類別以封裝範圍管理  \n→ Step 2: 在建構子中初始化空的區間列表 intervals // 以升序存放已追蹤的半開區間  \n→ Decision: 需要快速搜尋與合併區間？ // 判斷是否使用平衡樹或列表  \n Yes → Step 3: 選擇使用 SortedList / Balanced BST 以保持區間排序 // 以 O(log n) 取得插入與查找  \n No  → Step 3: 使用簡單列表並每次掃描 // 低效但簡單實作  \n→ Step 4: addRange(left, right) // 進行區間加入操作  \n→ Step 5: 在 intervals 中尋找第一個與 [left,right) 重疊或相鄰的區間 startIndex // 以保持區間不重複  \n→ Step 6: 從 startIndex 開始遍歷，合併所有重疊或相鄰區間，更新 newLeft = min(newLeft, current.left)，newRight = max(newRight, current.right) // 合併形成新的區間  \n→ Step 7: 刪除被合併的舊區間，並在正確位置插入新區間 [newLeft,newRight] // 保持列表排序  \n→ Step 8: removeRange(left, right) // 進行區間移除操作  \n→ Step 9: 在 intervals 中尋找第一個與 [left,right) 重疊的區間 startIndex  \n→ Step 10: 從 startIndex 開始遍歷，對每個重疊區間 current 做處理  \n → Decision: current.left < left && current.right > right // 整個區間是否被完全覆蓋？  \n  Yes → Step 11: 刪除 current // 完全被移除  \n  No  → Decision: current.left < left && current.right > left // 左側剩餘？  \n   Yes → Step 12: 插入左側剩餘區間 [current.left, left] // 只保留左半段  \n   No  → Decision: current.left < right && current.right > right // 右側剩餘？  \n    Yes → Step 13: 插入右側剩餘區間 [right, current.right] // 只保留右半段  \n    No → Step 14: 刪除 current // 完全在移除區間內  \n→ Step 15: 確保 intervals 仍保持升序且無重疊 // 需要合併相鄰區間（如有）  \n→ Step 16: queryRange(left, right) // 查詢是否完全被追蹤  \n→ Step 17: 在 intervals 中尋找最接近且左端 ≤ left 的區間 current  \n→ Decision: current != null 且 current.right >= right // 区间能覆盖整个查询区间？  \n Yes → Step 18: 返回 true // 完全覆蓋  \n No  → Step 19: 返回 false // 未被覆蓋  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,2,true,true,true,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, 2, true, true, true, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        \"\"\"初始化容量為 k 的循環雙端佇列\"\"\"\n        self.k = k\n        self.buf = [0] * k     # 用於存儲元素的循環緩衝區\n        self.head = 0          # 前端指標（指向首元素）\n        self.count = 0         # 當前佇列中的元素數量\n\n    def insertFront(self, value: int) -> bool:\n        \"\"\"在前端插入元素，若佇列已滿則返回 False\"\"\"\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        \"\"\"在後端插入元素，若佇列已滿則返回 False\"\"\"\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        \"\"\"刪除前端元素，若佇列為空則返回 False\"\"\"\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        \"\"\"刪除後端元素，若佇列為空則返回 False\"\"\"\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        \"\"\"取得前端元素，若佇列為空返回 -1\"\"\"\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        \"\"\"取得後端元素，若佇列為空返回 -1\"\"\"\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        \"\"\"判斷佇列是否為空\"\"\"\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        \"\"\"判斷佇列是否已滿\"\"\"\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        return\n    ops = ast.literal_eval(data[0])   # 例如 [\"MyCircularDeque\", \"insertLast\", ...]\n    args = ast.literal_eval(data[1])  # 例如 [[3], [1], ...]\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            # 建構子，結果為 null\n            obj = MyCircularDeque(arg[0])\n            results.append(None)\n        else:\n            # 取得方法對象\n            method = getattr(obj, op)\n            # 若 arg 為空列表，直接呼叫；否則傳入單個參數\n            if not arg:\n                res = method()\n            else:\n                res = method(arg[0])\n            results.append(res)\n\n    # 將結果轉換為 JSON 字符串，保持與 LeetCode 期望的輸出格式一致\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. We must design the circular deque. Provide lines with 虛擬碼步驟 and // 解釋. Use Start, End, Decision. Must not produce actual code. Let's produce steps:\n\nStart\n→ 初始化: 建立容量 k, 前指標 front = -1, 後指標 rear = -1, 數組 arr[k] // initialize\n→ Step: insertFront(x)\n    → Decision: if isFull()? Yes → return false // cannot insert\n    No → Decision: if isEmpty()? Yes → front = rear = 0, arr[front] = x, return true\n        No → front = (front - 1 + k) % k, arr[front] = x, return true\n→ Step: insertLast(x)\n    similar logic with rear\n→ Step: deleteFront()\n    → Decision: isEmpty()? Yes → return false\n    No → Decision: front == rear? Yes → front = rear = -1, return true\n        No → front = (front + 1) % k, return true\n→ Step: deleteLast()\n    similar\n→ Step: getFront()\n    → Decision: isEmpty()? Yes → return -1\n    No → return arr[front]\n→ Step: getRear()\n    similar\n→ Step: isEmpty()\n    → Decision: front == -1? Yes → return true\n    No → return false\n→ Step: isFull()\n    → Decision: (rear + 1) % k == front? Yes → return true\n    No → return false\nEnd\n\nEnsure each line is separate. Use arrow. Use \"→\" before each step. For decisions we indent? The example uses indentation with Decision: and Yes/No lines. We can produce similar.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ MyCircularDeque(k) // 建立容量為 k 的循環雙端佇列  \n→    arr ← new 數組長度 k // 儲存元素  \n→    front ← -1 // 前指標初始值  \n→    rear ← -1 // 後指標初始值  \n→ insertFront(x) // 將 x 加到前端  \n→    Decision: 如果 isFull()? // 檢查佇列是否已滿  \n→        Yes → return false // 插入失敗  \n→        No → Decision: 如果 isEmpty()? // 檢查是否為空  \n→            Yes → front ← rear ← 0, arr[front] ← x, return true // 空佇列時直接放入  \n→            No → front ← (front - 1 + k) % k, arr[front] ← x, return true // 往前移動前指標並放入  \n→ insertLast(x) // 將 x 加到後端  \n→    Decision: 如果 isFull()?  \n→        Yes → return false  \n→        No → Decision: 如果 isEmpty()?  \n→            Yes → front ← rear ← 0, arr[rear] ← x, return true  \n→            No → rear ← (rear + 1) % k, arr[rear] ← x, return true  \n→ deleteFront() // 刪除前端元素  \n→    Decision: 如果 isEmpty()? // 先檢查是否為空  \n→        Yes → return false // 刪除失敗  \n→        No → Decision: 如果 front == rear? // 只剩一個元素  \n→            Yes → front ← rear ← -1, return true // 清空佇列  \n→            No → front ← (front + 1) % k, return true // 移動前指標  \n→ deleteLast() // 刪除後端元素  \n→    Decision: 如果 isEmpty()?  \n→        Yes → return false  \n→        No → Decision: 如果 front == rear?  \n→            Yes → front ← rear ← -1, return true  \n→            No → rear ← (rear - 1 + k) % k, return true  \n→ getFront() // 取得前端元素  \n→    Decision: 如果 isEmpty()?  \n→        Yes → return -1 // 佇列空  \n→        No → return arr[front] // 回傳前端值  \n→ getRear() // 取得後端元素  \n→    Decision: 如果 isEmpty()?  \n→        Yes → return -1  \n→        No → return arr[rear]  \n→ isEmpty() // 檢查佇列是否為空  \n→    Decision: 如果 front == -1?  \n→        Yes → return true  \n→        No → return false  \n→ isFull() // 檢查佇列是否已滿  \n→    Decision: 如果 (rear + 1) % k == front?  \n→        Yes → return true  \n→        No → return false  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        # 將內容映射到所有檔案的完整路徑\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # 去掉末尾的 ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # 只保留重複的檔案群組\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得列表文字，假設輸入格式類似 'paths = [...]'\n    start = data.find('[')\n    end = data.rfind(']') + 1\n    list_str = data[start:end]\n    paths = ast.literal_eval(list_str)\n\n    sol = Solution()\n    result = sol.findDuplicate(paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: Iterate through each path string, parse directory path and files with contents. Build map content->list of file paths. After processing all, iterate map, collect lists with size>1. Return as list. Use virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. We need to include loops, parsing, data structures.\n\nWe should produce step by step pseudocode:\n\nStart\n→ Step 1: 建立空字典 content_to_paths // 存儲內容到文件路徑列表\n→ Step 2: 針對輸入列表 each path_str\n→ Step 3: 解析 directory 和 files\n→ Step 4: 對於每個 file_str\n→ Step 5: 分離 file_name 和 content\n→ Step 6: 建立 full_path\n→ Step 7: 把 full_path 加入 content_to_paths[content]\n→ End parsing\n→ Step 8: 建立結果列表 result\n→ Step 9: 遍歷 content_to_paths\n→ Decision: 如果 list_size > 1?\n    Yes → Step 10: 將 list 加入 result\n    No → Step 11: 忽略\n→ End\n→ Step 12: 返回 result\n\nWe need to include decision arrow formatting. Also we may show parsing steps with splitting by space, etc.\n\nMake sure each line uses \"虛擬碼步驟\". Also start and end. Provide explanation comments. Use arrows: → etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 content_to_paths  // 用來映射檔案內容到其完整路徑列表  \n→ Step 2: 針對輸入列表 each path_str  // 逐個處理每個目錄資訊字串  \n→ Step 3: 解析 directory 與 files  // 以空格切割，第一個是目錄路徑，後面是檔案資訊  \n→ Decision: 目錄路徑是否存在？ // 判斷是否有子目錄（m≥0）  \n  Yes → Step 4: dir = 第一個切割片段 // 取得完整目錄路徑  \n  No  → Step 4: dir = \"\" // 若輸入僅為檔案，設定為空字串  \n→ Step 5: 對於每個 file_str in 其餘切割片段  // 逐個檔案資訊  \n→ Step 6: 分離 file_name 與 content  // 在 '(' 號前取檔名，括號內為內容  \n→ Step 7: 建立 full_path = dir + \"/\" + file_name  // 組合完整檔案路徑  \n→ Step 8: 如果 content_to_paths 內已有此 content，則加入列表；否則新建列表  // 更新映射  \n  Decision: content 是否已存在？  \n   Yes → Step 9: content_to_paths[content].append(full_path) // 加入同內容列表  \n   No  → Step 9: content_to_paths[content] = [full_path] // 建立新列表  \n→ End  // 完成所有目錄資訊的解析  \n→ Step 10: 建立結果列表 result = []  // 儲存重複檔案的群組  \n→ Step 11: 遍歷 content_to_paths 的每個 key, value  // 檢查每個內容對應的檔案列表  \n→ Decision: value 列表長度是否大於 1？ // 只保留至少兩個檔案的內容  \n  Yes → Step 12: result.append(value) // 加入重複檔案群組  \n  No  → Step 13: 跳過  // 不加入單一檔案的內容  \n→ End  // 結束遍歷  \n→ Step 14: 返回 result // 輸出所有重複檔案的路徑群組  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[3]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[3]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[6,9]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[6, 9]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[3,1,3]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[3, 1, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# ---------------------------------------------------\n# 假設外部已經提供了 rand7() API。\n# 若在本地測試，下面的實作僅作示範使用。\n# ---------------------------------------------------\ndef rand7():\n    \"\"\"示範實作：請在正式環境中使用已提供的 rand7()。\"\"\"\n    import random\n    return random.randint(1, 7)\n\n# ---------------------------------------------------\n# 主解法：使用兩次 rand7() 產生 1~49 的均勻分布，  \n# 再以拒絕抽樣得到 1~10 的均勻分布。\n# ---------------------------------------------------\nclass Solution:\n    def rand10(self):\n        while True:\n            a = rand7()          # 第一個 1~7 的隨機數\n            b = rand7()          # 第二個 1~7 的隨機數\n            num = (a - 1) * 7 + b   # 將兩個數合併得到 1~49\n            if num <= 40:             # 只接受 1~40\n                return 1 + (num - 1) % 10   # 映射到 1~10\n\n# ---------------------------------------------------\n# main: 讀取輸入、調用 rand10() n 次、輸出結果\n# ---------------------------------------------------\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入字串中提取數字 n\n    m = re.search(r'\\d+', data)\n    n = int(m.group()) if m else 0\n\n    solver = Solution()\n    results = [solver.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for rand10() using rand7() only. Use rejection sampling: combine two rand7() to get 49 outcomes. Map 1-40 to 1-10 (4 each). Rejection for 41-49. Or better use 2*7-1 method. Provide step-by-step pseudocode lines with explanation. Need each line: 虛擬碼步驟 [space] // 解釋. Use Start, End, Decision: etc. Use arrow for sequence. Let's craft.\n\nPseudo:\n\nStart // begin\n→ Step 1: repeat\n    → Step 2: a ← rand7()\n    → Step 3: b ← rand7()\n    → Step 4: num ← (a-1)*7 + b // 1..49\n    → Decision: num <= 40? // accept if <=40\n        Yes → Step 5: result ← ((num-1) mod 10) + 1 // map to 1..10\n        No  → Step 6: go back to Step 1 // reject, repeat\n→ Step 7: return result\nEnd\n\nAdd comments. Also mention explanation. Provide each line with arrow? The example uses \"→ Step 1:\" etc. The arrows indent inside decision. So produce. Ensure each line has explanation.\n\nWe must also maybe mention that loop uses while true. Let's produce virtual code accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: repeat // 進入重複迴圈，直到得到有效數字  \n  → Step 2: a ← rand7() // 產生第一個 1~7 的隨機數  \n  → Step 3: b ← rand7() // 產生第二個 1~7 的隨機數  \n  → Step 4: num ← (a - 1) * 7 + b // 將兩個數合併得到 1~49 的數字  \n  → Decision: num <= 40? // 判斷是否落在可接受範圍內  \n    Yes → Step 5: result ← ((num - 1) mod 10) + 1 // 將 1~40 映射到 1~10  \n    No  → Step 6: continue // 超過 40，重新進入迴圈  \n→ Step 7: return result // 回傳隨機數 1~10  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) != 8:\n        print(\"false\")\n        sys.exit(0)\n    p1, p2, p3, p4 = (\n        [nums[0], nums[1]],\n        [nums[2], nums[3]],\n        [nums[4], nums[5]],\n        [nums[6], nums[7]],\n    )\n    sol = Solution()\n    print(\"true\" if sol.validSquare(p1, p2, p3, p4) else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm to check if four points form a square. Provide step-by-step virtual code with explanation after each line. Use arrows. Use Start, Decision, End. Must be line by line. Use \"→\" to indent decisions. Must include code logic: compute all pairwise distances squared, sort, check first 4 equal >0 and last 4 equal to 2*first? Wait typical algorithm: compute all 6 distances squared, sort. For square: first four equal (sides), last two equal (diagonals), and diagonal = 2*side. Also side>0. Provide steps.\n\nLet's produce:\n\nStart // begin\n→ Step 1: 計算所有 6 對點之間的距離平方並儲存 // compute distances squared\n→ Step 2: 將距離平方集合排序 // sort distances\n→ Decision: 檢查前四個距離是否相等且 >0? // verify sides\n    Yes → Decision: 檢查最後兩個距離是否相等? // verify diagonals\n        Yes → Decision: 檢查最後兩個距離是否為前四個距離之二倍? // check right angle\n            Yes → Step 3: 返回 true // 是正方形\n            No  → Step 4: 返回 false // 角度不為 90\n        No  → Step 5: 返回 false // 對角線長度不相等\n    No  → Step 6: 返回 false // 邊長不相等或為零\n\nBut also need to check side>0. Already first four equal >0. So Step 1 maybe compute distances. Provide explanation. Provide code like \"ComputeDistance(p_i, p_j)\" as placeholder.\n\nNeed to use virtual code arrow and decision indent. Provide each line with explanation. Must not output actual code but virtual code. Use \"Step X:\".\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 生成一個空清單 Distances // 用來儲存所有 6 對點之間的距離平方\n→ Step 2: 對每一對點 (p1,p2),(p1,p3),(p1,p4),(p2,p3),(p2,p4),(p3,p4) 進行\n    → Sub-step: 計算距離平方 d = (x_i-x_j)^2 + (y_i-y_j)^2\n    → Sub-step: 將 d 加入 Distances\n→ Step 3: 將 Distances 按升序排序 // 方便後續比較\n→ Decision: 如果前四個距離相等且 >0? // 邊長需相等且為正\n    Yes → Decision: 如果最後兩個距離相等? // 對角線需相等\n        Yes → Decision: 如果最後兩個距離 == 2 * 前四個距離? // 對角線長為邊長的 sqrt(2) 之平方\n            Yes → Step 4: 返回 true // 四個點構成正方形\n            No  → Step 5: 返回 false // 對角線長度不符\n        No  → Step 6: 返回 false // 對角線長度不相等\n    No  → Step 7: 返回 false // 邊長不相等或為零\nEnd // 程式執行結束\n\nBut need each line separate. Let's flatten: Each arrow line counts as a line. Use indentation for decisions. Provide explanation after each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空清單 Distances 用來儲存所有 6 對點之間的距離平方 // 準備距離資料  \n→ Step 2: 逐對遍歷所有點  \n → Sub-step: 計算兩點 (p_i, p_j) 的距離平方 d = (x_i - x_j)^2 + (y_i - y_j)^2 // 計算距離  \n → Sub-step: 將 d 加入 Distances // 收集距離  \n→ Step 3: 將 Distances 按升序排序 // 方便後續比較  \n→ Decision: 前四個距離是否相等且 >0? // 確認四條邊長相等且非零  \n Yes → Decision: 最後兩個距離是否相等? // 確認兩條對角線長度相同  \n  Yes → Decision: 最後兩個距離是否等於前四個距離的 2 倍? // 檢查 90° 角度條件  \n   Yes → Step 4: 返回 true // 四個點構成正方形  \n   No  → Step 5: 返回 false // 對角線長度不符 2 倍關係  \n  No  → Step 6: 返回 false // 對角線長度不相等  \n No  → Step 7: 返回 false // 邊長不相等或為零  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8st371un.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmp8st371un.py\", line 42, in main\n    equations, values, queries = parse_input(input_text)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8st371un.py\", line 32, in parse_input\n    tree = ast.parse(text)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppv4yzvf4.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmppv4yzvf4.py\", line 42, in main\n    equations, values, queries = parse_input(input_text)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppv4yzvf4.py\", line 32, in parse_input\n    tree = ast.parse(text)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsxgzeanm.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpsxgzeanm.py\", line 42, in main\n    equations, values, queries = parse_input(input_text)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpsxgzeanm.py\", line 32, in parse_input\n    tree = ast.parse(text)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1.0 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        result = []\n        for u, v in queries:\n            result.append(dfs(u, v, set()))\n        return result\n\ndef parse_input(text):\n    # Parse assignments like \"equations = [...], values = [...], queries = [...]\"\n    tree = ast.parse(text)\n    data = {}\n    for node in tree.body:\n        if isinstance(node, ast.Assign):\n            var_name = node.targets[0].id\n            data[var_name] = ast.literal_eval(node.value)\n    return data.get('equations', []), data.get('values', []), data.get('queries', [])\n\ndef main():\n    input_text = sys.stdin.read()\n    equations, values, queries = parse_input(input_text)\n    solution = Solution()\n    results = solution.calcEquation(equations, values, queries)\n    # Format each result to 5 decimal places\n    formatted = '[' + ','.join(f'{x:.5f}' for x in results) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the problem: evaluate division queries using equations. Standard solution: build graph adjacency with weights, DFS/BFS to find product.\n\nWe need to output line-by-line virtual code steps. Each line: virtual step + space + // explanation.\n\nUse arrow syntax, e.g., Start, →, Decision: etc.\n\nWe need to outline algorithm: Build graph from equations, then for each query compute result via DFS.\n\nWe need to produce pseudo code lines. Probably we include loops.\n\nWe'll produce steps like:\n\nStart // program start\n→ Build adjacency list // create graph mapping variable to neighbors and weight\n→ For each equation: add edges\n→ For each query: compute result via DFS\n→ Function DFS(current, target, accumulated, visited) // ...\n→ Decision: if current equals target? // base case\n... etc.\n\nNeed to ensure each line has // explanation.\n\nWe need to output only the virtual code, no real code. We should not produce actual syntax but pseudocode-like lines with arrows.\n\nMake sure each line has \"虛擬碼步驟 [space] // 解釋\".\n\nWe use arrows \"→\".\n\nWe also need to use \"Decision:\" with Yes/No.\n\nWe'll produce steps for building graph, then processing queries, then DFS function, then final output.\n\nLet's craft. We'll use indentation indicated by tabs or spaces but keep arrow indentation to show hierarchy. We need to keep format consistent.\n\nWe must avoid real code, just description.\n\nLet's write:\n\nStart // 開始\n→ Build adjacency map // 建立變數到相鄰變數及比例的映射\n\nFor each equation pair and value:\n    → Add edge Ai → Bi with weight values[i] // Ai / Bi = value\n    → Add edge Bi → Ai with weight 1/values[i] // 逆向比例\n\n→ Initialize result list // 存放每個查詢的答案\n\nFor each query [C, D]:\n    → Call DFS(C, D, 1.0, empty set) // 以累積乘積計算結果\n    → If DFS returns null:\n        No  → Append -1.0 to result list // 無法決定\n        Yes → Append returned value to result list // 有結果\n\n→ Return result list // 完成\n\nDefine Function DFS(current, target, product, visited):\n    → Add current to visited // 標記已訪問\n    → Decision: current == target?\n        Yes → Return product // 找到目標，返回乘積\n        No  → For each neighbor of current:\n                → Decision: neighbor not in visited?\n                    Yes → Call DFS(neighbor, target, product * weight, visited)\n                    No  → Skip\n                → If DFS returns not null:\n                    Yes → Return that value // 找到路徑\n                    No  → Continue\n    → Return null // 無路徑\n\nEnd // 程式結束\n\nBut must maintain arrow lines and decisions with Yes/No.\n\nLet's produce each line accordingly. Use indentation with spaces.\n\nAlso we need to include \"Decision:\" lines explicitly.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build adjacency map // 建立變數與相鄰變數及比例的圖形  \n→ For each equation (Ai, Bi) with value val:  \n    → Add edge Ai → Bi with weight val // Ai / Bi = val  \n    → Add edge Bi → Ai with weight 1/val // 逆向比例  \n→ Initialize result list // 用於存放查詢答案  \n→ For each query (C, D):  \n    → Call DFS(C, D, 1.0, empty set) // 以累積乘積計算結果  \n    → Decision: DFS返回值為 null? // 判斷是否找到路徑  \n        Yes → Append -1.0 to result list // 無法決定答案  \n        No  → Append DFS返回值到 result list // 有結果  \n→ Return result list // 給予所有查詢答案  \n→ End // 程式結束  \n\nDefine Function DFS(current, target, product, visited):  \n    → Add current to visited // 標記已訪問  \n    → Decision: current == target? // 是否已到達目標  \n        Yes → Return product // 找到目標，返回累積乘積  \n        No  → For each neighbor of current:  \n            → Decision: neighbor not in visited? // 防止循環  \n                Yes → Call DFS(neighbor, target, product * weight, visited) // 繼續遞迴  \n                No  → Skip // 已訪問的鄰居跳過  \n            → Decision: DFS返回值不為 null? // 是否找到合法路徑  \n                Yes → Return DFS返回值 // 傳遞回上層  \n                No  → Continue // 試下一個鄰居  \n    → Return null // 沒有可行路徑  \nEnd // DFS函式結束"
    },
    {
      "title": "Kth Largest Element in an Array",
      "source_file": "Leetcode/leetcode215.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findKthLargest(self, nums, k):\n        \"\"\"Return the k-th largest element without sorting the whole array.\"\"\"\n        if not nums or k <= 0 or k > len(nums):\n            return None\n\n        # The target index in the sorted (ascending) order\n        target = len(nums) - k\n        left, right = 0, len(nums) - 1\n\n        # QuickSelect loop\n        while left <= right:\n            pivot_index = self._partition(nums, left, right)\n            if pivot_index == target:\n                return nums[pivot_index]\n            elif pivot_index < target:\n                left = pivot_index + 1\n            else:\n                right = pivot_index - 1\n        return None\n\n    def _partition(self, nums, left, right):\n        \"\"\"\n        Partition the subarray nums[left:right+1] around a pivot.\n        Elements greater than the pivot are moved to the left side.\n        Returns the final index of the pivot.\n        \"\"\"\n        pivot = nums[right]               # Choose the rightmost element as pivot\n        store_index = left\n        for i in range(left, right):\n            if nums[i] > pivot:           # Want larger elements on the left\n                nums[i], nums[store_index] = nums[store_index], nums[i]\n                store_index += 1\n        nums[store_index], nums[right] = nums[right], nums[store_index]\n        return store_index\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse input string of the form:\n        nums = [3,2,1,5,6,4], k = 2\n    and return the list of numbers and the integer k.\n    \"\"\"\n    # Extract the list part\n    list_match = re.search(r'\\[(.*?)\\]', input_str)\n    if not list_match:\n        raise ValueError(\"Invalid input format: list not found\")\n    list_str = '[' + list_match.group(1) + ']'\n    nums = ast.literal_eval(list_str)\n\n    # Extract the integer k\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', input_str)\n    if not k_match:\n        raise ValueError(\"Invalid input format: k not found\")\n    k = int(k_match.group(1))\n\n    return nums, k\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Parse the numbers and k\n    nums, k = parse_input(raw_input)\n    # Compute the k-th largest element\n    sol = Solution()\n    result = sol.findKthLargest(nums, k)\n    # Print the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: find kth largest element in array without sorting. Likely use QuickSelect or min-heap of size k. We should provide step-by-step algorithm in virtual code. Output format: each line with virtual code step then comment. Use arrows and decision. We'll output Start, then maybe initial steps. Use \"→\" for steps.\n\nLet's craft algorithm:\n\n- Input array nums and integer k.\n- Option 1: QuickSelect: find kth largest => partition by pivot, recursively. Provide high-level steps.\n\nPseudo:\n\nStart\n→ Step 1: Initialize left = 0, right = nums.length -1 // boundaries\n→ Decision: If left > right? // sanity check\n    Yes → End // empty array\n→ Step 2: While left <= right // iterative QuickSelect\n    → Step 3: pivotIndex = Partition(nums, left, right) // partition around pivot\n    → Decision: If pivotIndex == k-1? // since sorted descending? Actually we want k-th largest, so index = length-k. So compute targetIndex = nums.length - k\n    -> We'll compute targetIndex at start.\n    Step 2: targetIndex = nums.length - k\n...\nWe need to keep logic.\n\nWe will include Partition function separately.\n\nLet's produce steps.\n\nWe also might include min-heap approach. But choose QuickSelect.\n\nWe need virtual code lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Set targetIndex = nums.length - k // 目標索引，k 大元素對應升序索引\n→ Decision: If nums is empty? // 檢查輸入\n    Yes → End // 無元素直接結束\n→ Step 2: Initialize left = 0, right = nums.length - 1 // 搜尋範圍\n→ Decision: While left <= right? // QuickSelect 迴圈\n    Yes → Step 3: pivot = nums[(left + right) // 2] // 取中位作 pivot\n    → Step 4: i = left, j = right // 指標初始化\n    → Step 5: While i <= j? // 進行分區\n        Yes → Decision: If nums[i] > pivot? // 依照 k-th largest 為升序排列的逆序\n            Yes → i = i + 1 // 右移\n            No → Decision: If nums[j] < pivot?\n                Yes → j = j - 1 // 左移\n                No → Step 6: Swap nums[i] and nums[j] // 交換元素\n                → i = i + 1\n                → j = j - 1\n    → Decision: If targetIndex <= j? // 決定搜索哪一側\n        Yes → right = j\n        No  → Decision: If targetIndex >= i?\n            Yes → left = i\n            No  → Step 7: Return nums[targetIndex] // 找到目標元素\n→ End // 程式結束\n\nBut we need to include Step 7 return before exit. Might use End after return.\n\nLet's structure better:\n\nStart // 程式開始執行\n→ Step 1: targetIndex = nums.length - k // 目標索引，k 大元素對應升序索引\n→ Decision: If nums is empty? // 檢查輸入\n    Yes → End // 無元素直接結束\n→ Step 2: left = 0, right = nums.length - 1 // 搜尋範圍\n→ Decision: While left <= right? // QuickSelect 迴圈\n    Yes → Step 3: pivotIndex = Partition(nums, left, right) // 進行分區\n    → Decision: If pivotIndex == targetIndex? // 找到目標\n        Yes → Step 4: Return nums[pivotIndex] // 返回 k-th 大元素\n        No  → Decision: If pivotIndex < targetIndex? // 目標在右側\n            Yes → left = pivotIndex + 1\n            No  → right = pivotIndex - 1\n→ End // 程式結束\n\nDefine Partition:\n\n→ Step 5: Function Partition(nums, left, right) // 分區，返回 pivot 索引\n    → Step 6: pivot = nums[right] // 取右端作 pivot\n    → Step 7: storeIndex = left\n    → Decision: For i from left to right -1? // 遍歷\n        Yes → Decision: If nums[i] > pivot? // 因為想要大元素在左側\n            Yes → Swap nums[i] and nums[storeIndex] // 交換\n            → storeIndex = storeIndex + 1\n    → Step 8: Swap nums[storeIndex] and nums[right] // 把 pivot 放到正確位置\n    → Step 9: Return storeIndex // 返回 pivot 索引\n\nBut need to keep format: each line with \"虛擬碼步驟\" and comment. Use arrow \"→\" before step lines. Indent decisions with \"Decision:\" and Yes/No.\n\nWe'll output with each line as required.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: targetIndex = nums.length - k // 目標索引，k 大元素對應升序索引  \n→ Decision: 如果 nums 為空? // 檢查輸入  \n    Yes → End // 無元素直接結束  \n→ Step 2: left = 0, right = nums.length - 1 // 搜尋範圍  \n→ Decision: While left <= right? // QuickSelect 迴圈  \n    Yes → Step 3: pivotIndex = Partition(nums, left, right) // 進行分區，返回 pivot 索引  \n    → Decision: 如果 pivotIndex == targetIndex? // 找到目標  \n        Yes → Step 4: Return nums[pivotIndex] // 返回 k‑th 大元素，結束程式  \n        No  → Decision: 如果 pivotIndex < targetIndex? // 目標在右側  \n            Yes → left = pivotIndex + 1  \n            No  → right = pivotIndex - 1  \n→ End // 程式結束  \n\nStep 5: Function Partition(nums, left, right) // 分區，返回 pivot 索引  \n    → Step 6: pivot = nums[right] // 取右端作 pivot  \n    → Step 7: storeIndex = left // 用於放置大於 pivot 的元素  \n    → Decision: For i from left to right - 1? // 遍歷左半區  \n        Yes → Decision: 如果 nums[i] > pivot? // 只保留比 pivot 大的元素在左側  \n            Yes → Swap nums[i] 和 nums[storeIndex] // 交換，將較大元素移至左側  \n            → storeIndex = storeIndex + 1  \n    → Step 8: Swap nums[storeIndex] 和 nums[right] // 把 pivot 放到正確位置  \n    → Step 9: Return storeIndex // 返回 pivot 索引，供 QuickSelect 判斷下一步範圍"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "expected_output": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]'\nGot (Norm):      '[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"John\",\"johnnybravo@mail.com\"],[\"Mary\",\"mary@mail.com\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]'\nRaw Got:      \"[['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['John', 'johnnybravo@mail.com'], ['Mary', 'mary@mail.com']]\""
        },
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co'], ['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        res = [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n        res.sort(key=lambda x: x[0])  # sort by name for deterministic order\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Support input format like \"accounts = [...]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        data = expr.strip()\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception:\n        print(\"[]\")\n        return\n\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments explaining. Steps: Build graph mapping email to name and adjacency list. Then DFS/BFS to find connected components. Then gather emails per component, sort, and output with name.\n\nWe need to follow format with Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce step-by-step. Use arrow \"→\" for subsequent steps. Use Decision for condition checks.\n\nLet's craft.\n\nStart\n→ Step 1: 建立 email→name 映射表 and graph adjacency list // 建立電子郵件到姓名的映射以及電子郵件之間的連結\n→ Step 2: 逐筆處理 accounts 列表\n    → Decision: accounts[i] 是否至少有 2 個元素? // 判斷帳號是否包含 email\n        Yes → Step 3: 取得 name = accounts[i][0] // 取帳號擁有者姓名\n            → Step 4: 針對此帳號的每一個 email\n                → Step 5: 將 email 加入 email→name 映射表\n                → Step 6: 若 email 不是第一次出現，將前一個 email 與此 email 連結\n                → Step 7: 若 email 為第一次，初始化 graph[email] 為空集合\n            // 完成此帳號的邊建立\n        No → Step 8: 跳過此帳號 // 若帳號僅含姓名，無需處理\n→ Step 9: 建立 visited 集合 // 用於標記已探索的 email\n→ Step 10: 建立結果列表 accounts_res\n→ Step 11: 逐個 email 做 DFS\n    → Decision: email 是否已訪問? // 判斷是否已處理\n        No → Step 12: 初始化 stack 為 [email]\n            → Step 13: 初始化 component_emails 集合\n            → Step 14: 進行 DFS\n                → Step 15: pop curr_email\n                → Step 16: 將 curr_email 加入 component_emails\n                → Step 17: 對每個鄰居 next_email\n                    → Decision: next_email 是否已訪問? // 避免重複\n                        No → Step 18: 標記已訪問\n                        Yes → Step 19: 跳過\n            → Step 20: 取得 component_name = email_to_name[email] // 取此組的姓名\n            → Step 21: 將 component_emails 轉為列表並排序\n            → Step 22: 建立 merged_account = [component_name] + sorted_emails\n            → Step 23: 加入 merged_account 到 accounts_res\n→ End\n\nWe need to produce each line with \"虛擬碼步驟\" e.g. \"Start\" or \"→ Step 1: ...\". Must include arrow lines and indenting? They used indentation. We'll mimic. Ensure each line ends with \"// 解釋\". We'll write each step.\n\nAlso use Decision with indentation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 email_to_name 映射表與 graph 邊集合 // 用於存放每個 email 所屬姓名與電子郵件之間的連結  \n→ Step 2: 逐筆處理 accounts 列表 // 依序檢視每一個帳號  \n&nbsp;&nbsp;→ Decision: accounts[i] 是否至少有 2 個元素? // 判斷帳號中是否有 email  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: 取 name = accounts[i][0] // 取得帳號擁有者姓名  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: 針對此帳號的每一個 email  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: 若 email 不在 email_to_name 中，則 email_to_name[email] ← name  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: 若 email 在 graph 中不存在，則 graph[email] ← 空集合  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: 若 email 為此帳號的第一個 email，跳過連結建立  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: 將前一個 email prev_email 與此 email 連結，並同樣更新 graph[prev_email]  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step 9: 跳過此帳號 // 只包含姓名的帳號不需要處理  \n→ Step 10: 建立 visited 集合 // 標記已探索過的 email  \n→ Step 11: 建立結果列表 merged_accounts // 儲存合併後的帳號  \n→ Step 12: 逐個 email 執行 DFS  \n&nbsp;&nbsp;→ Decision: email 是否已訪問? // 判斷此 email 是否已屬於某個組  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step 13: 初始化 stack 為 [email] // 開始新的 DFS  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 14: 初始化 component_emails 集合 // 收集同一個人所有 email  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 15: 進行 DFS  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 16: pop curr_email 從 stack  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 17: 將 curr_email 加入 component_emails  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 18: 對每個鄰居 next_email  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: next_email 是否已訪問?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 19: 標記 next_email 為已訪問，並 push 到 stack  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 20: 跳過  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 21: 取得 component_name ← email_to_name[email] // 取此組的姓名  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 22: 將 component_emails 轉為列表並排序 // 依字典序排列 email  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 23: 建立 merged_account ← [component_name] + sorted_emails  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 24: 將 merged_account 加入 merged_accounts  \n→ End // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,0,6,1,4,1,6,4]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 0, 6, 1, 4, 1, 6, 4]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    result = []\n    sol = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            sol = Solution(*args)\n            result.append(None)\n        else:\n            method = getattr(sol, cmd)\n            ret = method(*args)\n            result.append(ret)\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps, each line with explanation. We need to design algorithm: standard solution: map blacklisted numbers < m to allowed numbers >= m. Let m = n - blacklist.length. Preprocess: create hash map of blacklisted numbers < m to a white number >= m. Then pick random r in [0, m-1], if r is in map, return mapped value else r.\n\nWe need virtual code lines: Start, initialization steps, pick method. We need to illustrate algorithm.\n\nWe must not output actual code, just virtual code. Use arrow and decision etc. So structure:\n\nStart\n→ Step: compute m = n - blacklist.length // number of allowed slots\n→ Step: create hash map mapping\n→ Step: for each b in blacklist:\n   Decision: if b < m?\n      Yes → map[b] = find next white number >= m\n      No → ignore\n→ End of constructor\n→ End // constructor done\nThen pick function:\nStart pick\n→ Step: r = random integer [0, m-1]\n→ Decision: if r in map?\n   Yes → return map[r]\n   No → return r\nEnd pick\n\nWe can include helper to find next white number by iterating from m upward until not blacklisted.\n\nNeed to include virtual code lines with explanation. Use arrow (→) and indent for decisions. Use Yes →, No →.\n\nWe must not output actual code, just steps.\n\nLet's craft step by step lines.\n\nUse Step numbers maybe.\n\nAlso need to use `Decision:` for decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step: 初始化 m = n - blacklist.length // 允許數字的個數\n→ Step: 建立空的映射表 map // 用於將被封鎖的數字映射到合法數字\n\n→ Decision: 為每個 b in blacklist\n    // 逐一檢查黑名單\n    Yes → Step: 如果 b < m?\n        Decision: 是嗎？\n            Yes → Step: 尋找最小的合法數字 >= m 且不在 blacklist，並設定 map[b] = 該數字\n            No  → Step: 無需映射，因為 b 已在後面處理\n    No  → Step: 這個b不在 [0, m-1] 範圍內，直接忽略\n\nEnd // 構造完成\n\nNow pick function:\n\nStart // pick 方法開始\n→ Step: r = 隨機整數 [0, m-1] // 從允許的索引範圍內挑選\n→ Decision: r 是否存在於 map?\n    Yes → Step: 返回 map[r] // 對應的合法數字\n    No  → Step: 返回 r // r 本身已合法\n\nEnd // pick 方法結束\n\nBut must be in virtual code lines with arrow. We need to maintain structure: Start, →, Decision, Yes →, No →.\n\nLet's produce final answer accordingly. Ensure each line has explanation after //. Also maintain indentation properly. Use `→` after `Start`. Use `Decision:`, `Yes →`, `No →`. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 計算 m = n - blacklist.length // 允許數字的個數  \n→ Step: 建立空映射表 map // 用於將被封鎖的數字映射到合法數字  \n\n→ Decision: 逐一遍歷 blacklist 中的每個 b  \n    Yes → Step: 判斷 b 是否小於 m // 只需處理 [0, m-1] 範圍內的黑名單  \n        Yes → Step: 找到最小的合法數字 x >= m，且 x 不在 blacklist // 迭代 m, m+1, …  \n        No  → Step: 無需映射，因為 b 已在後面處理  \n    No  → Step: b 位於 [m, n-1] 範圍，直接忽略  \n\nEnd // 構造函式結束  \n\nStart // pick 方法開始  \n→ Step: 產生隨機整數 r ∈ [0, m-1] // 從允許的索引範圍內挑選  \n→ Decision: r 是否存在於 map？  \n    Yes → Step: 返回 map[r] // 對應的合法數字  \n    No  → Step: 返回 r // r 本身已合法  \n\nEnd // pick 方法結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.60815,0.16451],[-0.73349,0.12741],[-0.30088,0.35040]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.60815, 0.16451], [-0.73349, 0.12741], [-0.30088, 0.35040]]'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    obj = None\n    outputs = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)\n        else:\n            method = getattr(obj, cmd)\n            result = method(*args)\n            outputs.append(result)\n\n    # Format output as required\n    out_str = '['\n    for i, val in enumerate(outputs):\n        if i > 0:\n            out_str += ', '\n        if val is None:\n            out_str += 'null'\n        elif isinstance(val, list):\n            out_str += '[' + ', '.join(f'{x:.5f}' for x in val) + ']'\n        else:\n            out_str += str(val)\n    out_str += ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for this problem. It's about generating random point uniformly inside circle. Use rejection sampling or transform polar coordinates with sqrt. Let's outline steps: initialize radius, center. randPoint: generate random r uniformly in [0, radius] but need sqrt for area distribution; generate angle uniformly [0,2π]; compute x = center_x + r * cos(theta); y = center_y + r * sin(theta); return [x,y]. That's straightforward. Provide line by line pseudocode with arrows and explanation.\n\nThe format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision if needed. Might include a loop? Not necessary because each call independent. But we could mention \"random number generation\".\n\nLet's produce code structure:\n\nStart // program start\n→ Step 1: Initialize Solution with radius, x_center, y_center // store parameters\n→ End // constructor end\n→ Step 2: randPoint() // method to generate point\n    → Step 3: Generate random double t in [0,1] // random number\n    → Step 4: Compute r = radius * sqrt(t) // adjust for area\n    → Step 5: Generate random double u in [0,1] // for angle\n    → Step 6: Compute theta = 2 * π * u // random angle\n    → Step 7: x = x_center + r * cos(theta) // compute x coordinate\n    → Step 8: y = y_center + r * sin(theta) // compute y coordinate\n    → Step 9: Return [x, y] // output point\nEnd // program end\n\nBut need arrow lines. Might use indentation? The example shows arrow at start of each line. Use \"→\" for steps. For nested steps, maybe indent. Use no nested Decision needed. Use \"Start\" and \"End\". Provide explanation after each line.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution，接收參數 radius、x_center、y_center // 初始化圓的半徑與中心座標\n→ End // 建構子結束\n→ Step 2: randPoint() 方法開始 // 生成隨機點的入口\n    → Step 3: 產生隨機數 t ∈ [0,1] // 用於調整半徑的分佈\n    → Step 4: 計算 r = radius * √t // r 的分佈使點均勻分佈於圓面積\n    → Step 5: 產生隨機數 u ∈ [0,1] // 用於角度的隨機化\n    → Step 6: 計算 θ = 2π * u // 角度均勻分佈於 0~2π\n    → Step 7: 計算 x = x_center + r * cos(θ) // 根據極座標計算 X 坐標\n    → Step 8: 計算 y = y_center + r * sin(θ) // 根據極座標計算 Y 坐標\n    → Step 9: 回傳 [x, y] // 返回隨機點的座標\nEnd // 程式結束執行"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '9'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '9'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '1989'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '1989'"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # Precompute next and previous occurrence arrays\n    next_pos = [[n] * 26 for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        next_pos[i] = next_pos[i + 1][:]          # copy the list\n        next_pos[i][ord(s[i]) - 97] = i\n\n    prev_pos = [[-1] * 26 for _ in range(n)]\n    for i in range(n):\n        if i > 0:\n            prev_pos[i] = prev_pos[i - 1][:]\n        prev_pos[i][ord(s[i]) - 97] = i\n\n    # DP table\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        dp[i][i] = 1  # single character\n\n    for length in range(2, n + 1):  # substring length\n        for l in range(0, n - length + 1):\n            r = l + length - 1\n            if s[l] == s[r]:\n                c = ord(s[l]) - 97\n                low = next_pos[l + 1][c]      # first same char after l\n                high = prev_pos[r - 1][c]     # last same char before r\n\n                if low > high:          # no same char inside\n                    val = dp[l + 1][r] + dp[l][r - 1] + 1\n                elif low == high:       # exactly one same char inside\n                    val = dp[l + 1][r] + dp[l][r - 1] + 1\n                else:                   # more than one same char inside\n                    val = dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1] + 1\n            else:                       # first and last char differ\n                val = dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1]\n\n            dp[l][r] = val % MOD\n\n    return dp[0][n - 1] % MOD\n\n\ndef parse_input(data: str) -> str:\n    data = data.strip()\n    # Handle format like: s = \"bccb\"\n    if data.startswith('s ='):\n        # Find the first and last double quotes\n        first_quote = data.find('\"')\n        last_quote = data.rfind('\"')\n        if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n            return data[first_quote + 1:last_quote]\n    # Remove surrounding quotes if present\n    if data.startswith('\"') and data.endswith('\"'):\n        return data[1:-1]\n    return data\n\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = count_palindromic_subsequences(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for the problem: count distinct non-empty palindromic subsequences modulo 1e9+7. Provide step-by-step virtual code with explanations. Must use Start, End, Decision. Use arrows.\n\nWe need to outline algorithm: typical DP for counting distinct palindromic subsequences: dp[l][r] count for substring s[l..r]. Recurrence: if s[l] == s[r], then dp[l][r] = dp[l+1][r] + dp[l][r-1] + 1; else dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]. But need handle duplicates to avoid overcounting: use next/prev arrays or track next occurrence of each char. Standard solution: Use dp, and nextPos, prevPos arrays to adjust.\n\nBut we just need pseudocode; can describe algorithm at high level.\n\nWe produce lines:\n\nStart\n→ Read string s\n→ n = length of s\n→ Initialize 2D array dp[n][n] to 0\n→ Precompute next occurrence for each index and character: next[i][c] = next index > i with char c; similarly prev[i][c] = previous index < i with char c\n→ For i from 0 to n-1: dp[i][i] = 1 // single char palindrome\n→ For length from 2 to n:\n    → For l from 0 to n-length:\n        → r = l+length-1\n        → If s[l] == s[r]:\n            → nxt = next[l][s[l]] // next occurrence of s[l] after l\n            → prv = prev[r][s[r]] // previous occurrence of s[r] before r\n            → If nxt > prv:\n                → dp[l][r] = (dp[l+1][r] + dp[l][r-1] + 1) mod M\n            → Else if nxt == prv:\n                → dp[l][r] = (dp[l+1][r] + dp[l][r-1] + 1) mod M\n            → Else:\n                → dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1] + 1) mod M\n        → Else:\n            → dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]) mod M\n→ Result = dp[0][n-1] mod M\n→ Output result\nEnd\n\nNeed to include comments and decision branches. Use Decision: If s[l]==s[r] ?\n\nWe need to produce each line with \"→ Step ...\" and comment.\n\nAlso need to include decisions: Decision: s[l] == s[r]? etc. Use Yes→ and No→.\n\nLet's produce.\n\nAlso incorporate precomputation steps.\n\nOk.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Read string s // 取得輸入字串  \n→ n = length of s // 字串長度  \n→ M = 1_000_000_007 // 取餘數的模數  \n\n→ Initialize 2D array dp[n][n] with 0 // dp[l][r] 將存放 s[l..r] 的不同回文子序列數  \n→ For i from 0 to n-1: dp[i][i] = 1 // 單個字元本身就是回文  \n\n// ---------- 預處理下標 ----------  \n→ Initialize 2D array next[n][26] with n // next[i][c] 代表在 i 之後第一次出現字元 c 的位置，若不存在則為 n  \n→ Initialize 2D array prev[n][26] with -1 // prev[i][c] 代表在 i 之前最後一次出現字元 c 的位置，若不存在則為 -1  \n\n→ For i from n-1 downto 0:  \n    → For c from 0 to 25: next[i][c] = next[i+1][c]  \n    → next[i][s[i]-'a'] = i // 更新目前位置的字元  \n\n→ For i from 0 to n-1:  \n    → For c from 0 to 25: prev[i][c] = prev[i-1][c]  \n    → prev[i][s[i]-'a'] = i // 更新目前位置的字元  \n\n// ---------- DP 計算 ----------  \n→ For len from 2 to n: // 子字串長度  \n    → For l from 0 to n-len:  \n        → r = l + len - 1 // 子字串結尾索引  \n\n        → Decision: s[l] == s[r]? // 判斷首尾字元是否相同  \n            Yes → // 首尾相同  \n                → nxt = next[l][s[l]-'a'] // 下一個相同字元的位置  \n                → prv = prev[r][s[r]-'a'] // 上一個相同字元的位置  \n\n                → Decision: nxt > prv? // 是否只出現一次或無重複  \n                    Yes → // 只出現一次或沒有重複  \n                        → dp[l][r] = (dp[l+1][r] + dp[l][r-1] + 1) mod M  \n                    No → Decision: nxt == prv? // 出現恰好兩次  \n                        Yes → // 恰好兩次，仍需加 1  \n                            → dp[l][r] = (dp[l+1][r] + dp[l][r-1] + 1) mod M  \n                        No → // 出現兩次以上  \n                            → dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1] + 1) mod M  \n            No → // 首尾不同  \n                → dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]) mod M  \n\n// ---------- 結果 ----------  \n→ Result = dp[0][n-1] mod M // 整個字串的答案  \n→ Output Result // 輸出答案  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptpy24j9w.py\", line 75, in <module>\n    main()\n  File \"/tmp/tmptpy24j9w.py\", line 54, in main\n    args_list = json.loads(parts[1])\n                ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 28 (char 27)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"用於隨機洗牌的解法。\"\"\"\n\n    def __init__(self, nums):\n        \"\"\"\n        初始化時保留原始陣列與一個可變副本。\n        :param nums: 原始整數陣列\n        \"\"\"\n        # 原始陣列的深複製，供 reset 使用\n        self.original = list(nums)\n        # 目前的陣列，會在 shuffle 時被改變\n        self.current = list(nums)\n\n    def reset(self):\n        \"\"\"\n        將陣列重設為原始順序。\n        :return: 重設後的陣列\n        \"\"\"\n        self.current = list(self.original)\n        return self.current\n\n    def shuffle(self):\n        \"\"\"\n        隨機洗牌（Fisher‑Yates 演算法）。\n        :return: 洗牌後的陣列\n        \"\"\"\n        n = len(self.current)\n        for i in range(n):\n            # 產生從 i 到 n-1 的隨機整數\n            j = random.randint(i, n - 1)\n            # 交換 i 與 j 的元素\n            self.current[i], self.current[j] = self.current[j], self.current[i]\n        return self.current\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，預期為兩行：方法名稱列表與對應參數列表\n    parts = data.splitlines()\n    if len(parts) == 1:\n        # 有些測試會把兩個列表放在同一行，用逗號分隔\n        parts = parts[0].split('],', 1)\n        if len(parts) == 2:\n            parts[0] = parts[0] + ']'\n            parts[1] = '[' + parts[1]\n    commands = json.loads(parts[0])\n    args_list = json.loads(parts[1])\n\n    outputs = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # args 為 [[1,2,3]]，取第一個元素作為陣列\n            obj = Solution(args[0])\n            outputs.append(None)\n        elif cmd == \"reset\":\n            outputs.append(obj.reset())\n        elif cmd == \"shuffle\":\n            outputs.append(obj.shuffle())\n        else:\n            # 若出現未知方法，直接忽略或可改成錯誤處理\n            outputs.append(None)\n\n    # 使用 json.dumps 以符合題目期望的 null 表示\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem. We need to output line by line with \"虛擬碼步驟\" and explanation. Use arrow. Provide steps for Solution class with constructor, reset, shuffle, using Fisher-Yates algorithm. Should be step by step.\n\nWe need to format:\n\nStart\n→ Step 1...\nUse Decision etc.\n\nProbably break into main functions. Provide overall algorithm. Provide steps for constructor: store original array copy, store working array.\n\nReset: return original copy.\n\nShuffle: copy original into temp, then for i from 0 to n-1, pick random j from i to n-1, swap.\n\nWe need to use 虛擬碼 arrows. Example: \"→ Step: ...\" and comments.\n\nWe need to not output actual code. Just structure.\n\nLet's produce:\n\nStart // start program\n\n→ Step: 初始化 Solution // store original array\n\n→ Step: 保存原始副本 // keep copy\n\n→ Step: 初始化工作陣列 // maybe same as original\n\nEnd? Might end after constructor. But we need to show functions separately.\n\nWe might structure as separate blocks for each method. Use \"Start\", \"End\" for each method? Could.\n\nMaybe: \"Start // Solution class\" then \"→ Constructor\" block, \"→ reset method\", \"→ shuffle method\". Use Decision inside shuffle: \"Decision: if i < n-1\".\n\nBetter produce linear pseudo-steps for algorithm inside shuffle. For each iteration, random j and swap.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 建立 Solution 物件並傳入整數陣列 nums // 接收使用者提供的原始陣列\n→ Step: 產生原始陣列的複本 originalCopy ← nums 的深複製 // 保留原始順序以供 reset 使用\n→ Step: 產生工作陣列 currentArray ← nums 的深複製 // 之後在 shuffle 時操作此陣列\n→ Step: 將 originalCopy 與 currentArray 存入物件屬性 // 方便 reset 與 shuffle 之後取得\nEnd // 建構完成\n\nStart // reset 方法執行流程\n→ Step: 將 currentArray 設為 originalCopy 的複製 // 回復原始順序\n→ Step: 回傳 currentArray // 供呼叫者取得重置後的陣列\nEnd // reset 完成\n\nStart // shuffle 方法執行流程\n→ Step: 取得陣列長度 n ← currentArray 的長度 // 用於迴圈計算\n→ Decision: n 是否大於 0? // 若陣列為空則直接回傳\n    Yes → Step: 設定 i ← 0 // 從第一個索引開始\n    No  → Step: 回傳 currentArray // 空陣列不做處理\n→ Step: 開始 for 迴圈 while i < n-1 // 只要還有未處理元素就繼續\n    → Step: 產生隨機索引 j ← i 到 n-1 之間的整數 // Fisher‑Yates 隨機選取\n    → Step: 交換 currentArray[i] 與 currentArray[j] // 進行一次交換\n    → Step: i ← i + 1 // 移至下一個位置\n→ Step: 回傳 currentArray // 取得隨機排列\nEnd // shuffle 完成"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            # 把目前的子集加入結果\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                # 先把 nums[i] 加到子集中\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                # 回溯，把剛剛加入的元素移除\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 去除可能存在的 \"nums =\" 前綴\n    if data.lower().startswith(\"nums\"):\n        idx = data.find(\"[\")\n        if idx != -1:\n            data = data[idx:]\n\n    # 解析成 Python 列表\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        nums = []\n\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of a unique integer array. Use typical backtracking. Provide line by line with arrow.\n\nWe must obey output format: each line \"虛擬碼步驟 // 解釋\".\n\nLet's produce steps: Start, → Step 1: define result list, etc. Use Decision nodes. Provide arrow arrows with Yes/No. Use virtual arrow notation.\n\nLet's produce.\n\nWe must not output actual code. Just structure.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告 result 為空集合 // 用來儲存所有子集  \n→ Step 2: 呼叫 Backtrack(0, []) // 從索引0開始進行回溯  \n→ Decision: index 是否已經到達 nums 長度？ // 判斷是否已經處理完所有元素  \n    Yes → Step 3: 加入 current 到 result // 把目前的子集加入結果  \n    No  → Step 4: 執行選擇不包含 nums[index] 的分支 // 先不把當前元素加入子集  \n        → Step 5: Backtrack(index+1, current) // 進入下一個索引  \n    No  → Step 6: 執行選擇包含 nums[index] 的分支 // 把當前元素加入子集  \n        → Step 7: Backtrack(index+1, current + nums[index]) // 進入下一個索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Largest Palindrome Product",
      "source_file": "Leetcode/leetcode479.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "987",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '987'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '987'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\n\ndef is_palindrome(num: int) -> bool:\n    \"\"\"Check if an integer is a palindrome.\"\"\"\n    s = str(num)\n    return s == s[::-1]\n\ndef largest_palindrome(n: int) -> int:\n    \"\"\"\n    Find the largest palindromic product of two n‑digit numbers,\n    and return the result modulo 1337.\n    \"\"\"\n    # Special case for single digit\n    if n == 1:\n        return 9\n\n    max_num = 10**n - 1          # largest n‑digit number\n    min_num = 10**(n - 1)        # smallest n‑digit number\n\n    # For efficient search, generate palindromes in descending order\n    half_len = (n + 1) // 2      # length of the first half of the palindrome\n    max_half = 10**half_len - 1\n    min_half = 10**(half_len - 1)\n\n    for half in range(max_half, min_half - 1, -1):\n        half_str = str(half)\n        if n % 2 == 0:\n            # Even length: mirror the whole half\n            pal = int(half_str + half_str[::-1])\n        else:\n            # Odd length: mirror all but the last digit of the half\n            pal = int(half_str + half_str[-2::-1])\n\n        # Check if this palindrome can be factored into two n‑digit numbers\n        for a in range(max_num, min_num - 1, -1):\n            if pal % a == 0:\n                b = pal // a\n                if min_num <= b <= max_num:\n                    return pal % 1337\n            # Optional early break: if a*a < pal, no larger factor pair is possible\n            if a * a < pal:\n                break\n\n    # If no palindrome found (should not happen for n >= 1)\n    return 0\n\ndef main() -> None:\n    \"\"\"\n    Reads an integer n from standard input and prints the largest\n    palindromic product of two n‑digit numbers modulo 1337.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # Extract the first integer found in the input\n    n = None\n    for token in data.replace(',', ' ').split():\n        if token.isdigit():\n            n = int(token)\n            break\n    if n is None:\n        return\n    result = largest_palindrome(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, for algorithm to compute largest palindromic product of two n-digit integers, modulo 1337. But must be step-by-step pseudocode not actual code. Use Start, End, Decision etc. Should be concise but enough. Let's design:\n\n- Determine max n-digit number: 10^n - 1.\n- Determine min n-digit number: 10^(n-1).\n- Iterate i from max down to min.\n- For j from i down to min: product = i*j; if product <= current max break maybe, but we can early break.\n- Check palindrome: convert to string or numeric reverse. Since no code, just step: Check if product is palindrome.\n- Keep track of max palindrome.\n- After loops, return max mod 1337.\n\nWe need to present in steps, with decision branches. Use \"Decision:\" and arrow. Include comments.\n\nAlso need to incorporate optimization: iterate descending, break when product < max. Also early break when product <= current max maybe.\n\nWe should include modulo at end.\n\nLet's produce:\n\nStart\n→ Step 1: 計算最大 n 位數 maxNum = 10^n - 1\n→ Step 2: 計算最小 n 位數 minNum = 10^(n-1)\n→ Step 3: 初始化 maxPalindrome = 0\n→ Step 4: 迴圈 i 從 maxNum 下降到 minNum\n    → Step 5: 迴圈 j 從 i 下降到 minNum\n        → Decision: 如果 i*j 小於等於 maxPalindrome? // 如果已經小於已知最大，則跳出內層迴圈\n            Yes → Break inner loop // 內層結束\n            No  → Decision: i*j 是否為回文? // 檢查乘積是否為回文\n                Yes → Step 6: 更新 maxPalindrome = i*j\n                No  → Continue\n→ Step 7: 回傳 maxPalindrome mod 1337\nEnd\n\nWe might include function to check palindrome using reverse. But okay.\n\nAdd comments.\n\nLet's output in required format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算最大 n 位數 maxNum = 10^n - 1 // 取得最大的 n 位整數  \n→ Step 2: 計算最小 n 位數 minNum = 10^(n-1) // 取得最小的 n 位整數  \n→ Step 3: 初始化 maxPalindrome = 0 // 用於儲存目前找到的最大回文積  \n→ Step 4: 迴圈 i 從 maxNum 下降到 minNum  \n → Step 5: 迴圈 j 從 i 下降到 minNum  \n  → Decision: 如果 i*j 小於等於 maxPalindrome? // 已經無法得到更大的回文  \n   Yes → Break // 結束內層迴圈  \n   No → Decision: i*j 是否為回文? // 檢查乘積是否為回文數  \n    Yes → Step 6: 更新 maxPalindrome = i*j // 取得更大的回文  \n    No → Continue // 仍在內層迴圈  \n→ Step 7: 回傳 maxPalindrome mod 1337 // 將結果取模 1337  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array II",
      "source_file": "Leetcode/leetcode80.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[1,1,2,2,3,_]'\nGot (Norm):      '4,nums=[1,1,2,3,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [1,1,2,2,3,_]'\nRaw Got:      '4, nums = [1,1,2,3,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        # 沒有元素直接回傳 0\n        if not nums:\n            return 0\n        k = 0  # 寫入指標\n        for i in range(len(nums)):\n            # 如果是第 3 個以上且與第 2 個前的相同，就跳過\n            if i >= 2 and nums[i] == nums[i - 2]:\n                continue\n            nums[k] = nums[i]\n            k += 1\n        return k\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中抓取列表，例如 'nums = [1,1,1,2,2,3]'\n    match = re.search(r'\\[(.*?)\\]', data)\n    if match:\n        nums_str = '[' + match.group(1) + ']'\n        # 使用 eval 解析列表，對於測試環境可接受\n        nums = eval(nums_str)\n    else:\n        nums = []\n\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # 產生輸出列表，後面用 '_' 做占位\n    output_nums = nums[:k] + ['_'] * (len(nums) - k)\n    # 轉成字串，避免 underscore 被轉成 \"'_'\"\n    list_str = '[' + ','.join(str(x) if x != '_' else '_' for x in output_nums) + ']'\n    print(f\"{k}, nums = {list_str}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for the problem \"Remove Duplicates from Sorted Array II\" (LeetCode 80). Provide step-by-step pseudocode with explanation comments, using arrow syntax, decisions etc. Each line has \"虛擬碼步驟 // 解釋\". We must not produce actual code. Use \"Start\", \"End\", \"Decision:\" etc.\n\nLet's produce a line-by-line plan:\n\n1. Start\n2. Initialize write pointer (k) to 0\n3. Iterate through array with read pointer i from 0 to len-1\n4. Decision: if i >=2 and nums[i]==nums[i-2]?\n   Yes → skip (duplicate too many)\n   No → copy nums[i] to nums[k], increment k\n5. End\n\nBut maybe need to handle initial positions i<2 automatically.\n\nThus, pseudocode:\n\nStart\n→ Set k = 0 // write index\n→ For i from 0 to len(nums)-1 // read index\n    Decision: 如果 i >= 2 且 nums[i] == nums[i-2]?\n        Yes → // 超過兩個相同元素，跳過\n        No → nums[k] = nums[i]; k = k + 1 // 放入結果\n→ Return k // 最後有效長度\nEnd\n\nBut we need each line as \"虛擬碼步驟 // 解釋\". Also \"Decision:\" lines. Need to indent.\n\nLet's produce:\n\nStart // 程式開始\n→ Decision: 若 nums 為空? // 檢查是否有元素\n    Yes → End // 空陣列直接結束\n    No → \n→ Set k = 0 // 建立寫入指標\n→ For i = 0 to len(nums)-1 // 逐個讀取元素\n    Decision: 如果 i >= 2 且 nums[i] == nums[i-2]? // 判斷是否超過兩個相同\n        Yes → // 超過兩個相同，跳過不寫入\n        No → nums[k] = nums[i]; k = k + 1 // 複製元素並遞增寫指標\n→ Return k // 回傳有效長度\nEnd // 程式結束\n\nBut need arrow for decision inside for loop. Also need indentation.\n\nWe'll format with indentation by spaces? Use tabs? The example uses indentation with spaces.\n\nSo:\n\nStart // 程式開始\n→ Decision: 若 nums 為空? // 檢查是否有元素\n    Yes → End // 空陣列直接結束\n    No  → \n→ Set k = 0 // 建立寫入指標\n→ For i = 0 to len(nums)-1 // 逐個讀取元素\n    Decision: 如果 i >= 2 且 nums[i] == nums[i-2]? // 判斷是否超過兩個相同\n        Yes → // 超過兩個相同，跳過不寫入\n        No  → nums[k] = nums[i]; k = k + 1 // 複製元素並遞增寫指標\n→ Return k // 回傳有效長度\nEnd // 程式結束\n\nMake sure each line ends with \"// 解釋\". Provide arrow and indentation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Decision: 若 nums 為空? // 檢查是否有元素\n    Yes → End // 空陣列直接結束\n    No  → \n→ Set k = 0 // 建立寫入指標\n→ For i = 0 to len(nums)-1 // 逐個讀取元素\n    Decision: 如果 i >= 2 且 nums[i] == nums[i-2]? // 判斷是否超過兩個相同\n        Yes → // 超過兩個相同，跳過不寫入\n        No  → nums[k] = nums[i]; k = k + 1 // 複製元素並遞增寫指標\n→ Return k // 回傳有效長度\nEnd // 程式結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Multiply two non‑negative integer strings without using built‑in big integer conversion.\n        \"\"\"\n        # Special case: if either number is zero\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        # Result can be at most m + n digits\n        pos = [0] * (m + n)\n\n        # Grade‑school multiplication\n        for i in range(m - 1, -1, -1):\n            a = ord(num1[i]) - 48  # digit value of num1[i]\n            for j in range(n - 1, -1, -1):\n                b = ord(num2[j]) - 48  # digit value of num2[j]\n                mul = a * b\n                p1, p2 = i + j, i + j + 1\n\n                # Add mul to the current position, including carry\n                sum_ = mul + pos[p2]\n                pos[p2] = sum_ % 10\n                pos[p1] += sum_ // 10\n\n        # Convert digits to string and strip leading zeros\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read()\n    # Extract all digit sequences (handles inputs like: num1 = '123', num2 = '456')\n    numbers = re.findall(r'\\d+', data)\n    if len(numbers) < 2:\n        # Fallback: if input is two separate lines with numbers\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            num1 = lines[0].strip()\n            num2 = lines[1].strip()\n        else:\n            # Not enough data\n            return\n    else:\n        num1, num2 = numbers[0], numbers[1]\n\n    solution = Solution()\n    product = solution.multiply(num1, num2)\n    print(product)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code for multiplication of large numbers represented as strings without BigInteger conversion. The algorithm typical is grade school multiplication: for each digit in num2, multiply num1 by digit, shift, add. Or use array to store intermediate products.\n\nWe need to output line by line with the format:\n\n虛擬碼步驟 // 解釋\n\nUsing arrow lines.\n\nInclude Start, End, Decision, etc.\n\nWe need to avoid actual code, just pseudocode.\n\nLet's produce the algorithm:\n\nStart\n→ Step: Initialize result array of length len(num1)+len(num2) with zeros // store partial sums\n→ For i from len(num1)-1 down to 0: // iterate over digits of num1\n    → For j from len(num2)-1 down to 0: // iterate over digits of num2\n        → Compute product = (digit(num1,i)-'0') * (digit(num2,j)-'0')\n        → Compute sum = product + result[i+j+1] // add existing value at position\n        → Set result[i+j+1] = sum % 10 // store digit\n        → Carry = sum / 10\n        → Add carry to result[i+j] // carry to next position\n→ After loops, convert result array to string, skip leading zeros\n→ If string empty, return \"0\" else return string\nEnd\n\nNeed decisions for skip zeros.\n\nAlso decision: if result string empty -> \"0\" else result.\n\nLet's format lines with \"→\" and indentation for nested loops. Use Decision: for condition.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 初始化一個長度為 len(num1)+len(num2) 的整數陣列 result，全部設為 0 // 用來累積各位相乘結果\n→ For i = len(num1)-1 downto 0: // 從 num1 的最低位往高位遍歷\n    → For j = len(num2)-1 downto 0: // 從 num2 的最低位往高位遍歷\n        → 取得 a = num1[i] 的數字值 // 轉換字元為數字\n        → 取得 b = num2[j] 的數字值 // 轉換字元為數字\n        → 计算 product = a * b // 单位相乘\n        → 计算 sum = product + result[i+j+1] // 与现有进位结果相加\n        → 设 result[i+j+1] = sum % 10 // 存下个位\n        → 设 carry = sum / 10 // 取出进位\n        → 设 result[i+j] += carry // 加到前一位\n    → End For // 内层循环结束\n→ End For // 外层循环结束\n→ Step: 将 result 数组转成字符串，跳过前导零 // 构造最终乘积字符串\n    → Decision: 结果字符串为空? // 检查是否全为零\n        Yes → Step: 返回 \"0\" // 乘积为零时直接返回\n        No  → Step: 返回结果字符串 // 正常乘积返回\nEnd // 程式執行結束"
    }
  ]
}