{
  "run_index": 49,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 399,
  "generation_or_validation_failure_count": 40,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[5,3,2,6,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[5, 3, 2, 6, 4]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳結果列表\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    \"\"\"從標準輸入讀取程式碼並執行\"\"\"\n    code = sys.stdin.read()\n    # 執行讀入的程式碼，允許像 'print(roll_dice(5))' 這樣的輸入\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrow symbol, start, end, decision. Need to include random module. Function roll_dice(n). Simulate n times 6-sided die, return list of results. Should define function, import random, loop n times append random.randint(1,6) to list, return list.\n\nUse virtual code, no actual code. Provide step-by-step.\n\nUse Start, End. Use arrows: \"→\" etc.\n\nLet's produce.\n\nLine 1: Start // 程式開始執行\nLine 2: → Import random module // 引入 random 模組\nLine 3: → Function roll_dice(n): // 定義 roll_dice 函式，接受擲骰次數\nLine 4: → Decision: 參數 n 是否為非負整數? // 檢查 n 是否有效\nLine 5: Yes → Step: results = [] // 建立空串列儲存結果\nLine 6: Yes → Step: for i in range(n): // 循環 n 次\nLine 7: → Step: result = random.randint(1,6) // 擲一顆六面骰\nLine 8: → Step: results.append(result) // 將結果加入串列\nLine 9: → Step: return results // 回傳所有結果\nLine 10: No → Step: raise ValueError('n must be non-negative integer') // n 無效時拋出錯誤\nLine 11: End // 程式執行結束\n\nNeed arrow for decisions: \"Decision: ...\" then indent sub-steps: \"Yes →\", \"No →\". We need consistent indentation.\n\nLet's format exactly as per example: Use \"Decision:\" and indent steps under Yes/No.\n\nThus:\n\nStart // 程式開始執行\n→ Import random module // 引入 random 模組\n→ Function roll_dice(n): // 定義函式\n→ Decision: n 是否為非負整數? // 檢查 n\n    Yes → Step: results = [] // 初始化結果串列\n    Yes → Step: for i in range(n): // 迴圈 n 次\n        → Step: result = random.randint(1,6) // 擲骰\n        → Step: results.append(result) // 加入結果\n    Yes → Step: return results // 回傳\n    No  → Step: raise ValueError('n must be non-negative integer') // 錯誤處理\nEnd // 程式結束\n\nNeed to use \"→\" at each step. For Decision we can write \"Decision:\" line with indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random module // 引入 random 模組  \n→ Function roll_dice(n): // 定義 roll_dice 函式，接受擲骰次數  \n→ Decision: n 是否為非負整數? // 檢查參數 n 是否有效  \n Yes → Step: results = [] // 初始化空串列儲存結果  \n Yes → Step: for i in range(n): // 迴圈 n 次擲骰  \n  → Step: result = random.randint(1,6) // 擲一顆六面骰  \n  → Step: results.append(result) // 將結果加入串列  \n Yes → Step: return results // 回傳所有結果  \n No  → Step: raise ValueError('n must be non-negative integer') // n 無效時拋出錯誤  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func 執行所需秒數，並回傳四捨五入到小數點 3 位的結果。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取 stdin 裡的程式碼，執行並讓其中的 print 直接輸出到 stdout。\n    \"\"\"\n    code = sys.stdin.read()          # 讀取所有輸入\n    namespace = {'measure_time': measure_time}\n    exec(code, namespace)            # 執行輸入的程式碼\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation, per specification. We need to implement measure_time(func, *args) that uses time module to measure execution time and return result rounded to 3 decimal places.\n\nWe need to produce Start, End, Steps with arrows and decisions if needed. The function will be:\n\n- Import time module\n- Define measure_time(func, *args)\n- Start time = time.time()\n- result = func(*args)\n- End time = time.time()\n- elapsed = end - start\n- return round(elapsed, 3), result? The requirement says \"回傳結果\" but maybe return elapsed? Actually measure_time returns time? Wait: \"用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。\" Means return the time in seconds rounded to 3 decimal. So only elapsed.\n\nSo the function will return elapsed.\n\nWe need to produce code lines with virtual code arrows. We can include import statement as a step.\n\nLet's craft.\n\nStart // 程式開始\n→ Step 1: Import time module // 引入 time\n→ Step 2: Define function measure_time(func, *args) // 定義測量函數\n→ Inside function:\n    → Step 3: start_time ← time.time() // 記錄開始時間\n    → Step 4: result ← func(*args) // 執行傳入函數\n    → Step 5: end_time ← time.time() // 記錄結束時間\n    → Step 6: elapsed ← end_time - start_time // 計算耗時\n    → Step 7: rounded_elapsed ← round(elapsed, 3) // 四捨五入到3位小數\n    → Decision: 是否有錯誤? // 可以簡單忽略\n        Yes → Step 8: raise // not needed\n        No → Step 9: return rounded_elapsed // 回傳耗時\n→ End // 程式結束\n\nBut we need arrow formatting. Use `→` for steps. For decisions, use `Decision:`. Use indent lines for nested steps maybe.\n\nWe need to produce one line per step.\n\nWe need to embed code and comment.\n\nLet's craft each line:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 引入 time 库\n→ Step 2: Define function measure_time(func, *args) // 定義測量執行時間的函數\n→ Inside function: // 進入函數體\n    → Step 3: start_time ← time.time() // 取得當前時間作為開始時間\n    → Step 4: result ← func(*args) // 執行傳入的函數並傳遞所有參數\n    → Step 5: end_time ← time.time() // 取得結束時間\n    → Step 6: elapsed ← end_time - start_time // 計算執行時間差\n    → Step 7: rounded_elapsed ← round(elapsed, 3) // 四捨五入到小數點 3 位\n    → Decision: 是否需要處理異常? // 如果 func 可能拋出異常，可加 try/except（此處簡化不處理）\n        Yes → Step 8: raise // 直接拋出異常\n        No  → Step 9: return rounded_elapsed // 回傳經過四捨五入的秒數\nEnd // 程式執行結束\n\nBut they may want `→ Step X` lines not inside comment. The format example uses \"→ Step 1: ...\". For nested steps, maybe we just indent.\n\nBetter to keep each line as separate with arrow or decision. For nested inside function, we can just indent with spaces.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 引入 time\n→ Step 2: Define function measure_time(func, *args) // 定義測量執行時間的函數\n→ Inside function // 進入函數體\n    → Step 3: start_time ← time.time() // 取得開始時間\n    → Step 4: result ← func(*args) // 執行函數\n    → Step 5: end_time ← time.time() // 取得結束時間\n    → Step 6: elapsed ← end_time - start_time // 計算耗時\n    → Step 7: rounded_elapsed ← round(elapsed, 3) // 四捨五入到3位小數\n    → Decision: 是否需要處理異常? // 簡化不處理\n        Yes → Step 8: raise // 直接拋出\n        No  → Step 9: return rounded_elapsed // 回傳時間\nEnd // 程式結束\n\nBut we might not need decision step. We can omit decision.\n\nSimpler:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 引入 time\n→ Step 2: Define function measure_time(func, *args) // 定義函數\n→ Inside function // 進入函數體\n    → Step 3: start_time ← time.time() // 取得開始時間\n    → Step 4: result ← func(*args) // 執行傳入函數\n    → Step 5: end_time ← time.time() // 取得結束時間\n    → Step 6: elapsed ← end_time - start_time // 計算耗時\n    → Step 7: rounded_elapsed ← round(elapsed, 3) // 四捨五入到3位小數\n    → Step 8: return rounded_elapsed // 回傳時間\nEnd // 程式結束\n\nWe should keep indentation and arrow. Provide each line. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 定義測量執行時間的函式  \n→ Inside function // 進入函式體  \n  → Step 3: start_time ← time.time() // 取得開始時間  \n  → Step 4: result ← func(*args) // 執行傳入的函式  \n  → Step 5: end_time ← time.time() // 取得結束時間  \n  → Step 6: elapsed ← end_time - start_time // 計算耗時差  \n  → Step 7: rounded_elapsed ← round(elapsed, 3) // 四捨五入到小數點 3 位  \n  → Step 8: return rounded_elapsed // 回傳經過四捨五入的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"orange\",\"melon\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'orange', 'melon', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略標準輸入（可選）\n    sys.stdin.read()\n    \n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n    \n    # 1. 新增 'orange'\n    fruits.add('orange')\n    \n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n    \n    # 3. 移除 'banana'\n    fruits.remove('banana')\n    \n    # 4. 嘗試移除不存在的 'pineapple'（不會報錯）\n    fruits.discard('pineapple')\n    \n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The user gave a clear requirement. We'll produce steps.\n\nStructure: Start, Step lines, Decision maybe not needed but can show. End. Each line has code like \"Step 1: ...\". We should keep consistent. Use 虛擬碼步驟 then comment.\n\nWe should use \"Start // 程式開始執行\" and \"End // 程式執行結束\".\n\nInclude lines for each operation. Probably we don't need Decision.\n\nBut to show step numbers: \"Step 1: ...\" etc.\n\nWe need to add \"→\" arrow. Use \"→ Step 1: ...\" etc.\n\nWe should use \"Start\" line and \"End\" line.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize fruits set with {'apple', 'banana'} // 建立初始集合\n→ Step 2: fruits.add('orange') // 新增橙子\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增葡萄和西瓜\n→ Step 4: fruits.remove('banana') // 移除香蕉\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的菠蘿，無效\n→ Step 6: Output fruits // 顯示最終集合\n\nEnd\n\nBut each line must include virtual code step and comment separated by space. Use \"→\" arrow. Provide explanation.\n\nLet's include \"→ Step 1: fruits ← {'apple', 'banana'}\" but the arrow is used for flow, not assignment. We can just write \"Step 1: Set fruits = {'apple', 'banana'}\" etc.\n\nBetter: \"Step 1: fruits ← {'apple', 'banana'} // 建立初始集合\".\n\nAlso use arrow \"→\" before each step.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'（不會報錯）  \n→ Step 6: Output fruits // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate() -> str:\n    \"\"\"\n    向匯率 API 發送請求，取得 USD → TWD 的匯率，並回傳顯示文字。\n    若發生錯誤，回傳錯誤訊息。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()                    # 若 HTTP 狀態不是 200，拋出例外\n        data = response.json()\n        rate = data[\"rates\"][\"TWD\"]\n        return f\"目前美元匯率：約 {rate:.2f} TWD\"\n    except Exception:\n        return \"更新失敗，請檢查網路連線\"\n\ndef create_gui() -> None:\n    \"\"\"\n    建立 tkinter GUI，包含一個標籤與一個按鈕。\n    按鈕點擊時會呼叫 fetch_rate 並更新標籤文字。\n    \"\"\"\n    root = tk.Tk()\n    root.title(\"匯率查詢\")\n\n    label = tk.Label(root, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def on_update() -> None:\n        \"\"\"按鈕的回呼函式，取得匯率並更新標籤。\"\"\"\n        label.config(text=fetch_rate())\n\n    button = tk.Button(root, text=\"更新匯率\", command=on_update)\n    button.pack(pady=5)\n\n    # 初始載入一次匯率\n    on_update()\n    root.mainloop()\n\ndef main() -> None:\n    \"\"\"\n    主程式入口。\n    1. 從標準輸入讀取指令。\n    2. 若指令包含「更新匯率」，呼叫 fetch_rate 並把結果列印至標準輸出。\n    3. 啟動 GUI。\n    \"\"\"\n    # 讀取一行輸入，預設會是如「按下「更新匯率」按鈕」這類文字\n    command = sys.stdin.readline().strip()\n    if \"更新匯率\" in command:\n        # 取得匯率文字並輸出到 stdout\n        print(fetch_rate())\n\n    # 啟動 tkinter GUI\n    create_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines step by step. Use Start, End, Decision, etc. Provide explanations. Should include steps: import requests, import tkinter, create root window, define function to fetch rate, update label, button, loop. Use decision? maybe check if request success. Provide lines accordingly. Ensure each line ends with // explanation. Use arrow symbol for steps: →. The structure:\n\nStart\n→ Step 1: Import requests // ...\n→ Step 2: Import tkinter as tk // ...\n→ Step 3: Create root window // ...\n→ Step 4: Define function fetch_rate // ...\n    → Step 4.1: Send GET request to API // ...\n    → Decision: If response OK? // ...\n        Yes → Step 4.2: Parse JSON and get TWD rate // ...\n        No  → Step 4.3: Set rate_text to error message // ...\n    → Step 4.4: Update label text with rate_text // ...\n→ Step 5: Create label to display rate // ...\n→ Step 6: Create button that triggers fetch_rate // ...\n→ Step 7: Call fetch_rate once for initial load // ...\n→ Step 8: Start mainloop // ...\nEnd\n\nMake sure each line includes \"虛擬碼步驟\" (the step text). Use arrow before step lines. The \"Decision:\" line maybe inside function. Also note that inside function we have nested lines; use indentation? We can keep arrow each line but indent with spaces maybe. Keep consistent. Use \"→\" before each line except Start/End? In example, they used \"→ Step 1:\" etc. Use same.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests // 引入 HTTP 請求模組  \n→ Step 2: Import tkinter as tk // 引入 GUI 模組  \n→ Step 3: Create root window // 建立主視窗  \n→ Step 4: Define function fetch_rate() // 定義取得匯率的函式  \n → Step 4.1: Send GET request to API // 使用 requests 發送請求  \n → Decision: If response.status_code == 200? // 檢查回應是否成功  \n   Yes → Step 4.2: Parse JSON and get TWD rate // 解析 JSON 並取出 TWD 匯率  \n   No  → Step 4.3: Set rate_text to 'Error fetching rate' // 失敗時顯示錯誤訊息  \n → Step 4.4: Update label text with rate_text // 把匯率顯示在 Label  \n→ Step 5: Create label to display rate // 建立 Label 顯示匯率  \n→ Step 6: Create button that triggers fetch_rate // 建立按鈕，點擊時執行 fetch_rate  \n→ Step 7: Call fetch_rate() once for initial load // 程式啟動時先載入一次匯率  \n→ Step 8: Start mainloop // 啟動 tkinter 主循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxh6_zdix.py\", line 36, in <module>\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 94 (char 93)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    # Expect two lines: list of operations and list of arguments\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    results = []\n    obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            results.append(None)\n        elif op == \"insert\":\n            results.append(obj.insert(args[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(args[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n\n    # Output the results in JSON format (None becomes null)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate virtual code for implementing RandomizedSet. Should produce steps: Start, maintain two data structures: hash map for val->index, array list for values. Methods insert, remove, getRandom. Each O(1). We'll produce pseudocode lines with explanation. Use arrow notation.\n\nLet's craft:\n\nStart\n→ Initialize list and map\n→ Step: insert(val)\n    Decision: if val in map?\n        Yes → Return false\n        No → Append val to list, set map[val] = lastIndex, return true\n→ Step: remove(val)\n    Decision: if val not in map?\n        Yes → Return false\n        No → Get idx = map[val]; last = list[lastIndex]; swap; update map[last]; pop; delete map[val]; return true\n→ Step: getRandom()\n    Return random element from list by random index\nEnd\n\nWe need each line \"虛擬碼步驟 // 解釋\".\n\nLet's produce detailed lines:\n\nStart // 程式開始執行\n→ Initialize hashMap ← empty map // 用於快速判斷元素是否存在\n→ Initialize valList ← empty list // 存儲元素以便隨機存取\n→ End // 初始化完成\n\nStart // insert 方法開始\n→ Decision: 如果 val 在 hashMap? // 判斷元素是否已存在\n    Yes → Return false // 已存在，不插入\n    No  → Append val 至 valList // 將新元素加入列表\n→ Decision: 更新 hashMap[val] ← index of val 在 valList // 記錄索引\n→ Return true // 成功插入\nEnd // insert 方法結束\n\nStart // remove 方法開始\n→ Decision: 如果 val 不在 hashMap? // 判斷元素是否存在\n    Yes → Return false // 無法刪除\n    No  → idx ← hashMap[val] // 取得待刪除元素的索引\n→ lastIdx ← length(valList) - 1 // 取得最後元素索引\n→ lastVal ← valList[lastIdx] // 取得最後一個元素值\n→ Decision: 如果 idx ≠ lastIdx? // 若待刪除不是最後元素\n    Yes → valList[idx] ← lastVal // 用最後元素覆蓋待刪除位置\n    → hashMap[lastVal] ← idx // 更新被覆蓋元素的索引\n    No  → // idx == lastIdx，直接刪除即可\n→ Pop last element from valList // 刪除最後元素\n→ Delete hashMap[val] // 移除映射\n→ Return true // 成功刪除\nEnd // remove 方法結束\n\nStart // getRandom 方法開始\n→ n ← length(valList) // 取得元素數量\n→ randomIdx ← RandomInt(0, n-1) // 隨機索引\n→ Return valList[randomIdx] // 回傳隨機元素\nEnd // getRandom 方法結束\n\nWe need each line separated by newline. Also must include \"Start\" only once at top? But we can show separate for each method. Use \"Start\" and \"End\" appropriately. Ensure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ hashMap ← {} // 用於快速判斷元素是否存在  \n→ valList ← [] // 存儲元素以便隨機存取  \nEnd // 初始化完成  \n\nStart // insert 方法開始  \n→ Decision: 若 val 在 hashMap? // 判斷元素是否已存在  \n    Yes → Return false // 已存在，不插入  \n    No  → valList.append(val) // 將新元素加入列表  \n→ hashMap[val] ← len(valList) - 1 // 記錄新元素的索引  \n→ Return true // 成功插入  \nEnd // insert 方法結束  \n\nStart // remove 方法開始  \n→ Decision: 若 val 不在 hashMap? // 判斷元素是否存在  \n    Yes → Return false // 無法刪除  \n    No  → idx ← hashMap[val] // 取得待刪除元素的索引  \n→ lastIdx ← len(valList) - 1 // 取得最後元素索引  \n→ lastVal ← valList[lastIdx] // 取得最後一個元素值  \n→ Decision: 若 idx ≠ lastIdx? // 若待刪除不是最後元素  \n    Yes → valList[idx] ← lastVal // 用最後元素覆蓋待刪除位置  \n    → hashMap[lastVal] ← idx // 更新被覆蓋元素的索引  \n    No  → // idx == lastIdx，直接刪除即可  \n→ valList.pop() // 刪除最後元素  \n→ Delete hashMap[val] // 移除映射  \n→ Return true // 成功刪除  \nEnd // remove 方法結束  \n\nStart // getRandom 方法開始  \n→ n ← len(valList) // 取得元素數量  \n→ randomIdx ← RandomInt(0, n-1) // 隨機索引  \n→ Return valList[randomIdx] // 回傳隨機元素  \nEnd // getRandom 方法結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwj5ft7_p.py\", line 77, in <module>\n    main()\n  File \"/tmp/tmpwj5ft7_p.py\", line 58, in main\n    commands = json.loads(parts[0])\n               ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 12 (char 11)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        # rows and cols of the matrix\n        self.m = m\n        self.n = n\n        # total available cells (0s)\n        self.remain = m * n\n        # mapping for swapping indices\n        self.mapping = {}\n\n    def flip(self):\n        \"\"\"\n        隨機選取一個還未被翻轉的格子，並將其設為 1。\n        為了確保等機率且只呼叫一次 random，使用映射技巧。\n        \"\"\"\n        # 隨機選取 [0, remain-1]\n        idx = random.randint(0, self.remain - 1)\n        # 實際存放在 idx 的值（如果已被映射則取映射值）\n        real = self.mapping.get(idx, idx)\n\n        # 將 idx 位置映射到剩餘區域的最後一個位置\n        last = self.remain - 1\n        last_val = self.mapping.get(last, last)\n        self.mapping[idx] = last_val\n\n        # 如果最後一個位置本身已被映射，需要移除\n        if idx != last:\n            self.mapping.pop(last, None)\n\n        # 可翻轉格子數減一\n        self.remain -= 1\n\n        # 回傳二維座標\n        return [real // self.n, real % self.n]\n\n    def reset(self):\n        \"\"\"\n        重置矩陣，所有格子恢復為 0。\n        \"\"\"\n        self.remain = self.m * self.n\n        self.mapping.clear()\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # Parse commands and arguments\n    if len(data) >= 2:\n        commands = json.loads(data[0])\n        args_list = json.loads(data[1])\n    else:\n        # In case both are on the same line separated by comma\n        parts = data[0].split(',', 1)\n        commands = json.loads(parts[0])\n        args_list = json.loads(parts[1])\n    output = []\n    sol = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # Initialize with m and n\n            sol = Solution(args[0], args[1])\n            output.append(None)\n        elif cmd == \"flip\":\n            res = sol.flip()\n            output.append(res)\n        elif cmd == \"reset\":\n            sol.reset()\n            output.append(None)\n    # Print the results as JSON array\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, explanation. The solution: Use reservoir-like mapping, maintain a set of available indices. Approach: Represent matrix as 1D list of size m*n. Keep a dictionary mapping from index to value to handle swapped. Initially, all indices available. flip: pick random k from [0, remaining-1], get mapping k->value (if exists else k). Then swap that value with last available index (remaining-1). Decrease remaining. Return coordinates.\n\nreset: clear mapping, set remaining=m*n.\n\nTime O(1) avg, space O(m*n?) mapping up to number of flips, but at most m*n.\n\nMinimize random calls: only one per flip.\n\nImplement in virtual code.\n\nWe need to use Start, End, Decision. Provide each line.\n\nLet's produce.\n\nWe also need class Solution with constructor, flip, reset.\n\nWe will produce pseudo-code lines. Each line has virtual code step and explanation. Use arrows etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Declare variables m, n, remaining, map // 保存矩陣尺寸、剩餘可翻轉數量與映射表  \n→ Step 2: Call Init() // 初始化 map 與 remaining  \n\nStart // Init() 函式開始  \n→ Step 3: remaining ← m * n // 初始可翻轉位置數為所有格子  \n→ Step 4: map ← empty // 清空映射表  \n→ End // Init() 完成  \n\nStart // flip() 函式開始  \n→ Decision: 如果 remaining == 0? // 若已無空格子可翻  \n    Yes → Step 5: throw exception // 或回傳錯誤，表示無法再翻  \n    No  → Step 6: randIndex ← Random(0, remaining - 1) // 取得一個隨機索引，確保等機率  \n→ Step 7: realIndex ← map.get(randIndex, randIndex) // 若已映射則取映射值，否則取本身  \n→ Step 8: lastIndex ← remaining - 1 // 最後一個可用索引  \n→ Step 9: lastValue ← map.get(lastIndex, lastIndex) // 取最後索引的實際值  \n→ Step 10: map.put(randIndex, lastValue) // 將選中的位置更新為最後索引的值  \n→ Step 11: If randIndex != lastIndex Then map.remove(lastIndex) // 移除已使用的最後索引映射，保持映射表一致  \n→ Step 12: remaining ← remaining - 1 // 減少可用位置數  \n→ Step 13: row ← realIndex / n // 計算行號  \n→ Step 14: col ← realIndex % n // 計算列號  \n→ Step 15: return [row, col] // 回傳翻轉的坐標  \n\nEnd // flip() 完成  \n\nStart // reset() 函式開始  \n→ Step 16: Call Init() // 重新初始化矩陣  \n→ End // reset() 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9cz44ges.py\", line 67, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9cz44ges.py\", line 20, in __init__\n    self.lookup[(prefix, suffix)] = idx\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass WordFilter:\n    def __init__(self, words):\n        \"\"\"\n        words : List[str]\n        建構子會為每個單字建立所有可能的前綴與後綴組合\n        並把對應的索引（最大值）存入字典 self.lookup\n        \"\"\"\n        self.lookup = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            # 前綴長度 i 取值 0~L，後綴起始位置 j 取值 0~L\n            for i in range(L + 1):\n                prefix = word[:i]\n                for j in range(L + 1):\n                    suffix = word[j:]\n                    # 使用元組作為鍵，便於哈希查詢\n                    self.lookup[(prefix, suffix)] = idx\n\n    def f(self, pref, suff):\n        \"\"\"\n        pref : str   前綴\n        suff : str   後綴\n        回傳符合條件的最大索引，若無則回傳 -1\n        \"\"\"\n        return self.lookup.get((pref, suff), -1)\n\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串分成兩個 JSON 陣列\n    假設格式為 'words_json, params_json'，中間的逗號在最外層。\n    \"\"\"\n    depth = 0\n    split_index = None\n    for idx, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_index = idx\n            break\n    if split_index is None:\n        raise ValueError(\"Input format error\")\n    words_json = data[:split_index].strip()\n    params_json = data[split_index + 1:].strip()\n    words = json.loads(words_json)\n    params = json.loads(params_json)\n    if not isinstance(params, list) or len(params) != 2:\n        raise ValueError(\"Params must be a list of two strings\")\n    return words, params[0], params[1]\n\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    try:\n        words, pref, suff = parse_input(raw)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps to design a WordFilter class with methods constructor and f. Use virtual code with arrows etc. Probably we should outline building a Trie for prefixes and suffixes or using combined key of suffix+prefix. Since need largest index, we can store indices in lists. Provide step-by-step algorithm.\n\nWe must not output actual code, just pseudocode steps. Let's produce Start, steps.\n\nWe need to consider building a Trie of combined suffix+prefix? Classic solution: use hash map from combined key pref+\"#\"+suff to index. Or use two Tries.\n\nSimplest: For each word, for all suffixes, for all prefixes? That's O(n^3). Instead store mapping of combined key (suffix + \"#\" + prefix) to index, iterating over all suffixes and prefixes for each word: that's O(n*len^2). Acceptable for moderate constraints.\n\nBut we just need pseudocode.\n\nWe'll describe: On initialization: For each word with index i: For each suffix start pos from 0 to len: suffix = word[pos:]; For each prefix end pos from 0 to len: prefix = word[:end]; key = suffix + \"#\" + prefix; map[key] = i (overwrite to keep largest). Then f: key = suff + \"#\" + pref; return map.get(key, -1).\n\nAlso mention that we can use trie: Build prefix trie and suffix trie, then search intersection. But simpler map.\n\nLet's produce steps.\n\nWe'll need lines with '→' arrow for flow.\n\nLet's produce pseudocode:\n\nStart\n→ Step 1: Initialize empty map keyToIndex\n→ Decision: words list empty? Yes → End? but skip\n→ Step 2: For each word in words with index i: // iterate\n    → Step 2.1: For each suffixStart from 0 to length of word: suffix = substring(word, suffixStart)\n    → Step 2.2: For each prefixEnd from 1 to length of word: prefix = substring(word, 0, prefixEnd)\n    → Step 2.3: key = suffix + \"#\" + prefix\n    → Step 2.4: keyToIndex[key] = i // overwrite to store largest index\n→ End of constructor\n\nMethod f:\nStart\n→ Step 1: key = suff + \"#\" + pref\n→ Step 2: If key exists in keyToIndex: return keyToIndex[key] else return -1\nEnd\n\nWe need to incorporate arrow structure.\n\nLet's produce.\n\nWe also should include comment after each line.\n\nUse Start, End markers.\n\nWe should not output code but steps.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立空字典 keyToIndex // 用於存放「後綴#前綴」對應的最大索引\n→ Decision: words 为空? // 檢查是否有字典資料\n    Yes → End // 若無資料直接結束\n    No  → // 繼續執行\n\n→ Step 2: 對 words 之每個單字 word 及其索引 i 執行\n    → Step 2.1: 計算 word 長度 len\n    → Step 2.2: 對 suffixStart 從 0 到 len 迭代\n        → Step 2.2.1: suffix = substring(word, suffixStart, len) // 取後綴\n        → Step 2.2.2: 對 prefixEnd 從 1 到 len 迭代\n            → Step 2.2.2.1: prefix = substring(word, 0, prefixEnd) // 取前綴\n            → Step 2.2.2.2: key = suffix + \"#\" + prefix // 組合鍵\n            → Step 2.2.2.3: keyToIndex[key] = i // 覆寫以保持最大索引\n→ End // 建構子結束\n\n// =============================\n// 方法 f(prefix, suffix)\n// =============================\nStart // 方法 f 開始執行\n→ Step 1: key = suffix + \"#\" + prefix // 生成查詢鍵\n→ Decision: key 在 keyToIndex 中? // 檢查是否存在符合條件的單字\n    Yes → Step 2: return keyToIndex[key] // 回傳最大索引\n    No  → Step 3: return -1 // 無符合條件，回傳 -1\nEnd // 方法 f 結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3kbnkmzn.py\", line 56, in <module>\n    params = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3kbnkmzn.py\", line 42, in parse_input\n    key, val = part.split('=', 1)\n    ^^^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpajt6l7ct.py\", line 56, in <module>\n    params = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpajt6l7ct.py\", line 42, in parse_input\n    key, val = part.split('=', 1)\n    ^^^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, W: int, Profits: list[int], Capital: list[int]) -> int:\n        \"\"\"\n        用最大堆 (max-heap) 取出目前可執行專案中利潤最大的專案，\n        重複執行最多 k 次或直到沒有可執行專案為止。\n        \"\"\"\n        # 把所有專案以需要的資本排序，方便一次性把可執行專案加入堆\n        projects = sorted(zip(Capital, Profits), key=lambda x: x[0])\n\n        max_heap = []           # 儲存可執行專案的利潤，使用負值實現最大堆\n        idx = 0                 # 指標，指向還未處理的專案\n        n = len(Profits)\n\n        for _ in range(k):\n            # 把所有目前可執行的專案都放進堆\n            while idx < n and projects[idx][0] <= W:\n                heapq.heappush(max_heap, -projects[idx][1])  # 利潤取負數\n                idx += 1\n\n            # 如果沒有可執行專案，則結束\n            if not max_heap:\n                break\n\n            # 取出利潤最大的專案並更新資本\n            W += -heapq.heappop(max_heap)\n\n        return W\n\ndef parse_input(input_str: str) -> dict:\n    \"\"\"\n    解析類似 'k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]'\n    的輸入字串，回傳 dict。\n    \"\"\"\n    data = {}\n    # 先把所有逗號分開，然後再拆分 '='\n    for part in input_str.strip().split(','):\n        if not part.strip():\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        # 對於 list 和 int，直接 eval\n        try:\n            value = eval(val, {\"__builtins__\": None}, {})\n        except Exception:\n            value = val\n        data[key] = value\n    return data\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入（可能跨多行）\n    raw_input = sys.stdin.read()\n    params = parse_input(raw_input)\n\n    k = params.get('k', 0)\n    w = params.get('w', 0)\n    profits = params.get('profits', [])\n    capital = params.get('capital', [])\n\n    sol = Solution()\n    result = sol.findMaximizedCapital(k, w, profits, capital)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudocode solution to maximize capital by selecting at most k projects. Classic Leetcode 502 IPO problem. Approach: sort projects by capital requirement; use a max-heap for profits of available projects. For each of k times, add to heap all projects with capital <= current capital; if heap empty break; pop max profit, add to capital. Return capital. Pseudocode lines. Need Start, End, Decision, arrows. Use Step lines. Provide explanation after each line.\n\nLet's produce step by step:\n\nStart\n→ Step 1: 整理輸入參數 n, profits[], capital[], k, w // 讀取參數\n→ Step 2: 建立結構 Project(need, profit) 並將所有項目組成 list projects // 將資料打包\n→ Step 3: 按需資本升序排序 projects // 方便挑選可行專案\n→ Step 4: 建立空最大堆 profitHeap // 儲存可執行專案的利潤\n→ Step 5: 建立索引 ptr = 0 // 指向 projects 中尚未考慮的項目\n→ Decision: 是否已選取項目數 < k? // 控制選取次數\n    Yes → Step 6: 進行一次迴圈\n        → Decision: 是否還有可執行項目 (ptr < n 且 projects[ptr].need <= w)?\n            Yes → Step 7: 將 projects[ptr].profit 推入 profitHeap\n                → Step 8: ptr++ // 移動到下一個項目\n                → Step 9: 返回決策點 (重複判斷)\n            No  → Decision: profitHeap 是否非空?\n                Yes → Step 10: pop max profit from profitHeap\n                    → Step 11: w += poppedProfit // 更新資本\n                    → Step 12: 選取項目數 ++\n                    → Step 13: 回到決策點 (是否已選取項目數 < k)\n                No  → Step 14: 無更多可執行專案，終止迴圈\n    No  → End // 完成所有選擇\nEnd // 回傳 w\n\nBut need to structure with arrows properly. Provide explanation after each line.\n\nAlso we need to break lines: Step 1 etc. Use arrow \"→\" before step lines. Decision lines indent.\n\nNeed to ensure \"Start\" and \"End\". Provide all lines sequentially.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n, profits[], capital[], k, w // 取得輸入參數  \n→ Step 2: 建立 Project 結構 {need, profit}，並將所有專案加入 list projects // 整理資料  \n→ Step 3: 以 projects[.need] 升序排序 projects // 方便快速找出可執行專案  \n→ Step 4: 初始化一個空的最大堆 profitHeap // 用來儲存已可執行專案的利潤  \n→ Step 5: 設定指標 ptr = 0 // 指向還未處理的專案  \n→ Decision: 是否已選取專案數 < k? // 控制最多選 k 個  \n  Yes → Step 6: 開始迴圈  \n   → Decision: ptr < n 且 projects[ptr].need ≤ w? // 有未處理且可行的專案  \n    Yes → Step 7: 將 projects[ptr].profit 推入 profitHeap // 將可執行專案加入堆  \n     → Step 8: ptr++ // 移至下一個專案  \n     → Step 9: 回到 Decision: ptr < n 且 projects[ptr].need ≤ w? // 重新檢查是否還有更多可執行專案  \n    No  → Decision: profitHeap 是否非空? // 有沒有可選擇的利潤  \n     Yes → Step 10: pop maxProfit from profitHeap // 取出最大利潤  \n      → Step 11: w += maxProfit // 更新總資本  \n      → Step 12: 選取專案數 ++  \n      → Step 13: 回到 Decision: 是否已選取專案數 < k? // 再次判斷是否可以繼續  \n     No  → Step 14: 無更多可執行專案，終止迴圈  \n  No  → End // 已選取 k 個專案或無法再選  \nEnd // 回傳最終資本 w"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import deque\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"Return all unique strings after removing minimum invalid parentheses.\"\"\"\n        # Helper to check if parentheses in string are balanced\n        def is_valid(string: str) -> bool:\n            count = 0\n            for ch in string:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # BFS: level‑by‑level search\n        visited = {s}\n        level = {s}\n        while level:\n            # Check if any string in this level is valid\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid  # all of them are minimal removals\n            # Generate next level by removing one parenthesis from each string\n            next_level = set()\n            for item in level:\n                for i, ch in enumerate(item):\n                    if ch in ('(', ')'):\n                        new_item = item[:i] + item[i+1:]\n                        if new_item not in visited:\n                            visited.add(new_item)\n                            next_level.add(new_item)\n            level = next_level\n        return []\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the string value from the input\n    if '=' in data:\n        _, value = data.split('=', 1)\n        value = value.strip()\n    else:\n        value = data.strip()\n\n    # Remove surrounding quotes if present\n    if (value.startswith('\"') and value.endswith('\"')) or \\\n       (value.startswith(\"'\") and value.endswith(\"'\")):\n        value = value[1:-1]\n\n    solution = Solution()\n    result = solution.removeInvalidParentheses(value)\n    # Output as JSON array (double‑quoted strings)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm. It's classic problem: remove invalid parentheses to generate all valid strings with min removals. Usually BFS or DFS with pruning. Provide pseudo-code steps line by line. We should produce unique strings. Use set to avoid duplicates. BFS approach: level by level; first level with removal count 0, check if valid. If not, generate all strings by removing one parenthesis at each position, avoid duplicates in queue.\n\nProvide pseudo-code.\n\nLet's write steps:\n\nStart\n→ Step 1: 初始化 BFS queue with input string // start level 0\n→ Step 2: 初始化結果集合 result = {}\n→ Step 3: 初始化 visited 集合 visited = {}\n→ Decision: 是否找到有效字符串? // check if any string in current level is valid\n    Yes → Step 4: 將所有有效字符串加入 result // add all valid at this level\n    No  → Step 5: 生成下一層字符串 // produce all strings by removing one parenthesis\n        → Step 6: For each string cur in current level\n            → Decision: 是否已處理 cur? // skip if visited\n                Yes → skip\n                No  → add cur to visited\n            → For each index i in cur\n                → Decision: 是否為括號? // only consider '(' or ')'\n                    Yes →\n                        → Step 7: newStr = cur.substring(0,i)+cur.substring(i+1)\n                        → Decision: 是否已加入下一層? // avoid duplicates\n                            Yes → skip\n                            No  → add newStr to nextLevel\n        → Step 8: 若 nextLevel 非空，則設 current level = nextLevel，重複決策\n        → Step 9: 否則返回 result // no more strings\nEnd\n\nWe need unique strings result. Use set.\n\nAlso need function isValid(s) to check balanced parentheses.\n\nAlso ensure we don't generate duplicates across levels; use visited set.\n\nReturn result as list.\n\nWe must produce each step with explanation comment.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 BFS queue 為 {s} // 用集合存放目前層級的字串，起始層為輸入字串  \n→ Step 2: 初始化 result 集合為空 // 儲存符合條件且刪除數最少的有效字串  \n→ Step 3: 初始化 visited 集合為空 // 防止重複處理同一字串  \n→ Decision: 是否已找到有效字串? // 檢查目前層級中是否存在合法括號排列  \n  Yes → Step 4: 將所有合法字串加入 result // 這一層已達到最小刪除，收集後停止  \n  No  → Step 5: 生成下一層字串集合 nextLevel 為空 // 從每個字串刪除一個括號  \n    → Step 6: 對 current 層級中的每個字串 cur  \n     → Decision: cur 是否已在 visited? // 避免重複  \n      Yes → skip // 已處理，跳過  \n      No  → 加入 visited ← cur // 記錄已處理  \n      → Step 7: 逐個索引 i 循環遍歷 cur  \n       → Decision: cur[i] 是否為 '(' 或 ')'？ // 只對括號進行刪除  \n        Yes → Step 8: newStr ← cur 刪除第 i 個字符  \n         → Decision: newStr 是否已在 nextLevel？  \n          Yes → skip // 已生成，避免重複  \n          No  → 加入 nextLevel ← newStr // 新字串進入下一層  \n       → End for i  \n     → End for cur  \n    → Step 9: 若 nextLevel 非空，則 current ← nextLevel，重複決策流程  \n    → Step 10: 否則 // 兩層均無合法字串  \n     → End // 返回 result，程式結束  \nEnd // 程式執行結束  \n\n// 此虛擬碼使用 BFS，層級越深刪除字元越多；當第一層找到合法字串時即為最小刪除量，並將所有同層合法字串加入結果。  \n// visited 集合防止重複字串，nextLevel 集合確保每層僅處理一次，保證結果唯一。  \n// 最終 result 以集合形式儲存，可直接轉為列表返回。"
    },
    {
      "title": "My Calendar III",
      "source_file": "Leetcode/leetcode732.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,2,3,3,3]'\nGot (Norm):      '[None,1,1,2,3,3,3]'\n--- (Raw) ---\nRaw Expected: '[null, 1, 1, 2, 3, 3, 3]'\nRaw Got:      '[None, 1, 1, 2, 3, 3, 3]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\nimport ast\n\nclass MyCalendarThree:\n    \"\"\"\n    使用 sweep line 的方式，將每個事件的起點 +1、終點 -1 存入 timeline，\n    再對 timeline 進行排序並掃描，計算目前活躍事件數目\n    以及在所有事件中遇到的最大活躍數目。\n    \"\"\"\n    def __init__(self):\n        # timeline 會儲存 (time, delta) 這類元組\n        self.timeline = []\n\n    def book(self, start: int, end: int) -> int:\n        # 插入起點與終點，保持排序\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n\n        active = 0      # 當前重疊數\n        max_active = 0  # 遇到的最大重疊數\n        for time, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，並轉成兩個列表：operations 與 arguments\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析為兩個 Python 列表\n    ops, args = ast.literal_eval(raw_input)\n\n    results = []\n    calendar = None\n    for idx, op in enumerate(ops):\n        if op == \"MyCalendarThree\":\n            calendar = MyCalendarThree()\n            results.append(None)  # LeetCode 中對於建構子回傳 null\n        elif op == \"book\":\n            start, end = args[idx]\n            res = calendar.book(start, end)\n            results.append(res)\n        else:\n            # 若有其他方法，暫時跳過\n            results.append(None)\n\n    # 輸出結果列表，符合 LeetCode 的輸出格式\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for the solution to MyCalendarThree booking problem. We need to describe algorithm step by step. Use structure Start, Decision, etc. Probably using sweep line algorithm: maintain array of events (start, end). For each book, add to list, then compute maximum overlap using line sweep: create vector of (time, delta) where delta=+1 at start, -1 at end. Sort by time. Iterate accumulate count, track max. Return max. Should produce virtual code lines with explanation.\n\nWe need to generate each line with virtual code and comment. The lines can include loops, conditions. The lines should be clear but not actual code. Use arrows, decisions. We'll produce steps: Start, define class, constructor, book method, add event to list, compute max by sweep.\n\nWe need to output each line in the required format. Probably each line starts with \"Start\" etc. We'll write:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCalendarThree 類別 // 建立類別\n→ Step 2: 宣告 events 為空清單 // 儲存所有事件\n→ Step 3: MyCalendarThree() // 建構子\n    → Step 3a: events ← 空清單 // 初始化\n→ Step 4: book(startTime, endTime) // 進行預約\n    → Step 4a: events ← events 加入 (startTime, endTime) // 加入新事件\n    → Step 4b: 建立 empty list times // 用於線性掃描\n    → Step 4c: 對於每個 (s, e) 在 events\n        → Step 4c1: times ← times 加入 (s, +1) // 事件開始\n        → Step 4c2: times ← times 加入 (e, -1) // 事件結束\n    → Step 4d: times ← times 排序 按 time 值 // 依時間排序\n    → Step 4e: current ← 0, maxOverlap ← 0 // 初始化計數\n    → Step 4f: 對於每個 (t, delta) 在 times\n        → Step 4f1: current ← current + delta // 更新重疊計數\n        → Step 4f2: maxOverlap ← max(maxOverlap, current) // 更新最大重疊\n    → Step 4g: 返回 maxOverlap // 回傳最大 k\nEnd // 程式結束\n\nWe must ensure each line follows the pattern: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow \"→\" or \"Decision:\" etc. Use indentation for nested steps. Each step line will start with appropriate arrow.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCalendarThree 類別 // 建立類別容器  \n→ Step 2: 宣告 events 為空清單 // 用來儲存所有已預約的事件  \n→ Step 3: MyCalendarThree() // 建構子  \n  → Step 3a: events ← 空清單 // 初始化事件列表  \n→ Step 4: book(startTime, endTime) // 接受一次新的預約請求  \n  → Step 4a: events ← events 加入 (startTime, endTime) // 將新事件加入列表  \n  → Step 4b: 建立空清單 times // 用於線性掃描的時間點與變化量  \n  → Step 4c: 對於每個 (s, e) 在 events  \n    → Step 4c1: times ← times 加入 (s, +1) // 事件開始，重疊數 +1  \n    → Step 4c2: times ← times 加入 (e, -1) // 事件結束，重疊數 -1  \n  → Step 4d: times ← times 排序 按 time 值 // 依時間排序以便掃描  \n  → Step 4e: current ← 0, maxOverlap ← 0 // 初始化當前重疊數與最大值  \n  → Step 4f: 對於每個 (t, delta) 在 times  \n    → Step 4f1: current ← current + delta // 更新當前重疊數  \n    → Step 4f2: maxOverlap ← max(maxOverlap, current) // 取最大重疊值  \n  → Step 4g: 返回 maxOverlap // 回傳目前為止最大的 k-booking  \nEnd // 程式執行結束"
    },
    {
      "title": "Parse Lisp Expression",
      "source_file": "Leetcode/leetcode736.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps1m1rkrl.py\", line 80, in <module>\n    main()\n  File \"/tmp/tmps1m1rkrl.py\", line 76, in main\n    result = evaluate_expression(tokens, {})\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps1m1rkrl.py\", line 37, in evaluate_expression\n    val = evaluate_expression(tokens, new_env)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps1m1rkrl.py\", line 50, in evaluate_expression\n    return env[token]\n           ~~~^^^^^^^\nKeyError: 'mult'"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqu9tyqkk.py\", line 80, in <module>\n    main()\n  File \"/tmp/tmpqu9tyqkk.py\", line 76, in main\n    result = evaluate_expression(tokens, {})\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqu9tyqkk.py\", line 37, in evaluate_expression\n    val = evaluate_expression(tokens, new_env)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqu9tyqkk.py\", line 50, in evaluate_expression\n    return env[token]\n           ~~~^^^^^^^\nKeyError: ')'"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4me2yax7.py\", line 80, in <module>\n    main()\n  File \"/tmp/tmp4me2yax7.py\", line 76, in main\n    result = evaluate_expression(tokens, {})\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4me2yax7.py\", line 37, in evaluate_expression\n    val = evaluate_expression(tokens, new_env)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4me2yax7.py\", line 50, in evaluate_expression\n    return env[token]\n           ~~~^^^^^^^\nKeyError: 'add'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\ndef tokenize(s: str):\n    \"\"\"\n    把輸入字串拆成最小單位(token)，包括\n    - '('  ')'\n    - 整數 (可帶負號)\n    - 標識符（以字母開頭，隨後可接字母或數字）\n    \"\"\"\n    token_pattern = re.compile(r'\\s*([()]|[-]?\\d+|[a-zA-Z][a-zA-Z0-9]*)\\s*')\n    return deque(token_pattern.findall(s))\n\ndef evaluate_expression(tokens: deque, env: dict) -> int:\n    \"\"\"\n    以遞迴方式求值。tokens 是一個 deque，env 是目前作用域的變數環境。\n    \"\"\"\n    token = tokens.popleft()\n    if token == '(':\n        op = tokens.popleft()\n        if op == 'add':\n            val1 = evaluate_expression(tokens, env)\n            val2 = evaluate_expression(tokens, env)\n            tokens.popleft()          # 消費 ')'\n            return val1 + val2\n        elif op == 'mult':\n            val1 = evaluate_expression(tokens, env)\n            val2 = evaluate_expression(tokens, env)\n            tokens.popleft()          # 消費 ')'\n            return val1 * val2\n        elif op == 'let':\n            new_env = env.copy()\n            # 讀取所有「變數 = 表達式」對，直到只剩下一個 token（最後的表達式）\n            while len(tokens) > 1:\n                var = tokens.popleft()\n                val = evaluate_expression(tokens, new_env)\n                new_env[var] = val\n            # 最後一個 token 就是要計算的表達式\n            result = evaluate_expression(tokens, new_env)\n            tokens.popleft()          # 消費 ')'\n            return result\n        else:\n            raise ValueError(f\"未知操作符 {op}\")\n    else:\n        # 整數\n        if token.lstrip('-').isdigit():\n            return int(token)\n        # 變數查找\n        return env[token]\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從原始輸入中抽取真正的 Lisp 表達式字串。\n    允許輸入形如：\n        expression = \"(let x 2 ...)\"\n    或直接為 \"(let x 2 ...)\"。\n    \"\"\"\n    raw = raw.strip()\n    # 若包含 assignment 文字，取第一個 '(' 之後的內容\n    idx = raw.find('(')\n    if idx != -1:\n        expr = raw[idx:].strip()\n    else:\n        expr = raw\n    # 去掉可能存在的外層引號\n    expr = expr.strip('\\'\"')\n    return expr\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    expr_str = parse_input(raw_input)\n    tokens = tokenize(expr_str)\n    result = evaluate_expression(tokens, {})\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code to solve problem: evaluate Lisp-like expression string. Provide algorithm steps. Use virtual code lines with explanation.\n\nWe should produce high-level pseudocode: parse expression, recursion, environment stack.\n\nLet's produce steps: Start, define function eval(expr, envStack). Use tokenization. We'll handle parentheses. Use stack for scopes. Steps: parse string to tokens. Then recursive parse.\n\nWe'll output virtual code lines sequentially.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Tokenise input string into list of tokens (numbers, identifiers, parentheses) // 將輸入字串拆分為可操作的單元  \n→ Step 2: Initialise global environment list envStack ← empty list // 用於儲存變數的多層作用域  \n→ Step 3: Call evalExpression(0, envStack) // 從第一個 token 開始遞迴求值  \n→ End // 程式執行結束  \n\nStart // evalExpression 開始  \n→ Step 1: If current token is '(' → enter a composite expression  \n→ Decision: token == '('?  \n    Yes → Step 2: Read next token as operator (op) // e.g., 'add', 'mult', 'let'  \n    → Decision: op == 'add'?  \n        Yes → Step 3: val1 ← evalExpression(nextIndex, envStack) // 解析第一個子表達式  \n        → Step 4: val2 ← evalExpression(nextIndex, envStack) // 解析第二個子表達式  \n        → Step 5: Consume ')' token // 結束本層括號  \n        → Step 6: Return val1 + val2 // 返回加法結果  \n        No → Decision: op == 'mult'?  \n            Yes → Step 3: val1 ← evalExpression(nextIndex, envStack)  \n            → Step 4: val2 ← evalExpression(nextIndex, envStack)  \n            → Step 5: Consume ')'  \n            → Step 6: Return val1 * val2 // 返回乘法結果  \n            No → Decision: op == 'let'?  \n                Yes → Step 3: Push new empty scope onto envStack // 新作用域  \n                → Step 4: While next token not end of let expression (i.e., not the final expr)  \n                    → Step 5: If next token is variable name and the following token is not ')' →  \n                        → Step 6: val ← evalExpression(nextIndex, envStack) // 先計算右側表達式  \n                        → Step 7: Assign envStack.top[variable] ← val // 存入最新作用域  \n                        → Step 8: Advance to next token (after expression)  \n                    → Decision: else // 到達最後一個 expr  \n                        → Step 9: result ← evalExpression(nextIndex, envStack) // 計算最後表達式  \n                        → Step 10: Consume ')' // 結束 let  \n                        → Step 11: Pop the scope from envStack // 退出作用域  \n                        → Step 12: Return result // 返回 let 結果  \n                → No → Step 3: // 這裡不會出現非法情況，因為輸入合法  \n                    → Step 4: Return 0 // 佔位，實際上不會執行  \n            No → Step 3: // 不可能到這裡，輸入合法  \n                → Step 4: Return 0  \n    No → Decision: token is a number?  \n        Yes → Step 2: Convert token to integer and return it // 整數直接返回  \n        No → Decision: token is variable name?  \n            Yes → Step 3: Search envStack from top to bottom for variable value  \n            → Step 4: Return found value // 變數取值  \n            No → Step 3: // 這裡不會發生，因為輸入合法  \n                → Step 4: Return 0 // 占位  \n→ End // evalExpression 結束  \n\nStart // 迴圈控制與索引更新  \n→ Step 1: Use global index pointer to track current token position // 方便遞迴調用時更新位置  \n→ Step 2: Each evalExpression call returns new index after processing // 讓呼叫者知道下一個 token  \n→ End // 索引控制結束  \n\nStart // 整體流程回顧  \n→ Step 1: Tokenise  \n→ Step 2: 設置 envStack  \n→ Step 3: evalExpression(0)  \n→ Step 4: 輸出最終結果  \n→ End // 程式結束。"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxc10oud_.py\", line 68, in <module>\n    main()\n  File \"/tmp/tmpxc10oud_.py\", line 41, in main\n    args = json.loads('[' + args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 37 (char 36)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"\n    Reservoir sampling implementation.\n    \"\"\"\n    def __init__(self, nums):\n        # Store the original array\n        self.nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        Pick a random index i such that nums[i] == target.\n        Each such index has equal probability.\n        \"\"\"\n        count = 0          # Number of times target has been seen so far\n        chosen_index = -1  # Current chosen index\n\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                # Randomly decide whether to keep this index\n                if random.randint(1, count) == 1:\n                    chosen_index = i\n\n        return chosen_index\n\ndef main():\n    # Read entire stdin as a single string\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n\n    # The input format is: [commands], [arguments]\n    # Example: '[\"Solution\", \"pick\", \"pick\"], [[[1,2,3]], [1], [3]]'\n    # Use json to parse it\n    commands_str, args_str = input_data.split('],', 1)\n    commands = json.loads(commands_str + ']')\n    args = json.loads('[' + args_str)\n\n    results = []\n    solution = None\n    arg_idx = 0\n\n    for cmd in commands:\n        if cmd == \"Solution\":\n            # args[arg_idx] is a list containing the nums list\n            nums = args[arg_idx][0]\n            solution = Solution(nums)\n            results.append(None)  # Constructor returns null\n            arg_idx += 1\n        elif cmd == \"pick\":\n            # args[arg_idx] is a list containing the target value\n            target = args[arg_idx][0]\n            res = solution.pick(target)\n            results.append(res)\n            arg_idx += 1\n        else:\n            # Unknown command; skip or handle as needed\n            results.append(None)\n\n    # Output results as a JSON array\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described algorithm. Implementation likely uses reservoir sampling or mapping from target to indices. Because target is guaranteed to exist, we can do: in pick, iterate over array, maintain count and choose randomly. Or pre-process into map of target->list of indices, but memory may be high. But we can produce algorithm: For pick(target): iterate through nums, increment counter when nums[i]==target, generate random number between 1 and count, and if current index chosen, keep. At end return chosen. Complexity O(n). Provide steps: Start, store array, pick method, loop etc. Use virtual code with decision arrow. Let's produce lines.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows like →.\n\nLet's produce.\n\nNeed to use structure: Start, Decision, etc. Each line separate.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收整數陣列 nums 並儲存為物件屬性 // 建構子儲存輸入陣列  \n→ Step 2: 接收目標值 target 並準備隨機選取索引 // pick 方法入口  \n→ Step 3: 初始化變數 count = 0 // 用來計算目標值出現次數  \n→ Step 4: 初始化變數 chosenIndex = -1 // 儲存目前被選中的索引  \n→ Step 5: 開始遍歷 nums 的每個索引 i 從 0 到 nums.length-1  \n  → Decision: 如果 nums[i] == target? // 判斷是否為目標值  \n    Yes → Step 6: 將 count 加 1 // 目標值出現一次  \n    Yes → Step 7: 產生隨機整數 r 在範圍 [1, count]  \n    Yes → Decision: 如果 r == 1? // Reservoir sampling：只在第一次遇到時選擇  \n      Yes → Step 8: chosenIndex = i // 選中此索引  \n      No → Step 9: 跳過 // 其餘情況不改變 chosenIndex  \n→ Step 10: 結束遍歷 // 所有元素已檢查完畢  \n→ Step 11: 回傳 chosenIndex // 返回最終隨機選中的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nGot (Norm):      '[1,10,11,12,13]'\n--- (Raw) ---\nRaw Expected: '[1,10,11,12,13,2,3,4,5,6,7,8,9]'\nRaw Got:      '[1, 10, 11, 12, 13]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    \"\"\"Return numbers from 1 to n in lexicographical order.\"\"\"\n    result = []\n    cur = 1\n    while cur <= n:\n        result.append(cur)\n\n        # 1. Try to go to the first child (cur * 10)\n        if cur * 10 <= n:\n            cur *= 10\n            continue\n\n        # 2. Try to go to the next sibling\n        if cur % 10 != 9 and cur + 1 <= n:\n            cur += 1\n            continue\n\n        # 3. No child or sibling: climb up until we can go to the next sibling\n        while cur % 10 == 9:\n            cur //= 10\n        cur += 1\n\n        # If the next number is beyond n, we are done\n        if cur > n:\n            break\n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract the integer n from the input string (e.g., \"n = 13\")\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    ans = lexical_order(n)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The requirement: given integer n, return all numbers in range [1,n] sorted lexicographically. Must run O(n) time and O(1) extra space. We need to provide virtual code steps and explanations. Not actual code. Use Start, End, Decision, arrow. Provide each step line.\n\nWe need to design algorithm: can do iterative lexicographic DFS: start with 1, for each number, push to result; then if number*10 <= n, go deeper; else if number%10 != 9 and number+1 <= n, go to next sibling; else climb up. But we don't output actual array; just algorithm steps. Use O(1) extra space: we can use variable current and loop. Steps: set current=1; while current <= n: output current; if current*10 <= n: current *=10; else if current%10 !=9 and current+1 <= n: current +=1; else: while (current/10)%10==9 or current/10==0: current /=10; current +=1; But we need to produce virtual code lines.\n\nWe need to present each line as virtual code with explanation.\n\nWe'll produce steps:\n\nStart\n→ Set n = input // get n\n→ Set current = 1 // start from 1\n→ Set result = [] // placeholder for output\n→ While current <= n: // iterate until all numbers covered\n    → Output current // add to result\n    → Decision: if current * 10 <= n? // can go deeper\n        Yes → current = current * 10 // go to first child\n        No  → Decision: if current % 10 != 9 and current + 1 <= n? // can go to next sibling\n            Yes → current = current + 1 // next sibling\n            No  → Decision: if current / 10 == 0? // reached root\n                Yes → Break // all done\n                No  → current = current / 10 // climb up\n                → current = current + 1 // move to next sibling after climb\nEnd\n\nBut we need to ensure O(1) extra space: no array. We can output streaming. So maybe result not needed. So we can just output numbers.\n\nWe'll provide steps accordingly.\n\nMake sure to use correct arrow formatting.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set n = input // 取得上限 n  \n→ Set current = 1 // 從最小字典序 1 開始  \n\n→ While current ≤ n: // 依字典序遍歷所有數字  \n → Output current // 依序輸出當前數字  \n\n → Decision: 是否可以往子節點深挖? current × 10 ≤ n?  \n  Yes → current = current × 10 // 進入最左子節點（字典序最小的下一個數字）  \n  No → Decision: 是否能往同級右邊兄弟? current mod 10 ≠ 9 且 current + 1 ≤ n?  \n   Yes → current = current + 1 // 移動到同級下一個兄弟  \n   No → Decision: 是否已回到根節點? current / 10 = 0?  \n    Yes → Break // 所有數字已輸出，結束循環  \n    No → current = current / 10 // 從子節點回到父節點  \n    → current = current + 1 // 於父節點處移動到下一個兄弟  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp45w5ohrc.py\", line 43, in <module>\n    obj.push(arg[0])\n    ^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'push'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    # 若第一行為 \"Input\"，則移除\n    if data[0].strip().lower() == \"input\":\n        data = data[1:]\n    if len(data) < 2:\n        sys.exit(0)\n\n    ops = json.loads(data[0].strip())\n    args = json.loads(data[1].strip())\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops[1:], args[1:]):  # skip the initial \"MyQueue\" operation\n        if op == \"push\":\n            obj.push(arg[0])\n            results.append(\"null\")\n        elif op == \"pop\":\n            val = obj.pop()\n            results.append(str(val))\n        elif op == \"peek\":\n            val = obj.peek()\n            results.append(str(val))\n        elif op == \"empty\":\n            val = obj.empty()\n            results.append(\"true\" if val else \"false\")\n\n    # 輸出符合範例格式\n    print(\"[\" + \", \".join(results) + \"]\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for implementing MyQueue using two stacks. Provide each line with comment. Use arrows. Should include Start, End, Decision. Provide steps for push, pop, peek, empty. We should structure methods. Likely algorithm: use stack1 for push, stack2 for pop/peek: when pop or peek, if stack2 empty, transfer all from stack1 to stack2. Then pop/peek from stack2. Also check empty: return stack1 empty and stack2 empty.\n\nWe need to generate pseudocode for entire class. Each line as \"Start //\", \"→ Step: ...\" etc.\n\nLet's craft. For each method, step. But maybe we produce a single flow covering operations? Might produce pseudocode for entire class with methods. Provide line by line. Could use decision for pop/peek when stack2 empty. Provide general algorithm.\n\nLet's create structure:\n\nStart // Initialize queue\n→ Initialize stack1 // 用於入隊\n→ Initialize stack2 // 用於出隊\nEnd // End of initialization\n\nMethod push(x):\nStart // push(x)\n→ stack1.push(x) // 把元素放入stack1\nEnd\n\nMethod pop():\nStart // pop()\n→ Decision: 如果 stack2.isEmpty()? // 檢查stack2是否為空\n    Yes → Step: Transfer all from stack1 to stack2 // 將stack1的元素倒入stack2\n        → While stack1 is not empty\n            → temp = stack1.pop()\n            → stack2.push(temp)\n        → End While\n    No → // nothing\n→ result = stack2.pop() // 從stack2彈出前端元素\n→ Return result\nEnd\n\nMethod peek():\nStart // peek()\n→ Decision: 如果 stack2.isEmpty()?\n    Yes → Transfer as above\n    No → // nothing\n→ Return stack2.top() // 取得前端元素\nEnd\n\nMethod empty():\nStart // empty()\n→ Decision: 如果 stack1.isEmpty() AND stack2.isEmpty()?\n    Yes → Return true\n    No → Return false\nEnd\n\nLet's format accordingly.\n\nUse arrows \"→\". Use \"Decision:\" and \"Yes →\", \"No →\".\n\nWe must put each line with comment. Also use indentation for nested actions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始，初始化兩個堆疊以實作 FIFO 隊列  \n→ Initialize stack1 // 用於入隊操作  \n→ Initialize stack2 // 用於出隊、查首元素操作  \nEnd // 初始化結束  \n\n---  \nStart // push(x)：把元素 x 放入隊列尾部  \n→ stack1.push(x) // 直接把 x 放到 stack1 的頂部  \nEnd // push 完成  \n\n---  \nStart // pop()：移除並回傳隊列前端元素  \n→ Decision: 如果 stack2.isEmpty()? // 檢查是否需要轉移元素  \n  Yes → Step: Transfer all from stack1 to stack2 // 把所有 stack1 的元素倒轉到 stack2  \n    → While stack1 is not empty  \n     → temp = stack1.pop() // 從 stack1 取出頂部元素  \n     → stack2.push(temp) // 推入 stack2，維持 FIFO 順序  \n     → End While  \n  No  → // stack2 已經有元素，無需轉移  \n→ result = stack2.pop() // 從 stack2 取出前端元素  \n→ Return result // 回傳移除的元素  \nEnd // pop 完成  \n\n---  \nStart // peek()：回傳隊列前端元素但不移除  \n→ Decision: 如果 stack2.isEmpty()? // 必要時轉移元素  \n  Yes → Step: Transfer all from stack1 to stack2  \n    → While stack1 is not empty  \n     → temp = stack1.pop()  \n     → stack2.push(temp)  \n     → End While  \n  No  → // 已有元素，無需轉移  \n→ Return stack2.top() // 回傳 stack2 的頂部元素（隊列前端）  \nEnd // peek 完成  \n\n---  \nStart // empty()：判斷隊列是否為空  \n→ Decision: 如果 stack1.isEmpty() AND stack2.isEmpty()?  \n  Yes → Return true // 兩個堆疊皆空，隊列為空  \n  No  → Return false // 至少有一個堆疊有元素  \nEnd // empty 完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        Return the length of the longest uncommon subsequence among the given strings.\n        If none exists, return -1.\n        \"\"\"\n        # Count occurrences of each string\n        freq = Counter(strs)\n        # If any string is unique, its length is the answer\n        for s in strs:\n            if freq[s] == 1:\n                return len(s)\n        return -1\n\ndef main():\n    # Read entire stdin, strip whitespace\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse JSON array of strings\n    strs = json.loads(data)\n    # Compute result\n    sol = Solution()\n    result = sol.findLUSlength(strs)\n    # Output result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code. The problem: find longest uncommon subsequence length between strings in array. Known solution: if any string appears only once, its length is answer; otherwise -1. Explanation: because longest uncommon subsequence must be a whole string that's not subsequence of any other. If duplicates exist, can't use duplicate string. So algorithm: count frequencies; iterate strings; if freq==1 return len(string). If none return -1.\n\nWe need produce virtual code line by line, using Start, Decision, etc. Each line: virtual step + comment. Use arrows. Let's craft:\n\nStart\n→ Step 1: 初始化字典 counts // 建立每個字串出現次數\n→ Step 2: 對每個 str in strs: counts[str] += 1 // 统计频数\n→ Step 3: 对每个 str in strs:\n    Decision: counts[str] == 1? // 判断是否唯一\n        Yes → Step 4: 返回 len(str) // 唯一字符串即最长不通用子序列长度\n        No  → Step 5: 继续检查下一个字符串\n→ Step 6: 返回 -1 // 未找到唯一字符串\nEnd\n\nNeed to follow format: each line: virtual code step + space + // explanation. Use arrows. For decisions, indent lines.\n\nMake sure each line has no actual code, just virtual. Provide correct syntax as per example. Let's craft.\n\nAlso, we should ensure consistent formatting: \"→ Decision: counts[str] == 1? // ...\" and indent with 4 spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 counts // 用於統計每個字串的出現次數  \n→ Step 2: 對 strs 中每個 str 執行 counts[str] += 1 // 計算頻率  \n→ Step 3: 對 strs 中每個 str 執行  \n    Decision: counts[str] == 1? // 判斷此字串是否唯一  \n        Yes → Step 4: 回傳 len(str) // 唯一字串即為最長不通用子序列長度  \n        No  → Step 5: 進入下一個字串的判斷  \n→ Step 6: 回傳 -1 // 所有字串都有重複，無不通用子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\ndef permute(nums):\n    \"\"\"\n    回傳 nums 所有可能的排列。\n    采用交换方式的回溯算法，时间复杂度 O(n! * n)，空间复杂度 O(n! * n)（结果占用空间）。\n    \"\"\"\n    res = []\n\n    def backtrack(start):\n        # 如果已把所有元素放到前面，说明得到一个完整排列\n        if start == len(nums):\n            res.append(nums[:])  # 追加当前排列的拷贝\n            return\n        # 尝试把每个未处理的元素放到当前 start 位置\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]  # 交换\n            backtrack(start + 1)                          # 递归处理后续位置\n            nums[start], nums[i] = nums[i], nums[start]  # 回溯，恢复原状态\n\n    backtrack(0)\n    return res\n\nif __name__ == \"__main__\":\n    # 从标准输入读取数据\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 预期输入格式类似 \"nums = [1,2,3]\"\n    # 先分离等号左侧（可选）和右侧的列表字符串\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n    else:\n        list_str = data\n    list_str = list_str.strip()\n\n    # 用 ast.literal_eval 解析列表，安全且支持任意合法 Python 字面量\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        nums = []\n\n    # 计算所有排列\n    result = permute(nums)\n\n    # 输出结果，使用 json.dumps 去除默认空格，匹配题目示例\n    print(json.dumps(result, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations for generating all permutations of an array of distinct integers. It's a classic backtracking algorithm. Use virtual code arrow syntax. We'll produce steps: Start, Step to initialize result, define backtrack function, recursion, etc. Must output in Traditional Chinese. Ensure each line ends with // 解釋. Each line: \"Start // 程式開始執行\" etc. Use \"→\" for steps, \"Decision:\" for branching. Use \"Yes →\" and \"No →\". Must include arrow after each step. Should not output actual code. Just structure. Use proper indentation? The example uses indentation with arrow inside decision blocks. We should use that style. Let's produce maybe 12-15 lines.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 初始化答案陣列 result // 用來存放所有排列\n→ Step 2: 定義遞迴函式 backtrack(current, used) // current為目前排列，used為已選取元素的布林陣列\n→ Decision: 若 current 長度等於 nums 長度? // 判斷是否已形成完整排列\n    Yes → Step 3: 將 current 複製並加入 result // 將完整排列加入答案\n    No → Step 4: 循環遍歷 nums 以尋找未使用的元素 // 選擇下一個候選\n        → Decision: 若元素已被 used? // 判斷此元素是否已被選取\n            Yes → No → // 跳過已使用的元素\n            No → Step 5: 將元素加入 current 並標記為 used // 進行選擇\n                → Step 6: 呼叫 backtrack(current, used) // 繼續遞迴\n                → Step 7: 從 current 移除最後一個元素並標記為未使用 // 回溯\n→ Step 8: 呼叫 backtrack([], [false]*nums.length) // 開始遞迴\n→ Step 9: 回傳 result // 將所有排列返回\nEnd // 程式執行結束\n\nCheck formatting: Each line includes \"→\" after \"Start\"? Start uses no arrow. Example: \"Start //\". Then each line uses \"→ Step X\". For Decision blocks, use indentation: \"Decision: ...\" then lines indented with arrow and Yes/No. Example shows \"Yes → Step\". For No block, \"No  → Decision\". We'll follow that.\n\nEnsure that \"→ Step 1:\" lines are aligned. For decisions inside loops, use indentation with arrow and maybe nested indentation. We'll keep simple.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化答案陣列 result // 用來存放所有排列  \n→ Step 2: 定義遞迴函式 backtrack(current, used) // current 為目前排列，used 為已選取元素的布林陣列  \n→ Decision: 若 current 長度等於 nums 長度? // 判斷是否已形成完整排列  \n Yes → Step 3: 將 current 複製並加入 result // 將完整排列加入答案  \n No  → Step 4: 循環遍歷 nums 以尋找未使用的元素 // 選擇下一個候選  \n  → Decision: 若元素已被 used? // 判斷此元素是否已被選取  \n   Yes → No  → // 跳過已使用的元素  \n   No  → Step 5: 將元素加入 current 並標記為 used // 進行選擇  \n    → Step 6: 呼叫 backtrack(current, used) // 繼續遞迴  \n    → Step 7: 從 current 移除最後一個元素並標記為未使用 // 回溯  \n→ Step 8: 呼叫 backtrack([], [false]*nums.length) // 開始遞迴  \n→ Step 9: 回傳 result // 將所有排列返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,2,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 2, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的列表，方便隨機取\n        self.data = []\n        # value -> set of indices 在 data 中的位置集合\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        # 將 val 加到 data 最後\n        self.data.append(val)\n        # 新位置是 len-1，加入索引集合\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此 val 為首次出現，返回 True，否則 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        # 若該值不存在，直接返回 False\n        if not self.idx_map[val]:\n            return False\n        # 取得一個索引要被移除\n        remove_idx = self.idx_map[val].pop()\n        # 取最後一個元素位置\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n        # 把最後一個元素放到要移除的位置\n        self.data[remove_idx] = last_val\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n        # 刪除最後一個元素\n        self.data.pop()\n        # 如果該值的索引集合已空，刪除鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機取一個索引並返回對應元素\n        return random.choice(self.data)\n\ndef main():\n    input_str = sys.stdin.read().strip()\n    if not input_str:\n        return\n    # 將輸入包成 JSON 數組，解析出兩個列表\n    ops, args = json.loads('[' + input_str + ']')\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == 'RandomizedCollection':\n            obj = RandomizedCollection()\n            res.append(None)\n        elif op == 'insert':\n            res.append(obj.insert(arg[0]))\n        elif op == 'remove':\n            res.append(obj.remove(arg[0]))\n        elif op == 'getRandom':\n            res.append(obj.getRandom())\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 的輸出格式\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the implementation of RandomizedCollection, with each line including virtual code step and comment. Use structure with Start, Decision, Yes →, No →, End. Provide step-by-step algorithm. Not actual code. Should detail initialization, insert, remove, getRandom. Provide operations using array and hashmap of value to set of indices. Provide random selection from array. Provide O(1). Use typical solution. Provide pseudocode. Let's write line by line:\n\nStart\n→ Initialize array list, map value->set of indices\nThen define insert\nStep 1: Append val to array\nStep 2: Add new index to map\nStep 3: Return true if size of set was 1 else false\n\nSimilarly remove: check existence, get index to remove, swap with last, update indices sets, pop last, adjust map, remove empty set, return true/false\n\ngetRandom: random index within array length, return element.\n\nLet's produce each step with comments. Use arrows: →. Use Decision with Yes→. Ensure each line has comment after space.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立空的陣列 `arr` 用於存放所有元素 // 使得 getRandom 可以直接透過索引取得元素  \n→ Step 2: 建立雜湊表 `idxMap`，鍵為值 `val`，值為該值在 `arr` 中所有索引的集合 // 方便 O(1) 取得及更新索引  \n\n//---------------------  Insert ---------------------//\n→ Step 3: Function `insert(val)` // 插入操作  \n→ Decision: 檢查 `val` 是否已存在於 `idxMap`? // 用來決定回傳值  \n    Yes → Step 4: 將 `val` 加入 `arr` 的尾端，索引為 `len(arr)-1` // 實際插入  \n        → Step 5: 在 `idxMap[val]` 中加入新索引 `len(arr)-1` // 更新索引集合  \n        → Step 6: Return `false` // 因 `val` 已存在，插入後不變  \n    No  → Step 7: 同步執行步驟 4、5  \n        → Step 8: Return `true` // `val` 原本不存在，插入成功  \n\n//---------------------  Remove ---------------------//\n→ Step 9: Function `remove(val)` // 移除操作  \n→ Decision: 檢查 `idxMap` 是否包含 `val`?  \n    Yes → Step 10: 取得 `idxMap[val]` 中任一索引 `removeIdx` // 任取要移除的索引  \n        → Step 11: 取得陣列尾端元素 `lastVal` 與其索引 `lastIdx = len(arr)-1` // 準備交換  \n        → Step 12: 把 `lastVal` 放到 `removeIdx` 位置 `arr[removeIdx] = lastVal` // 交換位置  \n        → Step 13: 更新 `idxMap[lastVal]`：  \n                → Step 14: 移除 `lastIdx` 從 `idxMap[lastVal]` 集合  \n                → Step 15: 若 `lastIdx != removeIdx`，再將 `removeIdx` 加入 `idxMap[lastVal]` 集合 // 更新新位置  \n        → Step 16: 從 `idxMap[val]` 移除 `removeIdx` 集合  \n        → Step 17: 若 `idxMap[val]` 為空，刪除該鍵 // 清除空集合  \n        → Step 18: 移除 `arr` 的最後一個元素 `arr.pop()` // 真正刪除元素  \n        → Step 19: Return `true` // 成功移除  \n    No  → Step 20: Return `false` // `val` 不存在，無法移除  \n\n//---------------------  getRandom ---------------------//\n→ Step 21: Function `getRandom()` // 隨機取得  \n→ Step 22: 生成隨機整數 `randIdx` 在範圍 [0, len(arr)-1]  \n→ Step 23: Return `arr[randIdx]` // 直接取得隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"\n    MedianFinder 使用兩個堆來保持資料流中的中位數。\n    小半部分（lower）使用最大堆（用負值在 Python 的最小堆實現），\n    大半部分（upper）使用最小堆。\n    \"\"\"\n    def __init__(self):\n        # 最大堆（存負值）存放小半數字\n        self.lower = []\n        # 最小堆存放大半數字\n        self.upper = []\n\n    def addNum(self, num: int) -> None:\n        \"\"\"\n        把新數字插入兩個堆之一，並保持兩堆大小差不超過 1。\n        \"\"\"\n        # 先將數字插入左堆（最大堆）\n        heapq.heappush(self.lower, -num)\n\n        # 保持「左堆最大值」不大於「右堆最小值」的性質\n        if self.lower and self.upper and (-self.lower[0] > self.upper[0]):\n            val = -heapq.heappop(self.lower)\n            heapq.heappush(self.upper, val)\n\n        # 兩堆平衡：左堆可以比右堆多 1 個，右堆不可以比左堆多\n        if len(self.lower) > len(self.upper) + 1:\n            val = -heapq.heappop(self.lower)\n            heapq.heappush(self.upper, val)\n        elif len(self.upper) > len(self.lower):\n            val = heapq.heappop(self.upper)\n            heapq.heappush(self.lower, -val)\n\n    def findMedian(self) -> float:\n        \"\"\"\n        返回目前所有數字的中位數。\n        \"\"\"\n        if len(self.lower) > len(self.upper):\n            return -self.lower[0]\n        return (-self.lower[0] + self.upper[0]) / 2.0\n\n\ndef main() -> None:\n    \"\"\"\n    主程序：\n    1. 從 stdin 讀取輸入，解析操作列表與參數列表。\n    2. 按順序執行每個操作，收集結果。\n    3. 將結果以 JSON 格式輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離兩個 JSON 列表：操作列表和參數列表\n    # 依照括號深度分割，確保分隔符 ',' 不是在內部\n    depth = 0\n    split_index = None\n    for i, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_index = i\n            break\n\n    if split_index is None:\n        raise ValueError(\"Invalid input format\")\n\n    ops_str = data[:split_index].strip()\n    args_str = data[split_index + 1:].strip()\n\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    results = []\n    median_finder = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            median_finder = MedianFinder()\n            results.append(None)\n        elif op == \"addNum\":\n            median_finder.addNum(arg[0])\n            results.append(None)\n        elif op == \"findMedian\":\n            median = median_finder.findMedian()\n            results.append(median)\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    # 輸出結果，使用 JSON 以得到 null 表示\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MedianFinder class with addNum and findMedian, using typical approach: two heaps (max-heap for lower half, min-heap for upper half). We need to generate virtual code step by step with explanations. Format: each line: \"虛擬碼步驟 // 解釋\". Use arrow →, Decision: etc. Let's outline.\n\nStart, Initialize two heaps: lower (max), upper (min). AddNum: insert num into appropriate heap, balance sizes so difference <=1. findMedian: if sizes equal, return average of roots; else return root of larger heap. End. We'll break into steps. Use decision to check size parity, etc. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化兩個空堆：lower (最大堆) 及 upper (最小堆) // 用於分別存放小半與大半的數字\n→ Step 2: 定義 addNum(num) 方法 // 進入資料流新增數字的流程\n→ Decision: 若 num ≤ lower.最大值? // 判斷新數應歸入哪一堆\n    Yes → Step 3: 將 num 加入 lower // 小於等於中位數放入最大堆\n    No  → Step 4: 將 num 加入 upper // 大於中位數放入最小堆\n→ Step 5: 調整堆大小差距 // 確保兩堆大小差不超過 1\n→ Decision: 若 lower.size > upper.size + 1? // 若左堆過大\n    Yes → Step 6: 移動 lower.最大值 到 upper // 重新平衡\n    No → Decision: 若 upper.size > lower.size + 1? // 若右堆過大\n        Yes → Step 7: 移動 upper.最小值 到 lower // 重新平衡\n        No → Step 8: 完成 addNum // addNum 方法結束\n→ Step 9: 定義 findMedian() 方法 // 取得目前資料流的中位數\n→ Decision: 若 lower.size == upper.size? // 數量是否相等\n    Yes → Step 10: median = (lower.最大值 + upper.最小值) / 2.0 // 兩堆平均\n    No → Decision: 若 lower.size > upper.size? // 左堆多\n        Yes → Step 11: median = lower.最大值 // 取左堆頂\n        No  → Step 12: median = upper.最小值 // 取右堆頂\n→ Step 13: 回傳 median // 找到中位數後輸出\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv2wxwcza.py\", line 54, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpv2wxwcza.py\", line 42, in parse_input\n    raise ValueError(\"Invalid input format\")\nValueError: Invalid input format"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp18gssk58.py\", line 54, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp18gssk58.py\", line 42, in parse_input\n    raise ValueError(\"Invalid input format\")\nValueError: Invalid input format"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        插入並合併區間，保持區間不重疊且按起點排序。\n        \"\"\"\n        result = []          # 用來儲存合併後的區間\n        i = 0\n        n = len(intervals)\n\n        # 先把所有完全在 newInterval 左側的區間加入結果\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 將所有與 newInterval 重疊的區間合併\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # 把合併後的 newInterval 加入結果\n        result.append(newInterval)\n\n        # 把剩餘在右側的區間直接加入\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 intervals 與 newInterval。\n    \"\"\"\n    pattern = r'intervals\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*newInterval\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        raise ValueError(\"Invalid input format\")\n    intervals = ast.literal_eval(match.group(1))\n    new_interval = ast.literal_eval(match.group(2))\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入\n    intervals, new_interval = parse_input(raw_input)\n\n    # 呼叫解法\n    sol = Solution()\n    merged = sol.insert(intervals, new_interval)\n\n    # 輸出結果\n    print(merged)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Use Start, Decision, Step lines, arrow.\n\nWe need algorithm: Insert interval into sorted non-overlapping intervals, merging if necessary. Typical algorithm: result list. For each interval in intervals: if interval.end < newInterval.start -> append interval. Else if interval.start > newInterval.end -> if not yet added newInterval -> append newInterval; then append remaining intervals. Else they overlap: merge: newInterval.start = min(newInterval.start, interval.start); newInterval.end = max(newInterval.end, interval.end). After loop, if newInterval not added, append. Return result.\n\nImplement pseudo. Use Start, End. Use Decision: intervals empty? But algorithm can be straightforward.\n\nLet's produce step by step.\n\nWe also need to show decision for each condition. Use Yes →, No →. Provide each line.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的結果陣列 result // 用來儲存合併後的區間  \n→ Step 2: 取出新區間的起點 start, 終點 end // 方便後續比較  \n→ Decision: 是否已將 newInterval 加入結果? // 以標誌 hasInserted 追蹤  \n    No → Set hasInserted = False // 初始時尚未加入  \n\n→ For each interval in intervals: // 逐一檢查已有區間  \n    → Decision: interval.end < start? // 完全在新區間左側  \n        Yes → Step 3: 把 interval 加到 result // 不影響新區間  \n        No → Decision: interval.start > end? // 完全在新區間右側  \n            Yes → Decision: hasInserted? // 是否已插入新區間？  \n                Yes → Step 4: 把 interval 加到 result // 已插入，直接加入  \n                No  → Step 5: 把 newInterval 加到 result // 尚未插入，先加入  \n                → Step 6: 把 interval 加到 result // 然後加入當前區間  \n                → Set hasInserted = True // 標示已插入  \n            No  → Step 7: 合併兩區間  \n                → start = min(start, interval.start) // 更新合併後的起點  \n                → end = max(end, interval.end)   // 更新合併後的終點  \n                → // 仍不加入 result，因為可能還會有更多重疊  \n    → End of For loop  \n\n→ Decision: hasInserted? // 循環結束後檢查是否還未加入新區間  \n    No → Step 8: 把 newInterval 加到 result // 從未插入，加入最後  \n\n→ Step 9: 回傳 result // 取得插入並合併後的區間列表  \nEnd // 程式執行結束"
    },
    {
      "title": "All O`one Data Structure",
      "source_file": "Leetcode/leetcode432.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp97ocoxd2.py\", line 107, in <module>\n    main()\n  File \"/tmp/tmp97ocoxd2.py\", line 85, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 355, in raw_decode\n    raise JSONDecodeError(\"Expecting value\", s, err.value) from None\njson.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Node:\n    def __init__(self):\n        self.keys = set()\n        self.prev = None\n        self.next = None\n        self.count = 0\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node()\n        node.count = count\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        if key not in self.key_to_node:\n            return\n        node = self.key_to_node[key]\n        prev_count = node.count - 1\n        node.keys.remove(key)\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n    obj = None\n    outputs = []\n    for op, arg in zip(ops, args):\n        if op == \"AllOne\":\n            obj = AllOne()\n            outputs.append(None)\n        elif op == \"inc\":\n            obj.inc(arg[0])\n            outputs.append(None)\n        elif op == \"dec\":\n            obj.dec(arg[0])\n            outputs.append(None)\n        elif op == \"getMaxKey\":\n            outputs.append(obj.getMaxKey())\n        elif op == \"getMinKey\":\n            outputs.append(obj.getMinKey())\n    print(\"Output\")\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for design of AllOne class with O(1). The known solution: double-linked list of buckets by count, with hash map key->bucket node, and each bucket node has set of keys. Use sentinel head and tail. inc: if key not exist, add to bucket count=1; else move to next bucket count+1, create bucket if needed. dec: decrement, possibly remove from bucket, if count becomes 0 remove key. Also handle bucket removal when empty.\n\nAlso getMaxKey: tail.prev keys if any. getMinKey: head.next keys.\n\nWe need to produce steps line by line, with virtual code arrow etc.\n\nThe output should be only the steps, not actual code, just \"虛擬碼步驟 // 解釋\".\n\nWe need to output the whole algorithm? Probably outline initialization, inc, dec, getMaxKey, getMinKey. Provide pseudo steps.\n\nWe need to use structure: Start, End, Decision.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化雙向鏈表節點 head, tail // 用於存放最小和最大計數節點\n→ Step 2: 建立 key→節點 的 HashMap // 快速定位 key 所在的節點\n→ Step 3: 建立 count→節點 的 HashMap // 快速定位計數節點\n\ninc(key):\nStart\n→ Decision: key 是否存在? // 檢查 key 是否已在資料結構\n    Yes → Step 4: current = keyToNode[key] // 取得 key 所在節點\n          Step 5: next = current.next // 目標節點為 count+1\n          Step 6: Decision: next.count == current.count+1? // 是否已存在目標節點\n                Yes → Step 7: Move key to next.keys // 將 key 加入下一節點的 key 集合\n                No  → Step 8: 新建節點 newNode(count=current.count+1) // 新增節點\n                         Step 9: Insert newNode 之後在 current 之後\n                         Step 10: Move key to newNode.keys\n          Step 11: Remove key from current.keys\n          Step 12: Decision: current.keys 是否為空? // 若空，刪除節點\n                Yes → Step 13: Remove current from linked list\n                No  → No action\n          Step 14: keyToNode[key] = targetNode // 更新 key 位置\n    No → Step 15: Decision: head.next.count == 1? // 是否已存在計數為1的節點\n          Yes → Step 16: Move key to head.next.keys\n          No  → Step 17: 新建節點 node(count=1)\n                 Step 18: Insert node after head\n                 Step 19: Add key to node.keys\n          Step 20: keyToNode[key] = node\n          Step 21: countToNode[1] = node\n\ndec(key):\nStart\n→ Step 22: current = keyToNode[key]\n→ Step 23: prev = current.prev // 目標節點為 count-1\n→ Step 24: Decision: current.count == 1? // 如果是1，刪除 key\n          Yes → Step 25: Remove key from current.keys\n                 Step 26: Remove keyToNode[key]\n                 Step 27: Decision: current.keys 是否為空? // 若空，刪除節點\n                       Yes → Step 28: Remove current from linked list\n                       No  → No action\n          No  → Step 29: Decision: prev.count == current.count-1? // 是否已存在目標節點\n                    Yes → Step 30: Move key to prev.keys\n                    No  → Step 31: 新建節點 newNode(count=current.count-1)\n                           Step 32: Insert newNode 之前在 current 之前\n                           Step 33: Move key to newNode.keys\n          Step 34: Remove key from current.keys\n          Step 35: Decision: current.keys 是否為空? // 若空，刪除節點\n                    Yes → Step 36: Remove current from linked list\n                    No  → No action\n          Step 37: keyToNode[key] = targetNode\n\ngetMaxKey():\nStart\n→ Step 38: Decision: tail.prev == head? // 是否沒有元素\n          Yes → Step 39: return \"\"\n          No  → Step 40: key = 任意 key in tail.prev.keys // 任意一個最大計數的 key\n                Step 41: return key\n\ngetMinKey():\nStart\n→ Step 42: Decision: head.next == tail? // 是否沒有元素\n          Yes → Step 43: return \"\"\n          No  → Step 44: key = 任意 key in head.next.keys // 任意一個最小計數的 key\n                Step 45: return key\n\nEnd\n\nWe must keep each line with virtual code step then comment. Ensure each line is one step.\n\nWe also need to show virtual code arrows. Use \"→\".\n\nWe'll structure as lines. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 head 節點(count=0) // 代表最小節點  \n→ Step 2: 建立 tail 節點(count=∞) // 代表最大節點  \n→ Step 3: 連接 head → tail // 初始化雙向鏈表  \n→ Step 4: 初始化 HashMap keyToNode // key → 節點位置  \n→ Step 5: 初始化 HashMap countToNode // count → 節點位置  \n\n// ==================== inc(key) ====================  \nStart // inc 開始  \n→ Decision: key 是否已存在?  \n Yes → Step 6: current = keyToNode[key] // 取得 key 的節點  \n  → Step 7: next = current.next // 下一個節點 (可能是 count+1)  \n  → Decision: next.count == current.count+1?  \n   Yes → Step 8: Move key to next.keys // 加入下一節點的 key 集合  \n   No  → Step 9: 建立新節點 newNode(count=current.count+1)  \n    → Step 10: Insert newNode 後於 current  \n    → Step 11: Move key to newNode.keys  \n  → Step 12: Remove key from current.keys  \n  → Decision: current.keys 是否空?  \n   Yes → Step 13: 移除 current 節點  \n   No  → No action  \n  → Step 14: keyToNode[key] = (next 或 newNode) // 更新 key 位置  \n  → Step 15: 若新節點建立，更新 countToNode[newNode.count] = newNode  \n No  → Step 16: Decision: head.next.count == 1?  \n  Yes → Step 17: Move key to head.next.keys // 直接加入已有的 count=1 節點  \n  No  → Step 18: 建立節點 node(count=1)  \n   → Step 19: Insert node 後於 head  \n   → Step 20: Add key to node.keys  \n  → Step 21: keyToNode[key] = node // 設定 key 位置  \n  → Step 22: countToNode[1] = node // 設定 count 位置  \n\nEnd // inc 完成  \n\n// ==================== dec(key) ====================  \nStart // dec 開始  \n→ Step 23: current = keyToNode[key] // 取得 key 的節點  \n→ Step 24: prev = current.prev // 目標節點 (count-1)  \n→ Decision: current.count == 1?  \n Yes → Step 25: Remove key from current.keys  \n  → Step 26: Delete keyToNode[key] // 移除 key 映射  \n  → Decision: current.keys 是否空?  \n   Yes → Step 27: 移除 current 節點  \n   No  → No action  \n No  → Step 28: Decision: prev.count == current.count-1?  \n  Yes → Step 29: Move key to prev.keys // 加入已有的 count-1 節點  \n  No  → Step 30: 建立新節點 newNode(count=current.count-1)  \n   → Step 31: Insert newNode 前於 current  \n   → Step 32: Move key to newNode.keys  \n  → Step 33: Remove key from current.keys  \n  → Decision: current.keys 是否空?  \n   Yes → Step 34: 移除 current 節點  \n   No  → No action  \n  → Step 35: keyToNode[key] = (prev 或 newNode) // 更新 key 位置  \n  → Step 36: 若新節點建立，更新 countToNode[newNode.count] = newNode  \n\nEnd // dec 完成  \n\n// ==================== getMaxKey() ====================  \nStart // getMaxKey 開始  \n→ Decision: tail.prev == head? // 是否沒有任何節點  \n Yes → Step 37: return \"\" // 空字串  \n No  → Step 38: 任意取一個 key 從 tail.prev.keys  \n  → Step 39: return 取出的 key  \n\nEnd // getMaxKey 完成  \n\n// ==================== getMinKey() ====================  \nStart // getMinKey 開始  \n→ Decision: head.next == tail? // 是否沒有任何節點  \n Yes → Step 40: return \"\" // 空字串  \n No  → Step 41: 任意取一個 key 從 head.next.keys  \n  → Step 42: return 取出的 key  \n\nEnd // getMinKey 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    colors = ['R', 'Y', 'B', 'G', 'W']\n    INF = 10 ** 9\n\n    def __init__(self):\n        self.memo = {}\n\n    def collapse(self, s: str) -> str:\n        \"\"\"\n        Repeatedly remove groups of 3 or more consecutive same-colored balls.\n        \"\"\"\n        while True:\n            n = len(s)\n            i = 0\n            new_parts = []\n            removed = False\n            while i < n:\n                j = i + 1\n                while j < n and s[j] == s[i]:\n                    j += 1\n                if j - i >= 3:\n                    removed = True  # this group will be removed\n                else:\n                    new_parts.append(s[i:j])\n                i = j\n            if not removed:\n                break\n            s = ''.join(new_parts)\n        return s\n\n    def dfs(self, board: str, hand_counts: dict) -> int:\n        if not board:\n            return 0\n        key = (board, tuple(hand_counts[c] for c in self.colors))\n        if key in self.memo:\n            return self.memo[key]\n\n        min_steps = self.INF\n        for color in self.colors:\n            if hand_counts[color] == 0:\n                continue\n            # Try inserting this color at all positions that can form a group\n            for pos in range(len(board) + 1):\n                left_len = 0\n                i = pos - 1\n                while i >= 0 and board[i] == color:\n                    left_len += 1\n                    i -= 1\n                right_len = 0\n                i = pos\n                while i < len(board) and board[i] == color:\n                    right_len += 1\n                    i += 1\n                if left_len + right_len + 1 < 3:\n                    continue  # inserting here won't trigger a removal\n\n                # Simulate insertion and collapse\n                new_board = board[:pos] + color + board[pos:]\n                collapsed = self.collapse(new_board)\n\n                # Use one ball from hand\n                hand_counts[color] -= 1\n                res = self.dfs(collapsed, hand_counts)\n                hand_counts[color] += 1\n\n                if res != self.INF:\n                    min_steps = min(min_steps, 1 + res)\n\n        self.memo[key] = min_steps\n        return min_steps\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        hand_counts = defaultdict(int)\n        for ch in hand:\n            hand_counts[ch] += 1\n        result = self.dfs(board, hand_counts)\n        return -1 if result == self.INF else result\n\n\ndef parse_input(text: str):\n    \"\"\"\n    Parse input that may be in the form:\n        board = \"WRRBBW\", hand = \"RB\"\n    or just two lines with the board and hand strings.\n    \"\"\"\n    board_match = re.search(r'board\\s*=\\s*\"([^\"]+)\"', text)\n    hand_match = re.search(r'hand\\s*=\\s*\"([^\"]+)\"', text)\n    if board_match and hand_match:\n        board = board_match.group(1)\n        hand = hand_match.group(1)\n    else:\n        lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            board, hand = lines[0], lines[1]\n        else:\n            parts = re.split(r'[,\\s]+', text.strip())\n            board, hand = parts[0], parts[1] if len(parts) > 1 else ''\n    board = board.strip('\"').strip(\"'\")\n    hand = hand.strip('\"').strip(\"'\")\n    return board, hand\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    board, hand = parse_input(data)\n    solution = Solution()\n    answer = solution.findMinStep(board, hand)\n    print(answer)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanation. This is a typical Zuma problem: find minimum insertions to clear board using hand. It's basically a DFS with memoization, backtracking. Use state: board string, hand counts. Recursively try to insert each color available that can cause removal. For each possible insertion position between same color run, try insertion. After insertion, collapse board by removing groups of >=3. Recursively compute min steps.\n\nWe need to produce step-by-step pseudo-code. Since we need to output line by line, each with a comment. Use \"Start\", \"End\", \"Decision:\", etc. Also need to incorporate recursion and memoization. Provide lines like:\n\nStart // 程式開始\n→ Step 1: Define function minInsert(board, handCounts) // 主函式\n→ Decision: If board is empty? // 檢查是否已經清空\n    Yes → Return 0 // 無需插入\n    No → ... \n etc.\n\nBut we need to produce full algorithm description. We'll include memoization: use dictionary memo keyed by board+handCounts. We'll include collapse function collapse(board) that removes groups recursively.\n\nWe need to outline recursion steps. Also we can include optimization: try each color that can form group after insertion.\n\nAlso include base case: if no balls left in hand return Infinity -> unreachable.\n\nWe need to output in the specified format: each line: `虛擬碼步驟 [空格] // 解釋/說明`. Use arrows `→`, `Yes →`, `No →`, `Decision:`.\n\nLet's produce pseudo-code in Chinese.\n\nWe can structure like:\n\nStart // 程式開始\n→ Step 1: 定義 memo為空字典 // 用於存儲已計算的狀態\n→ Function minInsert(board, handCounts) // 計算最小插入次數\n→ Decision: If board為空? // 判斷是否已清空\n    Yes → Return 0 // 無需插入\n    No → \n        // 生成 key\n        Key = board + \"|\" + handCountsString\n        Decision: 如果 key在 memo? \n            Yes → Return memo[key]\n            No →\n                // 初始化最小值為無限大\n                minSteps = INF\n                // 對每種顏色進行嘗試\n                For color in handColors where handCounts[color] > 0:\n                    // 找到所有可以插入的索引位置\n                    For pos in 0..len(board):\n                        // 檢查插入位置是否合法並能形成組\n                        Decision: 如果可插入? // 若插入後同色連續數 >=3\n                            Yes →\n                                // 生成新手牌\n                                newHand = handCounts\n                                newHand[color] -= 1\n                                // 在board插入color於pos\n                                newBoard = board[:pos] + color + board[pos:]\n                                // 合併相同顏色的連續組\n                                collapsedBoard = collapse(newBoard)\n                                // 递归求解\n                                result = minInsert(collapsedBoard, newHand)\n                                Decision: 如果 result != INF? \n                                    Yes → minSteps = min(minSteps, 1 + result)\n                // 如果minSteps仍為INF，表示無法完成\n                Decision: 如果 minSteps == INF? \n                    Yes → memo[key] = INF\n                    No  → memo[key] = minSteps\n                Return memo[key]\n→ End // 程式結束\n\nAlso define collapse function.\n\nDefine collapse(board):\n→ Step: While True:\n    找到所有連續相同顏色長度>=3\n    If none，Break\n    Remove所有這些區段\nReturn board\n\nBut collapse could be iterative.\n\nNeed to produce step-by-step for collapse too.\n\nWe should also include converting hand string to counts mapping.\n\nLet's output lines accordingly.\n\nWe need to be careful to include all steps and comments. Use `Decision:` for if conditions.\n\nWe also need to mention that INF can be large integer or sentinel.\n\nThe pseudocode will include loops, function definitions, recursion.\n\nLet's produce final answer with lines.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 定義 memo 為空字典 // 用於記錄已計算的狀態，避免重複計算\n→ Function minInsert(board, handCounts) // 主函式，輸入目前棋盤及手牌顏色數量\n→ Decision: 若 board 為空? // 棋盤已清空，直接完成\n    Yes → Return 0 // 無需再插入球\n    No → \n        → Step 2: 產生 key = board + \"|\" + handCountsString // 以棋盤及手牌組合作為緩存鍵\n        → Decision: 若 key 在 memo 中? // 檢查是否已計算過此狀態\n            Yes → Return memo[key] // 直接回傳記錄的結果\n            No → \n                → Step 3: minSteps ← INF // 初始化最小插入次數為無限大\n                → Step 4: 循環遍歷每種顏色 color，若 handCounts[color] > 0\n                    → For color in handColors where handCounts[color] > 0:\n                        → Step 5: 循環遍歷所有可插入位置 pos (0 到 len(board))\n                            → For pos in 0..len(board):\n                                → Decision: 檢查插入位置是否能立即形成 3 個以上同色球? // 只嘗試能夠產生消除的插入\n                                    Yes →\n                                        → Step 6: 產生 newHand = handCounts，並將 newHand[color] 減 1 // 消耗一顆球\n                                        → Step 7: newBoard ← board[:pos] + color + board[pos:] // 在 pos 位置插入球\n                                        → Step 8: collapsedBoard ← collapse(newBoard) // 連續消除所有 ≥3 同色區段\n                                        → Step 9: result ← minInsert(collapsedBoard, newHand) // 重新遞迴求解\n                                        → Decision: 若 result ≠ INF? // 若此路徑能成功完成\n                                            Yes → minSteps ← min(minSteps, 1 + result) // 更新最小值\n                → Decision: 若 minSteps 仍為 INF? // 無任何合法路徑能成功\n                    Yes → memo[key] ← INF\n                    No  → memo[key] ← minSteps\n                → Return memo[key] // 回傳本狀態的最小插入數\n\n→ Function collapse(board) // 把棋盤上所有能夠消除的區段消除\n→ Step 10: 循環\n    → Step 11: 找到所有長度 ≥3 的連續同色區段\n    → Decision: 若不存在? // 無更多可消除的區段\n        Yes → Break // 結束循環\n        No →\n            → Step 12: 從 board 中移除所有這些區段 // 可能一次移除多個\n→ Step 13: Return board // 返回經過全部消除後的棋盤\n\n→ End // 程式結束"
    },
    {
      "title": "Can Place Flowers",
      "source_file": "Leetcode/leetcode605.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "flowerbed = [1,0,0,0,1], n = 1",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpaagmy5e0.py\", line 29, in <module>\n    n_part = parts[1].split('=')[1].strip()\n             ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "flowerbed = [1,0,0,0,1], n = 2",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp964bvert.py\", line 29, in <module>\n    n_part = parts[1].split('=')[1].strip()\n             ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def canPlaceFlowers(self, flowerbed, n):\n        count = 0\n        length = len(flowerbed)\n        i = 0\n        while i < length:\n            if flowerbed[i] == 0:\n                empty_prev = (i == 0) or (flowerbed[i - 1] == 0)\n                empty_next = (i == length - 1) or (flowerbed[i + 1] == 0)\n                if empty_prev and empty_next:\n                    flowerbed[i] = 1\n                    count += 1\n                    if count >= n:\n                        return True\n                    i += 1  # skip next plot\n            i += 1\n        return count >= n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 支援輸入形如: \"flowerbed = [1,0,0,0,1], n = 1\"\n    parts = [p.strip() for p in data.split(',')]\n    flowerbed_part = parts[0].split('=')[1].strip()\n    n_part = parts[1].split('=')[1].strip()\n\n    flowerbed = eval(flowerbed_part)  # 解析列表\n    n = int(n_part)  # 解析整數\n\n    solution = Solution()\n    result = solution.canPlaceFlowers(flowerbed, n)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We should produce step by step algorithm. Should use Start, Decision, etc. Provide explanation after each line.\n\nWe need to consider input: flowerbed array of 0s and 1s, integer n. We need to check if n new flowers can be planted without adjacency. Standard problem: for each position, if it's empty and neighbors empty (or out of bounds), plant and count++ until count >= n.\n\nSo algorithm:\n\nStart\n→ Step: set count = 0 // counter for planted new flowers\n→ For each index i from 0 to length-1:\n    → Decision: if flowerbed[i] == 0? // empty plot?\n        → Decision: if (i==0 or flowerbed[i-1]==0) and (i==len-1 or flowerbed[i+1]==0)? // neighbors empty\n            Yes → Step: flowerbed[i] = 1 // plant flower\n            → Step: count +=1 // increment counter\n            → Decision: if count >= n? // enough planted?\n                Yes → Step: return true // success\n                No  → continue loop\n        → No → continue loop\n    → No → continue loop\n→ Decision: if count >= n? // after loop check\n    Yes → Step: return true\n    No  → Step: return false\nEnd\n\nWe need to format each line with virtual code arrow notation. Use \"Start\", \"End\". Each line with explanation comment.\n\nNeed to ensure each line is separate. Use indent for nested decision. Should use arrow \"→\". For decision lines, after arrow we specify \"Decision:\".\n\nExample: \"→ Decision: if flowerbed[i] == 0?\" etc.\n\nWe also need to show sub-decisions indentation. Use indent spaces. Provide each line separate.\n\nLet's produce.\n\nAlso for loops: \"→ For i from 0 to len-1:\" and inside indent.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step: count = 0 // 初始化已種植新花的數量\n\nLine 3: → For i = 0 to length(flowerbed)-1: // 逐個檢查每個地段\n\nLine 4:     → Decision: if flowerbed[i] == 0? // 只有空地才可能種植\n\nLine 5:         → Decision: if (i == 0 or flowerbed[i-1] == 0) and (i == len-1 or flowerbed[i+1] == 0)? // 確認左右相鄰地段都空\n\nLine 6:             Yes → Step: flowerbed[i] = 1 // 種植花\n\nLine 7:             → Step: count = count + 1 // 更新已種植數量\n\nLine 8:             → Decision: if count >= n? // 是否已達到需要的數量\n\nLine 9:                 Yes → Step: return true // 成功，足夠種植\n\nLine 10:                 No  → // 仍未達標，繼續檢查下一個地段\n\nLine 11:         No  → // 位置不符合種植條件，跳到下一個\n\nLine 12:     No  → // 當前地段已被占用，跳過\n\nLine 13: End // 迴圈結束\n\nLine 14: → Decision: if count >= n? // 從迴圈結束後再次確認\n\nLine 15:     Yes → Step: return true // 可以種植足夠數量\n\nLine 16:     No  → Step: return false // 無法達成\n\nLine 17: End // 程式結束\n\nBut need to keep Start/End only once. But we can use End at final. Maybe we don't need End after loop. But it's fine.\n\nMake sure each line has \"虛擬碼步驟\" and comment after space. Provide Chinese comment.\n\nAlso for return lines, we can use \"→ Step: return true\" etc.\n\nNeed to ensure we don't output actual code, just virtual steps.\n\nAlso we might need to indicate \"Start\" and \"End\" outside loops.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: count = 0 // 初始化已種植新花的數量  \n→ For i = 0 to length(flowerbed)-1: // 逐個檢查每個地段  \n → Decision: if flowerbed[i] == 0? // 只有空地才可能種植  \n  → Decision: if (i == 0 or flowerbed[i-1] == 0) and (i == length(flowerbed)-1 or flowerbed[i+1] == 0)? // 確認左右相鄰地段都空  \n   Yes → Step: flowerbed[i] = 1 // 種植花  \n   → Step: count = count + 1 // 更新已種植數量  \n   → Decision: if count >= n? // 是否已達到需要的數量  \n    Yes → Step: return true // 成功，足夠種植  \n    No  → // 仍未達標，繼續檢查下一個地段  \n  No  → // 位置不符合種植條件，跳到下一個  \n No  → // 當前地段已被占用，跳過  \nEnd // 迴圈結束  \n→ Decision: if count >= n? // 從迴圈結束後再次確認  \n Yes → Step: return true // 可以種植足夠數量  \n No  → Step: return false // 無法達成  \nEnd // 程式結束"
    },
    {
      "title": "Strange Printer",
      "source_file": "Leetcode/leetcode664.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"aaabbb\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\n\ndef strange_printer(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            # Start with printing s[i] separately\n            dp[i][j] = dp[i + 1][j] + 1\n            for k in range(i + 1, j + 1):\n                if s[k] == s[i]:\n                    # Merge the prints of s[i] and s[k]\n                    left = dp[i][k - 1] if k > i else 0\n                    right = dp[k][j]\n                    dp[i][j] = min(dp[i][j], left + right)\n    return dp[0][n - 1]\n\ndef extract_string(raw: str) -> str:\n    # Try to find a quoted string\n    start = raw.find('\"')\n    end = raw.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        return raw[start + 1:end]\n    # Fallback: strip possible 's =' and whitespace\n    raw = raw.strip()\n    if raw.startswith('s ='):\n        raw = raw[3:].strip()\n    return raw\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = extract_string(raw_input)\n    result = strange_printer(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: Strange Printer. Provide steps line by line, with virtual code and explanation. Should not output actual code. Just steps. We can outline DP approach: dp[i][j] min turns to print substring s[i..j]. Transition: dp[i][j] = dp[i+1][j] + 1; for k from i+1 to j if s[k]==s[i] then dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j]). Finally answer dp[0][n-1]. We need virtual code steps: Start, initialize n, dp matrix, loops, decisions, etc.\n\nWe need to produce as many lines as necessary to describe algorithm step by step. Each line with virtual code + explanation.\n\nLet's craft.\n\nLine1: Start // Start of algorithm\nLine2: → Step 1: n ← Length of string s // Determine string length\nLine3: → Step 2: Create 2D array dp[n][n] initialized to 0 // DP table\nLine4: → Decision: If n == 0? // Handle empty string\nLine5:    Yes → Step 3: Return 0 // No turns needed\nLine6:    No // Continue\nLine7: → For i from n-1 downto 0: // Fill dp from end\nLine8:    → For j from i to n-1: // Substring s[i..j]\nLine9:        → If i == j: // Single char\nLine10:           → dp[i][j] ← 1 // One turn\nLine11:        → Else:\nLine12:           → dp[i][j] ← dp[i+1][j] + 1 // Print s[i] separately\nLine13:           → For k from i+1 to j:\nLine14:               → Decision: If s[k] == s[i]?\nLine15:                  Yes → dp[i][j] ← min(dp[i][j], dp[i+1][k-1] + dp[k][j]) // Merge prints\nLine16:                  No // skip\nLine17: → End For (k)\nLine18: → End For (j)\nLine19: → End For (i)\nLine20: → Step 4: Return dp[0][n-1] // Minimum turns for whole string\nLine21: End // End of algorithm\n\nWe need to ensure proper formatting: each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nMake sure to include arrow indentation maybe with tabs/spaces. We can use indent via spaces or arrows? They mention using arrow characters. So we can use \"→\" to denote each step inside loops? Might be fine.\n\nLet's craft final answer with each line. Ensure each line ends with comment. We'll provide them.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← Length of string s // 取得字串長度  \n→ Step 2: Create 2D array dp[n][n] initialized to 0 // 建立 DP 表格  \n→ Decision: 如果 n == 0? // 檢查字串是否為空  \n  Yes → Step 3: Return 0 // 空字串不需要任何印刷次數  \n  No // 繼續執行  \n→ For i from n-1 downto 0: // 從右往左遍歷起始位置  \n  → For j from i to n-1: // 遍歷終止位置  \n    → Decision: 如果 i == j? // 單個字符子字串  \n      Yes → dp[i][j] ← 1 // 只需要一次印刷  \n      No // 進一步處理  \n      → dp[i][j] ← dp[i+1][j] + 1 // 先印出 s[i]，其餘子字串再處理  \n      → For k from i+1 to j: // 嘗試將 s[i] 與 s[k] 合併印刷  \n        → Decision: 如果 s[k] == s[i]? // 同一字符可合併  \n          Yes → dp[i][j] ← min(dp[i][j], dp[i+1][k-1] + dp[k][j]) // 合併後的最小步驟  \n          No // 兩字符不同，跳過  \n      → End For (k) // k 循環結束  \n  → End For (j) // j 循環結束  \n→ End For (i) // i 循環結束  \n→ Step 4: Return dp[0][n-1] // 回傳整個字串的最小印刷次數  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []  # list of [start, end), non-overlapping, sorted\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # overlap\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        l, r = self.ranges[i - 1]\n        return l <= left and right <= r\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    outputs = []\n    rm_instance = None\n    for line in lines:\n        if line.startswith(\"RangeModule\"):\n            # instantiate the module\n            rm_instance = RangeModule()\n            outputs.append(\"null\")\n        elif \"addRange\" in line:\n            # extract numbers\n            start = line.find('(')\n            end = line.find(')')\n            nums = line[start+1:end].split(',')\n            left, right = int(nums[0].strip()), int(nums[1].strip())\n            rm_instance.addRange(left, right)\n            outputs.append(\"null\")\n        elif \"removeRange\" in line:\n            start = line.find('(')\n            end = line.find(')')\n            nums = line[start+1:end].split(',')\n            left, right = int(nums[0].strip()), int(nums[1].strip())\n            rm_instance.removeRange(left, right)\n            outputs.append(\"null\")\n        elif \"queryRange\" in line:\n            start = line.find('(')\n            end = line.find(')')\n            nums = line[start+1:end].split(',')\n            left, right = int(nums[0].strip()), int(nums[1].strip())\n            result = rm_instance.queryRange(left, right)\n            outputs.append(\"true\" if result else \"false\")\n        else:\n            # ignore unknown lines\n            pass\n    # print result in the requested format\n    print('[' + ', '.join(outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudo-code for a RangeModule class, with addRange, queryRange, removeRange, using half-open intervals, typical solution is to maintain a list of non-overlapping intervals sorted. For each operation, iterate, merge, split. Provide pseudo-code per line with explanation. Should not include actual code, just pseudo-code steps with arrows. So we will present steps for initialization, addRange, queryRange, removeRange. Each line with explanation. Use arrow \"→\". We need to start with \"Start\". We'll need to outline the internal structure: list of intervals. Use a variable intervals as list of [start, end). For each method, describe loops.\n\nLet's create high-level pseudo-code:\n\nStart\n→ Step 1: intervals ← empty list // 存儲已追蹤的非重疊半開區間\n→ Method: addRange(left, right)\n    → Step 1.1: newStart ← left; newEnd ← right\n    → Step 1.2: i ← 0\n    → Step 1.3: while i < length(intervals) and intervals[i].end < newStart\n        → i++ // 跳過完全在新區間左側的區間\n    → Step 1.4: // 合併重疊區間\n        → while i < length(intervals) and intervals[i].start <= newEnd\n            → newStart ← min(newStart, intervals[i].start)\n            → newEnd ← max(newEnd, intervals[i].end)\n            → remove intervals[i]\n        // after loop i points to first non-overlap\n    → Step 1.5: insert [newStart, newEnd] at position i\n    → Step 1.6: // 完成\n→ Method: queryRange(left, right)\n    → Step 2.1: i ← 0\n    → Step 2.2: while i < length(intervals) and intervals[i].end < left\n        → i++ // 跳過左側不相關區間\n    → Step 2.3: if i == length(intervals) or intervals[i].start > left\n        → return False // 左側未被追蹤\n    → Step 2.4: if intervals[i].end >= right\n        → return True // 覆蓋整個區間\n    → Step 2.5: return False // 右側不足以覆蓋\n→ Method: removeRange(left, right)\n    → Step 3.1: i ← 0\n    → Step 3.2: while i < length(intervals) and intervals[i].end <= left\n        → i++ // 跳過左側不相關區間\n    → Step 3.3: // 處理重疊區間\n        → while i < length(intervals) and intervals[i].start < right\n            → cur ← intervals[i]\n            → if cur.start < left\n                → insert [cur.start, left] before i // 保留左半部分\n            → if cur.end > right\n                → replace intervals[i] with [right, cur.end] // 保留右半部分\n                → i++ // 跳過此區間\n                → break // 右側已處理完畢\n            → else\n                → remove intervals[i] // 完全被移除\n            // after removal/insertion i stays same for next loop\n    → Step 3.4: // 完成\nEnd\n\nWe should also include initialization. Use \"Start\" and \"End\". Each line preceded by \"→\" or \"Start\". Provide explanation comments in Chinese. Use \"Decision:\" maybe not necessary but could use for queryRange logic. Provide the pseudo-code line-by-line.\n\nLet's format. Use no actual code, just pseudo-code steps.\n\nWe need to include \"Start // 程式開始執行\". Then \"→ Step ...\". Use \"End // 程式執行結束\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: intervals ← [] // 初始化空列表，儲存已追蹤的非重疊半開區間  \n\n→ Method: addRange(left, right) // 新增區間  \n    → Step 1.1: newStart ← left; newEnd ← right // 取入參區間  \n    → Step 1.2: i ← 0 // 指標設定在列表頭  \n    → Step 1.3: while i < len(intervals) and intervals[i].end < newStart  \n        → i++ // 跳過完全在左側的區間  \n    → Step 1.4: // 合併所有重疊區間  \n        → while i < len(intervals) and intervals[i].start ≤ newEnd  \n            → newStart ← min(newStart, intervals[i].start)  \n            → newEnd ← max(newEnd, intervals[i].end)  \n            → remove intervals[i] // 刪除舊區間  \n        // 循環結束後 i 指向第一個不重疊區間  \n    → Step 1.5: insert [newStart, newEnd] at position i // 插入合併後的新區間  \n\n→ Method: queryRange(left, right) // 查詢區間是否完整被追蹤  \n    → Step 2.1: i ← 0  \n    → Step 2.2: while i < len(intervals) and intervals[i].end < left  \n        → i++ // 跳過左側不相關區間  \n    → Step 2.3: if i == len(intervals) or intervals[i].start > left  \n        → return False // 左側沒有對應區間  \n    → Step 2.4: if intervals[i].end ≥ right  \n        → return True // 從 current 到 right 全部覆蓋  \n    → Step 2.5: return False // 右側不足以覆蓋  \n\n→ Method: removeRange(left, right) // 移除區間  \n    → Step 3.1: i ← 0  \n    → Step 3.2: while i < len(intervals) and intervals[i].end ≤ left  \n        → i++ // 跳過左側不相關區間  \n    → Step 3.3: // 處理所有與 [left, right) 重疊的區間  \n        → while i < len(intervals) and intervals[i].start < right  \n            → cur ← intervals[i]  \n            → if cur.start < left  \n                → insert [cur.start, left] before i // 保留左半部分  \n            → if cur.end > right  \n                → replace intervals[i] with [right, cur.end] // 保留右半部分  \n                → i++ // 此區間已處理完畢  \n                → break // 右側已無需再處理  \n            → else  \n                → remove intervals[i] // 完全被移除，指標不變以檢查下一個  \n    → Step 3.4: // 完成移除操作  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7g4wklji.py\", line 61, in <module>\n    ops = json.loads(data[0])          # 操作名稱列表\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k          # 存儲元素的固定長度陣列\n        self.head = 0               # 前端指標\n        self.count = 0              # 目前元素個數\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:    # 判斷是否已滿\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:    # 判斷是否已滿\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:         # 判斷是否為空\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:         # 判斷是否為空\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = json.loads(data[0])          # 操作名稱列表\n    args = json.loads(data[1]) if len(data) > 1 else []  # 對應的參數列表\n\n    obj = None\n    results = []\n    for i, op in enumerate(ops):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args[i])\n            results.append(None)\n        else:\n            method = getattr(obj, op)\n            # 參數可能是單一值或列表\n            if isinstance(args[i], list):\n                res = method(*args[i])\n            else:\n                res = method(args[i])\n            results.append(res)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. The task: design implementation of circular double-ended queue. We'll produce steps for MyCircularDeque class with methods: constructor, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nWe need to use virtual code structure with Start, End, Decision, arrows. We must output each line with \"虛擬碼步驟 [space] // 解釋\". Use arrows →, Decision: If condition? Yes → etc.\n\nWe need to represent the algorithmic steps, not actual code. Provide structure of data structure: array of size k, head index, tail index, count.\n\nWe need to provide step-by-step for each method. But \"逐行\" means each line of virtual code. We can produce a flowchart-like pseudocode for the class. Probably include main initialization steps, method logic. Use decision for full/empty checks.\n\nLet's design:\n\nStart\n→ Initialize array of size k, head=0, tail=-1, count=0\n→ End\n\nBut for methods we might break into separate flows. Probably show each method individually. Provide flow for each method: insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nWe should format as lines, each with explanation.\n\nLet's produce:\n\nStart // 開始定義 MyCircularDeque 類別\n→ Step 1: 定義成員變數: 數組 arr[ k ] // 用來儲存元素\n→ Step 2: head = 0 // 前端指標\n→ Step 3: tail = -1 // 後端指標\n→ Step 4: size = 0 // 現有元素數量\n→ End // 初始化結束\n\nThen for each method:\n\nInsertFront\nStart // insertFront 方法開始\n→ Decision: If size == k? // 檢查是否已滿\n    Yes → Return false // 無法插入\n    No  → head = (head - 1 + k) % k // 前移 head\n        → arr[ head ] = value // 存值\n        → size++ // 更新計數\n        → Return true // 成功\nEnd // 方法結束\n\nSimilarly InsertLast: if full -> false else tail = (tail + 1) % k; arr[tail]=value; size++; true.\n\nDeleteFront: if empty -> false else head = (head + 1) % k; size--; return true.\n\nDeleteLast: if empty -> false else tail = (tail - 1 + k) % k; size--; true.\n\nGetFront: if empty -> -1 else arr[head].\n\nGetRear: if empty -> -1 else arr[tail].\n\nIsEmpty: return size == 0.\n\nIsFull: return size == k.\n\nNeed to output each line with explanation. Use arrows and decisions accordingly.\n\nLet's produce.\n...done thinking.\n\nStart // 定義 MyCircularDeque 類別與資料結構  \n→ Step 1: 定義成員變數 arr[ k ] // 用於儲存元素的固定大小陣列  \n→ Step 2: head = 0 // 前端指標初值  \n→ Step 3: tail = -1 // 後端指標初值  \n→ Step 4: size = 0 // 目前儲存的元素數量  \n→ End // 初始化結束  \n\n// --------- insertFront 方法 ---------  \nStart // insertFront 方法開始  \n→ Decision: 如果 size == k? // 判斷是否已滿  \n  Yes → Return false // 若已滿，插入失敗  \n  No  → head = (head - 1 + k) % k // 前移 head 指標  \n    → arr[ head ] = value // 存入新元素  \n    → size++ // 更新元素數量  \n    → Return true // 插入成功  \nEnd // insertFront 方法結束  \n\n// --------- insertLast 方法 ---------  \nStart // insertLast 方法開始  \n→ Decision: 如果 size == k? // 判斷是否已滿  \n  Yes → Return false // 若已滿，插入失敗  \n  No  → tail = (tail + 1) % k // 後移 tail 指標  \n    → arr[ tail ] = value // 存入新元素  \n    → size++ // 更新元素數量  \n    → Return true // 插入成功  \nEnd // insertLast 方法結束  \n\n// --------- deleteFront 方法 ---------  \nStart // deleteFront 方法開始  \n→ Decision: 如果 size == 0? // 判斷是否為空  \n  Yes → Return false // 空無法刪除  \n  No  → head = (head + 1) % k // 前移 head 指標  \n    → size-- // 更新元素數量  \n    → Return true // 刪除成功  \nEnd // deleteFront 方法結束  \n\n// --------- deleteLast 方法 ---------  \nStart // deleteLast 方法開始  \n→ Decision: 如果 size == 0? // 判斷是否為空  \n  Yes → Return false // 空無法刪除  \n  No  → tail = (tail - 1 + k) % k // 後移 tail 指標  \n    → size-- // 更新元素數量  \n    → Return true // 刪除成功  \nEnd // deleteLast 方法結束  \n\n// --------- getFront 方法 ---------  \nStart // getFront 方法開始  \n→ Decision: 如果 size == 0? // 判斷是否為空  \n  Yes → Return -1 // 空時回傳 -1  \n  No  → Return arr[ head ] // 回傳前端元素  \nEnd // getFront 方法結束  \n\n// --------- getRear 方法 ---------  \nStart // getRear 方法開始  \n→ Decision: 如果 size == 0? // 判斷是否為空  \n  Yes → Return -1 // 空時回傳 -1  \n  No  → Return arr[ tail ] // 回傳後端元素  \nEnd // getRear 方法結束  \n\n// --------- isEmpty 方法 ---------  \nStart // isEmpty 方法開始  \n→ Return size == 0 // 若 size 為 0 則為空  \nEnd // isEmpty 方法結束  \n\n// --------- isFull 方法 ---------  \nStart // isFull 方法開始  \n→ Return size == k // 若 size 等於最大容量則為滿  \nEnd // isFull 方法結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"\n        Find all duplicate files by their content.\n        :param paths: List[str] directory info strings\n        :return: List[List[str]] duplicate file groups\n        \"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # remove trailing ')'\n                content_map[content].append(f\"{root}/{name}\")\n\n        # Filter groups with more than one file\n        return [group for group in content_map.values() if len(group) > 1]\n\ndef main():\n    # Read entire stdin content\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Expect format: paths = [ ... ]\n    if '=' in raw_input:\n        _, list_part = raw_input.split('=', 1)\n    else:\n        list_part = raw_input\n\n    list_part = list_part.strip()\n    # Safely evaluate the list string\n    try:\n        paths = ast.literal_eval(list_part)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    solution = Solution()\n    duplicates = solution.findDuplicate(paths)\n    print(duplicates)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: parse input list of directory info strings, map content to list of paths, then filter groups with size>1. Use Start/End/Decision, arrow. Provide line by line. Should explain each step. Use structure. Provide no actual code. Just pseudocode steps. Ensure Chinese explanation. Use arrows. Let's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 content_to_paths // 用於將檔案內容映射到檔案路徑列表  \n→ Step 2: 針對每一個輸入字串 dir_info 在 paths 清單中迴圈  \n  → Decision: 如果 dir_info 為空字串?  \n   Yes → Skip // 跳過空行  \n   No  →  \n    → Step 3: 以空格分隔 dir_info，取得 tokens // tokens[0] 為目錄路徑，後面為檔案資訊  \n    → Step 4: 取得 dir_path = tokens[0] // 目錄路徑  \n    → Step 5: 對於 tokens[1..] 中的每個 token  \n     → Decision: token 是否包含 '('? // 判斷是否為檔案資訊  \n      Yes →  \n       → Step 6: 以 '(' 為分隔符號分割 token 成 name 和 rest // name 是檔名，rest 包含內容與右括號  \n       → Step 7: 取 content = rest 的子字串去除最後一個 ')' // 取得檔案內容  \n       → Step 8: 建立 full_path = dir_path + '/' + name // 產生完整檔案路徑  \n       → Step 9: 若 content 不在 content_to_paths 中，初始化為空列表  \n       → Step 10: 將 full_path 加入 content_to_paths[content]  \n       → Decision: 重複檢查是否已經存在相同路徑?  \n        Yes → Skip // 防止重複加入  \n        No  → Append // 正常加入  \n      No → Skip // token 不是檔案資訊，忽略  \n→ Step 11: 建立空清單 duplicates // 用於儲存重複檔案組  \n→ Step 12: 針對 content_to_paths 的每一個內容對應的路徑列表 path_list  \n   → Decision: path_list 之長度是否大於 1?  \n    Yes → Step 13: 把 path_list 加入 duplicates // 這是一組重複檔案  \n    No  → Skip // 只有單個檔案，非重複  \n→ Step 14: 回傳 duplicates // 輸出所有重複檔案組  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,true,false,true,null,true]'\nGot (Norm):      '[None,None,True,False,True,None,True]'\n--- (Raw) ---\nRaw Expected: '[null, null, true, false, true, null, true]'\nRaw Got:      '[None, None, True, False, True, None, True]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Wrap the two lists into a tuple for safe evaluation\n    ops, args = ast.literal_eval('(' + data + ')')\n    trie = None\n    results = []\n    for i, op in enumerate(ops):\n        if op == 'Trie':\n            trie = Trie()\n            results.append(None)\n        elif op == 'insert':\n            trie.insert(args[i][0])\n            results.append(None)\n        elif op == 'search':\n            results.append(trie.search(args[i][0]))\n        elif op == 'startsWith':\n            results.append(trie.startsWith(args[i][0]))\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step for implementing a Trie class with methods: constructor, insert, search, startsWith. Need to use Start, End, Decision, arrows. Provide explanation after each line. No actual code. Each line should be like \"Start // 程式開始執行\". Use appropriate steps. Let's create a high-level algorithm: create TrieNode with children map and isEnd flag. Constructor initializes root. Insert: iterate characters, create nodes if not exist, set isEnd at last. Search: iterate, if node missing return false; after loop return isEnd. startsWith: iterate, if missing return false; after loop return true. Provide each line.\n\nWe need to produce step lines. Use arrow for steps inside methods. For each method, start with \"→ MethodName // description\" then steps.\n\nWe need to maintain structure: \"Start\", \"End\". Use Decision lines.\n\nOk produce virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 類別 // 創建節點結構，包含子節點映射與是否為單詞結束的標記  \n→ Step 2: TrieNode 內部結構 // children ← 空字典，isEnd ← False  \n→ Step 3: 定義 Trie 類別 // 主資料結構，包含根節點 root  \n→ Step 4: Trie() // 建構子，初始化根節點  \n    → Assign root ← new TrieNode() // root 為 Trie 之起點  \n→ Step 5: insert(word) // 將單詞加入 Trie  \n    → Set node ← root // 從根節點開始  \n    → For each character ch in word  \n        → Decision: node.children 包含 ch? // 檢查子節點是否已存在  \n            Yes → node ← node.children[ch] // 跳到現有子節點  \n            No  → node.children[ch] ← new TrieNode() // 建立新節點  \n                → node ← node.children[ch] // 移到新建立的節點  \n    → After loop, node.isEnd ← True // 標記單詞結束  \n→ Step 6: search(word) // 判斷單詞是否已插入  \n    → Set node ← root // 從根節點開始  \n    → For each character ch in word  \n        → Decision: node.children 包含 ch? // 檢查節點是否存在  \n            Yes → node ← node.children[ch] // 繼續下一字符  \n            No  → Return False // 未找到，單詞不存在  \n    → After loop, Return node.isEnd // 只有當最後節點為單詞結束時才回傳 True  \n→ Step 7: startsWith(prefix) // 判斷是否有單詞以 prefix 開頭  \n    → Set node ← root // 從根節點開始  \n    → For each character ch in prefix  \n        → Decision: node.children 包含 ch? // 檢查節點是否存在  \n            Yes → node ← node.children[ch] // 繼續下一字符  \n            No  → Return False // 未找到，無以此前綴開頭的單詞  \n    → After loop, Return True // 前綴存在於 Trie  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[3]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[3]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[6,6]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[6, 6]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[4,6,2]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[4, 6, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\n# 假設已經有一個 API rand7() 可用\ndef rand7():\n    # 這裡使用 Python 內建的 random 做示範，實際使用時可替換成其他實作\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        使用 rand7() 兩次產生 1~49 的均勻分布，若值>40 則重試。\n        將落在 1~40 的值映射到 1~10。\n        \"\"\"\n        while True:\n            # 產生 1~49\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    # 讀取輸入，例如 \"n = 3\"\n    line = sys.stdin.readline().strip()\n    if not line:\n        return\n    # 解析 n\n    parts = line.split('=')\n    if len(parts) != 2:\n        return\n    n = int(parts[1].strip())\n    \n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines explaining algorithm. Classic method: use rand7 twice to get 49 outcomes; reject if > 40; map 1-10 by (num-1)%10+1. Or we can use rejection sampling. So produce steps: start, call rand7 twice, compute value, if <=40 use, else repeat. Ensure we only call rand7. Provide comments. Use Start, End, Decision, etc. Need to generate step lines. The algorithm: function rand10() { loop: x=rand7(); y=rand7(); num = (x-1)*7 + y; if num <= 40 then return (num-1)%10 + 1 else repeat loop. } But we need to provide pseudo-code with arrows. We'll break into steps. Also mention that rand10 will be called n times internally; but that's not part of code. We just produce algorithm.\n\nLet's output lines with arrows:\n\nStart // 程式開始執行\n→ Step 1: 定義 function rand10() // 開始定義 rand10 函式\n→ Decision: 進入重複迴圈? // 設定一個無窮迴圈以保證每次都能產生合法值\n    Yes → Step 2: x ← rand7() // 取得第一個 1~7 的隨機數\n    → Step 3: y ← rand7() // 取得第二個 1~7 的隨機數\n    → Step 4: num ← (x-1)*7 + y // 將兩個數映射到 1~49 的範圍\n    → Decision: num ≤ 40? // 檢查是否落在可用的 40 個結果中\n        Yes → Step 5: result ← (num-1) % 10 + 1 // 將 1~40 映射到 1~10\n        → Step 6: return result // 回傳隨機數\n        No  → Step 7: 重複迴圈 // 若 num>40 則重新進入迴圈\nEnd // 程式執行結束\n\nBut need to show each line separate. Also maybe add comments for each line. Should use arrow '→' before steps. Use Decision indentation. Provide [空格] after each line.\n\nWe also must maintain that each line includes a virtual code step and comment. So produce:\n\nStart // 程式開始執行\n→ Function: rand10() // 定義 rand10 函式\n→ Loop: // 開始無窮迴圈\n    → Step 1: x ← rand7() // 取得第一個隨機數 1~7\n    → Step 2: y ← rand7() // 取得第二個隨機數 1~7\n    → Step 3: num ← (x-1)*7 + y // 將兩個數映射到 1~49\n    → Decision: num ≤ 40? // 判斷是否在可接受範圍\n        Yes → Step 4: result ← (num-1) % 10 + 1 // 轉換到 1~10\n        → Step 5: return result // 回傳結果\n        No  → Step 6: 循環回到 Loop // 重新開始\n\nEnd // 程式結束\n\nWe need to be careful to include Start and End. Provide comments.\n\nLet's output final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function: rand10() // 定義 rand10 函式  \n→ Loop: // 開始無窮迴圈  \n → Step 1: x ← rand7() // 取得第一個 1~7 的隨機數  \n → Step 2: y ← rand7() // 取得第二個 1~7 的隨機數  \n → Step 3: num ← (x-1) * 7 + y // 將兩個數映射到 1~49  \n → Decision: num ≤ 40? // 判斷是否落在可接受的 40 個結果中  \n  Yes → Step 4: result ← (num-1) % 10 + 1 // 將 1~40 映射到 1~10  \n   → Step 5: return result // 回傳隨機數  \n  No → Step 6: 循環回到 Loop // 若 num>40 則重新進入迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpybudfq7f.py\", line 35, in <module>\n    raise ValueError(\"Input format incorrect\")\nValueError: Input format incorrect"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0xh8fvbb.py\", line 35, in <module>\n    raise ValueError(\"Input format incorrect\")\nValueError: Input format incorrect"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # cost if bought at regular price\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # try each special offer\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # extract the three lists using a regex\n    lists = re.findall(r'\\[.*?\\]', data, flags=re.S)\n    if len(lists) != 3:\n        raise ValueError(\"Input format incorrect\")\n    price = ast.literal_eval(lists[0])\n    special = ast.literal_eval(lists[1])\n    needs = ast.literal_eval(lists[2])\n\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code for solution to the LeetCode problem \"Shopping Offers\". It's typical DP with recursion + memoization, or bitmask. We must output line-by-line steps with virtual code and explanation. Not actual code, but pseudo-steps. Must include Start, End, Decision, arrow, etc.\n\nWe need to provide algorithm steps: initialize price, needs, special. Recursion function minCost(needs). Check memo. Compute cost if buying individually. Loop offers, if feasible (needs >= offer counts). Subtract and recursively compute. Update min. Store in memo. Return min.\n\nAlso need to handle multiple uses of offer: recursion handles multiple. Complexity: 3^n.\n\nWe need to produce virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrows: \"→\". Use Decision etc.\n\nWe will produce a sequence of steps. Provide high-level steps: Start, Input, Initialize memo, define function, compute, End.\n\nLet's produce about maybe 25 lines. Include decisions for feasibility. Include memo lookup. Use recursion.\n\nWe need to output only virtual code steps, not actual code. Use \"Start\", \"→\", \"Decision:\" etc. Use indentation or newlines for sub-steps.\n\nLet's draft.\n\nStart\n→ Input price, needs, special // 讀入價格、需求、優惠組合\n→ Initialize memo = {} // 用於記錄已計算需求的最小價格\n→ Function MinCost(currentNeeds) // 計算給定需求的最低價格\n    → Decision: 是否在 memo 中? // 檢查是否已計算\n        Yes → Return memo[currentNeeds] // 直接回傳\n        No  → // 繼續計算\n    → 計算僅按單價購買的總價 // baseline price\n    → minPrice ← baseline // 初始化最小價格\n    → For each offer in special // 遍歷所有優惠\n        → Decision: 該優惠是否可用於 currentNeeds? // 檢查需求是否足夠\n            Yes →\n                → newNeeds ← currentNeeds - offerCounts // 減去優惠所含數量\n                → priceWithOffer ← offerPrice + MinCost(newNeeds) // 再計算剩餘需求\n                → Decision: priceWithOffer < minPrice? // 比較是否更便宜\n                    Yes → minPrice ← priceWithOffer // 更新最小價格\n            No → // 不可使用該優惠，跳過\n    → memo[currentNeeds] ← minPrice // 記錄結果\n    → Return minPrice // 回傳最小價格\n→ Call MinCost(needs) // 取得答案\n→ End\n\nBut we need to include arrow after each line. Also need indentation? The format example shows indentation lines inside decision. We can mimic with indentation spaces. Each line should be \"→\" for each step. The Decision block lines with Yes → or No →. For sub-steps after Yes → or No → we need new lines with indentation.\n\nLet's produce.\n\nStart // 程式開始執行\n→ Input price, needs, special // 讀入商品價格、需求量及優惠資訊\n→ Initialize memo = {} // 建立記憶化字典以儲存已計算的最小價格\n→ Define Function MinCost(currentNeeds) // 計算給定需求的最低價格\n    → Decision: currentNeeds 是否已存在於 memo? // 檢查是否已計算\n        Yes → Return memo[currentNeeds] // 回傳已記錄的最小價格\n        No  → // 進行計算\n    → Compute baseline = sum(price[i] * currentNeeds[i]) // 僅按單價購買的總價\n    → minPrice ← baseline // 初始化最小價格為 baseline\n    → For each offer in special // 遍歷每個優惠\n        → Decision: 該優惠是否可應用於 currentNeeds? // 檢查需求是否足夠\n            Yes →\n                → newNeeds ← currentNeeds - offerCounts // 減去優惠所含數量\n                → cost ← offerPrice + MinCost(newNeeds) // 遞迴計算剩餘需求的價格\n                → Decision: cost < minPrice? // 判斷是否更便宜\n                    Yes → minPrice ← cost // 更新最小價格\n            No → // 不可使用此優惠，跳過\n    → memo[currentNeeds] ← minPrice // 記錄結果以供重複使用\n    → Return minPrice // 回傳最小價格\n→ result ← MinCost(needs) // 取得購買所有需求的最低價格\n→ End // 程式執行結束\n\nBut we must keep the arrow formatting: \"→\". For nested lines, maybe indent with spaces. Example: \"    →\" with 4 spaces? The sample shows no indentation but sub-lines are indented with spaces before arrow. We'll mimic: two spaces before arrow for nested.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input price, needs, special // 讀入商品價格、需求量及優惠資訊  \n→ Initialize memo = {} // 建立記憶化字典以儲存已計算的最小價格  \n\n→ Define Function MinCost(currentNeeds) // 計算給定需求的最低價格  \n  → Decision: currentNeeds 是否已存在於 memo? // 檢查是否已計算  \n    Yes → Return memo[currentNeeds] // 回傳已記錄的最小價格  \n    No  → // 進行計算  \n  → Compute baseline = sum(price[i] * currentNeeds[i]) // 僅按單價購買的總價  \n  → minPrice ← baseline // 初始化最小價格為 baseline  \n  → For each offer in special // 遍歷每個優惠  \n    → Decision: 該優惠是否可應用於 currentNeeds? // 檢查需求是否足夠  \n      Yes →  \n        → newNeeds ← currentNeeds - offerCounts // 減去優惠所含數量  \n        → cost ← offerPrice + MinCost(newNeeds) // 遞迴計算剩餘需求的價格  \n        → Decision: cost < minPrice? // 判斷是否更便宜  \n          Yes → minPrice ← cost // 更新最小價格  \n      No → // 不可使用此優惠，跳過  \n  → memo[currentNeeds] ← minPrice // 記錄結果以供重複使用  \n  → Return minPrice // 回傳最小價格  \n\n→ result ← MinCost(needs) // 取得購買所有需求的最低價格  \n→ End // 程式執行結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1+2+3\",\"1*2*3\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpchmpthy3.py\", line 35, in <module>\n    exec(code_to_exec, {}, local_vars)\n  File \"<string>\", line 2\n    target = 6\nIndentationError: unexpected indent"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2+3*2\",\"2*3+2\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb7qmk_ja.py\", line 35, in <module>\n    exec(code_to_exec, {}, local_vars)\n  File \"<string>\", line 2\n    target = 8\nIndentationError: unexpected indent"
        },
        {
          "example_index": 2,
          "input": "num = \"3456237490\", target = 9191",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzjh_g661.py\", line 35, in <module>\n    exec(code_to_exec, {}, local_vars)\n  File \"<string>\", line 2\n    target = 9191\nIndentationError: unexpected indent"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':  # skip numbers with leading zero\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並處理成可執行的程式碼\n    raw_input = sys.stdin.read().strip()\n    # 把逗號改成換行，方便 exec 執行\n    code_to_exec = raw_input.replace(',', '\\n')\n    local_vars = {}\n    exec(code_to_exec, {}, local_vars)\n    num = local_vars.get('num')\n    target = local_vars.get('target')\n    # 取得結果\n    sol = Solution()\n    answer = sol.addOperators(num, target)\n    # 輸出 JSON 格式，確保雙引號\n    print(json.dumps(answer))",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for adding operators between digits to reach target. Should use backtracking with recursion. Also handle multiplication precedence by keeping previous multiplication value. Also skip numbers with leading zeros. Provide line-by-line with comments.\n\nNeed Start, End, Decision etc. Provide steps like \"→ Step: 解析 num 之長度\" etc.\n\nWe need to generate entire algorithm step by step. No actual code. Use virtual steps like \"→ Step 1: 定義遞迴函式 dfs(index, expr, cur_value, last_term)\". Also we need to mention building results list. Use arrow structure.\n\nLet's craft.\n\nWe need to use virtual code with arrows and Decision. Provide explanation in Chinese after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空列表 results 用來儲存符合條件的表達式 // 建立結果集  \n→ Step 2: 呼叫遞迴函式 dfs(0, \"\", 0, 0)  // 從第一個數字開始遞迴  \n→ Step 3: 定義遞迴函式 dfs(idx, expr, cur_val, last_mul)  \n    → Decision: idx 是否等於 num 長度? // 判斷是否已處理完所有數字  \n        Yes → Step 4: 如果 cur_val 等於 target? // 檢查表達式是否符合目標值  \n            Yes → Step 5: 把 expr 加入 results // 取得符合的表達式  \n            No  → Return // 不符合，結束此分支  \n        No → Step 6: 從 idx 開始遍歷 num 的每一個可能結尾 j  \n            → Decision: 子串 num[idx..j] 是否以 '0' 為首且長度>1? // 判斷是否有前導零  \n                Yes → Break // 跳過此子串，因為前導零不合法  \n            No → Step 7: 解析子串為數字 cur_num // 取得當前子數  \n            → Decision: expr 是否為空? // 判斷是否為第一個數字  \n                Yes → Step 8: dfs(j+1, cur_num, cur_num, cur_num) // 直接使用第一個數字  \n                No → Step 9: 對於每個運算符號 '+', '-', '*':  \n                    → Decision: 選 '+': // 加法  \n                        Yes → Step 10: dfs(j+1, expr + \"+\" + cur_num, cur_val + cur_num, cur_num) // 新值 + 目前數字  \n                    → Decision: 選 '-': // 減法  \n                        Yes → Step 11: dfs(j+1, expr + \"-\" + cur_num, cur_val - cur_num, -cur_num) // 新值 - 目前數字  \n                    → Decision: 選 '*': // 乘法  \n                        Yes → Step 12: dfs(j+1, expr + \"*\" + cur_num, cur_val - last_mul + (last_mul * cur_num), last_mul * cur_num) // 處理乘法優先級  \n→ End // 程式執行結束，results 為所有符合條件的表達式集合\n\n(Note: 虛擬碼中的 \"Decision:\" 用於分支判斷，\"→\" 表示流程流動，\"Yes\" 或 \"No\" 分別對應條件成立或不成立。)"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,1,1,5,4,6]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 1, 1, 5, 4, 6]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,2,1,3,2,3]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 2, 1, 3, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"Reorder nums to satisfy nums[0] < nums[1] > nums[2] < nums[3] ...\"\"\"\n        nums.sort()                           # 先升序排序\n        n = len(nums)\n        i = 1                                 # 從索引 1 開始\n        while i + 1 < n:                      # 只要還有相鄰兩個元素可交換\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            i += 2                            # 跳到下一個偶數索引\n        return nums\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 允許輸入形如 \"nums = [1,5,1,1,6,4]\" 或僅 \"[1,5,1,1,6,4]\"\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        raise ValueError(\"輸入格式錯誤，請提供數字列表\")\n    nums_str = match.group(0)\n    nums = eval(nums_str)                    # 轉換為 list，安全性在於題目給定合法輸入\n\n    sol = Solution()\n    sol.wiggleSort(nums)\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for wiggle sort algorithm. Outline: sort array, then swap elements pairwise? Actually to achieve wiggle property, typical solution: sort nums, then put smallest at even indices? For wiggle sort: After sorting, swap adjacent pairs from index 1 to end step 2? Let's recall: For array sorted ascending: to get wiggle property, we can reverse the array? Approach: sort ascending, then create new array result with even indices filled from second half reversed, odd indices from first half reversed? But simpler: after sorting, we can do: for i from 1 to n-2 step 2: swap(nums[i], nums[i+1]). That yields wiggle. Yes.\n\nSo steps: Start, Step 1: Sort nums ascending, Step 2: For i from 1 to length-2 step 2, swap nums[i] and nums[i+1], End. Include decision? Maybe not needed.\n\nBut need to include arrow and decision nodes. We can show loop decision.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: Sort nums ascending // 對輸入陣列進行升序排序\n→ Decision: 迴圈索引 i 之初始值為 1? // 檢查是否需要進入迴圈\n    Yes → Step 2: Swap nums[i] 與 nums[i+1] // 交換相鄰元素以產生波浪形\n    No  → End // 當 i 超過陣列長度-2 時結束\n\nBut need loop structure. Use Decision: i <= n-2? Yes loop.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 對輸入陣列進行升序排序\n→ Step 2: i ← 1 // 初始化索引為 1\n→ Decision: i ≤ length(nums)-2? // 判斷是否還有相鄰元素可交換\n    Yes → Step 3: Swap nums[i] 與 nums[i+1] // 交換相鄰元素\n    → Step 4: i ← i + 2 // 走到下一個偶數索引\n    No  → End // 迴圈結束，波浪形已完成\nEnd // 程式執行結束\n\nBut need arrow for Yes path. Use `→` after Yes. Use `Decision: ...` etc. Format: Decision line, indent Yes and No.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 對輸入陣列進行升序排序  \n→ Step 2: i ← 1 // 初始化索引為 1  \n→ Decision: i ≤ length(nums)-2? // 判斷是否還有相鄰元素可交換  \n Yes → Step 3: Swap nums[i] 與 nums[i+1] // 交換相鄰元素以形成波浪形  \n  → Step 4: i ← i + 2 // 迭代到下一個偶數索引  \n No → End // 迴圈結束，波浪形已完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Maximum Length of Pair Chain",
      "source_file": "Leetcode/leetcode646.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "pairs = [[1,2],[2,3],[3,4]]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxmeuy9zg.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmpxmeuy9zg.py\", line 31, in main\n    pairs = eval(data)\n            ^^^^^^^^^^\n  File \"<string>\", line 1\n    pairs = [[1,2],[2,3],[3,4]]\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "pairs = [[1,2],[7,8],[4,5]]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9urgmz1_.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmp9urgmz1_.py\", line 31, in main\n    pairs = eval(data)\n            ^^^^^^^^^^\n  File \"<string>\", line 1\n    pairs = [[1,2],[7,8],[4,5]]\n          ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    \"\"\"\n    依據題意，先將所有區間按右邊界遞增排序，然後\n    使用貪心策略：從最左端開始，若下一個區間的左端\n    大於目前已選區間的右端，就把它加入鏈中。\n    \"\"\"\n    def findLongestChain(self, pairs: List[List[int]]) -> int:\n        # 先按右邊界排序\n        pairs.sort(key=lambda x: x[1])\n        curr_end = float('-inf')  # 目前鏈的右端\n        count = 0                # 鏈長\n        for left, right in pairs:\n            if left > curr_end:  # 可以接上\n                count += 1\n                curr_end = right\n        return count\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入、計算、輸出結果。\n    輸入形式為一行 Python 表達式，例如：\n        pairs = [[1,2],[2,3],[3,4]]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入成列表\n    pairs = eval(data)\n    # 產生結果\n    sol = Solution()\n    result = sol.findLongestChain(pairs)\n    # 輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code in Traditional Chinese. The problem is Longest Chain of Pairs, similar to Leetcode 646. Approach: sort pairs by right ascending, then greedy: choose next pair whose left > last_right. Compute length.\n\nWe'll produce steps: Start, Step 1: Sort pairs by right. Step 2: Initialize count=0, last_end=-inf. Step 3: Iterate over sorted pairs. Decision: if pair.left > last_end? If Yes: count++ ; last_end=pair.right. End. Output count.\n\nWe need each line with \"虛擬碼步驟\" plus comment. Use arrow symbols.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 pairs 按右邊界 ascending 排序 // 方便用貪心選擇  \n→ Step 2: 設定 count = 0, last_end = -∞ // count 為鏈長，last_end 為上一次選取的右邊界  \n→ Step 3: 從排序後的 pairs 開始逐一檢查  \n    → Decision: pair.left > last_end? // 判斷此對是否能接在現有鏈後  \n        Yes → Step 4: count++ // 這個對可以加入鏈  \n        Yes → Step 5: last_end = pair.right // 更新上一次選取的右邊界  \n        No  → // 這個對不能接，直接跳過  \n→ End // 程式執行結束，count 為最大鏈長，返回 count\n\n---  \n說明：  \n- Step 1 透過排序使得能以左邊界遞增的方式贪心挑選。  \n- Step 3 迭代每個對，若左邊界大於目前鏈末端右邊界，則可接入並更新。  \n- 最終 count 即為可形成的最长链長。"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入為 accounts 列表\n    # 假設輸入格式為 \"accounts = [[...]]\" 或僅為列表字面量\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    accounts = ast.literal_eval(expr)\n\n    # 執行合併\n    sol = Solution()\n    result = sol.accountsMerge(accounts)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for merging accounts problem. We output each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. We must be careful to include structure: Start, →, Decision: If, Yes →, No →, End.\n\nWe produce steps: Build graph of emails, map email->name, union find? But we can use DFS/graph. Steps: Build adjacency list. For each account, connect all emails to first email. Then DFS each email to find component, collect emails, sort, attach name. Output.\n\nWe need to output in step-by-step. Use arrow lines. For loops, we may use \"for\" in pseudocode. Also decisions for visited.\n\nLet's craft. Use:\n\nStart // 程式開始執行\n→ Build adjacency list and name map // 建立電子郵件圖與名稱對應表\n→ for each account in accounts // 迭代每個帳戶\n    → name = account[0] // 取得帳戶名稱\n    → for i from 1 to len(account)-1\n        → email = account[i] // 取得電子郵件\n        → name_map[email] = name // 以電子郵件對應名稱\n        → if i == 1: first_email = email // 第一個郵件作為連接點\n        → adjacency[first_email].add(email) // 連接第一個郵件與其他郵件\n        → adjacency[email].add(first_email)\n→ visited = empty set // 記錄已訪問的郵件\n→ result = empty list // 儲存合併後的帳戶\n→ for each email in adjacency keys // 遍歷所有郵件\n    → if email not in visited\n        → component = empty list // 本組合併的郵件\n        → stack = [email] // DFS 堆疊\n        → while stack not empty\n            → current = stack.pop()\n            → if current in visited: continue\n            → visited.add(current)\n            → component.append(current)\n            → for neighbor in adjacency[current]\n                → if neighbor not in visited\n                    → stack.append(neighbor)\n        → component.sort() // 依字典順序排序\n        → name = name_map[component[0]] // 取得名稱\n        → result.append([name] + component) // 合併後帳戶\n→ End // 程式執行結束\n\nBut we need decision arrows: for loops can be represented with \"→ Decision:\"? We might not need arrows for loops, but we can represent with \"→ for\" as step.\n\nWe need to include arrow '→' for each line. Use indentation for nested steps maybe.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build adjacency list and name map // 建立電子郵件圖與名稱對應表  \n→ for each account in accounts // 迭代每個帳戶  \n → name = account[0] // 取得帳戶名稱  \n → for i from 1 to len(account)-1 // 迭代該帳戶的所有電子郵件  \n  → email = account[i] // 取得電子郵件  \n  → name_map[email] = name // 將電子郵件對應到名稱  \n  → if i == 1: first_email = email // 第一個郵件作為連接點  \n  → adjacency[first_email].add(email) // 連接第一個郵件與其他郵件  \n  → adjacency[email].add(first_email) // 同時建立反向連接  \n→ visited = empty set // 記錄已訪問的電子郵件  \n→ result = empty list // 儲存合併後的帳戶  \n→ for each email in adjacency keys // 遍歷所有電子郵件  \n → Decision: 如果 email 尚未訪問? // 判斷是否需要開始新的 DFS  \n  Yes → component = empty list // 本組合併的電子郵件集合  \n  → stack = [email] // DFS 堆疊初始化  \n  → while stack not empty // 執行 DFS  \n   → current = stack.pop() // 取出堆疊頂端郵件  \n   → Decision: 如果 current 已被訪問?  \n    Yes → continue // 已訪問則略過  \n    No  → visited.add(current) // 標記為已訪問  \n    → component.append(current) // 加入本組合併的郵件  \n    → for neighbor in adjacency[current] // 走訪相鄰郵件  \n     → Decision: 如果 neighbor 未訪問?  \n      Yes → stack.append(neighbor) // 將未訪問的相鄰郵件加入堆疊  \n      No  → continue // 已訪問則略過  \n  → component.sort() // 將合併後的郵件按字典序排序  \n  → name = name_map[component[0]] // 取得此組合併的名稱（所有郵件名稱相同）  \n  → result.append([name] + component) // 將名稱與排序後的郵件列表合併並加入結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,4,0,0,1,1,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 4, 0, 0, 1, 1, 0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # number of valid (non‑blacklisted) integers in [0, n-1]\n        self.size = n - len(blacklist)\n        self.mapping = {}\n        black_set = set(blacklist)\n        last = n - 1\n        # Map each blacklisted number that lies in the first 'size' slots\n        # to a valid number that lies in the last slots.\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # one call to the random function\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1]) if len(data) > 1 else []\n\n    obj = None\n    outputs = []\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            outputs.append(None)\n        elif op == \"pick\":\n            outputs.append(obj.pick())\n        else:\n            # unknown operation, ignore or raise error\n            outputs.append(None)\n\n    # Use JSON to print `null` for None values\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: Use mapping from white indices to black indices if black <= n-1. Standard solution: compress mapping: Let m = n - len(blacklist). For each black value b >= m, map it to some available white value in [0, m-1] that is not black. Then pick random k in [0, m-1], if k in mapping return mapping[k] else k.\n\nThus we need virtual code for initialization and pick.\n\nWe need to output line by line with arrow etc. Provide comments.\n\nWe should also handle black array sorting maybe.\n\nWe'll produce steps:\n\nStart\n\n→ Step: Initialize n, blacklist, calculate m = n - len(blacklist) // number of allowed numbers\n\n→ Step: Create set of black values that are >= m // to be remapped\n\n→ Step: Build list of available white indices less than m that are not in blacklist // iterate i in [0, m-1], if not in blacklist add to list\n\n→ Step: Create mapping dict\n\n→ For each black value b in blacklist >= m, pop one white from list and map b → white\n\n→ End of initialization\n\npick() steps:\n\n→ Step: generate random integer r in [0, m-1] // one call\n\n→ Decision: If r in mapping?\n\nYes → Return mapping[r]\n\nNo  → Return r\n\nEnd\n\nWe need to output each line with virtual code arrow and comment.\n\nWe need to format: 'Start // 程式開始執行' etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n, blacklist, 以及計算 m = n - blacklist.length // 可用數字總數  \n→ Step 2: 建立 set 大於等於 m 的 blacklist 值集合 badSet = { b | b ∈ blacklist 且 b ≥ m } // 這些值需要重新映射  \n→ Step 3: 建立 list avail = [] // 用於儲存 [0, m-1] 中不在 blacklist 的數字  \n    → For i from 0 to m-1  \n        → If i ∉ blacklist → Append i 到 avail // 取得所有可用白色索引  \n→ Step 4: 建立空字典 mapping = {} // 用於映射黑色索引到白色索引  \n    → For each b in badSet  \n        → Pop last element w from avail  \n        → mapping[b] = w // 把黑色索引映射到一個可用的白色索引  \n→ End // 初始化完成  \n\nFunction pick()  \n→ Step 5: 產生隨機整數 r = randomInt(0, m-1) // 只呼叫一次隨機函式  \n→ Decision: r 是否在 mapping 中?  \n    Yes → Step 6: 返回 mapping[r] // 被映射到的白色索引  \n    No  → Step 7: 返回 r // 直接返回原本的白色索引  \nEnd // 程式結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      '[None,None,3,None,5]'\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      '[None, None, 3, None, 5]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    __slots__ = (\"children\", \"sum\")\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.val_map = {}  # 現有鍵的值，用於計算差值\n\n    def insert(self, key: str, val: int) -> None:\n        diff = val - self.val_map.get(key, 0)      # 需要加到 Trie 的差值\n        self.val_map[key] = val\n        node = self.root\n        for ch in key:\n            node.sum += diff                      # 更新路徑上的總和\n            if ch not in node.children:\n                node.children[ch] = TrieNode()    # 新增節點\n            node = node.children[ch]\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef parse_input(s: str):\n    # 取出兩個頂層列表\n    if not s:\n        return [], []\n    i = 0\n    count = 0\n    while i < len(s):\n        if s[i] == '[':\n            count += 1\n        elif s[i] == ']':\n            count -= 1\n            if count == 0:\n                break\n        i += 1\n    first = s[:i+1]\n    rest = s[i+1:].lstrip(', \\n')\n    second = rest\n    ops = ast.literal_eval(first)\n    args = ast.literal_eval(second)\n    return ops, args\n\ndef main():\n    data = sys.stdin.read().strip()\n    ops, args = parse_input(data)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MapSum\":\n            obj = MapSum()\n            results.append(None)\n        elif op == \"insert\":\n            obj.insert(arg[0], arg[1])\n            results.append(None)\n        elif op == \"sum\":\n            results.append(obj.sum(arg[0]))\n        else:\n            # 忽略未知操作\n            results.append(None)\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step, with explanations, following format. Use virtual code steps with arrows and structure. We need to design a MapSum class with insert and sum. It's typical using Trie with sums. We produce steps of algorithm: initialization, insert, sum. Also maybe internal data structures. Provide pseudo-code lines.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc.\n\nWe produce something like:\n\nStart // Program start\n→ Step: Define class MapSum // define class\n→ Step: Define root node of trie with map children and sum field // root of trie\n→ Step: Define map key_to_val to track current values // to update sums\n→ Step: insert(key, val) // function\n→ Step: diff = val - key_to_val.get(key, 0) // compute difference\n→ Step: key_to_val[key] = val // update map\n→ Step: node = root // start from root\n→ Step: For each char c in key:\n    → node.sum += diff // update sum at node\n    → if c not in node.children: create new node\n    → node = node.children[c] // move to child\n→ Step: sum(prefix) // function\n→ Step: node = root\n→ Step: For each char c in prefix:\n    → if c not in node.children: return 0 // no such prefix\n    → node = node.children[c]\n→ Step: return node.sum // sum of this prefix\nEnd // End\n\nWe need to use Decision? We could use Decision for \"if key exists\"? But we used map to compute diff.\n\nAlso maybe use Decision for sum prefix existence.\n\nMake sure to include arrows.\n\nLet's craft output with each line.\n\nWe need to be careful: The requirement: \"逐行輸出\", each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows \"→\" \"Yes →\" \"No →\" and structure like Start, End, Decision:.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: 定義 MapSum 類別 // 建立 MapSum 物件\n→ Step 2: 定義 TrieNode 結構: children dict, sum int // Trie 節點結構\n→ Step 3: 在 MapSum 建構子中: 初始化 root 為 TrieNode, key_to_val 為空字典 // 初始化資料結構\n→ Step 4: 實作 insert(key, val) 方法 // 插入或更新鍵值\n    → Step 4.1: 計算 diff = val - key_to_val.get(key, 0) // 取得差值以更新 Trie\n    → Step 4.2: key_to_val[key] = val // 更新 key 對應值\n    → Step 4.3: node = root // 從根節點開始\n    → Step 4.4: For each character c in key:\n        → Step 4.4.1: node.sum += diff // 更新路徑上的累計和\n        → Step 4.4.2: 如果 c 不在 node.children 則創建新節點 // 建立子節點\n        → Step 4.4.3: node = node.children[c] // 進入子節點\n→ Step 5: 實作 sum(prefix) 方法 // 取得前綴總和\n    → Step 5.1: node = root // 從根節點開始\n    → Step 5.2: For each character c in prefix:\n        → Decision: 如果 c 在 node.children? // 判斷前綴是否存在\n            Yes → node = node.children[c] // 移動到子節點\n            No  → Return 0 // 前綴不存在，和為 0\n    → Step 5.3: Return node.sum // 回傳前綴下所有鍵值的總和\nEnd // 程式結束\n\nBut we need to keep consistent format: Each line \"虛擬碼步驟\" + \" // \" + explanation. Use \"→\" arrows on lines.\n\nWe need to ensure lines with \"Decision:\" followed by indented Yes/No branches. Let's format accordingly.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: 定義 MapSum 類別 // 建立 MapSum 物件\n→ Step 2: 定義 TrieNode 結構: children dict, sum int // Trie 節點結構\n→ Step 3: 在 MapSum 建構子中: 初始化 root 為 TrieNode, key_to_val 為空字典 // 初始化資料結構\n→ Step 4: 實作 insert(key, val) 方法 // 插入或更新鍵值\n    → Step 4.1: diff = val - key_to_val.get(key, 0) // 計算差值以更新 Trie\n    → Step 4.2: key_to_val[key] = val // 更新 key 對應值\n    → Step 4.3: node = root // 從根節點開始\n    → Step 4.4: For each character c in key:\n        → Step 4.4.1: node.sum += diff // 更新路徑上的累計和\n        → Step 4.4.2: 如果 c 不在 node.children 則創建新節點 // 建立子節點\n        → Step 4.4.3: node = node.children[c] // 進入子節點\n→ Step 5: 實作 sum(prefix) 方法 // 取得前綴總和\n    → Step 5.1: node = root // 從根節點開始\n    → Step 5.2: For each character c in prefix:\n        → Decision: c 是否在 node.children? // 判斷前綴是否存在\n            Yes → node = node.children[c] // 移動到子節點\n            No  → Return 0 // 前綴不存在，和為 0\n    → Step 5.3: Return node.sum // 回傳前綴下所有鍵值的總和\nEnd // 程式結束\n\nNeed to maintain indentation with spaces? Not mandatory, but can use indentation. Use \"Decision:\" and branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MapSum 類別 // 建立 MapSum 物件  \n→ Step 2: 定義 TrieNode 結構: children dict, sum int // Trie 節點結構  \n→ Step 3: 在 MapSum 建構子中: 初始化 root 為 TrieNode, key_to_val 為空字典 // 初始化資料結構  \n→ Step 4: 實作 insert(key, val) 方法 // 插入或更新鍵值  \n    → Step 4.1: diff = val - key_to_val.get(key, 0) // 計算差值以更新 Trie  \n    → Step 4.2: key_to_val[key] = val // 更新 key 對應值  \n    → Step 4.3: node = root // 從根節點開始  \n    → Step 4.4: For each character c in key:  \n        → Step 4.4.1: node.sum += diff // 更新路徑上的累計和  \n        → Step 4.4.2: 如果 c 不在 node.children 則創建新節點 // 建立子節點  \n        → Step 4.4.3: node = node.children[c] // 進入子節點  \n→ Step 5: 實作 sum(prefix) 方法 // 取得前綴總和  \n    → Step 5.1: node = root // 從根節點開始  \n    → Step 5.2: For each character c in prefix:  \n        → Decision: c 是否在 node.children? // 判斷前綴是否存在  \n            Yes → node = node.children[c] // 移動到子節點  \n            No  → Return 0 // 前綴不存在，和為 0  \n    → Step 5.3: Return node.sum // 回傳前綴下所有鍵值的總和  \nEnd // 程式結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.09219497345162307,0.9715436694165758],[-0.22684099932135307,-0.021535148576817174],[-0.5206976030140007,0.33799845517274013]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.09219497345162307, 0.9715436694165758], [-0.22684099932135307, -0.021535148576817174], [-0.5206976030140007, 0.33799845517274013]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 產生均勻分佈的半徑與角度\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip()) if len(data) > 1 else []\n\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 初始化物件\n            obj = Solution(*arg)\n            result.append(None)\n        elif op == \"randPoint\" and obj is not None:\n            # 取得隨機點\n            result.append(obj.randPoint())\n        else:\n            # 若操作不合法或物件尚未初始化，回傳 None\n            result.append(None)\n\n    # 輸出符合 JSON 格式的結果，None 會轉成 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode. The requirement: use arrows, Start, End, Decision. For each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to generate pseudocode for the class Solution, with constructor, randPoint method. We must ensure uniform random point inside circle. Typically use method: generate random radius sqrt(random)*R and random angle uniform [0, 2π). Then compute x = r*cos(theta)+x_center, y = r*sin(theta)+y_center.\n\nSo steps: Start. Then create class Solution: Constructor initializes radius and center. Then method randPoint: generate random angle, generate random radius sqrt(rand)*radius, compute coordinates. Return array.\n\nWe must use virtual code lines. Let's outline.\n\n- Start\n- → Define class Solution\n- → Start constructor with parameters radius, x_center, y_center\n- → Assign this.radius = radius\n- → Assign this.x_center = x_center\n- → Assign this.y_center = y_center\n- → End constructor\n- → Define method randPoint\n- → Generate random angle θ = random()*2π\n- → Generate random radius r = sqrt(random()) * this.radius\n- → Compute x = r * cos(θ) + this.x_center\n- → Compute y = r * sin(θ) + this.y_center\n- → Return [x, y]\n- → End method\n- → End class\n- End\n\nWe need to use decision? Not needed.\n\nBut maybe include decision: none.\n\nWe need to format each line with \"虛擬碼步驟 // 解釋\". Use arrow? For class definitions we can use \"→\". The sample uses \"→ Step 1\". So we can mimic.\n\nLet's craft lines:\n\nStart // 程式開始執行\n\n→ Define class Solution // 定義 Solution 類別\n\n→ Define constructor Solution(radius, x_center, y_center) // 初始化物件\n\n→ this.radius = radius // 儲存半徑\n\n→ this.x_center = x_center // 儲存中心 X\n\n→ this.y_center = y_center // 儲存中心 Y\n\n→ End constructor // 結束建構子\n\n→ Define method randPoint() // 定義隨機點產生方法\n\n→ θ = random() * 2π // 產生隨機角度\n\n→ r = sqrt(random()) * this.radius // 產生均勻半徑\n\n→ x = r * cos(θ) + this.x_center // 計算 X 坐標\n\n→ y = r * sin(θ) + this.y_center // 計算 Y 坐標\n\n→ return [x, y] // 回傳點座標\n\n→ End method // 結束方法\n\n→ End class // 結束類別\n\nEnd // 程式執行結束\n\nWe must keep arrow for each step. Use \"→\" at each. For lines like \"Start\" and \"End\" no arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class Solution // 定義 Solution 類別  \n→ Define constructor Solution(radius, x_center, y_center) // 初始化物件  \n→ this.radius = radius // 儲存半徑  \n→ this.x_center = x_center // 儲存中心 X 坐標  \n→ this.y_center = y_center // 儲存中心 Y 坐標  \n→ End constructor // 結束建構子  \n→ Define method randPoint() // 定義產生隨機點的方法  \n→ θ = random() * 2π // 產生 0~2π 的隨機角度  \n→ r = sqrt(random()) * this.radius // 產生均勻分佈的半徑  \n→ x = r * cos(θ) + this.x_center // 計算 X 坐標  \n→ y = r * sin(θ) + this.y_center // 計算 Y 坐標  \n→ return [x, y] // 回傳隨機點座標  \n→ End method // 結束 randPoint 方法  \n→ End class // 結束 Solution 類別  \nEnd // 程式執行結束"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbtj4ccpu.py\", line 28, in <module>\n    main()\n  File \"/tmp/tmpbtj4ccpu.py\", line 9, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5m417pg6.py\", line 28, in <module>\n    main()\n  File \"/tmp/tmp5m417pg6.py\", line 9, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\n    ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：將輸入字串直接執行，以取得 strs、m、n 三個變數\n    local_vars = {}\n    exec(data, {}, local_vars)\n    strs = local_vars['strs']\n    m = local_vars['m']\n    n = local_vars['n']\n\n    # 動態規劃：dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n        zeros = s.count('0')\n        ones = s.count('1')\n        # 逆序遍歷，避免同一個字串被重複計算\n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n\n    print(dp[m][n])\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for the problem: given array of binary strings, find largest subset size with at most m zeros and n ones. This is classic DP 0/1 knapsack 2D. Virtual code must be step by step. We should produce virtual code lines using Start, End, Decision, and steps. Probably we need loops, DP array. Provide explanation each line. Ensure we use arrow syntax.\n\nWe must output in Chinese, concise explanation. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n\nWe need to count zeros and ones for each string.\n\nInitialize dp[m+1][n+1] = 0.\n\nFor each string in strs:\n  count zeros, ones.\n  for i from m down to zeros:\n    for j from n down to ones:\n        dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1)\n\nFinally answer dp[m][n].\n\nLet's write pseudo with arrows.\n\nStart\n→ Step 1: 定義 dp 為 (m+1)×(n+1) 二維陣列，初值 0 // 初始化 DP 表\n→ Step 2: 遍歷 strs 中每個 binary string str // 主迴圈\n    → Decision: 計算 str 中 0 的個數 zeros 與 1 的個數 ones // 取得需求資源\n    → Decision: 如果 zeros > m 或 ones > n? // 超過限制直接跳過\n        Yes → Continue // 跳過此字串\n        No  → Decision: 從 i = m 下降到 zeros? // 逆序更新 DP 以避免重複使用\n            → Step 3: 從 j = n 下降到 ones? // 同上\n                → Step 4: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新子問題答案\n→ Step 5: 回傳 dp[m][n] // 取得最大子集大小\nEnd\n\nBut we need to adhere to format: each line has virtual code step and // explanation.\n\nUse arrow arrows with arrow.\n\nWe should include \"Start\" and \"End\" with comments.\n\nAlso we need Decision steps with Yes/No arrows.\n\nWe need to ensure each line uses virtual code arrow like \"→ Step 1:\" etc.\n\nLet's produce each line accordingly.\n\nUse \"→ Decision:\" lines.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 建立 dp 為 (m+1)×(n+1) 二維陣列，所有值為 0 // 初始化動態規劃表\n\nLine 3: → Step 2: 逐一處理每個字串 str ∈ strs // 外層迴圈\n\nLine 4:     → Decision: 計算 str 中 0 的個數 zeros 與 1 的個數 ones // 取得此字串的需求\n\nLine 5:     → Decision: 如果 zeros > m 或 ones > n? // 需檢查是否超出總容量\n\nLine 6:         Yes → Continue // 超過限制則跳過此字串\n\nLine 7:         No  → Decision: 迴圈 i 由 m 下降到 zeros? // 逆序迴圈確保不重複計算\n\nLine 8:             → Step 3: 迴圈 j 由 n 下降到 ones? // 內層迴圈\n\nLine 9:                 → Step 4: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新 DP\n\nLine 10: → Step 5: 回傳 dp[m][n] // 取得最大可選數量\n\nLine 11: End // 程式結束\n\nWe should also include \"Continue\" line? Might not needed.\n\nBut virtual code syntax for Continue maybe not needed. But it's okay.\n\nMake sure each line contains only one virtual step? The continue might not be required.\n\nMaybe restructure:\n\nDecision: zeros>m or ones>n? Yes → Continue // skip\nNo → for i from m downto zeros: for j from n downto ones: dp[i][j] = ...\n\nWe'll express loops as steps.\n\nWe can have Step 3: for i = m downto zeros\n\nThen Step 4: for j = n downto ones\n\nBut we can embed inside.\n\nLet's produce final lines:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 為 (m+1)×(n+1) 二維陣列，所有值初始化為 0 // 初始化 DP 表\n→ Step 2: 針對每個字串 str ∈ strs 執行以下步驟 // 外層迴圈\n    → Decision: 計算 str 中 0 的個數 zeros 與 1 的個數 ones // 取得此字串的資源需求\n    → Decision: 如果 zeros > m 或 ones > n? // 檢查是否超出總容量\n        Yes → Continue // 超過限制直接跳過\n        No  → Decision: 以 i = m 迴圈至 zeros? // 逆向迴圈更新 DP\n            → Step 3: 以 j = n 迴圈至 ones? // 內層迴圈\n                → Step 4: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新 DP\n→ Step 5: 回傳 dp[m][n] // 最終答案\nEnd // 程式結束\n\nCheck each line: The lines with indentation maybe considered separate lines. It's okay.\n\nMake sure each line ends with \"//\" explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 為 (m+1)×(n+1) 二維陣列，所有值初始化為 0 // 初始化 DP 表  \n→ Step 2: 針對每個字串 str ∈ strs 執行以下步驟 // 外層迴圈  \n  → Decision: 計算 str 中 0 的個數 zeros 與 1 的個數 ones // 取得此字串的資源需求  \n  → Decision: 如果 zeros > m 或 ones > n? // 檢查是否超出總容量  \n   Yes → Continue // 超過限制直接跳過  \n   No  → Decision: 以 i = m 迴圈至 zeros? // 逆向迴圈更新 DP  \n    → Step 3: 以 j = n 迴圈至 ones? // 內層迴圈  \n     → Step 4: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新 DP  \n→ Step 5: 回傳 dp[m][n] // 最終答案  \nEnd // 程式結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": ""
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 原始陣列\n        self.nums = list(nums)\n\n    def reset(self):\n        # 返回原始陣列\n        return self.nums\n\n    def shuffle(self):\n        # Fisher‑Yates 洗牌演算法\n        shuffled = list(self.nums)\n        n = len(shuffled)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入為兩個列表：commands 和 arguments\n    try:\n        commands, arguments = json.loads(raw_input)\n    except json.JSONDecodeError:\n        # 若輸入格式不符合 JSON，直接終止\n        sys.exit(1)\n\n    results = []\n    obj = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            # 參數為 [[1, 2, 3]]，取其第一個元素作為陣列\n            obj = Solution(arg[0])\n            results.append(None)\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n\n    # 輸出結果，使用 json.dumps 以得到符合範例的格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this algorithm. Provide step-by-step pseudocode with comments. Should not output real code. Just virtual pseudocode lines. Use arrow, Start, End, Decision. Provide each step and explanation.\n\nThe algorithm: class Solution, constructor store original array copy; reset returns copy of original; shuffle returns random permutation using Fisher-Yates. We should describe steps inside shuffle.\n\nWe'll produce lines like:\n\nStart\n→ Step 1: Define class Solution // Declare class\n→ Step 2: Define constructor Solution(nums) // Init with array\n    → Step 3: Store original array as orig // Keep original\n    → Step 4: Store a copy of nums as current // Current array\n→ Step 5: Define method reset() // Reset method\n    → Step 6: Return copy of orig // Return original config\n→ Step 7: Define method shuffle() // Shuffle method\n    → Step 8: For i from 0 to n-1\n        → Step 9: Pick random j between i and n-1\n        → Step 10: Swap current[i] and current[j]\n    → Step 11: Return current // Return shuffled array\nEnd\n\nBut must format with arrow lines and explanation. Use Decision only if conditional. Here there are no decisions, except maybe check if array is empty? Not necessary. We'll just present loops with comments.\n\nBut must show \"→\" arrow preceding each step. The Start/End are separate lines.\n\nLet's craft step-by-step lines. Use indentation to show nested steps? In example, they indent steps after Decision. We can indent steps inside methods? For clarity, we can indent steps inside methods.\n\nLet's produce.\n\nWe'll include \"→ Step 1: Define class Solution\" etc.\n\nBut we need to show algorithm: store original array and working array. Use copy.\n\nLet's produce lines:\n\nStart\n→ Step 1: Define class Solution // Define class to hold array\n→ Step 2: Define constructor Solution(nums) // Initialize with input array\n    → Step 3: Store a copy of nums as orig // Keep original order\n    → Step 4: Store another copy of nums as current // Working array for shuffle\n→ Step 5: Define method reset() // Reset array to original\n    → Step 6: Return a copy of orig // Return original configuration\n→ Step 7: Define method shuffle() // Generate random permutation\n    → Step 8: For i from 0 to length(current)-1\n        → Step 9: Generate random index j between i and length(current)-1 // Random choice\n        → Step 10: Swap current[i] with current[j] // Fisher–Yates swap\n    → Step 11: Return a copy of current // Return shuffled array\nEnd\n\nAdd explanation comment after each line.\n\nWe must ensure each line includes \"虛擬碼步驟 [space] // 解釋\". Use Chinese comment after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class Solution // 定義 Solution 類別  \n→ Step 2: Define constructor Solution(nums) // 建構子，接受整數陣列 nums  \n  → Step 3: Store a copy of nums as orig // 保留原始排列  \n  → Step 4: Store another copy of nums as current // 用於隨機打亂的工作陣列  \n→ Step 5: Define method reset() // 重置方法，還原原始順序  \n  → Step 6: Return a copy of orig // 回傳原始陣列的拷貝  \n→ Step 7: Define method shuffle() // 隨機打亂方法  \n  → Step 8: For i from 0 to length(current)-1 // 逐一遍歷每個位置  \n    → Step 9: Generate random index j between i and length(current)-1 // 產生隨機索引  \n    → Step 10: Swap current[i] with current[j] // 執行 Fisher‑Yates 交換  \n  → Step 11: Return a copy of current // 回傳打亂後的陣列拷貝  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    res = []\n\n    def backtrack(start, path):\n        res.append(path[:])          # 记录当前子集\n        for i in range(start, len(nums)):\n            path.append(nums[i])     # 包含当前元素\n            backtrack(i + 1, path)\n            path.pop()               # 取消选择，准备不包含当前元素\n\n    backtrack(0, [])\n    return res\n\ndef format_output(subsets_list):\n    # 将结果格式化为不含空格的字符串\n    subset_strings = []\n    for subset in subsets_list:\n        subset_str = '[' + ','.join(str(x) for x in subset) + ']'\n        subset_strings.append(subset_str)\n    return '[' + ','.join(subset_strings) + ']'\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取方括号中的列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums = ast.literal_eval(data[start:end+1])\n    result = subsets(nums)\n    print(format_output(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. For subset generation. Use recursion or iterative. We'll use DFS/backtracking. Provide steps.\n\nStructure:\n\nStart\n→ Step: Initialize result list with empty subset\n→ Step: Define backtrack function with current index and current subset\n    → Decision: index == len(nums)? // base case\n        Yes → Step: Append current subset copy to result\n        No  → Step: Add nums[index] to current subset\n            → Step: backtrack(index+1, current subset)\n            → Step: Remove last element from current subset\n            → Step: backtrack(index+1, current subset)\nEnd\n\nReturn result. Provide lines.\n\nMake sure each line has \"→\" arrow or \"Start\", \"End\". Use indentation for decisions.\n\nAlso we need explanation after each line.\n\nLet's craft.\n\nWe'll number steps maybe. But not necessary. Just arrow and explanation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 建立 result 為空集合並加入空子集 // 初始結果包含空集  \n→ Step: 定義回溯函式 backtrack(idx, curr) // 從索引 idx 開始探索  \n → Decision: 如果 idx 等於 nums 長度? // 基本終止條件  \n  Yes → Step: 把 curr 的拷貝加入 result // 找到一個完整子集  \n  No  → Step: 把 nums[idx] 加入 curr // 先包含本元素  \n   → Step: backtrack(idx+1, curr) // 進一步探索包含本元素的子集  \n   → Step: 從 curr 刪除最後一個元素 // 取消包含，準備不包含本元素  \n   → Step: backtrack(idx+1, curr) // 進一步探索不包含本元素的子集  \n→ Step: 呼叫 backtrack(0, 空列表) // 從頭開始遍歷所有元素  \n→ Step: 回傳 result // 輸出所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,0,1,0]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 0, 0, 1, 0]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"初始化，預先計算權重的前綴和。\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機選取一個索引，選取機率與權重成正比。\"\"\"\n        # 產生 [1, self.total] 之間的隨機整數\n        target = random.randint(1, self.total)\n        # 使用 bisect 找到最小的索引，使 prefix_sum[i] >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    \"\"\"從標準輸入讀取方法列表和參數，執行並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析類似 ['Solution','pickIndex'], [[[1]],[]] 的輸入\n    methods, args_list = ast.literal_eval(data)\n    results = []\n    instance = None\n\n    for idx, method in enumerate(methods):\n        if method == \"Solution\":\n            # 建構子，使用 *args_list[idx] 展開參數\n            instance = Solution(*args_list[idx])\n            results.append(None)          # 建構子回傳值視為 null\n        else:\n            # 其餘方法直接呼叫\n            func = getattr(instance, method)\n            res = func(*args_list[idx])\n            results.append(res)\n\n    # 將結果輸出為 JSON 格式，以得到 null 而不是 None\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The requirement: \"You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. You need to implement pickIndex(), which randomly picks an index with probability proportional to weight.\"\n\nWe need to output step-by-step pseudocode. Use Start, End, Decision, arrows. Each line: \"虛擬碼步驟 // 解釋/說明\". Should be line by line. We need to design algorithm: precompute prefix sums, total sum. In pickIndex, generate random number in [1,total], find index by binary search.\n\nWe need to include initialization and pickIndex function steps. So virtual code will have something like:\n\nStart\n→ Step 1: Input array w // Get weights\n→ Step 2: Compute prefixSum array // cumulative weights\n→ Step 3: Store totalSum = prefixSum[last] // sum of all weights\n→ End\n\nThen pickIndex function:\n\nStart\n→ Step 1: Generate random integer r between 1 and totalSum // inclusive\n→ Step 2: Binary search prefixSum to find smallest index where prefixSum[i] >= r\n→ Step 3: Return that index\nEnd\n\nWe may include decision for binary search? We can show iterative binary search steps.\n\nThus produce lines accordingly. Use \"Decision:\" for branching.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 w // 讀取權重陣列\n→ Step 2: 建立空陣列 prefix // 儲存累積和\n→ Decision: 如果 w 不是空陣列? // 確認陣列非空\n    Yes → Step 3: prefix[0] = w[0] // 設定第一個累積和\n    No  → Step 4: totalSum = 0 // 若空陣列，總和為0\n→ Step 5: 對於 i 從 1 到 w.length-1 做:\n    → prefix[i] = prefix[i-1] + w[i] // 更新累積和\n→ Step 6: totalSum = prefix[w.length-1] // 記錄總和\nEnd // 初始化結束\n\nNow pickIndex:\n\nStart // pickIndex 開始執行\n→ Step 1: 產生隨機整數 r，範圍 1..totalSum // 以總和為上限\n→ Step 2: 設定 low = 0, high = prefix.length-1 // binary search boundaries\n→ Decision: low <= high? // 判斷搜尋範圍\n    Yes → Step 3: mid = (low+high)//2 // 計算中點\n        Decision: prefix[mid] >= r? // 判斷 r 是否小於等於中點累積和\n            Yes → Step 4: high = mid-1 // r 在左半邊\n            No  → Step 5: low = mid+1 // r 在右半邊\n    No  → Step 6: return low // low 為所選索引\nEnd // pickIndex 結束\n\nNeed to make sure lines are separate.\n\nWe'll output exactly as required: each line \"虛擬碼步驟 // 解釋\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 w // 讀取權重陣列  \n→ Step 2: 建立空陣列 prefix // 儲存累積和  \n→ Decision: 如果 w 不是空陣列? // 確認陣列非空  \n Yes → Step 3: prefix[0] = w[0] // 設定第一個累積和  \n No  → Step 4: totalSum = 0 // 若空陣列，總和為0  \n→ Step 5: 對於 i 從 1 到 w.length-1 做:  \n → prefix[i] = prefix[i-1] + w[i] // 更新累積和  \n→ Step 6: totalSum = prefix[w.length-1] // 記錄總和  \nEnd // 初始化結束  \n\n---  \n\nStart // pickIndex 開始執行  \n→ Step 1: 產生隨機整數 r，範圍 1..totalSum // 以總和為上限  \n→ Step 2: 設定 low = 0, high = prefix.length-1 // binary search boundaries  \n→ Decision: low <= high? // 判斷搜尋範圍  \n Yes → Step 3: mid = (low+high)//2 // 計算中點  \n  Decision: prefix[mid] >= r? // 判斷 r 是否小於等於中點累積和  \n   Yes → Step 4: high = mid-1 // r 在左半邊  \n   No  → Step 5: low = mid+1 // r 在右半邊  \n No  → Step 6: return low // low 為所選索引  \nEnd // pickIndex 結束"
    }
  ]
}