{
  "run_index": 2,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 392,
  "generation_or_validation_failure_count": 47,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[5,4,1,1,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[5, 4, 1, 1, 4]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    模擬擲 n 次六面骰，回傳結果清單。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin 內容，並執行\n    input_code = sys.stdin.read()\n    exec(input_code, globals())",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code with explanation. Use random module, define function roll_dice(n). Steps: import random, define function, create list, loop n times, generate random int 1-6, append to list, return list. End. Provide Start, End, Decision maybe not needed. Just sequential. Provide each line. Use the required syntax: \"Start // ...\", \"→ Step 1: ... // ...\" etc. We should follow the format: \"虛擬碼步驟 [space] // 解釋\". Use arrow for each line. Use Start and End. No actual code. Just description. Provide each line. Ensure Chinese (繁體). Provide explanation after //. Let's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 導入隨機數模組  \n→ Step 2: Define function roll_dice(n) // 定義 roll_dice 函數，接受擲骰次數 n  \n→ Step 3: Initialize results as empty list // 建立空清單存放擲骰結果  \n→ Step 4: For i from 1 to n do // 迴圈執行 n 次  \n  → Step 5: Generate random integer between 1 and 6 // 產生 1 至 6 的隨機整數  \n  → Step 6: Append the integer to results list // 將結果加入清單  \n→ Step 7: Return results list // 回傳所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    start = time.time()\n    result = func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    code = sys.stdin.read()\n    exec_globals = {'measure_time': measure_time}\n    exec(code, exec_globals)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line, with comments. Format: each line: 虛擬碼步驟 + space + // 解釋/說明. Use arrows: →, Start, End, Decision. So we need to generate a step-by-step virtual code for function measure_time. We should include import time, define function, record start time, call func, record end time, compute elapsed, round to 3 decimals, return result.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: import time // 匯入 time 模組\n→ Step 2: 定義函數 measure_time(func, *args) // 函式開始\n    → Step 3: start = time.time() // 記錄開始時間\n    → Step 4: result = func(*args) // 執行目標函式並取得回傳值\n    → Step 5: elapsed = time.time() - start // 計算執行時間\n    → Step 6: elapsed = round(elapsed, 3) // 四捨五入到小數點 3 位\n    → Step 7: return result, elapsed // 回傳結果與耗時\nEnd // 程式結束\n\nBut must use virtual code arrow syntax. We need to use arrows between steps? Format: \"→ Step X:\" etc. Use indentation? The example shows indent for nested Decision. For function body, we might indent steps under function definition. Let's use spaces.\n\nAlso, we need to use `Decision:` for branching? Not needed. Use steps. Use \"→ Step ...\" lines. Use proper comment after space.\n\nLet's craft:\n\n```\nStart // 程式開始執行\n→ Step 1: import time // 匯入 time 模組\n→ Step 2: 定義函數 measure_time(func, *args) // 開始定義函式\n    → Step 3: start = time.time() // 記錄開始時間\n    → Step 4: result = func(*args) // 執行傳入的函式並取得結果\n    → Step 5: elapsed = time.time() - start // 計算執行時間\n    → Step 6: elapsed = round(elapsed, 3) // 四捨五入到三位小數\n    → Step 7: return result, elapsed // 回傳原始結果與耗時\nEnd // 程式執行結束\n```\n\nWe must ensure each line follows the format: \"虛擬碼步驟 [space] // 解釋/說明\". So we include arrow at start of each step. Provide indentation for nested steps, but the format still includes arrow at beginning of line.\n\nWe need to ensure we use `Start`, `End` as separate lines. Provide arrow for steps inside function. Provide arrow after each step.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import time // 匯入 time 模組  \n→ Step 2: 定義函數 measure_time(func, *args) // 開始定義函式  \n    → Step 3: start = time.time() // 記錄開始時間  \n    → Step 4: result = func(*args) // 執行傳入的函式並取得結果  \n    → Step 5: elapsed = time.time() - start // 計算執行時間  \n    → Step 6: elapsed = round(elapsed, 3) // 四捨五入到三位小數  \n    → Step 7: return result, elapsed // 回傳原始結果與耗時  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"apple\",\"melon\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'apple', 'melon', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    \"\"\"\n    讀取 stdin（若無輸入則為空字串），以符合主題要求。\n    接著執行集合操作，最後將結果輸出。\n    \"\"\"\n    # 讀取所有標準輸入，雖然本題不需要實際輸入資料\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'（不會拋錯）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments, no actual code. Each line includes \"虛擬碼步驟 // 解釋\". Use Start, End, Decision? We don't need Decision here. Just linear steps.\n\nUse arrow. Format: Start // 程式開始執行\n→ Step 1: 創建集合 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增橘子\n→ Step 3: fruits.update({'grape', 'melon'}) // 同時新增葡萄和哈密瓜\n→ Step 4: fruits.remove('banana') // 移除香蕉，若不存在會錯誤\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在元素，不會錯誤\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd // 程式結束\n\nNeed to keep each line format: \"虛擬碼步驟 // 解釋\". Use arrow and spacing. Ensure each line ends with // explanation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建集合 fruits = {'apple', 'banana'} // 初始化集合，包含蘋果與香蕉  \n→ Step 2: fruits.add('orange') // 使用 add() 新增橘子到集合  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增葡萄與哈密瓜  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除香蕉，若不存在將拋出錯誤  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的菠蘿，操作不會拋錯  \n→ Step 6: 輸出 fruits // 顯示集合最終內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.88TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.88 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef get_rate() -> str:\n    \"\"\"\n    從匯率 API 取得 USD → TWD 的匯率。\n    若成功回傳格式化的字串，失敗時回傳錯誤訊息。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        rate = data[\"rates\"][\"TWD\"]\n        return f\"目前美元匯率：約 {rate} TWD\"\n    except Exception:\n        return \"更新失敗，請檢查網路連線\"\n\ndef run_gui() -> None:\n    \"\"\"\n    建立 tkinter 視窗，並提供更新匯率的按鈕。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update_label() -> None:\n        label.config(text=get_rate())\n\n    tk.Button(win, text=\"更新匯率\", command=update_label).pack(pady=5)\n    win.mainloop()\n\ndef main() -> None:\n    \"\"\"\n    入口函式。\n    若從標準輸入讀到任何資料，則直接印出匯率；否則啟動 GUI。\n    \"\"\"\n    data = sys.stdin.read()\n    if data.strip():\n        # 任何輸入皆代表「按下更新匯率」指令\n        print(get_rate())\n    else:\n        run_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with lines: Start, steps, decisions, etc. Should include requests API call, parsing JSON, updating tkinter. No actual code, just steps. Use \"→\" arrow, \"Decision:\" etc. Provide explanation after each line. Use Traditional Chinese.\n\nWe need to cover:\n\nStart\n→ Step 1: Import necessary modules: requests, tkinter\n→ Step 2: Define API URL\n→ Step 3: Create tkinter root window\n→ Step 4: Create label to display rate\n→ Step 5: Define function fetch_rate\n   -> Step 5.1: Send GET request to API\n   -> Decision: 如果成功? \n        Yes -> Step 5.2: 解析 JSON\n              Step 5.3: 從 JSON 取 TWD 值\n              Step 5.4: 更新 label text\n              Step 5.5: 顯示 success message\n        No -> Step 5.6: 更新 label text to error\n→ Step 6: Create button that triggers fetch_rate\n→ Step 7: Call fetch_rate once to display initial rate\n→ Step 8: Start tkinter main loop\nEnd\n\nMake sure each line includes the step and comment. Use \"→\" arrow for substeps. Use Decision with Yes → and No → lines. Format exactly as specified: each line: virtual code + space + // explanation. Use brackets? It's just as sample.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests, tkinter // 先匯入網路請求與 GUI 模組  \n→ Step 2: Set API_URL = \"https://api.exchangerate-api.com/v4/latest/USD\" // 定義匯率 API 的網址  \n→ Step 3: Create root = tkinter.Tk() // 建立主視窗  \n→ Step 4: Create rate_label = tkinter.Label(root, text=\"匯率載入中...\") // 標籤顯示匯率  \n→ Step 5: Define fetch_rate() // 定義獲取匯率的函式  \n  → Step 5.1: response = requests.get(API_URL) // 發送 GET 請求到 API  \n  → Decision: response status code == 200? // 檢查請求是否成功  \n   Yes → Step 5.2: data = response.json() // 解析 JSON 回應  \n    → Step 5.3: twd_rate = data[\"rates\"][\"TWD\"] // 取出 TWD 的匯率值  \n    → Step 5.4: rate_label.config(text=f\"USD→TWD: {twd_rate}\") // 更新標籤文字  \n    → Step 5.5: print(\"匯率更新成功\") // 方便除錯，印出成功訊息  \n   No  → Step 5.6: rate_label.config(text=\"取得匯率失敗\") // 請求失敗時顯示錯誤訊息  \n→ Step 6: Create update_button = tkinter.Button(root, text=\"更新匯率\", command=fetch_rate) // 按鈕觸發匯率更新  \n→ Step 7: Call fetch_rate() // 初始載入一次匯率  \n→ Step 8: root.mainloop() // 開始 tkinter 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppkavedxa.py\", line 58, in <module>\n    args = ast.literal_eval(\"[\" + args_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [1], [2], [2], [], [1], [2], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\n\nclass RandomizedSet:\n    def __init__(self):\n        # Dictionary to map value to its index in the list\n        self.val_to_index = {}\n        # List to store the values\n        self.values = []\n\n    def insert(self, val):\n        # If value already exists, do nothing\n        if val in self.val_to_index:\n            return False\n        # Append new value and record its index\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        # If value does not exist, nothing to remove\n        if val not in self.val_to_index:\n            return False\n        # Get index of value to remove\n        index = self.val_to_index[val]\n        # Swap with the last element for O(1) deletion\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        # Remove the last element\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        # Randomly choose an element from the list\n        return random.choice(self.values)\n\ndef js_style_repr(value):\n    \"\"\"Convert Python values to JavaScript-like representation for output.\"\"\"\n    if value is None:\n        return \"null\"\n    if isinstance(value, bool):\n        return \"true\" if value else \"false\"\n    return str(value)\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # The input format is two comma‑separated lists in string form\n    # e.g. '[\"RandomizedSet\", \"insert\", ...], [[], [1], ...]'\n    ops_part, args_part = raw_input.split(\"],\", 1)\n    ops = ast.literal_eval(ops_part + \"]\")\n    args = ast.literal_eval(\"[\" + args_part.strip())\n\n    # Prepare result list\n    results = []\n\n    # Instance holder\n    obj = None\n\n    for op, params in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            results.append(None)  # Constructor returns null\n        else:\n            # Call the method dynamically\n            method = getattr(obj, op)\n            res = method(*params)\n            results.append(res)\n\n    # Convert results to JS-style output\n    output = \"[\" + \", \".join(js_style_repr(r) for r in results) + \"]\"\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for RandomizedSet class methods. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision, etc.\n\nWe need to explain the data structure: use hash map and list.\n\nSo produce steps for initialization, insert, remove, getRandom. Also maybe internal helper? Let's craft sequential steps.\n\nProbably need to start with Start // program start. Then each method.\n\nWe can structure as:\n\nStart\n→ Class RandomizedSet // Define class\n→ Constructor: initialize map and list // etc.\n\nFor insert: check if exists in map -> if Yes -> return false; else add to list, record index in map, return true.\n\nRemove: check if exists -> if No -> return false; else get index, swap with last element in list, update map for swapped element, pop last, remove from map, return true.\n\nGetRandom: pick random index from list size, return element.\n\nWe need average O(1). Provide decision nodes.\n\nLet's write each step.\n\nUse \"Decision:\" lines.\n\nEnsure each line ends with // explanation.\n\nUse arrow \"→\" before each step. For decisions, indent.\n\nWe may use indentation by spaces to show nested.\n\nLet's produce.\n\nAlso after each method, maybe EndMethod.\n\nLet's produce all steps in order.\n\nLet's write:\n\nStart // 程式開始執行\n→ Class RandomizedSet // 宣告 RandomizedSet 類別\n→ Start of Constructor // 建構子執行\n    → Step: 初始化 hash map indexMap // 存儲值到其在列表中的索引\n    → Step: 初始化 array list elements // 儲存所有元素\n→ End Constructor // 完成建構\n→ Start of insert(val) // 插入方法開始\n    → Decision: 如果 val 在 indexMap 中? // 檢查是否已存在\n        Yes → Step: return false // 已存在不插入，回傳 false\n        No  → Step: 把 val 加到 elements 列表末尾 // 插入新元素\n        → Step: 在 indexMap 記錄 val -> 索引 elements.size - 1 // 記錄索引\n        → Step: return true // 成功插入，回傳 true\n→ End insert // 插入方法結束\n→ Start of remove(val) // 刪除方法開始\n    → Decision: 如果 val 在 indexMap 中? // 檢查是否存在\n        Yes →\n            → Step: 取得 val 的索引 idx = indexMap[val] // 找到位置\n            → Step: 取得最後一個元素 lastVal = elements.last() // 取最後一個元素\n            → Decision: 如果 idx != elements.size - 1? // 是否不是最後一個\n                Yes →\n                    → Step: 交換 elements[idx] 與 lastVal // 把最後一個放到要刪除的位置\n                    → Step: 更新 indexMap[lastVal] = idx // 更新交換後元素的索引\n                No → // idx 已是最後一個，無需交換\n            → Step: 從 elements 刪除最後一個元素 // 刪除\n            → Step: 在 indexMap 中移除 val // 刪除索引\n            → Step: return true // 成功刪除，回傳 true\n        No  → Step: return false // 不存在，回傳 false\n→ End remove // 刪除方法結束\n→ Start of getRandom() // 取得隨機元素開始\n    → Step: 產生隨機索引 r 在 0 ~ elements.size - 1 // 隨機選擇\n    → Step: return elements[r] // 回傳隨機元素\n→ End getRandom // 隨機方法結束\nEnd // 程式執行結束\n\nCheck each line: Need \"虛擬碼步驟\" which may include \"Start\", \"→ Step ...\". Ensure each line ends with // explanation.\n\nMake sure to use indentation for decisions.\n\nAlso we need to maintain structure with arrow \"→\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class RandomizedSet // 宣告 RandomizedSet 類別  \n→ Start of Constructor // 建構子執行  \n    → Step: 初始化 hash map indexMap // 存儲值到其在列表中的索引  \n    → Step: 初始化 array list elements // 儲存所有元素  \n→ End Constructor // 完成建構  \n→ Start of insert(val) // 插入方法開始  \n    → Decision: 如果 val 在 indexMap 中? // 檢查是否已存在  \n        Yes → Step: return false // 已存在不插入，回傳 false  \n        No  → Step: 把 val 加到 elements 列表末尾 // 插入新元素  \n        → Step: 在 indexMap 記錄 val -> 索引 elements.size - 1 // 記錄索引  \n        → Step: return true // 成功插入，回傳 true  \n→ End insert // 插入方法結束  \n→ Start of remove(val) // 刪除方法開始  \n    → Decision: 如果 val 在 indexMap 中? // 檢查是否存在  \n        Yes →  \n            → Step: 取得 val 的索引 idx = indexMap[val] // 找到位置  \n            → Step: 取得最後一個元素 lastVal = elements.last() // 取最後一個元素  \n            → Decision: 如果 idx != elements.size - 1? // 是否不是最後一個  \n                Yes →  \n                    → Step: 交換 elements[idx] 與 lastVal // 把最後一個放到要刪除的位置  \n                    → Step: 更新 indexMap[lastVal] = idx // 更新交換後元素的索引  \n                No → // idx 已是最後一個，無需交換  \n            → Step: 從 elements 刪除最後一個元素 // 刪除  \n            → Step: 在 indexMap 中移除 val // 刪除索引  \n            → Step: return true // 成功刪除，回傳 true  \n        No  → Step: return false // 不存在，回傳 false  \n→ End remove // 刪除方法結束  \n→ Start of getRandom() // 取得隨機元素開始  \n    → Step: 產生隨機索引 r 在 0 ~ elements.size - 1 // 隨機選擇  \n    → Step: return elements[r] // 回傳隨機元素  \n→ End getRandom // 隨機方法結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[2,0],[0,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [2, 0], [0, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n\n        self.remaining = self.total\n        self.available = list(range(self.total))\n\n    def flip(self):\n        if self.remaining == 0:\n            return None\n        r = random.randint(0, self.remaining - 1)\n        idx = self.available[r]\n        # 把選中的位置移到末尾，避免再次被選\n        self.available[r], self.available[self.remaining - 1] = self.available[self.remaining - 1], self.available[r]\n        self.remaining -= 1\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        self.remaining = self.total\n        # 不需要重建 available，因為已經包含所有索引\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 分離兩個列表：方法名稱列表和參數列表\n    idx = data.find('],')\n    if idx == -1:\n        sys.exit(0)\n    list1_str = data[:idx + 1]\n    list2_str = data[idx + 2:].strip()\n\n    methods = ast.literal_eval(list1_str)\n    args_list = ast.literal_eval(list2_str)\n\n    result = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            result.append(None)\n        elif method == \"flip\":\n            result.append(obj.flip())\n        elif method == \"reset\":\n            obj.reset()\n            result.append(None)\n    # 輸出結果，使用 json.dumps 以得到 null 的表示\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the algorithm. Requirements: binary matrix m x n, initially all zeros. We need flip() that returns random zero index uniformly and flips it to one. Reset sets all back to zero. We must minimize random calls and optimize time and space.\n\nClassic solution: treat matrix as 1D array of size m*n. Maintain list of available indices. Use reservoir approach: Keep array 'available' of size m*n, initially each index. Maintain variable 'remaining' = m*n. flip() picks random k in [0, remaining-1], get idx = available[k]. Swap available[k] with available[remaining-1] (or replace). remaining--. Convert idx to (i,j). reset() sets remaining = m*n. No need to rebuild array; just keep as is. This uses O(m*n) space for available list. random calls per flip: one call.\n\nNeed to produce virtual code line by line, with comments. Use the format: Start, → Step 1: ... // explanation, etc.\n\nWe need to output for class initialization, flip, reset. Use steps for each method.\n\nWe should include logic like:\n\nInitialize: m, n; total = m*n; available = array of indices 0..total-1; remaining = total.\n\nflip(): if remaining == 0: error? but assume call only when zeros exist.\n\nPick rand = random(0, remaining-1). idx = available[rand]. Swap available[rand] with available[remaining-1]. remaining--. Return [idx/m, idx % n].\n\nreset(): remaining = total. // No need to reinitialize available because order can stay.\n\nBut must ensure that after reset, all zeros again. But if available array has swapped elements, but remaining set to total, the array's content will include all indices but swapped positions. That's fine. We don't need to reset content. So reset just sets remaining = total.\n\nWe should include handling random function call count: one per flip.\n\nLet's produce virtual code accordingly.\n\nWe'll produce lines starting with Start, then steps for constructor, flip, reset. Use decision if needed. Use arrow notation.\n\nLet's craft.\n\nNeed to ensure each line includes \"虛擬碼步驟\" plus space plus \"// 解釋\".\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: Define class Solution with attributes m, n, total, remaining, available // 初始化類別與參數\n→ Step 2: 在構造函數中設定 m, n // 設定行列大小\n→ Step 3: 計算 total = m * n // 總格數\n→ Step 4: 建立 available 為長度 total 的陣列，並填入 0..total-1 // 每個索引代表矩陣位置\n→ Step 5: 設定 remaining = total // 可用零格的數量\n→ End // 結束構造\n\nFor flip():\n\nStart // flip 方法開始\n→ Step 1: 若 remaining == 0，拋出錯誤或返回 null // 沒有可用格子\n→ Decision: 檢查 remaining > 0? // 確保可選\n    Yes → Step 2: 隨機產生 r = random(0, remaining-1) // 只呼叫一次隨機函數\n    Yes → Step 3: idx = available[r] // 取得隨機位置\n    Yes → Step 4: 交換 available[r] 與 available[remaining-1] // 移除已選位置\n    Yes → Step 5: remaining = remaining - 1 // 更新剩餘零格數\n    Yes → Step 6: i = idx / n // 計算行\n    Yes → Step 7: j = idx % n // 計算列\n    Yes → Step 8: 返回 [i, j] // 回傳隨機零格座標\n    No  → Step 9: return null // 沒有可用格子\n→ End // flip 方法結束\n\nReset():\n\nStart // reset 方法開始\n→ Step 1: 設定 remaining = total // 將剩餘格數重置為總數\n→ End // reset 方法結束\n\nBut maybe we should show the code structure with decision etc. Provide each line. Make sure each line is a separate step, include comment. Provide arrow lines.\n\nWe also need to show that available remains same; no need to rebuild. But if we want to be explicit we can fill available again but that's O(total). But better to keep as is.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別，屬性包括 m, n, total, remaining, available // 初始化基本變數\n→ Step 2: Solution(int m, int n) // 構造函數開始\n    → Step 3: 設定 this.m = m, this.n = n // 存儲行列尺寸\n    → Step 4: 計算 total = m * n // 總格數\n    → Step 5: 建立 available 為長度 total 的陣列，並填入 0..total-1 // 每個索引對應一個矩陣位置\n    → Step 6: 設定 remaining = total // 可用零格的數量\n→ End // 構造完成\n\nStart // flip 方法開始\n→ Step 1: Decision: remaining == 0? // 檢查是否還有零格\n    → Yes → Step 2: return null // 沒有可用格子，直接返回\n    → No → Step 3: 隨機產生 r = random(0, remaining - 1) // 只呼叫一次隨機函數\n    → Step 4: idx = available[r] // 取得隨機索引\n    → Step 5: 交換 available[r] 與 available[remaining - 1] // 將已選位置移到末尾\n    → Step 6: remaining = remaining - 1 // 更新剩餘零格數\n    → Step 7: i = idx / n // 計算行號\n    → Step 8: j = idx % n // 計算列號\n    → Step 9: return [i, j] // 回傳隨機零格座標\n→ End // flip 方法結束\n\nStart // reset 方法開始\n→ Step 1: 設定 remaining = total // 將剩餘格數重置為總數\n→ End // reset 方法結束\n```"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptlqrb_tv.py\", line 88, in <module>\n    main()\n  File \"/tmp/tmptlqrb_tv.py\", line 63, in main\n    operations, arguments = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptlqrb_tv.py\", line 57, in parse_input\n    args = json.loads(args_line)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 3 (char 2)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        \"\"\"把單詞集合存成 set，方便快速查詢\"\"\"\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        \"\"\"\n        檢查是否存在與 searchWord 只差一個字元的單詞。\n        只需遍歷已存的單詞集合，計算差異數量即可。\n        \"\"\"\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = 0\n            for a, b in zip(word, searchWord):\n                if a != b:\n                    diff += 1\n                    if diff > 1:\n                        break\n            if diff == 1:\n                return True\n        return False\n\n\ndef parse_input(raw):\n    \"\"\"\n    將輸入字串解析為兩個 list：operations 與 arguments。\n    支援：\n      * 兩行輸入（第一行 operations，第二行 arguments）\n      * 單行輸入，兩個 list 以 '], [' 分隔\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return [], []\n\n    lines = raw.splitlines()\n    if len(lines) >= 2:\n        ops_line, args_line = lines[0].strip(), lines[1].strip()\n    else:\n        # 單行輸入，使用正則拆分\n        parts = re.split(r'\\],\\s*\\[', raw, maxsplit=1)\n        ops_line = parts[0]\n        args_line = parts[1] if len(parts) > 1 else ''\n        # 加上缺失的 '['、']' 以便解析\n        ops_line = ops_line + ']' if not ops_line.endswith(']') else ops_line\n        args_line = '[' + args_line if not args_line.startswith('[') else args_line\n        args_line = args_line + ']' if not args_line.endswith(']') else args_line\n\n    ops = json.loads(ops_line)\n    args = json.loads(args_line)\n    return ops, args\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    operations, arguments = parse_input(raw_input)\n\n    results = []\n    magic_dict = MagicDictionary()\n\n    for op, arg in zip(operations, arguments):\n        if op == \"MagicDictionary\":\n            # 建構子，結果為 null\n            magic_dict = MagicDictionary()\n            results.append(None)\n        elif op == \"buildDict\":\n            magic_dict.buildDict(arg)\n            results.append(None)\n        elif op == \"search\":\n            res = magic_dict.search(arg)\n            results.append(res)\n        else:\n            # 其他未知方法，忽略\n            results.append(None)\n\n    # 輸出符合 LeetCode 風格的結果：null / true / false\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code for implementing MagicDictionary. No real code, just pseudo-code steps with arrows and explanations.\n\nWe need to cover class initialization, buildDict, search. Data structure design: maybe use hashmap of patterns with one char replaced by wildcard. Approach: for each word, generate all variants where one char replaced by '*' and map to list of words or count. Then search: generate variants of searchWord with '*' at each position; if any variant exists with count>1 or word different, return true. Provide pseudocode accordingly.\n\nWe must output line by line with \"虛擬碼步驟\" and comment. We'll use arrows →, Start, End, Decision.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 class MagicDictionary // 宣告 MagicDictionary 類別  \n→ Step 2: 內部屬性: dictionaryMap ← new HashMap<String, Set<String>> // 用於存放字串與其所有「*」模式的對應集合  \n→ Step 3: 內部屬性: wordSet ← new HashSet<String> // 用於快速判斷原字串是否存在  \n\n→ Step 4: 建構子 MagicDictionary()  \n→     → Initialize dictionaryMap ← {} // 空映射  \n→     → Initialize wordSet ← {} // 空集合  \n\n→ Step 5: 方法 buildDict(dictionary)  \n→     → 清空 dictionaryMap, wordSet // 重新建構  \n→     → Decision: 是否 dictionary 為空？  \n→         Yes → End // 若無字串，直接結束  \n→         No  → 逐個字串 word 進入 dictionary  \n→             → wordSet.add(word) // 先加入字串集合  \n→             → Decision: word長度 L = word.length()  \n→                 // 產生所有位置為 '*' 的模式  \n→                 → For i from 0 to L-1  \n→                     → pattern ← word.substring(0,i) + '*' + word.substring(i+1) // 替換第 i 個字元為 '*'\n→                     → 若 dictionaryMap 沒有 key pattern  \n→                         → dictionaryMap.put(pattern, new HashSet<String>)  \n→                     → dictionaryMap.get(pattern).add(word) // 把原字串加入對應集合  \n\n→ Step 6: 方法 search(searchWord)  \n→     → L ← searchWord.length() // 取得長度  \n→     → Decision: L 在 dictionaryMap 之中是否存在任何模式？  \n→         // 這裡不需要直接檢查，接下來逐個位置產生模式並查找  \n→     → 逐個位置 i 從 0 到 L-1  \n→         → pattern ← searchWord.substring(0,i) + '*' + searchWord.substring(i+1)  \n→         → Decision: dictionaryMap.containsKey(pattern)?  \n→             Yes → candidates ← dictionaryMap.get(pattern) // 可能的字串集合  \n→                 → Decision: candidates.size() > 1 或 (candidates.size()==1 且 !candidates.contains(searchWord))?  \n→                     Yes → Return true // 至少有一個不同字串可以只改一個字元  \n→                     No  → 继续下一个 i  \n→             No  → 继续下一个 i  \n→     → End of loop // 所有位置都檢查完  \n→     → Return false // 未找到符合條件的字串  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a)()()', '(a())()']\""
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        移除最少數量的無效括號，返回所有唯一有效字串\n        \"\"\"\n        # 用於儲存結果\n        res = set()\n\n        # 第一遍計算需要刪除的左括號與右括號數量\n        left_rem = right_rem = 0\n        for ch in s:\n            if ch == '(':\n                left_rem += 1\n            elif ch == ')':\n                if left_rem > 0:\n                    left_rem -= 1\n                else:\n                    right_rem += 1\n\n        # 深度優先搜尋\n        def dfs(index: int, left_count: int, right_count: int,\n                left_rem: int, right_rem: int, path: str):\n            # 當處理到字串結尾時，檢查是否符合條件\n            if index == len(s):\n                if left_rem == 0 and right_rem == 0 and left_count == right_count:\n                    res.add(path)\n                return\n\n            ch = s[index]\n            if ch == '(':\n                # 1. 刪除左括號\n                if left_rem > 0:\n                    dfs(index + 1, left_count, right_count,\n                        left_rem - 1, right_rem, path)\n                # 2. 保留左括號\n                dfs(index + 1, left_count + 1, right_count,\n                    left_rem, right_rem, path + ch)\n            elif ch == ')':\n                # 1. 刪除右括號\n                if right_rem > 0:\n                    dfs(index + 1, left_count, right_count,\n                        left_rem, right_rem - 1, path)\n                # 2. 保留右括號（但必須有對應左括號）\n                if left_count > right_count:\n                    dfs(index + 1, left_count, right_count + 1,\n                        left_rem, right_rem, path + ch)\n            else:  # 非括號字符，直接保留\n                dfs(index + 1, left_count, right_count,\n                    left_rem, right_rem, path + ch)\n\n        # 從頭開始遞迴\n        dfs(0, 0, 0, left_rem, right_rem, \"\")\n        return list(res)\n\ndef main():\n    # 從標準輸入讀取整行資料\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析字串值（支援 \"s = \\\"...\\\"\" 或僅提供字串的輸入）\n    if '=' in raw:\n        s = raw.split('=', 1)[1].strip()\n    else:\n        s = raw.strip()\n\n    # 移除可能的引號\n    s = s.strip('\"\\'')\n    sol = Solution()\n    result = sol.removeInvalidParentheses(s)\n    # 輸出列表\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving: remove minimum number of invalid parentheses to make string valid, return list of unique strings with minimal removals. Classic Leetcode 301. Approach: BFS or DFS with pruning. Use recursion to generate all valid strings with min removals. Implementation: compute left_rem, right_rem counts, then DFS backtracking generating strings, using set to avoid duplicates. Or BFS. We'll produce virtual steps for BFS approach: compute min removals, then BFS search. But need unique list.\n\nWe need to output virtual code line by line with explanations. Use Start, End, Decision. We'll outline steps: compute number of left and right parentheses to remove. Then use DFS to generate valid strings with pruning. Might be easier to represent using recursion: function dfs(s, index, left_count, right_count, left_rem, right_rem, path). But we need virtual code lines for each step.\n\nLet's produce generic algorithm: 1) Count left_rem and right_rem. 2) DFS function: parameters index, left_count, right_count, left_rem, right_rem, path, result set. 3) If index==len(s): if left_rem==0 && right_rem==0 && left_count==right_count: add path to result. 4) Else: char = s[index]. If char== '(' then branch remove or keep. If left_rem>0: branch remove: dfs(index+1,... left_rem-1). If keep: dfs(index+1, left_count+1,...). Similarly for ')': if right_rem>0: remove; if right_count>left_count: keep: dfs(index+1, left_count, right_count+1,...). If letter: keep: dfs(index+1,...). 5) After recursion, return result list.\n\nAlso handle duplicates: use set. Complexity.\n\nWe need to produce virtual code line by line: each line with arrow, etc.\n\nLet's craft virtual code:\n\nStart\n→ Step 1: Define function removeInvalidParentheses(s)\n→ Decision: 初始化 left_rem, right_rem = 0, 0 // Count removals needed\n    → For char in s:\n        → Decision: if char == '('? Yes → left_rem++ ; No → Decision: if char == ')' ? Yes → right_rem++ ; No → continue\n→ Step 2: 定義 result_set = empty set // 存放唯一有效字串\n→ Step 3: 定義遞迴函數 dfs(index, left_count, right_count, left_rem, right_rem, path)\n    → Decision: if index == len(s)? Yes → Decision: if left_rem==0 && right_rem==0 && left_count==right_count? Yes → Step 4: 把 path 加入 result_set ; No → return ; No → return\n    → Set char = s[index]\n    → Decision: if char == '('?\n        → Yes → Decision: if left_rem > 0? Yes → Step 5: dfs(index+1, left_count, right_count, left_rem-1, right_rem, path) // 刪除 '('\n        → No  → Decision: 跳過? Actually keep if we choose keep\n        → Decision: 進行保留分支: dfs(index+1, left_count+1, right_count, left_rem, right_rem, path + '(') // 保留 '('\n    → Decision: else if char == ')'\n        → Yes → Decision: if right_rem > 0? Yes → Step 6: dfs(index+1, left_count, right_count, left_rem, right_rem-1, path) // 刪除 ')'\n        → No\n        → Decision: if right_count < left_count? Yes → Step 7: dfs(index+1, left_count, right_count+1, left_rem, right_rem, path + ')') // 保留 ')'\n        → No → return // 不能保留，因為左括號不足\n    → Decision: else // letter\n        → Step 8: dfs(index+1, left_count, right_count, left_rem, right_rem, path + char) // 保留字母\n→ Step 9: 呼叫 dfs(0,0,0,left_rem,right_rem,\"\")\n→ Step 10: Return list(result_set) // 轉成列表\nEnd\n\nWe need to ensure each line has arrow or decision. Provide explanation after //.\n\nLet's format each line. Need Start and End. Provide decision with indentation.\n\nWe need to produce each line with \"→\" or \"Decision:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 removeInvalidParentheses(s) // 入口函式，接受原始字串 s\n→ Decision: 初始化 left_rem, right_rem = 0, 0 // 兩個變數用來統計需要刪除的左、右括號數量\n    → For char in s:\n        → Decision: 如果 char == '('? Yes → left_rem++ // 左括號數量加 1\n        → No → Decision: 如果 char == ')' ? Yes → right_rem++ // 右括號數量加 1\n        → No → 跳過 // 字母不影響計數\n→ Step 2: 定義 result_set = empty set // 用於儲存唯一的有效字串\n→ Step 3: 定義遞迴函數 dfs(index, left_count, right_count, left_rem, right_rem, path) // index: 當前處理位置，left_count/right_count: 當前已保留的左/右括號數，left_rem/right_rem: 剩餘可刪除的數量，path: 當前建構中的字串\n    → Decision: 如果 index == len(s)? Yes → Decision: 如果 left_rem==0 && right_rem==0 && left_count==right_count? Yes → Step 4: 把 path 加入 result_set // 生成的字串有效且已達到最小刪除\n    → No → 返回 // 無效情況直接回溯\n    → Decision: char = s[index] // 取得目前處理的字元\n    → Decision: 如果 char == '('? Yes →\n        → Decision: 如果 left_rem > 0? Yes → Step 5: dfs(index+1, left_count, right_count, left_rem-1, right_rem, path) // 刪除當前 '('\n        → No → 跳過 // 不刪除\n        → Step 6: dfs(index+1, left_count+1, right_count, left_rem, right_rem, path + '(') // 保留 '('\n    → No → Decision: 如果 char == ')'? Yes →\n        → Decision: 如果 right_rem > 0? Yes → Step 7: dfs(index+1, left_count, right_count, left_rem, right_rem-1, path) // 刪除當前 ')'\n        → No → 跳過 // 不刪除\n        → Decision: 如果 right_count < left_count? Yes → Step 8: dfs(index+1, left_count, right_count+1, left_rem, right_rem, path + ')') // 保留 ')'，但前提是左括號足夠\n        → No → 返回 // 右括號過多，無法保留\n    → No → Decision: 其他字母? Yes →\n        → Step 9: dfs(index+1, left_count, right_count, left_rem, right_rem, path + char) // 直接保留字母\n→ Step 10: 呼叫 dfs(0, 0, 0, left_rem, right_rem, \"\") // 從頭開始遞迴搜索\n→ Step 11: 返回 list(result_set) // 轉成列表形式回傳\nEnd // 程式執行結束"
    },
    {
      "title": "Jewels and Stones",
      "source_file": "Leetcode/leetcode771.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "jewels = \"aA\", stones = \"aAAbbbb\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\n\ndef num_jewels_in_stones(jewels: str, stones: str) -> int:\n    \"\"\"\n    Count how many stones are also jewels.\n    \"\"\"\n    jewel_set = set(jewels)          # O(1) look‑up for each stone\n    return sum(1 for stone in stones if stone in jewel_set)\n\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip().splitlines()\n\n    if len(data) >= 2:\n        # Two separate lines: first jewels, second stones\n        jewels = data[0].strip()\n        stones = data[1].strip()\n    else:\n        # Input might be in one line separated by whitespace\n        parts = data[0].split()\n        if len(parts) >= 2:\n            jewels, stones = parts[0], parts[1]\n        else:\n            # Fallback: empty or invalid input\n            jewels, stones = \"\", \"\"\n\n    result = num_jewels_in_stones(jewels, stones)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: count number of stones in string stones that are also present in jewels string. Each char counts individually. We output each line: Virtual Code step + explanation. Use Start, Decision, etc.\n\nWe need to not output actual code, but pseudo-code. Use arrows. So we need to write steps like:\n\nStart // program starts\n→ Step 1: Initialize count = 0 // set counter\n→ Step 2: Convert jewels string into set for O(1) lookup // store jewel types\n→ Step 3: For each char c in stones // iterate\n    → Decision: If c is in jewelsSet?\n        Yes → Step 4: Increment count\n        No  → (do nothing)\n→ Step 5: Output count // print result\nEnd // program ends\n\nWe must use \"→ Decision:\" lines. For the for-loop we can represent as \"For each\". Might use \"→ For each stone c in stones:\". And inside use Decision. Provide explanation.\n\nMake sure each line follows \"虛擬碼步驟 // 解釋\". Use arrow at start of line. The \"→ Decision:\" line must align indentation.\n\nLet's produce accordingly. Use Traditional Chinese comments. Provide short explanation.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: count ← 0 // 初始化計數器  \n→ Step 2: jewelsSet ← 轉換為集合(jewels) // 將鑽石類型轉成集合，方便 O(1) 查找  \n→ Step 3: For each stone c in stones // 逐個遍歷所有石頭  \n    → Decision: c 是否在 jewelsSet? // 檢查此石頭是否為鑽石  \n        Yes → Step 4: count ← count + 1 // 是鑽石，計數加一  \n        No  → // 不是鑽石，保持計數不變  \n→ Step 5: 輸出 count // 顯示鑽石總數  \nEnd // 程式執行結束"
    },
    {
      "title": "Assign Cookies",
      "source_file": "Leetcode/leetcode455.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeqmcyjp2.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmpeqmcyjp2.py\", line 43, in main\n    g, s = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpeqmcyjp2.py\", line 32, in parse_input\n    s_str = parts[1].split('=')[1].strip()\n            ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "g = [1,2], s = [1,2,3]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy0elb136.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmpy0elb136.py\", line 43, in main\n    g, s = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpy0elb136.py\", line 32, in parse_input\n    s_str = parts[1].split('=')[1].strip()\n            ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\ndef find_content_children(g, s):\n    \"\"\"\n    Greedy algorithm to maximize number of content children.\n    1. Sort greed factors and cookie sizes.\n    2. Use two pointers to pair smallest possible cookie with each child.\n    \"\"\"\n    g.sort()\n    s.sort()\n    i = j = 0          # i -> child index, j -> cookie index\n    count = 0          # number of satisfied children\n\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:     # current cookie can satisfy current child\n            count += 1\n            i += 1          # move to next child\n        j += 1              # cookie is used or discarded, move to next cookie\n    return count\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        g = [1,2,3], s = [1,1]\n    and return two lists g and s.\n    \"\"\"\n    data = data.strip().replace('\\n', ' ')\n    # split into two parts by the comma separating g and s\n    parts = data.split(',')\n    # Extract list string after '=' in each part\n    g_str = parts[0].split('=')[1].strip()\n    s_str = parts[1].split('=')[1].strip()\n    # Safely evaluate the list strings\n    g = eval(g_str)\n    s = eval(s_str)\n    return g, s\n\ndef main():\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    g, s = parse_input(raw_input)\n    result = find_content_children(g, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code (pseudocode) line by line with explanation, following the format. The problem is classic: assign cookies to children to maximize content. Use greedy: sort greed and sizes, two pointers. Need to output maximum count. So produce steps: Start, read input, sort arrays, initialize pointers i, j, count, loop while i < n && j < m: if s[j] >= g[i] then count++, i++, j++ else j++. End. Provide explanation. Use arrow format. Provide decision steps.\n\nLet's produce lines:\n\nStart // program starts\n→ Step 1: Read integer n, m // number of children and cookies\n→ Step 2: Read array g[0..n-1] // greed factors\n→ Step 3: Read array s[0..m-1] // cookie sizes\n→ Step 4: Sort g ascending // sort greed factors\n→ Step 5: Sort s ascending // sort cookie sizes\n→ Step 6: Initialize i = 0, j = 0, count = 0 // pointers and counter\n→ Decision: While i < n and j < m? // check if more children or cookies to process\n    Yes → Decision: If s[j] >= g[i]? // can this cookie satisfy current child\n        Yes → Step 7: count++ // child satisfied\n               → i++ // move to next child\n               → j++ // move to next cookie\n        No  → Step 8: j++ // current cookie too small, discard it\n    No → End // loop finished\n→ Step 9: Output count // maximum number of content children\n\nMake sure format: each line includes \"虛擬碼步驟 [space] // 解釋\". For decisions use indent? In example, decision lines have indent. We'll replicate with spaces before indent? Use 4 spaces? The example uses 4 spaces. We'll use same. Provide \"Decision:\" line and nested Yes/No with arrow.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Read integer n, m // 讀取孩子數量與餅乾數量\n→ Step 2: Read array g[0..n-1] // 讀取每個孩子的貪婪值\n→ Step 3: Read array s[0..m-1] // 讀取每個餅乾的大小\n→ Step 4: Sort g ascending // 將貪婪值升冪排序\n→ Step 5: Sort s ascending // 將餅乾大小升冪排序\n→ Step 6: Initialize i = 0, j = 0, count = 0 // 指標與計數器初始化\n→ Decision: While i < n and j < m? // 是否還有孩子與餅乾可處理\n    Yes → Decision: If s[j] >= g[i]? // 目前餅乾是否能滿足當前孩子\n        Yes → Step 7: count++ // 這個孩子滿足\n               → i++ // 移到下一個孩子\n               → j++ // 移到下一個餅乾\n        No  → Step 8: j++ // 這塊餅乾太小，丟棄\n    No → End // 兩個序列已處理完畢\n→ Step 9: Output count // 輸出能讓孩子滿足的最大數量\n\nEnd // 程式執行結束"
    },
    {
      "title": "Unique Substrings in Wraparound String",
      "source_file": "Leetcode/leetcode467.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findSubstringInWraproundString(self, p: str) -> int:\n        \"\"\"計算在無限循環字串 base 中，p 的所有唯一非空子字串個數\"\"\"\n        # dp[i] 代表以字母 chr(i + ord('a')) 結尾的最大連續子字串長度\n        dp = [0] * 26\n        cur_len = 0  # 當前連續子字串長度\n\n        for i in range(len(p)):\n            if i > 0 and (ord(p[i]) - ord(p[i - 1])) % 26 == 1:\n                cur_len += 1\n            else:\n                cur_len = 1\n            idx = ord(p[i]) - ord('a')\n            dp[idx] = max(dp[idx], cur_len)\n\n        return sum(dp)\n\ndef main() -> None:\n    # 讀取所有輸入\n    data = sys.stdin.read()\n    # 從輸入中擷取小寫字母串，若有多段字串，只取第一段\n    matches = re.findall(r'[a-z]+', data)\n    s = matches[0] if matches else \"\"\n\n    solution = Solution()\n    result = solution.findSubstringInWraproundString(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving the problem: given string s, count number of unique non-empty substrings that appear in the infinite wraparound string of lowercase alphabet. This is a known LeetCode problem: Unique Substrings in Wraparound String. Approach: dynamic programming maintain array of max length ending with each letter. For each position, track current consecutive wraparound length. For each char, update max for that char. Sum array gives answer.\n\nWe must produce virtual code line by line with explanation, using Start, Decision, arrows. No actual code.\n\nWe need to include steps: initialize array maxLen[26] to zeros, currentLen=0. For i from 0 to s.length-1: if s[i] consecutive to previous? (difference mod 26==1) else currentLen=1. Update maxLen[ index(s[i]) ] = max(maxLen[...], currentLen). After loop, sum maxLen. Return sum.\n\nAlso handle empty string: return 0.\n\nAlso handle wraparound for 'a' after 'z': difference should be (cur-prev+26)%26==1.\n\nAlso we need to maintain steps and decisions. Use Decision: if s empty? Yes -> return 0. No -> proceed.\n\nThen Start, Step lines.\n\nLet's produce virtual code lines.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\" with arrow.\n\nUse arrow symbols as per spec.\n\nWe can represent loop as Step: For i in range(len(s)).\n\nAlso maintain variable names: currentLen, maxLen[26], i, s[i].\n\nUse Decision: If s[i] consecutive to s[i-1]? Yes or No.\n\nAlso after loop sum.\n\nFinally return result.\n\nLet's produce.\n\nMake sure to include \"Start\" and \"End\".\n\nLet's output in Chinese comments.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 如果 s 為空? // 判斷輸入字串是否為空\n    Yes → Step: 回傳 0 // 空字串沒有子字串，直接回傳 0\n    No  → Step: 初始化 maxLen[26] 為 0，currentLen = 0 // 準備存放以每個字母結尾的最大連續子字串長度\n→ Step: 從 i = 0 到 i = s.length-1 // 逐字元遍歷輸入字串\n    → Decision: 如果 i > 0 且 s[i] 與 s[i-1] 是按字母表連續? // 判斷是否為連續字母（z→a 也算連續）\n        Yes → Step: currentLen += 1 // 連續，長度遞增\n        No  → Step: currentLen = 1 // 非連續，重置長度為 1（只包含當前字母）\n    → Step: idx = s[i] 的字母索引 (0-25) // 取得當前字母的索引\n    → Decision: 如果 currentLen > maxLen[idx]? // 判斷是否需要更新最大長度\n        Yes → Step: maxLen[idx] = currentLen // 更新以該字母結尾的最大長度\n        No  → // 不更新，保留較大的長度\n→ Step: result = 0 // 準備計算總數\n→ Step: 對於 j = 0 到 25\n    → Step: result += maxLen[j] // 累加每個字母結尾的最大長度，即獨特子字串數量\n→ Step: 回傳 result // 輸出最終答案\nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '\"12\"'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '\"457\"'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '\"1\"'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(reversed(res))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract all integer sequences from the input\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # Fallback: read two separate lines\n        lines = data.splitlines()\n        num1 = lines[0].strip()\n        num2 = lines[1].strip() if len(lines) > 1 else '0'\n\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    # Output with surrounding double quotes as required\n    print(f'\"{result}\"')",
      "virtual_code": "Thinking...\nWe need to produce virtual code for adding two non-negative integer strings without using BigInteger or converting to ints. So typical manual addition algorithm: iterate from end, sum digits with carry, build result string. Provide steps line by line with comments. Use the required format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc.\n\nWe need to produce code in natural language but virtual code style. For example:\n\nStart // 程式開始\n→ Step 1: 初始化指標 i = len(num1)-1 // 指向 num1 最右邊\n...\n\nUse Decision: if i>=0 etc.\n\nAlso need to handle carry.\n\nWe must avoid actual code, just virtual steps. Provide step by step. Use arrow arrows.\n\nLet's craft.\n\nWe should include input, initialize variables: i, j, carry, result as list. While i>=0 or j>=0 or carry>0: compute digit1, digit2; sum; compute new digit; push; update carry. Then reverse result and join.\n\nNeed to produce step by step with explanations.\n\nWe must not output actual code like `int i=...`. So we say \"Step X: 設定 i = length(num1)-1\" etc.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 設定指標 i = num1 的最後一個索引 // 從 num1 的最低位開始  \n→ Step 2: 設定指標 j = num2 的最後一個索引 // 從 num2 的最低位開始  \n→ Step 3: 設定變數 carry = 0 // 用來儲存進位  \n→ Step 4: 初始化空串 result // 用來暫存加法結果的各位數  \n→ Decision: i ≥ 0 或 j ≥ 0 或 carry > 0? // 判斷是否還有位數或進位未處理  \n  Yes → Step 5: 如果 i ≥ 0, digit1 = num1[i] 的數值, 否則 digit1 = 0 // 取得 num1 的當前位數，若已經走到頭則為 0  \n  Yes → Step 6: 如果 j ≥ 0, digit2 = num2[j] 的數值, 否則 digit2 = 0 // 同樣取得 num2 的當前位數  \n  Yes → Step 7: 計算 sum = digit1 + digit2 + carry // 求本位總和  \n  Yes → Step 8: 設定 carry = sum / 10 // 取整除得到進位  \n  Yes → Step 9: 設定 digit = sum mod 10 // 取模得到本位結果  \n  Yes → Step 10: 把 digit 前置到 result 的最前面 // 逐步建立結果串  \n  Yes → Step 11: i = i - 1 // 移動到 num1 的更高位  \n  Yes → Step 12: j = j - 1 // 移動到 num2 的更高位  \n  No  → End // 所有位數和進位已經處理完  \n→ End // 程式執行結束，result 即為兩數相加後的字串結果"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiuy03_rt.py\", line 30, in <module>\n    methods = ast.literal_eval(left)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"Solution\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立字典，將每個數字對應到所有其索引\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選 target 對應索引列表中的一個索引\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 以第一個逗號分割出兩個子字串\n    left, right = data.split(',', 1)\n    left = left.strip()\n    right = right.strip()\n\n    # 轉成 Python 內部資料結構\n    methods = ast.literal_eval(left)\n    args_list = ast.literal_eval(right)\n\n    results = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 這裡 args 本身是一個列表，例如 [[1,2,3,3,3]]\n            obj = Solution(*args)\n            results.append(None)  # 這裡用 None 代表 null\n        else:\n            # 直接呼叫對應的方法\n            results.append(getattr(obj, method)(*args))\n\n    # 輸出結果，使用 json.dumps 以得到 null 而不是 None\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for a Solution class with constructor storing nums and pick method selecting random index of target. Implementation: could precompute mapping from target to list of indices, or use reservoir sampling on the fly. Provide step-by-step pseudocode.\n\nWe'll output in the specified format: each line has virtual code step + // explanation. Use arrow → etc. Use Start, End, Decision. Ensure no actual code.\n\nWe need to show construction of mapping maybe.\n\nLet's design pseudocode:\n\nStart\n→ Step 1: Create empty map targetToIndices\n→ Decision: For each index i in nums? etc.\n\nBut we need to produce virtual code lines.\n\nWe can do:\n\nStart // 程式開始\n→ Step 1: 定義空字典 targetToIndices // 用來儲存每個數字對應的索引列表\n→ Step 2: 對於每個索引 i 從 0 到 nums.length-1\n    → Step 3: 取得 nums[i] 的值 val\n    → Step 4: 若 val 不在 targetToIndices 中，則 targetToIndices[val] ← 空列表\n    → Step 5: targetToIndices[val].append(i) // 把索引加入對應數字的列表\n→ End // 建構子完成\n\nThen pick method:\n\nStart // pick 方法開始\n→ Step 1: 取得 target 對應的索引列表 listIndices ← targetToIndices[target]\n→ Decision: listIndices 是否為空? (shouldn't happen)\n    Yes → Step 2: 返回 -1 或錯誤 // 但根據假設不會發生\n    No → Step 3: 產生隨機整數 r 在 0 到 len(listIndices)-1\n→ Step 4: 返回 listIndices[r] // 隨機選取索引\n→ End // pick 方法結束\n\nThat's the pseudocode.\n\nWe need to include the class structure.\n\nWe can show:\n\nStart // 程式開始\n→ Step 1: 定義類別 Solution\n    → Step 2: 定義建構子 Solution(nums)\n        ... above steps\n    → Step 3: 定義方法 pick(target)\n        ... above steps\n→ End // 程式結束\n\nWe should be consistent with format. Provide each line with virtual code step and explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 定義類別 Solution // 建立解決方案的類別\n    → Step 2: 定義建構子 Solution(nums) // 以 nums 初始化對象\n        → Step 3: 定義空字典 targetToIndices // 用於儲存每個數字對應的索引列表\n        → Step 4: 對於每個索引 i 從 0 到 nums.length-1\n            → Step 5: 取得 nums[i] 的值 val // 讀取目前的數字\n            → Step 6: 若 val 不在 targetToIndices 中，則 targetToIndices[val] ← 空列表 // 建立新鍵\n            → Step 7: targetToIndices[val].append(i) // 把索引 i 加入對應數字的列表\n    → Step 8: 結束建構子 // 完成對象初始化\n    → Step 9: 定義方法 pick(target) // 隨機選取 target 的索引\n        → Step 10: 取得 target 對應的索引列表 listIndices ← targetToIndices[target] // 取得所有合法索引\n        → Decision: listIndices 是否為空? // 檢查是否存在目標（理論上不會）\n            Yes → Step 11: 返回 -1 // 當然情況下不應該執行\n            No  → Step 12: 產生隨機整數 r 在 0 到 len(listIndices)-1\n        → Step 13: 返回 listIndices[r] // 隨機選取並返回索引\n    → Step 14: 結束方法 pick // 方法結束\nEnd // 程式結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> list[str]:\n        \"\"\"\n        找出所有重複出現的 10 字長子字串。\n        \"\"\"\n        seen = set()        # 已遇到的子字串\n        repeated = set()    # 重複出現的子字串\n        n = len(s)\n        if n < 10:\n            return []\n\n        # 用滑動窗口遍歷所有長度為 10 的子字串\n        for i in range(n - 9):\n            seq = s[i:i + 10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main() -> None:\n    \"\"\"\n    讀取 stdin，解析 DNA 序列，輸出重複 10 字長子字串。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式，例如 \"s = 'AAAAACC...'\"\n    if \"=\" in data:\n        start = data.find(\"'\")\n        end = data.rfind(\"'\")\n        if start != -1 and end != -1 and end > start:\n            s = data[start + 1:end]\n        else:\n            s = data\n    else:\n        s = data\n\n    sol = Solution()\n    result = sol.findRepeatedDnaSequences(s)\n    # 使用 json.dumps 以雙引號輸出列表，符合範例格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo code step-by-step for the described algorithm: find all 10-letter-long substrings that appear more than once in string s. Standard solution uses sliding window and hash map. Provide pseudo code with arrows, decisions. Let's generate steps: Start, input string s, length n, if n<10 return empty, initialize map, result set, loop i from 0 to n-10 inclusive, get substring, if map contains -> if value==1 add to result, increment map, else map 1. After loop, convert result set to list, End. Provide explanations.\n\nWe must not output real code, just virtual code. Use arrows and decisions. Provide each line with explanation after //.\n\nMake sure each line starts with virtual code step then space then // explanation.\n\nUse Start, End, Decision:. Use arrows \"→\" for flow.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Input s // 取得 DNA 序列字串\nLine 3: → n ← Length(s) // 計算序列長度\nLine 4: Decision: 如果 n < 10? // 無法形成 10 字長子字串\nLine 5: Yes → Return [] // 直接回傳空清單\nLine 6: No → // 繼續處理\nLine 7: → HashMap count ← {} // 儲存 10 字長子字串的出現次數\nLine 8: → Set result ← {} // 儲存重複的子字串\nLine 9: → For i from 0 to n-10 // 以滑動窗口遍歷所有可能子字串\nLine 10: → sub ← Substring(s, i, i+10) // 取出 10 字長子字串\nLine 11: Decision: 如果 sub 在 count? // 判斷子字串是否已經出現\nLine 12: Yes → cnt ← count[sub] // 取得已存的出現次數\nLine 13: Yes → cnt ← cnt + 1 // 次數加一\nLine 14: Yes → count[sub] ← cnt // 更新計數\nLine 15: Yes → Decision: 如果 cnt == 2? // 只在第二次出現時加入結果\nLine 16: Yes Yes → result.Add(sub) // 加入重複子字串\nLine 17: Yes No → // 已經加入過，保持結果不變\nLine 18: No → count[sub] ← 1 // 第一次出現，設定計數為 1\nLine 19: End // 迴圈結束\nLine 20: → List resList ← List(result) // 轉成列表\nLine 21: → Return resList // 回傳所有重複子字串\nLine 22: End // 程式執行結束\n\nCheck arrow formatting: lines with arrows and decisions. Decision lines should indent branches. Use \"→\" before each. For decisions we need \"Decision:\".\n\nMake sure each line has \"虛擬碼步驟\" followed by space then \"// 解釋\". For decision lines, we might indent. Use proper indent.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s // 取得 DNA 序列字串  \n→ n ← Length(s) // 計算序列長度  \nDecision: 如果 n < 10? // 無法形成 10 字長子字串  \n    Yes → Return [] // 直接回傳空清單  \n    No → // 繼續處理  \n→ HashMap count ← {} // 儲存 10 字長子字串的出現次數  \n→ Set result ← {} // 儲存重複的子字串  \n→ For i from 0 to n-10 // 以滑動窗口遍歷所有可能子字串  \n    → sub ← Substring(s, i, i+10) // 取出 10 字長子字串  \n    Decision: 如果 sub 在 count? // 判斷子字串是否已經出現  \n        Yes → cnt ← count[sub] // 取得已存的出現次數  \n        Yes → cnt ← cnt + 1 // 次數加一  \n        Yes → count[sub] ← cnt // 更新計數  \n        Yes → Decision: 如果 cnt == 2? // 只在第二次出現時加入結果  \n            Yes → result.Add(sub) // 加入重複子字串  \n            No  → // 已經加入過，保持結果不變  \n        No  → count[sub] ← 1 // 第一次出現，設定計數為 1  \n→ End // 迴圈結束  \n→ List resList ← List(result) // 轉成列表  \n→ Return resList // 回傳所有重複子字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])  # copy current permutation\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Find the first list literal in the input (e.g. [1,2,3])\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        nums_str = match.group(0)\n        nums = ast.literal_eval(nums_str)\n    else:\n        nums = []\n\n    sol = Solution()\n    perms = sol.permute(nums)\n\n    # Format output without spaces to match the examples\n    output = '[' + ','.join('[' + ','.join(map(str, perm)) + ']' for perm in perms) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for generating all permutations of an array of distinct integers. The format: each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols for flow: Start, Decision, etc. We should include recursion/backtracking. Provide line-by-line steps. The requirement: \"逐行地產生對應的虛擬碼\" means produce the algorithm steps.\n\nWe should not output actual code. Provide steps.\n\nLet's produce steps:\n\nStart\n→ Step 1: 定義結果列表 result // 用於存放所有排列\n→ Step 2: 定義遞歸函數 backtrack(path, remaining) // path 為當前排列，remaining 為尚未使用的元素\n→ Decision: 如果 remaining 為空? // 檢查是否已排列完成\n    Yes → Step 3: 複製 path 並加入 result // 完整排列加入結果\n    No  → Step 4: For 每個元素 in remaining: // 迭代所有可用元素\n        → Step 5: 呼叫 backtrack(path + [element], remaining - {element}) // 選擇元素並遞歸\nEnd\n\nBut need more detailed line structure. Provide arrows: \"→\" indicates next step, \"Yes →\" etc.\n\nWe should also include the initial call.\n\nStep 0: Start\n\nThen call backtrack([], nums).\n\nOk.\n\nLet's output.\n\nRemember to include \"End // 程式執行結束\" at end.\n\nAlso need to use \"Decision:\" for conditions.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 0: 初始化結果列表 result = [] // 用於存放所有排列\n→ Step 1: 定義遞歸函數 backtrack(path, remaining) // path: 當前已選擇的元素，remaining: 尚未選擇的元素\n→ Decision: 若 remaining 為空? // 判斷是否已經完成一個排列\n    Yes → Step 2: 複製 path 並加入 result // 完整排列加入結果列表\n    No  → Step 3: 對 remaining 中的每個 element 執行\n        → Step 4: 呼叫 backtrack(path + [element], remaining \\ {element}) // 選擇 element 後遞歸進行下一層選擇\n→ Step 5: 呼叫 backtrack([], nums) // 從空排列開始，使用所有數字\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwm1153ds.py\", line 65, in <module>\n    args = ast.literal_eval(lines[1].strip())\n                            ~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # List to store all values\n        self.data = []\n        # Dict mapping value -> set of indices in self.data\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        # Append the value to the list\n        self.data.append(val)\n        # Record the new index in the map\n        self.idx_map[val].add(len(self.data) - 1)\n        # Return True if this is the first occurrence\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        # If value not present, cannot remove\n        if not self.idx_map[val]:\n            return False\n        # Remove an arbitrary index of the value\n        remove_idx = self.idx_map[val].pop()\n        # Last element in the list\n        last_val = self.data[-1]\n        # Move last element to the removed spot if needed\n        if remove_idx != len(self.data) - 1:\n            self.data[remove_idx] = last_val\n            # Update index sets\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(len(self.data) - 1)\n        # Remove the last element from the list\n        self.data.pop()\n        # Clean up the map entry if empty\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        # Randomly select an index and return the element\n        return random.choice(self.data)\n\nif __name__ == \"__main__\":\n    # Read all input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Parse the two lists (methods and arguments)\n    if '],[' in raw_input:\n        # Handles format like: [\"op1\",\"op2\"], [[1],[2]]\n        parts = raw_input.split('],', 1)\n        methods_part = parts[0] + ']'\n        args_part = parts[1]\n        methods = ast.literal_eval(methods_part.strip())\n        args = ast.literal_eval(args_part.strip())\n    else:\n        # Handles two separate lines\n        lines = [line for line in raw_input.splitlines() if line.strip()]\n        methods = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n\n    result = [None]  # first operation is constructor, output null\n    obj = None\n    for op, arg in zip(methods, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)\n        elif op == \"insert\":\n            res = obj.insert(arg[0])\n            result.append(res)\n        elif op == \"remove\":\n            res = obj.remove(arg[0])\n            result.append(res)\n        elif op == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n        else:\n            # Unknown operation, ignore\n            pass\n\n    # Output in JSON format (null, true, false)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need produce virtual code lines following format. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision etc. We should implement class RandomizedCollection with methods insert, remove, getRandom. Provide steps: initialization: use array/list for elements, hash map from val to set of indices. Insert: add to array, add index to map set. Return true if first insertion. Remove: if val not in map return false. Get one index from set, remove it. If removed index not last, move last element to that index and update map. Remove last from array. Return true. getRandom: pick random index from array length. Each step in virtual code.\n\nWe need to output step by step lines. For clarity, we might start with class definition. But as virtual code, just steps. Use \"Start\" at beginning. Let's produce.\n\nWe may include substeps for insert, remove, getRandom as functions. Use indentation? Not specified but using arrow lines.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step: 初始化 RandomizedCollection // 建立空列表和空映射\n→ Decision: 是否呼叫 insert? // 用於流程示範\n    Yes → Step: insert(val) // 執行插入邏輯\n        ... etc\n\nBut perhaps better to show each function's internal steps. Provide separate sections for each method. Use \"Start\", \"End\" at end.\n\nLet's produce as:\n\nStart // 程式開始\n→ Step 1: 建立 list elements = [] // 存放所有元素\n→ Step 2: 建立 dict idx_map = {} // val -> set of indices\nEnd // 建構完成\n\nThen for insert:\n\nStart // insert(val) 開始\n→ Step: 若 val 不在 idx_map 則 idx_map[val] = set() // 初始化集合\n→ Step: append val 到 elements // 新元素加到列表尾端\n→ Step: idx = len(elements) - 1 // 新元素的索引\n→ Step: idx_map[val].add(idx) // 將索引加入對應集合\n→ Decision: idx_map[val] 的大小之前是否為 1? // 判斷是否首次出現\n    Yes → Return true // 新值未存在\n    No  → Return false // 已存在\nEnd // insert 結束\n\nSimilarly for remove.\n\nLet's craft lines accordingly.\n\nUse Chinese explanation.\n\nWe must avoid actual code syntax, just pseudo steps.\n\nWe need to maintain formatting: each line: \"虛擬碼步驟 // 解釋\".\n\nOk.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 list elements = [] // 用來儲存所有元素的順序列表  \n→ Step 2: 建立 dict idx_map = {} // key 為值，value 為該值在 elements 中所有索引的集合  \nEnd // 建構完成  \n\n---  \n\nStart // insert(val) 開始  \n→ Step 1: 若 val 不在 idx_map，則 idx_map[val] = set() // 初始化此值的索引集合  \n→ Step 2: elements.append(val) // 把新值加入列表尾端  \n→ Step 3: idx = len(elements) - 1 // 計算新加入元素的索引  \n→ Step 4: idx_map[val].add(idx) // 把索引加入對應值的索引集合  \n→ Decision: idx_map[val] 的大小是否為 1? // 判斷是否為首次插入此值  \n    Yes → Step 5: Return true // 這是新值，回傳 true  \n    No  → Step 5: Return false // 已存在，回傳 false  \nEnd // insert 結束  \n\n---  \n\nStart // remove(val) 開始  \n→ Decision: val 是否存在於 idx_map? // 檢查是否有可移除的值  \n    No → Step 1: Return false // 沒有此值，無法移除  \n    Yes → Step 1: idx_to_remove = 任意取 idx_map[val] 中的一個索引 // 取出一個該值的索引  \n→ Step 2: idx_map[val].remove(idx_to_remove) // 從索引集合中移除該索引  \n→ Decision: idx_to_remove 是否等於 len(elements)-1? // 判斷是否為最後一個元素  \n    Yes → Step 3: elements.pop() // 直接移除最後一個元素  \n    No  → Step 3: last_val = elements[-1] // 取最後一個元素的值  \n        Step 4: elements[idx_to_remove] = last_val // 把最後一個元素搬到要移除的位置  \n        Step 5: elements.pop() // 移除最後一個位置  \n        Step 6: idx_map[last_val].remove(len(elements)) // 移除舊索引  \n        Step 7: idx_map[last_val].add(idx_to_remove) // 加入新索引  \n→ Step 8: If idx_map[val] 為空集合，則刪除 idx_map[val] // 清除空集合以節省空間  \n→ Step 9: Return true // 成功移除一個元素  \nEnd // remove 結束  \n\n---  \n\nStart // getRandom() 開始  \n→ Step 1: n = len(elements) // 獲取目前元素數量  \n→ Step 2: rand_index = 隨機取整數 [0, n-1] // 隨機索引  \n→ Step 3: Return elements[rand_index] // 回傳對應的隨機值  \nEnd // getRandom 結束"
    },
    {
      "title": "Coin Change",
      "source_file": "Leetcode/leetcode322.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # dp[i] 表示湊成金額 i 所需的最少硬幣數，初始為無限大\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                if dp[i - coin] != float('inf'):\n                    dp[i] = min(dp[i], dp[i - coin] + 1)\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\ndef parse_input(s: str):\n    \"\"\"將類似 'coins = [1,2,5], amount = 11' 的字串解析成 (coins, amount)\"\"\"\n    s = s.strip()\n    if not s:\n        return [], 0\n    # 將等號轉成冒號，並包裝成 dict 字串\n    dict_str = '{' + s.replace('=', ':') + '}'\n    try:\n        data = eval(dict_str, {}, {})\n    except Exception:\n        data = {}\n    coins = data.get('coins', [])\n    amount = data.get('amount', 0)\n    return coins, amount\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    coins, amount = parse_input(raw_input)\n    result = Solution().coinChange(coins, amount)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for the classic coin change problem: compute min number of coins. We need to produce virtual code steps line by line, with comments. Use Start, End, Decision, Yes, No, arrows. Probably dynamic programming: create array dp of size amount+1, initialize with large value, dp[0]=0, for each coin iterate i from coin to amount, dp[i] = min(dp[i], dp[i-coin]+1). After filling, if dp[amount] is still large, return -1 else dp[amount]. Provide each step line with explanation. We'll produce pseudo code.\n\nMake sure to follow format: each line \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision: etc. Need to produce line by line. Let's outline:\n\nStart // start\n→ Step 1: 初始化 dp 数组长度 amount+1，填充大值 // set initial\n→ Step 2: dp[0] = 0 // base case\n→ Decision: 迭代每枚硬币? // iterate coins\n    Yes → Step 3: for each coin in coins // coin loop\n        → Step 4: 迭代金额从 coin 到 amount\n            → Step 5: 计算 newCount = dp[i-coin] + 1\n            → Step 6: dp[i] = min(dp[i], newCount)\n        // inner loop done\n    No // no more coins\n→ Decision: dp[amount] 是否大于等于 大值? // check if unreachable\n    Yes → Step 7: 返回 -1\n    No  → Step 8: 返回 dp[amount]\nEnd // end\n\nBut we must use arrows appropriately. Let's produce each line. Use \"Start\", \"End\" as separate lines. Use \"Decision:\" lines with indent. For loops, we may show \"Step\" with indentation. Use \"→ Step\" etc.\n\nWe need to output each line as: \"虛擬碼步驟 // 解釋/說明\". We cannot output actual code but pseudocode. Should we include loops? It's fine. We'll follow pattern: each line may be:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 陣列長度為 amount+1，並將每個位置設為一個足夠大的值 // 將 dp 初始化為無限大，代表未找到組合\n→ Step 2: dp[0] ← 0 // 金額為 0 時不需要任何硬幣\n→ Decision: 是否開始遍歷 coins? // 準備處理每種硬幣\n    Yes → Step 3: for each coin in coins // 逐一處理每種硬幣\n        → Step 4: for i from coin to amount // 只考慮可達金額\n            → Step 5: newCount ← dp[i-coin] + 1 // 用一枚當前硬幣加上剩餘金額的最小硬幣數\n            → Step 6: dp[i] ← min(dp[i], newCount) // 選擇更少的硬幣數\n        // 完成對當前硬幣的內層迴圈\n    No // 沒有硬幣可處理\n→ Decision: dp[amount] 是否大於等於大值? // 判斷是否無法組成目標金額\n    Yes → Step 7: return -1 // 無法組成\n    No  → Step 8: return dp[amount] // 返回最小硬幣數\nEnd // 程式結束\n\nWe must keep each line separate with no additional lines? It says \"逐行輸出\". So each line separate. Use appropriate indentation? The example shows indentation for nested lines. We'll mimic that. Each line should have virtual code step with arrow and comment. We'll produce the lines exactly.\n\nMake sure to include \"Start\" and \"End\". Use \"Decision:\" with indentation. The arrows may be shown as \"→\". For loops we use \"→ Step\". For nested we indent.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 陣列長度為 amount+1，並將每個位置設為一個足夠大的值 // 將 dp 初始化為無限大，代表未找到組合  \n→ Step 2: dp[0] ← 0 // 金額為 0 時不需要任何硬幣  \n→ Decision: 是否開始遍歷 coins? // 準備處理每種硬幣  \n  Yes → Step 3: for each coin in coins // 逐一處理每種硬幣  \n    → Step 4: for i from coin to amount // 只考慮可達金額  \n      → Step 5: newCount ← dp[i-coin] + 1 // 用一枚當前硬幣加上剩餘金額的最小硬幣數  \n      → Step 6: dp[i] ← min(dp[i], newCount) // 選擇更少的硬幣數  \n    // 完成對當前硬幣的內層迴圈  \n  No // 沒有硬幣可處理  \n→ Decision: dp[amount] 是否大於等於大值? // 判斷是否無法組成目標金額  \n  Yes → Step 7: return -1 // 無法組成  \n  No  → Step 8: return dp[amount] // 返回最小硬幣數  \nEnd // 程式結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8kjrz3nm.py\", line 52, in <module>\n    startGene, endGene, bank = parse_input(raw_input)\n                               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8kjrz3nm.py\", line 42, in parse_input\n    data[key] = ast.literal_eval(value)\n                ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"AACCGGTA\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list[str]) -> int:\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            for i in range(len(current)):\n                for g in genes:\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\ndef parse_input(text: str) -> tuple[str, str, list[str]]:\n    \"\"\"Parse input like\n    startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    \"\"\"\n    parts = [p.strip() for p in text.split(',')]\n    data = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, value = part.split('=', 1)\n        key = key.strip()\n        value = value.strip()\n        if key == 'bank':\n            # safe eval of list\n            data[key] = ast.literal_eval(value)\n        else:\n            # strip quotes\n            data[key] = value.strip('\"').strip(\"'\")\n    return data['startGene'], data['endGene'], data['bank']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    startGene, endGene, bank = parse_input(raw_input)\n    solution = Solution()\n    result = solution.minMutation(startGene, endGene, bank)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo code for BFS. Steps: start, create set, visited, queue, level. Loop until queue empty. For each current, if equals end, return level. Generate 4 variations each position, if in bank and not visited, enqueue, mark visited. Increment level after level loop. If none, return -1. Use start, decision etc. Provide line-by-line with arrow syntax. Ensure every line has `虛擬碼步驟` + space + `// 解釋/說明`. Use Start, End, Decision. Let's craft. Use Start // 程式開始執行. Then Step: 建立變數 bankSet, visited, queue. etc. Use arrow ->. Use Decision: 如果 current 等於 endGene? etc. Use nested loops: for i 0-7. for char in 'ACGT'. Use Decision: if next 在 bankSet 且 not visited? yes branch. After loop, increment level. After queue empty return -1. End. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: bankSet ← Set(bank) // 將 gene bank 轉成集合，方便 O(1) 檢查  \n→ Step 2: visited ← Set() // 記錄已訪問的基因，避免重複  \n→ Step 3: queue ← Queue() // BFS 用的佇列  \n→ Step 4: queue.enqueue(startGene) // 從起始基因開始  \n→ Step 5: visited.add(startGene) // 標記起始基因已訪問  \n→ Step 6: level ← 0 // 目前的突變步數  \n\n→ Decision: queue 是否為空? // 是否還有基因可處理  \n    Yes → End // queue 為空，表示沒找到 endGene，接下來處理結束  \n    No  → → While queue 不是空 // 處理每一層  \n\n        → Decision: queue.size() == 0? // 檢查是否已經無基因  \n            Yes → End // 無基因可處理，結束  \n            No  → → Step 7: current ← queue.dequeue() // 取出當前基因  \n\n        → Decision: current == endGene? // 是否已達終點  \n            Yes → → Step 8: return level // 回傳最小突變數  \n            No  → → Step 9: for i from 0 to 7 // 遍歷每個位置  \n                → Step 10: originalChar ← current[i] // 目前字符  \n                → Step 11: for char in ['A','C','G','T'] // 嘗試四種字符  \n                    → Decision: char != originalChar? // 只考慮改變  \n                        Yes → → Step 12: nextGene ← current[0:i] + char + current[i+1:] // 產生新基因  \n                        → Decision: nextGene 在 bankSet 且 nextGene 不在 visited? // 合法且未訪問  \n                            Yes → → Step 13: queue.enqueue(nextGene) // 加入佇列  \n                            → Step 14: visited.add(nextGene) // 標記已訪問  \n                            No  → // 無效或已訪問，忽略  \n                        No  → // 與原字符相同，忽略  \n                → // for char 迴圈結束  \n            → // for i 迴圈結束  \n            → Step 15: level ← level + 1 // 完成一層後步數加一  \n            → // While 迴圈繼續  \n\n→ Step 16: return -1 // 未找到 endGene，回傳 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp79vxdet2.py\", line 45, in <module>\n    methods = ast.literal_eval(methods_str)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆儲存較大的數字\n        self.large = []\n        # 大根堆（透過負號實作）儲存較小的數字\n        self.small = []\n\n    def addNum(self, num: int) -> None:\n        # 把新數字先放進小根堆\n        heapq.heappush(self.large, num)\n\n        # 若小根堆頂元素小於大根堆頂元素，交換\n        if self.large and self.small and self.large[0] < -self.small[0]:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n        # 平衡兩堆大小，差值不超過 1\n        if len(self.large) > len(self.small) + 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n        elif len(self.small) > len(self.large):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n    def findMedian(self) -> float:\n        if len(self.large) > len(self.small):\n            return float(self.large[0])\n        return (-self.small[0] + self.large[0]) / 2.0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入分成兩個列表\n    parts = data.split('],', 1)\n    methods_str = parts[0].strip()\n    args_str = ']' + parts[1].strip() if len(parts) > 1 else '[]'\n\n    methods = ast.literal_eval(methods_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n\n    for method, arg in zip(methods, args):\n        if method == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif method == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif method == \"findMedian\":\n            result.append(obj.findMedian())\n\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, describing algorithm for MedianFinder. Likely use two heaps: max-heap for lower half, min-heap for upper half. Each addNum balances heaps. findMedian returns top of heaps or average. We need to present as virtual code lines with // explanation. Each line should be: \"虛擬碼步驟 // 解釋\". Use arrows. Should start with Start. End. Use Decision lines.\n\nWe need to create class skeleton: Initialize two heaps. Methods: addNum, findMedian. Provide logic. Also we can describe balancing.\n\nLet's structure:\n\nStart\n→ Step 1: 定義 MedianFinder 類別\n→ Step 2: 初始化 lowerHalf (大根堆) 與 upperHalf (小根堆)\n→ Step 3: addNum 方法\n→ Decision: 是否將 num 加入 lowerHalf? etc\n\nBut we must keep line by line. Use arrow after Start? The example: Start // 程式開始執行\n→ Step 1: 輸入使用者數字 // ...\nSo each step prefixed with arrow. Should we indent decisions? The example used indent with spaces before \"Yes →\", etc. We can do similarly.\n\nLet's produce virtual code.\n\nWe'll also mention the balancing rule: after insertion, if size difference >1, move root. findMedian: if sizes equal, average; else root of larger heap.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 MedianFinder 類別 // 建立類別\n→ Step 2: 初始化兩個堆: lowerHalf (max-heap) 與 upperHalf (min-heap) // 以儲存兩邊資料\n→ Step 3: addNum(num) 方法開始 // 插入新數字\n    → Decision: lowerHalf 內的最大值 (若存在) 是否大於 num? // 判斷應放在哪一邊\n        Yes → lowerHalf.add(num) // 放入較小半段\n        No  → upperHalf.add(num) // 放入較大半段\n→ Step 4: 平衡堆大小 // 確保兩堆大小差不超過 1\n    → Decision: lowerHalf.size() > upperHalf.size() + 1? // 過大\n        Yes → upperHalf.add(lowerHalf.poll()) // 將最大值移至 upperHalf\n        No  → Decision: upperHalf.size() > lowerHalf.size() + 1? // 另一邊過大\n            Yes → lowerHalf.add(upperHalf.poll()) // 將最小值移至 lowerHalf\n            No  → // 堆已平衡\n→ Step 5: findMedian() 方法開始 // 回傳中位數\n    → Decision: lowerHalf.size() == upperHalf.size()? // 數量相等\n        Yes → return (lowerHalf.peek() + upperHalf.peek()) / 2.0 // 兩邊平均\n        No  → Decision: lowerHalf.size() > upperHalf.size()? // 下半較多\n            Yes → return lowerHalf.peek() // 取 max\n            No  → return upperHalf.peek() // 取 min\nEnd // 程式執行結束\n\nBut we need to format each line with // explanation. Let's put each statement as a separate line. Use arrow. For decisions indent lines with spaces. Ensure each line is \"→ Step X: ... // ...\" or \"→ Decision: ...\". Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MedianFinder 類別 // 建立要實作的類別  \n→ Step 2: 初始化兩個堆: lowerHalf (大根堆) 與 upperHalf (小根堆) // 分別儲存較小和較大的數字  \n→ Step 3: addNum(num) 方法開始 // 將新數字加入資料結構  \n  → Decision: lowerHalf 內最大值（若存在）是否大於 num? // 判斷該數應落在左半段還是右半段  \n    Yes → lowerHalf.add(num) // num 比左半段最大值小，放入左堆  \n    No  → upperHalf.add(num) // num 比左半段最大值大，放入右堆  \n→ Step 4: 平衡堆大小 // 兩堆大小差不超過 1，確保中位數能直接取出  \n  → Decision: lowerHalf.size() > upperHalf.size() + 1? // 左堆太大  \n    Yes → upperHalf.add(lowerHalf.poll()) // 把左堆最大值移到右堆  \n    No  → Decision: upperHalf.size() > lowerHalf.size() + 1? // 右堆太大  \n      Yes → lowerHalf.add(upperHalf.poll()) // 把右堆最小值移到左堆  \n      No  → // 堆已平衡  \n→ Step 5: findMedian() 方法開始 // 計算目前所有數字的中位數  \n  → Decision: lowerHalf.size() == upperHalf.size()? // 數量相等，兩堆都有元素  \n    Yes → return (lowerHalf.peek() + upperHalf.peek()) / 2.0 // 取兩堆頂部平均  \n    No  → Decision: lowerHalf.size() > upperHalf.size()? // 左堆較多  \n      Yes → return lowerHalf.peek() // 直接取左堆最大值  \n      No  → return upperHalf.peek() // 直接取右堆最小值  \nEnd // 程式執行結束"
    },
    {
      "title": "Data Stream as Disjoint Intervals",
      "source_file": "Leetcode/leetcode352.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]'\nGot (Norm):      '[None,None,[[1,1]],None,[[1,1],[3,3]],None,[[1,1],[3,3],[7,7]],None,[[1,3],[7,7]],None,[[1,3],[6,7]]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]'\nRaw Got:      '[None, None, [[1, 1]], None, [[1, 1], [3, 3]], None, [[1, 1], [3, 3], [7, 7]], None, [[1, 3], [7, 7]], None, [[1, 3], [6, 7]]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass SummaryRanges:\n    def __init__(self):\n        # intervals 是一個按 start 排序的列表，元素為 [start, end]\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        \"\"\"將數字 val 加入 stream，並更新 intervals。\"\"\"\n        new_interval = [val, val]\n        res = []\n        placed = False  # 標記是否已把 new_interval 放入 res\n\n        for start, end in self.intervals:\n            if end + 1 < val:\n                # 現有區間結束於 val 前，完全不重疊\n                res.append([start, end])\n            elif val + 1 < start:\n                # val 位於現有區間之前且不相鄰\n                if not placed:\n                    res.append(new_interval)\n                    placed = True\n                res.append([start, end])\n            else:\n                # 與 new_interval 有重疊或相鄰，合併\n                new_interval[0] = min(start, new_interval[0])\n                new_interval[1] = max(end, new_interval[1])\n\n        if not placed:\n            # 若尚未加入，將 new_interval 加入末尾\n            res.append(new_interval)\n\n        self.intervals = res\n\n    def getIntervals(self):\n        \"\"\"回傳目前所有不相交區間的列表。\"\"\"\n        return self.intervals\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行是方法名稱列表，第二行是對應的參數列表\n    commands = ast.literal_eval(data[0])\n    arguments = ast.literal_eval(data[1])\n\n    obj = None\n    outputs = []\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"SummaryRanges\":\n            obj = SummaryRanges()\n            outputs.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            outputs.append(None)\n        elif cmd == \"getIntervals\":\n            outputs.append(obj.getIntervals())\n        else:\n            # 忽略未知指令\n            outputs.append(None)\n\n    # 以 Python 列表文字形式輸出\n    print(outputs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe task: produce pseudo-code steps line by line for implementing the SummaryRanges class. Provide description after each line.\n\nWe need to use arrows and decisions etc. Outline: class with constructor, data structure (maybe TreeMap or SortedSet), addNum, getIntervals. Since pseudo-code, we can use steps like: Use a sorted map of start -> end. When adding number, find predecessor and successor intervals. Merge accordingly.\n\nWe must produce each line with arrow and comment. Use \"Start\" and \"End\". We'll include steps for constructor, addNum, getIntervals.\n\nEnsure each line ends with // 解釋.\n\nWe'll not output actual code, just pseudo-steps.\n\nWe'll use the format:\n\nStart // ...\n\n→ Step 1: 初始化空的有序映射 intervals // 建立一個存放區間的有序映射\n\nFor addNum: we need to find lower key less than value and upper key greater or equal.\n\nWe'll use operations: find predecessor key less than value (prevStart). If exists and prevEnd >= value-1, it's overlapping or adjacent.\n\nSimilarly find successor start key > value. If exists and succStart <= value+1, merge.\n\nIf both merges happen, merge all three into one.\n\nElse if only left merge, extend left end.\n\nElse if only right merge, create new interval merging value with right interval.\n\nElse create new interval [value,value].\n\nWe'll express these as decisions.\n\nWe need to produce getIntervals: just return list of intervals sorted by start.\n\nAll steps sequential.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 SummaryRanges 類別，並建立一個空的有序映射 intervals // 用來存放區間，key 為區間起始值，value 為區間結束值  \n→ Step 2: 定義 Constructor: SummaryRanges() → intervals ← 空映射 // 初始時不包含任何數字  \n\n→ Step 3: 定義 addNum(value) 方法  \n    → Decision: 先尋找鍵小於 value 的最大鍵 prevStart? // 判斷是否存在可能與 value 合併的左側區間  \n        Yes → Step 4: prevEnd ← intervals[prevStart] // 取得左側區間結束值  \n        No  → Step 4: prevStart ← null, prevEnd ← -∞ // 沒有左側區間  \n\n    → Decision: 先尋找鍵大於等於 value 的最小鍵 nextStart? // 判斷是否存在可能與 value 合併的右側區間  \n        Yes → Step 5: nextEnd ← intervals[nextStart] // 取得右側區間結束值  \n        No  → Step 5: nextStart ← null, nextEnd ← ∞ // 沒有右側區間  \n\n    → Decision: 若 prevEnd >= value - 1 且 nextStart <= value + 1? // 同時可合併左右區間  \n        Yes →  \n            → Step 6: newStart ← prevStart // 左側區間起點  \n            → Step 7: newEnd ← max(prevEnd, nextEnd) // 取最大結束值  \n            → Step 8: 刪除 intervals[prevStart] 和 intervals[nextStart] // 移除舊區間  \n            → Step 9: intervals[newStart] ← newEnd // 插入合併後的新區間  \n        No → Decision: 若 prevEnd >= value - 1? // 只可合併左側  \n            Yes →  \n                → Step 10: intervals[prevStart] ← max(prevEnd, value) // 擴張左側區間結束值  \n            No → Decision: 若 nextStart <= value + 1? // 只可合併右側  \n                Yes →  \n                    → Step 11: intervals[value] ← nextEnd // 新區間起點為 value，結束為右側區間結束  \n                    → Step 12: 刪除 intervals[nextStart] // 移除原右側區間  \n                No →  \n                    → Step 13: intervals[value] ← value // 新增獨立區間 [value,value]  \n\n→ Step 14: 定義 getIntervals() 方法  \n    → Step 15: intervalsList ← 空列表 // 用於存放最終的區間陣列  \n    → Decision: 若 intervals 為空? // 若沒有任何區間  \n        Yes → Step 16: return intervalsList // 直接回傳空列表  \n        No →  \n            → Step 17: 對於每個鍵 start 在 intervals 的有序鍵序列  \n                → Step 18: end ← intervals[start]  \n                → Step 19: intervalsList ← intervalsList ∪ [[start, end]] // 加入 [start, end]  \n            → Step 20: return intervalsList // 回傳已排序的區間列表  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport collections\nimport re\n\nclass Solution:\n    def findMinStep(self, board: str, hand: str) -> int:\n        # Count balls in hand\n        hand_count = collections.Counter(hand)\n        # Memoization dictionary\n        memo = {}\n\n        INF = 10 ** 9\n\n        def eliminate(s: str) -> str:\n            \"\"\"Repeatedly remove groups of 3 or more same-colored balls.\"\"\"\n            changed = True\n            while changed:\n                changed = False\n                i = 0\n                n = len(s)\n                while i < n:\n                    j = i + 1\n                    while j < n and s[j] == s[i]:\n                        j += 1\n                    if j - i >= 3:\n                        s = s[:i] + s[j:]\n                        changed = True\n                        break  # restart scanning from the beginning\n                    i = j\n            return s\n\n        def dfs(cur: str, hand_cnt: collections.Counter) -> int:\n            \"\"\"Return minimal insertions to clear cur, or INF if impossible.\"\"\"\n            if not cur:\n                return 0\n            if not hand_cnt:\n                return INF\n            key = (cur, tuple(sorted(hand_cnt.items())))\n            if key in memo:\n                return memo[key]\n\n            best = INF\n            n = len(cur)\n            i = 0\n            while i < n:\n                j = i + 1\n                while j < n and cur[j] == cur[i]:\n                    j += 1\n                color = cur[i]\n                count = j - i\n                # balls needed to remove this group\n                need = max(0, 3 - count)\n                if hand_cnt.get(color, 0) >= need:\n                    # Use 'need' balls of this color\n                    new_hand = hand_cnt.copy()\n                    new_hand[color] -= need\n                    if new_hand[color] == 0:\n                        del new_hand[color]\n                    # Remove the group (it will be eliminated)\n                    new_board = eliminate(cur[:i] + cur[j:])\n                    res = dfs(new_board, new_hand)\n                    if res != INF:\n                        best = min(best, 1 + res)\n                i = j\n\n            memo[key] = best\n            return best\n\n        result = dfs(board, hand_count)\n        return -1 if result == INF else result\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract quoted substrings (board and hand)\n    parts = re.findall(r'\"(.*?)\"', data)\n    if len(parts) < 2:\n        print(-1)\n        return\n    board, hand = parts[0], parts[1]\n    sol = Solution()\n    ans = sol.findMinStep(board, hand)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving Zuma minimal insertion problem. Use BFS/DFS with state: board string, hand multiset counts. Need to compute min insertions. We will produce pseudocode steps line by line. Should include logic: use recursion with pruning, memoization. Steps: Start, define function minInsertions(board, handCounts) → integer. If board empty return 0. If no hand left return INF. For each position between balls, for each color available in hand, if color can be inserted to create group >=3, compute new board after elimination. Recursively compute. Keep min. Use memo map. Finally if min>=INF return -1 else return min. Also need helper eliminate(board) that collapses groups repeatedly. Provide pseudocode. Use virtual code syntax as per spec. Each line with // explanation. Use arrows etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 MinInsertions(board, handCounts) → int // 主要遞迴函式，輸入棋盤狀態與手牌計數，輸出最少插入數  \n  → Decision: 若 board 為空？ // 判斷棋盤是否已清空  \n    Yes → Return 0 // 清空則不需插入任何球  \n    No  → Decision: 若所有 handCounts 為 0？ // 判斷手牌是否已用完  \n      Yes → Return INF // 沒有手牌且棋盤不空，視為無解  \n      No  → Step 2: 產生 memoKey = board + \"#\" + handCountsString // 將狀態轉成唯一鍵，方便快取  \n       Decision: 若 memoKey 已存在於 memo？ // 快取判斷  \n         Yes → Return memo[memoKey] // 直接回傳已計算結果  \n        No  → Step 3: minInsert = INF // 初始化最小插入數  \n         → Decision: 若 board 的長度為 0？ // 再次確認  \n           Yes → Return 0  \n           No  → Step 4: For pos 在 0 .. board.length // 遍歷所有可插入位置（含兩端）  \n            → For color 在 [R,Y,B,G,W]  \n              Decision: 若 handCounts[color] == 0？ // 沒有此顏色球  \n                Yes → Continue // 跳過此顏色  \n               No  → Step 5: newBoard = board[:pos] + color + board[pos:] // 在 pos 處插入球  \n                → newBoard = Eliminate(newBoard) // 連續消除操作  \n                → newHandCounts = handCounts; newHandCounts[color]-- // 使用一顆球  \n                → result = MinInsertions(newBoard, newHandCounts) // 递归求解  \n                Decision: 若 result != INF？ // 能清除  \n                  Yes → minInsert = min(minInsert, 1 + result) // 加上本次插入  \n                  No → Continue // 無法清除，嘗試其他位置/顏色  \n                → End For color  \n               → End For pos  \n               → memo[memoKey] = minInsert // 記錄快取  \n               → Return minInsert  \n→ Step 6: 定義函式 Eliminate(board) → string // 連續消除所有 3+ 同色區塊  \n      → Loop: changed = False // 迴圈直到無法再消  \n        → 用索引 i 從 0 到 board.length-1  \n         → 令 j=i+1；若 board[j]==board[i] 連續增加 j  \n         → 若 j-i >=3？ // 同色區塊長度足夠  \n            board = board[:i] + board[j:] // 刪除該區塊  \n            changed = True; Break // 重新從頭檢查  \n            Else i = j // 否則移動到下一個區塊起點  \n        → 若 changed == False 退出 Loop  \n      → Return board // 消除後的棋盤  \n→ Step 7: 主程序  \n     → handCounts = CountCharacters(hand) // 轉換手牌字串為顏色計數字典  \n     → ans = MinInsertions(board, handCounts) // 呼叫遞迴求解  \n     Decision: 若 ans == INF？ // 仍是無解  \n       Yes → Output -1 // 不能全部清除  \n       No → Output ans // 輸出最少插入數  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Closest Palindrome",
      "source_file": "Leetcode/leetcode564.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = \"123\"",
          "expected_output": "\"121\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '121'\nGot (Norm):      '122'\n--- (Raw) ---\nRaw Expected: '\"121\"'\nRaw Got:      '122'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        \"\"\"\n        1. 建立候選回文集合\n        2. 先加入 n-1, n+1\n        3. 再加入相同長度、長度-1、長度+1 的特殊回文\n        4. 依差距與大小決定答案\n        \"\"\"\n        length = len(n)\n        num = int(n)\n        candidates = set()\n\n        # 1. n-1 與 n+1\n        candidates.add(str(num - 1))\n        candidates.add(str(num + 1))\n\n        # 2. 相同長度的回文（前半數變化 -1, 0, +1）\n        prefix = int(n[:(length + 1) // 2])\n        for delta in (-1, 0, 1):\n            new_prefix = str(prefix + delta)\n            if length % 2 == 0:\n                palin = new_prefix + new_prefix[::-1]\n            else:\n                palin = new_prefix + new_prefix[:-1][::-1]\n            candidates.add(palin)\n\n        # 3. 長度減一的最大回文（如 99...9）\n        if length > 1:\n            candidates.add('9' * (length - 1))\n\n        # 4. 長度加一的最小回文（如 100...001）\n        candidates.add('1' + '0' * (length - 1) + '1')\n\n        # 5. 移除自己\n        candidates.discard(n)\n\n        # 6. 找出距離最小，若相同則取較小的數字\n        best_candidate = None\n        best_diff = None\n        for cand in candidates:\n            cand_int = int(cand)\n            diff = abs(cand_int - num)\n            if best_candidate is None or diff < best_diff or (diff == best_diff and cand_int < int(best_candidate)):\n                best_candidate = cand\n                best_diff = diff\n\n        return best_candidate\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，預期格式為：n = \"123\" 或類似形式\n    data = sys.stdin.read()\n    # 從引號中擷取數字字串\n    match = re.search(r'\"(\\d+)\"', data)\n    if match:\n        n = match.group(1)\n    else:\n        # 若沒有引號，直接去除空白並作為輸入\n        n = data.strip().strip('\"').strip()\n\n    solution = Solution()\n    result = solution.nearestPalindromic(n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given n string, find nearest palindrome not itself. Typical LeetCode 864. Approach: consider candidates: n-1, n+1, all palindromes from length len-1, len, len+1. Generate palindrome candidates by mirroring prefix, adjust middle. Compute distance, pick min, tie choose smaller. We'll produce pseudocode step by step with arrows and decisions.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow.\n\nWe need step by step.\n\nLet's outline:\n\nStart\n→ Input n string\n→ Compute length L\n→ Define list candidates\n→ Add n-1 and n+1 to candidates (if they are not same as n)\n→ Generate palindromes of same length:\n    Take prefix (first ceil(L/2)) as left\n    Mirror left to form palindrome\n    Add to candidates\n→ For L-1 length palindromes: 9 repeated L-1\n→ For L+1 length: 1 followed by zeros then 1\n→ For each candidate:\n    If candidate == n, skip\n    Compute abs diff\n    Track best diff, best candidate; if tie choose smaller\n→ Output best candidate as string\n\nWe need decision steps for candidate > n etc.\n\nLet's produce lines. Ensure each line has virtual code plus comment.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 n // 取得欲尋找相鄰回文的數字  \n→ Step 2: 計算長度 L = len(n) // 紀錄 n 的位數  \n→ Step 3: 初始化候選集合 candidates = {} // 用於存放所有可能的回文  \n\n→ Step 4: 加入 n-1 和 n+1 為候選 // 先考慮最直接的鄰近數字  \n    → Step 4a: candidates.add(str(int(n)-1)) // 加入 n-1  \n    → Step 4b: candidates.add(str(int(n)+1)) // 加入 n+1  \n\n→ Decision: 生成相同長度 L 的回文  \n    Yes → Step 5: 取左半邊 prefix = n[0 : ceil(L/2)] // 取得前半部分  \n        → Step 6: 生成 palindrome = prefix + reverse(prefix[0 : L%2]) // 對稱拼接  \n        → Step 7: candidates.add(palindrome) // 加入同長度回文  \n\n→ Decision: 生成長度 L-1 的最大回文  \n    Yes → Step 8: If L > 1: candidates.add('9' * (L-1)) // 例如 999  \n\n→ Decision: 生成長度 L+1 的最小回文  \n    Yes → Step 9: candidates.add('1' + '0' * (L-1) + '1') // 例如 1001  \n\n→ Step 10: 初始化 bestDiff = ∞, bestCandidate = \"\" // 追蹤最佳答案  \n\n→ Step 11: 對每個 cand in candidates  \n    → Decision: 如果 cand == n?  \n        Yes → Skip // 跳過自身  \n        No →  \n            → Step 11a: diff = abs(int(cand) - int(n)) // 計算絕對差  \n            → Decision: diff < bestDiff?  \n                Yes → Step 11b: bestDiff = diff; bestCandidate = cand // 更新最佳  \n                No → Decision: diff == bestDiff?  \n                    Yes → Step 11c: If int(cand) < int(bestCandidate) → bestCandidate = cand // tie -> 小的  \n                    No → // 不更新  \n\n→ Step 12: 輸出 bestCandidate // 回傳最近的回文  \n\nEnd // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,null,-1,3,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, null, -1, 3, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # move to end (most recently used)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # remove least recently used\n\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Parse input string into commands and arguments\n    # Expected format: '[\"cmd1\", \"cmd2\", ...], [[arg1], [arg2], ...]'\n    try:\n        parts = raw_input.split('],', 1)\n        cmds = json.loads(parts[0] + ']')\n        args = json.loads('[' + parts[1])\n    except Exception:\n        # If parsing fails, exit gracefully\n        sys.exit()\n\n    results = []\n    cache = None\n\n    for cmd, arg in zip(cmds, args):\n        if cmd == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            results.append(None)\n        elif cmd == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif cmd == \"get\":\n            res = cache.get(arg[0])\n            results.append(res)\n\n    # Output results as JSON array (None -> null)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps, line by line, each line with \"虛擬碼步驟 // 解釋\". Use arrows and decision. We need to design LRU cache. Steps: initialization, get, put, internal methods. Show use of doubly linked list + hashmap. Provide step-by-step pseudo-code. Provide logic for moving node to head, evict tail. Each step line with explanation. Should be clear.\n\nLet's produce:\n\nStart\n→ Step: Initialize hash map and doubly linked list with dummy head and tail // Create containers\n→ Step: Set capacity variable // Store max size\nEnd\n\nThen get operation:\n\nStart get\n→ Decision: key in map? // Check existence\n    Yes → Step: node = map[key] // Retrieve node\n    Yes → Step: remove node from its current position // Maintain order\n    Yes → Step: insert node right after head // Mark as recently used\n    Yes → Step: return node.value // Return value\n    No → Step: return -1 // Not found\nEnd get\n\nPut operation:\n\nStart put\n→ Decision: key in map? // Check if exists\n    Yes → Step: node = map[key]\n    Yes → Step: node.value = value // Update\n    Yes → Step: remove node from its current position\n    Yes → Step: insert node after head\n    No → Step: create new node with key,value\n    No → Step: add node to map\n    No → Step: insert node after head\n    No → Decision: size > capacity? // Check overflow\n        Yes → Step: lru = tail.prev // Least recently used\n        Yes → Step: remove lru from list\n        Yes → Step: delete map[lru.key] // Evict\nEnd put\n\nWe should also define remove and insert operations. They could be separate steps.\n\nAlso include helper functions: removeNode(node), addNodeAfterHead(node). Provide pseudocode for those.\n\nThus output lines accordingly. We'll produce in format.\n\nLet's craft output.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step: 初始化 hashMap 為空映射 // 用於快速存取鍵對應的節點  \n→ Step: 建立雙向鏈表的 dummyHead 與 dummyTail 節點，並相連 // 為了簡化插入與刪除操作  \n→ Step: 設定 head = dummyHead，tail = dummyTail // 簡化後續操作  \n→ Step: 設定 capacity = input_capacity // 儲存 LRU 緩存容量  \n→ Step: size = 0 // 追蹤目前儲存的鍵數量  \nEnd // 初始化完成\n\n--------------------------------------------------------------------\nStart get // get 操作開始  \n\n→ Decision: key 是否存在於 hashMap? // 檢查鍵是否已存在  \n    Yes → Step: node = hashMap[key] // 取得對應節點  \n    Yes → Step: removeNode(node) // 從現有位置移除節點  \n    Yes → Step: addNodeAfterHead(node) // 插入到最前面，標記為最近使用  \n    Yes → Step: return node.value // 返回對應值  \n    No → Step: return -1 // 鍵不存在，回傳 -1  \nEnd get // get 操作結束  \n\n--------------------------------------------------------------------\nStart put // put 操作開始  \n\n→ Decision: key 是否存在於 hashMap? // 檢查鍵是否已存在  \n    Yes → Step: node = hashMap[key] // 取得對應節點  \n    Yes → Step: node.value = value // 更新值  \n    Yes → Step: removeNode(node) // 移除舊位置  \n    Yes → Step: addNodeAfterHead(node) // 插入到最前面  \n    No  → Step: node = 新建節點(key, value) // 建立新節點  \n    No  → Step: hashMap[key] = node // 加入映射  \n    No  → Step: addNodeAfterHead(node) // 插入到最前面  \n    No  → Step: size = size + 1 // 更新尺寸  \n\n→ Decision: size > capacity? // 檢查是否超過容量  \n    Yes → Step: lru = tail.prev // 找到最舊節點  \n    Yes → Step: removeNode(lru) // 從鏈表移除  \n    Yes → Step: delete hashMap[lru.key] // 刪除映射  \n    Yes → Step: size = size - 1 // 更新尺寸  \nEnd put // put 操作結束  \n\n--------------------------------------------------------------------\nStart removeNode(node) // 移除節點的子程序  \n→ Step: node.prev.next = node.next // 連接前一節點與後一節點  \n→ Step: node.next.prev = node.prev // 連接後一節點與前一節點  \nEnd removeNode  \n\n--------------------------------------------------------------------\nStart addNodeAfterHead(node) // 在 head 後插入節點的子程序  \n→ Step: node.next = head.next // 指向舊的第一個節點  \n→ Step: node.prev = head // 前指向 head  \n→ Step: head.next.prev = node // 舊第一個節點的前指向新節點  \n→ Step: head.next = node // head 的 next 指向新節點  \nEnd addNodeAfterHead  \n\n--------------------------------------------------------------------\nEnd // 程式執行結束"
    },
    {
      "title": "Stickers to Spell Word",
      "source_file": "Leetcode/leetcode691.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprk42xdx5.py\", line 60, in <module>\n    stickers, target = parse_input(raw)\n                       ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprk42xdx5.py\", line 51, in parse_input\n    exec(data, {}, env)\n  File \"<string>\", line 1\n    stickers= [\"with\",\"example\",\"science\"], target= \"thehat\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "stickers = [\"notice\",\"possible\"], target = \"basicbasic\"",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_kjdw1ze.py\", line 60, in <module>\n    stickers, target = parse_input(raw)\n                       ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_kjdw1ze.py\", line 51, in parse_input\n    exec(data, {}, env)\n  File \"<string>\", line 1\n    stickers= [\"notice\",\"possible\"], target= \"basicbasic\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\ndef min_stickers(stickers, target):\n    \"\"\"Return the minimum number of stickers needed to form target,\n       or -1 if impossible.\"\"\"\n    # Pre‑compute letter frequency of each sticker\n    sticker_counts = [Counter(st) for st in stickers]\n    memo = {}\n\n    def dp(rem):\n        \"\"\"Recursive DP with memoization on remaining string `rem`.\"\"\"\n        if rem == \"\":\n            return 0\n        if rem in memo:\n            return memo[rem]\n\n        # Count letters needed for the remaining string\n        need = Counter(rem)\n        best = float('inf')\n\n        # Try every sticker that contains the first needed letter\n        for s in sticker_counts:\n            if rem[0] not in s:\n                continue\n\n            # Build the new remaining string after using this sticker\n            new_rem = \"\".join(\n                c * max(0, need[c] - s.get(c, 0)) for c in need\n            )\n\n            res = dp(new_rem)\n            if res != -1:\n                best = min(best, 1 + res)\n\n        memo[rem] = -1 if best == float('inf') else best\n        return memo[rem]\n\n    return dp(target)\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input like:\n        stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"\n    and return (stickers, target).\n    \"\"\"\n    # Normalize spacing and replace assignment signs for eval\n    data = data.replace(\"stickers =\", \"stickers=\").replace(\"target =\", \"target=\")\n    # Evaluate safely\n    env = {}\n    exec(data, {}, env)\n    return env[\"stickers\"], env[\"target\"]\n\nif __name__ == \"__main__\":\n    # Read all input\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    stickers, target = parse_input(raw)\n    ans = min_stickers(stickers, target)\n    print(ans)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm. Problem: minimum stickers to form target string. Classic problem \"Stickers to Spell Word\" (Leetcode 691). Approach: BFS or DP with bitmask or recursive memoization. Since target is small (concatenation of two random words, maybe <= 20 letters). Use recursion with memo: for each sticker, reduce target counts. Use DP on multiset.\n\nWe will produce pseudo-code steps:\n\nStart\n→ Step: Initialize dictionary of sticker counts: for each sticker, count letters frequency\n→ Step: Memo map\n→ Decision: if target empty → return 0\n→ Step: if target string in memo → return memo value\n→ Step: For each sticker:\n    → Step: compute remaining string after applying sticker\n    → Decision: if remaining string == target → skip (no progress)\n    → Step: recursively get stickers needed for remaining\n    → If result not -1 → update min\n→ Step: if min not found → memo[target] = -1\n→ Else memo[target] = min+1\n→ Return memo[target]\nEnd\n\nBut we must produce virtual code with arrows and explanations. Each line includes the step and comment. Use structure Start, End, Decision, etc. Provide multiple decision branches.\n\nWe need to be thorough but concise. Use \"Step: ...\" lines. Use \"→\" to denote next step. Use indentation for decisions.\n\nAlso handle infinite stickers: we can reuse same sticker multiple times, but recursion handles by picking stickers repeatedly.\n\nWe need to show minimal number.\n\nPseudo code:\n\nStart\n→ Step 1: Count frequencies of each sticker, store in list stickerFreqs\n→ Step 2: Define function dfs(remTarget) // compute min stickers for remTarget\n    → Decision: if remTarget empty? // no letters left\n        → Yes → Return 0 // no more stickers needed\n    → Decision: if remTarget in memo? \n        → Yes → Return memo[remTarget]\n    → Step 3: Set minStickers = INF\n    → For each freq in stickerFreqs:\n        → Step 4: Compute newTarget = subtract freq from remTarget\n        → Decision: if newTarget == remTarget? // sticker doesn't contribute\n            → Yes → Continue // skip\n        → Step 5: Call dfs(newTarget) → res\n        → Decision: if res != -1? // feasible\n            → Yes → minStickers = min(minStickers, res + 1)\n    → Decision: if minStickers == INF? // no feasible\n        → Yes → memo[remTarget] = -1\n        → No → memo[remTarget] = minStickers\n    → Return memo[remTarget]\n→ Step 6: Call dfs(target) → answer\n→ Decision: if answer == -1? // impossible\n    → Yes → Return -1\n    → No → Return answer\nEnd\n\nAlso show step for subtracting frequencies. Use helper function.\n\nWe must produce line-by-line with comments.\n\nAlso we need to use arrow for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得每張貼紙的字母頻率清單 stickerFreqs // 把每張貼紙的字母統計成字頻表  \n→ Step 2: 建立記憶化表 memo = {} // 用於存儲子問題的結果，避免重複計算  \n\n→ Step 3: 定義遞迴函式 dfs(remTarget) // 計算剩餘字串 remTarget 所需貼紙數  \n    → Decision: 如果 remTarget 為空? // 所有字母已完成  \n        Yes → Return 0 // 無需再貼紙  \n    → Decision: 如果 remTarget 已存在於 memo?  \n        Yes → Return memo[remTarget] // 直接回傳已計算的結果  \n\n    → Step 4: minStickers ← ∞ // 初始化為無限大，表示尚未找到可行方案  \n\n    → For each freq in stickerFreqs: // 嘗試每一張貼紙  \n        → Step 5: newTarget ← subtract(remTarget, freq) // 用貼紙減去字頻，得到剩餘字串  \n        → Decision: 如果 newTarget == remTarget? // 這張貼紙沒有提供任何字母  \n            Yes → Continue // 跳過此貼紙  \n\n        → Step 6: res ← dfs(newTarget) // 重新計算剩餘字串所需貼紙數  \n        → Decision: 如果 res ≠ -1? // 有可行方案  \n            Yes → minStickers ← min(minStickers, res + 1) // 加上這張貼紙  \n\n    → Decision: 如果 minStickers 為 ∞? // 沒有貼紙能解決此子問題  \n        Yes → memo[remTarget] ← -1 // 標記為不可行  \n        No  → memo[remTarget] ← minStickers // 存儲最小貼紙數  \n\n    → Return memo[remTarget] // 回傳結果  \n\n→ Step 7: answer ← dfs(target) // 以目標字串作為初始參數調用遞迴  \n→ Decision: 如果 answer == -1? // 任務無法完成  \n    Yes → Return -1 // 回傳失敗標記  \n    No  → Return answer // 回傳最小貼紙數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        i = 0\n        # find interval that could cover 'left'\n        for idx, (l, r) in enumerate(self.ranges):\n            if l <= left < r:\n                i = idx\n                break\n        else:\n            return False\n        return self.ranges[i][0] <= left and right <= self.ranges[i][1]\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    lines = [line.strip() for line in sys.stdin.read().strip().splitlines() if line.strip()]\n    vars = {}\n    results = []\n\n    for line in lines:\n        if line.startswith('RangeModule'):\n            # constructor\n            left, _ = line.split('=', 1)\n            var_name = left.strip().split()[-1]\n            vars[var_name] = RangeModule()\n            results.append(None)\n        else:\n            var_dot, rest = line.split('.', 1)\n            var_name = var_dot.strip()\n            method_part = rest.rstrip(';').strip()\n            method_name, args_part = method_part.split('(', 1)\n            args_str = args_part.rstrip(')')\n            args = [int(a.strip()) for a in args_str.split(',')] if args_str else []\n\n            obj = vars[var_name]\n            if method_name == 'addRange':\n                obj.addRange(*args)\n                results.append(None)\n            elif method_name == 'removeRange':\n                obj.removeRange(*args)\n                results.append(None)\n            elif method_name == 'queryRange':\n                res = obj.queryRange(*args)\n                results.append(res)\n            else:\n                # ignore unknown methods\n                pass\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing RangeModule. Not actual code, but pseudocode structure. We need to design data structure: maybe use sorted list of intervals or tree. We'll describe steps. Each line: 虛擬碼步驟 + space + // explanation.\n\nWe'll produce lines:\n\nStart\n→ Step 1: 初始化空 intervals list // store tracked intervals sorted\n\nDefine addRange: find position, merge overlapping intervals.\n\nWe'll outline algorithm.\n\nUse decisions.\n\nWe'll produce pseudo code.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建空列表 intervals // 用來儲存已追蹤的半開區間，按左端點遞增排序  \n→ Step 2: 定義 RangeModule() → Initialize intervals as empty list // 建構子初始化資料結構  \n\n→ Step 3: 定義 addRange(left, right)  \n  → Decision: 如果 right <= left? // 無效區間  \n   Yes → End addRange // 直接返回  \n   No  →  \n    → Step 4: 在 intervals 找到第一個左端點大於 left 的位置 idx_start // 二分搜尋  \n    → Step 5: 從 idx_start 向前移動，直到找不到與 left 相交的區間  \n    → Step 6: 取 idx_start 為 merge_start  \n    → Step 7: 找到最後一個與 right 相交或相鄰的區間 idx_end // 二分搜尋或線性掃描  \n    → Step 8: new_left = min(left, intervals[merge_start].left)  \n    → Step 9: new_right = max(right, intervals[merge_end].right) // 合併所有重疊區間  \n    → Step 10: 刪除 intervals[merge_start … merge_end] // 去除重疊區間  \n    → Step 11: 插入 intervals[merge_start] = [new_left, new_right] // 加入合併後的區間  \n    → End addRange // 完成加入  \n\n→ Step 12: 定義 queryRange(left, right)  \n  → Decision: 如果 right <= left? // 空區間，始終為真  \n   Yes → Return true // 空區間內所有數字皆被追蹤  \n   No  →  \n    → Step 13: 在 intervals 找到第一個左端點 <= left 的區間 idx // 二分搜尋  \n    → Decision: idx 不存在 或 intervals[idx].right < left? // 無覆蓋左端點  \n     Yes → Return false // 無法覆蓋整個區間  \n     No  →  \n      → Decision: intervals[idx].right < right? // 覆蓋不足  \n       Yes → Return false // 右端點未被追蹤  \n       No  → Return true // 右端點在此區間內，整個區間被追蹤  \n    → End queryRange // 完成查詢  \n\n→ Step 14: 定義 removeRange(left, right)  \n  → Decision: 如果 right <= left? // 空區間，直接返回  \n   Yes → End removeRange  \n   No  →  \n    → Step 15: 在 intervals 找到第一個左端點大於 left 的位置 idx_start  \n    → Step 16: 從 idx_start 向前移動，直到找不到與 left 相交的區間  \n    → Step 17: 找到最後一個與 right 相交的區間 idx_end  \n    → Decision: 是否有左側剩餘區間?  \n     Yes → Step 18: intervals[idx_start].right = left // 截斷左側區間  \n     No  → // 無左側剩餘  \n    → Decision: 是否有右側剩餘區間?  \n     Yes → Step 19: intervals[idx_end].left = right // 截斷右側區間  \n     No  → // 無右側剩餘  \n    → Step 20: 刪除 intervals[idx_start+1 … idx_end-1] // 刪除完全被移除的區間  \n    → End removeRange // 完成移除  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjh64owzm.py\", line 89, in <module>\n    main()\n  File \"/tmp/tmpjh64owzm.py\", line 71, in main\n    ops = json.loads(data[0])          # 例: [\"MyCircularDeque\", \"insertLast\", ...]\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        \"\"\"初始化容量為 k 的循環雙端佇列\"\"\"\n        self.k = k                    # 最大容量\n        self.buf = [0] * k            # 存儲元素的固定長度陣列\n        self.head = 0                 # 指向隊列首元素的索引\n        self.count = 0                # 當前元素數量\n\n    def insertFront(self, value: int) -> bool:\n        \"\"\"在前端插入元素，若已滿則失敗\"\"\"\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        \"\"\"在尾端插入元素，若已滿則失敗\"\"\"\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        \"\"\"刪除前端元素，若為空則失敗\"\"\"\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        \"\"\"刪除尾端元素，若為空則失敗\"\"\"\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        \"\"\"取得前端元素，若為空回傳 -1\"\"\"\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        \"\"\"取得尾端元素，若為空回傳 -1\"\"\"\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        \"\"\"判斷佇列是否為空\"\"\"\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        \"\"\"判斷佇列是否已滿\"\"\"\n        return self.count == self.k\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])          # 例: [\"MyCircularDeque\", \"insertLast\", ...]\n    args = json.loads(data[1])         # 例: [[3], [1], ...]\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(arg[0])\n            results.append(None)  # 代表 constructor 返回 null\n        else:\n            method = getattr(obj, op)\n            res = method(*arg)\n            results.append(res)\n\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps describing implementation of MyCircularDeque class. Provide each line with comment. Use virtual code with arrows, Start, End, Decision etc. Should be step by step design. Not actual code. Should include steps: initialize array, head tail pointers, size, capacity. Provide operations logic. Use Decision for empty/full etc. We'll output in Chinese explanation. Ensure each line has virtual code and comment.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: MyCircularDeque(int k) ← 初始化儲存區與指標 // 創建大小為 k 的陣列，並設定 head、tail、size  \n→ Step 2: head ← 0 // 指向隊列首位置  \n→ Step 3: tail ← 0 // 指向隊列尾位置  \n→ Step 4: size ← 0 // 目前元素數量  \n→ Step 5: capacity ← k // 最大容量  \n\n→ Step 6: insertFront(val) ← // 試圖在前面插入元素  \n→ Decision: 如果 isFull()? // 檢查是否已滿  \n  Yes → Return false // 不能插入  \n  No  → head ← (head - 1 + capacity) mod capacity // 往前移動 head  \n    array[head] ← val // 存入資料  \n    size ← size + 1  \n    Return true  \n\n→ Step 7: insertLast(val) ← // 試圖在後面插入元素  \n→ Decision: 如果 isFull()?  \n  Yes → Return false  \n  No  → array[tail] ← val // 存入資料  \n    tail ← (tail + 1) mod capacity // 往後移動 tail  \n    size ← size + 1  \n    Return true  \n\n→ Step 8: deleteFront() ← // 刪除前面元素  \n→ Decision: 如果 isEmpty()? // 檢查是否為空  \n  Yes → Return false // 無法刪除  \n  No  → head ← (head + 1) mod capacity // 移動 head  \n    size ← size - 1  \n    Return true  \n\n→ Step 9: deleteLast() ← // 刪除後面元素  \n→ Decision: 如果 isEmpty()?  \n  Yes → Return false  \n  No  → tail ← (tail - 1 + capacity) mod capacity // 往前移動 tail  \n    size ← size - 1  \n    Return true  \n\n→ Step 10: getFront() ← // 取得前面元素  \n→ Decision: 如果 isEmpty()?  \n  Yes → Return -1 // 空則回傳 -1  \n  No  → Return array[head]  \n\n→ Step 11: getRear() ← // 取得最後一個元素  \n→ Decision: 如果 isEmpty()?  \n  Yes → Return -1  \n  No  → idx ← (tail - 1 + capacity) mod capacity // 計算最後一個索引  \n    Return array[idx]  \n\n→ Step 12: isEmpty() ← // 判斷是否空  \n→ Return size == 0  \n\n→ Step 13: isFull() ← // 判斷是否滿  \n→ Return size == capacity  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcv8cvj2o.py\", line 76, in <module>\n    main()\n  File \"/tmp/tmpcv8cvj2o.py\", line 58, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ,[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    \"\"\"Trie節點，儲存子節點與是否為單字結束的標記。\"\"\"\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    \"\"\"支援 addWord 與 search（含 '.' 通配符）的字典。\"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            ch = word[i]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], i + 1)\n        return dfs(self.root, 0)\n\ndef main() -> None:\n    \"\"\"主程式：從 stdin 讀取操作與參數，執行後輸出結果。\"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析兩個列表：操作與對應參數\n    lines = raw.splitlines()\n    if len(lines) >= 2:\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n    else:\n        # 若兩個列表在同一行，用分隔符拆分\n        line = lines[0]\n        idx = line.find(']')\n        ops_str = line[:idx+1]\n        args_str = line[idx+1:].strip()\n        ops = ast.literal_eval(ops_str)\n        args = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n    for op, param in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            result.append(None)\n        elif op == \"addWord\":\n            obj.addWord(param[0])\n            result.append(None)\n        elif op == \"search\":\n            result.append(obj.search(param[0]))\n\n    # 以 JSON 格式輸出結果，None 會轉成 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the WordDictionary implementation supporting addWord and search with wildcard '.'.\n\nWe need to show structure with Start, Decision, etc.\n\nWe can design a trie data structure. Steps:\n\n- Define class Node with children map and isEnd flag.\n- WordDictionary: root node.\n- addWord: iterate characters, create nodes as needed, mark end.\n- search: recursive DFS through word string. If char '.' then try all children. else proceed.\n\nWe need to output line by line virtual code with explanation after each line. Use arrow notation. Let's produce something like:\n\nStart // program start\n→ Define class Node // Node structure for trie\n    → Node.children: map of char to Node // store child nodes\n    → Node.isEnd: boolean // marks end of word\n→ Define class WordDictionary // main data structure\n    → WordDictionary.root: Node // root of trie\n    → WordDictionary.WordDictionary() // constructor\n        → Initialize root node\n    → WordDictionary.addWord(word) // method to add word\n        → current ← root\n        → For each char in word\n            → If char not in current.children\n                → Create new Node and add to current.children\n            → current ← current.children[char]\n        → current.isEnd ← true\n    → WordDictionary.search(word) // method to search\n        → Return DFS(root, 0)\n        → Function DFS(node, index)\n            → If index == length of word\n                → Return node.isEnd\n            → ch ← word[index]\n            → If ch == '.'\n                → For each child in node.children\n                    → If DFS(child, index+1) return true\n                → Return false\n            → Else\n                → If ch in node.children\n                    → Return DFS(node.children[ch], index+1)\n                → Return false\nEnd // program end\n\nWe need to follow the exact output format: each line as \"虛擬碼步驟 // 解釋\".\n\nAlso we need to use arrow '→' and 'Yes →', 'No →' for decisions. So need to embed Decision blocks. For loops maybe just \"Decision: for each char\" not needed.\n\nWe can structure as:\n\nStart // 程式開始執行\n→ Define Node // 建立 Trie 節點結構\n    → Node.children ← map // 儲存子節點\n    → Node.isEnd ← false // 標記是否為單字結尾\n→ Define WordDictionary // 主資料結構\n    → WordDictionary.root ← new Node // 初始化根節點\n→ WordDictionary.WordDictionary() // 建構子\n    → WordDictionary.root ← new Node // 建立根節點\n→ WordDictionary.addWord(word) // 新增單字\n    → current ← WordDictionary.root // 從根節點開始\n    → For char in word\n        → Decision: char 是否已存在於 current.children?\n            → Yes → current ← current.children[char] // 直接移動\n            → No  → current.children[char] ← new Node // 新增節點\n                → current ← current.children[char] // 移動到新節點\n    → current.isEnd ← true // 標記單字結束\n→ WordDictionary.search(word) // 查詢單字\n    → Return DFS(WordDictionary.root, 0) // 啟動遞迴搜尋\n    → Function DFS(node, idx) // 內部遞迴\n        → Decision: idx == word.length?\n            → Yes → Return node.isEnd // 若已到字串尾，回傳是否為單字結尾\n            → No\n                → ch ← word[idx] // 取得當前字元\n                → Decision: ch == '.'\n                    → Yes → For child in node.children\n                        → Decision: DFS(child, idx+1) == true?\n                            → Yes → Return true\n                            → No → Continue loop\n                        → End For\n                        → Return false // 所有子節點都不符合\n                    → No\n                        → Decision: ch in node.children?\n                            → Yes → Return DFS(node.children[ch], idx+1)\n                            → No  → Return false\nEnd // 程式結束\n\nThis should satisfy format.\n\nWe need each line with \"虛擬碼步驟\" + \" // 解釋\". Let's write in Chinese.\n\nBe careful about indenting but each line separate.\n\nAlso we might include \"Decision:\" lines for branching.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Node // 建立 Trie 節點結構  \n→ Node.children ← map // 儲存子節點（鍵為字母，值為 Node）  \n→ Node.isEnd ← false // 標記此節點是否為單字結束  \n→ Define WordDictionary // 主資料結構  \n→ WordDictionary.root ← new Node // 初始化根節點  \n→ WordDictionary.WordDictionary() // 建構子  \n→ WordDictionary.root ← new Node // 建立根節點  \n→ WordDictionary.addWord(word) // 新增單字  \n→ current ← WordDictionary.root // 從根節點開始  \n→ For char in word  \n→ Decision: char 是否已存在於 current.children?  \n→ Yes → current ← current.children[char] // 已存在，直接移動到子節點  \n→ No  → current.children[char] ← new Node // 未存在，新增子節點  \n→ No  → current ← current.children[char] // 移動到新建立的子節點  \n→ current.isEnd ← true // 標記此節點為單字結束  \n→ WordDictionary.search(word) // 查詢單字  \n→ Return DFS(WordDictionary.root, 0) // 啟動遞迴搜尋  \n→ Function DFS(node, idx) // 內部遞迴搜尋函式  \n→ Decision: idx == word.length?  \n→ Yes → Return node.isEnd // 到達字串尾，回傳是否為單字結束  \n→ No → ch ← word[idx] // 取得目前字元  \n→ Decision: ch == '.'  \n→ Yes → For child in node.children  \n→ Decision: DFS(child, idx+1) == true?  \n→ Yes → Return true // 有子節點匹配，直接回傳 true  \n→ No  → Continue // 仍繼續搜尋其他子節點  \n→ End For  \n→ Return false // 所有子節點均不匹配  \n→ No  → Decision: ch 在 node.children?  \n→ Yes → Return DFS(node.children[ch], idx+1) // 直接往對應子節點遞迴  \n→ No  → Return false // 無對應子節點，搜尋失敗  \nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,5,5,8,8]'\nGot (Norm):      '[None,4,5,5,8,8]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 5, 5, 8, 8]'\nRaw Got:      '[None, 4, 5, 5, 8, 8]'"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,7,7,7,8]'\nGot (Norm):      '[None,7,7,7,8]'\n--- (Raw) ---\nRaw Expected: '[null, 7, 7, 7, 8]'\nRaw Got:      '[None, 7, 7, 7, 8]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass KthLargest:\n    \"\"\"\n    用最小堆來維護目前流中最大的 k 個數字，堆頂即為第 k 大的數字。\n    \"\"\"\n    def __init__(self, k, nums):\n        \"\"\"\n        初始化 k 以及初始數字流 nums。\n        :param k: int，要求的第 k 大數\n        :param nums: List[int]，初始的分數序列\n        \"\"\"\n        self.k = k\n        self.min_heap = []\n        # 依序將 nums 加入堆，確保堆大小不超過 k\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        \"\"\"\n        將新分數 val 加入流中，並回傳目前的第 k 大分數。\n        :param val: int，新增的分數\n        :return: int，第 k 大的分數\n        \"\"\"\n        heapq.heappush(self.min_heap, val)          # 先把新值放進堆\n        if len(self.min_heap) > self.k:              # 若堆太大，移除最小值\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]                      # 堆頂即為第 k 大\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並包裝成列表方便解析\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    data = '[' + raw_input + ']'\n    commands, arguments = ast.literal_eval(data)\n\n    result = []\n    obj = None\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"KthLargest\":\n            # args 為 [k, nums]\n            obj = KthLargest(args[0], args[1])\n            result.append(None)\n        else:  # \"add\"\n            # args 為 [val]\n            val = args[0]\n            result.append(obj.add(val))\n\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this algorithm: maintain k-th largest in a stream. Standard solution: maintain min-heap of size k. When add val, if heap size < k push val, else if val > heap[0] pop push val. Then return heap[0] as kth largest.\n\nWe need to produce line-by-line pseudocode with explanations after each line. Must include Start, End, Decision:, arrows etc. Use 虛擬碼步驟.\n\nWe need to cover initialization KthLargest(k, nums) and add(val). Also maintain min-heap. We can represent heap operations abstractly: HeapInsert, HeapExtractMin, HeapPeek.\n\nWe'll produce steps for constructor: create empty heap, set k, iterate nums and add each. For add: if heap size < k: insert val, else if val > peek: extract min then insert val. Return peek.\n\nWe must adhere to format: \"虛擬碼步驟 // 解釋\". Each line.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize KthLargest object with k and nums // Set up data members\n→ Step 2: Create empty min-heap H // heap holds up to k largest elements\n→ Step 3: For each score s in nums: // process initial stream\n→ Decision: If size(H) < k? // heap not full yet\n  Yes → Step 4: HeapInsert(H, s) // add element\n  No → Decision: If s > HeapPeek(H)? // new element may belong to top k\n    Yes → Step 5: HeapExtractMin(H) // remove smallest of top k"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    \"\"\"\n    找出所有重複檔案的完整路徑，返回一個列表，每個子列表包含相同內容的檔案路徑。\n    \"\"\"\n    content_map = defaultdict(list)\n\n    for path_info in paths:\n        # 以空格切分，第一個是目錄路徑\n        parts = path_info.split()\n        if not parts:\n            continue\n        root = parts[0]\n        # 之後的每一項是 file_name(content)\n        for file_info in parts[1:]:\n            # 以 '(' 分割得到檔名與內容\n            name, content_with_paren = file_info.split('(', 1)\n            content = content_with_paren.rstrip(')')\n            full_path = f\"{root}/{name}\"\n            content_map[content].append(full_path)\n\n    # 只保留重複的內容（至少兩個檔案）\n    return [paths for paths in content_map.values() if len(paths) > 1]\n\ndef parse_input(raw_input: str):\n    \"\"\"\n    從 stdin 讀取的字串轉成 paths 列表。\n    支援兩種格式：\n        1. paths = [\"root/a 1.txt(abcd)\", ...]\n        2. [\"root/a 1.txt(abcd)\", ...]\n    \"\"\"\n    raw_input = raw_input.strip()\n    if raw_input.startswith(\"paths\"):\n        # 去掉前面的 'paths ='\n        raw_input = raw_input.split('=', 1)[1].strip()\n    # 使用 ast.literal_eval 以安全方式解析 Python 列表字面量\n    try:\n        return ast.literal_eval(raw_input)\n    except Exception as e:\n        # 若解析失敗，回傳空列表\n        return []\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_data = sys.stdin.read()\n    # 轉成列表\n    paths_list = parse_input(raw_data)\n    # 取得重複檔案路徑組別\n    duplicates = find_duplicate(paths_list)\n    # 輸出結果，使用 Python 列表字面量格式\n    print(duplicates)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find duplicate file paths. Use pseudocode. Must be line-by-line with explanation. Use Start, End, Decision: etc. Provide algorithm.\n\nWe need to parse each directory string, extract path and file entries with content. For each file, compute content hash or store content string in map content->list of file paths. After processing all, output groups with size>=2. Use structure: Start, then iterate over list, parse, then for each file, add path to map, then after loop, iterate map, collect groups size>=2, add to result list, End.\n\nWe'll format as required: each line \"虛擬碼步驟 // 解釋\". Use arrow symbols. Provide decisions. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的字典 ContentMap 以儲存內容 → 與其對應的檔案路徑清單\n→ Step 2: 建立空的列表 Result 以儲存重複檔案組別\n→ Step 3: 對於輸入列表 Paths 中的每個 DirectoryInfo 進行迭代\n    → Decision: 取得 DirectoryInfo 中的目錄路徑與檔案清單 // 解析字串\n        Yes → Step 3.1: 用空格切分 DirectoryInfo，第一項為 FullPath\n        Yes → Step 3.2: 取剩餘部分為 FileEntries\n    → Decision: 迭代每個 FileEntry 在 FileEntries 中\n        Yes → Step 3.2.1: 取檔名與內容，檔名為第一個括號前的文字\n        Yes → Step 3.2.2: 取內容為第一個括號內的文字\n        Yes → Step 3.2.3: 組成完整路徑 FullFilePath = FullPath + \"/\" + FileName\n        Yes → Step 3.2.4: 若 ContentMap 中不存在 Content，則新增空清單\n        Yes → Step 3.2.5: 把 FullFilePath 加入 ContentMap[Content] 的清單\n→ Step 4: 迭代 ContentMap 中的每個 (Content, PathList)\n    → Decision: PathList 的長度是否大於等於 2 // 只保留重複檔案\n        Yes → Step 4.1: 把 PathList 加入 Result\n→ End // 程式執行結束，Result 為重複檔案組別的列表"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[9]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[9]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[3,9]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[3, 9]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[8,9,5]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[8, 9, 5]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef rand7():\n    # Placeholder implementation. In the real environment, this function will be provided.\n    import random\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        while True:\n            a = rand7()\n            b = rand7()\n            num = (a - 1) * 7 + b  # 1 to 49\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        return\n    m = re.search(r'(\\d+)', data)\n    n = int(m.group(1)) if m else 0\n    sol = Solution()\n    result = [sol.rand10() for _ in range(n)]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating rand10() from rand7().\n\nClassic solution: use two rand7() calls to generate 49 outcomes. Map 1-40 to 1-10 via modulo, reject 41-49. Or use rejection sampling with 49 outcomes.\n\nWe'll produce virtual code lines. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe must use arrow syntax. Example: Start, → Step etc. Use Decision.\n\nAlso must ensure we only call rand7().\n\nLet's craft algorithm:\n\nStart\n→ Step 1: repeat\n    → Step 2: a ← rand7() // first random number 1-7\n    → Step 3: b ← rand7() // second random number 1-7\n    → Step 4: num ← (a-1)*7 + b // produce number 1-49\n    → Decision: if num <= 40?\n        Yes → Step 5: return ((num-1) mod 10) + 1 // map to 1-10\n        No  → Step 6: repeat // discard and redo\nEnd\n\nWe need to show loop as repetition. Use \"Repeat ... until\" or \"While\". Use Decision.\n\nWe'll produce pseudo-code lines like:\n\nStart // 程式開始執行\n→ Step 1: repeat // 進入重複區塊，直到產生有效數值\n    → Step 2: a ← rand7() // 取得第一個隨機數，範圍 1~7\n    → Step 3: b ← rand7() // 取得第二個隨機數，範圍 1~7\n    → Step 4: num ← (a-1)*7 + b // 組合成 1~49 的數值\n    → Decision: num ≤ 40? // 檢查是否落在可接受範圍\n        Yes → Step 5: return ((num-1) mod 10) + 1 // 轉成 1~10 的結果\n        No  → Step 6: // 重新迭代\n→ End // 程式結束\n\nBut we need arrow formatting consistent. Use \"→\" at each line.\n\nAlso include \"End\" outside loop? In pseudo, after return we exit function. End outside maybe.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: repeat // 進入重複區塊，持續嘗試直到得到合法值  \n  → Step 2: a ← rand7() // 取得第一個隨機數，範圍 1~7  \n  → Step 3: b ← rand7() // 取得第二個隨機數，範圍 1~7  \n  → Step 4: num ← (a-1)*7 + b // 組合成 1~49 的整數  \n  → Decision: num ≤ 40? // 檢查 num 是否在可映射範圍內  \n   Yes → Step 5: return ((num-1) mod 10) + 1 // 轉為 1~10 的隨機數，並返回  \n   No  → Step 6: // 數值超過 40，重複循環  \n→ End // 程式執行結束（實際上已在 Step 5 中返回）"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0]-b[0])**2 + (a[1]-b[1])**2\n        \n        points = [p1, p2, p3, p4]\n        dists = []\n        \n        for i in range(4):\n            for j in range(i+1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n        \n        dists.sort()\n        \n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) != 8:\n        print(\"false\")\n    else:\n        p1 = [numbers[0], numbers[1]]\n        p2 = [numbers[2], numbers[3]]\n        p3 = [numbers[4], numbers[5]]\n        p4 = [numbers[6], numbers[7]]\n        sol = Solution()\n        print(\"true\" if sol.validSquare(p1, p2, p3, p4) else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, using Start, End, Decision, etc., no actual code. Must explain each step. The algorithm: compute all pairwise distances squared, get 6 distances: 4 sides and 2 diagonals. Check that there are only two distinct distances, smaller occurs 4 times, larger occurs 2 times, and larger = 2*smaller. Also check that smaller>0. Since input not ordered, we just treat any ordering. So virtual code:\n\nStart\n→ Step 1: Read points p1, p2, p3, p4 // get coordinates\n→ Step 2: Initialize empty list distances // store squared distances\n→ Step 3: For each unordered pair of points among four: compute squared distance, append to distances // compute all 6 pairwise distances\n→ Decision: Are there exactly 6 distances? // yes always\n→ Step 4: Count occurrences of each distance value // group by distance\n→ Decision: Are there exactly 2 distinct distances? // otherwise not square\n→ Step 5: Let d_small be the smaller distance, d_large be the larger distance\n→ Decision: Is d_small > 0? // sides must have positive length\n→ Decision: Does d_small occur 4 times and d_large occur 2 times? // side count\n→ Decision: Is d_large == 2 * d_small? // diagonal property of square\n→ Yes → Step 6: Return true // valid square\n→ No → Step 7: Return false // invalid\nEnd\n\nBut need to use Decision with Yes/No arrows. Ensure each line has \"虛擬碼步驟\" and explanation. Use arrows for flows. Should maintain indentation for nested decisions. Use \"Decision:\" lines with Yes→ and No→. Also maybe we need to show nested decisions. Use spaces accordingly.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取四個點 p1, p2, p3, p4 // 取得所有座標  \n→ Step 2: 初始化空列表 distances // 用來存放六條距離的平方值  \n→ Step 3: 對於四個點的每一對不重複組合  \n  →  計算該對點的距離平方並加入 distances // 產生所有 6 條距離  \n→ Decision: distances 是否包含 6 個值？ // 檢查計算是否正確  \n  Yes → // 繼續  \n  No  → Step 4: 回傳 false // 失敗，距離不完整  \n→ Step 4: 將 distances 按值分組，統計每個距離出現次數 // 得到兩種距離的計數  \n→ Decision: 只剩下 2 種不同距離？ // 正方形只會有兩種距離  \n  Yes → // 繼續  \n  No  → Step 5: 回傳 false // 不是正方形  \n→ Step 5: 設定 d_small 為較小的距離，d_large 為較大的距離  \n→ Decision: d_small > 0？ // 邊長必須為正  \n  Yes → // 繼續  \n  No  → Step 6: 回傳 false // 邊長為零，無效  \n→ Decision: d_small 出現 4 次且 d_large 出現 2 次？ // 邊和對角線數量檢查  \n  Yes → // 繼續  \n  No  → Step 7: 回傳 false // 次數不符  \n→ Decision: d_large == 2 * d_small？ // 正方形對角線長度平方等於兩倍邊長平方  \n  Yes → Step 8: 回傳 true // 合乎正方形條件  \n  No  → Step 9: 回傳 false // 對角線不符合正方形性質  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpm6uhnsun.py\", line 49, in <module>\n    price, special, needs = parse_input(raw_data)\n                            ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpm6uhnsun.py\", line 40, in parse_input\n    special = ast.literal_eval(lists[1])\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkx5ja6up.py\", line 49, in <module>\n    price, special, needs = parse_input(raw_data)\n                            ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkx5ja6up.py\", line 40, in parse_input\n    special = ast.literal_eval(lists[1])\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # cost without any special offer\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析類似於\n    price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n    這樣的輸入，返回(price, special, needs)。\n    \"\"\"\n    # 找出所有方括號內的子串\n    lists = re.findall(r'\\[.*?\\]', data, flags=re.S)\n    if len(lists) < 3:\n        raise ValueError(\"輸入格式不正確\")\n    price = ast.literal_eval(lists[0])\n    special = ast.literal_eval(lists[1])\n    needs = ast.literal_eval(lists[2])\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_data = sys.stdin.read().strip()\n    if not raw_data:\n        sys.exit()\n    price, special, needs = parse_input(raw_data)\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for solving Leetcode 638: Shopping Offers. Provide steps: start, read input, preprocess offers, DFS with memoization to minimize price. Use recursion, check if offer can be applied. Use backtracking. Also consider direct purchase cost. Use dynamic programming. We'll produce lines like \"Start // 程式開始執行\".\n\nWe'll produce explanation comments in Chinese.\n\nWe need to output step by step, each line as \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Decision: lines.\n\nWe need to produce a full algorithm but not actual code. Just pseudo. Provide steps.\n\nLet's craft algorithm:\n\nStart\n→ Initialize memo map\n→ Define function dfs(remaining_needs) // compute min cost for given needs\n    → Convert remaining_needs to key\n    → If key in memo, return memo[key]\n    → Compute cost without offers: sum(remaining_needs[i] * price[i])\n    → For each offer in special:\n        → Check if offer can be applied: for all i, offer[i] <= remaining_needs[i]\n        → If yes:\n            → new_needs = remaining_needs - offer[i] for each i\n            → cost = dfs(new_needs) + offer[last]\n            → min_cost = min(min_cost, cost)\n    → memo[key] = min_cost\n    → Return min_cost\n→ Call dfs(needs) // initial need\n→ Output result\n\nAlso include pruning? Not needed.\n\nWe can also add decision lines: check if offer applicable.\n\nLet's produce virtual code lines accordingly. Use \"→\" for steps. Use Decision lines: \"Decision: 是否可使用優惠?\" etc.\n\nAlso need to output in Chinese.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Define price, needs, special // 讀取輸入資料\n→ Initialize memo map // 用於快取已計算的需求狀態\n\n→ Define function dfs(cur_needs) // 計算在目前需求下的最低成本\n    → Decision: 如果 cur_needs 為空? // 檢查是否已無需購買\n        Yes → Return 0 // 無需花費\n    → Key ← cur_needs 轉成字串 // 用於 memo\n    → Decision: Key 是否已存在於 memo? // 快取判斷\n        Yes → Return memo[Key] // 直接回傳已計算結果\n    → cur_cost ← sum(cur_needs[i] * price[i]) // 先算不使用優惠的總價\n    → Decision: 目前 cur_cost 是否為最佳? // 以此作初始最小值\n        Yes → min_cost ← cur_cost // 設為目前最小\n    → For 每個 offer in special:\n        → Decision: 是否可以應用此 offer? // 檢查每種商品數量\n            Yes → new_needs ← cur_needs - offer_counts // 減去優惠中的商品數量\n            → offer_cost ← dfs(new_needs) + offer_price // Recursion + 優惠價\n            → Decision: offer_cost 是否 < min_cost? // 比較是否更低\n                Yes → min_cost ← offer_cost // 更新最小\n    → memo[Key] ← min_cost // 針對此需求快取結果\n    → Return min_cost\n\n→ result ← dfs(needs) // 從原始需求開始計算\n→ Output result // 回傳最低價格\n\nWe need to include arrow lines properly. Each line starting with \"→\". But for nested lines we might indent. In example, they indent nested steps. We'll maintain indentation via spaces.\n\nAlso need Decision lines with Yes → and No →.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define price, needs, special // 讀取輸入資料  \n→ Initialize memo map // 用於快取已計算的需求狀態  \n\n→ Define function dfs(cur_needs) // 計算在目前需求下的最低成本  \n  Decision: cur_needs 為空? // 檢查是否已無需購買  \n   Yes → Return 0 // 無需花費  \n  Key ← cur_needs 轉成字串 // 用於 memo  \n  Decision: Key 是否已存在於 memo? // 快取判斷  \n   Yes → Return memo[Key] // 直接回傳已計算結果  \n  cur_cost ← sum(cur_needs[i] * price[i]) // 先算不使用優惠的總價  \n  min_cost ← cur_cost // 設為目前最小  \n  For 每個 offer in special: // 嘗試所有優惠  \n   Decision: 是否可以應用此 offer? // 檢查每種商品數量  \n    Yes → new_needs ← cur_needs - offer_counts // 減去優惠中的商品數量  \n     offer_cost ← dfs(new_needs) + offer_price // Recursion + 優惠價  \n     Decision: offer_cost 是否 < min_cost? // 比較是否更低  \n      Yes → min_cost ← offer_cost // 更新最小  \n  memo[Key] ← min_cost // 針對此需求快取結果  \n  Return min_cost  \n\n→ result ← dfs(needs) // 從原始需求開始計算  \n→ Output result // 回傳最低價格"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4pl0iysv.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmp4pl0iysv.py\", line 47, in main\n    equations, values, queries = parse_input(raw_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4pl0iysv.py\", line 38, in parse_input\n    equations = ast.literal_eval(eq_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpenuwuuf6.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpenuwuuf6.py\", line 47, in main\n    equations, values, queries = parse_input(raw_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpenuwuuf6.py\", line 38, in parse_input\n    equations = ast.literal_eval(eq_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc_gy1gxi.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpc_gy1gxi.py\", line 47, in main\n    equations, values, queries = parse_input(raw_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc_gy1gxi.py\", line 38, in parse_input\n    equations = ast.literal_eval(eq_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        result = []\n        for u, v in queries:\n            result.append(dfs(u, v, set()))\n        return result\n\ndef parse_input(data: str):\n    \"\"\"Parse the input format shown in the examples.\"\"\"\n    eq_match = re.search(r'equations\\s*=\\s*(\\[.*?\\])', data, re.S)\n    val_match = re.search(r'values\\s*=\\s*(\\[.*?\\])', data, re.S)\n    qu_match = re.search(r'queries\\s*=\\s*(\\[.*?\\])', data, re.S)\n    if not (eq_match and val_match and qu_match):\n        raise ValueError(\"Input format is incorrect.\")\n    equations = ast.literal_eval(eq_match.group(1))\n    values = ast.literal_eval(val_match.group(1))\n    queries = ast.literal_eval(qu_match.group(1))\n    return equations, values, queries\n\ndef main():\n    raw_data = sys.stdin.read()\n    if not raw_data.strip():\n        return\n    equations, values, queries = parse_input(raw_data)\n    sol = Solution()\n    ans = sol.calcEquation(equations, values, queries)\n    # Format output as list of 5‑decimal numbers\n    formatted = '[' + ','.join(f\"{x:.5f}\" for x in ans) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: evaluate division queries using equations graph. Use union find or DFS. Provide line by line steps with explanation. Use Start, End, Decision. We'll design algorithm:\n\n- Build graph adjacency: variable -> list of (neighbor, value)\n- For each query: if either variable not in graph: answer -1.0; else DFS to find ratio.\n\nSo virtual code steps:\n\nStart\n→ Step 1: 初始化圖 graph 為空字典 // 建立變數到鄰接列表\n→ Decision: 是否存在 equations? // 如果無\n    Yes → Step 2: For each equation in equations, add edges // 兩向連接\n    No  → Step 3: // 直接結束? but still handle queries maybe -1.0.\n\nBetter to just always loop.\n\nSimplify: Step 1: Build graph\n\nThen Step 2: 初始化答案列表 ans\n\nThen Step 3: For每個 query in queries\n\nStep 4: If query variables not in graph -> ans append -1.0\n\nElse -> call DFS to find ratio\n\nDFS algorithm: Stack of (node, current_product). visited set. While stack: pop node, prod; if node==target: return prod; else push neighbors not visited with prod*edge_value\n\nIf not found return -1.0\n\nAdd to ans.\n\nAfter loop, End // return ans\n\nWe need to include decision branches: e.g., in DFS, if found else.\n\nLet's produce with virtual code lines. Each line: \"虛擬碼步驟 // 解釋\"\n\nLet's generate.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 graph 為空字典 // 建立變數到鄰接列表\n→ Step 2: For each (A, B) in equations:\n    → Step 2.1: graph[A].append((B, value)) // 連接 A → B，值為 Ai/Bi\n    → Step 2.2: graph[B].append((A, 1/value)) // 連接 B → A，值為 Bi/Ai\n→ Step 3: 初始化答案列表 ans 為空 // 用於存儲所有查詢結果\n→ Step 4: For每個 (C, D) 在 queries:\n    → Decision: 如果 C 或 D 不在 graph?\n        Yes → Step 4.1: ans.append(-1.0) // 未定義的變數，無法計算\n        No  → Step 4.2: Step 4.3: 執行 DFS 以尋找 C → D 的比值\n            → Step 4.3.1: 初始化 stack 為 [(C, 1.0)] // (節點, 目前乘積)\n            → Step 4.3.2: 初始化 visited 為空集合\n            → Decision: 迴圈是否有元素?\n                Yes → Step 4.3.3: node, prod = stack.pop()\n                No  → Step 4.3.4: ans.append(-1.0) // 找不到路徑\n            → Step 4.3.5: Decision: node == D?\n                Yes → Step 4.3.6: ans.append(prod) // 找到目標，存入結果\n                No  → Step 4.3.7: visited.add(node) // 標記已訪問\n                → Step 4.3.8: For每個 (nbr, val) 在 graph[node]:\n                    → Decision: nbr 是否已訪問?\n                        Yes → Skip // 已走過的節點不再探訪\n                        No  → Step 4.3.9: stack.append((nbr, prod * val)) // 推進下一節點\n                    → Back to Step 4.3.5 // 重新判斷當前節點是否為目標\n→ End // 程式執行結束，返回 ans\n```"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      '[null,null,2,2,false]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      '[null, null, 2, 2, false]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"LIFO stack implemented using two queues.\"\"\"\n\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"Push element onto the stack.\"\"\"\n        self.q1.append(x)\n\n    def pop(self):\n        \"\"\"Remove and return the top element of the stack.\"\"\"\n        if not self.q1:\n            return None\n        # Move all but the last element to q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top = self.q1.popleft()\n        # Swap queues to restore state\n        self.q1, self.q2 = self.q2, self.q1\n        return top\n\n    def top(self):\n        \"\"\"Return the top element without removing it.\"\"\"\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top = self.q1.popleft()\n        # Put the top element back into q2\n        self.q2.append(top)\n        # Swap queues back\n        self.q1, self.q2 = self.q2, self.q1\n        return top\n\n    def empty(self) -> bool:\n        \"\"\"Check whether the stack is empty.\"\"\"\n        return not self.q1\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the two lists from the input string\n    start_cmd = data.find('[')\n    end_cmd = data.find(']', start_cmd)\n    commands = ast.literal_eval(data[start_cmd:end_cmd + 1])\n\n    start_args = data.find('[', end_cmd + 1)\n    end_args = data.rfind(']')\n    args = ast.literal_eval(data[start_args:end_args + 1])\n\n    stack = MyStack()\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == 'push':\n            stack.push(arg[0])\n            results.append(None)\n        elif cmd == 'pop':\n            results.append(stack.pop())\n        elif cmd == 'top':\n            results.append(stack.top())\n        elif cmd == 'empty':\n            results.append(stack.empty())\n\n    # Format output: None -> null, bool -> true/false, others as numbers\n    formatted = []\n    for v in results:\n        if v is None:\n            formatted.append('null')\n        elif isinstance(v, bool):\n            formatted.append('true' if v else 'false')\n        else:\n            formatted.append(str(v))\n    print('[' + ', '.join(formatted) + ']')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for a MyStack class using two queues. Each line should have virtual code step and comment. Use arrows and decision structure. Let's design algorithm: Use two queues q1, q2. For push, enqueue into q1. For pop/top, move all elements except last from q1 to q2, keep last, then swap q1 and q2. That ensures LIFO. Provide operations empty check if q1 empty. We'll produce steps.\n\nWe'll output as lines starting with Start, then steps. Let's produce pseudo algorithm for class and methods. We'll show operations: initialization, push, pop, top, empty.\n\nMake sure to use queue operations: enqueue (push back), dequeue (pop front), peek(front), size, isEmpty.\n\nWe'll write pseudo: Start, initialize two queues.\n\nFor push(x): enqueue into queue1.\n\nFor pop(): if empty, return; else while size >1, dequeue from q1 to q2; last=dequeue q1; swap q1 & q2; return last.\n\nFor top(): similar but after retrieving last, re-enqueue last into q2? Actually for top, after moving all except last to q2, we need to keep last in q2 to preserve stack. So after retrieving last, enqueue it into q2. Then swap. Return last.\n\nFor empty(): return q1.isEmpty() && q2.isEmpty() maybe just q1.isEmpty().\n\nBut if we maintain all elements in q1 after each operation? After pop/top we swapped, so all elements in q1 again. So just check q1.isEmpty().\n\nLet's produce step-by-step.\n\nWe'll use \"Decision:\" for empty check, \"Yes →\" etc.\n\nAlso need to show usage of two queues.\n\nWe'll produce final virtual code with comments.\n\nLet's create the steps:\n\nStart\n→ Initialize Queue1, Queue2 // Two queues to simulate stack\n→ Define push(x): enqueue into Queue1\n→ Define pop(): \n    → Decision: if Queue1.isEmpty()? // empty stack\n        Yes → return null // no element\n        No  → \n            → While Queue1.size() > 1: // move all but last\n                → temp = Queue1.dequeue() // remove front\n                → Queue2.enqueue(temp) // add to back of q2\n            → last = Queue1.dequeue() // pop last\n            → Swap Queue1 and Queue2 // now q1 holds remaining elements\n            → return last\n→ Define top(): similar to pop but keep last in q2\n    → Decision: if Queue1.isEmpty()? \n        Yes → return null\n        No  →\n            → While Queue1.size() > 1:\n                → temp = Queue1.dequeue()\n                → Queue2.enqueue(temp)\n            → last = Queue1.dequeue()\n            → Queue2.enqueue(last) // put last back to maintain stack\n            → Swap Queue1 and Queue2\n            → return last\n→ Define empty(): return Queue1.isEmpty() // true if stack empty\nEnd\n\nBut we need each line as \"虛擬碼步驟 // 解釋\". So each step on separate line. Use arrows and decisions.\n\nLet's produce each step. We'll indent decision branches as separate lines.\n\nWe must avoid actual code; just pseudo.\n\nWe'll use \"→\" to indicate flow.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize Queue1, Queue2 // 建立兩個空隊列以模擬堆疊  \n\n// push 操作  \n→ Define push(x) // 定義 push 方法  \n→    Queue1.enqueue(x) // 把新元素加入 Queue1 的尾部  \n\n// pop 操作  \n→ Define pop() // 定義 pop 方法  \n→    Decision: if Queue1.isEmpty()? // 檢查堆疊是否為空  \n→        Yes → return null // 若空，回傳 null  \n→        No  →  \n→            While Queue1.size() > 1: // 移動除最後一個外的所有元素  \n→                → temp = Queue1.dequeue() // 從前端取出  \n→                → Queue2.enqueue(temp) // 加入 Queue2 的尾部  \n→            → last = Queue1.dequeue() // 取出最後一個元素  \n→            → Swap Queue1 and Queue2 // 交換兩個隊列，保持 Queue1 為主  \n→            → return last // 回傳被彈出的元素  \n\n// top 操作  \n→ Define top() // 定義 top 方法  \n→    Decision: if Queue1.isEmpty()? // 檢查堆疊是否為空  \n→        Yes → return null // 若空，回傳 null  \n→        No  →  \n→            While Queue1.size() > 1: // 移動除最後一個外的所有元素  \n→                → temp = Queue1.dequeue() // 從前端取出  \n→                → Queue2.enqueue(temp) // 加入 Queue2 的尾部  \n→            → last = Queue1.dequeue() // 取出最後一個元素  \n→            → Queue2.enqueue(last) // 再將它放回 Queue2，保留堆疊內容  \n→            → Swap Queue1 and Queue2 // 交換，恢復 Queue1 為主  \n→            → return last // 回傳堆疊頂部元素  \n\n// empty 操作  \n→ Define empty() // 定義 empty 方法  \n→    → return Queue1.isEmpty() // 若 Queue1 為空，堆疊為空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            px, py = find(x), find(y)\n            if px != py:\n                parent[py] = px\n\n        email_to_name = {}\n        for acc in accounts:\n            if not acc:\n                continue\n            name = acc[0]\n            if len(acc) < 2:\n                continue\n            first_email = acc[1]\n            for email in acc[1:]:\n                union(first_email, email)\n                email_to_name[email] = name\n\n        groups = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            groups[root].append(email)\n\n        result = []\n        for root, emails in groups.items():\n            emails.sort()\n            result.append([email_to_name[root]] + emails)\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Accept either \"accounts = [...]\" or just \"[...]\"\n    if data.startswith(\"accounts\"):\n        try:\n            _, expr = data.split(\"=\", 1)\n            accounts = ast.literal_eval(expr.strip())\n        except Exception:\n            accounts = ast.literal_eval(data)\n    else:\n        accounts = ast.literal_eval(data)\n\n    sol = Solution()\n    merged = sol.accountsMerge(accounts)\n    print(merged)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanations. We need to solve merging accounts problem. Steps: Build email to name mapping and DSU. For each account, union emails. Then group by root and build output. Use DSU operations. Provide virtual code.\n\nEnsure we output each line with \"→\" arrow. Use Start, End. Use Decision statements.\n\nLet's craft.\n\nStart\n→ Step 1: Initialize DSU data structures and email→name map // 建立 DSU 與 email 到姓名的映射\n→ Decision: For each account in accounts? // 逐筆處理\n    → Step 2: name ← account[0] // 取得姓名\n    → Decision: If account has emails? // 確認有 email\n        → Step 3: firstEmail ← account[1] // 第一封 email\n        → Step 4: Add mapping: emailName[firstEmail] = name // 將第一封 email 與姓名對應\n        → Decision: For each email e in account[2:]:\n            → Step 5: Add mapping: emailName[e] = name // 將其他 email 與姓名對應\n            → Step 6: If e not in DSU parent:\n                → Step 7: parent[e] = e // 初始化 DSU 節點\n            → Step 8: Union(firstEmail, e) // 合併第一封與其餘 email\n        → Step 9: Ensure firstEmail in DSU parent\n        → Decision: Else // no emails\n            → Step 10: // skip\n→ Step 11: Initialize groups map root→list of emails\n→ Decision: For each email e in emailName keys:\n    → Step 12: root ← Find(e) // 取得 email 的代表節點\n    → Step 13: groups[root].append(e) // 將 email 加入對應組\n→ Step 14: Prepare result list\n→ Decision: For each root, emails in groups:\n    → Step 15: Sort emails // 依字典序排序\n    → Step 16: name ← emailName[emails[0]] // 取任一 email 的姓名\n    → Step 17: result.append([name] + emails) // 組合姓名與 emails\n→ End // 完成合併\n\nWe need to include arrow formatting properly. For Decision branches we indent. Use Yes → No → but maybe we don't need Yes/No since it's just iteration. But requirement uses Decision. Use Decision: If ...? ; Yes → ; No →.\n\nWe may incorporate loops as Decision: For each account? But loops aren't decisions. But we can simulate with Decision: True →. But simpler: we can use Decision: If accounts not empty? Use loop arrow maybe.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Initialize DSU parent map, emailName map, and group map // 建立 DSU、email 到姓名的映射及組別儲存\n→ Decision: If accounts is not empty? // 檢查輸入是否有資料\n    Yes → \n        → Step 2: For each account in accounts // 逐筆處理每個帳號\n            → Step 3: name ← account[0] // 取得姓名\n            → Decision: If account has emails? // 是否包含 email\n                Yes →\n                    → Step 4: firstEmail ← account[1] // 取得第一封 email\n                    → Step 5: emailName[firstEmail] ← name // 將第一封 email 與姓名對應\n                    → Step 6: If firstEmail not in parent map\n                        Yes → Step 7: parent[firstEmail] ← firstEmail // 初始化 DSU 節點\n                    → Decision: For each email e in account[2:]\n                        Yes →\n                            → Step 8: emailName[e] ← name // 將其他 email 與姓名對應\n                            → Step 9: If e not in parent map\n                                Yes → Step 10: parent[e] ← e // 初始化 DSU 節點\n                            → Step 11: Union(firstEmail, e) // 合併第一封 email 與其餘 email\n                No → // 若帳號沒有 email，跳過\n            → Step 12: // 目前帳號處理完畢\n    No → // accounts 為空，直接結束\n→ Step 13: For each email e in emailName keys // 迭代所有 email\n    → Step 14: root ← Find(e) // 找到該 email 的代表節點\n    → Step 15: groups[root].append(e) // 將 email 加入對應組別\n→ Step 16: result ← [] // 初始化結果清單\n→ Decision: For each root, emails in groups\n    Yes →\n        → Step 17: Sort(emails) // 將 email 排序\n        → Step 18: name ← emailName[emails[0]] // 取任一 email 的姓名\n        → Step 19: result.append([name] + emails) // 組合姓名與排好序的 email\n→ End // 程式執行結束\n```\n\n此虛擬碼依循「Start → Step → Decision → Yes/No → End」結構，逐行說明如何使用 DSU 合併帳號並輸出已排序的結果。"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef parse_input(raw):\n    \"\"\"\n    解析像 'beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\"]' 這樣的輸入。\n    \"\"\"\n    assignments = {}\n    parts = raw.split(',')\n    for part in parts:\n        if '=' in part:\n            key, val = part.split('=', 1)\n            key = key.strip()\n            val = val.strip()\n            try:\n                assignments[key] = ast.literal_eval(val)\n            except Exception:\n                assignments[key] = val\n    return assignments.get('beginWord'), assignments.get('endWord'), assignments.get('wordList')\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])\n        sys.exit(0)\n    beginWord, endWord, wordList = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code that outlines algorithm for word ladder II: find all shortest transformation sequences. Use BFS to build levels and backtracking. Provide pseudocode lines with explanations. Use arrows etc. Must be step by step.\n\nLet's design:\n\nStart\n→ Input: beginWord, endWord, wordList\n→ Convert wordList to set for O(1)\n→ If endWord not in set: return empty list\n→ BFS queue: each element is word\n→ distance map: word -> level\n→ parents map: word -> set of predecessors\n→ Initialize queue with beginWord, distance[beginWord]=0\n→ While queue not empty:\n    → current = pop\n    → For each i in 0..len-1:\n        → For each char a-z:\n            → if newWord != current and newWord in set:\n                → if newWord not in distance:\n                    → distance[newWord] = distance[current]+1\n                    → enqueue newWord\n                → if distance[newWord] == distance[current]+1:\n                    → add current to parents[newWord]\n    → If current == endWord: break after finishing level? Actually break after level ends. We can stop when current level > distance[endWord].\n→ After BFS, if endWord not in parents: return empty list\n→ Backtrack from endWord to beginWord via parents to build all paths\n→ Use DFS stack: path list\n→ Return list of paths\n\nLet's write virtual code lines. Use arrow notation.\n\nLet's produce each step with explanation.\n\nWe must ensure each line is separate, using Start, End, Decision, etc.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Input: beginWord, endWord, wordList // 取得輸入資料\n→ wordSet ← Convert wordList to Set // 快速查找\n→ Decision: endWord ∈ wordSet? // 檢查終點是否可達\n    Yes → Continue\n    No  → End // 若終點不在字典，直接返回空結果\n→ wordDist ← Empty Map // 儲存每個單詞的 BFS 距離\n→ wordParents ← Empty Map // 儲存每個單詞的前驅\n→ queue ← New Queue\n→ Enqueue(queue, beginWord) // 開始於 beginWord\n→ wordDist[beginWord] ← 0 // beginWord 的距離為 0\n→ Decision: beginWord == endWord? // 若起點即終點\n    Yes → Return [[beginWord]] // 直接回傳單一序列\n    No  → Continue\n→ Decision: length(beginWord) == length(endWord)? // 必須長度相同\n    Yes → Continue\n    No  → End // 長度不同則無法轉換，返回空結果\n→ While queue not empty: // BFS 主循環\n    → current ← Dequeue(queue) // 取得目前單詞\n    → currentLevel ← wordDist[current] // 目前層級\n    → Decision: current == endWord? // 找到終點\n        Yes → // 仍需處理同層其他節點以確保所有最短路徑\n        No  → Continue\n    → For i from 0 to length(current)-1: // 逐字元位置\n        → For ch from 'a' to 'z': // 逐個替換字母\n            → newWord ← Replace(current, i, ch) // 生成新單詞\n            → Decision: newWord ∈ wordSet? // 是否在字典\n                Yes →\n                    → Decision: newWord ∉ wordDist? // 第一次遇到\n                        Yes →\n                            → wordDist[newWord] ← currentLevel + 1 // 記錄距離\n                            → Enqueue(queue, newWord) // 加入隊列\n                        No  →\n                            → Decision: wordDist[newWord] == currentLevel + 1? // 是否屬於同層\n                                Yes →\n                                    → // 新單詞已被發現，加入前驅\n                                    → Append(wordParents[newWord], current)\n                                No  → // 跳過較遠路徑\n                No  → // 新單詞不在字典，忽略\n→ Decision: endWord ∈ wordParents? // 是否找到至少一條路徑\n    Yes → Continue\n    No  → End // 沒有最短路徑，返回空列表\n→ result ← Empty List // 儲存所有最短序列\n→ path ← [endWord] // 從終點開始回溯\n→ DFS(current = endWord): // 從 endWord 回溯至 beginWord\n    → If current == beginWord:\n        → Reverse(path) // 逆序為 beginWord -> … -> endWord\n        → Append(result, Copy(path)) // 加入結果\n        → Return\n    → For each parent in wordParents[current]: // 遍歷前驅\n        → Prepend(path, parent) // 在前面加入 parent\n        → DFS(parent) // 進一步回溯\n        → Remove first element from path // 回溯，移除已使用的 parent\n→ DFS(endWord) // 開始回溯\n→ Return result // 所有最短轉換序列\nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true]'\nGot (Norm):      '[None,True,False,True]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true]'\nRaw Got:      '[None, True, False, True]'"
        }
      ],
      "generated_code": "import sys\n\nclass MyCalendar:\n    def __init__(self):\n        self.bookings = []\n\n    def book(self, start, end):\n        for s, e in self.bookings:\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 去掉外層單引號（若存在）\n    if data[0] in ('\"', \"'\") and data[-1] == data[0]:\n        data = data[1:-1].strip()\n\n    # 將兩個列表包成元組後 eval 解析\n    try:\n        ops, args = eval(\"(\" + data + \")\")\n    except Exception:\n        # 若解析失敗，直接終止\n        sys.exit()\n\n    results = []\n    cal = None\n    for idx, op in enumerate(ops):\n        if op == \"MyCalendar\":\n            cal = MyCalendar()\n            results.append(None)\n        elif op == \"book\" and cal is not None:\n            # args[idx] 可能是 [] 或 [start, end]\n            res = cal.book(*args[idx])\n            results.append(res)\n        else:\n            # 無效操作或未初始化\n            results.append(None)\n\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for a MyCalendar class with booking. The typical solution: store intervals in balanced BST or list; check for overlap. Provide pseudocode line by line.\n\nWe need to produce step-by-step. For MyCalendar constructor, initialize empty list.\n\nFor book: iterate through existing intervals to check overlap. If no overlap, add interval to list and return true, else return false.\n\nAlternatively use binary search.\n\nWe'll produce pseudocode with Start, End etc.\n\nWe need to use the format with arrows. We'll produce something like:\n\nStart // Initialize MyCalendar\n→ Step 1: Create empty list intervals // store existing bookings\nEnd // done.\n\nThen book function:\n\nStart // book function\n→ Step 1: For each (s, e) in intervals\n→ Decision: if startTime < e and s < endTime? // overlap condition\n→ Yes → Step 2: Return false // overlapping, cannot book\n→ No → continue loop\n→ After loop: Step 3: Add (startTime, endTime) to intervals\n→ Step 4: Return true\nEnd // function\n\nBut must use format lines with each line.\n\nWe need to include arrow indent for decisions.\n\nLet's produce something like:\n\nStart MyCalendar // 初始化日曆\n→ Step 1: intervals ← empty list // 用來存所有已預約的時間段\nEnd MyCalendar // 完成初始化\n\nThen for book function:\n\nStart book // 嘗試預約一段時間\n→ Step 1: For each (s, e) in intervals\n→ Decision: if startTime < e and s < endTime? // 檢查是否有重疊\n  Yes → Step 2: Return false // 重疊，拒絕預約\n  No  → Step 3: Continue to next interval\n→ Step 4: Append (startTime, endTime) to intervals // 沒有重疊，加入新預約\n→ Step 5: Return true // 成功預約\nEnd book // 結束預約流程\n\nWe need to follow the specified format: each line with \"虛擬碼步驟\" then space then \"// 解釋/說明\".\n\nAlso need to include arrow characters: →, Yes →, No →.\n\nMake sure indent for decisions.\n\nAlso the top-level \"Start MyCalendar\" maybe \"Start MyCalendar()\" but we just need pseudocode.\n\nLet's craft final answer.\n...done thinking.\n\nStart MyCalendar() // 初始化日曆物件  \n→ Step 1: intervals ← empty list // 用來儲存已成功預約的時間段  \nEnd MyCalendar() // 結束初始化  \n\nStart book(startTime, endTime) // 嘗試預約新事件  \n→ Step 1: For each (s, e) in intervals // 逐一檢查已存在的時間段  \n→ Decision: 是否有重疊?  // 檢查兩個區間是否相交  \n  Yes → Step 2: Return false // 若有重疊則拒絕預約  \n  No  → Step 3: Continue to next (s, e) // 若無重疊則繼續檢查  \n→ Step 4: Append (startTime, endTime) to intervals // 所有檢查結束後加入新預約  \n→ Step 5: Return true // 成功預約並返回真值  \nEnd book() // 結束預約流程"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,0,0,6,0,6,4,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 0, 0, 6, 0, 6, 4, 6]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip())\n\n    res = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            res.append(None)\n        elif cmd == \"pick\":\n            res.append(obj.pick())\n        else:\n            res.append(None)  # fallback for unexpected commands\n\n    # Convert None to 'null' for output\n    formatted = '[' + ', '.join('null' if v is None else str(v) for v in res) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step. The task: design algorithm for random pick with blacklist. Known solution: remap blacklisted values to whitelist space. Steps: compute mapping for blacklisted numbers less than m = n - len(blacklist). Preprocess: create set of blacklist. For each b in blacklist where b < m, map it to some whitelisted number >= m. Use pointer j = n-1 moving downwards. Build dict mapping. Then pick: rand = randomInt(0, m-1); if rand in map: return map[rand]; else return rand.\n\nWe need to produce virtual code lines accordingly. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: arrows etc. Also need to include initialization and pick.\n\nSo produce sequence:\n\nStart // 程式開始執行\n→ Step 1: 接收 n 與 blacklist // 建構物件初始化\n→ Step 2: 計算 m = n - blacklist.size() // 可用數字個數\n→ Step 3: 建立集合 B = blacklist 為查找集合 // 方便 O(1) 判斷\n→ Step 4: 建立空字典 map // 將黑名單 < m 的數映射到白名單\n→ Decision: 是否有黑名單? // 若 blacklist 为空\n    Yes → Step 5: 將所有 b < m 遍歷\n        → Step 5a: 找 j = n-1 向下尋找不在 B 的數字 // 將作為映射目標\n        → Step 5b: map[b] = j\n        → Step 5c: j-- // 更新\n→ Step 6: pick() // 生成隨機數\n→ Step 7: rand = randomInt(0, m-1) // 取得範圍內隨機整數\n→ Decision: rand 是否在 map 中? // 判斷是否需要映射\n    Yes → Step 8: 返回 map[rand] // 黑名單映射值\n    No  → Step 9: 返回 rand // 原始值\nEnd // 程式結束\n\nNeed to include arrows, and each line must have \"虛擬碼步驟 [space] // 解釋\". Also use arrow \"→\" for steps. Decision lines use \"Decision:\".\n\nLet's format accordingly. Ensure each line separate. Use Chinese comments. Should be \"Start // 程式開始執行\" etc. Need to show mapping step within decision? Use nested decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收參數 n 與 blacklist // 建構物件初始化  \n→ Step 2: 計算 m = n - blacklist.size() // 可用數字個數  \n→ Step 3: 建立集合 B = blacklist 為快速查找集合 // 方便 O(1) 判斷  \n→ Step 4: 建立空字典 map // 用於映射黑名單小於 m 的數  \n→ Decision: blacklist 是否非空? // 若沒有黑名單則直接跳過  \n    Yes → Step 5: 初始化 j = n - 1 // 從最高位開始尋找白名單  \n    → Step 6: 遍歷每個 b 在 blacklist  \n        → Decision: b < m? // 只映射那些落在 [0, m-1] 的黑名單  \n            Yes → Decision: j 在 B? // 確保 j 不是黑名單  \n                No → Step 7: map[b] = j // 建立映射  \n                Yes → Step 8: j-- // 退回到下一個可能的白名單  \n                → Step 9: j-- // 繼續搜尋直至找到非黑名單  \n            No → Step 10: 跳過該 b // 只對小於 m 的數進行處理  \n→ Step 11: 完成預處理 // map 現已準備好用於隨機選取  \n→ Function pick() // 生成隨機數  \n    → Step 12: rand = randomInt(0, m - 1) // 在可用範圍內隨機選取  \n    → Decision: rand 是否在 map? // 判斷是否為映射目標  \n        Yes → Step 13: return map[rand] // 返回映射後的白名單數  \n        No  → Step 14: return rand // 直接返回原始值  \nEnd // 程式結束執行"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.7844283261375683,0.37183386859748657],[0.7916525407978215,0.4823246641834805],[0.6814373110352852,0.347943661372849]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.7844283261375683, 0.37183386859748657], [0.7916525407978215, 0.4823246641834805], [0.6814373110352852, 0.347943661372849]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機生成半徑（保證均勻分佈）與角度\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換回笛卡兒座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取兩行：命令列表與對應的參數列表\n    input_data = sys.stdin.read().strip().splitlines()\n    if not input_data:\n        sys.exit(0)\n    commands = json.loads(input_data[0])\n    args_list = json.loads(input_data[1])\n\n    instance = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            instance = Solution(*args)\n            results.append(None)          # 代表構造函數呼叫\n        elif cmd == \"randPoint\":\n            if instance is None:\n                raise ValueError(\"randPoint called before Solution is instantiated\")\n            results.append(instance.randPoint())\n        else:\n            # 如有其他方法可在此處處理\n            pass\n\n    # 輸出結果為 JSON 格式，符合 LeetCode 的輸出規範\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanations, using Start, Decision etc. The requirement: implement a class Solution with constructor and method randPoint. Need to produce uniform random point inside circle. The typical method: generate random radius sqrt(random())*radius and angle uniform 0 to 2π. Then x = center_x + r*cos(theta), y = center_y + r*sin(theta). That ensures uniform distribution.\n\nWe produce steps:\n\nStart // program start\n→ Step 1: Define class Solution // class definition\n→ Step 2: Define constructor Solution(radius, x_center, y_center) // initialize properties\n→ Step 3: Store radius, center coordinates in object // fields\n→ Step 4: End of constructor // return\n\n→ Step 5: Define method randPoint() // method to generate point\n→ Step 6: Generate random number u between 0 and 1 // random()\n→ Step 7: Compute r = radius * sqrt(u) // radius scaling\n→ Step 8: Generate random angle θ between 0 and 2π // random()*2π\n→ Step 9: Compute x = x_center + r * cos(θ) // coordinate\n→ Step 10: Compute y = y_center + r * sin(θ) // coordinate\n→ Step 11: Return array [x, y] // output\nEnd // program end\n\nBut we need to incorporate decision arrows? No decision needed. But maybe we can show step structure with arrows. We need \"Start\", \"End\", \"Decision:\". But we don't have decisions. We can still present as steps. Use \"→\" to indicate sequence. Provide explanation comment.\n\nLet's format exactly as requested: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use Start and End lines.\n\nAlso, we need to maintain the formatting, e.g., Start // 程式開始執行.\n\nLet's create:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類\n→ Constructor Solution(radius, x_center, y_center) // 建構子，傳入半徑與中心座標\n→ Assign this.radius = radius // 存儲半徑\n→ Assign this.x_center = x_center // 存儲中心 X\n→ Assign this.y_center = y_center // 存儲中心 Y\n→ End Constructor // 建構完成\n→ Method randPoint() // 產生隨機點\n→ Generate u = random() // 產生 0~1 隨機數\n→ Compute r = radius * sqrt(u) // 根據均勻分佈調整半徑\n→ Generate theta = random() * 2π // 產生 0~2π 的角度\n→ Compute x = x_center + r * cos(theta) // 計算 X 坐標\n→ Compute y = y_center + r * sin(theta) // 計算 Y 坐標\n→ Return [x, y] // 回傳點\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Need to keep the pattern: \"虛擬碼步驟 [space] // 解釋\". We can use \"→\" to show sequence. Use \"Start\" and \"End\". The above lines are fine.\n\nDouble-check: \"每行必須包含：`虛擬碼步驟` + `[空格]` + `// 解釋/說明`。\" So each line should end with \"//\" comment.\n\nAlso need to not output actual code. The above lines are pseudocode with comments. That's fine.\n\nMake sure arrow lines begin with \"→\". We also should include \"Start // 程式開始執行\" etc. Provide no extra commentary.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution // 定義 Solution 類  \n→ Constructor Solution(radius, x_center, y_center) // 建構子，傳入半徑與中心座標  \n→ Assign this.radius = radius // 存儲半徑  \n→ Assign this.x_center = x_center // 存儲中心 X 坐標  \n→ Assign this.y_center = y_center // 存儲中心 Y 坐標  \n→ End Constructor // 建構完成  \n→ Method randPoint() // 產生隨機點  \n→ Generate u = random() // 產生 0~1 的隨機數  \n→ Compute r = radius * sqrt(u) // 根據均勻分佈調整半徑  \n→ Generate theta = random() * 2π // 產生 0~2π 的角度  \n→ Compute x = x_center + r * cos(theta) // 計算 X 坐標  \n→ Compute y = y_center + r * sin(theta) // 計算 Y 坐標  \n→ Return [x, y] // 回傳隨機點  \nEnd // 程式結束"
    },
    {
      "title": "4Sum II",
      "source_file": "Leetcode/leetcode454.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps5tca_ha.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmps5tca_ha.py\", line 26, in main\n    var, val = part.split('=', 1)\n    ^^^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef fourSumCount(A, B, C, D):\n    \"\"\"計算四元組的數量，使得 A[i] + B[j] + C[k] + D[l] == 0。\"\"\"\n    # A+B 的所有和及其出現頻率\n    AB = Counter(a + b for a in A for b in B)\n    count = 0\n    # 針對 C+D 的每一個和，查找其補數\n    for c in C:\n        for d in D:\n            count += AB.get(-(c + d), 0)\n    return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，例如 \"A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]\"\n    parts = [p.strip() for p in data.split(',')]\n    arrs = {}\n    for part in parts:\n        if not part:\n            continue\n        var, val = part.split('=', 1)\n        var = var.strip()\n        val = val.strip()\n        try:\n            arrs[var] = ast.literal_eval(val)\n        except Exception:\n            arrs[var] = []\n    A = arrs.get('A', [])\n    B = arrs.get('B', [])\n    C = arrs.get('C', [])\n    D = arrs.get('D', [])\n    result = fourSumCount(A, B, C, D)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo code for 4Sum counting problem. Approach: compute sums of A+B, store frequencies, then for each sum of C+D, look up complement. Use hash map. Steps: Start, input arrays. n = length. Build map sumAB. For i in 0..n-1, for j in 0..n-1: sum = A[i]+B[j]; map[sum]++.\n\nThen result=0. For k in 0..n-1, for l in 0..n-1: sumCD = C[k]+D[l]; complement = -sumCD; if complement in map: result += map[complement].\n\nReturn result. End.\n\nNeed to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End, Decision maybe not needed. But we can include Decision if checking map. Format:\n\nStart // 程式開始執行\n→ Step 1: Initialize n ← length(A) // 取得陣列長度\n→ Step 2: Initialize map ← empty hash map // 用來記錄 A+B 的和頻率\n→ Step 3: For i from 0 to n-1 // 遍歷 A\n    → For j from 0 to n-1 // 遍歷 B\n        → sum ← A[i] + B[j] // 計算 A[i] + B[j]\n        → map[sum] ← map.get(sum, 0) + 1 // 更新頻率\n→ Step 4: Initialize result ← 0 // 結果計數\n→ Step 5: For k from 0 to n-1 // 遍歷 C\n    → For l from 0 to n-1 // 遍歷 D\n        → sumCD ← C[k] + D[l] // 計算 C[k] + D[l]\n        → complement ← -sumCD // 需要的補數\n        → Decision: 如果 complement in map?\n            Yes → result ← result + map[complement] // 加上符合條件的組合數\n            No  →  // 無匹配，跳過\n→ Step 6: Return result // 回傳總數\nEnd // 程式結束\n\nMake sure each line has arrow arrow after Start? They used \"Start\" with no arrow. In format example, Start no arrow. Then \"→ Step 1:\" etc. So we need to maintain that. Also each line's explanation comment after //.\n\nNeed to include Decision with Yes → and No → lines. Format: \n→ Decision: 如果 complement in map? // 檢查是否有符合條件的和\n    Yes → result ← result + map[complement] // 加總\n    No  → // 無匹配，跳過\n\nBut need to indent properly. Use four spaces? In example they used two spaces indent before Yes. We'll mimic.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(A) // 取得陣列長度  \n→ Step 2: map ← empty hash map // 用於儲存 A[i] + B[j] 的和與頻率  \n→ Step 3: For i from 0 to n-1 // 遍歷 A  \n  → For j from 0 to n-1 // 遍歷 B  \n    → sum ← A[i] + B[j] // 計算 A[i] + B[j]  \n    → map[sum] ← map.get(sum, 0) + 1 // 更新該和的出現頻率  \n→ Step 4: result ← 0 // 初始化符合條件的四元組數量  \n→ Step 5: For k from 0 to n-1 // 遍歷 C  \n  → For l from 0 to n-1 // 遍歷 D  \n    → sumCD ← C[k] + D[l] // 計算 C[k] + D[l]  \n    → complement ← -sumCD // 需要的補數  \n    → Decision: 如果 complement in map? // 檢查是否有相對應的和  \n      Yes → result ← result + map[complement] // 加入匹配的組合數  \n      No  → // 沒有匹配，直接跳過  \n→ Step 6: Return result // 回傳總數  \nEnd // 程式執行結束"
    },
    {
      "title": "Reverse Words in a String",
      "source_file": "Leetcode/leetcode151.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"the sky is blue\"",
          "expected_output": "\"blue is sky the\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'blueisskythe'\nGot (Norm):      'blue\"issky\"the=s'\n--- (Raw) ---\nRaw Expected: '\"blue is sky the\"'\nRaw Got:      'blue\" is sky \"the = s'"
        },
        {
          "example_index": 1,
          "input": "s = \"  hello world  \"",
          "expected_output": "\"world hello\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'worldhello'\nGot (Norm):      '\"worldhello\"=s'\n--- (Raw) ---\nRaw Expected: '\"world hello\"'\nRaw Got:      '\" world hello \" = s'"
        },
        {
          "example_index": 2,
          "input": "s = \"a good   example\"",
          "expected_output": "\"example good a\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'examplegooda'\nGot (Norm):      'example\"good\"a=s'\n--- (Raw) ---\nRaw Expected: '\"example good a\"'\nRaw Got:      'example\" good \"a = s'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        # 先去除首尾空格，再以空格分割，並過濾掉多餘的空字串\n        words = s.strip().split()\n        # 反轉單詞順序後以單一空格連接\n        return ' '.join(words[::-1])\n\ndef main() -> None:\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 若輸入形如 s = \"the sky is blue\"，則擷取引號內的字串\n    if '=\"' in raw_input:\n        first_quote = raw_input.find('\"')\n        last_quote = raw_input.rfind('\"')\n        if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n            s = raw_input[first_quote + 1:last_quote]\n        else:\n            s = raw_input\n    else:\n        s = raw_input\n\n    result = Solution().reverseWords(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line with explanation, in Traditional Chinese. Need to handle input string, reverse words, output trimmed single-space separated. Provide virtual code steps with arrows.\n\nWe need to cover: Start, Step: input string s, Step: split into words, Step: filter empty, Step: reverse array, Step: join with single space, End.\n\nInclude decision maybe? Not needed but could include decisions about trimming.\n\nWe'll produce:\n\nStart\n→ Step 1: 讀取輸入字串 s // Get input string\n→ Step 2: 拆分 s 為單詞清單 wordsList, 使用空白分隔 // split by whitespace\n→ Step 3: 篩選 wordsList 只保留非空字串 // remove empty entries caused by multiple spaces\n→ Decision: wordsList 為空? // if no words, handle\n    Yes → Step 4: 回傳空字串 // return empty\n    No  → Step 5: 反轉 wordsList // reverse order\n→ Step 6: 用單一空格連接 wordsList 成結果字串 result // join with single space\n→ Step 7: 回傳 result // return result\nEnd\n\nMake sure each line: \"虛擬碼步驟 // 解釋\". For Decision block, we indent.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s // 從使用者取得輸入的原始字串\n→ Step 2: 拆分 s 為單詞清單 wordsList, 使用空白分隔 // 以空格作為分隔符號，得到單詞（可能含空字串）\n→ Step 3: 篩選 wordsList 只保留非空字串 // 去除因多重空白或首尾空白造成的空元素\n→ Decision: wordsList 為空? // 判斷是否存在任何有效單詞\n    Yes → Step 4: 回傳空字串 // 沒有單詞時直接回傳空字串\n    No  → Step 5: 反轉 wordsList // 將單詞順序倒轉\n→ Step 6: 用單一空格連接 wordsList 成結果字串 result // 以單一空格拼接倒轉後的單詞\n→ Step 7: 回傳 result // 將結果輸出\nEnd // 程式執行結束"
    },
    {
      "title": "Guess Number Higher or Lower",
      "source_file": "Leetcode/leetcode374.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 10, pick = 6",
          "expected_output": "6",
          "actual_output_or_error": "Invalid input format"
        },
        {
          "example_index": 1,
          "input": "n = 1, pick = 1",
          "expected_output": "1",
          "actual_output_or_error": "Invalid input format"
        },
        {
          "example_index": 2,
          "input": "n = 2, pick = 1",
          "expected_output": "1",
          "actual_output_or_error": "Invalid input format"
        }
      ],
      "generated_code": "import sys\n\n# Global variable to hold the secret number, accessible by the guess() function.\n_target = None\n\ndef guess(num: int) -> int:\n    \"\"\"\n    模擬外部 API：根據全局變量 _target 回傳結果。\n    -1 表示猜的數字比目標大\n     1 表示猜的數字比目標小\n     0 表示猜對了\n    \"\"\"\n    if num > _target:\n        return -1\n    elif num < _target:\n        return 1\n    else:\n        return 0\n\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        \"\"\"\n        使用二分搜尋結合 guess API，尋找秘密數字。\n        \"\"\"\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res < 0:   # guess(mid) == -1，mid 太大\n                right = mid - 1\n            else:           # guess(mid) == 1，mid 太小\n                left = mid + 1\n        return -1  # 不會到達此處，僅作兜底\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入，並從中擷取 n 與 pick 的值\n    raw_input = sys.stdin.read().strip()\n    # 例：raw_input 可能為 'n = 10, pick = 6'\n    numbers = [int(part) for part in raw_input.split() if part.isdigit()]\n    if len(numbers) >= 2:\n        n, pick = numbers[0], numbers[1]\n    else:\n        # 如果輸入格式不符，直接終止\n        sys.exit(\"Invalid input format\")\n\n    # 設定全域目標數字，供 guess() 參考\n    _target = pick\n\n    # 執行解法並輸出結果\n    solution = Solution()\n    answer = solution.guessNumber(n)\n    print(answer)",
      "virtual_code": "Thinking...\nWe need to output virtual code for the \"Guess Game\" algorithm: binary search using guess API. Each line with arrow and comment.\n\nWe must not output actual code, just virtual steps.\n\nFormat: \nStart\n→ Step...\nDecision: ... \n    Yes → ...\n    No → ...\nEnd\n\nWe need to describe algorithm: initialize low=1, high=n. While low <= high, mid=(low+high)/2, call guess(mid). If 0 return mid. If -1 high=mid-1. If 1 low=mid+1. End.\n\nWe produce step lines accordingly.\n\nWe must be careful: each step includes virtual code step text and comment after //.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: low ← 1, high ← n // 初始化搜尋範圍\n→ Step 2: 重複 while low <= high // 進入搜尋迴圈\n    → Step 2.1: mid ← low + (high - low) / 2 // 計算中間值，避免溢位\n    → Step 2.2: result ← guess(mid) // 呼叫 API 取得猜測結果\n    → Decision: result 等於 0? // 判斷是否猜對\n        Yes → Step 2.3: return mid // 找到正確數字，結束\n        No  → Decision: result 等於 -1? // 若猜太大\n            Yes → Step 2.4: high ← mid - 1 // 調整上界\n            No  → Step 2.5: low ← mid + 1 // 調整下界\n    // 迴圈結束後，若沒有找到，會跳出 while\nEnd // 程式執行結束\n\nBut need to maintain format exactly: each line must have 虛擬碼步驟 + space + // 解釋. Use arrow \"→\" for steps and decisions.\n\nAlso indent for decision branches with spaces or indentation. The example uses indentation with spaces before Yes/No arrows.\n\nLet's craft.\n\nWe need to include Start and End lines too.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 1, high ← n // 初始化搜尋範圍  \n→ Step 2: 重複 while low <= high // 進入搜尋迴圈  \n    → Step 2.1: mid ← low + (high - low) / 2 // 計算中間值，避免溢位  \n    → Step 2.2: result ← guess(mid) // 呼叫 API 取得猜測結果  \n    → Decision: result 等於 0? // 判斷是否猜對  \n        Yes → Step 2.3: return mid // 找到正確數字，結束  \n        No  → Decision: result 等於 -1? // 若猜太大  \n            Yes → Step 2.4: high ← mid - 1 // 調整上界  \n            No  → Step 2.5: low ← mid + 1 // 調整下界  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5qmv8fz5.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp5qmv8fz5.py\", line 25, in main\n    ops = json.loads(sys.stdin.readline())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 44 (char 43)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列（不可變）\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列的複製\n        return self.original[:]\n\n    def shuffle(self):\n        # 使用 Fisher-Yates 洗牌演算法\n        arr = self.original[:]\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    # 讀取操作與參數\n    ops = json.loads(sys.stdin.readline())\n    args = json.loads(sys.stdin.readline())\n\n    results = []\n    obj = None\n\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            # 初始化\n            obj = Solution(args[i][0])\n            results.append(None)  # 'Solution' 產生的回傳值為 null\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若有其他操作，直接忽略或可自行處理\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 的格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code, step-by-step, with explanation comments. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and structure: Start, End, Decision, etc.\n\nWe need to design algorithm: solution class, constructor, reset, shuffle. Implementation: store original array copy; reset returns copy; shuffle uses Fisher-Yates shuffle.\n\nWe need to output lines of virtual code. For example:\n\nStart // program start\n→ Step 1: Define class Solution // ...\n→ Step 2: Declare member variable originalArray // ...\n→ Step 3: Declare member variable currentArray // ...\n→ Step 4: Constructor: copy nums to originalArray // ...\n→ Step 5: Reset: return copy of originalArray // ...\n→ Step 6: Shuffle: copy originalArray to currentArray // ...\n→ Step 7: For i from length-1 down to 1: choose random j from 0..i // ...\n→ Step 8: Swap currentArray[i] and currentArray[j] // ...\n→ Step 9: Return currentArray // ...\nEnd // program end\n\nBut they ask to output line by line, each line with code + comment.\n\nWe must use virtual code style with arrows. Each line should be like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n...\n\nWe need to incorporate arrow lines and decision lines.\n\nThe algorithm is straightforward.\n\nMake sure to use \"Decision:\" lines only where we branch. In this case, maybe in shuffle algorithm we don't need decision; just loop.\n\nBut we can use for loop as loop, no need to show decision.\n\nBut we can still show steps with arrows. For loop we can show:\n\n→ Decision: i > 0? // 檢查是否還有元素需要交換\n    Yes → Step: 取隨機 j // ...\n    No → End // 循環結束\n\nAlternatively we can just show steps sequentially.\n\nBut the output format: each line must contain virtual code step + space + // explanation. So we can write:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 宣告原始陣列 originalArray // 儲存輸入的陣列\n→ Step 3: 宣告目前陣列 currentArray // 用於 shuffle\n→ Step 4: Constructor Solution(nums): 複製 nums 至 originalArray // 初始化\n→ Step 5: Method reset(): 回傳 originalArray 的複製 // 重置陣列\n→ Step 6: Method shuffle(): 複製 originalArray 至 currentArray // 開始洗牌\n→ Step 7: for i = currentArray.length-1 downto 1: // 逆序遍歷\n→ Decision: i > 0? // 檢查是否還有元素可交換\n    Yes → Step: 產生隨機整數 j 介於 0..i // 隨機選擇交換位置\n    Yes → Step: 交換 currentArray[i] 與 currentArray[j] // 交換\n    No → End // 結束循環\n→ Step 8: Return currentArray // 回傳洗牌結果\nEnd // 程式結束\n\nBut the loop may be considered as \"→ Step 7: for i = ...\". Then inside loop we have decision for j selection? The j selection doesn't require decision. But maybe we can just show as step inside loop.\n\nBut we should produce a single-line representation for each step. Maybe it's simpler:\n\nStart\n→ Step 1: Define class Solution // 建立類別\n→ Step 2: Declare originalArray // 存儲原始陣列\n→ Step 3: Declare currentArray // 用於洗牌\n→ Step 4: Constructor(nums): Copy nums to originalArray // 初始化\n→ Step 5: Method reset(): Return copy of originalArray // 重置\n→ Step 6: Method shuffle(): Copy originalArray to currentArray // 重新開始\n→ Step 7: For i = currentArray.length-1 downto 1: // 從尾到頭\n→ Decision: i > 0? // 仍有元素可處理\n    Yes → Step 7a: Generate random j between 0 and i // 隨機選擇\n    Yes → Step 7b: Swap currentArray[i] and currentArray[j] // 交換\n    No → End // 循環結束\n→ Step 8: Return currentArray // 結果\nEnd\n\nBut we need \"Step 7a\" etc? It's still lines.\n\nWe must obey \"每行虛擬碼步驟 + [空格] + // 解釋/說明\".\n\nThus each line should be:\n\nStart // 程式開始執行\n\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n\n→ Step 2: 宣告變數 originalArray // 儲存原始陣列\n\n…\n\nBut we need to use arrow \"→\" at beginning for lines after Start, and maybe use \"Decision:\" lines.\n\nWe'll produce a sequence:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 宣告原始陣列 originalArray // 用於儲存輸入的 nums\n→ Step 3: 宣告目前陣列 currentArray // 用於 shuffle\n→ Step 4: Constructor(nums): 複製 nums 至 originalArray // 初始化\n→ Step 5: Method reset(): 回傳 originalArray 的複製 // 重置為原始狀態\n→ Step 6: Method shuffle(): 複製 originalArray 至 currentArray // 開始洗牌\n→ Step 7: 從 i = currentArray.length-1 迴圈至 1 逐步遞減 // 逆序遍歷\n→ Decision: i > 0? // 檢查是否還有元素需要交換\n    Yes → Step 7a: 產生隨機 j 介於 0 和 i 之間 // 隨機選擇交換位置\n    Yes → Step 7b: 交換 currentArray[i] 與 currentArray[j] // 交換兩個位置\n    No → End // 迴圈結束\n→ Step 8: Return currentArray // 回傳洗牌後的陣列\nEnd // 程式結束執行\n\nBut \"Decision:\" lines maybe need indentation, but we can just put as separate lines:\n\nDecision: i > 0? // 檢查是否還有元素需要交換\n    Yes → Step 7a: ...\n    Yes → Step 7b: ...\n    No → End\n\nBut each line still follows the format: \"虛擬碼步驟 // 解釋\". The \"Yes →\" lines also follow.\n\nWe must ensure each line uses proper arrow.\n\nThus final output: Each line with a leading arrow except Start and End. Use Chinese comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 宣告變數 originalArray // 用於儲存原始陣列\n→ Step 3: 宣告變數 currentArray // 用於洗牌時的暫存陣列\n→ Step 4: Constructor(nums): 複製 nums 至 originalArray // 初始化時存入原始資料\n→ Step 5: Method reset(): 回傳 originalArray 的複製 // 將陣列重設為初始狀態\n→ Step 6: Method shuffle(): 複製 originalArray 至 currentArray // 重新開始洗牌\n→ Step 7: 從 i = currentArray.length-1 迴圈至 1 逐步遞減 // 逆序遍歷每個位置\n→ Decision: i > 0? // 判斷是否仍有元素需要交換\n    Yes → Step 7a: 產生隨機整數 j 介於 0 與 i 之間 // 隨機選擇交換位置\n    Yes → Step 7b: 交換 currentArray[i] 與 currentArray[j] // 交換兩個位置\n    No  → End // 迴圈結束\n→ Step 8: Return currentArray // 回傳洗牌後的陣列\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    \"\"\"生成 nums 的所有子集（幂集）\"\"\"\n    res = []\n\n    def backtrack(start, path):\n        # 把目前的子集加入結果\n        res.append(path[:])\n        # 從 start 開始選擇元素繼續遞歸\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()  # 回溯，移除最後加入的元素\n\n    backtrack(0, [])\n    return res\n\ndef format_output(res):\n    \"\"\"將子集列表轉成題目所需的字串格式，無空格\"\"\"\n    parts = []\n    for subset in res:\n        subset_str = '[' + ','.join(str(x) for x in subset) + ']'\n        parts.append(subset_str)\n    return '[' + ','.join(parts) + ']'\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，例如 \"nums = [1,2,3]\" 或僅 \"[1,2,3]\"\n    if '=' in data:\n        _, right = data.split('=', 1)\n    else:\n        right = data\n    right = right.strip()\n    nums = ast.literal_eval(right)          # 安全地將字串轉為 list\n\n    result = subsets(nums)\n    output = format_output(result)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. It's a typical power set generation. Must not duplicate subsets. Use recursion or backtracking. Provide steps.\n\nWe need Start, then maybe Step 1: sort? Not necessary. Use backtracking.\n\nLine format: `虛擬碼步驟 // 解釋/說明`\n\nUse arrows. Provide indentation? In example they used indentation. We'll mimic.\n\nLet's craft steps:\n\nStart\n→ Step 1: 定義回傳結果 list allSubsets ← empty list // 存放所有子集\n→ Step 2: 定義回調函式 backtrack(start, current) // start 索引，current 子集\n→ Step 3: → Step 3.1: 將 current 複製加入 allSubsets // 每次遞歸都加入當前子集\n→ Step 4: → Decision: start 是否超過 nums 長度? // 檢查是否已遍歷完\n    Yes → End // 若 end，返回\n    No  → For i from start to nums.length-1\n            → Step 5: current 加入 nums[i] // 選擇當前元素\n            → Step 6: backtrack(i+1, current) // 進一步遞歸\n            → Step 7: current 移除最後一個元素 // 回溯\n→ Step 8: Call backtrack(0, empty list) // 開始回溯\n→ Step 9: Return allSubsets // 回傳結果\n\nWe need to format with arrows. Let's produce:\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 allSubsets ← [] // 用於儲存所有子集\n→ Step 2: 定義函式 backtrack(start, current) // backtrack 的參數: 起始索引與目前子集\n→ Step 3: → Step 3.1: allSubsets ← allSubsets ∪ [current] // 把目前子集加入結果\n→ Step 4: → Decision: start ≥ nums.length? // 檢查是否已處理完所有元素\n    Yes → End // 若已結束，返回\n    No  → For i ← start to nums.length-1\n            → Step 5: current ← current ∪ [nums[i]] // 將 nums[i] 加入子集\n            → Step 6: backtrack(i+1, current) // 以下一個索引繼續遞歸\n            → Step 7: current ← current \\ {nums[i]} // 從子集移除已選元素（回溯）\n→ Step 8: backtrack(0, []) // 從索引0開始，子集空\n→ Step 9: Return allSubsets // 回傳完整子集集合\nEnd // 程式執行結束\n```\n\nBut each line must be separate, and we need arrow indentations. For sub-steps, we can use indentation or use separate lines with arrows and spaces. They used indent with 4 spaces for nested.\n\nLet's produce lines as separate lines:\n\nStart // 程式開始執行\n→ Step 1: allSubsets ← [] // 用於儲存所有子集\n→ Step 2: Define backtrack(start, current) // 回溯函式\n→ Step 3:   → allSubsets ← allSubsets ∪ [current] // 加入目前子集\n→ Step 4:   → Decision: start ≥ nums.length? // 檢查是否已處理完所有元素\n    Yes → End // 結束遞歸\n    No  → For i ← start to nums.length-1\n            → Step 5: current ← current ∪ [nums[i]] // 選擇元素\n            → Step 6: backtrack(i+1, current) // 進一步遞歸\n            → Step 7: current ← current \\ {nums[i]} // 回溯\n→ Step 8: backtrack(0, []) // 開始回溯\n→ Step 9: Return allSubsets // 回傳結果\nEnd // 程式結束\n\nNeed to keep consistent format: \"→ Step x: ...\" and \"Yes →\" etc. Ensure each line ends with // 解釋.\n\nWe'll produce accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: allSubsets ← [] // 用於儲存所有子集\n→ Step 2: Define backtrack(start, current) // 回溯函式\n→ Step 3:   → allSubsets ← allSubsets ∪ [current] // 把目前子集加入結果\n→ Step 4:   → Decision: start ≥ nums.length? // 檢查是否已處理完所有元素\n    Yes → End // 結束遞歸\n    No  → For i ← start to nums.length-1\n            → Step 5: current ← current ∪ [nums[i]] // 選擇元素並加入子集\n            → Step 6: backtrack(i+1, current) // 以下一個索引繼續遞歸\n            → Step 7: current ← current \\ {nums[i]} // 從子集移除已選元素（回溯）\n→ Step 8: backtrack(0, []) // 從索引0開始，子集為空\n→ Step 9: Return allSubsets // 回傳完整子集集合\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzxoovu3a.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpzxoovu3a.py\", line 37, in main\n    obj = NumArray(args[i])\n          ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzxoovu3a.py\", line 10, in __init__\n    self.prefix_sums.append(self.prefix_sums[-1] + num)\n                            ~~~~~~~~~~~~~~~~~~~~~^~~~~\nTypeError: unsupported operand type(s) for +: 'int' and 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    \"\"\"利用前綴和快速求區間和的資料結構。\"\"\"\n    def __init__(self, nums):\n        # 前綴和陣列，prefix_sums[i] 表示 nums[0:i] 的總和\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        \"\"\"返回 nums[left] + ... + nums[right]。\"\"\"\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    # 讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到第一個 ]，把輸入分成兩個部分\n    idx = data.find(']')\n    commands_str = data[:idx + 1]          # 第一個列表字串\n    args_str = data[idx + 1:].lstrip(',')  # 第二個列表字串\n\n    # 解析成 Python 物件\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    outputs = []\n    obj = None\n\n    for i, cmd in enumerate(commands):\n        if cmd == \"NumArray\":\n            # 建構子，參數是 nums\n            obj = NumArray(args[i])\n            outputs.append(None)  # 建構子回傳 null\n        else:\n            # 其他方法直接呼叫\n            method = getattr(obj, cmd)\n            result = method(*args[i])\n            outputs.append(result)\n\n    # 依照 LeetCode 的格式輸出，None 轉成 null\n    result_str = '[' + ', '.join('null' if v is None else str(v) for v in outputs) + ']'\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for class with constructor and sumRange. Use steps. Probably include initialization, prefix sum, sumRange calculation. Also maybe explain logic. Provide each line with arrow. Use Start, End. Let's produce.\n\nUse 虛擬碼步驟 like \"Start\" then steps.\n\nLet's create:\n\nStart\n→ Step 1: Initialize array nums and prefix sum array prefix // store input and compute prefix sums\n→ Step 2: For i from 0 to nums.length-1: prefix[i+1] = prefix[i] + nums[i] // build prefix sum array\n→ Step 3: Define method sumRange(left,right) // to answer queries\n    → Step 4: result = prefix[right+1] - prefix[left] // use prefix sums to get range sum\n    → Step 5: return result // output the sum\nEnd\n\nBut we need structure for class. Use Decision? Not needed.\n\nLet's output with arrows accordingly. Use \"Yes →\" not necessary. Use indentation.\n\nWe should use \"Step 1:\" etc. Provide explanation after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: NumArray(nums) // 建構子接收整數陣列 nums  \n→ Step 2: prefix ← Array(len(nums)+1) // 建立前綴和陣列，長度比 nums 多 1  \n→ Step 3: prefix[0] ← 0 // 前綴和初始值為 0  \n→ Step 4: For i from 0 to len(nums)-1: // 逐個累加計算前綴和  \n  → prefix[i+1] ← prefix[i] + nums[i] // prefix[i+1] 為 nums[0..i] 的總和  \n→ Step 5: End of constructor // 建構子結束，prefix 已完成  \n→ Step 6: sumRange(left, right) // 定義查詢方法  \n  → Step 7: result ← prefix[right+1] - prefix[left] // 用前綴和得到左右區間和  \n  → Step 8: return result // 回傳計算結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjzeon80c.py\", line 26, in <module>\n    data = json.loads(raw)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 25 (char 24)"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpax0b4yit.py\", line 26, in <module>\n    data = json.loads(raw)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw = sys.stdin.read()\n    if not raw.strip():\n        sys.exit()\n\n    # 解析輸入，使用 json 方便處理雙引號\n    data = json.loads(raw)\n    methods = data[0]          # [\"Solution\", \"pickIndex\", ...]\n    args_list = data[1]        # [[[1,3]], [], [], ...]\n    results = []\n\n    obj = None\n    for i, method in enumerate(methods):\n        if method == \"Solution\":\n            # 建構子，參數為 args_list[i][0]\n            obj = Solution(args_list[i][0])\n            results.append(None)   # 建構子不返回值\n        elif method == \"pickIndex\":\n            res = obj.pickIndex()\n            results.append(res)\n        else:\n            # 如有其他方法可在此處處理\n            pass\n\n    # 輸出為 JSON 格式，None 會自動轉成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing pickIndex using weighted random selection. We must explain each line.\n\nWe need to include steps: precompute prefix sums array, total sum. Then pickIndex: generate random number in [0,total). Find index via binary search.\n\nWe'll produce lines: Start, Step: build prefix sums, etc. Use arrow notation. Each line followed by // explanation.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 取輸入陣列 w // 取得權重陣列\n\nLine 3: → Step 2: 初始化 prefixSum = [] // 建立前綴和數組\n\nLine 4: → Step 3: sum = 0 // 計算總重量\n\nLine 5: → Decision: 遍歷 w? // 循環處理每個權重\n\nBut we need to express loops maybe as Decision. We can just describe step: for each weight add to prefixSum, update sum. We'll produce as steps.\n\nLine 6: → Step 4: 對每個 i in w: sum += w[i]; prefixSum.append(sum) // 建立前綴和\n\nLine 7: → End // 完成前綴和和總和\n\nThen pickIndex function.\n\nLine 8: → Function pickIndex(): // 定義隨機挑選函數\n\nLine 9: → Step 5: r = random.uniform(0, sum) // 產生 0~sum 之間的隨機數\n\nLine 10: → Decision: binary search prefixSum for r? // 找出 r 所對應的索引\n\nLine 11: → Step 6: low = 0; high = len(prefixSum)-1 // 設定搜尋範圍\n\nLine 12: → While low <= high: // 執行二分搜尋\n\nLine 13: →     mid = (low + high)//2 // 取中間索引\n\nLine 14: →     if prefixSum[mid] > r: high = mid - 1 // r 在左半邊\n\nLine 15: →     else: low = mid + 1 // r 在右半邊\n\nLine 16: → End While // 搜尋結束\n\nLine 17: → Step 7: return low // low 為第一個大於 r 的索引，即選擇的索引\n\nLine 18: End // 程式結束\n\nBut we need to maintain formatting: each line with arrow, maybe \"→\" before Step.\n\nWe must ensure each line has virtual code step then space then comment.\n\nLet's produce accordingly.\n\nAlso we can use Decision: for each w? But okay.\n\nWe must produce step-by-step lines as per example: Use arrow \"→\".\n\nWe'll output lines:\n\nStart // 程式開始執行\n\n→ Step 1: 取輸入陣列 w // 取得權重陣列\n\n→ Step 2: 初始化 prefixSum = [] // 建立前綴和數組\n\n→ Step 3: sum = 0 // 計算總重量\n\n→ Step 4: 對每個 i in w: sum += w[i]; prefixSum.append(sum) // 建立前綴和\n\n→ End // 前綴和與總重量已完成\n\n→ Function pickIndex(): // 定義 pickIndex 函式\n\n→ Step 5: r = random.uniform(0, sum) // 產生 0~sum 之間的隨機數\n\n→ Decision: 使用二分搜尋找到 r 在 prefixSum 中的位置? // 確定索引\n\n→ Step 6: low = 0; high = len(prefixSum)-1 // 初始化搜尋範圍\n\n→ While low <= high: // 開始二分搜尋\n\n→     mid = (low + high) // 2 // 計算中間索引\n\n→     if prefixSum[mid] > r: high = mid - 1 // r 在左半邊\n\n→     else: low = mid + 1 // r 在右半邊\n\n→ End While // 搜尋結束\n\n→ Step 7: return low // low 為對應的索引\n\n→ End // 程式結束\n\nMake sure each line has \"→\" at start except Start and End.\n\nAlso for End after while we may need \"End While\" but we can use \"End While\" comment.\n\nWe also need End after function? Example had \"End\" as program end. We'll just output End after all.\n\nAlso we might include Decision for building prefix sums? but not necessary.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取輸入陣列 w // 取得權重陣列  \n→ Step 2: 初始化 prefixSum = [] // 建立前綴和數組  \n→ Step 3: sum = 0 // 計算總重量  \n→ Step 4: 對每個 i in w: sum += w[i]; prefixSum.append(sum) // 建立前綴和  \n→ End // 前綴和與總重量已完成  \n\n→ Function pickIndex(): // 定義 pickIndex 函式  \n→ Step 5: r = random.uniform(0, sum) // 產生 0~sum 之間的隨機數  \n→ Decision: 使用二分搜尋找到 r 在 prefixSum 中的位置? // 確定索引  \n→ Step 6: low = 0; high = len(prefixSum)-1 // 初始化搜尋範圍  \n→ While low <= high: // 開始二分搜尋  \n→     mid = (low + high) // 2 // 計算中間索引  \n→     if prefixSum[mid] > r: high = mid - 1 // r 在左半邊  \n→     else: low = mid + 1 // r 在右半邊  \n→ End While // 搜尋結束  \n→ Step 7: return low // low 為對應的索引  \n→ End // 程式結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef h_index(citations):\n    \"\"\"\n    計算已排序引用數列的 h-index，時間複雜度為 O(log n)。\n    \"\"\"\n    n = len(citations)\n    if n == 0:\n        return 0\n\n    left, right = 0, n - 1\n    ans = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        # 在已排序數列中，若 citations[mid] >= n - mid 則至少有 n - mid 篇\n        # 文章被 citations[mid] 次引用，符合 h-index 條件。\n        if citations[mid] >= n - mid:\n            ans = n - mid          # 記錄目前合法的 h-index\n            left = mid + 1         # 可能還有更大的 h-index，往右尋找\n        else:\n            right = mid - 1        # 需要更小的 h-index，往左尋找\n\n    return ans\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入，格式可能為 \"citations = [0,1,3,5,6]\"\n    raw_input = sys.stdin.read().strip()\n\n    if raw_input.startswith(\"citations\"):\n        _, expr = raw_input.split(\"=\", 1)\n        expr = expr.strip()\n        citations = ast.literal_eval(expr)\n    else:\n        # 直接給出列表字面量\n        citations = ast.literal_eval(raw_input)\n\n    result = h_index(citations)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanation. Need to implement algorithm in logarithmic time. For sorted array, we can binary search for largest index such that citations[i] >= n - i. Since citations sorted ascending, we can find minimal i where citations[i] >= n-i. Equivalent to find h = n - i. We want max h. We'll binary search over i. Approach: left=0,right=n-1, ans=0. While left<=right: mid=(left+right)/2. If citations[mid] >= n-mid: ans=n-mid; left=mid+1 (try larger h). Else: right=mid-1. Return ans.\n\nWe output each step with explanation.\n\nWe need to format as given. Let's produce.\n\nWe start: Start. Step1: Read array and length n. Then binary search. Provide each step.\n\nWe should include decision branches. Provide lines like:\n\n→ Step 1: 計算 n = citations.length // 取得陣列長度\n→ Step 2: 初始化 left = 0, right = n-1, ans = 0 // 初始化二分搜尋參數\n→ Decision: left <= right? // 判斷搜尋區間是否仍有效\n    Yes → Step 3: 計算 mid = (left + right) // 2 // 取中點\n    Yes → Decision: citations[mid] >= n - mid? // 檢查中點是否滿足 h-index 條件\n        Yes → Step 4: 設定 ans = n - mid // 记录当前合法 h-index\n        Yes → Step 5: 設定 left = mid + 1 // 继续搜索更大的 h\n        No  → Step 6: 設定 right = mid - 1 // 继续搜索更小的 h\n    No → End // 搜索結束\n→ Step 7: 回傳 ans // 最終 h-index\n\nBut we need to follow required format: Each line has virtual code step + space + // explanation. Use arrows etc. We must ensure each line follows the arrow format. For decision, we indent with Yes → and No →. Provide step lines.\n\nLet's craft accordingly. Use \"Start\" and \"End\".\n\nWe can also include \"Decision:\" lines with Yes/No branches. We need to use indentation? In example they use indentation and Yes →, No → lines inside Decision. We'll follow similar.\n\nWe also need to not output actual code. Virtual code is just step description.\n\nWe must produce only pseudocode and explanations.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n = citations.length // 獲取已排序引用數列的總長度  \n→ Step 2: 初始化 left = 0, right = n - 1, ans = 0 // 設定二分搜尋的左右邊界與答案變數  \n→ Decision: left <= right? // 判斷搜尋區間是否仍有效  \n    Yes → Step 3: 計算 mid = (left + right) // 2 // 取目前搜尋區間的中點索引  \n    Yes → Decision: citations[mid] >= n - mid? // 檢查此中點是否滿足 h‑index 條件  \n        Yes → Step 4: ans = n - mid // 記錄合法的 h‑index  \n        Yes → Step 5: left = mid + 1 // 進一步搜尋更大的 h（右側區間）  \n        No  → Step 6: right = mid - 1 // 進一步搜尋較小的 h（左側區間）  \n    No → End // 搜尋區間已無效，結束迴圈  \n→ Step 7: 回傳 ans // 回傳計算得到的最大 h‑index  \nEnd // 程式執行結束"
    }
  ]
}