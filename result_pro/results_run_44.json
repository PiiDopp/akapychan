[
  {
    "source_file": "900.json",
    "problem_index_in_file": 0,
    "title": "安全除法",
    "description_snippet": "請寫一個程式，讓使用者輸入兩個整數 a 與 b，輸出 a / b 的結果。若輸入的資料非整數或除數為 0，請顯示錯誤提示『輸入錯誤或除數為 0』。程式必須使用 try / except 結構。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations, per format. The user wants a program that asks user to input two integers a and b, output a/b. If input not integer or divisor zero, show error message '輸入錯誤或除數為 0'. Must use try/except structure.\n\nThus the virtual code steps: Start, Input a, Input b, Try: convert a,b to int, divide, output result. Except (ValueError, ZeroDivisionError): output error message. End.\n\nNeed to produce line by line, each line \"虛擬碼步驟 // 解釋\". Use arrows and structure like \"Start\", \"Decision:\"? The try/except is a control structure. We can use \"Try:\" and \"Except:\"? But guidelines mention use arrows →, Yes →, No → and structure Start, End, Decision. But try/except can be represented as Decision: or simply as Try... Except. Use \"Decision:\" to check type? But it's try.\n\nWe might structure:\n\nStart // 程式開始\n→ Step 1: 輸入變數 a 原始字串 // 取得 a\n→ Step 2: 輸入變數 b 原始字串 // 取得 b\n→ Try: // 進入 try 區塊\n    → Step 3: 轉換 a 為整數 // 轉 int\n    → Step 4: 轉換 b 為整數 // 轉 int\n    → Step 5: 計算 a / b // 除法\n    → Step 6: 輸出結果 // 顯示結果\n→ Except (ValueError, ZeroDivisionError) : // 若有例外\n    → Step 7: 輸出 '輸入錯誤或除數為 0' // 錯誤訊息\nEnd // 程式結束\n\nNeed to use arrow notation \"→\". For Try/Except maybe we can indent lines under Try, with arrow. For the except block we can use \"→ Except:\" line.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入原始字串 a // 取得使用者輸入的 a  \n→ Step 2: 輸入原始字串 b // 取得使用者輸入的 b  \n→ Try: // 進入錯誤捕捉區塊  \n  → Step 3: 轉換 a 為整數 // 嘗試將 a 轉成 int  \n  → Step 4: 轉換 b 為整數 // 嘗試將 b 轉成 int  \n  → Step 5: 計算 a / b // 執行除法運算  \n  → Step 6: 輸出結果 // 顯示 a 除以 b 的結果  \n→ Except (ValueError, ZeroDivisionError): // 捕捉非整數或除數為 0 的例外  \n  → Step 7: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    try:\n        a_str = input()\n        a, b = map(int, a_str.split())\n        print(a / b)\n    except (ValueError, ZeroDivisionError):\n        print('輸入錯誤或除數為 0')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "10 0",
          "expected_output": "輸入錯誤或除數為 0",
          "success": true,
          "output": "輸入錯誤或除數為 0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "900.json",
    "problem_index_in_file": 1,
    "title": "統計文字行數",
    "description_snippet": "請寫一個程式，開啟名為 data.txt 的檔案，讀取內容並輸出總共有幾行文字。若檔案不存在，請顯示『找不到檔案！』。請使用 with 語法搭配 try / except。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output the virtual code line by line, with explanation after each line. Use structure: Start, → Step..., → Decision..., End. Use with and try/except. Provide explanation in Chinese. Ensure each line ends with // 解釋. Let's produce.\n\nMake sure to handle file open inside try/except. Steps:\n\nStart\n→ Step 1: 定義檔案路徑 // 指定要開啟的檔案名稱\n→ Decision: 檔案是否存在? // 檢查檔案是否存在\n    Yes → Step 2: 開啟檔案並計算行數 // 使用 with open 讀取行數\n    No → Step 3: 輸出 '找不到檔案！' // 檔案不存在時提示\n\nBut we also need to use try/except. Could do:\n\n→ Step 1: 使用 try 開啟檔案 // 用 try 來捕捉 FileNotFoundError\n    try:\n        with open...\n    except FileNotFoundError:\n        print...\n\nSo represent as steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義檔案名稱為 'data.txt' // 設定要讀取的檔案路徑\n→ Step 2: 嘗試打開檔案並計算行數 // 進入 try 區塊以捕捉檔案不存在的情況\n    try:\n→ Step 3: 使用 with open('data.txt', 'r') as file: // 用 with 進行安全開啟\n        → Step 4: 初始化行數計數器 line_count = 0 // 設置行數變數\n        → Step 5: 逐行遍歷 file 迴圈 // 讀取每一行以更新計數\n            for line in file:\n                → Step 6: line_count += 1 // 行數累加\n        → Step 7: 輸出總行數 // 完成後顯示行數\n            print(f'總共有 {line_count} 行')\n    except FileNotFoundError:\n→ Step 8: 輸出 '找不到檔案！' // 檔案不存在時提示\n        print('找不到檔案！')\nEnd // 程式執行結束\n\nWe need to keep each line as separate \"虛擬碼步驟\" lines. The lines inside try/except are nested; we might indent them but we can just use arrow for nested steps. Use proper indentation maybe.\n\nWe must adhere to format: each line starts with virtual code step, a space, then // explanation. So each line will have that. For nested we can use indentation spaces? The example didn't show indentation but they used tabs? Let's just use spaces.\n\nWe should include \"Start\" and \"End\". For try/except structure, we can represent:\n\n→ Step 2: 嘗試打開檔案並計算行數 // 進入 try 區塊以捕捉檔案不存在的情況\n    → Decision: 是否成功打開檔案? // 試圖捕捉成功與失敗\n        Yes → Step 3: 使用 with open ... // 使用 with 開啟檔案\n        No  → Step 4: 輸出 '找不到檔案！' // 失敗時提示\n\nBut they asked to use try/except; but representation with Decision can mimic. Let's produce:\n\nStart\n→ Step 1: 定義檔案名稱為 'data.txt' // 設定要讀取的檔案路徑\n→ Step 2: 嘗試打開檔案並計算行數 // 進入 try 區塊以捕捉 FileNotFoundError\n    → Decision: 是否能成功打開? // 這代表 try 是否成功\n        Yes → Step 3: 使用 with open('data.txt', 'r') as file: // 使用 with 進行安全開啟\n            → Step 4: 初始化 line_count = 0 // 設置行數計數器\n            → Step 5: 逐行遍歷 file 迴圈 // 讀取每一行以更新計數\n                for line in file:\n                    → Step 6: line_count += 1 // 行數累加\n            → Step 7: 輸出總行數 // 完成後顯示行數\n                print(f'總共有 {line_count} 行')\n        No  → Step 8: 輸出 '找不到檔案！' // 檔案不存在時提示\n            print('找不到檔案！')\nEnd\n\nBut the nested indentation maybe not necessary; but we need each line separate. Each line must have virtual code step. So we can't have for line in file: inside same line? We can separate steps: Step 5: 進入 for loop. Step 6: line_count += 1. Step 7: print. That's fine.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義檔案名稱為 'data.txt' // 設定要讀取的檔案路徑\n→ Step 2: 嘗試打開檔案並計算行數 // 進入 try 區塊以捕捉檔案不存在的情況\n    → Decision: 是否能成功打開檔案? // 代表 try 是否成功\n        Yes → Step 3: 使用 with open('data.txt', 'r') as file: // 使用 with 開啟檔案\n            → Step 4: 初始化行數計數器 line_count = 0 // 設置行數變數\n            → Step 5: 進入逐行遍歷 for loop // 讀取每一行以更新計數\n                → Step 6: 對每行執行 line_count += 1 // 行數累加\n            → Step 7: 結束遍歷並輸出總行數 // 完成後顯示行數\n                → Step 8: print(f'總共有 {line_count} 行')\n        No  → Step 9: 輸出 '找不到檔案！' // 檔案不存在時提示\n            → Step 10: print('找不到檔案！')\nEnd // 程式執行結束\n\nNeed to ensure each line is separate. Indentation for nested steps is okay but we might need to keep them separate lines. Also we used \"→ Decision\" inside try. But we must reflect try/except. The \"Decision\" maybe not strictly required, but acceptable. Alternatively we can show:\n\n→ Step 2: 嘗試打開檔案並計算行數 // 進入 try 區塊以捕捉 FileNotFoundError\n    → Try:\n        → Step 3: 使用 with open... // ...\n    → Except FileNotFoundError:\n        → Step 4: print('找不到檔案！')\n\nBut they ask to use with and try/except. Let's use structure with try/except.\n\nSo we can show:\n\nStart\n→ Step 1: 定義檔案名稱為 'data.txt' // 設定要讀取的檔案路徑\n→ Step 2: 嘗試打開檔案並計算行數 // 進入 try 區塊以捕捉 FileNotFoundError\n    → Try:\n        → Step 3: 使用 with open('data.txt', 'r') as file: // 使用 with 進行安全開啟\n            → Step 4: 初始化行數計數器 line_count = 0 // 設置行數變數\n            → Step 5: 進入逐行遍歷 for loop // 讀取每一行以更新計數\n                → Step 6: 對每行執行 line_count += 1 // 行數累加\n            → Step 7: 結束遍歷並輸出總行數 // 完成後顯示行數\n                → Step 8: print(f'總共有 {line_count} 行')\n    → Except FileNotFoundError:\n        → Step 9: 輸出 '找不到檔案！' // 檔案不存在時提示\n            → Step 10: print('找不到檔案！')\nEnd\n\nBut we must keep each line separate; so lines like \"→ Try:\" maybe separate. The \"Try:\" line is just a marker. The \"→ Except FileNotFoundError:\" line similarly.\n\nHowever, the example uses \"Decision:\" only. They didn't show Try/Except. But we can still use our own structure.\n\nBut the instruction: Use virtual code arrow (→, Yes →, No →) and structure (Start, End, Decision:). Not necessarily restrict to these; we can use Try. But maybe safer to stick to Decision and not include \"Try\" line. But they ask to use try/except. We can represent try/except using Decision: If FileNotFoundError? But that's not natural.\n\nBetter to keep simple: Use Decision to check file existence with try/except concept implicitly.\n\nBut they want to use with and try/except. We can still keep Decision representation and mention try/except inside explanation.\n\nI think it's okay to use Decision as placeholder for try block. We'll do:\n\nStart\n→ Step 1: 定義檔案名稱為 'data.txt' // 設定要讀取的檔案路徑\n→ Step 2: 嘗試打開檔案並計算行數 // 進入 try 區塊以捕捉檔案不存在的情況\n    → Decision: 讀取成功? // 代表 try 成功\n        Yes → Step 3: 使用 with open('data.txt', 'r') as file: // 用 with 進行安全開啟\n            → Step 4: 初始化 line_count = 0 // 設置行數計數器\n            → Step 5: 進入逐行遍歷 for loop // 讀取每一行以更新計數\n                → Step 6: 對每行執行 line_count += 1 // 行數累加\n            → Step 7: 輸出總行數 // 完成後顯示行數\n                → Step 8: print(f'總共有 {line_count} 行')\n        No  → Step 9: 輸出 '找不到檔案！' // 檔案不存在時提示\n            → Step 10: print('找不到檔案！')\nEnd\n\nBut this is a bit ambiguous. Let's produce final answer with each line separate.\n\nNeed to keep format: each line: virtual code step + space + // explanation. So no indentation spaces? Use indentation for nested steps but still each line separate.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義檔案名稱為 'data.txt' // 設定要讀取的檔案路徑  \n→ Step 2: 嘗試打開檔案並計算行數 // 進入 try 區塊以捕捉 FileNotFoundError  \n    → Decision: 讀取成功? // 代表 try 成功  \n        Yes → Step 3: 使用 with open('data.txt', 'r') as file: // 用 with 進行安全開啟  \n            → Step 4: 初始化行數計數器 line_count = 0 // 設置行數變數  \n            → Step 5: 進入逐行遍歷 for loop // 讀取每一行以更新計數  \n                → Step 6: 對每行執行 line_count += 1 // 行數累加  \n            → Step 7: 輸出總行數 // 完成後顯示行數  \n                → Step 8: print(f'總共有 {line_count} 行')  \n        No  → Step 9: 輸出 '找不到檔案！' // 檔案不存在時提示  \n            → Step 10: print('找不到檔案！')  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    # Consume any stdin input (if provided), but not used in the logic\n    sys.stdin.read()\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 1 行",
          "success": true,
          "output": "檔案共有 1 行"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 0,
    "title": "表達式計算",
    "description_snippet": "請寫一個程式，輸入三個整數 a、b、c，計算並輸出結果：a + b * c 和 (a + b) * c。請觀察兩者的不同。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line, no actual code. Use Start, End, Decision, etc. Provide lines: input three integers, compute sum = a + b * c, compute prod = (a + b) * c, output results.\n\nNo decisions needed except maybe verifying input? But not necessary. Provide explanation after each line. Use arrow and step labels. Let's produce.\n\nStart\n→ Step 1: 輸入 整數 a, b, c // 從使用者取得三個整數\n→ Step 2: 計算 sum = a + b * c // 按優先順序先乘後加\n→ Step 3: 計算 prod = (a + b) * c // 先加後乘\n→ Step 4: 輸出 sum // 顯示 a + b * c 的結果\n→ Step 5: 輸出 prod // 顯示 (a + b) * c 的結果\nEnd\n\nBut we might include explanation for each. Let's produce lines exactly: \"Start // 程式開始執行\". Each line: \"→ Step 1: ... // ...\". Use arrow.\n\nAlso maybe include Decision for difference? But not needed.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 整數 a, b, c // 從使用者取得三個整數  \n→ Step 2: 計算 sum = a + b * c // 按算術優先順序先算乘，再加  \n→ Step 3: 計算 prod = (a + b) * c // 先算加法，再乘  \n→ Step 4: 輸出 sum // 顯示 a + b * c 的結果  \n→ Step 5: 輸出 prod // 顯示 (a + b) * c 的結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef solve():\n    # 讀取輸入並轉成三個整數\n    data = sys.stdin.read().strip().split()\n    if len(data) != 3:\n        return\n    a, b, c = map(int, data)\n\n    # 依照算術優先順序計算兩個表達式\n    expr1 = a + b * c          # 先乘後加\n    expr2 = (a + b) * c        # 先加後乘\n\n    # 將結果輸出，符合題目要求的字串格式\n    print(f\"a + b * c = {expr1}\")\n    print(f\"(a + b) * c = {expr2}\")\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2 3 4",
          "expected_output": "a + b * c = 14\n(a + b) * c = 20",
          "success": true,
          "output": "a + b * c = 14\n(a + b) * c = 20"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 1,
    "title": "平均分配",
    "description_snippet": "小明有 n 顆糖果，要平均分給 m 個小朋友。請輸入 n 和 m，輸出每個小朋友分到幾顆糖果，剩下幾顆糖果沒有分完。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Format: each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision. Provide steps: Start, input n,m, compute quotient and remainder, output. Also end. Need to use Chinese. Provide decision if remainder >0? But not required. Just output quotient and remainder. So simple. Provide virtual code with arrows. Use \"Step 1: 輸入 n\" etc. Use Decision to compute remainder maybe. Provide \"Step 3: 輸出每個小朋友分到的糖果數量\" etc. Use arrow. Use \"→\" after Start, etc. Provide final End. Use proper indentation? In example they used indentation for Decision branches. So we need similar. Provide \"Decision:\" line to calculate remainder. But we could just compute. For demonstration: Step 2: 計算 quotient = n ÷ m // integer division. Step 3: 計算 remainder = n mod m. Then output. Might include decision: if remainder > 0 then show remainder else not. But requirement: output remainder anyway. So no decision needed. We can keep simple. But we can include a decision for if remainder > 0? Maybe not. The format example uses Decision but not mandatory. We can include. But simpler: no decision. Provide steps with arrows. Should be line by line. Provide start, Step 1 input, Step 2 compute, Step 3 output, End. Use arrows. Let's craft.\n\nEnsure each line ends with // explanation. Use \"Start\" then arrow. Each step preceded by \"→\". Decision only if needed. Provide \"End\" line. Use \"→\" after \"Start\". Ok.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 取得糖果總數  \n→ Step 2: 輸入 m // 取得小朋友人數  \n→ Step 3: 計算 quotient = n ÷ m // 每個小朋友可分得的整數糖果數  \n→ Step 4: 計算 remainder = n mod m // 未分完的剩餘糖果數  \n→ Step 5: 輸出 '每個小朋友分到' + quotient + '顆糖果' // 顯示平均分配結果  \n→ Step 6: 輸出 '剩下' + remainder + '顆糖果沒有分完' // 顯示剩餘糖果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 從標準輸入讀取所有資料，並拆分成數字\n    data = sys.stdin.read().strip().split()\n    if not data:  # 如果沒有輸入，直接返回\n        return\n    n, m = map(int, data[:2])  # 取得糖果總數與小朋友人數\n\n    per = n // m      # 每個小朋友能分到的完整糖果數\n    left = n % m      # 剩餘未分配的糖果數\n\n    # 輸出結果，格式符合題目要求\n    print(f\"每人={per} 剩下={left}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "20 6",
          "expected_output": "每人=3 剩下=2",
          "success": true,
          "output": "每人=3 剩下=2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 0,
    "title": "模擬擲骰子遊戲",
    "description_snippet": "請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output pseudo-code line by line, with each line \"虛擬碼步驟 // 解釋\" and use arrows and structure. Use Start, End, Decision. So we start with Start. Then maybe import random? We can include that step. Then define function roll_dice(n). Then initialize list. Then for i in range(n): roll = random.randint(1,6); append. After loop, return list. Then End.\n\nWe need to incorporate arrow arrow \"→\" for each step. Let's produce lines:\n\nStart\n→ Step 1: Import random module // 引入 random\n→ Step 2: Define function roll_dice(n) // 建立函式\n→ Step 3: 初始化結果串列 results = [] // 空串列存放擲骰結果\n→ Step 4: For i from 1 to n: // 重複 n 次\n    → Step 5: 擲骰: roll = random.randint(1, 6) // 產生 1-6 隨機數\n    → Step 6: Append roll to results // 存進結果串列\n→ Step 7: Return results // 回傳所有結果\nEnd\n\nNeed to use Decision? There's no decision. Could use Decision: if n <=0? But not needed. So no decision.\n\nBut the format example uses arrows after Start, e.g., \"Start // 程式開始執行\". Then \"→ Step 1: ...\". The \"→\" can be used. For loops, we can write \"→ Step 4: For i in range(n): // 重複 n 次\". Then indent sub steps with arrow or maybe same level. We could also indent with \"→\" lines preceded by space. The format uses indentation.\n\nWe should include explanation after each line.\n\nLet's craft lines accordingly. We'll keep consistent.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 引入 random 模組以使用亂數功能  \n→ Step 2: Define function roll_dice(n) // 建立 roll_dice 函式，接受擲骰次數 n  \n→ Step 3: Initialize results = [] // 建立空串列來存放每次擲骰的結果  \n→ Step 4: For i in range(n): // 進行 n 次迴圈  \n  → Step 5: roll = random.randint(1, 6) // 在 1 至 6 之間產生隨機整數  \n  → Step 6: Append roll to results // 把本次擲骰結果加入結果串列  \n→ Step 7: Return results // 回傳所有擲骰結果的串列  \nEnd // 程式執行結束",
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳結果串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼，並執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,6,6,6,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 6, 6, 6, 5]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 1,
    "title": "計算程式執行時間",
    "description_snippet": "請使用 time 模組，寫一個函數 measure_time(func, *args)，用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Format: \"虛擬碼步驟 // 解釋\". Use arrows etc. Should include time module usage, define function measure_time, call func with *args, capture time before/after, compute elapsed, round to 3 decimals, return. Possibly also return result of func? Problem: measure_time returns result? It says 回傳結果 (四捨五入到小數點 3 位)。 Might refer to elapsed time. So return elapsed. Provide virtual steps.\n\nAlso need to include Start End, Decision maybe not needed. Just steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 匯入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 建立 measure_time 函式\n→     Step 3: 記錄開始時間 start = time.perf_counter() // 取得開始時間\n→     Step 4: 執行 func 之後的結果 result = func(*args) // 呼叫目標函式\n→     Step 5: 記錄結束時間 end = time.perf_counter() // 取得結束時間\n→     Step 6: 計算 elapsed = end - start // 計算執行時間\n→     Step 7: 四捨五入到 3 位 elapsed_rounded = round(elapsed, 3) // 四捨五入\n→     Step 8: 回傳 elapsed_rounded // 回傳經過時間\nEnd // 程式執行結束\n\nBut need to use 虛擬碼 arrow syntax. Use \"→\" before each step. Also maintain indent for nested? Not necessary. Use \"Start\" and \"End\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 匯入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 建立 measure_time 函式  \n→     Step 3: Record start time start = time.perf_counter() // 取得執行開始時間  \n→     Step 4: Call target function result = func(*args) // 執行 func 並傳入所有參數  \n→     Step 5: Record end time end = time.perf_counter() // 取得執行結束時間  \n→     Step 6: Compute elapsed = end - start // 計算執行所需秒數  \n→     Step 7: Round to 3 decimal places elapsed_rounded = round(elapsed, 3) // 四捨五入到 3 位小數  \n→     Step 8: Return elapsed_rounded // 回傳經過時間  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行所需時間，回傳四捨五入到小數點 3 位的秒數。\"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\ndef main():\n    # 讀取所有標準輸入\n    code = sys.stdin.read()\n    # 建立執行環境，並把 measure_time 放進去\n    namespace = {'measure_time': measure_time}\n    # 執行輸入的程式碼；程式碼內部的 print 會直接輸出到標準輸出\n    exec(code, namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 0,
    "title": "BMI 計算器\n",
    "description_snippet": "請撰寫一個程式，依序讀入使用者的姓名、身高（公分，float）、體重（公斤，float），計算 BMI = 體重(kg) / (身高(m))^2，並印出「<姓名> 的 BMI 為 <數值>」。數值四捨...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Format: \"虛擬碼步驟 // 解釋/說明\". Must use arrows etc. Use Start, End, Decision: maybe not needed. But we can show steps: Start, input name, input height, input weight, compute BMI, round, print. Use virtual code arrow \"→\". Provide each step line. No actual code. Should be in Traditional Chinese. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入姓名 // 取得使用者輸入的姓名  \n→ Step 2: 讀入身高（公分） // 取得使用者輸入的身高，單位為公分  \n→ Step 3: 讀入體重（公斤） // 取得使用者輸入的體重，單位為公斤  \n→ Step 4: 將身高轉換為米 = 身高 ÷ 100 // 轉換身高單位，方便計算 BMI  \n→ Step 5: 計算 BMI = 體重 ÷ (身高米 × 身高米) // 依公式計算 BMI  \n→ Step 6: BMI 四捨五入到小數點後 1 位 // 取整數化顯示結果  \n→ Step 7: 印出 \"<姓名> 的 BMI 為 <BMI>\" // 顯示姓名與 BMI  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    name = input()\n    height_cm = float(input())\n    weight = float(input())\n    height_m = height_cm / 100\n    bmi = weight / (height_m ** 2)\n    print(f\"{name} 的 BMI 為 {bmi:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Alice\n160\n50\n",
          "expected_output": "Alice 的 BMI 為 19.5\n",
          "success": true,
          "output": "Alice 的 BMI 為 19.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 1,
    "title": "兩數計算小工具\n",
    "description_snippet": "請撰寫一個程式，讀入一行包含兩個以空白分隔的整數，將其轉為 int 後，計算並輸出四個結果：和、差（第一個減第二個）、積、平均（保留到小數點後 1 位）。輸出格式固定為：\n和:<和> 差:<差> 積:...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation, using Start, Decision, etc. Use arrow and structure. Use Chinese commentary. The user wants reading input, splitting, converting to int, computing sum, difference, product, average (to one decimal). Output formatted string. Provide steps accordingly. Must not output actual code, only virtual steps. Use arrow → for flow. Each line: \"虛擬碼步驟 // 解釋\". Provide all steps. Probably need steps: Start, Input line, Parse ints, Compute sum, diff, prod, avg, Format output, Output, End. Also could include Decision? Not necessary. But maybe include Decision to check if input length correct. But not needed.\n\nLet's produce.\n\nUse \"→ Step 1: 讀取整行輸入 // 取得包含兩個整數的字串\" etc.\n\nWe need to produce a series of steps: Start, Step 1, Step 2, Step 3, Step 4, Step 5, Step 6, End.\n\nMake sure to follow format. Use arrow for each step. Use indentation for steps? In example, they use arrow at start of line. So each line should start with \"→ Step X:\"? In example they start \"→ Step 1: 輸入使用者數字 // ...\" and \"→ Decision:\" etc.\n\nWe'll do same.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整行輸入 // 從標準輸入取得一行包含兩個以空白分隔的整數字串  \n→ Step 2: 以空白字元分割字串並轉為整數 // 取得兩個整數 a 與 b  \n→ Step 3: 計算和為 a + b // 取得兩數之和  \n→ Step 4: 計算差為 a - b // 取得第一個減第二個的差值  \n→ Step 5: 計算積為 a * b // 取得兩數之積  \n→ Step 6: 計算平均為 (a + b) / 2.0，並保留小數點後 1 位 // 取得平均值，轉為浮點數並四捨五入到 1 位  \n→ Step 7: 以固定格式組合字串 '和:<和> 差:<差> 積:<積> 平均:<平均>' // 將所有結果轉成字串並格式化輸出  \n→ Step 8: 輸出結果字串 // 將最終字串寫回標準輸出  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n    line = sys.stdin.readline().strip()\n    a_str, b_str = line.split()\n    a, b = int(a_str), int(b_str)\n    sum_val = a + b\n    diff_val = a - b\n    prod_val = a * b\n    avg_val = (a + b) / 2\n    print(f\"和:{sum_val} 差:{diff_val} 積:{prod_val} 平均:{avg_val:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 3\n",
          "expected_output": "和:15 差:9 積:36 平均:7.5\n",
          "success": true,
          "output": "和:15 差:9 積:36 平均:7.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 0,
    "title": "學生資料類別設計",
    "description_snippet": "請定義一個 Student 類別，具有屬性 name（姓名）與 score（分數）。\n1. 於 __init__() 建構子中初始化這兩個屬性。\n2. 定義方法 show_info()，輸出『XXX ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a step-by-step virtual code for defining a Student class with name and score, constructor initializing, method show_info() outputting 'XXX 的分數是 YYY', then create two objects and call show_info(). They want a structure using Start, End, Decision, etc. It's not a decision tree necessarily but just flow. We need to produce virtual code lines with explanation after each line. Each line should be \"虛擬碼步驟 // 解釋\". Should use arrows, Start, End, Decision: etc. For class definition, we can show class definition as step.\n\nWe should produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Student // 宣告 Student 類別\n    → Step 2: 在 Student 中定義 __init__(self, name, score) // 建構子接收姓名與分數\n        → Step 3: self.name = name // 設定實例屬性 name\n        → Step 4: self.score = score // 設定實例屬性 score\n    → Step 5: 定義方法 show_info(self) // 定義顯示資訊的方法\n        → Step 6: 輸出 f\"{self.name} 的分數是 {self.score}\" // 印出姓名與分數\n→ Step 7: 建立物件 student1 = Student('Alice', 90) // 建立第一個學生物件\n→ Step 8: 呼叫 student1.show_info() // 呼叫方法顯示第一個學生資訊\n→ Step 9: 建立物件 student2 = Student('Bob', 85) // 建立第二個學生物件\n→ Step 10: 呼叫 student2.show_info() // 呼叫方法顯示第二個學生資訊\nEnd // 程式執行結束\n\nBut we need to use arrows like \"→\" and maybe indent. The format example uses:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\nEnd // 程式執行結束\n\nThus we need to format similarly. Use indentation for nested steps. For class definition and methods, use indentation accordingly.\n\nWe can do:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Student // 宣告 Student 類別\n    → Step 2: 定義 __init__(self, name, score) // 建構子\n        → Step 3: self.name = name // 初始化姓名\n        → Step 4: self.score = score // 初始化分數\n    → Step 5: 定義方法 show_info(self) // 顯示資訊\n        → Step 6: 輸出 f\"{self.name} 的分數是 {self.score}\" // 印出訊息\n→ Step 7: 建立物件 student1 = Student('Alice', 90) // 創建第一個物件\n→ Step 8: 呼叫 student1.show_info() // 顯示第一個物件資訊\n→ Step 9: 建立物件 student2 = Student('Bob', 85) // 創建第二個物件\n→ Step 10: 呼叫 student2.show_info() // 顯示第二個物件資訊\nEnd // 程式結束\n\nMake sure each line ends with comment. Also maintain spacing.\n\nWe'll output as per the required format.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Student // 宣告 Student 類別\n    → Step 2: 定義 __init__(self, name, score) // 建構子接收姓名與分數\n        → Step 3: self.name = name // 初始化姓名屬性\n        → Step 4: self.score = score // 初始化分數屬性\n    → Step 5: 定義方法 show_info(self) // 定義顯示資訊的方法\n        → Step 6: 輸出 f\"{self.name} 的分數是 {self.score}\" // 印出姓名與分數\n→ Step 7: 建立物件 student1 = Student('Alice', 90) // 創建第一個學生物件\n→ Step 8: 呼叫 student1.show_info() // 呼叫方法顯示第一個學生資訊\n→ Step 9: 建立物件 student2 = Student('Bob', 85) // 創建第二個學生物件\n→ Step 10: 呼叫 student2.show_info() // 呼叫方法顯示第二個學生資訊\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Student:\n    \"\"\"\n    學生類別，持有姓名與分數，並提供顯示資訊的方法。\n    \"\"\"\n    def __init__(self, name, score):\n        # 初始化姓名與分數\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        # 印出「姓名 的分數是 分數」的格式\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    # 讀取所有標準輸入（不管內容），以符合「必須讀入輸入」的規定\n    sys.stdin.read()\n\n    # 建立兩個學生物件\n    s1 = Student('Alice', 90)\n    s2 = Student('Bob', 80)\n\n    # 呼叫顯示方法\n    s1.show_info()\n    s2.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "success": true,
          "output": "Alice 的分數是 90\nBob 的分數是 80"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 1,
    "title": "動物類別繼承",
    "description_snippet": "請設計一個父類別 Animal，包含方法 make_sound()，印出『動物發出聲音』。\n建立子類別 Dog 與 Cat：\n1. Dog 覆寫 make_sound()，輸出『汪汪！』。\n2. Ca...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanations. No actual code, just steps. Use Start, End, Decision maybe but no decisions needed. Use → Step: . We'll include steps: define class Animal with method make_sound. Define class Dog inheriting Animal, override method. Similarly Cat. Instantiate dog = Dog(), cat = Cat(). Call dog.make_sound(), cat.make_sound(). End.\n\nWe need to use virtual code steps: Start // ...\n→ Step: Define Animal class // ...\n→ Step: Define Dog class inheriting Animal // ...\n→ Step: Override Dog's make_sound method // ...\n→ Step: Define Cat class inheriting Animal // ...\n→ Step: Override Cat's make_sound method // ...\n→ Step: Create dog instance // ...\n→ Step: Create cat instance // ...\n→ Step: Call dog.make_sound() // ...\n→ Step: Call cat.make_sound() // ...\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋.\n\nWe need to use arrow symbol →. For subclassing we can use → Step: Define Dog extends Animal // etc.\n\nNo decisions. That should suffice.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義 Animal 類別 // 建立基礎類別  \n→ Step: 在 Animal 裡新增 make_sound 方法，輸出『動物發出聲音』 // 基本動作  \n→ Step: 定義 Dog 類別，繼承自 Animal // 子類別建立  \n→ Step: 在 Dog 中覆寫 make_sound 方法，輸出『汪汪！』 // Dog 的特定聲音  \n→ Step: 定義 Cat 類別，繼承自 Animal // 另一個子類別  \n→ Step: 在 Cat 中覆寫 make_sound 方法，輸出『喵～』 // Cat 的特定聲音  \n→ Step: 建立 Dog 物件 dog = Dog() // 實例化 Dog  \n→ Step: 建立 Cat 物件 cat = Cat() // 實例化 Cat  \n→ Step: 呼叫 dog.make_sound() // 執行 Dog 的聲音  \n→ Step: 呼叫 cat.make_sound() // 執行 Cat 的聲音  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Animal:\n    \"\"\"基礎動物類別，提供 make_sound 方法。\"\"\"\n    def make_sound(self):\n        print('動物發出聲音')\n\nclass Dog(Animal):\n    \"\"\"Dog 類別，覆寫 make_sound，輸出『汪汪！』。\"\"\"\n    def make_sound(self):\n        print('汪汪！')\n\nclass Cat(Animal):\n    \"\"\"Cat 類別，覆寫 make_sound，輸出『喵～』。\"\"\"\n    def make_sound(self):\n        print('喵～')\n\ndef main():\n    # 讀取輸入（雖然此題不需要任何實際輸入，仍遵循要求）\n    sys.stdin.read()\n    \n    # 建立實例並呼叫聲音方法\n    dog = Dog()\n    cat = Cat()\n    dog.make_sound()\n    cat.make_sound()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "汪汪！\n喵～",
          "success": true,
          "output": "汪汪！\n喵～"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 0,
    "title": "溫度判斷",
    "description_snippet": "請寫一個程式，輸入一個整數代表氣溫，並依下列規則輸出：\n- 小於 0：『冰點以下』\n- 0~29：『正常範圍』\n- 30~39：『炎熱』\n- 大於等於 40：『極端高溫』...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines, each line with explanation. Use Start, Decision, Yes →, No →. Need to include arrows. Need to handle ranges.\n\nLet's produce something like:\n\nStart // start\n\n→ Input temperature // read int\n\n→ Decision: 如果溫度 < 0? // check\n\n    Yes → Output '冰點以下' // output\n\n    No → Decision: 如果溫度 <= 29? // check next range\n\n        Yes → Output '正常範圍'\n\n        No → Decision: 如果溫度 <= 39? // check\n\n            Yes → Output '炎熱'\n\n            No → Output '極端高溫'\n\nEnd\n\nAlso we need arrow indentations.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use the arrow symbols.\n\nWe need to output exactly as required.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input temperature // 讀取使用者輸入的整數氣溫  \n→ Decision: 溫度 < 0? // 檢查是否低於冰點  \n    Yes → Output '冰點以下' // 小於 0，輸出對應訊息  \n    No → Decision: 溫度 <= 29? // 檢查是否在 0~29 範圍  \n        Yes → Output '正常範圍' // 0~29，輸出正常訊息  \n        No → Decision: 溫度 <= 39? // 檢查是否在 30~39 範圍  \n            Yes → Output '炎熱' // 30~39，輸出炎熱訊息  \n            No → Output '極端高溫' // 40 以上，輸出極端高溫訊息  \nEnd // 程式執行結束",
      "generated_code": "def get_temperature_message(temp: int) -> str:\n    \"\"\"\n    根據氣溫回傳對應訊息。\n    \"\"\"\n    if temp < 0:\n        return \"冰點以下\"\n    elif temp < 30:\n        return \"正常範圍\"\n    elif temp < 40:\n        return \"炎熱\"\n    else:\n        return \"極端高溫\"\n\n\ndef main() -> None:\n    \"\"\"\n    讀取單個整數氣溫，輸出對應訊息。\n    \"\"\"\n    try:\n        temp = int(input().strip())\n    except ValueError:\n        # 若輸入非整數，直接終止\n        return\n    message = get_temperature_message(temp)\n    print(message)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "35",
          "expected_output": "炎熱",
          "success": true,
          "output": "炎熱"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 1,
    "title": "三數最大值",
    "description_snippet": "請寫一個程式，輸入三個整數，輸出其中最大的數字。不得使用 Python 內建 max()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step with explanations. Need Start, End, Decision. Steps: input three integers a,b,c. Then find max using comparisons. Could use nested if else. For example:\n\n1. Input a\n2. Input b\n3. Input c\n4. Set max = a\n5. Decision: b > max?\n   Yes -> max = b\n6. Decision: c > max?\n   Yes -> max = c\n7. Output max\n\nAlternatively we could chain decisions. But need to include Decision arrows.\n\nWe need to format each line with \"虛擬碼步驟 [space] // 解釋\". Use arrows: → for sequential, Decision: ... with Yes →, No →. Provide nested indentation but we can use spaces? In example, they show indentation but no special formatting requirement. We'll just indent with spaces before Yes/No lines.\n\nSo produce lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 a // 取得第一個整數\n→ Step 2: 輸入整數 b // 取得第二個整數\n→ Step 3: 輸入整數 c // 取得第三個整數\n→ Step 4: 設定 max = a // 先把 max 設為第一個整數\n→ Decision: 如果 b > max? // 比較第二個整數是否更大\n    Yes → Step 5: 設定 max = b // 如果 b 更大，更新 max\n    No  → // 什麼也不做，保持現有 max\n→ Decision: 如果 c > max? // 比較第三個整數是否更大\n    Yes → Step 6: 設定 max = c // 如果 c 更大，更新 max\n    No  → // 什麼也不做\n→ Step 7: 輸出 max // 顯示最大的整數\nEnd // 程式執行結束\n\nWe need to maintain format: \"虛擬碼步驟 // 解釋\". For Yes/No lines we also provide explanation? The example: Yes → Step ... // 解釋. No → Decision ... // ... But we can just follow. For \"No → // 什麼也不做\" we still need to write // 解釋, maybe \"保持原 max\".\n\nBut we can also omit No → step? Example shows No → Decision: If ... else. So for No we need to provide the alternative branch. But we might not need extra step if nothing to do. But it's okay to include No → // 什麼也不做.\n\nLet's produce as above.\n\nBe careful to keep \"虛擬碼步驟\" like \"Step 1: ...\" but maybe \"Step 1: 輸入整數 a\". Use \"Decision:\" lines. Use arrow \"Yes →\" \"No →\" lines. Provide explanation comment after each line. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 a // 取得第一個整數  \n→ Step 2: 輸入整數 b // 取得第二個整數  \n→ Step 3: 輸入整數 c // 取得第三個整數  \n→ Step 4: 設定 max = a // 初始時把最大值設為第一個整數  \n→ Decision: 如果 b > max? // 判斷第二個整數是否比目前最大值大  \n Yes → Step 5: 設定 max = b // 如果 b 更大，更新 max  \n No  → // 什麼也不做，保持原 max  \n→ Decision: 如果 c > max? // 判斷第三個整數是否比目前最大值大  \n Yes → Step 6: 設定 max = c // 如果 c 更大，更新 max  \n No  → // 什麼也不做，保持原 max  \n→ Step 7: 輸出 max // 顯示最大的整數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef find_max(a, b, c):\n    # 首先把 max_val 設為第一個整數\n    max_val = a\n    # 比較第二個整數是否更大\n    if b > max_val:\n        max_val = b\n    # 再比第三個整數是否更大\n    if c > max_val:\n        max_val = c\n    return max_val\n\ndef main():\n    # 從標準輸入讀取三個整數（允許任意空白分隔）\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, c = map(int, data[:3])\n    # 輸出最大值\n    print(find_max(a, b, c))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 25 7",
          "expected_output": "25",
          "success": true,
          "output": "25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 0,
    "title": "倍數輸出",
    "description_snippet": "請寫一個程式，輸入一個正整數 n，使用 for 迴圈搭配 range()，輸出 1~50 之間所有能被 n 整除的數字。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code in Chinese, with arrows, Start, End. Each line: virtual code + space + // explanation.\n\nWe need to handle input n, for loop 1 to 50 inclusive, check if i % n == 0, output i. Should be in Chinese.\n\nWe need to format exactly like example: Start // 程式開始執行\n→ Step 1: 輸入使用者數字 // ...\n→ Decision: ...\nUse \"Decision:\" lines with Yes →, No → etc.\n\nWe can just do:\n\nStart // 程式開始執行\n→ Step 1: 輸入正整數 n // 從使用者處取得一個正整數\n→ Step 2: 初始化範圍 1 至 50 // 設定迴圈範圍\n→ For i 在 range(1, 51) 循環 // 逐一檢查 1~50\n    → Decision: i 是否能被 n 整除? // 判斷可否整除\n        Yes → Step 3: 輸出 i // 若能整除則輸出該數字\n        No → // 不執行任何操作\nEnd // 程式執行結束\n\nBut we need to keep the syntax with arrow. We should use arrow \"→\" for normal steps, and inside for loop we need indentation with \"    \" and maybe \"Decision:\" lines. For example:\n\n→ For i 在 range(1, 51) 循環 // 逐一檢查 1~50\n    → Decision: i 能被 n 整除? // 判斷是否整除\n        Yes → Step 3: 輸出 i // 若能整除則輸出\n\nWe should ensure each line is a separate bullet.\n\nWe need to maintain the \"Step\" labeling only for major actions. For decision we can just use Decision lines. Use \"Yes →\", \"No →\". Provide explanation.\n\nThe last line: End // 程式執行結束\n\nWe should follow exactly \"虛擬碼步驟 [space] // 解釋/說明\".\n\nThus output will be:\n\nStart // 程式開始執行\n→ Step 1: 輸入正整數 n // 從使用者處取得一個正整數\n→ Step 2: 定義迴圈範圍 1 至 50 // 設定要檢查的數字範圍\n→ For i 在 range(1, 51) 循環 // 從 1 到 50 逐一檢查\n    → Decision: i 能被 n 整除? // 判斷 i 是否為 n 的倍數\n        Yes → Step 3: 輸出 i // 如果是，輸出該數字\n        No  → // 不是，繼續迴圈\nEnd // 程式執行結束\n\nMake sure indentation is preserved.\n\nWe need to output only the code lines, no extra text.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入正整數 n // 從使用者處取得一個正整數\n→ Step 2: 定義迴圈範圍 1 至 50 // 設定要檢查的數字範圍\n→ For i 在 range(1, 51) 循環 // 從 1 到 50 逐一檢查\n    → Decision: i 能被 n 整除? // 判斷 i 是否為 n 的倍數\n        Yes → Step 3: 輸出 i // 如果是，輸出該數字\n        No  → // 不是，繼續迴圈\nEnd // 程式執行結束",
      "generated_code": "def main():\n    n = int(input())\n    for i in range(1, 51):\n        if i % n == 0:\n            print(i, end=' ')\n    # Optional: print newline\n    print()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "7",
          "expected_output": "7 14 21 28 35 42 49",
          "success": true,
          "output": "7 14 21 28 35 42 49"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 1,
    "title": "密碼檢查",
    "description_snippet": "請寫一個程式，讓使用者重複輸入密碼，直到輸入正確的密碼 'python123' 為止。每次輸入錯誤都提示『密碼錯誤，請再試一次』，輸入正確時輸出『登入成功』。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Use Start, Decision, Yes, No, End, arrows. Each line: \"虛擬碼步驟 [space] // 解釋/說明\". Must be line by line.\n\nWe need to incorporate loop until correct password. Use Decision step: If password == 'python123'? If Yes → output success and End. If No → output error message and loop again.\n\nIn pseudocode: Start // begin\n→ Step 1: 輸入密碼 // get input\n→ Decision: 密碼是否為 'python123'? // check\n    Yes → Step 2: 輸出 '登入成功' // success\n    No  → Step 3: 輸出 '密碼錯誤，請再試一次' // error\n       → Step 4: 跳回 Step 1 // loop\n\nBut the arrow for loop maybe using \"→\" with the same step? We can use \"→ Step 1: 輸入密碼\" again. So we must show loop.\n\nLet's craft lines accordingly.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入密碼 // 從使用者取得密碼輸入\n→ Decision: 密碼是否等於 'python123'? // 檢查輸入是否正確\n    Yes → Step 2: 輸出 '登入成功' // 正確，顯示登入成功訊息\n    No  → Step 3: 輸出 '密碼錯誤，請再試一次' // 錯誤，提示再次輸入\n        → Step 1: 輸入密碼 // 回到輸入步驟，形成迴圈\nEnd // 程式執行結束\n\nBut we might need an explicit End after success? Since when success, program ends. So we need End after Step 2? Use \"End\" after Step 2? Or we can simply put End after the decision block. But if we put End after the decision block, the flow will still show that after success, it ends. However we might want to indicate End inside the Yes branch. According to example, they placed End after all branches. It's fine.\n\nAlternatively we can include \"→ End // 程式執行結束\" inside Yes branch. But they used End after decision block.\n\nBetter to add End after Decision block. Provide clarity.\n\nBut we also need to maintain indentation for branches. Use spaces to indent under Decision. Eg:\n\n→ Decision: 密碼是否等於 'python123'? // ...\n    Yes → Step 2: ...\n    No  → Step 3: ...\n        → Step 1: ...\n\nYes good.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入密碼 // 從使用者取得密碼輸入  \n→ Decision: 密碼是否等於 'python123'? // 檢查輸入是否正確  \n    Yes → Step 2: 輸出 '登入成功' // 正確，顯示登入成功訊息  \n    No → Step 3: 輸出 '密碼錯誤，請再試一次' // 錯誤，提示再次輸入  \n        → Step 1: 輸入密碼 // 回到輸入步驟，形成迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    correct_password = \"python123\"\n    while True:\n        try:\n            password = input()\n        except EOFError:\n            break  # 若無更多輸入，結束\n        if password == correct_password:\n            print(\"登入成功\")\n            break\n        else:\n            print(\"密碼錯誤，請再試一次\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "abc\n1234\npython123",
          "expected_output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功",
          "success": true,
          "output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 0,
    "title": "串列操作練習",
    "description_snippet": "請建立一個串列，內容包含整數 1 到 5，接著完成以下操作：\n1. 新增一個元素 6 到串列尾端。\n2. 刪除串列中的第 2 個元素（索引 1 的位置）。\n3. 輸出最後的串列結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output lines following the pattern: \"虛擬碼步驟 // 解釋\" with arrow. Use Start, End, Decision. No actual code. Steps: Start, create list with 1-5, add 6, delete index 1, output list, End. No decisions needed. Ensure each line ends with // explanation. Provide line numbers? Not needed. Just each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立串列 List = [1, 2, 3, 4, 5] // 初始化包含整數 1 到 5 的串列  \n→ Step 2: 在 List 末尾新增元素 6 → List.append(6) // 將 6 加入串列尾端  \n→ Step 3: 刪除 List 中索引為 1 的元素 → List.pop(1) // 刪除第二個元素（值為 2）  \n→ Step 4: 輸出 List // 顯示最後的串列結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入，雖然此題目不需要輸入，但按規範先讀取並忽略\n    _ = sys.stdin.read()\n\n    # 建立包含 1 到 5 的串列\n    nums = [1, 2, 3, 4, 5]\n\n    # 在串列尾端新增 6\n    nums.append(6)\n\n    # 刪除索引 1 的元素（即第二個元素）\n    del nums[1]\n\n    # 輸出最後的串列\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[1, 3, 4, 5, 6]",
          "success": true,
          "output": "[1, 3, 4, 5, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 1,
    "title": "集合函數練習",
    "description_snippet": "請建立一個集合 fruits = {'apple', 'banana'}，並完成以下操作：\n1. 使用 add() 新增 'orange'。\n2. 使用 update() 一次新增 'grape' 與...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user asks for virtual code steps, not actual code. We need to output line by line with virtual code and comments. Format:\n\nStart\n→ Step: define set\n→ Step: add orange\n→ Step: update with grape, melon\n→ Step: remove banana\n→ Step: discard pineapple\n→ Step: print set\nEnd\n\nBut need to use arrow notation: \"Start // 程式開始執行\" etc. Also we must include 'Step' labeling? The example uses \"Step 1:\" etc. We'll follow similar style. We need to provide the virtual code steps. The code is not actual Python but virtual steps. Use \"→\" arrow and \"Decision:\" only if condition. But no decisions needed.\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: 定義集合 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'，不拋錯誤\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式執行結束\n\nYes. Use \"→ Step N:\" exactly. Also after each line, add comment. Use \" // \" separation. Good.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義集合 fruits = {'apple', 'banana'} // 初始化集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'，不拋錯誤  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有輸入（若有）但不使用，確保符合「從 stdin 讀取」的要求\n    sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 使用 update() 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 使用 discard() 嘗試移除不存在的 'pineapple'（不拋錯誤）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "success": true,
          "output": "{'apple', 'orange', 'grape', 'melon'}"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 0,
    "title": "質數判斷函數",
    "description_snippet": "請寫一個函數 is_prime(n)，判斷一個整數是否為質數。如果是質數回傳 True，否則回傳 False。\n\n質數定義：大於 1，且除了 1 和自己本身外，沒有其他因數。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. Use structure: Start, End, Decision, Steps. The function is_prime(n). Steps: check n <= 1 return False. Then iterate i from 2 to sqrt(n). If n % i == 0 return False. After loop return True.\n\nWe must not output actual code, just virtual code.\n\nUse each line: virtual code step + space + // explanation. Use arrow, decisions, etc.\n\nWe need to adhere to format: Start, End.\n\nWe'll include function definition? Use \"Step 1: 定義函式 is_prime(n)\". Might be okay.\n\nWe'll produce step lines.\n\nAlso for loop: \"Decision: i ≤ sqrt(n)?\" etc.\n\nLet's craft.\n\nWe must ensure each line contains \"虛擬碼步驟\" then space then comment. Use arrow for flow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 is_prime(n) // 建立判斷質數的函式  \n→ Decision: n <= 1? // 檢查數字是否小於等於 1  \n  Yes → Step 2: 回傳 False // 小於等於 1 不是質數  \n  No → Step 3: 設定 i = 2 // 初始化除數 i 為 2  \n→ Decision: i * i <= n? // 判斷 i 是否小於等於 n 的平方根  \n  Yes → Decision: n mod i == 0? // 檢查 n 是否被 i 整除  \n    Yes → Step 4: 回傳 False // 找到因數，非質數  \n    No → Step 5: i = i + 1 // i 加 1，繼續尋找因數  \n  No → Step 6: 回傳 True // 未找到任何因數，為質數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef is_prime(n):\n    \"\"\"判斷 n 是否為質數，若是回傳 True，否則回傳 False。\"\"\"\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef main():\n    \"\"\"從標準輸入讀取程式碼並執行，將結果輸出到標準輸出。\"\"\"\n    code = sys.stdin.read()\n    if code:\n        # 執行讀取到的程式碼，假設其中會呼叫 is_prime 函式\n        exec(code)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(is_prime(7))\nprint(is_prime(12))",
          "expected_output": "True\nFalse",
          "success": true,
          "output": "True\nFalse"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 1,
    "title": "計算平均分數",
    "description_snippet": "請寫一個函數 calc_avg(*scores)，接收多個分數作為參數，並回傳平均值 (四捨五入到小數點後 2 位)。\n\n限制：不可使用內建函數 sum()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with arrows. For a function calc_avg(*scores) that calculates average of variable number of scores, without using sum(). So we need to iterate over scores, sum manually. Then divide by len(scores). Round to 2 decimals (likely use round() but that is built-in? round is built-in but allowed maybe; the restriction only sum() cannot be used. So we can use round). Should be fine.\n\nNeed to use virtual code with arrows. Start, End, Decision.\n\nLet's produce step-by-step: Start, function definition, Step: initialize total = 0, Step: for each score in scores, add to total, Step: calculate count = len(scores), Step: average = total / count, Step: rounded = round(average, 2), Step: return rounded, End.\n\nWe need to include explanation after each line.\n\nWe also need to format each line with arrow and comment.\n\nMake sure each line has arrow like \"→\" or \"Decision:\".\n\nWe don't need Decision unless needed. But maybe we could add Decision to handle zero scores? But not specified; but we might include check for empty scores to avoid division by zero. Could add Decision: if count == 0? Yes -> return 0? or error? We'll keep simple: assume at least one score. But we can still include Decision for robustness.\n\nBut the instruction: produce virtual code steps, no actual code. So we can include a Decision: if len(scores) == 0? etc.\n\nLet's craft:\n\nStart\n→ Step: 定義函數 calc_avg(*scores) // 定義可變參數函數\n→ Step: 初始化 total = 0 // 用於累加分數\n→ Step: 初始化 count = 0 // 用於計算分數個數\n→ Step: 對於每個 score in scores\n    → Step: total = total + score // 加總分數\n    → Step: count = count + 1 // 計數\n→ Decision: 如果 count == 0? // 檢查是否傳入任何分數\n    Yes → Step: return 0 // 無分數時回傳 0\n    No  → Step: average = total / count // 計算平均值\n→ Step: rounded = round(average, 2) // 四捨五入到小數點後兩位\n→ Step: return rounded // 回傳結果\nEnd\n\nMake sure each line ends with comment.\n\nAlso need to use correct arrows: The first line Start. For each subsequent step, use arrow \"→\". For Decision lines, use \"Decision:\" and indent lines. We need to reflect arrow \"→\" before each inner step.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 定義函數 calc_avg(*scores) // 定義接收任意數量分數的函式\n→ Step: 初始化 total = 0 // 用於累加所有分數\n→ Step: 初始化 count = 0 // 用於計算分數的個數\n→ Step: 對於每個 score in scores // 遍歷所有傳入的分數\n    → Step: total = total + score // 將分數加入累加總和\n    → Step: count = count + 1 // 分數個數遞增\n→ Decision: 如果 count == 0? // 檢查是否有傳入任何分數\n    Yes → Step: return 0 // 若無分數，回傳 0 作為預設值\n    No  → Step: average = total / count // 計算平均值\n→ Step: rounded = round(average, 2) // 將平均值四捨五入至小數點後兩位\n→ Step: return rounded // 回傳最終計算結果\nEnd // 程式執行結束",
      "generated_code": "def calc_avg(*scores):\n    \"\"\"\n    計算多個分數的平均值，結果四捨五入到小數點後兩位。\n    不使用內建 sum()。\n    \"\"\"\n    total = 0   # 分數累加總和\n    count = 0   # 分數個數\n    for s in scores:\n        total += s\n        count += 1\n    if count == 0:\n        return 0\n    average = total / count\n    return round(average, 2)\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 讀取所有輸入並執行，假設輸入是合法的程式碼\n    # 例如：print(calc_avg(80, 90, 100))\n    data = sys.stdin.read()\n    if data:\n        exec(data, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(calc_avg(80, 90, 100))\nprint(calc_avg(70, 75, 85, 95))",
          "expected_output": "90.0\n81.25",
          "success": true,
          "output": "90.0\n81.25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 0,
    "title": "列表與條件生成式練習",
    "description_snippet": "請寫一個程式，建立一個包含 1 到 20 的整數列表，接著使用列表生成式（List Comprehension）產生一個新列表，只保留偶數並將它們平方後輸出結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format: each line with code step and comment. Use arrows →, Decision:, Start, End. The requirement: create list 1-20, use list comprehension to keep evens and square them, output result. So steps: Start, Step 1: create list, Step 2: list comprehension to filter even and square, Step 3: output result, End.\n\nAlso maybe include Decision? Not necessary. But we can show optional Decision: maybe check if list not empty? But not required. We'll produce simple linear steps.\n\nMake sure each line has '虛擬碼步驟' and comment. Provide Chinese explanation. Use virtual code arrow. Provide Start, End. We'll produce 5-6 lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Create numbers_list = [1, 2, …, 20] // 建立 1 到 20 的整數列表\n→ Step 2: squares_of_even = [x * x for x in numbers_list if x % 2 == 0] // 使用列表生成式過濾偶數並平方\n→ Step 3: Output squares_of_even // 輸出新列表\nEnd // 程式執行結束\n\nMake sure each line uses '→' except Start and End. Provide comment after //. Use Chinese. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: numbers_list = [1, 2, 3, …, 20] // 建立 1 到 20 的整數列表  \n→ Step 2: squares_of_even = [x * x for x in numbers_list if x % 2 == 0] // 使用列表生成式過濾偶數並平方  \n→ Step 3: Output squares_of_even // 輸出新列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin，但此題目不需要實際資料，僅確保讀取過程不會阻塞\n    sys.stdin.read()\n    # 建立 1~20 的整數列表\n    numbers = list(range(1, 21))\n    # 只保留偶數並平方\n    squares_of_even = [n * n for n in numbers if n % 2 == 0]\n    # 輸出結果\n    print(squares_of_even)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]",
          "success": true,
          "output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 1,
    "title": "map() / filter() / lambda 綜合練習",
    "description_snippet": "請寫一個程式，建立一個列表 numbers = [3, 7, 10, 15, 20]。\n1. 使用 filter() 搭配 lambda 篩選出可被 5 整除的數。\n2. 使用 map() 將這些數字...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Use virtual code arrow, Start, End, Decision etc. It's a simple procedure: create list, filter with lambda, map multiply, output. Use filter and map. We might include lambda and use variable names. Steps: Start, define numbers list, filter step, map step, output step, End. Provide explanation comments after each line. Use arrow \"→\". Use indentation for decisions? Not necessary. Use \"Step\" lines. Provide explanation after space. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: numbers ← [3, 7, 10, 15, 20] // 初始化數字列表\n→ Step 2: filtered ← filter(lambda x: x % 5 == 0, numbers) // 篩選能被 5 整除的數字\n→ Step 3: multiplied ← map(lambda x: x * 10, filtered) // 將篩選後的數字乘以 10\n→ Step 4: result ← list(multiplied) // 將 map 物件轉為列表以便輸出\n→ Step 5: print(result) // 輸出最終結果\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin（如果有輸入）但不使用它，確保程式可以接受任何輸入\n    _ = sys.stdin.read()\n\n    # 建立原始數字列表\n    numbers = [3, 7, 10, 15, 20]\n\n    # 使用 filter 與 lambda 篩選出能被 5 整除的數字\n    filtered = filter(lambda x: x % 5 == 0, numbers)\n\n    # 使用 map 與 lambda 把篩選後的數字乘以 10\n    result = list(map(lambda x: x * 10, filtered))\n\n    # 輸出最終結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[100, 150, 200]",
          "success": true,
          "output": "[100, 150, 200]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 0,
    "title": "JSON 檔案儲存與讀取練習",
    "description_snippet": "請寫一個程式，建立一個字典 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}。\n1. 使用 json.dump() 將其寫入 data.jso...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps per line with explanation. Use arrow. Steps: Start, Step 1: define dict, Step 2: open file for write, json.dump, Step 3: close, Step 4: open file for read, json.load, Step 5: print name and city, End. Use arrow formatting. Ensure each line has \"虛擬碼步驟 [space] // 解釋\". Use 虛擬碼 arrow \"→\". For decisions none. Just linear.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立字典\n→ Step 2: 開啟檔案 'data.json' 以寫入模式 // 準備寫入 JSON\n→ Step 3: 使用 json.dump(data, 檔案) // 將字典寫入檔案\n→ Step 4: 關閉檔案 // 完成寫入\n→ Step 5: 開啟檔案 'data.json' 以讀取模式 // 準備讀取 JSON\n→ Step 6: 使用 json.load(檔案) 並存於 loaded_data // 讀取並解析\n→ Step 7: 印出 loaded_data['name'] 與 loaded_data['city'] // 顯示 name 與 city\nEnd // 程式執行結束\n\nMake sure to keep the format exactly. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立字典\n→ Step 2: 開啟檔案 'data.json' 以寫入模式 // 準備寫入 JSON\n→ Step 3: 使用 json.dump(data, 檔案) // 將字典寫入檔案\n→ Step 4: 關閉檔案 // 完成寫入\n→ Step 5: 開啟檔案 'data.json' 以讀取模式 // 準備讀取 JSON\n→ Step 6: 使用 json.load(檔案) 並存於 loaded_data // 讀取並解析\n→ Step 7: 印出 loaded_data['name'] 與 loaded_data['city'] // 顯示 name 與 city\nEnd // 程式執行結束",
      "generated_code": "import json\nimport sys\n\ndef main() -> None:\n    # 讀取標準輸入（如果有提供，否則忽略）\n    _ = sys.stdin.read()\n\n    # 建立字典資料\n    data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}\n\n    # 1️⃣ 寫入 JSON 檔案\n    with open('data.json', 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=2)\n\n    # 2️⃣ 讀取 JSON 檔案\n    with open('data.json', 'r', encoding='utf-8') as f:\n        result = json.load(f)\n\n    # 輸出結果\n    print('姓名：', result['name'])\n    print('城市：', result['city'])\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "姓名： Alice\n城市： Taipei",
          "success": true,
          "output": "姓名： Alice\n城市： Taipei"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 1,
    "title": "即時匯率查詢小工具",
    "description_snippet": "請使用 requests 模組串接匯率 API（https://api.exchangerate-api.com/v4/latest/USD），取得當前美元兌換台幣（TWD）的匯率。\n將結果顯示在 t...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, with arrow and decision, etc. The code involves requests, tkinter, button click to update exchange rate from API. Use Start, End. Each line: \"虛擬碼步驟 // 解釋\". Use arrow (→). So produce something like:\n\nStart // 程式開始執行\n→ Step 1: 匯入 requests, tkinter, json // 導入必要模組\n→ Step 2: 定義函式 fetch_rate() // 函式取得匯率\n→ Decision: 是否成功取得 API 響應? // 檢查請求是否成功\n    Yes → Step 3: 解析 JSON 並取出 TWD 交換率 // 取得匯率值\n    No → Step 4: 返回 '無法取得匯率' // 錯誤處理\n→ Step 5: 定義函式 update_label() // 更新視窗顯示\n→ Step 6: 建立 tkinter 視窗 root // 初始化 GUI\n→ Step 7: 建立 label 以顯示匯率 // 文字顯示\n→ Step 8: 建立按鈕，點擊時呼叫 update_label // 互動按鈕\n→ Step 9: 初次顯示匯率 (呼叫 update_label) // 讓初始畫面有值\n→ Step 10: 啟動 mainloop // 進入事件循環\nEnd // 程式結束\n\nBut must include arrows like →. The decision block: indent and use Yes → ... No → ... Provide comments. Also must use Start and End. Use each line as separate line. Use the virtual code syntax: \"→ Step 1: ...\". The decision: \"Decision:\" line and then indent. Use \"Yes →\" and \"No →\" lines. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests、tkinter、json // 導入網路請求、GUI 與 JSON 處理模組  \n→ Step 2: 定義函式 fetch_rate() // 用來向匯率 API 發送請求並回傳 TWD 匯率  \n→ Decision: 取得 API 響應成功? // 檢查 HTTP 狀態碼是否為 200  \n    Yes → Step 3: 解析 JSON 並提取 TWD 兌換率 // 從回傳資料中抓取匯率值  \n    No → Step 4: 返回 '無法取得匯率' // 失敗時返回錯誤訊息  \n→ Step 5: 定義函式 update_label() // 取得最新匯率並更新 tkinter 標籤內容  \n→ Step 6: 建立 tkinter 主視窗 root // 初始化 GUI 主視窗  \n→ Step 7: 建立 label widget 顯示匯率 // 用於呈現匯率訊息  \n→ Step 8: 建立按鈕 widget，點擊時執行 update_label() // 供使用者手動更新  \n→ Step 9: 初次呼叫 update_label() 以顯示當前匯率 // 在啟動時顯示一次  \n→ Step 10: 執行 root.mainloop() // 進入 tkinter 事件循環等待使用者互動  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"向匯率 API 取得美元兌台幣的匯率，回傳格式化字串。\"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        resp = requests.get(url, timeout=5)\n        resp.raise_for_status()\n        data = resp.json()\n        rate = data['rates']['TWD']\n        return f'目前美元匯率：約 {rate:.4f} TWD'\n    except Exception:\n        return '更新失敗，請檢查網路連線'\n\ndef gui_app():\n    \"\"\"啟動 tkinter GUI，顯示匯率並提供更新按鈕。\"\"\"\n    root = tk.Tk()\n    root.title('匯率查詢')\n\n    label = tk.Label(root, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label():\n        label.config(text=fetch_rate())\n\n    tk.Button(root, text='更新匯率', command=update_label).pack(pady=5)\n\n    # 初始時即更新一次\n    update_label()\n    root.mainloop()\n\ndef main():\n    \"\"\"主執行區塊，從標準輸入讀取資料並輸出結果；若無輸入則啟動 GUI。\"\"\"\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        # 若收到任何輸入，視為「按下更新匯率」指令，直接印出結果\n        print(fetch_rate())\n    else:\n        gui_app()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.7800TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.7800 TWD'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode306.json",
    "problem_index_in_file": 0,
    "title": "Additive Number",
    "description_snippet": "An additive number is a string whose digits can form an additive sequence.\n\nA valid additive sequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for checking additive number. Use recursion/backtracking. Steps: Start, parse first number i from 1 to len-2, second number j from i+1 to len-1, ensure no leading zeros. Then loop: compute sum = first+second, convert to string; check if s starts with that at position j+len(second). If yes, move forward: set first=second, second=sum, pos=next. If reach end and at least 3 numbers, return true. If no, backtrack. If all combinations fail, return false.\n\nWe need line-by-line with explanation after comment. Use virtual code arrows etc. Let's produce.\n\nWe must not output actual code, only virtual code steps.\n\nWe should include loops: for first length i, for second length j, decision for leading zero, while loop for matching sums.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Let s be input string // 取得輸入字串\n→ Step 2: Let n = length of s // 取得字串長度\n→ Decision: n < 3? // 檢查是否至少能組成三個數\n    Yes → Return false // 字串太短，無法成為加法數字\n    No  → Continue // 字串長度足夠，進行後續處理\n→ Step 3: For i from 1 to n-2 // 設定第一個數的長度\n    → Decision: s[0] == '0' and i > 1? // 第一個數不能有前導零\n        Yes → Continue // 跳過此長度\n        No  → Continue // 合法長度，繼續\n    → Step 4: first = substring s[0:i] // 取得第一個數\n    → Step 5: For j from i+1 to n-1 // 設定第二個數的長度\n        → Decision: s[i] == '0' and (j-i) > 1? // 第二個數不能有前導零\n            Yes → Continue // 跳過此長度\n            No  → Continue // 合法長度\n        → Step 6: second = substring s[i:j] // 取得第二個數\n        → Step 7: pos = j // 下一個起始位置\n        → Step 8: count = 2 // 已形成兩個數\n        → Decision: pos == n? // 若已到字串末尾但數量不足三個\n            Yes → Continue // 無效組合，回到下一個第二數\n            No  → Continue // 進行匹配\n        → While pos < n // 只要還有字元未處理\n            → Step 9: sum = first + second // 計算前兩個數之和\n            → Step 10: sumStr = string representation of sum // 將和轉成字串\n            → Decision: s starting at pos has prefix sumStr? // 檢查後續字串是否以和為前綴\n                Yes → \n                    → Step 11: pos += length of sumStr // 移動位置至下一個數\n                    → Step 12: first = second // 更新第一個數\n                    → Step 13: second = sum // 更新第二個數\n                    → Step 14: count += 1 // 數量加一\n                No → Break // 無法匹配，結束此 while\n        → Decision: pos == n and count >= 3? // 完成字串且至少三個數\n            Yes → Return true // 找到合法加法數列\n            No  → Continue // 失敗，嘗試其他組合\n→ End // 所有組合都失敗，返回 false\nReturn false // 未找到合法加法數列\n\nNeed to include return false at end? Use Step.\n\nWe must adhere to format: Each line \"虛擬碼步驟 // 解釋\". Use arrows and decision indentation.\n\nWe should include \"→\" arrow for step lines; decisions use \"Decision:\" with indent and Yes→, No→.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let s be input string // 取得輸入字串  \n→ Step 2: Let n = length of s // 取得字串長度  \n→ Decision: n < 3? // 檢查字串是否至少能組成三個數  \n Yes → Return false // 字串太短，無法成為加法數字  \n No  → Continue // 字串長度足夠，進行後續處理  \n→ Step 3: For i from 1 to n-2 // 設定第一個數的長度  \n → Decision: s[0] == '0' and i > 1? // 第一個數不能有前導零  \n  Yes → Continue // 跳過此長度  \n  No  → Continue // 合法長度，繼續  \n → Step 4: first = substring s[0:i] // 取得第一個數  \n → Step 5: For j from i+1 to n-1 // 設定第二個數的長度  \n  → Decision: s[i] == '0' and (j-i) > 1? // 第二個數不能有前導零  \n   Yes → Continue // 跳過此長度  \n   No  → Continue // 合法長度  \n  → Step 6: second = substring s[i:j] // 取得第二個數  \n  → Step 7: pos = j // 下一個起始位置  \n  → Step 8: count = 2 // 已形成兩個數  \n  → Decision: pos == n? // 若已到字串末尾但數量不足三個  \n   Yes → Continue // 無效組合，回到下一個第二數  \n   No  → Continue // 進行匹配  \n  → While pos < n // 只要還有字元未處理  \n   → Step 9: sum = first + second // 計算前兩個數之和  \n   → Step 10: sumStr = string representation of sum // 將和轉成字串  \n   → Decision: s starting at pos has prefix sumStr? // 檢查後續字串是否以和為前綴  \n    Yes →  \n     → Step 11: pos += length of sumStr // 移動位置至下一個數  \n     → Step 12: first = second // 更新第一個數  \n     → Step 13: second = sum // 更新第二個數  \n     → Step 14: count += 1 // 數量加一  \n    No → Break // 無法匹配，結束此 while  \n  → Decision: pos == n and count >= 3? // 完成字串且至少三個數  \n   Yes → Return true // 找到合法加法數列  \n   No  → Continue // 失敗，嘗試其他組合  \n→ End // 所有組合都失敗，返回 false  \nReturn false // 未找到合法加法數列",
      "generated_code": "import sys\n\nclass Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        n = len(num)\n        # 嘗試所有可能的前兩個數字切分\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                num1, num2 = num[:i], num[i:j]\n\n                # 避免前導零\n                if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n                    continue\n\n                k = j\n                # 從第三個數開始驗證加法序列\n                while k < n:\n                    sum_str = str(int(num1) + int(num2))\n                    if not num.startswith(sum_str, k):\n                        break\n                    k += len(sum_str)\n                    num1, num2 = num2, sum_str\n\n                # 如果走到字串結尾，說明成功\n                if k == n:\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 如果輸入包含引號，去除它們\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n    # 直接使用 Solution 判斷\n    result = Solution().isAdditiveNumber(raw_input)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"112358\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"199100199\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode739.json",
    "problem_index_in_file": 0,
    "title": "Daily Temperatures",
    "description_snippet": "Given an array of integers temperatures represents the daily temperatures, return an array answer su...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for \"Daily Temperatures\" problem, similar to Leetcode 739. Use stack. Output step-by-step virtual code with comments.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows.\n\nLet's craft:\n\nStart\n→ Initialize answer array with zeros length n\n→ Initialize empty stack (indices)\n→ For each index i from 0 to n-1:\n    → While stack not empty and temps[i] > temps[stack.top]:\n        → j = stack.pop\n        → answer[j] = i - j\n    → Push i onto stack\nEnd\n\nBut we need to include decisions and loops. Provide step-by-step with arrows.\n\nUse \"Decision:\" for while condition. Also include \"For i\" loop.\n\nLet's produce:\n\nStart // 程式開始\n→ Decision: 取得溫度陣列長度 n? // 確定陣列長度\n    Yes → Step 1: 建立 answer 陣列，長度 n，所有值 0 // 用於儲存結果\n    No  → Step 1: 直接 End // 陣列為空，結束\n→ Step 2: 建立空棧 stack 用於存放索引 // 追蹤未遇到更熱天的日子\n→ For i 從 0 到 n-1: // 逐日處理\n    → Decision: stack 非空且 temps[i] > temps[stack.top]? // 判斷是否比堆頂更熱\n        Yes →\n            → Step 3: j ← stack.pop() // 取出上一個更冷天的索引\n            → Step 4: answer[j] ← i - j // 計算距離\n            → 回到 Decision  // 重新檢查堆頂\n        No →\n            → Step 5: stack.push(i) // 將當前天數索引推入棧\n→ End // 完成所有天數處理\n\nBut need arrows and formatting consistent. Use \"→\" for each step and \"Decision:\" with indentation. Use \"Yes →\" and \"No →\".\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 溫度陣列長度 n 為何? // 確定陣列大小  \n&nbsp;&nbsp;Yes → Step 1: 建立 answer 陣列，長度為 n，所有值初始化為 0 // 用於儲存答案  \n&nbsp;&nbsp;No  → End // 若陣列長度為 0，直接結束  \n→ Step 2: 建立空棧 stack 用於存放尚未找到更熱天的索引 // 準備工作  \n→ For i 從 0 到 n-1: // 逐日處理  \n&nbsp;&nbsp;Decision: stack 非空且 temps[i] > temps[stack.top]? // 判斷是否比棧頂更熱  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 3: j ← stack.pop() // 取出先前索引  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 4: answer[j] ← i - j // 計算天數差並存入答案  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到 Decision // 重新檢查新的棧頂  \n&nbsp;&nbsp;&nbsp;&nbsp;No  →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 5: stack.push(i) // 將當前索引推入棧  \n→ End // 所有天數處理完成，程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def dailyTemperatures(self, temperatures):\n        n = len(temperatures)\n        res = [0] * n\n        stack = []\n        for i in range(n):\n            while stack and temperatures[i] > temperatures[stack[-1]]:\n                idx = stack.pop()\n                res[idx] = i - idx\n            stack.append(i)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        sys.exit()\n    # 解析輸入，支持類似 [73,74,75] 的格式\n    temperatures = ast.literal_eval(data)\n    result = Solution().dailyTemperatures(temperatures)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[73,74,75,71,69,72,76,73]",
          "expected_output": "[1,1,4,2,1,1,0,0]",
          "success": true,
          "output": "[1, 1, 4, 2, 1, 1, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "[30,40,50,60]",
          "expected_output": "[1,1,1,0]",
          "success": true,
          "output": "[1, 1, 1, 0]"
        },
        {
          "example_index": 2,
          "input": "[30,60,90]",
          "expected_output": "[1,1,0]",
          "success": true,
          "output": "[1, 1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode71.json",
    "problem_index_in_file": 0,
    "title": "Simplify Path",
    "description_snippet": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Y...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm steps to simplify Unix path. Steps: split by '/', iterate components, use stack. Skip empty and '.' ; for '..' pop if stack not empty; else push component. After loop, join stack with '/' prefix. If empty return '/'. Provide step-by-step.\n\nWe need to output each line in format: `虛擬碼步驟 // 解釋`. Use arrows: `Start`, `→ Step 1...`, `Decision`, etc. Provide multiple lines. Use `Decision:` with Yes/No arrows.\n\nLet's craft.\n\nLines:\n\nStart\n→ Step 1: 將輸入路徑以 '/' 為分隔符切分為分段 // 分割路徑\n→ Step 2: 初始化空棧 stack 用於存儲合法目錄名稱 // 佈建棧\n→ Step 3: 對於切分得到的每一段 component 做處理 // 遍歷\n    → Decision: 如果 component 為空字串或 '.'? // 判斷無效/當前\n        Yes → Continue // 跳過\n    → Decision: 如果 component 為 '..'? // 判斷上一層\n        Yes → Decision: stack 是否非空?\n            Yes → Pop stack // 往上一層\n            No → Continue // 若在根，忽略\n    → Decision: 否則 // 有效目錄/檔名\n        Yes → Push component onto stack // 添加\n→ Step 4: 建立結果路徑 result 為 '/' + join(stack, '/') // 組裝\n→ Decision: 如果 result 為空? // 檢查是否仍空\n    Yes → result = '/' // 根目錄\n→ End // 返回結果\n\nWe need each line separated. Use indentation for nested decisions. Let's format properly.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入路徑以 '/' 為分隔符切分為分段 // 分割路徑成各個片段  \n→ Step 2: 初始化空棧 stack 用於存儲合法目錄名稱 // 準備存放有效目錄  \n→ Step 3: 對於切分得到的每一段 component 做處理 // 逐一檢查各片段  \n  → Decision: 如果 component 為空字串或 '.'? // 判斷無效或當前目錄  \n    Yes → Continue // 跳過此片段  \n  → Decision: 如果 component 為 '..'? // 判斷返回上一層  \n    Yes → Decision: stack 是否非空?  \n      Yes → Pop stack // 從棧中移除上一層目錄  \n      No → Continue // 已在根目錄，忽略  \n  → Decision: 否則 // component 為有效目錄或檔名  \n    Yes → Push component onto stack // 加入棧中  \n→ Step 4: 建立結果路徑 result 為 '/' + join(stack, '/') // 用 '/' 連接棧內容  \n→ Decision: 如果 result 為空? // 檢查是否還是空棧  \n  Yes → result = '/' // 只剩根目錄  \n→ End // 程式執行結束並返回 result",
      "generated_code": "import sys\nimport re\n\ndef simplify_path(path: str) -> str:\n    \"\"\"Return the canonical simplified Unix path.\"\"\"\n    stack = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue\n        if part == '..':\n            if stack:\n                stack.pop()\n        else:\n            stack.append(part)\n    return '/' + '/'.join(stack)\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the path string between the first pair of double quotes\n    match = re.search(r'\\\"([^\"]*)\\\"', data)\n    if not match:\n        # If no quoted string, treat the whole input as the path\n        path = data\n    else:\n        path = match.group(1)\n\n    result = simplify_path(path)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "path = \"/home/\"",
          "expected_output": "\"/home\"",
          "success": true,
          "output": "/home"
        },
        {
          "example_index": 1,
          "input": "path = \"/home//foo/\"",
          "expected_output": "\"/home/foo\"",
          "success": true,
          "output": "/home/foo"
        },
        {
          "example_index": 2,
          "input": "path = \"/home/user/Documents/../Pictures\"",
          "expected_output": "\"/home/user/Pictures\"",
          "success": true,
          "output": "/home/user/Pictures"
        },
        {
          "example_index": 3,
          "input": "path = \"/../\"",
          "expected_output": "\"/\"",
          "success": true,
          "output": "/"
        },
        {
          "example_index": 4,
          "input": "path = \"/.../a/../b/c/../d/./\"",
          "expected_output": "\"/.../b/d\"",
          "success": true,
          "output": "/.../b/d"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode347.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Elements",
    "description_snippet": "Given an integer array nums and an integer k, return the k most frequent elements. You may return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation comments. Use Start, Decision, etc. Outline: input array and k. Count frequencies, use a hash map. Build list of pairs. Sort by freq descending. Pick first k elements. Return. But we need to produce virtual code steps. Must be line-by-line, each with \"→ Step\" maybe. Use Decision for if statements. Use loops. Use Start and End.\n\nWe need to avoid actual code but produce steps.\n\nLet's produce:\n\nStart\n→ Step 1: 接收輸入 nums, k\n→ Step 2: 初始化空字典 freqMap // 存儲每個數字的頻率\n→ Step 3: 對 nums 進行遍歷\n    → Step 3.1: 對於每個 num，若 freqMap 已含 key，頻率加 1，否則設為 1\n→ Step 4: 將 freqMap 轉換為列表 of (num, count) // 方便排序\n→ Step 5: 對列表進行排序，按 count 降序\n→ Step 6: 取前 k 個元素的 num 值\n→ Step 7: 將結果存入 result 列表\n→ Step 8: 回傳 result\nEnd\n\nBut we need to use arrows, decisions etc. For loops maybe \"For each\". Use Decision if freqMap contains key. Provide simple explanation.\n\nAdd line numbers? Not necessary.\n\nLet's produce each line with explanation. Use \"→\" at start.\n\nMake sure each line ends with \"// 解釋\". Provide step names like \"Step 1\", etc.\n\nMake sure to include Start, End.\n\nAdd \"Decision:\" lines where needed.\n\nAlso need to keep each line as single virtual code step, not multi-lines.\n\nFor loops we can represent as \"→ Step: For each num in nums\" but we may break into inner decision. We'll keep simple.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 nums 與整數 k // 取得題目給定的參數\n→ Step 2: 初始化空字典 freqMap // 用來儲存每個數字的出現頻率\n→ Step 3: For each num in nums // 遍歷整個陣列\n    → Decision: freqMap 包含 key num? // 判斷此數字是否已經被計數\n        Yes → Step 3a: freqMap[num] ← freqMap[num] + 1 // 若已存在，頻率加 1\n        No  → Step 3b: freqMap[num] ← 1 // 若不存在，初始化頻率為 1\n→ Step 4: 將 freqMap 轉換為列表 pairList，元素為 (num, count) // 方便後續排序\n→ Step 5: pairList ← pairList sorted by count 降序 // 以頻率由高到低排序\n→ Step 6: result ← 空列表 // 用於存放前 k 個最常見的元素\n→ Step 7: For i from 0 to k-1 // 取排序後的前 k 個項目\n    → Step 7a: result.append(pairList[i].num) // 將數字加入結果\n→ Step 8: 回傳 result // 回傳 k 個最頻繁的元素\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        # Count frequency of each element\n        count = Counter(nums)\n        # Extract k items with highest frequency\n        return [item for item, freq in heapq.nlargest(k, count.items(), key=lambda x: x[1])]\n\ndef parse_input(data: str):\n    # 尝试解析形如 \"nums = [1,1,1,2,2,3], k = 2\" 的字符串\n    match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if match:\n        nums = ast.literal_eval(match.group(1))\n        k = int(match.group(2))\n        return nums, k\n\n    # 其它可能的输入格式：列表和整数分别在两行\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        nums = ast.literal_eval(lines[0])\n        k = int(lines[1])\n        return nums, k\n\n    # 无法解析，返回空\n    return [], 0\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    if nums and k:\n        sol = Solution()\n        result = sol.topKFrequent(nums, k)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode752.json",
    "problem_index_in_file": 0,
    "title": "Open the Lock",
    "description_snippet": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3',...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. This is essentially the LeetCode 752. We will produce BFS steps. The user wants virtual code with each line and explanation. No actual code, just pseudocode.\n\nWe need to output line by line with arrow syntax. Provide virtual steps for algorithm.\n\nLet's design:\n\nStart\n\n→ Initialize set of deadends\n\n→ If target is in deadends return -1\n\n→ If start '0000' in deadends return -1\n\n→ Initialize queue with '0000' and steps 0\n\n→ Initialize visited set with '0000'\n\n→ While queue not empty\n\n→   Dequeue state, steps\n\n→   If state == target return steps\n\n→   For each of 4 wheels\n\n→     For each direction +1 -1\n\n→       Compute new digit and wrap\n\n→       Build new state\n\n→       If new state not in deadends and not visited\n\n→         Add to visited, enqueue with steps+1\n\n→ End while\n\n→ Return -1\n\nEdge cases: if target equals start -> 0.\n\nWe need to show virtual code lines and explanation. Let's output accordingly.\n\nAlso we may add decisions for checking deadends. Use Decision: if.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Init DeadendSet ← set(deadends) // 將死結點轉成集合方便查詢  \n→ Decision: 如果 target ∈ DeadendSet? // 檢查目標是否為死結點  \n    Yes → End // 若是死結點，直接回傳 -1 (不會開鎖)  \n    No  → Decision: 如果 '0000' ∈ DeadendSet? // 檢查起點是否為死結點  \n        Yes → End // 若起點是死結點，也無法開鎖  \n        No  → Step 1: If target == '0000' then return 0 // 起點即目標，直接成功  \n→ Step 2: queue ← [( '0000', 0 )] // 以元組存放 (狀態, 步數)  \n→ Step 3: visited ← {'0000'} // 記錄已訪問的狀態  \n→ Decision: queue 是否為空?  \n    Yes → End // 若沒有可探索的狀態，回傳 -1  \n    No  → Step 4: (state, steps) ← queue.dequeue() // 取出前端節點  \n→ Decision: state == target?  \n    Yes → End // 找到目標，回傳已經走的步數  \n    No  → Step 5: for i in 0..3 // 迭代每一顆輪子  \n→        Step 6: for dir in [+1, -1] // 兩個方向：順時針、逆時針  \n→            digit ← int(state[i]) // 取出當前數字  \n→            new_digit ← (digit + dir) mod 10 // 加或減並環繞  \n→            new_state ← state[0:i] + str(new_digit) + state[i+1:] // 生成新組合  \n→            Decision: new_state ∈ DeadendSet 或 new_state ∈ visited?  \n                Yes → // 若為死結點或已訪問，跳過  \n                No  → Step 7: visited.add(new_state) // 標記已訪問  \n→                    Step 8: queue.enqueue((new_state, steps + 1)) // 加入隊列  \n→ End // 迴圈結束，若 queue 為空且未找到目標  \n→ Step 9: return -1 // 無法到達目標的情況  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import deque\nimport re\n\nclass Solution:\n    def openLock(self, deadends, target):\n        dead = set(deadends)\n        start = '0000'\n        if start in dead:\n            return -1\n        if target == start:\n            return 0\n        queue = deque([(start, 0)])\n        visited = {start}\n        while queue:\n            state, steps = queue.popleft()\n            if state == target:\n                return steps\n            for i in range(4):\n                digit = int(state[i])\n                for move in (-1, 1):\n                    new_digit = (digit + move) % 10\n                    new_state = state[:i] + str(new_digit) + state[i+1:]\n                    if new_state not in dead and new_state not in visited:\n                        visited.add(new_state)\n                        queue.append((new_state, steps + 1))\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n    \"\"\"\n    pattern = r'deadends\\s*=\\s*\\[(.*?)\\]\\s*,\\s*target\\s*=\\s*\"(.*?)\"'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format not recognized.\")\n    dead_raw = match.group(1).strip()\n    target = match.group(2).strip()\n    if dead_raw == '':\n        deadends = []\n    else:\n        deadends = [x.strip().strip('\"').strip(\"'\") for x in dead_raw.split(',') if x.strip()]\n    return deadends, target\n\ndef main():\n    raw = sys.stdin.read()\n    deadends, target = parse_input(raw)\n    sol = Solution()\n    result = sol.openLock(deadends, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "deadends = [\"8888\"], target = \"0009\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode380.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1)",
    "description_snippet": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool inser...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for the RandomizedSet class, with steps, each line including pseudo code step and comment. Use arrow notation, decisions, etc. We should include start, end, steps for constructor, insert, remove, getRandom. Use O(1). Implementation uses a list for values and a hash map for index mapping. So pseudo steps: Start -> Constructor: initialize array and map. Insert: if val in map then return false; else append val to array, record index, return true. Remove: if val not in map return false; else get index of val, get last element, replace index with last element, update map, pop last, delete val from map, return true. getRandom: choose random index from 0 to len-1, return array[randomIndex]. We'll include decisions. Use \"Yes→\" etc.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\" with arrow. Each step should be a line.\n\nLet's create a flow: Start. Constructor. Then each method as separate process. But we need pseudo-code steps, but not actual code. We'll show method bodies.\n\nWe might present as:\n\nStart\n→ Step 1: Define class RandomizedSet // 類別定義\n→ Step 2: Constructor: 初始化 values 與 map\n...\n\nBut to keep it simple, we can produce pseudo-code for each function.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Define RandomizedSet class // 建立類別\n→ Decision: (none)\n...\n\nHowever, they want sequential lines; each line with step and comment. Let's structure as:\n\nStart // 程式開始\n→ Step 1: Class RandomizedSet // 定義類別\n→ Step 2: Define members: values: list, map: hash // 兩個資料結構\n→ Step 3: Constructor // 初始化\n→ Step 4: values ← empty list // 空列表\n→ Step 5: map ← empty hash // 空字典\n→ Step 6: End Constructor // 結束建構\n→ Step 7: Method insert(val) // 插入\n→ Decision: 如果 val 在 map? // 檢查是否已存在\n   Yes → Step 8: Return false // 已存在不插入\n   No  → Step 9: Append val to values // 新增到末尾\n   → Step 10: map[val] ← len(values)-1 // 記錄索引\n   → Step 11: Return true // 成功插入\n→ Step 12: End insert // 結束\n→ Step 13: Method remove(val) // 刪除\n→ Decision: 如果 val 不在 map? // 檢查是否存在\n   Yes → Step 14: Return false // 不存在不刪除\n   No  → Step 15: idx ← map[val] // 取得索引\n   → Step 16: lastVal ← values[-1] // 取得最後元素\n   → Step 17: values[idx] ← lastVal // 把最後元素放到要刪除的位置\n   → Step 18: map[lastVal] ← idx // 更新 lastVal 的索引\n   → Step 19: values.pop() // 刪除最後元素\n   → Step 20: Delete map[val] // 移除映射\n   → Step 21: Return true // 成功刪除\n→ Step 22: End remove // 結束\n→ Step 23: Method getRandom() // 隨機取\n→ Step 24: n ← len(values) // 獲取長度\n→ Step 25: idx ← random integer in [0, n-1] // 隨機索引\n→ Step 26: Return values[idx] // 返回隨機元素\n→ Step 27: End getRandom // 結束\nEnd // 程式結束\n\nMake sure each line has arrow, etc. Use \"→\" at start for each step except Start and End? In example they use \"Start\" line no arrow. Each subsequent line uses \"→\". We'll follow that.\n\nAlso include decisions with indentation: \"Decision:\" line then Yes→ and No→ lines.\n\nWe'll produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Class RandomizedSet // 定義 RandomizedSet 類別\n→ Step 2: 定義成員: values: list, map: hash // 用 list 儲存元素, 用 hash 存索引\n→ Step 3: Constructor() // 初始化構造函式\n→ Step 4: values ← empty list // 初始化空列表\n→ Step 5: map ← empty hash // 初始化空字典\n→ Step 6: End Constructor // 結束構造\n→ Step 7: insert(val) // 插入方法\n→ Decision: val 是否存在於 map? // 檢查是否已存在\n   Yes → Step 8: Return false // 已存在則返回 false\n   No  → Step 9: Append val to values // 新元素追加到列表尾部\n   → Step 10: map[val] ← len(values) - 1 // 記錄新元素的索引\n   → Step 11: Return true // 成功插入返回 true\n→ Step 12: End insert // 結束插入\n→ Step 13: remove(val) // 刪除方法\n→ Decision: val 是否存在於 map? // 檢查是否可刪除\n   Yes → Step 14: idx ← map[val] // 取得要刪除元素的索引\n   → Step 15: lastVal ← values[-1] // 取得列表最後一個元素\n   → Step 16: values[idx] ← lastVal // 將最後元素放到要刪除的位置\n   → Step 17: map[lastVal] ← idx // 更新 lastVal 的索引\n   → Step 18: values.pop() // 刪除列表最後一個元素\n   → Step 19: Delete map[val] // 移除 val 的映射\n   → Step 20: Return true // 成功刪除返回 true\n   No  → Step 21: Return false // 不存在則返回 false\n→ Step 22: End remove // 結束刪除\n→ Step 23: getRandom() // 隨機取方法\n→ Step 24: n ← len(values) // 取得列表長度\n→ Step 25: idx ← random integer in [0, n-1] // 隨機產生索引\n→ Step 26: Return values[idx] // 回傳隨機元素\n→ Step 27: End getRandom // 結束隨機取\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # 用字典存值到索引的映射，用列表存實際值\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # 把最後一個元素放到被刪除位置\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\ndef parse_input(data):\n    data = data.strip()\n    if '\\n' in data:\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            ops = ast.literal_eval(lines[0])\n            args = ast.literal_eval(lines[1])\n            return ops, args\n    # 單行輸入或無換行\n    parts = data.split('],', 1)\n    if len(parts) == 2:\n        first = parts[0] + ']'\n        second = parts[1].lstrip()\n        ops = ast.literal_eval(first)\n        args = ast.literal_eval(second)\n        return ops, args\n    # 失敗時拋例外\n    raise ValueError(\"Invalid input format\")\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n\n    res = []\n    rs = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            rs = RandomizedSet()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(rs.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(rs.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(rs.getRandom())\n        else:\n            res.append(None)\n\n    # 格式化輸出為符合題目要求的 JSON 風格\n    formatted = []\n    for x in res:\n        if x is None:\n            formatted.append(\"null\")\n        elif isinstance(x, bool):\n            formatted.append(\"true\" if x else \"false\")\n        else:\n            formatted.append(str(x))\n    print(f\"[{', '.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "success": true,
          "output": "[null, true, false, true, 2, true, false, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode519.json",
    "problem_index_in_file": 0,
    "title": "Random Flip Matrix",
    "description_snippet": "There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to ran...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo code line by line with explanations, using arrows. For this algorithm: typical solution uses reservoir sampling-like mapping: maintain a map from index to another available index; maintain remaining count. flip: pick random number between 0 and remaining-1; map to actual index using dictionary mapping; then decrement remaining; update map. reset: clear mapping and set remaining=m*n.\n\nLet's generate steps: Start; constructor: set m, n, remaining = m*n; map = empty; etc.\n\nWe need to produce pseudo code lines with comments. Use Start, End, Decision. Use arrow → for each line.\n\nAlso need to include the algorithm steps. Provide for flip and reset.\n\nWe might structure like:\n\nStart\n→ Step 1: Initialize variables m, n, remaining, map\n→ Step 2: ... etc.\n\nBut we should show pseudo-code for the whole class. Let's produce separate pseudo-code for constructor, flip, reset. But the instruction: \"逐行生成虛擬碼 (Virtual Code)\" presumably the entire algorithm steps, not code skeleton. We can produce high-level pseudo-code with decision structures.\n\nLet's create:\n\nStart\n→ Step 1: Input m, n // 初始化矩陣尺寸\n→ Step 2: Set remaining = m*n // 可用空位數\n→ Step 3: map = empty dictionary // 位置映射\n→ Step 4: // flip 方法\n   → Step 4.1: If remaining == 0 → Return null? // no available, but assumption there is at least one\n   → Step 4.2: randIdx = random(0, remaining-1) // 隨機選擇剩餘範圍\n   → Step 4.3: actualIdx = map.get(randIdx, randIdx) // 若映射存在則取映射值\n   → Step 4.4: lastIdx = remaining-1\n   → Step 4.5: map[randIdx] = map.get(lastIdx, lastIdx) // 把最後一個位置映射到選中的位置\n   → Step 4.6: Remove map[lastIdx] if exists // 清除映射\n   → Step 4.7: remaining -= 1\n   → Step 4.8: i = actualIdx // / n; j = actualIdx % n // 轉換為二維坐標\n   → Step 4.9: Return [i, j]\n→ Step 5: // reset 方法\n   → Step 5.1: remaining = m*n\n   → Step 5.2: map.clear()\nEnd\n\nWe should show decision structure? The only decision is remaining==0 but we can skip.\n\nUse \"Decision:\" for conditional.\n\nLet's produce formatted lines.\n\nWe need to use \"→\" for each line and \"Decision:\" where needed. For mapping we can use \"map\" as dictionary.\n\nWe'll keep each line separate.\n\nLet's generate final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: input m, n // 初始化矩陣尺寸  \n→ Step 2: remaining ← m * n // 可用空位總數  \n→ Step 3: map ← {} // 空位索引對應映射表  \n→ Step 4: // flip 方法開始  \n→ Decision: 如果 remaining == 0? // 檢查是否還有空位可選  \n  Yes → Return null // 沒有空位，回傳空值（可選處理）  \n  No  → // 有空位可隨機選擇  \n→ Step 5: randIdx ← random(0, remaining - 1) // 產生 0~remaining-1 的隨機整數  \n→ Step 6: actualIdx ← map.get(randIdx, randIdx) // 若映射存在則取映射值，否則取自身索引  \n→ Step 7: lastIdx ← remaining - 1 // 最後一個可用索引  \n→ Step 8: map.put(randIdx, map.get(lastIdx, lastIdx)) // 把最後一個索引映射到選中的位置  \n→ Step 9: map.remove(lastIdx) // 移除最後一個索引的映射（若存在）  \n→ Step 10: remaining ← remaining - 1 // 可用空位減 1  \n→ Step 11: i ← actualIdx // n // 計算行座標  \n→ Step 12: j ← actualIdx % n // 計算列座標  \n→ Step 13: Return [i, j] // 回傳隨機選取的座標  \n→ Step 14: // reset 方法開始  \n→ Step 15: remaining ← m * n // 重置可用空位數  \n→ Step 16: map.clear() // 清空映射表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, m, n):\n        self.rows = m\n        self.cols = n\n        self.total = m * n\n        self.mapping = {}\n\n    def flip(self):\n        # 隨機選擇一個尚未翻轉的索引\n        r = random.randint(0, self.total - 1)\n        # 若映射存在則取映射值，否則取自身索引\n        x = self.mapping.get(r, r)\n        # 之後把最後一個可用索引映射到 r\n        last = self.total - 1\n        self.mapping[r] = self.mapping.get(last, last)\n        # 若 last 在映射中，移除它（因為已被「移走」）\n        if last in self.mapping:\n            del self.mapping[last]\n        self.total -= 1\n        # 轉換為行列座標\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.mapping.clear()\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將輸入轉為兩個列表\n    try:\n        commands, args = ast.literal_eval(f\"({data})\")\n    except Exception:\n        # 若輸入格式不符合，直接退出\n        sys.exit(1)\n\n    obj = None\n    outputs = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            outputs.append(None)\n        elif cmd == \"flip\":\n            outputs.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            outputs.append(None)\n        else:\n            # 忽略未知指令\n            outputs.append(None)\n\n    # 輸出結果，使用 json 以保證 null 的格式\n    print(json.dumps(outputs))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [1, 0]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode735.json",
    "problem_index_in_file": 0,
    "title": "Asteroid Collision",
    "description_snippet": "We are given an array asteroids of integers representing asteroids in a row. The indices of the aste...",
    "examples_loaded": 4,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode. The problem: Asteroid Collision. Use stack. We'll produce virtual code line by line with comments.\n\nWe should produce Start, End, Decision, arrows.\n\nWe need to output virtual code, not actual code. Use arrow →. Provide concise explanation after //.\n\nLet's produce algorithm:\n\nStart\n→ Step 1: Initialize empty stack // 用來存活的彗星\n→ Step 2: For each asteroid in asteroids array: // 遍歷每個彗星\n→ Decision: 若堆疊非空且頂部 >0 且 當前彗星<0? // 當前向左，堆疊頂向右，可能碰撞\n   Yes → Step 3: Compare abs(top) 與 abs(current)\n        Decision: abs(top) > abs(current)?\n             Yes → Step 4: current 彗星爆炸，continue to next asteroid // 當前爆炸，退出內部循環\n             No  → Decision: abs(top) == abs(current)?\n                   Yes → Step 5: pop stack，current 彗星爆炸，break // 兩者相等，互相爆炸\n                   No  → Step 6: pop stack，回到 Decision 重新檢查新頂部 // current 仍活著，可能再碰撞\n   No  → Step 7: push current asteroid onto stack // 沒有碰撞，保留\n→ Step 8: 循環結束\n→ Step 9: 返回堆疊中的彗星作為結果 // 堆疊順序即最終狀態\n\nNeed to incorporate while loop to handle multiple collisions. Use Step 6 to loop.\n\nWe'll use arrow lines with appropriate indentation.\n\nLet's write lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化一個空堆疊 // 用於保存尚未爆炸的彗星\n→ Step 2: 從左到右遍歷陣列 asteroids // 逐一處理每顆彗星\n→ Decision: 堆疊非空且堆疊頂 >0 且 current <0? // 判斷是否可能發生碰撞\n    Yes → Step 3: 計算 abs(top) 與 abs(current) // 比較兩顆彗星的大小\n    → Decision: abs(top) > abs(current)? // 大的彗星是否會爆炸小的彗星\n        Yes → Step 4: current 彗星爆炸，跳到下一顆 // 只保留頂部彗星\n        No  → Decision: abs(top) == abs(current)?\n              Yes → Step 5: pop(stack)，current 彗星爆炸，跳到下一顆 // 兩者相同大小互相消滅\n              No  → Step 6: pop(stack)，回到 Decision：堆疊非空且頂>0 且 current <0? // 可能再次碰撞\n    No  → Step 7: push current onto stack // 沒有碰撞，保留彗星\n→ Step 8: 重複步驟 2-7 直到所有彗星處理完\n→ Step 9: 將堆疊轉為陣列作為結果 // 堆疊中的順序即最終彗星狀態\nEnd // 程式執行結束\n\nBut we need to ensure proper arrow indentation: Use arrows for steps, and decision lines.\n\nLet's produce with \"→ Decision:\" lines with indent. Indentation can be represented by spaces. Provide explanation after //.\n\nAlso we need to incorporate loop for step 2; use arrow with while.\n\nLet's craft final answer accordingly.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化一個空堆疊 // 用於保存尚未爆炸的彗星\n→ Step 2: 從左到右遍歷陣列 asteroids // 逐一處理每顆彗星\n    → Decision: 堆疊非空且堆疊頂 >0 且 current <0? // 判斷是否可能發生碰撞\n        Yes →\n            → Step 3: 計算 abs(top) 與 abs(current) // 比較兩顆彗星的大小\n            → Decision: abs(top) > abs(current)? // 大的彗星是否會爆炸小的彗星\n                Yes → Step 4: current 彗星爆炸，跳到下一顆 // 只保留頂部彗星\n                No  →\n                    → Decision: abs(top) == abs(current)?\n                        Yes → Step 5: pop(stack)，current 彗星爆炸，跳到下一顆 // 兩者相同大小互相消滅\n                        No  → Step 6: pop(stack)，回到 Decision：堆疊非空且頂>0 且 current <0? // 可能再次碰撞\n        No  → Step 7: push current onto stack // 沒有碰撞，保留彗星\n→ Step 8: 所有彗星處理完畢 // 重複步驟 2-7 直到結束\n→ Step 9: 將堆疊轉為陣列作為結果 // 堆疊中的順序即最終彗星狀態\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def asteroidCollision(self, asteroids):\n        stack = []\n        for a in asteroids:\n            # 處理可能的碰撞：堆疊頂向右且目前向左\n            while stack and a < 0 < stack[-1]:\n                if stack[-1] < -a:\n                    stack.pop()           # 堆疊頂彗星被撞爆\n                    continue\n                elif stack[-1] == -a:\n                    stack.pop()           # 兩顆相同大小互相爆炸\n                break\n            else:\n                stack.append(a)           # 無碰撞，保留彗星\n        return stack\n\ndef parse_input(input_str):\n    \"\"\"\n    從輸入字串中擷取彗星列表。\n    期望格式類似 'asteroids = [5,10,-5]'\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    try:\n        # 取出方括號內的字串\n        start = input_str.index('[')\n        end = input_str.index(']', start)\n        list_str = input_str[start:end+1]\n        return ast.literal_eval(list_str)\n    except (ValueError, SyntaxError):\n        # 若格式不符，嘗試直接評估整個字串\n        try:\n            return ast.literal_eval(input_str)\n        except Exception:\n            return []\n\ndef main():\n    data = sys.stdin.read()\n    asteroids = parse_input(data)\n    result = Solution().asteroidCollision(asteroids)\n    # 以無空格的格式輸出結果\n    print('[' + ','.join(map(str, result)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "asteroids = [5,10,-5]",
          "expected_output": "[5,10]",
          "success": true,
          "output": "[5,10]"
        },
        {
          "example_index": 1,
          "input": "asteroids = [8,-8]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "asteroids = [10,2,-5]",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        },
        {
          "example_index": 3,
          "input": "asteroids = [3,5,-6,2,-1,4]",
          "expected_output": "[-6,2,4]",
          "success": true,
          "output": "[-6,2,4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode45.json",
    "problem_index_in_file": 0,
    "title": "Jump Game II",
    "description_snippet": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at index ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to solve minimum jumps to reach last index. Typical greedy approach: iterate through array keeping current max reach and next max reach, increment jumps when i reaches current max reach. We'll produce pseudo code. Ensure each line: virtual code + comment. Use arrows.\n\nLet's produce:\n\nStart // start\n→ Step 1: set jumps = 0, current_end = 0, farthest = 0 // initialize\n→ Step 2: for i from 0 to n-2 // iterate excluding last index\n    → Step 3: farthest = max(farthest, i + nums[i]) // update farthest reachable\n    → Decision: if i == current_end? // reached end of current jump range\n        Yes → jumps += 1 // need another jump\n        Yes → current_end = farthest // set new range\nEnd // finished\n\nAlso handle special case n <= 1: return 0.\n\nAdd step for n <= 1.\n\nLet's produce lines accordingly. Use appropriate arrow formatting: Use `→` at start of step line. For decision lines, indent? In example, they used indentation. We'll follow same style: Indent decision block. Let's produce.\n\nAlso we need to include \"Start\" line, \"End\" line.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: if n <= 1 then return 0 // 若陣列只有一個或沒有元素，直接回傳 0  \n→ Step 2: set jumps = 0, current_end = 0, farthest = 0 // 初始化跳躍次數、目前跳躍範圍結束位置與最遠可達位置  \n→ Step 3: for i from 0 to n-2 // 遍歷除最後一個索引外的所有位置  \n    → Step 4: farthest = max(farthest, i + nums[i]) // 更新目前能到達的最遠距離  \n    → Decision: i == current_end? // 檢查是否已達到當前跳躍範圍的終點  \n        Yes → jumps += 1 // 需要一次新的跳躍  \n        Yes → current_end = farthest // 重新設定下一個跳躍範圍的終點  \nEnd // 程式執行結束，返回最小跳躍次數",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def jump(self, nums):\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        jumps = 0\n        current_end = 0\n        farthest = 0\n\n        for i in range(n - 1):\n            farthest = max(farthest, i + nums[i])\n            if i == current_end:\n                jumps += 1\n                current_end = farthest\n\n        return jumps\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析出陣列 nums。\"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        raise ValueError(\"輸入格式不正確，請輸入類似 'nums = [1,2,3]' 的字串\")\n    nums_str = data[start:end + 1]\n    return ast.literal_eval(nums_str)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    sol = Solution()\n    result = sol.jump(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,3,0,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode495.json",
    "problem_index_in_file": 0,
    "title": "Teemo Attacking",
    "description_snippet": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets po...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step to solve this problem, with explanations. We must not output actual code, just pseudocode with arrows and comments.\n\nWe need to handle array timeSeries sorted non-decreasing, duration. The algorithm: iterate over timeSeries, sum total poisoned time. For each attack time t: if t > lastAttack + duration - 1? Actually we need to add min(duration, t_next - t). Standard solution: sum += duration for first, then for each subsequent attack, add min(duration, t_i - t_{i-1}). For last one, add duration.\n\nThus pseudocode:\n\nStart\nInitialize total = 0\nIf timeSeries empty → return 0\n\nLoop i from 0 to len-1\n    If i==0:\n        total += duration\n    Else:\n        diff = timeSeries[i] - timeSeries[i-1]\n        total += min(duration, diff)\nEnd loop\nReturn total\n\nNeed to use virtual code structure.\n\nWe need to output lines with \"虛擬碼步驟\" plus comments.\n\nWe need to use arrows (→), Decision: if etc. Also structure: Start, End.\n\nLet's produce step-by-step.\n\nUse lines like:\n\nStart // 程式開始執行\n→ Decision: timeSeries 是否為空? // 檢查是否有攻擊紀錄\n    Yes → Step 1: 返回 0 // 沒有攻擊，毒藥時間為 0\n    No  → Step 2: 初始化 total = 0, prev = timeSeries[0] // 用於累計毒藥時間，prev 追蹤上一個攻擊時間\n→ Step 3: total += duration // 第一個攻擊的毒藥持續 duration 秒\n→ Step 4: 循環 i 從 1 到 timeSeries.length-1 // 處理其餘攻擊\n    → Step 5: diff = timeSeries[i] - prev // 兩次攻擊之間的時間差\n    → Decision: diff 是否小於 duration? // 判斷兩次攻擊是否重疊\n        Yes → total += diff // 若重疊，僅累計差距\n        No  → total += duration // 若不重疊，累計完整 duration\n    → Step 6: prev = timeSeries[i] // 更新上一攻擊時間\n→ Step 7: 返回 total // 完成計算\nEnd // 程式執行結束\n\nWe also need to maintain structure: maybe use loop arrow and decisions.\n\nBetter: use \"→ Decision:\" for loops? We can just show step 4: Start loop, then inside.\n\nLet's produce final output. Ensure each line has \"虛擬碼步驟\" and comment. Use Chinese comments.\n\nReturn final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: timeSeries 是否為空? // 檢查是否有攻擊紀錄  \n  Yes → Step 1: 返回 0 // 沒有攻擊，毒藥時間為 0  \n  No  → Step 2: 初始化 total = 0, prev = timeSeries[0] // 用於累計毒藥時間，prev 追蹤上一個攻擊時間  \n→ Step 3: total += duration // 第一個攻擊的毒藥持續 duration 秒  \n→ Step 4: 循環 i 從 1 到 timeSeries.length-1 // 處理其餘攻擊  \n  → Step 5: diff = timeSeries[i] - prev // 計算兩次攻擊之間的時間差  \n  → Decision: diff 小於 duration? // 判斷兩次攻擊是否重疊  \n    Yes → total += diff // 若重疊，僅累計差距  \n    No  → total += duration // 若不重疊，累計完整 duration  \n  → Step 6: prev = timeSeries[i] // 更新上一攻擊時間  \n→ Step 7: 返回 total // 完成計算  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        if not timeSeries:\n            return 0\n        total = 0\n        for i in range(len(timeSeries) - 1):\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        total += duration\n        return total\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將輸入轉換為字典形式，例如\n    # timeSeries = [1,4], duration = 2\n    # 轉成 {'timeSeries': [1,4], 'duration': 2}\n    formatted = raw.replace('timeSeries =', 'timeSeries:') \\\n                   .replace(', duration =', ', duration:')\n    data = ast.literal_eval('{' + formatted + '}')\n    timeSeries = data['timeSeries']\n    duration = data['duration']\n\n    sol = Solution()\n    result = sol.findPoisonedDuration(timeSeries, duration)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpwvv_s1um.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpwvv_s1um.py\", line 24, in main\n    data = ast.literal_eval('{' + formatted + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7275255f7890>"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpowgllad_.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpowgllad_.py\", line 24, in main\n    data = ast.literal_eval('{' + formatted + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7095233fba90>"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode424.json",
    "problem_index_in_file": 0,
    "title": "Longest Repeating Character Replacement",
    "description_snippet": "You are given a string s and an integer k. You can choose any character of the string and change it ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: longest repeating character replacement, sliding window. Provide steps: start, input s, k. Use two pointers left, right. Count frequencies array. For each right iterate, increment count of s[right]. Find maxCount = max frequency in window. While window size - maxCount > k, shrink left: decrement count of s[left], left++. Keep answer = max(answer, right-left+1). End. Provide each step. Need to output step lines with virtual code and explanation. Use arrow etc. Let's structure.\n\nStart\n→ Input string s and integer k\n→ Initialize left = 0, maxLen = 0\n→ Initialize freq[26] = 0, maxFreq = 0\n→ For right from 0 to length-1:\n    → Increment freq[s[right]]\n    → Update maxFreq = max(maxFreq, freq[s[right]])\n    → Decision: If (right-left+1 - maxFreq > k)?\n        Yes → While condition:\n            → Decrement freq[s[left]]\n            → left++\n        No  → Continue\n    → Update maxLen = max(maxLen, right-left+1)\n→ End // Return maxLen\n\nBut need to show Decision block with Yes → ... No → ... but no else? We can put Decision and Yes branch, No branch just continue.\n\nWe must use `Decision:` and arrow. Use indentation? Provide arrow inside decision.\n\nLet's write each line. Use arrow after step label? Format: \"→ Step 1: ...\" etc.\n\nLet's produce.\n\nAlso, we may need to show loop for right. Use `→ For right = 0 to |s|-1` then inside block with indentation.\n\nLet's produce each line.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: 取得字串 s 與整數 k // 取得輸入資料  \n→ Initialise: left = 0, maxLen = 0, freq[26] = 0, maxFreq = 0 // 初始化指標與統計資料  \n→ For right = 0 to |s|-1 // 以滑動視窗遍歷字串  \n → Increment freq[ s[right] ] // 將右指標所指字元加入統計  \n → Update maxFreq = max( maxFreq, freq[ s[right] ] ) // 更新視窗內最多重複字元數量  \n → Decision: 如果 (right - left + 1 - maxFreq) > k? // 判斷是否超過可更改次數  \n  Yes → While (right - left + 1 - maxFreq) > k  \n    → Decrement freq[ s[left] ] // 收縮左指標時減少對應字元統計  \n    → left++ // 左指標向右移動  \n  No → // 不需要收縮，直接繼續  \n → Update maxLen = max( maxLen, right - left + 1 ) // 更新最大長度  \nEnd // 程式執行結束，回傳 maxLen 作为結果",
      "generated_code": "import sys\nimport re\n\ndef longest_repeating_substring_after_replacement(s: str, k: int) -> int:\n    \"\"\"\n    Return the maximum length of a substring that can be made of a single\n    repeated character by changing at most k characters in the string `s`.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # frequency of each letter in the current window\n    freq = [0] * 26\n    max_freq = 0  # max frequency of any letter in the window\n    left = 0\n    max_len = 0\n\n    for right, ch in enumerate(s):\n        idx = ord(ch) - ord('A')\n        freq[idx] += 1\n        max_freq = max(max_freq, freq[idx])\n\n        # If the number of changes needed > k, shrink window from the left\n        while (right - left + 1) - max_freq > k:\n            left_idx = ord(s[left]) - ord('A')\n            freq[left_idx] -= 1\n            left += 1\n            # Note: max_freq may be outdated after shrinking,\n            # but it's okay because it only makes the window smaller.\n\n        # Update answer\n        current_len = right - left + 1\n        if current_len > max_len:\n            max_len = current_len\n\n    return max_len\n\n\ndef parse_input(text: str):\n    \"\"\"\n    Parse the input from stdin. Supports formats such as:\n        s = \"ABAB\", k = 2\n    or simply:\n        ABAB 2\n    or:\n        ABAB\n        2\n    \"\"\"\n    # Try to match the \"s = \"...\", k = ...\" pattern\n    m = re.search(r's\\s*=\\s*\"([^\"]+)\"\\s*,\\s*k\\s*=\\s*(\\d+)', text)\n    if m:\n        s = m.group(1)\n        k = int(m.group(2))\n        return s, k\n\n    # Fallback: split by whitespace\n    tokens = text.replace(',', ' ').split()\n    if len(tokens) >= 2:\n        # If the first token is quoted, strip quotes\n        if tokens[0].startswith('\"') and tokens[0].endswith('\"'):\n            s = tokens[0][1:-1]\n        else:\n            s = tokens[0]\n        k = int(tokens[1])\n        return s, k\n\n    # If only one token is present, assume next line contains k\n    if len(tokens) == 1:\n        s = tokens[0]\n        # read the next line from stdin (should have been already read)\n        # but in this fallback scenario we can't get k, so return default\n        return s, 0\n\n    # Default fallback\n    return \"\", 0\n\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        sys.exit(0)\n\n    s, k = parse_input(input_text)\n    result = longest_repeating_substring_after_replacement(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode58.json",
    "problem_index_in_file": 0,
    "title": "Length of Last Word",
    "description_snippet": "Given a string s consisting of words and spaces, return the length of the last word in the string.\n\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line. We must produce steps, each line: virtual code step, space, comment. Use Start, Decision, etc. We need to produce pseudocode that finds length of last word. Use loops, conditions. Provide explanation after each line. No actual code, just virtual steps. Provide line by line. Let's produce.\n\nWe need to handle string s input, find last word length. Steps: Start, set i to length-1, skip trailing spaces, then count characters until space or start. Use decision to skip spaces, then count. Provide explanation each line.\n\nLet's produce like:\n\nStart // 開始\n\n→ Step 1: Set index i = length of s - 1 // 設定索引指向最後一個字元\n\n→ Decision: 如果 s[i] 是空格? // 判斷是否為尾端空格\n\n    Yes → Step 2: i = i - 1 // 移動至非空格字符\n\n    No → Step 3: // 跳過\n\n→ Step 4: Set length = 0 // 初始化最後一個單字長度\n\n→ Decision: 如果 i < 0? // 檢查是否全為空格\n\n    Yes → Step 5: Return 0 // 無單字\n\n    No → // 進行計數\n\n→ Step 6: While i >= 0 AND s[i] != ' ' // 逐字計數直到空格或字符串開始\n\n    → Step 6.1: length = length + 1 // 加一長度\n\n    → Step 6.2: i = i - 1 // 移動至上一個字元\n\n→ Step 7: Return length // 回傳最後一個單字長度\n\nEnd // 結束\n\nBut we need to use arrows with decisions and steps. Also we can use \"Step 1:\", \"Decision:\", etc. The formatting requires \"虛擬碼步驟\" followed by a space and comment. Use \"→\" for steps and \"Decision:\" for decision branches. Let's craft lines accordingly.\n\nWe need each line to have one step or decision. But the decision branches produce sublines. They used indent in example. We'll replicate. For decision branches, we need sub-lines with Yes → and No →. We must maintain indentation? They used indent with space before Yes →. We can mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = length(s) - 1 // 設定索引指向字串最後一個位置  \n→ Decision: 如果 s[i] 是空格? // 檢查尾端是否有空格  \n  Yes → Step 2: i = i - 1 // 移動到最後一個非空格字符  \n  No  → Step 3: // 跳過空格檢查  \n→ Step 4: length = 0 // 初始化最後一個單字長度為 0  \n→ Decision: 如果 i < 0? // 判斷字串是否全為空格  \n  Yes → Step 5: Return 0 // 無任何單字，回傳 0  \n  No  → // 進行單字長度計算  \n→ Step 6: While i >= 0 AND s[i] != ' ' // 從最後一個非空格字符往前遍歷直到遇到空格或到達字串開頭  \n  → Step 6.1: length = length + 1 // 計數目前字符  \n  → Step 6.2: i = i - 1 // 移動到上一個字符  \n→ Step 7: Return length // 回傳最後一個單字的長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        Returns the length of the last word in a given string.\n        A word is a maximal substring of non-space characters.\n        \"\"\"\n        # 去除前後空白，確保最後一個字符不是空格\n        s = s.strip()\n        # 如果字符串為空，直接回傳 0\n        if not s:\n            return 0\n        # 以空格切分，最後一個元素即為最後一個單字\n        words = s.split(' ')\n        # 取最後一個單字長度\n        return len(words[-1]) if words else 0\n\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取資料，解析出字符串 s，計算最後一個單字長度，並輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 解析輸入，取雙引號之間的內容作為字串\n    s = ''\n    if '\"' in data:\n        first_quote = data.find('\"')\n        last_quote = data.rfind('\"')\n        if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n            s = data[first_quote + 1:last_quote]\n        else:\n            s = data\n    else:\n        # 若沒有雙引號，嘗試從等號後面取值\n        if '=' in data:\n            parts = data.split('=', 1)\n            s = parts[1].strip()\n        else:\n            s = data\n\n    solution = Solution()\n    result = solution.lengthOfLastWord(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello World\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"   fly me   to   the moon  \"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"luffy is still joyboy\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode33.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array",
    "description_snippet": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being pas...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving rotated sorted array search, O(log n). Provide each line with explanation. Use arrows, Start, End, Decision. So produce algorithm pseudocode.\n\nWe need to show: Start, define low, high, while low <= high, compute mid, check mid==target, then determine which side sorted, etc. Use decision branches.\n\nWe must output lines exactly as described. Each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrow \"→\". Use \"Yes →\" and \"No →\". Use \"Decision:\" etc.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: low ← 0, high ← length(nums)-1 // 初始化搜尋範圍\n→ Decision: low ≤ high? // 檢查是否還有區間可搜尋\n    Yes → Step 2: mid ← (low + high) / 2 // 計算中點索引\n    → Decision: nums[mid] == target? // 中點是否為目標\n        Yes → Step 3: return mid // 找到目標，返回索引\n        No  → Step 4: lowMid ← nums[low], midVal ← nums[mid], highVal ← nums[high] // 取邊界值\n        → Decision: lowMid ≤ midVal? // 判斷左半段是否有序\n            Yes → Step 5: midVal < target AND target ≤ highVal? // 目標是否在右半段有序區\n                Yes → Step 6: low ← mid + 1 // 搜尋右半段\n                No  → Step 7: high ← mid - 1 // 搜尋左半段\n            No  → Step 8: lowMid ≤ target AND target < midVal? // 目標是否在左半段有序區\n                Yes → Step 9: high ← mid - 1 // 搜尋左半段\n                No  → Step 10: low ← mid + 1 // 搜尋右半段\n    No → End // 未找到目標，結束\nEnd // 程式結束\n\nBut we need \"Yes →\" \"No →\" lines accordingly. Also each line preceded by \"→\". For decisions, we need nested decisions.\n\nAlso need to handle return -1 at the end: After loop ends return -1.\n\nLet's craft with proper indentation using arrow indentation? In example, they show nested indentation like:\n\n→ Decision: If ...\n    Yes → ...\n    No  → ...\n\nWe'll follow similar. We'll include \"→ Step X\" lines and decisions.\n\nWe need to mention \"return -1\" at end.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0, high ← length(nums) - 1 // 初始化搜尋範圍  \n→ Decision: low ≤ high? // 是否還有區間可搜尋  \n  Yes → Step 2: mid ← (low + high) // 計算中點索引  \n  → Decision: nums[mid] == target? // 中點是否為目標  \n    Yes → Step 3: return mid // 找到目標，直接返回其索引  \n    No → Step 4: lowVal ← nums[low], midVal ← nums[mid], highVal ← nums[high] // 取得邊界值  \n    → Decision: lowVal ≤ midVal? // 判斷左半段是否為升序有序區  \n      Yes → Step 5: midVal < target ≤ highVal? // 目標是否落在右半段有序區  \n        Yes → Step 6: low ← mid + 1 // 搜尋右半段  \n        No → Step 7: high ← mid - 1 // 搜尋左半段  \n      No → Step 8: lowVal ≤ target < midVal? // 目標是否落在左半段有序區  \n        Yes → Step 9: high ← mid - 1 // 搜尋左半段  \n        No → Step 10: low ← mid + 1 // 搜尋右半段  \n  No → End // 未找到目標，搜尋結束  \n→ Step 11: return -1 // 迴圈結束後若仍未找到，回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:          # 左半段有序\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:                                # 右半段有序\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 解析輸入格式: nums = [4,5,6,7,0,1,2], target = 0\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        sys.exit(0)\n    nums_str, target_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n\n    result = Solution().search(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [1], target = 0",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode676.json",
    "problem_index_in_file": 0,
    "title": "Implement Magic Dictionary",
    "description_snippet": "Design a data structure that is initialized with a list of different words. Provided a string, you s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code, line by line, no real code, just structure. Steps: Start, buildDict: store words in array or set, also maybe preprocess. search: iterate over words and check if exactly one char difference. Use nested loops. Provide steps with decision and arrows.\n\nLet's produce pseudo algorithm:\n\nStart\n→ Step: Initialize data structure\n→ Step: buildDict(dictionary) // store words\n→ Step: search(searchWord) // iterate words\n→ Decision: If any word length != searchWord length? Skip\n→ For each word\n→ Decision: Count diff == 1? If yes return true\n→ End of search return false\n\nAlso could use map of patterns with wildcard etc. But simple.\n\nLet's write in requested format.\n\nWe must include `Start` and `End` markers. Use arrows.\n\nUse indent for nested decision.\n\nWill produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 MagicDictionary 物件 // 建立空資料結構\n→ Step 2: buildDict(dictionary) // 將單詞集合儲存\n    → Decision: 將 dictionary 存入內部陣列 words // 方便後續搜尋\n→ Step 3: search(searchWord) // 進行搜尋\n    → Decision: 有任何單詞長度與 searchWord 不同嗎? // 跳過不同長度的單詞\n        Yes → Continue // 跳過\n        No  → Continue // 仍進行\n    → Step 4: For each word in words\n        → Step 5: 初始化差異計數 diff = 0\n        → Step 6: For i from 0 to length-1\n            → Decision: words[i] ≠ searchWord[i]? // 是否不同\n                Yes → diff = diff + 1\n                No  → 仍不變\n            → Decision: diff > 1? // 超過 1 則可直接跳過\n                Yes → Break // 退出內層迴圈\n                No  → 仍執行\n        → Decision: diff == 1? // 恰好一個不同\n            Yes → Return true // 找到符合條件\n            No  → 仍繼續下一個單詞\n    → Return false // 沒有任何單詞符合\nEnd // 程式執行結束\n\nLet's make each line separate, use arrows appropriately. Need to format like: `Step 1: ... // 說明` etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 MagicDictionary 物件 // 初始化內部儲存結構  \n→ Step 2: buildDict(dictionary) // 將字典中的單詞存入資料結構  \n  Decision: 將 dictionary 存入陣列 words? // 方便後續逐字比對  \n   Yes → Step 3: words ← dictionary // 存儲所有單詞  \n→ Step 4: search(searchWord) // 開始搜尋是否能改一字匹配  \n  Decision: 有 words[i] 的長度與 searchWord 不同? // 不同長度的單詞無法匹配  \n   Yes → Continue // 跳過此單詞  \n   No  → Continue // 繼續檢查  \n  Step 5: For each word in words  \n   → Step 6: diff ← 0 // 差異字元計數器  \n   → Step 7: For j from 0 to length-1  \n     Decision: word[j] ≠ searchWord[j]? // 兩字元不同  \n      Yes → diff ← diff + 1 // 變化數增 1  \n      No  → 仍保持 diff  \n     Decision: diff > 1? // 超過一個差異即不符合條件  \n      Yes → Break // 跳出內層迴圈，檢查下一個單詞  \n      No  → 仍執行下一位  \n    Decision: diff == 1? // 恰好一個差異  \n     Yes → Return true // 找到符合的單詞，搜尋成功  \n     No  → 仍檢查下一個單詞  \n  Decision: 所有單詞檢查完畢仍未匹配? // 無法改一字匹配  \n   Yes → Return false // 搜尋失敗  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = 0\n            for a, b in zip(word, searchWord):\n                if a != b:\n                    diff += 1\n                    if diff > 1:\n                        break\n            if diff == 1:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 把兩個列表包裝成一個元組，方便 ast.literal_eval 解析\n    data = '(' + data + ')'\n    ops, args_list = ast.literal_eval(data)\n\n    result = []\n    magic_dict = None\n    for op, arg in zip(ops, args_list):\n        if op == \"MagicDictionary\":\n            magic_dict = MagicDictionary()\n            result.append(None)\n        elif op == \"buildDict\":\n            magic_dict.buildDict(arg)\n            result.append(None)\n        elif op == \"search\":\n            res = magic_dict.search(arg)\n            result.append(res)\n        else:\n            # 未知操作，返回 None\n            result.append(None)\n\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpffw0fh2x.py\", line 41, in <module>\n    magic_dict.buildDict(arg)\n  File \"/tmp/tmpffw0fh2x.py\", line 10, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode672.json",
    "problem_index_in_file": 0,
    "title": "Bulb Switcher II",
    "description_snippet": "There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the described problem. This is an algorithmic problem: given n bulbs initially ON, four button operations that flip subsets of bulbs, perform exactly 'presses' button presses (sequence length presses). We need count of distinct final statuses possible.\n\nWe must produce virtual code step-by-step explanation. So we should outline algorithm: The state of bulbs can be represented by vector of length n with bits. But n can be large; however with 4 buttons, the group of transformations is limited. Known problem \"Bulb Switcher III\" from LeetCode. The answer depends only on min(n, presses) and parity. Actually solution: maximum distinct states =\n\nIf presses == 0 => 1\n\nIf n == 1:\n  if presses == 1 => 2\n  else => 1\nElse if n == 2:\n  if presses == 1 => 2\n  if presses == 2 => 3\n  else => 4\nElse if n >= 3:\n  if presses == 1 => 4\n  if presses == 2 => 7\n  else => 8\n\nBut we can produce algorithm that explores all button combinations up to presses, but we need virtual code steps not actual code.\n\nWe need to produce step-by-step pseudocode with explanations, following format: each line: \"虛擬碼步驟 // 解釋\".\n\nWe'll write algorithm:\n\nStart\n→ Determine effective number of presses min(presses, 4) // more than 4 redundant\n→ If n == 1:\n    → Decide results based on presses\nElse if n == 2:\n    ...\nElse:\n    ...\n→ Output count.\n\nBut maybe we can produce general algorithm: iterate all possible button press sequences up to presses, using BFS or recursion, using bitset representation for bulbs. Since n might be up to maybe 1000, but we can use modulo patterns: only 16 possible combinations of button presses (since buttons commute and idempotent). So we can generate all subsets of buttons pressed an odd number of times. Because pressing same button twice cancels.\n\nThus the number of distinct states is at most 16. For given presses, we consider subsets with parity constraints: number of buttons pressed mod 2 can be anything but need to respect press count parity and max number of distinct combinations.\n\nThus algorithm: generate all subsets of {1,2,3,4} such that size <= presses and size mod 2 == presses mod 2? Actually pressing a button twice cancels, so effective state depends only on which buttons pressed odd number of times. So we need subsets S of buttons such that |S| <= presses and |S| mod 2 == presses mod 2. Because we can achieve S by pressing each button in S once, and for remaining presses, we can press any button twice (which cancel) to fill up to presses. Also we must ensure |S| <= presses. So number of distinct states is number of such subsets.\n\nWe then compute for each subset, apply flips to n bulbs initial all on, produce status string, store in set to dedupe. Count size.\n\nWe can produce virtual code steps accordingly.\n\nLet's write pseudocode:\n\nStart\n→ Read n, presses\n→ Initialize set statuses\n→ For each subset mask from 0 to 15:\n    → Let cnt = popcount(mask)\n    → If cnt <= presses AND (presses - cnt) % 2 == 0:\n        → Compute status array of length n with all on\n        → For each button bit:\n            → If bit set, flip corresponding bulbs\n        → Add status string to set\n→ Output size of set\n\nExplain each step.\n\nNow produce step lines with explanation. Use arrow arrow for decisions. Use Start, End.\n\nLet's craft step-by-step. Ensure each line has explanation. Use Chinese comments.\n\nWe need to be careful to use arrow for decision: \"Decision:\".\n\nAlso include structure lines with Start, End.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀入 n 與 presses // 取得燈泡數量與總按鈕次數\n→ Decision: n 是否為 0? // 檢查是否存在燈泡\n    Yes → Step 2: 輸出 0 // 無燈泡時只能有一種狀態，即無燈\n    No  → Step 3: 進行後續計算 // 進入主流程\n→ Step 4: 初始化空集合 statuses // 用來儲存不同的最終燈泡狀態\n→ Step 5: 循環 mask 從 0 到 15 // 代表所有 4 個按鈕的子集 (2^4 = 16)\n    → Step 6: 取 mask 的位數 popcount 為 cnt // cnt 為目前子集中的按鈕數量\n    → Decision: cnt <= presses 且 (presses - cnt) % 2 == 0? // 是否能用總按鈕次數實現此子集\n        Yes → Step 7: 建立全亮狀態陣列 state[n] 設為 1 // 1 表示燈泡亮\n        → Decision: mask 的第 1 位 (按鈕 1) 為 1? \n            Yes → Step 8: 反轉 state 中所有位置 // 按鈕 1 翻轉全部燈\n            No  → // 不操作\n        → Decision: mask 的第 2 位 (按鈕 2) 為 1? \n            Yes → Step 9: 反轉 state 中所有偶數索引位置 // 按鈕 2 翻轉偶數標號燈\n            No  → // 不操作\n        → Decision: mask 的第 3 位 (按鈕 3) 為 1? \n            Yes → Step 10: 反轉 state 中所有奇數索引位置 // 按鈕 3 翻轉奇數標號燈\n            No  → // 不操作\n        → Decision: mask 的第 4 位 (按鈕 4) 為 1? \n            Yes → Step 11: 反轉 state 中所有標號 j = 3k+1 的位置 // 按鈕 4 翻轉 1,4,7,...\n            No  → // 不操作\n        → Step 12: 將 state 轉換成字串 key 並加入 statuses 集合 // 以字串形式存入，確保唯一性\n        No  → // 若子集不可行，跳過\n→ Step 13: 輸出 statuses 集合的大小 // 代表不同的最終狀態數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def flipLights(self, n: int, m: int) -> int:\n        # No button pressed\n        if m == 0:\n            return 1\n        # Only one bulb\n        if n == 1:\n            return 2\n        # Two bulbs\n        if n == 2:\n            return 4 if m > 1 else 3\n        # Three or more bulbs\n        if m == 1:\n            return 4\n        if m == 2:\n            return 7\n        return 8\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, presses = nums[0], nums[1]\n    result = Solution().flipLights(n, presses)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, presses = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode60.json",
    "problem_index_in_file": 0,
    "title": "Permutation Sequence",
    "description_snippet": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\n\nBy listing and labeling all o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo-code) line by line with explanation comments, not actual code. Problem: given n and k, return kth permutation sequence. This is classic Leetcode 60: permutation sequence. We produce algorithm using factorial numbers.\n\nWe need to generate steps: precompute factorials, adjust k-1, maintain list of digits 1..n, loop i from 1 to n, choose index = (k-1)/fact[n-i], pick that digit, remove from list, append to result, reduce k.\n\nWe need to produce virtual code step by step, each line with explanation. Use arrows, Start, End, Decision. Provide line numbers? Not required but we can just list each step. Use structure: Start, → Step 1: etc.\n\nMake sure each line is virtual code plus comment. Use arrows and decisions.\n\nLet's produce:\n\nStart\n→ Step 1: 計算 0~n 的階乘陣列 fact // 用於快速查詢階乘值\n→ Step 2: 初始化可用數字列表 digits 為 [1, 2, ..., n] // 供選取\n→ Step 3: 將 k 減 1 以轉為 0 起始索引 // 方便除法索引計算\n→ Decision: n 是否為 0? // 判斷是否有元素\n    Yes → Step 4: 回傳空字串 // n=0 時回傳空\n    No  → Step 5: 初始化 result 為空串 // 存儲最終排列\n→ Step 6: 循環 i 從 1 到 n\n    → Step 6a: 取得 blockSize = fact[n-i] // 每個區塊大小\n    → Step 6b: 計算 idx = k / blockSize // 選取數字索引\n    → Step 6c: 取出 digits[idx] 並加入 result // 選定數字\n    → Step 6d: 從 digits 刪除該元素 // 移除已選數字\n    → Step 6e: 更新 k = k % blockSize // 更新剩餘索引\n→ Step 7: 回傳 result // 完成\nEnd\n\nWe need to use arrow style: → Step 1 ... ; Decision: ... ; Yes → ; No →.\n\nWe also need each line to have \"虛擬碼步驟\" plus comment. We'll produce as above. Use \"Step 1:\" etc. Each line separate.\n\nMake sure we include \"→\" before each step line except Start? Start is separate.\n\nWe need to ensure each line ends with // explanation. Use no actual code.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 0~n 的階乘陣列 fact // 用於快速查詢階乘值  \n→ Step 2: 初始化可用數字列表 digits 為 [1, 2, ..., n] // 供選取  \n→ Step 3: 將 k 減 1 以轉為 0 起始索引 // 方便除法索引計算  \n→ Decision: n 是否為 0? // 判斷是否有元素  \n  Yes → Step 4: 回傳空字串 // n=0 時回傳空  \n  No → Step 5: 初始化 result 為空串 // 存儲最終排列  \n→ Step 6: 循環 i 從 1 到 n  \n  → Step 6a: 取得 blockSize = fact[n-i] // 每個區塊大小  \n  → Step 6b: 計算 idx = k / blockSize // 選取數字索引  \n  → Step 6c: 取出 digits[idx] 並加入 result // 選定數字  \n  → Step 6d: 從 digits 刪除該元素 // 移除已選數字  \n  → Step 6e: 更新 k = k % blockSize // 更新剩餘索引  \n→ Step 7: 回傳 result // 完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport math\n\ndef get_permutation(n: int, k: int) -> str:\n    \"\"\"\n    Return the k-th permutation sequence of numbers 1..n.\n    k is 1-indexed.\n    \"\"\"\n    numbers = list(range(1, n + 1))\n    k -= 1  # 轉成 0‑起始索引\n    result = []\n\n    for i in range(n, 0, -1):\n        fact = math.factorial(i - 1)\n        index = k // fact\n        result.append(str(numbers.pop(index)))\n        k %= fact\n\n    return ''.join(result)\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取 n 與 k，輸出對應的排列字串。\n    輸入範例:  n = 3, k = 3\n    輸出範例:  \"213\"\n    \"\"\"\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    permutation = get_permutation(n, k)\n    print(f'\"{permutation}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 3",
          "expected_output": "\"213\"",
          "success": true,
          "output": "\"213\""
        },
        {
          "example_index": 1,
          "input": "n = 4, k = 9",
          "expected_output": "\"2314\"",
          "success": true,
          "output": "\"2314\""
        },
        {
          "example_index": 2,
          "input": "n = 3, k = 1",
          "expected_output": "\"123\"",
          "success": true,
          "output": "\"123\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode744.json",
    "problem_index_in_file": 0,
    "title": "Find Smallest Letter Greater Than Target",
    "description_snippet": "You are given an array of characters letters that is sorted in non-decreasing order, and a character...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. The requirement: use virtual code arrow syntax, Start, End, Decision. Each line: virtual step then // explanation. The algorithm: find smallest char > target in sorted array; if none, return first char. Usually binary search. But we can use linear scan because sorted but complexity irrelevant. But produce efficient. We'll produce binary search: left=0,right=len-1, while left<right, mid=(left+right)//2, if letters[mid] <= target: left=mid+1 else: right=mid. After loop, result=letters[left] if letters[left]>target else letters[0]? Actually binary search ensures left is first index where letters[left] > target. But if none, left will be len, but we can't. So we can after loop, if letters[left] <= target: return letters[0] else return letters[left]. But easier: if letters[left] > target return letters[left] else letters[0]. But ensure left in bounds. We can also check if left==len: return letters[0]. So produce steps accordingly.\n\nVirtual code lines:\n\nStart\n→ Step 1: 初始化 left = 0, right = letters.length - 1 // 設定搜尋範圍\n→ Decision: while left < right? // 判斷是否還有未搜尋區間\n    Yes → Step 2: 計算 mid = (left + right) // 2 // 取中間索引\n        → Decision: letters[mid] <= target? // 比較中間字元是否小於等於目標\n            Yes → Step 3: left = mid + 1 // 若小於等於，移到右半邊\n            No  → Step 4: right = mid // 否則移到左半邊\n    No → // 跳出迴圈\n→ Decision: left == letters.length? // 檢查是否超過範圍\n    Yes → Step 5: return letters[0] // 無大於目標的字元，回傳第一個\n    No  → Step 6: return letters[left] // 回傳找到的最小大於目標的字元\nEnd\n\nBut note: after loop left may be index of first > target. But if left==len, then no greater; return letters[0]. But if left < len, we need to check if letters[left] > target. In case when left==len-1 and letters[left] <= target, loop would have ended with left==right and left==len-1, but since letters[left] <= target, we would incorrectly return that letter. So better condition: if letters[left] <= target: return letters[0] else return letters[left]. But we can handle with check. But our algorithm: while left < right ensures left moves until left==right, which will be the first index where letters[left] > target? Actually for binary search, we need to use while left < right: mid = (left + right)//2; if letters[mid] <= target: left = mid + 1 else: right = mid. After loop left==right; this index is the smallest index where letters[i] > target. But if all letters <= target, left will end up equal to letters.length - 1? Let's test: array [a,b,c], target='c'. Initially left=0,right=2. mid=1,b<=c so left=2. Now left==right==2. loop ends. left=2 index of 'c'. But letters[left] == 'c', not > target. But algorithm would return letters[left] which is wrong. So we need additional check: after loop, if letters[left] <= target: return letters[0]. else return letters[left]. So add decision after loop: letters[left] <= target? Then return letters[0] else return letters[left]. That is better.\n\nLet's produce lines accordingly.\n\nSo:\n\nStart\n→ Step 1: left = 0, right = letters.length - 1\n→ Decision: left < right? \n    Yes → Step 2: mid = (left + right) // 2\n        → Decision: letters[mid] <= target? \n            Yes → Step 3: left = mid + 1\n            No  → Step 4: right = mid\n    No → // loop end\n→ Decision: letters[left] <= target? // 檢查最終字元是否仍不大於目標\n    Yes → Step 5: return letters[0] // 若沒有大於目標的，回傳第一個\n    No  → Step 6: return letters[left] // 回傳最小大於目標的字元\nEnd\n\nBut we also need to handle when left==len? That would happen if all letters <= target? Let's test with array [a,b], target='b'. After loop left=1,right=1. letters[1]='b' <= target -> return letters[0]='a'. correct. So we don't need to check left==len. For array [a,b], target='a', loop: left=0,right=1, mid=0, letters[0]='a' <= target so left=1, left==right==1 exit, letters[1]='b'>target, return letters[1]. Works. For array [a,b], target='c', loop: left=0,right=1, mid=0, letters[0]='a' <= target => left=1, exit. letters[1]='b' <= target? yes, return letters[0] which is 'a'. But expected return letters[0] because no greater? Wait sorted array [a,b], target='c', there is no greater, should return first char 'a', yes. Good. For array [a,b], target='z', letters[1]='b' <= target true return letters[0]='a'. Works.\n\nSo algorithm fine.\n\nNow produce virtual code lines with comments.\n\nNeed to include virtual code arrows etc. Ensure each line includes step name and comment. Use \"Step\" etc. Should start with \"Start\" line. Then each line with \"→ Step ...\".\n\nBut the example uses \"Start // 程式開始執行\". So we do:\n\nStart // 程式開始執行\n\n→ Step 1: left = 0, right = letters.length - 1 // 設定搜尋範圍\n\n→ Decision: left < right? // 判斷是否還有未搜尋區間\n\n    Yes → Step 2: mid = (left + right) // 2 // 計算中間索引\n\n        → Decision: letters[mid] <= target? // 比較中間字元是否小於等於目標\n\n            Yes → Step 3: left = mid + 1 // 若小於等於，移到右半邊\n\n            No  → Step 4: right = mid // 否則移到左半邊\n\n    No  → // 迴圈結束\n\n→ Decision: letters[left] <= target? // 檢查最終字元是否仍不大於目標\n\n    Yes → Step 5: return letters[0] // 若沒有大於目標的，回傳第一個\n\n    No  → Step 6: return letters[left] // 回傳最小大於目標的字元\n\nEnd // 程式執行結束\n\nWe must ensure the formatting: each line has \"虛擬碼步驟\" and comment after space. For Decision lines, they should start with \"Decision:\"? The example uses \"Decision: 如果數字大於 0? // ...\". So we follow that.\n\nBut we also need to handle indentation? The example uses indentation for nested decisions. So we can use indentation spaces. For clarity, we can use 4 spaces for nested lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = letters.length - 1 // 設定搜尋範圍  \n→ Decision: left < right? // 判斷是否還有未搜尋區間  \n Yes → Step 2: mid = (left + right) // 2 // 計算中間索引  \n  → Decision: letters[mid] <= target? // 比較中間字元是否小於等於目標  \n   Yes → Step 3: left = mid + 1 // 若小於等於，移到右半邊  \n   No  → Step 4: right = mid // 否則移到左半邊  \n No  → // 迴圈結束  \n→ Decision: letters[left] <= target? // 檢查最終字元是否仍不大於目標  \n Yes → Step 5: return letters[0] // 若沒有大於目標的，回傳第一個  \n No  → Step 6: return letters[left] // 回傳最小大於目標的字元  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def nextGreatestLetter(self, letters, target):\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if letters[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return letters[left % len(letters)]\n\ndef parse_input(data: str):\n    # 找出字母列表\n    list_match = re.search(r'\\[.*?\\]', data)\n    letters = ast.literal_eval(list_match.group()) if list_match else []\n    # 找出目標字母\n    target_match = re.search(r'target\\s*=\\s*[\"\\'](.*?)[\"\\']', data)\n    target = target_match.group(1) if target_match else ''\n    return letters, target\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    letters, target = parse_input(data)\n    result = Solution().nextGreatestLetter(letters, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"a\"",
          "expected_output": "\"c\"",
          "success": true,
          "output": "c"
        },
        {
          "example_index": 1,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"c\"",
          "expected_output": "\"f\"",
          "success": true,
          "output": "f"
        },
        {
          "example_index": 2,
          "input": "letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"",
          "expected_output": "\"x\"",
          "success": true,
          "output": "x"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode496.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element I",
    "description_snippet": "The next greater element of some element x in an array is the first greater element that is to the r...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the described problem: find next greater element for elements in nums1 within nums2. Classic approach: use stack to compute next greater for all nums2, store in map, then iterate nums1. Provide steps line by line. The virtual code must use arrows and decision structure. Provide explanation. No real code. Ensure each line has \"虛擬碼步驟\" and comment. Use Start, End. Let's craft steps:\n\nStart\n→ Step 1: 初始化堆疊 stack 和映射 map // 用於儲存每個數字的下一個更大值\n→ Step 2: 反向遍歷 nums2 // 從右向左找下一個更大值\n→ Decision: 如果 stack 不是空且 stack.top <= nums2[i] // 判斷堆疊頂元素是否小於等於當前\n    Yes → → While stack 不空且 stack.top <= nums2[i] // 清除不合適的堆疊元素\n        → Step 3: 彈出 stack.top // 移除不大於 nums2[i] 的元素\n    No  → // 跳過\n→ Step 4: 如果 stack 空則 map[nums2[i]] = -1 否則 map[nums2[i]] = stack.top // 記錄下一個更大值\n→ Step 5: 將 nums2[i] 推入 stack // 讓它成為未來元素的候選更大值\n→ Decision: 如果 i > 0? // 迴圈結束判斷\n    Yes → → Back to Step 2 for i-1\n    No  → // 迴圈結束\n→ Step 6: 初始化答案陣列 ans // 用於儲存結果\n→ Step 7: 遍歷 nums1\n→ Step 8: 設置 ans[i] = map[nums1[i]] // 直接查表\n→ End // 返回 ans\n\nNeed to format each line with arrow \"→\" except Start/End. Decision lines need Yes/No.\n\nLet's write each step exactly. Ensure each line is separated. Provide brief explanation. Use Chinese. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 stack 與映射表 map // 用於儲存每個元素的下一個更大值  \n→ Step 2: 設定變數 n = nums2.length  \n→ Step 3: 反向遍歷 nums2（從右到左）  \n→ Decision: i >= 0? // 是否還有元素要處理  \n  Yes → → Step 4: 當前元素 cur = nums2[i] // 取得當前數字  \n     Decision: stack 不是空且 stack.top <= cur? // 判斷堆疊頂是否小於等於 cur  \n       Yes → → Step 5: While stack 不空且 stack.top <= cur  \n          → Step 6: 彈出 stack.top // 移除不大於 cur 的元素  \n          → Loop until condition false  \n       No → // 無需清除堆疊  \n       Step 7: 如果 stack 空則 map[cur] = -1 否則 map[cur] = stack.top // 記錄下一個更大值  \n       Step 8: push cur 到 stack // 將 cur 加入堆疊  \n       Step 9: i = i - 1 // 移動到前一個元素  \n       Go to Decision: i >= 0?  \n       No → // 所有 nums2 元素已處理  \n→ Step 10: 初始化答案陣列 ans 為長度 nums1.length  \n→ Step 11: 迭代索引 j 從 0 到 nums1.length-1  \n     → Step 12: ans[j] = map[nums1[j]] // 直接從映射表取得結果  \n→ End // 程式執行結束，ans 為最終結果陣列",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def nextGreaterElement(self, nums1, nums2):\n        stack = []\n        next_greater = {}\n        for num in nums2:\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n        return [next_greater.get(x, -1) for x in nums1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 尋找兩個數組的字面量表示\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) >= 2:\n        nums1 = ast.literal_eval(lists[0])\n        nums2 = ast.literal_eval(lists[1])\n    else:\n        # 如果格式不是 [ ... ]，試著用分號或逗號分隔\n        parts = data.split(',')\n        nums1 = ast.literal_eval(parts[0].split('=')[1].strip())\n        nums2 = ast.literal_eval(parts[1].split('=')[1].strip())\n\n    sol = Solution()\n    result = sol.nextGreaterElement(nums1, nums2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "success": true,
          "output": "[-1, 3, -1]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "success": true,
          "output": "[3, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode658.json",
    "problem_index_in_file": 0,
    "title": "Find K Closest Elements",
    "description_snippet": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the ar...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: find k closest to x. We can binary search to find the position to insert x. Then use two pointers left, right. While k elements not selected, compare differences and choose closer. Then collect results, sort ascending. Let's produce virtual code.\n\nWe need to output step-by-step with arrow etc.\n\nLet's write:\n\nStart\n→ Step 1: 取輸入陣列 arr, 整數 k, 整數 x\n→ Step 2: 用二分搜尋找 insertPos: 第一個大於等於 x 的索引\n→ Decision: 如果 insertPos 位置存在，則左右指標設定\n    → Step 3: 左指標 left = insertPos - 1\n    → Step 4: 右指標 right = insertPos\nElse (insertPos beyond array)\n    → Step 5: left = len(arr)-1\n    → Step 6: right = len(arr)\n→ Step 7: 建立空結果列表 result\n→ Step 8: 循環 k 次\n    → Decision: 左邊還有元素? left >=0\n        Yes → Decision: 右邊還有元素? right < len(arr)\n            Yes → Decision: |arr[left]-x| <= |arr[right]-x|?\n                Yes → Step 9: 把 arr[left] 加到 result, left--\n                No  → Step 10: 把 arr[right] 加到 result, right++\n            No → Step 11: 把 arr[left] 加到 result, left--\n        No → Decision: 右邊還有元素? right < len(arr)\n            Yes → Step 12: 把 arr[right] 加到 result, right++\n            No → Step 13: // 兩邊無元素，終止\n→ Step 14: 將 result 重新排序升序\n→ End\n\nAlso include maybe \"Decision:\" indentation.\n\nMake sure arrow formatting: \"→ Decision:\" with indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取輸入陣列 arr、整數 k、整數 x // 取得使用者傳入的資料  \n→ Step 2: 用二分搜尋找 insertPos：第一個 ≥ x 的索引 // 確定 x 在陣列中的插入位置  \n→ Decision: insertPos 有值? // 判斷 insertPos 是否在陣列範圍內  \n Yes → Step 3: 左指標 left ← insertPos - 1 // 左側起點  \n     Step 4: 右指標 right ← insertPos // 右側起點  \n No  → Step 5: 左指標 left ← len(arr) - 1 // 左側為陣列最後一個  \n     Step 6: 右指標 right ← len(arr) // 右側為陣列尾端（不存在的索引）  \n→ Step 7: 建立空列表 result // 用來儲存最近的 k 個數字  \n→ Step 8: 重複 k 次 // 每次選取一個最近的數字  \n  → Decision: left ≥ 0? // 左邊還有可選項?  \n   Yes → Decision: right < len(arr)? // 右邊還有可選項?  \n    Yes → Decision: |arr[left] - x| ≤ |arr[right] - x|? // 比較左右距離  \n     Yes → Step 9: 把 arr[left] 加到 result, left ← left - 1 // 選左側  \n     No  → Step 10: 把 arr[right] 加到 result, right ← right + 1 // 選右側  \n    No  → Step 11: 把 arr[left] 加到 result, left ← left - 1 // 只剩左側  \n  No  → Decision: right < len(arr)? // 只剩右側  \n   Yes → Step 12: 把 arr[right] 加到 result, right ← right + 1 // 選右側  \n   No  → Step 13: // 兩邊皆無元素，結束迴圈  \n→ Step 14: 將 result 重新排序為升序 // 確保輸出符合要求  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        # Binary search on start index of the window of size k\n        left, right = 0, len(arr) - k\n        while left < right:\n            mid = (left + right) // 2\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]\n\ndef parse_input(text):\n    \"\"\"\n    將輸入文字解析為 arr, k, x 三個變數。\n    期望輸入類似:  'arr = [1,2,3,4,5], k = 4, x = 3'\n    \"\"\"\n    arr_match = re.search(r'arr\\s*=\\s*(\\[[^\\]]*\\])', text)\n    k_match   = re.search(r'k\\s*=\\s*(-?\\d+)', text)\n    x_match   = re.search(r'x\\s*=\\s*(-?\\d+)', text)\n\n    if not arr_match or not k_match or not x_match:\n        raise ValueError(\"Input format is incorrect.\")\n    arr = eval(arr_match.group(1))\n    k   = int(k_match.group(1))\n    x   = int(x_match.group(1))\n    return arr, k, x\n\ndef main():\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        return\n    arr, k, x = parse_input(input_text)\n    sol = Solution()\n    result = sol.findClosestElements(arr, k, x)\n    # 輸出符合範例格式：無空格的列表\n    print('[' + ','.join(map(str, result)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "success": true,
          "output": "[1,2,3,4]"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "success": true,
          "output": "[1,1,2,3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode93.json",
    "problem_index_in_file": 0,
    "title": "Restore IP Addresses",
    "description_snippet": "A valid IP address consists of exactly four integers separated by single dots. Each integer is betwe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines with explanation. It's like a typical algorithm: backtracking. Provide steps. Ensure use arrow formatting.\n\nLet's craft:\n\nStart\n→ Step 1: 定義結果列表 result // 存儲有效IP\n→ Step 2: 定義遞迴函式 backtrack(start, parts) // start索引, parts已處理的段數\n→ Decision: 若 parts==4 且 start==len(s) // 完成四段且已用完字串\n    Yes → Step 3: 組合 parts 為IP並加入 result // 把parts用'.'連接存入結果\n    No  → Decision: 若 parts==4 或 start==len(s) // 已完成四段或無剩字\n        Yes → Step 4: 返回 // 結束此分支\n        No  → Step 5: 循環長度 len in {1,2,3}\n            → Decision: 若 start+len <= len(s) // 子字串不越界\n                Yes → Step 6: 取 sub = s[start:start+len] // 獲取候選段\n                → Decision: sub首位為'0'且len>1? // 檢查前導零\n                    Yes → Step 7: 跳過此長度 // 無效，繼續下一長度\n                    No  → Decision: 轉為int值 <=255 ?\n                        Yes → Step 8: 加入sub至parts並遞迴backtrack(start+len, parts+1) // 進一步探索\n                        No  → Step 9: 跳過此長度 // 超過255，繼續下一長度\n→ Step 10: 呼叫 backtrack(0, 0) // 從頭開始\n→ Step 11: 返回 result // 結果\n\nMake sure each line has arrow. Use \"→\" for sequence. For Decision use \"Decision:\".\n\nLet's produce lines exactly as format: \"Start // ...\". Use arrow indentation but keep each line one line.\n\nAlso note we may need to use indent for sub-steps, but they are still lines. The example shows indentation with spaces. So we can indent with 4 spaces for sub-steps.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義結果列表 result // 用來存放所有合法 IP\n→ Step 2: 定義遞迴函式 backtrack(start, parts) // start 是目前處理的位置，parts 是已確定的段數\n→ Decision: parts == 4 且 start == len(s) ? // 檢查是否已形成四段且完全用完字串\n    Yes → Step 3: result.append('.'.join(parts)) // 把已確定的四段用點連接後加入結果\n    No  → Decision: parts == 4 或 start == len(s) ? // 已達四段或字串已用完但不符合前一條件\n        Yes → Step 4: return // 結束此分支，回到上一層\n        No  → Step 5: for length in {1, 2, 3} // 嘗試各段長度\n            → Decision: start + length <= len(s) ? // 子字串不越界\n                Yes → Step 6: sub = s[start:start+length] // 取得候選段\n                → Decision: sub[0] == '0' 且 length > 1 ? // 前導零檢查\n                    Yes → Step 7: continue // 前導零且長度>1，跳過此長度\n                    No  → Decision: int(sub) <= 255 ? // 數值是否在 0~255 範圍\n                        Yes → Step 8: parts.append(sub) ; backtrack(start+length, parts+1) ; parts.pop() // 加入段後遞迴，回朔\n                        No  → Step 9: continue // 超過 255，跳過此長度\n→ Step 10: backtrack(0, 0) // 從字串開頭開始遞迴\n→ Step 11: return result // 回傳所有合法 IP\n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def restoreIpAddresses(self, s: str):\n        res = []\n\n        def backtrack(start: int, path: list):\n            # 若已分為四段且正好使用完字串，加入結果\n            if start == len(s) and len(path) == 4:\n                res.append(\".\".join(path))\n                return\n            # 若已超過四段或字串已使用完，回溯\n            if len(path) >= 4 or start == len(s):\n                return\n            # 嘗試 1、2、3 位長度\n            for length in range(1, 4):\n                if start + length > len(s):\n                    break\n                part = s[start:start + length]\n                # 前導零且長度>1 或數值超過 255 時跳過\n                if (part.startswith('0') and len(part) > 1) or int(part) > 255:\n                    continue\n                backtrack(start + length, path + [part])\n\n        backtrack(0, [])\n        return res\n\ndef parse_input() -> str:\n    \"\"\"\n    從標準輸入讀取字串，並抽取出 s 的值。\n    輸入範例可能是：\n        s = \"25525511135\"\n    或直接給出純數字字串。\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    # 先嘗試尋找第一個雙引號\n    first_quote = raw.find('\"')\n    if first_quote != -1:\n        second_quote = raw.find('\"', first_quote + 1)\n        if second_quote != -1:\n            return raw[first_quote + 1:second_quote]\n    # 若找不到雙引號，直接回傳去除空白的內容\n    return raw.replace('s = ', '').strip().strip('\"')\n\nif __name__ == \"__main__\":\n    s = parse_input()\n    solution = Solution()\n    result = solution.restoreIpAddresses(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"25525511135\"",
          "expected_output": "[\"255.255.11.135\",\"255.255.111.35\"]",
          "success": true,
          "output": "['255.255.11.135', '255.255.111.35']"
        },
        {
          "example_index": 1,
          "input": "s = \"0000\"",
          "expected_output": "[\"0.0.0.0\"]",
          "success": true,
          "output": "['0.0.0.0']"
        },
        {
          "example_index": 2,
          "input": "s = \"101023\"",
          "expected_output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
          "success": true,
          "output": "['1.0.10.23', '1.0.102.3', '10.1.0.23', '10.10.2.3', '101.0.2.3']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode393.json",
    "problem_index_in_file": 0,
    "title": "UTF-8 Validation",
    "description_snippet": "Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line with explanation comments. Problem: validate UTF-8 encoding for an array of integers (bytes). Steps: iterate array, determine leading bits to know length, check subsequent bytes for 10xxxxxx pattern. Edge cases: if insufficient bytes left, invalid. Also if leading byte pattern invalid (e.g., 10xxxxxx as start). Need virtual code with arrows and decisions.\n\nWe need to follow output format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, Yes → etc. We should not output actual code, only virtual steps.\n\nLet's craft a pseudocode:\n\nStart\n→ Initialize i = 0 // index\n→ Decision: while i < len(data)? // loop\n    Yes → Step: first_byte = data[i] & 0xFF // ensure byte\n    → Decision: if first_byte has leading 0 bit? // 1-byte\n        Yes → i = i + 1 // consume one byte\n        No  → Decision: determine number of leading 1 bits in first_byte // n\n            // If n==1 or n>4 -> invalid\n            → Decision: if n == 1 or n > 4? // invalid first byte\n                Yes → Return False // invalid\n                No → // valid start\n            → Decision: if i + n - 1 >= len(data)? // not enough bytes\n                Yes → Return False\n                No → // check continuation bytes\n                → Decision: for j from 1 to n-1:\n                    Yes → if data[i+j] has leading bits 10? // check\n                        // continue\n                    No → Return False\n                → i = i + n // consume n bytes\n    → Continue loop\n→ End // after loop, all bytes valid\n→ Return True\n\nNeed to structure decisions with arrows. Let's craft step lines.\n\nWe'll produce each step as separate line: maybe nested decisions use indentation.\n\nUse \"Decision:\" and then \"Yes →\" and \"No →\".\n\nWe need to include the decision of counting leading ones. Could separate step: Count leading ones.\n\nLet's produce.\n\nAlso need to ensure we output exactly one line per step. Use indentation maybe but it's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize i = 0 // 設定索引為 0\n→ Decision: i < len(data)? // 檢查是否還有未處理的位元組\n    Yes → Step: first_byte = data[i] & 0xFF // 取得目前位元組並取低 8 位\n    → Decision: (first_byte >> 7) == 0? // 判斷是否為 1 位元組字元\n        Yes → i = i + 1 // 單字元，直接往下\n        No  → Step: n = count_leading_ones(first_byte) // 計算連續 1 的個數\n        → Decision: (n == 1) or (n > 4)? // 第一個位元組是否為非法模式\n            Yes → Return False // 非法 UTF‑8 開頭\n            No  → // n 為 2~4，合法開頭\n        → Decision: i + n - 1 >= len(data)? // 檢查後續位元組是否足夠\n            Yes → Return False // 不足位元組，無法完成字元\n            No  → // 足夠位元組，進行後續位元組驗證\n            → Decision: for j in 1 to n-1:\n                Yes → (data[i+j] >> 6) == 0b10? // 判斷是否為 10xxxxxx 格式\n                    // 符合格式，繼續\n                No  → Return False // 連續位元組格式不符\n            → i = i + n // 消耗完此多位元組字元\n    → // 回到 Decision: i < len(data)? 循環\n→ End // 所有位元組均已驗證完畢\n→ Return True // 所有字元皆為合法 UTF‑8 編碼\n\n*注：`count_leading_ones(byte)` 為計算一個位元組中最左邊連續 1 的數量。*",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def validUtf8(self, data):\n        n_bytes = 0  # number of continuation bytes expected\n        for num in data:\n            byte = num & 0xFF  # only the lowest 8 bits are relevant\n            if n_bytes == 0:\n                # determine the number of leading 1 bits\n                mask = 0x80  # 10000000b\n                leading_ones = 0\n                while mask & byte:\n                    leading_ones += 1\n                    mask >>= 1\n                if leading_ones == 0:\n                    continue  # 1‑byte character\n                if leading_ones == 1 or leading_ones > 4:\n                    return False  # invalid first byte\n                n_bytes = leading_ones - 1  # remaining continuation bytes\n            else:\n                # continuation byte must start with '10'\n                if (byte & 0xC0) != 0x80:\n                    return False\n                n_bytes -= 1\n        return n_bytes == 0\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    # Expect input like: data = [197,130,1]\n    if '=' in input_data:\n        _, rhs = input_data.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = input_data\n    try:\n        data = ast.literal_eval(rhs)\n    except Exception:\n        print('false')\n        return\n    sol = Solution()\n    result = sol.validUtf8(data)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "data = [197,130,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "data = [235,140,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode475.json",
    "problem_index_in_file": 0,
    "title": "Heaters",
    "description_snippet": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed war...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for algorithm: given houses and heaters positions, find minimal radius r such that each house within distance r of at least one heater. Standard problem. Approach: sort houses and heaters. For each house, find nearest heater using binary search or two-pointer. Compute max distance needed. Steps: sort, for each house, find nearest heater: find insertion index. Compute distance to left and right heater; min distance; keep max. At end return max. So produce virtual code steps.\n\nWe need to output with format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. Start, Decision, etc.\n\nWe can outline algorithm.\n\nWe need to produce \"逐行\" output with virtual code steps and explanation. Should cover all steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort houses array in ascending order // 方便後續查找\n→ Step 2: Sort heaters array in ascending order // 同樣方便\n→ Step 3: Initialize variable maxRadius = 0 // 追蹤最小必要半徑\n→ For each housePosition in houses: // 遍歷每座房屋\n    → Step 4: Use binary search to find index idx where heater >= housePosition // 找最近右邊的暖氣\n    → Decision: If idx == 0? // 如果沒有左邊暖氣，最靠近的是右邊\n        Yes → Step 5: distance = heaters[idx] - housePosition // 只考慮右邊暖氣\n        No  → Step 5: distance = min(heaters[idx] - housePosition, housePosition - heaters[idx-1]) // 左右兩側取最近\n    → Step 6: If distance > maxRadius → maxRadius = distance // 更新最大距離\n→ End // 完成遍歷\n→ Return maxRadius // 返回最小半徑\n\nBut must use \"Decision:\" with Yes →, No →. So we need to indent accordingly. Use arrows.\n\nLet's produce full pseudo-code with each line. Each line ends with \"//\" explanation. Need to include Start, End. Use arrow \"→\" before each step except Start/End? Use \"→\" before each line. Example shows \"→ Step 1\". Yes.\n\nAlso need to use indentation for decision branches. Use \"Decision:\" with lines after indent.\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: Sort houses array ascending // 方便後續查找\n→ Step 2: Sort heaters array ascending // 同樣方便\n→ Step 3: maxRadius ← 0 // 追蹤最大所需半徑\n→ For each housePos in houses: // 遍歷每個房屋\n    → Step 4: idx ← BinarySearchFirstGreaterOrEqual(heaters, housePos) // 找右邊最近暖氣索引\n    → Decision: idx == 0? // 是否沒有左邊暖氣？\n        Yes → Step 5: dist ← heaters[idx] - housePos // 只考慮右側暖氣\n        No  → Step 5: dist ← min(heaters[idx] - housePos, housePos - heaters[idx-1]) // 左右兩側取較小距離\n    → Decision: dist > maxRadius? // 是否更新最大半徑？\n        Yes → Step 6: maxRadius ← dist // 更新最大半徑\n        No  → // 不更新\n→ End // 完成遍歷\n→ Return maxRadius // 回傳最小標準半徑\n\nCheck format: Need \"虛擬碼步驟\" each line. We need to ensure indentation with spaces. Use indentation to indicate nested.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort houses array ascending // 方便後續查找  \n→ Step 2: Sort heaters array ascending // 同樣方便  \n→ Step 3: maxRadius ← 0 // 追蹤最大所需半徑  \n→ For each housePos in houses: // 遍歷每個房屋  \n → Step 4: idx ← BinarySearchFirstGreaterOrEqual(heaters, housePos) // 找右邊最近暖氣索引  \n → Decision: idx == 0? // 是否沒有左邊暖氣？  \n  Yes → Step 5: dist ← heaters[idx] - housePos // 只考慮右側暖氣  \n  No  → Step 5: dist ← min(heaters[idx] - housePos, housePos - heaters[idx-1]) // 左右兩側取較小距離  \n → Decision: dist > maxRadius? // 是否更新最大半徑？  \n  Yes → Step 6: maxRadius ← dist // 更新最大半徑  \n  No  → // 不更新  \n→ End // 完成遍歷  \n→ Return maxRadius // 回傳最小標準半徑",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef find_radius(houses, heaters):\n    houses.sort()\n    heaters.sort()\n    res = 0\n    i = 0  # index of the nearest right heater\n\n    for house in houses:\n        # move to the heater that is closer to the house\n        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        # update the maximum required radius\n        res = max(res, abs(heaters[i] - house))\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list literals for houses and heaters\n    houses_match = re.search(r'houses\\s*=\\s*(\\[.*?\\])', data)\n    heaters_match = re.search(r'heaters\\s*=\\s*(\\[.*?\\])', data)\n\n    if not houses_match or not heaters_match:\n        print(\"0\")\n        sys.exit(0)\n\n    houses = ast.literal_eval(houses_match.group(1))\n    heaters = ast.literal_eval(heaters_match.group(1))\n\n    radius = find_radius(houses, heaters)\n    print(radius)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode591.json",
    "problem_index_in_file": 0,
    "title": "Tag Validator",
    "description_snippet": "Given a string representing a code snippet, implement a tag validator to parse the code and return w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for a tag validator per rules. The user wants step-by-step virtual code, each line with comment. We need to implement algorithm conceptually, not actual code. Use Start, Decision, etc. So outline steps: Start, parse string, ensure at least one closed tag, use stack, handle CDATA, check TAG_NAME validity, unmatched <, etc. Need to produce \"逐行\" lines.\n\nWe need to include virtual code arrows etc. So each line like \"Start // 程式開始執行\". We need to structure algorithm. Provide high-level logic: parse index i, check first '<', verify closed tag, etc. Use decision points.\n\nWe must ensure to cover rules. We'll produce algorithm that returns valid/invalid. Use stack of tag names, parse char by char, handle CDATA by skipping until \"]]>\". Use flag when inside CDATA to ignore tags. Also check tag name length and characters.\n\nWe'll produce about maybe 30-40 lines. Each line a step or decision. Use arrow \"→\" to indicate next step. Use \"Decision:\" lines.\n\nLet's design:\n\n1. Start\n2. → Step 1: Initialize index = 0, stack empty, flag insideCData = false\n3. → Decision: index < len? else invalid (empty string)\n4. → Step 2: If first char is not '<', invalid (must start with tag)\n5. → Step 3: Parse first tag. It must be a start tag or closed tag? According rule: code must be wrapped in a valid closed tag. So first tag should be a start tag of a closed tag. We'll parse the first start tag, then parse its content recursively until corresponding end tag.\n6. Use recursive parse function? But we can model with loop and stack.\n\nLet's produce pseudo code lines:\n\nStart\n→ Initialize i=0, stack empty, insideCDATA=false\n→ Decision: 是否為空？ // 如果字符串为空则无效\n    Yes → Return Invalid\n    No  → Continue\n→ Decision: 第一个字符是否为 '<'？\n    Yes → Continue\n    No  → Return Invalid\n→ Step: 解析第一个开始标签\n    Parse tag name between '<' and '>'\n→ Decision: tagName 是否有效？ // 1-9 uppercase\n    Yes → Push tagName onto stack\n    No  → Return Invalid\n→ Decision: 在 tagName 后是否紧跟 '>'？\n    Yes → Continue\n    No  → Return Invalid\n→ Step: 将 i 移至 '>' 后的位置\n→ Step: 开始解析内容直到遇到对应结束标签\nWe need a loop: while i < len\nInside loop:\n    If insideCDATA: find next \"]]>\", set i, continue\n    Else if current char is '<':\n        If next char is '/': parse end tag\n            parse end tag name\n            compare to stack top\n            if not match or stack empty => Invalid\n            else pop stack\n            if stack empty: // we reached outermost closing tag\n                // Ensure no extra chars after this\n                Check remaining chars: if any non-whitespace? maybe treat as invalid\n        Else if next char == '!' and following \"CDATA[\": start CDATA\n            set insideCDATA true, skip to after \"CDATA[\"\n        Else: parse start tag\n            parse tag name\n            if tagName invalid => Invalid\n            push onto stack\n            // continue parsing content inside\n    Else: normal character, just i++\n\nAlso need to ensure no unmatched '<' i.e., '<' without following '>'. So when encountering '<', search for next '>'.\n\nAdditionally, need to ensure after outermost closing tag there is no other non-whitespace characters.\n\nWe also need to ensure the content of CDATA is ignored for tags.\n\nAlso need to handle rule that inside content, cannot have unmatched <, start/end tags, etc. Our parsing will catch that.\n\nAlso check that after parsing whole string, stack should be empty and we have closed the outermost tag.\n\nOk, produce pseudo steps accordingly.\n\nAlso mention that we treat any characters inside tags and content as allowed except restrictions.\n\nLet's produce the virtual code lines accordingly. Use \"→ Decision:\" etc.\n\nWill produce about 35 lines.\n\nLet's start.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: i ← 0, stack ← empty, insideCDATA ← false // 初始化索引、棧及 CDATA 標誌\n→ Decision: 是否為空？ // 判斷字串是否為空\n    Yes → End ← Return 'Invalid' // 空字串不符合規則\n    No  → Continue\n→ Decision: 第 0 個字元是否為 '<'？ // 必須以起始標籤開頭\n    Yes → Continue\n    No  → End ← Return 'Invalid'\n→ Step 2: 解析第一個起始標籤 // <TAG_NAME>\n    tagStart ← i\n    tagEnd ← index of next '>' from i\n    If tagEnd == -1 → End ← Return 'Invalid' // < 未找到對應 >\n    tagName ← substring(i+1, tagEnd-1)\n→ Decision: tagName 是否符合規則 1-9 大寫英文字母？ // 規則3\n    Yes → Push tagName onto stack\n    No  → End ← Return 'Invalid'\n→ Step 3: i ← tagEnd + 1 // 移至標籤結束後的第一個位置\n→ Step 4: 開始主解析循環 // 逐字節解析內容\n→ Decision: i < len(string)？ // 是否還有未解析字元\n    Yes → Continue\n    No  → End ← Return 'Invalid' // 未找到結束標籤\n→ Step 5: 若 insideCDATA = true\n        → Find next occurrence of ']]>' from i\n        If 找不到 → End ← Return 'Invalid' // CDATA 未關閉\n        i ← index after ']]>' + 3\n        insideCDATA ← false\n        Continue // 跳過 CDATA 內部內容\n→ Decision: s[i] == '<'？ // 可能為標籤或 CDATA\n    Yes → Step 6: 判斷後續字元\n        → Decision: s[i+1] == '/'？ // 結束標籤\n            Yes → Step 7: 解析結束標籤\n                endTagStart ← i + 2\n                endTagEnd ← index of next '>' from i+2\n                If endTagEnd == -1 → End ← Return 'Invalid'\n                endTagName ← substring(endTagStart, endTagEnd-1)\n                If stack.isEmpty() → End ← Return 'Invalid' // 沒有對應起始標籤\n                topTag ← stack.pop()\n                If topTag ≠ endTagName → End ← Return 'Invalid' // TAG_NAME 不匹配\n                i ← endTagEnd + 1\n                If stack.isEmpty() → // 已關閉最外層標籤\n                    → Decision: i == len(string)？ // 之後不能再有字符\n                        Yes → End ← Return 'Valid'\n                        No  → End ← Return 'Invalid' // 末尾有多餘字元\n                Continue // 仍在解析\n            No  → Step 8: 判斷是否為 CDATA\n                → Decision: s[i+1] == '!' 且 s[i+2] == '[' 且 substring(i, i+9) == '<![CDATA['？\n                    Yes → insideCDATA ← true\n                        i ← i + 9 // 跳過 '<![CDATA['\n                        Continue\n                    No  → Step 9: 解析起始標籤\n                        startTagStart ← i + 1\n                        startTagEnd ← index of next '>' from i+1\n                        If startTagEnd == -1 → End ← Return 'Invalid' // < 未找到 >\n                        startTagName ← substring(startTagStart, startTagEnd-1)\n                        If startTagName 不符合規則 1-9 大寫英文字母 → End ← Return 'Invalid'\n                        stack.push(startTagName)\n                        i ← startTagEnd + 1\n                        Continue\n        No → // 非 '<' 字元，視為普通內容\n            i ← i + 1\n            Continue\n→ Decision: i < len(string)？ // 循環條件\n    Yes → 回到 Step 4\n    No  → End ← Return 'Invalid' // 解析完畢但仍未關閉標籤或有遺留字元\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isValid(self, code: str) -> bool:\n        stack = []\n        i = 0\n        n = len(code)\n        while i < n:\n            # 若已離開所有標籤但還有剩餘字元，則不合法\n            if i > 0 and not stack:\n                return False\n            # CDATA 區塊\n            if code.startswith(\"<![CDATA[\", i):\n                j = i + 9\n                k = code.find(\"]]>\", j)\n                if k == -1:\n                    return False\n                i = k + 3\n            # 結束標籤\n            elif code.startswith(\"</\", i):\n                j = i + 2\n                k = code.find(\">\", j)\n                if k == -1:\n                    return False\n                tag_name = code[j:k]\n                if not stack or stack[-1] != tag_name:\n                    return False\n                stack.pop()\n                i = k + 1\n            # 起始標籤\n            elif code[i] == '<':\n                j = i + 1\n                k = code.find(\">\", j)\n                if k == -1 or k == j or k - j > 9:\n                    return False\n                tag_name = code[j:k]\n                if not all('A' <= c <= 'Z' for c in tag_name):\n                    return False\n                stack.append(tag_name)\n                i = k + 1\n            else:\n                # 普通字元\n                i += 1\n        # 最終檢查：所有標籤已閉合且字串以 < 開頭、> 結尾\n        return not stack and code.startswith(\"<\") and code.endswith(\">\")\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"false\")\n        sys.exit(0)\n    # 解析輸入格式，如 code = \"<DIV>...</DIV>\"\n    if '=' in data:\n        _, rest = data.split('=', 1)\n        code = rest.strip()\n    else:\n        code = data.strip()\n    # 移除可能的雙引號或單引號\n    if (code.startswith('\"') and code.endswith('\"')) or (code.startswith(\"'\") and code.endswith(\"'\")):\n        code = code[1:-1]\n    # 建立解題器並判斷\n    solver = Solution()\n    result = solver.isValid(code)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "code = \"<A>  <B> </A>   </B>\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode679.json",
    "problem_index_in_file": 0,
    "title": "24 Game",
    "description_snippet": "You are given an integer array cards of length 4. You have four cards, each containing a number in t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the 24 game with 4 numbers. We will produce step-by-step pseudo-code with arrows, decisions, loops, recursion maybe. Provide explanation after each line. Must use the formatting rules. Each line: `虛擬碼步驟 // 解釋`.\n\nWe need to show algorithm: generate all permutations of numbers, all combinations of operations, all parenthesization possibilities. Use recursion/backtracking to try all possibilities, evaluate with real division. Return true if any expression equals 24 within tolerance.\n\nWe should produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義目標值 24 // 目標結果\n→ Step 2: 定義遞迴函數 dfs(nums) // 用於檢查數字組合\n→ Decision: nums 長度為 1? // 判斷是否僅剩一個數字\n    Yes → 判斷 nums[0] 是否接近 24? // 如果是，成功\n        Yes → Return true\n        No → Return false\n    No → // 進行二元運算\n→ For i from 0 to nums.length-1\n    For j from i+1 to nums.length-1\n        // 取兩個數字\n→ Compute所有可能的結果\n    For each result in results\n        // 生成新列表\n→ Call dfs(newNums) // 递归\n→ Decision: 递归返回 true? // 是否成功\n    Yes → Return true\n    No → Continue\n\nWe also need to ensure operations order and parentheses. The algorithm using pairwise combination automatically accounts for all parenthesizations.\n\nNeed to include division by zero check.\n\nAlso need to ensure we consider commutativity for + and * maybe but can ignore.\n\nWill produce final line End // 程式結束.\n\nWe need to ensure each line has a virtual code step followed by a space and comment. Use `→` arrow.\n\nLet's produce the lines.\n\nWe need to include the outer function check24(cards) returning true/false. Use recursion.\n\nLet's write:\n\nStart // 程式開始執行\n→ Function check24(cards) // 主函式，輸入卡片陣列\n    → Step 1: 目標值 target ← 24 // 定義要達到的數值\n    → Step 2: 定義遞迴函式 dfs(nums) // 用於嘗試所有組合\n        → Decision: nums.length == 1? // 若只剩一個數字\n            Yes → Decision: abs(nums[0] - target) < 1e-6? // 接近 24\n                Yes → Return true // 成功\n                No  → Return false // 失敗\n            No  → // 仍有多個數字，進行兩數運算\n        → For i in 0 .. nums.length-1\n            For j in i+1 .. nums.length-1\n                num1 ← nums[i]\n                num2 ← nums[j]\n                // 創建剩餘數字列表\n                newNums ← [nums[k] for k≠i,j] // 除去兩個數字\n                // 產生所有可能的運算結果\n                results ← []\n                → results.append(num1 + num2)\n                → results.append(num1 - num2)\n                → results.append(num2 - num1)\n                → results.append(num1 * num2)\n                → If num2 ≠ 0 then results.append(num1 / num2)\n                → If num1 ≠ 0 then results.append(num2 / num1)\n                → For each r in results\n                    → Append r to newNums to form nextNums\n                    → If dfs(nextNums) return true\n                        → Return true\n        → Return false // 所有嘗試結束仍未成功\n    → // 呼叫遞迴\n    → If dfs(cards) return true\n        → Return true\n        → Else return false\nEnd // 程式結束執行\n\nBut need to format each line with `虛擬碼步驟 // 解釋`. We must ensure each line is a single step, no multi-step lines. The pseudo code lines should be each line. We'll need to break the loops into multiple lines. For loops we can write as:\n\n→ For i from 0 to nums.length-1\n→ For j from i+1 to nums.length-1\n\nBut the indentation: use nested indentation with arrows? The example uses indentation with `Yes →` etc. We can use similar structure. But each line should contain a single step. Indentation with spaces is fine.\n\nLet's craft the output accordingly.\n\nWe must avoid actual code syntax, just pseudo. Use comments after each step. We must maintain arrow `→` for each step.\n\nAlso include division by zero check.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function check24(cards) // 主函式，輸入卡片陣列  \n → Step 1: 目標值 target ← 24 // 定義要達到的數值  \n → Step 2: 定義遞迴函式 dfs(nums) // 用於嘗試所有組合  \n  → Decision: nums.length == 1? // 若只剩一個數字  \n   Yes → Decision: abs(nums[0] - target) < 1e-6? // 接近 24  \n    Yes → Return true // 成功  \n    No → Return false // 失敗  \n   No → // 仍有多個數字，進行兩數運算  \n   → For i from 0 to nums.length-1 // 選取第一個數字  \n    → For j from i+1 to nums.length-1 // 選取第二個數字  \n     → num1 ← nums[i] // 第一次取數  \n     → num2 ← nums[j] // 第二次取數  \n     → newNums ← [] // 建立除去兩個數字後的數列  \n      → For k from 0 to nums.length-1 // 產生新數列  \n        Decision: k == i or k == j? // 排除已選取的數字  \n         Yes → // 跳過  \n         No  → newNums.append(nums[k]) // 加入剩餘數字  \n      → // 產生所有可能的運算結果  \n      → results ← [] // 存放運算結果  \n      → results.append(num1 + num2) // 加法  \n      → results.append(num1 - num2) // 減法 (順序 1)  \n      → results.append(num2 - num1) // 減法 (順序 2)  \n      → results.append(num1 * num2) // 乘法  \n      → Decision: num2 ≠ 0? // 分母不能為 0  \n       Yes → results.append(num1 / num2) // 除法 (順序 1)  \n      → Decision: num1 ≠ 0? // 分母不能為 0  \n       Yes → results.append(num2 / num1) // 除法 (順序 2)  \n      → // 逐一嘗試每個結果  \n      → For each r in results // 遍歷所有運算結果  \n        → nextNums ← newNums.clone() // 複製剩餘數字列表  \n        → nextNums.append(r) // 加入新結果  \n        → If dfs(nextNums) return true // 進行遞迴  \n         Yes → Return true // 成功，結束遞迴  \n        No → // 失敗，繼續嘗試其他結果  \n      → Return false // 所有嘗試結束仍未成功  \n → // 呼叫遞迴函式  \n → If dfs(cards) return true // 若遞迴成功  \n  Yes → Return true // 回傳成功  \n  No → Return false // 回傳失敗  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\ndef can_make_24(nums):\n    target = 24.0\n\n    def dfs(current):\n        if len(current) == 1:\n            return abs(current[0] - target) < 1e-6\n        n = len(current)\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                a, b = current[i], current[j]\n                remaining = [current[k] for k in range(n) if k != i and k != j]\n\n                # Generate all possible results of a op b\n                results = [a + b, a - b, a * b]\n                if b != 0:\n                    results.append(a / b)\n                if a != 0:\n                    results.append(b / a)\n\n                for val in results:\n                    if dfs(remaining + [val]):\n                        return True\n        return False\n\n    return dfs([float(x) for x in nums])\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract all integers from the input (inside brackets or elsewhere)\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) != 4:\n        print('false')\n        return\n    result = can_make_24(nums)\n    print('true' if result else 'false')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "cards = [4,1,8,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "cards = [1,2,1,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode557.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String III",
    "description_snippet": "Given a string s, reverse the order of characters in each word within a sentence while still preserv...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The problem: reverse characters in each word of a string s. Preserve whitespace and order of words. Virtual steps: start, input s, maybe iterate over string, split on words but preserve whitespace? Could do: split by spaces? But need preserve whitespace, meaning multiple spaces? Possibly use split preserving delimiters or scan characters: build result by reading characters: accumulate word, when encounter whitespace, output reversed word and whitespace. Or use regex to capture words and spaces. Virtual pseudocode: Start, Step 1: input string s. Step 2: initialize result string empty, wordBuffer empty. Step 3: for each char c in s: if c is not space: add to wordBuffer. else: reverse wordBuffer, append to result, append space, clear wordBuffer. After loop, handle last word. Step 4: output result. End.\n\nAdd Decision steps? Use simple loop.\n\nLet's produce lines with arrow and explanation. Use \"→\" for steps.\n\nNeed to use decision arrow? Could include decision for whitespace? But we can embed within loop.\n\nSimplify: Use loop step and decision inside. Use Start, End. Provide explanation after each line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得原始句子\n→ Step 2: 初始化空字串 result, 空字串 wordBuffer // 用於儲存結果與正在讀取的字\n→ Step 3: 循環遍歷 s 的每個字元 c // 逐字處理\n    → Decision: 如果 c 為空白字元? // 判斷是否為分隔符\n        Yes → Step 4a: 把 wordBuffer 反轉後追加到 result // 完成單詞反轉\n        Yes → Step 4b: 追加 c 到 result // 保留空白\n        Yes → Step 4c: 清空 wordBuffer // 為下一個單詞做準備\n        No  → Step 4d: 把 c 加入 wordBuffer // 累積單詞字元\n→ Step 5: 迴圈結束後，如果 wordBuffer 不為空, 反轉並追加到 result // 處理最後一個單詞\n→ Step 6: 輸出 result // 顯示反轉後的句子\nEnd // 程式執行結束\n\nNeed to add [空格] after each step before comment. Also indent decisions lines? The format sample shows indentation under Decision. Use same style.\n\nLet's ensure each line has \"虛擬碼步驟\" then space then comment. We'll include the \"Decision:\" line with arrow indent. Provide consistent formatting.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得原始句子  \n→ Step 2: 初始化空字串 result, 空字串 wordBuffer // 用於儲存結果與正在讀取的字  \n→ Step 3: 循環遍歷 s 的每個字元 c // 逐字處理  \n    → Decision: 如果 c 為空白字元? // 判斷是否為分隔符  \n        Yes → Step 4a: 把 wordBuffer 反轉後追加到 result // 完成單詞反轉  \n        Yes → Step 4b: 追加 c 到 result // 保留空白  \n        Yes → Step 4c: 清空 wordBuffer // 為下一個單詞做準備  \n        No  → Step 4d: 把 c 加入 wordBuffer // 累積單詞字元  \n→ Step 5: 迴圈結束後，如果 wordBuffer 不為空, 反轉並追加到 result // 處理最後一個單詞  \n→ Step 6: 輸出 result // 顯示反轉後的句子  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"Reverse each word in the string while keeping whitespace and order.\"\"\"\n        # Split on spaces so that consecutive spaces become empty strings.\n        # Reversing each word and joining preserves the original spacing.\n        return ' '.join(word[::-1] for word in s.split(' '))\n\ndef extract_input(raw: str) -> str:\n    \"\"\"\n    Extract the string value from an input that may be of the form:\n    s = \"some text\"\n    If no assignment is found, treat the entire raw input as the string.\n    \"\"\"\n    # Try to find a quoted string after an assignment.\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', raw)\n    if match:\n        return match.group(1)\n    # Fallback: strip whitespace and return the raw string.\n    return raw.strip()\n\ndef main():\n    # Read all input from stdin.\n    raw_input = sys.stdin.read()\n    # Extract the relevant string.\n    s = extract_input(raw_input)\n    # Process with the solution.\n    sol = Solution()\n    reversed_str = sol.reverseWords(s)\n    # Print the result surrounded by quotes as shown in the examples.\n    print(f'\"{reversed_str}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Let's take LeetCode contest\"",
          "expected_output": "\"s'teL ekat edoCteeL tsetnoc\"",
          "success": true,
          "output": "\"s'teL ekat edoCteeL tsetnoc\""
        },
        {
          "example_index": 1,
          "input": "s = \"Mr Ding\"",
          "expected_output": "\"rM gniD\"",
          "success": true,
          "output": "\"rM gniD\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode491.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Subsequences",
    "description_snippet": "Given an integer array nums, return all the different possible non-decreasing subsequences of the gi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a pseudo-code algorithm for generating all distinct non-decreasing subsequences of length >=2 from an integer array. Should be structured with Start, End, Decision, etc. Each line \"虛擬碼步驟 // 解釋\".\n\nLet's produce a clear step-by-step pseudocode.\n\nNeed to include backtracking DFS, maintain current subsequence, track visited results set to avoid duplicates, etc.\n\nWe need to keep pseudocode, not actual code.\n\nSo we produce:\n\nStart\n→ Initialize result set to store sequences\n→ Define recursive function DFS(index, current)\n→ ... etc.\n\nWe also need to handle duplicate sequences. Since subsequence may contain same numbers, we can use a set to store string representation or use nested loops.\n\nWe'll produce pseudocode:\n\nStart // 程式開始執行\n→ Step 1: Input array nums // 取得輸入陣列\n→ Step 2: Initialize resultSet as empty set // 用於存放唯一子序列\n→ Decision: If length(nums) < 2? // 若長度不足，無法生成子序列\n    Yes → End // 結束程序\n    No  → Step 3: 定義遞迴函式 DFS(pos, currentSeq) // 進行回溯搜尋\n→ Step 4: 呼叫 DFS(0, empty list) // 從索引 0 開始搜尋\n→ Step 5: 將 resultSet 轉成列表並回傳 // 輸出結果\nEnd // 程式執行結束\n\nWithin DFS we need steps.\n\nAdd to pseudocode:\n\n→ Step 3: 定義遞迴函式 DFS(pos, currentSeq)\n    → Step 3.1: 若 currentSeq 長度 ≥ 2，將其轉成 tuple 並加入 resultSet // 記錄有效子序列\n    → Step 3.2: Decision: 若 pos >= len(nums)? // 檢查是否到達結尾\n        Yes → Return // 回到上一層\n        No  → Step 3.3: For i from pos to len(nums)-1\n            → Decision: 若 currentSeq 為空 或 nums[i] >= last element of currentSeq? // 確保非遞減\n                Yes → Step 3.4: Append nums[i] 到 currentSeq // 選擇此元素\n                → Step 3.5: Call DFS(i+1, currentSeq) // 繼續搜尋\n                → Step 3.6: Remove last element from currentSeq // 回溯\n                No  → Continue // 不選此元素，跳到下一個\n\nBut must be sequential lines. Use arrow '→'.\n\nWe can embed loops as steps. But need each line as a step.\n\nWe can produce:\n\n→ Step 3: 定義遞迴函式 DFS(pos, currentSeq) // 建立遞迴\n    → Step 3.1: If len(currentSeq) ≥ 2 then add tuple(currentSeq) to resultSet // 儲存有效子序列\n    → Step 3.2: If pos == len(nums) then Return // 遞迴終止\n    → Step 3.3: For i in range(pos, len(nums)):\n        → Step 3.3.1: If currentSeq is empty OR nums[i] >= currentSeq[-1] then\n            → Step 3.3.1.1: Append nums[i] to currentSeq // 選擇元素\n            → Step 3.3.1.2: Call DFS(i+1, currentSeq) // 繼續遞迴\n            → Step 3.3.1.3: Remove last element from currentSeq // 回溯\n        → Step 3.3.2: Else continue // 不選擇\n\nWe must maintain indentation but each line as separate step.\n\nLet's produce a clear list. We'll also include variable names.\n\nAlso we need to mention using set to avoid duplicates. So in step 3.1, we convert list to tuple and add to set.\n\nWe also need to mention that the resultSet ensures uniqueness.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Input array nums // 取得輸入陣列\n→ Step 2: Initialize resultSet as empty set // 用於存放唯一子序列\n→ Decision: If length(nums) < 2? // 檢查是否足夠長\n    Yes → End // 無法產生子序列，結束\n    No  → Step 3: Define recursive function DFS(pos, currentSeq) // 建立遞迴\n        → Step 3.1: If len(currentSeq) ≥ 2 then add tuple(currentSeq) to resultSet // 儲存有效子序列\n        → Step 3.2: If pos == len(nums) then Return // 遞迴終止\n        → Step 3.3: For i from pos to len(nums)-1\n            → Step 3.3.1: Decision: If currentSeq is empty OR nums[i] ≥ last element of currentSeq? // 確保非遞減\n                Yes → Step 3.3.1.1: Append nums[i] to currentSeq // 選擇元素\n                → Step 3.3.1.2: Call DFS(i+1, currentSeq) // 繼續遞迴\n                → Step 3.3.1.3: Remove last element from currentSeq // 回溯\n                No  → Step 3.3.1.4: Continue // 跳過此元素\n        → Step 3.4: Return // 返回上一層\n→ Step 4: Call DFS(0, empty list) // 從索引 0 開始搜尋\n→ Step 5: Convert resultSet to list of lists and return // 輸出結果\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findSubsequences(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            if len(path) > 1:\n                res.append(path[:])\n            used = set()\n            for i in range(start, len(nums)):\n                if (not path or nums[i] >= path[-1]) and nums[i] not in used:\n                    used.add(nums[i])\n                    path.append(nums[i])\n                    backtrack(i + 1, path)\n                    path.pop()\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        nums = ast.literal_eval(match.group())\n    else:\n        nums = []\n\n    solution = Solution()\n    result = solution.findSubsequences(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,6,7,7]",
          "expected_output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
          "success": true,
          "output": "[[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]"
        },
        {
          "example_index": 1,
          "input": "nums = [4,4,3,2,1]",
          "expected_output": "[[4,4]]",
          "success": true,
          "output": "[[4, 4]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode535.json",
    "problem_index_in_file": 0,
    "title": "Encode and Decode TinyURL",
    "description_snippet": "Note: This is a companion problem to the System Design problem: Design TinyURL.\nTinyURL is a URL sho...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. We must design a class Solution with encode and decode methods. Use simple approach: maintain dictionary mapping short->long and long->short. Use a counter to generate unique IDs. Base62 encode.\n\nWe need to produce virtual code with Start, Decision, etc. Provide step-by-step logic of constructor, encode, decode.\n\nLet's create pseudocode. Ensure each line has arrow and explanation.\n\nWe may show:\n\nStart\n→ Initialize counter and dicts\n→ encode:\n    → If longUrl already in longToShort dict\n        → Return existing shortUrl\n    → Else generate new id, encode to base62 string\n    → Build shortUrl by prefix\n    → Store mapping\n    → Return shortUrl\n→ decode:\n    → Extract code part from shortUrl\n    → Lookup in shortToLong dict\n    → Return longUrl\n\nWe need to show virtual code with arrows etc. Use Decision steps where needed. Provide concise explanations.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 初始化對象 // 創建 Solution 對象，準備儲存編碼映射\n    → Counter ← 0 // 用於產生唯一的編碼 ID\n    → longToShort ← 空字典 // 以長網址為鍵存儲短網址\n    → shortToLong ← 空字典 // 以短網址為鍵存儲長網址\n\n→ Step 2: encode(longUrl) // 將長網址編碼為短網址\n    → Decision: 如果 longUrl 已存在於 longToShort? // 檢查是否已編碼過\n        Yes → Return longToShort[longUrl] // 直接返回已存在的短網址\n        No  → Decision: 生成新編碼? // 需要產生新的短網址\n            Yes → Counter ← Counter + 1 // ID 加 1，確保唯一\n            → code ← Base62Encode(Counter) // 將數字轉為 62 進制字符串\n            → shortUrl ← \"http://tinyurl.com/\" + code // 組合成完整短網址\n            → longToShort[longUrl] ← shortUrl // 建立長→短映射\n            → shortToLong[shortUrl] ← longUrl // 建立短→長映射\n            → Return shortUrl // 返回新生成的短網址\n\n→ Step 3: decode(shortUrl) // 從短網址恢復長網址\n    → Decision: 是否在 shortToLong 中? // 檢查映射是否存在\n        Yes → Return shortToLong[shortUrl] // 直接返回對應的長網址\n        No  → Return \"\" // (理論上不會發生，因為已保證短網址由同一個對象生成)\n\nEnd // 程式執行結束\n\n// Base62Encode 函式（虛擬碼示例）\n→ Function Base62Encode(num) // 將整數轉為 Base62 字符串\n    → chars ← \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    → code ← 空字符串\n    → While num > 0\n        → remainder ← num mod 62\n        → code ← chars[remainder] + code\n        → num ← num / 62\n    → Return code // 返回編碼字符串\n\n// 虛擬碼結束，所有步驟已按需求逐行列出並說明。",
      "generated_code": "import sys\n\nclass Solution:\n    \"\"\"簡易 TinyURL 編碼與解碼系統。\"\"\"\n\n    def __init__(self):\n        # 內部計數器，用於產生唯一編碼\n        self.counter = 0\n        # 基本短網址前綴\n        self.base_url = \"http://tinyurl.com/\"\n        # 長網址 ↔ 短網址映射\n        self.long_to_short = {}\n        self.short_to_long = {}\n\n    def _base62(self, num: int) -> str:\n        \"\"\"將整數轉換成 62 進制字串。\"\"\"\n        chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        if num == 0:\n            return \"0\"\n        res = []\n        while num:\n            num, r = divmod(num, 62)\n            res.append(chars[r])\n        return \"\".join(reversed(res))\n\n    def encode(self, longUrl: str) -> str:\n        \"\"\"\n        把長網址編碼成短網址。\n        如果相同長網址已經編碼過，直接返回已存在的短網址。\n        \"\"\"\n        if longUrl in self.long_to_short:\n            return self.long_to_short[longUrl]\n        self.counter += 1\n        code = self._base62(self.counter)\n        shortUrl = self.base_url + code\n        self.long_to_short[longUrl] = shortUrl\n        self.short_to_long[shortUrl] = longUrl\n        return shortUrl\n\n    def decode(self, shortUrl: str) -> str:\n        \"\"\"把短網址解碼回原始長網址。\"\"\"\n        return self.short_to_long.get(shortUrl, \"\")\n\n\ndef main():\n    # 從標準輸入讀取整行資料\n    raw_input = sys.stdin.read().strip()\n    # 去除可能存在的前後雙引號\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n    # 產生 Solution 實例\n    solver = Solution()\n    # 執行編碼與解碼\n    encoded = solver.encode(raw_input)\n    decoded = solver.decode(encoded)\n    # 將結果輸出\n    print(decoded)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"https://leetcode.com/problems/design-tinyurl\"",
          "expected_output": "\"https://leetcode.com/problems/design-tinyurl\"",
          "success": true,
          "output": "https://leetcode.com/problems/design-tinyurl"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode745.json",
    "problem_index_in_file": 0,
    "title": "Prefix and Suffix Search",
    "description_snippet": "Design a special dictionary that searches the words in it by a prefix and a suffix.\n\nImplement the W...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for design of special dictionary with prefix-suffix search. Steps: build data structure with Trie for prefixes and suffixes? Probably use trie mapping of words with all suffixes? Or use combined key pref + '#' + suff. Known solution: use dictionary mapping from pref+ '#' + suff to max index. Build for each word, all prefixes and suffixes combinations. Complexity large but acceptable. Provide virtual steps. We just need to output virtual code steps with explanation. Let's produce Start, Build dictionary mapping, f method. We'll include decisions. Use loops. Let's write virtual code step by step.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: WordFilter(words) // 建構函式，接受字串陣列  \n    → Step 1.1: 建立空字典 dict // 用來儲存所有(prefix + '#' + suffix) → 最大索引  \n    → Decision: 迭代每個單字 word 及其索引 idx 在 words 之中?  \n        → Yes → Step 1.2: 生成所有前綴 pref_list ← AllPrefixes(word) // 包含空字串  \n        → Decision: 迭代每個前綴 pref 在 pref_list?  \n            → Yes → Step 1.3: 生成所有後綴 suff_list ← AllSuffixes(word) // 包含空字串  \n            → Decision: 迭代每個後綴 suff 在 suff_list?  \n                → Yes → Step 1.4: key ← pref + '#' + suff // 組合鍵  \n                → Step 1.5: dict[key] ← idx // 覆寫或更新為最大索引（因 idx 逐步遞增）  \n            → No → 迭代結束  \n        → No → 迭代結束  \n    → No → 迭代結束  \n    → Step 1.6: 儲存 dict 為實例屬性 // 為後續查詢做準備  \n→ End // 建構完成  \n\n→ Step 2: f(pref, suff) // 查詢函式  \n    → Step 2.1: key ← pref + '#' + suff // 與建構時相同格式  \n    → Decision: key 是否存在於 dict?  \n        → Yes → Step 2.2: Return dict[key] // 取得最大索引  \n        → No  → Step 2.3: Return -1 // 無符合條件之單字  \n→ End // 函式結束",
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    \"\"\"特殊字典：根據前綴與後綴搜尋單字。\"\"\"\n\n    def __init__(self, words):\n        \"\"\"\n        建構函式：把所有單字的前綴和後綴組合存到字典中。\n        key 形式為 (prefix, suffix)，value 為單字在 words 中的最大索引。\n        \"\"\"\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # 產生所有前綴（從空字串到完整字串）\n            for i in range(L + 1):\n                pref = word[:i]\n                # 產生所有後綴（從空字串到完整字串）\n                for j in range(L + 1):\n                    suff = word[j:]\n                    self.lookup[(pref, suff)] = weight\n\n    def f(self, prefix, suffix):\n        \"\"\"回傳符合前綴 prefix 與後綴 suffix 的最大索引，若不存在則回傳 -1。\"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 把兩個列表用逗號分隔的字串轉成 Python 物件\n    # 例如： '[[\"apple\"]], [\"a\", \"e\"]'  -> ([\"apple\"], [\"a\", \"e\"])\n    expr = f'({raw})'\n    words, query = ast.literal_eval(expr)\n\n    # query 可能是 ['prefix', 'suffix'] 或者單一字串（如果只提供前綴）\n    if isinstance(query, (list, tuple)):\n        prefix, suffix = query[0], query[1]\n    else:\n        prefix, suffix = query, ''\n\n    wf = WordFilter(words)\n    result = wf.f(prefix, suffix)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpesb_v3mm.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmpesb_v3mm.py\", line 44, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpesb_v3mm.py\", line 21, in __init__\n    self.lookup[(pref, suff)] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode409.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindrome",
    "description_snippet": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanations. The problem: find length of longest palindrome that can be built from letters, case-sensitive. Approach: count frequencies, sum even counts fully, odd counts add (odd-1) for each, and add 1 if any odd exists.\n\nWe need virtual code lines. Steps: Start, Step 1: Input string s. Step 2: Initialize counter map. Step 3: For each char, increment count. Step 4: Initialize result = 0, oddExists = false. Step 5: For each count in map: if count is even: result += count. else: result += count - 1; oddExists = true. Step 6: If oddExists: result += 1. Step 7: Output result. End.\n\nWe need to use decision arrows. Let's incorporate Decision: if count%2==0? etc.\n\nWe must output each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrow symbols. E.g.,\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 從使用者取得字串\n→ Step 2: 建立字母頻率表 freq // 用於統計每個字母出現次數\n→ Step 3: 對於字串 s 中的每個字元 c: freq[c] += 1 // 逐字計數\n→ Step 4: 初始化 result = 0 // 儲存可組成的回文長度\n→ Step 5: 初始化 oddExists = false // 標記是否存在奇數頻率字母\n→ Decision: 對於 freq 中每個字母計數 count? // 遍歷頻率表\n    Yes → Decision: count 是偶數? // 檢查是否為偶數\n        Yes → Step 6: result += count // 偶數字母全用\n        No  → Step 7: result += count - 1 // 奇數字母減 1\n              → Step 8: oddExists = true // 標記存在奇數\n→ Decision: oddExists? // 是否有奇數字母\n    Yes → Step 9: result += 1 // 加一個中心字母\n    No  → No operation // 無奇數字母不需加\n→ Step 10: 輸出 result // 回傳最大回文長度\nEnd // 程式結束\n\nBut the decision formatting: The guidelines say use \"Decision:\" then sub-indentation with Yes → ... No → ... We need to be consistent.\n\nLet's produce final answer with each line following pattern. Ensure each line ends with // explanation.\n\nAlso include \"Start\" and \"End\" lines. Use \"Decision:\" with proper indent.\n\nAlso we need to handle loops: \"For each char in s: ...\" Use arrow. Let's produce.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者取得字串  \n→ Step 2: 建立空頻率表 freq // 用於統計每個字母出現次數  \n→ Step 3: For each 字元 c in s: freq[c] += 1 // 逐字計數  \n→ Step 4: 初始化 result = 0 // 儲存可組成的回文長度  \n→ Step 5: 初始化 oddExists = false // 標記是否存在奇數頻率字母  \n→ Decision: 遍歷 freq 中每個計數 count? // 對每個字母的頻率做處理  \n  Yes → Decision: count 為偶數? // 檢查是否為偶數  \n    Yes → Step 6: result += count // 偶數字母全部使用，長度加上其頻率  \n    No  → Step 7: result += count - 1 // 奇數字母減 1（只用偶數個）  \n     → Step 8: oddExists = true // 標記存在奇數字母，後續可加中心字母  \n  No → No operation // 沒有計數項則跳過（實際上不會發生）  \n→ Decision: oddExists? // 判斷是否有奇數頻率字母  \n  Yes → Step 9: result += 1 // 加一個中心字母，形成最大回文  \n  No  → No operation // 沒有奇數字母不需要額外加長  \n→ Step 10: 輸出 result // 回傳能構成的最大回文長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        \"\"\"\n        計算能以給定字串中的字母組成的最大回文長度。\n        方案：\n        1. 先統計每個字母出現的次數。\n        2. 對於偶數次數的字母，全數都能使用。\n        3. 對於奇數次數的字母，只能使用次數-1 個（保留一個給回文中心）。\n        4. 如果存在奇數次數的字母，最終回文長度再加 1。\n        \"\"\"\n        count = Counter(s)\n        length = 0\n        odd_found = False\n        for val in count.values():\n            if val % 2 == 0:\n                length += val\n            else:\n                length += val - 1\n                odd_found = True\n        if odd_found:\n            length += 1\n        return length\n\ndef main():\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    # 若輸入包含類似 's = \"abc\"' 的格式，剔除前導文字並取出引號中的字串\n    if raw_input.startswith('s ='):\n        first_quote = raw_input.find('\"')\n        last_quote = raw_input.rfind('\"')\n        if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n            s = raw_input[first_quote + 1:last_quote]\n        else:\n            # 失敗時直接去除前導文字\n            s = raw_input[3:].strip()\n    else:\n        s = raw_input\n\n    solution = Solution()\n    result = solution.longestPalindrome(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abccccdd\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode502.json",
    "problem_index_in_file": 0,
    "title": "IPO",
    "description_snippet": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Cap...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual algorithm for the problem: maximize capital after at most k projects, each requires capital[i] and gives profit[i]. Classic Leetcode problem 502. Approach: Use max-heap for profits among projects with capital <= current capital. Use min-heap for projects sorted by capital. Steps: sort projects by capital ascending. For i from 0 to n-1, push projects with capital <= w into maxProfit heap. For j in 1..k: if maxProfit empty break; pop max profit, add to w. Then after each addition, push new projects whose capital <= w. Finally return w.\n\nWe need to output step-by-step virtual code with explanations per line.\n\nLet's produce:\n\nStart\n→ Step 1: 將所有專案按資本需求升序排序 // 方便後續過濾可執行專案\n→ Step 2: 初始化指標 idx = 0 // 追蹤已加入堆的專案\n→ Step 3: 建立最大堆 maxProfit // 儲存可執行專案的利潤\n→ Decision: 是否已經執行了 k 個專案? // 循環最多 k 次\n    No → Step 4: 在 sorted list 中找出所有 capital[i] ≤ current capital 並加入 maxProfit // 將可執行專案的利潤加入堆\n        ← While idx < n 且 projects[idx].capital ≤ w\n            → maxProfit.add(projects[idx].profit)\n            → idx += 1\n    No → Decision: maxProfit 是否為空? // 沒有可執行專案時結束\n        Yes → End // 無法再增加資本\n        No  → Step 5: 取出最大利潤 profit = maxProfit.pop() // 選擇最有利可行的專案\n    No → Step 6: 更新現有資本 w += profit // 完成專案後增加資本\n    No → Step 7: 回到 Decision: 是否已經執行了 k 個專案? // 迴圈條件\nEnd // 回傳最終資本 w\n\nBut need to include all lines with virtual code arrow and explanation.\n\nWe should maintain each line as \"虛擬碼步驟 // 解釋\". Use arrows \"→\". Also Decision block: we need to indent lines properly.\n\nThe sample uses indentation with spaces. We can emulate.\n\nWe should produce:\n\nStart // 程式開始執行\n→ Step 1: Sort projects by capital ascending // 方便後續選擇可執行專案\n→ Step 2: idx ← 0 // 指標追蹤已加入堆的專案\n→ Step 3: maxProfit ← MaxHeap() // 儲存可執行專案的利潤\n→ Decision: 是否已執行 k 個專案? // 迴圈最多 k 次\n    No  → Step 4: while idx < n and projects[idx].capital ≤ w:\n        → maxProfit.add(projects[idx].profit)\n        → idx += 1\n    No  → Decision: maxProfit 為空? // 沒有可執行專案時結束\n        Yes → End // 無法再增加資本\n        No  → Step 5: profit ← maxProfit.pop() // 取出利潤最大的專案\n    No  → Step 6: w ← w + profit // 完成專案後更新資本\n    No  → Step 7: goto Decision // 回到迴圈條件\nEnd // 程式結束，返回最終資本\n\nBut we need to add comments after each line. Also need to maintain arrow for decisions and sub-indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort projects by capital ascending // 方便後續選擇可執行專案  \n→ Step 2: idx ← 0 // 指標追蹤已加入堆的專案  \n→ Step 3: maxProfit ← MaxHeap() // 儲存可執行專案的利潤  \n→ Decision: 是否已執行 k 個專案? // 迴圈最多 k 次  \n    No  → Step 4: while idx < n and projects[idx].capital ≤ w:  \n        → maxProfit.add(projects[idx].profit) // 將符合資本需求的專案利潤加入最大堆  \n        → idx += 1 // 移動指標到下一個專案  \n    No  → Decision: maxProfit 為空? // 若沒有可執行專案則結束  \n        Yes → End // 無法再增加資本，程式結束  \n        No  → Step 5: profit ← maxProfit.pop() // 取出利潤最大的專案  \n    No  → Step 6: w ← w + profit // 完成專案後更新現有資本  \n    No  → Step 7: goto Decision // 回到迴圈條件檢查是否還能再執行專案  \nEnd // 程式結束，返回最終資本 w",
      "generated_code": "import sys\nimport re\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k, W, Profits, Capital):\n        # 將所有專案按資本需求升序排序，方便後續挑選可執行專案\n        projects = sorted(zip(Capital, Profits))\n        max_heap = []          # 儲存可執行專案的利潤（用負值做最大堆）\n        i = 0                  # 指標追蹤已加入堆的專案\n        n = len(Profits)\n\n        for _ in range(k):\n            # 把所有目前可承擔的專案利潤加入最大堆\n            while i < n and projects[i][0] <= W:\n                heapq.heappush(max_heap, -projects[i][1])\n                i += 1\n            # 若沒有可執行專案，結束\n            if not max_heap:\n                break\n            # 取出利潤最大的專案並更新資本\n            W += -heapq.heappop(max_heap)\n\n        return W\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 解析形如 'k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]'\n    pattern = r'k\\s*=\\s*(\\d+),\\s*w\\s*=\\s*(\\d+),\\s*profits\\s*=\\s*(\\[.*?\\]),\\s*capital\\s*=\\s*(\\[.*?\\])'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    k = int(match.group(1))\n    w = int(match.group(2))\n    profits = eval(match.group(3))\n    capital = eval(match.group(4))\n\n    sol = Solution()\n    result = sol.findMaximizedCapital(k, w, profits, capital)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode242.json",
    "problem_index_in_file": 0,
    "title": "Valid Anagram",
    "description_snippet": "Given two strings s and t, return true if t is an anagram of s, and false otherwise....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for checking anagram. Use steps: start, input strings, compare lengths, sort, compare sorted, or use frequency map. Provide each line with explanation. Use Start, End, Decision. Use arrows. Provide each line of virtual code.\n\nLet's do:\n\nStart // program start\n→ Step 1: Read strings s and t // input\n→ Decision: If len(s) ≠ len(t)? // check length\n    No → Step 2: Initialize count map of 26 zeros // freq array\n    Yes → Step 3: Return false // lengths differ => not anagram\n→ Step 4: For each character c in s: increment count[c] // count s\n→ Step 5: For each character c in t: decrement count[c] // subtract t\n→ Decision: If any count ≠ 0? // check all zeros\n    No → Step 6: Return true // all counts zero => anagram\n    Yes → Step 7: Return false // mismatch\nEnd // program ends\n\nWe need each line with arrow? Use \"→\" before each step.\n\nMake sure to use indentation for decisions. Provide explanation after //.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s 與 t // 從使用者取得兩個字串  \n→ Decision: s 與 t 的長度是否相等? // 檢查字串長度是否相同  \n  Yes → Step 2: 初始化長度為 26 的計數陣列 count[26] 為 0 // 建立字母頻率表  \n  No  → Step 3: 回傳 false // 長度不同，不能為 anagram  \n→ Step 4: 對 s 中的每個字元 c: count[字母索引(c)]++ // 統計 s 的字母出現次數  \n→ Step 5: 對 t 中的每個字元 c: count[字母索引(c)]-- // 減去 t 的字母出現次數  \n→ Decision: 是否存在任何 count[i] ≠ 0? // 檢查所有字母的頻率是否為零  \n  Yes → Step 6: 回傳 false // 有字母頻率不為零，兩字串不是 anagram  \n  No  → Step 7: 回傳 true // 所有頻率皆為零，為 anagram  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef is_anagram(s: str, t: str) -> bool:\n    \"\"\"檢查兩字串是否為 anagram。\"\"\"\n    # 先用 Counter 比較兩個字串的頻率表\n    return Counter(s) == Counter(t)\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入資料中抓取字串 s 與 t。\n    這裡假設輸入格式類似：\n        s = \"anagram\", t = \"nagaram\"\n    若沒有符合的格式，則嘗試直接以空白分隔取得兩個字串。\n    \"\"\"\n    # 先找所有雙引號內的字串\n    quotes = re.findall(r'\"([^\"]*)\"', data)\n    if len(quotes) >= 2:\n        return quotes[0], quotes[1]\n    # 若無雙引號，嘗試以空白分隔\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # 若仍不足，回傳空字串\n    return \"\", \"\"\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    s, t = parse_input(raw_input)\n\n    # 判斷是否為 anagram，輸出小寫字串\n    result = is_anagram(s, t)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"anagram\", t = \"nagaram\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"rat\", t = \"car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode301.json",
    "problem_index_in_file": 0,
    "title": "Remove Invalid Parentheses",
    "description_snippet": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parenth...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce pseudocode for algorithm: given string s containing parentheses and letters, remove minimal invalid parentheses to produce all valid strings. It's classic problem Leetcode 301. We need algorithm: BFS or DFS with pruning, computing min removals. Approach: compute leftRem and rightRem counts (number of extra '(' and ')') to remove. Then backtrack to generate all possible valid strings. Use recursion to explore removals and skip duplicates.\n\nSimplify: Use DFS with parameters index, leftCount, rightCount, leftRem, rightRem, path string, results set. At each char: if char is letter, just add. If '(' and leftRem>0, we can skip. If ')' and rightRem>0, skip. If '(' add and leftCount++. If ')' add if leftCount>0 else skip. At end, if index==len and leftRem==0 && rightRem==0 && leftCount==rightCount, add to set.\n\nBut we also need minimal removals; the counts computed ensure that.\n\nAlternate BFS approach: generate all strings by removing one char at a time, use set to avoid duplicates, and stop when we find first level of valid strings.\n\nBut pseudocode easier: BFS.\n\nWe'll produce pseudocode lines with steps and explanation. Use virtual code arrows. We'll produce Start, BFS queue, visited set, result set. While queue not empty: pop current. If valid: add to result, set found flag. Continue exploring deeper only if not found. For each position in current string: if char is '(' or ')', generate new string with that char removed. If new string not visited, add to queue.\n\nReturn result.\n\nInclude explanation each line.\n\nLet's produce lines accordingly. Use virtual code with arrows. Provide explanation after //.\n\nMake sure each line is \"虛擬碼步驟 // 解釋/說明\". Use \"Start\" \"End\".\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 queue ← [s] // 將原始字串加入 BFS 隊列  \n→ Step 2: 初始化 visited ← {s} // 記錄已處理的字串以避免重複  \n→ Step 3: 初始化 result ← ∅ // 儲存符合條件的最小刪除結果  \n→ Step 4: 初始化 found ← False // 判斷是否已找到最小刪除層級的有效字串  \n\n→ Decision: 若 queue 非空? // 若還有字串待處理  \n    Yes → Step 5: 從 queue 取出 front → current // 取下一個字串進行檢查  \n        → Decision: 若 current 為有效字串? // 檢查括號配對是否正確  \n            Yes → Step 6: 加入 current 至 result // 符合條件的字串加入結果集  \n                → Step 7: 設定 found ← True // 只需要同層級的最小刪除結果  \n                → Decision: 若已經找到最小刪除字串? // 是否停止進一步搜尋同層級字串  \n                    Yes → Step 8: 跳過後續生成新字串，直接返回隊列下一項  \n                    No  → Step 9: (實際上已在 found 為 True 時不會執行此路徑)  \n            No  → Decision: 若已找到最小刪除字串? // 若已找到，則不再生成更深層字串  \n                Yes → Step 10: 跳過生成後續子字串，繼續 while 迴圈  \n                No  → Step 11: 從 current 產生所有可能的子字串  \n                    → Decision: 對每個位置 i (0 ≤ i < len(current))?  \n                        Yes → Step 12: 若 current[i] 為 '(' 或 ')'  \n                            → Step 13: 生成 new ← current[0:i) + current(i+1:)] // 刪除位置 i 的括號  \n                                → Decision: 若 new 未在 visited?  \n                                    Yes → Step 14: 加入 new 至 queue // 新字串加入待處理隊列  \n                                        → Step 15: 加入 new 至 visited // 標記已處理  \n                                    No  → Step 16: 跳過，因已處理  \n                        No  → Step 17: 位置 i 不是括號，跳過  \n\n→ Decision: queue 是否空?  \n    Yes → End // BFS 完成，返回結果  \n    No  → 迴圈回到 Step 4 開始下一輪  \n\n// 之後輸出 result 集合中的所有字串即可。",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Remove the minimum number of invalid parentheses to make the input string valid.\n        Return all possible results in a list.\n        \"\"\"\n        # Helper to check if a string is valid\n        def is_valid(string: str) -> bool:\n            count = 0\n            for ch in string:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # BFS level set\n        level = {s}\n        while level:\n            # Find all valid strings in current level\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid\n\n            # Generate next level by removing one parenthesis\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        next_item = item[:i] + item[i+1:]\n                        if next_item not in next_level:\n                            next_level.add(next_item)\n            level = next_level\n\n        return []\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Parse input data to extract the string s.\n    Handles formats like: 's = \"()())()\"' or just '\"()())()\"'\n    \"\"\"\n    data = data.strip()\n    if '=' in data:\n        _, value = data.split('=', 1)\n        value = value.strip()\n    else:\n        value = data\n    # Remove surrounding quotes if present\n    if len(value) >= 2 and value[0] == value[-1] and value[0] in ('\"', \"'\"):\n        return value[1:-1]\n    return value\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    results = solution.removeInvalidParentheses(s)\n    # Print results as a JSON array to match the example output format\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "success": true,
          "output": "[\"(a())()\", \"(a)()()\"]"
        },
        {
          "example_index": 2,
          "input": "s = \")(\"",
          "expected_output": "[\"\"]",
          "success": true,
          "output": "[\"\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode482.json",
    "problem_index_in_file": 0,
    "title": "License Key Formatting",
    "description_snippet": "You are given a license key represented as a string s that consists of only alphanumeric characters ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: reformat license key. Provide step-by-step pseudocode with explanation after each line. Should be line by line with arrows and decisions. Let's produce steps: Start, remove dashes, convert to uppercase, reverse string maybe easier to group from end. Or iterate from end to form groups. Approach: Clean string, uppercase, iterate from end building groups of k, insert dash. Finally reverse groups.\n\nPseudo:\n\nStart\n→ Step 1: Remove all dashes from s and store in cleaned // remove separators\n→ Step 2: Convert cleaned to uppercase // standardize\n→ Step 3: Initialize empty list groups // to hold groups\n→ Step 4: Initialize index i = length of cleaned - 1 // start from end\n→ Decision: while i >= 0? // loop over characters\n    Yes → Step 5: Determine end index = i\n    → Step 6: Determine start index = max(0, i - k + 1) // k chars\n    → Step 7: Extract substring cleaned[start:end+1] // group\n    → Step 8: Insert substring at front of groups // maintain order\n    → Step 9: Set i = start - 1 // move left\n    No → Step 10: Join groups with dashes into result // final string\nEnd\n\nBut need to explain each line. Provide comments after space.\n\nMake sure use arrow notation properly: \"→ Step 1:\" etc.\n\nInclude decisions: \"Decision: i >= 0?\" with Yes branch.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: cleaned ← RemoveAll(s, '-') // 把字串 s 裡所有 '-' 刪除，只留下字母與數字  \n→ Step 2: cleaned ← ToUpperCase(cleaned) // 轉成全大寫字母，統一格式  \n→ Step 3: groups ← EmptyList() // 用來儲存每一個重新分組的字串  \n→ Step 4: i ← Length(cleaned) - 1 // 從字串最後一個字元開始倒序處理  \n→ Decision: i ≥ 0? // 仍有未處理的字元嗎？  \n  Yes → Step 5: end ← i // 當前組的右端索引  \n    → Step 6: start ← Max(0, i - k + 1) // 確定當前組左端索引，保證組長不超過 k  \n    → Step 7: sub ← Substring(cleaned, start, end) // 取得從 start 到 end 的子字串  \n    → Step 8: InsertAtFront(groups, sub) // 把此組放到 list 前面，維持正序  \n    → Step 9: i ← start - 1 // 移動到前一個未處理的字元位置  \n  No → Step 10: result ← Join(groups, '-') // 把所有組以 '-' 連接起來  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        # 移除所有 '-' 並轉成大寫\n        S = S.replace('-', '').upper()\n        n = len(S)\n        # 第一組長度，若能被 K 整除則整組長度為 K\n        first_group_len = n % K or K\n        res = [S[:first_group_len]]\n        for i in range(first_group_len, n, K):\n            res.append(S[i:i + K])\n        return '-'.join(res)\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入資料中解析出字串 s 與整數 k。\n    支援以下格式：\n    1. s = \"xxxxx\", k = 4\n    2. 兩行輸入：第一行是字串，第二行是整數\n    3. 單行空白分隔：xxxxx 4\n    \"\"\"\n    # 先嘗試匹配 \"s = \\\"...\\\", k = ...\"\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if s_match and k_match:\n        s = s_match.group(1)\n        k = int(k_match.group(1))\n        return s, k\n\n    # 分行方式\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        s = lines[0]\n        try:\n            k = int(lines[1])\n            return s, k\n        except ValueError:\n            pass\n\n    # 單行空白分隔\n    parts = data.split()\n    if len(parts) >= 2:\n        s = parts[0]\n        try:\n            k = int(parts[1])\n            return s, k\n        except ValueError:\n            pass\n\n    raise ValueError(\"輸入格式不符合要求\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, k = parse_input(raw_input)\n    sol = Solution()\n    result = sol.licenseKeyFormatting(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "success": true,
          "output": "5F3Z-2E9W"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "success": true,
          "output": "2-5G-3J"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode373.json",
    "problem_index_in_file": 0,
    "title": "Find K Pairs with Smallest Sums",
    "description_snippet": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nD...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find k pairs with smallest sums from two sorted arrays. Known solution: use min-heap (priority queue). Push first pair of each first element with nums2[0], or push (i,0) for all i up to k-1? Actually algorithm: Use min-heap storing tuples (sum, i, j). Initially push (nums1[i]+nums2[0], i, 0) for i in 0..min(k, len(nums1))-1. Then iterate up to k times: pop smallest, add to result, if j+1 < len(nums2), push (nums1[i]+nums2[j+1], i, j+1). Complexity O(k log k). Provide virtual code line by line with explanation.\n\nNeed to adhere to format: each line: 虛擬碼步驟 [space] // 解釋/說明. Use arrows and decision. Must start with Start, End.\n\nLet's produce.\n\nWe also need to show loops and decisions. Use \"For\" loop: \"For i = 0 to min(k, len(nums1))-1\". Use \"→\". Provide explanation.\n\nWe should include variable definitions. Provide priority queue.\n\nWill produce:\n\nStart // 開始程序\n→ Step 1: 定義變數 m ← length(nums1), n ← length(nums2) // 取得兩陣列長度\n→ Step 2: 定義 minHeap ← 空最小堆 // 儲存 (sum, i, j) 以取得最小和\n→ Step 3: 定義 result ← 空列表 // 儲存最小 k 對\n→ Decision: 如果 k = 0? // 若 k 為 0，直接返回空結果\n    Yes → Step 4: Return result // 回傳空列表\n    No  → Decision: 如果 nums1 為空 或 nums2 為空? // 檢查是否有數字可配對\n        Yes → Step 5: Return result // 若任一陣列空，回傳空\n        No  → Step 6: 執行初始化 minHeap\n→ Step 6: For i = 0 to min(k, m)-1 // 只取前 k 個第一陣列元素\n    → Step 7: Push (nums1[i] + nums2[0], i, 0) 到 minHeap // 初始配對 (i,0)\n→ Step 8: For count = 1 to k\n    → Decision: 如果 minHeap 為空? // 若沒有更多配對可取\n        Yes → Step 9: Break // 結束迴圈\n        No  → Step 10: Pop (sum, i, j) ← minHeap // 取得和最小的配對\n        → Step 11: Append (nums1[i], nums2[j]) 到 result // 存入結果\n        → Decision: 如果 j + 1 < n? // 是否還有第二陣列的下一個元素\n            Yes → Step 12: Push (nums1[i] + nums2[j+1], i, j+1) 到 minHeap // 推入下一個 j\n            No  → Step 13: // 不做任何事\n→ End // 程式結束，回傳 result\n\nBut need to show final return statement at end. Add Step 14: Return result // 返回最小 k 對\n\nAlso include explanation after each.\n\nMake sure each line has \"→\" for steps inside loops or decisions. Use \"Decision:\" for if statements.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 m ← length(nums1), n ← length(nums2) // 取得兩陣列長度  \n→ Step 2: 定義 minHeap ← 空最小堆 // 儲存 (sum, i, j) 以取得最小和  \n→ Step 3: 定義 result ← 空列表 // 儲存最小 k 對  \n→ Decision: 如果 k = 0? // 若 k 為 0，直接返回空結果  \n    Yes → Step 4: Return result // 回傳空列表  \n    No  → Decision: 如果 nums1 為空 或 nums2 為空? // 檢查是否有數字可配對  \n        Yes → Step 5: Return result // 若任一陣列空，回傳空  \n        No  → Step 6: // 繼續執行初始化 minHeap  \n→ Step 6: For i = 0 to min(k, m)-1 // 只取前 k 個第一陣列元素  \n    → Step 7: Push (nums1[i] + nums2[0], i, 0) 到 minHeap // 初始配對 (i,0)  \n→ Step 8: For count = 1 to k // 取 k 次最小配對  \n    → Decision: 如果 minHeap 為空? // 若沒有更多配對可取  \n        Yes → Step 9: Break // 結束迴圈  \n        No  → Step 10: Pop (sum, i, j) ← minHeap // 取得和最小的配對  \n        → Step 11: Append (nums1[i], nums2[j]) 到 result // 存入結果  \n        → Decision: 如果 j + 1 < n? // 是否還有第二陣列的下一個元素  \n            Yes → Step 12: Push (nums1[i] + nums2[j+1], i, j+1) 到 minHeap // 推入下一個 j  \n            No  → Step 13: // 不做任何事  \n→ Step 14: Return result // 回傳最小 k 對  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nimport heapq\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        if not nums1 or not nums2 or k <= 0:\n            return []\n        heap = []\n        res = []\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n        while heap and len(res) < k:\n            sum_val, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        return res\n\ndef parse_input(data: str):\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums1_match or not nums2_match or not k_match:\n        return [], [], 0\n    nums1 = ast.literal_eval(nums1_match.group(1))\n    nums2 = ast.literal_eval(nums2_match.group(1))\n    k = int(k_match.group(1))\n    return nums1, nums2, k\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    nums1, nums2, k = parse_input(raw)\n    sol = Solution()\n    result = sol.kSmallestPairs(nums1, nums2, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "success": true,
          "output": "[[1, 2], [1, 4], [1, 6]]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "success": true,
          "output": "[[1, 1], [1, 1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode732.json",
    "problem_index_in_file": 0,
    "title": "My Calendar III",
    "description_snippet": "A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm of MyCalendarThree. Essentially, we need to maintain events and compute maximum concurrent events at any time after each booking. Classic solution: use a difference map or segment tree. Use sweep line: maintain map of time points to delta; when booking, add +1 at start, -1 at end; then recompute maximum by iterating through sorted keys accumulating sum. However that would be O(n^2). Better: use a segment tree with lazy propagation for range add and max query. But maybe simpler virtual code: maintain list of events; each book, add to list, recompute max by scanning all events (O(n^2) but ok). But for clarity, we can implement difference map and maintain current max by scanning map each time. Let's produce virtual code steps for MyCalendarThree class.\n\nWe need to produce virtual code line by line with arrow and explanation. Let's create steps:\n\n- Start: class MyCalendarThree\n\n- Constructor: initialize events list or difference map.\n\n- book(start, end): update difference map.\n\n- compute max: iterate sorted keys, accumulate current overlaps, keep max.\n\n- return max.\n\nLet's output each step accordingly.\n\nWe should not output actual code, only virtual steps.\n\nWe'll include arrows:\n\nStart\n\n→ Step: Initialize diffMap // map to store time points and delta\n\n→ Step: maxOverlap = 0 // variable to hold current maximum\n\n→ Step: MyCalendarThree() // constructor // initialize diffMap and maxOverlap\n\n→ Step: book(startTime, endTime) // method to add event and compute maximum\n\n→ Step: diffMap[startTime] += 1 // increment count at start\n\n→ Step: diffMap[endTime] -= 1 // decrement count at end\n\n→ Step: current = 0 // current overlap counter\n\n→ Step: currentMax = 0 // temporary max for this booking\n\n→ Step: Iterate over diffMap sorted by time\n\n→ Step: current += delta // update current overlap\n\n→ Step: if current > currentMax then currentMax = current // update max\n\n→ Step: maxOverlap = currentMax // update overall max\n\n→ Step: return maxOverlap // return result\n\nEnd\n\nBut we need \"Decision:\" lines maybe not necessary. Just linear steps. Use arrow \"→\".\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 初始化 diffMap 為空字典 // 用來記錄每個時間點的變化量 (+1 開始, -1 結束)\n→ Step: maxOverlap ← 0 // 全局最大同時重疊事件數\n→ Step: MyCalendarThree() // 建構子，初始化資料結構\n→ Step: book(startTime, endTime) // 新增事件並回傳目前最大 k-booking\n→ Step: diffMap[startTime] ← diffMap.get(startTime, 0) + 1 // 在開始時間點加一\n→ Step: diffMap[endTime] ← diffMap.get(endTime, 0) - 1 // 在結束時間點減一\n→ Step: current ← 0 // 當前重疊數量\n→ Step: currentMax ← 0 // 本次計算得到的最大重疊數\n→ Step: 依時間排序遍歷 diffMap 的 key, delta // 以時間順序掃描所有事件變化\n    → Step: current ← current + delta // 更新當前重疊數\n    → Step: 如果 current > currentMax? // 判斷是否有更高重疊\n        Yes → currentMax ← current // 更新本次最大重疊\n→ Step: maxOverlap ← currentMax // 更新全局最大值\n→ Step: return maxOverlap // 回傳目前的最大 k-booking\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\nimport bisect\n\nclass MyCalendarThree:\n    def __init__(self):\n        self.timeline = []\n\n    def book(self, start, end):\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n        active = 0\n        max_active = 0\n        for time, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two input lists\n    split_idx = data.find('],')\n    if split_idx == -1:\n        raise ValueError(\"Input format incorrect.\")\n    first_part = data[:split_idx + 1]\n    second_part = data[split_idx + 2:]\n    commands = ast.literal_eval(first_part)\n    args_list = ast.literal_eval(second_part)\n\n    cal = MyCalendarThree()\n    results = [None]  # constructor returns null\n    for cmd, args in zip(commands[1:], args_list[1:]):  # skip the first \"MyCalendarThree\"\n        if cmd == \"book\":\n            res = cal.book(*args)\n            results.append(res)\n        else:\n            # In case other methods are added later\n            results.append(None)\n\n    # Output the result list using JSON to get `null` for None\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "success": true,
          "output": "[null, 1, 1, 2, 3, 3, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode162.json",
    "problem_index_in_file": 0,
    "title": "Find Peak Element",
    "description_snippet": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search approach. Each line with arrow and explanation. We'll follow format. We'll produce Start, then input array. Then set low=0, high=n-1. While low<high: mid=(low+high)/2. If nums[mid] < nums[mid+1], low=mid+1 else high=mid. End loop. Return low. Each step with explanation. Use decision arrows. Ensure each line includes virtual code step then comment. Use `→` arrow. Ensure start, end. We'll produce multi-line. Use indentation for decisions. Provide explanation in Chinese. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums，並取得長度 n // 從使用者處取得整數陣列與其長度  \n→ Step 2: 初始化 low = 0, high = n - 1 // 設定二分搜尋的左右邊界  \n→ Decision: low < high? // 檢查搜尋範圍是否還有效  \n    Yes → Step 3: 計算 mid = (low + high) / 2 // 找出中間索引  \n    → Decision: nums[mid] < nums[mid + 1]? // 判斷中點是否小於右側鄰居  \n        Yes → Step 4: low = mid + 1 // 若小於右鄰，峰必在右半部，更新 low  \n        No  → Step 5: high = mid // 若不小於右鄰，峰必在左半部或是 mid，更新 high  \n    Yes → 回到 Decision: low < high? // 重新檢查搜尋範圍，若仍有效則重複循環  \n    No  → Step 6: 回傳 low // low 已指向一個峰元素的索引，結束搜尋  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_peak(nums):\n    \"\"\"找出任何一個峰值的索引，使用 O(log n) 的二分搜尋。\"\"\"\n    if not nums:\n        return -1\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef main():\n    # 從標準輸入讀取整行文字\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中提取陣列\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        print(\"0\")  # 若無合法陣列，預設輸出 0\n        return\n\n    nums_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(nums_str)\n        if not isinstance(nums, list):\n            nums = []\n    except Exception:\n        nums = []\n\n    # 呼叫演算法並輸出結果\n    peak_index = find_peak(nums)\n    print(peak_index)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,3,5,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode736.json",
    "problem_index_in_file": 0,
    "title": "Parse Lisp Expression",
    "description_snippet": "You are given a string expression representing a Lisp-like expression to return the integer value of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for evaluating a Lisp-like expression. The user wants the pseudocode for the evaluator. We should produce step-by-step algorithm: parse tokens, use stack for scopes, recursive evaluation, handling let, add, mult. Provide virtual code line by line with comments. No actual code. Use Start, End, Decision, etc. Use arrow lines. Let's produce algorithm. Let's break into high-level steps: tokenize, parse, evaluate recursively, maintain scopes as stack of dictionaries. We'll create Evaluate(expression) function. Use recursion or stack. For let, evaluate each pair with new scope. etc.\n\nLet's produce. Use arrow \"→\". For decisions use \"Decision:\". Also include comments. Provide each step as \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Tokenize the input string into a list of tokens (parentheses, words, numbers) // 將輸入字串拆成單一字元/字串以便解析  \n→ Step 2: Call Evaluate(tokens, scopeStack) // 進入主評估流程，scopeStack 先為空列表  \n→ Decision: tokens 是否只剩一個？ // 判斷是否已經到達單一值  \n  Yes → Step 3: 若 tokens[0] 是 整數，返回 整數值 // 整數直接返回  \n  No  → Step 4: 若 tokens[0] 為變數名稱，查找 scopeStack 取得值並返回 // 變數需依照最近範圍查找  \n→ Step 5: tokens[0] 為 '('，開始解析複合式表達式 // 進入括號內部  \n→ Step 6: 讀取 tokens[1] 為關鍵字 (add / mult / let) // 確定操作類型  \n  Decision: 關鍵字是 \"add\"？  \n   Yes → Step 7: 解析 e1 = Evaluate(tokens[2], scopeStack)  \n    Decision: tokens[3] 為 ')'？  \n     No → Step 8: 解析 e2 = Evaluate(tokens[3], scopeStack)  \n     返回 e1 + e2 // 加法結果  \n   No  \n    Decision: 關鍵字是 \"mult\"？  \n     Yes → Step 9: 解析 e1 = Evaluate(tokens[2], scopeStack)  \n      Decision: tokens[3] 為 ')'？  \n       No → Step 10: 解析 e2 = Evaluate(tokens[3], scopeStack)  \n       返回 e1 * e2 // 乘法結果  \n     No  \n      Decision: 關鍵字是 \"let\"？  \n       Yes → Step 11: 建立新的局部字典 newScope = {}  \n       Push newScope 到 scopeStack // 新範圍加入堆疊  \n       Set idx = 2 // 開始解析變數/表達式對  \n       Loop: idx < tokens.length-1（最後一個是 expr）  \n        Decision: tokens[idx] 是否為變數？  \n         Yes → Step 12: v = tokens[idx]  \n          e = Evaluate(tokens[idx+1], scopeStack) // 先評估表達式再賦值  \n          newScope[v] = e // 存入當前 scope  \n          idx += 2  \n         No → // 到達最後的 expr  \n          exprValue = Evaluate(tokens[idx], scopeStack) // 評估 expr  \n          Pop newScope 從 scopeStack // 退出當前範圍  \n          返回 exprValue  \n        No → // 不是 let、add、mult，錯誤不處理  \n→ End // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        def tokenize(expr: str):\n            \"\"\"Split expr into top‑level tokens ignoring nested parentheses.\"\"\"\n            tokens = []\n            bal = 0\n            start = 0\n            for i, ch in enumerate(expr):\n                if ch == '(':\n                    bal += 1\n                elif ch == ')':\n                    bal -= 1\n                elif ch == ' ' and bal == 0:\n                    tokens.append(expr[start:i])\n                    start = i + 1\n            tokens.append(expr[start:])\n            return tokens\n\n        def eval_expr(expr: str, env: dict):\n            # Simple value or variable\n            if expr[0] != '(':\n                if expr[0].isalpha():\n                    return env[expr]\n                return int(expr)\n\n            # Strip outer parentheses and tokenize\n            inner = expr[1:-1]\n            toks = tokenize(inner)\n            op = toks[0]\n\n            if op == 'add':\n                return eval_expr(toks[1], env) + eval_expr(toks[2], env)\n            elif op == 'mult':\n                return eval_expr(toks[1], env) * eval_expr(toks[2], env)\n            elif op == 'let':\n                new_env = env.copy()\n                i = 1\n                # Process pairs until the last token (the expression to evaluate)\n                while i < len(toks) - 1:\n                    var = toks[i]\n                    val = eval_expr(toks[i + 1], new_env)\n                    new_env[var] = val\n                    i += 2\n                return eval_expr(toks[-1], new_env)\n            # Should not reach here for valid inputs\n            raise ValueError(f\"Unknown operator: {op}\")\n\n        return eval_expr(expression, {})\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the expression part after '=' if present\n    if '=' in data:\n        expr_part = data.split('=', 1)[1].strip()\n    else:\n        expr_part = data\n\n    # Remove surrounding quotes if any\n    if expr_part and expr_part[0] in ('\"', \"'\") and expr_part[-1] == expr_part[0]:\n        expr_part = expr_part[1:-1]\n\n    solution = Solution()\n    result = solution.evaluate(expr_part)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "success": true,
          "output": "14"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode87.json",
    "problem_index_in_file": 0,
    "title": "Scramble String",
    "description_snippet": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the st...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that determine if s2 is a scrambled string of s1. We should design a recursive algorithm similar to Leetcode 87. We must produce step-by-step lines with explanation. Must use arrow notation. Use decision nodes. Start, End. Let's create steps:\n\nStart\n→ Step 1: 比對 s1 與 s2 是否相同 // 若完全相同則為真\n→ Decision: 長度是否相等? // 必須相等才能比較\n    No  → Step 2: 回傳 False // 長度不等\n    Yes → Decision: s1 是否與 s2 相等? // 直接匹配\n        Yes → Step 3: 回傳 True\n        No → Decision: s1 是否為亂序? // 若字母分布不同則不可能\n            Yes → Step 4: 逐個分割點 i 從 1 到 len-1\n                → Decision: 是否存在分割使兩段匹配? // 分析\n                    -> Yes → Step 5: recursively判斷對應段\n                    -> No → Step 6: 繼續\n                → If any i success -> 回傳 True\n            No → Step 7: 回傳 False\n\nBut we need more structured. Use recursion function isScramble(a,b).\n\nDefine function isScramble(s1, s2):\nStart // 開始\n→ Step 1: 若 s1==s2 → return True // identical\n→ Decision: s1長度是否等於 s2長度? \n    No → Step 2: return False\n    Yes → Decision: 字符頻數是否相同? // Quick prune\n        No → Step 3: return False\n        Yes → Decision: s1長度是否為1? \n            Yes → Step 4: return True // single char already matched earlier\n            No → Decision: 對於 i in 1..len-1? // iterate splits\n                → Decision: \n                    - 不交換情況: isScramble(s1[:i], s2[:i]) 並且 isScramble(s1[i:], s2[i:])\n                    - 交換情況: isScramble(s1[:i], s2[-i:]) 並且 isScramble(s1[i:], s2[:-i])\n                → If any true → Step 5: return True\n            → Step 6: return False\nEnd\n\nBut we need to produce virtual code lines with arrows and decision. We need to use \"Decision:\" lines. Use \"Yes →\", \"No →\". Use indentation.\n\nLet's format each line with one step and comment.\n\nAlso we may need to mention recursion call.\n\nLet's produce as:\n\nStart // 程式開始執行\n→ Step 1: 定義遞迴函式 isScramble(s1, s2) // 判斷兩字串是否為亂碼\n→ Step 2: 進入 isScramble(s1, s2)\n→ Decision: s1 是否等於 s2? // 直接相等即為亂碼\n    Yes → Step 3: 回傳 True // 完全相同\n    No  → Decision: s1 長度是否等於 s2 長度? // 必須同長\n        No  → Step 4: 回傳 False // 長度不同不可能\n        Yes → Decision: s1 及 s2 的字母頻數是否相同? // 先檢查字符統計\n            No  → Step 5: 回傳 False // 字符不匹配\n            Yes → Decision: s1 長度是否為 1? // 單字元已在第一步處理\n                Yes → Step 6: 回傳 True\n                No  → Decision: 對於 i 從 1 到 len-1? // 逐個可能的分割點\n                    → Step 7: 建立兩種情況檢查\n                        - 情況A: isScramble(s1[:i], s2[:i]) 並且 isScramble(s1[i:], s2[i:])\n                        - 情況B: isScramble(s1[:i], s2[-i:]) 並且 isScramble(s1[i:], s2[:-i])\n                    → Decision: 是否存在 i 使上述任一情況為 True?\n                        Yes → Step 8: 回傳 True // 找到合法分割\n                        No  → Step 9: 回傳 False // 所有分割點皆不符合\n\nBut the \"Decision:\" after loop maybe not typical. Let's restructure:\n\nAfter loop, if no return true, return false.\n\nWe need to present line by line; each line includes arrow or decision. Use indentation for nested steps.\n\nWe should include Start and End.\n\nLet's craft final output.\n\nAlso each line must end with comment. Use //.\n\nAlso need to not output actual code; only virtual steps. So we can show function call but not actual code. Use pseudocode.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義遞迴函式 isScramble(s1, s2) // 用於判斷兩字串是否為亂碼\n→ Step 2: 呼叫 isScramble(s1, s2) // 進行主判斷\n→ Decision: s1 是否等於 s2? // 直接相等即為亂碼\n    Yes → Step 3: 回傳 True // 完全相同，成立\n    No  → Decision: s1 長度是否等於 s2 長度? // 必須同長才可能\n        No  → Step 4: 回傳 False // 長度不同，立刻失敗\n        Yes → Decision: s1 與 s2 的字母頻數是否相同? // 先做快速排除\n            No  → Step 5: 回傳 False // 字符分布不一致，無法亂碼\n            Yes → Decision: s1 長度是否為 1? // 單字元已在第一步處理\n                Yes → Step 6: 回傳 True // 單字元相同即為亂碼\n                No  → Decision: 對於 i 從 1 到 len(s1)-1? // 逐一嘗試分割點\n                    → Step 7: 檢查兩種可能\n                        - 情況 A: isScramble(s1[:i], s2[:i]) 並且 isScramble(s1[i:], s2[i:])\n                        - 情況 B: isScramble(s1[:i], s2[-i:]) 並且 isScramble(s1[i:], s2[:-i])\n                    → Decision: 是否存在某個 i 使上述任一情況為 True?\n                        Yes → Step 8: 回傳 True // 找到合法分割，結束\n                        No  → Step 9: 回傳 False // 所有分割點皆不符合\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom functools import lru_cache\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n\n        @lru_cache(maxsize=None)\n        def dfs(x: str, y: str) -> bool:\n            if x == y:\n                return True\n            if sorted(x) != sorted(y):\n                return False\n            n = len(x)\n            for i in range(1, n):\n                # No swap case\n                if dfs(x[:i], y[:i]) and dfs(x[i:], y[i:]):\n                    return True\n                # Swap case\n                if dfs(x[:i], y[-i:]) and dfs(x[i:], y[:-i]):\n                    return True\n            return False\n\n        return dfs(s1, s2)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to extract quoted strings first\n    quotes = re.findall(r'\"([^\"]*)\"', data)\n    if len(quotes) >= 2:\n        s1, s2 = quotes[0], quotes[1]\n    else:\n        # Fallback: split by whitespace or comma\n        parts = re.split(r'[\\s,]+', data)\n        parts = [p for p in parts if p]\n        if len(parts) >= 2:\n            s1, s2 = parts[0], parts[1]\n        else:\n            # If still not enough parts, assume whole line as first string\n            s1 = parts[0]\n            s2 = ''\n\n    solution = Solution()\n    result = solution.isScramble(s1, s2)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"great\", s2 = \"rgeat\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"abcde\", s2 = \"caebd\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s1 = \"a\", s2 = \"a\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode34.json",
    "problem_index_in_file": 0,
    "title": "Find First and Last Position of Element in Sorted Array",
    "description_snippet": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending positio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode with line-by-line explanation. For searching in sorted array, use binary search to find leftmost and rightmost positions. We'll produce virtual code. Use Start, End, Decision, Yes, No arrows. Provide step-by-step. Use binary search subfunctions maybe. Let's craft.\n\nAlso need to note complexity. Provide explanation.\n\nMake sure not to output actual code. Use virtual code steps.\n\nLet's produce:\n\nStart\n→ Step 1: 定義 low ← 0, high ← len(nums) - 1 // 初始化二分搜索範圍\n→ Step 2: 定義 left ← -1, right ← -1 // 存儲結果\n→ Decision: 如果 low > high? // 判斷陣列是否為空\n    Yes → End // 直接返回結果\n    No → Step 3: 開始尋找左邊界\n→ Step 3: → Step 3.1: While low ≤ high:\n→ Step 3.1.1: mid ← (low + high) // 2 // 計算中點\n→ Step 3.1.2: Decision: nums[mid] < target? // 中點小於目標\n        Yes → low ← mid + 1 // 移動左側\n        No → Decision: nums[mid] > target? // 中點大於目標\n            Yes → high ← mid - 1 // 移動右側\n            No → left ← mid // 找到目標\n                // 但還需繼續向左尋找更小的索引\n                high ← mid - 1 // 保持左側搜索\n→ Step 4: Reset low ← 0, high ← len(nums) - 1 // 重置範圍以尋找右邊界\n→ Step 5: 開始尋找右邊界\n→ Step 5.1: While low ≤ high:\n→ Step 5.1.1: mid ← (low + high) // 2 // 計算中點\n→ Step 5.1.2: Decision: nums[mid] > target? // 中點大於目標\n        Yes → high ← mid - 1 // 移動右側\n        No → Decision: nums[mid] < target? // 中點小於目標\n            Yes → low ← mid + 1 // 移動左側\n            No → right ← mid // 找到目標\n                // 但還需繼續向右尋找更大的索引\n                low ← mid + 1 // 保持右側搜索\n→ Step 6: Return [left, right] // 輸出結果\nEnd\n\nBut must use arrows accordingly. Let's format each line with \"→\" etc. Ensure each line has explanation after //.\n\nAlso ensure no actual code syntax? They allow some pseudo. We must avoid actual code like python or variable assignment? But we can use pseudo assignments. It's okay.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0, high ← len(nums) - 1 // 初始化二分搜尋範圍  \n→ Step 2: left ← -1, right ← -1 // 預設結果為未找到  \n→ Decision: low > high? // 判斷陣列是否為空  \n  Yes → End // 直接結束並返回 [-1, -1]  \n  No  → Step 3: // 開始尋找左邊界  \n→ Step 3: // 進行第一輪二分搜尋，尋找最左側的 target  \n  While low ≤ high: // 繼續搜尋直到範圍縮小  \n    mid ← (low + high) // 2 // 取中點索引  \n    Decision: nums[mid] < target? // 中點小於目標  \n      Yes → low ← mid + 1 // 移動左側邊界至 mid+1  \n      No  → Decision: nums[mid] > target? // 中點大於目標  \n        Yes → high ← mid - 1 // 移動右側邊界至 mid-1  \n        No  → left ← mid // 找到目標，記錄索引  \n          high ← mid - 1 // 繼續向左搜尋更小的索引  \n→ Step 4: low ← 0, high ← len(nums) - 1 // 重置範圍以尋找右邊界  \n→ Step 5: // 進行第二輪二分搜尋，尋找最右側的 target  \n  While low ≤ high: // 繼續搜尋直到範圍縮小  \n    mid ← (low + high) // 2 // 取中點索引  \n    Decision: nums[mid] > target? // 中點大於目標  \n      Yes → high ← mid - 1 // 移動右側邊界至 mid-1  \n      No  → Decision: nums[mid] < target? // 中點小於目標  \n        Yes → low ← mid + 1 // 移動左側邊界至 mid+1  \n        No  → right ← mid // 找到目標，記錄索引  \n          low ← mid + 1 // 繼續向右搜尋更大的索引  \n→ Step 6: Return [left, right] // 輸出最左與最右位置  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef find_left(nums, target):\n    left, right = 0, len(nums) - 1\n    index = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] >= target:\n            right = mid - 1\n        else:\n            left = mid + 1\n        if nums[mid] == target:\n            index = mid\n    return index\n\ndef find_right(nums, target):\n    left, right = 0, len(nums) - 1\n    index = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] <= target:\n            left = mid + 1\n        else:\n            right = mid - 1\n        if nums[mid] == target:\n            index = mid\n    return index\n\ndef search_range(nums, target):\n    return [find_left(nums, target), find_right(nums, target)]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract nums array\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if nums_match and target_match:\n        nums_str = nums_match.group(1)\n        target_str = target_match.group(1)\n        try:\n            nums = ast.literal_eval(nums_str)\n            target = int(target_str)\n        except Exception:\n            nums, target = [], 0\n    else:\n        nums, target = [], 0\n    result = search_range(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,7,7,8,8,10], target = 8",
          "expected_output": "[3,4]",
          "success": true,
          "output": "[3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [5,7,7,8,8,10], target = 6",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        },
        {
          "example_index": 2,
          "input": "nums = [], target = 0",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode771.json",
    "problem_index_in_file": 0,
    "title": "Jewels and Stones",
    "description_snippet": "You're given strings jewels representing the types of stones that are jewels, and stones representin...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code line by line, with arrow. It's a simple algorithm: count occurrences of jewels in stones. Steps: input strings, create set of jewels, iterate stones, count if char in set, output count.\n\nWe must output each line as \"虛擬碼步驟 // 解釋\". Include Start, End, Decision. Use arrow → and Yes→ No→.\n\nLet's craft:\n\nStart // program start\n\n→ Input jewels // read jewel string\n\n→ Input stones // read stones string\n\n→ Create set JewelSet from jewels // build set for O(1) lookup\n\n→ Initialize count = 0 // counter\n\n→ For each char in stones // iterate stones\n\n    → Decision: if char in JewelSet? // check if stone is jewel\n\n        Yes → Increment count // increment counter\n\n        No → Do nothing // skip\n\n→ Output count // display result\n\nEnd // program end\n\nNeed to ensure each line is separate with arrow. For loops, use \"For each\" as step. For decision, indent with Yes→ etc. Provide explanation after //.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input jewels // 讀取字串 jewels，代表所有鑽石類型  \n→ Input stones // 讀取字串 stones，代表你手上的石頭  \n→ Create JewelSet from jewels // 將 jewels 的每個字元存入集合，方便 O(1) 查詢  \n→ Initialize count = 0 // 設定計數器為 0  \n→ For each char in stones // 逐一遍歷 stones 中的每個字元  \n    → Decision: 如果 char 在 JewelSet? // 判斷該石頭是否為鑽石類型  \n        Yes → Increment count // 若是，將計數器加 1  \n        No  → Do nothing // 若否，保持計數器不變  \n→ Output count // 顯示鑽石類型石頭的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_jewels_in_stones(jewels: str, stones: str) -> int:\n    \"\"\"計算 stones 中有多少個字符屬於 jewels\"\"\"\n    jewel_set = set(jewels)\n    return sum(1 for ch in stones if ch in jewel_set)\n\ndef main() -> None:\n    # 從標準輸入讀取全部內容\n    data = sys.stdin.read()\n\n    # 先嘗試從格式化字串中抽取兩個雙引號內的內容\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        jewels, stones = quoted[0], quoted[1]\n    else:\n        # 若沒有雙引號，直接以空白或換行分隔\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            jewels, stones = parts[0], parts[1]\n        else:\n            jewels, stones = \"\", \"\"\n\n    result = num_jewels_in_stones(jewels, stones)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "jewels = \"aA\", stones = \"aAAbbbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "jewels = \"z\", stones = \"ZZ\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode594.json",
    "problem_index_in_file": 0,
    "title": "Longest Harmonious Subsequence",
    "description_snippet": "We define a harmonious array as an array where the difference between its maximum value and its mini...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving the problem. Steps: compute frequencies, then iterate keys, check freq[i] and freq[i+1], compute sum, track max. Provide each line with explanation. Use arrows. Let's write: Start → Step: Count frequencies (hash map). → Step: Initialize maxLen = 0. → Decision: For each key in frequencies: if freq contains key+1: current = freq[key] + freq[key+1]; if current > maxLen: update. → End. Use Start, End markers.\n\nWe must produce line by line, each line \"虛擬碼步驟 // 解釋\". Use arrows appropriately. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 freq 以統計每個數值出現次數 // 建立頻率表\n→ Step 2: 對 nums 中每個元素 x: freq[x]++ // 填充頻率表\n→ Step 3: 設定 maxLen 為 0 // 初始化長度最大值\n→ Step 4: 對 freq 的每個鍵 key 進行迭代 // 遍歷所有不同數值\n    → Decision: 若 freq 中存在 key+1? // 檢查相鄰數值是否存在\n        Yes → Step 5: 計算 current = freq[key] + freq[key+1] // 取兩相鄰數值的總數\n        Yes → Step 6: 若 current > maxLen? // 更新最大長度\n            Yes → Step 7: maxLen = current // 更新最大長度\n        No  → // 若沒有相鄰數值則跳過\nEnd // 程式執行結束\n\nBut we need to use arrow for decision. Format: Decision: ...; Yes → ... No → ... . So we must format accordingly. Each line may be nested. For decision block we can indent. Example: \n→ Decision: 是否存在 key+1? // 檢查相鄰數值是否存在\n    Yes → Step 5: 計算 current = freq[key] + freq[key+1] // 取兩相鄰數值的總數\n    No  → // 無相鄰數值，跳過\nAnd inside Yes branch we need another decision: 若 current > maxLen? // 更新最大長度\n    Yes → Step 7: maxLen = current // 更新最大長度\n    No  → // 不更新\n\nAlso, we might include Step numbers for clarity. Provide explanation for each line. Ensure no actual code output. Provide in Traditional Chinese.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空字典 freq 以統計每個數值出現次數 // 建立頻率表\n→ Step 2: 對 nums 中每個元素 x: freq[x]++ // 填充頻率表\n→ Step 3: 設定 maxLen 為 0 // 初始化長度最大值\n→ Step 4: 對 freq 的每個鍵 key 進行迭代 // 遍歷所有不同數值\n    → Decision: 是否存在 key+1? // 檢查相鄰數值是否存在\n        Yes → Step 5: 計算 current = freq[key] + freq[key+1] // 取兩相鄰數值的總數\n        Yes → Decision: current > maxLen? // 判斷是否更新最大長度\n            Yes → Step 6: maxLen = current // 更新最大長度\n            No  → // 無需更新，跳至下一個 key\n        No  → // 無相鄰數值，跳過\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef find_lhs(nums):\n    \"\"\"\n    計算 nums 的最長和諧子序列長度。\n    兩個相鄰整數的頻率相加即為和諧子序列長度。\n    \"\"\"\n    freq = Counter(nums)\n    best = 0\n    for num in freq:\n        nxt = num + 1\n        if nxt in freq:\n            cur = freq[num] + freq[nxt]\n            if cur > best:\n                best = cur\n    return best\n\ndef main():\n    \"\"\"\n    從標準輸入讀取資料，輸出最長和諧子序列長度。\n    期望輸入形如:  nums = [1,3,2,2,5,2,3,7]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找出第一個完整的方括號中的列表\n    match = re.search(r'\\[.*?\\]', data, re.DOTALL)\n    if match:\n        list_str = match.group(0)\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n    print(find_lhs(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,2,5,2,3,7]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1.json",
    "problem_index_in_file": 0,
    "title": "Two Sum",
    "description_snippet": "Given an array of integers nums and an integer target, return indices of the two numbers such that t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code for two-sum problem, line by line with comments. Use Start, Decision, etc. Let's produce steps: iterate over array, maintain hash map of complement to index. So steps: Start, Input array and target, Initialize hash map, Iterate i from 0 to len-1, compute complement, Decision: if complement in map? Yes -> return indices, No -> store current number in map. End. Need line numbers? Not necessary. Provide each line as \"→ Step: ...\" with comment.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums, target // 取得數字陣列與目標值  \n→ Decision: 初始化空 hash_map // 建立空字典存放數值與其索引  \n    Yes → Step: hash_map ← {} // hash_map 用於快速查找已遇過的數字  \n→ Step: 對每個索引 i 以及對應值 val 循環 (i 0 到 len(nums)-1) // 逐一檢查每個數字  \n    → Decision: 是否存在 hash_map[ target - val ]? // 檢查是否已找到能配對的數字  \n        Yes → Step: 返回 [ hash_map[ target - val ], i ] // 找到答案即返回兩個索引  \n        No  → Step: hash_map[ val ] ← i // 若未找到，將目前數字及其索引加入 hash_map  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"找出兩個數字的索引，使其和等於目標值。\"\"\"\n        dic = {}\n        for i, val in enumerate(nums):\n            # 檢查是否已經存在相差為 target - val 的數字\n            if target - val in dic:\n                return [dic[target - val], i]\n            # 若不存在，將目前數字及其索引存入字典\n            dic[val] = i\n        # 根據題目說明，必定有唯一解，若此行執行則表示輸入錯誤\n        return []\n\ndef parse_input(input_str: str):\n    \"\"\"從輸入字串中解析出 nums 與 target。\"\"\"\n    # 先把所有換行符轉成逗號，方便分割\n    cleaned = input_str.replace(\"\\n\", \",\")\n    parts = cleaned.split(\",\")\n    nums = None\n    target = None\n    for part in parts:\n        part = part.strip()\n        # 解析 nums\n        if part.lower().startswith(\"nums\"):\n            m = re.search(r\"nums\\s*=\\s*(.*)\", part, re.IGNORECASE)\n            if m:\n                # 使用 literal_eval 解析列表，安全性高\n                nums = ast.literal_eval(m.group(1))\n        # 解析 target\n        if part.lower().startswith(\"target\"):\n            m = re.search(r\"target\\s*=\\s*(-?\\d+)\", part, re.IGNORECASE)\n            if m:\n                target = int(m.group(1))\n    if nums is None or target is None:\n        raise ValueError(\"輸入格式錯誤，請提供 'nums' 與 'target'\")\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入的全部內容\n    raw_input = sys.stdin.read()\n    # 解析出 nums 與 target\n    nums, target = parse_input(raw_input)\n    # 計算答案\n    result = Solution().twoSum(nums, target)\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp1q3nkdmo.py\", line 46, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1q3nkdmo.py\", line 32, in parse_input\n    nums = ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp27ztd9mk.py\", line 46, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp27ztd9mk.py\", line 32, in parse_input\n    nums = ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpiyym9gmi.py\", line 46, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpiyym9gmi.py\", line 32, in parse_input\n    nums = ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode354.json",
    "problem_index_in_file": 0,
    "title": "Russian Doll Envelopes",
    "description_snippet": "You are given a 2D array of integers envelopes where envelopes[i] = [w_i, h_i] represents the width ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudo-code for solving the Russian Doll Envelopes problem. Use virtual code with arrows, Start, Decision, etc. We must output each line with comment. Use Chinese explanations. Provide algorithm: sort envelopes by width ascending, height descending if width same. Then compute LIS on heights. Use binary search to find position. Provide steps: input, sort, build list of heights, compute LIS. Finally output result.\n\nWe need to output virtual code lines with arrow etc. Each line: \"虛擬碼步驟 // 解釋\". Use the arrow symbol →. For decisions: Decision: ... Yes →, No →.\n\nLet's craft the lines:\n\nStart // 開始程式\n→ Input: envelopes // 讀取 2D 數組\n→ Step: sort envelopes by width asc, height desc // 先排序，便於 LIS\n→ Step: 初始化空列表 heights // 存放高度\n→ Step: 將每個 envelope 的 height 加入 heights // 生成高度序列\n→ Step: 初始化空列表 dp // 存放 LIS 最小尾部\n→ Decision: 遍歷每個 height in heights? // 處理高度\n    → Step: 使用二分搜尋找到 dp 中第一個 >= height 的位置 pos // 二分\n    → Decision: pos 等於 dp 長度? // 是否要延長 LIS\n        Yes → Step: dp.append(height) // 新增尾部\n        No  → Step: dp[pos] = height // 更新尾部\n→ Step: 返回 dp 長度 // LIS 長度即最大數量\nEnd // 程式結束\n\nNeed to reflect each step line. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: envelopes // 讀取給定的 2D 數組  \n→ Step: sort envelopes by width asc, height desc // 先按寬度升序，寬度相同則按高度降序排序  \n→ Step: 初始化空列表 heights // 用來儲存排序後的高度序列  \n→ Step: 將每個 envelope 的 height 加入 heights // 建立高度序列  \n→ Step: 初始化空列表 dp // dp 用來存儲 LIS 的最小尾部  \n→ Decision: 遍歷每個 height in heights? // 處理高度序列  \n  Yes → Step: 使用二分搜尋在 dp 找到第一個 >= height 的位置 pos // 找到替換位置  \n  Decision: pos 等於 dp 長度? // 判斷是否需要擴展 LIS  \n   Yes → Step: dp.append(height) // 若是，將 height 加入 dp  \n   No  → Step: dp[pos] = height // 否則，用 height 更新 dp[pos]  \n→ Step: 返回 dp 長度 // dp 的長度即為最大可容納的信封數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport bisect\n\ndef max_envelopes(envelopes):\n    \"\"\"\n    計算可以互相套疊的最大信封數量。\n    思路：先按寬度升序，寬度相同時按高度降序排序，\n    然後對高度序列求 Longest Increasing Subsequence (LIS)。\n    \"\"\"\n    if not envelopes:\n        return 0\n\n    # 1. 先排序：寬度升序，寬度相同時高度降序\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n\n    # 2. 用 dp 儲存每個 LIS 長度對應的最小尾部\n    dp = []\n    for _, h in envelopes:\n        idx = bisect.bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)      # 延長 LIS\n        else:\n            dp[idx] = h       # 更新較小的尾部\n    return len(dp)\n\ndef parse_input(input_str):\n    \"\"\"\n    將輸入字串轉成 envelopes 的 list[list[int]]。\n    支援形如 'envelopes = [[5,4],[6,4],[6,7],[2,3]]' 或僅列表的輸入。\n    \"\"\"\n    input_str = input_str.strip()\n    # 如果有 'envelopes' 這個關鍵字，去掉前面的部分\n    if 'envelopes' in input_str:\n        # 找 '=' 之後的部分\n        idx = input_str.find('=')\n        if idx != -1:\n            input_str = input_str[idx + 1:].strip()\n    # 使用安全的 literal_eval 解析\n    try:\n        data = ast.literal_eval(input_str)\n    except Exception as e:\n        # 若解析失敗，回傳空列表\n        data = []\n    # 確保返回值是 list of lists\n    if not isinstance(data, list):\n        data = []\n    return data\n\ndef main():\n    # 讀取所有輸入\n    raw_input = sys.stdin.read()\n    envelopes = parse_input(raw_input)\n    result = max_envelopes(envelopes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "envelopes = [[5,4],[6,4],[6,7],[2,3]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "envelopes = [[1,1],[1,1],[1,1]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode746.json",
    "problem_index_in_file": 0,
    "title": "Min Cost Climbing Stairs",
    "description_snippet": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: minimum cost to climb stairs, starting at 0 or 1. Classic DP: dp[i] min cost to reach step i. dp[0]=0, dp[1]=0? Wait, you can start at step 0 or 1, paying cost when you step on them? Actually cost[i] is the cost of ith step. If you start at step 0 or 1, you pay cost for that step. Then you climb. Goal: top after last index. Usually answer = min(dp[n-1]+cost[n-1], dp[n-2]+cost[n-2]) or using dp array size n+1 where dp[i] min cost to reach step i (floor after nth). We can implement DP iteratively. Steps: compute dp[0]=0, dp[1]=0? Let's design: dp[i] min cost to reach step i (index i). Starting from 0 or 1: dp[0]=cost[0], dp[1]=cost[1]. For i>=2: dp[i] = cost[i] + min(dp[i-1], dp[i-2]). Finally answer = min(dp[n-1], dp[n-2])? Actually to reach top after last step (index n-1). We can either finish at step n-1 or step n-2 and then climb 1 or 2 to top. The top is after last index. So cost to finish from step n-1: min(dp[n-1], dp[n-2]). Wait dp[n-1] is cost to land on step n-1. If you start at step n-1 and then take 1 step to top, you don't pay extra. Similarly starting at step n-2 and then take 2 steps to top. So answer = min(dp[n-1], dp[n-2]). Works.\n\nWe'll generate virtual code lines accordingly. Use arrows. Provide each line.\n\nLet's produce: Start, Step1: initialize n, dp array, Step2: handle base cases. Step3: loop from 2 to n-1. Step4: compute answer. End.\n\nNeed to use arrow syntax: → Step X: ... // explanation. Decision: maybe none needed. Use Start, End.\n\nLet's craft.\n\nNote: We may need to consider cost array length. We'll output lines.\n\nMake sure each line ends with //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(cost) // 取得台階數量  \n→ Step 2: dp ← array of size n // 建立 dp 陣列存儲最小費用  \n→ Step 3: dp[0] ← cost[0] // 從第 0 階開始，需支付其費用  \n→ Step 4: dp[1] ← cost[1] // 從第 1 階開始，需支付其費用  \n→ Decision: 如果 n > 2? // 若台階多於兩級，需做迴圈計算  \n    Yes → For i from 2 to n-1:  \n        → dp[i] ← cost[i] + min(dp[i-1], dp[i-2]) // 走到第 i 階時，取上一或前上一階的最小費用加上當前費用  \n        → End For  \n    No  → // 只兩級，無需迴圈  \n→ Step 5: result ← min(dp[n-1], dp[n-2]) // 最終到達頂部的最小費用  \n→ Step 6: return result // 回傳答案  \nEnd // 程式執行結束",
      "generated_code": "import sys, ast\n\nclass Solution:\n    def minCostClimbingStairs(self, cost):\n        n = len(cost)\n        if n == 0:\n            return 0\n        if n == 1:\n            return cost[0]\n        dp = [0]*n\n        dp[0], dp[1] = cost[0], cost[1]\n        for i in range(2, n):\n            dp[i] = cost[i] + min(dp[i-1], dp[i-2])\n        return min(dp[-1], dp[-2])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        cost = []\n    else:\n        cost = ast.literal_eval(data)\n    result = Solution().minCostClimbingStairs(cost)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[10,15,20]",
          "expected_output": "15",
          "success": true,
          "output": "15"
        },
        {
          "example_index": 1,
          "input": "[1,100,1,1,1,100,1,1,100,1]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode630.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule III",
    "description_snippet": "There are n different online courses numbered from 1 to n. You are given an array courses where cour...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for scheduling max courses. This is classic problem \"Course Schedule III\". Solution: sort by lastDay, use max-heap to track durations, iterate, add course, if total time > lastDay then remove longest course. At end size of heap is answer. We need step-by-step pseudocode with arrow syntax.\n\nWe need to output line by line: each line: virtual code step + space + // explanation.\n\nWe'll use Start, Decision:, etc. Include loops. Use arrow for next step. Use heap operations: push, pop. Represent as \"Add to heap\" etc. Use variable totalTime. Use for loop over sorted courses. Use if statements.\n\nLet's produce.\n\nStructure:\n\nStart\n→ Read n\n→ Read courses array\n→ Sort courses by lastDay ascending\n→ totalTime = 0\n→ Initialize max-heap durations\n→ For each course in courses:\n   -> Add duration to heap\n   -> totalTime += duration\n   -> Decision: if totalTime > lastDay\n        Yes -> Remove longest duration from heap\n        totalTime -= removed duration\n   -> End if\n→ End for\n→ Result = size of heap\n→ Output result\nEnd\n\nNeed to use arrow syntax.\n\nAlso include Decision for sorting? but that's fine.\n\nNeed to include each step with explanation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read n // 取得課程數量  \n→ Read courses // 取得每門課程的 (duration, lastDay)  \n→ Sort courses by lastDay ascending // 先按最後允許完成日排序，方便後續判斷  \n→ totalTime = 0 // 目前已花費的總天數  \n→ Initialize maxHeap // 以最大堆儲存已選課程的 duration，方便快速刪除最長課程  \n→ For each (duration, lastDay) in courses: // 逐一處理每門課  \n  → Push duration into maxHeap // 暫時加入這門課  \n  → totalTime += duration // 更新總耗時  \n  → Decision: if totalTime > lastDay // 目前時間已超過此課程允許的最遲完成日  \n    Yes → Remove longestDuration = Pop maxHeap // 取出已選課程中最長的一門並刪除  \n     → totalTime -= longestDuration // 將耗時減去剔除的課程時間  \n    No  → No action // 符合時間限制，保留此課程  \n→ End For // 所有課程處理完畢  \n→ result = Size of maxHeap // 最大堆中剩餘課程數即為可修課程最大數量  \n→ Output result // 回傳答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass Solution:\n    def scheduleCourse(self, courses):\n        # 按結束時間排序\n        courses.sort(key=lambda x: x[1])\n        total_time = 0\n        max_heap = []\n\n        for duration, last_day in courses:\n            total_time += duration\n            heapq.heappush(max_heap, -duration)  # 用負數做最大堆\n            if total_time > last_day:\n                # 刪除最長課程\n                longest = -heapq.heappop(max_heap)\n                total_time -= longest\n        return len(max_heap)\n\ndef parse_input(raw):\n    raw = raw.strip()\n    if raw.startswith(\"courses\"):\n        # 去掉前面的 \"courses =\"\n        _, expr = raw.split(\"=\", 1)\n        raw = expr.strip()\n    return ast.literal_eval(raw)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    courses = parse_input(raw_input)\n    solution = Solution()\n    result = solution.scheduleCourse(courses)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "courses = [[1,2]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "courses = [[3,2],[4,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode233.json",
    "problem_index_in_file": 0,
    "title": "Number of Digit One",
    "description_snippet": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting total number of digit '1' appearing in all non-negative integers <= n. Standard algorithm: iterate over digit positions, compute count per position: high, current, low. We'll present as pseudo-code lines. Use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow. We'll include variables: n, position, factor, high, cur, low, result. Steps: initialize result=0; for position=1; while position <= n: compute high = n // (position*10); cur = (n // position) % 10; low = n % position; if cur == 0: result += high * position; else if cur == 1: result += high * position + low + 1; else: result += (high + 1) * position; position *= 10. End. Use arrow indent. Ensure each line has comment. Provide explanation. Use Start, End, Decision etc. Provide arrow lines. Ensure each line ends with //. Provide short explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 變數 result ← 0 // 用於累加總數字 1 的個數  \n→ Step 2: 變數 position ← 1 // 代表目前正在處理的位數（單位、十位、百位……）  \n→ Decision: 如果 position ≤ n? // 判斷是否還有位數要處理  \n Yes → Step 3: 變數 high ← n // (position * 10) // 整數除法取得高位數  \n    // high 表示比目前位數高的部分  \n    → Step 4: 變數 cur ← (n // position) % 10 // 取得目前位數的數字  \n    → Step 5: 變數 low ← n % position // 取得比目前位數低的部分  \n    → Decision: 如果 cur = 0? // 判斷目前位數為 0  \n     Yes → Step 6: result ← result + high * position // 這位所有數字 1 的數量  \n     No → Decision: 如果 cur = 1? // 判斷目前位數為 1  \n      Yes → Step 7: result ← result + high * position + low + 1 // 加上低位的 +1  \n      No → Step 8: result ← result + (high + 1) * position // 低於 1 時的計算  \n    → Step 9: position ← position * 10 // 移動到下一個位數  \n    → Decision: 如果 position ≤ n? // 重新判斷是否還有位數  \n     Yes → 回到 Step 3  \n     No → 跳至 Step 10  \n→ Step 10: 輸出 result // 顯示所有非負整數 ≤ n 中數字 1 的總個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_digit_one(n: int) -> int:\n    \"\"\"Count the total number of digit '1' appearing in all non‑negative integers\n    less than or equal to n.\"\"\"\n    if n <= 0:\n        return 0\n\n    count = 0\n    factor = 1  # 1, 10, 100, ...\n\n    while factor <= n:\n        divider = factor * 10\n        high = n // divider           # digits higher than current position\n        cur  = (n // factor) % 10     # digit at current position\n        low  = n % factor             # digits lower than current position\n\n        if cur == 0:\n            count += high * factor\n        elif cur == 1:\n            count += high * factor + low + 1\n        else:  # cur > 1\n            count += (high + 1) * factor\n\n        factor *= 10\n\n    return count\n\n\ndef parse_input(data: str) -> int:\n    \"\"\"Extract the first integer from the input string.\"\"\"\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return 0\n    return int(numbers[0])\n\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    n = parse_input(input_data)\n    result = count_digit_one(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode299.json",
    "problem_index_in_file": 0,
    "title": "Bulls and Cows",
    "description_snippet": "You are playing the Bulls and Cows game with your friend.\n\nYou write down a secret number and ask yo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Must follow format: each line: virtual code step + space + // explanation. Use arrows, Start, End, Decision etc. Need to implement logic: count bulls and cows. Use arrays to track frequency. We'll produce high-level pseudocode.\n\nLet's outline algorithm:\n\n- Start\n- Step 1: initialize bulls = 0, cows = 0\n- Step 2: create array count[10] = 0 for digits frequency in secret not matched\n- Step 3: loop i from 0 to len(secret)-1\n   - if secret[i] == guess[i] then bulls++ else:\n       - count[secret[i]]++ // secret digit\n       - count[guess[i]]-- // guess digit\n- After loop, cows = sum over digits of abs(count[d])? Actually count is net: positive means more secret, negative more guess. Cows = sum of min(secretCount, guessCount). Equivalent to sum over digits of max(0, count[d])? Wait algorithm: after loop, for each digit, if count[d] > 0 then we have more secret than guess; if <0 more guess. For cows, we sum min(secretCount, guessCount) which is sum over digits of max(0, -count[d])? Let's think: Standard algorithm: we increment count[secret[i]] and decrement count[guess[i]] for mismatches. After loop, cows = sum of max(0, -count[d])? Actually if secret has 3 of digit 1, guess has 1 of digit 1, mismatch: count[1] would be +2 (3-1). Cows should be 1. We need min(secretCount, guessCount). After loop, count[1] = 2 >0 meaning extra secret. We can compute cows as sum over d of max(0, -count[d])? For this case -count[1] = -2, so max(0,-2)=0 not correct. Alternatively we can accumulate cows during loop: when secret[i] != guess[i], if count[guess[i]] < 0 then cows++ ; if count[secret[i]] > 0 then cows++. Standard approach: When mismatched, if the count for the guess digit is negative (meaning this digit already appeared in guess earlier but not in secret yet), we increment cows. Similarly for secret digit. Let's use that.\n\nSo algorithm:\n\n- Initialize bulls=0, cows=0, count[10]=0\n- Loop over i:\n   - if secret[i]==guess[i] then bulls++\n   - else:\n       - if count[guess[i]] < 0 then cows++\n       - if count[secret[i]] > 0 then cows++\n       - count[secret[i]]++\n       - count[guess[i]]--\n- End loop\n- Output bulls and cows formatted.\n\nWe'll produce pseudocode.\n\nNeed to ensure lines with arrows etc.\n\nLet's craft:\n\nStart // 程式開始\n\n→ Step 1: 初始化 bulls = 0, cows = 0 // 計算貝利和牛的數量\n\n→ Step 2: 初始化 count[10] 為 0 // 追蹤各數字在不匹配位置的差異\n\n→ Step 3: 對 i 從 0 到 len(secret)-1 迴圈 // 遍歷每個位元\n\n    → Decision: 如果 secret[i] 等於 guess[i]? // 判斷是否為貝利\n\n        Yes → Step 4: bulls++ // 找到一個貝利\n\n        No  → Step 5: 進行牛的檢查與計數\n\n            → Step 5.1: 如果 count[guess[i]] < 0? // guess 的數字在先前不匹配中多出來\n\n                Yes → Step 5.1.1: cows++ // 為牛\n\n                No  → Step 5.1.2: // 不執行\n\n            → Step 5.2: 如果 count[secret[i]] > 0? // secret 的數字在先前不匹配中多出來\n\n                Yes → Step 5.2.1: cows++ // 為牛\n\n                No  → Step 5.2.2: // 不執行\n\n            → Step 5.3: count[secret[i]]++ // 更新 secret 的計數\n\n            → Step 5.4: count[guess[i]]-- // 更新 guess 的計數\n\n← End of loop\n\n→ Step 6: 回傳 字串 \"${bulls}A${cows}B\" // 格式化輸出\n\nEnd // 程式結束\n\nBut we need each line formatted with \"虛擬碼步驟\" and explanation. Use arrows and structure.\n\nLet's produce final answer accordingly. Use Start, End. Use arrow arrow for each line. Provide explanation after //.\n\nMake sure no actual code, just pseudocode steps.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 bulls = 0, cows = 0 // 設定貝利與牛的計數器為零  \n→ Step 2: 初始化 count[10] 為 0 // 用於追蹤每個數字在不匹配位置的差異  \n→ Step 3: 對 i 從 0 到 len(secret)-1 進行迴圈 // 遍歷每個位元  \n  → Decision: 如果 secret[i] 等於 guess[i]? // 判斷是否為貝利  \n   Yes → Step 4: bulls++ // 找到一個貝利，計數器加一  \n   No → Step 5: 進行牛的檢查與計數  \n    → Step 5.1: 如果 count[guess[i]] < 0? // guess 的數字在先前不匹配中已出現多一次  \n     Yes → Step 5.1.1: cows++ // 確定為牛，計數器加一  \n     No → Step 5.1.2: // 無動作  \n    → Step 5.2: 如果 count[secret[i]] > 0? // secret 的數字在先前不匹配中已出現多一次  \n     Yes → Step 5.2.1: cows++ // 確定為牛，計數器加一  \n     No → Step 5.2.2: // 無動作  \n    → Step 5.3: count[secret[i]]++ // 更新 secret 的計數器  \n    → Step 5.4: count[guess[i]]-- // 更新 guess 的計數器  \n→ Step 6: 回傳字串 \"${bulls}A${cows}B\" // 格式化輸出為 xAyB  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef get_hint(secret: str, guess: str) -> str:\n    \"\"\"Return the Bulls and Cows hint for the given secret and guess.\"\"\"\n    bulls = cows = 0\n    # count[d] stores the difference between the number of digit d\n    # in secret and in guess for the positions that are not bulls.\n    count = [0] * 10\n\n    for s, g in zip(secret, guess):\n        if s == g:\n            bulls += 1\n        else:\n            # If the guess digit has been seen more times in guess\n            # than in secret up to this point, it forms a cow.\n            if count[int(g)] < 0:\n                cows += 1\n            # If the secret digit has been seen more times in secret\n            # than in guess up to this point, it also forms a cow.\n            if count[int(s)] > 0:\n                cows += 1\n            count[int(s)] += 1\n            count[int(g)] -= 1\n\n    return f\"{bulls}A{cows}B\"\n\ndef parse_input(data: str):\n    \"\"\"Parse the stdin data into secret and guess strings.\"\"\"\n    lines = data.strip().splitlines()\n    if not lines:\n        raise ValueError(\"No input provided\")\n    if len(lines) == 1:\n        # Try to extract the two quoted strings\n        quoted = re.findall(r'\"([^\"]*)\"', lines[0])\n        if len(quoted) >= 2:\n            return quoted[0], quoted[1]\n        # Fallback: split by comma\n        parts = lines[0].split(',')\n        secret = parts[0].split('=')[1].strip().strip('\"')\n        guess = parts[1].split('=')[1].strip().strip('\"')\n        return secret, guess\n    # Two separate lines: first secret, second guess\n    secret = lines[0].strip().strip('\"')\n    guess = lines[1].strip().strip('\"')\n    return secret, guess\n\ndef main():\n    data = sys.stdin.read()\n    secret, guess = parse_input(data)\n    print(get_hint(secret, guess))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '1A3B'\nGot (Norm):      '1A0B'\n--- (Raw) ---\nRaw Expected: '\"1A3B\"'\nRaw Got:      '1A0B'"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '1A1B'\nGot (Norm):      '1A0B'\n--- (Raw) ---\nRaw Expected: '\"1A1B\"'\nRaw Got:      '1A0B'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode486.json",
    "problem_index_in_file": 0,
    "title": "Predict the Winner",
    "description_snippet": "You are given an integer array nums. Two players are playing a game with this array: player 1 and pl...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, explaining each line. Problem: Determine if Player1 can win or tie when both play optimally. Classic problem: \"Predict the Winner\". Use DP: dp[i][j] = maximum difference of scores that current player can achieve over opponent from subarray i..j. dp[i][i] = nums[i]. For length >1: dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]). After filling, if dp[0][n-1] >= 0 return true. Use recursion or memo. Provide virtual steps.\n\nWe need to output as described. Should include Start, End. Use arrow \"→\". Each line has virtual step + \" // 解釋\". Provide each line.\n\nLet's produce algorithm steps: Start, Input array, n, create DP 2D array, initialize base, loop len from 2 to n, compute dp, final result check dp[0][n-1] >=0, return result, End.\n\nLet's produce each line. Use indent for decisions? Not needed for DP algorithm, but we can use Decision if check result. Provide decision at end. Provide steps.\n\nOk. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 從使用者處取得陣列  \n→ Step 2: 設定 n 為 nums 的長度 // 方便後續迴圈使用  \n→ Step 3: 建立 2D 陣列 dp[n][n] // 用來記錄子問題的最大分數差  \n→ Step 4: 針對 i 從 0 到 n-1 做初始化: dp[i][i] = nums[i] // 單一元素時，玩家可拿走該數值  \n→ Step 5: 從子陣列長度 2 開始，遞增到 n  \n    → Step 5.1: 對每個起始點 i 從 0 到 n - len  \n        → Step 5.1.1: 計算結束點 j = i + len - 1  \n        → Step 5.1.2: dp[i][j] = max( nums[i] - dp[i+1][j] , nums[j] - dp[i][j-1] ) // 選左或右，減去對手未來可得到的最大差值  \n→ Decision: 如果 dp[0][n-1] >= 0? // 代表玩家 1 的最終分數差不小於 0  \n    Yes → Step 6: 回傳 true // 玩家 1 可以贏或平手  \n    No  → Step 7: 回傳 false // 玩家 2 會贏  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def predictTheWinner(self, nums):\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n        return dp[0][n - 1] >= 0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 支援 \"nums = [1,5,2]\" 或直接 \"[1,5,2]\" 的輸入格式\n    if '=' in data:\n        _, array_str = data.split('=', 1)\n        array_str = array_str.strip()\n    else:\n        array_str = data\n    nums = eval(array_str)  # 解析輸入為 list\n    solution = Solution()\n    result = solution.predictTheWinner(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,233,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode338.json",
    "problem_index_in_file": 0,
    "title": "Counting Bits",
    "description_snippet": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: compute count of set bits for each number 0..n. Use DP: ans[0] = 0; for i from 1 to n: ans[i] = ans[i>>1] + (i & 1). Or use dynamic approach. Provide steps with Start, End, Decision. Also loops. Provide each line with \"虛擬碼步驟 // 解釋\". Use arrow →. Each step separate line. Let's craft.\n\nLines:\n\nStart // start\n→ Step 1: 接收輸入 n // get integer\n→ Step 2: 初始化陣列 ans 大小 n+1 // allocate\n→ Step 3: 設定 ans[0] = 0 // base\n→ Decision: n 是否大於 0? // check loop need\n    Yes → Step 4: 設定 i = 1 // loop counter\n    No  → Jump to End // if n==0\n→ Step 5: While i <= n: // loop\n        Yes → Step 6: 計算 ans[i] = ans[i >> 1] + (i & 1) // DP formula\n        Yes → Step 7: i = i + 1 // next\n        Yes → 回到 Step 5\n→ End // return ans\n\nBut we need arrow for loop decisions? Use Decision: while i <= n? maybe.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得輸入整數\n→ Step 2: 建立陣列 ans 佔 n+1 個位置 // 為結果預留空間\n→ Step 3: 設定 ans[0] = 0 // 0 的位元數為 0\n→ Decision: n 是否大於 0? // 判斷是否需要進行迴圈\n    Yes → Step 4: 設定 i = 1 // 初始化迴圈計數器\n    No  → Step 5: End // n 為 0 時直接結束\n→ Decision: i <= n? // 迴圈條件\n    Yes → Step 6: 計算 ans[i] = ans[i >> 1] + (i & 1) // 使用已計算的前一個數值\n    Yes → Step 7: i = i + 1 // 移動到下一個數字\n    Yes → 回到 Decision: i <= n? // 重新檢查條件\n    No  → Step 8: End // 完成所有計算\n\nBut we should maintain Start/End markers. Maybe we can unify:\n\nStart\n→ Step 1...\n→ Step 2...\n→ Step 3...\n→ Decision: n > 0?\n    Yes → Step 4...\n    No  → Step 5: End\n\nThen Decision: i <= n?\n    Yes → Step 6...\n    Yes → Step 7...\n    Yes → 回到 Decision...\n    No  → Step 8: End\n\nBut we have two End, maybe we can collapse last End to main End. Let's just produce single End at the end.\n\nBetter structure:\n\nStart\n→ Step 1: 輸入 n\n→ Step 2: 建立陣列 ans[0..n]\n→ Step 3: ans[0] = 0\n→ Decision: n > 0?\n    Yes → Step 4: i = 1\n    No  → Step 5: End\n→ Decision: i <= n?\n    Yes → Step 6: ans[i] = ans[i >> 1] + (i & 1)\n    Yes → Step 7: i = i + 1\n    Yes → 回到 Decision: i <= n?\n    No  → Step 8: End\n\nBut we need to ensure that we exit when i > n. The End is final.\n\nLet's craft final answer accordingly. Use each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得要計算的上限  \n→ Step 2: 建立陣列 ans 佔 n+1 個位置 // 為每個數字儲存 1 的個數  \n→ Step 3: 設定 ans[0] = 0 // 0 的二進位表示為 0，位元數為 0  \n→ Decision: n 是否大於 0? // 判斷是否需要進行迴圈  \n&nbsp;&nbsp;Yes → Step 4: 設定 i = 1 // 初始化迴圈計數器  \n&nbsp;&nbsp;No  → End // n 為 0 時直接結束  \n→ Decision: i ≤ n? // 迴圈條件  \n&nbsp;&nbsp;Yes → Step 5: ans[i] = ans[i >> 1] + (i & 1) // 利用前一個數的結果計算  \n&nbsp;&nbsp;Yes → Step 6: i = i + 1 // 移動到下一個數字  \n&nbsp;&nbsp;Yes → 回到 Decision: i ≤ n? // 重新檢查條件  \n&nbsp;&nbsp;No  → End // 所有數字已處理完畢  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countBits(self, n: int):\n        \"\"\"\n        Return a list where the ith element is the number of 1's in the binary\n        representation of i, for all i from 0 to n inclusive.\n        \"\"\"\n        res = [0] * (n + 1)\n        for i in range(1, n + 1):\n            # res[i] = number of set bits in i\n            # i >> 1 shifts i right by 1 (removes the least significant bit)\n            # i & 1 gets the least significant bit (0 or 1)\n            res[i] = res[i >> 1] + (i & 1)\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input; it may contain spaces or other characters.\n    data = sys.stdin.read()\n    # Extract the first integer found in the input.\n    match = re.search(r'\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input\")\n    n = int(match.group())\n    # Compute the answer and print it.\n    solution = Solution()\n    answer = solution.countBits(n)\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,1]",
          "success": true,
          "output": "[0, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[0,1,1,2,1,2]",
          "success": true,
          "output": "[0, 1, 1, 2, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode757.json",
    "problem_index_in_file": 0,
    "title": "Set Intersection Size At Least Two",
    "description_snippet": "You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the problem: minimum size of a set covering each interval with at least two integers. Classic problem: choose points greedily. Approach: sort intervals by end. For each interval, maintain count of points chosen in that interval. Keep list of selected points. We choose the largest possible points (end, end-1). Implementation: iterate sorted intervals; for each interval, determine how many of the last two selected points lie in the interval. Then if need more, add points at end-1 and end (if not already present). But we must ensure distinctness.\n\nWe produce virtual code step by step, each line with explanation.\n\nWe'll produce lines:\n\nStart\n→ Step 1: Sort intervals by ascending end\n→ Step 2: Initialize selectedPoints as empty list\n→ Step 3: For each interval in sorted intervals:\n   → Step 4: Count how many points in selectedPoints are >= start and <= end\n   → Decision: needPoints = 2 - count\n        Yes → Step 5: If needPoints > 0\n            → Decision: needPoints == 1? \n                Yes → Step 6: Add point (end-1) if not already present\n                No  → Step 7: Add point (end-1) and (end) if not already present\n            → Step 8: Update selectedPoints with added points\n        No → Step 9: Continue to next interval\nEnd\n\nBut need to show details of counting and adding. Could break into more lines.\n\nAlso must keep track of selectedPoints sorted maybe. For counting, we can loop.\n\nSimplify: use list, but conceptually we can use set.\n\nWe'll produce pseudo code.\n\nOk. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort intervals by end ascending // 先將所有區間按結束值遞增排列，方便後續贈點  \n→ Step 2: selectedPoints ← empty list // 用來存放已選的整數，確保唯一  \n→ Step 3: For each interval [s, e] in sorted intervals do // 逐一處理每個區間  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: count ← 0 // 這個區間已經包含的點數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 迴圈遍歷 selectedPoints  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: 如果 point ≥ s 且 point ≤ e then count ← count + 1  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: need ← 2 - count // 這個區間還缺的點數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: need > 0? // 是否需要再新增點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: // 先嘗試把最大的兩個可能點加入  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: need == 1? // 只需要一個點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: pointToAdd ← e-1 // 最右邊可能的第二個點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: pointToAdd ← e-1 // 第一個點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: If pointToAdd not in selectedPoints then add to selectedPoints  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → // 需要兩個點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 11: point1 ← e-1 // 第二個最後的點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 12: point2 ← e   // 最右端的點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 13: For each p in [point1, point2]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 14: If p not in selectedPoints then add to selectedPoints  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 15: // 已經有足夠點，直接跳過  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step 16: // 本區間已滿足需求，移到下一個  \n→ End // 程式執行結束，selectedPoints 的長度即為最小包含集合大小\n\n說明：  \n- 先按結束值排序能保證每次加入的點對後續區間最大化利用。  \n- `selectedPoints` 只存放唯一的整數，並以遞增方式保持，方便後續檢查。  \n- 對每個區間計算已存在於其中的點數，再決定要不要新增 `e-1` 或 `e`（或兩者）來達到至少兩個點的要求。  \n- 若已存在足夠點則不做任何變動，直接處理下一個區間。  \n- 最後 `selectedPoints` 的長度即為最小包含集合的大小。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def intersectionSizeTwo(self, intervals):\n        # Sort by end ascending, and by start descending for ties\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        res = []            # selected points\n        last, second_last = -1, -1  # last two points added\n\n        for start, end in intervals:\n            count = 0\n            # Count how many of the last two points are inside this interval\n            if start <= second_last <= end:\n                count += 1\n            if start <= last <= end:\n                count += 1\n\n            if count >= 2:\n                continue\n            elif count == 1:\n                # add the largest possible point that hasn't been used yet\n                res.append(end)\n                second_last, last = last, end\n            else:\n                # need two new points: end-1 and end\n                res.extend([end - 1, end])\n                second_last, last = end - 1, end\n\n        return len(res)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入包含 \"intervals =\"，把它去掉\n    if data.startswith('intervals'):\n        idx = data.find('[')\n        if idx != -1:\n            data = data[idx:]\n\n    try:\n        intervals = ast.literal_eval(data)\n    except Exception:\n        intervals = []\n\n    sol = Solution()\n    result = sol.intersectionSizeTwo(intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[3,7],[8,9]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,3],[1,4],[2,5],[3,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3],[2,4],[4,5]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode647.json",
    "problem_index_in_file": 0,
    "title": "Palindromic Substrings",
    "description_snippet": "Given a string s, return the number of palindromic substrings in it.\n\nA string is a palindrome when ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for counting palindromic substrings. Use expand around center approach. Steps: Start, read s, initialize count 0, loop i from 0 to n-1, expand odd, expand even. Then return count. Use virtual steps. Provide each line with explanation. Use Start, End, Decision, etc. Use arrow \"→\" for steps. Also include comments. Let's craft.\n\nMake sure each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End. Provide arrow and indent for decisions. Use Yes/No arrow. Use virtual code structure.\n\nWe need \"逐行輸出\". So we produce a sequence of lines.\n\nLet's construct:\n\nStart // 程式開始\n→ Step 1: 取得輸入字串 s // 取得要分析的字串\n→ Step 2: 設定變數 n 為 s 的長度 // 方便後續迴圈\n→ Step 3: 初始化 count 為 0 // 用來累計回文子字串數量\n→ For i 從 0 到 n-1 // 以每個字元為中心展開\n    → Decision: 是否處理奇數長回文? // 奇數長子字串以單一字元為中心\n        Yes → Step 4a: 設定 left = i, right = i // 初始左右指標指向中心\n        → While left >= 0 AND right < n AND s[left] == s[right] // 雙邊字符相同\n            Yes → Step 5a: 增加 count, left--, right++ // 這是一個有效回文\n            No  → Break // 雙邊不相同，停止\n        No  → // 不需要處理奇數回文，跳過\n    → Decision: 是否處理偶數長回文? // 偶數長子字串以相鄰兩字元為中心\n        Yes → Step 4b: 設定 left = i, right = i+1 // 初始左右指標分別指向相鄰字元\n        → While left >= 0 AND right < n AND s[left] == s[right]\n            Yes → Step 5b: 增加 count, left--, right++ // 有效偶數回文\n            No  → Break\n        No  → // 不需要處理偶數回文，跳過\n→ Step 6: 回傳 count // 輸出最終回文子字串數量\nEnd // 程式結束\n\nBut need each line with \"虛擬碼步驟 // 解釋\". Use arrow and indent. Let's refine.\n\nWe can combine decisions with indentation. Provide Yes/No arrows with indentation.\n\nMake sure each line unique.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者取得要分析的字串  \n→ Step 2: 設定變數 n 為 s 的長度 // 方便後續迴圈使用  \n→ Step 3: 初始化 count 為 0 // 用來累計所有回文子字串的數量  \n\n→ For i 從 0 到 n-1 // 以每個字元為中心展開  \n    → Decision: 處理奇數長回文? // 奇數長子字串以單一字元為中心  \n        Yes → Step 4a: 設定 left = i, right = i // 左右指標初始指向中心  \n        → While left >= 0 AND right < n AND s[left] == s[right] // 雙邊字符相同  \n            Yes → Step 5a: 增加 count, left--, right++ // 發現一個回文，計數並展開  \n            No  → Break // 不相同，停止此輪展開  \n        No  → // 無奇數長回文情況，直接跳過  \n\n    → Decision: 處理偶數長回文? // 偶數長子字串以相鄰兩字元為中心  \n        Yes → Step 4b: 設定 left = i, right = i+1 // 左右指標初始指向相鄰字元  \n        → While left >= 0 AND right < n AND s[left] == s[right] // 雙邊字符相同  \n            Yes → Step 5b: 增加 count, left--, right++ // 發現一個偶數長回文，計數並展開  \n            No  → Break // 不相同，停止此輪展開  \n        No  → // 無偶數長回文情況，直接跳過  \n\n→ Step 6: 回傳 count // 輸出最終計算得到的回文子字串數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countSubstrings(self, s: str) -> int:\n        \"\"\"\n        Count all palindromic substrings in the input string `s` using\n        the expand‑around‑center technique.\n        \"\"\"\n        n = len(s)\n        count = [0]  # use a mutable container so the inner function can modify it\n\n        def expand(left: int, right: int) -> None:\n            \"\"\"\n            Expand the window [left, right] while the characters match\n            and increment the palindrome counter.\n            \"\"\"\n            while left >= 0 and right < n and s[left] == s[right]:\n                count[0] += 1\n                left -= 1\n                right += 1\n\n        for i in range(n):\n            # Odd length palindromes (single center)\n            expand(i, i)\n            # Even length palindromes (center between i and i+1)\n            expand(i, i + 1)\n\n        return count[0]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n\n    # Extract the first quoted string as the actual input string\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    s = match.group(1) if match else \"\"\n\n    # Compute the number of palindromic substrings\n    solution = Solution()\n    result = solution.countSubstrings(s)\n\n    # Output the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"aaa\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode846.json",
    "problem_index_in_file": 0,
    "title": "leetcode846_problem_1",
    "description_snippet": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: Given array hand and groupSize, can rearrange into groups of groupSize consecutive cards. This is a known problem: hand of straights. Approach: Count frequencies of each card. Then iterate over sorted keys; for each key, if count >0, try to subtract count from subsequent groupSize-1 consecutive values. If any missing or insufficient count, return false. Finally return true.\n\nWe need to produce virtual code with steps, each line with explanation. Use arrow, Decision, Start, End. Let's produce:\n\nStart\n→ Step 1: 建立卡牌頻率表 freq // 計算每張卡牌出現次數\n→ Step 2: 取得所有卡牌值並排序 sortedCards // 為了按升序處理\n→ Decision: 是否存在卡牌值? // 若空則直接 return true\n    Yes → Step 3: For each card in sortedCards // 逐一處理每個卡牌值\n        → Decision: freq[card] > 0? // 只處理未被消耗的卡牌\n            Yes → Step 4: groupCount = freq[card] // 本組需要的卡牌數\n            → Step 5: For offset from 0 to groupSize-1 // 檢查連續卡牌\n                → Step 6: nextCard = card + offset // 目標卡牌\n                → Decision: freq[nextCard] >= groupCount? // 確認足夠數量\n                    Yes → Step 7: freq[nextCard] -= groupCount // 消耗該卡牌\n                    No  → Step 8: Return False // 缺少卡牌，無法完成\n            → End For\n        No  → Step 9: Continue // 卡牌已消耗完，跳過\n    → End For\n→ Step 10: Return True // 所有卡牌成功分組\nEnd\n\nWe need to ensure arrow formatting: each line \"→ Step X: ...\" and \"→ Decision: ...\". Provide explanation after //.\n\nWe should include Start and End.\n\nMake sure to have proper indentation for decisions and nested steps? The sample shows indentation via spaces. We can use spaces for indentation, but it's not strictly required.\n\nAlso use Yes → and No → for decisions inside Decision blocks.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立卡牌頻率表 freq // 計算 hand 中每張卡牌出現的次數  \n→ Step 2: 取得所有卡牌值並排序 sortedCards // 以升序處理卡牌  \n→ Decision: sortedCards 是否存在卡牌? // 判斷是否有卡牌可處理  \n Yes → Step 3: For each card in sortedCards // 逐一處理每個卡牌值  \n  → Decision: freq[card] > 0? // 只處理尚未被消耗完的卡牌  \n   Yes → Step 4: groupCount = freq[card] // 本組需要消耗的卡牌數  \n   → Step 5: For offset from 0 to groupSize-1 // 檢查連續卡牌是否足夠  \n    → Step 6: nextCard = card + offset // 目標卡牌值  \n    → Decision: freq[nextCard] >= groupCount? // 確認是否有足夠數量  \n     Yes → Step 7: freq[nextCard] -= groupCount // 消耗該卡牌  \n     No  → Step 8: Return False // 缺少卡牌，無法完成分組  \n   → End For  \n  No  → Step 9: Continue // 卡牌已被消耗完，跳過  \n → End For  \n→ Step 10: Return True // 所有卡牌成功分組  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        # 如果總牌數不是 groupSize 的倍數，直接無法分組\n        if len(hand) % groupSize != 0:\n            return False\n\n        count = Counter(hand)\n        # 按牌值升序逐張處理\n        for card in sorted(count):\n            freq = count[card]\n            if freq > 0:\n                # 檢查從 card 開始的 groupSize 張牌是否都有足夠數量\n                for i in range(card, card + groupSize):\n                    if count[i] < freq:\n                        return False\n                    count[i] -= freq\n        return True\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取 hand 列表與 groupSize 整數。\n    允許輸入類似於 'hand = [1,2,3], groupSize = 3' 的格式。\n    \"\"\"\n    # 取出手牌列表\n    hand_match = re.search(r'hand\\s*=\\s*(\\[[^\\]]*\\])', data)\n    hand = eval(hand_match.group(1)) if hand_match else []\n\n    # 取出 groupSize 整數\n    group_match = re.search(r'groupSize\\s*=\\s*(\\d+)', data)\n    groupSize = int(group_match.group(1)) if group_match else 0\n\n    return hand, groupSize\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read()\n    hand, groupSize = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.isNStraightHand(hand, groupSize)\n    # 將布林值輸出為 'True' 或 'False'\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode88.json",
    "problem_index_in_file": 0,
    "title": "Merge Sorted Array",
    "description_snippet": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in steps, each line with \"虛擬碼步驟 // 解釋\". Must follow arrow syntax. Problem: merging two sorted arrays into nums1, using the end as target. Typical algorithm: set i = m-1, j = n-1, k = m+n-1, while i>=0 && j>=0: compare nums1[i] and nums2[j], set nums1[k] accordingly, decrement indices. Then while j>=0: nums1[k] = nums2[j]; j--; k--; (i elements already in place). Provide steps.\n\nWe need to produce the virtual code lines. Format: Start, steps with arrows. Use \"Decision:\" for decisions. Use indentation to show nested decisions. Use \"Yes →\" \"No →\". But we can also just use loops, but the requirement: Use arrows (→) and structure. We can express loops as \"While\" maybe? The sample didn't show loops but we can create \"Loop:\"? Not defined but can use \"While\". The requirement didn't forbid loops. But we can use \"Decision:\".\n\nLet's produce:\n\nStart\n→ Step 1: i ← m - 1 // nums1 last valid element index\n→ Step 2: j ← n - 1 // nums2 last index\n→ Step 3: k ← m + n - 1 // nums1 merge position\n→ Decision: i >= 0 AND j >= 0? // both arrays have elements\n    Yes → Step 4: Compare nums1[i] and nums2[j]\n        If nums1[i] > nums2[j] → Step 5: nums1[k] ← nums1[i] // place larger\n            i ← i - 1\n        Else → Step 6: nums1[k] ← nums2[j] // place larger\n            j ← j - 1\n        k ← k - 1\n        → Back to Decision: i >= 0 AND j >= 0? // repeat\n    No → Decision: j >= 0? // remaining nums2 elements\n        Yes → Step 7: nums1[k] ← nums2[j] // copy remaining\n            j ← j - 1\n            k ← k - 1\n            → Back to Decision: j >= 0?\n        No → End // done\n\nBut we need each line separate. Use arrows for each step. Provide simple decisions.\n\nLet's produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← m - 1 // 設定 nums1 的最後一個有效元素索引  \n→ Step 2: j ← n - 1 // 設定 nums2 的最後一個元素索引  \n→ Step 3: k ← m + n - 1 // 設定合併後的最終位置索引  \n→ Decision: i ≥ 0 且 j ≥ 0? // 兩陣列是否還有元素可比  \n    Yes → Step 4: 比較 nums1[i] 與 nums2[j]  \n        If nums1[i] > nums2[j] → Step 5: nums1[k] ← nums1[i] // 放入較大值  \n            i ← i - 1 // 移動 nums1 的索引  \n        Else → Step 6: nums1[k] ← nums2[j] // 放入較大值  \n            j ← j - 1 // 移動 nums2 的索引  \n        k ← k - 1 // 更新合併位置  \n        → Back to Decision: i ≥ 0 且 j ≥ 0? // 重複比較  \n    No → Decision: j ≥ 0? // 是否還有 nums2 的元素剩餘  \n        Yes → Step 7: nums1[k] ← nums2[j] // 把剩餘元素拷貝進 nums1  \n            j ← j - 1  \n            k ← k - 1  \n            → Back to Decision: j ≥ 0? // 繼續拷貝  \n        No → End // 合併完成，程式結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\ndef parse_input(text):\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', text)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', text)\n    m_match = re.search(r'm\\s*=\\s*(\\d+)', text)\n    n_match = re.search(r'n\\s*=\\s*(\\d+)', text)\n\n    nums1 = ast.literal_eval(nums1_match.group(1)) if nums1_match else []\n    nums2 = ast.literal_eval(nums2_match.group(1)) if nums2_match else []\n    m = int(m_match.group(1)) if m_match else 0\n    n = int(n_match.group(1)) if n_match else 0\n\n    return nums1, m, nums2, n\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    nums1, m, nums2, n = parse_input(input_text)\n    Solution().merge(nums1, m, nums2, n)\n    print(nums1)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "success": true,
          "output": "[1, 2, 2, 3, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1009.json",
    "problem_index_in_file": 0,
    "title": "Complement of Base 10 Integer",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. The task: compute binary complement of integer n. Steps: convert to binary string? Or bitwise operation: find number of bits, invert. Virtual code: Start, get n, determine bits, compute mask with all 1's of length bits, complement = n XOR mask, output. Or simpler: loop while n>0, for each bit flip. But we need virtual steps.\n\nWe'll produce a generic algorithm: \n1. Start\n2. Input n\n3. If n == 0: output 1? Actually complement of 0 (binary \"0\") flipping gives \"1\" -> 1. But often problem defines complement of 0 as 1. We'll include.\n4. Determine bit length: initialize temp=n, length=0; while temp>0: length++; temp>>=1.\n5. Build mask: mask = (1<<length)-1\n6. Complement = n XOR mask\n7. Output complement\n8. End\n\nWe need to use decision structure for n==0? Provide branch. We'll keep steps with Decision, Yes/No.\n\nWe need to produce each line: e.g., \"Start // 程式開始執行\"\n\nLet's write lines accordingly.\n\nEnsure each line includes virtual code step and comment after //. Use → arrow for steps. Use Decision: label.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入整數 n // 從使用者取得整數\n→ Decision: 如果 n 為 0? // 檢查 n 是否為零\n    Yes → Step 2: 輸出 1 // 0 的補數為 1\n    No  → Step 3: 設 temp = n // 初始化 temp 以計算位數\n→ Step 4: 設 length = 0 // 用於儲存二進位位數\n→ Decision: 是否 temp > 0? // 迴圈計算位數\n    Yes → Step 5: length += 1 // 位數加 1\n    Yes → Step 6: temp = temp >> 1 // 右移一位\n    Yes → 回到 Decision: 是否 temp > 0? // 重新檢查\n    No  → Step 7: 設 mask = (1 << length) - 1 // 生成全 1 的掩碼\n→ Step 8: 設 complement = n XOR mask // 將 n 取反\n→ Step 9: 輸出 complement // 回傳結果\nEnd // 程式執行結束\n\nBut we need to use proper indentation for decision branches: The example used indentation for Yes/No. We'll mimic: inside Decision, Yes→ etc. Use consistent arrow.\n\nWe must include arrow for Step lines. Use \"→\" before each step.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入整數 n // 從使用者取得整數  \n→ Decision: 如果 n 為 0? // 檢查 n 是否為零  \n Yes → Step 2: 輸出 1 // 0 的補數為 1，直接回傳  \n No  → Step 3: 設 temp = n // 初始化 temp 以計算位數  \n→ Step 4: 設 length = 0 // 用於儲存二進位位數  \n→ Decision: 是否 temp > 0? // 迴圈計算 n 的位數  \n Yes → Step 5: length += 1 // 位數加 1  \n Yes → Step 6: temp = temp >> 1 // 右移一位，繼續計算  \n Yes → 回到 Decision: 是否 temp > 0? // 重新檢查是否還有位數  \n No  → Step 7: 設 mask = (1 << length) - 1 // 生成全 1 的掩碼  \n→ Step 8: 設 complement = n XOR mask // 將 n 取反（按位 XOR 掩碼）  \n→ Step 9: 輸出 complement // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef bitwise_complement(n: int) -> int:\n    \"\"\"Return the binary complement of a non‑negative integer n.\"\"\"\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = (1 << bit_length) - 1\n    return n ^ mask\n\ndef parse_input(data: str) -> int:\n    \"\"\"Parse an integer from the input string.\n    Accepts formats like 'n = 5', '5', or any string containing an integer.\"\"\"\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    return int(match.group())\n\ndef main() -> None:\n    # Read all data from standard input\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return  # No input, nothing to do\n\n    # Extract the integer n\n    n = parse_input(raw_input)\n\n    # Compute its complement\n    result = bitwise_complement(n)\n\n    # Output the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 10",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode712.json",
    "problem_index_in_file": 0,
    "title": "Minimum ASCII Delete Sum for Two Strings",
    "description_snippet": "Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for solution to problem: given two strings s1, s2, find minimum ASCII sum of deleted characters to make them equal. Classic dynamic programming. We produce line-by-line steps with explanation. Not actual code. Use arrows. Include Start, End, Decision. Provide steps: input, initialize DP table of size (len1+1)x(len2+1). Compute dp[i][j] minimal ascii sum for prefixes. Use base cases: dp[i][0] sum of first i chars of s1; dp[0][j] sum of first j chars of s2. Then for i>0,j>0: if s1[i-1]==s2[j-1] dp[i][j]=dp[i-1][j-1]; else dp[i][j]=min(dp[i-1][j]+ord(s1[i-1]), dp[i][j-1]+ord(s2[j-1])). Finally return dp[len1][len2]. Use loops. Provide pseudo code steps.\n\nLet's format each line with arrow. For loops we can represent as Step: for i from 0 to len1: etc. Use Decision lines.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s1, s2 // 從使用者取得兩個字串  \n→ Step 2: 計算 len1 = s1 的長度, len2 = s2 的長度  \n→ Step 3: 初始化 DP 表格 dp[0..len1][0..len2] // 二維動態規劃表  \n→ Step 4: dp[0][0] = 0 // 空字串對空字串的最小刪除和  \n→ Step 5: for i from 1 to len1: // 設定第一列的基礎情況  \n  → Step 6: dp[i][0] = dp[i-1][0] + ASCII(s1[i-1]) // 只保留 s1 的字元，刪除其餘  \n→ Step 7: for j from 1 to len2: // 設定第一行的基礎情況  \n  → Step 8: dp[0][j] = dp[0][j-1] + ASCII(s2[j-1]) // 只保留 s2 的字元，刪除其餘  \n→ Step 9: for i from 1 to len1:  \n  → Step 10: for j from 1 to len2:  \n    → Decision: s1[i-1] 是否等於 s2[j-1]? // 檢查兩個字元是否相同  \n     Yes → Step 11: dp[i][j] = dp[i-1][j-1] // 字元相同，保持不刪除  \n     No → Step 12: dp[i][j] = min( dp[i-1][j] + ASCII(s1[i-1]), // 刪除 s1 的字元  \n                   dp[i][j-1] + ASCII(s2[j-1]) ) // 或刪除 s2 的字元  \n→ Step 13: 取得答案 ans = dp[len1][len2] // 最小刪除 ASCII 和  \n→ Step 14: 輸出 ans // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # Base cases: delete all characters from one string to match an empty string\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n\n        # DP transition\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(\n                        dp[i - 1][j] + ord(s1[i - 1]),\n                        dp[i][j - 1] + ord(s2[j - 1]),\n                    )\n\n        return dp[m][n]\n\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract quoted strings (assumes format like: s1 = \"string1\", s2 = \"string2\")\n    strings = re.findall(r'\"([^\"]*)\"', data)\n    if len(strings) >= 2:\n        s1, s2 = strings[0], strings[1]\n    else:\n        # Fallback: try to split by comma and strip quotes\n        parts = [p.strip() for p in data.split(\",\")]\n        s1 = parts[0].split('=')[1].strip().strip('\"')\n        s2 = parts[1].split('=')[1].strip().strip('\"')\n\n    solution = Solution()\n    result = solution.minimumDeleteSum(s1, s2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"sea\", s2 = \"eat\"",
          "expected_output": "231",
          "success": true,
          "output": "231"
        },
        {
          "example_index": 1,
          "input": "s1 = \"delete\", s2 = \"leet\"",
          "expected_output": "403",
          "success": true,
          "output": "403"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode640.json",
    "problem_index_in_file": 0,
    "title": "Solve the Equation",
    "description_snippet": "Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. The user wants to solve equation containing only +, -, variable x and its coefficient. Should return string \"x=#value\" or \"No solution\" or \"Infinite solutions\". They ask for virtual code, not actual code. We need to produce steps with explanation. Use arrows, Decision etc. Let's design algorithm.\n\nSteps:\n\nStart\n\n→ Step 1: Parse equation string into left and right sides by '='\n\n→ Step 2: For each side, compute total coefficient of x and constant term by iterating tokens.\n\n→ Step 3: Move all x terms to left, constants to right: compute totalCoef = coefLeft - coefRight, totalConst = constRight - constLeft\n\n→ Step 4: Decision: if totalCoef == 0?\n\n    Yes → Decision: if totalConst == 0?\n\n        Yes → Step 5: return \"Infinite solutions\"\n\n        No  → Step 6: return \"No solution\"\n\n    No  → Step 7: Compute x = totalConst / totalCoef (integer division)\n\n        Step 8: return \"x=\" + x\n\nEnd\n\nAlso need to explain each step.\n\nEdge: parsing may require splitting by '+' and '-' carefully. But we can generalize: tokenization using regex.\n\nWe should produce virtual code lines: each line with step comment. Use arrow arrows.\n\nWe need to use \"Start\", \"End\", \"Decision:\" with Yes → and No →.\n\nLet's produce.\n\nWe also need to mention that we ensure integer solution.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將方程式字串以 '=' 分割成左、右兩部分 // 把等式左右兩邊分開  \n→ Step 2: 定義兩個變數 totalCoefX = 0, totalConst = 0 // 初始化總係數與總常數  \n→ Decision: 是否需要先為左右兩邊各自解析? // 判斷是否分別處理  \n  Yes → Step 3: 解析左側：對每個項目，若包含 'x'，累加其係數到 leftCoef；若不含 'x'，累加數值到 leftConst  \n  No  → Step 4: 解析右側：對每個項目，若包含 'x'，累加其係數到 rightCoef；若不含 'x'，累加數值到 rightConst  \n→ Step 5: 將所有 x 係數移到左側，常數移到右側：  \n  totalCoefX = leftCoef - rightCoef  \n  totalConst = rightConst - leftConst // 右常數減左常數  \n→ Decision: totalCoefX 是否等於 0? // 判斷是否有 x 係數  \n  Yes → Decision: totalConst 是否等於 0? // 判斷常數是否也為 0  \n    Yes → Step 6: 回傳 \"Infinite solutions\" // 無限制多解  \n    No  → Step 7: 回傳 \"No solution\" // 無解  \n  No  → Step 8: 計算 x 值：x = totalConst / totalCoefX // 由於已保證結果為整數  \n    Step 9: 回傳 \"x=\" + x // 產生所需字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def solveEquation(self, equation: str) -> str:\n        # 解析單側方程，得到 x 的係數和常數項\n        def parse_side(s: str):\n            coeff_x, const = 0, 0\n            i, n, sign = 0, len(s), 1\n            while i < n:\n                if s[i] == '+':\n                    sign = 1\n                    i += 1\n                elif s[i] == '-':\n                    sign = -1\n                    i += 1\n                else:\n                    j = i\n                    while j < n and s[j] not in '+-':\n                        j += 1\n                    token = s[i:j]\n                    if 'x' in token:\n                        coeff = token[:-1]\n                        if coeff == '' or coeff == '+':\n                            coeff_val = 1\n                        elif coeff == '-':\n                            coeff_val = -1\n                        else:\n                            coeff_val = int(coeff)\n                        coeff_x += sign * coeff_val\n                    else:\n                        const += sign * int(token)\n                    i = j\n            return coeff_x, const\n\n        left, right = equation.split('=')\n        left_x, left_const = parse_side(left)\n        right_x, right_const = parse_side(right)\n\n        total_coeff = left_x - right_x\n        total_const = right_const - left_const\n\n        if total_coeff == 0:\n            if total_const == 0:\n                return \"Infinite solutions\"\n            else:\n                return \"No solution\"\n        else:\n            return f\"x={total_const // total_coeff}\"\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 取得方程式字串，支援帶引號或直接輸入\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and start < end:\n        equation = data[start + 1:end]\n    else:\n        equation = data.replace('equation =', '').strip()\n    sol = Solution()\n    result = sol.solveEquation(equation)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equation = \"x+5-3+x=6+x-2\"",
          "expected_output": "x=2",
          "success": true,
          "output": "x=2"
        },
        {
          "example_index": 1,
          "input": "equation = \"x=x\"",
          "expected_output": "Infinite solutions",
          "success": true,
          "output": "Infinite solutions"
        },
        {
          "example_index": 2,
          "input": "equation = \"2x=x\"",
          "expected_output": "x=0",
          "success": true,
          "output": "x=0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode128.json",
    "problem_index_in_file": 0,
    "title": "Longest Consecutive Sequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code, step by step, describing algorithm: O(n) using hash set to find start of sequences.\n\nSo steps: Build set of numbers, iterate each number, if num-1 not in set start new sequence, then iterate while next in set count length. Track max. End. Use virtual steps with arrows.\n\nWe must output each line with code step and comment.\n\nLet's produce.\n\nNeed Start End, Decision: with Yes/No arrow. Provide O(n) complexity.\n\nLet's produce.\n\nMake sure each line is: \"虛擬碼步驟 // 解釋\".\n\nWe'll start:\n\nStart // program start\n\n→ Step 1: Initialize set S with elements from nums // O(n)\n\n→ Step 2: Initialize maxLen = 0 // store longest length\n\n→ Step 3: For each number num in S // iterate over unique elements\n\n    → Decision: If num-1 is in S? // check if num is start of sequence\n\n        No  → // Not a start; skip to next\n\n        Yes → // Start of a sequence\n\n            → Step 4: Initialize current = num // current number\n\n            → Step 5: Initialize currentLen = 1 // length counter\n\n            → Decision: While current+1 is in S? // continue sequence\n\n                Yes →\n\n                    → Step 6: current = current + 1 // move to next\n\n                    → Step 7: currentLen = currentLen + 1 // increment length\n\n                    → Decision: Continue while loop\n\n                No → // end of this sequence\n\n                    → Step 8: maxLen = max(maxLen, currentLen) // update max\n\n→ Step 9: Return maxLen // output result\n\nEnd // program end\n\nNeed to include \"Decision:\" lines for each conditional.\n\nAlso for loop structure: \"For each number num in S\" is a loop; maybe use \"Decision:\" for loop? We'll just use for loop step.\n\nWe must keep each line separate with // explanation.\n\nAlso include arrows accordingly.\n\nMake sure to use proper formatting: arrow \"→\" for each step line; \"Decision:\" lines with indent.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立集合 S，將 nums 中所有元素加入 // O(n) 時間建立哈希集合  \n→ Step 2: 初始化變數 maxLen = 0 // 儲存目前為止的最大連續序列長度  \n→ Step 3: 遍歷集合 S 中每一個數字 num // 只處理唯一元素  \n    → Decision: 若 num-1 存在於 S? // 判斷 num 是否為序列起點  \n        No  → // 若不是起點，直接跳至下一個 num  \n        Yes → // 這個 num 為新的連續序列開始  \n            → Step 4: current = num // 設定目前檢查的數字  \n            → Step 5: currentLen = 1 // 目前序列長度從 1 開始  \n            → Decision: current+1 是否在 S? // 判斷序列是否可以延伸  \n                Yes →  \n                    → Step 6: current = current + 1 // 移動到下一個數字  \n                    → Step 7: currentLen = currentLen + 1 // 長度加一  \n                    → Decision: current+1 是否在 S? // 繼續檢查後續數字  \n                        Yes → (重複 Step 6–7)  \n                        No  → // 序列結束  \n                            → Step 8: maxLen = max(maxLen, currentLen) // 更新最大長度  \n                No  → // 直接更新最大長度（僅單一數字序列）  \n                    → Step 8: maxLen = max(maxLen, currentLen) // 更新最大長度  \n→ Step 9: 回傳 maxLen // 輸出最長連續序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef longest_consecutive(nums):\n    \"\"\"\n    返回 nums 中最長連續子序列的長度。\n    時間複雜度：O(n)，使用集合做快速查詢。\n    \"\"\"\n    if not nums:\n        return 0\n\n    num_set = set(nums)\n    longest = 0\n\n    for num in num_set:\n        # 如果 num-1 不在集合中，num 為序列起點\n        if num - 1 not in num_set:\n            current = num\n            length = 1\n\n            # 逐步往後搜尋連續整數\n            while current + 1 in num_set:\n                current += 1\n                length += 1\n\n            longest = max(longest, length)\n\n    return longest\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 從輸入中找出第一個 '[' 和最後一個 ']'，取其間的子字串\n    start = raw_input.find('[')\n    end = raw_input.rfind(']')\n    if start != -1 and end != -1 and end > start:\n        nums_str = raw_input[start:end+1]\n        try:\n            nums = ast.literal_eval(nums_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    result = longest_consecutive(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [100,4,200,1,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "nums = [1,0,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode56.json",
    "problem_index_in_file": 0,
    "title": "Merge Intervals",
    "description_snippet": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for merging overlapping intervals. Provide each line with arrow or decision etc. Start, End, Decision. Should be virtual code with \"Step 1:\" etc. Provide explanation after //.\n\nWe need to output only the pseudocode lines with explanation. Use Start and End markers. Use arrow. Use Decision. Should not output actual code. Must be in Traditional Chinese.\n\nLet's design steps:\n\n1. Start\n2. Step 1: Input intervals array\n3. Step 2: If intervals empty → return empty\n4. Step 3: Sort intervals by start ascending\n5. Step 4: Initialize merged list with first interval\n6. Step 5: For each interval from second to last:\n   - Decision: if current.start <= lastMerged.end?\n       Yes → update lastMerged.end = max(lastMerged.end, current.end) // merge\n       No  → Append current to merged // no overlap\n7. Step 6: Return merged\n8. End\n\nWe need to include arrow for loops? maybe use → for Step 5 loop. Use Decision inside.\n\nWe need to represent \"for each interval\". Use \"Loop: for i from 1 to len-1\". Use \"→\" for inside.\n\nLet's produce lines.\n\nUse \"→ Step ...\" and \"Decision: ...\".\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: intervals ← Input // 取得輸入的區間陣列\n→ Decision: intervals 為空? // 檢查是否沒有區間\n    Yes → Return [] // 若為空，直接回傳空陣列\n    No  → Continue // 否則進行排序\n→ Step 2: intervals ← Sort(intervals, by start ascending) // 按起點排序\n→ Step 3: merged ← [intervals[0]] // 以第一個區間開始合併清單\n→ Loop: for i ← 1 to len(intervals)-1 // 從第二個區間開始遍歷\n    → Current ← intervals[i] // 取得當前區間\n    → Last ← merged[-1] // 取得已合併清單的最後一個區間\n    → Decision: Current.start ≤ Last.end? // 判斷是否重疊\n        Yes → Last.end ← max(Last.end, Current.end) // 重疊則更新終點\n        No  → Append merged ← Current // 不重疊則加入新區間\n→ Step 4: Return merged // 回傳合併後的區間列表\nEnd // 程式執行結束\n\nBut we need to include each line with \"虛擬碼步驟\". Use \"Step\" etc. Use arrow \"→\" before each step. For loop we can use \"Loop:\" but it's not typical in given format. They want arrow for structure. We could use \"→ Loop: for i...\" but we can also just embed inside Decision.\n\nBetter to keep simple: Use \"→ Step 5: For i in 1..len-1\" etc. Use \"Decision\" inside.\n\nLet's craft final answer accordingly. Ensure each line is separate, with arrow. Use \"Decision:\" lines as nested. Use indentation? The example uses indentation for nested lines. We'll mimic that.\n\nMake sure to maintain Traditional Chinese for comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: intervals ← Input // 取得輸入的區間陣列  \n→ Decision: intervals 為空? // 檢查是否沒有區間  \n  Yes → Return [] // 若為空，直接回傳空陣列  \n  No  → Continue // 否則進行排序  \n→ Step 2: intervals ← Sort(intervals, by start ascending) // 按起點排序  \n→ Step 3: merged ← [intervals[0]] // 以第一個區間開始合併清單  \n→ Loop: for i ← 1 to len(intervals)-1 // 從第二個區間開始遍歷  \n  → Current ← intervals[i] // 取得當前區間  \n  → Last ← merged[-1] // 取得已合併清單的最後一個區間  \n  → Decision: Current.start ≤ Last.end? // 判斷是否重疊  \n    Yes → Last.end ← max(Last.end, Current.end) // 重疊則更新終點  \n    No  → Append merged ← Current // 不重疊則加入新區間  \n→ Step 4: Return merged // 回傳合併後的區間列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport re\nfrom ast import literal_eval\n\ndef merge(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        prev = merged[-1]\n        if current[0] <= prev[1]:\n            prev[1] = max(prev[1], current[1])\n        else:\n            merged.append(current)\n    return merged\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 從輸入字串中提取區間列表\n    match = re.search(r'=\\s*(\\[[^\\]]*\\])', raw)\n    list_str = match.group(1) if match else raw\n    try:\n        intervals = literal_eval(list_str)\n    except Exception:\n        intervals = []\n    result = merge(intervals)\n    # 以 JSON 格式輸出，保持無空格的簡潔表示\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "expected_output": "[[1,6],[8,10],[15,18]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,6],[8,10],[15,18]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[1,6],[8,10],[15,18]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,4],[4,5]]",
          "expected_output": "[[1,5]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,5]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[1,5]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "intervals = [[4,7],[1,4]]",
          "expected_output": "[[1,7]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,7]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[1,7]]'\nRaw Got:      '[]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode395.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring with At Least K Repeating Characters",
    "description_snippet": "Given a string s and an integer k, return the length of the longest substring of s such that the fre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo-code for algorithm: longest substring with all chars freq >= k. This is a classic problem solved by divide and conquer or sliding window. We can produce pseudo-code that uses divide and conquer: recursively split by characters with freq < k. Steps: count frequencies, find split points. Or use sliding window approach scanning all possible number of distinct characters. Simpler: use recursion. Let's produce pseudo-code accordingly.\n\nWe should output each line: \"虛擬碼步驟 // 解釋\". Use arrow, decisions, Start/End.\n\nMake sure each line has \"虛擬碼步驟 [space] // 解釋\". Use Start, End. Use Decision: with Yes →, No →. Use arrows. We'll produce a pseudo-code with recursion function.\n\nPseudo-code:\n\nStart // start program\n→ Input s, k // get string and k\n→ Call function longestSubstring(s, k) // compute result\n→ Output result\nEnd // program end\n\nDefine function longestSubstring(sub, k):\nStart // function start\n→ If length(sub) < k: Return 0 // cannot have all chars >=k\n→ Count freq of each char in sub\n→ Find any char c with freq < k\n→ If none: Return length(sub) // all chars satisfy\n→ Else:\n    → Split sub by chars where freq < k (these are split points)\n    → For each segment seg:\n        → result = max(result, longestSubstring(seg, k))\n    → Return result\nEnd // function end\n\nBut we need each line of pseudo-code. We'll break into lines:\n\nStart // 程式開始執行\n→ Input s, k // 取得字串 s 與整數 k\n→ result ← longestSubstring(s, k) // 呼叫遞迴函式計算最大長度\n→ Output result // 顯示結果\nEnd // 程式結束\n\nDefine longestSubstring(sub, k):\nStart // 函式開始\n→ If length(sub) < k: Return 0 // 子字串長度不足以達成頻率要求\n→ freq ← Count frequencies of characters in sub // 計算每個字元出現次數\n→ Decision: 有無字元頻率 < k? // 判斷是否存在不滿足條件的字元\n    Yes → badChars ← list of chars with freq < k // 收集所有頻率不足的字元\n        → segments ← split sub by any badChars // 將子字串以 badChars 為分隔符切割\n        → maxLen ← 0 // 初始化最大長度\n        → For each seg in segments:\n            → segLen ← longestSubstring(seg, k) // 重新遞迴處理每段\n            → If segLen > maxLen: maxLen ← segLen // 更新最大長度\n        → Return maxLen // 回傳此層的最大長度\n    No  → Return length(sub) // 所有字元頻率都≥k，回傳子字串長度\nEnd // 函式結束\n\nBut we need to adhere to the output format: each line: \"虛擬碼步驟 [space] // 解釋\". So no \"Define\" maybe \"Function:\". We'll write \"Function longestSubstring(sub, k) // 定義遞迴函式\". Then each line inside.\n\nLet's craft final answer accordingly.\n\nWe'll produce lines as:\n\nStart // 程式開始執行\n→ Input s, k // 讀入字串與整數\n→ result ← longestSubstring(s, k) // 計算結果\n→ Output result // 顯示長度\nEnd // 程式結束\n\nFunction longestSubstring(sub, k) // 定義遞迴函式\nStart // 函式開始\n→ If length(sub) < k: Return 0 // 長度不足，無法符合條件\n→ freq ← Count frequencies of characters in sub // 取得每個字元出現次數\n→ Decision: 有無字元頻率 < k? // 判斷是否存在不滿足條件的字元\n    Yes → badChars ← list of chars with freq < k // 收集頻率不足的字元\n        → segments ← split sub by any badChars // 以這些字元分割子字串\n        → maxLen ← 0 // 初始化最大長度\n        → For each seg in segments:\n            → segLen ← longestSubstring(seg, k) // 重新遞迴處理每段\n            → If segLen > maxLen: maxLen ← segLen // 更新最大長度\n        → Return maxLen // 回傳此層計算得到的最大長度\n    No  → Return length(sub) // 所有字元頻率都≥k，回傳子字串長度\nEnd // 函式結束\n\nWe need to ensure we use arrows and decisions format. Provide each line accordingly. Ensure indentation maybe not needed but we can show lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s, k // 讀入字串與整數  \n→ result ← longestSubstring(s, k) // 呼叫遞迴函式計算最大長度  \n→ Output result // 顯示最長子字串長度  \nEnd // 程式結束  \n\nFunction longestSubstring(sub, k) // 定義遞迴函式  \nStart // 函式開始  \n→ If length(sub) < k: Return 0 // 子字串長度不足，無法滿足頻率要求  \n→ freq ← Count frequencies of characters in sub // 計算每個字元出現次數  \n→ Decision: 有無字元頻率 < k? // 判斷是否存在不滿足條件的字元  \n Yes → badChars ← list of chars with freq < k // 收集所有頻率不足的字元  \n  → segments ← split sub by any badChars // 以這些字元為分隔符切割子字串  \n  → maxLen ← 0 // 初始化最大長度  \n  → For each seg in segments: // 逐段遞迴處理  \n   → segLen ← longestSubstring(seg, k) // 重新遞迴計算該段長度  \n   → If segLen > maxLen: maxLen ← segLen // 更新最大長度  \n  → Return maxLen // 回傳此層得到的最大長度  \n No  → Return length(sub) // 所有字元頻率都≥k，回傳子字串長度  \nEnd // 函式結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        if len(s) < k:\n            return 0\n\n        count = Counter(s)\n        for char in count:\n            if count[char] < k:\n                return max(self.longestSubstring(sub, k) for sub in s.split(char))\n        return len(s)\n\ndef parse_input(data: str):\n    # Try to match pattern like: s = \"aaabb\", k = 3\n    pattern = r's\\s*=\\s*\"([^\"]*)\",\\s*k\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if match:\n        s = match.group(1)\n        k = int(match.group(2))\n        return s, k\n\n    # Fallback: two lines, first is string, second is integer\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        s = lines[0].strip('\"').strip(\"'\")\n        try:\n            k = int(lines[1])\n        except ValueError:\n            k = int(re.search(r'\\d+', lines[1]).group())\n        return s, k\n\n    raise ValueError(\"Input format not recognized\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.longestSubstring(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabb\", k = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"ababbc\", k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode231.json",
    "problem_index_in_file": 0,
    "title": "Power of Two",
    "description_snippet": "Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nAn integer n is a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line. Steps: start, input n, decision if n <= 0? etc. The problem: Given integer n, return true if it's power of two. We can do: if n <= 0 → false. Then loop dividing by 2 while n%2==0. If after loop n==1 → true else false. Or bit trick: n & (n-1)==0. But we can use loop. Provide virtual code. Let's write.\n\nLine 1: Start\nLine 2: → Step 1: 輸入整數 n // 取得使用者輸入的數值\nLine 3: → Decision: n <= 0? // 檢查 n 是否為非正數\nLine 4: Yes → Step 2: 輸出 False // 非正數非 2 的冪\nLine 5: No  → Decision: n % 2 == 0? // 檢查 n 是否能被 2 整除\nLine 6: Yes → Step 3: n = n / 2 // 將 n 除以 2，重複檢查\nLine 7: No  → Decision: n == 1? // 最後 n 是否為 1\nLine 8: Yes → Step 4: 輸出 True // n 為 1 表示 2 的冪\nLine 9: No  → Step 5: 輸出 False // 否則非 2 的冪\nLine 10: End\n\nBut we need to loop. In virtual code, we might use a loop: while n % 2 == 0. We can express as Decision with Yes loop back.\n\nLet's design: after Step 1, Decision n <= 0? -> Yes -> output false end. No -> Decision n % 2 == 0? -> Yes -> Step: n = n/2; goto Decision n % 2 == 0? (loop). No -> Decision n == 1? -> Yes -> output true; No -> output false.\n\nSo need a back arrow. Use \"→\" to go to earlier step. We can indicate loop by indentation or by specifying \"→\" to earlier decision. Let's write:\n\nStart\n→ Step 1: 輸入整數 n // 取得使用者輸入\n→ Decision: n <= 0? // 非正數直接 false\n    Yes → Step 2: 輸出 False // 結束\n    No  → Decision: n % 2 == 0? // 能否被 2 整除\n        Yes → Step 3: n = n / 2 // 進行除法\n            → Decision: n % 2 == 0? // 重新判斷，形成迴圈\n        No  → Decision: n == 1? // 判斷是否已縮小到 1\n            Yes → Step 4: 輸出 True // 成功\n            No  → Step 5: 輸出 False // 失敗\nEnd\n\nBut we need to show line numbers? Not required. The format is \"虛擬碼步驟 [space] // 解釋\". We need to indent to show hierarchy. Provide each line as a separate line. Use indentation for nested decisions? The sample uses indentation. So produce same style.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得使用者輸入的數值\n→ Decision: n <= 0? // 判斷 n 是否非正數\n    Yes → Step 2: 輸出 False // 非正數不是 2 的冪\n    No  → Decision: n % 2 == 0? // 判斷 n 是否能被 2 整除\n        Yes → Step 3: n = n / 2 // 將 n 除以 2，進入下一輪判斷\n            → Decision: n % 2 == 0? // 重新判斷，形成迴圈\n        No  → Decision: n == 1? // 判斷是否已縮小到 1\n            Yes → Step 4: 輸出 True // n 為 1 表示是 2 的冪\n            No  → Step 5: 輸出 False // 不是 2 的冪\nEnd // 程式執行結束\n\nNeed to ensure that after Step 3, we loop back to the Decision n % 2 == 0? maybe we can show as \"→ Decision: n % 2 == 0? // 重新判斷\". Good.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得使用者輸入的數值  \n→ Decision: n <= 0? // 判斷 n 是否非正數  \n  Yes → Step 2: 輸出 False // 非正數不是 2 的冪  \n  No  → Decision: n % 2 == 0? // 判斷 n 是否能被 2 整除  \n   Yes → Step 3: n = n / 2 // 將 n 除以 2，進入下一輪判斷  \n     → Decision: n % 2 == 0? // 重新判斷，形成迴圈  \n   No  → Decision: n == 1? // 判斷是否已縮小到 1  \n    Yes → Step 4: 輸出 True // n 為 1 表示是 2 的冪  \n    No  → Step 5: 輸出 False // 不是 2 的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        \"\"\"Return True if n is a power of two, otherwise False.\"\"\"\n        if n <= 0:\n            return False\n        # A power of two has exactly one bit set in binary representation\n        return (n & (n - 1)) == 0\n\ndef main() -> None:\n    # Read entire input from stdin\n    data = sys.stdin.read()\n    # Extract the first integer (handles optional leading/trailing text like 'n =')\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return  # No integer found, nothing to output\n    n = int(match.group())\n    solution = Solution()\n    result = solution.isPowerOfTwo(n)\n    # Output lowercase 'true' or 'false' as required\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode455.json",
    "problem_index_in_file": 0,
    "title": "Assign Cookies",
    "description_snippet": "Assume you are an awesome parent and want to give your children some cookies. But, you should give e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code, line by line, with explanation comments. It's essentially the \"Assign Cookies\" problem: greedy algorithm: sort greed factors and cookie sizes, then two pointers. Provide step-by-step pseudocode.\n\nWe must follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows and structure.\n\nWe need to include Start, End, Decision etc. Let's produce lines.\n\nWe might structure:\n\nStart\n→ Read n,m // number of children and cookies\n→ Input array g[1..n] // greed factors\n→ Input array s[1..m] // cookie sizes\n→ Sort g ascending\n→ Sort s ascending\n→ Set i = 0, j = 0, count = 0 // indices and counter\n→ Decision: i < n AND j < m? // still have children and cookies\n    Yes → Decision: s[j] >= g[i]? // cookie big enough\n        Yes → count = count + 1 ; i = i + 1 ; j = j + 1 // assign and move both\n        No → j = j + 1 // cookie too small, try bigger cookie\n    No → End\nEnd\n\nAdd comments.\n\nNeed to output in Traditional Chinese.\n\nMake sure each line ends with comment after //.\n\nAlso include \"Decision:\" lines with indent? In example they indent sublines. We'll keep same style.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read n, m // 讀取兒童數量與餅乾數量  \n→ Input array g[1..n] // 讀入每個兒童的貪婪值  \n→ Input array s[1..m] // 讀入每塊餅乾的大小  \n→ Sort g ascending // 將貪婪值升序排列，便於一次性配對  \n→ Sort s ascending // 將餅乾大小升序排列，方便逐一匹配  \n→ Set i = 0, j = 0, count = 0 // i 為兒童索引，j 為餅乾索引，count 記錄滿足兒童數  \n→ Decision: i < n AND j < m? // 是否還有未分配的兒童與餅乾？  \n  Yes → Decision: s[j] >= g[i]? // 当前餅乾是否足以滿足當前兒童？  \n   Yes → count = count + 1 ; i = i + 1 ; j = j + 1 // 兒童滿足，分配餅乾，移動兩個指標  \n   No  → j = j + 1 // 餅乾太小，嘗試下一塊較大的餅乾  \n  No  → End // 所有兒童或餅乾已處理完畢  \nEnd // 程式執行結束，count 即為最大滿足兒童數量",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findContentChildren(self, g, s):\n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 g 與 s 的列表。\n    支援類似 \"g = [1,2,3], s = [1,1]\" 或者在多行中出現的格式。\n    \"\"\"\n    g_match = re.search(r'g\\s*=\\s*(\\[[^\\]]*\\])', data)\n    s_match = re.search(r's\\s*=\\s*(\\[[^\\]]*\\])', data)\n    g = ast.literal_eval(g_match.group(1)) if g_match else []\n    s = ast.literal_eval(s_match.group(1)) if s_match else []\n    return g, s\n\ndef main():\n    raw_data = sys.stdin.read()\n    g, s = parse_input(raw_data)\n    result = Solution().findContentChildren(g, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "g = [1,2], s = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode155.json",
    "problem_index_in_file": 0,
    "title": "Min Stack",
    "description_snippet": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nI...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each line \"虛擬碼步驟 // 解釋\". We need to design algorithm for MinStack with O(1). Typically use two stacks: data stack and min stack. Each push pushes val to data, and pushes min(val, top of minStack) onto minStack. Pop pops both. Top returns top of data. getMin returns top of minStack.\n\nNeed to produce step by step pseudocode.\n\nWe need to follow format with arrows and structure: Start, End, Decision etc.\n\nWe should present algorithm for class initialization and methods. We can produce top-level steps for each method.\n\nMaybe break into Start, define class, methods. Use arrows.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Define MinStack // 建立 MinStack 類別\n→ Declare two stacks: mainStack, minStack // 主堆疊與最小值堆疊\n→ MinStack() // 建構子\n    → Initialize mainStack and minStack as empty // 初始化為空堆疊\n→ push(val)\n    → Push val onto mainStack // 把值加入主堆疊\n    → Decision: Is minStack empty? // 檢查最小值堆疊是否為空\n        Yes → Push val onto minStack // 空時直接把 val 作為最小值\n        No  → Decision: val < minStack.top()? // 與當前最小值比較\n            Yes → Push val onto minStack // 更小則更新最小值\n            No  → Push minStack.top() onto minStack // 保持舊最小值\n→ pop()\n    → Decision: mainStack is empty? // 檢查是否有元素\n        Yes → // do nothing or error // 空時不做任何事\n        No  → Pop from mainStack // 移除主堆頂\n        → Pop from minStack // 同時移除最小值堆頂\n→ top()\n    → Decision: mainStack is empty? // 檢查是否有元素\n        Yes → Return error // 空時返回錯誤\n        No  → Return mainStack.top() // 回傳主堆頂\n→ getMin()\n    → Decision: minStack is empty? // 檢查是否有元素\n        Yes → Return error // 空時返回錯誤\n        No  → Return minStack.top() // 回傳當前最小值\nEnd // 程式執行結束\n\nNeed to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow arrows \"→\". Use Decision blocks with indent? The sample shows indent and arrows inside. Use same style.\n\nWe should maintain structure: Start, End, Decision:... Yes →..., No →...\n\nWe must include each step line by line. Let's produce lines.\n\nLine1: Start // 程式開始執行\n\nLine2: → Define MinStack // 建立 MinStack 類別\n\nLine3: → Declare two stacks: mainStack, minStack // 主堆疊與最小值堆疊\n\nLine4: → MinStack() // 建構子\n\nLine5:     → Initialize mainStack and minStack as empty // 初始化為空堆疊\n\nLine6: → push(val) // push 方法\n\nLine7:     → Push val onto mainStack // 將值加入主堆疊\n\nLine8:     → Decision: Is minStack empty? // 檢查最小值堆疊是否為空\n\nLine9:         Yes → Push val onto minStack // 空時直接把 val 作為最小值\n\nLine10:         No  → Decision: val < minStack.top()? // 與當前最小值比較\n\nLine11:             Yes → Push val onto minStack // 更小則更新最小值\n\nLine12:             No  → Push minStack.top() onto minStack // 保持舊最小值\n\nLine13: → pop() // pop 方法\n\nLine14:     → Decision: mainStack is empty? // 檢查是否有元素\n\nLine15:         Yes → // do nothing // 空時不做任何事\n\nLine16:         No  → Pop from mainStack // 移除主堆頂\n\nLine17:             → Pop from minStack // 同時移除最小值堆頂\n\nLine18: → top() // top 方法\n\nLine19:     → Decision: mainStack is empty? // 檢查是否有元素\n\nLine20:         Yes → Return error // 空時返回錯誤\n\nLine21:         No  → Return mainStack.top() // 回傳主堆頂\n\nLine22: → getMin() // getMin 方法\n\nLine23:     → Decision: minStack is empty? // 檢查是否有元素\n\nLine24:         Yes → Return error // 空時返回錯誤\n\nLine25:         No  → Return minStack.top() // 回傳當前最小值\n\nLine26: End // 程式執行結束\n\nWe need to ensure that the lines with indentation preserve arrow formatting. The sample uses tabs or spaces. We can use four spaces indentation to show nested lines.\n\nAlso we might include comments after // explaining.\n\nOk. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define MinStack // 建立 MinStack 類別  \n→ Declare two stacks: mainStack, minStack // 主堆疊與最小值堆疊  \n→ MinStack() // 建構子  \n    → Initialize mainStack and minStack as empty // 初始化為空堆疊  \n→ push(val) // push 方法  \n    → Push val onto mainStack // 將值加入主堆疊  \n    → Decision: Is minStack empty? // 檢查最小值堆疊是否為空  \n        Yes → Push val onto minStack // 空時直接把 val 作為最小值  \n        No  → Decision: val < minStack.top()? // 與當前最小值比較  \n            Yes → Push val onto minStack // 更小則更新最小值  \n            No  → Push minStack.top() onto minStack // 保持舊最小值  \n→ pop() // pop 方法  \n    → Decision: mainStack is empty? // 檢查是否有元素  \n        Yes → // do nothing // 空時不做任何事  \n        No  → Pop from mainStack // 移除主堆頂  \n            → Pop from minStack // 同時移除最小值堆頂  \n→ top() // top 方法  \n    → Decision: mainStack is empty? // 檢查是否有元素  \n        Yes → Return error // 空時返回錯誤  \n        No  → Return mainStack.top() // 回傳主堆頂  \n→ getMin() // getMin 方法  \n    → Decision: minStack is empty? // 檢查是否有元素  \n        Yes → Return error // 空時返回錯誤  \n        No  → Return minStack.top() // 回傳當前最小值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    \"\"\"Stack that supports push, pop, top, and retrieving the minimum element in O(1).\"\"\"\n\n    def __init__(self):\n        self.stack = []        # Main stack to store all values\n        self.min_stack = []    # Auxiliary stack to keep track of minimums\n\n    def push(self, val: int) -> None:\n        \"\"\"Push an element onto the stack.\"\"\"\n        self.stack.append(val)\n        # Update min_stack: push current value if it's new minimum,\n        # otherwise keep the previous minimum on top.\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        \"\"\"Remove the top element from the stack.\"\"\"\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        # If the popped value is the current minimum, pop it from min_stack too.\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -> int:\n        \"\"\"Return the top element of the stack.\"\"\"\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self) -> int:\n        \"\"\"Retrieve the minimum element in the stack.\"\"\"\n        return self.min_stack[-1] if self.min_stack else None\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the input into operations and arguments\n    # Input format:  [\"op1\",\"op2\",...],[args1,args2,...]\n    try:\n        split_idx = data.index('],')\n        ops_str = data[:split_idx + 1]   # include the closing bracket\n        args_str = data[split_idx + 2:]  # skip the comma\n    except ValueError:\n        # If the format is not as expected, raise an error\n        raise ValueError(\"Input format incorrect. Expected two JSON arrays separated by a comma.\")\n\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    res = []\n    stack_obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack_obj = MinStack()\n            res.append(None)  # LeetCode-style null\n        elif op == \"push\":\n            stack_obj.push(arg[0])\n            res.append(None)\n        elif op == \"pop\":\n            stack_obj.pop()\n            res.append(None)\n        elif op == \"top\":\n            res.append(stack_obj.top())\n        elif op == \"getMin\":\n            res.append(stack_obj.getMin())\n        else:\n            raise ValueError(f\"Unsupported operation: {op}\")\n\n    # Convert Python's None to JSON null in the output\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "success": true,
          "output": "[null, null, null, null, -3, null, 0, -2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode12.json",
    "problem_index_in_file": 0,
    "title": "Integer to Roman",
    "description_snippet": "Seven different symbols represent Roman numerals with the following values:\n\nSymbol\tValue\nI\t1\nV\t5\nX\t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines. Let's outline algorithm: use mapping arrays for values and symbols. Iterate through list of tuples descending. For each value, while num>=value, append symbol, subtract. But handle subtractive: we need pairs for 4 and 9 forms. Simpler: use arrays of values and symbols including subtractive pairs: [1000,\"M\"], [900,\"CM\"], [500,\"D\"], [400,\"CD\"], [100,\"C\"], [90,\"XC\"], [50,\"L\"], [40,\"XL\"], [10,\"X\"], [9,\"IX\"], [5,\"V\"], [4,\"IV\"], [1,\"I\"]. Then loop.\n\nImplement virtual code accordingly with Start, Decision etc.\n\nLet's produce step-by-step lines.\n\nUse decision to iterate over array.\n\nLet's write:\n\nStart\n→ Step 1: 初始化值列表 values = [1000,900,500,400,100,90,50,40,10,9,5,4,1] // 预设值\n→ Step 2: 初始化符号列表 symbols = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"] // 对应符号\n→ Step 3: 初始化输入整数 num, 初始化空字符串 result // 准备结果\n→ Step 4: 初始化索引 i = 0 // 從最大值開始\n→ Decision: i < values.length? // 是否還有值需要處理\n    Yes → Decision: num >= values[i]? // 当前值是否能減去\n        Yes → Step 5: result += symbols[i] // 添加符号\n        Yes → Step 6: num -= values[i] // 减去对应数值\n        Yes → Decision: num >= values[i]? // 是否仍能继续减去同一值\n            Yes → 回到上一步Decision  // 继续循环同一值\n            No  → Step 7: i += 1 // 轉到下一個更小的值\n        No  → Step 7: i += 1 // 当前值不适用，转到下一个\n    No → Step 8: 输出 result // 完成转换\nEnd\n\nBut we need \"逐行虛擬碼\" with arrow for each line. Use \"→\" preceding each step.\n\nAlso ensure decision formatting with nested indentation. Provide comment after each line.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化值列表 values = [1000,900,500,400,100,90,50,40,10,9,5,4,1] // 先設定所有可用的數值（含減法形式）  \n→ Step 2: 初始化符號列表 symbols = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"] // 對應於 values 的羅馬字母  \n→ Step 3: 初始化輸入整數 num, result = \"\" // 讀入要轉換的數字並準備結果字串  \n→ Step 4: i = 0 // 從最大值開始索引  \n→ Decision: i < values.length? // 是否還有數值需要處理？  \n  Yes → Decision: num >= values[i]? // 此值是否可被減去？  \n   Yes → Step 5: result += symbols[i] // 加上對應符號  \n   Yes → Step 6: num -= values[i] // 減去該數值  \n   Yes → Decision: num >= values[i]? // 是否還能再次使用同一數值？  \n    Yes → 回到上一行 Decision // 重新判斷是否可繼續減去同一個值  \n    No  → Step 7: i += 1 // 移到下一個更小的值  \n   No  → Step 7: i += 1 // 當前值不適用，直接往下  \n  No  → Step 7: i += 1 // 當 num 小於 values[i] 時跳過該值  \n→ Decision: i < values.length? // 仍有值未處理？  \n  Yes → 回到上一層 Decision // 重複整個過程  \n  No  → Step 8: 輸出 result // 轉換完成，輸出羅馬字母  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef int_to_roman(num: int) -> str:\n    \"\"\"將整數轉換為羅馬數字。\"\"\"\n    # 數值與對應羅馬符號，先處理較大的值再往下\n    values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    roman_parts = []\n    for value, symbol in zip(values, symbols):\n        # 只要 num 大於等於 value，就重複加入 symbol\n        while num >= value:\n            roman_parts.append(symbol)\n            num -= value\n    return ''.join(roman_parts)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取所有內容，並尋找第一個整數\n    data = sys.stdin.read()\n    number_match = re.search(r\"\\d+\", data)\n    if number_match:\n        number = int(number_match.group())\n        result = int_to_roman(number)\n        print(result)\n    else:\n        # 若沒有找到數字，直接輸出空字串或提示\n        print(\"\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 3749",
          "expected_output": "\"MMMDCCXLIX\"",
          "success": true,
          "output": "MMMDCCXLIX"
        },
        {
          "example_index": 1,
          "input": "num = 58",
          "expected_output": "\"LVIII\"",
          "success": true,
          "output": "LVIII"
        },
        {
          "example_index": 2,
          "input": "num = 1994",
          "expected_output": "\"MCMXCIV\"",
          "success": true,
          "output": "MCMXCIV"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode165.json",
    "problem_index_in_file": 0,
    "title": "Compare Version Numbers",
    "description_snippet": "Given two version strings, version1 and version2, compare them. A version string consists of revisio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. For the problem: compare version strings. Provide pseudo code with arrows and decisions. Use Start, End. Provide line-by-line. Use 虛擬碼步驟 + // 解釋.\n\nWe'll produce something like:\n\nStart // start\n→ Split version1 by '.' into list1 // get revisions\n→ Split version2 by '.' into list2\n→ Determine maxLen = max(length of list1, length of list2) // to iterate\n→ For i from 0 to maxLen-1:\n    → Get rev1 = if i < len(list1) then int(list1[i]) else 0 // convert or 0\n    → Get rev2 = if i < len(list2) then int(list2[i]) else 0\n    → Decision: rev1 > rev2? // compare\n        Yes → Return 1 // version1 greater\n        No → Decision: rev1 < rev2? // compare\n            Yes → Return -1 // version1 smaller\n            No → Continue // equal, next revision\n→ Return 0 // all revisions equal\nEnd // done\n\nNeed to use virtual code arrows. Format: `虛擬碼步驟` + space + `// 解釋`. Use arrow notation.\n\nMake sure each line has arrow or start/end.\n\nWe need to use `Start`, `End`, `Decision:` etc. Use `→` for steps.\n\nWe might need loops: maybe use `While` or `For`. We'll represent as `→ For i = 0 to maxLen-1:` etc.\n\nLet's produce.\n\nAlso need to include splitting, parsing to integer ignoring leading zeros. Use int conversion.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: list1 ← Split(version1, '.') // 以 '.' 分割第一個版本字串，得到修訂版號列表\n→ Step 2: list2 ← Split(version2, '.') // 以 '.' 分割第二個版本字串，得到修訂版號列表\n→ Step 3: maxLen ← Max(length(list1), length(list2)) // 取兩個列表長度的最大值，以確保遍歷所有修訂版\n→ Step 4: For i ← 0 to maxLen - 1: // 逐一比較每個位置的修訂版號\n    → Decision: i < length(list1) ? // 判斷第一個版本是否還有該位置的修訂版\n        Yes → rev1 ← Integer(list1[i]) // 取得並轉成整數（忽略前導零）\n        No  → rev1 ← 0 // 若缺失，視為 0\n    → Decision: i < length(list2) ? // 判斷第二個版本是否還有該位置的修訂版\n        Yes → rev2 ← Integer(list2[i]) // 取得並轉成整數（忽略前導零）\n        No  → rev2 ← 0 // 若缺失，視為 0\n    → Decision: rev1 > rev2? // 比較兩個修訂版號\n        Yes → Return 1 // 第一個版本更大，結束\n        No  → Decision: rev1 < rev2? // 仍需要判斷是否更小\n            Yes → Return -1 // 第二個版本更大，結束\n            No  → Continue // 相等，進入下一個修訂版\n→ Step 5: Return 0 // 所有修訂版號都相等，兩個版本相同\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        \"\"\"Compare two version strings and return -1, 0, or 1.\"\"\"\n        # Split each version string into integer revisions\n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        # Compare each revision; treat missing revisions as 0\n        for i in range(max(len(v1), len(v2))):\n            num1 = v1[i] if i < len(v1) else 0\n            num2 = v2[i] if i < len(v2) else 0\n            if num1 < num2:\n                return -1\n            if num1 > num2:\n                return 1\n        return 0\n\ndef parse_input(data: str):\n    \"\"\"Extract two version strings from the input data.\"\"\"\n    # Find all substrings enclosed in double quotes\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # If no quoted strings, split by whitespace\n    tokens = data.strip().split()\n    if len(tokens) >= 2:\n        return tokens[0], tokens[1]\n    # If still not enough, fallback to empty strings\n    return \"\", \"\"\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    version1, version2 = parse_input(data)\n    solution = Solution()\n    result = solution.compareVersion(version1, version2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "version1 = \"1.2\", version2 = \"1.10\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "version1 = \"1.0\", version2 = \"1.0.0.0\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode692.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Words",
    "description_snippet": "Given an array of strings words and an integer k, return the k most frequent strings.\n\nReturn the an...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: given words array and k, return k most frequent strings sorted by frequency desc, tie by lexicographical order. Should produce step-by-step pseudocode with arrows and explanation. Use Start, Decision, End, etc.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" before each step, and Decision: ... with Yes →, No →. Use Start, End.\n\nWe need to produce a linear pseudo code: count frequencies, sort by (frequency desc, lex asc), then pick first k.\n\nBut we must show as a flow: Start → Step 1: count frequencies → Step 2: create list of pairs (word, freq) → Step 3: sort list by custom comparator → Step 4: take first k words → End.\n\nWe can include decisions: e.g., Step: If words array empty? → yes -> return empty. But not necessary. But we can show some decision.\n\nLet's produce lines accordingly.\n\nWe need to use Chinese (繁體) for explanation.\n\nLet's produce: Start // 程式開始執行\n\n→ Step 1: Initialize hash map countMap to map string→int // 建立字典統計字詞頻率\n\n→ Step 2: For each word in words: if word not in countMap, countMap[word] = 0; countMap[word]++ // 逐字遍歷並累加頻率\n\n→ Decision: 如果 words 為空? // 判斷是否有輸入\n\n    Yes → Step 3: Return empty list // 沒有字詞時直接回傳空結果\n\n    No → Proceed to next step\n\n→ Step 4: Convert countMap entries to list of (word, freq) pairs // 轉成可排序的列表\n\n→ Step 5: Sort the list with comparator: first by freq descending, then by word ascending // 依頻率遞減、字典序遞增排序\n\n→ Step 6: Initialize result list // 建立結果容器\n\n→ Step 7: For i from 0 to k-1: if i < list.size() then add list[i].word to result // 取前k個字詞\n\n→ End // 程式執行結束\n\nAdd maybe a Decision: if k > list.size()? but we can handle by adding condition.\n\nLet's output each line with // explanation.\n\nWe need to use arrow arrow. Use \"→ Step X: ...\" lines.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize countMap as empty hash map from string to int // 建立字典統計字詞頻率  \n→ Step 2: For each word in words:  \n  → If word not in countMap then countMap[word] = 0  \n  → countMap[word]++ // 逐字遍歷並累加頻率  \n→ Decision: words 為空? // 判斷是否有輸入  \n  Yes → Step 3: Return empty list // 沒有字詞時直接回傳空結果  \n  No → Continue  \n→ Step 4: Convert countMap entries to list of (word, freq) pairs // 轉成可排序的列表  \n→ Step 5: Sort the list with comparator: first by freq descending, then by word ascending // 依頻率遞減、字典序遞增排序  \n→ Step 6: Initialize result as empty list // 建立結果容器  \n→ Step 7: For i from 0 to k-1:  \n  → If i < list.size() then add list[i].word to result // 取前k個字詞  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        \"\"\"\n        計算每個字詞的頻率，並依頻率降序、字典序升序排序，最後取前 k 個字詞。\n        \"\"\"\n        count = Counter(words)\n        # 先依頻率遞減，若頻率相同則依字典序遞增\n        sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0]))\n        # 取前 k 個字詞\n        return [word for word, _ in sorted_words[:k]]\n\nif __name__ == \"__main__\":\n    \"\"\"\n    讀取整個輸入，解析出 words 列表與 k 整數，並輸出前 k 個頻率最高的字詞。\n    輸入範例：\n        words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n    輸出範例：\n        [\"i\",\"love\"]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析 words 列表\n    words_match = re.search(r'words\\s*=\\s*(\\[[^\\]]*\\])', data)\n    words = eval(words_match.group(1)) if words_match else []\n\n    # 解析 k 整數\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    k = int(k_match.group(1)) if k_match else 0\n\n    solution = Solution()\n    result = solution.topKFrequent(words, k)\n\n    # 使用 json.dumps 以符合範例輸出格式\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "success": true,
          "output": "[\"i\", \"love\"]"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "success": true,
          "output": "[\"the\", \"is\", \"sunny\", \"day\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode728.json",
    "problem_index_in_file": 0,
    "title": "Self Dividing Numbers",
    "description_snippet": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to compute list of self-dividing numbers between left and right inclusive. Provide steps line by line with explanation, using arrows etc. No actual code.\n\nWe need to output virtual code lines: Start, arrow to Step 1: ... Then Decision: ... etc. We'll need to cover loop over range, check digits, skip zero, check divisibility. Use list to store result. Then End.\n\nWe need to produce steps like:\n\nStart // program start\n→ Step 1: Initialize result list // create empty list\n→ Step 2: For number from left to right inclusive: // iterate\n   → Decision: If number contains 0? // skip\n      Yes → Continue // skip to next number\n      No  → Step 3: Check divisibility by each digit\n         → Decision: If all digits divide number? // boolean\n            Yes → Step 4: Append number to result\n            No  → No action\n→ Step 5: Return result // output list\nEnd\n\nWe need to show each line with explanation after //.\n\nAlso ensure each line uses arrow format: \"→\" or \"Yes →\" etc.\n\nWe need to use Decision: etc.\n\nWe also need to show Start, End.\n\nLet's produce a more detailed step-by-step:\n\nStart\n→ Step 1: Set result = [] // initialize empty list\n→ Step 2: For num from left to right:\n   → Decision: If num contains digit 0? // check for zero digit\n      Yes → Continue // skip this num\n      No  → Step 3: Set temp = num, flag = true // temp for digit extraction\n         → While temp > 0:\n            → Step 4: digit = temp % 10 // get last digit\n            → Decision: If num % digit != 0? // test divisibility\n               Yes → Step 5: flag = false; Break // not self-dividing\n               No  → Step 6: temp = temp / 10 // remove digit\n         → Decision: If flag == true? // all digits passed\n            Yes → Step 7: Append num to result\n            No  → No action\n→ Step 8: Return result\nEnd\n\nWe should keep each line separate.\n\nMake sure to use \"→\" arrow for step lines, \"Decision:\" for decision, and indent decision branches.\n\nWe need to maintain indentation via spaces.\n\nAlso each line must have \"//\" explanation.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set result = [] // 初始化空列表，用於儲存自除數  \n→ Step 2: For num from left to right inclusive: // 逐一檢查區間內每個數字  \n   → Decision: If num contains digit 0? // 檢查是否含有 0，因為自除數不允許 0  \n      Yes → Continue // 若含 0，直接跳過本數字  \n      No  → Step 3: Set temp = num, flag = true // 初始化 temp 用於分離位元，flag 判斷是否全為可整除  \n         → While temp > 0: // 逐位元分離  \n            → Step 4: digit = temp % 10 // 取得最低位數字  \n            → Decision: If num % digit != 0? // 檢查當前位元是否整除 num  \n               Yes → Step 5: flag = false; Break // 若不整除，標記失敗並離開循環  \n               No  → Step 6: temp = temp / 10 // 整除以去除已處理位元  \n         → Decision: If flag == true? // 所有位元都可整除  \n            Yes → Step 7: Append num to result // 加入結果列表  \n            No  → No action // 不是自除數，什麼也不做  \n→ Step 8: Return result // 回傳所有自除數的列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef self_dividing_numbers(left: int, right: int):\n    \"\"\"\n    Return a list of all self‑dividing numbers in the inclusive range [left, right].\n    \"\"\"\n    res = []\n    for num in range(left, right + 1):\n        temp = num\n        divisible = True\n        while temp > 0:\n            digit = temp % 10\n            if digit == 0 or num % digit != 0:\n                divisible = False\n                break\n            temp //= 10\n        if divisible:\n            res.append(num)\n    return res\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read()\n    # Extract integers from the input string\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) >= 2:\n        left, right = nums[0], nums[1]\n        result = self_dividing_numbers(left, right)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 1, right = 22",
          "expected_output": "[1,2,3,4,5,6,7,8,9,11,12,15,22]",
          "success": true,
          "output": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"
        },
        {
          "example_index": 1,
          "input": "left = 47, right = 85",
          "expected_output": "[48,55,66,77]",
          "success": true,
          "output": "[48, 55, 66, 77]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1296.json",
    "problem_index_in_file": 0,
    "title": "Divide Array in Sets of K Consecutive Numbers",
    "description_snippet": "Given an array of integers nums and a positive integer k, check whether it is possible to divide thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Let's think algorithm: Count frequency of each number via map. Then sort unique numbers. For each number in sorted order: if freq>0, we need to subtract freq from next k-1 consecutive numbers. If any number missing or freq negative => return false. Finally return true.\n\nWe need to produce steps with Start, Step lines, Decision, etc. Also each line should be \"虛擬碼步驟 // 解釋\".\n\nUse arrow symbol '→' at start of step line. Include Decision lines with indentation maybe using tabs. Let's produce something like:\n\nStart // start\n\n→ Step 1: 建立空哈希表 count // 统计每个整数出现次数\n\n→ Step 2: 对 nums 中每个 num 进行 count[num]++ // 填充计数\n\n→ Step 3: 将 count 的键取出并排序为 sortedNums // 获取升序唯一数字\n\n→ Decision: sortedNums 是否为空? // 如果为空直接返回 true\n\n   Yes → End // 空数组可分组\n\n   No  →\n\n→ Step 4: 遍历 sortedNums 中的每个 num\n\n   → Decision: count[num] > 0? // 是否还有未分组的该数\n\n      Yes →\n\n         → Step 5: 设 curCount = count[num] // 当前要分配的组数\n\n         → Step 6: 对 i 从 0 到 k-1 进行\n\n            → Step 7: target = num + i // 目标数\n\n            → Decision: count[target] < curCount? // 目标数不足\n\n               Yes → Step 8: 返回 false // 不可能分组\n\n               No  → Step 9: count[target] -= curCount // 减去已分配\n\n         → Step 10: // 结束对该 num 的处理\n\n      No  → // 该数已被完全分配，继续下一个\n\n→ End // 所有检查完毕，返回 true\n\nBut need to output boolean return. Add Step 11: return true after loop.\n\nAlso include Return step after false earlier.\n\nWe must keep arrow formatting: \"→\" then maybe indent for nested. Use consistent indentation with spaces.\n\nWe'll produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空哈希表 count // 用於統計每個數字出現的頻率  \n→ Step 2: 對 nums 中每個 num 進行 count[num]++ // 填充頻率表  \n→ Step 3: 將 count 的鍵取出並排序為 sortedNums // 獲取升序的唯一數字列表  \n→ Decision: sortedNums 是否為空? // 空陣列自動符合條件  \n   Yes → End // 回傳 true，程式結束  \n   No  →  \n→ Step 4: 遍歷 sortedNums 中的每個 num // 按升序處理每個數字  \n   → Decision: count[num] > 0? // 是否還有未分配的該數字  \n      Yes →  \n         → Step 5: 設定 curCount = count[num] // 需要分配的組數  \n         → Step 6: 對 i 從 0 到 k-1 進行 // 檢查 k 個連續數字  \n            → Step 7: target = num + i // 目標連續數字  \n            → Decision: count[target] < curCount? // 目標數字是否不足  \n               Yes →  \n                  → Step 8: 返回 false // 無法完成分組，結束程式  \n               No  →  \n                  → Step 9: count[target] -= curCount // 從目標數字中扣除已分配的數量  \n         → Step 10: // 結束對 num 的處理  \n      No  → // num 已完全分配，繼續下一個數字  \n→ Step 11: 返回 true // 所有檢查完成，符合條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isPossibleDivide(self, nums, k: int) -> bool:\n        # If total length not divisible by k, impossible\n        if len(nums) % k != 0:\n            return False\n\n        count = Counter(nums)\n        # Process numbers in ascending order\n        for num in sorted(count):\n            freq = count[num]\n            if freq == 0:\n                continue\n            # Need to create `freq` groups starting at `num`\n            for val in range(num, num + k):\n                if count[val] < freq:\n                    return False\n                count[val] -= freq\n        return True\n\ndef main():\n    # Read the entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list of numbers\n    list_match = re.search(r'\\[.*?\\]', data)\n    if not list_match:\n        raise ValueError(\"Input format error: cannot find number list.\")\n    nums_str = list_match.group()\n    nums = eval(nums_str)  # safely parse the list\n\n    # Extract the value of k\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not k_match:\n        raise ValueError(\"Input format error: cannot find k value.\")\n    k = int(k_match.group(1))\n\n    solution = Solution()\n    result = solution.isPossibleDivide(nums, k)\n    # Output in lowercase as required\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,3,4,4,5,6], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode238.json",
    "problem_index_in_file": 0,
    "title": "Product of Array Except Self",
    "description_snippet": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for the product except self problem, in O(n) time, no division. Use prefix and suffix products. Provide line-by-line pseudocode with explanation. Must follow format exactly: each line \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End, Decision if needed. Probably not many decisions. Provide algorithm: initialize answer array, left product array. Steps: compute left products, then right product on the fly. Provide pseudocode accordingly. Use arrow lines. Provide explanation comments. Use Start, End.\n\nLet's craft:\n\nStart\n→ Step 1: 將輸入陣列 nums 的長度存入 n // 取得陣列長度\n→ Step 2: 建立長度為 n 的答案陣列 answer 並初始化為 1 // 每個位置先設為 1\n→ Step 3: 設定變數 left = 1 // 左側累積乘積初值\n→ Step 4: 從左至右遍歷索引 i 0 到 n-1\n    → Step 4.1: answer[i] = left // 將目前左側乘積存入答案\n    → Step 4.2: left = left * nums[i] // 更新左側乘積\n→ Step 5: 設定變數 right = 1 // 右側累積乘積初值\n→ Step 6: 從右至左遍歷索引 i n-1 到 0\n    → Step 6.1: answer[i] = answer[i] * right // 加入右側乘積\n    → Step 6.2: right = right * nums[i] // 更新右側乘積\n→ Step 7: 回傳 answer // 完成\nEnd\n\nNeed to use arrow lines: \"→\" prefix each step. Use \"Start\" and \"End\". No other formatting. Provide line-by-line with comments.\n\nEnsure that we use correct syntax: \"→ Step X:\" etc. Provide nested arrows for sub-steps? The example shows nested with indent and arrow for Yes/No. For loops, we can indicate as Step 4: Loop i from 0 to n-1, then inside indent. We'll use indentation by spaces.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將輸入陣列 nums 的長度存入變數 n // 取得陣列長度\n→ Step 2: 建立長度為 n 的答案陣列 answer 並初始化為 1 // 每個位置先設為 1\n→ Step 3: 設定變數 left = 1 // 左側累積乘積初值\n→ Step 4: 從左至右遍歷索引 i = 0 到 n-1\n    → Step 4.1: answer[i] = left // 把目前左側乘積寫入答案\n    → Step 4.2: left = left * nums[i] // 更新左側乘積以備下一位\n→ Step 5: 設定變數 right = 1 // 右側累積乘積初值\n→ Step 6: 從右至左遍歷索引 i = n-1 到 0\n    → Step 6.1: answer[i] = answer[i] * right // 把目前右側乘積乘入答案\n    → Step 6.2: right = right * nums[i] // 更新右側乘積以備下一位\n→ Step 7: 回傳 answer // 完成結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def productExceptSelf(self, nums):\n        n = len(nums)\n        res = [1] * n\n        left = 1\n        for i in range(n):\n            res[i] = left\n            left *= nums[i]\n        right = 1\n        for i in range(n - 1, -1, -1):\n            res[i] *= right\n            right *= nums[i]\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 找出第一個 '['，如果沒有則直接解析整個輸入\n    start = data.find('[')\n    if start == -1:\n        nums = ast.literal_eval(data)\n    else:\n        nums = ast.literal_eval(data[start:])\n    solution = Solution()\n    result = solution.productExceptSelf(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "[24,12,8,6]",
          "success": true,
          "output": "[24, 12, 8, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,1,0,-3,3]",
          "expected_output": "[0,0,9,0,0]",
          "success": true,
          "output": "[0, 0, 9, 0, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode321.json",
    "problem_index_in_file": 0,
    "title": "Create Maximum Number",
    "description_snippet": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 re...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: given two arrays of digits, create maximum number of length k from digits while preserving relative order within each array. Classic LeetCode problem \"Create Maximum Number\". Approach: For each possible split i from max(0,k-n) to min(k,m): pick i digits from nums1, k-i from nums2. For each, get maximum subsequence of length i from nums1, similarly for nums2. Then merge two subsequences into maximum number (like merging with lexicographic comparison). Finally pick maximum among all merges.\n\nSo virtual code steps: Start, get min and max for split loop, function to pick max subsequence, function to merge, comparison of merges. End.\n\nWe need to output line by line with arrow and explanation.\n\nLet's craft. Use virtual steps like:\n\nStart // start\n→ Step 1: Determine start = max(0, k - len(nums2)), end = min(k, len(nums1)) // bounds for selecting digits from nums1\n\n→ Loop i from start to end: // iterate split\n    → Step 2: seq1 = pickMax(nums1, i) // get max subsequence length i from nums1\n    → Step 3: seq2 = pickMax(nums2, k - i) // get max subsequence length k-i from nums2\n    → Step 4: candidate = merge(seq1, seq2) // merge into max number\n    → Decision: if candidate > best // compare lexicographically\n        Yes → Step 5: best = candidate // update best\n\n→ End // finished\n\nNeed functions: pickMax and merge. Provide steps inside them.\n\nDefine function pickMax(nums, t):\n- Use stack to keep digits, remove if greater next digit and remaining > needed.\n\nDefine function merge(seq1, seq2):\n- While seq1 or seq2 not empty:\n    - If seq1 > seq2 lexicographically, take first from seq1 else seq2.\n\nComparison lexicographic: use array compare.\n\nNeed to represent function definitions.\n\nLet's produce virtual code lines.\n\nUse arrow for decisions.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: m ← length(nums1) // 取得第一個陣列長度\n→ Step 2: n ← length(nums2) // 取得第二個陣列長度\n→ Step 3: best ← empty array of length k // 儲存目前最佳答案\n→ Step 4: min_i ← max(0, k - n) // nums1 最少取幾個\n→ Step 5: max_i ← min(k, m) // nums1 最多取幾個\n→ Decision: For i from min_i to max_i // 依分割方式嘗試\n    Yes → Step 6: seq1 ← pickMax(nums1, i) // 從 nums1 取最大子序列\n    Yes → Step 7: seq2 ← pickMax(nums2, k - i) // 從 nums2 取最大子序列\n    Yes → Step 8: candidate ← merge(seq1, seq2) // 合併兩個子序列\n    Yes → Decision: if candidate > best // 比較字典序\n        Yes → Step 9: best ← candidate // 更新最佳答案\n→ End // 程式結束\n\nNow define pickMax:\n\n→ Function pickMax(nums, t) // 取得長度 t 的最大子序列\n    → Step 10: stack ← empty list // 用於堆疊\n    → Step 11: drop ← length(nums) - t // 可丟棄的數量\n    → Loop each num in nums:\n        → Decision: while stack not empty AND stack.last < num AND drop > 0\n            Yes → Step 12: stack.pop() // 移除較小前綴\n            Yes → Step 13: drop ← drop - 1 // 下降可丟棄數量\n        → Step 14: stack.push(num) // 放入堆疊\n    → Step 15: return first t elements of stack // 取前 t 個作為結果\n\nDefine merge:\n\n→ Function merge(seq1, seq2) // 合併兩個序列為最大數\n    → Step 16: result ← empty list\n    → While seq1 not empty OR seq2 not empty:\n        → Decision: if seq1 > seq2 // 以字典序比較\n            Yes → Step 17: result.append(seq1[0]); seq1 ← seq1[1:]\n            No  → Step 18: result.append(seq2[0]); seq2 ← seq2[1:]\n    → Step 19: return result // 合併後的序列\n\nComparison function: maybe embed in Decision: seq1 > seq2 uses lexicographic comparison.\n\nWe might need a helper compare(seqA, seqB): return true if seqA > seqB lexicographically.\n\nBut can embed inline.\n\nAlso need to compare candidate > best lexicographically. Use similar logic.\n\nAdd Decision: compareArrays(candidate, best)\n\nDefine compareArrays:\n\n→ Function compareArrays(a, b) // 返回 a > b\n    → Step 20: for idx from 0 to length(a)-1:\n        → Decision: a[idx] != b[idx]\n            Yes → Decision: a[idx] > b[idx]\n                Yes → Step 21: return True\n                No  → Step 22: return False\n    → Step 23: return False // 若相同則不大\n\nBut can just use inline.\n\nWe can keep simple.\n\nLet's produce virtual code.\n\nMake sure each line ends with // 解釋.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← length(nums1) // 取得第一個陣列長度  \n→ Step 2: n ← length(nums2) // 取得第二個陣列長度  \n→ Step 3: best ← empty array of length k // 儲存目前最佳答案  \n→ Step 4: min_i ← max(0, k - n) // nums1 最少取幾個  \n→ Step 5: max_i ← min(k, m) // nums1 最多取幾個  \n→ Decision: For i from min_i to max_i // 依分割方式嘗試  \n    Yes → Step 6: seq1 ← pickMax(nums1, i) // 從 nums1 取最大子序列  \n    Yes → Step 7: seq2 ← pickMax(nums2, k - i) // 從 nums2 取最大子序列  \n    Yes → Step 8: candidate ← merge(seq1, seq2) // 合併兩個子序列  \n    Yes → Decision: if compareArrays(candidate, best) // 比較字典序  \n        Yes → Step 9: best ← candidate // 更新最佳答案  \n→ End // 程式結束  \n\nFunction pickMax(nums, t) // 取得長度 t 的最大子序列  \n    → Step 10: stack ← empty list // 用於堆疊  \n    → Step 11: drop ← length(nums) - t // 可丟棄的數量  \n    → Loop each num in nums:  \n        → Decision: while stack not empty AND stack.last < num AND drop > 0  \n            Yes → Step 12: stack.pop() // 移除較小前綴  \n            Yes → Step 13: drop ← drop - 1 // 下降可丟棄數量  \n        → Step 14: stack.push(num) // 放入堆疊  \n    → Step 15: return first t elements of stack // 取前 t 個作為結果  \n\nFunction merge(seq1, seq2) // 合併兩個序列為最大數  \n    → Step 16: result ← empty list  \n    → While seq1 not empty OR seq2 not empty:  \n        → Decision: if compareArrays(seq1, seq2) // 以字典序比較  \n            Yes → Step 17: result.append(seq1[0]); seq1 ← seq1[1:] // 取 seq1 前元素  \n            No  → Step 18: result.append(seq2[0]); seq2 ← seq2[1:] // 取 seq2 前元素  \n    → Step 19: return result // 合併後的序列  \n\nFunction compareArrays(a, b) // 返回 a > b  \n    → Step 20: for idx from 0 to length(a)-1:  \n        → Decision: a[idx] != b[idx]  \n            Yes → Decision: a[idx] > b[idx]  \n                Yes → Step 21: return True // a 在字典序上更大  \n                No  → Step 22: return False // a 在字典序上更小  \n    → Step 23: return False // 若相同則不大 (或等於)",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def maxNumber(self, nums1, nums2, k):\n        def pick_max(nums, t):\n            drop = len(nums) - t\n            stack = []\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:t]\n\n        def merge(a, b):\n            res = []\n            while a or b:\n                # Use lexicographic comparison of remaining lists\n                if a > b:\n                    res.append(a[0])\n                    a = a[1:]\n                else:\n                    res.append(b[0])\n                    b = b[1:]\n            return res\n\n        max_res = []\n        m, n = len(nums1), len(nums2)\n        start = max(0, k - n)\n        end = min(k, m)\n        for i in range(start, end + 1):\n            a = pick_max(nums1, i)\n            b = pick_max(nums2, k - i)\n            candidate = merge(a, b)\n            if candidate > max_res:\n                max_res = candidate\n        return max_res\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the two lists and k\n    lists = re.findall(r'\\[.*?\\]', data)\n    nums1 = ast.literal_eval(lists[0])\n    nums2 = ast.literal_eval(lists[1])\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    k = int(k_match.group(1)) if k_match else 0\n\n    sol = Solution()\n    result = sol.maxNumber(nums1, nums2, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5",
          "expected_output": "[9,8,6,5,3]",
          "success": true,
          "output": "[9, 8, 6, 5, 3]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [6,7], nums2 = [6,0,4], k = 5",
          "expected_output": "[6,7,6,0,4]",
          "success": true,
          "output": "[6, 7, 6, 0, 4]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [3,9], nums2 = [8,9], k = 3",
          "expected_output": "[9,8,9]",
          "success": true,
          "output": "[9, 8, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode343.json",
    "problem_index_in_file": 0,
    "title": "Integer Break",
    "description_snippet": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the pro...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code. Problem: integer break: maximum product by splitting into at least two positive integers. Classic dynamic programming or greedy: break into 3s, but need k>=2. For n=2->1, n=3->2, etc. The algorithm: if n<=3 return n-1. else compute product of as many 3's as possible, with remainder. Use integer multiplication. Provide step-by-step virtual code.\n\nWe need to output lines with virtual code and explanation.\n\nWe need to produce virtual pseudocode step by step. Use \"Start\", \"End\". Use \"Decision:\".\n\nWe need to include arrow lines.\n\nLet's produce:\n\nStart\n→ Step 1: 接收輸入整數 n\n→ Decision: n <= 3? \n   Yes → Step 2: 返回 n - 1\n   No  → Step 3: 設置 result = 1\n→ Step 4: 計算 quotient = n / 3, remainder = n % 3\n→ Decision: remainder == 0? \n   Yes → Step 5: 將 quotient 個 3 相乘 result *= 3^quotient\n   No  → Decision: remainder == 1? \n        Yes → Step 6: result *= 3^(quotient-1) * 4 // 1+3 -> 4\n        No  → Step 7: result *= 3^quotient * remainder\n→ Step 8: 返回 result\nEnd\n\nBut must show arrows and decisions. For multiplication 3^quotient, we can iterate multiplication.\n\nNeed to show iterative multiplication lines maybe:\n\n→ Step 5: for i=1 to quotient do result *= 3\n\nBut we also can do exponent.\n\nSimplify: produce loops.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得需要分解的數字\n→ Decision: n <= 3? // 小數情況直接決定\n    Yes → Step 2: 回傳 n - 1 // 2 ->1, 3->2\n    No  → Step 3: 設定 result = 1 // 初始化乘積\n→ Step 4: 計算 quotient = n / 3, remainder = n % 3 // 取得除以3的商與餘數\n→ Decision: remainder == 0? // 檢查餘數\n    Yes → Step 5: for i = 1 to quotient do result *= 3 // 所有 3 相乘\n    No  → Decision: remainder == 1? // 若餘數為1\n        Yes → Step 6: for i = 1 to (quotient - 1) do result *= 3 // 先把一個 3 轉為 4\n              → Step 7: result *= 4 // 4 代表 2+2\n        No  → Step 8: for i = 1 to quotient do result *= 3 // 乘以所有 3\n              → Step 9: result *= remainder // 再乘以餘數 (2)\n→ Step 10: 回傳 result // 最終最大乘積\nEnd // 程式執行結束\n\nLet's check lines formatting.\n\nWe need to ensure each line: virtual code step + space + // explanation.\n\nWe need to use arrow \"→\" at start of each step except Start and End. For Decision we indent? We can just indent lines.\n\nBut format: \nStart //...\n→ Step 1: ...\n→ Decision: ...\n    Yes → Step 2: ...\n    No  → Step 3: ...\n\nWe need to keep consistent indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得需要分解的數字  \n→ Decision: n <= 3? // 小數情況直接決定  \n Yes → Step 2: 回傳 n - 1 // 2 -> 1, 3 -> 2  \n No  → Step 3: 設定 result = 1 // 初始化乘積  \n→ Step 4: 計算 quotient = n / 3, remainder = n % 3 // 取得除以3的商與餘數  \n→ Decision: remainder == 0? // 檢查餘數  \n Yes → Step 5: for i = 1 to quotient do result *= 3 // 所有 3 相乘  \n No  → Decision: remainder == 1? // 若餘數為1  \n  Yes → Step 6: for i = 1 to (quotient - 1) do result *= 3 // 先把一個 3 轉為 4  \n   → Step 7: result *= 4 // 4 代表 2+2  \n  No  → Step 8: for i = 1 to quotient do result *= 3 // 乘以所有 3  \n   → Step 9: result *= remainder // 再乘以餘數 (2)  \n→ Step 10: 回傳 result // 最終最大乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef integer_break(n: int) -> int:\n    \"\"\"\n    分解整数 n 為至少兩個正整數，使其乘積最大。\n    這裡使用贈物法：盡量拆成 3，若剩餘 1 則把一個 3 合成 4（2+2）。\n    \"\"\"\n    if n == 2:\n        return 1          # 1 + 1 = 2 → 1*1 = 1\n    if n == 3:\n        return 2          # 2 + 1 = 3 → 2*1 = 2\n\n    result = 1\n    while n > 4:\n        result *= 3\n        n -= 3\n    # 此時 n 為 2、3 或 4，直接乘上即可\n    return result * n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中提取第一個整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    print(integer_break(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 10",
          "expected_output": "36",
          "success": true,
          "output": "36"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode438.json",
    "problem_index_in_file": 0,
    "title": "Find All Anagrams in a String",
    "description_snippet": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step solution. Problem: find all start indices of anagrams of p in s. Approach: sliding window, frequency map of p, compare with window map. Return indices. Steps: compute freq of p, window freq, sliding over s, check equality. Complexity O(n). We'll produce pseudo code lines with arrows. Use Start, End, Decision. Provide explanation after //.\n\nNeed to include arrow → for each step. We'll structure: Start, step 1: initialize variables, step 2: build freq map, step 3: iterate with window, step 4: adjust counts, step 5: compare maps, if equal add index, step 6: move window. Use Decision for comparing maps? Instead can just check equality. Use Decision: if window count matches p count? Yes → add index. No → nothing. Provide explanations.\n\nLet's produce.\n\nMake sure each line has virtual code step then space then // explanation.\n\nWe must not output real code. So use words: Step 1: Set variables, etc.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化 p 的字頻表 freqP // 建立 p 中每個字母的出現次數\n→ Step 2: 初始化空字頻表 freqW // 用於滑動窗口中的字頻\n→ Step 3: 設定窗口大小 lenP = length of p // 知道滑動窗口的長度\n→ Step 4: 從 s 的前 lenP 個字符更新 freqW // 為第一個窗口建立字頻\n→ Decision: 如果 freqW 與 freqP 相等? // 判斷第一個窗口是否為字母重排\n    Yes → Step 5: 將索引 0 加入答案 // 第一個窗口符合條件\n    No  → // 不做操作\n→ Step 6: 從 i = lenP 到 length of s - 1 迴圈 // 遍歷剩餘字符\n    → Step 6.1: 進入新字符 c = s[i] 的頻率加 1 在 freqW // 調整右邊邊界\n    → Step 6.2: 移出舊字符 d = s[i - lenP] 的頻率減 1 在 freqW // 調整左邊邊界\n    → Decision: 如果 freqW 與 freqP 相等? // 檢查新窗口\n        Yes → Step 6.3: 將起始索引 i - lenP + 1 加入答案 // 添加符合的起始位置\n        No  → // 不做操作\n→ End // 程式執行結束\n\nMake sure we maintain indent levels with arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 p 的字頻表 freqP // 建立 p 中每個字母的出現次數  \n→ Step 2: 初始化空字頻表 freqW // 用於滑動窗口中的字頻  \n→ Step 3: 設定窗口大小 lenP = length of p // 知道滑動窗口的長度  \n→ Step 4: 從 s 的前 lenP 個字符更新 freqW // 為第一個窗口建立字頻  \n→ Decision: 如果 freqW 與 freqP 相等? // 判斷第一個窗口是否為字母重排  \n  Yes → Step 5: 將索引 0 加入答案 // 第一個窗口符合條件  \n  No  → // 不做操作  \n→ Step 6: 從 i = lenP 到 length of s - 1 迴圈 // 遍歷剩餘字符  \n  → Step 6.1: 進入新字符 c = s[i] 的頻率加 1 在 freqW // 調整右邊邊界  \n  → Step 6.2: 移出舊字符 d = s[i - lenP] 的頻率減 1 在 freqW // 調整左邊邊界  \n  → Decision: 如果 freqW 與 freqP 相等? // 檢查新窗口  \n    Yes → Step 6.3: 將起始索引 i - lenP + 1 加入答案 // 添加符合的起始位置  \n    No  → // 不做操作  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef find_anagrams(s: str, p: str):\n    ns, np = len(s), len(p)\n    if ns < np:\n        return []\n\n    p_count = Counter(p)\n    s_count = Counter(s[:np])\n    res = []\n\n    if s_count == p_count:\n        res.append(0)\n\n    for i in range(1, ns - np + 1):\n        left = s[i - 1]\n        s_count[left] -= 1\n        if s_count[left] == 0:\n            del s_count[left]\n\n        right = s[i + np - 1]\n        s_count[right] += 1\n\n        if s_count == p_count:\n            res.append(i)\n\n    return res\n\ndef main():\n    data = sys.stdin.read()\n    data = data.replace('\\n', ' ')\n\n    # Try to extract s and p from patterns like: s = \"...\" , p = \"...\"\n    s_match = re.search(r's\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', data)\n    p_match = re.search(r'p\\s*=\\s*[\\'\"]([^\\'\"]*)[\\'\"]', data)\n\n    if s_match and p_match:\n        s = s_match.group(1)\n        p = p_match.group(1)\n    else:\n        # Fallback: assume the first two whitespace‑separated tokens are s and p\n        parts = data.split()\n        s = parts[0] if len(parts) > 0 else \"\"\n        p = parts[1] if len(parts) > 1 else \"\"\n\n    result = find_anagrams(s, p)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"cbaebabacd\", p = \"abc\"",
          "expected_output": "[0,6]",
          "success": true,
          "output": "[0, 6]"
        },
        {
          "example_index": 1,
          "input": "s = \"abab\", p = \"ab\"",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode467.json",
    "problem_index_in_file": 0,
    "title": "Unique Substrings in Wraparound String",
    "description_snippet": "We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so b...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code. The algorithm: Given s, count unique substrings that appear as contiguous in infinite wraparound string. Known solution: track longest contiguous substring ending with each letter, then sum. For each char in s, compute length of current consecutive wraparound substring, update array of max length for each ending letter. Then sum. Also need to handle duplicates, but using this DP ensures unique. Provide pseudo-code line by line with explanation.\n\nWe need to output lines: \"Start // 程式開始執行\" etc.\n\nPseudo-code steps: \n1. Initialize array maxLen[26] = 0.\n2. prevLen = 0.\n3. For each character c in s:\n    - If c is consecutive after previous char in wraparound sense (i.e., (c - prevChar + 26) % 26 == 1), then prevLen++ else prevLen = 1.\n    - index = c - 'a'.\n    - maxLen[index] = max(maxLen[index], prevLen).\n4. Sum over maxLen to get result.\n5. Return result.\n\nWe need to incorporate decision for checking consecutive. We'll use if else. Provide explanation comments in Chinese.\n\nLet's output step-by-step.\n\nRemember no actual code, just virtual steps with arrow. Use \"Decision:\".\n\nLet's craft.\n\nWe'll output:\n\nStart\n→ Step 1: 初始化 26 個字母對應的最大子串長度陣列 maxLen[26] 為 0 // 用來記錄以每個字母結尾的最大有效子串長度\n→ Step 2: prevLen ← 0 // 追蹤當前連續有效子串長度\n→ Decision: 迭代 s 的每個字元 c? // 遍歷輸入字串\n    Yes → Step 3: 若 i > 0 且 c 與前一字元 prevChar 在字母表上恰好相鄰（(c - prevChar + 26) mod 26 == 1）? // 判斷是否為連續\n        Yes → prevLen ← prevLen + 1 // 繼續延伸長度\n        No  → prevLen ← 1 // 重置長度為 1\n    Yes → Step 4: idx ← ord(c) - ord('a') // 將字母映射到 0-25\n    Yes → Step 5: maxLen[idx] ← max(maxLen[idx], prevLen) // 更新該結尾字母的最大長度\n→ End // 完成遍歷\n→ Step 6: result ← sum(maxLen[0..25]) // 所有字母最大長度相加即為唯一子串數\n→ Step 7: return result // 回傳答案\nEnd\n\nBut we need arrows with indentation. Use \"Decision:\" lines. In the pseudo-code we can use nested indent. Also use \"Yes →\" \"No →\".\n\nMake sure each line includes comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 26 個字母對應的最大子串長度陣列 maxLen[26] 為 0 // 用來記錄以每個字母結尾的最大有效子串長度  \n→ Step 2: prevLen ← 0 // 追蹤當前連續有效子串長度  \n→ Decision: 迭代 s 的每個字元 c? // 遍歷輸入字串  \n  Yes → Step 3: 若 i > 0 且 c 與前一字元 prevChar 在字母表上恰好相鄰（(c - prevChar + 26) mod 26 == 1）?  \n    Yes → prevLen ← prevLen + 1 // 繼續延伸長度  \n    No  → prevLen ← 1 // 重置長度為 1  \n  Yes → Step 4: idx ← ord(c) - ord('a') // 將字母映射到 0-25  \n  Yes → Step 5: maxLen[idx] ← max(maxLen[idx], prevLen) // 更新該結尾字母的最大長度  \n→ End // 完成遍歷  \n→ Step 6: result ← sum(maxLen[0..25]) // 所有字母最大長度相加即為唯一子串數  \n→ Step 7: return result // 回傳答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findSubstringInWraproundString(self, p: str) -> int:\n        # dp[i] 表示以字母 chr(i + ord('a')) 結尾的最大子串長度\n        dp = [0] * 26\n        k = 0  # 目前連續子串長度\n\n        for i, ch in enumerate(p):\n            if i > 0 and (ord(ch) - ord(p[i - 1])) % 26 == 1:\n                k += 1\n            else:\n                k = 1\n            idx = ord(ch) - ord('a')\n            if k > dp[idx]:\n                dp[idx] = k\n\n        return sum(dp)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：若包含 's ='，則提取雙引號中的內容\n    if 's =' in data:\n        start = data.find('\"')\n        end = data.rfind('\"')\n        if start != -1 and end != -1 and end > start:\n            s = data[start + 1:end]\n        else:\n            s = data.replace('s =', '').strip().strip('\"')\n    else:\n        s = data.strip().strip('\"')\n    sol = Solution()\n    result = sol.findSubstringInWraproundString(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode219.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate II",
    "description_snippet": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that checks for duplicates within k distance. It's classic problem. Steps: Use hash map to store last index of number. Iterate array with index i, if number seen before, check distance <=k -> return true. Else update map. After loop, return false.\n\nWe need to output line by line: each line with virtual code step and explanation. Use arrow syntax: Start, → Step, Decision, etc.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize an empty hash map `indexMap` // 用來記錄每個數字最後出現的位置\n→ Step 2: For each index `i` from 0 to length(nums)-1 // 逐個遍歷陣列\n    → Decision: If nums[i] exists in indexMap? // 檢查此數字是否已經出現過\n        Yes →\n            → Decision: If i - indexMap[nums[i]] <= k? // 距離是否小於等於 k\n                Yes → Step 3: Return true // 找到符合條件的重複元素\n                No  → Step 4: Update indexMap[nums[i]] = i // 更新為最新索引，繼續遍歷\n        No →\n            → Step 5: Insert nums[i] with index i into indexMap // 第一次出現\n→ Step 6: Return false // 未找到任何符合條件的重複元素\nEnd\n\nWe need to match the format exactly: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use \"Start\", \"End\". Use arrow \"→\" for step, and indentation for nested decision.\n\nEnsure each line has the arrow or \"Start\" etc. For decisions we use \"Decision: ...?\" Then sub lines with Yes → or No →. Must include the explanation after //.\n\nLet's produce.\n\nAlso ensure no actual code like arrays. Use placeholders like `indexMap`, `nums`, `i`, `k`. Use Chinese comments.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的哈希表 indexMap // 用於儲存每個數字最後一次出現的索引  \n→ Step 2: 從 i = 0 開始遍歷 nums 的每個索引 // 逐一檢查陣列中的元素  \n  Decision: nums[i] 是否已存在於 indexMap? // 判斷此數字是否曾經出現  \n   Yes → Decision: i - indexMap[nums[i]] <= k? // 計算距離是否不超過 k  \n    Yes → Step 3: 回傳 true // 找到符合條件的重複元素，結束程式  \n    No → Step 4: 更新 indexMap[nums[i]] = i // 將索引更新為最新位置，繼續檢查  \n   No  → Step 5: 將 nums[i] 與索引 i 插入 indexMap // 第一次出現，記錄索引  \n→ Step 6: 回傳 false // 迴圈結束仍未找到符合條件的重複元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        index_map = {}\n        for i, num in enumerate(nums):\n            if num in index_map and i - index_map[num] <= k:\n                return True\n            index_map[num] = i\n        return False\n\ndef parse_input(data: str):\n    \"\"\"Parse input like 'nums = [1,2,3,1], k = 3'.\"\"\"\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    nums_str, k_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    nums, k = parse_input(raw_input)\n    sol = Solution()\n    result = sol.containsNearbyDuplicate(nums, k)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1], k = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode135.json",
    "problem_index_in_file": 0,
    "title": "Candy",
    "description_snippet": "There are n children standing in a line. Each child is assigned a rating value given in the integer ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanation. Problem: candy distribution. Classic solution: two-pass or monotonic stack. Provide pseudo steps: input array, initialize candies array with 1, first pass left to right, if rating[i] > rating[i-1] set candies[i] = candies[i-1]+1, second pass right to left, if rating[i] > rating[i+1] set candies[i] = max(candies[i], candies[i+1]+1). Sum candies.\n\nLet's generate step-by-step.\n\nNeed Start and End. Use Decision arrows for decisions. Provide each line.\n\nWe need to follow formatting: each line \"虛擬碼步驟 // 解釋\". Use \"→\" arrow. Use Decision: etc. Provide indentation.\n\nLet's create.\n\nStart\n\n→ Input ratings // Get array of ratings\n\n→ Initialize n = length(ratings) // number of children\n\n→ Initialize candies array of size n with all 1 // each child gets at least one candy\n\n→ Decision: n <= 1? // If only one child\n\n    Yes → Step 1: Return candies[0] // return 1\n\n    No → Proceed to first pass\n\n→ Step 1: For i from 1 to n-1 // left to right pass\n\n    → Decision: ratings[i] > ratings[i-1]?\n\n        Yes → candies[i] = candies[i-1] + 1 // child has higher rating than left neighbor\n\n        No  → candies[i] = candies[i] // keep current (already 1)\n\n→ Step 2: For i from n-2 down to 0 // right to left pass\n\n    → Decision: ratings[i] > ratings[i+1]?\n\n        Yes → candies[i] = max(candies[i], candies[i+1] + 1) // ensure higher rating than right neighbor\n\n        No  → candies[i] = candies[i] // keep current\n\n→ Step 3: total = 0 // initialize sum\n\n→ For i from 0 to n-1\n\n    → total = total + candies[i] // accumulate candies\n\n→ End // Return total\n\nMake sure each line has arrow at start or not? Example in sample: \"→ Step 1:\" They used arrow before step. Use \"→\" each line? In sample, they use \"→ Step 1:\" etc. So we should use \"→\" before each step, but for Decision lines we use \"Decision:\". Let's maintain.\n\nAlso we might need to include the decision lines inside indentation. They used indentation for decisions inside \"Decision:\" block. Provide that.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Input ratings // 讀取孩子評分陣列\n→ Initialize n = length(ratings) // 獲取孩子數量\n→ Initialize candies[n] = 1 // 每個孩子至少得到一顆糖果\n→ Decision: n <= 1? // 僅一個孩子的特殊情況\n    Yes → Return candies[0] // 直接回傳 1\n    No  → Proceed to first pass // 進行兩次掃描\n→ Step 1: For i = 1 to n-1 // 從左至右掃描\n    → Decision: ratings[i] > ratings[i-1]?\n        Yes → candies[i] = candies[i-1] + 1 // 評分更高則糖果比左鄰多\n        No  → // 保持原有糖果數\n→ Step 2: For i = n-2 downto 0 // 從右至左掃描\n    → Decision: ratings[i] > ratings[i+1]?\n        Yes → candies[i] = max(candies[i], candies[i+1] + 1) // 確保比右鄰多\n        No  → // 保持原有糖果數\n→ Step 3: total = 0 // 初始化總糖果計數\n→ For i = 0 to n-1\n    → total = total + candies[i] // 累加各孩子糖果\n→ End // 回傳最小所需糖果總數\n\nBut we need to include \"Return total\" at end. Add step.\n\n→ Return total // 回傳最小總糖果數\n\nPlace End after that? Sample has End after returning? They have End at the end. So we can add Return total then End.\n\nLet's craft final output.\n\nAlso ensure each line starts with \"→\" except Start? In sample, Start without arrow. End without arrow. Decision lines start with \"Decision:\" without arrow. Steps have arrow. So maintain that.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input ratings // 讀取孩子評分陣列  \n→ Initialize n = length(ratings) // 獲取孩子數量  \n→ Initialize candies[n] = 1 // 每個孩子至少得到一顆糖果  \n→ Decision: n <= 1? // 僅一個孩子的特殊情況  \n    Yes → Return candies[0] // 直接回傳 1  \n    No  → // 進行兩次掃描  \n→ Step 1: For i = 1 to n-1 // 從左至右掃描  \n    → Decision: ratings[i] > ratings[i-1]?  \n        Yes → candies[i] = candies[i-1] + 1 // 評分更高則糖果比左鄰多  \n        No  → // 保持原有糖果數  \n→ Step 2: For i = n-2 downto 0 // 從右至左掃描  \n    → Decision: ratings[i] > ratings[i+1]?  \n        Yes → candies[i] = max(candies[i], candies[i+1] + 1) // 確保比右鄰多  \n        No  → // 保持原有糖果數  \n→ Step 3: total = 0 // 初始化總糖果計數  \n→ For i = 0 to n-1  \n    → total = total + candies[i] // 累加各孩子糖果  \n→ Return total // 回傳最小總糖果數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        if n == 0:\n            return 0\n        candies = [1] * n\n\n        # Left to right pass\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Right to left pass\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)\n\ndef parse_ratings(input_str: str) -> List[int]:\n    \"\"\"\n    把輸入字串轉成 ratings 列表。\n    支援「ratings = [1, 0, 2]」或直接「[1, 0, 2]」等格式。\n    \"\"\"\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        return []\n    try:\n        return ast.literal_eval(input_str[start:end + 1])\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    ratings = parse_ratings(raw_input)\n    solution = Solution()\n    print(solution.candy(ratings))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ratings = [1,0,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "ratings = [1,2,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode127.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Problem: Word Ladder length. We need BFS. Steps: load list, check endWord, create adjacency. BFS. Use queue. Count levels. Return 0 if none. We output virtual code lines: Start, steps. Use arrow.\n\nMake each step line: \"→ Step X: ...\" with explanation. Use Decision. No code.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 beginWord、endWord 與 wordList // 取得輸入資料  \n→ Step 2: 檢查 endWord 是否存在於 wordList // 若不存在，直接回傳 0  \n    No  → End // 結束程式，無合法序列  \n→ Decision: 轉換字典為 Set<string> words // 方便 O(1) 查詢  \n    Yes → Step 3: 初始化 queue 並加入 (beginWord, 1) // 第一層長度為 1  \n→ Step 4: 建立 visited Set<string> 並加入 beginWord // 避免重複處理  \n→ Decision: queue 是否為空?  \n    Yes → End // 若無剩餘字，回傳 0  \n    No  → Step 5: 取出 (current, level) 從 queue 前端 // 開始 BFS  \n→ Step 6: 若 current 等於 endWord → Return level // 找到最短序列長度  \n→ Step 7: 對於每個字母位置 i 從 0 到 len-1  \n→ Step 8: 對於每個字母 c 從 'a' 到 'z'  \n→ Step 9: 生成 newWord 替換位置 i 為 c // 檢查是否為合法鄰居  \n→ Decision: newWord 是否在 words 且未被 visited?  \n    Yes → Step 10: 加入 newWord 至 visited  \n    Yes → Step 11: queue 入列 (newWord, level + 1) // 下一層  \n→ Decision: 完成所有 i、c 後 → 回到 Step 5 // 進一步 BFS  \n→ End // 若 queue 先後空，回傳 0，表示無可行序列",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (current_word, current_length)\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        wordSet.remove(new_word)          # mark visited\n                        queue.append((new_word, length + 1))\n        return 0\n\ndef parse_input(data: str):\n    \"\"\"Parse input like:\n       beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\"]\n    \"\"\"\n    begin = re.search(r'beginWord\\s*=\\s*\"([^\"]+)\"', data)\n    end = re.search(r'endWord\\s*=\\s*\"([^\"]+)\"', data)\n    wl = re.search(r'wordList\\s*=\\s*(\\[[^\\]]*\\])', data)\n\n    if not (begin and end and wl):\n        raise ValueError(\"Invalid input format\")\n\n    beginWord = begin.group(1)\n    endWord = end.group(1)\n    wordList = ast.literal_eval(wl.group(1))\n    return beginWord, endWord, wordList\n\ndef main():\n    raw = sys.stdin.read()\n    beginWord, endWord, wordList = parse_input(raw)\n    result = Solution().ladderLength(beginWord, endWord, wordList)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode76.json",
    "problem_index_in_file": 0,
    "title": "Minimum Window Substring",
    "description_snippet": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for minimum window substring algorithm, step-by-step. We must use Start, End, Decision, etc. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrow lines. Provide typical sliding window with hashmap counts. Since unique answer, no tie-breaking. We should generate virtual code that includes input, building frequency map for t, sliding window pointers left/right, maintain formed count. Implementation typical. Provide explanation. Ensure no actual code, just pseudocode lines.\n\nWe need to start with Start. Then steps: Initialize required freq map. Initialize left=0, right=0. required=unique chars. formed=0. windowCounts. best window size and indices. Then loop while right < m: add char at right, update windowCounts, if matches required freq, formed++. Then while left <= right and formed==required: update best if smaller, try to shrink by moving left, decrement counts, if below required, formed--. Then right++. After loop, if best length is INF return \"\", else return substring from best indices. End.\n\nNeed to include decisions. Use \"Decision:\" lines for formed==required and while loops. Also Decision for best window found. Ensure each line has \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\nWe'll use \"→\" arrow for flow. Each step with indentation maybe. Provide decision indenting. Must ensure each line ends with // 解釋.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 needCounts，計算 t 中每個字符的需求頻率 // 準備目標頻率表  \n→ Step 2: 計算 required = needCounts 的鍵數量 // 知道需要匹配的不同字符數  \n→ Step 3: 初始化滑動窗口指標 left = 0, right = 0 // 左右游標起點  \n→ Step 4: 初始化變數 formed = 0, windowCounts = 空字典 // 追蹤已滿足條件的字符數量  \n→ Step 5: 初始化 bestLen = ∞, bestStart = 0, bestEnd = 0 // 儲存最佳子串資訊  \n\n→ Decision: 是否有更多字符可以擴右邊界? // 迴圈條件  \n    Yes → Step 6: let char = s[right] // 取右邊界字符  \n    → Step 7: windowCounts[char] = windowCounts.get(char, 0) + 1 // 更新窗口頻率  \n    → Decision: 這個字符是否已滿足需求頻率? // 檢查是否與 needCounts 相符  \n        Yes → Step 8: if windowCounts[char] == needCounts[char] then formed = formed + 1 // 追蹤已滿足的字符類型  \n    → Step 9: right = right + 1 // 右指標往右擴  \n    → Decision: 形成的字符類型數是否等於 required? // 判斷是否可以收縮窗口  \n        Yes → Step 10: while left < right and formed == required: // 收縮窗口\n                → Step 11: let startChar = s[left] // 取左邊界字符  \n                → Decision: 這個字符是否是多餘的? // 若超過需求可移除  \n                    Yes → Step 12: windowCounts[startChar] = windowCounts.get(startChar, 0) - 1 // 減少頻率  \n                    → Decision: 減少後是否低於需求?  \n                        Yes → Step 13: if windowCounts[startChar] < needCounts.get(startChar, 0) then formed = formed - 1 // 失去一類型匹配  \n                → Decision: 當前窗口長度是否小於 bestLen?  \n                    Yes → Step 14: bestLen = right - left // 更新最佳長度  \n                    → Step 15: bestStart = left  \n                    → Step 16: bestEnd = right // 記錄最佳範圍  \n                → Step 17: left = left + 1 // 左指標往右收縮  \n        No  → Step 18: // 右指標繼續擴張  \n→ Decision: 是否完成整個字串掃描? // 結束條件  \n    No → 回到 Decision: 是否有更多字符可以擴右邊界?  \n    Yes → Step 19: Decision: 是否找到有效窗口? // 判斷最佳長度是否被更新  \n        Yes → Step 20: return s.substring(bestStart, bestEnd) // 回傳最小有效子串  \n        No  → Step 21: return \"\" // 無有效窗口，返回空字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\ndef min_window(s: str, t: str) -> str:\n    if not s or not t:\n        return \"\"\n    dict_t = Counter(t)\n    required = len(dict_t)\n    l = r = 0\n    formed = 0\n    window_counts = {}\n    ans = (float(\"inf\"), None, None)\n\n    while r < len(s):\n        character = s[r]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n\n        while l <= r and formed == required:\n            character = s[l]\n            if r - l + 1 < ans[0]:\n                ans = (r - l + 1, l, r)\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n            l += 1\n\n        r += 1\n\n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2] + 1]\n\ndef parse_input(text: str):\n    import re\n    parts = re.findall(r'\"([^\"]*)\"', text)\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    tokens = text.strip().split()\n    if len(tokens) >= 2:\n        return tokens[0], tokens[1]\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s, t = parse_input(data)\n    result = min_window(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
          "expected_output": "\"BANC\"",
          "success": true,
          "output": "BANC"
        },
        {
          "example_index": 1,
          "input": "s = \"a\", t = \"a\"",
          "expected_output": "\"a\"",
          "success": true,
          "output": "a"
        },
        {
          "example_index": 2,
          "input": "s = \"a\", t = \"aa\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode420.json",
    "problem_index_in_file": 0,
    "title": "Strong Password Checker",
    "description_snippet": "A password is considered strong if the below conditions are all met:\n\nIt has at least 6 characters a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines describing algorithm to compute minimum steps to make password strong.\n\nWe need to include virtual code lines with explanation after each. Use Start, Decision, etc. We'll produce algorithm:\n\n1. Count length n\n2. Determine missing types: missing_lower, missing_upper, missing_digit\n3. Find repeats: sequences of same char length>=3. For each, store len, compute replace_needed = len//3\n4. If n < 6: need insert steps = 6-n. We also need to cover missing types and repeats. We can treat insert as satisfying missing types or reduce repeats. Use max(missing_types, replace_needed, inserts) but careful with repeats. Actually we can do: steps = max(missing_types, replace_needed, 6-n)\n5. If 6 <= n <= 20: steps = max(missing_types, replace_needed)\n6. If n > 20: deletions_needed = n-20. We can reduce repeats by deletions. Greedy: first delete from sequences where len%3==0 (deleting one reduces one replace). Then len%3==1 etc. After deletion, compute remaining replace_needed. steps = deletions_needed + max(missing_types, replace_needed)\nReturn steps.\n\nWe need to output virtual code lines reflecting this logic.\n\nWe must not output actual code, only virtual pseudocode with arrows and explanation.\n\nLet's craft lines.\n\nWe may use Start, Step numbers, Decision, loops etc.\n\nMake sure each line ends with `// ...` explanation.\n\nLet's produce step-by-step:\n\nStart\n→ Step 1: 計算密碼長度 n\n→ Step 2: 初始化 missingLower, missingUpper, missingDigit 為 0\n→ Decision: 是否存在小寫字母? \n   Yes → 設置 missingLower = 1 // 需要至少一個小寫\n   No → // 無需變更\nSimilarly for uppercase, digit. We can combine but maybe separate.\n\n→ Step 3: 建立重複字元序列列表 repeats\n→ For each character in password\n   → If 連續相同字元個數 >=3\n        → 將序列長度加入 repeats\n        → 計算 replaceNeeded += 序列長度 // 3\n        → // 用於後續替換\n\n→ Step 4: 計算 missingTypes = missingLower + missingUpper + missingDigit\n\n→ Decision: n < 6 ?\n   Yes → Step 5: 需要插入 count = 6 - n\n       → Step 6: steps = max(missingTypes, replaceNeeded, count)\n   No → Decision: n <= 20 ?\n      Yes → Step 7: steps = max(missingTypes, replaceNeeded)\n      No → Step 8: deletionsNeeded = n - 20\n           → Step 9: // 先用刪除降低 replaceNeeded\n                → 先對 repeats 進行優先級排序: len%3==0, len%3==1, others\n                → 針對每個序列，刪除 until deletionsNeeded==0 或序列長度<3\n                → 更新 replaceNeeded\n           → Step 10: steps = deletionsNeeded + max(missingTypes, replaceNeeded)\n\nEnd.\n\nWe need to incorporate loops and decisions as virtual code. Provide explanation each line.\n\nWe must maintain one line per virtual code step.\n\nLet's produce more precise lines.\n\nWe'll use:\n\nStart\n→ Step 1: n ← length(password) // 取得密碼長度\n→ Step 2: missingLower ← 0; missingUpper ← 0; missingDigit ← 0 // 初始化缺失類型\n→ Decision: 內含小寫字母? \n   Yes → missingLower ← 1 // 至少一個小寫\n   No  → // 無需改動\n→ Decision: 內含大寫字母? \n   Yes → missingUpper ← 1\n   No  → \n→ Decision: 內含數字? \n   Yes → missingDigit ← 1\n   No  → \n→ Step 3: repeats ← empty list // 儲存重複序列長度\n→ Step 4: i ← 0 // 迭代索引\n→ Decision: i < n ?\n   Yes → Step 5: j ← i+1\n          → Decision: j < n AND password[j]==password[i] ?\n              Yes → j ← j+1\n              No  → // 找到一個序列\n          → Step 6: seqLen ← j - i\n          → Decision: seqLen >= 3 ?\n              Yes → repeats.append(seqLen); replaceNeeded ← replaceNeeded + seqLen // 3\n              No  → // 不足三個不計算\n          → i ← j\n          → // 迴圈重複\n   No  → // 迴圈結束\n\n→ Step 7: missingTypes ← missingLower + missingUpper + missingDigit // 需要的類型數\n\n→ Decision: n < 6 ?\n   Yes → Step 8: insertsNeeded ← 6 - n\n          → Step 9: steps ← max(missingTypes, replaceNeeded, insertsNeeded)\n   No → Decision: n <= 20 ?\n      Yes → Step 10: steps ← max(missingTypes, replaceNeeded)\n      No  → Step 11: deletionsNeeded ← n - 20\n            → // 用刪除優先消減替換需求\n            → Step 12: // 先針對 seqLen % 3 == 0 的序列刪除一個字符\n            → Step 13: // 接著 seqLen % 3 == 1 的序列刪除兩個字符\n            → Step 14: // 其餘序列刪除三個字符\n            → Step 15: // 在刪除過程中更新 replaceNeeded\n            → Step 16: steps ← deletionsNeeded + max(missingTypes, replaceNeeded)\n\nEnd\n\nBut we need each line as single line with virtual code and explanation.\n\nWe need to include Decision lines with indent. The example uses indentation inside Decision block with tabs? They used spaces.\n\nWe must ensure each line includes arrow symbol? They used `→` arrow before each step. For Decision block they used `Decision:` then indent lines with Yes → etc. We'll mimic that.\n\nSo each line must start with `→` for step, but Decision block may start with `Decision:`. For Yes / No, we use `Yes →` or `No →`. For loops, we can use `While` or `For`. Provide explanation after `//`.\n\nWe need to avoid actual code.\n\nLet's craft final output:\n\n```\nStart // 程式開始執行\n→ Step 1: n ← length(password) // 取得密碼長度\n→ Step 2: missingLower ← 0; missingUpper ← 0; missingDigit ← 0 // 初始化缺失類型計數\nDecision: 密碼中是否存在小寫字母? // 檢查小寫字母\n    Yes → missingLower ← 1 // 需要至少一個小寫字母\n    No  → // 沒有小寫字母，保持 0\nDecision: 密碼中是否存在大寫字母? // 檢查大寫字母\n    Yes → missingUpper ← 1 // 需要至少一個大寫字母\n    No  → // 沒有大寫字母，保持 0\nDecision: 密碼中是否存在數字? // 檢查數字\n    Yes → missingDigit ← 1 // 需要至少一個數字\n    No  → // 沒有數字，保持 0\n→ Step 3: repeats ← empty list // 用於儲存重複字元序列長度\n→ Step 4: i ← 0 // 索引初始化\nDecision: i < n? // 循環遍歷字串\n    Yes → Step 5: j ← i + 1 // 第二個索引開始\n        Decision: j < n AND password[j] == password[i]? // 判斷是否同一字元\n            Yes → j ← j + 1 // 繼續延伸序列\n            No  → // 序列結束\n        Step 6: seqLen ← j - i // 計算序列長度\n        Decision: seqLen ≥ 3? // 判斷是否為重複序列\n            Yes → repeats.append(seqLen); replaceNeeded ← replaceNeeded + seqLen // 3 // 記錄序列並計算需替換數\n            No  → // 序列太短，忽略\n        Step 7: i ← j // 移至下一個位置\n        // 回到 Decision: i < n? 循環\n    No  → // 完成所有字符遍歷\n→ Step 8: missingTypes ← missingLower + missingUpper + missingDigit // 總缺失類型數\nDecision: n < 6? // 密碼太短\n    Yes → Step 9: insertsNeeded ← 6 - n // 需要插入字符數\n        Step 10: steps ← max(missingTypes, replaceNeeded, insertsNeeded) // 取最大步數\n    No → Decision: n ≤ 20? // 密碼長度在允許範圍\n        Yes → Step 11: steps ← max(missingTypes, replaceNeeded) // 取最大步數\n        No  → Step 12: deletionsNeeded ← n - 20 // 需要刪除字符數\n            // 先用刪除降低替換需求，按序列長度 % 3 先後順序\n            → Step 13: // 對每個 seqLen%3==0 的序列刪除 1 個字符，更新 replaceNeeded\n            → Step 14: // 對每個 seqLen%3==1 的序列刪除 2 個字符，更新 replaceNeeded\n            → Step 15: // 對其餘序列刪除 3 個字符，更新 replaceNeeded\n            → Step 16: steps ← deletionsNeeded + max(missingTypes, replaceNeeded) // 最終步數\nEnd // 程式執行結束\n```\n\nWe need to ensure each line has the arrow `→` or `Decision:` or `Yes →` etc. Also explanation after `//`. Provide each line.\n\nLet's refine to meet formatting. Ensure there is a space after `→` before code. For Decision block, start with `Decision:` but indentation? The example uses tabs or spaces. We'll just indent with two spaces for inner lines.\n\nMake sure to avoid actual code syntax like `missingLower ← 1` etc. But it's okay.\n\nWe need to provide \"逐行\" output. We must not include any other text.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(password) // 取得密碼長度  \n→ Step 2: missingLower ← 0; missingUpper ← 0; missingDigit ← 0 // 初始化缺失類型計數  \nDecision: 密碼中是否存在小寫字母? // 檢查小寫字母  \n  Yes → missingLower ← 1 // 需要至少一個小寫字母  \n  No  → // 沒有小寫字母，保持 0  \nDecision: 密碼中是否存在大寫字母? // 檢查大寫字母  \n  Yes → missingUpper ← 1 // 需要至少一個大寫字母  \n  No  → // 沒有大寫字母，保持 0  \nDecision: 密碼中是否存在數字? // 檢查數字  \n  Yes → missingDigit ← 1 // 需要至少一個數字  \n  No  → // 沒有數字，保持 0  \n→ Step 3: repeats ← empty list // 用於儲存重複字元序列長度  \n→ Step 4: i ← 0 // 索引初始化  \nDecision: i < n? // 循環遍歷字串  \n  Yes → Step 5: j ← i + 1 // 第二個索引開始  \n    Decision: j < n AND password[j] == password[i]? // 判斷是否同一字元  \n      Yes → j ← j + 1 // 繼續延伸序列  \n      No  → // 序列結束  \n    Step 6: seqLen ← j - i // 計算序列長度  \n    Decision: seqLen ≥ 3? // 判斷是否為重複序列  \n      Yes → repeats.append(seqLen); replaceNeeded ← replaceNeeded + seqLen // 3 // 記錄序列並計算需替換數  \n      No  → // 序列太短，忽略  \n    Step 7: i ← j // 移至下一個位置  \n    // 回到 Decision: i < n? 循環  \n  No  → // 完成所有字符遍歷  \n→ Step 8: missingTypes ← missingLower + missingUpper + missingDigit // 總缺失類型數  \nDecision: n < 6? // 密碼太短  \n  Yes → Step 9: insertsNeeded ← 6 - n // 需要插入字符數  \n    Step 10: steps ← max(missingTypes, replaceNeeded, insertsNeeded) // 取最大步數  \n  No → Decision: n ≤ 20? // 密碼長度在允許範圍  \n    Yes → Step 11: steps ← max(missingTypes, replaceNeeded) // 取最大步數  \n    No  → Step 12: deletionsNeeded ← n - 20 // 需要刪除字符數  \n      // 先用刪除降低替換需求，按序列長度 % 3 先後順序  \n      → Step 13: // 對每個 seqLen%3==0 的序列刪除 1 個字符，更新 replaceNeeded  \n      → Step 14: // 對每個 seqLen%3==1 的序列刪除 2 個字符，更新 replaceNeeded  \n      → Step 15: // 對其餘序列刪除 3 個字符，更新 replaceNeeded  \n      → Step 16: steps ← deletionsNeeded + max(missingTypes, replaceNeeded) // 最終步數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strongPasswordChecker(self, s: str) -> int:\n        n = len(s)\n\n        # Determine missing character types\n        has_lower = has_upper = has_digit = 0\n        for c in s:\n            if c.islower():\n                has_lower = 1\n            elif c.isupper():\n                has_upper = 1\n            elif c.isdigit():\n                has_digit = 1\n        missing_types = 3 - (has_lower + has_upper + has_digit)\n\n        # Find repeating sequences\n        replace = 0          # total replacements needed for repeats\n        one_mod = two_mod = 0  # counts of sequences where len % 3 == 0 or 1\n        i = 0\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            length = j - i\n            if length >= 3:\n                replace += length // 3\n                if length % 3 == 0:\n                    one_mod += 1\n                elif length % 3 == 1:\n                    two_mod += 1\n            i = j\n\n        if n < 6:\n            return max(6 - n, missing_types)\n        elif n <= 20:\n            return max(replace, missing_types)\n        else:\n            delete = n - 20\n            original_delete = delete\n\n            # Reduce replacements by deleting from sequences where len % 3 == 0\n            reduce = min(delete, one_mod)\n            replace -= reduce\n            delete -= reduce\n\n            # Reduce replacements by deleting from sequences where len % 3 == 1\n            reduce = min(delete // 2, two_mod)\n            replace -= reduce\n            delete -= reduce * 2\n\n            # Remaining deletions reduce replacements by delete//3\n            replace -= delete // 3\n\n            return original_delete + max(missing_types, replace)\n\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract the password string inside quotes\n    match = re.search(r'\"(.*?)\"', data, re.DOTALL)\n    if match:\n        password = match.group(1)\n    else:\n        password = data.strip()\n\n    solver = Solution()\n    result = solver.strongPasswordChecker(password)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "password = \"a\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "password = \"aA1\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "password = \"1337C0d3\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode643.json",
    "problem_index_in_file": 0,
    "title": "Maximum Average Subarray I",
    "description_snippet": "You are given an integer array nums consisting of n elements, and an integer k.\n\nFind a contiguous s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem. So algorithm: sliding window of length k to compute sum, maintain max sum, divide by k. Steps: input array, input k, initialize sum of first k, maxSum = sum, iterate i from k to n-1: sum += nums[i] - nums[i-k], if sum>maxSum update. After loop compute maxSum / k as average. Return. Complexity O(n). Use virtual steps.\n\nWe must produce each line: Virtual code step + comment.\n\nNeed to use Start, End, Decision, arrows. Provide steps. Provide each line as described. We'll produce a linear flow: Start, Input, Compute initial sum, Set maxSum, for loop decision: i < n? Yes: update sum, check > max? etc. At loop end compute average, output. End.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Input: nums, k // 取得輸入陣列與窗口長度\n→ Decision: nums長度 < k? // 檢查是否足夠長\n    Yes → Output: 0 // 若不足，直接返回 0（或可拋出錯誤）\n    No  → Step 1: sum ← 0 // 初始化滑動窗口總和\n→ Step 2: 對於 i = 0 到 k-1: sum ← sum + nums[i] // 計算前 k 個元素之和\n→ Step 3: maxSum ← sum // 設定初始最大和\n→ Decision: i = k 到 nums.length-1? // 開始滑動窗口\n    Yes → Step 4: sum ← sum + nums[i] - nums[i-k] // 加入新元素並移除舊元素\n    Yes → Decision: sum > maxSum? // 檢查是否更新最大和\n        Yes → maxSum ← sum // 更新最大和\n        No  → // 不更新\n    No  → // 迴圈結束\n→ Step 5: maxAvg ← maxSum / k // 計算最大平均值\n→ Output: maxAvg // 回傳結果\nEnd // 程式執行結束\n\nBut need to format properly: each line as \"虛擬碼步驟 // 解釋\". Use arrows. For loops, we can show decision. For loop: Decision: i < n? Yes: step; No: End of loop. But to keep simple, we can show decision for loop start and inside. Let's produce:\n\nStart // 程式開始執行\n→ Input: nums, k // 取得輸入陣列與窗口長度\n→ Decision: nums.length < k? // 檢查陣列是否足夠長\n    Yes → Output: 0 // 如果不足，直接回傳 0\n    No  → Step 1: sum ← 0 // 初始化滑動窗口總和\n→ Step 2: for i = 0 to k-1: sum ← sum + nums[i] // 計算前 k 個元素之和\n→ Step 3: maxSum ← sum // 設定初始最大和\n→ Decision: i = k to nums.length-1? // 檢查是否還有元素可滑動\n    Yes → Step 4: sum ← sum + nums[i] - nums[i-k] // 更新滑動窗口總和\n    Yes → Decision: sum > maxSum? // 判斷是否更新最大和\n        Yes → maxSum ← sum // 更新最大和\n        No  → // 不更新\n    No  → // 迴圈結束\n→ Step 5: maxAvg ← maxSum / k // 計算最大平均值\n→ Output: maxAvg // 回傳結果\nEnd // 程式執行結束\n\nBut we need to ensure \"→\" used before each step. For Decision lines, we need to indent Yes and No branches.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums, k // 取得輸入陣列與窗口長度  \n→ Decision: nums.length < k? // 檢查陣列是否足夠長  \n  Yes → Output: 0 // 若不足，直接回傳 0（可視需求調整）  \n  No  → Step 1: sum ← 0 // 初始化滑動窗口總和  \n→ Step 2: for i = 0 to k-1: sum ← sum + nums[i] // 計算前 k 個元素之和  \n→ Step 3: maxSum ← sum // 設定初始最大和  \n→ Decision: i = k to nums.length-1? // 判斷是否還有元素可滑動  \n  Yes → Step 4: sum ← sum + nums[i] - nums[i-k] // 加入新元素並移除最舊元素  \n  Yes → Decision: sum > maxSum? // 檢查是否更新最大和  \n    Yes → maxSum ← sum // 更新最大和  \n    No  → // 不更新  \n  No  → // 迴圈結束  \n→ Step 5: maxAvg ← maxSum / k // 計算最大平均值  \n→ Output: maxAvg // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef find_max_average(nums, k):\n    if k == 0 or len(nums) < k:\n        return 0.0\n    window_sum = sum(nums[:k])\n    max_sum = window_sum\n    for i in range(k, len(nums)):\n        window_sum += nums[i] - nums[i - k]\n        if window_sum > max_sum:\n            max_sum = window_sum\n    return max_sum / k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list of numbers\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if list_match:\n        list_str = list_match.group(1)\n        nums = [int(x.strip()) for x in list_str.split(',') if x.strip()]\n    else:\n        nums = []\n\n    # Extract k\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    k = int(k_match.group(1)) if k_match else 0\n\n    avg = find_max_average(nums, k)\n    print(f\"{avg:.5f}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,12,-5,-6,50,3], k = 4",
          "expected_output": "12.75000",
          "success": true,
          "output": "12.75000"
        },
        {
          "example_index": 1,
          "input": "nums = [5], k = 1",
          "expected_output": "5.00000",
          "success": true,
          "output": "5.00000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode258.json",
    "problem_index_in_file": 0,
    "title": "Add Digits",
    "description_snippet": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in Chinese, step by step with explanation. Use Start, Decision, etc. Use arrow arrows. Ensure each line has virtual code step + space + // explanation. We need to show algorithm: sum digits until single digit. Use loop, maybe while len >1.\n\nWe must not output actual code. Provide structure. Let's write:\n\nStart // 開始\n→ Step 1: 設定 result = num // 初始結果為輸入數字\n→ Decision: 如果 result 為單一數位? // 判斷是否已經只有一位\n    Yes → Step 2: 返回 result // 回傳單一位數\n    No  → Step 3: 計算 result 的所有位數之和 // 重新求和\n        → Step 4: 設定 result = sum // 更新結果\n        → Jump to Decision // 重新檢查\n\nEnd // 結束\n\nNeed to include arrow lines. Use arrow for loop? Use decision arrow.\n\nAlso need to show while loop concept. Use Step 3 as a block. The \"→ Step 3:\" line should lead to the sum calculation. But we can embed.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 result = num // 將輸入整數賦值給 result  \n→ Decision: result 是否只有一位數? // 判斷 result 是否已經是單一數位  \n Yes → Step 2: 返回 result // 若是單一數位，直接回傳  \n No → Step 3: 計算 result 的所有位數之和 // 將 result 的每一位相加  \n  → Step 4: 設定 result = sum // 更新 result 為新的數字總和  \n  → Jump to Decision // 重新檢查 result 是否已為單一數位  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        \"\"\"\n        Repeatedly sum the digits of num until it becomes a single digit.\n        \"\"\"\n        while num >= 10:\n            num = sum(int(d) for d in str(num))\n        return num\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，尋找第一個出現的整數\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if match:\n        num = int(match.group())\n    else:\n        num = 0  # 若找不到數字，預設為 0\n\n    # 計算結果並輸出\n    result = Solution().addDigits(num)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 38",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode696.json",
    "problem_index_in_file": 0,
    "title": "Count Binary Substrings",
    "description_snippet": "Given a binary string s, return the number of non-empty substrings that have the same number of 0's ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for problem: count substrings with equal number of consecutive zeros and ones, grouped consecutively. Known solution: count consecutive runs of 0s and 1s, then answer sum over min(count[i], count[i+1]) for each adjacent group. So pseudocode: Start, Step 1: iterate string, group counts. Step 2: sum min of consecutive counts. Step 3: return result. We'll produce lines with arrow. Provide explanation.\n\nWe must avoid actual code, just pseudocode. Use arrows. Provide each line with explanation. Should include Start, End. Use Decision if needed. Let's craft:\n\nStart\n→ Step 1: 初始化空列表 groups，prev = s[0]，cnt = 0 // 讀取字串並建立相鄰相同字符群組\n→ Step 2: 對每個字符 ch in s 往後遍歷\n   → Decision: 如果 ch 等於 prev?\n      Yes → cnt += 1 // 同一組，累計計數\n      No  → Step 3: 將 cnt 加入 groups，cnt = 1，prev = ch // 結束一組，開始新組\n→ Step 4: 後續將最後 cnt 加入 groups // 處理最後一組\n→ Step 5: 初始化 result = 0\n→ Step 6: 對 i in 0 .. groups.length-2\n   → Decision: 是否需要計算? // 只要相鄰兩組\n      Yes → result += min(groups[i], groups[i+1]) // 將兩組最小值加入結果\n→ Step 7: 返回 result\nEnd\n\nWe need to adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrow. Eg \"Start // 程式開始執行\". For steps with decision, we need indent lines with Yes → etc. Use same style as example.\n\nMake sure each line has a single step. Indentation indicated by spaces? Use indentation for nested steps.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 groups，prev = s[0]，cnt = 0 // 讀取字串並準備分組  \n→ Step 2: 對每個字符 ch 往後遍歷  \n  Decision: 如果 ch 等於 prev?  \n   Yes → cnt += 1 // 同一組，累計計數  \n   No  → Step 3: 將 cnt 加入 groups，cnt = 1，prev = ch // 結束前一組，開始新組  \n→ Step 4: 將最後 cnt 加入 groups // 處理最後一組  \n→ Step 5: 初始化 result = 0 // 用於累計答案  \n→ Step 6: 對 i 從 0 到 groups.length-2  \n  Decision: 需要計算?  \n   Yes → result += min(groups[i], groups[i+1]) // 相鄰兩組最小值即符合條件的子字串數量  \n→ Step 7: 返回 result // 回傳最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        \"\"\"Count substrings with equal number of consecutive 0's and 1's.\"\"\"\n        groups = []          # store lengths of consecutive runs\n        count = 1            # at least one character in the string\n\n        # Build the list of consecutive run lengths\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                count += 1\n            else:\n                groups.append(count)\n                count = 1\n        groups.append(count)  # last run\n\n        # For each adjacent pair of runs, the number of valid substrings is\n        # the minimum of the two run lengths.\n        result = 0\n        for i in range(1, len(groups)):\n            result += min(groups[i], groups[i - 1])\n        return result\n\ndef parse_input(data: str) -> str:\n    \"\"\"Extract the binary string from the raw input.\"\"\"\n    # If the input contains quotes, extract the part between the first pair.\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != start:\n        return data[start + 1:end]\n    # Fallback: strip spaces and any surrounding characters\n    return data.strip()\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    binary_string = parse_input(raw_data)\n    solution = Solution()\n    print(solution.countBinarySubstrings(binary_string))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"00110011\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "s = \"10101\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode205.json",
    "problem_index_in_file": 0,
    "title": "Isomorphic Strings",
    "description_snippet": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for checking if two strings are isomorphic, using pseudocode. Provide line by line with arrow, decision, etc. Each line with explanation.\n\nWe should include Start, End. Use decisions, steps. No actual code. Just virtual code.\n\nWe need to handle mapping from s to t and t to s to ensure bijection. So steps: check lengths, create maps, iterate, check mapping consistency, return true/false. Use virtual arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 s 與 t 的長度是否相等 // 若長度不同即非同構，直接結束  \n→ Decision: 如果長度不相等?  \n  Yes → Step 2: 回傳 false // 兩字串長度不同，無法同構  \n  No → Step 3: 建立空映射 Map_s_to_t, Map_t_to_s // 用於記錄字符對應關係  \n→ Step 4: 循環 i 從 0 到 s.length-1  \n  → Step 5: 取 s[i] 為 char_s, t[i] 為 char_t // 取得目前索引對應的字符  \n  → Decision: 是否已有 char_s 映射至 char_t?  \n    Yes → Step 6: 若 Map_s_to_t[char_s] ≠ char_t? // 檢查映射是否一致  \n      Yes → Step 7: 回傳 false // 映射不一致，非同構  \n      No → Step 8: 繼續下一個字符 // 映射正確，保持進行  \n    No → Step 9: Decision: 是否已存在 char_t 作為另一個 char_s 的映射?  \n      Yes → Step 10: 回傳 false // 另一個字符已映射到相同目標，違反單射  \n      No → Step 11: 設定 Map_s_to_t[char_s] = char_t, Map_t_to_s[char_t] = char_s // 建立新的映射  \n→ Step 12: 迴圈結束 // 所有字符檢查完畢  \n→ Step 13: 回傳 true // 所有條件滿足，兩字串同構  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        \"\"\"判斷兩字串是否同構。\"\"\"\n        if len(s) != len(t):\n            return False\n        mapping_s_t = {}\n        mapping_t_s = {}\n        for c1, c2 in zip(s, t):\n            if c1 in mapping_s_t and mapping_s_t[c1] != c2:\n                return False\n            if c2 in mapping_t_s and mapping_t_s[c2] != c1:\n                return False\n            mapping_s_t[c1] = c2\n            mapping_t_s[c2] = c1\n        return True\n\ndef parse_input(text: str):\n    \"\"\"\n    解析形如：\n        s = \"egg\", t = \"add\"\n    的輸入，回傳 s、t 字串。\n    \"\"\"\n    pattern = r's\\s*=\\s*\"([^\"]+)\"\\s*,\\s*t\\s*=\\s*\"([^\"]+)\"'\n    match = re.search(pattern, text)\n    if match:\n        return match.group(1), match.group(2)\n\n    # 若輸入格式不符合，嘗試從單行拆分\n    parts = text.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    raise ValueError(\"輸入格式不正確\")\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read()\n    s, t = parse_input(raw_input)\n    sol = Solution()\n    result = sol.isIsomorphic(s, t)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"egg\", t = \"add\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"foo\", t = \"bar\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"paper\", t = \"title\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode412.json",
    "problem_index_in_file": 0,
    "title": "Fizz Buzz",
    "description_snippet": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation, line by line. The user gave requirement: FizzBuzz problem. Must produce steps. Each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow, Start, End, Decision. They want virtual code only, no actual code. We produce steps: Start, initialize array, loop from 1 to n, decision chain to determine output, assign string, continue, End. Provide explanations. Each line is separate.\n\nMake sure to include \"→\" for arrow or \"Decision:\" with Yes →, No →. Use 1-indexed. Provide steps: Start // start, → Step 1: Initialize answer array size n, // allocate array. → Step 2: For i = 1 to n // iterate. Within loop: Decision: if i divisible by 3 and 5? Yes → assign \"FizzBuzz\". No → Decision: if i divisible by 3? Yes → assign \"Fizz\". No → Decision: if i divisible by 5? Yes → assign \"Buzz\". No → assign string of i. Then End loop. End // finish. Provide explanation lines accordingly. Use virtual code syntax. Use \"→ Step ...\" etc. Must be careful to keep each line separate. Let's craft.\n\nWe can use \"Start\" then arrow. Eg:\n\nStart // 程式開始執行\n\n→ Step 1: Create array answer of length n // 建立答案陣列\n\n→ Step 2: For i from 1 to n // 逐一處理 1 到 n\n\n→ Decision: i mod 3 == 0 AND i mod 5 == 0? // 判斷是否同時能被 3 和 5 整除\n\n    Yes → Step 3a: answer[i] = \"FizzBuzz\" // 設定為 \"FizzBuzz\"\n\n    No → Decision: i mod 3 == 0? // 判斷是否能被 3 整除\n\n        Yes → Step 3b: answer[i] = \"Fizz\" // 設定為 \"Fizz\"\n\n        No → Decision: i mod 5 == 0? // 判斷是否能被 5 整除\n\n            Yes → Step 3c: answer[i] = \"Buzz\" // 設定為 \"Buzz\"\n\n            No → Step 3d: answer[i] = string(i) // 不是任何條件，設定為數字字串\n\n→ End For // 完成迴圈\n\nEnd // 程式執行結束\n\nAlso note indices: answer[1] corresponds to index 1, but array maybe 0-based; we can mention offset. Provide explanation accordingly.\n\nLet's output accordingly. Ensure each line has \"虛擬碼步驟\" and explanation. Use \"→\" arrow. Provide decisions with Yes → etc. Provide explanation. No actual code.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化答案陣列 answer，長度為 n // 建立一個空的字串陣列來儲存結果  \n→ Step 2: 從 i = 1 到 n 逐一處理 // 迴圈從 1 開始，以符合 1‑indexed 的要求  \n→ Decision: i 能否同時被 3 與 5 整除? // 檢查最嚴格的條件  \n Yes → Step 3a: answer[i] = \"FizzBuzz\" // 同時滿足時填入 \"FizzBuzz\"  \n No → Decision: i 能否被 3 整除? // 檢查是否只符合 3 的條件  \n  Yes → Step 3b: answer[i] = \"Fizz\" // 只滿足 3 的時候填入 \"Fizz\"  \n  No → Decision: i 能否被 5 整除? // 檢查是否只符合 5 的條件  \n   Yes → Step 3c: answer[i] = \"Buzz\" // 只滿足 5 的時候填入 \"Buzz\"  \n   No → Step 3d: answer[i] = string(i) // 都不符合時，將 i 本身轉成字串存入  \n→ End For // 迴圈結束，所有數字已處理完畢  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fizzBuzz(self, n):\n        res = []\n        for i in range(1, n + 1):\n            if i % 15 == 0:\n                res.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                res.append(\"Fizz\")\n            elif i % 5 == 0:\n                res.append(\"Buzz\")\n            else:\n                res.append(str(i))\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    m = re.search(r'\\d+', data)\n    if not m:\n        return\n    n = int(m.group())\n    sol = Solution()\n    ans = sol.fizzBuzz(n)\n    out = '[' + ','.join(f'\"{x}\"' for x in ans) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"1\",\"2\",\"Fizz\"]",
          "success": true,
          "output": "[\"1\",\"2\",\"Fizz\"]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
          "success": true,
          "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
          "success": true,
          "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode150.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Reverse Polish Notation",
    "description_snippet": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polis...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines explaining evaluation of Reverse Polish Notation (RPN). Use Start, End, Decision, etc. We must not output actual code. Just steps. Use arrows. We need to generate algorithm using stack. Use iterative over tokens. For each token: if operator, pop two operands, apply, push result; else push integer. After loop, result on stack top. Return that. Also handle integer conversion, division truncating toward zero.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". So we need to write each step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空堆疊 stack // 用於儲存中間值\n→ For 每個 token in tokens // 遍歷輸入的逆波蘭表達式\n    → Decision: token 是否為運算符? // 判斷目前的 token 是否為 '+', '-', '*', '/' \n        Yes → Step 2: 從 stack 弹出第二個 operand B // 先彈出右邊操作數\n        → Step 3: 再弹出第一個 operand A // 然後彈出左邊操作數\n        → Step 4: 根據 token 執行對應運算: A + B, A - B, A * B, 或 A / B // 執行算術\n        → Step 5: 將運算結果 push 回 stack // 將結果存回堆疊\n        No  → Step 6: 將 token 轉為整數並 push 回 stack // 令字串數字進堆疊\n→ Step 7: 從 stack 弹出最後結果 // 表達式求值完畢\n→ Step 8: 回傳結果 // 返回計算結果\nEnd // 程式執行結束\n\nWe might need to include integer conversion line. Also division truncation toward zero, but that's inherent in integer division. Should mention.\n\nMaybe include line: // Division truncates toward zero.\n\nLet's format properly. Each line: \"虛擬碼步驟 // 解釋\".\n\nAlso we may need to use arrow at start: \"→\". The Decision: block uses Yes →, No →. Also for For loop we might use \"→ For 每個 token in tokens\". Let's use Start, End. Use Decision block properly indent.\n\nOk. Provide final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空堆疊 stack // 用於儲存中間值  \n→ For 每個 token in tokens // 遍歷輸入的逆波蘭表達式  \n → Decision: token 是否為運算符? // 判斷目前的 token 是否為 '+', '-', '*', '/'  \n  Yes → Step 2: 從 stack 弹出第二個 operand B // 先彈出右邊操作數  \n  → Step 3: 再弹出第一個 operand A // 然後彈出左邊操作數  \n  → Step 4: 根據 token 執行對應運算: A + B, A - B, A * B, 或 A / B // 執行算術  \n  → Step 5: 將運算結果 push 回 stack // 將結果存回堆疊  \n  No  → Step 6: 將 token 轉為整數並 push 回 stack // 令字串數字進堆疊  \n→ Step 7: 從 stack 弹出最後結果 // 表達式求值完畢  \n→ Step 8: 回傳結果 // 返回計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                else:  # token == '/'\n                    stack.append(int(a / b))  # truncates toward zero\n            else:\n                stack.append(int(token))\n        return stack[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 支援兩種輸入格式： tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] 或僅輸入 [\"2\",\"1\",\"+\",\"3\",\"*\"]\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = data\n    # 使用安全的 literal_eval 解析字串成列表\n    tokens = ast.literal_eval(rhs)\n    result = Solution().evalRPN(tokens)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "expected_output": "22",
          "success": true,
          "output": "22"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode90.json",
    "problem_index_in_file": 0,
    "title": "Subsets II",
    "description_snippet": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for generating all subsets of an integer array that may contain duplicates, ensuring no duplicate subsets. Typical algorithm: sort array, backtracking with skip duplicates.\n\nWe need to produce steps line by line with arrows and explanation. No actual code. Use Start, End, Decision, etc. Use virtual code style.\n\nLet's produce something like:\n\nStart\n→ Sort nums // 排序以便處理重複\n→ Step 1: 初始化結果列表 subsets ← [ [] ] // 空集\n→ Step 2: 初始化暫存列表 current ← [] // 用於構造子集\n→ Step 3: 定義遞迴函數 backtrack(start)\n    → Decision: 是否已經處理完所有元素? // 如果 start == len(nums)\n        Yes → Step: 將 current 的複製加入 subsets // 將子集加入結果\n        No  → Decision: 處理重複元素? // 跳過重複\n            Yes → Step: 跳過相同元素 // skip duplicates\n            No  → Step: 添加 nums[start] 至 current // 選取當前元素\n            → Call backtrack(start+1)\n            → Step: 移除 nums[start] 從 current // 回溯\n→ Step 4: 呼叫 backtrack(0) // 開始遞迴\nEnd\n\nBut we need to include arrow lines, each step separate.\n\nAlso the output should have each line: \"虛擬碼步驟 // 解釋\". So we need to produce each line like \"Start // 程式開始執行\".\n\nWe need to incorporate Decision structure.\n\nThe user request: \"請根據輸出格式要求產生虛擬碼和逐行解釋\". So produce the virtual code.\n\nWe need to include \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Sort nums // 排序以便處理重複元素\n→ Step 2: subsets ← [ [] ] // 初始化結果，包含空集合\n→ Step 3: current ← [] // 用於存放當前子集\n→ Step 4: Define backtrack(start) // 以 start 作為遞迴起點\n    → Decision: 是否已經遍歷完所有元素? // 判斷遞迴終止條件\n        Yes → Step 5: Append copy of current to subsets // 將完整子集加入結果\n        No  → Step 6: For i from start to len(nums)-1 // 遍歷剩餘元素\n            → Decision: i > start AND nums[i] == nums[i-1]? // 判斷重複元素\n                Yes → Step 7: Continue // 跳過重複的起始索引\n                No  → Step 8: Append nums[i] to current // 選擇此元素\n                → Call backtrack(i+1) // 進一步構造子集\n                → Step 9: Remove last element from current // 回溯\n→ Step 10: Call backtrack(0) // 開始遞迴\nEnd // 程式執行結束\n\nBut ensure each line uses virtual arrow: \"→\" for steps, \"Decision:\" lines have Yes → and No → lines with indentation maybe.\n\nBut we should not use actual code but just pseudo.\n\nBetter to produce structure:\n\nStart // 程式開始執行\n→ Step 1: Sort nums // 對輸入陣列進行排序，方便後續排除重複子集\n→ Step 2: subsets ← [ [] ] // 初始化結果集合，先加入空集\n→ Step 3: current ← [] // 用於構造當前子集的暫存\n→ Step 4: Define backtrack(start) // 定義遞迴函式\n    → Decision: start == len(nums)? // 判斷是否到達結束\n        Yes → Step 5: Append copy of current to subsets // 將子集加入結果\n        No  → Decision: i > start AND nums[i] == nums[i-1]? // 判斷是否跳過重複\n            Yes → Step 6: Continue // 跳過重複索引\n            No  → Step 7: Append nums[i] to current // 加入當前元素\n            → Call backtrack(i+1) // 進一步遞迴\n            → Step 8: Remove last element from current // 回溯\n→ Step 9: Call backtrack(0) // 從索引0開始遞迴\nEnd // 程式執行結束\n\nBut we need to ensure each line is a single line with virtual code step and comment. For nested steps, we still need to separate lines. For Decision blocks we need to include nested lines. We should keep indentation via spaces or maybe we use tab? In sample, they indent with 4 spaces before nested lines? They used:\n\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n\nSo indentation with 4 spaces. We should mimic that.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: Sort nums // 排序輸入陣列以便後續處理重複\n→ Step 2: subsets ← [ [] ] // 初始化結果，包含空集合\n→ Step 3: current ← [] // 用於暫存當前子集\n→ Step 4: Define backtrack(start) // 定義遞迴函式\n    → Decision: start == len(nums)? // 判斷是否已經到達陣列結尾\n        Yes → Step 5: Append copy of current to subsets // 將子集加入結果\n        No  → Decision: i > start AND nums[i] == nums[i-1]? // 判斷是否要跳過重複元素\n            Yes → Step 6: Continue // 跳過此重複元素\n            No  → Step 7: Append nums[i] to current // 加入當前元素\n            → Call backtrack(i+1) // 進一步遞迴\n            → Step 8: Remove last element from current // 回溯\n→ Step 9: Call backtrack(0) // 開始遞迴\nEnd // 程式執行結束\n\nBut the Decision inside for loop needs a loop. Might need to include Step 10: For i from start to len(nums)-1 // 循環遍歷剩餘元素. Then inside Decision. So maybe better to include Step 10 as loop and then Decision.\n\nLet's refine:\n\nStart // 程式開始執行\n→ Step 1: Sort nums // 排序輸入陣列以便後續處理重複\n→ Step 2: subsets ← [ [] ] // 初始化結果，包含空集合\n→ Step 3: current ← [] // 用於暫存當前子集\n→ Step 4: Define backtrack(start) // 定義遞迴函式\n    → Decision: start == len(nums)? // 判斷是否已經到達陣列結尾\n        Yes → Step 5: Append copy of current to subsets // 將子集加入結果\n        No  → Step 6: For i from start to len(nums)-1 // 遍歷剩餘元素\n            → Decision: i > start AND nums[i] == nums[i-1]? // 判斷是否要跳過重複元素\n                Yes → Step 7: Continue // 跳過此重複元素\n                No  → Step 8: Append nums[i] to current // 加入當前元素\n                → Call backtrack(i+1) // 進一步遞迴\n                → Step 9: Remove last element from current // 回溯\n→ Step 10: Call backtrack(0) // 從索引0開始遞迴\nEnd // 程式執行結束\n\nThis structure includes loop.\n\nWe should ensure indentation: Step 6 line inside Decision: No part. Then indent Step 7 and Step 8 inside Decision No branch. Use 4 spaces indentation.\n\nBut we also need to indent \"→ Call backtrack(i+1)\" and \"→ Step 9: Remove last element from current\" inside No branch.\n\nThus final output:\n\n```\nStart // 程式開始執行\n→ Step 1: Sort nums // 排序輸入陣列以便後續處理重複\n→ Step 2: subsets ← [ [] ] // 初始化結果，包含空集合\n→ Step 3: current ← [] // 用於暫存當前子集\n→ Step 4: Define backtrack(start) // 定義遞迴函式\n    → Decision: start == len(nums)? // 判斷是否已經到達陣列結尾\n        Yes → Step 5: Append copy of current to subsets // 將子集加入結果\n        No  → Step 6: For i from start to len(nums)-1 // 遍歷剩餘元素\n            → Decision: i > start AND nums[i] == nums[i-1]? // 判斷是否要跳過重複元素\n                Yes → Step 7: Continue // 跳過此重複元素\n                No  → Step 8: Append nums[i] to current // 加入當前元素\n                → Call backtrack(i+1) // 進一步遞迴\n                → Step 9: Remove last element from current // 回溯\n→ Step 10: Call backtrack(0) // 從索引0開始遞迴\nEnd // 程式執行結束\n```\n\nMake sure each line ends with comment. That seems good.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort nums // 排序輸入陣列以便後續處理重複\n→ Step 2: subsets ← [ [] ] // 初始化結果，包含空集合\n→ Step 3: current ← [] // 用於暫存當前子集\n→ Step 4: Define backtrack(start) // 定義遞迴函式\n    → Decision: start == len(nums)? // 判斷是否已經到達陣列結尾\n        Yes → Step 5: Append copy of current to subsets // 將子集加入結果\n        No  → Step 6: For i from start to len(nums)-1 // 遍歷剩餘元素\n            → Decision: i > start AND nums[i] == nums[i-1]? // 判斷是否要跳過重複元素\n                Yes → Step 7: Continue // 跳過此重複元素\n                No  → Step 8: Append nums[i] to current // 加入當前元素\n                → Call backtrack(i+1) // 進一步遞迴\n                → Step 9: Remove last element from current // 回溯\n→ Step 10: Call backtrack(0) // 從索引0開始遞迴\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        nums.sort()\n        res = []\n\n        def backtrack(start, path):\n            res.append(path.copy())\n            for i in range(start, len(nums)):\n                # 跳過重複元素\n                if i > start and nums[i] == nums[i - 1]:\n                    continue\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 預期輸入格式為 \"nums = [1,2,2]\" 或僅為 \"[1,2,2]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    try:\n        nums = eval(expr, {}, {})\n    except Exception:\n        # 若 eval 失敗，嘗試直接抽取數字\n        import re\n        nums = list(map(int, re.findall(r'-?\\d+', expr)))\n\n    solution = Solution()\n    result = solution.subsetsWithDup(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "success": true,
          "output": "[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode415.json",
    "problem_index_in_file": 0,
    "title": "Add Strings",
    "description_snippet": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines. The requirement: two non-negative integers as strings, sum as string, no BigInteger, no converting to integer directly. So we need to simulate addition digit by digit.\n\nWe produce steps: Start, Input strings, Initialize carry, set i pointing to end of strings, loop while i>=0 or j>=0 or carry. Add digits by converting char to int via subtract '0'. Sum = digit1 + digit2 + carry, new digit = sum % 10, carry = sum /10. Append digit to result (build reversed). After loop reverse or build in correct order. Then output result.\n\nWe need to use pseudocode arrows, Decision. Provide each line. Format: \"虛擬碼步驟 // 解釋\".\n\nLet's produce step by step.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Input num1, num2 // 取得兩個數字字串\n→ Set i = length(num1) - 1 // 指向 num1 最右端\n→ Set j = length(num2) - 1 // 指向 num2 最右端\n→ Set carry = 0 // 初始進位\n→ Set result = empty string // 存放累加結果\n→ Decision: i >= 0 or j >= 0 or carry > 0? // 檢查是否還有位數或進位\n    Yes → Step: digit1 = 0 if i < 0 else int(num1[i]) // 取得 num1 目前位數\n    → Step: digit2 = 0 if j < 0 else int(num2[j]) // 取得 num2 目前位數\n    → Step: sum = digit1 + digit2 + carry // 計算本位總和\n    → Step: result = (sum % 10) appended to front of result // 取個位並加入結果\n    → Step: carry = sum / 10 // 取進位\n    → Step: i = i - 1 // 移到 num1 前一位\n    → Step: j = j - 1 // 移到 num2 前一位\n    → Go back to Decision\n    No → End of loop\n→ End // 程式結束\n\nBut we must provide per line. Also we can include \"Start\" and \"End\". Use arrow notation as required. Let's produce.\n\nWe must include \"Start // ...\", \"→ Step\" etc. Use decision with Yes/No branches. Provide explanation after //.\n\nLet's write each line.\n\nWe should ensure that each line ends with // explanation.\n\nWe must use \"Start\" and \"End\" as separate lines.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input num1, num2 // 取得兩個數字字串  \n→ Set i = length(num1) - 1 // 讓 i 指向 num1 最右端的索引  \n→ Set j = length(num2) - 1 // 讓 j 指向 num2 最右端的索引  \n→ Set carry = 0 // 初始進位值為 0  \n→ Set result = \"\" // 用於累積計算出的每一位數字，最終將是答案  \n→ Decision: i >= 0 or j >= 0 or carry > 0? // 判斷是否還有位數需要處理或進位仍未歸零  \n    Yes → Step: digit1 = 0 if i < 0 else int(num1[i]) // 取得 num1 目前位數，若已越界則為 0  \n    → Step: digit2 = 0 if j < 0 else int(num2[j]) // 取得 num2 目前位數，若已越界則為 0  \n    → Step: sum = digit1 + digit2 + carry // 計算本位總和（包括進位）  \n    → Step: result = str(sum % 10) + result // 取個位數字並放在 result 前面  \n    → Step: carry = sum // 10 // 計算新的進位  \n    → Step: i = i - 1 // 移動到 num1 的上一位  \n    → Step: j = j - 1 // 移動到 num2 的上一位  \n    → Go back to Decision // 回到條件判斷繼續處理下一位  \n    No → End // 所有位數及進位都已處理完畢，結束循環  \nEnd // 程式執行結束，result 為兩數相加的字串結果",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(reversed(res))\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 找出所有非負整數字串\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        # 如果輸入是兩行，每行一個數字\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            nums = [lines[0], lines[1]]\n    if len(nums) < 2:\n        return\n\n    num1, num2 = nums[0], nums[1]\n    sol = Solution()\n    result = sol.addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode440.json",
    "problem_index_in_file": 0,
    "title": "K-th Smallest in Lexicographical Order",
    "description_snippet": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n]....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm: Given two integers n and k, return the kth lexicographically smallest integer in [1,n]. We need to generate pseudo-code, line by line, with explanations.\n\nWe should produce algorithm similar to Leetcode 440. Approach: use prefix counting to skip subtrees.\n\nPseudo-code:\n\nStart\n→ Step 1: 初始化 current = 0, steps = 0 // current prefix and steps used\n→ Step 2: while steps < k:\n    → Step 3: next = current * 10 // next prefix\n    → Step 4: steps_to_add = countSteps(next, next+1, n) // compute numbers in subtree\n    → Decision: if steps_to_add <= k - steps:\n        → Step 5: steps += steps_to_add\n        → Step 6: current += 1 // move to next sibling\n        → Step 7: if current > n: break\n    → Decision: else:\n        → Step 8: current = next // go deeper\n→ Step 9: return current // kth number\n\nWe need countSteps function: count = 0; while first <= n: count += min(n+1, second) - first; first *= 10; second *=10; return count.\n\nSo virtual code lines with explanation. Must use arrow and decisions. We'll produce.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\". Use \"Start\", \"End\", \"Decision:\".\n\nWe'll produce like:\n\nStart // 程式開始\n→ Step 1: Input n, k // 取得範圍上限和目標順位\n→ Step 2: current ← 0 // 初始化前綴\n→ Step 3: steps ← 0 // 已經計算出的項數\n→ Step 4: Function countSteps(first, second, n) // 定義計算前綴區間內數字個數\n    → Step 5: count ← 0 // 計數器\n    → Step 6: while first ≤ n:\n        → Step 7: count += min(n+1, second) - first // 累計當前層節點數\n        → Step 8: first ← first * 10 // 進入下一層\n        → Step 9: second ← second * 10 // 進入下一層\n    → Step 10: return count // 回傳計算結果\n→ Step 11: while steps < k: // 迭代尋找第k個數\n    → Step 12: next ← current * 10 // 進一步子前綴\n    → Step 13: stepsToAdd ← countSteps(next, next + 1, n) // 計算子樹大小\n    → Decision: if stepsToAdd ≤ k - steps:\n        → Step 14: steps ← steps + stepsToAdd // 跳過整棵子樹\n        → Step 15: current ← current + 1 // 移到同層下一個前綴\n        → Decision: if current > n: // 若超過範圍\n            → Step 16: break\n        → Step 17: continue\n    → Decision: else:\n        → Step 18: current ← next // 進入子前綴\n→ Step 19: End // 程式結束\n\nBut we need each line to have arrow etc. We need indent decisions.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: Input n, k // 取得範圍上限與目標順位\n→ Step 2: current ← 0 // 初始化前綴為 0\n→ Step 3: steps ← 0 // 已計算出的項數\n→ Function countSteps(first, second, n) // 計算從 first 到 second-1 內所有數字的個數\n    → Step 4: count ← 0 // 計數器\n    → Step 5: while first ≤ n: // 逐層往下遍歷\n        → Step 6: count += min(n + 1, second) - first // 累計當前層節點數\n        → Step 7: first ← first * 10 // 進入下一層\n        → Step 8: second ← second * 10 // 進入下一層\n    → Step 9: return count // 回傳子樹大小\n→ Step 10: while steps < k: // 尋找第 k 個數\n    → Step 11: next ← current * 10 // 將前綴擴展為下一層\n    → Step 12: stepsToAdd ← countSteps(next, next + 1, n) // 計算子樹內數字數量\n    → Decision: if stepsToAdd ≤ k - steps: // 若子樹全部可跳過\n        → Step 13: steps ← steps + stepsToAdd // 更新已計算項數\n        → Step 14: current ← current + 1 // 移到同層下一個前綴\n        → Decision: if current > n: // 若已超出範圍則結束\n            → Step 15: break\n        → Step 16: continue // 回到 while 迴圈開始\n    → Decision: else: // 必須進入子樹\n        → Step 17: current ← next // 進入下一層子前綴\n→ Step 18: return current // 第 k 個字典序數字\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef find_kth_number(n: int, k: int) -> int:\n    \"\"\"Return the k-th lexicographically smallest integer in [1, n].\"\"\"\n    def count_prefix(prefix: int) -> int:\n        \"\"\"Count numbers starting with the given prefix up to n.\"\"\"\n        cur, nxt, cnt = prefix, prefix + 1, 0\n        while cur <= n:\n            cnt += min(n + 1, nxt) - cur\n            cur *= 10\n            nxt *= 10\n        return cnt\n\n    curr = 1          # current prefix\n    k -= 1            # convert to zero‑based index\n    while k > 0:\n        cnt = count_prefix(curr)\n        if k >= cnt:          # skip entire subtree of curr\n            k -= cnt\n            curr += 1\n        else:                 # go deeper into the subtree\n            k -= 1\n            curr *= 10\n    return curr\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    print(find_kth_number(n, k))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode40.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum II",
    "description_snippet": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given list of candidate numbers, find all unique combinations summing to target, each number used once. This is typical \"combination sum II\" problem. We will output pseudocode line by line with explanations. Use Start, End, Decision, arrow. Should include sorting to handle duplicates. Use backtracking. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Provide indentation maybe via indentation? We should include indentation for nested steps. But need to maintain format: each line includes the step and comment. Use arrow for lines after start. Use decision lines: \"Decision:\" and Yes/No arrows. Use recursion calls. Let's craft lines.\n\nWe'll write:\n\nStart // 程式開始執行\n→ Step 1: 將 candidates 依升序排序 // 為了方便處理重複項\n→ Step 2: 建立空列表 result 用於儲存所有組合 // 結果集合\n→ Step 3: 定義遞迴函式 Backtrack(start, current, remaining) // 回溯函式\n→ Decision: 如果 remaining == 0? // 檢查是否達到目標和\n    Yes → Step 4: 將 current 的拷貝加入 result // 成功組合加入結果\n    No → Decision: 如果 start == len(candidates)? // 已經走到陣列尾端\n        Yes → Return // 沒有更多項可選\n        No  → Step 5: 從 i = start 到 len(candidates)-1 進行迴圈 // 遍歷剩餘候選\n            → Step 6: Decision: 如果 i > start 且 candidates[i] == candidates[i-1]? // 跳過重複\n                Yes → Continue // 跳過此項\n                No  → Decision: 如果 candidates[i] > remaining? // 剩餘不足以使用此項\n                    Yes → Break // 因為已排序，後面都更大，直接跳出迴圈\n                    No  → Step 7: Append candidates[i] 到 current // 添加選項\n                        → Step 8: Call Backtrack(i+1, current, remaining - candidates[i]) // 進一步搜尋\n                        → Step 9: Remove last element from current // 回溯，移除已選項\nEnd // 程式執行結束\n\nWe need to add comments after each line. Ensure each line has one virtual code step and comment separated by space. Use \"→\" for steps and \"Decision:\" lines. Use \"Yes →\" and \"No →\". Use indentation? The spec does not restrict indentation but examples show indentation. We'll indent lines within decisions using 4 spaces. Provide the same formatting. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 candidates 依升序排序 // 方便後續跳過重複數字  \n→ Step 2: 建立空列表 result 用於儲存所有組合 // 結果集合  \n→ Step 3: 定義遞迴函式 Backtrack(start, current, remaining) // 回溯函式  \n→ Decision: 如果 remaining == 0? // 檢查是否已達目標和  \n  Yes → Step 4: 將 current 的拷貝加入 result // 成功組合加入結果  \n  No → Decision: 如果 start == len(candidates)? // 已經到陣列尾端  \n   Yes → Return // 沒有更多項可選  \n   No → Step 5: 從 i = start 到 len(candidates)-1 進行迴圈 // 遍歷剩餘候選  \n    → Step 6: Decision: 如果 i > start 且 candidates[i] == candidates[i-1]? // 跳過重複  \n     Yes → Continue // 跳過此項  \n     No → Decision: 如果 candidates[i] > remaining? // 目前項已超過剩餘和  \n      Yes → Break // 後面皆更大，直接跳出迴圈  \n      No → Step 7: Append candidates[i] 到 current // 添加選項  \n       → Step 8: Call Backtrack(i+1, current, remaining - candidates[i]) // 進一步搜尋  \n       → Step 9: Remove last element from current // 回溯，移除已選項  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        Return all unique combinations of candidates that sum to target.\n        Each candidate may be used at most once.\n        \"\"\"\n        candidates.sort()\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            prev = -1\n            for i in range(start, len(candidates)):\n                if candidates[i] == prev:\n                    continue\n                path.append(candidates[i])\n                backtrack(i + 1, path, total + candidates[i])\n                path.pop()\n                prev = candidates[i]\n\n        backtrack(0, [], 0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract list of candidates\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not list_match:\n        print(\"[]\")\n        return\n    list_str = list_match.group(1)\n    candidates = [int(x) for x in list_str.split(',') if x.strip()]\n\n    # Extract target value\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    target = int(target_match.group(1)) if target_match else 0\n\n    sol = Solution()\n    result = sol.combinationSum2(candidates, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "success": true,
          "output": "[[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "success": true,
          "output": "[[1, 2, 2], [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode449.json",
    "problem_index_in_file": 0,
    "title": "Serialize and Deserialize BST",
    "description_snippet": "Serialization is converting a data structure or object into a sequence of bits so that it can be sto...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: Pre-order traversal of BST, use delimiter like comma, with sentinel for null? For BST, can serialize by preorder and during deserialization use bounds to reconstruct. Use stack or recursion. Compact string: no null markers, because BST structure can be inferred from values order. We'll use preorder with values separated by comma. For deserialization, reconstruct using bounds with recursion: pass min, max.\n\nWe produce step-by-step virtual code. Use Start, End, Decision. Provide each line with // explanation.\n\nLet's write virtual code. We'll include steps: Serialize: function serialize(root) -> string: do preorder, join. Then Deserialize: function deserialize(data) -> TreeNode: split string to list of ints, index pointer, recursively build with min, max.\n\nWe'll illustrate with recursion. Use pointer as array index.\n\nWrite virtual code with arrow. We'll show main steps. Ensure to include Start, End.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取二元搜尋樹根節點 root // 開始序列化或反序列化流程\n→ Decision: 是否為序列化? // 判斷使用者想做序列化還是反序列化\n    Yes → → Step 2: 初始化空字串 result = \"\" // 準備累積序列化結果\n    → Step 3: 進行前序遍歷 preorder(node) // 前序可保證 BST 結構可由值順序重建\n        → Decision: node 為 null? // 判斷是否達到葉子節點的子空指標\n            Yes → → Step 4: 返回 // 前序遍歷結束，無需標記 null\n            No  → → Step 5: 將 node.val 轉為字串並加上 ',' 至 result // 記錄節點值\n            → Step 6: preorder(node.left) // 遞迴處理左子樹\n            → Step 7: preorder(node.right) // 遞迴處理右子樹\n    → Step 8: 去除最後一個 ',' 後回傳 result // 輸出最終序列化字串\n    → End // 完成序列化\n    No  → → Step 9: 將輸入字串 data 以 ',' 分割成數值陣列 nums // 準備反序列化\n    → Step 10: 初始化指標 idx = 0 // 用於追蹤目前已處理的節點\n    → Step 11: 呼叫 helper(min, max) 以重建 BST\n        → Step 12: Decision: idx >= nums.length 或 nums[idx] not in (min, max)? // 檢查是否應該建立節點\n            Yes → → Step 13: 回傳 null // 無節點，對應原來的 null 子節點\n            No  → → Step 14: 建立新節點 node = new TreeNode(nums[idx]) // 創建節點\n            → Step 15: idx += 1 // 前進指標到下一個值\n            → Step 16: node.left = helper(min, node.val) // 左子樹必須小於節點值\n            → Step 17: node.right = helper(node.val, max) // 右子樹必須大於節點值\n            → Step 18: 回傳 node // 返回已完成的子樹\n    → Step 19: 回傳 helper(-∞, ∞) 的結果作為整棵樹的根節點\nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import deque\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\"\"\"\n        res = []\n\n        def preorder(node):\n            if not node:\n                return\n            res.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n\n        preorder(root)\n        return ','.join(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\"\"\"\n        if not data:\n            return None\n        preorder = list(map(int, data.split(',')))\n\n        def build(min_val, max_val):\n            if preorder and min_val < preorder[0] < max_val:\n                val = preorder.pop(0)\n                node = TreeNode(val)\n                node.left = build(min_val, val)\n                node.right = build(val, max_val)\n                return node\n            return None\n\n        return build(float('-inf'), float('inf'))\n\ndef insert_into_bst(root, val):\n    if root is None:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insert_into_bst(root.left, val)\n    else:\n        root.right = insert_into_bst(root.right, val)\n    return root\n\ndef build_tree_from_list(values):\n    root = None\n    for v in values:\n        root = insert_into_bst(root, v)\n    return root\n\ndef tree_to_level_list(root):\n    if not root:\n        return []\n    result = []\n    q = deque([root])\n    while q:\n        node = q.popleft()\n        result.append(node.val)\n        if node.left:\n            q.append(node.left)\n        if node.right:\n            q.append(node.right)\n    return result\n\ndef parse_input_line(line):\n    # Expected format: root = [a,b,c]\n    line = line.strip()\n    if '=' not in line:\n        return []\n    _, arr_part = line.split('=', 1)\n    arr_part = arr_part.strip()\n    if not arr_part.startswith('[') or not arr_part.endswith(']'):\n        return []\n    inner = arr_part[1:-1].strip()\n    if not inner:\n        return []\n    return list(map(int, inner.split(',')))\n\ndef main():\n    data = sys.stdin.read()\n    values = parse_input_line(data)\n    # Build original BST\n    root = build_tree_from_list(values)\n\n    codec = Codec()\n    serialized = codec.serialize(root)\n    deserialized_root = codec.deserialize(serialized)\n\n    output_list = tree_to_level_list(deserialized_root)\n    print('[' + ','.join(map(str, output_list)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "root = [2,1,3]",
          "expected_output": "[2,1,3]",
          "success": true,
          "output": "[2,1,3]"
        },
        {
          "example_index": 1,
          "input": "root = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode349.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The problem: intersection of two integer arrays, unique elements, any order.\n\nWe need to use Start, End, Decision, arrow, etc. Provide a step-by-step pseudocode.\n\nShould include steps: convert arrays to sets, find intersection, output array.\n\nLet's craft.\n\nStart\n→ Step 1: Convert nums1 to Set1 // transform first array to set for O(1) lookup\n→ Step 2: Initialize empty Set intersection // store unique common elements\n→ Step 3: For each element x in nums2 // iterate second array\n    → Decision: If x in Set1? // check if common\n        Yes → Step 4: Add x to intersection // add to result set\n        No  → Step 5: Continue // skip\n→ Step 6: Convert intersection set to array // produce output array\nEnd\n\nNeed each line with explanation. Use arrow for steps. For loops, we may represent as Step with loop, but we need line by line. The loop body has decision inside.\n\nAlso we need \"Start\" line and \"End\" line. Use '→' arrows. Each line must contain '虛擬碼步驟' + ' ' + '// 解釋/說明'.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 nums1 轉成 Set1 // 用 Set1 方便 O(1) 查找  \n→ Step 2: 初始化空 Set intersection // 用於儲存唯一交集元素  \n→ Step 3: 對 nums2 的每個元素 x 執行  \n    → Decision: x 是否在 Set1? // 判斷是否為交集元素  \n        Yes → Step 4: 把 x 加入 intersection // 將唯一交集元素存入集合  \n        No  → Step 5: 繼續 // 非交集元素不處理  \n→ Step 6: 把 intersection 轉成陣列 output // 生成最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"返回兩個整數陣列的唯一交集，順序任意\"\"\"\n        return list(set(nums1) & set(nums2))\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中擷取 nums1 與 nums2 的清單\"\"\"\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[.*?\\])', data, re.S)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[.*?\\])', data, re.S)\n    if not nums1_match or not nums2_match:\n        raise ValueError(\"輸入格式錯誤，請包含 nums1 與 nums2 列表。\")\n    nums1 = ast.literal_eval(nums1_match.group(1))\n    nums2 = ast.literal_eval(nums2_match.group(1))\n    return nums1, nums2\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums1, nums2 = parse_input(raw_input)\n    sol = Solution()\n    result = sol.intersection(nums1, nums2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "success": true,
          "output": "[9, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode416.json",
    "problem_index_in_file": 0,
    "title": "Partition Equal Subset Sum",
    "description_snippet": "Given an integer array nums, return true if you can partition the array into two subsets such that t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with step-by-step lines, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. The logic: Given array nums, check if can partition into two subsets equal sum. Classic subset sum / DP: total sum, if odd -> false. Else target = total/2. Then dynamic programming using set or boolean array. Use DP: dp[0]=true; for each num: for j from target down to num: dp[j] = dp[j] or dp[j-num]. After all, return dp[target].\n\nWe need to produce virtual code lines, each with explanation. Use arrow symbol. Use Yes/No for decisions. Let's produce.\n\nWe need step-by-step: Start, compute sum, decision if sum odd, etc. Then iterate numbers, DP. At the end, return dp[target]. End.\n\nAlso need to consider \"逐行\" - each line. Use virtual code steps.\n\nLet's produce.\n\nProbably we need to show for loop. For DP loop we can show \"→ For each num in nums:\" etc. Use Decision for j loops? Could use \"Decision: j ≥ num?\" to decide if update. Use nested loops.\n\nLet's produce simple representation.\n\nLet's proceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 nums 之總和 totalSum // 取得整個陣列的和  \n→ Decision: 如果 totalSum 為奇數? // 無法平分成兩個相等子集  \n  Yes → Step 2: 回傳 false // 直接返回無法分割  \n  No  → Step 3: 設定 target = totalSum / 2 // 目標子集和  \n→ Step 4: 建立布林陣列 dp[0 … target]，並初始化 dp[0] 為 true // dp[j] 表示能否組成和 j  \n→ For each num 在 nums 之中: // 逐個處理陣列中的數值  \n  → Decision: 如果 num 大於 target? // 超過目標值直接跳過  \n    Yes → Continue // 跳到下一個 num  \n    No → For j 從 target 下降到 num: // 從高到低更新 dp 以避免重複使用同一個 num  \n      Decision: 如果 dp[j - num] 為 true? // 已經能組成 j-num，則 j 也可行  \n        Yes → Step 5: 設定 dp[j] = true // 更新 dp  \n        No  → // 不變，保持原值  \n→ Step 6: 回傳 dp[target] // 若能組成 target，則可平分  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canPartition(self, nums):\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        target = total // 2\n\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n\n        return dp[target]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 若輸入為 \"nums = [1,2,3]\" 之類的格式，移除前綴\n    if raw_input.lower().startswith(\"nums\"):\n        # 分割等號\n        parts = raw_input.split('=', 1)\n        if len(parts) == 2:\n            raw_input = parts[1].strip()\n\n    # 使用 literal_eval 轉成列表，確保安全\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，輸出 false\n        print(\"false\")\n        sys.exit(0)\n\n    # 確保輸入是列表\n    if not isinstance(nums, list):\n        print(\"false\")\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.canPartition(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,11,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,5]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode398.json",
    "problem_index_in_file": 0,
    "title": "Random Pick Index",
    "description_snippet": "Given an integer array nums with possible duplicates, randomly output the index of a given target nu...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. For this problem, typical solution: store mapping from target to list of indices; pick random from list. Or reservoir sampling during pick. Let's outline: In constructor, iterate array, map target to list of indices. In pick, get list and random choice. Virtual code lines.\n\nWe output with arrows. Use \"Start\", \"End\", \"Decision:\".\n\nLet's craft:\n\nStart\n→ Step 1: 初始化哈希表 targetToIndices // 建立目標到索引列表的映射\n→ Step 2: 迭代 nums 並填充 targetToIndices // 為每個值將其索引加入對應列表\nEnd // 建構完成\n\nThen pick method:\n\nStart // pick 方法開始\n→ Step 3: 取得 target 對應的索引列表 idxList = targetToIndices[target] // 獲取所有符合目標的索引\n→ Decision: 如果 idxList 為空? // 檢查是否有匹配\n    Yes → Step 4: 回傳 -1 // 雖然題目保證存在，但此處作安全處理\n    No  → Step 5: 生成隨機整數 r 於 0 到 len(idxList)-1 // 隨機選擇一個位置\n→ Step 6: 回傳 idxList[r] // 返回隨機索引\nEnd // pick 方法結束\n\nBut we need to output each line with virtual code arrow and comment. We need to use \"→\" arrow. For decisions, use \"Decision:\" with indentation.\n\nMake sure each line is separate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 targetToIndices: Map<int, List<int>> // 用於儲存每個目標值對應的索引列表\n→ Step 2: 從 nums 迭代 i = 0 至 nums.length-1\n    → Decision: 若 nums[i] 尚未在 targetToIndices 中? // 檢查鍵是否存在\n        Yes → Step 3a: 建立新列表 targetToIndices[nums[i]] = [] // 初始化列表\n        No  →\n    → Step 3b: 將索引 i 加入 targetToIndices[nums[i]] // 將索引加入對應列表\nEnd // 建構完成\n\nStart // pick 方法開始\n→ Step 4: 取得 idxList = targetToIndices[target] // 取得所有符合目標的索引\n→ Decision: 若 idxList 為空? // 安全檢查，實際不會發生\n    Yes → Step 5a: 回傳 -1 // 不合法情況返回 -1\n    No  →\n→ Step 5b: 產生隨機整數 r 在 0 與 len(idxList)-1 之間 // 隨機選取索引位置\n→ Step 6: 回傳 idxList[r] // 返回隨機索引\nEnd // pick 方法結束\n\nBut need to follow the format exactly: each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow. Also \"Start\" \"End\". We need indent for nested lines. In sample, they had indentation with spaces before arrow.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 targetToIndices: Map<int, List<int>> // 用於儲存每個目標值對應的索引列表\n→ Step 2: 從 nums 迭代 i = 0 至 nums.length-1\n    → Decision: 若 nums[i] 尚未在 targetToIndices 中? // 檢查鍵是否存在\n        Yes → Step 3a: 建立新列表 targetToIndices[nums[i]] = [] // 初始化列表\n        No  →\n    → Step 3b: 將索引 i 加入 targetToIndices[nums[i]] // 將索引加入對應列表\nEnd // 建構完成\n\nStart // pick 方法開始\n→ Step 4: 取得 idxList = targetToIndices[target] // 取得所有符合目標的索引\n→ Decision: 若 idxList 為空? // 安全檢查，實際不會發生\n    Yes → Step 5a: 回傳 -1 // 不合法情況返回 -1\n    No  →\n→ Step 5b: 產生隨機整數 r 在 0 與 len(idxList)-1 之間 // 隨機選取索引位置\n→ Step 6: 回傳 idxList[r] // 返回隨機索引\nEnd // pick 方法結束\n\nBut the format maybe expects each line with arrow and comment. Indentation may use spaces. Provide exactly as sample: use 4 spaces before inner lines? They used 4 spaces before \"Yes →\". So replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 targetToIndices: Map<int, List<int>> // 用於儲存每個目標值對應的索引列表\n→ Step 2: 從 nums 迭代 i = 0 至 nums.length-1\n    → Decision: 若 nums[i] 尚未在 targetToIndices 中? // 檢查鍵是否存在\n        Yes → Step 3a: 建立新列表 targetToIndices[nums[i]] = [] // 初始化列表\n        No  →\n    → Step 3b: 將索引 i 加入 targetToIndices[nums[i]] // 將索引加入對應列表\nEnd // 建構完成\n\nStart // pick 方法開始\n→ Step 4: 取得 idxList = targetToIndices[target] // 取得所有符合目標的索引\n→ Decision: 若 idxList 為空? // 安全檢查，實際不會發生\n    Yes → Step 5a: 回傳 -1 // 不合法情況返回 -1\n    No  →\n→ Step 5b: 產生隨機整數 r 在 0 與 len(idxList)-1 之間 // 隨機選取索引位置\n→ Step 6: 回傳 idxList[r] // 返回隨機索引\nEnd // pick 方法結束",
      "generated_code": "import sys\nimport json\nimport random\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"初始化，將每個目標值對應的所有索引存於字典中\"\"\"\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"隨機選取 target 的索引，若存在多個索引則機率均等\"\"\"\n        return random.choice(self.indices[target])\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析為兩個列表：commands 與 arguments\n    # 例如輸入: '[\"Solution\", \"pick\", \"pick\"], [[[1, 2, 3]], [1], [2]]'\n    # 會得到 commands=['Solution','pick','pick'], args=[[1,2,3],[1],[2]]\n    commands, args_list = ast.literal_eval(raw)\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 建構物件\n            obj = Solution(*args)\n            results.append(None)  # 按題目輸出 null\n        else:\n            # 呼叫方法\n            res = getattr(obj, cmd)(*args)\n            results.append(res)\n\n    # 輸出結果，使用 json.dumps 讓 None 變成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 4]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode139.json",
    "problem_index_in_file": 0,
    "title": "Word Break",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a spac...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for word break problem. Provide lines with arrows, decisions, etc. Not actual code. Provide explanations. Use Start, End. Each line: \"虛擬碼步驟 // 解釋\". Use \"Decision:\" for conditions. Provide algorithm: dynamic programming or recursion with memoization. Let's choose DP. Steps: initialize dp array length len(s)+1 boolean. dp[0]=true. Iterate i from 1 to n, for each j from 0 to i, if dp[j] and s[j:i] in wordDict, set dp[i]=true and break. At end return dp[n]. Provide steps accordingly.\n\nWe must output each line with virtual code arrow. For loops: \"→ Loop i from 1 to n\" etc. Provide decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義字串長度 n = len(s) // 取得輸入字串長度  \n→ Step 2: 初始化布林陣列 dp[0..n] 為 false，並將 dp[0] 設為 true // dp[i] 表示 s[:i] 可被分割成字典詞組  \n→ Decision: 是否有任何字典詞長度大於 n?  \n    Yes → Step 3: 移除長度大於 n 的字典詞 // 節省後續搜尋  \n    No  →  \n→ Step 4: 對 i 從 1 到 n 進行迴圈 // i 為當前考慮的子字串長度  \n    → Decision: dp[i] 已經為 true?  \n        Yes → Step 5: 跳過此 i，進入下一次迴圈 // 已找到合法分割，無需再檢查  \n        No  → → Loop j 從 0 到 i-1 // j 為前一個分割點  \n            → Decision: dp[j] 為 true 且 s[j:i] 在 wordDict 中?  \n                Yes → Step 6: 設定 dp[i] 為 true，跳出內部 j 迴圈 // 找到合法分割，結束 j 迴圈  \n                No  →  \n→ Step 7: 回傳 dp[n] // 若最後位置可分割，則整個字串可分割  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(s)]\n\ndef parse_input(text):\n    # 匹配形式: s = \"string\", wordDict = [\"word1\",\"word2\",...]\n    pattern = r's\\s*=\\s*\"(.+?)\"\\s*,\\s*wordDict\\s*=\\s*\\[(.*)\\]'\n    match = re.search(pattern, text, re.S)\n    if not match:\n        # 如果輸入格式不同，嘗試簡單的 eval 方式（非安全，但符合範例）\n        try:\n            data = eval(text.strip())\n            return data.get('s', ''), data.get('wordDict', [])\n        except Exception:\n            return '', []\n    s = match.group(1)\n    words_raw = match.group(2)\n    if words_raw.strip() == '':\n        words = []\n    else:\n        words = [w.strip().strip('\"').strip(\"'\") for w in words_raw.split(',')]\n    return s, words\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    s, wordDict = parse_input(input_text)\n    result = Solution().wordBreak(s, wordDict)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode283.json",
    "problem_index_in_file": 0,
    "title": "Move Zeroes",
    "description_snippet": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for moving zeros to end while preserving order, in-place. Use two-pointer approach: slow index to place next non-zero. Iterate over array, if element != 0, set arr[slow] = arr[i], slow++. After loop, fill zeros from slow to end. That is typical. Provide virtual code step by step with arrows and decisions. Output must be in Traditional Chinese. Let's craft. Use \"Start\", \"End\", \"Decision:\" lines. Use \"→\" arrow. Provide explanation after each line. Each line ends with // 解釋. Provide step names. Use \"Step 1: ...\" etc. Ensure each line contains virtual code + space + // + explanation. Use Chinese. Provide only virtual code, no actual code.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數陣列 nums // 取得要處理的陣列\n→ Step 2: 設定變數 pos = 0 // pos 用於記錄下一個非零元素應放置的位置\n→ Decision: pos < nums.length? // 檢查是否已經遍歷完陣列\n    Yes → Step 3: 如果 nums[pos] ≠ 0? // 判斷目前元素是否為非零\n        Yes → Step 4: 把 nums[pos] 放到 nums[pos] // 將非零元素保留在原位置（或後面移動）\n            No  → Step 5: // 不做任何事，等待下一個位置\n    No  → Step 6: // 完成非零元素的移動\n→ Step 7: 設定變數 i = pos // i 從最後一個非零元素位置開始填充零\n→ Decision: i < nums.length? // 檢查是否還有位置需要填充\n    Yes → Step 8: 把 nums[i] 設為 0 // 在剩餘位置填充零\n        No  → Step 9: // 所有位置已填滿零\nEnd // 程式執行結束\n\nBut we need to ensure virtual code is step-by-step, with decisions, loops. Provide arrow for loops. But we can use Decision: and Yes/No blocks. Let's produce more formal.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 取得要處理的陣列  \n→ Step 2: 設定變數 pos = 0 // pos 用於記錄下一個非零元素應放置的位置  \n\n→ Decision: pos < nums.length? // 檢查是否還有元素未處理  \n    Yes → Step 3: 如果 nums[pos] ≠ 0? // 判斷目前元素是否為非零  \n        Yes → Step 4: 把 nums[pos] 放到 nums[pos] // 將非零元素保留在正確位置  \n            No  → Step 5: // 這裡不做任何改動，等待下一個元素  \n        No  → Step 6: pos = pos + 1 // 進一步檢查下一個位置  \n        No  → Step 6: pos = pos + 1  \n    No  → Step 7: // 所有元素已經檢查完畢  \n\n→ Step 8: 設定變數 i = pos // i 從最後一個非零元素位置開始填零  \n→ Decision: i < nums.length? // 檢查是否還有位置需要填零  \n    Yes → Step 9: 把 nums[i] 設為 0 // 在剩餘位置填入零  \n        No  → Step 10: i = i + 1 // 前進到下一個位置  \n    No  → Step 11: // 所有剩餘位置已填滿零  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def moveZeroes(self, nums):\n        \"\"\"\n        Move all zeros to the end while maintaining the order of non-zero elements.\n        The operation is performed in-place.\n        \"\"\"\n        zero_pos = 0  # Position where the next non-zero element should be placed\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[zero_pos], nums[i] = nums[i], nums[zero_pos]\n                zero_pos += 1\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # If the input contains an equals sign, split and take the right-hand side\n    if '=' in raw_input:\n        _, list_part = raw_input.split('=', 1)\n    else:\n        list_part = raw_input\n\n    # Safely parse the list using ast.literal_eval\n    try:\n        nums = ast.literal_eval(list_part.strip())\n    except Exception:\n        # If parsing fails, assume the input itself is the list string\n        nums = ast.literal_eval(raw_input)\n\n    # Ensure we have a list\n    if not isinstance(nums, list):\n        raise ValueError(\"Input must be a list of integers\")\n\n    # Apply the moveZeroes algorithm\n    Solution().moveZeroes(nums)\n\n    # Output the resulting list\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,0,3,12]",
          "expected_output": "[1,3,12,0,0]",
          "success": true,
          "output": "[1, 3, 12, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode650.json",
    "problem_index_in_file": 0,
    "title": "2 Keys Keyboard",
    "description_snippet": "There is only one character 'A' on the screen of a notepad. You can perform one of two operations on...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solution to problem: minimum operations to produce n 'A's using copy all and paste operations. Classic problem: \"2 Keys Keyboard\". The optimal number of steps equals sum of prime factors of n. Approach: factorize n into primes, sum them. So virtual code: Start, read n, if n <= 1, result 0? For n=1 result 0. Then initialize ans=0, temp=n. While temp>1: find smallest factor i from 2 to sqrt(temp). If found, ans += i, temp/=i. If not found, ans+=temp, temp=1. End. Output ans.\n\nWe must produce virtual code step by step with comments. Use arrow syntax. Let's produce.\n\nWe need to use \"Start\" and \"End\" markers. Use \"Decision:\" lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 從輸入取得目標字母數量\n→ Decision: n 等於 1? // n=1 時已達到需求\n    Yes → Step 2: 輸出 0 // 只需 0 步驟\n    No  → Step 3: 初始化 ans = 0 // 用於累計步驟數\n        → Step 4: 設定 temp = n // temp 用於分解質因數\n            → Decision: temp 大於 1? // 需要進行分解\n                Yes → Step 5: 找最小質因數 i 從 2 開始至 sqrt(temp)\n                    → Decision: 找到 i 為質因數? // 判斷是否存在質因數\n                        Yes → Step 6: ans += i // 加入質因數作為步驟數\n                            → Step 7: temp = temp / i // 消除該質因數\n                            → Decision: temp > 1? // 是否還有質因數需要處理\n                                Yes → 回到 Step 5\n                                No  → Step 8: 輸出 ans // 所有質因數已累加完畢\n                No  → Step 9: ans += temp // temp 本身是質數\n                    → Step 10: temp = 1\n                    → Step 11: 輸出 ans // 輸出最終步驟數\nEnd // 程式執行結束\n\nBut need more precise: We can condense. Provide each line with arrow. Use \"Yes →\" and \"No →\" for decisions. Use \"Decision:\" lines.\n\nBetter format:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得目標字母數量\n→ Decision: n 等於 1? // n=1 時不需要任何操作\n    Yes → Step 2: 輸出 0 // 結束\n    No  → Step 3: 初始化 ans = 0 // 步驟計數器\n        → Step 4: temp = n // 用於分解\n            → Decision: temp > 1? // 是否還有質因數\n                Yes → Step 5: i = 2 // 搜尋最小質因數\n                    → Decision: i * i <= temp? // 檢查 i 是否可作為因數\n                        Yes → Decision: temp mod i 等於 0? // i 為質因數\n                            Yes → Step 6: ans += i // 加步驟\n                                → Step 7: temp = temp / i // 去除質因數\n                                → Step 8: 重新進入 Step 5 // 重新搜尋\n                            No  → Step 9: i += 1 // 嘗試下一個 i\n                        No  → Step 10: ans += temp // temp 本身是質數\n                            → Step 11: temp = 1 // 結束\n                No  → Step 12: 輸出 ans // 所有質因數已處理\nEnd // 程式結束\n\nBut maybe need to restructure to match required format exactly: Each line \"虛擬碼步驟 [空格] // 解釋\".\n\nThus we need each line separated by newline. Use arrow and indent as needed.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得目標字母數量  \n→ Decision: n 等於 1? // n=1 時已達到需求  \n Yes → Step 2: 輸出 0 // 只需 0 步驟，結束  \n No  → Step 3: 初始化 ans = 0 // 步驟計數器  \n  → Step 4: temp = n // 用於分解質因數  \n   → Decision: temp > 1? // 是否還有質因數需要處理  \n    Yes → Step 5: i = 2 // 從最小整數開始尋找因數  \n     → Decision: i * i <= temp? // i 是否可能是因數  \n      Yes → Decision: temp mod i 等於 0? // i 為實際質因數  \n       Yes → Step 6: ans += i // 加入此質因數作為步驟數  \n        → Step 7: temp = temp / i // 消除此質因數  \n        → Step 8: 重新進入 Step 5 // 仍可能有其他因數  \n       No  → Step 9: i += 1 // 試下個整數  \n     No  → Step 10: ans += temp // temp 本身是質數  \n      → Step 11: temp = 1 // 結束分解  \n      → Step 12: 輸出 ans // 所有質因數已累加完成  \n    No  → Step 13: 輸出 ans // temp 已為 1，直接輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_steps(n: int) -> int:\n    \"\"\"Return the minimal number of operations to obtain n 'A's.\"\"\"\n    if n <= 1:\n        return 0\n    steps = 0\n    d = 2\n    while n > 1:\n        while n % d == 0:\n            steps += d\n            n //= d\n        d += 1\n    return steps\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 尋找第一個正整數，若輸入為 \"n = 3\" 或僅為 \"3\" 都能正確解析\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = min_steps(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode397.json",
    "problem_index_in_file": 0,
    "title": "Integer Replacement",
    "description_snippet": "Given a positive integer n, you can apply one of the following operations:\n\n1. If n is even, replace...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm that finds minimal operations to reduce n to 1 using rules: if n even -> n/2; if odd -> n+1 or n-1. Classic problem: \"integer replacement\" on Leetcode. Optimal solution uses greedy: if n is odd, choose between n+1 or n-1; except special case when n==3 -> choose -1; else if n%4==1 choose -1 else +1. Use recursion or loop. Provide virtual code lines with explanations.\n\nWe need to output line by line with arrow structure. Start, End, Decision: etc. Use 虛擬碼步驟 + space + // 解釋. Use arrow. Let's craft algorithm: function minOperations(n). Count=0. While n != 1: if n%2==0: n/=2; else: if n==3: n-=1; else if n%4==1: n-=1; else: n+=1; Count++ each time; return count.\n\nLet's produce pseudocode with steps:\n\nStart\n→ Step 1: Input n // get positive integer\n→ Step 2: count ← 0 // initialize counter\n→ Decision: while n != 1? // loop until target\n    Yes → Step 3: if n is even? // check parity\n        Yes → Step 4: n ← n / 2 // even operation\n        No → Step 5: if n == 3? // special case\n            Yes → Step 6: n ← n - 1 // decrement\n            No → Decision: if n % 4 == 1? // choose direction\n                Yes → Step 7: n ← n - 1 // decrement\n                No  → Step 8: n ← n + 1 // increment\n        End if\n    End if\n    → Step 9: count ← count + 1 // increment operation count\n    → Step 10: continue // loop back\nEnd // exit loop\n→ Step 11: return count // output result\n\nBut must include the structure: Start, End, Decision:, Yes→, No→. Need to represent while loop as Decision? We can treat while n != 1 as Decision: if n != 1? Yes→ ... No→ End. Or use Loop: but specification didn't mention Loop; but can use Decision. We'll use Decision. So:\n\nStart\n→ Decision: n == 1? // check if already 1\n    Yes → End // already done\n    No → ... // rest\nBut better to use while. Let's use Decision for each iteration: Step: While n != 1? Represent as Decision: n != 1? Yes→ ... No→ End.\n\nLet's construct:\n\nStart // 程式開始\n→ Decision: n == 1? // 是否已經是1\n    Yes → End // 已完成\n    No  → Step 1: count ← 0 // 初始化計數\n    → Step 2: count ← 0 // 計數器\n    → Decision: n != 1? // 進入循環\n        Yes → Step 3: if n % 2 == 0? // 判斷偶數\n            Yes → Step 4: n ← n / 2 // 偶數直接除以2\n            No  → Decision: n == 3? // 特殊情況3\n                Yes → Step 5: n ← n - 1 // 對3減1\n                No  → Decision: n % 4 == 1? // 根據模4選擇\n                    Yes → Step 6: n ← n - 1 // 模4等於1減1\n                    No  → Step 7: n ← n + 1 // 否則加1\n                End Decision\n            End Decision\n        End if\n        → Step 8: count ← count + 1 // 操作計數加一\n        → Step 9: continue // 回到決策\n        No  → Step 10: return count // 返回結果\nEnd // 程式結束\n\nBut we need to use arrow for each line. Provide each line as \"虛擬碼步驟\" + space + // explanation.\n\nLet's produce with proper indentation. Ensure no code syntax. Use arrow characters.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: n == 1? // 判斷輸入是否已為 1  \n  Yes → End // 若已是 1，直接結束  \n  No → Step 1: count ← 0 // 初始化操作計數器  \n→ Decision: n != 1? // 進入主循環，直到 n 變為 1  \n  Yes → Step 2: if n % 2 == 0? // 判斷 n 是否為偶數  \n    Yes → Step 3: n ← n / 2 // 偶數直接除以 2  \n    No → Decision: n == 3? // 特殊情況 3，選擇減 1  \n      Yes → Step 4: n ← n - 1 // 對 3 做 -1 操作  \n      No → Decision: n % 4 == 1? // 根據 n mod 4 選擇方向  \n        Yes → Step 5: n ← n - 1 // 若 mod 4 == 1，減 1  \n        No  → Step 6: n ← n + 1 // 否則加 1  \n      End Decision  \n    End Decision  \n  End if  \n  → Step 7: count ← count + 1 // 每一步操作計數加一  \n  → Step 8: continue // 返回 Decision，檢查是否已達 1  \n  No  → Step 9: return count // 循環結束，返回最小操作數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def integerReplacement(self, n: int) -> int:\n        \"\"\"Return the minimal number of operations to reduce n to 1.\"\"\"\n        count = 0\n        while n != 1:\n            if n % 2 == 0:          # Even case: divide by 2\n                n //= 2\n            else:                   # Odd case: decide to add or subtract\n                if n == 3 or ((n >> 1) & 1) == 0:\n                    n -= 1         # Prefer -1 for 3 or when second‑least bit is 0\n                else:\n                    n += 1         # Otherwise prefer +1\n            count += 1\n        return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the first integer found in the input\n    match = re.search(r\"-?\\d+\", data)\n    if match:\n        n = int(match.group(0))\n        result = Solution().integerReplacement(n)\n        print(result)\n    else:\n        # No integer found; nothing to output\n        pass",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 8",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode387.json",
    "problem_index_in_file": 0,
    "title": "First Unique Character in a String",
    "description_snippet": "Given a string s, find the first non-repeating character in it and return its index. If it does not ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format:\n\nStart // 程式開始執行\n→ Step 1: ... // explanation\n\nUse Decision etc.\n\nWe need to output virtual code for algorithm: Given string s, find first non-repeating char index. We can use hash map to count frequencies, then loop again to find first char with count 1. Return index or -1.\n\nWe need to produce step by step pseudocode. The user says \"使用者需求\" given. So produce steps.\n\nLet's craft:\n\nStart\n→ Step 1: 建立空字典 frequencyMap // 用於儲存每個字元出現次數\n→ Step 2: 從前到後遍歷字符串 s\n    → Decision: 如果字元已存在於 frequencyMap? // 檢查是否已計數\n        Yes → Update frequencyMap[char] = frequencyMap[char] + 1 // 次數加一\n        No  → Add frequencyMap[char] = 1 // 第一次出現\n→ Step 3: 再次從前到後遍歷字符串 s\n    → Decision: frequencyMap[char] == 1? // 檢查字元是否唯一\n        Yes → Return current index // 找到第一個非重複字元\n        No  → 繼續\n→ Decision: 迴圈結束後沒有返回? // 若未找到唯一字元\n    Yes → Return -1 // 沒有非重複字元\nEnd\n\nWe need to use arrows properly: \"→\" preceding step lines. For decisions we indent with spaces maybe. Use \"Decision:\" as header then lines with \"Yes →\" and \"No →\" for branching.\n\nMake sure each line ends with comment // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 frequencyMap // 用於儲存每個字元出現次數  \n→ Step 2: 從前到後遍歷字符串 s // 逐一檢查每個字元  \n  Decision: 字元已存在於 frequencyMap? // 檢查是否已計數  \n   Yes → frequencyMap[char] = frequencyMap[char] + 1 // 次數加一  \n   No  → frequencyMap[char] = 1 // 第一次出現  \n→ Step 3: 再次從前到後遍歷字符串 s // 重新尋找第一個唯一字元  \n  Decision: frequencyMap[char] == 1? // 判斷字元是否唯一  \n   Yes → Return currentIndex // 找到第一個非重複字元，返回其索引  \n   No  → 繼續遍歷  \n→ Decision: 迴圈結束後沒有返回? // 若未找到唯一字元  \n  Yes → Return -1 // 沒有非重複字元  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        \"\"\"返回字符串中首个非重复字符的索引，若不存在則返回 -1。\"\"\"\n        # 1. 計算每個字元的出現次數\n        freq = {}\n        for ch in s:\n            freq[ch] = freq.get(ch, 0) + 1\n\n        # 2. 再次遍歷，找出首個出現次數為 1 的字元\n        for idx, ch in enumerate(s):\n            if freq[ch] == 1:\n                return idx\n        return -1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n\n    # 解析輸入，支援兩種形式：\n    #   s = \"leetcode\"\n    #   leetcode\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接取等號後面的字串\n        if '=' in raw_input:\n            s = raw_input.split('=', 1)[1].strip()\n        else:\n            s = raw_input\n        s = s.strip('\"').strip()\n\n    # 執行算法並輸出結果\n    solution = Solution()\n    print(solution.firstUniqChar(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "s = \"loveleetcode\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"aabb\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode697.json",
    "problem_index_in_file": 0,
    "title": "Degree of an Array",
    "description_snippet": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the ma...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving: find smallest contiguous subarray with same degree. We'll produce steps: count frequencies, find degree, record first/last indices per element, compute minimal length. Provide steps with arrows. We'll include Start, End, Decision. Use virtual code. Each line: \"虛擬碼步驟 // 解釋\". Must be in Traditional Chinese. Provide sequential steps. Use arrow notation. Let's craft.\n\nOutline:\n\nStart\n→ Step 1: Initialize empty hash maps: count, firstIndex, lastIndex // 记录每个元素出现次数、第一次出现位置、最后一次出现位置\n→ Step 2: For each index i, value val in nums:\n    → Update count[val] += 1\n    → If val not in firstIndex: firstIndex[val] = i\n    → Update lastIndex[val] = i\n→ Step 3: Determine degree = max(count.values()) // 最大出现次数\n→ Step 4: Initialize minLength = length of nums // 设定初始最小长度\n→ Step 5: For each val in count:\n    → If count[val] == degree:\n        → length = lastIndex[val] - firstIndex[val] + 1\n        → If length < minLength: minLength = length\n→ End // 输出 minLength\n\nWe need decisions? Maybe a decision: if count == degree.\n\nWe can structure with Decision: ... Yes/No. We'll produce.\n\nLet's produce lines with arrow formatting.\n\nMake sure each line includes `//` explanation.\n\nWe'll use `→` arrow after Start. Indent? Provide as lines.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 hash map count, firstIndex, lastIndex // 用來統計每個元素的頻率與最初/最後出現位置\n→ Step 2: 遍歷 nums 的每個索引 i 及對應值 val\n    → Decision: 是否已經在 firstIndex 中記錄 val? // 判斷是否為第一次出現\n        Yes → // 已記錄，跳過設定第一次位置\n        No  → firstIndex[val] ← i // 記錄第一次出現的位置\n    → count[val] ← count[val] + 1 // 更新頻率\n    → lastIndex[val] ← i // 更新最後一次出現的位置\n→ Step 3: degree ← max(count.values()) // 取得陣列的度（最大頻率）\n→ Step 4: minLength ← nums.length // 初始最小長度設為整個陣列長度\n→ Step 5: 遍歷 count 中的每個元素 val\n    → Decision: count[val] == degree? // 判斷是否為度元素\n        Yes → length ← lastIndex[val] - firstIndex[val] + 1 // 計算此元素的子陣列長度\n        → Decision: length < minLength? // 判斷是否更短\n            Yes → minLength ← length // 更新最小長度\n            No  → // 不更新\n        No  → // 非度元素，忽略\nEnd // 程式執行結束，minLength 為答案。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findShortestSubArray(self, nums):\n        # left: first occurrence index of each number\n        # right: last occurrence index of each number\n        # count: frequency of each number\n        left, right, count = {}, {}, {}\n        for i, num in enumerate(nums):\n            if num not in left:\n                left[num] = i          # record first appearance\n            right[num] = i              # keep updating last appearance\n            count[num] = count.get(num, 0) + 1\n\n        degree = max(count.values())     # maximum frequency\n        min_length = float('inf')\n        for num, freq in count.items():\n            if freq == degree:\n                length = right[num] - left[num] + 1\n                if length < min_length:\n                    min_length = length\n        return min_length\n\ndef parse_input(raw):\n    \"\"\"\n    解析從 stdin 讀取的資料，取得數列 nums。\n    資料格式示例：'nums = [1,2,2,3,1]'\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return []\n\n    # 找出第一個 '[' 和最後一個 ']'，提取其中的字串\n    l = raw.find('[')\n    r = raw.rfind(']')\n    if l != -1 and r != -1:\n        list_str = raw[l:r+1]\n        try:\n            return ast.literal_eval(list_str)\n        except Exception:\n            pass\n\n    # 若無方括號，直接嘗試解析整個字串\n    try:\n        return ast.literal_eval(raw)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    if nums:\n        sol = Solution()\n        result = sol.findShortestSubArray(nums)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,2,3,1,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode503.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element II",
    "description_snippet": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: next greater element in circular array. Use monotonic stack. Steps: initialize result array same length with -1. Create stack. Iterate from 2*n-1 downto 0: idx = i % n. While stack not empty and stack.top <= nums[idx], pop. If stack not empty, result[idx] = stack.top else -1. Push nums[idx]. End. Return result.\n\nWe need to provide each step line by line with explanation. Use structure Start, End, Decision etc. The virtual code arrow formatting. We'll produce steps accordingly. Need to use 虛擬碼步驟 and explanation. Let's craft.\n\nStart // 程式開始執行\n\n→ Step 1: 初始化結果陣列 res 為長度 n，所有元素設為 -1 // 用於儲存每個位置的下一個更大數\n\n→ Step 2: 初始化空棧 stack // 用於維持遞減堆疊\n\n→ Step 3: 設定迴圈 i 從 2n-1 下降到 0 // 兩輪遍歷以模擬循環\n\n    → Decision: i ≥ 0? // 判斷是否結束迴圈\n\n        Yes → Step 4: 計算 idx = i mod n // 取得實際索引位置\n\n        → Step 5: while stack 非空 且 stack.top ≤ nums[idx] do pop // 去除不夠大的元素\n\n        → Decision: stack 非空? // 判斷是否還有更大的元素\n\n            Yes → Step 6: res[idx] = stack.top // 設定下一個更大數\n\n            No  → Step 7: res[idx] = -1 // 沒有更大數，保持 -1\n\n        → Step 8: push nums[idx] 進 stack // 將目前元素加入堆疊\n\n        → Step 9: i = i - 1 // 迴圈遞減\n\n    No  → End // 迴圈結束\n\n→ Step 10: 輸出 res // 返回結果陣列\n\nEnd // 程式執行結束\n\nBut the virtual code must use arrow syntax. They used \"→\" for steps, and \"Decision:\" lines. Indentation for nested decisions. Provide arrow for nested steps too.\n\nMake sure each line has 虛擬碼步驟 followed by // 解釋. Use spaces after arrow.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化結果陣列 res 為長度 n，所有元素設為 -1 // 用於儲存每個位置的下一個更大數\n→ Step 2: 初始化空棧 stack // 用於維持遞減堆疊\n→ Step 3: 設定迴圈 i 從 2n-1 下降到 0 // 兩輪遍歷以模擬循環\n    → Decision: i ≥ 0? // 判斷是否結束迴圈\n        Yes → Step 4: 計算 idx = i mod n // 取得實際索引位置\n        → Step 5: while stack 非空 且 stack.top ≤ nums[idx] do pop // 去除不夠大的元素\n        → Decision: stack 非空? // 判斷是否還有更大的元素\n            Yes → Step 6: res[idx] = stack.top // 設定下一個更大數\n            No  → Step 7: res[idx] = -1 // 沒有更大數，保持 -1\n        → Step 8: push nums[idx] 進 stack // 將目前元素加入堆疊\n        → Step 9: i = i - 1 // 迴圈遞減\n    No  → End // 迴圈結束\n→ Step 10: 輸出 res // 返回結果陣列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextGreaterElements(self, nums):\n        n = len(nums)\n        if n == 0:\n            return []\n        res = [-1] * n\n        stack = []\n        # Traverse twice to simulate circular array\n        for i in range(2 * n - 1, -1, -1):\n            idx = i % n\n            # Pop elements that are not greater than current\n            while stack and stack[-1] <= nums[idx]:\n                stack.pop()\n            # If stack not empty, the top is the next greater element\n            res[idx] = stack[-1] if stack else -1\n            stack.append(nums[idx])\n        return res\n\ndef parse_input(data: str):\n    \"\"\"Parse input like 'nums = [1,2,1]' or just '[1,2,1]'.\"\"\"\n    data = data.strip()\n    if data.startswith(\"nums\"):\n        _, expr = data.split(\"=\", 1)\n        data = expr.strip()\n    return ast.literal_eval(data)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.nextGreaterElements(nums)\n    # Print without spaces after commas to match expected format\n    print('[' + ','.join(map(str, result)) + ']')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1]",
          "expected_output": "[2,-1,2]",
          "success": true,
          "output": "[2,-1,2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,3]",
          "expected_output": "[2,3,4,-1,4]",
          "success": true,
          "output": "[2,3,4,-1,4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode120.json",
    "problem_index_in_file": 0,
    "title": "Triangle",
    "description_snippet": "Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving the minimum path sum in a triangle array. We should provide each step line-by-line with \"虛擬碼步驟\" and comment. Use arrow, decisions. The problem: given triangle, find min sum from top to bottom. Classic DP. Use bottom-up DP, O(n^2). Steps: Start, input triangle, compute dp from bottom row, iterate upward, update dp[i] = min(dp[i], dp[i+1]) + triangle[row][i]. At end dp[0] is answer. Or top-down. Provide decision if triangle empty etc. Use arrow.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: Input triangle // get 2D array\n→ Decision: triangle is empty? // check\n    Yes → Step 2: Return 0 // no elements\n    No → Step 3: Initialize dp as copy of last row // dp[i] = triangle[last][i]\n→ Step 4: For row from second-last to first: // iterate upwards\n    → Step 5: For each index i in that row: // iterate columns\n        → Step 6: Update dp[i] = triangle[row][i] + min(dp[i], dp[i+1]) // combine current and two possible next positions\n→ Step 7: Return dp[0] // minimal path sum\n\nUse arrows and decisions.\n\nWe should include each line, e.g.\n\nStart // 程式開始執行\n→ Step 1: 讀取三角陣列 // 獲取輸入\n→ Decision: 如果三角陣列為空？ // 檢查是否無元素\n    Yes → Step 2: 回傳 0 // 空陣列返回 0\n    No  → Step 3: 初始化 dp 為最後一行的副本 // dp[i] = triangle[last][i]\n→ Step 4: 從倒數第二行往上迭代\n    → Step 5: 對每個索引 i\n        → Step 6: dp[i] = triangle[row][i] + min(dp[i], dp[i+1]) // 更新最小和\n→ Step 7: 回傳 dp[0] // 最小路徑總和\n\nNeed to keep format: each line separated, with arrow if inside loops, decision indentation. We need to use \"→\" for steps, \"Decision:\" etc. Should maintain indentation using spaces maybe. The example shows indentation by spaces: Decision: ... Then lines inside have indented spaces. Use two spaces maybe. Let's produce. Ensure we don't output actual code but virtual steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取三角陣列 // 獲取輸入  \n→ Decision: 如果三角陣列為空？ // 檢查是否無元素  \n&nbsp;&nbsp;Yes → Step 2: 回傳 0 // 空陣列直接回傳 0  \n&nbsp;&nbsp;No  → Step 3: 初始化 dp 為最後一行的副本 // dp[i] = triangle[last][i]  \n→ Step 4: 從倒數第二行往上迭代 // 逐行更新最小路徑  \n&nbsp;&nbsp;→ Step 5: 對每個索引 i  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: dp[i] = triangle[row][i] + min(dp[i], dp[i+1]) // 選擇較小的下一行值  \n→ Step 7: 回傳 dp[0] // dp[0] 即為最小路徑總和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef minimum_total(triangle):\n    \"\"\"Return the minimum path sum from top to bottom of a triangle.\"\"\"\n    if not triangle:\n        return 0\n    # Copy the last row; it will be updated in-place as we move up the triangle\n    dp = triangle[-1][:]\n    # Iterate from the second-last row up to the first row\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            # For each position, choose the smaller of the two adjacent numbers\n            # in the row below and add the current number\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n    return dp[0]\n\ndef solve() -> None:\n    \"\"\"Read input from stdin, compute the result, and print it.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # The input format is expected to be something like:\n    # triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n    # Extract the part after '=' (if present) and evaluate it safely\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # Parse the list of lists representing the triangle\n    triangle = ast.literal_eval(expr)\n\n    # Compute the minimum total and print it\n    result = minimum_total(triangle)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        },
        {
          "example_index": 1,
          "input": "triangle = [[-10]]",
          "expected_output": "-10",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode506.json",
    "problem_index_in_file": 0,
    "title": "Relative Ranks",
    "description_snippet": "You are given an integer array score of size n, where score[i] is the score of the i_th athlete in a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. The problem: given unique scores array, assign rank strings: Gold, Silver, Bronze, or numeric string of rank. Need to output array answer where answer[i] is rank of ith athlete. Standard solution: sort indices by score descending, then assign rank to each. So pseudo steps:\n\nStart\n→ Step 1: Initialize n = length of score\n→ Step 2: Create list of pairs (index, score)\n→ Step 3: Sort pairs by score descending\n→ Step 4: Initialize answer array of size n\n→ Step 5: For i from 0 to n-1:\n    → Decision: if i == 0? // first place\n        Yes → Step: answer[ pairs[i].index ] = \"Gold Medal\"\n        No → Decision: if i == 1? // second\n            Yes → answer[ pairs[i].index ] = \"Silver Medal\"\n            No → Decision: if i == 2? // third\n                Yes → answer[ pairs[i].index ] = \"Bronze Medal\"\n                No → answer[ pairs[i].index ] = string(i+1) // rank number\n→ End.\n\nWe need each line with explanation after //.\n\nLet's ensure each line includes the arrow syntax. Use \"Start\" and \"End\".\n\nMake sure to format as described. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 n = score 的長度 // 先知道陣列長度  \n→ Step 2: 建立 pairs = 空列表 // 用來存 (index, score)  \n→ Step 3: 對於 i 從 0 到 n-1:\n  → pairs.Add( (i, score[i]) ) // 把索引跟分數對應起來  \n→ Step 4: 將 pairs 依 score 降序排序 // 最高分先來  \n→ Step 5: 建立 answer = 空陣列長度 n // 用來存排名結果  \n→ Step 6: 對於 i 從 0 到 n-1:\n  → Decision: 如果 i == 0? // 第一名  \n    Yes → answer[ pairs[i].index ] = \"Gold Medal\" // 送金牌  \n    No  → Decision: 如果 i == 1? // 第二名  \n      Yes → answer[ pairs[i].index ] = \"Silver Medal\" // 送銀牌  \n      No  → Decision: 如果 i == 2? // 第三名  \n       Yes → answer[ pairs[i].index ] = \"Bronze Medal\" // 送銅牌  \n       No  → answer[ pairs[i].index ] = string(i+1) // 其餘輸出名次  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass Solution:\n    def findRelativeRanks(self, score):\n        \"\"\"Return rank list for each athlete.\"\"\"\n        if not score:\n            return []\n        # 1. Sort scores in descending order\n        sorted_scores = sorted(score, reverse=True)\n        # 2. Map each score to its rank string\n        rank_map = {}\n        for i, s in enumerate(sorted_scores):\n            if i == 0:\n                rank_map[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_map[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_map[s] = \"Bronze Medal\"\n            else:\n                rank_map[s] = str(i + 1)\n        # 3. Build result in original order\n        return [rank_map[s] for s in score]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 轉換字串為 Python 列表\n    try:\n        score_list = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，直接輸出空列表\n        score_list = []\n    # 呼叫解法\n    result = Solution().findRelativeRanks(score_list)\n    # 以 JSON 格式輸出，保留雙引號\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[5,4,3,2,1]",
          "expected_output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]",
          "success": true,
          "output": "[\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]"
        },
        {
          "example_index": 1,
          "input": "[10,3,8,9,4]",
          "expected_output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]",
          "success": true,
          "output": "[\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode451.json",
    "problem_index_in_file": 0,
    "title": "Sort Characters By Frequency",
    "description_snippet": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequenc...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The algorithm: count frequencies using map, sort characters by freq descending, then build output string by repeating char freq times. Provide steps with arrows. No actual code, only pseudocode steps.\n\nLet's write:\n\nStart\n→ Step 1: Initialize frequency_map as empty // create map\n→ Step 2: For each char c in s, increment frequency_map[c] // count frequencies\n→ Decision: frequency_map is empty? // if s empty\n    Yes → Step 3: Return empty string // nothing to output\n    No  → Step 4: Create list of (char, freq) from frequency_map // pair list\n→ Step 5: Sort list by freq descending // ordering\n→ Step 6: Initialize result as empty string // output string\n→ For each (char, freq) in sorted list:\n    → Step 7: Append char repeated freq times to result // build string\n→ Step 8: Return result // final output\nEnd\n\nNeed to follow arrow style exactly: use →, Yes →, No →. Each line include explanation comment after //.\n\nAlso include indentation? Not necessary but we can indent for decisions.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize frequency_map as empty // 建立空字典以存放字元頻率  \n→ Step 2: For each char c in s, increment frequency_map[c] // 對字串中的每個字元計算出現次數  \n→ Decision: frequency_map is empty? // 檢查字串是否為空  \n    Yes → Step 3: Return empty string // 若字串為空，直接回傳空字串  \n    No  → Step 4: Create list of (char, freq) from frequency_map // 轉成字元與頻率的列表  \n→ Step 5: Sort list by freq descending // 按頻率從高到低排序  \n→ Step 6: Initialize result as empty string // 用於儲存最終排序後的字串  \n→ For each (char, freq) in sorted list: // 逐個處理排序後的字元  \n    → Step 7: Append char repeated freq times to result // 依頻率把字元重複加入結果  \n→ Step 8: Return result // 回傳完成的排序字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef parse_input(text: str) -> str:\n    \"\"\"\n    從輸入文字中提取字串值。\n    允許形如 `s = \"tree\"` 或直接給出 `\"tree\"` 的輸入。\n    \"\"\"\n    text = text.strip()\n    # 先嘗試解析帶變數名的格式\n    m = re.search(r's\\s*=\\s*[\"\\'](.*)[\"\\']', text)\n    if m:\n        return m.group(1)\n    # 再嘗試直接找引號中的內容\n    m = re.search(r'[\"\\'](.*)[\"\\']', text)\n    if m:\n        return m.group(1)\n    # 若沒有引號，直接返回整個輸入（如僅輸入 tree）\n    return text\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"\n    依字元出現頻率遞減排序並組成新字串。\n    \"\"\"\n    cnt = Counter(s)\n    # most_common 會以頻率遞減返回 (char, freq) 的列表\n    return ''.join(char * freq for char, freq in cnt.most_common())\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 解析出需要處理的字串\n    s = parse_input(raw_input)\n    # 執行排序演算法\n    result = frequency_sort(s)\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eetr\"",
          "success": true,
          "output": "eetr"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"cccaaa\"",
          "success": true,
          "output": "cccaaa"
        },
        {
          "example_index": 2,
          "input": "s = \"Aabb\"",
          "expected_output": "\"bbAa\"",
          "success": true,
          "output": "bbAa"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode336.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Pairs",
    "description_snippet": "You are given a 0-indexed array of unique strings words.\n\nA palindrome pair is a pair of integers (i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm to find palindrome pairs in O(total length). This is typical problem: for each word, we consider prefixes and suffixes, and store reversed words in hash map, check for splits. Complexity O(total length). We'll write pseudocode lines with explanation. Use Start, End, Decision, etc. Ensure each line ends with // explanation.\n\nLet's produce step-by-step.\n\nStart\n→ Step 1: 建立哈希表 map，鍵為詞語的倒序，值為該詞在 words 陣列中的索引 // 用於快速查找反向詞\n→ Step 2: 初始化結果 list pairs // 用於儲存符合條件的索引對\n→ Step 3: 遍歷 words，對於每個索引 i 和詞 word // 主迴圈\n    → Step 3a: 取得 word 長度 n\n    → Step 3b: 對於分割位置 cut 從 0 到 n（包括 n）進行迴圈 // 包含全字母分割\n        → Decision: 前綴 word[0:cut] 是否為回文？ // 檢查左側\n            Yes → 取反向前綴 revPre = reverse(word[cut:]) // 從分割點到末尾\n                 → Decision: revPre 是否存在於 map 且 map[revPre] != i？ // 找到匹配的右側詞\n                     Yes → Step 3b1: 加入 (map[revPre], i) 到 pairs // 右側詞 + word 形成回文\n                     No  → No action\n            No  → No action\n        → Decision: 後綴 word[cut:] 是否為回文？ // 檢查右側\n            Yes → 取反向後綴 revSuf = reverse(word[0:cut]) // 從開頭到分割點\n                 → Decision: revSuf 是否存在於 map 且 map[revSuf] != i？\n                     Yes → Step 3b2: 加入 (i, map[revSuf]) 到 pairs // word + 右側詞形成回文\n                     No  → No action\n            No  → No action\n    → Step 3c: 特殊處理：當 word 本身為回文且空字符串在 map 中存在，避免重複\nEnd\n\nNeed to incorporate handling of empty string. Use step 3d.\n\nBut we must maintain O(total length). The loops are within each word's length. So overall O(total length). Provide pseudocode accordingly.\n\nLet's produce final output. Ensure each line has the arrow and explanation. Use indentation.\n\nAlso use arrow → for steps. Use Decision: for branching. Indent inside decisions with 4 spaces maybe.\n\nWe need to include lines for building map, result list, main loop, etc.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立哈希表 map，鍵為 words[i] 的倒序，值為 i // 方便快速查找反向詞  \n→ Step 2: 初始化空列表 pairs 用於儲存所有 (i, j)  \n→ Step 3: 遍歷 words，對每個索引 i 與詞 word  \n    → Step 3a: 設置 n = len(word) // 詞長度  \n    → Step 3b: 對於切割位置 cut 從 0 到 n（含 n）  \n        → Decision: 前綴 word[0:cut] 是否為回文？ // 檢查左側是否已經對稱  \n            Yes → Step 3b1: 取 revPre = reverse(word[cut:]) // 從切割點到結尾的反向  \n                → Decision: revPre 是否存在於 map 且 map[revPre] != i？ // 找到匹配右側詞  \n                    Yes → Step 3b1a: 加入 (map[revPre], i) 到 pairs // 右側詞 + word 為回文  \n                    No → No action  \n            No → No action  \n        → Decision: 後綴 word[cut:] 是否為回文？ // 檢查右側是否已經對稱  \n            Yes → Step 3b2: 取 revSuf = reverse(word[0:cut]) // 從開頭到切割點的反向  \n                → Decision: revSuf 是否存在於 map 且 map[revSuf] != i？ // 找到匹配左側詞  \n                    Yes → Step 3b2a: 加入 (i, map[revSuf]) 到 pairs // word + 右側詞為回文  \n                    No → No action  \n            No → No action  \n    → Step 3c: 若 word 本身為回文且空字串 \"\" 在 map 中，且 map[\"\"] != i，加入 (i, map[\"\"]) 和 (map[\"\"], i) // 處理空字串特殊情況  \nEnd // 程式執行結束並返回 pairs",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立以反向詞為鍵、索引為值的字典\n        rev_dict = {w[::-1]: i for i, w in enumerate(words)}\n        res = []\n        # 遍歷每個詞\n        for i, word in enumerate(words):\n            n = len(word)\n            # 分割點從 0 到 n（含 n）\n            for cut in range(n + 1):\n                prefix = word[:cut]\n                suffix = word[cut:]\n\n                # 前綴為回文時，檢查反向後綴是否存在\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    j = rev_dict.get(rev_suffix)\n                    if j is not None and j != i:\n                        res.append([j, i])\n\n                # 後綴為回文時（且 cut != n 防止重複），檢查反向前綴\n                if cut != n and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    j = rev_dict.get(rev_prefix)\n                    if j is not None and j != i:\n                        res.append([i, j])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入，例如 \"words = ['abcd','dcba']\"\n    if data.startswith(\"words\"):\n        _, words_part = data.split(\"=\", 1)\n        words_str = words_part.strip()\n    else:\n        words_str = data\n    # 使用 ast.literal_eval 以安全方式解析列表字面量\n    words = ast.literal_eval(words_str)\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode386.json",
    "problem_index_in_file": 0,
    "title": "Lexicographical Numbers",
    "description_snippet": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm: given n, return all numbers 1..n sorted lexicographically, O(n) time, O(1) space.\n\nWe need to produce step-by-step algorithm description, not actual code. Use virtual code lines, each with // explanation. Use arrows and decisions.\n\nWe should design algorithm: Use DFS lexicographic traversal: start with current=1; output current; then try to go deeper: current*=10 while current <= n; else backtrack to increment until next multiple of 10. Equivalent to lexicographic order traversal. This uses O(1) space (only current and next). Complexity O(n) because each number printed once, each increment operation constant. We can produce algorithm steps.\n\nSo steps: Start, set current=1, loop until count==n. Output current. If current*10 <= n, set current*=10 else if current%10 != 9 and current+1 <= n, set current++ else while current%10==9 or current+1>n, current/=10; if current==0 break; else current++.\n\nSimplify algorithm: Use for loop i from 1 to n: output i. Use while loop to compute next lexicographic number: if i*10 <= n, i*=10; else while i%10==9 or i+1>n: i/=10; i++; return i. Use O(1) space.\n\nBut we need algorithm steps.\n\nLet's produce virtual code:\n\nStart // 程式開始執行\n→ Step 1: 初始化變數 current = 1, count = 0 // 設定目前數字與已輸出數量\n→ Decision: 如果 count < n? // 檢查是否已輸出所有數字\n    Yes → Step 2: 輸出 current // 輸出目前的數字\n    → Step 3: count = count + 1 // 更新已輸出數量\n    → Step 4: Decision: 如果 current * 10 <= n? // 試著進入下一層前綴\n        Yes → Step 5: current = current * 10 // 進入下一層\n        No  → Decision: 如果 current % 10 != 9 且 current + 1 <= n? // 可能直接遞增\n            Yes → Step 6: current = current + 1 // 直接遞增到下一個同層數字\n            No  → Step 7: Decision: 如果 current % 10 == 9? // 檢查是否在尾端\n                Yes → Step 8: current = current / 10 // 回溯到上一層\n                No  → Step 8: current = current / 10 // 同樣回溯，因為無法遞增\n                // After回溯，執行 Step 9: current = current + 1 // 移動到下一個兄弟節點\n                → Step 9: current = current + 1\n    → End // 完成一次迴圈\n→ End // 迴圈結束後全部輸出完畢\nEnd // 程式結束\n\nBut we need to include the loop in steps. Maybe use Decision: while count < n.\n\nLet's craft a clear algorithm: Use while loop:\n\nStart\n→ Step 1: current ← 1, count ← 0\n→ Decision: count < n? // loop condition\n    Yes → Step 2: output current\n          Step 3: count ← count + 1\n          Decision: current * 10 ≤ n?\n              Yes → Step 4: current ← current * 10\n              No  → Decision: current % 10 ≠ 9 and current + 1 ≤ n?\n                    Yes → Step 5: current ← current + 1\n                    No  → Step 6: current ← current / 10\n                          Step 7: current ← current + 1\n          // loop back to decision\n    No → End // loop exit\nEnd\n\nBut Step 6 and 7 need to consider repeated /10 until not trailing 9 or until <1? We can express as while loop but O(1) space.\n\nSimplify: Use while true:\n\nWe can use nested loops: After failing to multiply by 10, we need to find next number in lexicographic order. That is basically:\n\nwhile (current % 10 == 9 || current + 1 > n) {\n    current /= 10;\n}\ncurrent++;\n\nBut that uses loop. But we need to keep O(1) space.\n\nSo we can encode as Decision: If current % 10 == 9 or current+1 > n, then loop back. But we can express this as a loop: While (current%10==9 || current+1>n) { current /=10; }. But that's still fine.\n\nWe'll represent with nested decisions.\n\nLet's produce step-by-step:\n\nStart // 程式開始執行\n→ Step 1: current ← 1, count ← 0 // 初始化\n→ Decision: count < n? // 是否還未輸出完\n    Yes → Step 2: output current // 輸出\n          Step 3: count ← count + 1\n          Decision: current * 10 ≤ n? // 可進入下一層\n              Yes → Step 4: current ← current * 10 // 進入\n              No  → Step 5: Decision: current % 10 ≠ 9 AND current + 1 ≤ n?\n                    Yes → Step 6: current ← current + 1 // 直接遞增\n                    No  → Step 7: Decision: current % 10 == 9? // 若尾端 9\n                            Yes → Step 8: current ← current / 10 // 回溯\n                            No  → Step 8: current ← current / 10 // 同樣回溯\n                            Step 9: current ← current + 1 // 移到兄弟\n            // After any adjustment, loop back\n    No  → End // 退出\nEnd\n\nBut Step 7 includes the same as 8. Maybe we can use while loop representation: while (current % 10 == 9 || current + 1 > n) { current /=10; }. Then current++.\n\nLet's produce a clearer algorithm:\n\nStart\n→ Step 1: current ← 1; count ← 0\n→ Decision: count < n?\n    Yes → Step 2: output current\n          Step 3: count ← count + 1\n          Decision: current * 10 ≤ n?\n              Yes → Step 4: current ← current * 10\n              No  → Step 5: Decision: current % 10 = 9 OR current + 1 > n?\n                    Yes → Step 6: while current % 10 = 9 OR current + 1 > n:\n                                 current ← current / 10\n                              Step 7: current ← current + 1\n                    No  → Step 8: current ← current + 1\n          // loop back\n    No  → End\nEnd\n\nThis algorithm uses O(1) space and O(n) time.\n\nLet's craft final output with each line having code step and comment.\n\nWe need to use virtual code arrow. Each line like: Start // 程式開始執行\n\nMake sure indentation is correct. Use spaces.\n\nWill produce:\n\nStart // 程式開始執行\n→ Step 1: current ← 1, count ← 0 // 初始化變數\n→ Decision: count < n? // 是否還有數字要輸出\n    Yes → Step 2: output current // 輸出目前數字\n          → Step 3: count ← count + 1 // 已輸出數量加一\n          → Decision: current * 10 ≤ n? // 可否進一步深層\n              Yes → Step 4: current ← current * 10 // 進入下一層\n              No  → Decision: current % 10 = 9 OR current + 1 > n? // 是否需要回溯\n                  Yes → Step 5: while current % 10 = 9 OR current + 1 > n:\n                              → current ← current / 10 // 回溯到父節點\n                          → Step 6: current ← current + 1 // 移到兄弟節點\n                  No  → Step 7: current ← current + 1 // 直接遞增\n          // 迴圈結束後重新判斷\n    No  → End // 所有數字已輸出\nEnd // 程式結束\n\nBut we need to show each step in separate line, with arrow at beginning for steps inside decisions. The while loop is not an actual code; we can represent as nested Decision: while? We'll approximate.\n\nBetter: Use nested Decision loops.\n\nSimplify: Represent the while loop as:\n\n→ Decision: current % 10 = 9 OR current + 1 > n?\n    Yes → Step 5: current ← current / 10 // 回溯\n          → Decision: current % 10 = 9 OR current + 1 > n?\n              Yes → Repeat // 迴圈\n              No  → Step 6: current ← current + 1 // 移到兄弟\n    No  → Step 6: current ← current + 1\n\nBut this is confusing.\n\nMaybe we can encode as:\n\n→ Decision: current % 10 = 9 OR current + 1 > n?\n    Yes → Step 5: current ← current / 10 // 回溯\n          → Decision: current % 10 = 9 OR current + 1 > n?\n              Yes → repeat Step 5\n              No  → Step 6: current ← current + 1\n    No  → Step 6: current ← current + 1\n\nBut this replicates loop.\n\nSimpler: Use a separate loop step:\n\n→ Step 5: while current % 10 = 9 OR current + 1 > n:\n            current ← current / 10 // 回溯\n        // 之後再執行\n→ Step 6: current ← current + 1 // 移到兄弟\n\nBut the requirement is \"虛擬碼步驟\" each line. We can have step with while. But \"while\" is not defined in the instruction. But we can use Decision and loops.\n\nGiven requirement: Use virtual code arrow and structure like Decision: , Start, End. They didn't mention while but we can use Decision loops.\n\nLet's just use Decision: \"current % 10 = 9 OR current + 1 > n?\" and then have nested loops.\n\nAlternatively, we can present algorithm as DFS recursion but no recursion (since O(1) space). But DFS recursion uses O(log n) stack, not allowed.\n\nThus we produce algorithm with incremental generation.\n\nLet's produce final answer:\n\nStart // 程式開始執行\n→ Step 1: current ← 1; count ← 0 // 初始化變數\n→ Decision: count < n? // 是否還有數字要輸出\n    Yes → Step 2: output current // 輸出目前數字\n          → Step 3: count ← count + 1 // 已輸出數量加一\n          → Decision: current * 10 ≤ n? // 能否進一步深層\n              Yes → Step 4: current ← current * 10 // 進入下一層\n              No  → Decision: current % 10 = 9 OR current + 1 > n? // 是否需要回溯\n                  Yes → Step 5: current ← current / 10 // 回溯到父節點\n                        → Decision: current % 10 = 9 OR current + 1 > n? // 重複回溯\n                            Yes → repeat Step 5 // 迴圈回溯\n                            No  → Step 6: current ← current + 1 // 移到兄弟節點\n                  No  → Step 6: current ← current + 1 // 直接遞增\n          // 重新回到 Decision: count < n?\n    No  → End // 所有數字已輸出\nEnd // 程式結束\n\nBut we used \"repeat Step 5\" which is not a step. We could express using nested decisions that automatically loop until condition false, but might be confusing.\n\nAlternate: Use a Decision with while structure:\n\n→ Decision: current % 10 = 9 OR current + 1 > n?\n    Yes → Step 5: current ← current / 10 // 回溯\n          → Decision: current % 10 = 9 OR current + 1 > n?\n              Yes → repeat Step 5\n              No  → Step 6: current ← current + 1\n    No  → Step 6: current ← current + 1\n\nBetter to use a separate step representing the loop:\n\n→ Step 5: while current % 10 = 9 OR current + 1 > n:\n            current ← current / 10 // 回溯\n        // loop ends when condition false\n→ Step 6: current ← current + 1 // 移到兄弟節點\n\nBut \"while\" may not be allowed but it's a natural representation.\n\nGiven the instruction, they didn't restrict use of while, but used \"Decision:\" and arrows. They said use arrows and structure like Decision. But we can use while.\n\nLet's produce with while lines.\n\nThus final output lines:\n\nStart // 程式開始執行\n→ Step 1: current ← 1; count ← 0 // 初始化變數\n→ Decision: count < n? // 判斷是否還有數字需要輸出\n    Yes → Step 2: output current // 輸出目前數字\n          → Step 3: count ← count + 1 // 已輸出數量加一\n          → Decision: current * 10 ≤ n? // 能否進一步進入子前綴\n              Yes → Step 4: current ← current * 10 // 進入下一層\n              No  → Step 5: while current % 10 = 9 OR current + 1 > n:\n                              current ← current / 10 // 回溯到父節點\n                          // 循環直到不滿條件\n                          → Step 6: current ← current + 1 // 移到兄弟節點\n          // 回到 Decision: count < n?\n    No  → End // 所有數字已輸出\nEnd // 程式結束\n\nBut we need each line separated with arrow. Step 5 is multi-line with while loop; maybe separate each sub-step:\n\nStep 5a: while current % 10 = 9 OR current + 1 > n?\n    Yes → Step 5b: current ← current / 10 // 回溯\n        → repeat Step 5a\n    No  → Step 5c: current ← current + 1 // 移到兄弟節點\n\nBut this becomes too nested.\n\nSimplify: Provide a clear step sequence, using decision loops.\n\nLet's propose final algorithm:\n\nStart // 程式開始執行\n→ Step 1: current ← 1; count ← 0 // 初始化\n→ Decision: count < n? // 有沒有輸出完\n    Yes → Step 2: output current // 輸出\n          → Step 3: count ← count + 1\n          → Decision: current * 10 ≤ n? // 能否深入\n              Yes → Step 4: current ← current * 10 // 進入\n              No  → Decision: current % 10 = 9 OR current + 1 > n?\n                      Yes → Step 5: current ← current / 10 // 回溯\n                            → Decision: current % 10 = 9 OR current + 1 > n?\n                                Yes → repeat Step 5\n                                No  → Step 6: current ← current + 1 // 移到兄弟\n                      No  → Step 6: current ← current + 1 // 直接遞增\n          // 回到 Decision: count < n?\n    No  → End // 完成\nEnd\n\nBut we repeated Step 6 for both Yes/No cases; okay.\n\nBut we used \"repeat Step 5\" which is not a line.\n\nBetter to use while representation:\n\nStep 5: while current % 10 = 9 OR current + 1 > n:\n            current ← current / 10 // 回溯\n\nBut they said no actual code, just virtual. So while is okay.\n\nThus final answer: Provide each line as above. Use spaces after arrow. Provide explanation after //.\n\nLet's craft final answer carefully, ensuring each line ends with // explanation. Ensure that decisions have indentation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: current ← 1; count ← 0 // 初始化變數，current 為目前正在輸出的數字，count 為已輸出數量\n→ Decision: count < n? // 判斷是否還有數字需要輸出\n    Yes → Step 2: output current // 輸出目前的數字\n          → Step 3: count ← count + 1 // 已輸出數量加一\n          → Decision: current * 10 ≤ n? // 能否進一步進入下一層前綴\n              Yes → Step 4: current ← current * 10 // 進入下一層（把 current 乘 10）\n              No  → Step 5: while current % 10 = 9 OR current + 1 > n:\n                              → current ← current / 10 // 回溯到父節點，直到不滿條件\n                          // 迴圈結束後，current 已經指向一個可以遞增的節點\n                          → Step 6: current ← current + 1 // 移到同層的下一個兄弟節點\n          // 重新回到 Decision: count < n?\n    No  → End // 所有數字已輸出，結束迴圈\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    result = []\n    current = 1\n    count = 0\n    while count < n:\n        result.append(current)\n        count += 1\n        if current * 10 <= n:               # 進入下一層前綴\n            current *= 10\n        else:\n            # 回溯到能遞增的節點\n            while (current % 10 == 9) or (current + 1 > n):\n                current //= 10\n            current += 1\n    return result\n\ndef main():\n    data = sys.stdin.read()\n    m = re.search(r'\\d+', data)\n    if not m:\n        return\n    n = int(m.group())\n    res = lexical_order(n)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "success": true,
          "output": "[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode10.json",
    "problem_index_in_file": 0,
    "title": "Regular Expression Matching",
    "description_snippet": "Given an input string s and a pattern p, implement regular expression matching with support for '.' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for regex matching. Provide line-by-line steps with explanation, using Start, Decision, etc. We need to implement algorithm: DP or recursion with memo. We'll produce a virtual algorithm description: Start, initialize DP table (m+1)x(n+1) booleans. Set dp[0][0] true. For i=0 to m, j iterate. Use pattern index j, string index i. Fill dp[i][j] based on pattern char. Use rules: if pattern[j-1] == '*', then check dp[i][j-2] or if matches, dp[i-1][j]. else if match (s[i-1]==p[j-1] or p[j-1]=='.'), dp[i-1][j-1]. At the end return dp[m][n].\n\nWe will output lines accordingly, with each step as virtual code with comment. Use arrow notation. Provide decisions: if char == '*', etc. We'll produce enough steps but not too many. Use loops for initialization and for filling DP. Use decision branching inside loops.\n\nLet's craft:\n\nStart\n→ Initialize variables: m ← length(s), n ← length(p)\n→ Create 2D array dp of size (m+1)×(n+1) with all false\n→ Set dp[0][0] ← true\n→ Decision: 是否需要處理空字符串和包含 '*' 的模式？ // Explanation: initialize first row for patterns that can match empty string\n    → For j from 1 to n\n        → Decision: 如果 p[j-1] == '*'? // Check if current pattern char is '*'\n            → Yes → dp[0][j] ← dp[0][j-2] // '*' can match zero preceding element\n            → No → dp[0][j] ← false // no effect\n→ Loop: for i from 1 to m\n    → Loop: for j from 1 to n\n        → Decision: 如果 p[j-1] == '*'? // '*' handling\n            → Yes →\n                → Decision: dp[i][j-2] is true? // zero occurrence\n                    → Yes → dp[i][j] ← true\n                    → No →\n                        → Decision: s[i-1] matches p[j-2] (p[j-2] == s[i-1] or p[j-2] == '.')? // one or more occurrence\n                            → Yes → dp[i][j] ← dp[i-1][j] // keep '*' active\n                            → No → dp[i][j] ← false\n            → No →\n                → Decision: s[i-1] matches p[j-1] (p[j-1] == s[i-1] or p[j-1] == '.')? // single character match\n                    → Yes → dp[i][j] ← dp[i-1][j-1]\n                    → No → dp[i][j] ← false\n→ Return dp[m][n] // 完成匹配判斷\n\nWe must keep each line as virtual code line with comment. We need to separate each step. Use arrow after each line. Provide explanation comments. Use Start, End.\n\nLet's output accordingly. Ensure each line follows format: \"虛擬碼步驟 // 解釋/說明\".\n\nUse \"→\" at start of each step after Start. Indentation for nested loops? We can use indentation or just continue. We'll include indentation to show nested structure. The example didn't use indentation but used new lines with arrows. We can use indentation by adding spaces before arrow maybe. But to keep simple, we can use arrows for each line. For nested decisions, we can include nested arrows with additional arrow \"→\" maybe but example uses \"Yes →\" and \"No →\". We'll follow similar style.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ m ← length(s) // 取得輸入字串長度  \n→ n ← length(p) // 取得模式字串長度  \n→ dp ← 2D boolean array of size (m+1)×(n+1) // 建立 DP 表格  \n→ Set dp[0][0] ← true // 空字串與空模式匹配  \n\n→ Decision: 是否需要處理空字串和含「*」的模式？  \n    Yes →  \n        → for j ← 1 to n  \n            → Decision: p[j-1] == '*'?  \n                Yes → dp[0][j] ← dp[0][j-2] // '*' 可以匹配前面元素零次  \n                No  → dp[0][j] ← false // 其他情況不匹配空字串  \n\n→ for i ← 1 to m  \n    → for j ← 1 to n  \n        → Decision: p[j-1] == '*'?  \n            Yes →  \n                → Decision: dp[i][j-2] is true? // '*' 用零次匹配  \n                    Yes → dp[i][j] ← true  \n                    No  →  \n                        → Decision: s[i-1] matches p[j-2] (p[j-2]==s[i-1] OR p[j-2]=='.')?  \n                            Yes → dp[i][j] ← dp[i-1][j] // '*' 用一次或多次匹配  \n                            No  → dp[i][j] ← false  \n            No →  \n                → Decision: s[i-1] matches p[j-1] (p[j-1]==s[i-1] OR p[j-1]=='.')?  \n                    Yes → dp[i][j] ← dp[i-1][j-1] // 單字符匹配  \n                    No  → dp[i][j] ← false  \n\n→ Return dp[m][n] // 回傳整個字串是否完全匹配  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # Patterns that can match an empty string (like a* or a*b*)\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    # Two possibilities: treat '*' as zero occurrence, or\n                    # use it to match one more character if preceding element matches.\n                    dp[i][j] = dp[i][j - 2]\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n                else:\n                    # Direct match (including '.')\n                    if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                        dp[i][j] = dp[i - 1][j - 1]\n        return dp[m][n]\n\ndef parse_input(text: str):\n    \"\"\"\n    Attempts to extract two quoted strings from the input.\n    The input can be either:\n        s = \"aa\", p = \"a\"\n    or two separate lines each containing a quoted string.\n    \"\"\"\n    # Find all quoted substrings\n    parts = re.findall(r'\"([^\"]*)\"', text)\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # Fallback: try to split by lines and strip\n    lines = [line.strip() for line in text.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # If only one line with two strings separated by comma\n    if ',' in text:\n        left, right = text.split(',', 1)\n        left = left.strip().strip('\"')\n        right = right.strip().strip('\"')\n        return left, right\n    # Default to empty strings if parsing fails\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    s, p = parse_input(raw_input)\n    sol = Solution()\n    result = sol.isMatch(s, p)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"a*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\", p = \".*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode518.json",
    "problem_index_in_file": 0,
    "title": "Coin Change II",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the coin change combinations problem. The algorithm typical: dynamic programming 1D dp[0..amount] where dp[0]=1, for each coin iterate for i from coin to amount: dp[i] += dp[i-coin]. Finally return dp[amount].\n\nWe need to produce step-by-step virtual code. The user didn't specify input details, but assume: Start, Step: input coins array, amount. Use dp array. Iterate over coins, nested loops. Use Decision to maybe check if amount==0 then return 1? Also handle amount<0? But typical. Let's produce.\n\nWe must adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrow. Use Start, End, Decision. We'll include input steps, initialization, loops, condition, final output.\n\nLet's produce:\n\nStart\n→ Step 1: Input coins array and amount // 取得硬幣種類和目標金額\n→ Decision: 如果 amount < 0? // 金額為負時無解\n    Yes → Step 2: Return 0 // 直接回傳 0\n    No  →\n→ Step 3: 初始化 dp 陣列長度 amount+1 並把 dp[0] 設為 1 // 代表凑成 0 的方式為 1 (不取任何硬幣)\n→ Decision: 迭代每一枚硬幣 coin in coins? // 逐個硬幣處理\n    Yes → Step 4: For i from coin 到 amount 步進 1 // 只考慮能夠凑到的金額\n        → Step 5: dp[i] = dp[i] + dp[i - coin] // 加上以此硬幣結尾的組合數\n    No  → \n→ Step 6: Return dp[amount] // 目標金額的組合數\nEnd\n\nNeed to format with indentation for Decision branches. Provide arrow formatting. Use `Yes →`, `No →`. For loops maybe use \"For i in range(coin, amount+1):\". Provide explanation after each. Provide indentation for loops. Let's craft.\n\nCheck requirement: each line must include `虛擬碼步驟` + space + `// 解釋`. Use arrows. For nested structures, indent subsequent lines. Use maybe `→` to start substeps. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input coins array and amount // 取得硬幣種類與目標金額  \n→ Decision: 如果 amount < 0? // 金額為負時無法凑成  \n Yes → Step 2: Return 0 // 直接回傳 0  \n No  →  \n→ Step 3: 初始化 dp 陣列長度 amount+1 並把 dp[0] 設為 1 // dp[0]=1 代表凑成 0 有一種方式（不取硬幣）  \n→ Decision: 逐枚硬幣進行計算? // 遍歷 coins 陣列  \n Yes → Step 4: For i from coin 到 amount 步進 1 // 只考慮能凑得的金額  \n  → Step 5: dp[i] = dp[i] + dp[i - coin] // 加上以此硬幣結尾的組合數  \n No  →  \n→ Step 6: Return dp[amount] // 回傳目標金額的組合數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def change(self, amount, coins):\n        \"\"\"\n        1D 動態規劃: dp[i] 代表凑成金額 i 的組合數\n        初始化 dp[0] = 1，因為凑 0 有且只有一種方式（不取硬幣）\n        遍歷每一種硬幣，對所有可凑得的金額更新 dp\n        \"\"\"\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n        return dp[amount]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 期望輸入格式: amount, [coin1,coin2,...]\n    amount_part, coins_part = data.split(',', 1)\n    amount = int(amount_part.strip())\n    # 直接 eval 解析硬幣列表，題目保證格式正確\n    coins = eval(coins_part.strip())\n    sol = Solution()\n    result = sol.change(amount, coins)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "5, [1,2,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "3, [2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "10, [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode434.json",
    "problem_index_in_file": 0,
    "title": "Number of Segments in a String",
    "description_snippet": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contigu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting number of segments in string s. Each step line. Steps: Start, input string s. We need to iterate through characters, maintain inSegment flag, count increments when we transition from space to non-space. Use decision etc.\n\nWe output lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化變數 count ← 0, inSegment ← False // 初始化計數與是否在區段\n→ Step 2: 從 s 的首字符開始遍歷到尾字符 // 逐字符處理\n    → Decision: 當前字符是否為空格? // 判斷字符類型\n        Yes → Step 3: inSegment ← False // 空格，離開區段\n        No  → Decision: 是否已在區段? // 判斷是否進入新區段\n            Yes → Step 4: // 在區段內，繼續\n            No  → Step 5: count ← count + 1, inSegment ← True // 開始新區段\n→ Step 6: 返回 count // 結果\n\nBut need to keep arrow structure. Let's format properly:\n\nStart // 程式開始執行\n→ Step 1: count ← 0, inSegment ← False // 初始化計數與標誌\n→ Step 2: i ← 0 // 從第一個字符開始\n→ Decision: i < s.length? // 是否還有字符\n    Yes → Step 3: current ← s[i] // 取得當前字符\n        → Decision: current == ' '?\n            Yes → Step 4: inSegment ← False // 空格，標誌不在區段\n            No  → Decision: inSegment? // 是否已在區段\n                Yes → Step 5: // 已在區段，無需操作\n                No  → Step 6: count ← count + 1, inSegment ← True // 新區段開始\n        → Step 7: i ← i + 1 // 移動到下一個字符\n        → Step 8: 跳回到 Decision: i < s.length?\n    No  → Step 9: 返回 count // 完成，返回段數\nEnd // 程式結束\n\nEnsure each line ends with // 解釋. Good.\n\nNow produce answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: count ← 0, inSegment ← False // 初始化段數與是否在區段的標誌  \n→ Step 2: i ← 0 // 從字串第一個位置開始  \n→ Decision: i < s.length? // 檢查是否還有字元要處理  \n    Yes → Step 3: current ← s[i] // 取得目前字元  \n        → Decision: current == ' ' ? // 判斷是否為空格  \n            Yes → Step 4: inSegment ← False // 空格，離開任何區段  \n            No  → Decision: inSegment ? // 已經在區段嗎？  \n                Yes → Step 5: // 已在區段，保持不變  \n                No  → Step 6: count ← count + 1, inSegment ← True // 開始新區段  \n        → Step 7: i ← i + 1 // 移到下一個字元  \n        → Step 8: 跳回到 Decision: i < s.length? // 重新檢查是否還有字元  \n    No  → Step 9: return count // 所有字元已處理，返回段數  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def countSegments(self, s: str) -> int:\n        \"\"\"\n        Count the number of contiguous non‑space segments in the string `s`.\n        \"\"\"\n        count = 0          # Number of segments found so far\n        in_segment = False # Flag indicating whether we are inside a segment\n\n        for ch in s:\n            if ch == ' ':\n                # We hit a space → we are no longer inside a segment\n                in_segment = False\n            else:\n                if not in_segment:\n                    # Starting a new segment\n                    count += 1\n                    in_segment = True\n                # else: still inside the same segment → nothing to do\n\n        return count\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Try to extract the string inside double quotes, if present\n    if '\"' in raw_input:\n        first_quote = raw_input.find('\"')\n        last_quote = raw_input.rfind('\"')\n        s = raw_input[first_quote + 1:last_quote]\n    else:\n        # If no quotes, remove a leading \"s = \" if present\n        s = raw_input.lstrip()\n        if s.startswith(\"s =\"):\n            s = s[3:].lstrip()\n        s = s.strip('\"')  # Remove any surrounding quotes\n\n    solution = Solution()\n    result = solution.countSegments(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello, my name is John\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"Hello\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode483.json",
    "problem_index_in_file": 0,
    "title": "Smallest Good Base",
    "description_snippet": "Given an integer n represented as a string, return the smallest good base of n.\n\nWe call k >= 2 a go...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: given integer n as string, find smallest good base k >=2 such that representation of n in base k is all 1's. This is known LeetCode 1861: Find smallest good base. Approach: For length of digits m from log2(n)+1 down to 3? Actually we need to consider exponent p+1 digits of 1's: n = (k^p + k^(p-1)+...+1) = (k^(p+1)-1)/(k-1). So for each p from log2(n) down to 2, try solving k from integer root. Also special case k = n-1 gives base with two digits \"11\". So algorithm: if n length 1? but n>=3. So steps:\n\nStart, parse n string to integer big integer maybe using BigInteger. For n= string maybe >2^63. Use BigInteger.\n\nEdge: if n == 1? Not relevant.\n\nCompute limit pmax = floor(log2(n)). For p from pmax down to 2: find k as integer floor of n^(1/p). Use binary search to find k such that sum formula equals n. If found, return k. If not found, after loop return n-1.\n\nNeed to produce virtual steps line by line.\n\nWe should produce virtual code with Start, End, Decision etc. Provide steps of algorithm.\n\nLet's draft:\n\nStart // 開始\n→ Step: 將輸入字串 n 轉為大整數 N // 轉成 BigInteger\n→ Step: 若 N == 3? return 2? Actually general algorithm covers.\n\nCompute maxPower = floor(log2(N)) // 計算最大可能的指數 p\n\n→ Decision: 若 maxPower < 2?  // 若 N 很小\n    Yes → Step: 返回 N-1 // 兩位數 11 的基底\n    No →\n\n→ Loop p from maxPower downto 2\n    → Step: 計算 k 的近似值 = N 的 p 次根 (使用幂根方法)\n    → Decision: 若 k <= 1? continue // 可能不符合\n    → Decision: 若 (k^p + k^(p-1)+...+1) == N?\n        Yes → Step: 返回 k // 找到最小基底\n        No  → Loop next p\n\nAfter loop, Step: 返回 N-1 // 兜底\n\nEnd.\n\nNeed to be more detailed with binary search for k.\n\nWe can break into substeps:\n\n→ Decision: 是否需要使用二分搜尋來尋找 k?  // Always yes for each p\n\n→ Step: 將 low=2, high= N^(1/p) +1 // upper bound\n\n→ Decision: while low <= high\n    → Step: mid = (low+high)/2\n    → Step: calcSum = (mid^(p+1)-1)/(mid-1)\n    → Decision: if calcSum == N\n          Yes → return mid\n          No: if calcSum < N\n                low = mid +1\n            else\n                high = mid -1\n\nBut we can't put loops inside loops? We can just describe pseudo.\n\nWe need to keep each step one line. Use virtual arrows.\n\nWe'll produce lines accordingly.\n\nMake sure each line has explanation after //.\n\nWe'll not output actual code.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 取得輸入字串 n 並轉成大整數 N // 轉為 BigInteger 以處理大數  \n→ Step: 計算最大可能的指數 pmax = ⌊log₂(N)⌋ // 最高位數的上限  \n→ Decision: 若 pmax < 2? // 判斷 n 是否過小（如 3 或 4）  \n    Yes → Step: 回傳 N - 1 // 兩位數 11 的基底（最小解）  \n    No  →  \n→ Loop: p 從 pmax 下降到 2  \n    → Step: 計算 k 的上界 upper = ⌊N^(1/p)⌋ + 1 // 上限估算  \n    → Step: 設定 low = 2, high = upper // 二分搜尋範圍  \n    → Decision: while low ≤ high? // 二分搜尋開始  \n        Yes →  \n            → Step: mid = (low + high) / 2 // 中點 k 值  \n            → Step: 以 mid 计算和 sum = (mid^(p+1) - 1) / (mid - 1) // 等比數列求和  \n            → Decision: if sum == N? // 是否匹配  \n                Yes → Step: 回傳 mid // 找到最小 good base  \n                No →  \n                    → Decision: if sum < N? // 和太小  \n                        Yes → Step: low = mid + 1 // 移到右半段  \n                        No  → Step: high = mid - 1 // 移到左半段  \n            → Decision: 循環結束? // 繼續 while 迴圈  \n        No  → // 二分搜尋結束，未找到此 p 的解  \n    → // p 循環結束  \n→ Step: 回傳 N - 1 // 若所有 p 均無解，兜底返回 n-1（基底 11）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        N = int(n)\n        # 若 N 只有兩位數 \"11\" 的表示，直接返回 N-1\n        if N <= 3:\n            return str(N - 1)\n\n        max_m = N.bit_length()  # 最大可能的位數\n        for m in range(max_m, 1, -1):\n            low, high = 2, N - 1\n            while low <= high:\n                mid = (low + high) // 2\n                # 計算 1 + mid + mid^2 + ... + mid^(m-1)\n                # 使用等比數列求和公式\n                s = (mid ** m - 1) // (mid - 1)\n                if s == N:\n                    return str(mid)\n                elif s < N:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n        return str(N - 1)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # 從輸入中提取數字（可處理形式 n = \"13\" 或僅為 13）\n    match = re.search(r'\\\"(\\d+)\\\"', data)\n    if match:\n        n_str = match.group(1)\n    else:\n        # 若未找到引號，直接提取第一個數字\n        match = re.search(r'(\\d+)', data)\n        n_str = match.group(1) if match else ''\n    if not n_str:\n        return\n    result = Solution().smallestGoodBase(n_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"13\"",
          "expected_output": "\"3\"",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = \"4681\"",
          "expected_output": "\"8\"",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 2,
          "input": "n = \"1000000000000000000\"",
          "expected_output": "\"999999999999999999\"",
          "success": true,
          "output": "999999999999999999"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode326.json",
    "problem_index_in_file": 0,
    "title": "Power of Three",
    "description_snippet": "Given an integer n, return true if it is a power of three. Otherwise, return false.\n\nAn integer n is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in the specified format. It should be line by line, each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use virtual code arrows and structure Start, End, Decision. The logic: Given integer n, return true if power of three.\n\nWe need to produce algorithm steps: Start, Decision: if n <= 0? etc.\n\nSimplest: if n <= 0 then false. Then while n%3==0 divide. After loop, if n==1 true else false.\n\nWrite steps.\n\nWe need to use virtual code arrow for flow.\n\nAlso we can include function definition: \"Function IsPowerOfThree(n):\" then steps inside.\n\nBut keep simple: start of program. Let's produce.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入 n // 取得要檢查的數字\n→ Decision: 如果 n <= 0? // 負數或零不可能是 3 的冪\n    Yes → Step 2: 返回 false // 直接返回 false\n    No  → Decision: 如果 n % 3 != 0? // n 不是 3 的倍數，非 3 的冪\n        Yes → Step 3: 返回 false // 直接返回 false\n        No  → Step 4: 設定 tmp = n // 從 n 開始除\n→ Step 5: while tmp % 3 == 0 // 只要能被 3 整除就除\n    → Step 6: tmp = tmp / 3 // 除以 3\n→ Decision: 如果 tmp == 1? // 除到只剩 1，代表是 3 的冪\n    Yes → Step 7: 返回 true // 是 3 的冪\n    No  → Step 8: 返回 false // 否則不是\nEnd // 程式執行結束\n\nCheck format: each line must contain 虛擬碼步驟 space // explanation.\n\nWe need to use arrow formatting: \"→ Step 1: ...\". We must include the step names with colon and description. In decision, use \"Decision:\". Use indent lines? In sample, they use indentation to show nested decisions. We'll mimic. So indent the lines under decisions with spaces.\n\nImportant: The \"→ Decision:\" lines are at same indentation level as others. Under them, the Yes and No branches lines are indented more, with \"Yes →\" and \"No  →\". After that, subsequent lines at same indentation as the Yes/No lines maybe unindented? In sample, after Yes branch, they indent further? They indent like:\n\n    Yes → Step 2: ...\n    No  → Decision: ...\n\nand then inside that Decision's branches, they indent further:\n\n        Yes → Step 3: ...\n        No  → Step 4: ...\n\nHence we should replicate similar indenting.\n\nLet's produce accordingly. Ensure each line ends with comment after //.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入 n // 取得要檢查的數字  \n\n→ Decision: 如果 n <= 0? // 負數或零不可能是 3 的冪  \n    Yes → Step 2: 返回 false // 直接返回 false  \n    No  → Decision: 如果 n % 3 != 0? // n 不是 3 的倍數，非 3 的冪  \n        Yes → Step 3: 返回 false // 直接返回 false  \n        No  → Step 4: 設定 tmp = n // 從 n 開始除  \n\n→ Step 5: while tmp % 3 == 0 // 只要能被 3 整除就除  \n    → Step 6: tmp = tmp / 3 // 除以 3  \n\n→ Decision: 如果 tmp == 1? // 除到只剩 1，代表是 3 的冪  \n    Yes → Step 7: 返回 true // 是 3 的冪  \n    No  → Step 8: 返回 false // 否則不是  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        \"\"\"判斷 n 是否為 3 的冪.\"\"\"\n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n //= 3\n        return n == 1\n\ndef main() -> None:\n    \"\"\"從 stdin 讀取輸入，輸出判斷結果。\"\"\"\n    # 讀取所有輸入文字\n    data = sys.stdin.read()\n    # 用正則尋找第一個整數（可能帶負號）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        # 若沒有找到整數，直接退出\n        return\n    n = int(match.group(0))\n    sol = Solution()\n    result = sol.isPowerOfThree(n)\n    # 依題目要求輸出小寫 true/false\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 27",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = -1",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode179.json",
    "problem_index_in_file": 0,
    "title": "Largest Number",
    "description_snippet": "Given a list of non-negative integers nums, arrange them such that they form the largest number and ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. The algorithm: sort numbers as strings with custom comparator: compare a+b vs b+a. Then if first char is '0', return \"0\". Else join. So produce steps: Input list, convert to string list, sort with comparator, check first element zero, output join. Also need to consider string conversion. We'll produce pseudo-code steps line by line with explanation. Use Start, End, Decision. Use arrow '→' for actions, 'Yes →', 'No →'. Provide short explanation. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得輸入的非負整數陣列  \n→ Step 1: Convert every number in nums to its string representation → stringNums // 方便字串比較  \n→ Step 2: 定義比較函式 compare(a, b): return a+b > b+a // 判斷兩個字串組合的大小  \n→ Step 3: Sort stringNums 依照 compare 降序排列 // 使排列後的數字能組成最大數  \n→ Decision: 如果 stringNums 第一個字串為 '0'? // 判斷結果是否全為零  \n Yes → Step 4: Return '0' // 所有數字都是 0，直接回傳 \"0\"  \n No  → Step 5: Join all strings in stringNums 為一個長字串 → result // 將排序後的字串連接  \n→ Step 6: Return result // 傳回最終的最大數字字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom functools import cmp_to_key\n\nclass Solution:\n    def largestNumber(self, nums):\n        \"\"\"Arrange the integers to form the largest possible number.\"\"\"\n        # 把每個整數轉成字串，方便字串比較\n        nums_str = list(map(str, nums))\n\n        # 自訂比較器：先比較 x+y 與 y+x 的大小\n        def compare(x, y):\n            if x + y > y + x:\n                return -1   # x 應該排在 y 前面\n            elif x + y < y + x:\n                return 1    # y 應該排在 x 前面\n            else:\n                return 0    # 同等大小\n\n        # 依照比較器排序，得到最大數字組合\n        nums_str.sort(key=cmp_to_key(compare))\n\n        # 如果最高位是 '0'，代表全是 0\n        if nums_str[0] == '0':\n            return '0'\n        return ''.join(nums_str)\n\ndef main():\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 支援輸入形如 \"nums = [10,2]\" 或僅 \"[10,2]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # 解析成 list of int\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        print(\"Invalid input format\")\n        return\n\n    # 取得結果\n    solution = Solution()\n    result = solution.largestNumber(nums)\n\n    # 將結果以雙引號包裹後輸出\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,2]",
          "expected_output": "\"210\"",
          "success": true,
          "output": "\"210\""
        },
        {
          "example_index": 1,
          "input": "nums = [3,30,34,5,9]",
          "expected_output": "\"9534330\"",
          "success": true,
          "output": "\"9534330\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode232.json",
    "problem_index_in_file": 0,
    "title": "Implement Queue using Stacks",
    "description_snippet": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should supp...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a queue using two stacks. Provide step-by-step explanation. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Provide Start, End. Include decision structure. Need to be line by line. Let's craft.\n\nPseudo code for MyQueue class:\n\nStart\n→ Define stack1 // 主堆，用於push\n→ Define stack2 // 助堆，用於pop/peek\n\nDefine push(x)\n    → stack1.push(x) // 把元素推入主堆\n\nDefine pop()\n    → Decision: If stack2 is empty? // 檢查助堆是否有元素\n        Yes → Step: While stack1 not empty:\n                → temp = stack1.pop()\n                → stack2.push(temp) // 把主堆的元素倒轉到助堆\n        No → // nothing\n    → result = stack2.pop() // 取出前端元素\n    → Return result\n\nDefine peek()\n    → Decision: If stack2 is empty?\n        Yes → Step: While stack1 not empty:\n                → temp = stack1.pop()\n                → stack2.push(temp)\n        No → // nothing\n    → result = stack2.peek() // 取得前端元素但不移除\n    → Return result\n\nDefine empty()\n    → Decision: If stack1 is empty AND stack2 is empty?\n        Yes → Return true\n        No → Return false\n\nEnd\n\nWe need to write each line as virtual code with explanation. Use \"Start //\". Use arrows \"→\". Provide indentation maybe not necessary.\n\nLet's produce lines.\n\nWe must show each line of pseudo code. Also each line includes explanation. Let's produce.\n\nBe careful: Use \"Start\" and \"End\" at beginning and end.\n\nLet's write.\n\n```\nStart // 程式開始執行\n→ Define stack1 // 主堆，儲存入列元素\n→ Define stack2 // 助堆，用於出列與取首元素\n→ Define push(x) // 推送元素到佇列尾部\n    → stack1.push(x) // 將 x 放到主堆頂部\n→ Define pop() // 從佇列頭部移除並回傳元素\n    → Decision: stack2.isEmpty()? // 判斷助堆是否已有元素\n        Yes → While stack1 is not empty? // 若助堆空，將主堆倒轉進助堆\n                → temp = stack1.pop() // 取主堆頂\n                → stack2.push(temp) // 推入助堆\n        No → // 助堆已有元素，直接使用\n    → result = stack2.pop() // 從助堆頂取出佇列首元素\n    → Return result\n→ Define peek() // 取得佇列頭部元素但不移除\n    → Decision: stack2.isEmpty()? // 同樣判斷助堆是否空\n        Yes → While stack1 is not empty?\n                → temp = stack1.pop()\n                → stack2.push(temp)\n        No →\n    → result = stack2.peek() // 取得助堆頂元素\n    → Return result\n→ Define empty() // 檢查佇列是否為空\n    → Decision: stack1.isEmpty() AND stack2.isEmpty() ?\n        Yes → Return true // 兩堆皆空，佇列空\n        No  → Return false // 至少有一堆有元素\nEnd // 程式執行結束\n```\n\nBut we need each line as \"虛擬碼步驟 // 解釋\". We need to avoid indentation? We can keep indentation for readability. Each line including indentation still counted as line. Provide arrow \"→\". For nested blocks we might indent lines with 4 spaces.\n\nBut the format sample shows indentation like \"→ Decision: ... //\" and then lines inside with indentation \"    Yes → Step ...\" etc. So we can replicate.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Define stack1 // 主堆，儲存入列元素\n→ Define stack2 // 助堆，用於出列與取首元素\n→ Define push(x) // 推送元素到佇列尾部\n    → stack1.push(x) // 將 x 放到主堆頂部\n→ Define pop() // 從佇列頭部移除並回傳元素\n    → Decision: stack2.isEmpty()? // 判斷助堆是否已有元素\n        Yes → While stack1.isNotEmpty()? // 若助堆空，將主堆倒轉進助堆\n                → temp = stack1.pop() // 取主堆頂\n                → stack2.push(temp) // 推入助堆\n        No → // 助堆已有元素，直接使用\n    → result = stack2.pop() // 從助堆頂取出佇列首元素\n    → Return result\n→ Define peek() // 取得佇列頭部元素但不移除\n    → Decision: stack2.isEmpty()? // 同樣判斷助堆是否空\n        Yes → While stack1.isNotEmpty()?\n                → temp = stack1.pop()\n                → stack2.push(temp)\n        No →\n    → result = stack2.peek() // 取得助堆頂元素\n    → Return result\n→ Define empty() // 檢查佇列是否為空\n    → Decision: stack1.isEmpty() AND stack2.isEmpty() ?\n        Yes → Return true // 兩堆皆空，佇列空\n        No  → Return false // 至少有一堆有元素\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        # No operations to process\n        print([])\n        sys.exit(0)\n\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyQueue\":\n            obj = MyQueue()\n            result.append(None)\n        elif op == \"push\":\n            obj.push(arg[0])\n            result.append(None)\n        elif op == \"pop\":\n            result.append(obj.pop())\n        elif op == \"peek\":\n            result.append(obj.peek())\n        elif op == \"empty\":\n            result.append(obj.empty())\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpeun83gyn.py\", line 33, in <module>\n    ops = ast.literal_eval(data[0])\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x750fb4326c90>"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode718.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Repeated Subarray",
    "description_snippet": "Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in bo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solution to find longest common subarray between two integer arrays. We need to output in requested format: Start, → Step, Decision, etc. Provide step-by-step.\n\nWe must avoid actual code, just pseudo-code.\n\nWe need to think algorithm: use binary search on length plus rolling hash or DP with hash table. Simpler: DP O(n*m). But they want maybe efficient: binary search + hashing. We can produce generic pseudo-code. Use Start, Step 1: input arrays. Step 2: compute low/high. Step 3: while low <= high: mid. Step 4: if exists common subarray of length mid: answer=mid; low=mid+1 else high=mid-1. Step 5: return answer.\n\nNeed subarray existence check: use rolling hash with set. Step 5a: compute hash of first mid length subarray of nums1, add to set. Then slide through nums1 computing next hash. Use base, mod. Then for nums2, compute hash for each length mid; if in set return true. else false.\n\nAlso need to handle collision: double hash or confirm via actual compare.\n\nWe'll produce steps accordingly. Each line includes pseudo-code step and comment. Use arrow indentation.\n\nLet's produce: Start, → Step 1: get arrays, etc.\n\nWe must ensure each line has \"虛擬碼步驟\" + \" // 解釋\". Use Chinese. Use arrow notation for decisions.\n\nLet's produce.\n\nWe need to decide on structure: we can indent decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收兩個整數陣列 nums1, nums2 // 取得輸入資料  \n→ Step 2: 設定 low = 0, high = min(nums1.length, nums2.length) // 初始化二分搜尋的搜尋範圍  \n→ Step 3: 設定 answer = 0 // 儲存目前找到的最大子陣列長度  \n→ Decision: low ≤ high? // 判斷是否仍有可能找到更長的子陣列  \n    Yes → Step 4: mid = (low + high) // 2 // 計算目前要檢查的子陣列長度  \n    → Step 5: 呼叫 ExistsCommonSubarray(nums1, nums2, mid) // 判斷長度為 mid 的子陣列是否同時存在於兩個陣列  \n        → Decision: 回傳值為 True? // 檢查是否找到長度為 mid 的共通子陣列  \n            Yes → Step 6: answer = mid // 更新最大長度  \n            → Step 7: low = mid + 1 // 嘗試更長的長度  \n            No  → Step 8: high = mid - 1 // 需要更短的長度  \n    → Step 9: 重複 Decision: low ≤ high? // 進入下一輪二分搜尋  \n→ End // 完成二分搜尋，得到答案  \n→ Step 10: 回傳 answer // 輸出最長共通子陣列長度  \n\n// --- 子函式 ExistsCommonSubarray 的虛擬碼 --------------------------------  \n→ Step 11: 若 length == 0 return True // 空長度總是共通  \n→ Step 12: 設定 base = 100007, mod = 10^9+7 // 滾動哈希的基數與模數  \n→ Step 13: 計算 base^(length-1) mod mod 作為幂值 // 用於快速更新哈希  \n→ Step 14: // 先對 nums1 計算所有長度為 length 的子陣列哈希值  \n    → Step 15: 計算 nums1 前 length 個元素的哈希值 hash1  \n    → Step 16: 建立空集合 seenHash  \n    → Step 17: 把 hash1 加入 seenHash  \n    → Step 18: For i from length to nums1.length-1:  \n        → Step 19: hash1 = (hash1 - nums1[i-length] * power) * base + nums1[i] // 滾動更新哈希  \n        → Step 20: hash1 = (hash1 % mod + mod) % mod // 確保正值  \n        → Step 21: seenHash.add(hash1) // 加入集合  \n→ Step 22: // 再對 nums2 檢查是否有相同哈希值  \n    → Step 23: 計算 nums2 前 length 個元素的哈希值 hash2  \n    → Step 24: If hash2 in seenHash return True // 直接找到相同哈希  \n    → Step 25: For j from length to nums2.length-1:  \n        → Step 26: hash2 = (hash2 - nums2[j-length] * power) * base + nums2[j] // 滾動更新哈希  \n        → Step 27: hash2 = (hash2 % mod + mod) % mod  \n        → Step 28: If hash2 in seenHash return True // 找到相同哈希  \n→ Step 29: // 為避免哈希碰撞，對所有候選子陣列進行實際比較  \n    → Step 30: For each start index i in nums1 where subarray length == length:  \n        → Step 31: For each start index j in nums2 where subarray length == length:  \n            → Step 32: If nums1[i:i+length] == nums2[j:j+length] return True // 真正相等  \n→ Step 33: Return False // 沒有找到長度為 length 的共通子陣列",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef find_length(nums1, nums2):\n    \"\"\"計算兩個陣列的最長公共子陣列長度。\"\"\"\n    m, n = len(nums1), len(nums2)\n    # 只保留兩列 DP 以降低記憶體使用\n    prev = [0] * (n + 1)\n    cur = [0] * (n + 1)\n    max_len = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                cur[j] = prev[j - 1] + 1\n                if cur[j] > max_len:\n                    max_len = cur[j]\n            else:\n                cur[j] = 0\n        # 交換前後兩列\n        prev, cur = cur, prev\n\n    return max_len\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read()\n    # 找出所有方括號內的清單字串\n    lists = re.findall(r'\\[.*?\\]', raw_input)\n    if len(lists) >= 2:\n        nums1 = ast.literal_eval(lists[0])\n        nums2 = ast.literal_eval(lists[1])\n        result = find_length(nums1, nums2)\n        print(result)\n    else:\n        print(0)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode493.json",
    "problem_index_in_file": 0,
    "title": "Reverse Pairs",
    "description_snippet": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code (like pseudo-code) for counting reverse pairs in an array with condition nums[i] > 2 * nums[j], 0 <= i < j < n. Should use some efficient algorithm: probably merge sort based inversion counting, or BIT after coordinate compression. Provide virtual steps with arrows, decisions, etc.\n\nWe need to output line by line with \"虛擬碼步驟 [space] // 解釋/說明\". Use Start, End, Decision: etc. Ensure no actual code. Provide a step-by-step algorithm.\n\nLet's propose algorithm: use divide and conquer merge sort:\n\n1. Start\n2. → Step: Define function countAndMergeSort(nums, left, right)\n   // Recursively count reverse pairs and sort subarray\n3. → Decision: if left >= right? // base case single element\n   Yes → Return 0\n   No → Continue\n4. Compute mid\n5. → Step: leftCount = countAndMergeSort(nums, left, mid)\n   // Count reverse pairs in left half\n6. → Step: rightCount = countAndMergeSort(nums, mid+1, right)\n   // Count reverse pairs in right half\n7. → Step: crossCount = countCrossPairs(nums, left, mid, right)\n   // Count pairs with i in left, j in right\n8. → Step: merge(nums, left, mid, right)\n   // Merge sorted halves\n9. → Step: Return leftCount + rightCount + crossCount\n10. End\n\nDefine countCrossPairs:\n- Use two pointers i=left, j=mid+1; while i<=mid: while j<=right and nums[i] > 2*nums[j] increment j; count += j-(mid+1); i++.\n\nAlso merge typical.\n\nWe need to provide explanation per line.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step: 定義函式 countAndMergeSort(nums, left, right) // 進行分治與排序同時計算逆序對\n    → Decision: 是否 left >= right? // 子陣列長度為 1 或 0，無逆序對\n        Yes → Step: Return 0 // 基本情況返回 0\n        No  → Step: 計算 mid = (left+right)/2 // 找中點\n        → Step: leftCount = countAndMergeSort(nums, left, mid) // 計算左半段逆序對\n        → Step: rightCount = countAndMergeSort(nums, mid+1, right) // 計算右半段逆序對\n        → Step: crossCount = countCrossPairs(nums, left, mid, right) // 計算跨半段逆序對\n        → Step: merge(nums, left, mid, right) // 合併已排序的兩段\n        → Step: Return leftCount + rightCount + crossCount // 回傳總逆序對數\n→ Function: countCrossPairs(nums, left, mid, right)\n    → Step: i = left; j = mid + 1; count = 0\n    → Decision: while i <= mid? // 逐個遍歷左半段\n        Yes → Decision: while j <= right and nums[i] > 2*nums[j]? // 找符合條件的右半段\n                Yes → Step: j += 1 // j 向右移\n                No  → Step: count += j - (mid + 1) // 所有 j 到 j-1 為有效逆序對\n                      → Step: i += 1 // 移動到下一個左半段元素\n        No  → End // 迴圈結束\n→ Function: merge(nums, left, mid, right)\n    // 合併兩個已排序子陣列\n    → Step: temp = empty list\n    → Step: i = left; j = mid + 1\n    → Decision: while i <= mid and j <= right?\n        Yes → Decision: if nums[i] <= nums[j]?\n                Yes → Step: temp.append(nums[i]); i += 1\n                No  → Step: temp.append(nums[j]); j += 1\n        No  → Step: while i <= mid? // 將剩餘左半段加入\n                Yes → Step: temp.append(nums[i]); i += 1\n        No  → Step: while j <= right? // 將剩餘右半段加入\n                Yes → Step: temp.append(nums[j]); j += 1\n    → Step: for k in range(len(temp)): nums[left + k] = temp[k] // 把排序後的元素寫回原陣列\nEnd // 程式執行結束\n\nBut need format: each line must be \"虛擬碼步驟 [space] // 解釋/說明\". We can't use multiline steps? Each line is separate. Use arrows only for transitions. We can have nested decisions as indent maybe.\n\nSimplify: Provide top-level steps and sub-functions separate. Each line should include the step and explanation. We can break into separate blocks.\n\nLet's produce:\n\nStart // 程式開始\n→ Step: Call countAndMergeSort(nums, 0, nums.length-1) // 以整個陣列為範圍開始遞迴\n→ Function: countAndMergeSort(nums, left, right) // 分治排序並計算逆序對\n    → Decision: left >= right? // 子陣列只有一個元素\n        Yes → Return 0 // 基本情況返回 0\n        No  → Step: mid = (left + right) / 2 // 計算中點\n        → Step: leftCount = countAndMergeSort(nums, left, mid) // 計算左半段逆序對\n        → Step: rightCount = countAndMergeSort(nums, mid+1, right) // 計算右半段逆序對\n        → Step: crossCount = countCrossPairs(nums, left, mid, right) // 計算跨半段逆序對\n        → Step: merge(nums, left, mid, right) // 合併已排序的兩段\n        → Return leftCount + rightCount + crossCount // 回傳總逆序對數\n→ Function: countCrossPairs(nums, left, mid, right) // 計算 i 在左半段，j 在右半段的逆序對\n    → Step: i = left; j = mid + 1; count = 0 // 初始化指標和計數器\n    → Decision: i <= mid? // 遍歷左半段\n        Yes → Decision: j <= right and nums[i] > 2*nums[j]? // 判斷是否為逆序對\n                Yes → Step: j += 1 // 右指標向右移\n                No  → Step: count += j - (mid + 1) // 所有符合條件的 j 都計入\n                      → Step: i += 1 // 移動到下一個左半段元素\n        No  → End // 完成跨段計算\n→ Function: merge(nums, left, mid, right) // 合併兩個已排序子陣列\n    → Step: temp = [] // 暫存已排序結果\n    → Step: i = left; j = mid + 1\n    → Decision: i <= mid and j <= right? // 同時有元素可比對\n        Yes → Decision: nums[i] <= nums[j]? // 選取較小的元素\n                Yes → Step: temp.append(nums[i]); i += 1\n                No  → Step: temp.append(nums[j]); j += 1\n        No  → Step: while i <= mid? // 左半段剩餘\n                Yes → Step: temp.append(nums[i]); i += 1\n        No  → Step: while j <= right? // 右半段剩餘\n                Yes → Step: temp.append(nums[j]); j += 1\n    → Step: for k from 0 to temp.length-1: nums[left + k] = temp[k] // 把排序後的元素寫回原陣列\nEnd // 程式執行結束\n\nWe must ensure each line is a separate line. Use arrow for steps within functions? Each step line start with \"→\". But we already used \"→ Function:\" as separate. That is acceptable. We need indentation? It's fine. But we need to keep each line with \"虛擬碼步驟 // 解釋\". Ensure no actual code syntax like array indexing? But it's virtual code; we can include pseudocode like nums.length-1.\n\nWe should avoid actual code? It's allowed; it's pseudo code. But we must not output actual code? The instruction: \"請勿輸出實際程式碼，只輸出結構化的步驟.\" That means we should avoid real syntax like \"for\" loops? But we used them. Maybe it's acceptable as pseudo.\n\nBetter keep simple: steps referencing loops, conditions. It's pseudo. That's okay.\n\nLet's produce final answer with each line as required.\n...done thinking.\n\nStart // 程式開始  \n→ Step: Call countAndMergeSort(nums, 0, nums.length-1) // 以整個陣列為範圍開始遞迴  \n→ Function: countAndMergeSort(nums, left, right) // 分治排序並計算逆序對  \n  → Decision: left >= right? // 子陣列只有一個元素  \n   Yes → Return 0 // 基本情況返回 0  \n   No  → Step: mid = (left + right) / 2 // 計算中點  \n    → Step: leftCount = countAndMergeSort(nums, left, mid) // 計算左半段逆序對  \n    → Step: rightCount = countAndMergeSort(nums, mid+1, right) // 計算右半段逆序對  \n    → Step: crossCount = countCrossPairs(nums, left, mid, right) // 計算跨半段逆序對  \n    → Step: merge(nums, left, mid, right) // 合併已排序的兩段  \n    → Return leftCount + rightCount + crossCount // 回傳總逆序對數  \n→ Function: countCrossPairs(nums, left, mid, right) // 計算 i 在左半段，j 在右半段的逆序對  \n  → Step: i = left; j = mid + 1; count = 0 // 初始化指標和計數器  \n  → Decision: i <= mid? // 遍歷左半段  \n   Yes → Decision: j <= right and nums[i] > 2*nums[j]? // 判斷是否為逆序對  \n     Yes → Step: j += 1 // 右指標向右移  \n     No  → Step: count += j - (mid + 1) // 所有符合條件的 j 都計入  \n       → Step: i += 1 // 移動到下一個左半段元素  \n   No  → End // 完成跨段計算  \n→ Function: merge(nums, left, mid, right) // 合併兩個已排序子陣列  \n  → Step: temp = [] // 暫存已排序結果  \n  → Step: i = left; j = mid + 1  \n  → Decision: i <= mid and j <= right? // 同時有元素可比對  \n   Yes → Decision: nums[i] <= nums[j]? // 選取較小的元素  \n     Yes → Step: temp.append(nums[i]); i += 1  \n     No  → Step: temp.append(nums[j]); j += 1  \n   No  → Step: while i <= mid? // 左半段剩餘  \n     Yes → Step: temp.append(nums[i]); i += 1  \n   No  → Step: while j <= right? // 右半段剩餘  \n     Yes → Step: temp.append(nums[j]); j += 1  \n  → Step: for k from 0 to temp.length-1: nums[left + k] = temp[k] // 把排序後的元素寫回原陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef reverse_pairs(nums):\n    def merge_sort(start, end):\n        if start >= end:\n            return 0\n        mid = (start + end) // 2\n        count = merge_sort(start, mid) + merge_sort(mid + 1, end)\n\n        j = mid + 1\n        for i in range(start, mid + 1):\n            while j <= end and nums[i] > 2 * nums[j]:\n                j += 1\n            count += j - (mid + 1)\n\n        temp = []\n        left, right = start, mid + 1\n        while left <= mid and right <= end:\n            if nums[left] <= nums[right]:\n                temp.append(nums[left])\n                left += 1\n            else:\n                temp.append(nums[right])\n                right += 1\n        while left <= mid:\n            temp.append(nums[left])\n            left += 1\n        while right <= end:\n            temp.append(nums[right])\n            right += 1\n\n        nums[start:end + 1] = temp\n        return count\n\n    return merge_sort(0, len(nums) - 1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        nums = ast.literal_eval(match.group(0))\n    else:\n        nums = []\n    result = reverse_pairs(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,4,3,5,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode443.json",
    "problem_index_in_file": 0,
    "title": "String Compression",
    "description_snippet": "Given an array of characters chars, compress it using the following algorithm:\n\nBegin with an empty ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanation after each line. Must not output actual code. Provide algorithm for compressing in-place array of chars. Use constant extra space. Steps: iterate through array, keep write pointer, read pointer, group length count, etc. Use pseudo code style with arrow etc.\n\nWe must produce lines with \"虛擬碼步驟 // 解釋\".\n\nWe need to incorporate Decision steps and arrow.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化 read = 0, write = 0 // read pointer for iterating input, write pointer for output position\n→ Step 2: 讀取 chars 長度 n // get length of array\n→ Decision: read < n? // loop while there are characters to process\n    Yes →\n        → Step 3: 設定 currChar = chars[read] // current character being processed\n        → Step 4: 設定 count = 0 // reset count for current group\n        → Step 5: 讀取相同字符並計數\n        → Decision: read < n and chars[read] == currChar? // while characters match current group\n            Yes →\n                → Step 6: count++ // increment group length\n                → Step 7: read++ // move to next character\n                → Step 5  // repeat counting\n            No → // finished counting group\n                → Step 8: 將 currChar 寫入 chars[write]; write++ // output character\n                → Decision: count > 1? // if group length >1\n                    Yes →\n                        → Step 9: 轉換 count 為字串 strCount\n                        → Step 10: 對每個 digit in strCount:\n                            → Step 10.1: chars[write] = digit; write++ // write each digit\n                    No → // count ==1, nothing more to write\n                → Step 11: 返回 Decision: read < n? // continue loop\n    No → // finished reading all groups\n→ Step 12: 返回 write // 新長度\nEnd // 程式結束\n\nBut need to format properly with arrows and comments. Use \"Decision:\" lines.\n\nAlso, maybe break counting into a separate Decision.\n\nWe must keep constant extra space: using count integer, char buffer for digits maybe string but can convert using math to array of digits? We can use string conversion for simplicity; still constant space because length of count is small relative to n? But algorithm may treat as temporary string; still considered constant. It's fine.\n\nLet's produce final answer.\n\nAlso use \"→\" arrow to show progression. Let's produce each line.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 read = 0, write = 0 // read pointer and write pointer初始化\n→ Step 2: 讀取 n = len(chars) // 獲取輸入陣列長度\n→ Decision: read < n? // 是否還有字符未處理\n    Yes →\n        → Step 3: currChar = chars[read] // 紀錄當前字符\n        → Step 4: count = 0 // 重置當前組的計數\n        → Decision: read < n and chars[read] == currChar? // 以while方式計數\n            Yes →\n                → Step 5: count++ // 同一字符計數\n                → Step 6: read++ // 移動到下一個字符\n                → Step 4 // 回到決策重複計數\n            No → // 組已結束\n                → Step 7: chars[write] = currChar; write++ // 輸出字符\n                → Decision: count > 1? // 是否需要寫入計數\n                    Yes →\n                        → Step 8: strCount = str(count) // 將計數轉為字串\n                        → Step 9: for digit in strCount:\n                            → Step 9.1: chars[write] = digit; write++ // 寫入每個數字\n                    No → // count 為 1，無需寫入數字\n                → Step 10: 回到 Decision: read < n? // 進行下一組\n    No → // 所有字符已處理\n→ Step 11: return write // 回傳新長度\nEnd // 程式結束\n\nNeed to ensure each line ends with // 解釋.\n\nAlso maintain format: \"虛擬碼步驟 // 解釋\".\n\nLet's output exactly as specified. Use Chinese for comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: read = 0, write = 0 // 初始化讀取指標與寫入指標  \n→ Step 2: n = len(chars) // 取得輸入陣列長度  \n→ Decision: read < n? // 是否還有字符未處理  \n Yes →  \n  → Step 3: currChar = chars[read] // 記錄當前組的字符  \n  → Step 4: count = 0 // 重置本組計數  \n  → Decision: read < n and chars[read] == currChar? // 以 while 方式計數相同字符  \n   Yes →  \n    → Step 5: count++ // 同一字符計數  \n    → Step 6: read++ // 移至下一個字符  \n    → Step 4 // 回到決策繼續計數  \n   No → // 本組已結束  \n    → Step 7: chars[write] = currChar; write++ // 寫入該字符  \n    → Decision: count > 1? // 是否需要寫入組長  \n     Yes →  \n      → Step 8: strCount = str(count) // 把長度轉成字串  \n      → Step 9: for digit in strCount:  \n        → Step 9.1: chars[write] = digit; write++ // 逐位寫入長度  \n      No → // count 為 1，無需寫入長度  \n     → Step 10: 回到 Decision: read < n? // 進行下一組  \n   No → // 所有字符已處理  \n→ Step 11: return write // 回傳新的陣列長度  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def compress(self, chars):\n        write = 0\n        left = 0\n        n = len(chars)\n        while left < n:\n            right = left\n            while right < n and chars[right] == chars[left]:\n                right += 1\n            chars[write] = chars[left]\n            write += 1\n            count = right - left\n            if count > 1:\n                for c in str(count):\n                    chars[write] = c\n                    write += 1\n            left = right\n        return write\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    eq = data.find('=')\n    if eq != -1:\n        chars_part = data[eq + 1:].strip()\n    else:\n        chars_part = data\n    chars = ast.literal_eval(chars_part)\n    sol = Solution()\n    new_len = sol.compress(chars)\n    print(new_len)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "chars = [\"a\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode674.json",
    "problem_index_in_file": 0,
    "title": "Longest Continuous Increasing Subsequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest continuous increasing sub...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for algorithm: find longest continuous increasing subarray length. Approach: iterate, maintain current length and max. Complexity O(n). Provide virtual code steps.\n\nWe need to use arrow symbols and Decision. Let's craft. Use Start, End. For each step: maybe Step 1: Initialize variables. Step 2: iterate array. Step 3: check if current > previous. If yes increment currLen else reset to 1. Update maxLen. At end output maxLen.\n\nAdd explanation after each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxLen ← 1, currLen ← 1 // 設定最大長度與目前連續遞增長度  \n→ Step 2: 若 nums 長度為 0 則 maxLen ← 0 // 處理空陣列情況  \n→ Decision: 從索引 1 到 nums.length-1 迭代 // 開始遍歷陣列  \n    → Step 3: 若 nums[i] > nums[i-1] // 檢查是否遞增  \n        → Yes → currLen ← currLen + 1 // 連續遞增長度加 1  \n        → No  → currLen ← 1 // 不是遞增，重置長度為 1  \n    → Step 4: maxLen ← max(maxLen, currLen) // 更新最大長度  \n→ End // 迴圈結束，已計算完成  \n→ Step 5: 輸出 maxLen // 返回最長連續遞增子陣列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_length_of_lcis(nums):\n    \"\"\"\n    找出 nums 中最長的連續遞增子陣列長度。\n    \"\"\"\n    if not nums:                     # 空陣列直接回傳 0\n        return 0\n    max_len = 1                      # 至少有一個元素\n    cur_len = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:    # 繼續遞增\n            cur_len += 1\n            max_len = max(max_len, cur_len)\n        else:                        # 不遞增，重置計數\n            cur_len = 1\n    return max_len\n\ndef parse_input(text):\n    \"\"\"\n    解析輸入文字成整數列表。\n    支援兩種格式：\n    1. 'nums = [1,2,3]'\n    2. '[1,2,3]' 或 '1,2,3'\n    \"\"\"\n    text = text.strip()\n    if not text:\n        return []\n    # 若包含 '='，則取等號右側\n    if '=' in text:\n        _, expr = text.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = text\n    # 若還是以逗號分隔的數字，將其包成列表字串\n    if expr and expr[0] not in ('[', '('):\n        expr = '[' + expr + ']'\n    try:\n        return ast.literal_eval(expr)\n    except Exception:\n        # 最後的備援方案：直接從字串中提取所有整數\n        nums = []\n        num = ''\n        for ch in expr:\n            if ch.isdigit() or ch == '-':\n                num += ch\n            else:\n                if num:\n                    nums.append(int(num))\n                    num = ''\n        if num:\n            nums.append(int(num))\n        return nums\n\ndef main():\n    input_text = sys.stdin.read()\n    nums = parse_input(input_text)\n    result = find_length_of_lcis(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode541.json",
    "problem_index_in_file": 0,
    "title": "Reverse String II",
    "description_snippet": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for algorithm to reverse first k chars for every 2k chars.\n\nWe will create steps:\n\nStart\n→ Step 1: 取得輸入 s, k // Input\n→ Step 2: 轉成字元陣列 chars // convert to array\n→ Step 3: 初始化 i = 0 // index\n→ Decision: i < length? // loop\n   Yes → Step 4: 計算 end1 = min(i + k, length) // first k segment\n   Yes → Step 5: reverse(chars, i, end1-1) // reverse first k\n   Yes → Step 6: i += 2*k // skip next k (leave unchanged)\n   No → End\n\nBut we also need handle case less than k, etc. The reverse step handles all.\n\nNeed to ensure we only reverse first k if exist, and skip next k or less. The algorithm with i += 2*k works because we skip the next k; but if remaining less than k? After reversing first k (maybe less if not enough). But we skip 2k. If less than k left we reverse all and then loop ends. If between k and 2k-1, we reverse k then skip remaining but there may be less than k left to skip. But i += 2*k may overshoot length. Then loop condition will terminate.\n\nSo we can produce pseudocode accordingly.\n\nLet's produce virtual code lines with arrow arrows.\n\nWe need each line: \"虛擬碼步驟 // 解釋\".\n\nWe can include nested decisions.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s 以及整數 k // 取得使用者輸入  \n→ Step 2: chars ← s.toCharArray() // 將字串轉成可改寫的字元陣列  \n→ Step 3: i ← 0 // 初始化索引，指向當前處理的位置  \n→ Decision: i < chars.length? // 是否還有字元未處理  \n  Yes → Step 4: end1 ← min(i + k, chars.length) // 取出第一段需反轉的區域結束索引（若不足 k 則至結尾）  \n  Yes → Step 5: reverse(chars, i, end1 - 1) // 反轉 chars[i … end1-1]  \n  Yes → Step 6: i ← i + 2 * k // 跳過後面 k 個字元（保持原順序），進入下一個 2k 區段  \n  No → End // 所有字元已處理，結束程式  \nEnd // 程式執行結束  \n\n// reverse(chars, start, end) 代表將 chars[start] 到 chars[end] 的順序反轉。  \n// min(a, b) 取兩者較小值，用於處理剩餘字元不足 k 的情況。",
      "generated_code": "import sys\n\ndef reverse_str(s: str, k: int) -> str:\n    \"\"\"\n    將字串 s 的每 2k 個字元中，前 k 個字元反轉。\n    \"\"\"\n    chars = list(s)\n    n = len(chars)\n    for i in range(0, n, 2 * k):\n        end = min(i + k, n)            # 若不足 k 個字元，則反轉到結尾\n        chars[i:end] = reversed(chars[i:end])\n    return \"\".join(chars)\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入，處理問題並輸出結果。\n    預期輸入格式為：'<字串>', <k>，例如：\"abcdefg\", 2\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 直接使用 eval 解析輸入，得到 (字串, k) 的元組\n    s, k = eval(data)\n\n    result = reverse_str(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abcdefg\", 2",
          "expected_output": "\"bacdfeg\"",
          "success": true,
          "output": "bacdfeg"
        },
        {
          "example_index": 1,
          "input": "\"abcd\", 2",
          "expected_output": "\"bacd\"",
          "success": true,
          "output": "bacd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode188.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock IV",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Problem: max profit with at most k transactions. Standard DP: dp[t][i] = max profit up to day i with at most t transactions. O(k n). Use local and global optimum. But virtual code: we just outline steps.\n\nWe need to produce steps like:\n\nStart\n→ Step: Initialize variables k, prices, n.\n→ Decision: If k >= n/2? // if unlimited transactions, sum positive diffs.\n→ Yes → Step: Compute sum of all positive differences // result\n→ No  → Step: Create dp arrays\n→ Step: For each transaction from 1 to k\n    → Step: Initialize maxDiff = -prices[0]\n    → For each day from 1 to n-1\n        → Step: Update dp[t][day] = max(dp[t][day-1], prices[day]+maxDiff)\n        → Step: Update maxDiff = max(maxDiff, dp[t-1][day]-prices[day])\n→ End // output dp[k][n-1]\n\nWe need to use arrows like →, Decision, etc. Provide comment after each line. Must not output actual code. Just virtual steps. So we should produce like:\n\nStart // 程式開始\n→ Step 1: 讀取 n, k, 以及價格陣列 prices // 取得輸入資料\n→ Decision: 若 k >= n/2? // 檢查是否為無限制交易情況\n    Yes → Step 2: 計算所有正差值之和 // 取得最大利潤\n    No → Step 3: 建立 dp 陣列 dp[k+1][n] 以儲存利潤 // 初始化動態規劃表\n...\n\nWe need to maintain proper indentation maybe. Use Decision with Yes and No. Each line must be single step with arrow.\n\nOk. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n、k 與價格陣列 prices // 取得輸入資料  \n→ Decision: 如果 k >= n/2? // 檢查是否為無限制交易情況  \n Yes → Step 2: 計算所有正差值之和並輸出 // 取得最大利潤，因為可以無限次交易  \n No  → Step 3: 建立 dp 陣列 dp[k+1][n]，並以 0 初始化 // 動態規劃表，dp[t][i] 代表在第 i 天最多完成 t 次交易的最大利潤  \n  → Step 4: 進入外層迴圈 t 從 1 到 k // 處理每一次交易次數  \n   → Step 5: 設定 maxDiff = -prices[0] // 追蹤前一交易結束後可取得的最高利潤減去當前價格  \n   → Step 6: 進入內層迴圈 i 從 1 到 n-1 // 處理每天的價格  \n    → Step 7: 更新 dp[t][i] = max( dp[t][i-1], prices[i] + maxDiff ) // 選擇不交易或以今天賣出取得利潤  \n    → Step 8: 更新 maxDiff = max( maxDiff, dp[t-1][i] - prices[i] ) // 為下一天做準備，計算可用於第 t 次買入的最高利潤減價格  \n→ Step 9: 輸出 dp[k][n-1] // 取得最多 k 次交易的最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef max_profit(k, prices):\n    n = len(prices)\n    if n == 0 or k == 0:\n        return 0\n    # 若交易次數足夠多，等同於無限制交易\n    if k >= n // 2:\n        profit = 0\n        for i in range(1, n):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit\n    # 動態規劃：dp[t][d] 表示到第 d 天最多完成 t 次交易的最大利潤\n    dp = [[0] * n for _ in range(k + 1)]\n    for t in range(1, k + 1):\n        max_diff = -prices[0]   # 前一交易結束後可取得的最高利潤減去今天價格\n        for d in range(1, n):\n            # 不交易或今天賣出\n            dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff)\n            # 為下一天做準備：更新可用於第 t 次買入的最高利潤減價格\n            max_diff = max(max_diff, dp[t - 1][d] - prices[d])\n    return dp[k][n - 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 嘗試解析 k 與 prices\n    k = None\n    prices = None\n    match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if match:\n        k = int(match.group(1))\n    match = re.search(r'prices\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if match:\n        prices = ast.literal_eval(match.group(1))\n    # 若無法以「k = ..., prices = [...]」的形式解析，則嘗試簡易分割\n    if k is None or prices is None:\n        parts = data.replace(',', ' ').split()\n        if len(parts) >= 2:\n            try:\n                k = int(parts[0])\n                prices = list(map(int, parts[1:]))\n            except ValueError:\n                pass\n    # 若還是無法解析，則直接退出\n    if k is None or prices is None:\n        return\n    result = max_profit(k, prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode522.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence II",
    "description_snippet": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve longest uncommon subsequence length between strings array. Problem: from LeetCode \"Longest Uncommon Subsequence II\". The solution: if any string not equal to any other, answer length of that string. If all strings same, answer -1.\n\nSteps: read array, find duplicates. Use map count. For each string, if its count==1, candidate length. Take max. If max found, return that, else -1.\n\nLet's produce steps:\n\nStart\n→ Step 1: Build frequency map of all strings // Count occurrences\n→ Step 2: Initialize maxLen = -1 // Default result\n→ Decision: For each string in array // Iterate\n    Yes → Decision: If frequency of string == 1? // Unique string\n        Yes → Step 3: Update maxLen = max(maxLen, length of string) // Update longest unique\n        No → Step 4: // Skip duplicate strings\nEnd\n→ Step 5: Return maxLen // Final answer (may be -1)\n\nNeed to show virtual code arrow and explanation. Use Decision arrow for loops. Use Yes/No arrow for condition. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字串頻率表 freq_map 以計算每個字串在陣列中的出現次數 // 方便判斷是否唯一  \n→ Step 2: 初始化 maxLen 為 -1，表示目前尚未找到不常見子序列長度 // -1 代表不存在  \n→ Decision: 針對陣列中的每個字串 str 進行迭代 // 逐一檢查  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: 若 freq_map[str] == 1？ // 判斷字串是否唯一  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: maxLen = max(maxLen, len(str)) // 更新目前最長的不常見子序列長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 4: // 字串重複，忽略不作處理  \nEnd // 迭代結束  \n→ Step 5: 回傳 maxLen // 若 maxLen 為 -1 表示不存在，否則為最長不常見子序列長度",
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\ndef findLUSlength(strs):\n    \"\"\"\n    回傳陣列中最長的不常見子序列長度。\n    若不存在，回傳 -1。\n    \"\"\"\n    if not strs:\n        return -1\n\n    # 計算每個字串的出現頻率\n    freq = Counter(strs)\n\n    # 找出所有唯一字串（頻率為 1）的長度，取最大值\n    max_len = -1\n    for s in strs:\n        if freq[s] == 1:\n            max_len = max(max_len, len(s))\n\n    return max_len\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，並移除前後空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(-1)\n    else:\n        # 解析 JSON 格式的字串陣列\n        try:\n            strs = json.loads(raw_input)\n        except json.JSONDecodeError:\n            # 若解析失敗，直接輸出 -1\n            print(-1)\n        else:\n            # 確保輸入為字串列表\n            if isinstance(strs, list) and all(isinstance(x, str) for x in strs):\n                result = findLUSlength(strs)\n                print(result)\n            else:\n                print(-1)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"aba\",\"cdc\",\"eae\"]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode413.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices",
    "description_snippet": "An integer array is called arithmetic if it consists of at least three elements and if the differenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code that counts arithmetic subarrays in array nums. We must produce step-by-step with explanation, using Start, End, Decision, arrows. Should not output actual code, only virtual steps. Each line: `虛擬碼步驟 // 解釋`. Use arrows like `→`. Need to produce algorithm: iterate over array, compute differences, maintain current run length of equal differences, whenever run length >=2 (meaning at least 3 elements), add (run_length-1) to answer? Actually for subarray count: for each run of length k+1 elements (k differences equal), number of arithmetic subarrays is (k*(k-1)/2). Equivalent to for each new element if diff same, increment current count, ans += current count. We'll produce steps.\n\nWe'll include initialization of ans, current, previous diff. Loop i from 2 to n-1. For each, compute diff, compare with prev_diff, update current, ans. Finally output ans.\n\nWe'll use virtual steps: Start, → Step: Initialize ans=0, current=0, prev_diff=nums[1]-nums[0], etc.\n\nNeed to consider n<3: answer 0.\n\nLet's produce steps accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 判斷 nums 長度是否小於 3？ // 若長度不足三個元素，無法形成算術子陣列  \n    Yes → Step 2: 回傳 0 // 直接結束，返回結果  \n    No  → Step 3: 初始化 ans = 0, current = 0 // ans 為累積算術子陣列數，current 為目前相同差值連續段的長度（以差值計）  \n→ Step 4: 計算第一個差值 prevDiff = nums[1] - nums[0] // 用於比較後續差值是否相同  \n→ Step 5: 從索引 i = 2 開始迴圈至 nums.length - 1 // 每一步檢查從第三個元素開始的差值  \n    → Step 6: 計算 currDiff = nums[i] - nums[i-1] // 目前兩個相鄰元素的差值  \n    → Decision: currDiff 是否等於 prevDiff? // 判斷是否繼續相同的差值序列  \n        Yes → Step 7: current = current + 1 // 差值相同，連續段長度加 1（表示多了一個可形成算術子陣列的段）  \n            → Step 8: ans = ans + current // 目前的連續段產生 current 個新的算術子陣列  \n            → Step 9: prevDiff = currDiff // 更新 prevDiff 以便下一次比較  \n        No  → Step 10: current = 0 // 差值不同，重置連續段長度  \n            → Step 11: prevDiff = currDiff // 更新 prevDiff 為新的差值  \n→ End // 程式執行結束，ans 為所有算術子陣列的總數  \n→ Step 12: 回傳 ans // 輸出最終結果",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        計算給定整數陣列中所有等差子陣列的個數。\n        子陣列至少包含 3 個元素，且相鄰元素之差相同。\n        \"\"\"\n        n = len(nums)\n        if n < 3:\n            return 0\n\n        total = 0      # 最終答案\n        curr = 0       # 以目前元素結尾且符合等差條件的子陣列數量\n\n        for i in range(2, n):\n            # 檢查是否仍為相同的差值\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                curr += 1          # 新增一個符合條件的子陣列\n                total += curr      # 將所有新形成的子陣列加入總數\n            else:\n                curr = 0           # 差值不同，重置計數\n\n        return total\n\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，預期格式類似於：\n        nums = [1,2,3,4]\n    或\n        nums = [1]\n    回傳對應的 list 物件。\n    \"\"\"\n    data = data.strip()\n    # 找到等號右側的列表字串\n    if '=' in data:\n        _, right = data.split('=', 1)\n        list_str = right.strip()\n    else:\n        list_str = data\n    # 使用 literal_eval 以安全方式解析為 Python 物件\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 若解析失敗，回傳空清單\n        nums = []\n    # 確保得到的是 list，否則回傳空清單\n    if not isinstance(nums, list):\n        nums = []\n    return nums\n\n\nif __name__ == \"__main__\":\n    # 讀取所有標準輸入\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.numberOfArithmeticSlices(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode345.json",
    "problem_index_in_file": 0,
    "title": "Reverse Vowels of a String",
    "description_snippet": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e',...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step. Use Start, End, Decision, arrow. Provide explanation after each line. No actual code. Just virtual steps.\n\nLet's think of algorithm: Use two pointers left, right. While left < right: move left forward until vowel. Move right backward until vowel. If left < right, swap s[left] and s[right], increment left, decrement right. End. Return string. Edge cases: single char, no vowels.\n\nWe need to provide virtual code lines.\n\nWe can have:\n\nStart\n→ Step 1: Initialize left = 0, right = length(s) - 1 // 左右指標\n→ Step 2: Define function isVowel(c) // 判斷元音\n    → Decision: If c in ['a','e','i','o','u','A','E','I','O','U']?\n        Yes → Return True\n        No  → Return False\n→ Step 3: While left < right: // 主迴圈\n    → Decision: isVowel(s[left])? // 判斷左邊是否元音\n        Yes → (nothing, continue)\n        No  → left = left + 1 // 移動左指標\n    → Decision: isVowel(s[right])? // 判斷右邊是否元音\n        Yes → (nothing, continue)\n        No  → right = right - 1 // 移動右指標\n    → Decision: left < right? // 確認仍可交換\n        Yes → Step 4: Swap s[left] and s[right] // 交換\n            left = left + 1\n            right = right - 1\n        No  → (loop ends)\n→ Step 5: Return s // 回傳結果\nEnd\n\nBut need more detailed virtual code: each step line with arrow. For decision with sub-steps, use indentation.\n\nLet's produce.\n\nUse 'Start' line, then '→ Step 1: ...', etc.\n\nWe need to not produce actual code but description. But still need to show steps as if code. Use pseudo.\n\nLet's craft.\n\nAlso might use a loop with while left < right: but inside loop we need nested decisions.\n\nWe can structure as:\n\nStart // 程式開始\n\n→ Step 1: Set left = 0, right = length(s) - 1 // 初始化兩個指標\n\n→ Step 2: Define function isVowel(c) // 判斷元音\n    → Decision: If c ∈ {a,e,i,o,u,A,E,I,O,U}?\n        Yes → Return True\n        No  → Return False\n\n→ Step 3: While left < right: // 主迴圈\n    → Decision: isVowel(s[left])?\n        Yes → (do nothing)\n        No  → left = left + 1 // 移動左指標\n    → Decision: isVowel(s[right])?\n        Yes → (do nothing)\n        No  → right = right - 1 // 移動右指標\n    → Decision: left < right?\n        Yes → Step 4: Swap s[left] and s[right] // 交換兩個元音\n            → Step 4a: temp = s[left]\n            → Step 4b: s[left] = s[right]\n            → Step 4c: s[right] = temp\n            → Step 4d: left = left + 1\n            → Step 4e: right = right - 1\n        No  → (break loop)\n\n→ Step 5: Return s // 回傳處理後的字串\n\nEnd // 程式結束\n\nBut need to avoid actual code. Provide explanation after each line. Also note indentation.\n\nWe must produce each line as: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" and maybe \"Yes →\" \"No →\". Let's produce like:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = length(s) - 1 // 初始化左、右指標\n→ Step 2: Define function isVowel(c) // 定義判斷元音的輔助函式\n    → Decision: 如果 c 為 'a','e','i','o','u','A','E','I','O','U'?\n        Yes → Return True // 是元音\n        No  → Return False // 不是元音\n→ Step 3: While left < right: // 迴圈，直到左右指標相遇或交叉\n    → Decision: isVowel(s[left])?\n        Yes → (不動) // 左邊已是元音\n        No  → left = left + 1 // 向右移動左指標\n    → Decision: isVowel(s[right])?\n        Yes → (不動) // 右邊已是元音\n        No  → right = right - 1 // 向左移動右指標\n    → Decision: left < right?\n        Yes → Step 4: Swap s[left] 與 s[right] // 交換兩個元音\n            → Step 4a: temp = s[left]\n            → Step 4b: s[left] = s[right]\n            → Step 4c: s[right] = temp\n            → Step 4d: left = left + 1\n            → Step 4e: right = right - 1\n        No  → (跳出迴圈)\n→ Step 5: Return s // 輸出反轉元音後的字串\nEnd // 程式執行結束\n\nMake sure each line has arrow before it, except Start and End. The Decision lines inside loop also have indentation and arrow. The substeps after swap also have arrow.\n\nWe need to ensure no actual code but explanation after //.\n\nThus produce as above.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = length(s) - 1 // 初始化左、右指標  \n→ Step 2: Define function isVowel(c) // 定義判斷元音的輔助函式  \n  → Decision: 如果 c 為 'a','e','i','o','u','A','E','I','O','U'?  \n   Yes → Return True // 是元音  \n   No  → Return False // 不是元音  \n→ Step 3: While left < right: // 迴圈，直到左右指標相遇或交叉  \n  → Decision: isVowel(s[left])?  \n   Yes → (不動) // 左邊已是元音  \n   No  → left = left + 1 // 向右移動左指標  \n  → Decision: isVowel(s[right])?  \n   Yes → (不動) // 右邊已是元音  \n   No  → right = right - 1 // 向左移動右指標  \n  → Decision: left < right?  \n   Yes → Step 4: Swap s[left] 與 s[right] // 交換兩個元音  \n    → Step 4a: temp = s[left]  \n    → Step 4b: s[left] = s[right]  \n    → Step 4c: s[right] = temp  \n    → Step 4d: left = left + 1  \n    → Step 4e: right = right - 1  \n   No  → (跳出迴圈)  \n→ Step 5: Return s // 輸出反轉元音後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef reverse_vowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')\n    chars = list(s)\n    left, right = 0, len(chars) - 1\n    while left < right:\n        while left < right and chars[left] not in vowels:\n            left += 1\n        while left < right and chars[right] not in vowels:\n            right -= 1\n        if left < right:\n            chars[left], chars[right] = chars[right], chars[left]\n            left += 1\n            right -= 1\n    return ''.join(chars)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 尋找第一對雙引號內的內容作為字串輸入\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        input_str = match.group(1)\n    else:\n        # 若沒有雙引號，則直接使用整段輸入，並去除首尾空白\n        input_str = data.strip()\n    result = reverse_vowels(input_str)\n    # 將結果用雙引號包起來輸出\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"IceCreAm\"",
          "expected_output": "\"AceCreIm\"",
          "success": true,
          "output": "\"AceCreIm\""
        },
        {
          "example_index": 1,
          "input": "s = \"leetcode\"",
          "expected_output": "\"leotcede\"",
          "success": true,
          "output": "\"leotcede\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode464.json",
    "problem_index_in_file": 0,
    "title": "Can I Win",
    "description_snippet": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The p...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the \"100 game\" variation: each integer 1..maxChoosableInteger can be used at most once, players alternate adding a chosen integer to running total; first to reach >= desiredTotal wins. We must produce algorithm to determine if first player can force win, assuming optimal play. This is a typical problem: LeetCode 464. Approach: DFS with memoization (bitmask). If total needed <=0 return true. If sum of all remaining numbers < desiredTotal return false. Use bitmask to encode used numbers. Memoization of (usedMask) -> bool if current player can force win. For each number not used, try choose it, if opponent cannot win after this choice -> return true. Else continue. If no number leads to win, return false. Also check base conditions: if desiredTotal <=0 -> true; else if sum of all numbers < desiredTotal -> false. That's it.\n\nWe need to output virtual code steps line by line with explanation comments.\n\nLet's craft pseudocode:\n\nStart\n→ Decision: 如果 desiredTotal <= 0? // 若已達到目標，先手勝\n    Yes → Step: 回傳 true // 先手已勝\n    No → Decision: 若 maxChoosableInteger <= 0? // 無可選數\n        Yes → Step: 回傳 false // 無法達到\n        No → Step: 初始化 totalSum = maxChoosableInteger * (maxChoosableInteger+1)/2 // 全部數字總和\n→ Decision: 如果 totalSum < desiredTotal? // 目標無法達到\n    Yes → Step: 回傳 false // 先手必輸\n    No → Step: 初始化 memo map // 用於記錄已探索狀態\n→ Step: 定義函式 canWin(usedMask, currentTotal) // DFS\n    → Decision: 如果 currentTotal >= desiredTotal? // 先手已達標\n        Yes → Step: 回傳 true // 先手勝\n        No →\n            → Decision: 若 usedMask 已在 memo? // 已記錄\n                Yes → Step: 回傳 memo[usedMask] // 直接回傳\n                No →\n                    → Step: win = false // 假設先手無法勝\n                    → Step: 迭代 i from 1 to maxChoosableInteger\n                        → Decision: 若 (usedMask >> (i-1)) & 1 == 0? // i 未被使用\n                            Yes →\n                                → Step: nextMask = usedMask | (1 << (i-1))\n                                → Step: oppWin = canWin(nextMask, currentTotal + i) // 對手的結果\n                                → Decision: 若 !oppWin? // 若對手無法勝\n                                    Yes →\n                                        → Step: win = true\n                                        → Step: break // 找到一個贏\n                    → Step: memo[usedMask] = win\n                    → Step: 回傳 win\n→ Step: 回傳 canWin(0, 0) // 起始狀態\n\nNeed to maintain explanation after each line.\n\nLet's ensure formatting: each line \"虛擬碼步驟 [space] // 解釋\". Use arrows: Start, Decision, Yes →, No →, Step. Also maybe use indent for nested decisions: but the example shows nested indentation with spaces. We'll follow same style.\n\nBe careful with syntax: \"Decision:\" lines. Indentation uses spaces. Provide explanation after each line.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Decision: 如果 desiredTotal <= 0? // 目標已滿足，先手直接勝\n    Yes → Step: 回傳 true // 先手已經勝利\n    No  → Decision: 如果 maxChoosableInteger <= 0? // 無可選擇數字\n        Yes → Step: 回傳 false // 先手無法行動，必輸\n        No  → Step: totalSum = maxChoosableInteger * (maxChoosableInteger + 1) / 2 // 計算所有可用數字之和\n→ Decision: 如果 totalSum < desiredTotal? // 所有數字加起來也達不到目標\n    Yes → Step: 回傳 false // 先手必輸\n    No  → Step: memo = {} // 建立記憶表，鍵為已使用數字的位元遮罩\n→ Step: 定義函式 canWin(usedMask, currentTotal) // DFS+記憶化\n    → Decision: 如果 currentTotal >= desiredTotal? // 目前總和已達目標\n        Yes → Step: 回傳 true // 先手勝\n        No  →\n            → Decision: 如果 usedMask 在 memo? // 先前已計算過此狀態\n                Yes → Step: 回傳 memo[usedMask] // 直接回傳結果\n                No  →\n                    → Step: win = false // 預設先手無法勝\n                    → Step: 迭代 i 從 1 到 maxChoosableInteger\n                        → Decision: 如果 (usedMask >> (i-1)) & 1 == 0? // i 未被使用\n                            Yes →\n                                → Step: nextMask = usedMask | (1 << (i-1)) // 標記 i 已使用\n                                → Step: oppWin = canWin(nextMask, currentTotal + i) // 對手的勝負\n                                → Decision: 如果 !oppWin? // 若對手無法勝\n                                    Yes →\n                                        → Step: win = true // 找到一個能使對手失敗的選擇\n                                        → Step: 跳出迴圈 // 不再嘗試其他數字\n                    → Step: memo[usedMask] = win // 記錄此狀態結果\n                    → Step: 回傳 win // 回傳先手是否能勝\n→ Step: 回傳 canWin(0, 0) // 從初始狀態開始判斷\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom functools import lru_cache\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        # If the desired total is already met or exceeded, the first player wins immediately\n        if desiredTotal <= 0:\n            return True\n        # If the sum of all available numbers is less than the desired total,\n        # it's impossible to reach the target\n        if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\n            return False\n\n        memo = {}\n\n        def can_win(used: int, total: int) -> bool:\n            # If we have already computed this state, return the cached result\n            if used in memo:\n                return memo[used]\n            # Try each unused number\n            for i in range(maxChoosableInteger):\n                bit = 1 << i\n                if not (used & bit):\n                    number = i + 1\n                    # If picking this number reaches or exceeds the target, current player wins\n                    if total <= number or not can_win(used | bit, total - number):\n                        memo[used] = True\n                        return True\n            # No winning move found for current player\n            memo[used] = False\n            return False\n\n        return can_win(0, desiredTotal)\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        print(\"false\")\n        return\n    maxChoosableInteger, desiredTotal = nums[0], nums[1]\n    solution = Solution()\n    result = solution.canIWin(maxChoosableInteger, desiredTotal)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "maxChoosableInteger = 10, desiredTotal = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "maxChoosableInteger = 10, desiredTotal = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "maxChoosableInteger = 10, desiredTotal = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode122.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock II",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm to compute max profit with unlimited transactions but only one share at a time. Classic solution: sum of positive differences.\n\nSo pseudo-code:\n\nStart\n→ Step 1: 初始化 profit = 0, holding = false, boughtPrice = 0\n→ Step 2: 迭代每一天 i\n    → Decision: 如果 holding = false? \n        Yes → Decision: 是否應該買進？ // But typical greedy: just track max.\nBut simpler: for each day, if price > previous price, add diff to profit. That yields maximum profit.\n\nBut need to reflect unlimited transactions.\n\nWe can produce steps:\n\nStart\n→ Step 1: profit ← 0\n→ Step 2: for i from 1 to len(prices)-1\n    → Decision: if prices[i] > prices[i-1]?\n        Yes → profit ← profit + (prices[i] - prices[i-1]) // sell at higher price\n        No  → // do nothing\n→ End\n\nBut also can include buying and selling concept.\n\nAlternatively:\n\nStart\n→ Step 1: profit ← 0\n→ Step 2: for each price in prices\n    → Step 3: if not holding AND next price > current price? but we can just sum differences.\n\nLet's produce a clear pseudo-code following the required format. Need \"虛擬碼步驟\" then comment. Use arrow symbols.\n\nWe must ensure each line ends with `// 解釋/說明`.\n\nAlso use Start, End, Decision.\n\nWe'll include loop constructs: `for i in 0..len-1`. Use arrow indentations.\n\nWe also might show buying and selling logic: `If holding` etc.\n\nBut easiest is difference method. Provide clear steps.\n\nOk produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: profit ← 0 // 初始化總利潤為 0\n→ Step 2: if prices is empty? // 檢查輸入是否有效\n    Yes → End // 沒有價格資料，直接結束\n    No  → // 繼續執行\n→ Step 3: for i ← 1 to len(prices) - 1 // 從第二天開始遍歷每一天\n    → Decision: if prices[i] > prices[i-1]? // 本天價格高於前一天\n        Yes → profit ← profit + (prices[i] - prices[i-1]) // 在本天賣出，取得利潤差值\n        No  → // 本天價格不高於前一天，保持不做交易\n→ End // 程式執行結束，profit 為最大可達利潤\n\n---  \n**說明**：  \n- 透過累加所有正向價格差值，相當於在每個上漲趨勢的起點買進，頂點賣出。  \n- 這種做法等效於「買入-賣出」多次但同時只持一股的限制。  \n- 若需更直觀的「買」與「賣」步驟，可在判斷 `prices[i] > prices[i-1]` 時，先執行 `sell`，再在下一天若仍上漲時執行 `buy`，但邏輯本質相同。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 將輸入轉換為價格列表\n    try:\n        # 找出 '[' 與 ']' 之間的子字串，再用 literal_eval 解析\n        start = data.find('[')\n        end = data.rfind(']')\n        if start != -1 and end != -1:\n            prices = ast.literal_eval(data[start:end+1])\n        else:\n            prices = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，直接結束\n        sys.exit(0)\n    sol = Solution()\n    result = sol.maxProfit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode214.json",
    "problem_index_in_file": 0,
    "title": "Shortest Palindrome",
    "description_snippet": "You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n\nRe...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solution: Given string s, find shortest palindrome by adding chars to front. Standard algorithm: find longest palindromic prefix, then add reverse of suffix. Use KMP on s + '#' + reverse(s) to find longest prefix that matches suffix.\n\nWe need to produce step-by-step virtual code.\n\nThe requirement: output each line with virtual code step + explanation. Use arrow notation and structure.\n\nWe need to be careful: we cannot output actual code, only virtual steps.\n\nLet's produce steps:\n\nStart\n\n→ Step 1: Set rev = reverse(s) // get reverse string\n\n→ Step 2: Create combined = s + \"#\" + rev // concatenate with delimiter\n\n→ Step 3: Initialize array lps of length combined length with zeros // for KMP\n\n→ Step 4: Compute LPS array for combined string // standard KMP preprocessing\n\n→ Step 5: lps_val = lps[last_index] // longest prefix that is also suffix\n\n→ Step 6: suffix_to_add = rev.substring(0, s.length - lps_val) // characters not covered\n\n→ Step 7: Return suffix_to_add + s // prepend missing part to form palindrome\n\nBut need to be \"逐行\" and each line must contain \"虛擬碼步驟\" + \" // 解釋/說明\".\n\nUse arrows and structure. Example format uses \"Start // ...\". They used \"→ Step 1: ...\" style.\n\nAlso might need Decision nodes? Not necessary here.\n\nBut we can structure with decision: If s empty etc. But may not needed.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Let rev = reverse(s) // 取得 s 的逆序\n→ Step 2: Let combined = s + \"#\" + rev // 組成主字串，用 \"#\" 作分隔符\n→ Step 3: Initialise lps array of length combined.length with 0 // 用於 KMP 的前綴函數\n→ Step 4: Set i = 1, length = 0 // KMP 迭代準備\n→ Decision: 是否 i < combined.length? // 開始計算 LPS\n    Yes → Step 5: If combined[i] == combined[length] then length++ ; lps[i] = length ; i++ // 匹配成功\n    No  → Step 5: Else if length != 0 then length = lps[length-1] // 退回較長前綴\n    No  → Step 5: Else lps[i] = 0 ; i++ // 無匹配\n← End Decision // LPS 完成\n→ Step 6: Let matchLen = lps[combined.length-1] // 最長匹配前綴長度\n→ Step 7: Let prefixToAdd = rev.substring(0, s.length - matchLen) // 未被匹配的後綴\n→ Step 8: Return prefixToAdd + s // 將缺失部分加在前面，得到最短回文\nEnd // 程式結束\n\nBut we should use arrow notation properly.\n\nThey used:\n\nStart // 程式開始執行\n→ Step 1: ... \n→ Decision: ...\n    Yes → ...\n    No  → ...\n\nSo we must maintain that pattern.\n\nAlso each line after the arrow has a space then the step, then \" // 說明\". We cannot output actual code but we can reference variables.\n\nThus we produce lines accordingly.\n\nWe also need to mention variable names: s, rev, combined, lps, i, length, matchLen, prefixToAdd.\n\nWe must ensure each line includes \" // \" explanation.\n\nAlso we might include the KMP loop as multiple steps? But we can simplify as one step: compute LPS. But to show the algorithm we might use Decision for each iteration? Too many lines? But we can keep concise.\n\nBut the requirement: \"逐行\" but not necessarily each step of algorithm loops. But we can break into bigger steps.\n\nBut we need to reflect that we compute LPS via KMP; can be one step or more.\n\nWe might do:\n\n→ Step 4: Compute LPS array for combined // 典型 KMP 前綴函數計算\n\nSimplify.\n\nThus final output:\n\nStart // 程式開始執行\n→ Step 1: Let rev = reverse(s) // 取得 s 的逆序\n→ Step 2: Let combined = s + \"#\" + rev // 組成主字串，使用 '#' 作分隔符\n→ Step 3: Initialise lps array of length combined.length with zeros // 用於 KMP 的前綴函數\n→ Step 4: Compute LPS array for combined // 透過 KMP 前綴函數找出每個位置的最大前綴後綴長度\n→ Step 5: Let matchLen = lps[combined.length - 1] // 最長匹配前綴長度，表示 s 的最大回文前綴長度\n→ Step 6: Let prefixToAdd = rev.substring(0, s.length - matchLen) // 需要添加到前面以完成回文的字元\n→ Step 7: Return prefixToAdd + s // 將缺失部分加在前面得到最短回文\nEnd // 程式結束\n\nWe need to use \"→\" before each step and \"Start\" at top.\n\nLet's format accordingly. Ensure each line ends with explanation.\n\nCheck each line: \"Start // 程式開始執行\" is fine.\n\nBut we must maintain consistent \"→\" prefix. For the first step, use \"→ Step 1:\" etc.\n\nYes.\n\nWe can also add \"Decision\" lines but not necessary.\n\nBut maybe the requirement: use arrow and structure.\n\nBut the example includes \"Decision:\" for branching.\n\nBut our algorithm doesn't require branching except maybe if s is empty. But we can ignore.\n\nBut to be safe, maybe add a decision at start: if s empty return s. But not necessary.\n\nBut we can include a simple decision: Decision: s empty? Yes → Step 1: return s. No → ... But we can keep simple.\n\nBut might not be needed.\n\nHowever to follow format, we can add a Decision to handle edge case. Let's do:\n\n→ Decision: s is empty? // 檢查是否為空字串\n    Yes → Step 1: Return s // 空字串本身即為回文\n    No  → Step 2: Let rev = reverse(s) // 取得 s 的逆序\n\nBut we need to maintain step numbers accordingly. But step numbers might not be sequential due to branching.\n\nAlternatively, we can keep sequential steps ignoring empty case; it's fine.\n\nThe user didn't specify to handle edge case, but it's fine.\n\nWe should not use \"Start\" as \"Start // 程式開始執行\".\n\nWe need to ensure each line has \"虛擬碼步驟\" + \" // 解釋/說明\". The example shows \"Start // 程式開始執行\". Then \"→ Step 1: ...\". So we replicate.\n\nThus final answer will be:\n\nStart // 程式開始執行\n→ Step 1: Let rev = reverse(s) // 取得 s 的逆序\n→ Step 2: Let combined = s + \"#\" + rev // 組成主字串，使用 '#' 作分隔符\n→ Step 3: Initialise lps array of length combined.length with zeros // 用於 KMP 的前綴函數\n→ Step 4: Compute LPS array for combined // 透過 KMP 前綴函數找出每個位置的最大前綴後綴長度\n→ Step 5: Let matchLen = lps[combined.length - 1] // 最長匹配前綴長度，表示 s 的最大回文前綴長度\n→ Step 6: Let prefixToAdd = rev.substring(0, s.length - matchLen) // 需要添加到前面以完成回文的字元\n→ Step 7: Return prefixToAdd + s // 將缺失部分加在前面得到最短回文\nEnd // 程式結束\n\nThis meets requirements.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let rev = reverse(s) // 取得 s 的逆序  \n→ Step 2: Let combined = s + \"#\" + rev // 組成主字串，使用 '#' 作分隔符  \n→ Step 3: Initialise lps array of length combined.length with zeros // 用於 KMP 的前綴函數  \n→ Step 4: Compute LPS array for combined // 透過 KMP 前綴函數找出每個位置的最大前綴後綴長度  \n→ Step 5: Let matchLen = lps[combined.length - 1] // 最長匹配前綴長度，表示 s 的最大回文前綴長度  \n→ Step 6: Let prefixToAdd = rev.substring(0, s.length - matchLen) // 需要添加到前面以完成回文的字元  \n→ Step 7: Return prefixToAdd + s // 將缺失部分加在前面得到最短回文  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef shortest_palindrome(s: str) -> str:\n    if not s:\n        return \"\"\n    temp = s + '#' + s[::-1]\n    n = len(temp)\n    lps = [0] * n\n    for i in range(1, n):\n        length = lps[i - 1]\n        while length > 0 and temp[i] != temp[length]:\n            length = lps[length - 1]\n        if temp[i] == temp[length]:\n            length += 1\n        lps[i] = length\n    to_add = s[lps[-1]:][::-1]\n    return to_add + s\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n    # Extract string inside single quotes if present\n    match = re.search(r\"'([^']*)'\", data)\n    s = match.group(1) if match else data\n    result = shortest_palindrome(s)\n    print(f\"'{result}'\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'aacecaaa'",
          "expected_output": "'aaacecaaa'",
          "success": true,
          "output": "'aaacecaaa'"
        },
        {
          "example_index": 1,
          "input": "s = 'abcd'",
          "expected_output": "'dcbabcd'",
          "success": true,
          "output": "'dcbabcd'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode713.json",
    "problem_index_in_file": 0,
    "title": "Subarray Product Less Than K",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for sliding window approach. Provide lines with \"Start\", \"→ Step\", \"→ Decision\". Provide explanation.\n\nWe should produce lines such as:\n\nStart // 程式開始執行\n→ Step 1: 初始化左指標 left = 0, 乘積 product = 1, 結果 count = 0 // 初始設置\n→ Step 2: 從 i = 0 到 nums.length-1 // 迴圈遍歷\n    → Step 3: product = product * nums[i] // 更新乘積\n    → Decision: product < k? // 判斷是否滿足條件\n        Yes → Step 4: count = count + (i - left + 1) // 加入子陣列數量\n        No → Decision: left <= i? // 要縮小窗口\n            Yes → Step 5: While product >= k and left <= i: // 循環縮小窗口\n                    product = product / nums[left]\n                    left = left + 1\n            No → // (這裡不會發生)\n            // After while, add count if product < k\n            Step 6: count = count + (i - left + 1) // 新窗口\n    // loop continues\nEnd // 程式結束\n\nBut need to handle case k <= 1: return 0.\n\nAdd step for that.\n\nAlso we need \"虛擬碼步驟\" preceding explanation. Eg:\n\nStart // 程式開始執行\n\n→ Step 1: if k <= 1 return 0 // 當 k <= 1 時無法滿足\n\nBut virtual code must use arrow format.\n\nWe can write:\n\n→ Decision: if k <= 1? // 檢查 k 是否 <=1\n    Yes → Step 1: return 0 // 直接返回 0\n    No  → Step 2: left = 0, product = 1, count = 0 // 初始化\n\nBut return inside decision might conflict with structure. Could be separate.\n\nWe need to produce a linear pseudo-code. But we can incorporate decision.\n\nBetter structure:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, product = 1, count = 0 // 初始化變量\n→ Decision: k <= 1? // 檢查 k 是否 <= 1\n    Yes → Step 2: return 0 // 直接返回 0\n    No  → Step 3: 進入主循環\n→ Step 3: for i = 0 to nums.length - 1 // 主迴圈遍歷\n    → Step 4: product = product * nums[i] // 更新乘積\n    → Decision: product < k? // 檢查乘積是否符合條件\n        Yes → Step 5: count = count + (i - left + 1) // 直接計數\n        No  → Decision: left <= i? // 開始縮小窗口\n            Yes → Step 6: While product >= k and left <= i\n                        product = product / nums[left] // 除去左邊元素\n                        left = left + 1 // 左移指標\n                // 循環結束後再次檢查\n                Step 7: if product < k then count = count + (i - left + 1) // 計數\n            No  → // 不會發生\n→ End // 程式結束\n\nWe must ensure each line has the format: \"虛擬碼步驟 [space] // 解釋\"\n\nAlso we need arrow \"→\" preceding steps, \"Decision:\" for decision.\n\nWe need to incorporate the \"Yes →\" and \"No →\" sub-steps properly.\n\nWe need to format sub-steps inside decision indentation, but still each line start with \"→\".\n\nIn example, they had indentation for sub-steps.\n\nThus we produce lines with indentation.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: left = 0; product = 1; count = 0 // 初始化指標、乘積及計數器\n→ Decision: k <= 1? // 若 k 小於等於 1，沒有符合條件的子陣列\n    Yes → Step 2: return 0 // 直接返回 0\n    No  → Step 3: 進入主循環\n→ Step 3: for i = 0 to nums.length - 1 // 依序遍歷陣列\n    → Step 4: product = product * nums[i] // 加入新元素更新乘積\n    → Decision: product < k? // 檢查當前乘積是否已滿足條件\n        Yes → Step 5: count = count + (i - left + 1) // 所有以 i 為右端點的子陣列皆符合\n        No  → Decision: left <= i? // 需要縮小窗口\n            Yes → Step 6: while product >= k and left <= i\n                        product = product / nums[left] // 移除左邊元素\n                        left = left + 1 // 左移指標\n                // 退出 while 循環後重新計算\n                Step 7: if product < k then count = count + (i - left + 1) // 重新計數\n            No  → // 當 left > i 時，無法縮小窗口\n→ End // 程式結束\n\nBut we used Step 3 for loop and also Step 3 again for entering main loop; conflict. Should rename.\n\nLet's rename step numbers unique.\n\nStart // 程式開始執行\n→ Step 1: left = 0; product = 1; count = 0 // 初始化指標、乘積及計數器\n→ Decision: k <= 1? // 若 k 小於等於 1，沒有符合條件的子陣列\n    Yes → Step 2: return 0 // 直接返回 0\n    No  → Step 3: // 進入主循環\n→ Step 4: for i = 0 to nums.length - 1 // 依序遍歷陣列\n    → Step 5: product = product * nums[i] // 加入新元素更新乘積\n    → Decision: product < k? // 檢查當前乘積是否已滿足條件\n        Yes → Step 6: count = count + (i - left + 1) // 所有以 i 為右端點的子陣列皆符合\n        No  → Decision: left <= i? // 需要縮小窗口\n            Yes → Step 7: while product >= k and left <= i\n                        product = product / nums[left] // 移除左邊元素\n                        left = left + 1 // 左移指標\n                // 退出 while 循環後重新計算\n                Step 8: if product < k then count = count + (i - left + 1) // 重新計數\n            No  → // 當 left > i 時，無法縮小窗口\n→ End // 程式結束\n\nBut we need each line \"虛擬碼步驟\" and explanation. For while we may need to indent.\n\nThe example uses nested indentation:\n\n→ Decision: ...\n    Yes → ...\n    No  → Decision: ...\n        Yes → ...\n        No  → ...\n\nSo we can do that.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0; product = 1; count = 0 // 初始化左指標、乘積及計數器  \n→ Decision: k <= 1? // 若 k 小於等於 1，所有子陣列的乘積必定不小於 k  \n    Yes → Step 2: return 0 // 直接返回 0，結束程序  \n    No  → Step 3: // 進入主循環  \n→ Step 4: for i = 0 to nums.length - 1 // 逐個遍歷陣列中的元素  \n    → Step 5: product = product * nums[i] // 將當前元素加入乘積  \n    → Decision: product < k? // 檢查當前子陣列乘積是否已滿足條件  \n        Yes → Step 6: count = count + (i - left + 1) // 以 i 為右端點的所有子陣列均符合條件，累加計數  \n        No  → Decision: left <= i? // 若乘積不符合，需要縮小窗口  \n            Yes → Step 7: while product >= k and left <= i // 循環縮小窗口直到乘積小於 k  \n                        product = product / nums[left] // 移除左邊元素的影響  \n                        left = left + 1 // 左指標右移  \n                // 退出 while 循環後重新檢查乘積  \n                Step 8: if product < k then count = count + (i - left + 1) // 重新計算符合條件的子陣列數量  \n            No  → // 當 left > i 時，已無法進一步縮小窗口，直接跳過  \n→ End // 程式結束",
      "generated_code": "import sys, re, ast\n\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums, k):\n        if k <= 1:\n            return 0\n        prod = 1\n        left = 0\n        res = 0\n        for right, val in enumerate(nums):\n            prod *= val\n            while prod >= k and left <= right:\n                prod //= nums[left]\n                left += 1\n            res += right - left + 1\n        return res\n\ndef parse_input(data: str):\n    data = data.strip()\n    # Try to find list inside brackets\n    list_match = re.search(r'\\[(.*?)\\]', data)\n    if list_match:\n        nums_str = '[' + list_match.group(1) + ']'\n        nums = ast.literal_eval(nums_str)\n        # find k\n        k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n        if k_match:\n            k = int(k_match.group(1))\n        else:\n            # maybe after comma\n            nums_part = data.split(']')[1]\n            k_match = re.search(r'(\\d+)', nums_part)\n            k = int(k_match.group(1)) if k_match else 0\n    else:\n        # assume first line numbers, second line k\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            nums = list(map(int, lines[0].split()))\n            k = int(lines[1].strip())\n        else:\n            parts = data.split()\n            nums = list(map(int, parts[:-1]))\n            k = int(parts[-1])\n    return nums, k\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    nums, k = parse_input(data)\n    sol = Solution()\n    result = sol.numSubarrayProductLessThanK(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,5,2,6], k = 100",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3], k = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode187.json",
    "problem_index_in_file": 0,
    "title": "Repeated DNA Sequences",
    "description_snippet": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. For e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find all 10-letter-long substrings that appear more than once in string s. Classic LeetCode 187. Approach: sliding window of length 10, hash set for seen, result set. Use dictionary. Complexity O(n). We'll produce step-by-step pseudocode lines with explanations.\n\nWe must follow format: \"Start // 程式開始執行\" etc.\n\nUse arrow lines. Should produce each step line.\n\nProbably steps:\n\nStart\n→ Step 1: If length of s < 10 then return empty // early exit\n→ Step 2: 初始化空集合 seen // track substrings seen once\n→ Step 3: 初始化空集合 repeated // track substrings seen >1\n→ Step 4: 循環 i from 0 to len(s)-10 // sliding window\n    → Step 5: substring = s[i:i+10] // current 10-char sequence\n    → Decision: substring in seen? // has appeared before?\n        Yes → Step 6: add substring to repeated // record duplicate\n        No  → Step 7: add substring to seen // first occurrence\n→ Step 8: 返回 repeated // convert to list or set\nEnd\n\nWe can also mention use of hash sets. Provide each line with explanation.\n\nMake sure each line ends with // 解釋.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 s 的長度 < 10? // 檢查輸入是否足夠長以包含 10 字母序列  \n  Yes → Step 1: 返回空集合 // 沒有足夠長度，直接回傳空結果  \n  No  → Step 2: 初始化空集合 seen // 用於儲存第一次遇到的 10 字母子序列  \n→ Step 3: 初始化空集合 repeated // 用於儲存已重複出現的 10 字母子序列  \n→ Step 4: 循環 i 從 0 到 len(s)-10 // 以滑動視窗方式遍歷所有長度為 10 的子序列  \n  → Step 5: substring ← s[i:i+10] // 取得目前的 10 字母子序列  \n  → Decision: substring 是否已存在於 seen? // 判斷此子序列是否已出現過  \n    Yes → Step 6: 將 substring 加入 repeated // 已重複，記錄下來  \n    No  → Step 7: 將 substring 加入 seen // 第一次出現，加入 seen 集合  \n→ Step 8: 返回 repeated // 將重複出現的子序列作為結果回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"找出 DNA 序列中重複出現的 10 字母子序列。\"\"\"\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    # 讀取所有輸入資料\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 從輸入中抽取 DNA 序列\n    # 例如: \"s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'\"\n    # 也可能直接輸入 DNA 字串本身\n    match = re.search(r\"['\\\"](.+?)['\\\"]\", data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data.strip()\n\n    sol = Solution()\n    result = sol.findRepeatedDnaSequences(s)\n\n    # 以列表字面量形式輸出，逗號後不留空格\n    if result:\n        print(f'[\"' + '\",\"'.join(result) + '\"]')\n    else:\n        print('[]')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'"
        },
        {
          "example_index": 1,
          "input": "s = 'AAAAAAAAAAAAA'",
          "expected_output": "[\"AAAAAAAAAA\"]",
          "success": true,
          "output": "[\"AAAAAAAAAA\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode300.json",
    "problem_index_in_file": 0,
    "title": "Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the length of the longest strictly increasing subsequence....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the problem: longest increasing subsequence length. We need to produce algorithm: dynamic programming O(n^2) or patience sorting O(n log n). But we can choose simple DP O(n^2) for clarity. Provide steps.\n\nThe virtual code must be in lines, each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows. Each line includes the step and comment. We should output in Traditional Chinese.\n\nMake sure to include arrows like →. For decisions use Decision: If ...? then Yes→, No→.\n\nLet's write algorithm:\n\nStart\n→ Input nums array\n→ Initialize n = length of nums\n→ If n==0 → Step: return 0 // 空陣列\n→ Initialize dp array of size n, all 1 // 每個位置至少1\n→ For i from 0 to n-1:\n    → For j from 0 to i-1:\n        → Decision: 如果 nums[j] < nums[i]? // 比較前面小於當前\n            Yes → dp[i] = max(dp[i], dp[j]+1) // 更新長度\n→ Step: ans = max(dp) // 找最大值\n→ Output ans\nEnd\n\nWe need to produce step by step with arrow. Use decision block with indentation maybe.\n\nMake sure each line ends with // explanation in Chinese.\n\nLet's format.\n\nWe need arrow symbols: →. For decision, we can indent or show as lines under.\n\nWe need to ensure each line contains \"虛擬碼步驟 // 解釋\". For decision we use \"Decision:\" line and then Yes→ or No→ lines. For loops we use \"→ For i from ...:\" etc.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Input nums // 取得整數陣列\n→ n ← length(nums) // 取得陣列長度\n→ Decision: 如果 n 等於 0? // 檢查是否為空陣列\n    Yes → Return 0 // 若空陣列，長度為 0\n    No  → Continue // 否則繼續\n→ Initialize dp array of size n with all 1 // 每個位置最小長度為 1\n→ For i from 0 to n-1:\n    → For j from 0 to i-1:\n        → Decision: 如果 nums[j] < nums[i]? // 判斷前一個是否小於當前\n            Yes → dp[i] ← max(dp[i], dp[j] + 1) // 更新 dp[i]\n            No  → // 無動作\n→ ans ← max(dp) // 找出最大的 dp 值\n→ Output ans // 回傳結果\nEnd // 程式執行結束\n\nCheck formatting: Each line is \"虛擬碼步驟 // 解釋\". But our decision lines include indentation but still \"Decision: ...\". Should we keep them as separate lines or maybe \"Decision: 如果 nums[j] < nums[i]? // ...\" and then nested \"Yes → ...\"? The example shows:\n\nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // ...\n\nThus they use indentation but still each line has \"Yes → ...\". So we can format accordingly.\n\nBut the indentation lines also need to end with // 解釋. For \"Yes → dp[i] ← max(dp[i], dp[j] + 1) // 更新 dp[i]\".\n\nThe \"No → // 無動作\" should still have // explanation. But maybe we can just comment \"No → // 無動作\" (no operation). But in example they wrote \"No  → Decision: ...\" or \"No  → Step 3: ...\". So we can follow.\n\nWe also need \"Decision:\" line for n==0? That line also ends with // 解釋.\n\nSo final output lines:\n\nStart // 程式開始執行\n→ Input nums // 取得整數陣列\n→ n ← length(nums) // 取得陣列長度\n→ Decision: 如果 n 等於 0? // 檢查是否為空陣列\n    Yes → Return 0 // 若空陣列，長度為 0\n    No  → // 繼續執行\n→ Initialize dp array of size n with all 1 // 每個位置最小長度為 1\n→ For i from 0 to n-1:\n    → For j from 0 to i-1:\n        → Decision: 如果 nums[j] < nums[i]? // 判斷前一個是否小於當前\n            Yes → dp[i] ← max(dp[i], dp[j] + 1) // 更新 dp[i]\n            No  → // 無動作\n→ ans ← max(dp) // 找出最大的 dp 值\n→ Output ans // 回傳結果\nEnd // 程式執行結束\n\nWe should ensure that after \"No  → // 繼續執行\" we have comment. It might be unnecessary but fine.\n\nAlso we may need to close the loops with indentation properly. We can show as above. Provide each line separated by newline.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得整數陣列  \n→ n ← length(nums) // 取得陣列長度  \n→ Decision: 如果 n 等於 0? // 檢查是否為空陣列  \n  Yes → Return 0 // 若空陣列，長度為 0  \n  No  → // 繼續執行  \n→ Initialize dp array of size n with all 1 // 每個位置最小長度為 1  \n→ For i from 0 to n-1:  \n  → For j from 0 to i-1:  \n    → Decision: 如果 nums[j] < nums[i]? // 判斷前一個是否小於當前  \n     Yes → dp[i] ← max(dp[i], dp[j] + 1) // 更新 dp[i]  \n     No  → // 無動作  \n→ ans ← max(dp) // 找出最大的 dp 值  \n→ Output ans // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport bisect\n\nclass Solution:\n    def lengthOfLIS(self, nums):\n        # tails[i] 代表長度為 i+1 的遞增子序列的最小尾端元素\n        tails = []\n        for num in nums:\n            idx = bisect.bisect_left(tails, num)\n            if idx == len(tails):\n                tails.append(num)\n            else:\n                tails[idx] = num\n        return len(tails)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 從輸入中提取所有整數（可處理負數）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    print(sol.lengthOfLIS(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,9,2,5,3,7,101,18]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,3,2,3]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [7,7,7,7,7,7,7]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode46.json",
    "problem_index_in_file": 0,
    "title": "Permutations",
    "description_snippet": "Given an array nums of distinct integers, return all the possible permutations. You can return the a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation after each line, no actual code. Use Start, End, Decision. Provide algorithm for generating all permutations of array of distinct integers. Use backtracking recursion. Provide steps: Start, initialize result list, call backtrack with path and used set. Then in backtrack: if path length == len(nums) -> add copy to result. Else iterate each num: if not used then mark used, add to path, backtrack, then backtrack (unmark, remove). After recursion finish, End. Provide explanations. Ensure each line has virtual code step + space + // explanation. Use arrow lines for steps. Use decisions for base case. Use Yes/No. Should maintain arrow format as examples: \"→ Step 1: ...\" etc. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 generatePermutations(nums) // 接收整數陣列作為輸入  \n→ Step 2: 初始化 result 為空列表 // 用於儲存所有排列  \n→ Step 3: 初始化 path 為空列表 // 目前正在構造的排列  \n→ Step 4: 初始化 used 為空集合 // 追蹤已被選用的數字  \n→ Step 5: 定義遞迴函式 backtrack() // 進行深度優先搜尋  \n→ Step 6: Decision: 如果 len(path) == len(nums)? // 檢查是否已組成完整排列  \n  Yes → Step 7: 將 path 的複製加入 result // 完整排列完成，加入結果  \n  No → Step 8: For each num in nums // 循環所有可能的數字  \n   Decision: 如果 num 未在 used? // 判斷此數字是否已被使用  \n    Yes → Step 9: 將 num 加入 path // 將數字加入當前排列  \n      Step 10: 將 num 加入 used // 標記為已使用  \n      Step 11: 呼叫 backtrack() // 進一步遞迴構造  \n      Step 12: 從 used 中移除 num // 退回，取消標記  \n      Step 13: 從 path 中移除最後一個元素 // 退回，取消加入  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef permute(nums):\n    \"\"\"返回 nums 的所有排列\"\"\"\n    res = []\n\n    def backtrack(start):\n        # ① 基本情況：當 start 等於長度時，已得到完整排列\n        if start == len(nums):\n            res.append(nums[:])  # ② 把目前排列複製加入結果\n            return\n        # ③ 迭代每個可能的交換位置\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]   # ④ 交換\n            backtrack(start + 1)                         # ⑤ 進一步遞迴\n            nums[start], nums[i] = nums[i], nums[start]   # ⑥ 反向交換回原來\n\n    backtrack(0)\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 從輸入中提取數字列表，例如 \"nums = [1,2,3]\"\n    try:\n        # 找到第一個 '[' 和最後一個 ']' 之間的子字串\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        nums_str = data[start:end]\n        nums = ast.literal_eval(nums_str)  # 安全地解析為列表\n    except (ValueError, SyntaxError):\n        # 若解析失敗，直接使用 eval（假設輸入合法）\n        nums = eval(data.split('=')[-1].strip())\n\n    # 計算所有排列\n    result = permute(nums)\n\n    # 輸出結果，與範例輸出的格式保持一致\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode829.json",
    "problem_index_in_file": 0,
    "title": "Consecutive Numbers Sum",
    "description_snippet": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive int...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line, with arrows. We must not output actual code. Just pseudo-code.\n\nWe need to solve problem: number of ways to represent integer n as sum of consecutive positive integers. Known formula: number of odd divisors of n. Or can iterate start and end. We'll produce algorithm: For each start from 1 to n, find sum while sum < n, increment count when sum==n. Complexity O(n^2). Or better: factor n, count odd divisors. Let's produce pseudo-code using divisor method.\n\nPseudo-code: Start, Step: Initialize count=0, Step: For each divisor d of n, if d is odd, count++. But we need count of ways; each odd divisor corresponds to representation. So answer count.\n\nImplementation: iterate d from 1 to sqrt(n), check divisibility. For each divisor d, if n % d ==0, then if d odd increment count. Also if other divisor d2 = n/d and d2 != d, check if d2 odd increment count.\n\nReturn count.\n\nWe'll produce pseudo-code lines accordingly.\n\nLet's follow format: \"Start // 程式開始執行\" etc.\n\nWe need to include arrows and decisions.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得要拆分的數字\n→ Step 2: 初始化計數器 count = 0 // 用於統計分解方式數量\n→ Step 3: 計算上限 limit = floor(sqrt(n)) // 只需檢查到平方根即可\n→ Decision: 是否執行迴圈 1 到 limit? // 檢查迴圈是否需要執行\n    Yes → Step 4: for each d from 1 to limit // 遍歷可能的因子\n        → Step 5: 判斷 n mod d 是否為 0 // 判斷 d 是否為 n 的因子\n            Yes → Step 6: 如果 d 為奇數則 count += 1 // 每個奇數因子對應一種分解\n            No  → // 不做任何操作\n        → Step 7: 計算對應因子 d2 = n / d // 取得配對因子\n            → Decision: d2 是否等於 d? // 避免平方根重複計算\n                Yes → // 兩因子相同，已處理完畢\n                No  → Step 8: 判斷 d2 是否為奇數\n                    → Decision: d2 為奇數?\n                        Yes → Step 9: count += 1 // 計入配對奇數因子\n                        No  → // 不做任何操作\n→ Step 10: 輸出 count // 回傳分解方式數量\nEnd // 程式執行結束\n\nNeed to ensure each line has arrow or decision.\n\nWe might need to show arrows after Step? Use \"→\" before step. For decisions, indent with spaces. Should match format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得要拆分的數字\n→ Step 2: 初始化計數器 count = 0 // 用於統計分解方式數量\n→ Step 3: 計算上限 limit = floor(sqrt(n)) // 只需檢查到平方根即可\n→ Decision: 是否執行迴圈 1 到 limit? // 檢查迴圈是否需要執行\n    Yes → Step 4: for each d from 1 to limit // 遍歷可能的因子\n        → Step 5: 判斷 n mod d 是否為 0 // 判斷 d 是否為 n 的因子\n            Yes → Step 6: 如果 d 為奇數則 count += 1 // 每個奇數因子對應一種分解\n            No  → // 不做任何操作\n        → Step 7: 計算對應因子 d2 = n / d // 取得配對因子\n            → Decision: d2 是否等於 d? // 避免平方根重複計算\n                Yes → // 兩因子相同，已處理完畢\n                No  → Step 8: 判斷 d2 是否為奇數\n                    → Decision: d2 為奇數?\n                        Yes → Step 9: count += 1 // 計入配對奇數因子\n                        No  → // 不做任何操作\n→ Step 10: 輸出 count // 回傳分解方式數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\n\nclass Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        \"\"\"\n        計算 n 可以被寫成連續正整數之和的方式數量。\n        這裡使用雙指標/累加和的方式。\n        \"\"\"\n        count = 0\n        k = 1  # 連續數字的個數\n        # 只要起點為正整數，k*(k-1)/2 必須小於 n\n        while k * (k - 1) // 2 < n:\n            # 需要 (n - 前 k-1 個數的總和) 能被 k 整除\n            if (n - k * (k - 1) // 2) % k == 0:\n                count += 1\n            k += 1\n        return count\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，預期格式類似於 \"n = 5\"\n    data = sys.stdin.read()\n    # 從輸入中擷取第一個整數\n    try:\n        n_str = data.strip().split('=')[1].strip()\n        n = int(n_str)\n    except (IndexError, ValueError):\n        # 如果解析失敗，直接退出\n        sys.exit(1)\n\n    sol = Solution()\n    result = sol.consecutiveNumbersSum(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 9",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode202.json",
    "problem_index_in_file": 0,
    "title": "Happy Number",
    "description_snippet": "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations, line by line. The algorithm: Start, input n, set seen set, while true, if n==1 return true, if n in seen return false, add n to seen, compute sum of squares of digits. Use decision steps. Use Start, End. Need to output only virtual code lines with explanations. Use arrow etc. So we produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入 n // 取得待檢查的正整數\n→ Step 2: 初始化空集合 seen // 用來記錄已出現的數字\n→ Step 3: 重複以下過程直到終止 // 進入循環\n    → Decision: n 等於 1? // 檢查是否已是 1\n        Yes → Step 4: 回傳 true // 若是 1，則為快樂數\n        No  → Decision: n 已在 seen? // 檢查是否重複\n            Yes → Step 5: 回傳 false // 若重複，則不是快樂數\n            No  → Step 6: 把 n 加入 seen // 記錄本次數字\n    → Step 7: 計算 sum_of_squares = Σ (digit^2) // 計算各位數字平方和\n    → Step 8: 設定 n = sum_of_squares // 更新 n\n→ End // 程式結束\n\nBut need to include arrow before each line. For decisions, indent inside. We also need to include step numbers maybe? We can use \"Step 1:\" etc. Should be fine. Also each line must contain virtual code step and explanation. Use comment // after space. Provide indentation for decision branches. Use arrow symbol for steps. Use \"Decision:\" lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入 n // 取得待檢查的正整數  \n→ Step 2: 初始化空集合 seen // 用來記錄已出現的數字  \n→ Step 3: 進入重複循環 // 開始不斷進行計算直到終止  \n    → Decision: n 等於 1? // 檢查目前數字是否已是 1  \n        Yes → Step 4: 回傳 true // 若為 1，則為快樂數，結束程式  \n        No  → Decision: n 已在 seen? // 檢查是否重複出現  \n            Yes → Step 5: 回傳 false // 若已重複，表示進入循環，不是快樂數  \n            No  → Step 6: 把 n 加入 seen // 記錄此數字以供後續檢查  \n    → Step 7: 計算 sum_of_squares = Σ (digit^2) // 將 n 的各位數字平方後相加  \n    → Step 8: 設定 n = sum_of_squares // 更新 n 為新的平方和  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_happy(n: int) -> bool:\n    \"\"\"\n    Determine whether an integer n is a happy number.\n    \"\"\"\n    def next_number(number: int) -> int:\n        total = 0\n        while number:\n            digit = number % 10\n            total += digit * digit\n            number //= 10\n        return total\n\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = next_number(n)\n    return n == 1\n\ndef main() -> None:\n    \"\"\"\n    Read an integer from stdin, determine if it is a happy number,\n    and print 'true' or 'false' accordingly.\n    \"\"\"\n    # Read entire stdin\n    data = sys.stdin.read()\n    # Extract the first integer occurrence\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        # No integer found, nothing to process\n        return\n    n = int(match.group())\n    result = is_happy(n)\n    # Output lowercase true/false as required\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 19",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode189.json",
    "problem_index_in_file": 0,
    "title": "Rotate Array",
    "description_snippet": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. Must be line by line. Use Start, End, Decision, arrows. For rotate array to right by k steps. Steps: handle k >= n, adjust k% n. Use reverse method? Could use extra array approach. But we can choose algorithm. Let's do reverse algorithm: reverse entire array, reverse first k, reverse remaining n-k. Provide step-by-step.\n\nWe need to output lines:\n\nStart\n→ Step 1: Read nums array and k // Get input\n→ Step 2: n ← length of nums // array size\n→ Decision: 如果 n == 0? // if empty\n    Yes → End // nothing to do\n    No\n→ Step 3: k ← k mod n // normalize steps\n→ Step 4: reverse(nums, 0, n-1) // reverse entire array\n→ Step 5: reverse(nums, 0, k-1) // reverse first k elements\n→ Step 6: reverse(nums, k, n-1) // reverse rest\n→ End // done\n\nBut include function reverse description lines? We might include Step 7: return nums.\n\nBetter: Step 6: return nums // rotated array\n\nInclude explanation comments. Ensure using arrow syntax and indentation.\n\nLet's output as plain lines.\n\nCheck formatting: each line: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nUse arrow \"→\" preceding each step. For decisions, we use \"Decision:\" and indent Yes / No lines. The example uses indent via spaces. Let's replicate.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取陣列 nums 與整數 k // 取得輸入資料\n→ Step 2: n ← nums.length // 取得陣列長度\n→ Decision: 如果 n = 0? // 檢查是否為空陣列\n    Yes → End // 空陣列無需旋轉\n    No\n→ Step 3: k ← k mod n // 將步數縮減到範圍內\n→ Step 4: reverse(nums, 0, n-1) // 先將整個陣列反轉\n→ Step 5: reverse(nums, 0, k-1) // 再將前 k 個元素反轉\n→ Step 6: reverse(nums, k, n-1) // 最後將後 n-k 個元素反轉\n→ Step 7: return nums // 回傳已旋轉的陣列\nEnd // 程式執行結束\n\nMake sure each line uses arrow and comment. Provide indent for decision branches.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取陣列 nums 與整數 k // 取得輸入資料\n→ Step 2: n ← nums.length // 取得陣列長度\n→ Decision: 如果 n = 0? // 檢查是否為空陣列\n    Yes → End // 空陣列無需旋轉\n    No\n→ Step 3: k ← k mod n // 將步數縮減到範圍內\n→ Step 4: reverse(nums, 0, n-1) // 先將整個陣列反轉\n→ Step 5: reverse(nums, 0, k-1) // 再將前 k 個元素反轉\n→ Step 6: reverse(nums, k, n-1) // 最後將後 n-k 個元素反轉\n→ Step 7: return nums // 回傳已旋轉的陣列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def rotate(self, nums, k):\n        \"\"\"\n        Rotate the list nums to the right by k steps in-place.\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return\n        k %= n\n        if k == 0:\n            return\n        # 使用切片實現旋轉：取最後 k 個元素 + 前面 n-k 個元素\n        nums[:] = nums[-k:] + nums[:-k]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中提取 nums 列表和 k 整數。\n    支援形如 'nums = [1,2,3], k = 2' 的格式。\n    \"\"\"\n    nums_match = re.search(r'\\[(.*?)\\]', data, re.S)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not k_match:\n        return [], 0\n\n    nums_str = nums_match.group(1)\n    # 允許逗號後有空白\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    k = int(k_match.group(1))\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    nums, k = parse_input(raw_input)\n\n    solution = Solution()\n    solution.rotate(nums, k)\n\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "success": true,
          "output": "[5, 6, 7, 1, 2, 3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "success": true,
          "output": "[3, 99, -1, -100]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode492.json",
    "problem_index_in_file": 0,
    "title": "Construct the Rectangle",
    "description_snippet": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps. We need to produce line by line with arrow arrows, Start End, Decision. Need to describe algorithm: given area A, find L, W integer? Assume integers. Find pair of factors L>=W with minimal difference. Approach: iterate W from floor(sqrt(A)) down to 1, check if divides A, then L=A/W, ensure L>=W. When found first, difference minimal. Output [L, W].\n\nLet's produce steps:\n\nStart\n→ Step 1: Input area A // get target area\n→ Step 2: Compute sqrtA = floor(sqrt(A)) // start from largest possible width\n→ Step 3: Initialize bestL = A, bestW = 1 // default pair (A,1)\n→ Step 4: For W from sqrtA down to 1 // iterate possible widths\n    → Decision: Does A mod W == 0? // check if W divides A\n        Yes → Step 5: L = A / W // compute corresponding length\n            → Decision: Is L >= W? // ensure length not smaller\n                Yes → Step 6: bestL = L ; bestW = W ; Break loop // found optimal\n                No → No operation // should not happen because W <= sqrtA ensures L >= W\n        No → No operation // continue loop\n→ Step 7: Return [bestL, bestW] // output result\nEnd\n\nBut need to ensure minimal difference: Because we iterate from sqrtA downward, first factor encountered yields L>=W and difference minimal. So break after first found.\n\nAdd some comments.\n\nNeed to use Decision and arrows properly. For loop may be represented by Decision? Might use Step for loop? Use \"Step: For W from sqrtA down to 1\" as a loop structure, maybe we use \"Decision:\"? The spec: Use 虛擬碼的箭頭 (→, Yes →, No →) and 結構 (Start, End, Decision:). We can represent loop as Step maybe. Let's keep consistent with example: Use Step for loop.\n\nWe need to include [空格] between virtual code step and comment. Ensure no code output.\n\nLet's craft final output lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入目標面積 A // 取得使用者指定的面積  \n→ Step 2: 計算 sqrtA = floor(√A) // 取得面積平方根的整數下限，作為寬度的起點  \n→ Step 3: 初始化 bestL = A, bestW = 1 // 預設寬度為 1，長度為面積本身  \n→ Step 4: 迴圈 W 從 sqrtA 下降至 1 // 遍歷所有可能的寬度  \n  → Decision: A mod W == 0? // 檢查 W 是否為面積的因數  \n   Yes → Step 5: 計算 L = A / W // 獲得相對應的長度  \n    → Decision: L >= W? // 確保長度不小於寬度（此條件應總成立）  \n     Yes → Step 6: bestL = L ; bestW = W ; 跳出迴圈 // 找到最小差距的矩形，結束搜尋  \n     No → No // 理論上不會發生，保持流程完整  \n   No → No // 不是因數，繼續下一個 W  \n→ Step 7: 返回 [bestL, bestW] // 輸出長寬配對  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\n\ndef construct_rectangle(area: int):\n    \"\"\"Return [L, W] for the rectangle with given area.\n    L >= W and L-W is minimized.\"\"\"\n    w = int(math.isqrt(area))          # start from floor(sqrt(area))\n    while area % w != 0:               # find the largest divisor <= sqrt(area)\n        w -= 1\n    return [area // w, w]              # L = area // w, W = w\n\nif __name__ == \"__main__\":\n    # Read whole input; expected format like \"area = 4\"\n    data = sys.stdin.read().strip()\n    if '=' in data:\n        _, val = data.split('=', 1)\n        area = int(val.strip())\n    else:\n        area = int(data)\n    result = construct_rectangle(area)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "area = 4",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "area = 37",
          "expected_output": "[37,1]",
          "success": true,
          "output": "[37, 1]"
        },
        {
          "example_index": 2,
          "input": "area = 122122",
          "expected_output": "[427,286]",
          "success": true,
          "output": "[427, 286]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode383.json",
    "problem_index_in_file": 0,
    "title": "Ransom Note",
    "description_snippet": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code in Traditional Chinese. Steps: Start, count letters in magazine, iterate ransomNote letters check counts. Output true/false. Use virtual code arrow style.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\" with arrow arrow or decision lines. Let's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 magazineCount // 用來儲存每個字母在雜誌中的出現次數\n→ Step 2: For each char in magazine: increment magazineCount[char] // 逐字計數\n→ Step 3: For each char in ransomNote:\n    → Decision: 若 magazineCount[char] > 0? // 是否還有此字母可用\n        Yes → magazineCount[char]-- // 消耗一次\n        No  → Step 4: 返回 false // 無法構成\n→ Step 5: 返回 true // 所有字母都足夠\nEnd // 程式執行結束\n\nBut need to follow format: \"虛擬碼步驟\" then space then \"// 解釋\". So each line must include that. Also use \"Start\", \"End\". Use arrow \"→\". For decision we need \"Decision: ...\" with Yes → and No →. Also indentation? We can use spaces.\n\nMake sure each line follows: \"虛擬碼步驟 // 解釋\". So \"Start // 程式開始執行\" etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 magazineCount // 用來記錄雜誌中每個字母的出現次數  \n→ Step 2: For 每個 char in magazine: magazineCount[char] = magazineCount.get(char, 0) + 1 // 逐字計數  \n→ Step 3: For 每個 char in ransomNote:  \n  Decision: 若 magazineCount.get(char, 0) > 0? // 檢查此字母是否還可用  \n   Yes → magazineCount[char] = magazineCount[char] - 1 // 消耗一次該字母  \n   No  → Step 4: 返回 false // 無法構成，結束流程  \n→ Step 5: 返回 true // 所有字母都足夠，能構成 ransomNote  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport collections\nimport re\n\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        # 用 Counter 計算兩個字串中每個字母的出現次數\n        ransom_count = collections.Counter(ransomNote)\n        magazine_count = collections.Counter(magazine)\n        # 若 ransomNote 中任一字母的需求超過 magazine 的供應，返回 False\n        for char, cnt in ransom_count.items():\n            if cnt > magazine_count.get(char, 0):\n                return False\n        return True\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 從字串中提取兩個被雙引號包住的字串\n    matches = re.findall(r'\"(.*?)\"', data)\n    if len(matches) >= 2:\n        ransomNote, magazine = matches[0], matches[1]\n    else:\n        ransomNote, magazine = \"\", \"\"\n    # 執行判斷並輸出結果\n    sol = Solution()\n    result = sol.canConstruct(ransomNote, magazine)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ransomNote = \"a\", magazine = \"b\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "ransomNote = \"aa\", magazine = \"ab\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode376.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Subsequence",
    "description_snippet": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for longest wiggle subsequence. Should use DP? Classic solution: maintain up[i] and down[i] length of wiggle ending at i with last diff positive or negative. We can produce algorithm: iterate, if nums[i]>prev then up[i]=down[i-1]+1; else if < then down[i]=up[i-1]+1; else no change. Final answer max of up[-1], down[-1].\n\nWe need to output step-by-step pseudocode lines with explanation. Use Start, Decision, etc. Provide virtual code with arrows.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize up[0] = down[0] = 1 // each element alone is wiggle length 1\n→ Step 2: For i from 1 to n-1: // iterate through array\n    → Decision: if nums[i] > nums[i-1] ?\n        Yes → up[i] = down[i-1] + 1 // extend negative to positive\n        No  → Decision: if nums[i] < nums[i-1] ?\n            Yes → down[i] = up[i-1] + 1 // extend positive to negative\n            No  → up[i] = up[i-1]; down[i] = down[i-1] // equal, no change\n→ Step 3: Answer = max(up[n-1], down[n-1]) // longest wiggle subsequence length\nEnd\n\nBut need to ensure DP uses prev values? Classic approach uses two variables up and down instead of arrays. Let's use two variables for simplicity: up=1, down=1. For each i>0, compare nums[i] with nums[i-1] and update accordingly. That yields O(n). Provide virtual code lines accordingly.\n\nLet's craft:\n\nStart\n→ Step 1: If nums is empty return 0 // no elements\n→ Step 2: Set up = 1, down = 1 // lengths of wiggle subsequence ending with last diff positive/negative\n→ Step 3: For i from 1 to length(nums)-1: // iterate over array\n    → Decision: if nums[i] > nums[i-1] ?\n        Yes → up = down + 1 // last difference becomes positive\n        No  → Decision: if nums[i] < nums[i-1] ?\n            Yes → down = up + 1 // last difference becomes negative\n            No  → // equal, no change\n→ Step 4: Result = max(up, down) // longest wiggle subsequence length\n→ Step 5: Return Result\nEnd\n\nAdd explanation each line.\n\nLet's produce output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 如果 nums 為空則回傳 0 // 沒有元素時長度為 0  \n→ Step 2: 設定 up ← 1, down ← 1 // up 為最後差值為正的最長波浪子序列長度，down 為最後差值為負的長度  \n→ Step 3: 從 i = 1 到 nums.length-1 迭代 // 遍歷陣列  \n    → Decision: 如果 nums[i] > nums[i-1] ? // 目前差值為正  \n        Yes → up ← down + 1 // 用之前負差結尾的序列加一，得到正差結尾  \n        No  → Decision: 如果 nums[i] < nums[i-1] ? // 目前差值為負  \n            Yes → down ← up + 1 // 用之前正差結尾的序列加一，得到負差結尾  \n            No  → // nums[i] == nums[i-1]，不改變 up 或 down，因為零差值不允許  \n→ Step 4: Result ← max(up, down) // 取兩種結尾長度的最大值即為最長波浪子序列長度  \n→ Step 5: 回傳 Result // 將結果返回給呼叫者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef wiggle_max_length(nums):\n    if not nums:\n        return 0\n    up = down = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 將形如 \"nums = [1,2,3]\" 的字串轉成 list\n    match = re.search(r'nums\\s*=\\s*(.+)', data, re.DOTALL)\n    if not match:\n        raise ValueError(\"Input format error: expected 'nums = [...]'\")\n    nums_str = match.group(1).strip()\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception as e:\n        raise ValueError(f\"Failed to parse numbers: {e}\")\n    result = wiggle_max_length(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,4,9,2,5]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,17,5,10,13,15,10,5,16,8]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4,5,6,7,8,9]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1249.json",
    "problem_index_in_file": 0,
    "title": "Minimum Remove to Make Valid Parentheses",
    "description_snippet": "Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for removing minimum parentheses to get a valid string. Typical algorithm: first pass left to right to mark unmatched ')', second pass right to left to mark unmatched '('. Then build string.\n\nWe'll produce virtual code with steps: input string, count stack or counter, mark indices, build result.\n\nWe need to output line by line, with arrows and decisions.\n\nWe'll produce something like:\n\nStart // start\n→ Step 1: Initialize counter = 0, marks array of length n with False // prepare\n→ Step 2: For i from 0 to n-1: // first pass\n    Decision: if s[i] == '('? // increment counter\n        Yes → counter++ // seen '('\n    Decision: else if s[i] == ')'?\n        Yes → Decision: if counter > 0? // matched\n            Yes → counter-- // consume '('\n            No → marks[i] = True // unmatched ')'\n    Else // lowercase\n        No // ignore\n→ Step 3: Second pass from n-1 down to 0: // find unmatched '('\n    Decision: if s[i] == '('?\n        Yes → Decision: if counter > 0? // unmatched\n            Yes → marks[i] = True // mark '(' to remove\n            No → counter-- // matched\n    Else // ignore\n→ Step 4: Build result by concatenating s[i] where marks[i] == False // produce final\n→ End // done\n\nBut we must also use \"Yes →\" and \"No →\" for decision branches.\n\nWe need to keep to the specified format: \"虛擬碼步驟 [space] // 解釋\".\n\nUse arrows like → and Yes →, No →.\n\nLet's produce final output.\n\nAlso, we may need to show the result step. And we might include an example but not necessary.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: n = length of s, counter = 0, marks = array of n False // 初始化計數與標記\n\n→ Step 2: For i = 0 to n-1 // 第一遍掃描左到右\n    Decision: s[i] == '('?\n        Yes → counter++ // 看到左括號，計數+1\n        No  → Decision: s[i] == ')'?\n            Yes → Decision: counter > 0?\n                Yes → counter-- // 可以配對，計數-1\n                No  → marks[i] = True // 無法配對，標記為刪除\n            No  → // 小寫字母，忽略\n\n→ Step 3: For i = n-1 down to 0 // 第二遍掃描右到左\n    Decision: s[i] == '('?\n        Yes → Decision: counter > 0?\n            Yes → marks[i] = True // 未配對的左括號，標記刪除\n            No  → counter-- // 已配對，計數-1\n        No  → // 不是 '('，忽略\n\n→ Step 4: result = empty string\n→ For i = 0 to n-1\n    Decision: marks[i] == True?\n        Yes → // 跳過已標記刪除的字符\n        No  → result += s[i] // 把未標記的字符加入結果\n\n→ End // 結束並返回 result\n\nBut each line must be separate. We need to maintain indentation? Not necessary. Just lines. Use arrows for decision branches: maybe we need to indent lines after Decision.\n\nBut requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line is a line. For branches, we might write separate lines with \"Decision:\" and \"Yes →\" lines etc.\n\nLet's create lines:\n\nStart // 程式開始執行\n\n→ Step 1: n = len(s), counter = 0, marks = array[n] False // 初始化變量\n\n→ Step 2: For i = 0 to n-1 // 第一遍掃描\n    Decision: s[i] == '('?\n        Yes → counter++ // 看到左括號，計數+1\n        No  → Decision: s[i] == ')'?\n            Yes → Decision: counter > 0?\n                Yes → counter-- // 可配對，計數-1\n                No  → marks[i] = True // 無法配對，標記刪除\n            No  → // 小寫字母，忽略\n\n→ Step 3: For i = n-1 down to 0 // 第二遍掃描\n    Decision: s[i] == '('?\n        Yes → Decision: counter > 0?\n            Yes → marks[i] = True // 未配對的左括號，標記刪除\n            No  → counter-- // 已配對，計數-1\n        No  → // 不是 '('，忽略\n\n→ Step 4: result = \"\" // 初始化結果\n→ For i = 0 to n-1\n    Decision: marks[i] == True?\n        Yes → // 跳過已標記刪除的字符\n        No  → result += s[i] // 加入未標記字符\n\n→ End // 程式結束，返回 result\n\nNeed to ensure each line ends with // explanation.\n\nBut lines with nested decision may have multiple lines; each line separate. For readability, we might include indent but not necessary.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = len(s), counter = 0, marks = array[n] False // 初始化長度、計數器與刪除標記  \n→ Step 2: For i = 0 to n-1 // 第一遍掃描，從左到右  \n    Decision: s[i] == '('? // 判斷是否為左括號  \n        Yes → counter++ // 看到左括號，計數器加 1  \n        No  → Decision: s[i] == ')'? // 判斷是否為右括號  \n            Yes → Decision: counter > 0? // 是否有未配對的左括號  \n                Yes → counter-- // 能配對，計數器減 1  \n                No  → marks[i] = True // 無法配對，標記為刪除  \n            No  → // 小寫字母，直接忽略  \n→ Step 3: For i = n-1 down to 0 // 第二遍掃描，從右到左  \n    Decision: s[i] == '('? // 判斷是否為左括號  \n        Yes → Decision: counter > 0? // 是否仍有未配對的右括號  \n            Yes → marks[i] = True // 未配對的左括號，標記刪除  \n            No  → counter-- // 已配對，計數器減 1  \n        No  → // 不是 '('，直接忽略  \n→ Step 4: result = \"\" // 初始化結果字符串  \n→ For i = 0 to n-1 // 建構最終字符串  \n    Decision: marks[i] == True? // 這個位置被標記刪除？  \n        Yes → // 跳過已標記的字符  \n        No  → result += s[i] // 加入未標記的字符  \n→ End // 程式結束，返回最終的有效括號字符串(result)",
      "generated_code": "import sys\nimport re\n\ndef min_remove_to_make_valid(s: str) -> str:\n    \"\"\"\n    Remove the minimum number of parentheses to make the string valid.\n    Uses a stack to track unmatched '(' positions.\n    \"\"\"\n    chars = list(s)\n    stack = []\n\n    # First pass: identify unmatched ')' and record '(' indices\n    for i, c in enumerate(chars):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            if stack:\n                stack.pop()          # matched '('\n            else:\n                chars[i] = ''         # unmatched ')', mark for removal\n\n    # Second pass: remove any remaining unmatched '('\n    for i in stack:\n        chars[i] = ''\n\n    return ''.join(chars)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Extract the string value from the raw stdin content.\n    Handles formats like:\n        s = \"abc\"\n    or just the raw string without quotes.\n    \"\"\"\n    raw = raw.strip()\n    # Look for quoted substring\n    m = re.search(r'\"(.*)\"', raw)\n    if m:\n        return m.group(1)\n    # Handle potential leading 's = '\n    if raw.lower().startswith('s'):\n        parts = raw.split('=', 1)\n        if len(parts) == 2:\n            return parts[1].strip()\n    # Fallback: return the whole trimmed input\n    return raw\n\ndef main() -> None:\n    data = sys.stdin.read()\n    s = parse_input(data)\n    result = min_remove_to_make_valid(s)\n    # Output the result surrounded by double quotes as specified\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"lee(t(c)o)de)\"",
          "expected_output": "\"lee(t(c)o)de\"",
          "success": true,
          "output": "\"lee(t(c)o)de\""
        },
        {
          "example_index": 1,
          "input": "s = \"a)b(c)d\"",
          "expected_output": "\"ab(c)d\"",
          "success": true,
          "output": "\"ab(c)d\""
        },
        {
          "example_index": 2,
          "input": "s = \"))((\"",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode239.json",
    "problem_index_in_file": 0,
    "title": "Sliding Window Maximum",
    "description_snippet": "You are given an array of integers nums, there is a sliding window of size k which is moving from th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for sliding window maximum. Provide each step line-by-line with explanation. Use Start, Decision, etc. Let's produce algorithm: use deque to maintain indices of max. Steps: Initialize deque, loop i from 0 to n-1: Remove front if out of window. While deque not empty and nums[i] >= nums[deque.back], pop back. Push i. If i >= k-1, record nums[deque.front] as max for current window. End.\n\nLet's write in lines. Provide explanation after space. Use arrows: Start, → etc. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告空的雙端佇列 dq // 用來儲存可能成為最大值的索引  \n→ Step 2: 初始化空陣列 result // 儲存每個滑動窗口的最大值  \n→ Step 3: 迴圈 i 從 0 到 nums.length-1 // 遍歷整個陣列  \n   Decision: 如果 dq 的前端索引 <= i-k? // 檢查是否已離開窗口  \n    Yes → Step 4: 移除 dq 前端索引 // 把已不在窗口內的索引移除  \n    No  → // 不做任何事  \n   Decision: 如果 dq 不是空且 nums[i] >= nums[dq.back]? // 新數字是否比佇列後端大  \n    Yes → Step 5: 移除 dq 後端索引 // 移除不可能成最大值的索引  \n    No  → // 不做任何事  \n   → Step 6: 將 i 推進 dq // 加入當前索引  \n   Decision: 如果 i >= k-1? // 是否已經形成完整的窗口  \n    Yes → Step 7: result.push(nums[dq.front]) // 把窗口最大值加入結果  \n    No  → // 等待窗口形成  \n→ End // 程式執行結束，result 為滑動窗口最大值的序列",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"Return list of max values in each sliding window of size k.\"\"\"\n        if not nums or k == 0:\n            return []\n\n        deq = deque()\n        res = []\n\n        for i, num in enumerate(nums):\n            # Remove indices outside the current window\n            while deq and deq[0] < i - k + 1:\n                deq.popleft()\n\n            # Remove smaller numbers from the back\n            while deq and nums[deq[-1]] < num:\n                deq.pop()\n\n            deq.append(i)\n\n            # Record the max for windows that are fully formed\n            if i >= k - 1:\n                res.append(nums[deq[0]])\n\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n    nums = [1,3,-1,-3,5,3,6,7], k = 3\n    or with newlines.\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not k_match:\n        raise ValueError(\"Invalid input format\")\n\n    nums_str = nums_match.group(1)\n    k_str = k_match.group(1)\n\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n\n    try:\n        nums, k = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.maxSlidingWindow(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "success": true,
          "output": "[3, 3, 5, 5, 6, 7]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode628.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Three Numbers",
    "description_snippet": "Given an integer array nums, find three numbers whose product is maximum and return the maximum prod...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve \"maximum product of three numbers\" problem. Provide lines with \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc. No actual code. Should be step-by-step algorithm: sort array, consider product of last three and first two with last one. Steps: start, input array, sort, compute candidate1, candidate2, take max, output. Provide explanation. Use arrow. Use Yes/No decisions? Might need decision to compare candidate1 and candidate2. Use Decision: if candidate1 > candidate2? else. Or use Step to compute max.\n\nAlso need to use 虛擬碼箭頭 →. Use Start, End. Use Step numbers maybe. Provide explanation in Chinese.\n\nLet's produce.\n\nWe should ensure each line follows format: \"虛擬碼步驟 // 解釋\".\n\nWe need to maintain order: Start, → Step 1 etc. Use arrows.\n\nLet's craft:\n\nStart // 程式開始\n\n→ Step 1: 輸入整數陣列 nums // 從使用者取得數字列表\n\n→ Step 2: 取得陣列長度 n // 用於後續判斷\n\n→ Decision: 如果 n < 3? // 檢查是否至少有三個數字\n\n    Yes → Step 3: 輸出 '無法計算' // 如果不足三個，返回錯誤訊息\n\n    No → Step 4: 對 nums 進行升序排序 // 排序後可快速取最大/最小值\n\n→ Step 5: 取得最大三個數值 max1, max2, max3 // nums[n-1], nums[n-2], nums[n-3]\n\n→ Step 6: 取得最小兩個數值 min1, min2 // nums[0], nums[1]\n\n→ Step 7: 計算 product1 = max1 * max2 * max3 // 三個最大值的乘積\n\n→ Step 8: 計算 product2 = min1 * min2 * max1 // 最小兩個與最大值的乘積\n\n→ Decision: 如果 product1 > product2? // 比較兩種情況\n\n    Yes → Step 9: 設 result = product1 // 取較大乘積\n\n    No  → Step 10: 設 result = product2 // 取較大乘積\n\n→ Step 11: 輸出 result // 回傳最大乘積\n\nEnd // 程式結束\n\nMake sure to include arrow symbols. Use \"→\" after each step. Provide explanation. Use no code. Should be fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 從使用者處取得整數列表  \n→ Step 2: 取得陣列長度 n // 用於判斷是否足夠三個數字  \n→ Decision: 如果 n < 3? // 檢查數組元素是否少於三個  \n    Yes → Step 3: 輸出 '無法計算' // 若不足三個，直接回傳錯誤訊息  \n    No → Step 4: 對 nums 進行升序排序 // 排序後可快速取得最小與最大值  \n→ Step 5: 取得最大三個數值 max1, max2, max3 // 分別為 nums[n-1], nums[n-2], nums[n-3]  \n→ Step 6: 取得最小兩個數值 min1, min2 // 分別為 nums[0], nums[1]  \n→ Step 7: 計算 product1 = max1 * max2 * max3 // 三個最大值的乘積  \n→ Step 8: 計算 product2 = min1 * min2 * max1 // 最小兩個與最大值的乘積  \n→ Decision: 如果 product1 > product2? // 比較兩種可能的最大乘積  \n    Yes → Step 9: 設 result = product1 // 取較大乘積作為答案  \n    No  → Step 10: 設 result = product2 // 取較大乘積作為答案  \n→ Step 11: 輸出 result // 回傳最終計算得到的最大乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef maximum_product(nums):\n    \"\"\"\n    計算三個數字乘積中的最大值。\n    方法：排序後，兩種可能：取三個最大值或兩個最小值與最大值相乘。\n    \"\"\"\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析 nums 列表，計算並輸出最大乘積。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中擷取列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        # eval 是安全的，因為輸入只包含整數列表\n        nums = eval(data[start:end + 1])\n\n    if len(nums) < 3:\n        # 若數量不足三個，按題目假設不會發生\n        print(\"N/A\")\n        return\n\n    result = maximum_product(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "24",
          "success": true,
          "output": "24"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-2,-3]",
          "expected_output": "-6",
          "success": true,
          "output": "-6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode68.json",
    "problem_index_in_file": 0,
    "title": "Text Justification",
    "description_snippet": "Given an array of strings words and a width maxWidth, format the text such that each line has exactl...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for text justification. Each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. We need to output step by step.\n\nLet's design algorithm:\n\nStart\n→ Initialize result list\n→ Initialize index=0\n→ While index < words.length:\n    → Determine end index for current line: start= index; totalLen=words[start].length; end=start+1\n    → While end < words.length and totalLen +1 + words[end].length <= maxWidth:\n        → totalLen +=1 + words[end].length\n        → end+=1\n    → Number of words in line = end-start\n    → If end==words.length or number words ==1:\n        → Build line by joining words with single space, then pad with spaces to maxWidth\n    → Else:\n        → totalSpaces = maxWidth - sumLen of words in line\n        → spacesBetween = totalSpaces // (numWords-1)\n        → extraSpaces = totalSpaces % (numWords-1)\n        → For i from start to end-1:\n            → Add words[i]\n            → If i< end-1:\n                → add spacesBetween + (i-start < extraSpaces ?1:0) spaces\n    → Add constructed line to result\n    → index = end\n→ End\n\nLet's convert to virtual code lines with explanation.\n\nNeed to use \"Decision:\" with Yes/No arrows for conditional. Use \"→\" for next step.\n\nOk produce.\n\nWe must avoid real code. Use pseudocode. Each line: \"虛擬碼步驟 // 解釋\"\n\nLet's craft.\n\nStart // 程式開始\n\n→ Initialize result list // 建立結果儲存結構\n\n→ Set index = 0 // 位置指標初始化\n\n→ Decision: index < words.length? // 判斷是否還有未處理單詞\n\n    Yes →\n\n        → Set start = index // 行首單詞索引\n\n        → Set totalLen = length(words[start]) // 行中已佔用字符長度\n\n        → Set end = start + 1 // 下一個待檢查單詞索引\n\n        → Decision: end < words.length AND totalLen + 1 + length(words[end]) <= maxWidth? // 判斷能否將 next 單詞放入行\n\n            Yes → \n                → totalLen = totalLen + 1 + length(words[end]) // 更新已佔用長度（包含空格）\n                → end = end + 1 // 移動到下一個單詞\n                → Go back to Decision: end < words.length AND ... // 重新判斷\n\n            No → // 無法再放入更多單詞，行確定\n\n        → Set numWords = end - start // 行中單詞數\n\n        → Decision: end == words.length OR numWords == 1? // 判斷是否為最後一行或只有一個單詞\n\n            Yes →\n\n                → Set line = words[start] // 從第一個單詞開始\n\n                → For i from start+1 to end-1:\n\n                    → line = line + \" \" + words[i] // 單詞之間插入單個空格\n\n                → Pad line with spaces on right until length(line) == maxWidth // 右側補空格\n\n            No →\n\n                → Set sumLen = 0\n\n                → For i from start to end-1:\n\n                    → sumLen = sumLen + length(words[i]) // 計算行中所有單詞長度總和\n\n                → Set totalSpaces = maxWidth - sumLen // 行中所有空格數量\n\n                → Set gaps = numWords - 1 // 單詞之間的空格槽數\n\n                → Set spacesPerGap = totalSpaces // gaps // 每個空格槽最少空格數\n\n                → Set extra = totalSpaces % gaps // 左側多餘空格數\n\n                → Set line = \"\"\n\n                → For i from start to end-1:\n\n                    → line = line + words[i] // 加入單詞\n\n                    → If i < end-1:\n\n                        → If (i - start) < extra:\n\n                            → line = line + repeat(\" \", spacesPerGap + 1) // 多一個空格的槽\n\n                        → Else:\n\n                            → line = line + repeat(\" \", spacesPerGap) // 基本空格\n\n        → Append line to result list // 保存此行\n\n        → Set index = end // 移至下一行起始位置\n\n→ Go back to Decision: index < words.length? // 重複處理下一行\n\nEnd // 程式結束\n\nNeed to ensure we include \"→\" arrow in each step. Use consistent indent for substeps. Should be fine.\n\nWe must keep \"虛擬碼步驟\" as each line. Use \"Decision:\" lines with \"Yes →\" etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize result list // 建立儲存完整對齊後文字的容器  \n→ Set index = 0 // 設定當前單詞索引為起始位置  \n\n→ Decision: index < words.length? // 判斷是否還有未處理的單詞  \n    Yes →  \n        → Set start = index // 行首單詞索引  \n        → Set totalLen = length(words[start]) // 行已佔用的字符長度  \n        → Set end = start + 1 // 下一個待檢查單詞索引  \n        → Decision: end < words.length AND totalLen + 1 + length(words[end]) <= maxWidth? // 判斷是否能把下一個單詞放入當前行  \n            Yes →  \n                → totalLen = totalLen + 1 + length(words[end]) // 更新已佔用長度（含空格）  \n                → end = end + 1 // 移動到下一個單詞  \n                → Go back to Decision: end < words.length AND totalLen + 1 + length(words[end]) <= maxWidth? // 重新判斷是否還能加入  \n            No → // 無法再放入更多單詞，行確定  \n\n        → Set numWords = end - start // 當前行的單詞數  \n\n        → Decision: end == words.length OR numWords == 1? // 判斷是否為最後一行或只有一個單詞  \n            Yes →  \n                → Set line = words[start] // 從第一個單詞開始  \n                → For i from start+1 to end-1:  \n                    → line = line + \" \" + words[i] // 單詞之間插入單個空格  \n                → Pad line with spaces on right until length(line) == maxWidth // 右側補空格，使行長度達 maxWidth  \n            No →  \n                → Set sumLen = 0  \n                → For i from start to end-1:  \n                    → sumLen = sumLen + length(words[i]) // 計算行中所有單詞長度總和  \n                → Set totalSpaces = maxWidth - sumLen // 行中所有空格數量  \n                → Set gaps = numWords - 1 // 單詞之間的空格槽數  \n                → Set spacesPerGap = totalSpaces // gaps // 每個空格槽最少空格數  \n                → Set extra = totalSpaces % gaps // 左側多餘空格數  \n                → Set line = \"\"  \n                → For i from start to end-1:  \n                    → line = line + words[i] // 加入單詞  \n                    → If i < end-1:  \n                        → If (i - start) < extra:  \n                            → line = line + repeat(\" \", spacesPerGap + 1) // 多一個空格的槽  \n                        → Else:  \n                            → line = line + repeat(\" \", spacesPerGap) // 基本空格  \n\n        → Append line to result list // 保存此行的對齊結果  \n        → Set index = end // 移至下一行的起始位置  \n\n→ Go back to Decision: index < words.length? // 重複處理下一行  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            line_words = words[i:j]\n            gaps = len(line_words) - 1\n            spaces_needed = maxWidth - sum(len(w) for w in line_words)\n\n            if j == n or gaps == 0:\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                space, extra = divmod(spaces_needed, gaps)\n                line_parts = []\n                for k in range(gaps):\n                    line_parts.append(line_words[k] + ' ' * (space + (1 if k < extra else 0)))\n                line_parts.append(line_words[-1])\n                line = ''.join(line_parts)\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef parse_input(text):\n    words_match = re.search(r'words\\s*=\\s*(\\[[^\\]]*\\])', text)\n    max_match = re.search(r'maxWidth\\s*=\\s*(\\d+)', text)\n    if not words_match or not max_match:\n        raise ValueError(\"Invalid input format\")\n    words = ast.literal_eval(words_match.group(1))\n    max_width = int(max_match.group(1))\n    return words, max_width\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    words, max_width = parse_input(raw_input)\n    solution = Solution()\n    result = solution.fullJustify(words, max_width)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "success": true,
          "output": "['This    is    an', 'example  of text', 'justification.  ']"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "success": true,
          "output": "['What   must   be', 'acknowledgment  ', 'shall be        ']"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "success": true,
          "output": "['Science  is  what we', 'understand      well', 'enough to explain to', 'a  computer.  Art is', 'everything  else  we', 'do                  ']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode38.json",
    "problem_index_in_file": 0,
    "title": "Count and Say",
    "description_snippet": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line steps and explanation comments. The problem: generate nth term of count-and-say. Use recursion or iteration. Provide pseudocode. Use Start, Decision, etc. Let's craft steps:\n\nStart\n→ Step 1: Input n\n→ Decision: 如果 n == 1? // base case\n    Yes → Step 2: Return \"1\"\n    No → Step 3: Set prev = \"1\" // start from first term\n→ Step 4: For i from 2 to n // build terms iteratively\n    → Step 5: Initialize current = \"\" // empty string for new term\n    → Step 6: Initialize count = 1 // count of current digit\n    → Decision: If i == 2? Actually loop through prev characters\n    → Step 7: For j from 1 to length(prev)-1\n        → Decision: 如果 prev[j] == prev[j-1]?\n            Yes → count++\n            No  → Step 8: Append count and prev[j-1] to current\n                  → count = 1\n    → Step 9: After loop, append count and last char to current\n    → Step 10: prev = current // prepare for next iteration\n→ Step 11: Return prev // nth term\n\nNeed to include Start, End, Decision, Yes/No arrows, etc. Each line must include the code step and comment. Use \"→\" arrow for transitions.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Input n // 取得要產生的第 n 項\n→ Decision: 如果 n == 1? // 判斷是否為基礎情況\n    Yes → Step 2: Return \"1\" // 若 n 為 1，直接回傳 \"1\"\n    No  → Step 3: Set prev = \"1\" // 初始化上一項為 \"1\"\n→ Step 4: For i = 2 to n // 從第二項開始逐步產生\n    → Step 5: Set current = \"\" // 用於儲存新的一項\n    → Step 6: Set count = 1 // 記錄相同數字的連續次數\n    → Step 7: For j = 1 to Length(prev) - 1 // 逐字元比對\n        → Decision: 如果 prev[j] == prev[j-1]? // 同一數字則累計\n            Yes → Step 8: count = count + 1 // 次數加 1\n            No  → Step 9: Append count + prev[j-1] to current // 輸出已完成的段\n                  → Step 10: Set count = 1 // 重置計數\n    → Step 11: Append count + prev[Last] to current // 處理最後一段\n    → Step 12: Set prev = current // 更新上一項\n→ Step 13: Return prev // 回傳第 n 項\nEnd // 程式執行結束\n\nNeed to use \"Yes →\" \"No →\" with indentation. Ensure each line has code and comment separated by space. Provide proper arrows. Let's format.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Input n // 取得要產生的第 n 項\n→ Decision: 如果 n == 1? // 判斷是否為基礎情況\n    Yes → Step 2: Return \"1\" // 若 n 為 1，直接回傳 \"1\"\n    No  → Step 3: Set prev = \"1\" // 初始化上一項為 \"1\"\n→ Step 4: For i = 2 to n // 從第二項開始逐步產生\n    → Step 5: Set current = \"\" // 用於儲存新的一項\n    → Step 6: Set count = 1 // 記錄相同數字的連續次數\n    → Step 7: For j = 1 to Length(prev) - 1 // 逐字元比對\n        → Decision: 如果 prev[j] == prev[j-1]? // 同一數字則累計\n            Yes → Step 8: count = count + 1 // 次數加 1\n            No  → Step 9: Append count + prev[j-1] to current // 輸出已完成的段\n                  → Step 10: Set count = 1 // 重置計數\n    → Step 11: Append count + prev[Last] to current // 處理最後一段\n    → Step 12: Set prev = current // 更新上一項\n→ Step 13: Return prev // 回傳第 n 項\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef count_and_say(n: int) -> str:\n    \"\"\"\n    Generate the nth term of the count‑and‑say sequence iteratively.\n    \"\"\"\n    # Base case\n    if n == 1:\n        return \"1\"\n\n    prev = \"1\"  # The first term\n    for _ in range(2, n + 1):\n        current_parts = []  # 用於儲存新的一項\n        count = 1           # 同一數字的連續次數\n\n        # 逐字符比較\n        for i in range(1, len(prev)):\n            if prev[i] == prev[i - 1]:\n                count += 1\n            else:\n                # 把已完成的段寫入 current_parts\n                current_parts.append(str(count))\n                current_parts.append(prev[i - 1])\n                count = 1\n\n        # 處理最後一段\n        current_parts.append(str(count))\n        current_parts.append(prev[-1])\n\n        # 更新 prev 為新的一項\n        prev = \"\".join(current_parts)\n\n    return prev\n\ndef main():\n    \"\"\"\n    主程式入口：從標準輸入讀取 n，計算並輸出結果。\n    \"\"\"\n    # 讀取整個輸入，並搜尋第一個出現的整數\n    data = sys.stdin.read().strip()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return  # 若無有效整數，直接結束\n\n    n = int(match.group())\n    result = count_and_say(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "\"1211\"",
          "success": true,
          "output": "1211"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "\"1\"",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode287.json",
    "problem_index_in_file": 0,
    "title": "Find the Duplicate Number",
    "description_snippet": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code, following the specified format. The problem: find duplicate number in array of n+1 integers, range [1,n], one duplicate, cannot modify array, constant extra space. Classic Floyd's Tortoise and Hare (cycle detection). Steps: Initialize slow and fast pointers to first element, loop to find intersection, then reset one pointer to start and move both step by step until they meet again, return meeting value.\n\nWe need to output virtual code lines with \"→\" etc. Each line: virtual step + \" // explanation\". Must be line by line, with Start, End, Decision:, and arrows.\n\nWe should use arrow syntax: Start, → Step X, Decision: etc.\n\nWe need to produce the algorithm. Ensure it's virtual, not actual code.\n\nWe need to include condition checks: while loop, etc. But must be represented as virtual steps. For loops and decisions.\n\nLet's outline:\n\nStart\n\n→ Step 1: Initialize slow = nums[0] // slow pointer starts at first element\n\n→ Step 2: Initialize fast = nums[nums[0]] // fast pointer starts at second element\n\n→ Decision: while slow ≠ fast? // detect cycle\n\n    Yes → Step 3: slow = nums[slow] // move slow by one\n\n    Yes → Step 4: fast = nums[nums[fast]] // move fast by two\n\n    No  → ... // exit loop\n\nAfter loop exit, intersection found.\n\n→ Step 5: Reset slow = nums[0] // start slow at beginning\n\n→ Decision: while slow ≠ fast? // find entrance to cycle\n\n    Yes → Step 6: slow = nums[slow] // move slow by one\n\n    Yes → Step 7: fast = nums[fast] // move fast by one\n\n    No  → Step 8: Return slow // duplicate number found\n\nEnd\n\nNeed to incorporate the loop structure properly: We can represent loops with Decision: while condition? and Yes branch containing steps and then loop back? But we need to indicate that after step 3/4 the loop continues. We can use Decision: while slow ≠ fast? and Yes → loop body, No → exit.\n\nSimilarly for second loop.\n\nWe need to show loops and pointer moves. Use arrow indenting? We can indent inside decisions.\n\nExample format:\n\nDecision: while slow ≠ fast? // check if pointers equal\n\n    Yes → Step 3: slow = nums[slow] // move slow by one\n\n    Yes → Step 4: fast = nums[nums[fast]] // move fast by two\n\n    No  → // pointers met, exit loop\n\nBut we need to show that after step 4 it returns to Decision. Might not be needed.\n\nWe also need to show that at No we exit loop.\n\nSimilarly second loop.\n\nLet's craft final answer.\n\nEnsure to include \"Start\" and \"End\".\n\nEach line must be a virtual code step, but we can have multiple steps inside Decision? Actually we need to use \"Decision:\" with Yes → and No → lines. Each step within Yes can be separate lines, but we might need to indicate that they are part of the loop.\n\nSimplify: Use a loop representation:\n\nDecision: while slow ≠ fast? // check condition\n\n    Yes → Step 3: slow = nums[slow] // advance slow by one\n\n    Yes → Step 4: fast = nums[nums[fast]] // advance fast by two\n\n    No  → // exit loop\n\nBut we need to indicate that after step 4 we go back to Decision. This representation may suffice.\n\nSimilarly second loop.\n\nNow produce final output.\n\nEnsure formatting: each line with \"虛擬碼步驟\" followed by a space and then \"// 解釋\".\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow = nums[0] // 初始慢指標指向第一個元素  \n→ Step 2: fast = nums[nums[0]] // 初始快指標指向第二個元素  \n→ Decision: while slow ≠ fast? // 判斷慢指標與快指標是否相遇  \n    Yes → Step 3: slow = nums[slow] // 慢指標前進一步  \n    Yes → Step 4: fast = nums[nums[fast]] // 快指標前進兩步  \n    No  → // 指標相遇，進入下一階段  \n→ Step 5: slow = nums[0] // 將慢指標重置到陣列起始位置  \n→ Decision: while slow ≠ fast? // 再次判斷直到兩指標相遇  \n    Yes → Step 6: slow = nums[slow] // 同步前進一步  \n    Yes → Step 7: fast = nums[fast] // 同步前進一步  \n    No  → Step 8: return slow // slow 與 fast 相遇於重複數值，返回該數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_duplicate(nums):\n    # 使用 Floyd's Tortoise and Hare 演算法\n    slow = fast = nums[0]\n    # 第一階段：找相遇點\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n    # 第二階段：找重複數字\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得陣列字串，容錯處理\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1:\n        nums = ast.literal_eval(data[start:end+1])\n    else:\n        nums = ast.literal_eval(data)\n    result = find_duplicate(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,4,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3,3,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode714.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Transaction Fee",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem (max profit with transaction fee). Provide each line with arrow, decision etc.\n\nWe must produce virtual code, not actual code. Use arrow and structure as example. Need to cover algorithm: dynamic programming with two states: hold and not hold. But in virtual code we can describe steps. Since not actual code, we can abstract. Provide steps: Start, initialize variables, iterate days, update states, final result, End.\n\nWe must ensure each line has \"虛擬碼步驟 // 解釋\".\n\nInclude decisions, loops, etc. Use arrows for transitions.\n\nLet's produce:\n\nStart // program begins\n\n→ Initialize maxProfit = 0 // track best profit\n\n→ Initialize hold = -prices[0] // profit if holding stock after day 0\n\n→ For each day i from 1 to n-1 // iterate days\n\n    → Decision: If we are holding, can we sell today? // evaluate selling\n\n        Yes → holdProfit = hold + prices[i] - fee // profit if selling\n\n        No  → holdProfit = hold // keep holding\n\n    → Decision: If we are not holding, can we buy today? // evaluate buying\n\n        Yes → notHoldProfit = maxProfit - prices[i] // profit if buying\n\n        No  → notHoldProfit = maxProfit // keep not holding\n\n    → Update maxProfit = max(maxProfit, holdProfit) // best profit so far\n\n    → Update hold = max(holdProfit, hold) // best holding profit\n\n    → Update maxProfit = max(maxProfit, notHoldProfit) // consider buying\n\n    → Update notHoldProfit = maxProfit // update non-hold state\n\nEnd // finish\n\nBut need structure using arrows: e.g., → For each day i: ...\n\nBetter to use decision blocks inside loop.\n\nSimplify: Use two variables: cash (not holding) and hold. Each day:\n\n    newCash = max(cash, hold + price - fee)\n\n    newHold = max(hold, cash - price)\n\nSet cash = newCash, hold = newHold.\n\nFinally output cash.\n\nLet's produce virtual code lines accordingly.\n\nAlso include decision arrows maybe.\n\nLet's design:\n\nStart\n\n→ Initialize cash = 0 // profit when not holding\n\n→ Initialize hold = -prices[0] // profit when holding after first day\n\n→ For i from 1 to n-1 // iterate over remaining days\n\n    → Decision: Calculate potentialSell = hold + prices[i] - fee // profit if sell today\n\n        Yes → newCash = max(cash, potentialSell) // choose best cash\n\n        No  → newCash = cash // keep current cash\n\n    → Decision: Calculate potentialBuy = cash - prices[i] // profit if buy today\n\n        Yes → newHold = max(hold, potentialBuy) // choose best hold\n\n        No  → newHold = hold // keep current hold\n\n    → Update cash = newCash\n\n    → Update hold = newHold\n\n→ End // result cash is maximum profit\n\nBut the decision arrow may not be needed. But we can use Decision blocks to illustrate.\n\nLet's craft final answer. Use arrow for transitions. Ensure each line ends with `//` explanation.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Initialize cash = 0 // 無持股時的最高利潤\n→ Initialize hold = -prices[0] // 第一天購買後的持股利潤\n→ For i from 1 to n-1 // 遍歷剩餘天數\n    → Decision: 以持股出售今天的利潤 potentialSell = hold + prices[i] - fee // 計算今日賣出的可能利潤\n        Yes → newCash = max(cash, potentialSell) // 若賣出更優，更新現金利潤\n        No  → newCash = cash // 其他情況保持現金利潤\n    → Decision: 以不持股購買今天的利潤 potentialBuy = cash - prices[i] // 計算今日買入的可能利潤\n        Yes → newHold = max(hold, potentialBuy) // 若買入更優，更新持股利潤\n        No  → newHold = hold // 其他情況保持持股利潤\n    → Update cash = newCash // 設定新的現金利潤\n    → Update hold = newHold // 設定新的持股利潤\n→ End // 程式執行結束，最終利潤為 cash\n\nBut we need every line with arrow? Not necessary. But example shows arrow for transitions. It's okay.\n\nBetter to use arrow for each line, but for loops and decisions we need indent. Provide arrow for each subline.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize cash = 0 // 無持股時的最高利潤  \n→ Initialize hold = -prices[0] // 第一天購買後的持股利潤  \n\n→ For i from 1 to n-1 // 遍歷剩餘天數  \n    → Decision: 計算今日賣出的利潤 potentialSell = hold + prices[i] - fee // 先算出若今天賣出的可能利潤  \n        Yes → newCash = max(cash, potentialSell) // 若賣出更優，更新現金利潤  \n        No  → newCash = cash // 否則保持原來的現金利潤  \n\n    → Decision: 計算今日買入的利潤 potentialBuy = cash - prices[i] // 先算出若今天買入的可能利潤  \n        Yes → newHold = max(hold, potentialBuy) // 若買入更優，更新持股利潤  \n        No  → newHold = hold // 否則保持原來的持股利潤  \n\n    → Update cash = newCash // 設定新的現金利潤  \n    → Update hold = newHold // 設定新的持股利潤  \n\n→ End // 程式執行結束，最終利潤為 cash",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices, fee):\n        if not prices:\n            return 0\n        hold = -prices[0]\n        cash = 0\n        for price in prices[1:]:\n            cash = max(cash, hold + price - fee)\n            hold = max(hold, cash - price)\n        return cash\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'prices = [1,3,2,8,4,9], fee = 2' 的輸入字串。\n    \"\"\"\n    pattern = r'prices\\s*=\\s*(\\[.*?\\])\\s*,\\s*fee\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        raise ValueError(\"輸入格式錯誤\")\n    prices_str, fee_str = match.group(1), match.group(2)\n    prices = ast.literal_eval(prices_str)\n    fee = int(fee_str)\n    return prices, fee\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    prices, fee = parse_input(raw_input)\n    result = Solution().maxProfit(prices, fee)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,3,2,8,4,9], fee = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "prices = [1,3,7,5,10,3], fee = 3",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode406.json",
    "problem_index_in_file": 0,
    "title": "Queue Reconstruction by Height",
    "description_snippet": "You are given an array of people, people, which are the attributes of some people in a queue (not ne...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for solving the problem: Reconstruct Queue by Height. We should produce pseudocode lines with explanations, following the format. Need to explain steps. Let's craft algorithm: sort people by height descending, then by k ascending. Then insert each person into result at index k. That's standard.\n\nLet's produce virtual code with lines like:\n\nStart\n→ Step 1: Sort people by descending height, ascending k // ...\n→ Step 2: Initialize empty queue list // ...\n→ Step 3: For each person in sorted list:\n   → Step 3.1: Insert person at index k in queue // ...\n→ End\n\nBut we need to use virtual code arrow. Use Start, End, Decision: but no decisions needed except maybe condition for loop. But we can include for loop as Step. For loops: maybe represent as \"For each person in sorted list → Step\" etc.\n\nEnsure each line has \"虛擬碼步驟 [space] // 解釋\". Use the arrow. For loops: \"→ For each person in sortedList: // iterate\".\n\nWe need to keep each line separate, include nested lines with indentation? They used indent in example. We can indent nested lines with spaces or tab.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Sort people by height descending, and if heights equal, by k ascending // 排序以方便插入\n→ Step 2: 初始化空的 queue // 用於儲存重建後的佈局\n→ Step 3: 對於排序後的每一位人 (h, k)：\n    → Step 3.1: 在 queue 中插入 (h, k) 至索引 k // 根據前面 k 個高於等於 h 的人插入位置\n→ End // 程式執行結束\n\nBut we need to show the for loop as a step. Maybe \"Step 3: For each person in sorted list\". Then nested \"Step 3.1\".\n\nOk produce accordingly.\n\nMake sure each line contains \"虛擬碼步驟\" like \"Step 1:\" etc. But the example uses \"Step 1:\" after arrow. They used \"Step 1:\" as part of line. So we can follow that.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: Sort people by height descending, and k ascending // 排序便於後續插入\n→ Step 2: Initialize empty queue // 用於儲存最終佈局\n→ Step 3: For each person in sorted list:\n    → Step 3.1: Insert person at index k in queue // 根據 k 的值將人插入正確位置\n→ End // 程式執行結束\n\nEnsure no actual code. Good.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort people by height descending, and if heights equal, by k ascending // 先排好順序，方便後續插入  \n→ Step 2: 初始化空的 queue // 用來儲存重建後的佈局  \n→ Step 3: 對於排序後的每一位人 (h, k)：  \n  → Step 3.1: 在 queue 中插入 (h, k) 至索引 k // 根據前面 k 個高於等於 h 的人插入位置  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reconstructQueue(self, people):\n        # Sort by height descending, then by k ascending\n        people.sort(key=lambda x: (-x[0], x[1]))\n        res = []\n        for p in people:\n            res.insert(p[1], p)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list part from the input, e.g. \"people = [[7,0],[4,4]]\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        # If no brackets found, try to evaluate the whole input\n        people = ast.literal_eval(data)\n    else:\n        people = ast.literal_eval(data[start:end+1])\n\n    solution = Solution()\n    result = solution.reconstructQueue(people)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
          "expected_output": "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]",
          "success": true,
          "output": "[[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]"
        },
        {
          "example_index": 1,
          "input": "people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]",
          "expected_output": "[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]",
          "success": true,
          "output": "[[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode381.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "description_snippet": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line with comments. Provide structure: Start, End, Decision. The pseudocode is for RandomizedCollection operations: insert, remove, getRandom. Use data structures: list/array for values, hashmap value->set of indices. Also maintain total size. Provide steps for each function. Also include initialization. Provide high-level pseudocode of whole class, not actual code. Provide steps for each method with decisions. Ensure each step has comment. Use \"→\" for next step. Provide line by line. Let's produce.\n\nWe'll start with Start // program starts. Then we define class RandomizedCollection. Steps inside: initialization: create array/list, map. Then methods: insert, remove, getRandom.\n\nWe need to output pseudocode with step lines. Let's produce a structured approach:\n\nStart\n→ Step 1: Initialize empty list `values` // 存儲所有元素\n→ Step 2: Initialize empty map `indices` from int to set of positions // 每個值對應的索引集合\n→ Step 3: Initialize counter `size = 0` // 目前元素數量\n\nThen methods:\n\n// Insert\nStart // 插入方法\n→ Step 1: Append `val` to `values` // 在末尾加入新元素\n→ Step 2: Add `size` to `indices[val]` // 將新索引加入集合\n→ Step 3: If `indices[val]` had size 1 after adding? // 判斷是否首次出現\n    Yes → Step 4: Return true // 未出現過\n    No  → Step 4: Return false // 已存在\n→ Step 5: Increment `size` // 更新總數\n\nBut note we need to decide before or after increment. We'll incorporate size before increment? Actually we push value at index size (current length). So before increment, size = len(values). After push, we update indices. So we can compute result based on whether there was earlier presence: before addition, check if val existed. So we can do: existed = indices[val] non-empty before adding? Or easier: Check before adding; but we need to add anyway. So algorithm:\n\nStep 1: Get current index = size\nStep 2: Append val\nStep 3: If val not in indices: create new set\nStep 4: Add index to indices[val]\nStep 5: If size==index before adding? Actually size is before push; but we can use existed bool before push.\nSimplify: existed = val in indices (and indices[val] not empty). Then after push, return not existed.\n\nWe'll produce steps accordingly.\n\nSimilarly remove:\n\nDecision: If val not in indices or empty? Return false.\nElse: Take an index idx from indices[val] (any). Remove idx from indices[val]. Get lastIndex = size-1. If idx != lastIndex: replace values[idx] with values[lastIndex]; update indices for the moved value: remove lastIndex from its set; add idx to its set. Then pop last element from values. Remove lastIndex from indices[val] maybe already removed. Decrement size. Return true.\n\nWe'll pseudocode with decisions.\n\ngetRandom:\n\nReturn values[randomIndex] where randomIndex between 0 and size-1. Use random function.\n\nWe'll produce line by line.\n\nLet's format as required: each line \"虛擬碼步驟 // 解釋/說明\"\n\nUse arrows for steps. Indent decision branches with indentation and Yes/No lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n// ---------- 初始化 RandomizedCollection ----------\n→ Step 1: Create list `values` // 用來存放所有元素\n→ Step 2: Create map `indices` : int → set of int // 每個值對應其在 values 中的索引集合\n→ Step 3: Set integer `size = 0` // 當前元素總數\nEnd // 初始化完成\n\n// ---------- insert(val) ----------\nStart // insert 方法開始\n→ Decision: 是否已經存在 `val`? // 檢查 `indices` 中是否已有 `val`\n    Yes → Step 1: Set `firstInsert = false` // 已存在\n    No  → Step 1: Set `firstInsert = true`  // 首次插入\n→ Step 2: Let `idx = size` // 新元素將放在末尾，索引為目前大小\n→ Step 3: Append `val` to `values` // 將元素加到列表末尾\n→ Step 4: If `indices[val]` does not exist, create an empty set // 為新值建立索引集合\n→ Step 5: Insert `idx` into `indices[val]` // 記錄新索引\n→ Step 6: Increment `size` // 更新總數\n→ Decision: `firstInsert` 為 true? // 判斷是否為首次出現\n    Yes → Step 7: Return true // 新值未曾出現\n    No  → Step 7: Return false // 已存在\nEnd // insert 方法結束\n\n// ---------- remove(val) ----------\nStart // remove 方法開始\n→ Decision: `indices[val]` 為空或不存在? // 檢查是否有此值可移除\n    Yes → Step 1: Return false // 沒有該值\n    No  → \n        → Step 2: Let `removeIdx` be an arbitrary index from `indices[val]` // 隨便取一個索引\n        → Step 3: Remove `removeIdx` from `indices[val]` // 從集合移除該索引\n        → Step 4: Let `lastIdx = size - 1` // 末尾元素索引\n        → Decision: `removeIdx` 等於 `lastIdx`? // 判斷是否為最後一個元素\n            Yes → \n                → Step 5: Remove last element from `values` // 直接 pop\n                → Step 6: Decrement `size` // 更新總數\n            No  → \n                → Step 5: Let `lastVal = values[lastIdx]` // 取最後一個值\n                → Step 6: Set `values[removeIdx] = lastVal` // 用最後一個值覆蓋要移除的位置\n                → Step 7: Remove `lastIdx` from `indices[lastVal]` // 從最後一個值的集合中刪除舊索引\n                → Step 8: Insert `removeIdx` into `indices[lastVal]` // 新索引加入集合\n                → Step 9: Remove last element from `values` // pop last\n                → Step 10: Decrement `size` // 更新總數\n        → Step 11: Return true // 成功移除一個元素\nEnd // remove 方法結束\n\n// ---------- getRandom() ----------\nStart // getRandom 方法開始\n→ Step 1: Let `randIdx = RandomInteger(0, size-1)` // 隨機產生索引\n→ Step 2: Return `values[randIdx]` // 回傳隨機元素\nEnd // getRandom 方法結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 用於存儲所有元素\n        self.data = []\n        # 字典，key 為元素值，value 為包含該元素索引的集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        # 把新元素放到列表尾部\n        self.data.append(val)\n        # 把新索引加入到對應值的集合\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此值之前不存在，返回 True；否則返回 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        # 若此值不存在或集合為空，直接返回 False\n        if not self.idx_map[val]:\n            return False\n        # 隨機取出一個索引（任何一個都可）\n        remove_idx = self.idx_map[val].pop()\n        # 取最後一個元素的值\n        last_val = self.data[-1]\n        # 把最後一個元素移到要刪除的位置\n        self.data[remove_idx] = last_val\n        # 更新最後一個元素索引集合\n        self.idx_map[last_val].add(remove_idx)\n        # 刪除舊索引\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        # 刪除列表最後一個元素\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機選擇並返回一個元素\n        return random.choice(self.data)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並解析為兩個列表\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        # 可能輸入跨多行，先把換行符替換空格再解析\n        raw_input = raw_input.replace('\\n', ' ')\n        ops, args = ast.literal_eval(raw_input)\n        # 結果列表\n        res = []\n        # 先執行第一個操作，通常是構造器\n        obj = None\n        for op, arg in zip(ops, args):\n            if op == \"RandomizedCollection\":\n                obj = RandomizedCollection()\n                res.append(None)\n            elif op == \"insert\":\n                res.append(obj.insert(*arg))\n            elif op == \"remove\":\n                res.append(obj.remove(*arg))\n            elif op == \"getRandom\":\n                res.append(obj.getRandom())\n        # 輸出結果\n        print(res)\n    else:\n        # 若輸入為空，直接退出\n        pass",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[None,True,False,True,2,True,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[None, True, False, True, 2, True, 1]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode132.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning II",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: given string s, find min cuts needed for palindrome partition. Classic DP: precompute palindrome table; dp[i] = min cuts for prefix up to i. Steps:\n\nStart\nInput string s\nLet n = length\nInitialize palindrome table pal[i][j] boolean\nCompute pal table: for length 1, true; length 2, s[i]==s[i+1]; length>2: s[i]==s[j] && pal[i+1][j-1]\nInitialize dp array size n; dp[i] = i (max cuts)\nLoop i from 0 to n-1:\nIf pal[0][i] then dp[i]=0\nElse loop j from 1 to i:\nIf pal[j][i] then dp[i] = min(dp[i], dp[j-1]+1)\nReturn dp[n-1]\nBut need virtual code step by step.\n\nWe must output each line: virtual code step + // explanation.\n\nWe use Start, End, Decision, etc.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: Input string s // 取得輸入字串\n\n→ Step 2: Let n = length of s // 獲取字串長度\n\n→ Step 3: Create 2D boolean array pal[n][n] // 用於記錄子字串是否為回文\n\n→ Decision: 先計算 pal table // 先判斷所有子字串是否為回文\n\n    → Step 4: For i from 0 to n-1: // 遍歷起始位置\n        → Step 5: For j from i to n-1: // 遍歷結束位置\n            → Decision: If i==j? // 單字符為回文\n                Yes → Step 6: pal[i][j] = true // 單字符回文\n                No  → Decision: If j==i+1? // 兩字符\n                    Yes → Step 7: pal[i][j] = (s[i]==s[j]) // 兩字符回文條件\n                    No  → Decision: If s[i]==s[j] AND pal[i+1][j-1]? // 更長\n                        Yes → Step 8: pal[i][j] = true // 回文\n                        No  → Step 9: pal[i][j] = false // 非回文\n\n→ Step 10: Create integer array dp[n] // dp[i] = 最小切割數到 i\n\n→ Decision: 初始化 dp // 設定最大值\n\n    → Step 11: For i from 0 to n-1: dp[i] = i // 最多切割 i 次\n\n→ Step 12: For i from 0 to n-1: // 計算 dp\n\n    → Decision: If pal[0][i]? // 前面全回文\n        Yes → Step 13: dp[i] = 0 // 無需切割\n        No  → Step 14: For j from 1 to i: // 嘗試分割點\n            → Decision: If pal[j][i]? // 子字串回文\n                Yes → Step 15: dp[i] = min(dp[i], dp[j-1]+1) // 更新最小切割\n\n→ Step 16: Return dp[n-1] // 最終最小切割數\n\nEnd // 程式結束\n\nWe need each line as virtual code plus comment. But need to use virtual arrows, Start, End, Decision, Yes→, No→ etc. Format:\n\nStart // 程式開始執行\n\n→ Step 1: Input string s // 取得輸入字串\n\n...\n\nWe should maintain arrow indentation.\n\nBut each line must be a separate line. For loops, we can include indentation with spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input string s // 取得輸入字串  \n→ Step 2: Let n = length of s // 獲取字串長度  \n→ Step 3: Create 2D boolean array pal[n][n] // 用於記錄子字串是否為回文  \n→ Decision: 先計算 pal table // 先判斷所有子字串是否為回文  \n    → Step 4: For i from 0 to n-1: // 遍歷起始位置  \n        → Step 5: For j from i to n-1: // 遍歷結束位置  \n            → Decision: If i==j? // 單字符為回文  \n                Yes → Step 6: pal[i][j] = true // 單字符回文  \n                No  → Decision: If j==i+1? // 兩字符  \n                    Yes → Step 7: pal[i][j] = (s[i]==s[j]) // 兩字符回文條件  \n                    No  → Decision: If s[i]==s[j] AND pal[i+1][j-1]? // 更長  \n                        Yes → Step 8: pal[i][j] = true // 回文  \n                        No  → Step 9: pal[i][j] = false // 非回文  \n→ Step 10: Create integer array dp[n] // dp[i] = 最小切割數到 i  \n→ Decision: 初始化 dp // 設定最大值  \n    → Step 11: For i from 0 to n-1: dp[i] = i // 最多切割 i 次  \n→ Step 12: For i from 0 to n-1: // 計算 dp  \n    → Decision: If pal[0][i]? // 前面全回文  \n        Yes → Step 13: dp[i] = 0 // 無需切割  \n        No  → Step 14: For j from 1 to i: // 嘗試分割點  \n            → Decision: If pal[j][i]? // 子字串回文  \n                Yes → Step 15: dp[i] = min(dp[i], dp[j-1]+1) // 更新最小切割  \n→ Step 16: Return dp[n-1] // 最終最小切割數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * n\n        pal = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            min_cut = i\n            for j in range(i + 1):\n                if s[j] == s[i] and (i - j <= 1 or pal[j + 1][i - 1]):\n                    pal[j][i] = True\n                    if j == 0:\n                        min_cut = 0\n                    else:\n                        min_cut = min(min_cut, dp[j - 1] + 1)\n            dp[i] = min_cut\n\n        return dp[-1] if n else 0\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Try to extract string inside quotes\n    match = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    s = match.group(1) if match else data\n    solution = Solution()\n    result = solution.minCut(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode521.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence I",
    "description_snippet": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations, no actual code. For problem: given two strings a and b, find length of longest uncommon subsequence (LUS). Known solution: if a==b return -1 else return max(len(a),len(b)). Because if strings equal, no uncommon subsequence; else the longer string itself is uncommon.\n\nSo virtual steps: Start, input strings, compare, decision: if equal then return -1 else return max length. End.\n\nNeed to produce each line: \"Start // 程式開始執行\" etc.\n\nWe should include arrow \"→\" to next steps.\n\nLet's craft lines:\n\nStart // 程式開始執行\n\n→ Step 1: 讀取字符串 a, b // 從輸入取得兩個字串\n\n→ Decision: a 與 b 是否相等? // 比較兩個字串是否完全相同\n\n    Yes → Step 2: 輸出 -1 // 若相同，無不相同的子序列，回傳 -1\n\n    No  → Decision: len(a) 與 len(b) 之較大值? // 若不同，計算長度較大的字串\n\n        Yes → Step 3: 輸出 len(a) // 若 a 較長，輸出 a 的長度\n\n        No  → Step 4: 輸出 len(b) // 若 b 較長，輸出 b 的長度\n\nEnd // 程式執行結束\n\nBut need to use Yes → and No → arrows within decision block. Use indent.\n\nLet's follow format example: indent with 4 spaces? The example uses tab indent? They used 4 spaces after Decision. We'll replicate.\n\nNeed to keep \"→ Decision:\" lines with decision condition. After that, indent lines for Yes and No.\n\nEnsure each line has virtual code and comment after //.\n\nLet's produce.\n\nAlso may include that we compute max directly: Step 2: 輸出 max(len(a), len(b)). But keep explicit decision for clarity.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 a 與 b // 從輸入取得兩個字串  \n→ Decision: a 與 b 是否相等? // 比較兩個字串是否完全相同  \n  Yes → Step 2: 輸出 -1 // 若相同，沒有不相同的子序列，回傳 -1  \n  No  → Decision: len(a) 與 len(b) 之較大值? // 若不同，判斷哪個字串更長  \n    Yes → Step 3: 輸出 len(a) // a 更長，輸出 a 的長度  \n    No  → Step 4: 輸出 len(b) // b 更長，輸出 b 的長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef find_lus_length(a: str, b: str) -> int:\n    \"\"\"\n    回傳兩個字串 a 與 b 之間「最長不常見子序列」的長度。\n    若兩個字串相同，則不存在不常見子序列，回傳 -1。\n    \"\"\"\n    if a == b:\n        return -1\n    return max(len(a), len(b))\n\ndef main() -> None:\n    \"\"\"\n    主函式：\n    1. 從標準輸入讀取所有資料。\n    2. 解析出兩個字串 a 與 b。\n    3. 計算並輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 去除可能的引號\n    data = data.replace('\"', '').replace(\"'\", '')\n\n    # 以逗號分割，若只有一個項目則再以空白分割\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) == 1:\n        parts = data.split()\n\n    a = parts[0] if len(parts) > 0 else ''\n    b = parts[1] if len(parts) > 1 else ''\n\n    result = find_lus_length(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"aba\", \"cdc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "\"aaa\", \"bbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "\"aaa\", \"aaa\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode322.json",
    "problem_index_in_file": 0,
    "title": "Coin Change",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for coin change problem (min coins). Provide step-by-step algorithm, presumably dynamic programming. Use virtual code lines with explanations. Use Start, End, Decision, arrows. Each line includes \"虛擬碼步驟\" + \" // 解釋/說明\". We need to show algorithm steps. We'll produce lines: Start, initialize DP array length amount+1 with INF, DP[0]=0. Loop over coins, nested loop over amount from coin to amount. Update DP[i] = min(DP[i], DP[i-coin]+1). After loops, if DP[amount] is INF return -1 else DP[amount]. Use decision steps for INF check. Provide explanation after each line. Use arrow characters.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 INF 為一個足夠大的整數 // 方便判斷無法組合\n→ Step 2: 初始化 DP 陣列長度 amount+1 且全部值為 INF // DP[i] 代表組成金額 i 所需最小硬幣數\n→ Step 3: 設定 DP[0] = 0 // 零金額不需要硬幣\n→ Decision: 迭代每一種硬幣面額? // 避免重複計算\n    Yes → Step 4: 對於每枚硬幣 coin, 迭代金額 i 從 coin 到 amount\n        → Step 5: 若 DP[i - coin] + 1 < DP[i]，則更新 DP[i] = DP[i - coin] + 1 // 用更少硬幣組合\n→ Step 6: 迭代完成後，判斷 DP[amount] 是否為 INF\n    → Decision: 若 DP[amount] == INF?\n        Yes → Step 7: 回傳 -1 // 無法組成指定金額\n        No  → Step 8: 回傳 DP[amount] // 最小硬幣數\nEnd // 程式執行結束\n\nWe should ensure format: each line \"虛擬碼步驟 // 解釋/說明\". For decisions we use \"Decision: ...\". For indentation maybe spaces. Provide the structure as example.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 INF 為一個足夠大的整數 // 方便判斷無法組合\n→ Step 2: 初始化 DP 陣列長度 amount+1 且全部值為 INF // DP[i] 代表組成金額 i 所需最小硬幣數\n→ Step 3: 設定 DP[0] = 0 // 零金額不需要硬幣\n→ Decision: 迭代每一種硬幣面額? // 避免重複計算\n    Yes → Step 4: 對於每枚硬幣 coin, 迭代金額 i 從 coin 到 amount\n        → Step 5: 若 DP[i - coin] + 1 < DP[i]，則更新 DP[i] = DP[i - coin] + 1 // 用更少硬幣組合\n→ Step 6: 迭代完成後，判斷 DP[amount] 是否為 INF\n    → Decision: 若 DP[amount] == INF?\n        Yes → Step 7: 回傳 -1 // 無法組成指定金額\n        No  → Step 8: 回傳 DP[amount] // 最小硬幣數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef coin_change(coins, amount):\n    \"\"\"Return the minimum number of coins needed to make up the amount,\n    or -1 if it is not possible.\"\"\"\n    # Use a large integer to represent infinity\n    INF = amount + 1\n    dp = [INF] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for value in range(coin, amount + 1):\n            if dp[value - coin] + 1 < dp[value]:\n                dp[value] = dp[value - coin] + 1\n    return dp[amount] if dp[amount] != INF else -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Expect input like: \"coins = [1,2,5], amount = 11\"\n    match = re.search(r'coins\\s*=\\s*(\\[.*?\\])\\s*,\\s*amount\\s*=\\s*(-?\\d+)', data)\n    if not match:\n        raise ValueError(\"Invalid input format\")\n    coins_str, amount_str = match.group(1), match.group(2)\n    coins = eval(coins_str)\n    amount = int(amount_str)\n    result = coin_change(coins, amount)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "coins = [1], amount = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode213.json",
    "problem_index_in_file": 0,
    "title": "House Robber II",
    "description_snippet": "You are a professional robber planning to rob houses along a street. Each house has a certain amount...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: House Robber II with circular houses. Standard DP: choose either first excluded or last excluded.\n\nSteps: compute max for linear houses from 0 to n-2 and from 1 to n-1. Return max. Edge cases n==1.\n\nWe'll output line-by-line virtual code with explanations. Use Start, End, Decision, etc.\n\nLet's produce a clear virtual code. Ensure each line ends with comment after space. We'll use \"→\" for next step.\n\nWe'll not output actual code but pseudo-steps. Let's produce.\n\nWe can write:\n\nStart\n→ Step: If nums length == 1 → End return nums[0]\n→ Step: Compute maxRob(nums, 0, n-2) // helper linear\n→ Step: Compute maxRob(nums, 1, n-1)\n→ Step: result = max(first, second)\n→ End return result\n\nDefine helper: DP with prev2, prev1.\n\nWe'll incorporate decision for dp. Let's produce.\n\nEnsure each line is one step.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: n ← length(nums) // 取得房屋總數  \n→ Decision: 如果 n == 1? // 僅有一棟房子  \n    Yes → Step: return nums[0] // 直接取得該筆財富  \n    No  → Step: firstMax ← maxRob(nums, 0, n-2) // 計算不偷最後一棟的最大收益  \n→ Step: secondMax ← maxRob(nums, 1, n-1) // 計算不偷第一棟的最大收益  \n→ Step: result ← max(firstMax, secondMax) // 取兩種情況中更大的值  \n→ End return result // 程式執行結束  \n\nStart // helper 函式開始  \n→ Step: prev2 ← 0 // 前前一棟的最大收益  \n→ Step: prev1 ← 0 // 前一棟的最大收益  \n→ Step: for i from startIndex to endIndex: // 逐個房子計算  \n    → Decision: 如果 nums[i] + prev2 > prev1? // 決定偷不偷  \n        Yes → curr ← nums[i] + prev2 // 偷：加入前前一棟收益  \n        No  → curr ← prev1 // 不偷：保持前一棟收益  \n    → Step: prev2 ← prev1 // 更新前前一棟  \n    → Step: prev1 ← curr // 更新前一棟  \n→ End return prev1 // 回傳區間內的最大收益",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def rob(self, nums):\n        \"\"\"Return the maximum money that can be robbed from circular houses.\"\"\"\n        if not nums:\n            return 0\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n\n        def rob_linear(houses):\n            \"\"\"Maximum rob amount for a linear sequence of houses.\"\"\"\n            prev, curr = 0, 0\n            for value in houses:\n                prev, curr = curr, max(curr, prev + value)\n            return curr\n\n        # Two scenarios: exclude first house, or exclude last house\n        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input like 'nums = [2,3,2]' or simply '[2,3,2]'.\n    Returns a list of integers.\n    \"\"\"\n    data = data.strip()\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n    return ast.literal_eval(list_part)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.rob(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode402.json",
    "problem_index_in_file": 0,
    "title": "Remove K Digits",
    "description_snippet": "Given string num representing a non-negative integer num, and an integer k, return the smallest poss...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code in line by line. The requirement: no actual code, just pseudo code steps. Use arrow notation. Each line: \"虛擬碼步驟 // 解釋/說明\". Format example. Should start with Start, End, Decision etc.\n\nWe need to cover algorithm: remove k digits to get smallest possible integer. Classic problem using greedy stack: iterate digits, while k > 0 and stack not empty and top > current digit, pop stack, decrement k. After loop, if k > 0, pop last k digits. Build result from stack. Remove leading zeros. If empty, return \"0\".\n\nWe need to produce virtual code lines: Start, Input num, k. Process: convert string to list of digits? Or iterate char. Use stack. For each digit d in num: Decision: if k > 0 and stack not empty and stack.top > d, then pop stack and decrement k. Continue maybe while loop. After processing all digits, if k > 0, pop last k digits. Build result string from stack. Remove leading zeros: Decision if result starts with zeros? Remove. Decision if result empty? Return \"0\". Else return result. End.\n\nWe need to use arrow notation: \"→ Step 1: ...\" etc.\n\nWe need to use \"Decision:\" and arrows. Let's craft.\n\nWe'll produce maybe 15-20 lines.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 接收字串 num 與整數 k // 取得輸入資料\n→ Step 2: 建立空堆疊 stack // 用於儲存剩餘位數\n→ Decision: 如果 k 等於 0? // 若不需要移除任何位數\n    Yes → Step 3: 直接回傳 num // 結束\n    No  → Step 4: 循環遍歷 num 中每一位 d // 逐位處理\n        → Decision: 是否 k > 0? // 檢查是否還有位數要移除\n            Yes → Decision: 是否 stack 非空且 stack.top > d? // 判斷是否可優先移除較大數字\n                Yes → Step 5: 從 stack 彈出頂部元素 // 移除較大數字\n                    → Step 6: k ← k - 1 // k 減 1\n                    → Decision: 重複上述 Decision? // 可能多次移除\n                        Yes → 返回到 上層 Decision: 是否 stack 非空且 stack.top > d?\n                        No  → Step 7: 將 d 推進 stack // 放入目前位數\n                No  → Step 7: 將 d 推進 stack // 不需要移除，直接放入\n            No  → Step 7: 將 d 推進 stack // k 為 0，直接放入\n        → End of loop over d // 完成一次字元處理\n→ Step 8: 如果 k > 0? // 仍有位數未移除\n    Yes → Step 9: 從 stack 彈出 k 個頂部元素 // 移除剩餘位數\n→ Step 10: 由 stack 產生結果字串 res // 連結堆疊內容\n→ Decision: 是否有前導零? // 檢查是否需要去除\n    Yes → Step 11: 移除所有前導零 // 去除多餘零\n    No  → Step 12: 保留 res\n→ Decision: res 是否為空? // 檢查是否全被移除\n    Yes → Step 13: 設定 res 為 \"0\" // 回傳 0\n    No  → Step 14: 保留 res\n→ Step 15: 回傳 res // 結果輸出\nEnd // 程式執行結束\n\nBut we need to format each line as \"虛擬碼步驟 // 解釋\". Also use arrow: \"→\" before each step. We need to indicate nested decisions properly: indentation maybe.\n\nBetter to use like:\n\nStart // 程式開始執行\n→ Step 1: 接收字串 num 與整數 k // 取得輸入資料\n→ Step 2: 建立空堆疊 stack // 用於儲存剩餘位數\n→ Decision: k == 0? // 若不需要移除任何位數\n    Yes → Step 3: 回傳 num // 直接輸出\n    No  → Step 4: 遍歷 num 中每一位 d // 逐位處理\n        → Decision: k > 0? // 是否還有位數要移除\n            Yes → Decision: stack 非空 且 stack.top > d? // 判斷是否可優先移除較大數字\n                Yes → Step 5: 彈出 stack.top // 移除較大數字\n                    → Step 6: k ← k - 1 // k 減 1\n                    → Decision: stack 非空 且 stack.top > d? // 可能繼續移除\n                        Yes → 返回上一層 Decision: stack 非空 且 stack.top > d?\n                        No  → Step 7: push d onto stack // 放入目前位數\n                No  → Step 7: push d onto stack // 不需要移除\n            No  → Step 7: push d onto stack // k 為 0\n        → End of loop // 完成一次字元處理\n→ Decision: k > 0? // 仍有位數未移除\n    Yes → Step 8: 從 stack 彈出 k 個元素 // 移除剩餘位數\n→ Step 9: 由 stack 產生結果字串 res // 連結堆疊內容\n→ Decision: res 有前導零? // 檢查並去除\n    Yes → Step 10: 移除所有前導零 // 去除多餘零\n    No  → Step 11: 保留 res\n→ Decision: res 為空? // 檢查是否全被移除\n    Yes → Step 12: res ← \"0\" // 設為 0\n    No  → Step 13: 保留 res\n→ Step 14: 回傳 res // 結果輸出\nEnd // 程式結束\n\nWe need to keep lines count moderate. Use indentation maybe but not necessary. Each line must have \"虛擬碼步驟\" and comment. They say each line must contain virtual code step + space + // explanation. Use arrow before each step. Use Decision: etc. Let's produce final output accordingly.\n\nWe should ensure each line starts with arrow or Start/End. Provide indentation with spaces? It's fine.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收字串 num 與整數 k // 取得輸入資料  \n→ Step 2: 建立空堆疊 stack // 用於儲存剩餘位數  \n→ Decision: k == 0? // 若不需要移除任何位數  \n  Yes → Step 3: 回傳 num // 直接輸出  \n  No  → Step 4: 遍歷 num 中每一位 d // 逐位處理  \n   → Decision: k > 0? // 是否還有位數要移除  \n    Yes → Decision: stack 非空 且 stack.top > d? // 判斷是否可優先移除較大數字  \n      Yes → Step 5: 彈出 stack.top // 移除較大數字  \n       → Step 6: k ← k - 1 // k 減 1  \n       → Decision: stack 非空 且 stack.top > d? // 可能繼續移除  \n         Yes → 回到上一層 Decision: stack 非空 且 stack.top > d?  \n         No  → Step 7: push d onto stack // 放入目前位數  \n      No  → Step 7: push d onto stack // 不需要移除  \n    No  → Step 7: push d onto stack // k 為 0  \n   → End of loop // 完成一次字元處理  \n→ Decision: k > 0? // 仍有位數未移除  \n  Yes → Step 8: 從 stack 彈出 k 個元素 // 移除剩餘位數  \n→ Step 9: 由 stack 產生結果字串 res // 連結堆疊內容  \n→ Decision: res 有前導零? // 檢查並去除  \n  Yes → Step 10: 移除所有前導零 // 去除多餘零  \n  No  → Step 11: 保留 res  \n→ Decision: res 為空? // 檢查是否全被移除  \n  Yes → Step 12: res ← \"0\" // 設為 0  \n  No  → Step 13: 保留 res  \n→ Step 14: 回傳 res // 結果輸出  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        \"\"\"移除 k 位數，留下最小可能的整數（作為字串返回）。\"\"\"\n        stack = []\n        for digit in num:\n            # 若有剩餘位數要移除且堆疊頂端的數字大於當前，則彈出\n            while k > 0 and stack and stack[-1] > digit:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n\n        # 若仍有剩餘位數未移除，從尾部刪除\n        while k > 0:\n            stack.pop()\n            k -= 1\n\n        # 轉成字串並去除前導零\n        result = ''.join(stack).lstrip('0')\n        return result if result else \"0\"\n\ndef parse_input(data: str):\n    \"\"\"從輸入文字中提取 num 與 k。支持兩種格式：\n       1) num = \"12345\", k = 2\n       2) 兩行分別為 num 與 k\n    \"\"\"\n    # 先嘗試匹配第一種格式\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]+)\"', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if num_match and k_match:\n        num = num_match.group(1)\n        k = int(k_match.group(1))\n        return num, k\n\n    # 否則嘗試第二種格式：每行一個參數\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        num = lines[0]\n        try:\n            k = int(lines[1])\n        except ValueError:\n            # 如果第二行不是純數字，嘗試從中提取數字\n            k_match = re.search(r'(\\d+)', lines[1])\n            k = int(k_match.group(1)) if k_match else 0\n        return num, k\n\n    # 若無法解析，拋出錯誤\n    raise ValueError(\"無法解析輸入。\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    try:\n        num_str, k_val = parse_input(raw_input)\n    except ValueError:\n        # 如輸入僅為兩行：num 與 k\n        parts = raw_input.strip().splitlines()\n        if len(parts) >= 2:\n            num_str = parts[0].strip()\n            k_val = int(parts[1].strip())\n        else:\n            raise\n\n    solver = Solution()\n    result = solver.removeKdigits(num_str, k_val)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"1432219\", k = 3",
          "expected_output": "\"1219\"",
          "success": true,
          "output": "1219"
        },
        {
          "example_index": 1,
          "input": "num = \"10200\", k = 1",
          "expected_output": "\"200\"",
          "success": true,
          "output": "200"
        },
        {
          "example_index": 2,
          "input": "num = \"10\", k = 2",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode125.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome",
    "description_snippet": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and remov...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step: start, steps, decisions. Need to avoid actual code. Provide lines with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow. Steps: input string, normalize: iterate chars, if alphanumeric keep lowercase, else skip. Build cleaned string. Then check palindrome: compare mirrored indices or reverse and compare. Output true/false. End.\n\nMake sure to not output actual code. Use virtual steps: Step 1: read input string. Step 2: initialize empty cleaned string. Step 3: iterate over characters. Decision: char is alphanumeric? Yes → convert to lowercase and append. No → skip. After loop, Step 4: initialize left=0, right=len-1. Decision: left>=right? Yes → return true. No → compare cleaned[left] and cleaned[right]; if equal → left++ right-- and loop; else → return false. End.\n\nWe can use Decision block inside loop.\n\nWrite each line with virtual code style: \"→ Step 1: Read input string s // 取得輸入字串\". Use \"→\" arrow. For decisions: \"Decision: ...?\" and Yes/No branches.\n\nOk. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 取得使用者提供的原始字串  \n→ Step 2: 建立空白字串 cleaned // 用來儲存去除非字母數字且全部小寫的字元  \n→ Step 3: 逐字元遍歷 s // 為了將字串轉為可比對的純文字  \n  Decision: 目前字元為字母或數字? // 判斷是否為有效字元  \n   Yes → Step 4: 轉換為小寫並追加至 cleaned // 小寫化並保留字母數字  \n   No  → Step 5: 跳過此字元 // 非字母數字直接忽略  \n→ Step 6: 取得 cleaned 的長度 n // 用於設定左右指標  \n→ Step 7: 初始化 left = 0, right = n - 1 // 左右指標準備對比  \n→ Decision: left >= right? // 判斷是否已檢查完所有對稱字元  \n  Yes → Step 8: 回傳 true // 所有對稱字元皆相等，為迴文  \n  No  → Decision: cleaned[left] == cleaned[right]? // 進一步比對左右字元  \n    Yes → Step 9: left = left + 1, right = right - 1, 重複 Decision: left >= right? // 移動指標並再次檢查  \n    No  → Step 10: 回傳 false // 任何不相等即非迴文  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        \"\"\"\n        1. 把所有字母轉成小寫，且只保留字母或數字。  \n        2. 再把結果和它的反序比較。若相同就為迴文，回傳 True，否則 False。\n        \"\"\"\n        filtered = [c.lower() for c in s if c.isalnum()]\n        return filtered == filtered[::-1]\n\ndef extract_string(raw: str) -> str:\n    \"\"\"\n    從類似 's = \"...\"' 的輸入中提取引號內的字串。\n    若找不到符合的模式，直接回傳整個輸入（去除前後空白）。\n    \"\"\"\n    # 先嘗試找到第一個和最後一個雙引號之間的內容\n    first_quote = raw.find('\"')\n    last_quote = raw.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        return raw[first_quote + 1:last_quote]\n    # 若沒有引號，直接剔除首尾空白\n    return raw.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = extract_string(raw_input)\n    sol = Solution()\n    result = sol.isPalindrome(s)\n    # 將布林值轉成小寫字串回傳\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"race a car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \" \"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode169.json",
    "problem_index_in_file": 0,
    "title": "Majority Element",
    "description_snippet": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for majority element. Should use Boyer-Moore voting algorithm. Provide steps line by line. Format with arrows and decisions. No actual code. Provide explanations. Let's produce a concise algorithm. Let's output something like:\n\nStart\n→ Step 1: 初始化候选者候选值 candidate 为 null, count = 0 // 初始化\n→ Step 2: 遍歷陣列 nums\n    → Decision: 如果 count == 0? // count 為零時更新候選者\n        Yes → Step 3: candidate = current element // 更新候選者\n        No  → Decision: 如果 current == candidate? // 判斷是否相同\n            Yes → Step 4: count = count + 1 // 相同則 count++\n            No  → Step 5: count = count - 1 // 不同則 count--\n→ End // 返回候選者\n\nBut include explanation lines. Use correct arrow indent. Use Yes → and No →. Format each line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 candidate = null, count = 0 // 初始化候選者與計數  \n→ Step 2: 從 nums 開始遍歷每一個元素 // 進入主迴圈  \n&nbsp;&nbsp;&nbsp;Decision: count == 0? // 判斷是否需要選新的候選者  \n&nbsp;&nbsp;&nbsp;  Yes → Step 3: candidate = current element // 選取新候選者  \n&nbsp;&nbsp;&nbsp;  No → Decision: current element == candidate? // 判斷當前元素是否與候選者相同  \n&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;Yes → Step 4: count = count + 1 // 同一則計數加一  \n&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;No  → Step 5: count = count - 1 // 不同則計數減一  \n→ End // 輸出候選者為 majority element",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def majorityElement(self, nums):\n        \"\"\"Return the element that appears more than n/2 times using Boyer‑Moore.\"\"\"\n        count = 0\n        candidate = None\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        return candidate\n\ndef main():\n    # Read entire input from stdin\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 支援「nums = [3,2,3]」或直接「[3,2,3]」的輸入格式\n    if '=' in raw:\n        _, expr = raw.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw\n\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        # 若解析失敗，直接結束\n        return\n\n    sol = Solution()\n    result = sol.majorityElement(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,1,1,1,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode468.json",
    "problem_index_in_file": 0,
    "title": "Validate IP Address",
    "description_snippet": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 ad...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Each line: virtual step + space + // explanation. Use arrow, Start, End, Decision. We need to outline algorithm to check IPv4, IPv6, or neither. Provide steps like: Start, Step 1: split by '.' if contains '.' then test IPv4, else if contains ':' test IPv6, else Neither. For IPv4: count parts = 4, each part non-empty, no leading zeros except single '0', numeric, 0-255. For IPv6: count parts = 8, each part length 1-4, all hex characters. If passes return appropriate string. Then End. Let's craft lines.\n\nNeed to be thorough: Steps include splitting, decisions. Use \"Decision:\" for condition. Use \"Yes →\" \"No →\". Let's write.\n\nWe also need to include after each line explanation. Provide arrow lines: \"→\" preceding step. Example: \"→ Step 1: split queryIP by '.' and ':'\". Explanation. Let's produce.\n\nAlso we must not output actual code. Just virtual steps.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 判斷 IP 是否含有 '.' ？ // 檢查是否可能為 IPv4\n\nDecision: If contains '.' then IPv4 path else check ':' else Neither\n\nWe may split into separate decision steps.\n\nLine 3: → Decision: queryIP 包含 '.'? // 判斷是否為 IPv4 形式\n\n    Yes → Step 2: 將 queryIP 以 '.' 分割成 parts // 取得四個段落\n\n    No  → Decision: queryIP 包含 ':'? // 判斷是否為 IPv6 形式\n\n        Yes → Step 3: 將 queryIP 以 ':' 分割成 parts // 取得八個段落\n\n        No  → Step 4: 輸出 \"Neither\" // 既不是 IPv4 也不是 IPv6\n\nAfter splits, need to validate.\n\nFor IPv4 path:\n\nLine after Step 2: → Decision: parts 數量是否為 4? // IPv4 必須四段\n\n    Yes → Step 5: 遍歷每個 part\n\n        → Step 5a: part 不能為空 // 檢查非空\n\n        → Step 5b: 若 part 長度 >1 且首字元為 '0' → Step 6: 輸出 \"Neither\" // 領先零不允許\n\n        → Step 5c: 若 part 不是全數字 → Step 6: 輸出 \"Neither\" // 必須是數字\n\n        → Step 5d: 轉成整數，若不在 0~255 → Step 6: 輸出 \"Neither\" // 數值範圍\n\n    No → Step 6: 輸出 \"Neither\" // 段落數目錯誤\n\nIf all pass: Step 7: 輸出 \"IPv4\"\n\nFor IPv6 path:\n\nLine after Step 3: → Decision: parts 數量是否為 8? // IPv6 必須八段\n\n    Yes → Step 8: 遍歷每個 part\n\n        → Step 8a: part 不能為空\n\n        → Step 8b: part 長度是否在 1~4? 若否 → Step 9: 輸出 \"Neither\"\n\n        → Step 8c: 每個字符是否為十六進制 (0-9,a-f,A-F)? 若非 → Step 9: 輸出 \"Neither\"\n\n    No → Step 9: 輸出 \"Neither\"\n\nIf all pass: Step 10: 輸出 \"IPv6\"\n\nFinally End.\n\nNeed to use virtual arrow lines for steps inside loops? Might need indentation but not required. Use \"→\" each line.\n\nWe must not output actual code. Provide explanation in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 queryIP 是否包含 '.' 或 ':' // 判斷可能的 IP 類型  \n→ Decision: queryIP 包含 '.'? // 判斷是否為 IPv4 形式  \n Yes → Step 2: 用 '.' 分割成 parts // 取得可能的四段  \n No → Decision: queryIP 包含 ':'? // 判斷是否為 IPv6 形式  \n  Yes → Step 3: 用 ':' 分割成 parts // 取得可能的八段  \n  No → Step 4: 輸出 \"Neither\" // 既不是 IPv4 也不是 IPv6  \n→ Decision: parts 數量是否為 4? // IPv4 必須四段  \n Yes → Step 5: 遍歷每個 part 做驗證  \n  → Step 5a: part 是否為空? // 必須非空  \n  → Step 5b: 若 part 長度>1 且首字元為 '0' → Step 6: 輸出 \"Neither\" // 領先零不允許  \n  → Step 5c: part 是否全為數字? 若非 → Step 6: 輸出 \"Neither\" // 必須是數字  \n  → Step 5d: 將 part 轉為整數，若不在 0~255 → Step 6: 輸出 \"Neither\" // 數值範圍檢查  \n No  → Step 6: 輸出 \"Neither\" // 段落數目錯誤  \n→ Decision: 所有 IPv4 驗證通過?  \n Yes → Step 7: 輸出 \"IPv4\" // 成功判定為 IPv4  \n No  → // 進入下一判斷  \n→ Decision: parts 數量是否為 8? // IPv6 必須八段  \n Yes → Step 8: 遍歷每個 part 做驗證  \n  → Step 8a: part 是否為空? // 必須非空  \n  → Step 8b: part 長度是否在 1~4? 若否 → Step 9: 輸出 \"Neither\" // 長度限制  \n  → Step 8c: part 的每個字元是否為十六進制 (0-9,a-f,A-F)? 若非 → Step 9: 輸出 \"Neither\" // 十六進制檢查  \n No  → Step 9: 輸出 \"Neither\" // 段落數目錯誤  \n→ Decision: 所有 IPv6 驗證通過?  \n Yes → Step 10: 輸出 \"IPv6\" // 成功判定為 IPv6  \n No  → // 兩種格式都不符合  \n→ Step 11: 輸出 \"Neither\" // 既不是 IPv4 也不是 IPv6  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        # Helper to validate IPv4\n        def isIPv4(s: str) -> bool:\n            parts = s.split('.')\n            if len(parts) != 4:\n                return False\n            for part in parts:\n                if not part.isdigit():\n                    return False\n                if (part[0] == '0' and len(part) != 1):\n                    return False\n                if not 0 <= int(part) <= 255:\n                    return False\n            return True\n\n        # Helper to validate IPv6\n        def isIPv6(s: str) -> bool:\n            parts = s.split(':')\n            if len(parts) != 8:\n                return False\n            hexdigits = set(\"0123456789abcdefABCDEF\")\n            for part in parts:\n                if not (1 <= len(part) <= 4):\n                    return False\n                if any(ch not in hexdigits for ch in part):\n                    return False\n            return True\n\n        # Count separators to quickly decide\n        if queryIP.count('.') == 3 and isIPv4(queryIP):\n            return \"IPv4\"\n        elif queryIP.count(':') == 7 and isIPv6(queryIP):\n            return \"IPv6\"\n        else:\n            return \"Neither\"\n\ndef main():\n    # Read all input, strip surrounding whitespace\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Extract the IP address from input that might be in the form\n    #   queryIP = \"172.16.254.1\"\n    # or just the raw IP string\n    match = re.search(r'\"([^\"]+)\"', raw_input)\n    if match:\n        ip = match.group(1)\n    else:\n        # If no quotes, assume the whole line is the IP\n        ip = raw_input\n\n    solution = Solution()\n    result = solution.validIPAddress(ip)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "queryIP = \"172.16.254.1\"",
          "expected_output": "IPv4",
          "success": true,
          "output": "IPv4"
        },
        {
          "example_index": 1,
          "input": "queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"",
          "expected_output": "IPv6",
          "success": true,
          "output": "IPv6"
        },
        {
          "example_index": 2,
          "input": "queryIP = \"256.256.256.256\"",
          "expected_output": "Neither",
          "success": true,
          "output": "Neither"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode433.json",
    "problem_index_in_file": 0,
    "title": "Minimum Genetic Mutation",
    "description_snippet": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining steps to solve the problem: find min mutation steps from startGene to endGene, BFS. Use queue, visited set. If end not found return -1. Use gene bank as set for O(1) lookup. Edge cases. We'll output in Chinese. Ensure each line includes virtual code step + space + // explanation. Use arrows, Decision, etc. We'll produce something like:\n\nStart // 程式開始\n\n→ Step 1: 將 bank 轉為集合 bankSet // 方便快速查找\n\n→ Step 2: 如果 endGene 不在 bankSet → Return -1 // 沒有可達終點\n\n→ Step 3: 初始化 BFS：queue = [(startGene, 0)] // 起點，距離0\n\n→ Step 4: visited = {startGene} // 標記已訪問\n\n→ Decision: queue 是否空? // 是否還有節點\n\n    No → Step 5: 取出 (current, steps) = queue.pop(0) // 取前\n\n    → Step 6: 如果 current == endGene → Return steps // 找到最短\n\n    → Step 7: 生成所有可能 mutationList // 每個位置 4 字母\n\n        For i in 0..7\n\n            For c in 'ACGT'\n\n                如果 c != current[i] 且 newGene 在 bankSet 且 not in visited\n\n                    → Step 8: queue.append((newGene, steps+1))\n\n                    → Step 9: visited.add(newGene)\n\n    → Decision: queue 是否空? // 重複\n\n        Yes → Step 10: Return -1 // 搜索完畢未找到\n\nEnd\n\nBut need to use virtual code style: \"→ Step 1: ...\". Use \"Decision:\" with Yes and No.\n\nWe must produce line-by-line.\n\nWe need to include the initial Step 1, etc.\n\nAlso note: \"Start\" and \"End\" lines.\n\nLet's craft.\n\nAlso mention we use BFS. Use for loops inside steps but keep within line? Might need nested decisions.\n\nSimplify: we can denote \"For each position i\" as Step. But we can just mention generation step.\n\nMaybe produce:\n\n→ Step 5: 生成 all one-character mutations of current\n\n→ Decision: For each newGene in mutations\n\n    Yes → ... but it's within loop. Might skip detailed.\n\nSimplify: Keep straightforward.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 bankSet ← Set(bank) // 把基因庫轉成集合，方便 O(1) 查找\n→ Decision: 若 endGene 不在 bankSet? // 檢查終點是否可達\n    Yes → Step 2: Return -1 // 沒有可達終點，直接結束\n    No  → \n→ Step 3: 初始化 BFS：queue ← [(startGene, 0)] // 起點與距離\n→ Step 4: visited ← {startGene} // 標記已訪問的基因\n→ Decision: queue 是否空? // 判斷是否還有節點可處理\n    No → Step 5: current, steps ← queue.pop(0) // 取出隊首基因與當前距離\n    → Decision: current 是否等於 endGene? // 檢查是否到達終點\n        Yes → Step 6: Return steps // 找到最短路徑，返回步數\n        No  → Step 7: 生成所有一次變異的新基因 list ← [] // 只改一個位置\n        → For i in 0..7\n            → For c in ['A','C','G','T']\n                → Decision: c != current[i] 且 newGene in bankSet 且 newGene not in visited?\n                    Yes → Step 8: queue.append((newGene, steps+1)) // 加入隊列\n                    → Step 9: visited.add(newGene) // 標記為已訪問\n    → Decision: queue 是否空? // 是否還有節點待處理\n        Yes → Step 10: Return -1 // 搜尋完畢未找到終點\n        No  → 回到 Decision: queue 是否空? // 迴圈繼續\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start, end, bank):\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"Parse input in the form:\n    startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\n    \"\"\"\n    start_match = re.search(r'startGene\\s*=\\s*\"([^\"]+)\"', data)\n    end_match = re.search(r'endGene\\s*=\\s*\"([^\"]+)\"', data)\n    bank_match = re.search(r'bank\\s*=\\s*\\[([^\\]]*)\\]', data)\n\n    if not (start_match and end_match and bank_match):\n        raise ValueError(\"Input format is incorrect\")\n\n    start = start_match.group(1)\n    end = end_match.group(1)\n    bank_raw = bank_match.group(1)\n\n    # Split bank items, strip quotes and whitespace\n    bank = []\n    for item in re.findall(r'\"([^\"]+)\"', bank_raw):\n        bank.append(item)\n\n    return start, end, bank\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    try:\n        start_gene, end_gene, bank = parse_input(raw_input)\n    except ValueError:\n        # If parsing fails, just exit or print -1\n        print(-1)\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.minMutation(start_gene, end_gene, bank)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode168.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Title",
    "description_snippet": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanation. Use Start, Decision, etc. Problem: convert number to Excel column title. Use loop, modulo 26, etc. Let's produce steps.\n\nFormat: each line: \"虛擬碼步驟 // 解釋\". Use arrow. Include Start, End. Use Decision: if remainder. Steps: Initialize result = \"\" ; while columnNumber > 0: remainder = (columnNumber - 1) % 26; char = chr(remainder + ord('A')); result = char + result; columnNumber = (columnNumber - 1) // 26; End. So produce line by line.\n\nMake sure each line includes '→' arrow if it's a step? Example uses \"→ Step 1:\". So we can use \"→ Step 1: Initialize result as empty string // ...\" etc. For decision, use \"Decision:\".\n\nLet's craft. Use step numbers? It's optional but helpful. Use \"Step\". Provide explanation. Let's produce.\n\nStart // 程式開始執行\n→ Step 1: 宣告 result 為空字串 // 用來累積列標題\n→ Step 2: 循環 while columnNumber > 0 // 只要還有數值就繼續轉換\n    → Decision: columnNumber > 0? // 判斷是否還有剩餘數字\n        Yes →\n            → Step 3: 計算 remainder = (columnNumber - 1) % 26 // 取得目前位元的 0-25\n            → Step 4: 取得對應字母 char = chr(remainder + ord('A')) // 轉換成 A-Z\n            → Step 5: result = char + result // 把字母加到結果前面\n            → Step 6: columnNumber = (columnNumber - 1) // 26 // 减少已處理位元\n        No → // 循環結束\nEnd // 程式執行結束，result 即為 Excel 列標題\n\nBut we need correct arrow usage: \"→ Decision:\" etc. Provide each line separately, no nested lines? The example had indentation but still each line separate. We can output indentation with spaces but keep each line separate. Provide arrow for step lines. Use \"→ Decision:\" for decision. Use indentation to show nested.\n\nEnsure no actual code, just pseudo.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告 result 為空字串 // 用來累積列標題  \n→ Step 2: 循環 while columnNumber > 0 // 只要還有數值就繼續轉換  \n    → Decision: columnNumber > 0? // 判斷是否還有剩餘數字  \n        Yes →  \n            → Step 3: remainder ← (columnNumber - 1) % 26 // 取得目前位元的 0-25  \n            → Step 4: char ← chr(remainder + ord('A')) // 轉換為對應字母 A-Z  \n            → Step 5: result ← char + result // 把字母加到結果前面  \n            → Step 6: columnNumber ← (columnNumber - 1) // 26 // 移除已處理位元  \n        No  → // 循環結束  \nEnd // 程式執行結束，result 即為 Excel 列標題",
      "generated_code": "import sys\nimport re\n\ndef convert_to_title(column_number: int) -> str:\n    \"\"\"將給定的正整數轉換為 Excel 列標題。\"\"\"\n    title = []\n    while column_number > 0:\n        column_number -= 1                    # 先減 1 以處理 1~26 對應 A~Z\n        title.append(chr(column_number % 26 + ord('A')))  # 取得本位元字母\n        column_number //= 26                  # 移到下一位\n    return ''.join(reversed(title))           # 反轉得到最終字串\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    if data:\n        # 找出第一個整數，假設輸入類似 'columnNumber = 28'\n        match = re.search(r'(\\d+)', data)\n        if match:\n            col_num = int(match.group(1))\n            result = convert_to_title(col_num)\n            # 以雙引號包住輸出結果\n            print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnNumber = 1",
          "expected_output": "\"A\"",
          "success": true,
          "output": "\"A\""
        },
        {
          "example_index": 1,
          "input": "columnNumber = 28",
          "expected_output": "\"AB\"",
          "success": true,
          "output": "\"AB\""
        },
        {
          "example_index": 2,
          "input": "columnNumber = 701",
          "expected_output": "\"ZY\"",
          "success": true,
          "output": "\"ZY\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode23.json",
    "problem_index_in_file": 0,
    "title": "Merge k Sorted Lists",
    "description_snippet": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerg...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for merging k sorted linked lists into one sorted linked list. Use steps: Use priority queue (min-heap) or divide and conquer. Provide virtual code lines with explanation. We must output line by line, each line with virtual code + space + // explanation. Use Start, End, Decision etc. We should produce algorithm: push head of each list into min-heap, pop smallest, attach to result, push next node from that list, repeat until heap empty.\n\nWe'll produce steps: Start, initialize min-heap, for each list push head, create dummy head, tail pointer, while heap not empty, pop min node, attach to tail, if popped node.next push that, tail update. End. We'll include Decision if heap empty. Also decision for list index > 0? Might not need.\n\nEnsure format.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 初始化最小堆 heap // 建立一個可儲存節點的最小堆\n→ Decision: 是否有至少一個 linked-list? // 檢查輸入是否為空\n    Yes → Step 2: 對每個非空 linked-list 的 head 進行\n    →   Step 2a: 把 head 節點 push 到 heap // 把每條鏈表的第一個節點加入堆中\n    No → End // 若無任何鏈表，直接結束返回空\n→ Step 3: 建立 dummyHead 與 tail // 用 dummy 方便回傳結果，tail 指向結果尾節點\n→ Decision: heap 是否為空? // 開始合併流程\n    Yes → End // 堆空則結束，返回 dummyHead.next\n    No  → Step 4: pop 最小節點 node = heap.pop() // 取出堆中最小值\n→   Step 5: tail.next = node // 把最小節點加到結果鏈表\n→   Step 6: tail = tail.next // 更新 tail\n→   Decision: node.next 是否為 null? // 判斷是否還有下一個節點\n        Yes → Step 7: 如果 node.next 為 null, do nothing // 無下一節點，堆不變\n        No  → Step 8: 把 node.next push 到 heap // 把同一條鏈表的下一節點加入堆\n→   Step 9: 回到 Decision: heap 是否為空? // 迴圈結束條件\nEnd // 程式執行結束\n\nBut need to ensure format: each line should have virtual code + space + // explanation.\n\nAlso use arrows: Start, Decision: If ...? Yes →, No →, etc. Ensure correct indent? The example uses indentation. We can follow similar.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 初始化最小堆 heap // 建立一個可儲存節點的最小堆\n→ Decision: 是否至少有一個 linked-list? // 檢查輸入是否為空\n    Yes → Step 2: 對每個非空 linked-list 的 head 進行\n    →   Step 2a: 把 head 節點 push 到 heap // 把每條鏈表的第一個節點加入堆中\n    No  → End // 若無任何鏈表，直接結束返回空\n→ Step 3: 建立 dummyHead 與 tail // 用 dummy 方便回傳結果，tail 指向結果尾節點\n→ Decision: heap 是否為空? // 開始合併流程\n    Yes → End // 堆空則結束，返回 dummyHead.next\n    No  → Step 4: node = heap.pop() // 取出堆中最小值\n→   Step 5: tail.next = node // 把最小節點加到結果鏈表\n→   Step 6: tail = tail.next // 更新 tail\n→   Decision: node.next 是否為 null? // 判斷是否還有下一個節點\n        Yes → Step 7: 無下一節點，堆不變 // 直接跳過\n        No  → Step 8: 把 node.next push 到 heap // 把同一條鏈表的下一節點加入堆\n→   Step 9: 回到 Decision: heap 是否為空? // 迴圈結束條件\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport heapq\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        \"\"\"\n        Merge k sorted linked lists using a min-heap.\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n\n        heap = []\n        # Use a counter to avoid comparison of ListNode when values are equal\n        counter = 0\n        for node in lists:\n            if node:  # only push non-empty lists\n                heapq.heappush(heap, (node.val, counter, node))\n                counter += 1\n\n        dummy = ListNode(0)\n        tail = dummy\n\n        while heap:\n            val, _, node = heapq.heappop(heap)\n            tail.next = node\n            tail = tail.next\n            if node.next:\n                heapq.heappush(heap, (node.next.val, counter, node.next))\n                counter += 1\n\n        return dummy.next\n\ndef list_to_linked(lst):\n    \"\"\"Convert a Python list to a linked list.\"\"\"\n    dummy = ListNode(0)\n    cur = dummy\n    for val in lst:\n        cur.next = ListNode(val)\n        cur = cur.next\n    return dummy.next\n\ndef linked_to_list(node):\n    \"\"\"Convert a linked list back to a Python list.\"\"\"\n    res = []\n    while node:\n        res.append(node.val)\n        node = node.next\n    return res\n\ndef parse_input(data):\n    \"\"\"\n    Parse input data of the form 'lists = [[1,4,5],[1,3,4],[2,6]]'\n    or similar, extracting the nested list.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # Split on the first '='\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    # Evaluate the expression safely\n    return ast.literal_eval(expr)\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read()\n    # Parse the nested list structure\n    lists_data = parse_input(raw_input)\n\n    # Convert each sublist to a linked list\n    linked_lists = [list_to_linked(sublist) for sublist in lists_data]\n\n    # Merge k lists\n    solution = Solution()\n    merged_head = solution.mergeKLists(linked_lists)\n\n    # Convert result back to Python list and print\n    result = linked_to_list(merged_head)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "success": true,
          "output": "[1, 1, 2, 3, 4, 4, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "lists = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "lists = [[]]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode295.json",
    "problem_index_in_file": 0,
    "title": "Find Median from Data Stream",
    "description_snippet": "The median is the middle value in an ordered integer list. If the size of the list is even, there is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step-by-step for implementing MedianFinder class with methods: constructor, addNum, findMedian. Use two heaps approach: max-heap for lower half, min-heap for upper half. Steps: maintain sizes difference <=1, balance. findMedian depends on sizes: if equal, return average of top of both heaps, else return top of larger heap. Provide step-by-step.\n\nWe need to output in Chinese. Use structure: Start, End, Decision, arrows. Provide explanation per line. Ensure each line includes \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nWe don't output real code; just pseudo steps.\n\nLet's craft. We'll show Start, constructor, addNum, findMedian, End.\n\nAlso maybe include helper functions: balanceHeaps. But can inline.\n\nNeed step-by-step for each method.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立 MedianFinder 物件 // 初始化兩個堆疊\n    → Variable: 小堆（max-heap）為 lowerHalf // 存放較小的一半數字\n    → Variable: 大堆（min-heap）為 upperHalf // 存放較大的另一半數字\n    → Decision: 若兩堆皆為空? // 檢查是否為第一次初始化\n        Yes → Step 2: 兩堆皆空 // 初始狀態\n        No  → // 由於此時尚未執行任何操作，直接跳過\n\n→ Step 3: 方法 addNum(num) // 新數字加入資料結構\n    → Decision: 小堆是否空或 num ≤ 小堆頂點? // 判斷新數字屬於哪半段\n        Yes → 小堆入堆 // 加入小堆\n        No  → 大堆入堆 // 加入大堆\n    → Step 4: 調整堆疊平衡 // 保持兩堆大小差 ≤ 1\n        → Decision: 小堆大小 > 大堆大小 + 1? // 小堆過大\n            Yes → 大堆入堆(小堆頂點) // 取小堆最大值移入大堆\n            No  → // 無需調整\n        → Decision: 大堆大小 > 小堆大小 + 1? // 大堆過大\n            Yes → 小堆入堆(大堆頂點) // 取大堆最小值移入小堆\n            No  → // 無需調整\n\n→ Step 5: 方法 findMedian() // 取得目前所有數字的中位數\n    → Decision: 小堆大小 == 大堆大小? // 堆大小相等時\n        Yes → Result = (小堆頂點 + 大堆頂點) / 2.0 // 取兩頂點平均值\n        No  → Decision: 小堆大小 > 大堆大小? // 小堆較多\n            Yes → Result = 小堆頂點 // 取小堆最大值\n            No  → Result = 大堆頂點 // 取大堆最小值\n    → Return Result // 回傳計算出的中位數\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport heapq\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (invert sign)\n        self.large = []  # min-heap\n\n    def addNum(self, num):\n        heapq.heappush(self.small, -num)\n        # If the largest in small is greater than smallest in large, swap them\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # Balance sizes\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two lists: operations and arguments\n    split_pos = data.find('], [')\n    if split_pos == -1:\n        raise ValueError(\"Invalid input format\")\n    ops_str = data[:split_pos + 1]          # include the closing bracket\n    args_str = data[split_pos + 3:-1]       # exclude the surrounding brackets\n    operations = ast.literal_eval(ops_str)\n    args_list = ast.literal_eval('[' + args_str + ']')\n    obj = None\n    outputs = []\n    for op, args in zip(operations, args_list):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            outputs.append(None)\n        elif op == \"addNum\":\n            obj.addNum(args[0])\n            outputs.append(None)\n        elif op == \"findMedian\":\n            outputs.append(obj.findMedian())\n        else:\n            raise ValueError(f\"Unknown operation {op}\")\n    # Convert Python None to JSON null when dumping\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpdif52vsm.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmpdif52vsm.py\", line 42, in main\n    args_list = ast.literal_eval('[' + args_str + ']')\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [1], [2], [], [3], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode352.json",
    "problem_index_in_file": 0,
    "title": "Data Stream as Disjoint Intervals",
    "description_snippet": "Given a data stream input of non-negative integers a_1, a_2, ..., a_n, summarize the numbers seen so...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line, with \"虛擬碼步驟\" and comment. Should not output real code. Provide steps for SummaryRanges class. So structure: Start, define class, initialization, addNum, getIntervals. Use decision flows. Provide list of intervals, maybe maintain sorted list of intervals. For addNum, check if value exists, find position. Use decision structure. Provide pseudocode. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Class SummaryRanges // 定義 SummaryRanges 類別  \n → Start // 建構子執行  \n  → Initialise intervals = empty list // 初始時無任何區間  \n → End // 建構子結束  \n → Start // addNum 方法執行  \n  → Input value // 取得要加入的整數  \n  → Decision: value 已存在於 intervals? // 判斷數值是否已在任何區間中  \n   Yes → End // 若已存在，直接返回（無需重複加入）  \n   No  → Find position i such that intervals[i].end < value < intervals[i+1].start // 找到左側區間與右側區間（若有）  \n    Decision: value 紧邻左区间? // 檢查是否可合併左側  \n     Yes → Extend intervals[i].end to value // 左側區間右端擴張  \n     No  → Decision: value 紧邻右区间? // 檢查是否可合併右側  \n      Yes → Extend intervals[i+1].start to value // 右側區間左端縮小  \n      No  → Insert new interval [value, value] at position i+1 // 同時不連接任何區間，新增新區間  \n       Decision: 兩側區間是否相連? // 檢查新插入區間是否與左右兩側相連  \n        Yes → Merge intervals[i] and intervals[i+1] into [intervals[i].start, intervals[i+1].end] // 合併兩側區間  \n        No  → End // 否則保持分離  \n        End  \n      End  \n    End  \n   End  \n → End // addNum 方法結束  \n → Start // getIntervals 方法執行  \n  → Return copy of intervals // 直接回傳目前的區間列表（已排序）  \n → End // getIntervals 方法結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass SummaryRanges:\n    \"\"\"\n    SummaryRanges 使用一個有序的區間列表來維護已經加入的數字。\n    每次新增一個數字時，根據該數字與現有區間的位置關係來決定\n    是擴張區間、合併區間還是新建一個區間。\n    \"\"\"\n    def __init__(self):\n        # 目前所有的區間，形如 [[start1, end1], [start2, end2], ...]\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        \"\"\"\n        將整數 val 加入流中。\n        \"\"\"\n        new_start, new_end = val, val\n        res = []\n        placed = False\n\n        for start, end in self.intervals:\n            if end + 1 < val:\n                # 現有區間在 val 左側且不相鄰，直接加入結果\n                res.append([start, end])\n            elif val + 1 < start:\n                # val 在此區間左側且不相鄰\n                if not placed:\n                    res.append([new_start, new_end])\n                    placed = True\n                res.append([start, end])\n            else:\n                # val 與此區間相鄰或重疊，合併\n                new_start = min(start, new_start)\n                new_end = max(end, new_end)\n\n        if not placed:\n            # val 在最右側或所有區間都已處理完畢\n            res.append([new_start, new_end])\n\n        self.intervals = res\n\n    def getIntervals(self):\n        \"\"\"\n        取得目前所有的區間。\n        \"\"\"\n        return self.intervals\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行是方法名列表，第二行是參數列表\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    obj = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"SummaryRanges\":\n            obj = SummaryRanges()\n            outputs.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            outputs.append(None)\n        elif op == \"getIntervals\":\n            outputs.append(obj.getIntervals())\n        else:\n            # 忽略未知方法\n            outputs.append(None)\n\n    # 使用 json.dumps 讓 None 轉成 null，保持輸出格式一致\n    print(json.dumps(outputs))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "success": true,
          "output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode717.json",
    "problem_index_in_file": 0,
    "title": "1-bit and 2-bit Characters",
    "description_snippet": "We have two special characters:\\n- The first character can be represented by one bit 0.\\n- The secon...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (step-by-step). The user request: \"Given a binary array bits that ends with 0, return true if the last character must be a one-bit character.\" They want pseudocode with step-by-step lines with explanation. Use arrow syntax. Must not output actual code. So produce steps.\n\nWe need to handle algorithm: iterate from start to second last? Standard solution: if last 0 has preceding 1 bit: if bits[n-2]==1 then the last 0 is part of a two-bit char and result false else true. But also need to consider earlier patterns. Actually algorithm: traverse from 0 to n-2, when see 0, move 1; when see 1, move 2. At end, if pointer equals n-1 return true else false. Because last bit is at index n-1. Let's produce virtual steps accordingly.\n\nProvide virtual code lines with arrows. Each line has explanation comment. Ensure formatting: \"Start // ...\" etc. Use arrows. Ensure each step. Let's write.\n\nWe need to use \"Start\", \"End\", \"Decision:\" lines. Also maybe \"Step:\". We'll use \"→\" arrow for steps. We'll embed decisions. So produce something like:\n\nStart // start\n→ Step 1: Let n = length(bits) // 获取数组长度\n→ Step 2: Let i = 0 // 初始化指针\n→ Decision: While i < n-1? // 循环直到到达倒数第二个位置\n    Yes → Step 3: If bits[i] == 0? // 当前位是 0\n        Yes → i = i + 1 // 移动一步\n        No  → i = i + 2 // 移动两步（因为是 10 或 11）\n    No → Decision: If i == n-1? // 检查指针是否停在最后一位\n        Yes → Step 4: Return true // 必须是单比特字符\n        No  → Step 5: Return false // 不是单比特字符\nEnd // 结束\n\nWe need to use arrow syntax properly. Let's ensure each line has a virtual code and comment.\n\nAlso we may include more explanation lines: \"Check if bits[i] == 0\" etc. We'll produce concise but clear.\n\nMake sure to follow formatting: each line start with \"Start\" or \"→\" etc. No actual code, only pseudo.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = length(bits) // 取得位元陣列長度  \n→ Step 2: Let i = 0 // 初始化指標至陣列起點  \n→ Decision: i < n-1? // 是否還有位元可處理（不超過倒數第二位）  \n  Yes → Step 3: If bits[i] == 0? // 當前位元為單比特 0  \n    Yes → i = i + 1 // 移動一個位置（單比特字符結束）  \n    No  → i = i + 2 // 移動兩個位置（代表 10 或 11 的雙比特字符）  \n  No  → Decision: i == n-1? // 指標是否停在最後一個 0  \n    Yes → Step 4: Return true // 必須是單比特字符，回傳 true  \n    No  → Step 5: Return false // 不是單比特字符，回傳 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_one_bit_character(bits):\n    i = 0\n    n = len(bits)\n    while i < n - 1:\n        if bits[i] == 1:\n            i += 2\n        else:\n            i += 1\n    return i == n - 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中擷取所有數字\n    nums = re.findall(r'\\d+', data)\n    bits = [int(num) for num in nums]\n    result = is_one_bit_character(bits)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "bits = [1,0,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "bits = [1,1,1,0]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode47.json",
    "problem_index_in_file": 0,
    "title": "Permutations II",
    "description_snippet": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step, with arrows. Problem: Generate all unique permutations of list with duplicates. We need algorithm: backtracking with visited array and sort to skip duplicates. Provide virtual code lines with explanation. Use Decision, Start, End. Each line \"→ Step X: ...\" maybe.\n\nLet's produce steps:\n\nStart\n→ Step 1: Sort nums // sort to handle duplicates\n→ Step 2: Initialize result list // store permutations\n→ Step 3: Initialize visited boolean array // track usage\n→ Step 4: Call backtrack(path = [], depth = 0) // start recursion\n\nDefine backtrack function\n→ Step 5: Decision: depth == len(nums)? // base case\n    Yes → Step 6: Append copy of path to result // store permutation\n    No  → Decision: for i in range(len(nums))? // iterate candidates\n        Yes → Step 7: Decision: visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1])? // skip used or duplicate before\n            Yes → Continue // skip\n            No  → Step 8: visited[i] = True // mark used\n            → Step 9: Append nums[i] to path // add to current permutation\n            → Step 10: Call backtrack(path, depth+1) // recursive\n            → Step 11: Remove last element from path // backtrack\n            → Step 12: visited[i] = False // unmark\n\nEnd\n\nBut need arrow representation.\n\nLet's produce each line accordingly.\n\nAlso need explanation after //.\n\nLet's produce like:\n\nStart // 程式開始執行\n→ Step 1: Sort(nums) // 將輸入數列排序，方便後續去重\n→ Step 2: result ← [] // 用來儲存所有唯一排列\n→ Step 3: visited ← [False] * len(nums) // 標記每個元素是否已被使用\n→ Step 4: backtrack([], 0) // 開始深度優先搜尋\n\nThen define backtrack function; maybe we treat as Step 5: Define backtrack(path, depth) // ...\n\nBut we should maintain linear steps: we might include function definition lines.\n\nLet's produce:\n\n→ Step 5: Define backtrack(path, depth) // 定義遞迴函式\n\nThen inside:\n\n→ Step 6: Decision: depth == len(nums)? // 基本情況：已組成完整排列\n    Yes → Step 7: Append copy of path to result // 將排列加入結果\n    No  → Decision: i from 0 to len(nums)-1? // 遍歷所有元素\n        Yes → Step 8: Decision: visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1])? // 判斷是否跳過重複\n            Yes → Continue // 跳過本次循環\n            No  → Step 9: visited[i] ← True // 標記元素已使用\n            → Step 10: Append nums[i] to path // 加入到當前排列\n            → Step 11: Call backtrack(path, depth+1) // 進一步深度搜尋\n            → Step 12: Remove last element from path // 回溯\n            → Step 13: visited[i] ← False // 取消標記\nEnd // 程式結束\n\nBut we need to ensure each line has \"→\" arrow. For nested decision, we can indent with spaces.\n\nWe can use indentation: 4 spaces before sub-steps.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort(nums) // 將輸入數列排序，方便後續去重  \n→ Step 2: result ← [] // 用來儲存所有唯一排列  \n→ Step 3: visited ← [False] * len(nums) // 標記每個元素是否已被使用  \n→ Step 4: backtrack([], 0) // 開始深度優先搜尋  \n\n→ Step 5: Define backtrack(path, depth) // 定義遞迴函式  \n → Step 6: Decision: depth == len(nums)? // 基本情況：已組成完整排列  \n  Yes → Step 7: Append copy of path to result // 將排列加入結果  \n  No  → Decision: i in 0..len(nums)-1? // 遍歷所有元素  \n   Yes → Step 8: Decision: visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1])? // 判斷是否跳過重複  \n    Yes → Continue // 跳過本次循環  \n    No  → Step 9: visited[i] ← True // 標記元素已使用  \n     → Step 10: Append nums[i] to path // 加入到當前排列  \n     → Step 11: Call backtrack(path, depth+1) // 進一步深度搜尋  \n     → Step 12: Remove last element from path // 回溯  \n     → Step 13: visited[i] ← False // 取消標記  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permuteUnique(self, nums):\n        \"\"\"\n        Generate all unique permutations of the list nums.\n        \"\"\"\n        res = []\n        nums.sort()            # 排序後可方便去重\n        used = [False] * len(nums)\n\n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(path[:])   # 把完整排列加入結果\n                return\n            for i in range(len(nums)):\n                if used[i]:\n                    continue\n                # 若相鄰元素相同且前一個未被使用，則跳過\n                if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                    continue\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n\n        backtrack([])\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 支援形如 \"nums = [1,1,2]\" 的輸入\n    if 'nums' in data:\n        idx = data.find('[')\n        if idx != -1:\n            data = data[idx:]\n\n    # 轉成 Python 物件\n    nums = ast.literal_eval(data)\n\n    # 產生答案並輸出\n    solution = Solution()\n    result = solution.permuteUnique(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "[[1,1,2],[1,2,1],[2,1,1]]",
          "success": true,
          "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": true,
          "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode719.json",
    "problem_index_in_file": 0,
    "title": "Find K-th Smallest Pair Distance",
    "description_snippet": "The distance of a pair of integers a and b is defined as the absolute difference between a and b.\\nG...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm that finds k-th smallest distance among all pairs. Typically solution: sort array, binary search on distance d, count number of pairs with distance <= d, adjust. Steps: sort, binary search low=0, high=max-min, loop while low<high, mid=(low+high)/2, count pairs <= mid using two-pointer sliding window, if count>=k low=mid+1 else high=mid, finally answer low? Actually after loop, low is smallest distance >? We want kth smallest. If count(mid) >= k, then high=mid else low=mid+1. After loop low==high. That distance. Implementation details.\n\nWe need to output virtual code lines with explanations. Use arrows and decisions. We'll produce steps.\n\nLet's outline:\n\nStart\n→ Step: Sort nums ascending\n→ Step: Initialize low=0, high= max(nums)-min(nums)\n→ Decision: While low < high?\n    Yes → Step: mid = (low+high)/2\n    → Step: count = 0\n    → Step: left=0\n    → Decision: For right from 1 to n-1?\n        Yes → Decision: while nums[right]-nums[left] > mid? \n                Yes → left++ (move left pointer)\n                No  → No action\n            End While\n        → Step: count += right-left\n        End For\n    → Decision: if count >= k?\n            Yes → high = mid\n            No  → low = mid + 1\n    → End Decision\n→ End While\n→ Step: return low // kth smallest distance\n\nInclude comments.\n\nLet's produce each line.\n\nWe need structure with arrows and decision. Use indentation.\n\nWe need to produce each line with // explanation.\n\nMake sure to include Start, End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Sort nums in ascending order // 先排序以便後續滑動窗口判斷距離  \n→ Step: low ← 0 // 可能的最小距離  \n→ Step: high ← nums[nums.length-1] - nums[0] // 可能的最大距離  \n→ Decision: low < high? // 是否還有距離區間需要搜尋  \n    Yes → Step: mid ← (low + high) / 2 // 計算中間距離作為查詢  \n    → Step: count ← 0 // 用來統計距離 ≤ mid 的對數  \n    → Step: left ← 0 // 左指標開始於陣列起點  \n    → Decision: for right = 1 to nums.length-1? // 右指標掃描整個陣列  \n        Yes → Decision: while nums[right] - nums[left] > mid? // 若距離過大，左指標右移  \n                Yes → left ← left + 1 // 移動左指標以縮小窗口  \n                No  → // 不需動作，距離已符合條件  \n            End While  \n        → Step: count ← count + (right - left) // 以 current right 為右端，所有合法左端形成對  \n        End For  \n    → Decision: count ≥ k? // 這個距離能否滿足至少 k 個對？  \n        Yes → high ← mid // 可以，縮小上限  \n        No  → low ← mid + 1 // 不行，需增大距離  \n    → End Decision  \n→ End While  \n→ Step: return low // low 即為第 k 小的距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport bisect\nfrom typing import List\n\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n\n        def count_pairs(mid: int) -> int:\n            count = 0\n            left = 0\n            for right in range(n):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            return count\n\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            if count_pairs(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(data: str):\n    \"\"\"Parse input data to extract nums list and k.\"\"\"\n    # Try to match the format: nums = [...], k = ...\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    k_match = re.search(r'k\\s*=\\s*([-\\d]+)', data)\n\n    if nums_match and k_match:\n        nums_str = nums_match.group(1)\n        nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n        k = int(k_match.group(1))\n        return nums, k\n\n    # Fallback: try to interpret as two separate lines\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        try:\n            nums = eval(lines[0], {\"__builtins__\": None}, {})\n        except Exception:\n            nums = [int(x) for x in lines[0].replace('[', '').replace(']', '').split(',') if x.strip()]\n        k = int(lines[1])\n        return nums, k\n\n    # Final fallback: single line with two parts separated by comma\n    parts = data.split(',')\n    if len(parts) >= 2:\n        try:\n            nums = eval(parts[0], {\"__builtins__\": None}, {})\n        except Exception:\n            nums = [int(x) for x in parts[0].replace('[', '').replace(']', '').split() if x.strip()]\n        k = int(parts[1])\n        return nums, k\n\n    raise ValueError(\"Unable to parse input\")\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read().strip()\n    if not raw_data:\n        sys.exit(0)\n    nums, k = parse_input(raw_data)\n    solution = Solution()\n    result = solution.something? Wait; Let's correct.Thinking...\nWe made a mistake: we didn't write result call properly. Let's fix: solution.something? We need to call solution.smallestDistancePair. Also final line print(result). Let's rewrite code block correctly.\n...done thinking.",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,1], k = 1",
          "expected_output": "0",
          "success": false,
          "output": "File \"/tmp/tmpc10w289e.py\", line 69\n    result = solution.something? Wait; Let's correct.Thinking...\n                                          ^\nSyntaxError: unterminated string literal (detected at line 69)"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1], k = 2",
          "expected_output": "0",
          "success": false,
          "output": "File \"/tmp/tmpwb29xhut.py\", line 69\n    result = solution.something? Wait; Let's correct.Thinking...\n                                          ^\nSyntaxError: unterminated string literal (detected at line 69)"
        },
        {
          "example_index": 2,
          "input": "nums = [1,6,1], k = 3",
          "expected_output": "5",
          "success": false,
          "output": "File \"/tmp/tmpfd16joy6.py\", line 69\n    result = solution.something? Wait; Let's correct.Thinking...\n                                          ^\nSyntaxError: unterminated string literal (detected at line 69)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode452.json",
    "problem_index_in_file": 0,
    "title": "Minimum Number of Arrows to Burst Balloons",
    "description_snippet": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps to solve the problem: given intervals, find minimum number of points (arrows) to cover all intervals. Classic greedy: sort by end, pick earliest end, increment count, skip overlapping intervals. So need to produce steps in virtual code lines.\n\nThe output: lines like \"Start // 程式開始執行\" etc. Use arrow \"→\" after Start. Use Decision blocks. Provide explanation in Chinese. Need to be structured: Start, arrow, decisions. Let's produce.\n\nWe need steps:\n\nStart\n→ Step 1: Sort balloons by their x_end in ascending order // 排序\n→ Step 2: 初始化 arrow_count = 0 // 計數\n→ Step 3: 初始化 current_arrow_position = -∞ // 無箭頭位置\n→ Decision: 是否還有未處理的氣球?\n  Yes → Step 4: 取得第一個氣球的 x_end // 取得最小終點\n  → Decision: x_start <= current_arrow_position? // 是否已被前箭頭擊中\n     Yes → Step 5: 跳過此氣球 // 已覆蓋\n     No → Step 6: arrow_count += 1 // 發射新箭頭\n        → Step 7: current_arrow_position = x_end // 設定箭頭位置\n  → Step 8: 移至下一個氣球\n→ End // 完成\n\nNeed to loop. Might use while loop. But we can express as decision and loop. Provide proper indentation. Let's craft.\n\nLet's produce as lines. Use \"→\" arrow after Start. Use \"Decision:\" with indent for Yes and No. Provide comments in Chinese. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort balloons by x_end ascending // 將氣球按水平結束點排序\n→ Step 2: arrow_count ← 0 // 初始化已射箭數量\n→ Step 3: current_arrow_pos ← -∞ // 目前箭頭位置，初始為無限小\n→ Step 4: i ← 0 // 設定指標指向第一個氣球\n→ Decision: i < balloons.length? // 是否還有氣球未處理？\n    Yes → Step 5: x_start ← balloons[i].x_start // 取得目前氣球的起點\n           Step 6: x_end   ← balloons[i].x_end   // 取得目前氣球的終點\n           → Decision: x_start ≤ current_arrow_pos? // 此氣球是否已被現有箭頭擊中？\n               Yes → Step 7: i ← i + 1 // 跳過已覆蓋氣球，處理下一個\n               No  → Step 8: arrow_count ← arrow_count + 1 // 發射新箭頭\n                    Step 9: current_arrow_pos ← x_end // 將箭頭位置設為此氣球的結束點\n                    Step 10: i ← i + 1 // 處理下一個氣球\n           // 回到 Decision: i < balloons.length? 以檢查是否還有氣球\n    No  → End // 所有氣球已處理，結束程式",
      "generated_code": "import sys\nimport ast\n\ndef find_min_arrows(points):\n    if not points:\n        return 0\n    # 依照 x_end 進行排序\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    current_end = points[0][1]\n    for start, end in points[1:]:\n        if start > current_end:\n            arrows += 1\n            current_end = end\n    return arrows\n\ndef parse_input(s):\n    \"\"\"\n    解析輸入字串，支援\n    - points = [[1,2],[3,4]]\n    - [[1,2],[3,4]]\n    \"\"\"\n    s = s.strip()\n    if not s:\n        return []\n    # 找到第一個 '['\n    idx = s.find('[')\n    if idx == -1:\n        return []\n    sub = s[idx:]\n    try:\n        return ast.literal_eval(sub)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    points = parse_input(raw)\n    result = find_min_arrows(points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode123.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock III",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\n\nFind t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrows. It's the classic two transactions maximum profit problem. Steps: we can use DP with four states: first buy1, first sell1, second buy2, second sell2. Or simpler maintain bestBuy1, bestSell1, bestBuy2, bestSell2. Implementation: iterate over prices: update bestBuy1 = max(bestBuy1, -price); bestSell1 = max(bestSell1, bestBuy1 + price); bestBuy2 = max(bestBuy2, bestSell1 - price); bestSell2 = max(bestSell2, bestBuy2 + price). Return bestSell2. Provide explanation each line.\n\nWe need to output each line with \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End. Use Decision if necessary. But basically linear. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 bestBuy1 ← 0 // 第一次買入後的最大利潤（負值）  \n→ Step 2: 定義變數 bestSell1 ← 0 // 第一次賣出後的最大利潤  \n→ Step 3: 定義變數 bestBuy2 ← 0 // 第二次買入後的最大利潤（基於第一次賣出的利潤）  \n→ Step 4: 定義變數 bestSell2 ← 0 // 第二次賣出後的最大利潤  \n→ Decision: 遍歷每個價格 price in prices? // 對每天的股價進行迭代  \n    Yes → Step 5: bestBuy1 ← max(bestBuy1, -price) // 更新第一次買入時的最佳狀態  \n    Yes → Step 6: bestSell1 ← max(bestSell1, bestBuy1 + price) // 更新第一次賣出時的最佳利潤  \n    Yes → Step 7: bestBuy2 ← max(bestBuy2, bestSell1 - price) // 基於第一次賣出的利潤更新第二次買入  \n    Yes → Step 8: bestSell2 ← max(bestSell2, bestBuy2 + price) // 更新第二次賣出時的最佳利潤  \nEnd // 所有股價已遍歷，準備輸出結果  \n→ Step 9: Return bestSell2 // 返回可達到的最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def maxProfit(self, prices):\n        # 如果價格列表為空，直接返回 0\n        if not prices:\n            return 0\n        # 第一次買入時的最佳利潤（負值）\n        buy1 = float('-inf')\n        # 第一次賣出時的最佳利潤\n        sell1 = 0\n        # 第二次買入時的最佳利潤（基於第一次賣出的利潤）\n        buy2 = float('-inf')\n        # 第二次賣出時的最佳利潤\n        sell2 = 0\n        # 逐天更新四個狀態\n        for price in prices:\n            buy1 = max(buy1, -price)            # 更新第一次買入\n            sell1 = max(sell1, buy1 + price)    # 更新第一次賣出\n            buy2 = max(buy2, sell1 - price)     # 更新第二次買入\n            sell2 = max(sell2, buy2 + price)    # 更新第二次賣出\n        return sell2\n\ndef parse_prices(input_text: str):\n    \"\"\"\n    從輸入文字中提取出形如 [1,2,3] 的列表。\n    若找不到，回傳空列表。\n    \"\"\"\n    match = re.search(r'\\[.*?\\]', input_text, re.DOTALL)\n    if not match:\n        return []\n    # 使用 ast.literal_eval 以安全方式解析列表\n    try:\n        return ast.literal_eval(match.group(0))\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    prices = parse_prices(data)\n    result = Solution().maxProfit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode57.json",
    "problem_index_in_file": 0,
    "title": "Insert Interval",
    "description_snippet": "You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for merging intervals with insertion, as described. We'll produce step-by-step pseudocode with explanations. Each line: virtual code + // explanation.\n\nLet's produce:\n\nStart\n→ Initialize result list empty\n→ For each interval in intervals\n    → If current interval ends < newInterval.start\n        → Add current interval to result\n    → Else if current interval starts > newInterval.end\n        → Add newInterval to result (if not added yet) and add current interval, set newInterval flag removed, continue\n    → Else overlapping: merge intervals: newInterval.start = min(newInterval.start, current.start), newInterval.end = max(newInterval.end, current.end)\n→ After loop, if newInterval not yet added, add it\nEnd\n\nWe need to use Decision: etc. We need arrow and indentation.\n\nWe should include step numbers? Not necessary but can. Let's format accordingly.\n\nWe'll produce lines with arrow, steps.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize result as empty list // 用於儲存最終合併後的區間  \n→ Set addedFlag ← False // 用來標記 newInterval 是否已加入 result  \n\n→ Decision: 是否有任何區間？ // 若 intervals 為空直接加入 newInterval  \n    Yes → Step 1: 將 newInterval 加入 result  \n    No →  \n\n→ For each interval in intervals // 遍歷原始區間  \n    → Decision: interval.end < newInterval.start? // 完全在 newInterval 左側  \n        Yes → Step 2: 將 interval 加入 result // 保持順序  \n        No →  \n\n    → Decision: interval.start > newInterval.end? // 完全在 newInterval 右側  \n        Yes → Decision: addedFlag 為 False? // 判斷 newInterval 是否已加入  \n            Yes → Step 3: 將 newInterval 加入 result // 插入新區間  \n            No →  \n        → Step 4: 將 interval 加入 result // 直接加入右側區間  \n        No →  \n\n    → Decision: 有重疊? // 兩區間有交集  \n        Yes → Step 5: newInterval.start ← min(newInterval.start, interval.start) // 合併起點  \n              → Step 6: newInterval.end   ← max(newInterval.end, interval.end)   // 合併終點  \n        No →  \n\n→ Decision: addedFlag 為 False? // 循環結束後檢查是否還沒加入 newInterval  \n    Yes → Step 7: 將 newInterval 加入 result // 將遺漏的區間加入  \n    No →  \n\nEnd // 程式執行結束，返回 result 以得到合併後的區間集合",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals\n        and merge if necessary.\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Add the merged newInterval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(text):\n    \"\"\"\n    Parse the input string into intervals and newInterval.\n    Expected format examples:\n      'intervals = [[1,3],[6,9]], newInterval = [2,5]'\n      'intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]'\n    \"\"\"\n    parts = []\n    current = ''\n    brackets = 0\n    for ch in text:\n        if ch == '[':\n            brackets += 1\n        elif ch == ']':\n            brackets -= 1\n        if ch == ',' and brackets == 0:\n            parts.append(current.strip())\n            current = ''\n        else:\n            current += ch\n    parts.append(current.strip())\n\n    def extract_list(part):\n        idx = part.find('=')\n        if idx == -1:\n            return None\n        list_str = part[idx + 1:].strip()\n        return ast.literal_eval(list_str)\n\n    intervals = extract_list(parts[0])\n    newInterval = extract_list(parts[1]) if len(parts) > 1 else None\n    return intervals, newInterval\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    intervals, new_interval = parse_input(raw_input)\n    solution = Solution()\n    merged = solution.insert(intervals, new_interval)\n    print(merged)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "success": true,
          "output": "[[1, 5], [6, 9]]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "success": true,
          "output": "[[1, 2], [3, 10], [12, 16]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode592.json",
    "problem_index_in_file": 0,
    "title": "Fraction Addition and Subtraction",
    "description_snippet": "Given a string expression representing an expression of fraction addition and subtraction, return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. The requirement: Given string expression representing fraction addition and subtraction, return result in irreducible fraction, integer as X/1. We need to produce pseudo-code algorithm.\n\nWe need to produce line-by-line virtual code with explanations. Use arrow and decision etc. Provide steps: parse string, split terms, convert to fraction, accumulate numerator/denominator using LCM or GCD, reduce. Also handle sign. Steps: Start, parse expression into list of terms (split by + or - with sign). For each term: parse numerator and denominator, sign. Sum using common denominator: sum_numerators/denominator: keep common denominator as product or LCM? For simplicity use common denominator = product of denominators, sum numerators accordingly. After sum, reduce by GCD. Ensure denominator positive. Output string.\n\nLet's produce steps: Start, initialize sum_num=0, sum_den=1. Step 1: Split expression into tokens with regex. For each token: parse sign, numerator, denominator. Step 2: Convert to integer numerator with sign. Step 3: Update sum: new_num = sum_num*den + num*sum_den; new_den = sum_den*den; sum_num=new_num; sum_den=new_den. Step 4: After loop, reduce: gcd=GCD(abs(sum_num), sum_den); sum_num/=gcd; sum_den/=gcd. Step 5: Ensure denominator positive: if sum_den<0, multiply both by -1. Step 6: Convert to string: f\"{sum_num}/{sum_den}\". End.\n\nNeed to include decision steps for parsing sign. Also ensure integer output as fraction.\n\nLet's produce virtual code lines accordingly. Use arrows. Use Decision for sign. Use Start, End. Provide each step line with explanation. Ensure each line has \"// 解釋/說明\" after code.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sum_num ← 0, sum_den ← 1 // 初始化累加分子與分母  \n→ Step 2: tokens ← 解析 expression 為符號 +、- 之後的分式列表 // 使用正則或分隔符將字串拆成獨立分式  \n→ Decision: tokens 是否為空？ // 檢查輸入是否有效  \n  Yes → End // 若無分式，直接結束（不會發生）  \n  No →  \n   → For each token in tokens: // 逐一處理每個分式  \n     → Step 3: sign ← token 首字符是否為 '-' ? -1 : 1 // 判斷符號  \n     → Step 4: num_str, den_str ← 拆分 token 為 'numerator' 與 'denominator' // 取分子分母字串  \n     → Step 5: num ← sign × 轉為整數(num_str) // 取得帶符號的分子  \n     → Step 6: den ← 轉為整數(den_str) // 取得分母  \n     → Decision: den 是否為 0？ // 防止除以零  \n       Yes → Throw Error // 如有 0 分母，拋錯  \n       No →  \n         → Step 7: new_num ← sum_num × den + num × sum_den // 先把前一結果調整為相同分母後相加  \n         → Step 8: new_den ← sum_den × den // 共同分母為乘積  \n         → sum_num ← new_num, sum_den ← new_den // 更新累加結果  \n→ Step 9: gcd_val ← GCD( |sum_num|, sum_den ) // 取得分子分母的最大公因數  \n→ Step 10: sum_num ← sum_num ÷ gcd_val, sum_den ← sum_den ÷ gcd_val // 約分至最簡形式  \n→ Decision: sum_den < 0？ // 確保分母正數  \n  Yes → sum_num ← -sum_num, sum_den ← -sum_den // 兩者同時取負號  \n  No →  \n→ Step 11: result ← 字串化 sum_num / sum_den // 轉成「分子/分母」字串  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom fractions import Fraction\n\nclass Solution:\n    def fractionAddition(self, expression: str) -> str:\n        # 找出所有帶符號的分式\n        fractions = re.findall(r'[+-]?\\d+/\\d+', expression)\n        # 用 Fraction 直接求和\n        result = sum(Fraction(frac) for frac in fractions)\n        return f\"{result.numerator}/{result.denominator}\"\n\ndef main() -> None:\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析 expression，支援形式如：expression = \"-1/2+1/2\"\n    expr_match = re.search(r'[\"\\']([^\"\\']+)[\"\\']', data)\n    if expr_match:\n        expression = expr_match.group(1)\n    else:\n        # 如果沒有引號，直接嘗試取等號右側或整行\n        if '=' in data:\n            expression = data.split('=', 1)[1].strip()\n        else:\n            expression = data\n\n    sol = Solution()\n    result = sol.fractionAddition(expression)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"-1/2+1/2\"",
          "expected_output": "0/1",
          "success": true,
          "output": "0/1"
        },
        {
          "example_index": 1,
          "input": "expression = \"-1/2+1/2+1/3\"",
          "expected_output": "1/3",
          "success": true,
          "output": "1/3"
        },
        {
          "example_index": 2,
          "input": "expression = \"1/3-1/2\"",
          "expected_output": "-1/6",
          "success": true,
          "output": "-1/6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode624.json",
    "problem_index_in_file": 0,
    "title": "Maximum Distance in Arrays",
    "description_snippet": "You are given m arrays, where each array is sorted in ascending order.\nYou can pick up two integers ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code that finds maximum absolute difference between any two integers selected from two different sorted arrays among m arrays. We can pick one integer from each of two different arrays. The distance is absolute difference. We need max distance overall.\n\nApproach: For each array, the smallest element min_i and largest element max_i. The maximum distance would be between a minimal element from one array and a maximal element from another array (or vice versa). The global maximum distance = max( max_i - min_j ) over all i != j, where i,j indexes arrays. Equivalent to difference between global maximum of all max_i and global minimum of all min_j? Wait: If we choose max_i from one array and min_j from another array, distance = max_i - min_j. Also choose min_i and max_j: distance = max_j - min_i. So overall maximum distance is max of (global max - global min). Because any pair of arrays gives difference between a max of one and min of another; the extreme difference will be between overall max and overall min across all arrays. But careful: arrays sorted ascending; each array has min_i and max_i. The maximum absolute difference achievable is between the largest element in some array and the smallest element in some other array. So we just compute global_max = max over all arrays of max_i; global_min = min over all arrays of min_i. If the arrays that hold these extremes are different, answer = global_max - global_min. If the same array holds both, we need to consider second extremes: either second max or second min from same array? Actually if global_max and global_min come from same array, we cannot choose both from same array. We need to find max distance using one array with max, another array with min. So we need second min from other arrays or second max. So we need to compute:\n\nLet arrays list. For each array i, min_i, max_i.\n\nWe want max over i!=j of max_i - min_j and max_j - min_i. Equivalent to max over i!=j of max_i - min_j (since max_j - min_i is just swapping indices). So compute for each array i: consider candidate1 = max_i - min_j for all j!=i. The maximum will be max_i - global_min_of_all_other_arrays. Similarly, candidate2 = max_j - min_i for all j!=i -> same as global_max_of_other_arrays - min_i. So overall max distance is max( max_i - min_except_i , max_except_i - min_i ). So we can compute global max and min, and also second global max and second global min? But we need to know for each array the best opposite extremes.\n\nSimpler algorithm: iterate over all pairs i<j, compute abs(max_i - min_j) and abs(max_j - min_i). Keep maximum. Complexity O(m^2). m maybe small; but we can do O(m). Let's design algorithm with O(m) using precomputed global extremes.\n\nWe'll produce virtual code:\n\nStart\n→ Step: Initialize arrays data\n→ Step: For each array i: compute min_i and max_i\n→ Step: Compute global_max = max over all max_i\n→ Step: Compute global_min = min over all min_i\n→ Decision: Is array containing global_max different from array containing global_min?\n    Yes → Step: result = global_max - global_min\n    No → Step: Need to find second extreme\n        → Step: Find second_max = second largest max_i (exclude array with global_max)\n        → Step: Find second_min = second smallest min_i (exclude array with global_min)\n        → Step: result_candidate1 = second_max - global_min  // using second max with global min\n        → Step: result_candidate2 = global_max - second_min  // using global max with second min\n        → Step: result = max(result_candidate1, result_candidate2)\nEnd\n\nEdge cases: m could be 1? Problem states we must pick two arrays, but if m=1, maybe distance is 0? We can decide.\n\nWe'll include decision for m<2: result = 0.\n\nOk produce virtual code accordingly. Each line with arrow and comment. Use 'Start', 'End', 'Decision:', 'Yes →', 'No →'.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 m 個已排序的陣列 // 收集所有陣列  \n→ Step 2: 初始化 global_min = +∞, global_max = -∞, idx_min = -1, idx_max = -1 // 用於儲存全局最小/最大值及其所在陣列索引  \n→ Step 3: 建立 minList, maxList 空清單 // 方便後續計算第二極值  \n→ Decision: m < 2? // 是否至少有兩個陣列可供選取  \n    Yes → Step 4a: 設 result = 0 // 只能取同一陣列，距離視為 0  \n    No  → Decision: proceed to compute extremes  \n        → Step 5: For i = 0 to m-1  \n            → Substep 5.1: min_i = 第一個元素 of array[i] // 陣列已升序  \n            → Substep 5.2: max_i = 最後一個元素 of array[i]  \n            → Substep 5.3: append min_i to minList  \n            → Substep 5.4: append max_i to maxList  \n            → Substep 5.5: 若 min_i < global_min, 設 global_min = min_i, idx_min = i  \n            → Substep 5.6: 若 max_i > global_max, 設 global_max = max_i, idx_max = i  \n        → Decision: idx_min ≠ idx_max? // 全球最小和最大來自不同陣列  \n            Yes → Step 6a: result = global_max - global_min // 直接取兩極值差距  \n            No  → Step 6b: // 全球最小和最大來自同一陣列，需找次極值  \n                → Step 7: 尋找 second_max = 第二大的 max_i (排除 idx_max)  \n                → Step 8: 尋找 second_min = 第二小的 min_i (排除 idx_min)  \n                → Step 9: candidate1 = second_max - global_min // 第二大最大值與全局最小值  \n                → Step 10: candidate2 = global_max - second_min // 全局最大值與第二小最小值  \n                → Step 11: result = max(candidate1, candidate2) // 選擇較大距離  \n→ Step 12: 輸出 result // 顯示最大距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_distance(arrays):\n    \"\"\"Return the maximum absolute difference between any two numbers chosen\n    from two different sorted arrays.\"\"\"\n    if len(arrays) < 2:\n        return 0\n\n    min_val = arrays[0][0]\n    max_val = arrays[0][-1]\n    res = 0\n\n    for arr in arrays[1:]:\n        # potential distances using the current array's extremes\n        res = max(res, abs(arr[-1] - min_val), abs(max_val - arr[0]))\n        # update the global extremes\n        min_val = min(min_val, arr[0])\n        max_val = max(max_val, arr[-1])\n\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect input like: arrays = [[1,2,3],[4,5],[1,2,3]]\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    try:\n        arrays = ast.literal_eval(expr)\n    except Exception:\n        print(\"0\")\n        return\n    result = max_distance(arrays)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arrays = [[1,2,3],[4,5],[1,2,3]]",
          "expected_output": " 4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": " arrays = [[1],[1]]",
          "expected_output": " 0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode20.json",
    "problem_index_in_file": 0,
    "title": "Valid Parentheses",
    "description_snippet": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the in...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code step by step with explanations. Use Start, End, Decision, arrow. Each line: 虛擬碼步驟 + space + // explanation. We should describe algorithm: Use stack. Iterate each char. If opening, push. If closing, check stack not empty and top matches. At end, check stack empty. Provide each step. Include comments. Provide structure.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化空棧 stack // 用於儲存未匹配的開括號\n→ Step 2: 迭代字串 s 的每個字元 ch // 遍歷所有字符\n→ Decision: ch 是否為 '(' 或 '[' 或 '{'? // 判斷是否是開括號\n    Yes → Step 3: 將 ch 推入 stack // 將開括號入棧\n    No  → Decision: ch 是否為 ')' 或 ']' 或 '}'? // 判斷是否是關閉括號\n        Yes → Step 4: 如果 stack 為空? // 沒有對應的開括號\n            Yes → Step 5: 返回 false // 關閉括號沒有匹配\n            No  → Step 6: pop top = stack.top() // 取得最近的開括號\n            → Decision: top 與 ch 的類型是否匹配? // 比較括號種類\n                Yes → Step 7: 繼續下一個字符 // 匹配成功，繼續\n                No  → Step 8: 返回 false // 類型不匹配\n        No  → Step 9: 返回 false // 字元不是括號\n→ Decision: stack 是否為空? // 檢查是否所有開括號都已匹配\n    Yes → Step 10: 返回 true // 所有括號正確配對\n    No  → Step 11: 返回 false // 有未匹配的開括號\nEnd\n\nBut need to use the exact format with arrows: \"→ Step 1: ...\". Use Start, End.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 stack // 用於儲存尚未匹配的開括號  \n→ Step 2: 迭代字串 s 的每個字元 ch // 循環檢查每個符號  \n→ Decision: ch 是否為 '(' 或 '[' 或 '{'? // 判斷是否為開括號  \n  Yes → Step 3: 將 ch 推入 stack // 把開括號加入棧  \n  No  → Decision: ch 是否為 ')' 或 ']' 或 '}'? // 判斷是否為閉括號  \n   Yes → Step 4: 如果 stack 為空? // 沒有對應的開括號  \n    Yes → Step 5: 返回 false // 閉括號沒有匹配的開括號  \n    No  → Step 6: pop top = stack.top() // 取出最近的開括號  \n    → Decision: top 與 ch 的類型是否匹配? // 檢查括號類型是否相同  \n     Yes → Step 7: 繼續下一個字符 // 匹配成功，繼續循環  \n     No  → Step 8: 返回 false // 類型不匹配，字符串無效  \n   No  → Step 9: 返回 false // 字符不是合法的括號  \n→ Decision: stack 是否為空? // 檢查是否所有開括號都已配對  \n  Yes → Step 10: 返回 true // 字符串有效  \n  No  → Step 11: 返回 false // 有未匹配的開括號  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        檢查字串 s 是否為有效的括號配對。\n        \"\"\"\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n\n        for char in s:\n            if char in mapping:                     # 關閉括號\n                top = stack.pop() if stack else '#'  # 若棧空則取特殊符號\n                if mapping[char] != top:            # 類型不匹配\n                    return False\n            else:                                   # 開括號\n                stack.append(char)\n\n        return not stack  # 若棧空則所有括號已配對\n\ndef extract_string(line: str) -> str:\n    \"\"\"\n    從可能包含「s = \\\"...\\\"」形式的輸入中抽取括號字串。\n    若沒有引號，直接返回整行。\n    \"\"\"\n    line = line.strip()\n    first_quote = line.find('\"')\n    last_quote = line.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        return line[first_quote + 1:last_quote]\n    return line\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit()\n    # 可能有多行輸入，僅取第一行作為待檢查字串\n    first_line = raw_input.splitlines()[0]\n    s = extract_string(first_line)\n\n    sol = Solution()\n    result = sol.isValid(s)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 3,
          "input": "s = \"([])\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 4,
          "input": "s = \"([)]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode204.json",
    "problem_index_in_file": 0,
    "title": "Count Primes",
    "description_snippet": "Given an integer n, return the number of prime numbers that are strictly less than n....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps line by line, with \"虛擬碼步驟\" and explanation comment. Need to cover algorithm: given n, count primes < n. Use Sieve of Eratosthenes or simple check? Just design steps. Use Start, End, Decision, loops. Provide explanation comments. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce something like:\n\nStart // 程式開始\n→ Step 1: 初始化 count = 0 // 计数器\n→ Step 2: 初始化布尔数组 isPrime[0..n-1] 为 true // 记录素数状态\n→ Step 3: Set isPrime[0] = isPrime[1] = false // 0和1不是素数\n→ Step 4: For i from 2 to sqrt(n-1) // 主循环\n    → Decision: if isPrime[i] // 检查是否素数\n        Yes → For j from i*i to n-1 step i // 标记合数\n            isPrime[j] = false\n        No → // 跳过\n→ Step 5: For i from 2 to n-1 // 统计\n    → Decision: if isPrime[i]\n        Yes → count = count + 1\n→ Step 6: Return count // 输出结果\nEnd\n\nBut need \"逐行\" and include indentation? Each line: \"虛擬碼步驟 // 解釋\". Need to incorporate decision with Yes/No arrow. Each decision line may have nested lines. But we must still maintain one line per step? The example shows indentation for nested decisions. We can produce lines as:\n\nStart // 程式開始執行\n→ Step 1: count = 0 // 初始化素数计数器\n→ Step 2: isPrime = array of size n filled with true // 创建布尔数组\n→ Step 3: isPrime[0] = false ; isPrime[1] = false // 0和1不是素数\n→ Step 4: for i from 2 to floor(sqrt(n-1)) // 主循环检查小素数\n    → Decision: isPrime[i] ? // 判断i是否仍标记为素数\n        Yes → for j from i*i to n-1 step i // 标记i的倍数为非素数\n            isPrime[j] = false\n        No  → // 继续下一个i\n→ Step 5: for i from 2 to n-1 // 统计素数\n    → Decision: isPrime[i] ? // 判断i是否为素数\n        Yes → count = count + 1\n→ Step 6: return count // 返回素数总数\nEnd // 程式執行結束\n\nBut must keep each line \"虛擬碼步驟 // 解釋\". So for the nested loops, each line is separate. Indentation may be optional but used to show structure. Let's produce exactly.\n\nEnsure not output actual code. Use pseudo. Use \"→\" arrow, \"Decision:\" lines. Provide explanation in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: count = 0 // 初始化素數計數器  \n→ Step 2: isPrime = array[0..n-1] of true // 建立布林陣列標記所有數為可能素數  \n→ Step 3: isPrime[0] = false ; isPrime[1] = false // 0 與 1 不是素數  \n→ Step 4: for i from 2 to floor(sqrt(n-1)) // 從 2 開始到 √(n-1) 進行主循環  \n    → Decision: isPrime[i] ? // 判斷 i 是否仍被標記為素數  \n        Yes → for j from i*i to n-1 step i // 將 i 的倍數標記為非素數  \n            isPrime[j] = false  \n        No → // 若已不是素數，直接跳過  \n→ Step 5: for i from 2 to n-1 // 再次遍歷所有數以統計素數  \n    → Decision: isPrime[i] ? // 判斷 i 是否為素數  \n        Yes → count = count + 1 // 素數則計數器加一  \n→ Step 6: return count // 回傳小於 n 的素數總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_primes(n: int) -> int:\n    \"\"\"\n    回傳小於 n 的質數個數。\n    使用埃拉托斯特尼篩法。\n    \"\"\"\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    limit = int(n ** 0.5) + 1\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)\n\ndef main() -> None:\n    \"\"\"\n    讀取 stdin，解析出整數 n，計算並輸出答案。\n    \"\"\"\n    data = sys.stdin.read()\n    # 從輸入中找第一個整數，若沒有則預設為 0\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n    print(count_primes(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode264.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number II",
    "description_snippet": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. \n\nGiven an inte...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find nth ugly number. Standard DP with multiple pointers. Provide line-by-line virtual steps with explanation. Use Start, End, Decision. Use arrows. Each line: virtual code step + // explanation. Let's craft. We'll include initialization, loop until count equals n, update pointers. Use decision on min. Also maybe compute min among three candidate multiples. Provide final output. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 取得要找的第 n 個丑數  \n→ Step 2: 初始化 ugly[1] = 1, index2 = index3 = index5 = 1 // 設定第一個丑數和三個指標  \n→ Step 3: 設定 count = 1 // 目前已生成丑數的個數  \n→ Decision: count < n? // 判斷是否已生成足夠數量的丑數  \n    Yes → Step 4: 計算 next2 = ugly[index2] * 2, next3 = ugly[index3] * 3, next5 = ugly[index5] * 5 // 分別計算三種可能的下一個丑數  \n    → Step 5: 找出 nextUgly = min(next2, next3, next5) // 取三者最小值作為下一個丑數  \n    → Step 6: ugly[count + 1] = nextUgly // 存入丑數列  \n    → Step 7: Decision: nextUgly == next2? // 判斷哪個指標需要向前移動  \n        Yes → index2 = index2 + 1  \n        No  → No // 不移動  \n    → Step 8: Decision: nextUgly == next3? // 同理處理 3 的指標  \n        Yes → index3 = index3 + 1  \n        No  → No  \n    → Step 9: Decision: nextUgly == next5? // 同理處理 5 的指標  \n        Yes → index5 = index5 + 1  \n        No  → No  \n    → Step 10: count = count + 1 // 已生成一個新丑數  \n    → Step 11: 回到 Decision: count < n? // 重新檢查是否還需繼續生成  \n    No  → Step 12: 輸出 ugly[n] // 取得第 n 個丑數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        ugly = [1]\n        i2 = i3 = i5 = 0\n\n        while len(ugly) < n:\n            next2, next3, next5 = ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5\n            next_ugly = min(next2, next3, next5)\n            ugly.append(next_ugly)\n\n            if next_ugly == next2:\n                i2 += 1\n            if next_ugly == next3:\n                i3 += 1\n            if next_ugly == next5:\n                i5 += 1\n\n        return ugly[-1]\n\ndef parse_input(data: str) -> int:\n    \"\"\"從輸入文字中擷取整數 n。\"\"\"\n    match = re.search(r'\\d+', data)\n    if match:\n        return int(match.group())\n    raise ValueError(\"未找到有效的整數輸入\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    n = parse_input(raw_input)\n    solution = Solution()\n    result = solution.nthUglyNumber(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "12",
          "success": true,
          "output": "12"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode316.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicate Letters",
    "description_snippet": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for algorithm to remove duplicate letters to get smallest lexicographical order. Classic problem: Leetcode 316. Use stack and frequency count. Approach: count occurrences, use visited set. Iterate characters: decrement count, if visited skip. While stack not empty and current < stack top and count[stack top] > 0, pop and mark visited false. Push current, mark visited true.\n\nWe need to output line by line with arrow and explanation, with Start/End, Decision: etc.\n\nWe should output each logical step.\n\nLet's draft.\n\nStart\n→ Step 1: 初始化字母出現次數表 count[s.char] // 計算每個字母剩餘次數\n→ Step 2: 初始化空堆疊 stack, 空集合 visited // 用於存放結果字母\n→ Step 3: 遍歷字串 s 中每個字符 c\n    → Decision: 是否減少 count[c] // 每次遇到字符，減一次\n        Yes → Step 4: count[c] = count[c] - 1 // 更新剩餘次數\n    → Decision: 如果 c 已在 visited? // 是否已加入結果\n        Yes → Step 5: 跳過此字符 // 重複字母不處理\n        No  → Decision: 如果 stack 不空且 c < stack.top() 且 count[stack.top()] > 0? // 可以移除較大字母\n            Yes → Step 6: pop = stack.pop() ; visited.remove(pop) // 移除\n            No  → Step 7: 推進到下一步\n    → Step 8: 將 c 推入 stack，mark visited[c] = true // 添加\n→ Step 9: 將 stack 轉為字串作為結果\nEnd\n\nBut must format each line with \"虛擬碼步驟\" plus // explanation.\n\nUse arrows: Start, Step X, Decision, Yes →, No →. Use indent for sub-steps.\n\nLet's produce lines.\n\nImportant: For decision lines, we need to include arrow after Yes and No.\n\nExample: \"Decision: if c already visited? // ...\" and then indent \"Yes → Step 5: skip ...\" etc.\n\nLet's produce.\n\nAlso need to include the decrement step separately maybe part of loop.\n\nBetter to combine decrement as part of loop but we can do separate step.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 計算每個字母在 s 中的出現次數，存入 count // 用於追蹤剩餘字母數量\n→ Step 2: 建立空堆疊 stack 與集合 visited // stack 用於保存結果字母，visited 用於快速判斷字母是否已加入\n→ Step 3: 對 s 中的每個字符 c 執行以下操作 // 主迴圈\n    → Decision: 先將 count[c] 減 1 // 更新剩餘次數\n        Yes → Step 4: count[c] = count[c] - 1 // 將 c 的剩餘數量減 1\n    → Decision: 如果 c 已在 visited? // 判斷是否已加入結果\n        Yes → Step 5: 跳過此字符 // 重複字母不處理\n        No  → Decision: 是否可以將較大的已存在字母從 stack 移除？ // 檢查條件\n            Yes → Step 6: pop = stack.pop(); visited.remove(pop) // 移除堆疊頂部字母並更新 visited\n            No  → Step 7: 繼續執行下一步\n    → Step 8: 把 c 放入 stack 並標記為已訪問 // 將字母加入結果\n        → Step 8.1: stack.push(c)\n        → Step 8.2: visited.add(c)\n→ Step 9: 將 stack 轉換為字串作為最終結果 // 把堆疊中的字母按順序拼接\nEnd // 程式執行結束\n\nBut the format might need each line with a single \"→ Step X:\" or \"Decision:\" etc. The nested steps after Yes/No should be indented with a tab? In sample, they indent with 4 spaces maybe. We'll use two spaces indent.\n\nLet's refine:\n\nStart // 程式開始執行\n→ Step 1: 計算每個字母在 s 中的出現次數，存入 count // 用於追蹤剩餘字母數量\n→ Step 2: 建立空堆疊 stack 與集合 visited // stack 用於保存結果字母，visited 用於快速判斷字母是否已加入\n→ Step 3: 對 s 中的每個字符 c 執行以下操作 // 主迴圈\n    → Decision: 將 count[c] 減 1 // 更新剩餘次數\n        Yes → Step 4: count[c] = count[c] - 1 // 重新計算剩餘次數\n    → Decision: 如果 c 已在 visited? // 判斷是否已加入結果\n        Yes → Step 5: 跳過此字符 // 重複字母不處理\n        No  → Decision: 是否可以將較大的已存在字母從 stack 移除？ // 檢查條件\n            Yes → Step 6: pop = stack.pop(); visited.remove(pop) // 移除堆疊頂部字母並更新 visited\n            No  → Step 7: 繼續執行下一步\n    → Step 8: 把 c 放入 stack 並標記為已訪問 // 將字母加入結果\n        → Step 8.1: stack.push(c)\n        → Step 8.2: visited.add(c)\n→ Step 9: 將 stack 轉換為字串作為最終結果 // 把堆疊中的字母按順序拼接\nEnd // 程式執行結束\n\nBut we can reduce Step 8.1 and 8.2 to one line maybe. But it's okay.\n\nHowever, we must ensure each line has the arrow (→). Indentation shows arrow? In sample, indentation uses \"    Yes →\". So we should indent with two spaces before \"Yes →\".\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算每個字母在 s 中的出現次數，存入 count // 用於追蹤剩餘字母數量  \n→ Step 2: 建立空堆疊 stack 與集合 visited // stack 用於保存結果字母，visited 用於快速判斷字母是否已加入  \n→ Step 3: 對 s 中的每個字符 c 執行以下操作 // 主迴圈  \n  → Decision: 將 count[c] 減 1 // 更新剩餘次數  \n      Yes → Step 4: count[c] = count[c] - 1 // 重新計算剩餘次數  \n  → Decision: 如果 c 已在 visited? // 判斷是否已加入結果  \n      Yes → Step 5: 跳過此字符 // 重複字母不處理  \n      No  → Decision: 是否可以將較大的已存在字母從 stack 移除？ // 檢查條件  \n          Yes → Step 6: pop = stack.pop(); visited.remove(pop) // 移除堆疊頂部字母並更新 visited  \n          No  → Step 7: 繼續執行下一步  \n  → Step 8: 把 c 放入 stack 並標記為已訪問 // 將字母加入結果  \n      → Step 8.1: stack.push(c)  \n      → Step 8.2: visited.add(c)  \n→ Step 9: 將 stack 轉換為字串作為最終結果 // 把堆疊中的字母按順序拼接  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeDuplicateLetters(self, s: str) -> str:\n        stack = []\n        seen = set()\n        # 計算每個字母最後一次出現的位置\n        last_occurrence = {c: i for i, c in enumerate(s)}\n        \n        for i, c in enumerate(s):\n            if c not in seen:\n                # 如果堆疊頂部字母大於當前字母且還有機會再遇到它\n                while stack and c < stack[-1] and i < last_occurrence[stack[-1]]:\n                    seen.discard(stack.pop())\n                stack.append(c)\n                seen.add(c)\n        return ''.join(stack)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 若輸入類似 's = \"bcabc\"'，提取引號內的字串；否則直接使用整行文字\n    match = re.search(r'\"([^\"]*)\"', data)\n    s = match.group(1) if match else data.strip()\n    solution = Solution()\n    result = solution.removeDuplicateLetters(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bcabc\"",
          "expected_output": "\"abc\"",
          "success": true,
          "output": "abc"
        },
        {
          "example_index": 1,
          "input": "s = \"cbacdcbc\"",
          "expected_output": "\"acdb\"",
          "success": true,
          "output": "acdb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode432.json",
    "problem_index_in_file": 0,
    "title": "All O`one Data Structure",
    "description_snippet": "Design a data structure to store the strings' count with the ability to return the strings with mini...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Use Start, End, Decision, arrows. Need to design AllOne with O(1). Typical solution: doubly linked list of buckets (counts) with set of keys. Map key to node. Implementation steps: initialize head sentinel. inc: if key not exist, add to count 1 bucket, else increase bucket. dec: remove from bucket, if zero remove key. getMaxKey: head.prev (or tail). getMinKey: head.next.\n\nBut we need virtual code, not actual. Provide step-by-step algorithm, not code lines. So we produce a sequence of steps: Start, etc. Each line includes explanation.\n\nWe need to describe all methods: init, inc, dec, getMaxKey, getMinKey. Each step inside. We can use decision flows.\n\nLet's produce.\n\nWe'll represent data structures: map<Key, BucketNode> keyNodeMap; doubly linked list of BucketNode, each has count and set of keys. Head sentinel with count -inf? But not necessary. We'll have head and tail sentinels.\n\nPseudo:\n\nStart\n→ Initialize: head ← new Node(count=0) // dummy head\n→ head.next ← tail // dummy tail\n→ tail.prev ← head\n→ keyNodeMap ← empty map\nEnd\n\nMethod inc(key)\n→ Decision: If key exists in keyNodeMap?\n    Yes → node ← keyNodeMap[key]\n        // increase count\n        nextNode ← node.next\n        If nextNode.count == node.count + 1\n            // same bucket, add key\n            nextNode.keys.add(key)\n        Else\n            // create new bucket\n            newNode ← new Node(count = node.count + 1)\n            newNode.keys.add(key)\n            // insert after node\n            newNode.prev ← node\n            newNode.next ← node.next\n            node.next.prev ← newNode\n            node.next ← newNode\n        // remove key from old bucket\n        node.keys.remove(key)\n        If node.keys is empty\n            // remove node\n            node.prev.next ← node.next\n            node.next.prev ← node.prev\n        // update map\n        keyNodeMap[key] ← nextNode or newNode\n    No  → // key not exist\n        // add to count 1 bucket\n        If head.next.count == 1\n            head.next.keys.add(key)\n        Else\n            newNode ← new Node(count=1)\n            newNode.keys.add(key)\n            newNode.prev ← head\n            newNode.next ← head.next\n            head.next.prev ← newNode\n            head.next ← newNode\n        keyNodeMap[key] ← head.next\nEnd\n\nMethod dec(key)\n→ node ← keyNodeMap[key]\n→ // decrease count\n→ prevNode ← node.prev\n→ If node.count - 1 == 0\n    // remove key entirely\n    node.keys.remove(key)\n    keyNodeMap.remove(key)\n→ Else\n    If prevNode.count == node.count - 1\n        prevNode.keys.add(key)\n    Else\n        newNode ← new Node(count = node.count - 1)\n        newNode.keys.add(key)\n        // insert before node\n        newNode.prev ← prevNode\n        newNode.next ← node\n        prevNode.next ← newNode\n        node.prev ← newNode\n    node.keys.remove(key)\n    If node.keys is empty\n        node.prev.next ← node.next\n        node.next.prev ← node.prev\n    keyNodeMap[key] ← prevNode or newNode\nEnd\n\nMethod getMaxKey\n→ If head.next == tail\n    return \"\"\n→ Return any key from tail.prev.keys\n\nMethod getMinKey\n→ If head.next == tail\n    return \"\"\n→ Return any key from head.next.keys\n\nBut need to output line by line with explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Initialise AllOne // 建立資料結構\n    → head ← new Node(count=0) // 送端 dummy 頭節點\n    → tail ← new Node(count=∞) // 送端 dummy 尾節點\n    → head.next ← tail // 將頭節點指向尾節點\n    → tail.prev ← head // 尾節點指回頭節點\n    → keyNodeMap ← empty map // key → bucket 節點的映射\nEnd // 初始化結束\n\n// -------------------- inc 方法 --------------------\n→ inc(key) // 對 key 增加 1\n    → Decision: key 目前是否存在？\n        Yes → node ← keyNodeMap[key] // 取得 key 所在的桶\n            → newCount ← node.count + 1 // 計算新計數\n            → Decision: node.next.count == newCount ?\n                Yes → target ← node.next // 已存在符合計數的桶\n                No  → // 新建桶\n                    → target ← new Node(count = newCount)\n                    → target.keys.add(key)\n                    → target.prev ← node\n                    → target.next ← node.next\n                    → node.next.prev ← target\n                    → node.next ← target\n            → node.keys.remove(key) // 從舊桶移除 key\n            → Decision: node.keys is empty ?\n                Yes → // 舊桶無元素則刪除\n                    → node.prev.next ← node.next\n                    → node.next.prev ← node.prev\n            → keyNodeMap[key] ← target // 更新 key 的桶\n        No  → // key 尚未存在，插入計數 1 的桶\n            → Decision: head.next.count == 1 ?\n                Yes → target ← head.next\n                No  → // 新建桶\n                    → target ← new Node(count = 1)\n                    → target.keys.add(key)\n                    → target.prev ← head\n                    → target.next ← head.next\n                    → head.next.prev ← target\n                    → head.next ← target\n            → target.keys.add(key) // 只在不存在時新增\n            → keyNodeMap[key] ← target\nEnd // inc 方法結束\n\n// -------------------- dec 方法 --------------------\n→ dec(key) // 對 key 減少 1\n    → node ← keyNodeMap[key] // 取得 key 的桶\n    → newCount ← node.count - 1 // 計算新計數\n    → Decision: newCount == 0 ?\n        Yes → // 數量降到 0，完全移除 key\n            → node.keys.remove(key)\n            → keyNodeMap.remove(key)\n            → Decision: node.keys is empty ?\n                Yes → // 若桶為空，刪除\n                    → node.prev.next ← node.next\n                    → node.next.prev ← node.prev\n        No  → // 仍有正計數\n            → prevNode ← node.prev\n            → Decision: prevNode.count == newCount ?\n                Yes → target ← prevNode\n                No  → // 新建桶\n                    → target ← new Node(count = newCount)\n                    → target.keys.add(key)\n                    → target.prev ← prevNode\n                    → target.next ← node\n                    → prevNode.next ← target\n                    → node.prev ← target\n            → node.keys.remove(key)\n            → Decision: node.keys is empty ?\n                Yes → // 若桶為空，刪除\n                    → node.prev.next ← node.next\n                    → node.next.prev ← node.prev\n            → keyNodeMap[key] ← target // 更新 key 的桶\nEnd // dec 方法結束\n\n// -------------------- getMaxKey 方法 --------------------\n→ getMaxKey() // 取得最大計數的任一 key\n    → Decision: head.next == tail ?\n        Yes → return \"\" // 無任何 key\n        No  → return any key from tail.prev.keys // 取尾節點前一桶的任意 key\nEnd // getMaxKey 方法結束\n\n// -------------------- getMinKey 方法 --------------------\n→ getMinKey() // 取得最小計數的任一 key\n    → Decision: head.next == tail ?\n        Yes → return \"\" // 無任何 key\n        No  → return any key from head.next.keys // 取頭節點後一桶的任意 key\nEnd // getMinKey 方法結束\n\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport json\n\nclass Node:\n    def __init__(self, count=0):\n        self.count = count\n        self.keys = set()\n        self.prev = None\n        self.next = None\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()          # dummy head (count 0)\n        self.tail = Node()          # dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node(count)\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key: str) -> None:\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key: str) -> None:\n        if key not in self.key_to_node:\n            return\n        node = self.key_to_node[key]\n        node.keys.remove(key)\n        new_count = node.count - 1\n        if new_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < new_count:\n                new_node = self._insert_after(node.prev, new_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self) -> str:\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self) -> str:\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    raw = sys.stdin.read().splitlines()\n    lines = [line.strip() for line in raw if line.strip() != \"\"]\n    if not lines:\n        return\n    # determine which line contains commands list\n    if lines[0].startswith('['):\n        cmd_line = lines[0]\n        arg_line = lines[1] if len(lines) > 1 else '[]'\n    else:\n        cmd_line = lines[1]\n        arg_line = lines[2] if len(lines) > 2 else '[]'\n    commands = json.loads(cmd_line)\n    args_list = json.loads(arg_line)\n\n    obj = None\n    results = []\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"AllOne\":\n            obj = AllOne()\n            results.append(None)\n        elif cmd == \"inc\":\n            obj.inc(args[0])\n            results.append(None)\n        elif cmd == \"dec\":\n            obj.dec(args[0])\n            results.append(None)\n        elif cmd == \"getMaxKey\":\n            results.append(obj.getMaxKey())\n        elif cmd == \"getMinKey\":\n            results.append(obj.getMinKey())\n    print(\"Output\")\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "success": true,
          "output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode344.json",
    "problem_index_in_file": 0,
    "title": "Reverse String",
    "description_snippet": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for reversing a string in-place, given array of characters s. Provide step-by-step lines with virtual code and comments. Use Start, End, Decision, arrows. Need to use in-place O(1). The typical algorithm: two pointers left=0, right=len-1. While left<right swap(s[left], s[right]), left++, right--.\n\nWe need to generate each line as a step. Each line: \"Start // 程式開始執行\" then \"→ Step 1: 獲取字串長度 n = s.length // 取得字串長度\" etc. Decision: If left < right? etc. Use Yes → and No →.\n\nWe must produce in Chinese explanation. The instructions: \"Use 虛擬碼的箭頭 (→, Yes →, No →) and 結構 (Start, End, Decision:).\" So each line is like \"→ Step 1: ... // ...\" or \"Decision: ...\" maybe inside. Use Start and End.\n\nWe should be careful to format exactly as required: Each line is a string with virtual code step, a space, and then // explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = s.length - 1 // 設定左右指標\n→ Decision: left < right? // 判斷是否還需要交換\n    Yes → Step 2: swap s[left] 與 s[right] // 交換左右兩個字符\n    Yes → Step 3: left++ // 左指標右移\n    Yes → Step 4: right-- // 右指標左移\n    Yes → Decision: left < right? // 重新判斷條件\n        Yes → ... (loop) (but we need to structure the loop)\nBut better to use while loop? We can simulate loop via decision with Yes branch repeating steps. We can represent with \"→ Decision: left < right?\" and indent sub-steps.\n\nWe must maintain arrow formatting: Use \"→\" before each step. Indentation not necessary but can show hierarchical.\n\nBetter structure:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = s.length - 1 // 初始化左右指標\n→ Decision: left < right? // 判斷是否需要繼續交換\n    Yes → Step 2: swap s[left] 與 s[right] // 交換兩個字符\n    Yes → Step 3: left++ // 左指標向右移\n    Yes → Step 4: right-- // 右指標向左移\n    Yes → Decision: left < right? // 重新檢查條件，若為真則重複步驟 2-4\n        Yes → ... // 這裡實際是循環\n    No  → End // 所有交換完成，結束程序\n\nBut need to avoid recursion.\n\nMaybe simpler:\n\nStart\n→ Step 1: left = 0, right = s.length - 1\n→ Decision: left < right?\n    Yes → Step 2: swap s[left] 與 s[right]\n    Yes → Step 3: left++\n    Yes → Step 4: right--\n    Yes → Decision: left < right?\n        Yes → ... // loop continues\n    No → End\n\nBut we need to show the loop with arrows. Usually we can use \"→\" to show that after step 4, we go back to Decision. So we can have:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = s.length - 1 // 初始化左右指標\n→ Decision: left < right? // 判斷是否需要交換\n    Yes → Step 2: swap s[left] 與 s[right] // 交換兩個字符\n    Yes → Step 3: left++ // 左指標右移\n    Yes → Step 4: right-- // 右指標左移\n    Yes → Decision: left < right? // 循環回到條件判斷\n    No  → End // 循環結束，所有字符已逆轉\n\nBut we need to maintain that after Step 4, we go back to Decision, not after Step 2 and 3 individually. So better to use a \"→\" after Step 4 that goes to Decision. So we can list steps sequentially; after step 4 we can show \"→ Decision:\" again. Use indentation: maybe each step has \"→\" arrow. Use \"Decision:\" lines.\n\nBetter:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = s.length - 1 // 初始化左右指標\n→ Decision: left < right? // 判斷是否需要交換\n    Yes → Step 2: swap s[left] 與 s[right] // 交換兩個字符\n    Yes → Step 3: left++ // 左指標右移\n    Yes → Step 4: right-- // 右指標左移\n    Yes → Decision: left < right? // 重新檢查條件，若仍為真則重複步驟 2-4\n        Yes → … // 循環重複\n    No → End // 交換完成，程式結束\nNo → End // 初始時左指標不小於右指標，直接結束\n\nBut we should produce all steps. In practice, we don't need to duplicate start of loop again. Use arrow chain: after Step 4, \"→ Decision:\" again. So:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = s.length - 1 // 初始化左右指標\n→ Decision: left < right? // 判斷是否需要交換\n    Yes → Step 2: swap s[left] 與 s[right] // 交換兩個字符\n    Yes → Step 3: left++ // 左指標右移\n    Yes → Step 4: right-- // 右指標左移\n    Yes → Decision: left < right? // 重新判斷條件，若為真則重複交換\n    No  → End // 所有交換完成，程式結束\n\nBut we also need to consider that if initial left >= right, we skip loop. So we can just go to End. That's fine.\n\nNow produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = s.length - 1 // 初始化左右指標\n→ Decision: left < right? // 判斷是否需要交換\n    Yes → Step 2: swap s[left] 與 s[right] // 交換兩個字符\n    Yes → Step 3: left++ // 左指標向右移動\n    Yes → Step 4: right-- // 右指標向左移動\n    Yes → Decision: left < right? // 重新檢查條件，若仍為真則重複步驟 2-4\n    No  → End // 所有交換完成，程式結束\nNo  → End // 初始時左指標已不小於右指標，直接結束程式",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def reverseString(self, s):\n        \"\"\"\n        In-place reverse the array of characters s.\n        Uses two pointers moving towards the center.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        while left < right:\n            # Swap the characters at positions left and right\n            s[left], s[right] = s[right], s[left]\n            left += 1          # move left pointer to the right\n            right -= 1         # move right pointer to the left\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part after 's ='\n    if 's =' in data:\n        list_str = data.split('=', 1)[1].strip()\n    else:\n        # If the input does not contain 's =', assume the whole line is the list\n        list_str = data\n\n    # Safely evaluate the list string to a Python list\n    try:\n        s = ast.literal_eval(list_str)\n    except Exception:\n        # If parsing fails, treat the whole input as a string list\n        s = list_str\n\n    # Ensure s is a list\n    if not isinstance(s, list):\n        s = [s]\n\n    # Reverse the string in-place\n    Solution().reverseString(s)\n\n    # Output the result in JSON format (double quotes around strings)\n    print(json.dumps(s))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
          "expected_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
          "success": true,
          "output": "[\"o\", \"l\", \"l\", \"e\", \"h\"]"
        },
        {
          "example_index": 1,
          "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
          "expected_output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
          "success": true,
          "output": "[\"h\", \"a\", \"n\", \"n\", \"a\", \"H\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2220.json",
    "problem_index_in_file": 0,
    "title": "Minimum Bit Flips to Convert Number",
    "description_snippet": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from ei...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode that computes minimal number of bit flips to convert start to goal. That's basically the Hamming distance between binary representations considering leading zeros? The difference is that we can flip any bit including leading zeros. The minimal flips is simply number of differing bits in binary representation? But if you can flip leading zeros arbitrarily many bits? But you only need to flip bits where they differ. However, consider that you might flip a leading zero to 1 to set a higher bit than either start or goal? But goal is fixed. To convert start to goal, you only need to flip bits that differ between start and goal. Since you can flip any bit including leading zeros, but flipping a leading zero that is not in goal or start might create extra bits; but that wouldn't reduce flips. So answer is number of bits where start XOR goal has 1. That's Hamming distance. So algorithm: compute XOR = start XOR goal, count set bits. Return count. If we want to consider infinite leading zeros? They all zero. XOR will have zeros there. So fine.\n\nWe need to generate virtual code step by step: Start, compute XOR, count bits, return count, End. Each line with explanation.\n\nUse arrow '→'. Provide indentation for decision? But we just need simple. So steps:\n\nStart\n→ Step 1: compute xor = start XOR goal // 取兩數的 XOR，得到不同位\n→ Step 2: set flips = 0 // 初始化翻轉計數\n→ Step 3: While xor ≠ 0 // 只要還有不同位\n  → Step 3.1: flips = flips + 1 // 每次找到一個 1，翻轉數增 1\n  → Step 3.2: xor = xor AND (xor - 1) // 去掉最低位的 1\n→ Step 4: Return flips // 返回最小翻轉數\nEnd\n\nBut we need to use proper virtual code arrows and decisions? We can use Decision: If? But not necessary. Could use Decision to check xor zero? Use Decision: if xor = 0? Yes/No? But they want arrow. Let's produce:\n\nStart\n→ Step 1: xor ← start XOR goal // 取得不同位的位掩碼\n→ Decision: if xor = 0? // 若兩數相同，無需翻轉\n  Yes → Step 2: return 0 // 結束\n  No  → Step 3: flips ← 0 // 初始化翻轉計數\n    → While xor ≠ 0 // 處理每一個不同位\n     → flips ← flips + 1 // 這一位需要翻轉\n     → xor ← xor AND (xor - 1) // 去除已處理的最低位\n    → End While\n    → return flips\nEnd\n\nBut the while loop might be considered structure, but we can use Decision. The requirement: use arrows and structures (Start, End, Decision:). Not necessary to include loops? But maybe use Decision: While? It's ambiguous. But we can use Decision: While xor ≠ 0? But that's not standard. Let's include a loop structure: \"Loop\" maybe.\n\nBut requirement didn't mention loops. But we can produce a simple algorithm: count bits by iterating over 32 bits or while loop. Provide explanation. Let's produce:\n\nStart\n→ Step 1: xor ← start XOR goal // 取兩數的差異位\n→ Step 2: flips ← 0 // 初始翻轉計數\n→ Loop: while xor ≠ 0 // 只要有不同位\n  → flips ← flips + 1 // 找到一個不同位，翻轉計數加一\n  → xor ← xor AND (xor - 1) // 去掉最低位的 1\n→ End Loop\n→ Step 3: return flips // 最小翻轉數\nEnd\n\nBut we need \"→\" arrow for each step, not indent? But we can indent for substeps. They didn't specify indent but we can use indentation.\n\nWe'll keep it simple: Use Step labels.\n\nWe must not output actual code; just virtual steps. Provide explanation after each line.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: xor ← start XOR goal // 取得 start 與 goal 的不同位掩碼\n→ Step 2: flips ← 0 // 初始化翻轉計數為 0\n→ Decision: xor = 0? // 判斷兩數是否已相同\n  Yes → Step 3: return 0 // 若相同，直接返回 0\n  No  → Loop: while xor ≠ 0 // 只要還有不同位\n    → Step 4: flips ← flips + 1 // 這一位需要翻轉，計數加 1\n    → Step 5: xor ← xor AND (xor - 1) // 去掉已處理的最低位 1\n    → End Loop\n    → Step 6: return flips // 返回最小翻轉數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_bit_flips(start: int, goal: int) -> int:\n    \"\"\"\n    以 XOR 找出 start 與 goal 不同的位，然後計算這些位的數量。\n    每一次 while 迴圈都處理一個最低位的 1，最後回傳翻轉所需的最小次數。\n    \"\"\"\n    xor = start ^ goal\n    flips = 0\n    while xor:\n        flips += xor & 1\n        xor >>= 1\n    return flips\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n\n    # 先嘗試使用正則表達式抓取所有整數\n    nums = re.findall(r\"-?\\d+\", data)\n    if len(nums) >= 2:\n        start, goal = map(int, nums[:2])\n    else:\n        # 若輸入格式不符合上面的模式，嘗試以空白分隔\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            start, goal = map(int, parts[:2])\n        else:\n            raise ValueError(\"輸入格式不正確，無法解析 start 與 goal。\")\n\n    # 計算並輸出最小翻轉數\n    print(min_bit_flips(start, goal))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "start = 10, goal = 7",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "start = 3, goal = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode767.json",
    "problem_index_in_file": 0,
    "title": "Reorganize String",
    "description_snippet": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm to rearrange string such that no adjacent same characters. We need to produce steps, with decisions etc. Probably using max heap of frequencies. Provide virtual code step by step. Not actual code. Just pseudocode. Let's produce steps: Start, compute frequency, check max > (n+1)/2 -> impossible. Build max heap of (count,char). previous char placeholder. While heap not empty: pop top, append to result, decrement, if prev count >0 push prev back, set prev=top. etc. Provide explanation per line. Use arrow structure.\n\nWe need to format: each line has \"虛擬碼步驟 // 解釋\". Use → arrow. Use Start and End.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算每個字元出現頻率 // 取得 s 中每個字元的個數  \n→ Step 2: 檢查最大頻率是否大於 (len(s)+1)/2 // 若最大頻率過高，無法排列  \n    Yes → Step 3: 回傳 \"\" // 直接返回空字串表示無法重排  \n    No  → Step 4: 建立一個優先佇列，將 (頻率, 字元) 按頻率遞減排序 // 用來每次取出最多數的字元  \n→ Step 5: 初始化 prevCount = 0, prevChar = \"\" // 用來暫存上一個已使用字元  \n→ Step 6: 初始化 result = \"\" // 用來組裝重排後的字串  \n→ Decision: 優先佇列是否為空?  \n    Yes → End // 當佇列空時，已完成排列，結束程式  \n    No  → Step 7: 從佇列中取出頻率最高的字元 curChar, curCount // 取得下一個要插入的字元  \n→ Step 8: 把 curChar 加到 result // 先把字元放進結果  \n→ Step 9: curCount = curCount - 1 // 減少該字元的剩餘數量  \n→ Step 10: 若 prevCount > 0 // 若上一個字元還有剩餘  \n        Yes → Step 11: 將 (prevCount, prevChar) 放回佇列 // 重新加入佇列以備後續使用  \n        No  → Step 12: // 不做任何事  \n→ Step 13: 若 curCount > 0 // 若目前字元還有剩餘  \n        Yes → prevCount = curCount, prevChar = curChar // 更新 prev 以備下次迴圈使用  \n        No  → prevCount = 0, prevChar = \"\" // 重置 prev，因該字元已用完  \n→ Decision: 回到 Step 6 的決策點 // 重新判斷佇列是否為空  \nEnd // 程式執行結束，返回 result（已重排的字串）",
      "generated_code": "import sys\nimport re\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        # Count the frequency of each character\n        freq = Counter(s)\n        n = len(s)\n\n        # If any character occurs more than (n+1)//2 times,\n        # it's impossible to rearrange without adjacent duplicates\n        if max(freq.values()) > (n + 1) // 2:\n            return \"\"\n\n        # Build a max-heap based on character frequencies\n        max_heap = [(-cnt, ch) for ch, cnt in freq.items()]\n        heapq.heapify(max_heap)\n\n        # prev holds the last used character and its remaining count\n        prev_cnt, prev_ch = 0, ''\n        result = []\n\n        while max_heap:\n            cnt, ch = heapq.heappop(max_heap)\n            result.append(ch)\n\n            # If there is a previous character with remaining count, push it back\n            if prev_cnt < 0:\n                heapq.heappush(max_heap, (prev_cnt, prev_ch))\n\n            # Update prev to the current character (its count has been decreased by 1)\n            prev_cnt, prev_ch = cnt + 1, ch\n\n        rearranged = ''.join(result)\n        # Final safety check: ensure the rearranged string has the same length\n        return rearranged if len(rearranged) == n else \"\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to extract the string inside double quotes, e.g., s = \"aab\"\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        s = m.group(1)\n    else:\n        # If no quotes are found, assume the whole input is the string\n        s = data.strip()\n\n    sol = Solution()\n    output = sol.reorganizeString(s)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "\"aba\"",
          "success": true,
          "output": "aba"
        },
        {
          "example_index": 1,
          "input": "s = \"aaab\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode312.json",
    "problem_index_in_file": 0,
    "title": "Burst Balloons",
    "description_snippet": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it repre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for maximum coins burst balloons DP. Provide line-by-line with arrow and comments. We must not output actual code but pseudo. Use structure: Start, End, Decision. We need to describe algorithm. Provide DP: add virtual 1 at boundaries, then use recursion with memoization or bottom-up. Provide pseudocode. Use lines like \"→ Step 1: Initialize extended array\" etc. Each line ends with // explanation. Use arrow for transitions. Use indentation? They didn't specify indentation but sample shows indent. We'll follow similar style.\n\nWe need to produce line by line pseudocode. Let's craft:\n\nStart\n→ Step 1: create extended array nums' by adding 1 at start and end\n→ Step 2: let m = length of nums'\n→ Step 3: initialize 2D DP table dp[m][m] with zeros\n→ Decision: if m <= 2? // no balloons\n    Yes → Step 4: return 0 // nothing to burst\n→ Step 5: for length from 2 to m-1 // length of interval excluding boundaries\n        → Step 6: for left from 1 to m-length\n              → Step 7: right = left + length - 1\n              → Step 8: for last in left to right // choose last balloon to burst\n                    → Step 9: coins = nums'[left-1] * nums'[last] * nums'[right+1]\n                    → Step 10: total = dp[left][last-1] + coins + dp[last+1][right]\n                    → Decision: if total > dp[left][right]?\n                        Yes → Step 11: dp[left][right] = total\n    End // loops\n→ Step 12: return dp[1][m-2] // maximum coins\n\nBut we need arrows. Use arrow with spaces. Example: \"→ Step 1: ...\". For decisions: \"Decision: if ...\" with Yes → and No → branches.\n\nLet's craft properly. Provide each line. Use consistent naming. Provide indentation maybe with tab or spaces. Sample uses indentation for nested steps. We'll use indentation with tabs.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立新陣列 extendedNums = [1] + nums + [1] // 在兩端加入虛擬氣球 1  \n→ Step 2: 設定 m = len(extendedNums) // 新陣列長度  \n→ Step 3: 建立 2D DP 陣列 dp[m][m] 初始化為 0 // dp[l][r] 代表區間 (l,r) 內最優金幣  \n→ Decision: m <= 2? // 只有兩個虛擬氣球，無實際氣球  \n  Yes → Step 4: return 0 // 無法收集任何金幣  \n  No →  // 繼續以下演算法  \n→ Step 5: for lenInterval from 2 to m-2 step 1 // lenInterval 為真實氣球數量  \n  → Step 6: for left from 1 to m - lenInterval - 1 step 1 // left 為區間左端實際氣球起點  \n   → Step 7: right = left + lenInterval - 1 // 計算右端實際氣球  \n   → Step 8: for last in left to right step 1 // 選擇最後被擊破的氣球索引  \n    → Step 9: coins = extendedNums[left-1] * extendedNums[last] * extendedNums[right+1] // 此氣球擊破時得到的金幣  \n    → Step 10: total = dp[left][last-1] + coins + dp[last+1][right] // 左右子區間的最優金幣 + current coins  \n    → Decision: total > dp[left][right]? // 更新 dp 若更優  \n      Yes → Step 11: dp[left][right] = total // 記錄更高的金幣數  \n      No →  // 保持現有 dp 值  \n      End  \n    End  \n   End  \n  End  \n→ Step 12: return dp[1][m-2] // 取整個區間的最大金幣  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def maxCoins(self, nums):\n        # 在前後加 1 方便計算\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        # 遍歷所有長度\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                # i 為最後一個被戳破的氣球\n                for i in range(left + 1, right):\n                    dp[left][right] = max(\n                        dp[left][right],\n                        nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]\n                    )\n        return dp[0][n - 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找出第一個 '[' 到最後一個 ']' 之間的子字串，並解析成列表\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        nums = ast.literal_eval(match.group())\n    else:\n        nums = []\n    result = Solution().maxCoins(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,1,5,8]",
          "expected_output": "167",
          "success": true,
          "output": "167"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode166.json",
    "problem_index_in_file": 0,
    "title": "Fraction to Recurring Decimal",
    "description_snippet": "Given two integers representing the numerator and denominator of a fraction, return the fraction in ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: fraction to decimal with repeating detection. Use virtual steps. Provide explanation each line. Provide decision branches. Should handle negative sign, division, remainder detection, store remainder positions map. Output string building. Since it's virtual code, no actual code, just steps.\n\nWe need to be clear: Start, input numerator, denominator. Handle sign. Take absolute values. Compute integer part: numerator / denominator. Append to result. Compute remainder = numerator % denominator. If remainder==0, end. Else append '.' and proceed to fractional part. Use map to record remainder positions in result string. While remainder != 0 and remainder not seen: remainder *=10; digit = remainder / denominator; append digit; remainder %= denominator; store remainder index. If remainder repeats: insert '(' at stored index, append ')' and break. Then end.\n\nEdge cases: numerator zero => return \"0\".\n\nUse virtual code. Let's produce lines. Use indentation? Not necessary but we can show hierarchy. But each line is \"虛擬碼步驟 // 解釋\".\n\nLet's create. Use arrow for decision. Use Start End. Use nested decisions.\n\nWe need to produce lines like:\n\nStart // 程式開始\n\n→ Step 1: 輸入分子 numerator 和分母 denominator // 從使用者處取得兩個整數\n\n→ Decision: numerator 為 0? // 檢查分子是否為 0\n\n    Yes → Step 2: 返回 \"0\" // 若分子為 0，直接回傳字串\n\n    No  → Step 3: 計算符號 sign // 決定結果正負\n\n...\n\nWe need to ensure each line ends with // 解釋.\n\nLet's craft.\n\nAlso handle sign: if numerator<0 XOR denominator<0 then sign=\"-\" else sign=\"\". Use abs.\n\nAlso compute integerPart = abs(numerator) / abs(denominator). Append to result string.\n\nCompute remainder = abs(numerator) % abs(denominator).\n\nIf remainder==0, return sign + integerPart as string.\n\nElse, result = sign + integerPart + \".\"; and start fractional.\n\nUse map mapRemainderToIndex: remainder->index in result string (index after decimal point).\n\nWhile remainder !=0 and remainder not in map:\n\n    map[remainder] = current length of result\n\n    remainder *=10\n\n    digit = remainder / abs(denominator)\n\n    append digit to result\n\n    remainder %= abs(denominator)\n\nAfter loop, if remainder==0, return result\n\nElse // remainder repeated\n\n    insert '(' at map[remainder] position in result\n\n    append ')' to result\n\nReturn result.\n\nWe need to include decision branches for remainder==0 inside loop? We can incorporate within loop: Decision: remainder==0? break.\n\nBut in pseudo we can just say while remainder != 0 and remainder not seen. Then after loop handle repeated case.\n\nLet's produce step lines accordingly.\n\nWe need to output in Chinese. Use Traditional Chinese. Provide explanation lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入分子 numerator 與分母 denominator // 從使用者處取得兩個整數  \n→ Decision: numerator 為 0? // 檢查分子是否為 0  \n  Yes → Step 2: 返回 \"0\" // 若分子為 0，直接回傳字串  \n  No → Step 3: 計算符號 sign // 決定結果正負  \n    → Step 4: 若 numerator < 0 XOR denominator < 0，則 sign = \"-\"，否則 sign = \"\" // 確定符號  \n→ Step 5: 取絕對值 absNum = |numerator|，absDen = |denominator| // 用正整數進行後續計算  \n→ Step 6: 計算整數部分 integerPart = absNum ÷ absDen // 整數商  \n→ Step 7: 計算餘數 remainder = absNum MOD absDen // 初始餘數  \n→ Decision: remainder 為 0? // 判斷是否為有限小數  \n  Yes → Step 8: 返回 sign + integerPart  // 直接回傳正負整數  \n  No → Step 9: 建立結果字符串 result = sign + integerPart + \".\" // 加入小數點  \n→ Step 10: 建立空映射 mapRemainderToIndex // 用於記錄餘數所在位置  \n→ Step 11: 初始化 index = length of result // 現在結果字符串長度，作為下一位小數的索引  \n→ Decision: remainder != 0 且 remainder 尚未在 mapRemainderToIndex? // 判斷是否需要繼續生成小數位  \n  Yes → Step 12: 將 remainder 映射到 index // mapRemainderToIndex[remainder] = index  \n    → Step 13: remainder = remainder × 10 // 進位  \n    → Step 14: digit = remainder ÷ absDen // 取得下一位小數  \n    → Step 15: result = result + digit  // 將小數位加入結果  \n    → Step 16: remainder = remainder MOD absDen // 更新餘數  \n    → Step 17: index = length of result // 更新下一位小數的索引  \n    → Step 18: 回到 Decision: remainder != 0 且 remainder 尚未在 mapRemainderToIndex?  \n  No → Step 19: 判斷 remainder 為 0? // 判斷是否結束或發現循環  \n    Yes → Step 20: 返回 result // 完成非循環小數  \n    No → Step 21: 找到重複開始位置 repeatIndex = mapRemainderToIndex[remainder] // 重複餘數對應的位置  \n     → Step 22: 在 result 的 repeatIndex 位置插入 \"(\" // 開始括號  \n     → Step 23: result = result + \")\" // 結束括號  \n     → Step 24: 返回 result // 回傳包含循環部分的小數字符串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return \"0\"\n        res = []\n        # 處理符號\n        if (numerator < 0) ^ (denominator < 0):\n            res.append(\"-\")\n        numerator, denominator = abs(numerator), abs(denominator)\n        # 整數部分\n        res.append(str(numerator // denominator))\n        remainder = numerator % denominator\n        if remainder == 0:\n            return \"\".join(res)\n        res.append(\".\")\n        seen = {}\n        while remainder != 0:\n            if remainder in seen:\n                idx = seen[remainder]\n                res.insert(idx, \"(\")\n                res.append(\")\")\n                break\n            seen[remainder] = len(res)\n            remainder *= 10\n            res.append(str(remainder // denominator))\n            remainder %= denominator\n        return \"\".join(res)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 2:\n        numerator, denominator = nums[0], nums[1]\n    else:\n        # 如果沒有符合的數字，直接退出\n        sys.exit()\n    solution = Solution()\n    result = solution.fractionToDecimal(numerator, denominator)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numerator = 1, denominator = 2",
          "expected_output": "\"0.5\"",
          "success": true,
          "output": "0.5"
        },
        {
          "example_index": 1,
          "input": "numerator = 2, denominator = 1",
          "expected_output": "\"2\"",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "numerator = 4, denominator = 333",
          "expected_output": "\"0.(012)\"",
          "success": true,
          "output": "0.(012)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode30.json",
    "problem_index_in_file": 0,
    "title": "Substring with Concatenation of All Words",
    "description_snippet": "You are given a string s and an array of strings words. All the strings of words are of the same len...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm. Should explain each step. The problem: find all start indices of concatenated substrings in s that contain all words (same length) exactly once each. Classic Leetcode 30: Substring with Concatenation of All Words. Approach: sliding window with word length. Implementation: use hash map of word counts, iterate over offset 0..wordLen-1, maintain window of words, adjust counts, etc.\n\nWe must produce step-by-step virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrow markers.\n\nLet's craft algorithm steps:\n\nStart\n→ Initialize wordLen = length of first word\n→ Initialize wordsCount map counting each word\n→ Initialize totalWords = length of words\n→ Initialize result list\n→ For offset in 0..wordLen-1:\n    → Initialize left = offset\n    → Initialize currentCount map\n    → Initialize formed = 0\n    → For right from offset to len(s)-wordLen step wordLen:\n        → Extract word = s.substring(right, right+wordLen)\n        → If word not in wordsCount:\n            → Reset currentCount to empty, formed = 0, left = right + wordLen\n            → Continue\n        → Increment currentCount[word]\n        → If currentCount[word] <= wordsCount[word]:\n            → formed += 1\n        → While right - left + wordLen == totalWords * wordLen:\n            → If formed == totalWords:\n                → Add left to result\n            → leftWord = s.substring(left, left+wordLen)\n            → If leftWord in wordsCount:\n                → If currentCount[leftWord] <= wordsCount[leftWord]:\n                    → formed -= 1\n                → Decrement currentCount[leftWord]\n            → left += wordLen\nEnd // Output result\n\nWe need to put each step as a line with explanation.\n\nProbably include steps for initializing maps, loops, decisions.\n\nMake sure to use \"Decision:\" lines for if conditions.\n\nLet's produce the output.\n\nAlso mention \"Start\" and \"End\".\n\nWe must maintain arrow syntax: \"→ Step ...\" or \"Decision:\".\n\nLet's write:\n\nStart // 程式開始執行\n→ wordLen ← Length of first word in words // 取得單一字串長度\n→ wordsCount ← Map counting occurrences of each word in words // 建立每個字串出現次數的哈希表\n→ totalWords ← Length of words // 總字串數\n→ result ← Empty list // 存放符合條件的起始位置\n\n→ For offset from 0 to wordLen-1:\n    → left ← offset // 左邊界指標\n    → currentCount ← Empty map // 當前滑動窗口內各字串的計數\n    → formed ← 0 // 目前已正確匹配的字串數\n    → For right from offset to Length(s)-wordLen step wordLen:\n        → word ← Substring(s, right, wordLen) // 從 s 取出當前長度為 wordLen 的字串\n        → Decision: 如果 word 不在 wordsCount? // 檢查字串是否為 words 中的元素\n            Yes → currentCount ← Empty map // 重置計數\n            Yes → formed ← 0\n            Yes → left ← right + wordLen // 移動左邊界到下一個可能起點\n            Yes → Continue // 跳過後續判斷\n        No → // word 在 wordsCount 中\n            → Increment currentCount[word] // 更新該字串的計數\n            → Decision: 如果 currentCount[word] <= wordsCount[word]? // 是否仍在允許範圍內\n                Yes → formed ← formed + 1 // 允許範圍內則增加已匹配數\n                No  → // 超過允許次數，將不會直接增加 formed\n        → Decision: 如果 (right - left + wordLen) == totalWords * wordLen? // 是否已組成完整長度窗口\n            Yes → Decision: 如果 formed == totalWords? // 檢查是否所有字串都正確匹配\n                Yes → Append left to result // 將起始位置加入答案\n            Yes → // 將左邊界移動一個字串長度，縮小窗口\n                → leftWord ← Substring(s, left, wordLen) // 取得左邊界字串\n                → Decision: 如果 leftWord 在 wordsCount? // 左邊界字串是否為 words 中的元素\n                    Yes → Decision: 如果 currentCount[leftWord] <= wordsCount[leftWord]? // 是否在允許範圍內\n                        Yes → formed ← formed - 1 // 若在範圍內，減少已匹配數\n                    Yes → Decrement currentCount[leftWord] // 更新左邊界字串的計數\n                Yes → left ← left + wordLen // 左邊界向右移動\n            No  → // 窗口未達完整長度，繼續擴展\n        No  → // 右邊界未達完整長度，繼續擴展\nEnd // 程式執行結束，result 為所有符合條件的起始索引\n\nNeed to ensure each line is separate. But the specification: \"逐行輸出\" meaning each line separate.\n\nLet's produce the output accordingly.\n\nAlso mention \"Start // 程式開始執行\" etc.\n\nCheck that we use \"Decision:\" for if conditions.\n\nEnsure lines like \"→ Decision: ...\" have correct syntax.\n\nWill produce each step as a separate line with the arrow.\n\nAlso might need to include \"←\" arrow for assignment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ wordLen ← Length(first words[0]) // 取得 words 中單一字串的長度  \n→ wordsCount ← Map() // 建立每個字串出現次數的哈希表  \n→ For each w in words:  \n    → If w not in wordsCount: wordsCount[w] ← 0  \n    → wordsCount[w] ← wordsCount[w] + 1 // 計算每個字串的頻率  \n→ totalWords ← Length(words) // 總字串數量  \n→ result ← Empty list // 儲存所有符合條件的起始索引  \n\n→ For offset from 0 to wordLen-1:  \n    → left ← offset // 左邊界指標  \n    → currentCount ← Map() // 當前滑動窗口內各字串的計數  \n    → formed ← 0 // 目前已正確匹配的字串數  \n    → For right from offset to Length(s)-wordLen step wordLen:  \n        → word ← Substring(s, right, wordLen) // 取出當前長度為 wordLen 的字串  \n        → Decision: word not in wordsCount?  \n            Yes → currentCount ← Map() // 重置計數  \n            Yes → formed ← 0  \n            Yes → left ← right + wordLen // 移動左邊界到下一個可能起點  \n            Yes → Continue // 跳過後續判斷  \n        No → // word 在 wordsCount 中  \n            → currentCount[word] ← currentCount.get(word, 0) + 1 // 更新該字串的計數  \n            → Decision: currentCount[word] <= wordsCount[word]?  \n                Yes → formed ← formed + 1 // 允許範圍內則增加已匹配數  \n                No  → // 超過允許次數，不改變 formed  \n        → Decision: (right - left + wordLen) == totalWords * wordLen?  \n            Yes → Decision: formed == totalWords?  \n                Yes → Append left to result // 找到一個完整的拼接子字串  \n            Yes → // 總長度已達到，開始縮小窗口  \n                → leftWord ← Substring(s, left, wordLen) // 取得左邊界字串  \n                → Decision: leftWord in wordsCount?  \n                    Yes → Decision: currentCount[leftWord] <= wordsCount[leftWord]?  \n                        Yes → formed ← formed - 1 // 左邊界字串仍在允許範圍內，減少已匹配數  \n                    Yes → currentCount[leftWord] ← currentCount.get(leftWord, 0) - 1 // 更新計數  \n                Yes → left ← left + wordLen // 左邊界向右移動一個字串長度  \n            No  → // 窗口未達完整長度，繼續擴大右邊界  \n    → // offset 迴圈結束  \n\nEnd // 程式執行結束，result 為所有符合條件的起始索引",
      "generated_code": "import sys\nimport re\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def findSubstring(self, s, words):\n        \"\"\"返回所有符合條件的起始索引\"\"\"\n        if not s or not words:\n            return []\n\n        word_len = len(words[0])\n        total_words = len(words)\n        substring_len = word_len * total_words\n        if len(s) < substring_len:\n            return []\n\n        # words 中各字串的期望頻率\n        word_count = Counter(words)\n        res = []\n\n        # 依照單字長度的 offset 進行滑動窗口\n        for offset in range(word_len):\n            left = offset\n            right = offset\n            current = defaultdict(int)\n            formed = 0  # 目前已符合頻率的字串數\n\n            while right + word_len <= len(s):\n                word = s[right:right+word_len]\n                right += word_len\n\n                if word in word_count:\n                    current[word] += 1\n                    if current[word] <= word_count[word]:\n                        formed += 1\n                else:\n                    # 非有效字串，重置\n                    current.clear()\n                    formed = 0\n                    left = right\n                    continue\n\n                # 當滑動窗口長度達到所有字串總長\n                while right - left == substring_len:\n                    if formed == total_words:\n                        res.append(left)\n\n                    left_word = s[left:left+word_len]\n                    if left_word in word_count:\n                        if current[left_word] <= word_count[left_word]:\n                            formed -= 1\n                        current[left_word] -= 1\n                    left += word_len\n\n        return res\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析出 s 與 words\"\"\"\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    words_match = re.search(r'words\\s*=\\s*\\[([^\\]]*)\\]', data)\n    s = s_match.group(1) if s_match else \"\"\n    words = []\n    if words_match:\n        words_str = words_match.group(1).strip()\n        if words_str:\n            # 拆分並移除可能存在的引號、空格\n            words = [w.strip().strip('\"').strip(\"'\") for w in words_str.split(',')]\n    return s, words\n\ndef main():\n    data = sys.stdin.read().strip()\n    s, words = parse_input(data)\n    sol = Solution()\n    result = sol.findSubstring(s, words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "success": true,
          "output": "[0, 9]"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "success": true,
          "output": "[6, 9, 12]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode553.json",
    "problem_index_in_file": 0,
    "title": "Optimal Division",
    "description_snippet": "You are given an integer array nums. The adjacent integers in nums will perform the float division.\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: given an array nums, produce an expression string with parentheses that yields maximum value of successive division with left-to-right by default but parentheses can change order.\n\nWe need to output step-by-step virtual code. We need not output actual code but pseudo steps.\n\nSo we must design algorithm: The known solution: For maximizing division expression, put first number then divide by product of remaining numbers. For array of length n>=2, the optimal is: nums[0] / (nums[1] / nums[2] / ... / nums[n-1])? Wait typical result: For maximum value, we want to divide first number by the minimal possible result of remaining. Since division is decreasing function, to maximize, we want the denominator minimal. For consecutive divisions, the minimal value of a/(b/c/d/e...) etc. Actually known result: expression = nums[0] / (nums[1] / nums[2] / ... / nums[n-1])? Let's recall. For input [a,b,c,d], we want a / (b / c / d) -> a * c * d / b. This is maximum? Example [2,3,4]: a/(b/c/d)=2/(3/4)=2*4/3=8/3=2.666... but direct 2/3/4=0.1666. So that is bigger. Actually known solution: put parentheses after first number: a/(b/c/d/...), but we need to check that parentheses are minimal: for n>=3, best is a/(b/c/d/... ) where we put parentheses after first number and after b? Actually known result from Leetcode problem 1593: maximum division. The solution: if n==1 return str(nums[0]); if n==2 return f\"{nums[0]}/{nums[1]}\"; else return f\"{nums[0]}/({nums[1]}/{'/'.join(map(str, nums[2:]))})\". Equivalent: a/(b/c/d/...).\n\nHence algorithm: if len(nums)==1: expression = str(nums[0]); else if len==2: expression = f\"{nums[0]}/{nums[1]}\"; else: expression = f\"{nums[0]}/({nums[1]}/\" + \"/\".join(nums[2:]) + \")\".\n\nThus produce expression with minimal parentheses: parentheses around entire denominator part, but inside we don't need parentheses because division is left associative. Actually the denominator is b/c/d/... So we don't need parentheses inside. But we need outer parentheses.\n\nThus algorithm is simple. But still we need to produce pseudo code with steps. Should include reading array, length check, constructing string accordingly. No loops except join.\n\nAlso mention removing redundant parentheses.\n\nThus produce steps. Let's produce virtual code lines:\n\nStart\n→ Step 1: 取得 nums 陣列長度 n // 取得輸入長度\n→ Decision: n == 1? // 檢查是否只有一個數\n    Yes → Step 2: 表達式 = str(nums[0]) // 單個數直接回傳\n    No  → Decision: n == 2? // 檢查是否兩個數\n        Yes → Step 3: 表達式 = str(nums[0]) + \"/\" + str(nums[1]) // 兩個數直接相除\n        No  → Step 4: 建立 denominatorStr = str(nums[1]) + \"/\" + \"/\".join(str(x) for x in nums[2:]) // 組成 b/c/d/...\n        → Step 5: 表達式 = str(nums[0]) + \"/(\" + denominatorStr + \")\" // 加上外部括號\n→ Step 6: 回傳 表達式 // 輸出結果\nEnd\n\nNeed to use virtual code arrow: Start, End, Decision: etc. Provide comment after each line.\n\nMake sure each line has the arrow syntax: \"Start //\", \"→ Step 1: ...\" etc.\n\nMake sure we include comments after space.\n\nAlso incorporate the join step: Might need a loop to build string but we can keep simple.\n\nAlso mention that we avoid redundant parentheses: only outer parentheses for denominator when length>2.\n\nAlso we can produce explanation for each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 nums 陣列長度 n // 讀取輸入陣列並取得其長度  \n→ Decision: n == 1? // 檢查是否只有一個數字  \n    Yes → Step 2: 表達式 = str(nums[0]) // 只有一個數，直接回傳其字串表示  \n    No → Decision: n == 2? // 檢查是否只有兩個數  \n        Yes → Step 3: 表達式 = str(nums[0]) + \"/\" + str(nums[1]) // 兩個數直接相除，無需括號  \n        No → Step 4: denominatorStr = str(nums[1]) + \"/\" + \"/\".join(str(x) for x in nums[2:]) // 組成 b/c/d/...  \n        → Step 5: 表達式 = str(nums[0]) + \"/(\" + denominatorStr + \")\" // 將整個分母用一對括號包起來，避免冗餘  \n→ Step 6: 回傳 表達式 // 輸出最優化的分式字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef optimal_division(nums):\n    if len(nums) == 1:\n        return str(nums[0])\n    if len(nums) == 2:\n        return f\"{nums[0]}/{nums[1]}\"\n    return f\"{nums[0]}/(\" + \"/\".join(map(str, nums[1:])) + \")\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums = ast.literal_eval(data)\n    expr = optimal_division(nums)\n    print(f'\"{expr}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1000,100,10,2]",
          "expected_output": "\"1000/(100/10/2)\"",
          "success": true,
          "output": "\"1000/(100/10/2)\""
        },
        {
          "example_index": 1,
          "input": "[2,3,4]",
          "expected_output": "\"2/(3/4)\"",
          "success": true,
          "output": "\"2/(3/4)\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode368.json",
    "problem_index_in_file": 0,
    "title": "Largest Divisible Subset",
    "description_snippet": "Given a set of distinct positive integers nums, return the largest subset answer such that every pai...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for algorithm: Given distinct positive integers, find largest subset where every pair divisible. Classic solution: sort array, dynamic programming longest divisible subset. Approach: sort nums ascending, dp[i] longest subset ending at i, parent array. Then reconstruct.\n\nWe produce step-by-step virtual code lines with arrows.\n\nWe need use arrow \"→\" for steps, \"Decision:\" for decisions. Provide each line with comment.\n\nWe must not output actual code. Just structure.\n\nLet's craft.\n\nStart\n→ Step 1: Sort nums ascending // arrange so that potential divisors come before multiples\n→ Step 2: Initialize arrays dp and parent of size n with all 1 and -1 // each element alone forms subset size 1\n→ Step 3: For i from 0 to n-1\n    → Decision: For each j from 0 to i-1\n        → Decision: If nums[i] % nums[j] == 0 // i is multiple of j\n            Yes → Update dp[i] and parent[i] if dp[j]+1 > dp[i] // extend best subset ending at j\n        // else do nothing\n→ Step 4: Find index maxIdx where dp[maxIdx] is maximum // largest subset size\n→ Step 5: Reconstruct answer by tracing parent from maxIdx back to -1\n    → Step 5a: Initialize empty list result\n    → Step 5b: While maxIdx != -1\n        → Step 5c: Append nums[maxIdx] to result\n        → Step 5d: Set maxIdx = parent[maxIdx]\n→ Step 6: Reverse result // to maintain ascending order\n→ Step 7: Return result // largest divisible subset\nEnd\n\nNeed ensure each line has \"虛擬碼步驟\" followed by comment. Use arrow \"→\" to indent. For loops, we can represent with \"For\" and \"Decision:\".\n\nLet's produce each line separately, each line includes arrow. Might need to indent for nested loops. Use arrows accordingly.\n\nWe'll produce like:\n\nStart // ...\n→ Step 1: Sort nums ascending // ...\n→ Step 2: Initialize dp[0..n-1] = 1, parent[0..n-1] = -1 // ...\n\nFor loops: We'll use arrow for loop line, then indent inside.\n\nLet's write:\n\n→ For i = 0 to n-1\n    → For j = 0 to i-1\n        → Decision: nums[i] % nums[j] == 0\n            Yes → If dp[j]+1 > dp[i] then dp[i] = dp[j]+1, parent[i] = j\n\nBut we need \"Yes →\" arrow for true branch.\n\nAlso need to include \"Decision:\" lines for loops? Use \"For\" not \"Decision\". For loops are not decisions. So just \"For\".\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先將數字升冪排序，方便後續找可整除的關係\n→ Step 2: Initialize dp[0..n-1] = 1, parent[0..n-1] = -1 // 每個數字自身為長度 1 的子集，parent 用於回溯\n→ For i = 0 to n-1\n    → For j = 0 to i-1\n        → Decision: nums[i] % nums[j] == 0 // 檢查 i 是否為 j 的倍數\n            Yes → Decision: dp[j] + 1 > dp[i] // 若使用 j 可以得到更長子集\n                Yes → Step: dp[i] = dp[j] + 1, parent[i] = j // 更新 dp 與 parent\n→ Step 3: Find maxIdx where dp[maxIdx] is maximum // 獲取子集長度最大的結點\n→ Step 4: Reconstruct answer by backtracking parent from maxIdx\n    → Step 4a: Initialize empty list result\n    → While maxIdx != -1\n        → Step 4b: Append nums[maxIdx] to result // 將當前元素加入結果\n        → Step 4c: Set maxIdx = parent[maxIdx] // 移動到上一個節點\n→ Step 5: Reverse result // 由遞增順序回到升序輸出\n→ Step 6: Return result // 輸出最大的可整除子集\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def largestDivisibleSubset(self, nums):\n        if not nums:\n            return []\n        nums.sort()\n        n = len(nums)\n        dp = [1] * n\n        prev = [-1] * n\n        max_index = 0\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n            if dp[i] > dp[max_index]:\n                max_index = i\n\n        res = []\n        while max_index >= 0:\n            res.append(nums[max_index])\n            max_index = prev[max_index]\n\n        return res[::-1]\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n    else:\n        # Extract the list part from input like \"nums = [1,2,3]\"\n        start = data.find('[')\n        end = data.rfind(']')\n        if start != -1 and end != -1:\n            list_str = data[start:end+1]\n            nums = ast.literal_eval(list_str)\n            solution = Solution()\n            result = solution.largestDivisibleSubset(nums)\n            print(result)\n        else:\n            print([])",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,4,8]",
          "expected_output": "[1,2,4,8]",
          "success": true,
          "output": "[1, 2, 4, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode705.json",
    "problem_index_in_file": 0,
    "title": "Design HashSet",
    "description_snippet": "Design a HashSet without using any built-in hash table libraries.\n\nImplement MyHashSet class:\n\nvoid ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo code line by line, with comments. No actual code. Use Start, End, Decision. Implementation: Use array of buckets. Use linked list or array inside bucket. Use a fixed size like 769 or 1000. Provide add, contains, remove. Should include functions. Use a class. Provide steps inside each method.\n\nSo output:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyHashSet 類別 // 定義類別\n→ Step 2: 內部使用 buckets = Array of size 769, each element = 空陣列 // 初始化桶\n→ Step 3: 定義 hash(key) = key % 769 // 哈希函式\n\nThen methods:\n\n→ Step 4: 方法 add(key): // 插入\n    → Step 4.1: idx = hash(key)\n    → Step 4.2: bucket = buckets[idx]\n    → Step 4.3: Decision: 如果 key 已在 bucket? // 檢查是否存在\n        Yes → Step 4.3a: Return // 已存在，結束\n        No → Step 4.3b: Append key to bucket // 新增\n\nSimilar for contains, remove.\n\nAdd explanation after each line.\n\nBe careful to keep arrow notation.\n\nWe'll produce each step line by line, with // comments in Chinese.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyHashSet 類別 // 建立 HashSet 的封裝類別  \n→ Step 2: 內部使用 buckets = Array(769) // 初始化 769 個桶（因為 769 為質數，分佈較均勻）  \n→ Step 3: 每個 bucket 以動態陣列 (list) 或鏈結串列儲存對應鍵值 // 每個桶存放碰撞的鍵  \n→ Step 4: 定義 hash(key) = key % 769 // 計算鍵的哈希值並映射至桶索引  \n\n→ Step 5: 方法 add(key) // 插入鍵  \n    → Step 5.1: idx = hash(key) // 取得鍵的桶索引  \n    → Step 5.2: bucket = buckets[idx] // 取得對應桶  \n    → Step 5.3: Decision: 如果 key 已在 bucket? // 檢查鍵是否已存在  \n        Yes → Step 5.3a: Return // 已存在，無需重複插入  \n        No  → Step 5.3b: Append key to bucket // 將鍵加入桶中  \n\n→ Step 6: 方法 contains(key) // 判斷鍵是否存在  \n    → Step 6.1: idx = hash(key) // 取得桶索引  \n    → Step 6.2: bucket = buckets[idx] // 取得桶  \n    → Step 6.3: Decision: 如果 key 在 bucket? // 搜尋桶中是否有鍵  \n        Yes → Step 6.3a: Return true // 找到，回傳真  \n        No  → Step 6.3b: Return false // 未找到，回傳假  \n\n→ Step 7: 方法 remove(key) // 刪除鍵  \n    → Step 7.1: idx = hash(key) // 取得桶索引  \n    → Step 7.2: bucket = buckets[idx] // 取得桶  \n    → Step 7.3: Decision: 如果 key 在 bucket? // 判斷是否存在  \n        Yes → Step 7.3a: Remove key from bucket // 從桶中刪除鍵  \n        No  → Step 7.3b: Return // 不存在，直接結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyHashSet:\n    def __init__(self):\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key):\n        return key % self.size\n\n    def add(self, key):\n        h = self._hash(key)\n        if key not in self.buckets[h]:\n            self.buckets[h].append(key)\n\n    def remove(self, key):\n        h = self._hash(key)\n        if key in self.buckets[h]:\n            self.buckets[h].remove(key)\n\n    def contains(self, key):\n        h = self._hash(key)\n        return key in self.buckets[h]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit()\n    commands = ast.literal_eval(data[0])\n    arguments = ast.literal_eval(data[1])\n\n    result = []\n    obj = None\n    for i, cmd in enumerate(commands):\n        if cmd == \"MyHashSet\":\n            obj = MyHashSet()\n            result.append(None)\n        elif cmd == \"add\":\n            obj.add(arguments[i][0])\n            result.append(None)\n        elif cmd == \"remove\":\n            obj.remove(arguments[i][0])\n            result.append(None)\n        elif cmd == \"contains\":\n            res = obj.contains(arguments[i][0])\n            result.append(res)\n\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]",
          "expected_output": "[null, null, null, true, false, null, true, null, false]",
          "success": true,
          "output": "[null, null, null, true, false, null, true, null, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode645.json",
    "problem_index_in_file": 0,
    "title": "Set Mismatch",
    "description_snippet": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step for algorithm to find duplicate and missing number in array containing 1..n with one duplicate. Classic approach: compute sum and sum of squares, or use frequency map, or use XOR.\n\nWe'll produce a virtual code with steps, decisions. Use Start, End. Provide each line: Virtual code step, then // explanation. Ensure no actual code, just structure. We'll produce algorithm:\n\n- Start\n- Initialize n = length of nums\n- Initialize duplicate = 0, missing = 0\n- Compute sum of nums and sum of expected (1..n)\n- Compute squareSum of nums and expected\n- Compute diff = expectedSum - actualSum  (missing - duplicate)\n- Compute sqDiff = expectedSqSum - actualSqSum  (missing^2 - duplicate^2)\n- Since missing^2 - duplicate^2 = (missing - duplicate)(missing + duplicate) => sqDiff / diff = missing + duplicate\n- Solve for missing and duplicate: sum = missing + duplicate, diff = missing - duplicate\n- duplicate = (sum - diff)/2\n- missing = duplicate + diff\n- Return [duplicate, missing]\n- End\n\nWe should show decisions? Not many. Might have decision if diff==0? but not necessary.\n\nWe'll produce each line with arrow. Use virtual arrows: \"→\" preceding steps. For decisions: maybe use Decision to check if diff==0? Not needed.\n\nWe produce lines:\n\nStart\n→ Step 1: Let n = length(nums) // 取得陣列長度\n→ Step 2: Set duplicate = 0, missing = 0 // 初始化結果變數\n→ Step 3: Compute expectedSum = n*(n+1)/2 // 1 到 n 的總和\n→ Step 4: Compute actualSum = sum of elements in nums // 目前陣列的總和\n→ Step 5: Compute expectedSqSum = n*(n+1)*(2n+1)/6 // 1 到 n 的平方和\n→ Step 6: Compute actualSqSum = sum of squares of elements in nums // 陣列中各數平方和\n→ Step 7: diff = expectedSum - actualSum // missing - duplicate\n→ Step 8: sqDiff = expectedSqSum - actualSqSum // missing^2 - duplicate^2\n→ Step 9: sum = sqDiff / diff // missing + duplicate\n→ Step 10: duplicate = (sum - diff) / 2 // 計算重複數\n→ Step 11: missing = duplicate + diff // 計算缺失數\n→ Step 12: Return [duplicate, missing] // 結果輸出\nEnd\n\nNeed to include arrows for each step. Use arrow \"→\" before each step. For the decisions? Not needed.\n\nAlso we might use \"Decision:\" for if diff==0, but that shouldn't happen. But we can include safety.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = length(nums) // 取得陣列長度，代表原本 1~n 的範圍  \n→ Step 2: Set duplicate = 0, missing = 0 // 初始化結果變數  \n→ Step 3: Compute expectedSum = n*(n+1)/2 // 計算 1 到 n 的理論總和  \n→ Step 4: Compute actualSum = sum of elements in nums // 取得目前陣列的總和  \n→ Step 5: Compute expectedSqSum = n*(n+1)*(2n+1)/6 // 計算 1 到 n 的平方和  \n→ Step 6: Compute actualSqSum = sum of squares of elements in nums // 取得陣列中各數平方和  \n→ Step 7: diff = expectedSum - actualSum // diff = missing - duplicate  \n→ Step 8: sqDiff = expectedSqSum - actualSqSum // sqDiff = missing² - duplicate²  \n→ Step 9: sum = sqDiff / diff // sum = missing + duplicate（利用 (a²-b²)/(a-b)=a+b）  \n→ Step 10: duplicate = (sum - diff) / 2 // 由 sum 与 diff 求得 duplicate  \n→ Step 11: missing = duplicate + diff // 再由 duplicate 与 diff 求得 missing  \n→ Step 12: Return [duplicate, missing] // 將重複數與缺失數回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findErrorNums(self, nums):\n        n = len(nums)\n        num_set = set(nums)\n        duplicate = sum(nums) - sum(num_set)\n        missing = n * (n + 1) // 2 - sum(num_set)\n        return [duplicate, missing]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list part from the input\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n    # Safely evaluate the list\n    nums = eval(list_part, {\"__builtins__\": None}, {})\n    result = Solution().findErrorNums(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,4]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode458.json",
    "problem_index_in_file": 0,
    "title": "Poor Pigs",
    "description_snippet": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out wh...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for solving the problem: given buckets, minutesToDie, minutesToTest, find minimum pigs needed. Classic problem: number of tests rounds = floor(minutesToTest / minutesToDie). Let rounds = t. Each pig can encode base (rounds+1) states (since pig can die in one of rounds or survive). So number of distinct outcomes = (rounds+1)^p. Need >= buckets. Solve for p minimal integer. So steps: compute rounds, then compute minimal p such that (rounds+1)^p >= buckets. Return p.\n\nWe need to output pseudocode line by line with explanations. Use Start, End, Decision. So produce lines like:\n\nStart\n→ Step 1: compute rounds = floor(minutesToTest / minutesToDie)\n→ Decision: If buckets <= 1? etc.\n\nBut we should produce straightforward algorithm. Steps:\n\n1. Calculate rounds.\n2. If buckets <=1: return 0 (no pigs needed)\n3. Initialize pigs = 0\n4. While (rounds+1)^pigs < buckets: pigs++\n5. Return pigs.\n\nWe can also show calculation of exponent. Use loop or log. But easier: loop.\n\nWe need to produce pseudo-code lines. Use arrows, decisions. Provide brief explanations. Each line should include virtual code then comment. We'll follow format. Let's craft lines.\n\nWe'll use `→` for step indentation.\n\nWe'll include decisions for loops and conditions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: rounds ← floor(minutesToTest / minutesToDie) // 先算可進行的測試輪數  \n→ Decision: 如果 buckets ≤ 1? // 若只有一個或沒有桶，無需使用豬  \n  Yes → Step 2: Return 0 // 直接回傳0，無豬足夠辨識  \n  No → Step 3: p ← 0 // 初始化所需豬的數量為0  \n→ Decision: 當 (rounds + 1)^p < buckets? // 檢查目前可辨識的桶數是否足夠  \n  Yes → Step 4: p ← p + 1 // 若不足，增加一隻豬  \n  No  → Step 5: Return p // 若已足夠，回傳所需的最少豬數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef solve(buckets, minutesToDie, minutesToTest):\n    \"\"\"\n    計算在給定時間內最少需要多少隻豬才能確定哪一桶是毒桶。\n    \"\"\"\n    # 每個豬可以在 (rounds + 1) 種狀態下回報結果：\n    #  - 在某一次測試後死亡（共 rounds 次）\n    #  - 仍然存活（最後一次測試後仍存活）\n    rounds = minutesToTest // minutesToDie\n    states = rounds + 1\n\n    pigs = 0\n    # 只要 (states ** pigs) 小於桶的總數，就繼續增加豬的數量\n    while states ** pigs < buckets:\n        pigs += 1\n    return pigs\n\ndef main():\n    # 從標準輸入讀取所有文字，找出所有整數\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) < 3:\n        return  # 輸入不完整，直接結束\n    buckets, minutesToDie, minutesToTest = numbers[0], numbers[1], numbers[2]\n    result = solve(buckets, minutesToDie, minutesToTest)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 15",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 30",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode49.json",
    "problem_index_in_file": 0,
    "title": "Group Anagrams",
    "description_snippet": "Given an array of strings strs, group the anagrams together. You can return the answer in any order....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for grouping anagrams. We output each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, Decision etc. Let's design algorithm: Use hash map keyed by sorted string. Steps: Start. Step: initialize map. Step: iterate array. For each string, sort characters to key. If key not in map, create list. Append string to list. After loop, output values list. End.\n\nWe need to use arrow formatting: \"→\" and decisions. For map key existence we might use Decision: if key exists? Yes→ append else→ create new list. Let's produce step lines.\n\nMake sure each line contains virtual code + space + // explanation.\n\nLet's produce: \nStart // 程式開始執行\n→ Step 1: 初始化哈希表 groups // 用來存放以字母排序後的字串為鍵的列表\n→ Step 2: 遍歷輸入陣列 strs // 逐個處理每個字串\n    → Step 2.1: 取得字串 s\n    → Step 2.2: 將 s 的字元排序得到 key // 排序後的字串作為鍵\n    → Decision: key 是否已在 groups?\n        Yes → Step 2.3: groups[key].append(s) // 已有鍵，將 s 加入對應列表\n        No  → Step 2.4: groups[key] = [s] // 未有鍵，創建新列表並加入 s\n→ Step 3: 將 groups 的所有值收集為列表 result // 得到分組後的結果\n→ Step 4: 回傳 result // 結束並輸出\nEnd // 程式執行結束\n\nBut we need arrow \"→\" before each step. For decision branches we need Yes →, No → lines.\n\nLet's format each line precisely. Use consistent indent.\n\nAlso each line must have \"虛擬碼步驟\" then space then comment.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化哈希表 groups // 用來存放以字母排序後的字串為鍵的列表\n→ Step 2: 遍歷輸入陣列 strs // 逐個處理每個字串\n    → Step 2.1: 取得字串 s // 取當前字串\n    → Step 2.2: 將 s 的字元排序得到 key // 排序後的字串作為鍵\n    → Decision: key 是否已在 groups?\n        Yes → Step 2.3: groups[key].append(s) // 已有鍵，將 s 加入對應列表\n        No  → Step 2.4: groups[key] = [s] // 未有鍵，創建新列表並加入 s\n→ Step 3: 將 groups 的所有值收集為列表 result // 得到分組後的結果\n→ Step 4: 回傳 result // 結束並輸出\nEnd // 程式執行結束\n\nBut we need each line separated by newline, no extra spaces? Should be fine.\n\nMake sure each line has \"虛擬碼步驟\" then space. For decision line \"Decision:\" we need to keep same format. Use \"Decision:\" exactly. The arrow lines with Yes/No use \"Yes →\" \"No →\". We need to include space after arrow? The format example: \"Yes → Step 2: 輸出 '正數'\" They had \"Yes → Step 2: 輸出 '正數'\". So \"Yes → Step 2: ...\" Good.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化哈希表 groups // 用來存放以字母排序後的字串為鍵的列表  \n→ Step 2: 遍歷輸入陣列 strs // 逐個處理每個字串  \n → Step 2.1: 取得字串 s // 取當前字串  \n → Step 2.2: 將 s 的字元排序得到 key // 排序後的字串作為鍵  \n → Decision: key 是否已在 groups? // 檢查鍵是否存在  \n  Yes → Step 2.3: groups[key].append(s) // 已有鍵，將 s 加入對應列表  \n  No  → Step 2.4: groups[key] = [s] // 未有鍵，創建新列表並加入 s  \n→ Step 3: 將 groups 的所有值收集為列表 result // 得到分組後的結果  \n→ Step 4: 回傳 result // 結束並輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        from collections import defaultdict\n\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = ''.join(sorted(s))          # 把字串排序後做為鍵\n            anagrams[key].append(s)           # 把原字串加入對應的分組\n\n        return list(anagrams.values())\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中取得字串列表\n    try:\n        # 找到 '=' 之後的部分並評估成 Python 資料型別\n        idx = data.find('=')\n        list_str = data[idx + 1:].strip() if idx != -1 else data\n        strs = ast.literal_eval(list_str)\n    except Exception:\n        strs = []\n\n    result = Solution().groupAnagrams(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
          "success": true,
          "output": "[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]"
        },
        {
          "example_index": 1,
          "input": "strs = [\"\"]",
          "expected_output": "[[\"\"]]",
          "success": true,
          "output": "[['']]"
        },
        {
          "example_index": 2,
          "input": "strs = [\"a\"]",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode546.json",
    "problem_index_in_file": 0,
    "title": "Remove Boxes",
    "description_snippet": "You are given several boxes with different colors represented by different positive numbers.\n\nYou ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for maximum points by removing boxes. This is known as Leetcode 546 Remove Boxes. We must give pseudo-code with decision structure. Not actual code, but algorithm steps. Use dynamic programming with memoization. Provide line-by-line pseudo-code with explanation.\n\nWe need to produce steps: Start, maybe define function solve(boxes) etc. Steps for recursion, memoization key: (l,r,k). Steps: if l>r return 0. Count same colored boxes at right, etc. Provide recursion and decision. Provide base. End. Also steps for main. Let's produce.\n\nWe must output in specified format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow. We'll use Start, End, Decision:.\n\nLet's produce lines:\n\nStart\n→ Step 1: 讀取輸入盒子陣列 // 取得盒子顏色序列\n→ Step 2: 呼叫 Solve(0, n-1, 0) // 開始遞迴計算最大分數\n→ Step 3: 輸出回傳值 // 顯示最高分數\nEnd\n\nBut we need recursion details:\n\nDefine function Solve(l, r, k):\n- if l>r return 0\n- While r>l and boxes[r]==boxes[r-1], increment k, r-- // merge same color at right end\n- Base: result = Solve(l, r-1, 0) + (k+1)^2\n- For i from l to r-1:\n    if boxes[i]==boxes[r]:\n        temp = Solve(l, i, k+1) + Solve(i+1, r-1, 0)\n        result = max(result, temp)\n- memo[l][r][k] = result\n- return result\n\nWe need to represent memoization. Use key (l,r,k). Steps:\n\n→ Decision: if l > r? // Check base case\n    Yes → Step 4: Return 0 // No boxes left\n    No → continue\n\n→ Step 5: While r > l and boxes[r] == boxes[r-1] // merge same color at end\n→ Step 6: Increment k, r--\n\n→ Step 7: result ← Solve(l, r-1, 0) + (k+1)^2 // remove rightmost group\n\n→ Step 8: For i from l to r-1\n→ Step 9: Decision: boxes[i] == boxes[r]?\n    Yes → Step 10: temp ← Solve(l, i, k+1) + Solve(i+1, r-1, 0)\n    → Step 11: result ← max(result, temp)\n    No → continue\n\n→ Step 12: memo[l][r][k] ← result\n→ Step 13: Return result\n\nAlso need to check if already computed:\n\n→ Step 14: Decision: memo[l][r][k] exists?\n    Yes → Step 15: Return memo[l][r][k]\n    No → continue\n\nAlso need to declare memo structure.\n\nWe should produce pseudo-code line by line. Let's compile final answer.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取盒子顏色序列 boxes // 取得輸入的盒子顏色\n→ Step 2: n ← length(boxes) // 盒子總數\n→ Step 3: 初始化三維緩存 memo // 用於記錄已計算的子問題結果\n→ Step 4: result ← Solve(0, n-1, 0) // 從整個序列開始遞迴計算最大分數\n→ Step 5: 輸出 result // 顯示最高分數\nEnd // 程式執行結束\n\n// ----------------  Solve 函式 ----------------\n→ Function Solve(l, r, k) // 計算從 l 到 r 的最大分數，k 為右側已合併的同色盒子數\n    → Decision: l > r? // 檢查是否已無盒子\n        Yes → Return 0 // 無盒子時分數為 0\n        No  → Continue\n    → Decision: memo[l][r][k] 已存在?\n        Yes → Return memo[l][r][k] // 若已計算直接回傳\n        No  → Continue\n    → Step 6: while r > l and boxes[r] == boxes[r-1] // 合併右端相同顏色盒子\n        → Step 7: r ← r - 1\n        → Step 8: k ← k + 1\n    → Step 9: result ← Solve(l, r-1, 0) + (k+1)^2 // 先移除右端的同色盒子\n    → Step 10: for i from l to r-1 // 嘗試將盒子 i 與右端同色盒子合併\n        → Decision: boxes[i] == boxes[r]?\n            Yes →\n                → Step 11: temp ← Solve(l, i, k+1) + Solve(i+1, r-1, 0) // 合併後再遞迴\n                → Step 12: result ← max(result, temp) // 取最大分數\n            No → Continue\n    → Step 13: memo[l][r][k] ← result // 記錄結果\n    → Step 14: Return result // 回傳此子問題的最大分數\n```",
      "generated_code": "import sys\nimport ast\nimport sys\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得盒子列表，支援 \"boxes = [1,2,3]\" 或 \"[1,2,3]\" 的輸入格式\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data\n    try:\n        boxes = ast.literal_eval(list_str)\n    except Exception:\n        # 如果輸入不是合法的 Python 表達式，直接回傳\n        print(\"0\")\n        return\n\n    sys.setrecursionlimit(10000)\n    n = len(boxes)\n    memo = {}\n\n    def dp(l: int, r: int, k: int) -> int:\n        if l > r:\n            return 0\n        key = (l, r, k)\n        if key in memo:\n            return memo[key]\n\n        # 合併右端相同顏色的盒子\n        while r > l and boxes[r] == boxes[r - 1]:\n            r -= 1\n            k += 1\n\n        # 直接移除右端的同色盒子\n        res = dp(l, r - 1, 0) + (k + 1) ** 2\n\n        # 嘗試把左側相同顏色的盒子合併到右端\n        for i in range(l, r):\n            if boxes[i] == boxes[r]:\n                temp = dp(l, i, k + 1) + dp(i + 1, r - 1, 0)\n                if temp > res:\n                    res = temp\n\n        memo[key] = res\n        return res\n\n    result = dp(0, n - 1, 0)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "boxes = [1,3,2,2,2,3,4,3,1]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        },
        {
          "example_index": 1,
          "input": "boxes = [1,1,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "boxes = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode488.json",
    "problem_index_in_file": 0,
    "title": "Zuma Game",
    "description_snippet": "You are playing a variation of the game Zuma. \nIn this variation of Zuma, there is a single row of c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps. This is a problem akin to Zuma Game from Leetcode 488. We need to provide algorithm steps: DFS/backtracking with pruning, or BFS. Since we need virtual code step-by-step. Provide generic algorithm. Steps: define function minInsertToClear(board, hand). Use recursion with memoization. Steps: convert hand counts. Use helper dfs(board, hand_counts). If board empty return 0. If no balls left return INF. For each position between characters, find segment of same color. If needed insert to reach 3. Compute insertion count. Update board by removing. Recursively compute. Use pruning: if hand count insufficient. Use memo key board+hand_counts. Return min. If INF return -1.\n\nWe need to output virtual code lines with explanations.\n\nWe need to output each step line, maybe with indentations. Provide pseudo-code with \"Start\", \"End\" etc. Use arrow \"→\" etc. So produce something like:\n\nStart // main entry\n→ Step 1: function minInsertToClear(board, hand) // compute answer\n...\n\nBetter to structure: Start -> Step 1: Preprocess hand to counts. -> Step 2: call dfs. -> etc.\n\nBut we need to use decision structures. Provide DFS function with memoization.\n\nWe'll output lines accordingly.\n\nOk let's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n\n→ Step 1: 將手中的球轉成顏色計數表 handCount // 方便快速查詢可用球數\n    // 例如 hand = \"WRR\" → handCount = {W:1, R:2}\n\n→ Step 2: 呼叫 DFS(board, handCount) → minInsert // 取得最少插入數\n    // DFS 會回傳最小插入步驟，若無法完成則回傳 INF\n\n→ Decision: 若 minInsert == INF? // 無法清空\n    Yes → Step 3: 回傳 -1 // 失敗\n    No  → Step 4: 回傳 minInsert // 成功\n\nEnd // 程式執行結束\n\n\n// ---------------------------------------------------------------------------\n// DFS 函式 (回溯 + 記憶化)\n// ---------------------------------------------------------------------------\n\n→ Function DFS(board, handCount) // 回傳最小插入步驟或 INF\n    // 若棋盤已清空，無需再插球\n    → Decision: 若 board 為空? \n        Yes → Return 0 // 已成功清空\n        No  → 接續\n    \n    // 用字串+手中球計數作為 memo key\n    → Let key = board + \"|\" + handCountString(handCount) // 產生唯一鍵\n\n    → Decision: 若 key 在 memo? \n        Yes → Return memo[key] // 直接回傳已計算結果\n        No  → 進行計算\n\n    → Let result = INF // 初始化為無法完成的高值\n\n    // 逐個位置嘗試插入\n    → For i from 0 to board.length\n        // 在 board[i-1] 與 board[i] 之間插入\n        // 若 i==0 或 i==board.length 時為兩端\n        → Let leftColor = (i==0)? '' : board[i-1]\n        → Let rightColor = (i==board.length)? '' : board[i]\n        → Let insertColor = (leftColor==rightColor)? leftColor : '' // 只考慮同色插入可產生連續\n\n        → Decision: 若 insertColor 為空? \n            Yes → Continue // 這個位置不可能產生三連\n            No  → \n\n        // 計算在此位置連續的同色區段長度\n        → Let l = i-1, r = i\n        → While l>=0 and board[l]==insertColor: l--\n        → While r<board.length and board[r]==insertColor: r++\n        → Let sameLen = r-l-1 // 連續區段長度\n\n        // 需要插入的球數量\n        → Let need = 3 - sameLen\n        → Decision: 若 handCount[insertColor] < need? \n            Yes → Continue // 球不夠，不能插\n            No  → \n\n        // 更新手中球計數\n        → handCount[insertColor] -= need\n\n        // 將該位置的連續區段從棋盤移除，產生新的棋盤\n        → Let newBoard = board[0:l+1] + board[r:] // 刪除 [l+1, r-1] 區段\n        // 之後可能還會有多連續消除，使用 collapse 函式處理\n        → Let collapsedBoard = collapse(newBoard) // 連續消除直到無效\n\n        // 重新遞迴計算剩餘插入數\n        → Let sub = DFS(collapsedBoard, handCount)\n\n        → Decision: 若 sub != INF? \n            Yes → result = min(result, need + sub) // 取最小\n            No  → // 無解，忽略\n\n        // 回復手中球計數 (backtrack)\n        → handCount[insertColor] += need\n\n    // 記憶化結果\n    → memo[key] = result\n\n    → Return result\nEnd\n\n\n// ---------------------------------------------------------------------------\n// collapse 函式 (連續消除)\n// ---------------------------------------------------------------------------\n\n→ Function collapse(board) // 只處理連續消除，非回溯\n    → Let changed = true\n    → While changed\n        → Set changed = false\n        → Let i = 0\n        → While i < board.length\n            → Let j = i+1\n            → While j<board.length and board[j]==board[i]: j++\n            → Let len = j-i\n            → Decision: 若 len >= 3? \n                Yes → board = board[0:i] + board[j:] // 刪除連續區段\n                      → changed = true\n                      → Break // 重新從頭掃描\n                No  → i = j // 移動到下一個區段\n    → Return board\nEnd\n\n\n// ---------------------------------------------------------------------------\n// 工具函式 handCountString\n// ---------------------------------------------------------------------------\n\n→ Function handCountString(handCount)\n    → Let parts = []\n    → For each color in ['R','Y','B','G','W']\n        → parts.append(color + handCount[color])\n    → Return join(parts, ',') // 如 \"R2,Y1,B0,G0,W0\"\nEnd\n```\n這段虛擬碼完整描述了使用 DFS + 記憶化、回溯以及連續消除的核心流程，並以逐行解釋說明每個步驟的目的。",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nINF = 10 ** 9\nCOLORS = ['R', 'Y', 'B', 'G', 'W']\n\n\ndef collapse(s: str) -> str:\n    \"\"\"連續消除長度≥3的相同顏色球，直到無法再消除.\"\"\"\n    while True:\n        changed = False\n        i = 0\n        n = len(s)\n        while i < n:\n            j = i + 1\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:\n                s = s[:i] + s[j:]\n                changed = True\n                break\n            i = j\n        if not changed:\n            break\n    return s\n\n\nclass Solution:\n    def __init__(self):\n        self.memo = {}\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        hand_count = tuple(Counter(hand)[c] for c in COLORS)\n\n        def dfs(b: str, counts: tuple) -> int:\n            if not b:\n                return 0\n            key = (b, counts)\n            if key in self.memo:\n                return self.memo[key]\n\n            ans = INF\n            n = len(b)\n            for i in range(n + 1):\n                for idx, color in enumerate(COLORS):\n                    if counts[idx] == 0:\n                        continue\n\n                    # Find same color segment around position i\n                    l = i - 1\n                    while l >= 0 and b[l] == color:\n                        l -= 1\n                    r = i\n                    while r < n and b[r] == color:\n                        r += 1\n                    same_len = r - l - 1\n                    need = 3 - same_len\n                    if need <= 0 or counts[idx] < need:\n                        continue\n\n                    # Insert needed balls and collapse\n                    new_b = b[:i] + color * need + b[i:]\n                    collapsed = collapse(new_b)\n\n                    new_counts = list(counts)\n                    new_counts[idx] -= need\n                    sub = dfs(collapsed, tuple(new_counts))\n                    if sub != INF:\n                        ans = min(ans, need + sub)\n\n            self.memo[key] = ans\n            return ans\n\n        res = dfs(board, hand_count)\n        return -1 if res == INF else res\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Try to extract quoted strings first\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        board, hand = parts[0], parts[1]\n    else:\n        # Fallback: split by whitespace or newlines\n        tokens = data.replace(',', ' ').split()\n        if len(tokens) >= 2:\n            board, hand = tokens[0], tokens[1]\n        else:\n            board = tokens[0]\n            hand = ''\n    solution = Solution()\n    result = solution.findMinStep(board, hand)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode564.json",
    "problem_index_in_file": 0,
    "title": "Find the Closest Palindrome",
    "description_snippet": "Given a string n representing an integer, return the closest integer (not including itself), which i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation after each. Must not produce actual code. Use arrow, Decision, etc. Steps: parse string to int, generate palindrome candidates by adjusting digits, compute difference, track min diff, tie rule pick smaller. Also need to handle cases: single-digit? 0? but general approach.\n\nWe need to provide virtual steps: Start, input n string, convert to int. Generate list of candidates: \n- Palindrome of same length: mirror first half to second.\n- Lower palindrome: decrement middle then mirror.\n- Higher palindrome: increment middle then mirror.\n- Also consider 10^len-1 +1 and 10^(len-1)-1? Actually typical solution: candidates: \n    - Mirror: s[0:mid] + reverse(s[0:mid]) (depending odd/even)\n    - Next higher palindrome: increment middle and propagate carry, mirror.\n    - Next lower palindrome: decrement middle, propagate borrow, mirror.\n    - Edge candidates: 10^len+1 (like 100...001) and 10^len-1 (like 99...99). But easier: for len L, create 10^L+1: '1' + '0'*(L-1) + '1'; and 10^L-1: '9'* (L-1).\nWe then compute differences to original integer excluding itself. Select min diff, tie choose smaller palindrome.\n\nAlso consider original integer itself should not be considered.\n\nWe need to produce virtual steps for these.\n\nThus produce steps:\n\nStart\n→ Input string n\n→ Convert n to integer target\n→ Determine length L\n→ Generate mirror candidate M by mirroring\n→ Generate lower candidate Lc by decrement middle with borrow and mirror\n→ Generate higher candidate Hc by increment middle with carry and mirror\n→ Generate edge lower: 10^(L-1)-1\n→ Generate edge higher: 10^L+1\n→ Create list candidates = [M,Lc,Hc,edge lower,edge higher]\n→ Filter out candidate equal to target\n→ Initialize bestDiff = Infinity, bestCandidate = null\n→ For each cand in candidates:\n    → Compute diff = abs(cand - target)\n    → Decision: If diff < bestDiff? -> update\n        Yes → set bestDiff=diff, bestCandidate=cand\n        No  → Decision: If diff == bestDiff? -> tie\n            Yes → Decision: If cand < bestCandidate? -> update\n                Yes → set bestCandidate=cand\n                No → no change\n            No → no change\n→ End // return bestCandidate\n\nNeed to also note that for generating mirror, we might need helper functions. Use substeps maybe.\n\nBut we must output line by line virtual code. We can include substeps. Use arrows for decisions.\n\nLet's craft.\n\nMake sure to keep each line in one step. Use arrows as described.\n\nWe also need to note steps like \"Calculate prefix and suffix\". Provide explanation.\n\nWe'll produce about 20-25 lines.\n\nLet's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 n // 從使用者取得表示整數的字串  \n→ Step 2: 將字串 n 轉成整數 target // 方便後續數值比較  \n→ Step 3: 計算字串長度 L = n.length // 需要知道位數以生成不同長度的候選  \n→ Step 4: 產生鏡像候選 M：將前半段（含中間位）反向接到後半段 // 最直接的回文  \n→ Step 5: 產生較小候選 Lc：將中間位數減 1（並處理借位），再鏡像反向接回後半段 // 比原字串小的回文  \n→ Step 6: 產生較大候選 Hc：將中間位數加 1（並處理進位），再鏡像反向接回後半段 // 比原字串大的回文  \n→ Step 7: 產生邊界較小候選 EdgeLow = 10^(L-1) - 1 // 如 99…9，長度 L-1  \n→ Step 8: 產生邊界較大候選 EdgeHigh = 10^L + 1 // 如 100…001，長度 L+1  \n→ Step 9: 建立候選清單 Candidates = [M, Lc, Hc, EdgeLow, EdgeHigh]  \n→ Step 10: 從 Candidates 中移除等於 target 的項目 // 不能回傳自己  \n→ Step 11: 初始化 bestDiff = ∞，bestCandidate = null // 用來追蹤最小距離  \n→ Step 12: 遍歷每個 cand 於 Candidates  \n    → Step 12.1: 計算 diff = |cand - target| // 兩數之絕對差  \n    → Decision: diff < bestDiff? // 是否比目前最佳距離還小  \n        Yes → Step 12.2: bestDiff = diff；bestCandidate = cand // 更新最佳答案  \n        No → Decision: diff == bestDiff? // 是否距離相同（Tie）  \n            Yes → Decision: cand < bestCandidate? // 選擇較小的回文  \n                Yes → Step 12.3: bestCandidate = cand // 更新為較小的候選  \n                No  → // 保留目前較小的候選，無需變動  \n            No  → // 距離更大，忽略此候選  \n→ End // 程式執行結束，bestCandidate 為最接近的非自身回文整數",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        length = len(n)\n        num = int(n)\n        candidates = set()\n\n        # Edge candidates: 10^length + 1 (e.g., 100...001) and 10^(length-1) - 1 (e.g., 99...99)\n        candidates.add(str(10 ** length + 1))\n        candidates.add(str(10 ** (length - 1) - 1))\n\n        # Prefix of the original number (first half + middle if odd)\n        prefix = int(n[:(length + 1) // 2])\n        for i in (-1, 0, 1):\n            new_prefix = str(prefix + i)\n            if length % 2 == 0:\n                palin = new_prefix + new_prefix[::-1]\n            else:\n                palin = new_prefix + new_prefix[:-1][::-1]\n            candidates.add(palin)\n\n        # Exclude the original number itself\n        candidates.discard(n)\n\n        # Find the best candidate\n        best = None\n        for cand in candidates:\n            diff = abs(int(cand) - num)\n            if best is None:\n                best = cand\n            else:\n                best_diff = abs(int(best) - num)\n                if diff < best_diff or (diff == best_diff and int(cand) < int(best)):\n                    best = cand\n\n        return best\n\ndef main():\n    # Read all input and extract the numeric part\n    raw_input = sys.stdin.read()\n    digits = re.findall(r'\\d+', raw_input)\n    if not digits:\n        return\n    n = digits[0]\n\n    solution = Solution()\n    result = solution.nearestPalindromic(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"123\"",
          "expected_output": "\"121\"",
          "success": true,
          "output": "121"
        },
        {
          "example_index": 1,
          "input": "n = \"1\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode442.json",
    "problem_index_in_file": 0,
    "title": "Find All Duplicates in an Array",
    "description_snippet": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. Should describe algorithm: iterate, use negative marking: for each num in nums, index=abs(num)-1; if nums[index]<0 then add to result else nums[index] = -nums[index]. Complexity O(n) and constant space.\n\nWe produce lines with Start, End, Decision etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空陣列 result // 用來存放重複出現的數字  \n→ Step 2: for i from 0 to nums.length-1 // 遍歷整個陣列  \n  → Decision: 若 abs(nums[i]) 在陣列內? // 檢查索引合法性（在本題始終合法）  \n   Yes → Step 3: index ← abs(nums[i]) - 1 // 將數字轉為對應索引  \n    Decision: 若 nums[index] < 0? // 該位置已被標記為負，表示此數已出現一次  \n     Yes → Step 4: result.append(nums[index] * -1) // 加入結果，並恢復正值  \n     No  → Step 5: nums[index] ← -nums[index] // 以負號標記此數已出現  \n→ Step 6: EndFor // 完成所有元素的處理  \nEnd // 程式執行結束，返回 result\n\n// 解釋：通過將對應索引位置的值變為負號來記錄已見過的數字，當再次遇到同一數字時，該位置已為負，即可判定為重複並加入結果。此方法僅使用常數額外空間，且時間複雜度為 O(n)。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicates(self, nums):\n        \"\"\"Return all numbers that appear twice in nums using O(n) time and O(1) extra space.\"\"\"\n        res = []\n        for num in nums:\n            index = abs(num) - 1          # 轉換成對應的索引\n            if nums[index] < 0:           # 已經被標記過，說明此數字已重複\n                res.append(abs(num))      # 加入結果\n            else:\n                nums[index] = -nums[index]  # 以負號標記此數字已出現\n        return res\n\ndef parse_input(input_str):\n    \"\"\"\n    從輸入字串中解析出 nums 列表。\n    支援形如 'nums = [1,2,3]' 或直接 '[1,2,3]' 的輸入。\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    # 找到第一個 '['，並從那裡開始取字串，確保能正確解析\n    start = input_str.find('[')\n    if start == -1:\n        # 沒有 '['，直接嘗試解析整個字串\n        return ast.literal_eval(input_str)\n    arr_str = input_str[start:]\n    return ast.literal_eval(arr_str)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findDuplicates(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,2]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode146.json",
    "problem_index_in_file": 0,
    "title": "LRU Cache",
    "description_snippet": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplemen...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for LRUCache design, with steps line by line. Use Start, End, Decision, arrows, etc. Each line: \"虛擬碼步驟 // 解釋\". Provide explanation in Chinese. Should not output actual code.\n\nWe need to describe initialization, get, put, internal structures: use doubly linked list + hash map. Provide step-by-step pseudocode: Start, initialize capacity, create hashmap, create head/tail sentinel nodes for list. Then define helper functions: addNode, removeNode, moveToHead, popTail. Then implement get: check map, if not found return -1, else move node to head and return value. Implement put: if key exists, update value, move to head. Else create new node, add to map, add to head. If size>capacity, pop tail, remove from map. End.\n\nWe must produce each step line, with explanation. Use arrow for flow: → Step ... But each line is a step. For decisions, use Decision: ... Yes → ... No → ... Provide indentation maybe but keep same formatting. Use the same format example.\n\nWe need to list steps for initialization, functions, helpers. Provide virtual code with labels: Step 1, Step 2 etc. Use Start at top.\n\nLet's produce a thorough flow. Probably 20-30 lines.\n\nRemember each line: \"虛擬碼步驟 // 解釋\". So after each step, a space then comment. The comment must be brief.\n\nLet's start:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 LRUCache(capacity) // 設定最大容量\n\n→ Step 2: 建立 hashMap<key, node> // 快速存取節點\n\n→ Step 3: 建立雙向鏈表 dummyHead, dummyTail // 兩個哨兵節點\n\n→ Step 4: dummyHead.next = dummyTail; dummyTail.prev = dummyHead // 連結哨兵\n\n→ Step 5: 定義 helper 函式 addNode(node) // 把節點加入到 head\n\n→ Step 6: 在 addNode 中 // 步驟1: node.prev = dummyHead\n\n→ Step 7: addNode 中 // 步驟2: node.next = dummyHead.next\n\n→ Step 8: addNode 中 // 步驟3: dummyHead.next.prev = node\n\n→ Step 9: addNode 中 // 步驟4: dummyHead.next = node\n\n→ Step 10: 定義 helper 函式 removeNode(node) // 移除節點\n\n→ Step 11: removeNode 中 // node.prev.next = node.next\n\n→ Step 12: removeNode 中 // node.next.prev = node.prev\n\n→ Step 13: 定義 helper moveToHead(node) // 移動節點到 head\n\n→ Step 14: moveToHead 中 // 呼叫 removeNode(node)\n\n→ Step 15: moveToHead 中 // 呼叫 addNode(node)\n\n→ Step 16: 定義 helper popTail() // 刪除最舊節點\n\n→ Step 17: popTail 中 // target = dummyTail.prev\n\n→ Step 18: popTail 中 // 呼叫 removeNode(target)\n\n→ Step 19: popTail 中 // 回傳 target\n\n→ Step 20: 定義函式 get(key) // 取得值\n\n→ Step 21: get 中 // if key not in hashMap, return -1\n\n→ Step 22: get 中 // node = hashMap[key]\n\n→ Step 23: get 中 // 呼叫 moveToHead(node)\n\n→ Step 24: get 中 // return node.value\n\n→ Step 25: 定義函式 put(key, value) // 插入/更新\n\n→ Step 26: put 中 // if key in hashMap\n\n→ Step 27: put 中 Yes → node = hashMap[key]; node.value = value\n\n→ Step 28: put 中 Yes → 呼叫 moveToHead(node)\n\n→ Step 29: put 中 No  → node = new Node(key, value)\n\n→ Step 30: put 中 No → hashMap[key] = node\n\n→ Step 31: put 中 No → 呼叫 addNode(node)\n\n→ Step 32: put 中 No → size++ // 追蹤容量\n\n→ Step 33: put 中 // if size > capacity\n\n→ Step 34: put 中 Yes → tail = popTail()\n\n→ Step 35: put 中 Yes → 移除 hashMap[tail.key]\n\n→ Step 36: put 中 Yes → size--\n\n→ End // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟 // 解釋\". The above has each line. But we need \"虛擬碼步驟\" part: e.g., \"Start\" etc. Provide comment. Good.\n\nWe must be careful that each line has \"虛擬碼步驟\" and comment. We can use labels like \"Step 1:\". The comment should be short but intuitive. Provide Chinese. Use arrow for flow? The format says to use virtual code arrows: \"→\" etc. We can incorporate arrow before steps to denote flow. But each line is separate. Use \"→\" at beginning maybe. Example given: \"→ Step 1: ...\" Good. Use \"→\" for steps. Decision lines: \"Decision: ...\" etc. For decision branches, we need indentation. But not necessary to indent; can just use separate lines with \"Yes →\" and \"No →\". We need to show Yes/No branches.\n\nMake sure to use \"Decision:\" lines with conditions. We need to include \"Decision:\" for get check and put check.\n\nLet's refine.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: LRUCache(capacity) // 設定最大容量\n→ Step 2: hashMap = {} // 建立 key->node 的映射\n→ Step 3: dummyHead, dummyTail = Node(0,0), Node(0,0) // 哨兵節點\n→ Step 4: dummyHead.next = dummyTail; dummyTail.prev = dummyHead // 連結\n→ Step 5: size = 0 // 目前元素數量\n\n→ Step 6: Function addNode(node) // 把 node 放到 head\n→     node.prev = dummyHead\n→     node.next = dummyHead.next\n→     dummyHead.next.prev = node\n→     dummyHead.next = node\n\n→ Step 7: Function removeNode(node) // 從鏈表中移除\n→     node.prev.next = node.next\n→     node.next.prev = node.prev\n\n→ Step 8: Function moveToHead(node) // 移動到 head\n→     removeNode(node)\n→     addNode(node)\n\n→ Step 9: Function popTail() // 移除並回傳最舊節點\n→     tail = dummyTail.prev\n→     removeNode(tail)\n→     return tail\n\n→ Step 10: Function get(key) // 取得 key 的值\n→     Decision: key 在 hashMap 中嗎? // 檢查存在性\n→         Yes → node = hashMap[key]\n→             moveToHead(node)\n→             return node.value\n→         No  → return -1\n\n→ Step 11: Function put(key, value) // 插入或更新\n→     Decision: key 在 hashMap 中嗎? // 檢查是否已存在\n→         Yes → node = hashMap[key]\n→             node.value = value\n→             moveToHead(node)\n→         No  → node = Node(key, value)\n→             hashMap[key] = node\n→             addNode(node)\n→             size += 1\n→             Decision: size > capacity? // 超過容量則淘汰\n→                 Yes → tail = popTail()\n→                     delete hashMap[tail.key]\n→                     size -= 1\n\nEnd // 程式執行結束\n\nBut we must keep each line as separate, no multi-line functions. Each line needs to be one \"虛擬碼步驟\". But multi-step function definitions need separate lines. However we might combine into multi-step definitions. Example: \"Function addNode(node) // ...\" Then subsequent lines starting with \"→\" etc. The example had \"Decision:\" inside indentation.\n\nWe should produce lines like:\n\n→ Step 6: Function addNode(node) // 把 node 放到 head\n→     node.prev = dummyHead\n→     node.next = dummyHead.next\n→     dummyHead.next.prev = node\n→     dummyHead.next = node\n\nBut each line must be separate. However the line with \"node.prev = dummyHead\" has indentation. The comment should follow the code line. Good.\n\nSimilarly for other functions.\n\nWe also need to ensure each line is consistent: \"→\" at start? The example uses \"→\" before step, and within decision branches \"Yes →\". So for each line we should use \"→\". The initial \"Start\" didn't have arrow, just \"Start\". But we can keep as \"Start\". Example: \"Start // 程式開始執行\".\n\nThus each step line should start with \"→\". For function lines, we might need to indent with \"→\" then spaces, but okay.\n\nMake sure to use \"Decision:\" for branches. We must include \"Yes →\" and \"No →\" lines.\n\nWe should keep the comment after space.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: LRUCache(capacity) // 初始化 LRUCache 並設定容量  \n→ Step 2: hashMap = {} // 建立 key → node 的映射表  \n→ Step 3: dummyHead, dummyTail = Node(0,0), Node(0,0) // 建立雙向鏈表的哨兵節點  \n→ Step 4: dummyHead.next = dummyTail; dummyTail.prev = dummyHead // 連接哨兵  \n→ Step 5: size = 0 // 記錄目前元素數量  \n\n→ Step 6: Function addNode(node) // 將節點插入到頭部  \n→     node.prev = dummyHead  \n→     node.next = dummyHead.next  \n→     dummyHead.next.prev = node  \n→     dummyHead.next = node  \n\n→ Step 7: Function removeNode(node) // 從鏈表中移除節點  \n→     node.prev.next = node.next  \n→     node.next.prev = node.prev  \n\n→ Step 8: Function moveToHead(node) // 把節點移到最近使用位置  \n→     removeNode(node)  \n→     addNode(node)  \n\n→ Step 9: Function popTail() // 刪除最舊節點並回傳  \n→     tail = dummyTail.prev  \n→     removeNode(tail)  \n→     return tail  \n\n→ Step 10: Function get(key) // 取得 key 的值  \n→     Decision: key 在 hashMap 中嗎?  \n→         Yes → node = hashMap[key]  \n→             moveToHead(node)  \n→             return node.value  \n→         No  → return -1  \n\n→ Step 11: Function put(key, value) // 插入或更新鍵值對  \n→     Decision: key 在 hashMap 中嗎?  \n→         Yes → node = hashMap[key]  \n→             node.value = value  \n→             moveToHead(node)  \n→         No  → node = Node(key, value)  \n→             hashMap[key] = node  \n→             addNode(node)  \n→             size += 1  \n→             Decision: size > capacity?  \n→                 Yes → tail = popTail()  \n→                     delete hashMap[tail.key]  \n→                     size -= 1  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        value = self.cache[key]\n        del self.cache[key]\n        self.cache[key] = value\n        return value\n\n    def put(self, key, value):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入分成兩個列表\n    match = re.search(r'\\],\\s*\\[', data)\n    if match:\n        first_part = data[:match.start() + 1]      # 包含第一個 ]\n        second_part = data[match.start() + 1:]     # 從第二個 [\n        commands = ast.literal_eval(first_part)\n        args = ast.literal_eval(second_part)\n    else:\n        # 若輸入已經是包含兩個列表的形式\n        arr = ast.literal_eval(data)\n        commands, args = arr[0], arr[1]\n\n    cache = None\n    outputs = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            outputs.append(None)\n        elif cmd == \"put\":\n            cache.put(arg[0], arg[1])\n            outputs.append(None)\n        elif cmd == \"get\":\n            res = cache.get(arg[0])\n            outputs.append(res)\n\n    # 格式化輸出為 [null, null, ...] 形式\n    out_str = '[' + ', '.join('null' if v is None else str(v) for v in outputs) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpc2ma36m_.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpc2ma36m_.py\", line 36, in main\n    args = ast.literal_eval(second_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    , [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode9.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Number",
    "description_snippet": "Given an integer x, return true if x is a palindrome, and false otherwise....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanation after each line. Format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Steps to check palindrome of integer. Approach: convert to string or reverse integer. Virtual steps: Start, Step 1: check if x < 0 → return false; Step 2: convert to string; Step 3: compare string with reverse; Step 4: return result. But we need Decision nodes for negative, or we can use reversed integer method.\n\nSimplest: Use string method: Convert integer to string s; compare s with reverse(s). If equal return true else false. Provide virtual steps accordingly.\n\nWe should include decisions: if x < 0? Yes -> return false. Then Step: Convert x to string s. Step: Reverse s to get rev. Step: Compare s == rev? Yes -> return true; No -> return false. End.\n\nWe need to output each line with arrow: \"→\" before steps. Format:\n\nStart // 程式開始執行\n→ Decision: x < 0? // 檢查是否為負數\n    Yes → Step: Return false // 負數不可能為迴文\n    No  → Step 1: s = ToString(x) // 轉成字串\n→ Step 2: rev = ReverseString(s) // 取得反轉字串\n→ Decision: s == rev? // 判斷是否相同\n    Yes → Step: Return true // 是迴文\n    No  → Step: Return false // 不是迴文\nEnd // 程式結束\n\nBut need to maintain correct indentation and arrow usage. Use \"Yes →\" and \"No →\" inside decisions. For lines after Decision, we indent further maybe. Provide each line as separate line.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: x < 0? // 檢查是否為負數  \n Yes → Step: Return false // 負數不可能為迴文  \n No  → Step 1: s = ToString(x) // 轉成字串  \n→ Step 2: rev = ReverseString(s) // 取得反轉字串  \n→ Decision: s == rev? // 判斷是否相同  \n Yes → Step: Return true // 是迴文  \n No  → Step: Return false // 不是迴文  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        Return True if the integer x is a palindrome, otherwise False.\n        \"\"\"\n        # Negative numbers cannot be palindromes\n        if x < 0:\n            return False\n        # Convert number to string\n        s = str(x)\n        # Check if string equals its reverse\n        return s == s[::-1]\n\ndef main():\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the first integer found in the input\n    match = re.search(r'[-]?\\d+', data)\n    if not match:\n        print('false')\n        return\n    x = int(match.group())\n    sol = Solution()\n    result = sol.isPalindrome(x)\n    # Output 'true' or 'false' in lowercase\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 121",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = -121",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 10",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode421.json",
    "problem_index_in_file": 0,
    "title": "Maximum XOR of Two Numbers in an Array",
    "description_snippet": "Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step with arrows and decision nodes. The problem: find max XOR pair in array. Standard algorithm: use bitwise trie. Steps: initialize max_xor = 0, prefix=0, iterate bits from 31 downto 0, maintain a set of prefixes for each iteration, compute best candidate, etc. Provide pseudocode with start, decision, loops. Avoid actual code, just steps. Use arrow notation.\n\nWe need to produce virtual code line by line, each line has \"虛擬碼步驟 // 解釋\". Use arrow for transitions: \"→\" after Start. Use Decision: if condition? with Yes/No arrows.\n\nLet's structure: Start, Step 1: initialize variables, Step 2: iterate bits from high to low, Step 3: build prefixes set, Step 4: compute best candidate, Step 5: update max_xor, Step 6: return max_xor, End.\n\nWe might incorporate loops. Use Decision: \"是否已經處理完所有位數?\" etc.\n\nLet's produce.\n\nBe mindful to keep each line separate. Use \"Step X:\" maybe.\n\nWe'll include \"Decision:\" for checking if bit index < 0 etc. Provide arrow structure.\n\nLet's write:\n\nStart // 開始執行\n\n→ Step 1: 初始化 max_xor = 0，mask = 0 // 用於累積前綴並保存最高位\n\n→ Decision: 是否還有位數可處理? // 判斷是否已經處理完 32 位\n    Yes → Step 2: 將 mask 右移 1 位，更新為 mask = mask | (1 << i) // 更新 mask 以包含當前位\n    → Step 3: 建立空集合 prefixSet // 存儲所有數字對應的前綴\n    → Loop: 對於每個 num in nums\n        → Step 4: 計算前綴 pre = num & mask\n        → Step 5: 將 pre 加入 prefixSet\n    → Step 6: 計算理想候選 best = (max_xor << 1) | 1 // 期望在此位為 1\n    → Step 7: Decision: 是否存在 pre1, pre2 在 prefixSet 使得 pre1 XOR pre2 = best? // 檢查是否能在此位得到 1\n        Yes → Step 8: max_xor = best // 可得到 1，更新最大 XOR\n        No  → Step 9: max_xor = max_xor << 1 // 只能得到 0，將最大 XOR 左移\n    → Back to Decision: 是否還有位數可處理? // 迴圈結束判斷\n        No  → Step 10: 返回 max_xor // 返回最終結果\nEnd // 程式執行結束\n\nWe need to ensure arrow syntax. Use \"→\" before each step. The decision lines should have \"Decision:\" with Yes and No arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 max_xor = 0，mask = 0 // 用於累積前綴並保存最高位  \n→ Decision: 是否還有位數可處理? // 判斷是否已經處理完 32 位  \n&nbsp;&nbsp;&nbsp;Yes → Step 2: 更新 mask 為 mask | (1 << i) // 讓 mask 包含到目前為止的最高 i 位  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3: 建立空集合 prefixSet // 用於存放本次位階的所有前綴  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Loop: 對 nums 中的每個 num  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: 計算 pre = num & mask // 取出 num 的前綴  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: 將 pre 加入 prefixSet  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: 計算理想候選 best = (max_xor << 1) | 1 // 期望此位為 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: Decision: 是否存在 pre1, pre2 ∈ prefixSet 使得 pre1 XOR pre2 = best? // 檢查是否能得到 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: max_xor = best // 能得到 1，更新最大 XOR  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: max_xor = max_xor << 1 // 只能得到 0，左移保持前面已確定的位  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Back to Decision: 是否還有位數可處理?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 10: 返回 max_xor // 返回最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def findMaximumXOR(self, nums):\n        max_xor = 0\n        mask = 0\n        # 32-bit numbers, iterate from the highest bit to the lowest\n        for i in range(31, -1, -1):\n            mask |= (1 << i)\n            # collect all prefixes of current length\n            prefixes = {num & mask for num in nums}\n            # try to set the current bit to 1\n            candidate = max_xor | (1 << i)\n            # check if any two prefixes can achieve this candidate\n            for p in prefixes:\n                if (candidate ^ p) in prefixes:\n                    max_xor = candidate\n                    break\n        return max_xor\n\ndef parse_nums(input_str):\n    \"\"\"\n    Extract a list of integers from a string that may contain\n    something like 'nums = [3,10,5,25,2,8]' or just a raw list.\n    \"\"\"\n    # Find the first square-bracketed expression\n    m = re.search(r'\\[.*\\]', input_str, re.S)\n    if m:\n        return ast.literal_eval(m.group())\n    # Fallback: treat the whole input as space-separated integers\n    parts = input_str.strip().split()\n    return [int(p) for p in parts if p.strip()]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    nums = parse_nums(raw_input)\n    sol = Solution()\n    result = sol.findMaximumXOR(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,10,5,25,2,8]",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 1,
          "input": "nums = [14,70,53,83,49,91,36,80,92,51,66,70]",
          "expected_output": "127",
          "success": true,
          "output": "127"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode524.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary through Deleting",
    "description_snippet": "Given a string s and a string array dictionary, return the longest string in the dictionary that can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The user wants to find longest string in dictionary that can be formed by deleting some characters from s. Also tie-breaking: longest, then smallest lexicographical order. If none, return empty string.\n\nWe should produce algorithm: iterate through dictionary, check subsequence via two pointers. Keep best answer by length and lex order.\n\nVirtual code steps: Start, Step 1: sort dictionary by length descending, lex ascending? Actually we need to evaluate all to find best. Use variable best. For each word in dictionary: if word is subsequence of s: if length > best length or same length but word lex smaller -> update best. After loop return best.\n\nWe must produce virtual code with arrows etc. Also include comments.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize best = \"\" // 儲存目前最佳單字\n→ Step 2: For each word in dictionary // 遍歷字典\n    → Step 3: If word is subsequence of s // 檢查是否能由 s 形成\n        → Decision: 如果 word 長度 > best 長度? // 判斷長度\n            Yes → Step 4: best = word // 更長直接更新\n            No → Decision: 如果 word 長度 == best 長度? // 長度相同\n                Yes → Decision: 如果 word < best? // lexicographically smaller\n                    Yes → Step 5: best = word // 更新為更小字\n                    No → No change\n                No → No change\n→ Step 6: Return best // 輸出結果\nEnd\n\nNeed to explain subsequence check function. Could include substep:\n\n→ Step 7: Define function isSubsequence(word, s)\n    → Step 8: i=0, j=0\n    → While i < word.length and j < s.length\n        → If word[i] == s[j] then i++\n        → j++\n    → Return i == word.length\n\nBut we need to incorporate that into virtual steps. We can integrate inside loop as subroutine.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: best = \"\" // 儲存目前符合條件的最佳單字  \n→ Step 2: For each word in dictionary // 遍歷字典中的每一個單字  \n    → Step 3: If isSubsequence(word, s) // 檢查 word 是否能從 s 中刪字得到  \n        → Decision: 是否 word.length > best.length? // 判斷長度是否更長  \n            Yes → Step 4: best = word // 更長直接更新最佳單字  \n            No → Decision: 是否 word.length == best.length? // 長度相同時再比大小寫順序  \n                Yes → Decision: 是否 word < best? // lexicographically 更小則更新  \n                    Yes → Step 5: best = word // 更新為字典序更小的單字  \n                    No → No change // 保持現有最佳單字  \n                No → No change // 兩條件均不滿足，保持現有最佳單字  \n→ Step 6: Return best // 輸出結果（若無符合則為空字串）  \nEnd // 程式執行結束  \n\n// -------------------- 子程序 --------------------  \n→ Function isSubsequence(word, s) // 判斷 word 是否為 s 的子序列  \n    → i = 0, j = 0 // 初始化指標  \n    → While i < word.length AND j < s.length  \n        → Decision: 是否 word[i] == s[j]?  \n            Yes → i++ // 找到對應字符，移到 word 的下一個字符  \n            No → No change // 仍檢查 s 的下一個字符  \n        → j++ // 無論是否匹配，都向前移動 s 的指標  \n    → Return i == word.length // 若 i 達到 word 長度，則所有字符已匹配完  \n// -------------------------------------------------",
      "generated_code": "import sys\nimport ast\n\ndef is_subsequence(word: str, s: str) -> bool:\n    \"\"\"檢查 word 是否為 s 的子序列。\"\"\"\n    it = iter(s)\n    return all(c in it for c in word)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試把整個輸入當成一個 tuple 解析\n    try:\n        s, dictionary = ast.literal_eval('(' + data + ')')\n    except Exception:\n        # 若失敗，假設輸入是兩行：第一行是 s，第二行是 list\n        parts = data.splitlines()\n        if len(parts) < 2:\n            return\n        s = parts[0].strip('\"')\n        dictionary = ast.literal_eval(parts[1])\n\n    best = \"\"\n    for word in dictionary:\n        if is_subsequence(word, s):\n            if len(word) > len(best) or (len(word) == len(best) and word < best):\n                best = word\n\n    print(best)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"]",
          "expected_output": "\"apple\"",
          "success": true,
          "output": "apple"
        },
        {
          "example_index": 1,
          "input": "\"abpcplea\", [\"a\",\"b\",\"c\"]",
          "expected_output": "\"a\"",
          "success": true,
          "output": "a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode599.json",
    "problem_index_in_file": 0,
    "title": "Minimum Index Sum of Two Lists",
    "description_snippet": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\n\nA co...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. Use Start, End, Decision, arrows. Let's design algorithm: Use map to store string -> index in list1. Then iterate list2, compute sum indices, keep minSum and result list. If sum < minSum, reset; if sum == minSum, add. Provide steps. Provide explanation per line. Should be in Traditional Chinese. Use 虛擬碼步驟. Eg \"Start // 程式開始\". Need to maintain format: \"虛擬碼步驟 [space] // 解釋\".\n\nWe need to include arrows with \"→\". Use indentation? The example uses indentation for decisions but we can simply use spaces. Use \"Decision:\" with Yes and No. For loops we may use \"Loop\" or \"Step\". Let's produce:\n\nStart\n→ Step 1: 建立空字典 indexMap // 用來存儲 list1 中每個字串的索引\n→ Loop i from 0 to len(list1)-1\n    → Step 2: indexMap[list1[i]] = i // 將字串映射到其索引\n→ Step 3: minSum = 大整數 // 初始最小索引和\n→ Step 4: result = 空串列 // 存儲答案\n→ Loop j from 0 to len(list2)-1\n    → Decision: list2[j] 是否在 indexMap 中? // 判斷是否為共同字串\n        Yes → Step 5: i = indexMap[list2[j]] // 取得在 list1 中的索引\n              → Step 6: sum = i + j // 計算索引和\n              → Decision: sum 是否小於 minSum? // 比較是否為更小索引和\n                  Yes → Step 7: minSum = sum // 更新最小索引和\n                        → Step 8: result = [list2[j]] // 重置結果列表\n                  No  → Decision: sum 是否等於 minSum? // 檢查是否相同\n                      Yes → Step 9: result.append(list2[j]) // 加入結果\n                      No  → // 不做任何事\n→ End // 結束並返回 result\n\nNeed to use 虛擬碼 arrows. Ensure each line has \"虛擬碼步驟\" + \" // 解釋\". For loops we might use \"Loop\" or \"Step\". Provide proper indentation: maybe use spaces to indent sub-steps under decisions. Use \"→\" for flow. The format example uses indentation of 4 spaces before sub-steps. We'll follow that.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 indexMap // 用來存儲 list1 中每個字串的索引  \n→ Loop i from 0 to len(list1)-1  \n    → Step 2: indexMap[list1[i]] = i // 將 list1 中的字串映射到其索引  \n→ Step 3: minSum = 大整數 // 初始設定為最大值  \n→ Step 4: result = 空串列 // 用來儲存最小索引和的共同字串  \n→ Loop j from 0 to len(list2)-1  \n    → Decision: list2[j] 是否在 indexMap 中? // 判斷是否為共同字串  \n        Yes → Step 5: i = indexMap[list2[j]] // 取得在 list1 中的索引  \n             → Step 6: sum = i + j // 計算兩個索引的總和  \n             → Decision: sum 是否小於 minSum? // 檢查是否為更小的總和  \n                 Yes → Step 7: minSum = sum // 更新最小總和  \n                     → Step 8: result = [list2[j]] // 重置結果列表，只保留此字串  \n                 No  → Decision: sum 是否等於 minSum? // 若不小於，檢查是否相等  \n                     Yes → Step 9: result.append(list2[j]) // 加入等值字串  \n                     No  → // 不作任何變更  \n→ End // 程式結束，返回 result 其中包含所有最小索引和的共同字串",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findRestaurant(self, list1, list2):\n        # 建立 list1 的索引映射\n        index_map = {name: i for i, name in enumerate(list1)}\n        min_sum = float('inf')\n        res = []\n\n        # 遍歷 list2，計算索引和\n        for j, name in enumerate(list2):\n            if name in index_map:\n                total_index = j + index_map[name]\n                if total_index < min_sum:\n                    min_sum = total_index\n                    res = [name]\n                elif total_index == min_sum:\n                    res.append(name)\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取兩個 list，並轉成 Python list。\n    允許輸入形式為：\n    'list1 = [...], list2 = [...]'\n    \"\"\"\n    # 先找出兩個方括號包住的字串\n    lists = re.findall(r'\\[.*?\\]', data, flags=re.S)\n    if len(lists) != 2:\n        raise ValueError(\"輸入格式錯誤，未找到兩個 list\")\n    list1 = ast.literal_eval(lists[0])\n    list2 = ast.literal_eval(lists[1])\n    return list1, list2\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入為兩個 list\n    try:\n        list1, list2 = parse_input(raw_input)\n    except Exception as e:\n        print(f\"輸入解析失敗: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # 產生答案\n    solution = Solution()\n    result = solution.findRestaurant(list1, list2)\n\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "['Shogun']"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "['Shogun']"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "success": true,
          "output": "['sad', 'happy']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode629.json",
    "problem_index_in_file": 0,
    "title": "K Inverse Pairs Array",
    "description_snippet": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.leng...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: count number of permutations of [1..n] with exactly k inversions. Classic DP: dp[i][j] = number of permutations of size i with j inversions. Recurrence: dp[i][j] = sum_{t=0}^{min(j,i-1)} dp[i-1][j-t]. Use prefix sums to optimize O(nk). Mod 1e9+7. Also use rolling array to reduce memory. At the end output dp[n][k] % mod.\n\nWe need to generate step-by-step pseudocode lines with explanation. Should include Start, End, Decision, arrow etc. Provide each line. We need to include loops and DP updates. Must not produce actual code but pseudocode. So we will outline steps.\n\nLet's design:\n\nStart\n→ Initialize MOD=1e9+7\n→ Initialize 2D array dp of size (n+1) x (k+1) with zeros\n→ Set dp[0][0] = 1 // base case: empty array has 0 inversions\n→ For i from 1 to n: // number of elements considered\n    → For j from 0 to k:\n        → dp[i][j] = 0\n        → For t from 0 to min(j, i-1):\n            → dp[i][j] = (dp[i][j] + dp[i-1][j-t]) % MOD\n    // Alternatively use prefix sums:\n    → For j from 0 to k:\n        → Compute prefix sums of dp[i-1] to quickly get sum over t range\nBut for pseudocode we can show prefix sum approach.\n\nMaybe better:\n\n→ For i from 1 to n:\n    → Compute prefix[0] = dp[i-1][0]\n    → For j from 1 to k:\n        → prefix[j] = (prefix[j-1] + dp[i-1][j]) % MOD\n    → For j from 0 to k:\n        → left = j - (i-1)\n        → if left < 0: left = 0\n        → dp[i][j] = (prefix[j] - (left>0?prefix[left-1]:0) + MOD) % MOD\n\nAfter loops:\n\n→ Answer = dp[n][k]\n→ Output Answer % MOD\nEnd\n\nBut we need step-by-step explanation per line. Let's craft lines:\n\nStart // 程式開始\n→ Set MOD = 1_000_000_007 // 常數模數\n→ Declare dp as 2D array (n+1)×(k+1) initialized to 0 // DP table\n→ Set dp[0][0] = 1 // 空序列只有 0 個反序對\n→ For i from 1 to n: // 計算長度為 i 的排列\n    → Declare prefix as array size k+1 initialized to 0 // 前綴和\n    → Set prefix[0] = dp[i-1][0]\n    → For j from 1 to k:\n        → prefix[j] = (prefix[j-1] + dp[i-1][j]) % MOD // 生成前綴和\n    → For j from 0 to k:\n        → left = j - (i-1)\n        → If left < 0: left = 0\n        → sum = (prefix[j] - (left>0?prefix[left-1]:0) + MOD) % MOD // 区间和\n        → dp[i][j] = sum // dp[i][j] 的值\n→ Answer = dp[n][k] // 最終答案\n→ Output Answer // 輸出結果\nEnd // 程式結束\n\nBut we need to use arrow syntax \"→\". Also we need to use Decision maybe for if conditions. Use \"Decision: if left < 0?\" with Yes/No arrows.\n\nLet's craft properly.\n\nWe should include decision lines for condition left<0 and maybe for left>0 to subtract prefix. We can just use inline comment.\n\nBut requirement: use Decision structure: \"Decision: ...\" with Yes → and No →. So we need to use Decision for conditional. We can have:\n\nDecision: left < 0? // 判斷 left 是否為負\n    Yes → left = 0\n    No →\n\nSimilarly for subtract.\n\nLet's write:\n\nStart // 程式開始\n→ Set MOD = 1000000007 // 模數\n→ Initialize dp[0…n][0…k] = 0 // DP 表\n→ Set dp[0][0] = 1 // 空排列只有 0 反序對\n\n→ For i = 1 to n:\n    → Initialize prefix[0…k] = 0 // 前綴和\n    → Set prefix[0] = dp[i-1][0]\n    → For j = 1 to k:\n        → Set prefix[j] = (prefix[j-1] + dp[i-1][j]) mod MOD // 前綴和計算\n    → For j = 0 to k:\n        → Decision: j - (i-1) < 0? // 判斷 left 是否為負\n            Yes → Set left = 0\n            No  → Set left = j - (i-1)\n        → sum = prefix[j]\n        → Decision: left > 0? // 若 left>0 則需要減去前綴和\n            Yes → sum = (sum - prefix[left-1] + MOD) mod MOD\n            No  →\n        → Set dp[i][j] = sum // 計算 dp[i][j]\n→ Answer = dp[n][k] // 最終答案\n→ Output Answer // 輸出結果\nEnd // 程式結束\n\nThis uses decision. Ensure each line has \"→\" arrow at start except decisions which start with \"Decision:\" maybe preceded by indentation. Use \"→\" arrow for all steps, even inside loops.\n\nWe should use indentation to show nested loops? It's not strictly required but good.\n\nWe must ensure each line has virtual code step + space + comment.\n\nWe also need to keep consistent formatting. For Decision, after \"Decision:\" we include the condition, then indent inside Yes/No lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始\n→ Set MOD = 1000000007 // 模數\n→ Initialize dp[0…n][0…k] = 0 // DP 表\n→ Set dp[0][0] = 1 // 空排列只有 0 反序對\n\n→ For i = 1 to n: // 計算長度為 i 的排列\n    → Initialize prefix[0…k] = 0 // 前綴和\n    → Set prefix[0] = dp[i-1][0]\n    → For j = 1 to k: // 建立前綴和\n        → Set prefix[j] = (prefix[j-1] + dp[i-1][j]) mod MOD\n    → For j = 0 to k: // 計算 dp[i][j]\n        → Decision: j - (i-1) < 0? // 判斷左邊界是否為負\n            Yes → Set left = 0\n            No  → Set left = j - (i-1)\n        → Set sum = prefix[j]\n        → Decision: left > 0? // 若左邊界 > 0 則需要扣除前綴和\n            Yes → Set sum = (sum - prefix[left-1] + MOD) mod MOD\n            No  →\n        → Set dp[i][j] = sum // dp[i][j] 的值\n\n→ Answer = dp[n][k] // 最終答案\n→ Output Answer // 輸出結果\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_inverse_pairs(n: int, k: int) -> int:\n    # If the requested number of inversions is larger than the maximum possible,\n    # the answer is 0.\n    max_inv = n * (n - 1) // 2\n    if k > max_inv:\n        return 0\n\n    prev = [0] * (k + 1)\n    prev[0] = 1  # base case: empty permutation has 0 inversions\n\n    for i in range(1, n + 1):\n        cur = [0] * (k + 1)\n        cur[0] = 1  # dp[i][0] == 1 for any i\n        for j in range(1, k + 1):\n            val = cur[j - 1] + prev[j]\n            if j >= i:\n                val -= prev[j - i]\n            cur[j] = val % MOD\n        prev = cur\n\n    return prev[k]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) < 2:\n        # If input is not in the expected format, exit gracefully\n        sys.exit(0)\n    n, k = nums[0], nums[1]\n    result = count_inverse_pairs(n, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode693.json",
    "problem_index_in_file": 0,
    "title": "Binary Number with Alternating Bits",
    "description_snippet": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line, no actual code. Just steps, explanation after //.\n\nNeed to produce algorithm: given positive integer n, check alternating bits.\n\nWe need steps: Start, input n, decision: n>0? maybe not necessary. But we can check bits by bitwise operations: use previous bit variable.\n\nAlgorithm:\n\n- Start\n- Step 1: Input n\n- Step 2: If n==0? maybe not; but we can handle trivial case: If n <=0, return False? but positive integer given.\n- Step 3: Initialize previous_bit = n & 1 (least significant bit)\n- Step 4: Shift n right by 1\n- Step 5: While n > 0:\n   - current_bit = n & 1\n   - If current_bit == previous_bit: return False\n   - previous_bit = current_bit\n   - Shift n right by 1\n- Step 6: Return True\n\nBut need to output virtual code lines with arrows.\n\nSo we need to produce a step-by-step representation.\n\nLet's produce lines:\n\nStart\n→ Step 1: Read input n // 取得輸入的正整數\n→ Decision: n <= 0? // 檢查是否為非正數\n    Yes → Step 2: Return False // 非正數無法交替位\n    No  →\n→ Step 3: Set prev_bit = n & 1 // 取最低位作為前一個位\n→ Step 4: Shift n right by 1 // 去掉已檢查的位\n→ Decision: n == 0? // 是否已經檢查完所有位\n    Yes → Step 5: Return True // 所有位都交替\n    No  →\n→ Step 6: Set curr_bit = n & 1 // 取得下一位\n→ Decision: curr_bit == prev_bit? // 與前一位是否相同\n    Yes → Step 7: Return False // 發現相同位，非交替\n    No  →\n→ Step 8: Set prev_bit = curr_bit // 更新前一位\n→ Step 9: Shift n right by 1 // 移除已檢查的位\n→ Go back to Decision: n == 0? // 重新檢查是否還有位\nEnd\n\nBut the format expects \"→\" lines with indent and then decisions. The example uses indentation.\n\nWe can produce something like:\n\nStart // 程式開始執行\n→ Step 1: Input n // 取得正整數\n→ Decision: n <= 0? // 檢查是否為非正數\n    Yes → Step 2: Return False // 無效輸入\n    No  →\n→ Step 3: prev_bit = n & 1 // 取最低位\n→ Step 4: n = n >> 1 // 去掉最低位\n→ Decision: n == 0? // 是否已經檢查完\n    Yes → Step 5: Return True // 所有位交替\n    No  →\n→ Step 6: curr_bit = n & 1 // 取下一位\n→ Decision: curr_bit == prev_bit? // 與前一位相同?\n    Yes → Step 7: Return False // 發現相同位\n    No  →\n→ Step 8: prev_bit = curr_bit // 更新前一位\n→ Step 9: n = n >> 1 // 去掉已檢查位\n→ Decision: n == 0? // 重新檢查\n    Yes → Step 5: Return True // 所有位交替\n    No  → (loop back)\nEnd // 程式結束\n\nWe must keep \"逐行\" each line with explanation after //.\n\nWe might need to include the loop, maybe by using Decision repeated.\n\nBut we can also express loop by using arrow back. Example: use \"→ Go to Step 6\" but not necessary.\n\nLet's produce simpler: We'll have a loop structure:\n\nStart\n→ Step 1: Input n\n→ Decision: n <= 0?\n    Yes → Step 2: Return False\n    No →\n→ Step 3: prev = n & 1\n→ Step 4: n = n >> 1\n→ Decision: n == 0?\n    Yes → Step 5: Return True\n    No →\n→ Step 6: curr = n & 1\n→ Decision: curr == prev?\n    Yes → Step 7: Return False\n    No  →\n→ Step 8: prev = curr\n→ Step 9: n = n >> 1\n→ Decision: n == 0? (go back to Step 6 or Step 5 accordingly)\n    Yes → Step 5: Return True\n    No  → Go to Step 6\n\nBut \"Go to Step 6\" may be indicated as arrow pointing back: \"→ Step 6: curr = n & 1\" but we need to differentiate between loop start.\n\nWe can use \"→ Step 6\" again as a new step? In pseudocode representation we can show as:\n\n→ Step 6: curr = n & 1\n...\n→ Decision: n == 0?\n    Yes → Step 5: Return True\n    No  → Step 6 // loop\n\nBut we have Step 6 defined earlier, we need to differentiate.\n\nWe can mark \"Loop\" step maybe: \"→ Step 6: curr = n & 1 // 進入循環檢查下一位\". Then in the decision \"No → Step 6\" referencing same step.\n\nOk.\n\nLet's craft final answer accordingly.\n\nWe should produce output lines as per format.\n\nI'll produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input n // 取得正整數  \n→ Decision: n <= 0? // 檢查是否為非正數  \n Yes → Step 2: Return False // 無效輸入，立即結束  \n No →  \n→ Step 3: prev_bit = n & 1 // 取得最低位作為前一個位  \n→ Step 4: n = n >> 1 // 去掉已檢查的最低位  \n→ Decision: n == 0? // 是否已經沒有更多位要檢查  \n Yes → Step 5: Return True // 所有位都已交替  \n No →  \n→ Step 6: curr_bit = n & 1 // 取得下一個位  \n→ Decision: curr_bit == prev_bit? // 與前一個位是否相同  \n Yes → Step 7: Return False // 發現相同位，非交替  \n No →  \n→ Step 8: prev_bit = curr_bit // 更新前一個位  \n→ Step 9: n = n >> 1 // 去掉已檢查的位  \n→ Decision: n == 0? // 重新檢查是否還有位  \n Yes → Step 5: Return True // 所有位都交替  \n No → Step 6 // 進入下一輪循環檢查  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef hasAlternatingBits(n: int) -> bool:\n    \"\"\"Return True if the binary representation of n has alternating bits.\"\"\"\n    prev_bit = n & 1\n    n >>= 1\n    while n:\n        curr_bit = n & 1\n        if curr_bit == prev_bit:\n            return False\n        prev_bit = curr_bit\n        n >>= 1\n    return True\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中提取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    print('true' if hasAlternatingBits(n) else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode13.json",
    "problem_index_in_file": 0,
    "title": "Roman to Integer",
    "description_snippet": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Val...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps line by line with explanations. It's roman to integer conversion. We need to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows and decisions. We can start with Start, input roman string, initialize result=0, loop i from 0 to len-1, if current value < next value then subtract else add. At end output result. Use decision arrow syntax. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: 讀取羅馬數字字串 S // 取得使用者輸入的羅馬數字  \n→ Declare: 變數 total = 0 // 用於累積最終整數結果  \n→ Declare: 變數 i = 0 // 索引指標，從第一個字符開始  \n→ Decision: i < length(S) ? // 是否還有未處理的字符？  \n  Yes → Step: 取值 cur = S[i] 的數值 // 根據符號對應表獲取數值  \n     If i + 1 < length(S) && cur < S[i+1] 的數值? // 判斷是否為減法情況  \n      Yes → total = total - cur // 低位前置，需減去其值",
      "generated_code": "import sys\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"\n    Convert a Roman numeral string to an integer.\n    \"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev_value = 0\n    for ch in reversed(s):\n        value = roman_map[ch]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total\n\ndef parse_input_line(line: str) -> str:\n    \"\"\"\n    Extract the Roman numeral string from a line.\n    Supports formats like:\n        s = \"III\"\n        \"III\"\n        III\n    \"\"\"\n    line = line.strip()\n    if not line:\n        return \"\"\n    # Find first and last double quotes\n    first_quote = line.find('\"')\n    last_quote = line.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        return line[first_quote + 1:last_quote]\n    # Find single quotes\n    first_quote = line.find(\"'\")\n    last_quote = line.rfind(\"'\")\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        return line[first_quote + 1:last_quote]\n    # Otherwise return the line as-is (trimmed)\n    return line\n\nif __name__ == \"__main__\":\n    # Read all non-empty lines from stdin\n    lines = [ln for ln in sys.stdin if ln.strip()]\n    if not lines:\n        sys.exit(0)\n    # Use the first non-empty line as input\n    raw_input = lines[0]\n    roman_str = parse_input_line(raw_input)\n    result = roman_to_int(roman_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"III\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"LVIII\"",
          "expected_output": "58",
          "success": true,
          "output": "58"
        },
        {
          "example_index": 2,
          "input": "s = \"MCMXCIV\"",
          "expected_output": "1994",
          "success": true,
          "output": "1994"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode134.json",
    "problem_index_in_file": 0,
    "title": "Gas Station",
    "description_snippet": "There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code. The task: find starting gas station index for circular tour. Standard problem: Gas Station. Use greedy algorithm: track total surplus, current surplus, and start index. Return start if total >=0 else -1.\n\nWe need to output line by line with arrow and explanation. No actual code. Use Start, End, Decision, Yes/No arrows.\n\nWe should produce pseudo-code with steps: initialize total=0, surplus=0, start=0. Loop i from 0 to n-1: total += gas[i] - cost[i]; surplus += gas[i] - cost[i]; if surplus < 0: start = i+1; surplus=0; after loop: if total >=0 return start else -1. Also need to handle when start >= n? Actually if start==n return -1. But unique solution guarantee.\n\nWe'll format each line accordingly. Provide explanation after space. Use Start line.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 取得 gas 與 cost 陣列長度 n // 獲取氣站數量\n→ Step 2: 初始化 total_surplus ← 0, current_surplus ← 0, start_index ← 0 // 初始化變數\n→ Step 3: 循環 i 從 0 到 n-1 // 逐個檢查氣站\n    → Step 3.1: total_surplus ← total_surplus + gas[i] - cost[i] // 計算總剩餘量\n    → Step 3.2: current_surplus ← current_surplus + gas[i] - cost[i] // 計算目前連續剩餘量\n    → Decision: current_surplus < 0? // 檢查目前剩餘是否不足\n        Yes → Step 3.3: start_index ← i + 1 // 重新設定起點為下一個氣站\n        Yes → Step 3.4: current_surplus ← 0 // 重置目前剩餘量\n        No  → // 目前剩餘足夠，繼續往後\n→ Decision: total_surplus >= 0? // 檢查總剩餘是否足以完成一圈\n    Yes → Step 4: 回傳 start_index // 成功，回傳起點\n    No  → Step 4: 回傳 -1 // 失敗，無法完成一圈\nEnd // 程式執行結束\n\nNeed to ensure each line uses arrow and comment.\n\nBut indentation? The example uses indent for nested steps, with arrow after indent. We'll produce similar style.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得 gas 與 cost 陣列長度 n // 獲取氣站數量\n→ Step 2: 初始化 total_surplus ← 0, current_surplus ← 0, start_index ← 0 // 初始化變數\n→ Step 3: 循環 i 從 0 到 n-1 // 逐個檢查氣站\n    → Step 3.1: total_surplus ← total_surplus + gas[i] - cost[i] // 計算總剩餘量\n    → Step 3.2: current_surplus ← current_surplus + gas[i] - cost[i] // 計算目前連續剩餘量\n    → Decision: current_surplus < 0? // 檢查目前剩餘是否不足\n        Yes → Step 3.3: start_index ← i + 1 // 重新設定起點為下一個氣站\n        Yes → Step 3.4: current_surplus ← 0 // 重置目前剩餘量\n        No  → // 目前剩餘足夠，繼續往後\n→ Decision: total_surplus >= 0? // 檢查總剩餘是否足以完成一圈\n    Yes → Step 4: 回傳 start_index // 成功，回傳起點\n    No  → Step 4: 回傳 -1 // 失敗，無法完成一圈\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        Greedy algorithm to find starting station.\n        total_surplus keeps track of overall gas minus cost.\n        current_surplus resets when it becomes negative, meaning we cannot\n        reach the next station from the current start.\n        \"\"\"\n        total_surplus = 0\n        current_surplus = 0\n        start_index = 0\n        n = len(gas)\n\n        for i in range(n):\n            diff = gas[i] - cost[i]\n            total_surplus += diff\n            current_surplus += diff\n\n            # If we cannot reach station i+1, restart from i+1\n            if current_surplus < 0:\n                start_index = i + 1\n                current_surplus = 0\n\n        return start_index if total_surplus >= 0 else -1\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract two integer lists from an input string like:\n    'gas = [1,2,3], cost = [4,5,6]'\n    \"\"\"\n    # Find all substrings inside square brackets\n    brackets = re.findall(r'\\[([^\\]]*)\\]', data)\n    if len(brackets) < 2:\n        return [], []\n\n    # Convert comma-separated values to int list\n    def to_int_list(text: str):\n        # Remove any spaces\n        items = [x.strip() for x in text.split(',') if x.strip()]\n        return list(map(int, items)) if items else []\n\n    gas = to_int_list(brackets[0])\n    cost = to_int_list(brackets[1])\n    return gas, cost\n\ndef main():\n    # Read all input from stdin\n    raw_data = sys.stdin.read()\n    if not raw_data.strip():\n        return\n\n    gas, cost = parse_input(raw_data)\n\n    # Edge case: if lists are empty or lengths differ, return -1\n    if len(gas) != len(cost) or not gas:\n        print(-1)\n        return\n\n    sol = Solution()\n    result = sol.canCompleteCircuit(gas, cost)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode540.json",
    "problem_index_in_file": 0,
    "title": "Single Element in a Sorted Array",
    "description_snippet": "You are given a sorted array consisting of only integers where every element appears exactly twice, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the problem: find unique element in sorted array where every element appears twice except one. Need O(log n) time, O(1) space. Use binary search: mid index; if mid is even, check mid+1 equals mid? if yes unique is after mid+1 else before mid. If mid odd, check mid-1. Implementation steps.\n\nWe must provide step-by-step with explanation.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 left = 0, right = length-1 // 設定搜尋範圍\n→ Decision: 左右是否相等? // 檢查是否只剩一個元素\n    Yes → Step 2: 返回 nums[left] // 這個元素就是唯一值\n    No → Step 3: 進入迴圈 // 開始二分搜尋\n→ Step 3: Start loop // 迭代直到找到唯一\n    → Step 4: mid = left + (right - left) / 2 // 計算中間索引\n    → Decision: mid % 2 == 0? // 判斷 mid 的奇偶性\n        Yes → Decision: nums[mid] == nums[mid+1]? // 若 mid 為偶數且其右鄰相同\n            Yes → Step 5: left = mid + 2 // 唯一元素在右半\n            No  → Step 6: right = mid - 1 // 唯一元素在左半\n        No  → Decision: nums[mid] == nums[mid-1]? // 若 mid 為奇數且其左鄰相同\n            Yes → Step 7: left = mid + 1 // 唯一元素在右半\n            No  → Step 8: right = mid - 2 // 唯一元素在左半\n    → Decision: left > right? // 搜尋結束條件\n        Yes → Step 9: 返回 nums[left] // 唯一元素位於 left\n        No  → Loop back to Step 4\nEnd // 程式結束\n\nBut we need to maintain arrow format: we need to show arrow lines \"→\" and \"Decision:\" lines.\n\nWe should format exactly as required: each line \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe also need to use arrow \"→\" for steps, and \"Decision:\" lines. Indent maybe not necessary. In example they had indent for nested decisions but we can use indentation with spaces or tabs but not mandatory.\n\nLet's create lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = nums.length - 1 // 設定搜尋範圍\n→ Decision: left == right? // 是否只剩一個元素\n    Yes → Step 2: 返回 nums[left] // 唯一元素已找到\n    No  → Step 3: 進入二分搜尋迴圈 // 開始搜尋\n→ Step 3: 開始 while loop // 迭代直到找到唯一元素\n    → Step 4: mid = left + (right - left) / 2 // 計算中間索引\n    → Decision: mid % 2 == 0? // mid 是偶數？\n        Yes → Decision: nums[mid] == nums[mid + 1]? // mid 與右鄰相同？\n            Yes → Step 5: left = mid + 2 // 唯一元素在右半\n            No  → Step 6: right = mid - 1 // 唯一元素在左半\n        No  → Decision: nums[mid] == nums[mid - 1]? // mid 與左鄰相同？\n            Yes → Step 7: left = mid + 1 // 唯一元素在右半\n            No  → Step 8: right = mid - 2 // 唯一元素在左半\n    → Decision: left > right? // 搜尋結束？\n        Yes → Step 9: 返回 nums[left] // 唯一元素\n        No  → 回到 Step 4 // 繼續迭代\nEnd // 程式執行結束\n\nWe need to check that we didn't use actual code. We used pseudo like \"返回 nums[left]\". It's okay because it's pseudo.\n\nBut we may need to maintain structure of Start, End.\n\nAlso \"Step 3: 進入二分搜尋迴圈\" maybe not needed; we can skip Step 3 and go directly to loop.\n\nLet's refine:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = nums.length - 1 // 初始化搜尋邊界\n→ Decision: left == right? // 若只剩一個元素\n    Yes → Step 2: return nums[left] // 那就是唯一元素\n    No  → Step 3: 進入二分搜尋 // 開始查找\n→ Step 3: while left <= right // 迭代條件\n    → Step 4: mid = left + (right - left) / 2 // 計算中間索引\n    → Decision: mid % 2 == 0? // mid 為偶數\n        Yes → Decision: nums[mid] == nums[mid + 1]? // 是否與右鄰相同\n            Yes → Step 5: left = mid + 2 // 唯一元素在右半\n            No  → Step 6: right = mid - 1 // 唯一元素在左半\n        No  → Decision: nums[mid] == nums[mid - 1]? // mid 為奇數，與左鄰比較\n            Yes → Step 7: left = mid + 1 // 唯一元素在右半\n            No  → Step 8: right = mid - 2 // 唯一元素在左半\n    → Decision: left > right? // 搜尋結束\n        Yes → Step 9: return nums[left] // 唯一元素\n        No  → 回到 Step 4 // 繼續迭代\nEnd // 程式結束\n\nBut we might not need to have while loop line separately; but it's fine.\n\nAlso need to note that we should avoid actual programming language constructs; but pseudo \"while\" is okay.\n\nWe should also not use \"return\" maybe but \"返回\" is fine.\n\nAlso \"回到 Step 4\" is okay.\n\nLet's produce final answer accordingly. Ensure each line ends with comment.\n\nCheck that each line has a space after code and before comment.\n\nAlso each decision line has \"Decision:\" and options. The options lines should be indented with 4 spaces or tab? In example, they had indentation with spaces. We'll use two spaces before \"Yes\" lines etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = nums.length - 1 // 初始化搜尋邊界  \n→ Decision: left == right? // 若只剩一個元素  \n Yes → Step 2: return nums[left] // 那就是唯一元素  \n No  → Step 3: 進入二分搜尋 // 開始查找  \n→ Step 3: while left <= right // 迭代條件  \n → Step 4: mid = left + (right - left) / 2 // 計算中間索引  \n → Decision: mid % 2 == 0? // mid 為偶數  \n  Yes → Decision: nums[mid] == nums[mid + 1]? // 與右鄰相同？  \n   Yes → Step 5: left = mid + 2 // 唯一元素在右半  \n   No  → Step 6: right = mid - 1 // 唯一元素在左半  \n  No  → Decision: nums[mid] == nums[mid - 1]? // mid 為奇數，與左鄰比較  \n   Yes → Step 7: left = mid + 1 // 唯一元素在右半  \n   No  → Step 8: right = mid - 2 // 唯一元素在左半  \n → Decision: left > right? // 搜尋結束？  \n  Yes → Step 9: return nums[left] // 唯一元素  \n  No  → 回到 Step 4 // 繼續迭代  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef single_non_duplicate(nums):\n    \"\"\"\n    Find the single element in a sorted array where every other element appears twice.\n    Uses binary search in O(log n) time and O(1) space.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        # Ensure mid is even to compare pairs correctly\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            # Pair is intact, unique element is to the right\n            left = mid + 2\n        else:\n            # Pair is broken, unique element is to the left (including mid)\n            right = mid\n    return nums[left]\n\ndef main():\n    # Read entire input from stdin and parse as a list\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums = ast.literal_eval(data)\n    result = single_non_duplicate(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,2,3,3,4,4,8,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[3,3,7,7,10,11,11]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode622.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Queue",
    "description_snippet": "Design your implementation of the circular queue. The circular queue is a linear data structure in w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementation of MyCircularQueue class. Should be step-by-step instructions. Likely we will describe initialization, data structure, pointers, operations. Each line with arrow and comment. Use \"Start\" \"End\". Decision blocks for empty/full. Provide steps in natural language but as virtual code.\n\nLet's produce:\n\nStart\n→ Step 1: 定義類別 MyCircularQueue // 建立類別\n→ Step 2: 宣告內部陣列 buffer of size k // 儲存元素\n→ Step 3: 設置 head = 0 // 指向前端\n→ Step 4: 設置 tail = 0 // 指向後端\n→ Step 5: 設置 count = 0 // 目前元素數\n→ Step 6: 將 k 存為 capacity // 最大容量\n\nThen methods: Front, Rear, enQueue, deQueue, isEmpty, isFull. For each, produce virtual code lines with decisions.\n\nLet's create each method step by step. Use Decision: and Yes/No branches.\n\nImportant: The format: each line starts with arrow. For start of method, maybe we can write:\n\n→ Method: Front() // 取得前端\n\nBut we need to keep consistent. Use \"→ Step: Method: Front()\". Let's keep.\n\nOk produce.\n\nMake sure each line has \" // \" explanation.\n\nAt end End.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MyCircularQueue // 建立類別  \n→ Step 2: 宣告內部陣列 buffer of size k // 用於儲存元素  \n→ Step 3: 設置 head = 0 // 指向前端位置  \n→ Step 4: 設置 tail = 0 // 指向後端位置  \n→ Step 5: 設置 count = 0 // 現有元素數量  \n→ Step 6: 設置 capacity = k // 最大容量  \n\n// --- Front() 方法 ---  \n→ Method: Front() // 取得前端元素  \n    → Decision: 如果 count = 0? // 判斷是否為空  \n        Yes → Return -1 // 空時回傳 -1  \n        No  → Return buffer[head] // 否則回傳前端值  \n\n// --- Rear() 方法 ---  \n→ Method: Rear() // 取得後端元素  \n    → Decision: 如果 count = 0? // 判斷是否為空  \n        Yes → Return -1 // 空時回傳 -1  \n        No  → Return buffer[(tail - 1 + capacity) mod capacity] // 後端值  \n\n// --- enQueue(value) 方法 ---  \n→ Method: enQueue(value) // 插入元素  \n    → Decision: 如果 count = capacity? // 判斷是否已滿  \n        Yes → Return False // 失敗回傳 False  \n        No  →  \n            → Assign buffer[tail] = value // 將值寫入後端  \n            → Update tail = (tail + 1) mod capacity // 移動後端指標  \n            → Increment count = count + 1 // 元素數增加  \n            → Return True // 成功回傳 True  \n\n// --- deQueue() 方法 ---  \n→ Method: deQueue() // 刪除元素  \n    → Decision: 如果 count = 0? // 判斷是否為空  \n        Yes → Return False // 失敗回傳 False  \n        No  →  \n            → Update head = (head + 1) mod capacity // 移動前端指標  \n            → Decrement count = count - 1 // 元素數減少  \n            → Return True // 成功回傳 True  \n\n// --- isEmpty() 方法 ---  \n→ Method: isEmpty() // 判斷是否空  \n    → Return count = 0 // 若 count 為 0 則為空  \n\n// --- isFull() 方法 ---  \n→ Method: isFull() // 判斷是否滿  \n    → Return count = capacity // 若 count 等於容量則為滿  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyCircularQueue:\n    def __init__(self, k):\n        self.queue = [0] * k\n        self.head = self.tail = -1\n        self.size = k\n\n    def enQueue(self, value):\n        if self.isFull():\n            return False\n        if self.isEmpty():\n            self.head = 0\n        self.tail = (self.tail + 1) % self.size\n        self.queue[self.tail] = value\n        return True\n\n    def deQueue(self):\n        if self.isEmpty():\n            return False\n        if self.head == self.tail:\n            self.head = self.tail = -1\n        else:\n            self.head = (self.head + 1) % self.size\n        return True\n\n    def Front(self):\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self):\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self):\n        return self.head == -1\n\n    def isFull(self):\n        return (self.tail + 1) % self.size == self.head\n\n\nif __name__ == \"__main__\":\n    # Read the whole input, split into two lines\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    # Parse operations and arguments (JSON format)\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    results = []\n    obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"MyCircularQueue\":\n            obj = MyCircularQueue(*args)\n            results.append(None)  # null in JSON\n        elif op == \"enQueue\":\n            results.append(obj.enQueue(args[0]))\n        elif op == \"deQueue\":\n            results.append(obj.deQueue())\n        elif op == \"Front\":\n            results.append(obj.Front())\n        elif op == \"Rear\":\n            results.append(obj.Rear())\n        elif op == \"isEmpty\":\n            results.append(obj.isEmpty())\n        elif op == \"isFull\":\n            results.append(obj.isFull())\n        else:\n            # Unsupported operation; append None\n            results.append(None)\n\n    # Output results in JSON format (null, true, false)\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"Rear\", \"isFull\", \"deQueue\", \"enQueue\", \"Rear\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 3, true, true, true, 4]",
          "success": true,
          "output": "[null, true, true, true, false, 3, true, true, true, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode22.json",
    "problem_index_in_file": 0,
    "title": "Generate Parentheses",
    "description_snippet": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parenthes...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for generating all combinations of well-formed parentheses for n pairs. Provide step-by-step pseudocode, each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision:, arrow notation. Should cover recursion/backtracking. Use virtual code, not actual code. Need to output line by line.\n\nLet's craft pseudocode:\n\nStart\n→ Step 1: 定義函式 Generate(n) // 入口函式\n→ Step 2: 初始化結果列表 results = [] // 存放所有合法字串\n→ Step 3: 呼叫 Backtrack(空字串, open=0, close=0, n, results) // 開始回溯\n→ Step 4: 回傳 results // 返回所有組合\n→ Step 5: End\n\nDefine Backtrack(string current, int open, int close, int n, list results)\n→ Decision: 如果 open==n and close==n? // 完全生成\n    Yes → Step: 把 current 加入 results // 添加完成的字串\n    No  → Decision: 如果 open < n? // 仍可加 '('\n        Yes → Step: 呼叫 Backtrack(current + '(', open+1, close, n, results) // 加左括號\n        No  → Decision: 如果 close < open? // 仍可加 ')'\n            Yes → Step: 呼叫 Backtrack(current + ')', open, close+1, n, results) // 加右括號\n            No  → Step: return // 不能再加任何括號\n\nBut need structure: maybe use nested Decision. Each line with arrow.\n\nLet's produce lines.\n\nWe need to keep proper indentation maybe with spaces. Use \"Decision:\" lines and \"Yes →\" \"No →\".\n\nLet's write.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義函式 Generate(n) // 入口函式\n→ Step 2: 初始化 results = [] // 用於存放所有合法字串\n→ Step 3: 呼叫 Backtrack(\"\", 0, 0, n, results) // 開始回溯生成\n→ Step 4: 回傳 results // 返回結果集合\n→ End // 程式結束\n```\n\nNow define Backtrack:\n\n```\nStart // Backtrack 函式開始\n→ Decision: 是否 open == n 且 close == n? // 檢查是否已生成完整字串\n    Yes → Step: results.append(current) // 將完整字串加入結果\n    No  → Decision: open < n? // 可以再加 '('\n        Yes → Step: Backtrack(current + \"(\", open + 1, close, n, results) // 加左括號\n        No  → Decision: close < open? // 可以再加 ')'\n            Yes → Step: Backtrack(current + \")\", open, close + 1, n, results) // 加右括號\n            No  → Step: return // 無法再加任何括號，回到上一層\n→ End // Backtrack 函式結束\n```\n\nBut we need to output as a single pseudo-code? Could combine both parts sequentially. We need each line with arrow and comment.\n\nWe should list the lines as separate items, maintain the structure. The instructions: \"逐行輸出\", each line must contain virtual code step and explanation. Use arrow notation.\n\nThus we need to produce the full algorithm in one block? The example shows continuous lines with arrows and decisions. So we produce the pseudocode lines in order.\n\nLet's produce final answer with lines.\n\nWe'll include start of algorithm, define Generate, call Backtrack, etc. We'll also include the definition of Backtrack. We'll use indentation but still each line separate.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 Generate(n) // 入口函式，接收括號對數 n  \n→ Step 2: 初始化 results = [] // 用於存放所有合法的字串  \n→ Step 3: 呼叫 Backtrack(\"\", 0, 0, n, results) // 開始回溯生成  \n→ Step 4: 回傳 results // 返回所有組合  \n→ End // 程式結束  \n\nStart // Backtrack 函式開始  \n→ Decision: open == n 且 close == n? // 檢查是否已生成完整字串  \n  Yes → Step: results.append(current) // 將完整字串加入結果  \n  No  → Decision: open < n? // 還可再加 '('  \n    Yes → Step: Backtrack(current + \"(\", open + 1, close, n, results) // 加左括號  \n    No  → Decision: close < open? // 還可再加 ')'  \n     Yes → Step: Backtrack(current + \")\", open, close + 1, n, results) // 加右括號  \n     No  → Step: return // 無法再加任何括號，回到上一層  \n→ End // Backtrack 函式結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def generateParenthesis(self, n: int):\n        res = []\n\n        def backtrack(s=\"\", left=0, right=0):\n            if len(s) == 2 * n:\n                res.append(s)\n                return\n            if left < n:\n                backtrack(s + \"(\", left + 1, right)\n            if right < left:\n                backtrack(s + \")\", left, right + 1)\n\n        backtrack()\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入並提取第一個整數作為 n\n    data = sys.stdin.read()\n    match = re.search(r\"\\d+\", data)\n    if match:\n        n = int(match.group())\n    else:\n        n = 0  # 若沒有找到數字，預設為 0\n\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n\n    # 輸出 JSON 格式的列表，以符合範例輸出\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
          "success": true,
          "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[\"()\"]",
          "success": true,
          "output": "[\"()\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode217.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate",
    "description_snippet": "Given an integer array nums, return true if any value appears at least twice in the array, and retur...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for checking duplicates. Provide line by line with arrow. Use Start, End. Use Decision, Step. Provide explanation after //.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize an empty set seen // 用來記錄已見過的值\n→ For each num in nums:\n    → Decision: If num in seen? // 檢查是否已存在\n        Yes → Step 2: Return true // 找到重複，直接回傳\n        No  → Step 3: Add num to seen // 未見過，加入集合\n→ Step 4: Return false // 全部遍歷完仍無重複\n\nWe need to use arrow for loop? Might just use \"→ For each num in nums:\" arrow? But they want structure? Might do \"→ Step 2: For each num in nums:\" but it's a loop.\n\nLet's produce each line:\n\nStart // 程式開始執行\n→ Step 1: Initialize empty set seen // 建立一個集合來記錄已出現的元素\n→ Step 2: For each num in nums: // 逐個遍歷陣列中的數字\n    → Decision: If num in seen? // 判斷此數字是否已經在集合中\n        Yes → Step 3: Return true // 發現重複元素，回傳 true\n        No  → Step 4: Add num to seen // 沒有重複，將數字加入集合\n→ Step 5: Return false // 所有元素都遍歷完且未發現重複，回傳 false\nEnd // 程式執行結束\n\nWe need arrow for each step: use \"→\" at beginning. For Decision we indent.\n\nWe must not output actual code. It's fine.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空集合 seen // 建立一個集合用於存儲已出現的元素\n→ Step 2: 對 nums 中的每個 num 進行迭代 // 逐個檢查陣列中的數字\n    → Decision: 如果 num 已存在於 seen? // 判斷此數字是否已經重複\n        Yes → Step 3: 回傳 true // 發現重複，立即返回 true\n        No  → Step 4: 將 num 加入 seen // 未重複，將此數字記錄進集合\n→ Step 5: 回傳 false // 所有數字遍歷完且未發現重複，返回 false\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef contains_duplicate(nums):\n    \"\"\"\n    判斷陣列中是否存在重複元素。\n    使用集合來記錄已出現的值，若再次遇到同一值則直接回傳 True。\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入為 list\n    # 若輸入格式為 'nums = [1,2,3]'，取等號右側作為 list 表達式\n    if '=' in data:\n        _, right = data.split('=', 1)\n        expr = right.strip()\n    else:\n        expr = data.strip()\n\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        # 若解析失敗，假設輸入為空格分隔的整數\n        nums = list(map(int, expr.split()))\n\n    result = contains_duplicate(nums)\n    # 根據題目要求輸出 'true' 或 'false'\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode389.json",
    "problem_index_in_file": 0,
    "title": "Find the Difference",
    "description_snippet": "You are given two strings s and t.\n\nString t is generated by random shuffling string s and then add ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, each with \"虛擬碼步驟\" and // explanation. Using arrows and decision etc.\n\nTask: Given s and t, where t is shuffled s plus one extra letter. Find that added letter.\n\nWe can use approach: count frequency or sum ASCII.\n\nSimplify: Use frequency difference or XOR.\n\nWe'll produce pseudocode:\n\nStart\n→ Step 1: Initialize freq[26] = 0 // array for letter counts\n→ Step 2: For each char in s: freq[char]++ // count s letters\n→ Step 3: For each char in t: freq[char]-- // subtract t letters\n→ Step 4: For each index i in 0..25: if freq[i] != 0 → Step 5: return corresponding letter // found added letter\n\nAlternate approach: sum of ASCII.\n\nBut we'll go with frequency method.\n\nNeed to use virtual code arrow syntax.\n\nInclude decisions? Not necessary but can.\n\nWe can also use XOR: sum of char codes.\n\nBut frequency is more explicit.\n\nWe'll produce:\n\nStart\n→ Step 1: Define array count[26] all zero // frequency array\n→ Step 2: For each ch in s: count[ index(ch) ] = count[ index(ch) ] + 1 // count s\n→ Step 3: For each ch in t: count[ index(ch) ] = count[ index(ch) ] - 1 // subtract t\n→ Step 4: Decision: 是否存在 count[i] ≠ 0? // check if any count not zero\n    Yes → Step 5: return character corresponding to that index // added letter\n    No  → Step 6: return null // should not happen\n\nEnd\n\nAdd arrows.\n\nLet's produce each line accordingly. Ensure each line has \"// 解釋\".\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Define array count[26] all zero // 建立 26 個字母的頻率表\n→ Step 2: For each character ch in s: count[ index(ch) ] = count[ index(ch) ] + 1 // 統計 s 中每個字母出現的次數\n→ Step 3: For each character ch in t: count[ index(ch) ] = count[ index(ch) ] - 1 // 把 t 的字母次數減去，與 s 的統計相抵消\n→ Step 4: Decision: 是否存在 count[i] ≠ 0? // 檢查頻率表中是否有剩餘\n    Yes → Step 5: return character corresponding to that index // 找到非零項即為多出的字母\n    No  → Step 6: return null // 理論上不會發生，表示輸入不合法\nEnd // 程式執行結束\n\nMake sure formatting: each line has arrow arrow.\n\nUse \"→\" for steps, and \"Decision:\" for decision.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Define array count[26] all zero // 建立 26 個字母的頻率表\n→ Step 2: For each character ch in s: count[ index(ch) ] = count[ index(ch) ] + 1 // 統計 s 中每個字母出現的次數\n→ Step 3: For each character ch in t: count[ index(ch) ] = count[ index(ch) ] - 1 // 把 t 的字母次數減去，與 s 的統計相抵消\n→ Step 4: Decision: 是否存在 count[i] ≠ 0? // 檢查頻率表中是否有剩餘\n    Yes → Step 5: return character corresponding to that index // 找到非零項即為多出的字母\n    No  → Step 6: return null // 理論上不會發生，表示輸入不合法\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        \"\"\"\n        找出在 t 中比 s 多出的一個字母。\n        使用 Counter 逐字母扣減，剩下的字母即為答案。\n        \"\"\"\n        cnt = Counter(s)\n        for ch in t:\n            if cnt[ch] == 0:          # 若 s 沒有此字母，直接返回\n                return ch\n            cnt[ch] -= 1\n        return ''  # 理論上不會到這裡\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 先嘗試匹配「s = \"abcd\", t = \"abcde\"」這種格式\n    pattern = r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*t\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, raw_input)\n\n    if match:\n        s_val = match.group(1)\n        t_val = match.group(2)\n    else:\n        # 若輸入為兩行分別給 s 與 t，或其他簡單格式，直接處理\n        parts = raw_input.splitlines()\n        if len(parts) >= 2:\n            s_val = parts[0].strip()\n            t_val = parts[1].strip()\n        else:\n            # 仍然嘗試把所有字串做簡單拆分\n            s_val = ''\n            t_val = raw_input\n\n    solution = Solution()\n    answer = solution.findTheDifference(s_val, t_val)\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "success": true,
          "output": "e"
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "success": true,
          "output": "y"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode75.json",
    "problem_index_in_file": 0,
    "title": "Sort Colors",
    "description_snippet": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for Dutch national flag problem. We produce step-by-step pseudocode, no real code, each line with arrow and comment. Use Start, End, Decision, Step, Yes →, No →. Provide for array nums, n. We need to sort in-place with O(1) space, O(n). Use pointers: low, mid, high. While mid <= high: if nums[mid]==0, swap low, mid; low++; mid++; elif 1: mid++; else: swap mid, high; high--. We'll provide pseudocode accordingly.\n\nNeed to be line by line. Provide explanations after //.\n\nMake sure arrow formatting: \"→ Step ...\". Also Decision lines with Yes →, No →.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 low = 0, mid = 0, high = n-1 // 建立三個指標，分別指向紅、白、藍區塊的邊界  \n→ Decision: while mid <= high? // 只要中指標未超過高指標，就持續處理  \n  Yes → Step 2: 取得 nums[mid] 的值 // 讀取當前元素的顏色  \n  Decision: 如果 nums[mid] == 0? // 若為紅色  \n    Yes → Step 3: 交換 nums[low] 與 nums[mid] // 把紅色放到最左邊  \n       low++; mid++; // 移動 low 與 mid 指標向右  \n    No → Decision: 如果 nums[mid] == 1? // 若為白色  \n      Yes → Step 4: mid++; // 白色已處於正確位置，僅前進 mid  \n      No → Step 5: 交換 nums[mid] 與 nums[high] // 把藍色放到最右邊  \n         high--; // 高指標左移，因為 mid 位置已交換，需要再次檢查  \n         // mid 不變，因為新交換進來的元素尚未判斷  \n  No → End // 循環結束，所有元素已排序完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def sortColors(self, nums):\n        \"\"\"\n        Sorts the list `nums` in-place so that all 0s come first, then 1s, then 2s.\n        Uses the Dutch national flag algorithm with three pointers.\n        \"\"\"\n        low, mid, high = 0, 0, len(nums) - 1\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:  # nums[mid] == 2\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # The input is expected to be something like: \"nums = [2,0,1]\"\n    # Extract the list part between '[' and ']'\n    try:\n        start = data.index('[')\n        end = data.index(']', start) + 1\n        nums_str = data[start:end]\n        nums = ast.literal_eval(nums_str)\n    except (ValueError, SyntaxError):\n        # If parsing fails, exit silently\n        sys.exit()\n\n    # Sort the colors\n    Solution().sortColors(nums)\n\n    # Output the sorted list\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,0,2,1,1,0]",
          "expected_output": "[0,0,1,1,2,2]",
          "success": true,
          "output": "[0, 0, 1, 1, 2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,0,1]",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode378.json",
    "problem_index_in_file": 0,
    "title": "K^th Smallest Element in a Sorted Matrix",
    "description_snippet": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations for solution: find k-th smallest in sorted matrix (rows and columns ascending). Need memory better than O(n^2). Standard solution: use binary search on value range with count of <= mid. Complexity O(n log(max-min)). Or use min-heap O(k log n). Memory O(n). We'll produce virtual code accordingly.\n\nLet's produce steps: Start; input matrix, n, k; determine low=matrix[0][0], high=matrix[n-1][n-1]; while low<high: mid=low + (high-low)//2; count = count_less_equal(matrix, mid); if count < k: low = mid+1 else high = mid; End; Output low. Need count function: count numbers <= mid by iterating each row starting from rightmost column. Complexity O(n^2) for counting but overall O(n log). But can count by binary search per row O(n log n). But easier: count in O(n^2). Memory O(1). Provide pseudocode.\n\nWe'll produce virtual steps with arrows. Let's produce.\n\nAlso can mention decision: if low<high loop. Provide count subroutine.\n\nLet's output lines accordingly. Ensure each line ends with comment.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入矩陣 A、大小 n 以及目標位置 k // 從使用者處取得輸入  \n→ Step 2: 設定 low = A[0][0] // 最小值  \n→ Step 3: 設定 high = A[n-1][n-1] // 最大值  \n→ Decision: low < high? // 判斷搜尋區間是否已縮小到單一值  \n    Yes → Step 4: 計算 mid = low + (high - low) // 取中間值，避免溢位  \n    → Step 5: 呼叫 CountLessEqual(A, mid) → 回傳 count // 取得 <= mid 的元素數量  \n    → Decision: count < k? // 若數量少於 k，答案在更大值區域  \n        Yes → Step 6: 設定 low = mid + 1 // 重新搜尋右半區間  \n        No  → Step 7: 設定 high = mid // 重新搜尋左半區間  \n    → Decision: low < high? // 重複 binary search 迴圈  \n        Yes → 回到 Step 4  \n        No  → End // binary search 完成  \n→ Step 8: 輸出 low // low 即為第 k 小的元素  \nEnd // 程式執行結束  \n\n// CountLessEqual 子程序  \nStart_Count // 子程序開始  \n→ Step C1: 設定 total = 0  \n→ Step C2: 針對每一行 r 從 0 到 n-1  \n    → Step C2a: 設定 col = n - 1 // 從最右邊開始  \n    → Decision: col >= 0 且 A[r][col] > mid? // 只要比 mid 大就往左移  \n        Yes → Step C2b: col = col - 1 // 向左移動  \n        No  → Step C2c: total = total + col + 1 // 所有列到 col 的元素 <= mid  \n→ Step C3: 回傳 total  \nEnd_Count // 子程序結束  \n\n// 以上虛擬碼使用 O(n log(max-min)) 時間與 O(1) 附加空間，符合記憶體複雜度優於 O(n^2) 的需求。",
      "generated_code": "import sys\nimport re\nimport ast\nimport heapq\n\ndef kth_smallest(matrix, k):\n    \"\"\"使用最小堆找出矩陣中第 k 小的元素。\"\"\"\n    n = len(matrix)\n    # 堆中存放 (值, 行, 列)\n    heap = [(matrix[i][0], i, 0) for i in range(n)]\n    heapq.heapify(heap)\n\n    # 抽取 k-1 次最小元素，最後一次 pop 的元素即為第 k 小\n    for _ in range(k - 1):\n        val, r, c = heapq.heappop(heap)\n        if c + 1 < n:\n            heapq.heappush(heap, (matrix[r][c + 1], r, c + 1))\n    return heapq.heappop(heap)[0]\n\ndef parse_input(text):\n    \"\"\"\n    解析形如\n        matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    的字串，回傳 matrix 與 k。\n    \"\"\"\n    # 使用正則找出 matrix 與 k 的部分\n    m = re.search(r\"matrix\\s*=\\s*(\\[[\\s\\S]*?\\])\\s*,\\s*k\\s*=\\s*(\\d+)\", text)\n    if not m:\n        raise ValueError(\"輸入格式錯誤\")\n    matrix_str = m.group(1)\n    k_str = m.group(2)\n    matrix = ast.literal_eval(matrix_str)\n    k = int(k_str)\n    return matrix, k\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入得到 matrix 與 k\n    matrix, k = parse_input(data)\n\n    # 計算第 k 小的元素並輸出\n    result = kth_smallest(matrix, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "success": true,
          "output": "13"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "success": true,
          "output": "-5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode164.json",
    "problem_index_in_file": 0,
    "title": "Maximum Gap",
    "description_snippet": "Given an integer array nums, return the maximum difference between two successive elements in its so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for maximum gap in sorted array, linear time, linear space. Use bucket sort (Pigeonhole). Steps: handle edge cases, find min max, compute bucket size, bucket count, init buckets with min/max per bucket. Iterate to fill buckets, compute max gap between non-empty buckets. Output. Provide line by line virtual code with explanations. Let's write.\n\nNeed to ensure \"Start\" \"End\" and \"Decision\" usage. Provide arrow lines. We'll produce steps with names: Step 1: check length. Step 2: find min and max. Step 3: if min==max return 0. Step 4: compute bucket size = max(1, (max-min)/(n-1)). Step 5: bucket count = (max-min)/bucket_size + 1. Step 6: init arrays minBucket[], maxBucket[], set minBucket to INF, maxBucket to -INF. Step 7: iterate nums to assign to bucket. Step 8: compute max gap scanning buckets. Step 9: return max_gap.\n\nAlso decision for len<2: Yes -> return 0. Also if min==max: Yes -> return 0.\n\nAlso inside bucket assignment: skip if value == min or max? Actually they are handled in gap calculation. Implementation detail: just assign.\n\nOk produce lines with explanation.\n\nUse arrow \"→\". Provide indentation for decisions. Let's craft.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 檢查陣列長度是否小於 2 // 若不足兩個元素則無法計算差距\n    Yes → Step 2: 回傳 0 // 直接結束\n    No  // 繼續執行\n→ Step 3: 迭代 nums 找出全域最小值 min 和最大值 max // 用於 bucket 範圍計算\n→ Decision: 如果 min 與 max 相同? // 所有元素相同，最大差為 0\n    Yes → Step 4: 回傳 0\n    No  // 繼續執行\n→ Step 5: 計算 bucket 容量 bucketSize = max(1, ⌊(max - min) / (n - 1)⌋) // 保證至少 1，避免除以零\n→ Step 6: 計算 bucket 數量 bucketCount = ⌊(max - min) / bucketSize⌋ + 1 // 覆蓋整個範圍\n→ Step 7: 初始化兩個陣列 minBucket[0..bucketCount-1] 為 +∞，maxBucket[0..bucketCount-1] 為 -∞ // 用於紀錄每個 bucket 的極值\n→ Step 8: 迭代 nums，對每個 value 進行 bucket 位置 idx = ⌊(value - min) / bucketSize⌋\n    → 更新 minBucket[idx] = min(minBucket[idx], value) // 取 bucket 中最小值\n    → 更新 maxBucket[idx] = max(maxBucket[idx], value) // 取 bucket 中最大值\n→ Step 9: 初始化 prev = min，maxGap = 0 // prev 追蹤上一個非空 bucket 的最大值\n→ Step 10: 從第 0 個 bucket 開始掃描\n    → Decision: bucket 空? // 仍為 +∞ 或 -∞ 表示無數值\n        Yes → Skip 本 bucket\n        No  // 有數值，計算 gap\n            → Step 11: 計算 gap = minBucket[idx] - prev // 從上一個非空 bucket 的最大值到現在 bucket 的最小值\n            → Step 12: maxGap = max(maxGap, gap) // 更新最大差距\n            → Step 13: prev = maxBucket[idx] // 更新 prev 為本 bucket 的最大值\n→ Step 14: 回傳 maxGap // 最大差距已計算完成\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\n\nclass Solution:\n    def maximumGap(self, nums):\n        n = len(nums)\n        if n < 2:\n            return 0\n\n        # 取得全域最小值與最大值\n        min_val = min(nums)\n        max_val = max(nums)\n\n        # 所有數字相同時最大差距為 0\n        if min_val == max_val:\n            return 0\n\n        # bucket 的大小與數量\n        bucket_size = max(1, (max_val - min_val) // (n - 1))\n        bucket_count = (max_val - min_val) // bucket_size + 1\n\n        # 兩個 bucket 陣列：minBucket、maxBucket\n        min_bucket = [math.inf] * bucket_count\n        max_bucket = [-math.inf] * bucket_count\n\n        # 將每個數值放進對應的 bucket\n        for value in nums:\n            idx = (value - min_val) // bucket_size\n            min_bucket[idx] = min(min_bucket[idx], value)\n            max_bucket[idx] = max(max_bucket[idx], value)\n\n        # 計算最大差距\n        prev = min_val\n        max_gap = 0\n        for i in range(bucket_count):\n            if min_bucket[i] == math.inf:  # bucket 仍為空\n                continue\n            max_gap = max(max_gap, min_bucket[i] - prev)\n            prev = max_bucket[i]\n\n        return max_gap\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 取得所有整數（含負號）\n    import re\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    result = sol.maximumGap(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [10]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode350.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays II",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps with arrows, decisions, and explanation. The requirement: two integer arrays nums1, nums2, return intersection array. Each element appears as many times as it shows in both arrays. Order can be any.\n\nWe need to output step-by-step pseudo-code, not actual code.\n\nLet's produce Start, maybe Build hash map count for nums1, then iterate nums2, build result. Could also use sorting approach. But simple hash map.\n\nWe need to show steps:\n\nStart\n→ Step 1: Build frequency map of nums1 // Count occurrences\n→ Step 2: Initialize result array // To store intersection\n→ Decision: For each element num in nums2\n   -> Check if num exists in map and count > 0\n        Yes → Add num to result // add intersection\n              → Decrement map count\n        No → Continue // skip\n→ End\n\nBut need to adhere to format: \"虛擬碼步驟\" plus explanation.\n\nUse \"Start\" and \"End\". Use \"Decision:\" with Yes/No.\n\nAlso include loops: \"→ For each element num in nums2: ...\" but maybe break down into steps: \"→ Decision: For each num in nums2?\".\n\nBetter structure: After building map, we iterate over nums2: for each num, if map contains and >0 then add and decrement.\n\nPseudo code:\n\nStart // 程式開始執行\n→ Step 1: Initialize empty map freq // 用於記錄 nums1 中各數字的頻率\n→ Step 2: For each num in nums1: // 逐一計數\n    → Increment freq[num] // 若存在則+1，否則設為1\n→ Step 3: Initialize empty list result // 存放交集結果\n→ Step 4: For each num in nums2: // 逐一檢查\n    → Decision: 是否在 freq 且 freq[num] > 0? // 判斷是否仍有可配對\n        Yes → Step 5: Add num to result // 把此數字加入結果\n              → Step 6: Decrement freq[num] // 減一，避免重複配對\n        No  → Step 7: Continue // 不符合條件，跳過\n→ End // 程式執行結束\n\nMake sure each line contains arrow. For loops we can indent. Use \"Decision:\" lines with Yes→ and No→. Provide explanation.\n\nWe should also show \"→ For each num in nums1:\" maybe we need arrow then Decision? But we can use nested steps with indentation as in example.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: freq ← empty map // 用於記錄 nums1 的頻率\n→ Step 2: For each num in nums1: // 逐一計數\n    → freq[num] ← freq[num] + 1 // 1 增加計數\n→ Step 3: result ← empty list // 存放交集\n→ Step 4: For each num in nums2: // 逐一檢查\n    → Decision: 是否 freq 內存在 num 且 freq[num] > 0? // 判斷是否仍可配對\n        Yes → Step 5: Append num to result // 加入結果\n              → Step 6: freq[num] ← freq[num] - 1 // 減一\n        No  → Step 7: // 不做任何事，繼續下一個數字\n→ End // 程式執行結束\n\nMake sure each line has explanation after //. For lines inside decisions, indent with spaces? In example, they used tab indentation: \"→ Decision:\" then lines with \"Yes →\" etc. Use same.\n\nEnsure no actual code. Only pseudo steps. Provide in Chinese.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: freq ← empty map // 用於記錄 nums1 中每個數字的出現頻率\n→ Step 2: For each num in nums1: // 逐一遍歷 nums1\n    → freq[num] ← freq[num] + 1 // 若已存在則加一，否則初始化為 1\n→ Step 3: result ← empty list // 用於儲存交集結果\n→ Step 4: For each num in nums2: // 逐一遍歷 nums2\n    → Decision: 是否 freq 中存在 num 且 freq[num] > 0? // 判斷是否仍有可配對的出現次數\n        Yes → Step 5: Append num to result // 把此數字加入交集結果\n              → Step 6: freq[num] ← freq[num] - 1 // 減少該數字的剩餘頻率\n        No  → Step 7: // 無需處理，直接繼續下一個數字\n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"Return the intersection of two integer arrays with multiplicities.\"\"\"\n        c1, c2 = Counter(nums1), Counter(nums2)\n        res = []\n        for num in c1:\n            if num in c2:\n                res.extend([num] * min(c1[num], c2[num]))\n        return res\n\ndef main():\n    # Read the entire input from stdin\n    data = sys.stdin.read()\n    \n    # Find the two list literals in the input\n    matches = re.findall(r'\\[([^\\]]*)\\]', data)\n    \n    # Parse the first list (nums1)\n    if len(matches) > 0 and matches[0].strip():\n        nums1 = [int(x.strip()) for x in matches[0].split(',')]\n    else:\n        nums1 = []\n    \n    # Parse the second list (nums2)\n    if len(matches) > 1 and matches[1].strip():\n        nums2 = [int(x.strip()) for x in matches[1].split(',')]\n    else:\n        nums2 = []\n    \n    # Compute the intersection\n    solution = Solution()\n    result = solution.intersect(nums1, nums2)\n    \n    # Print the result as a JSON array (no spaces)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "success": true,
          "output": "[4, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode691.json",
    "problem_index_in_file": 0,
    "title": "Stickers to Spell Word",
    "description_snippet": "We are given n different types of stickers. Each sticker has a lowercase English word on it.\nYou wou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for the problem: given list of stickers (words) and target string. We can use each sticker multiple times (infinite supply). Need minimal number of stickers to form target by cutting letters from stickers. Equivalent to \"Sticker to Spell Word\" problem from Leetcode. Standard solution: use bitmask DP or BFS over states or recursion with memo + bitmask, or backtracking with memoization. Since we need produce pseudocode, not actual code. We need step-by-step pseudocode. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision.\n\nWe can produce pseudocode: Start → preprocess stickers: compute letter count array for each sticker. Then define recursive function minStickers(remain) with memo. Base case: if remain empty return 0. For each sticker, choose one that has at least one letter from remain. Compute new remain by subtracting. Recursively compute cost. Keep min. If no sticker can progress, return Infinity. After loop, store in memo and return min+1. Finally if result infinite → -1 else return result.\n\nWe can present pseudocode in lines.\n\nNeed to be careful about \"逐行\" each line with arrow \"→\" or \"Start\" etc. Provide explanation after each line.\n\nWe can structure:\n\nStart // Program begins\n→ Preprocess stickers into letter count array // convert each sticker into 26-length array counts\n→ Define memo map // store results for remaining strings\n→ Function MinStickers(remain) // recursive\n    → Decision: if remain empty? // check if target fully formed\n        Yes → Return 0 // no more stickers needed\n        No  → Decision: if remain in memo? // check cache\n            Yes → Return memo[remain] // reuse cached result\n            No  → Set best = Infinity\n            → For each stickerCount in stickerCounts: // iterate stickers\n                → Decision: if stickerCount can reduce remain? // at least one letter matches\n                    Yes →\n                        → Compute newRemain by subtracting counts\n                        → Call MinStickers(newRemain) → res\n                        → Decision: if res != Infinity? // valid path\n                            Yes → Update best = min(best, res + 1)\n                        → No → continue\n                → No → continue\n            → Decision: if best == Infinity? // no solution\n                Yes → memo[remain] = Infinity\n                No  → memo[remain] = best\n            → Return memo[remain]\n→ End Function\n→ Call MinStickers(target) → result\n→ Decision: if result == Infinity? // impossible\n    Yes → Return -1\n    No  → Return result\nEnd // Program ends\n\nWe need to ensure each line uses \"→\" for indentation. Also \"Decision:\" lines with Yes → and No →. Each line includes \"// explanation\". Provide explanation after space.\n\nAlso need to show arrow for recursion calls. But we can include \"→ Call MinStickers(newRemain) → res\" etc.\n\nMake sure each line is separate.\n\nAlso, for \"Decision: if remain empty?\" we need to indent subsequent lines; maybe using \"→\" before each line. But the example shows indentation by spaces: they used \"    Yes →\" lines inside decision. So we can follow that.\n\nLet's craft final answer with proper formatting. Use \"Start\", \"End\". Use \"→\" for steps.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Preprocess stickers into 26‑letter count arrays // 把每張貼紙轉成 26 個字母頻數的向量，方便計算  \n→ Initialize memo map // 用來快取已計算的子問題答案，避免重複計算  \n\n→ Function MinStickers(remain) // 定義遞迴函式，參數為尚未完成的字串  \n    → Decision: 是否為空字串? // 檢查是否已拼完目標  \n        Yes → Return 0 // 無需再使用貼紙  \n        No  → Decision: 是否已在 memo 中? // 若已計算過，直接回傳  \n            Yes → Return memo[remain] // 回傳快取結果  \n            No  → Set best = Infinity // 初始化最小貼紙數  \n\n            → For each stickerCount in stickerCounts: // 遍歷所有貼紙  \n                → Decision: 這張貼紙能否減少 remain? // 至少有一個字母可用  \n                    Yes →  \n                        → Compute newRemain by subtracting stickerCount from remain // 生成新的未完成字串  \n                        → Call MinStickers(newRemain) → res // 重新遞迴  \n                        → Decision: res != Infinity? // 路徑可行  \n                            Yes → Update best = min(best, res + 1) // 加上這張貼紙  \n                            No  → // 跳過，因為無法進一步完成  \n                    No  → // 這張貼紙無法使用，直接繼續  \n\n            → Decision: best 仍為 Infinity? // 若沒有任何貼紙能推進  \n                Yes → memo[remain] = Infinity // 記錄無解  \n                No  → memo[remain] = best // 記錄最小貼紙數  \n            → Return memo[remain] // 回傳此子問題的結果  \n\nEnd Function // 結束遞迴函式  \n\n→ Call MinStickers(target) → result // 從目標字串開始遞迴求解  \n→ Decision: result == Infinity? // 是否無法完成拼字  \n    Yes → Return -1 // 任務不可完成  \n    No  → Return result // 最小貼紙數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def minStickers(self, stickers, target):\n        # Precompute letter counts for each sticker\n        sticker_counts = [Counter(sticker) for sticker in stickers]\n        memo = {}\n\n        def dp(remaining):\n            if not remaining:\n                return 0\n            if remaining in memo:\n                return memo[remaining]\n\n            remaining_count = Counter(remaining)\n            best = float('inf')\n            for sc in sticker_counts:\n                # Quick check: sticker must contain at least one needed letter\n                if not (set(sc) & set(remaining)):\n                    continue\n                # Build new remaining string after using this sticker\n                new_remaining = []\n                for ch, cnt in remaining_count.items():\n                    remaining_needed = max(0, cnt - sc.get(ch, 0))\n                    new_remaining.extend([ch] * remaining_needed)\n                new_remaining_str = ''.join(new_remaining)\n                res = dp(new_remaining_str)\n                if res != -1:\n                    best = min(best, 1 + res)\n\n            memo[remaining] = -1 if best == float('inf') else best\n            return memo[remaining]\n\n        return dp(target)\n\ndef parse_input(data: str):\n    \"\"\"\n    尝试解析包含 stickers 与 target 的输入格式：\n    - stickers = [\"a\",\"b\",\"c\"], target = \"abc\"\n    如无此格式，则默认第一行为空格分隔的 stickers，第二行是 target。\n    \"\"\"\n    stickers_match = re.search(r'stickers\\s*=\\s*\\[(.*?)\\]', data, re.S)\n    target_match = re.search(r'target\\s*=\\s*[\"\\'](.*?)[\"\\']', data, re.S)\n\n    if stickers_match and target_match:\n        stickers_str = stickers_match.group(1)\n        # 用 ast.literal_eval 解析成列表\n        stickers = ast.literal_eval('[' + stickers_str + ']')\n        target = target_match.group(1)\n    else:\n        # 退化为两行输入\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            stickers = lines[0].strip().split()\n            target = lines[1].strip()\n        else:\n            stickers = []\n            target = ''\n    return stickers, target\n\ndef main():\n    data = sys.stdin.read()\n    stickers, target = parse_input(data)\n    sol = Solution()\n    result = sol.minStickers(stickers, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "stickers = [\"notice\",\"possible\"], target = \"basicbasic\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode583.json",
    "problem_index_in_file": 0,
    "title": "Delete Operation for Two Strings",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and wor...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (step-by-step algorithm). The problem: minimum deletions to make two strings equal. Equivalent to 2 * (len(word1)+len(word2) - 2* LCS). Actually steps = len(word1)+len(word2) - 2*LCS length. So algorithm: compute LCS via DP. Then compute steps. We'll produce virtual code. Use Start, Decision, loops. Show DP table building. Then compute result.\n\nWe need to produce lines with virtual code and explanation. Each line ends with `// 解釋`. Should not output actual code but pseudo steps. Use arrow notation. Provide loops. Use Decision: if.\n\nLet's design:\n\nStart // program start\n→ Step 1: 初始化 DP 二維陣列 (len1+1) x (len2+1) 以存儲 LCS 長度 // init DP\n→ Step 2: For i from 1 to len1 // iterate over word1\n    → For j from 1 to len2 // iterate over word2\n        → Decision: 如果 word1[i-1] == word2[j-1]? // compare characters\n            Yes → DP[i][j] = DP[i-1][j-1] + 1 // matched, extend LCS\n            No  → DP[i][j] = max(DP[i-1][j], DP[i][j-1]) // choose max of skip options\n→ Step 3: LCS = DP[len1][len2] // LCS length\n→ Step 4: steps = len1 + len2 - 2 * LCS // compute deletions\n→ Step 5: 輸出 steps // output result\nEnd // end\n\nNeed to add explanation each line.\n\nMake sure to follow format: each line: \"虛擬碼步驟 // 解釋/說明\".\n\nUse arrow and indentation. Eg:\n\nStart // 程式開始\n\n→ Step 1: 初始化 DP 二維陣列 (len1+1) x (len2+1) 以存儲 LCS 長度 // 初始化 DP 表\n\nWe'll keep arrow with spaces. For nested loops, maybe indent with spaces. Eg: \"→ For i from 1 to len1 // 迭代字串 word1\". Then indent inner loops. Provide decisions.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 DP 二維陣列 (len1+1) × (len2+1) 以存儲 LCS 長度 // 建立動態規劃表  \n→ Step 2: For i from 1 to len1 // 逐字元迭代 word1  \n  → For j from 1 to len2 // 逐字元迭代 word2  \n    → Decision: 如果 word1[i-1] == word2[j-1]? // 比對兩字元是否相同  \n      Yes → DP[i][j] = DP[i-1][j-1] + 1 // 匹配，LCS 長度加一  \n      No → DP[i][j] = max(DP[i-1][j], DP[i][j-1]) // 不匹配，取前一步最大值  \n→ Step 3: LCS = DP[len1][len2] // 取得最長公共子序列長度  \n→ Step 4: steps = len1 + len2 - 2 * LCS // 計算最小刪除步數  \n→ Step 5: 輸出 steps // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        以動態規劃計算兩個字串的最長公共子序列 (LCS) 長度，\n        然後根據公式 steps = len(word1) + len(word2) - 2 * LCS\n        計算最小刪除步數。\n        \"\"\"\n        m, n = len(word1), len(word2)\n        # dp[i][j] 表示 word1[:i] 與 word2[:j] 的 LCS 長度\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        lcs_len = dp[m][n]\n        return m + n - 2 * lcs_len\n\n\ndef main():\n    data = sys.stdin.read()\n    # 先嘗試從引號中擷取字串\n    words = re.findall(r'\"([^\"]*)\"', data)\n    if len(words) >= 2:\n        word1, word2 = words[0], words[1]\n    else:\n        # 如果沒有引號，直接以空白分割，取前兩個字串\n        tokens = data.strip().split()\n        if len(tokens) >= 2:\n            word1, word2 = tokens[0], tokens[1]\n        else:\n            # 讀不到足夠字串，視為空字串\n            word1, word2 = tokens[0] if tokens else '', tokens[1] if len(tokens) > 1 else ''\n\n    sol = Solution()\n    result = sol.minDistance(word1, word2)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"sea\", word2 = \"eat\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "word1 = \"leetcode\", word2 = \"etco\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode28.json",
    "problem_index_in_file": 0,
    "title": "Implement strStr()",
    "description_snippet": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line. The requirement: use arrows (→, Yes→, No→) and structure (Start, End, Decision:). Provide step description and explanation after //.\n\nUser requirement: find index of first occurrence of needle in haystack, or -1. So essentially substring search.\n\nWe should produce steps: Start, input haystack and needle, check if needle empty? If empty, return 0 (depending on typical Leetcode: empty needle returns 0). Then iterate i from 0 to haystack.length - needle.length, and for each, check substring match. If match found, return i. After loop, return -1. End.\n\nSo pseudo-code: Start // program starts. Input haystack, needle. Decision: If needle length == 0? Yes → Step: return 0. No → Loop i from 0 to haystack.length - needle.length. For each i, set match true. Loop j from 0 to needle.length-1. Decision: haystack[i+j] != needle[j]? Yes → match false, break. No → continue. After inner loop: Decision: match? Yes → return i. No → continue. After loop: return -1. End.\n\nWe need to use arrow format: → for each step. Indentation for decisions: Decision: If... Then Yes→, No→.\n\nLet's produce line by line. Ensure each line has \"虛擬碼步驟\" and explanation. Use Chinese explanation.\n\nMake sure to include \"Start // 程式開始執行\" and \"End // 程式執行結束\". Also use \"Decision:\" lines.\n\nWe should not output actual code. Just pseudo-code.\n\nLet's write lines.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Input haystack, needle // 取得兩個輸入字串\n\nLine 3: → Decision: 若 needle 為空字串? // 判斷需要搜尋的字串是否為空\n\nLine 4:     Yes → Return 0 // 空字串視為在任何位置出現，返回 0\n\nLine 5:     No // 不是空字串，繼續搜尋\n\nLine 6: → For i 从 0 到 haystack.length - needle.length: // 逐位置嘗試對齊\n\nLine 7:     → Decision: haystack[i] == needle[0]? // 初始字元快速篩選\n\nLine 8:         Yes → For j 从 1 到 needle.length - 1: // 進一步檢查剩餘字元\n\nLine 9:             → Decision: haystack[i + j] == needle[j]? // 比對字元\n\nLine 10:                Yes → Continue // 若相同，繼續檢查\n\nLine 11:                No  → Break // 不同則跳出內層循環\n\nLine 12:         → Decision: 所有字元均相等? // 判斷是否整段相符\n\nLine 13:             Yes → Return i // 找到第一個匹配，返回索引\n\nLine 14:             No  → Continue // 不是完整匹配，嘗試下一個 i\n\nLine 15: → Return -1 // 若循環結束仍未匹配，返回 -1\n\nLine 16: End // 程式執行結束\n\nBut need to ensure arrow formatting: For loops we can use \"→ For i ...\" line. For decisions inside, use indentation. Need to show \"Decision:\" lines. Also inside for j, we need a Decision. At the end of j loop we need a decision to check all matched. We can use a flag variable maybe \"match = true\" and set to false inside inner loop. But we didn't mention match variable. Let's incorporate match variable.\n\nWe can set before j loop: → Set match = true // 以備檢查\n\nThen inside j loop if mismatch, set match = false, break.\n\nThen after j loop, decision: if match? Yes → return i.\n\nAlternatively we can use \"Decision: 是否全部相符?\" after j loop. We'll incorporate variable.\n\nSo adjust.\n\nLine 6: → For i from 0 to haystack.length - needle.length: // 逐位置嘗試對齊\n\nLine 7:     → Set match = true // 初始化匹配標誌\n\nLine 8:     → For j from 0 to needle.length - 1: // 比對每個字元\n\nLine 9:         → Decision: haystack[i + j] == needle[j]? // 檢查字元是否相同\n\nLine 10:             Yes → Continue // 繼續比對下一個字元\n\nLine 11:             No  → Set match = false // 失配，標記為 false\n\nLine 12:                 → Break // 跳出內層循環\n\nLine 13: → Decision: match? // 判斷整段是否相符\n\nLine 14:     Yes → Return i // 找到第一個匹配，返回索引\n\nLine 15:     No  → Continue // 不是完整匹配，嘗試下一個 i\n\nBut we need to maintain indentation properly. Also we need \"End\" after return -1.\n\nLet's restructure:\n\nStart\n\n→ Input haystack, needle\n\n→ Decision: 若 needle 為空字串?\n\n    Yes → Return 0\n\n    No // 不是空字串，繼續搜尋\n\n→ For i from 0 to haystack.length - needle.length:\n\n    → Set match = true\n\n    → For j from 0 to needle.length - 1:\n\n        → Decision: haystack[i + j] == needle[j]?\n\n            Yes → Continue\n\n            No  → Set match = false\n\n                → Break\n\n    → Decision: match?\n\n        Yes → Return i\n\n        No  → Continue\n\n→ Return -1\n\nEnd\n\nMake sure each line ends with \"// 說明\". Provide explanation in Chinese.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input haystack, needle // 取得兩個輸入字串  \n→ Decision: 若 needle 為空字串? // 判斷需要搜尋的字串是否為空  \n    Yes → Return 0 // 空字串視為在任何位置出現，返回 0  \n    No // 不是空字串，繼續搜尋  \n→ For i from 0 to haystack.length - needle.length: // 逐位置嘗試對齊  \n    → Set match = true // 初始化匹配標誌  \n    → For j from 0 to needle.length - 1: // 比對每個字元  \n        → Decision: haystack[i + j] == needle[j]? // 檢查字元是否相同  \n            Yes → Continue // 繼續比對下一個字元  \n            No  → Set match = false // 失配，標記為 false  \n                → Break // 跳出內層循環  \n    → Decision: match? // 判斷整段是否相符  \n        Yes → Return i // 找到第一個匹配，返回索引  \n        No  → Continue // 不是完整匹配，嘗試下一個 i  \n→ Return -1 // 若循環結束仍未匹配，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import re\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        n, m = len(haystack), len(needle)\n        for i in range(n - m + 1):\n            if haystack[i:i+m] == needle:\n                return i\n        return -1\n\ndef main():\n    import sys\n    data = sys.stdin.read()\n    if not data:\n        return\n    haystack = \"\"\n    needle = \"\"\n    h_match = re.search(r'haystack\\s*=\\s*\"([^\"]*)\"', data)\n    n_match = re.search(r'needle\\s*=\\s*\"([^\"]*)\"', data)\n    if h_match:\n        haystack = h_match.group(1)\n    if n_match:\n        needle = n_match.group(1)\n    sol = Solution()\n    result = sol.strStr(haystack, needle)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "haystack = \"sadbutsad\", needle = \"sad\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "haystack = \"leetcode\", needle = \"leeto\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode605.json",
    "problem_index_in_file": 0,
    "title": "Can Place Flowers",
    "description_snippet": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the described problem. Provide steps line by line with explanation.\n\nWe need to use virtual code arrow symbols, Decision: etc.\n\nWe need to write the algorithm: iterate through array, count potential placements, skip adjacent. If count >= n return true else false.\n\nProvide code steps.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\". For decisions, use \"Decision: if ...?\".\n\nLet's produce.\n\nWe need to start: Start // 程式開始\n\n→ Step 1: 初始化 count = 0 // 用於記錄可種植花的數量\n\n→ Step 2: For i from 0 to length-1 // 遍歷花壇\n\n→ Decision: 如果 flowerbed[i] == 0? // 檢查當前位置是否空\n\n→ Decision: (i == 0 或 flowerbed[i-1] == 0) AND (i == last OR flowerbed[i+1] == 0)? // 檢查左右鄰居是否空\n\n→ Yes → Step 3: 將 count 加 1 // 位置可種植，計數增加\n\n→ Yes → Step 4: 將 flowerbed[i] 設為 1 // 標記為已種植，避免後續誤判\n\n→ Decision: 如果 count >= n? // 已滿足所需數量\n\n→ Yes → Step 5: 返回 true // 可種植足夠花\n\n→ No  → Continue loop // 繼續檢查剩餘位置\n\nEnd // 程式執行結束\n\nBut we need to embed the decision inside the for loop.\n\nBetter structure:\n\nStart\n→ Step 1: count = 0\n→ Step 2: len = length of flowerbed\n→ Step 3: For i = 0 to len-1\n    → Decision: if flowerbed[i] == 0?\n        Yes → Decision: (i == 0 OR flowerbed[i-1] == 0) AND (i == len-1 OR flowerbed[i+1] == 0)?\n            Yes → count = count + 1\n            Yes → flowerbed[i] = 1\n            No  → (do nothing)\n        No → (do nothing)\n    → Decision: if count >= n?\n        Yes → Return true\n        No → (continue)\nEnd\n→ Return false\n\nWe need to produce in format:\n\nStart // 程式開始執行\n→ Step 1: count = 0 // 初始化計數\n→ Step 2: len = 花壇長度 // 取得花壇長度\n→ Step 3: For i = 0 to len-1 // 循環遍歷每個位置\n    → Decision: 花壇[i] == 0? // 檢查位置是否空\n        Yes → Decision: (i == 0 或 花壇[i-1] == 0) AND (i == len-1 或 花壇[i+1] == 0)? // 檢查左右鄰居是否空\n            Yes → Step 4: count = count + 1 // 計數加一\n            Yes → Step 5: 花壇[i] = 1 // 標記為已種植\n            No  → (不執行)\n        No  → (不執行)\n    → Decision: count >= n? // 已達到所需數量\n        Yes → Step 6: 返回 true // 可以種植\n        No  → (繼續迴圈)\nEnd // 程式結束\n→ Step 7: 返回 false // 無法滿足要求\n\nMake sure each line includes explanation. Indentation maybe optional but okay.\n\nWe need to ensure each line is in format: \"虛擬碼步驟 // 解釋\". For decisions we need to include Yes →, No →.\n\nLet's write final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: count = 0 // 初始化計數器，記錄已可種植的花朵數量  \n→ Step 2: len = flowerbed.length // 取得花壇的長度  \n→ Step 3: For i = 0 to len-1 // 循環遍歷每個地塊  \n    → Decision: flowerbed[i] == 0? // 檢查當前地塊是否空  \n        Yes → Decision: (i == 0 OR flowerbed[i-1] == 0) AND (i == len-1 OR flowerbed[i+1] == 0)? // 檢查左右鄰居是否也空  \n            Yes → Step 4: count = count + 1 // 可種植，計數加一  \n            Yes → Step 5: flowerbed[i] = 1 // 標記為已種植，避免後續錯誤判斷  \n            No  → (不執行任何操作) // 若左右鄰居不滿足，保持原狀  \n        No  → (不執行任何操作) // 當前地塊已被種植，跳過  \n    → Decision: count >= n? // 已經達到所需種植數量  \n        Yes → Step 6: 返回 true // 可以滿足需求，提前結束  \n        No  → (繼續迴圈) // 繼續檢查剩餘地塊  \nEnd // 程式執行結束  \n→ Step 7: 返回 false // 迴圈結束仍未滿足，表示無法種植足夠花朵",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canPlaceFlowers(self, flowerbed, n):\n        count = 0\n        length = len(flowerbed)\n        i = 0\n        while i < length:\n            if flowerbed[i] == 0:\n                empty_prev = (i == 0) or (flowerbed[i-1] == 0)\n                empty_next = (i == length-1) or (flowerbed[i+1] == 0)\n                if empty_prev and empty_next:\n                    flowerbed[i] = 1\n                    count += 1\n                    if count >= n:\n                        return True\n                    i += 1\n            i += 1\n        return count >= n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list inside brackets\n    list_match = re.search(r'\\[([0-1,\\s]+)\\]', data)\n    if not list_match:\n        print(\"false\")\n        return\n    list_str = list_match.group(1)\n    flowerbed = [int(x.strip()) for x in list_str.split(',') if x.strip() != '']\n    # Extract n value\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', data)\n    if not n_match:\n        print(\"false\")\n        return\n    n = int(n_match.group(1))\n\n    solution = Solution()\n    result = solution.canPlaceFlowers(flowerbed, n)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "flowerbed = [1,0,0,0,1], n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "flowerbed = [1,0,0,0,1], n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode768.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted II",
    "description_snippet": "You are given an integer array arr.\n\nWe split arr into some number of chunks (i.e., partitions), and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm. The problem: \"Max Chunks To Make Sorted II\" Leetcode 768. Approach: iterate, track max so far, track suffix min array. When max_so_far <= min_suffix[i+1] then can cut. Count. Provide virtual code. Let's produce steps.\n\nWe need to output each line with \"虛擬碼步驟\" and comment. Use arrow style. Provide Start, End. Provide decision.\n\nLet's produce pseudo:\n\nStart\n→ Step 1: 計算 arr 長度 n\n→ Step 2: 初始化 suffixMin[n+1] 為 +∞\n→ Step 3: 從右到左遍歷 arr，更新 suffixMin[i] = min(arr[i], suffixMin[i+1])\n→ Step 4: 設置 maxLeft = -∞, chunks = 0\n→ Step 5: 從左到右遍歷 arr，更新 maxLeft = max(maxLeft, arr[i])\n→ Decision: 如果 maxLeft <= suffixMin[i+1]? // i index\n    Yes → chunks++ // 可以切\n→ Step 6: End\nReturn chunks\n\nLet's produce in virtual code lines.\n\nWe need to follow format: Each line: virtual code + space + // 解釋.\n\nUse arrows: Start, End, Decision.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: Set n ← length of arr // 取得陣列長度\n→ Step 2: Create array suffixMin of size n+1, fill with +∞ // 用於儲存每個位置右側最小值\n→ Step 3: For i from n-1 down to 0: suffixMin[i] ← min(arr[i], suffixMin[i+1]) // 從右往左計算後綴最小\n→ Step 4: Set maxLeft ← -∞, chunks ← 0 // 初始化左側最大值與切塊數\n→ Step 5: For i from 0 to n-1:\n    → Update maxLeft ← max(maxLeft, arr[i]) // 更新左側最大\n    → Decision: if maxLeft <= suffixMin[i+1]? // 判斷是否能切分\n        Yes → chunks ← chunks + 1 // 可以切分，增加計數\n→ Step 6: End // 程式結束\nReturn chunks // 回傳最大切分數\n\nBut we need each line separate. The decision block may need lines for Yes branch. We'll include indentation.\n\nMake sure each line ends with // comment. Provide step numbers as per arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: Set n ← length of arr // 取得陣列長度\n→ Step 2: Create array suffixMin of size n+1, fill with +∞ // 用於儲存每個位置右側最小值\n→ Step 3: For i from n-1 down to 0: suffixMin[i] ← min(arr[i], suffixMin[i+1]) // 從右往左計算後綴最小\n→ Step 4: Set maxLeft ← -∞, chunks ← 0 // 初始化左側最大值與切塊數\n→ Step 5: For i from 0 to n-1:\n    → Update maxLeft ← max(maxLeft, arr[i]) // 更新左側最大\n    → Decision: if maxLeft <= suffixMin[i+1]? // 判斷是否能切分\n        Yes → chunks ← chunks + 1 // 可以切分，增加計數\n→ Step 6: End // 程式結束\nReturn chunks // 回傳最大切分數",
      "generated_code": "import sys\nimport re\n\ndef max_chunks_to_sorted(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    # Compute suffix minimums\n    right_min = [0] * n\n    right_min[-1] = arr[-1]\n    for i in range(n - 2, -1, -1):\n        right_min[i] = min(arr[i], right_min[i + 1])\n    # Count cuts\n    chunks = 0\n    left_max = float('-inf')\n    for i in range(n - 1):\n        left_max = max(left_max, arr[i])\n        if left_max <= right_min[i + 1]:\n            chunks += 1\n    return chunks + 1\n\ndef solve():\n    data = sys.stdin.read().strip()\n    # Extract the list literal after \"arr =\"\n    m = re.search(r'arr\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if m:\n        try:\n            # Evaluate safely; no builtins needed\n            arr = eval(m.group(1), {\"__builtins__\": None}, {})\n        except Exception:\n            arr = []\n    else:\n        arr = []\n\n    result = max_chunks_to_sorted(arr)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [5,4,3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [2,1,3,4,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode664.json",
    "problem_index_in_file": 0,
    "title": "Strange Printer",
    "description_snippet": "There is a strange printer with the following two special properties:\n\nThe printer can only print a ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps. Provide each line with comment. It's dynamic programming, but we need to outline algorithm, not actual code. Provide steps: preprocess, DP table dp[i][j] min turns for substring i..j. Recurrence: dp[i][j] = dp[i+1][j]+1; for k in [i+1..j] if s[k]==s[i] then dp[i][j] = min(dp[i][j], dp[i+1][k-1]+dp[k][j]); Complexity O(n^3). Outline input reading, DP init, loops. Provide pseudocode with arrow.\n\nLet's produce steps. Use \"Start\", \"End\". Indent decisions.\n\nWe need to include arrow lines with \"→\". Provide each line as:\n\nStart // 程式開始執行\n\n→ Input: string s // 取得待列印字串\n\n→ Let n be length of s // 取得長度\n\n→ Create 2D array dp[n][n] // dp[i][j] min turns for s[i..j]\n\n→ For i from 0 to n-1: dp[i][i] = 1 // 單字元需要一次列印\n\n→ For len from 2 to n: // 子字串長度\n\n    → For i from 0 to n-len: j = i+len-1\n\n        → Set dp[i][j] = dp[i+1][j] + 1 // 初始假設最壞情況\n\n        → For k from i+1 to j:\n\n            → If s[k] == s[i]:\n\n                → If k == i+1: temp = dp[k][j] // No middle\n\n                → Else temp = dp[i+1][k-1] + dp[k][j] // combine\n\n                → dp[i][j] = min(dp[i][j], temp)\n\n→ Output dp[0][n-1] // 最小列印次數\n\nEnd // 程式結束\n\nAlso include decision arrow for if s[k]==s[i] else. Provide simple decisions.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: 字串 s // 取得待列印字串  \n→ Let n = s.length // 取得字串長度  \n→ Create 2D 陣列 dp[n][n] // dp[i][j] 代表 s[i..j] 的最少列印次數  \n→ For i = 0 to n-1: dp[i][i] = 1 // 單一字元只需一次列印  \n→ For len = 2 to n: // 依子字串長度遞增  \n    → For i = 0 to n - len:  \n        → j = i + len - 1 // 子字串結尾索引  \n        → Set dp[i][j] = dp[i+1][j] + 1 // 初始假設將 s[i] 單獨列印一次  \n        → For k = i+1 to j: // 探索與 s[i] 相同字元的位置  \n            → Decision: 若 s[k] == s[i] ? // 是否可將 s[i] 與 s[k] 同時列印  \n                Yes → If k == i+1: temp = dp[k][j] // 兩者相鄰，直接合併  \n                     No  → temp = dp[i+1][k-1] + dp[k][j] // 先列印中間，再合併兩端  \n                No  → Continue // s[k] 與 s[i] 不同，跳過  \n            → dp[i][j] = min(dp[i][j], temp) // 更新最小值  \n→ Output dp[0][n-1] // 最小列印次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strangePrinter(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        # dp[i][j] : min turns to print s[i..j]\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                # Worst case: print s[i] separately, then s[i+1..j]\n                dp[i][j] = dp[i + 1][j] + 1\n                for k in range(i + 1, j + 1):\n                    if s[k] == s[i]:\n                        # If we can merge s[i] with s[k]\n                        left = dp[i + 1][k - 1] if k - 1 >= i + 1 else 0\n                        right = dp[k][j]\n                        dp[i][j] = min(dp[i][j], left + right)\n        return dp[0][n - 1]\n\ndef extract_string(data: str) -> str:\n    # 尋找引號內的字串\n    m = re.search(r'[\"\\']([^\"\\']*)[\"\\']', data)\n    if m:\n        return m.group(1)\n    # 若未找到引號，嘗試去除可能的前綴\n    data = data.replace('s =', '').strip()\n    return data\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = extract_string(raw_input)\n    solution = Solution()\n    print(solution.strangePrinter(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabbb\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode377.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum IV",
    "description_snippet": "Given an array of distinct integers nums and a target integer target, return the number of possible ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: count number of possible combinations (order matters?) that add up to target, distinct integers in array. This is essentially \"Combination Sum IV\" problem: number of combinations that sum to target using given numbers, order matters. Use DP. Steps: initialize dp array length target+1 with 0; dp[0] = 1; iterate i from 1 to target: for each num in nums: if num <= i: dp[i] += dp[i-num]; result dp[target]. Provide virtual code line by line with explanation. Use Start, End, Decision. Use arrow. Also mention array and initialization.\n\nMake sure no actual code; only virtual code with arrows and explanations. Let's produce step by step. Use virtual code lines like \"Start\" etc.\n\nWe need to be thorough: read input, initialize dp, loop, inner loop, update, final output. Should include decisions for dp updates: if num <= i? else skip. Use decision block.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數陣列 nums 及目標值 target // 從輸入取得必要資料  \n→ Step 2: 建立長度為 target+1 的整數陣列 dp 並全部設定為 0 // dp[i] 代表能組合出總和為 i 的方式數  \n→ Step 3: 設定 dp[0] = 1 // 基礎情況：零和只有一種方式（不取任何數字）  \n→ Step 4: 針對 i 從 1 到 target 逐一處理 // 外層迴圈遍歷所有可能的總和  \n    → Decision: 若 i < 最小的 nums 元素? // 若目前總和小於可用最小數，則無法組合  \n        Yes → Continue // 跳過此 i，直接進入下一個總和  \n        No  → Step 5: 對於陣列 nums 中的每一個數 num  \n            → Decision: 若 num ≤ i? // 只考慮能在此總和下使用的數字  \n                Yes → Step 6: dp[i] = dp[i] + dp[i - num] // 把以 num 作為最後一個數的組合數加進來  \n                No  → No operation // 無法使用此 num，直接跳過  \n→ Step 7: 完成所有 i 的處理後，dp[target] 即為答案 // 所有可能的組合數已累計  \n→ Step 8: 輸出 dp[target] // 將結果傳回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        # DP array where dp[i] is number of combinations to reach sum i\n        dp = [0] * (target + 1)\n        dp[0] = 1  # base case: one way to reach 0 (choose nothing)\n\n        # Build up dp for all sums from 1 to target\n        for i in range(1, target + 1):\n            for num in nums:\n                if num <= i:  # only consider numbers that fit in current sum\n                    dp[i] += dp[i - num]\n        return dp[target]\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse an input string of the form:\n        nums = [1,2,3], target = 4\n    and return the corresponding list and target integer.\n    \"\"\"\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, input_str, re.DOTALL)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    nums_str, target_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    return nums, target\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    solution = Solution()\n    result = solution.combinationSum4(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode726.json",
    "problem_index_in_file": 0,
    "title": "Number of Atoms",
    "description_snippet": "Given a string formula representing a chemical formula, return the count of each atom.\n\nThe atomic e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. For algorithm: parse string using stack, handle parentheses and counts. Steps: Start, parse, use stack of maps, iterate chars with index. When uppercase start, read element name; parse following digits; push to stack? Actually maintain stack of maps for nested parentheses. Algorithm: use stack of maps. For each char:\n- If '(', push new empty map onto stack.\n- If uppercase letter, parse element name and count. Add to current map on top of stack.\n- If ')', pop top map, parse following digits for multiplier (default 1). Multiply counts in popped map by multiplier, merge into new top map.\nAfter loop, merge all maps from stack (should be one) into result. Then sort keys, build string.\n\nNeed to produce virtual code step lines accordingly. Provide explanation.\n\nLet's output step-by-step. We'll include Decision nodes maybe for conditions like if char '(' etc.\n\nWe'll produce as per format. Use \"Start\", \"End\". Use \"Decision:\" lines for char type checks.\n\nWe'll produce lines: Start, → Step 1: Initialize stack with empty map // etc. Use → etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize a stack with one empty atom count map // 用於處理括號層級  \n→ Step 2: 設定索引 i = 0，並取得輸入字串 formula  \n→ Decision: 若 i < len(formula)? // 迴圈判斷  \n Yes → Step 3: 讀取當前字符 c = formula[i]  \n  Decision: c == '('? // 開啟括號  \n   Yes → Step 4: 推入新的空映射至 stack // 開始新的子公式  \n   No  → Decision: c == ')'？ // 關閉括號  \n    Yes → Step 5: pop = stack.pop() // 取出子公式計數  \n     Step 6: i += 1  \n     Decision: i < len(formula) 且 formula[i] 為數字？ // 解析乘數  \n      Yes → Step 7: 讀取完整數字 multiplier  \n      No  → Step 8: multiplier = 1  \n      Step 9: 將 pop 中每個元素乘上 multiplier，並合併回 stack[-1]  \n      Step 10: i = i + len(multiplier) // 移至下一位置  \n      No → Step 11: i = i + 1 // 移至下一位置  \n      End  \n      Decision: i >= len(formula)? // 若結束，退出  \n       Yes → Step 12: 跳至結束  \n       No → Decision: 仍需處理？  \n        Yes → 回到 Decision: 若 i < len(formula)?  \n        No → 進行下一迴圈  \n      End  \n      Decision: c 不是括號？ // 必定為元素字母  \n      Yes → Step 13: 讀取元素名稱：從 c 開始讀取後續小寫字母 until non‑lowercase  \n       Step 14: i += len(elementName)  \n       Step 15: 讀取可選數字 count（預設 1）  \n       Step 16: stack[-1][elementName] += count  \n       i = i + len(count) // 移至下一位置  \n       Decision: i < len(formula)? // 是否繼續迴圈  \n        Yes → 回到 Decision: 若 i < len(formula)?  \n        No → 進行下一迴圈  \n      End  \n      End  \n      Decision: i >= len(formula)?  \n      Yes → Step 17: 合併 stack[-1] 為最終結果 map  \n      No → 回到 Decision: 若 i < len(formula)?  \n      End  \n      End  \n  Decision: i >= len(formula)?  \n  Yes → Step 18: 取出最終計數 map，將鍵排序為字典序  \n   Step 19: 初始化結果字串 result = ''  \n   Step 20: 對每個鍵 atom in sorted_keys:  \n     Step 21: result += atom  \n      Decision: count > 1?  \n       Yes → Step 22: result += str(count)  \n       No → 跳過  \n      End  \n     End  \n   Step 23: 輸出 result  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def countOfAtoms(self, formula: str) -> str:\n        n = len(formula)\n        self.i = 0\n\n        def parse() -> Counter:\n            cnt = Counter()\n            while self.i < n and formula[self.i] != ')':\n                if formula[self.i] == '(':\n                    # Enter a new group\n                    self.i += 1\n                    inner = parse()\n                    # Skip the closing ')'\n                    self.i += 1\n                    # Parse optional multiplier\n                    mult = 0\n                    while self.i < n and formula[self.i].isdigit():\n                        mult = mult * 10 + int(formula[self.i])\n                        self.i += 1\n                    if mult == 0:\n                        mult = 1\n                    # Merge inner counts multiplied by mult\n                    for k, v in inner.items():\n                        cnt[k] += v * mult\n                else:\n                    # Parse an element name\n                    start = self.i\n                    self.i += 1\n                    while self.i < n and formula[self.i].islower():\n                        self.i += 1\n                    name = formula[start:self.i]\n                    # Parse optional count\n                    num = 0\n                    while self.i < n and formula[self.i].isdigit():\n                        num = num * 10 + int(formula[self.i])\n                        self.i += 1\n                    if num == 0:\n                        num = 1\n                    cnt[name] += num\n            return cnt\n\n        counts = parse()\n        parts = []\n        for atom in sorted(counts.keys()):\n            parts.append(atom + (str(counts[atom]) if counts[atom] > 1 else \"\"))\n        return \"\".join(parts)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # Handle input formats like: formula = \"H2O\" or just \"H2O\"\n    if '=' in raw_input:\n        _, value = raw_input.split('=', 1)\n        value = value.strip()\n    else:\n        value = raw_input\n    # Remove surrounding quotes if present\n    if (value.startswith('\"') and value.endswith('\"')) or (value.startswith(\"'\") and value.endswith(\"'\")):\n        value = value[1:-1]\n    formula = value\n    sol = Solution()\n    result = sol.countOfAtoms(formula)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "formula = \"H2O\"",
          "expected_output": "\"H2O\"",
          "success": true,
          "output": "H2O"
        },
        {
          "example_index": 1,
          "input": "formula = \"Mg(OH)2\"",
          "expected_output": "\"H2MgO2\"",
          "success": true,
          "output": "H2MgO2"
        },
        {
          "example_index": 2,
          "input": "formula = \"K4(ON(SO3)2)2\"",
          "expected_output": "\"K4N2O14S4\"",
          "success": true,
          "output": "K4N2O14S4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode575.json",
    "problem_index_in_file": 0,
    "title": "Distribute Candies",
    "description_snippet": "Alice has n candies, where the i^th candy is of type candyType[i]. Alice noticed that she started to...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that solves the problem: Given array candyType of length n even, return max distinct types she can eat if eat n/2 candies. Essentially answer = min( number of distinct types, n/2 ).\n\nWe need to output step-by-step pseudocode lines with arrows and explanations.\n\nWe should include Start, decisions, loops, etc.\n\nThe virtual code should reflect algorithm: Count distinct types using a set. Let distinctCount = size of set. Let half = n / 2. Result = min(distinctCount, half). Return.\n\nWe need to use virtual code arrows: →, Decision, Yes→, No→. Use Start, End. Provide explanation each line.\n\nLet's produce line by line:\n\nStart\n→ Step 1: Read array candyType and determine n // 获取长度 n\n→ Step 2: Initialize empty set distinctSet // 用来记录不同种类\n→ Step 3: For each type in candyType: Add type to distinctSet // 统计种类\n→ Step 4: distinctCount ← size of distinctSet // 得到不同种类数量\n→ Step 5: half ← n / 2 // 计算允许吃的最大数量\n→ Decision: If distinctCount > half? // 判断种类是否多于可吃数\n    Yes → result ← half // 只能吃到 half 种\n    No  → result ← distinctCount // 可以吃所有种\n→ Step 6: Return result // 输出最大不同种类数\nEnd\n\nBut we need to include arrow after each line? Format: \"虛擬碼步驟 [space] // 解釋\". So we need the arrow before step? In example, they have \"→ Step 1: ...\" So we should maintain same style. So each line: \"→ Step X: ...\" or \"Decision: ...\". For Start and End, just \"Start\" and \"End\". Provide explanation. Use arrows for steps, decisions.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取陣列 candyType 並計算長度 n // 取得糖果總數  \n→ Step 2: 建立空集合 distinctSet // 用於記錄不同類型  \n→ Step 3: 對 candyType 中每個元素 type: 把 type 加入 distinctSet // 統計種類  \n→ Step 4: distinctCount ← distinctSet 的大小 // 得到不同種類數量  \n→ Step 5: half ← n / 2 // 計算醫生允許吃的最大數量  \n→ Decision: distinctCount > half? // 檢查種類是否多於可吃數  \n  Yes → result ← half // 只能吃到 half 種不同糖果  \n  No  → result ← distinctCount // 可以吃完所有不同種類  \n→ Step 6: 返回 result // 輸出最大可吃的不同種類數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    @staticmethod\n    def distributeCandies(candyType):\n        \"\"\"\n        Return the maximum number of different candy types Alice can eat.\n        She may eat at most n/2 candies, where n is the total number of candies.\n        \"\"\"\n        distinct = len(set(candyType))\n        half = len(candyType) // 2\n        return min(distinct, half)\n\ndef main():\n    # 讀取整個標準輸入並尋找所有整數\n    data = sys.stdin.read()\n    if not data:\n        return\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # 有些輸入可能會把 n 放在前面，例如「6 1 1 2 2 3 3」\n    # 如果首個數字等於後面數量，或等於後面數量-1，就把它當作 n 丟掉\n    if numbers and (numbers[0] == len(numbers) or numbers[0] == len(numbers) - 1):\n        candy_type = numbers[1:]\n    else:\n        candy_type = numbers\n\n    # 直接使用解法\n    result = Solution.distributeCandies(candy_type)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candyType = [1,1,2,2,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "candyType = [1,1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "candyType = [6,6,6,6]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode532.json",
    "problem_index_in_file": 0,
    "title": "K-diff Pairs in an Array",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the ar...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanation for algorithm to count unique k-diff pairs. We will use a hash set to count unique pairs. Steps: sort? But better approach: use hashmap to count frequencies. Then for each number check if k==0: count numbers with freq>1. else for each number, if number+k exists, add pair. Use set of pairs to avoid duplicates? If we iterate each number once, add pair (num, num+k) only once. Use set to store unique first elements maybe. But ensure not double counting. Simpler: For k>0: iterate numbers, if num+k in set, count++. For k==0: count numbers with freq>1. Use set of numbers to check existence.\n\nPseudo lines: Start, build frequency map, decide k, etc.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows: Start, Decision, etc. Must be line-by-line. Let's craft.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化頻率字典 freq = {} // 用於統計每個數字出現次數\n→ Decision: 是否需要填充 freq?\n    Yes → For each num in nums:\n              → Step 2: freq[num] = freq.get(num,0)+1 // 計算每個數字的頻率\n    No  // (不需要) skip\n\n→ Step 3: 初始化計數 count = 0 // 存儲唯一 k-diff 對的數量\n→ Decision: k == 0 ?\n    Yes → Step 4: For each (num, cnt) in freq:\n              → Decision: cnt > 1 ?\n                  Yes → count += 1 // 數字出現多於一次，形成 (num,num) 對\n                  No  → No action\n    No  → Step 5: For each num in freq:\n              → Decision: (num + k) in freq ?\n                  Yes → count += 1 // (num, num+k) 為有效對\n                  No  → No action\n\n→ End // 輸出 count\n\nBut need to format each line individually with arrow? Actually we need \"虛擬碼步驟 [space] // 解釋\". For Decision we need indentation. The sample shows indentation: \"Decision: ...\". We can replicate.\n\nLet's craft final output. Ensure each line uses arrow \"→\" except Start/End. For Decision, indent lines under it. For Yes/No arrows also.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空頻率字典 freq = {} // 用於記錄每個數字的出現頻率\n→ Decision: 是否需要填充 freq? // 從輸入陣列統計頻率\n    Yes → For each num in nums:\n              → Step 2: freq[num] = freq.get(num, 0) + 1 // 更新 num 的計數\n    No  // 若 nums 為空，略過\n\n→ Step 3: 初始化計數 count = 0 // 用於儲存唯一 k‑diff 對的數量\n→ Decision: k == 0? // k 為零時特殊處理\n    Yes → Step 4: For each (num, cnt) in freq:\n              → Decision: cnt > 1?\n                  Yes → count += 1 // 只要出現至少兩次，(num, num) 為有效對\n                  No  → No action\n    No  → Step 5: For each num in freq:\n              → Decision: (num + k) in freq?\n                  Yes → count += 1 // (num, num+k) 為有效且唯一對\n                  No  → No action\n\nEnd // 輸出 count，程式結束\n\nMake sure each line separate. That's it.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空頻率字典 freq = {} // 用於記錄每個數字的出現頻率  \n→ Decision: 是否需要填充 freq? // 從輸入陣列統計頻率  \n  Yes → For each num in nums:  \n    → Step 2: freq[num] = freq.get(num, 0) + 1 // 更新 num 的計數  \n  No  // 若 nums 為空，略過  \n\n→ Step 3: 初始化計數 count = 0 // 用於儲存唯一 k‑diff 對的數量  \n→ Decision: k == 0? // k 為零時特殊處理  \n  Yes → Step 4: For each (num, cnt) in freq:  \n    → Decision: cnt > 1?  \n      Yes → count += 1 // 只要出現至少兩次，(num, num) 為有效對  \n      No  → No action  \n  No  → Step 5: For each num in freq:  \n    → Decision: (num + k) in freq?  \n      Yes → count += 1 // (num, num+k) 為有效且唯一對  \n      No  → No action  \n\nEnd // 輸出 count，程式結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findPairs(self, nums, k):\n        if k < 0:\n            return 0\n        count = Counter(nums)\n        if k == 0:\n            return sum(v > 1 for v in count.values())\n        return sum(n + k in count for n in count)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 支援「[a,b,c], k」或「[a,b,c] k」兩種輸入格式\n    if ',' in data:\n        nums_str, k_str = data.rsplit(',', 1)\n    else:\n        # 若沒有逗號，預期第一行是陣列，第二行是 k\n        parts = data.splitlines()\n        nums_str = parts[0].strip()\n        k_str = parts[1].strip() if len(parts) > 1 else '0'\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n    result = Solution().findPairs(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode611.json",
    "problem_index_in_file": 0,
    "title": "Valid Triangle Number",
    "description_snippet": "Given an integer array nums, return the number of triplets chosen from the array that can make trian...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: count number of triplets that can form triangle. This is classic problem: sort array, use two pointers to count. Provide step-by-step virtual code.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Provide Start, End, Decision: etc.\n\nLet's craft.\n\nStart\n→ Step 1: Sort nums ascending // 排序便於後續比較\n→ Step 2: 初始化 count = 0 // 儲存符合條件的三元組數量\n→ Step 3: for i from 0 to len(nums)-3 // 固定第一條邊\n    → Step 4: left = i + 1, right = len(nums)-1 // 設置左右指標\n    → Decision: while left < right? // 確保兩邊指標有效\n        → Step 5: if nums[i] + nums[left] > nums[right]? // 判斷是否能成三角形\n            → Yes → Step 6: count += right - left // 右邊左側所有點皆可配對\n            → Step 7: right -= 1 // 缩小右指標\n            → No → Step 8: left += 1 // 右指標無法成三角形，左移左指標\n→ Step 9: return count // 結果\nEnd\n\nBut we need \"虛擬碼步驟\" each line. Use arrow \"→\" each step. Need decision lines. Let's produce.\n\nWe also might need Step labels.\n\nWe need to ensure each line ends with comment after space.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先排序方便後續判斷\n→ Step 2: Initialize count = 0 // 計數符合三角形條件的組合\n→ Step 3: For i from 0 to len(nums)-3 // 固定最短邊\n    → Step 4: left = i + 1, right = len(nums) - 1 // 設定左右指標\n    → Decision: while left < right? // 只要左指標在右指標左側才有效\n        → Yes → Step 5: if nums[i] + nums[left] > nums[right]? // 判斷三角形不等式\n            → Yes → Step 6: count += right - left // 右側所有點皆可組成三角形\n            → Step 7: right -= 1 // 將右指標左移以尋找更小的長度\n            → No → Step 8: left += 1 // 左指標右移以增大左邊長度\n→ Step 9: Return count // 回傳符合條件的三元組數量\nEnd // 程式執行結束\n\nMake sure indentation maybe but each line separate. Provide explanation comment.\n\nAlso we need to be careful: Decision: while left < right? -> Yes -> steps, No -> loop ends.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先將陣列排序，方便後續的三角形判斷\n→ Step 2: Initialize count = 0 // 用來統計符合三角形條件的三元組數\n→ Step 3: For i from 0 to len(nums) - 3 // 固定最短邊的索引 i\n    → Step 4: left = i + 1, right = len(nums) - 1 // 設定左右指標，指向剩餘兩條邊\n    → Decision: while left < right? // 當左指標仍在右指標左側時執行\n        → Yes → Step 5: if nums[i] + nums[left] > nums[right]? // 判斷三角形不等式\n            → Yes → Step 6: count += right - left // 所有從 left 到 right-1 的索引皆可形成三角形\n            → Step 7: right -= 1 // 將右指標左移，尋找更小的長度\n            → No → Step 8: left += 1 // 右指標長度不夠，左指標右移以增大左邊長度\n→ Step 9: Return count // 回傳符合條件的三元組數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def triangleNumber(self, nums):\n        nums.sort()\n        count = 0\n        n = len(nums)\n        # 使用從最長邊開始的雙指標法\n        for k in range(n - 1, 1, -1):\n            i, j = 0, k - 1\n            while i < j:\n                if nums[i] + nums[j] > nums[k]:\n                    # 當 i 與 j 的和大於最長邊時，i 到 j-1 的所有組合皆可成三角形\n                    count += j - i\n                    j -= 1\n                else:\n                    i += 1\n        return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取 list\n    match = re.search(r'\\[.*?\\]', data)\n    nums = eval(match.group(0)) if match else []\n    result = Solution().triangleNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode3.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring Without Repeating Characters",
    "description_snippet": "Given a string s, find the length of the longest substring without duplicate characters....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code, line by line, with arrow, steps, decision. For problem: longest substring without repeating characters. Approach: sliding window with hash set. We'll produce virtual code lines. Must not output actual code, just virtual steps.\n\nWe need to produce steps like:\n\nStart\n→ Step 1: Initialize left = 0, right = 0, maxLen = 0, set = empty // ...\n→ Step 2: While right < length of s // loop over characters\n→ Decision: character s[right] in set? // check duplicate\n   Yes → Step 3: Remove s[left] from set, left++ // move left pointer\n   No  → Step 4: Add s[right] to set, update maxLen = max(maxLen, right-left+1) // update length\n→ Step 5: right++ // move right pointer\n→ Decision: right < length? // continue\nEnd\n\nWe need to maintain arrow indenting and decisions with Yes/No. Provide explanations after //.\n\nEnsure each line has exactly the format \"虛擬碼步驟 // 解釋/說明\". For decisions indent we can indent? Example shows indentation for nested lines. We should keep same.\n\nWe'll generate. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = 0, maxLen = 0, set = 空集合 // 設定滑動窗口指標與最大長度\n→ Step 2: 當 right 小於 s 的長度時進入迴圈 // 遍歷整個字串\n    → Decision: s[right] 是否已存在於 set？ // 檢查右指標字符是否重複\n        Yes → Step 3: 從 set 中移除 s[left]，並將 left 增 1 // 移動左指標以縮小窗口\n        No  → Step 4: 將 s[right] 加入 set，並計算並更新 maxLen = max(maxLen, right - left + 1) // 更新最大子字串長度\n    → Step 5: right 增 1 // 移動右指標繼續掃描\n→ Decision: right 小於 s 的長度？ // 判斷是否還有字符未處理\n    Yes → 回到 Step 2 // 繼續迴圈\n    No  → Step 6: 輸出 maxLen // 最終結果為最大不重複子字串長度\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    計算給定字串 s 中不含重複字元的最長子字串長度。\n    使用滑動窗口 + 集合的做法，時間複雜度 O(n)。\n    \"\"\"\n    char_set = set()\n    left = 0\n    max_len = 0\n\n    for right, ch in enumerate(s):\n        # 如果右指標字符已在窗口中，則從左指標開始移除，直到不重複\n        while ch in char_set:\n            char_set.remove(s[left])\n            left += 1\n        char_set.add(ch)\n        max_len = max(max_len, right - left + 1)\n\n    return max_len\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並剔除前後空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入格式：例如 s = \"abcabcbb\"\n    # 取得第一個雙引號之間的內容作為字串\n    parts = raw_input.split('\"')\n    if len(parts) >= 2:\n        s = parts[1]\n    else:\n        # 若輸入本身就是字串，直接使用\n        s = raw_input\n\n    result = length_of_longest_substring(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcabcbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"bbbbb\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \"pwwkew\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode715.json",
    "problem_index_in_file": 0,
    "title": "Range Module",
    "description_snippet": "A Range Module is a module that tracks ranges of numbers. Design a data structure to track the range...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. It's a design for RangeModule with operations addRange, queryRange, removeRange. Likely use interval set, maybe tree or sorted list. Provide algorithm in pseudocode: maintain list of non-overlapping intervals sorted. add: merge with overlapping. query: check coverage. remove: cut intervals. We'll produce step-by-step for each method? The task: generate virtual code for the design. Probably provide class structure with methods. We'll write pseudo-code lines: Start, initialize, addRange, queryRange, removeRange, End. Each line with explanation. Need arrow structure. We'll use Decision, etc. We'll show loops for iterating intervals. Use indices. Provide high-level logic.\n\nLet's output something like:\n\nStart\n→ Initialize empty interval list // store non-overlapping intervals sorted\n→ Method: addRange(left,right) //...\n→ Decision: find first interval with end >= left? etc.\n\nWe must produce line by line, each with comment. We'll include indentation maybe but still same line format.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Set intervals ← empty list // 用於儲存已追蹤的非重疊半開區間，按左端排序  \n→ Method: addRange(left, right) // 新增區間  \n    → Find idx ← 最小索引，使 intervals[idx].right >= left // 找到可能重疊的第一個區間  \n    → Decision: idx 是否存在?  \n        Yes → While idx < intervals.length AND intervals[idx].left <= right  \n            → Update left ← min(left, intervals[idx].left) // 合併左端  \n            → Update right ← max(right, intervals[idx].right) // 合併右端  \n            → Remove intervals[idx] // 刪除已合併的區間  \n            → idx ← idx // 因為已刪除，索引保持不變  \n        No → // 無重疊區間，直接跳過  \n    → Insert [left, right] at idx // 插入新的合併後區間，保持排序  \n→ Method: queryRange(left, right) // 查詢區間是否完全被追蹤  \n    → Find idx ← 最小索引，使 intervals[idx].left <= left < intervals[idx].right OR idx+1 ... // 找到左端落在或左於區間的區間  \n    → Decision: idx 是否存在?  \n        No → Return false // 沒有區間包含左端  \n        Yes → Decision: intervals[idx].right >= right?  \n            Yes → Return true // 整個查詢區間被單個區間覆蓋  \n            No → // 需要檢查連續區間  \n            → Set curEnd ← intervals[idx].right  \n            → idx ← idx + 1  \n            → While curEnd < right AND idx < intervals.length AND intervals[idx].left <= curEnd  \n                → curEnd ← intervals[idx].right  \n                → idx ← idx + 1  \n            → Decision: curEnd >= right?  \n                Yes → Return true // 連續區間覆蓋整個查詢範圍  \n                No → Return false // 尚未覆蓋完整  \n→ Method: removeRange(left, right) // 移除區間  \n    → Find idx ← 最小索引，使 intervals[idx].right > left // 找到可能受影響的第一個區間  \n    → Decision: idx 是否存在?  \n        No → Return // 沒有區間受影響  \n        Yes → While idx < intervals.length AND intervals[idx].left < right  \n            → Decision: intervals[idx].left < left AND intervals[idx].right > right?  \n                Yes → // 檢查區間被完全覆蓋，需拆成兩個  \n                    → Set newRight ← left  \n                    → Set newLeft ← right  \n                    → intervals[idx].right ← newRight // 左半段保留  \n                    → Insert [newLeft, intervals[idx].right] at idx+1 // 右半段插入  \n                    → idx ← idx + 2 // 跳過新插入區間  \n                No → Decision: intervals[idx].left < left?  \n                    Yes → intervals[idx].right ← left // 刪除右邊覆蓋部分  \n                    No → // intervals[idx].left >= left  \n                    → Decision: intervals[idx].right <= right?  \n                        Yes → Remove intervals[idx] // 整個區間被移除  \n                        No → intervals[idx].left ← right // 只移除左邊覆蓋部分  \n            → idx ← idx + 1  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        # 儲存的區間是非重疊、按左端排序的列表\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:                      # 完全在左側\n                new_ranges.append([l, r])\n            elif right < l:                   # 完全在右側\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:                             # 有重疊\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:                         # 新區間在最右側\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        # 找到最後一個左端 <= left 的區間\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        l, r = self.ranges[i-1]\n        return l <= left and right <= r\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:       # 與 [left, right) 完全不相交\n                new_ranges.append([l, r])\n            else:\n                if l < left:                  # 左邊剩餘部分\n                    new_ranges.append([l, left])\n                if r > right:                 # 右邊剩餘部分\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\nif __name__ == \"__main__\":\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    outputs = []\n    rm = None\n\n    for line in lines:\n        line = line.rstrip(';')          # 移除結尾的分號\n        if line.startswith(\"RangeModule\"):\n            rm = RangeModule()\n            outputs.append(\"null\")\n        elif line.startswith(\"rangeModule.addRange\"):\n            inside = line[line.find('(')+1:line.find(')')]\n            left, right = map(int, inside.split(','))\n            rm.addRange(left, right)\n            outputs.append(\"null\")\n        elif line.startswith(\"rangeModule.removeRange\"):\n            inside = line[line.find('(')+1:line.find(')'))\n            left, right = map(int, inside.split(','))\n            rm.removeRange(left, right)\n            outputs.append(\"null\")\n        elif line.startswith(\"rangeModule.queryRange\"):\n            inside = line[line.find('(')+1:line.find(')')]\n            left, right = map(int, inside.split(','))\n            res = rm.queryRange(left, right)\n            outputs.append(\"true\" if res else \"false\")\n        else:\n            # 若有不符合預期格式的行，可忽略或報錯\n            continue\n\n    print(\"[\" + \", \".join(outputs) + \"]\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "success": false,
          "output": "File \"/tmp/tmp4wtton10.py\", line 63\n    inside = line[line.find('(')+1:line.find(')'))\n                                                 ^\nSyntaxError: closing parenthesis ')' does not match opening parenthesis '['"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode641.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Deque",
    "description_snippet": "Design your implementation of the circular double-ended queue (deque).\n\nImplement the MyCircularDequ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the design of a circular deque. Each line must be in format: \"虛擬碼步驟 // 解釋\". Use arrows. Use structure. No actual code. We'll create steps: Start, initialize array, front, rear pointers, size, capacity. Provide methods insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Provide decision logic. Let's craft sequentially.\n\nWe need to output step by step, maybe pseudo-code lines with arrows. Provide explanation after each.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCircularDeque 類別，包含容量 k、陣列 data、前指標 front、後指標 rear、當前長度 size // 建立資料結構\n→ Decision: 初始化時將 front = 0, rear = 0, size = 0 // 初始空 deque\n→ Method: insertFront(value) // 向前端插入\n    → Decision: if size == k? // 判斷是否已滿\n        Yes → Return false // 若滿，插入失敗\n        No  → front = (front - 1 + k) mod k // 往前移動 front\n            → data[front] = value\n            → size += 1\n            → Return true\n→ Method: insertLast(value) // 往後端插入\n    → Decision: if size == k?\n        Yes → Return false\n        No  → data[rear] = value\n            → rear = (rear + 1) mod k // 往後移動 rear\n            → size += 1\n            → Return true\n→ Method: deleteFront() // 刪除前端\n    → Decision: if size == 0?\n        Yes → Return false // 空則失敗\n        No  → front = (front + 1) mod k // 前移\n            → size -= 1\n            → Return true\n→ Method: deleteLast() // 刪除後端\n    → Decision: if size == 0?\n        Yes → Return false\n        No  → rear = (rear - 1 + k) mod k // 後移\n            → size -= 1\n            → Return true\n→ Method: getFront() // 取得前端值\n    → Decision: if size == 0?\n        Yes → Return -1\n        No  → Return data[front]\n→ Method: getRear() // 取得後端值\n    → Decision: if size == 0?\n        Yes → Return -1\n        No  → idx = (rear - 1 + k) mod k\n            → Return data[idx]\n→ Method: isEmpty() // 判斷是否空\n    → Return size == 0\n→ Method: isFull() // 判斷是否滿\n    → Return size == k\nEnd // 程式結束\n\nWe need to include arrow arrows \"→\" for steps. Each line must contain the virtual code step and comment after //. We can nest decisions with indentation? The sample shows indentation. We'll produce similar.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類別，包含容量 k、陣列 data、前指標 front、後指標 rear、當前長度 size // 建立資料結構  \n→ Decision: 初始化時將 front = 0, rear = 0, size = 0 // 初始空 deque  \n\n→ Method: insertFront(value) // 向前端插入  \n → Decision: 如果 size == k? // 判斷是否已滿  \n  Yes → Return false // 若滿，插入失敗  \n  No  → front = (front - 1 + k) mod k // 往前移動 front  \n   → data[front] = value  \n   → size += 1  \n   → Return true  \n\n→ Method: insertLast(value) // 往後端插入  \n → Decision: 如果 size == k?  \n  Yes → Return false  \n  No  → data[rear] = value  \n   → rear = (rear + 1) mod k // 往後移動 rear  \n   → size += 1  \n   → Return true  \n\n→ Method: deleteFront() // 刪除前端  \n → Decision: 如果 size == 0?  \n  Yes → Return false // 空則失敗  \n  No  → front = (front + 1) mod k // 前移  \n   → size -= 1  \n   → Return true  \n\n→ Method: deleteLast() // 刪除後端  \n → Decision: 如果 size == 0?  \n  Yes → Return false  \n  No  → rear = (rear - 1 + k) mod k // 後移  \n   → size -= 1  \n   → Return true  \n\n→ Method: getFront() // 取得前端值  \n → Decision: 如果 size == 0?  \n  Yes → Return -1  \n  No  → Return data[front]  \n\n→ Method: getRear() // 取得後端值  \n → Decision: 如果 size == 0?  \n  Yes → Return -1  \n  No  → idx = (rear - 1 + k) mod k  \n   → Return data[idx]  \n\n→ Method: isEmpty() // 判斷是否空  \n → Return size == 0  \n\n→ Method: isFull() // 判斷是否滿  \n → Return size == k  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value):\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value):\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self):\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self):\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self):\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self):\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self):\n        return self.count == 0\n\n    def isFull(self):\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args)\n            results.append(None)\n        else:\n            method = getattr(obj, cmd)\n            res = method(*args)\n            results.append(res)\n\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmplyo6q9y5.py\", line 62, in <module>\n    commands = json.loads(data[0])\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode410.json",
    "problem_index_in_file": 0,
    "title": "Split Array Largest Sum",
    "description_snippet": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the la...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: split array into k subarrays minimizing largest sum: classic problem \"Split Array Largest Sum\". Approach: binary search on answer with feasibility check using greedy to count splits.\n\nWe need step-by-step virtual code lines with arrows. Let's design.\n\nSteps: Start, input array, k. Define lower bound = max element, upper bound = sum. While low < high: mid = (low+high)/2; if feasible(mid) -> high = mid else low = mid+1. After loop, answer = low. Feasible function: iterate array, accumulate sum, when > mid, increment count, reset sum to current element. Count <= k => true.\n\nWe'll produce virtual code lines accordingly.\n\nWe must use arrows for decision: Yes →, No →. Provide explanation comments.\n\nLet's produce lines.\n\nBe mindful of formatting: each line: \"虛擬碼步驟 [space] // 解釋\".\n\nStart, End, Decision. Use indentation? Not required but maybe arrow. We'll produce like example.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums 與整數 k // 取得輸入資料  \n→ Step 2: 計算 lowerBound = 最大值(nums) // 任何子陣列至少要包含最大元素  \n→ Step 3: 計算 upperBound = 所有元素和(nums) // 最大子陣列可能為整個陣列  \n→ Step 4: 設定 low = lowerBound, high = upperBound // 初始搜尋區間  \n→ Decision: while low < high? // 判斷搜尋是否完成  \n  Yes → Step 5: 計算 mid = (low + high) / 2 // 取區間中點作為猜測最大子陣列和  \n   → Step 6: 呼叫 Feasible(mid) 判斷能否以此最大值切分為 ≤ k 個子陣列  \n   → Decision: 若 Feasible(mid) 為真? // 可行則嘗試更小的最大值  \n    Yes → Step 7: 設定 high = mid // 收窄上界  \n    No  → Step 8: 設定 low = mid + 1 // 收窄下界  \n  No  → End // 搜尋結束  \n→ Step 9: 回傳 low // low 為最小化的最大子陣列和  \n\nStart // Feasible 函式開始  \n→ Step 10: 初始化 count = 1, currentSum = 0 // 起始一個子陣列  \n→ Decision: 遍歷 nums 中的每個元素 val? // 對每個元素進行處理  \n  Yes → Step 11: 若 currentSum + val <= target? // 可以加入現有子陣列  \n    Yes → Step 12: currentSum += val // 加入元素  \n    No  → Step 13: count += 1 // 開啟新子陣列  \n     → Step 14: currentSum = val // 以該元素作為新子陣列的和  \n  No  → End // 完成遍歷  \n→ Step 15: 回傳 count <= k // 能否切分為 k 個或更少子陣列  \nEnd // Feasible 函式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def splitArray(self, nums, k):\n        # 判斷給定最大子陣列和能否切分成 <= k 個子陣列\n        def can_split(limit):\n            count, cur_sum = 1, 0\n            for num in nums:\n                if cur_sum + num > limit:\n                    count += 1\n                    cur_sum = num\n                else:\n                    cur_sum += num\n            return count <= k\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if can_split(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n    # 取得 nums 的字串表示\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data, re.S)\n    k_match    = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not k_match:\n        print(\"Invalid input format\")\n        sys.exit(1)\n    nums_str = nums_match.group(1)\n    k_str    = k_match.group(1)\n\n    # 轉成實際的 list 與 int\n    try:\n        nums = eval(nums_str, {\"__builtins__\": {}})\n        k    = int(k_str)\n    except Exception as e:\n        print(\"Error parsing input:\", e)\n        sys.exit(1)\n\n    # 計算並輸出結果\n    result = Solution().splitArray(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [7,2,5,10,8], k = 2",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,5], k = 2",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode274.json",
    "problem_index_in_file": 0,
    "title": "H-Index",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Should implement algorithm: sort array descending, find maximum h where citations[i] >= i+1. Steps: Start, Input array, Sort descending, Initialize h=0, Iterate over sorted, if citation >= index+1 increment h, else break, End. Provide each line with explanation. Use arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 citations array // 從使用者取得論文引用數列  \n→ Step 2: Sort citations 以降序排列 // 方便快速比較  \n→ Step 3: 初始化 h_index 為 0 // 目前已找到的最大 h-index  \n→ Decision: 是否還有未檢查的引用數? // 判斷是否繼續遍歷  \n    Yes → Step 4: 取得下一個引用數 cur_citation // 取排序後的下一個值  \n    → Step 5: 取得目前索引 i (從 0 開始) // 代表已檢查的論文數量  \n    → Decision: 若 cur_citation ≥ i+1? // 檢查是否符合 h 指標條件  \n        Yes → Step 6: h_index = i+1 // 更新 h-index 為更大值  \n        No  → Step 7: 結束遍歷 // 已無法再找到更大的 h 指標  \n    → Decision: 繼續到下一個引用數? // 如果還有，回到 Decision 步驟  \n        Yes → 回到 Decision: 是否還有未檢查的引用數?  \n        No  → Step 8: 輸出 h_index // 顯示最終計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hIndex(self, citations):\n        # 先按降序排列\n        citations.sort(reverse=True)\n        h = 0\n        for i, c in enumerate(citations):\n            if c >= i + 1:\n                h = i + 1\n            else:\n                break\n        return h\n\ndef parse_citations(data: str):\n    \"\"\"\n    從輸入字串中擷取整數，並回傳對應的整數列表。\n    這裡使用正則表達式抓取所有數字，支援負號。\n    \"\"\"\n    numbers = re.findall(r'-?\\d+', data)\n    return [int(n) for n in numbers]\n\ndef main():\n    # 讀取所有輸入資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    citations = parse_citations(raw_input)\n    sol = Solution()\n    result = sol.hIndex(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [3,0,6,1,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode462.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements II",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for minimum moves to equal array elements with inc/dec by 1. Known solution: median minimal moves. So steps: compute median, sum abs differences. Use virtual code. Each line with explanation. Should be line-by-line.\n\nLet's produce:\n\nStart\n→ Step 1: Input array nums // receive array\n→ Step 2: Sort nums // sorting to find median\n→ Step 3: Determine median // median value\n→ Step 4: Initialize moves = 0 // accumulator\n→ Step 5: For each element x in nums // iterate\n    → Step 5.1: moves += abs(x - median) // add moves\n→ Step 6: Output moves // return result\nEnd\n\nBut need to include decision? maybe not necessary. Just linear steps.\n\nBut to follow format: need virtual code arrow notation. For loops we use \"For\" maybe.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: Input array nums // 取得整數陣列\n→ Step 2: Sort nums // 排序以便找到中位數\n→ Step 3: If n is odd Then median = nums[n/2] Else median = (nums[n/2-1] + nums[n/2]) / 2 // 取中位數\n→ Step 4: Initialize moves = 0 // 用於累計移動次數\n→ Step 5: For each element x in nums // 遍歷陣列\n    → Step 5.1: moves += abs(x - median) // 加上與中位數的差值\n→ Step 6: Output moves // 回傳最小移動次數\nEnd // 程式結束\n\nBut need to use arrow \"→\" before each step. Also decisions with \"Decision:\" maybe we use Decision for odd/even? Or just an if statement. Format says use Decision: if. So we can use:\n\n→ Decision: n odd? \n    Yes → Step 3a: median = nums[n/2]\n    No → Step 3b: median = (nums[n/2-1] + nums[n/2]) / 2\n\nBetter.\n\nAlso we can use for loop as step 5.\n\nOk.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: Input array nums // 取得整數陣列  \n→ Step 2: Sort nums // 排序以便找到中位數  \n→ Decision: n 是否為奇數? // 檢查陣列長度是否為奇數  \n  Yes → Step 3a: median = nums[n/2] // 奇數長度時取中間元素  \n  No  → Step 3b: median = (nums[n/2-1] + nums[n/2]) / 2 // 偶數長度時取兩個中間元素的平均  \n→ Step 4: Initialize moves = 0 // 用於累計需要的移動次數  \n→ Step 5: For each element x in nums // 遍歷所有元素  \n  → Step 5.1: moves += abs(x - median) // 加上 x 與中位數的差值  \n→ Step 6: Output moves // 回傳最小移動次數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minMoves2(self, nums):\n        if not nums:\n            return 0\n        nums.sort()\n        median = nums[len(nums)//2]\n        moves = 0\n        for num in nums:\n            moves += abs(num - median)\n        return moves\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Try to extract the list from the input\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data.strip()\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        # Fallback: evaluate as a full expression\n        nums = eval(list_part)\n    sol = Solution()\n    result = sol.minMoves2(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,10,2,9]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode209.json",
    "problem_index_in_file": 0,
    "title": "Minimum Size Subarray Sum",
    "description_snippet": "Given an array of positive integers nums and a positive integer target, return the minimal length of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanation. It's sliding window. We produce start, input array, target. Use variables: start, end, sum, minLen = INF. Loop end over array, add nums[end], while sum >= target: update minLen, subtract nums[start], increment start. After loop, if minLen == INF, return 0 else minLen.\n\nWe produce lines accordingly. Ensure each line has arrow → or Start, End. Use Decision. Provide comments in Chinese.\n\nLet's craft lines. We'll include lines for initialization, for loop, addition, decision, update, removal, etc. Ensure we adhere to format: each line: \"虛擬碼步驟 // 解釋\". The arrow may be part of step: \"→ Step 1: ...\".\n\nLet's produce.\n\nAlso mention reading input: Step 1: Initialize variables. Step 2: Start loop over indices. Step 3: Add current number to sum. Step 4: While sum >= target. Inside while: update minLen. Subtract from sum, increment start. After loop end, decide output. Then End.\n\nWe'll use \"Decision:\" for while condition? Actually while is loop; we can write \"Decision: sum >= target?\" with Yes → block. Let's produce accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 start = 0, sum = 0, minLen = 無限大 // 設定滑動窗口指標與最小長度  \n→ Step 2: 迭代 i 從 0 到 nums.length - 1 // 遍歷每個元素  \n    → Step 3: sum = sum + nums[i] // 將當前元素加入窗口總和  \n    → Decision: sum >= target? // 檢查窗口總和是否已達目標  \n        Yes → Step 4: minLen = min(minLen, i - start + 1) // 更新最小長度  \n        Yes → Step 5: sum = sum - nums[start] // 從窗口左端移除元素  \n        Yes → Step 6: start = start + 1 // 左指標右移  \n        Yes → Decision: sum >= target? // 重新檢查，若仍滿足則重複步驟 4-6  \n            Yes → ...  \n            No  → 回到 Step 2 的迴圈  \n        No  → 回到 Step 2 的迴圈  \n→ Decision: minLen == 無限大? // 判斷是否找到符合條件的子陣列  \n    Yes → Step 7: return 0 // 未找到任何子陣列，回傳 0  \n    No  → Step 8: return minLen // 返回最小子陣列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: list[int]) -> int:\n        left = 0\n        total = 0\n        min_len = float('inf')\n        for right in range(len(nums)):\n            total += nums[right]\n            while total >= target:\n                min_len = min(min_len, right - left + 1)\n                total -= nums[left]\n                left += 1\n        return 0 if min_len == float('inf') else min_len\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'target = 7, nums = [2,3,1,2,4,3]' 或多行形式的輸入。\n    返回 target 整數和 nums 列表。\n    \"\"\"\n    # 將所有換行視為逗號分隔\n    data = data.replace('\\n', ',')\n    parts = [p.strip() for p in data.split(',') if p.strip()]\n    values = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        # 使用 eval 解析數值（安全性假設輸入合法）\n        values[key] = eval(val)\n    target = values.get('target')\n    nums = values.get('nums')\n    return target, nums\n\ndef main():\n    input_data = sys.stdin.read()\n    target, nums = parse_input(input_data)\n    solution = Solution()\n    result = solution.minSubArrayLen(target, nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpthmzct9e.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpthmzct9e.py\", line 39, in main\n    target, nums = parse_input(input_data)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpthmzct9e.py\", line 32, in parse_input\n    values[key] = eval(val)\n                  ^^^^^^^^^\n  File \"<string>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpls0o8t58.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpls0o8t58.py\", line 39, in main\n    target, nums = parse_input(input_data)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpls0o8t58.py\", line 32, in parse_input\n    values[key] = eval(val)\n                  ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpfew8411b.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpfew8411b.py\", line 39, in main\n    target, nums = parse_input(input_data)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfew8411b.py\", line 32, in parse_input\n    values[key] = eval(val)\n                  ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode633.json",
    "problem_index_in_file": 0,
    "title": "Sum of Square Numbers",
    "description_snippet": "Given a non-negative integer c, decide whether there're two integers a and b such that a^2 + b^2 = c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step. We need to decide whether a and b exist such that a^2 + b^2 = c. Approach: iterate a from 0 to sqrt(c). For each a, compute b2 = c - a^2. Check if b2 is perfect square. If yes, return true. Else continue. At end, return false. Virtual code: Start, Step: calculate limit = floor(sqrt(c)). For a from 0 to limit, compute b2. Check perfect square by integer sqrt. If b^2 == b2, found. Yes. Decision: found? -> End true. If loop finishes -> End false. Need to output each step line with explanation. Use Decision, loops.\n\nLet's structure:\n\nStart\n→ Step 1: 计算 sqrt_c = floor(√c) // 计算最大 a\n→ Decision: 是否还有未遍历的 a? // 循环条件\n    Yes → Step 2: 对 a 从 0 到 sqrt_c 进行循环\n        → Step 3: 计算 b2 = c - a^2 // 计算 b 的平方\n        → Decision: b2 是否为非负数? // 检查有效性\n            Yes → Step 4: 计算 b = floor(√b2) // 取 b 的整数根\n            → Decision: b^2 == b2? // 判断是否完全平方\n                Yes → Step 5: 输出 true 并结束 // 找到 a,b\n                No  → Decision: 是否还有更大的 a? // 继续循环\n                    Yes → 回到 Step 2\n                    No  → Step 6: 输出 false 并结束 // 未找到\n            No  → Decision: 是否还有更大的 a? // 跳过此 a\n                Yes → 回到 Step 2\n                No  → Step 6: 输出 false 并结束\nEnd\n\nWe need to produce with arrows. Format: \"Start // ...\" etc. Each line separate.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 計算 limit = ⌊√c⌋ // 取得最大可能的 a\n→ Decision: a 是否小於等於 limit? // 循環判斷\n    Yes → Step 2: 計算 a^2 // 取得 a 的平方\n    → Step 3: 計算 b2 = c - a^2 // 需要的 b^2\n    → Decision: b2 是否非負? // 確保合法\n        Yes → Step 4: 計算 b = ⌊√b2⌋ // 取得 b 的整數根\n        → Decision: b^2 == b2? // 判斷 b2 是否為完全平方\n            Yes → Step 5: 輸出 true 並結束 // 找到合法 a,b\n            No  → Decision: a 是否 < limit? // 若尚未結束，繼續\n                Yes → Step 6: a = a + 1 // 進一步迭代\n                No  → Step 7: 輸出 false 並結束 // 沒有找到\n        No  → Decision: a 是否 < limit? // 若 b2 負，跳過此 a\n            Yes → Step 6: a = a + 1\n            No  → Step 7: 輸出 false 並結束\nEnd // 程式執行結束\n\nBut we need to ensure each line has format: \"虛擬碼步驟 // 解釋\". Also arrows for branching.\n\nNeed to include arrow for loop increments. Possibly use \"→\" at start of each step line, except Start and End. Also \"Decision:\" lines. For increments we can show \"→ Step 6: a = a + 1 // 增加 a\" etc.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 limit = ⌊√c⌋ // 取得 a 的最大可行值  \n→ Decision: a 是否小於等於 limit? // 判斷是否還有未檢查的 a  \n Yes → Step 2: 計算 a² // 取得 a 的平方  \n → Step 3: 計算 b2 = c - a² // 需要的 b² 值  \n → Decision: b2 是否非負? // 確保 b² 合法  \n  Yes → Step 4: 計算 b = ⌊√b2⌋ // 取得 b 的整數根  \n  → Decision: b² == b2? // 判斷 b² 是否為完全平方  \n   Yes → Step 5: 輸出 true 並結束 // 找到符合條件的 (a, b)  \n   No  → Decision: a 是否 < limit? // 若未檢查完所有 a，繼續迭代  \n    Yes → Step 6: a = a + 1 // 將 a 加 1 以進入下一輪  \n    No  → Step 7: 輸出 false 並結束 // 所有 a 都檢查完畢未找到  \n  No  → Decision: a 是否 < limit? // b2 負值時跳過此 a  \n   Yes → Step 6: a = a + 1 // 進入下一輪  \n   No  → Step 7: 輸出 false 並結束 // 所有 a 都檢查完畢未找到  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\nimport re\n\n# 判斷是否存在 a, b 使得 a^2 + b^2 = c\ndef judgeSquareSum(c: int) -> bool:\n    left = 0                               # a 的起點\n    right = math.isqrt(c)                  # b 的最大可能值\n    while left <= right:                   # 兩端同時往中心逼近\n        total = left * left + right * right\n        if total == c:                     # 找到符合條件的 a, b\n            return True\n        elif total < c:                    # 總和太小，增大 a\n            left += 1\n        else:                              # 總和太大，減小 b\n            right -= 1\n    return False                            # 所有組合都檢查完畢未找到\n\ndef main() -> None:\n    # 從標準輸入讀取原始字串，例如 \"c = 5\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 用正則表達式抓取第一個整數\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        return\n    c = int(match.group(1))\n\n    # 呼叫核心演算法並輸出結果\n    result = judgeSquareSum(c)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "c = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "c = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode667.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement II",
    "description_snippet": "Given two integers n and k, construct a list answer that contains n different positive integers rang...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for constructing a permutation of 1..n with exactly k distinct absolute differences between consecutive elements. It's known problem. Approach: Start with small sequence that yields k distinct differences: we can alternate between low and high ends to produce differences decreasing: For i from 1..k+1, we can pick numbers: 1, n, 2, n-1, 3, n-2,... this yields differences: n-1, n-2, n-3,... which gives k distinct differences. After that, we can append remaining numbers in ascending order to keep differences 1 only. So algorithm: create array result. left=1, right=n. for i in 0..k: if i%2==0: add left; left++ else: add right; right--. After this k+1 elements produced. Then append remaining numbers from left to right. The differences between last of the first part and first of the rest will be either 1? Let's verify: Suppose we ended with right side. After loop, we may have next numbers ascending, difference small maybe >1 but could introduce new differences. But known solution ensures the rest differences are all 1, because remaining numbers are contiguous. Actually after alternating, the remaining numbers are consecutive block. The last element of constructed part will be either low or high depending on parity. The remaining block will be either [left..right] where left>right? Let's test n=7,k=3: loop 0..3: i0 add 1; i1 add7; i2 add2; i3 add6. Result [1,7,2,6], left=3,right=5. Remaining block 3,4,5. Append 3,4,5 => final [1,7,2,6,3,4,5]. Differences:6,5,4,3,1,1. Distinct: {1,3,4,5,6}=5 >k? k=3, not correct. So we need different approach: typical solution: first generate k+1 numbers with alternating extremes to create distinct differences of n-1, n-2,..., n-k. After that, simply fill remaining numbers in increasing order from remaining unused numbers. But the difference between last of first part and first of second part may be not 1, could introduce new difference. However if we choose the remaining numbers in a specific order to keep differences as 1 or duplicates of existing differences, we can avoid new distinct differences.\n\nStandard solution: For n,k, build permutation: start with low=1, high=n. For i in 0..k: if i%2==0: answer.append(low); low++ else answer.append(high); high--. After this, if k%2==0: then append remaining numbers from low to high ascending; else: append remaining numbers from high to low descending. This ensures differences of 1 for remaining part and the boundary difference will be 1. Let's test n=7,k=3: low=1,high=7: i0 add1 low=2; i1 add7 high=6; i2 add2 low=3; i3 add6 high=5. Now low=3, high=5. k%2=1 (odd). So append remaining numbers from high to low descending: 5,4,3. Sequence [1,7,2,6,5,4,3]. Differences:6,5,4,1,1,1 => distinct {1,4,5,6}=4 >3. Hmm still 4. Wait boundary difference between 6 and5 is1 fine. But difference between 2 and6 is4 (existing). 6 and5 is1. 5 and4 is1. 4 and3 is1. So distinct differences: {6,5,4,1}. That's 4 distinct >3.\n\nSo maybe we need different arrangement: Actually standard problem: Build a permutation with exactly k distinct differences: Approach: start with 1..n. For first k+1 elements, choose pattern: 1, n, 2, n-1, ... as earlier. For rest, simply append the remaining numbers in increasing order. But we must ensure boundary difference between last of first part and next element is 1. In pattern above, after k+1 terms, the last term will be some middle number, and next remaining number (smallest unused) may create difference not equal to existing differences. But if we append remaining numbers in increasing order starting from the next smallest unused, the difference might be 1 or some existing difference? Let's test n=7,k=3: first part [1,7,2,6]. Remaining numbers: 3,4,5. Append 3: difference 3 (between 6 and3). 3 not in existing set {6,5,4}. So new difference 3 -> 4 distinct. So not good.\n\nAlternate strategy: after k+1 elements, we can append the remaining numbers in such an order that boundary difference is 1. That means the last element of first part must be adjacent to the next number (difference 1). So we need to design first part such that last element is either left or right side that is one away from next remaining number. We can simply produce first part of length k+1, and then fill the rest in either ascending or descending such that boundary difference is 1. For example, if we end with left side number, then next unused numbers start from left+1 upward, so difference 1. Similarly if we end with right side number, next unused start from right-1 downward. So we need to consider parity: if k is even, last added will be low side (since start with low). Let's check: For k=3 (odd), last added is high side? Sequence: i0 low, i1 high, i2 low, i3 high. So last is high side. After that remaining block low=3 high=5. We need next to be high-1=4? difference 2? Wait high side 6, remaining numbers are 5,4,3. If we append 5 first, difference 1. Good. Then 4,3 differences 1. So boundary difference is 1. But earlier we had pattern 5,4,3 produced differences 1. The resulting distinct differences were {6,5,4,1}. That was 4 >3. Because we still had 4. But we need only 3 distinct differences. Which differences existed? 6 (n-1),5 (n-2),4 (n-3). Those are 3 distinct. But we added 1 as a new difference. But we need to avoid introducing new distinct difference 1? Wait but we need exactly k distinct differences, so we need exactly k distinct numbers among all differences. If we add 1 as new difference, we get k+1. To avoid, we need to make all remaining differences belong to the set of existing differences. That means differences 1 must already be in the set. But 1 is not among n-1, n-2, n-3 unless n-3=1 i.e., n=4. So we need to ensure that we don't introduce difference 1 unless k already includes 1. That suggests that the set of k distinct differences is {1,2,...,k} after sorting? Actually we can choose any set of distinct differences; typical algorithm chooses differences decreasing from n-1 to n-k. That set doesn't include 1 unless n-k=1. So we need to avoid new difference 1. How to avoid? Instead of appending ascending or descending, we can append numbers such that differences are one of the already used differences. For that, we can append the remaining numbers in increasing order but starting from the last number of first part minus 1 or plus 1 such that differences equal existing. But maybe easier: we can construct permutation as: first part produce k+1 numbers using pattern; remaining numbers appended in increasing order from left to right but after the first part we may have differences not in set. However we can adjust: Instead of using low and high extremes, we can use pattern that yields differences {k, k-1, ..., 1}. For example, construct first part as: 1, 1+k, 1, 1+k-1, ... Actually known solution: For k distinct differences, we can build as: For i from 1 to k+1: if i is odd: append i; else: append n - (i/2)+1? I'm fuzzy.\n\nLet's recall known Leetcode problem 2172 \"Make Array Zero by Subtracting Equal Amount\". Wait not that. There's problem 1474? Actually this is Leetcode 1474? Not sure.\n\nBut known approach: For given n and k, we can construct answer as:\n\nlet left=1, right=n, result=[]\n\nfor i in range(k+1):\n   if i%2==0: result.append(left); left+=1\n   else: result.append(right); right-=1\n\nAfter that, if k%2==0: # even\n   # append remaining in ascending order from left to right\n   result.extend(range(left, right+1))\nelse:\n   # append remaining in descending order from right to left\n   result.extend(range(right, left-1, -1))\n\nThis yields exactly k distinct differences. Let's test with n=7,k=3: left=1 right=7\ni0: add1 left=2\ni1: add7 right=6\ni2: add2 left=3\ni3: add6 right=5\nNow left=3 right=5 k%2==1 -> append descending 5,4,3\nResult [1,7,2,6,5,4,3]\nDifferences:6,5,4,1,1,1 -> distinct {1,4,5,6} =4. So not correct.\n\nMaybe I misremember; maybe correct formula is: if k%2==0: append remaining ascending; else: append remaining descending, but also reverse order? Let's test n=5,k=2: left=1 right=5\ni0 add1 left=2\ni1 add5 right=4\ni2 add2 left=3\nNow left=3 right=4, k%2=0 -> ascending 3,4\nResult [1,5,2,3,4]\nDifferences:4,3,1,1 -> distinct {1,3,4} =3 >2.\n\nSo this algorithm gives k+1 distinct differences. So we need to adjust differences to be exactly k.\n\nPerhaps we need to build differences that are 1..k, not n-1..n-k. The known solution: For given n,k, we can construct permutation where the first k+1 elements produce differences of k, k-1, ..., 1, and then remaining elements produce difference 1 repeated. That yields exactly k distinct differences: {1,...,k}. Approach: Use two pointers low=1, high= k+1? Actually we can produce sequence: for i from 0 to k: if i%2==0: append 1 + i//2; else: append k+1 - i//2. This yields differences k, k-1,...,1. Example n=7,k=3: k+1=4. Build first part of length 4: i=0 add 1; i=1 add 4; i=2 add 2; i=3 add 3 => [1,4,2,3]. Differences:3,2,1 distinct {1,2,3}. Good. Then remaining numbers are 5,6,7 ascending. Append 5,6,7. Differences between 3 and5 is2, already in set. Between 5 and6 is1. So overall distinct still {1,2,3}. Works.\n\nLet's test n=5,k=2: first part length 3: sequence: i0 add1; i1 add3; i2 add2 => [1,3,2]. Differences:2,1 distinct {1,2}. Remaining numbers 4,5 ascending: diff between 2 and4=2 (existing), 4-5=1. Distinct stays {1,2}. Works.\n\nThus algorithm: generate first k+1 numbers using alternating low/high within range 1..k+1. After that, append remaining numbers from k+2 to n ascending. That yields exactly k distinct differences {1..k}. This works for any n>k. If k= n-1, first part uses 1..n: produce differences n-1..1. Works.\n\nSo virtual code: compute first part as described, then rest.\n\nImplement:\n\nStart\n→ Initialize list answer\n→ left = 1\n→ right = k+1\n→ i=0\n→ While i <= k:\n    If i % 2 == 0:\n        answer.append(left)\n        left += 1\n    Else:\n        answer.append(right)\n        right -= 1\n    i += 1\n→ For num from k+2 to n:\n    answer.append(num)\nEnd\n\nReturn answer.\n\nWe should add comment lines. Also need to output virtual code lines with \"→\" arrow. Use Decision nodes? Not needed.\n\nBut maybe we need to handle n==k? Actually if n==k+1, no remaining part. Works.\n\nOk produce virtual code with step numbers? Not necessary, just sequential.\n\nLet's craft lines:\n\nStart\n→ Step 1: 初始化 answer 為空列表 // 建立結果容器\n→ Step 2: 設定 left = 1, right = k + 1, i = 0 // 左右指標與迴圈索引\n→ Decision: i <= k? // 產生前 k+1 個元素\n    Yes → Step 3: 如果 i 為偶數，加入 left 並 left++ // 取最小剩餘數\n    Yes → Step 4: 否則加入 right 並 right-- // 取最大剩餘數\n    Yes → Step 5: i++ // 前進索引\n    Yes → 回到 Decision\n→ Step 6: 從 k + 2 到 n (若有) 依序加入 answer // 填充剩餘數字\nEnd\n\nReturn answer? The problem says return list. We can include Step 7: Return answer.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 answer 為空列表 // 用於儲存結果的容器  \n→ Step 2: 設定 left = 1, right = k + 1, i = 0 // 左右指標與迴圈索引  \n→ Decision: i <= k? // 產生前 k+1 個元素，形成 k 個不同的差值  \n  Yes → Step 3: 如果 i 為偶數，加入 left 並 left++ // 取最小剩餘數，差值開始最大  \n  Yes → Step 4: 否則加入 right 並 right-- // 取最大剩餘數，交替產生差值  \n  Yes → Step 5: i++ // 進一步迭代  \n  Yes → 回到 Decision  \n→ Step 6: 從 k + 2 到 n (若有) 依序加入 answer // 其餘數字按遞增順序填入，差值只會是已存在的 1~k  \n→ Step 7: Return answer // 回傳符合條件的排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def constructArray(self, n: int, k: int):\n        res = []\n        left, right = 1, k + 1\n        \n        # 先生成 k 個不同差值\n        for i in range(k + 1):\n            if i % 2 == 0:\n                res.append(left)\n                left += 1\n            else:\n                res.append(right)\n                right -= 1\n        \n        # 剩下的直接遞增填充\n        for i in range(k + 2, n + 1):\n            res.append(i)\n        \n        return res\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    sol = Solution()\n    answer = sol.constructArray(n, k)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 1",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 2",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode69.json",
    "problem_index_in_file": 0,
    "title": "Sqrt(x)",
    "description_snippet": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for integer sqrt with floor, no pow or exponent. Use binary search.\n\nWe need step by step, with Start, →, Decision, End.\n\nWe need each line: virtual code step + space + // explanation.\n\nWe need to include arrow → for step lines, Decision: etc. For loops? We'll do binary search.\n\nPseudo:\n\nStart\n→ Step 1: Read x // input non-negative int\n→ Step 2: If x == 0 or 1 → return x // trivial cases\n→ Step 3: Set low = 1, high = x // search bounds\n→ Decision: while low <= high? // loop\n    Yes → Step 4: mid = (low + high) // 2 // mid point\n    → Decision: mid*mid <= x? // compare square\n        Yes → Step 5: ans = mid // store candidate\n            → Decision: mid*mid == x? // exact hit\n                Yes → Step 6: return mid // done\n                No → Step 7: low = mid + 1 // search higher\n        No → Step 8: high = mid - 1 // search lower\n→ Step 9: return ans // after loop ends\n\nBut we need \"virtual code\" lines. Each line may be like \"Step 1: ...\".\n\nNeed to use arrows and Decision. For while loop we can treat as Decision: low <= high? Yes: do steps, No: go to End.\n\nWe should also show the loop body lines. For nested decisions we indent.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取非負整數 x // 取得輸入值\n→ Decision: x 等於 0 或 1? // 簡易情況\n    Yes → Step 2: 回傳 x // 直接回傳結果\n    No  → Step 3: 設定 low = 1, high = x // 初始化搜尋範圍\n→ Decision: low <= high? // 進入二分搜尋迴圈\n    Yes → Step 4: mid = (low + high) // 2 // 取中值\n        → Decision: mid * mid <= x? // 檢查 mid 的平方\n            Yes → Step 5: ans = mid // 暫存候選答案\n                → Decision: mid * mid == x? // 是否正好等於\n                    Yes → Step 6: 回傳 mid // 完成\n                    No  → Step 7: low = mid + 1 // 往高端搜尋\n            No  → Step 8: high = mid - 1 // 往低端搜尋\n    No  → Step 9: 回傳 ans // 迴圈結束，回傳最接近的整數平方根\nEnd // 程式執行結束\n\nBut we need to put arrow for each step line, and Decision lines preceded by \"Decision:\".\n\nAlso we might need to include \"→\" before Step lines. Yes.\n\nAlso for nested decision indent maybe with spaces.\n\nMake sure each line has the virtual code step plus space plus explanation comment.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取非負整數 x // 取得輸入值\n→ Decision: x 等於 0 或 1? // 簡易情況\n    Yes → Step 2: 回傳 x // 直接回傳結果\n    No  → Step 3: 設定 low = 1, high = x // 初始化搜尋範圍\n→ Decision: low <= high? // 進入二分搜尋迴圈\n    Yes → Step 4: mid = (low + high) // 2 // 取中值\n        → Decision: mid * mid <= x? // 檢查 mid 的平方\n            Yes → Step 5: ans = mid // 暫存候選答案\n                → Decision: mid * mid == x? // 是否正好等於\n                    Yes → Step 6: 回傳 mid // 完成\n                    No  → Step 7: low = mid + 1 // 往高端搜尋\n            No  → Step 8: high = mid - 1 // 往低端搜尋\n    No  → Step 9: 回傳 ans // 迴圈結束，回傳最接近的整數平方根\nEnd // 程式執行結束",
      "generated_code": "def my_sqrt(x: int) -> int:\n    \"\"\"\n    依照題目使用二分搜尋計算整數平方根 (向下取整)。\n    \"\"\"\n    if x < 2:\n        return x\n\n    left, right = 1, x // 2\n    answer = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        sq = mid * mid\n        if sq == x:\n            return mid\n        elif sq < x:\n            left = mid + 1\n            answer = mid          # 目前為止最接近但不超過的候選答案\n        else:\n            right = mid - 1\n\n    return answer\n\n\nif __name__ == \"__main__\":\n    import sys\n    import re\n\n    # 讀取全部輸入，並尋找第一個數字（允許有文字說明）\n    raw = sys.stdin.read()\n    numbers = re.findall(r'\\d+', raw)\n    x_val = int(numbers[0]) if numbers else 0\n\n    print(my_sqrt(x_val))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 8",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode385.json",
    "problem_index_in_file": 0,
    "title": "Mini Parser",
    "description_snippet": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for deserializing nested integer list string. Provide line-by-line pseudo code with explanation comments. Use Start, End, Decision, arrows. Not actual code. We'll produce steps for algorithm: use stack to parse characters. When encountering digits, build number. When '[' start new list push. When ']' close list pop. Commas separate. Implementation details: if string length 1-digit? Actually string could be single integer, no brackets. So we check if first char not '[' then return NestedInteger(int(s)). We'll handle negative numbers. Use variable num, negative flag. Provide algorithm. Ensure we adhere to format: each line \"虛擬碼步驟 // 解釋\". Provide step numbers optional but not necessary. Let's produce.\n\nWe'll structure:\n\nStart\n→ Decision: s[0] == '['? // check if it's a list\n    Yes → Step: 初始化 stack, current = null\n    No  → Step: return NestedInteger(int(s)) // single integer\n\nFor list:\n→ Step: For each char in s\n    Decision: char == '['\n        Yes → Step: create new NestedInteger list, push onto stack, set current\n        No  → Decision: char == ']'\n            Yes → Step: if num parsed, add to current; pop stack; update current\n            No  → Decision: char == ','\n                Yes → Step: if num parsed, add to current; reset num\n                No  → Decision: char == '-' \n                    Yes → Step: negative = true\n                    No → Step: digit char, accumulate num\n\nAfter loop, if stack empty, result is current else stack.top\n\nEnd\n\nWe need to include arrow and explanation per line. Provide clear step labels.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 字串是否以 '[' 開頭? // 判斷輸入是否為列表  \n Yes → Step 1: 初始化堆疊 stack，並將 current 設為 null // 準備存放正在構建的 NestedInteger  \n No  → Step 2: 直接回傳 NestedInteger(整數值) // 單個整數情況，解析完成  \nEnd // 單個整數情況結束  \n\nYes → Step 3: 迭代字串中的每一個字元 ch  \n Decision: ch 是否為 '['? // 開始新的子列表  \n  Yes → Step 4: 建立新的 NestedInteger list，若 current 存在則將其加入到 current，推入堆疊，並設 current 為新列表 // 建立新子列表並把目前列表加入堆疊  \n  No  → Decision: ch 是否為 ']'? // 結束目前子列表  \n   Yes → Step 5: 若已累積數字，將其轉為 NestedInteger 並加入 current，清空累積變數；若堆疊非空則 pop 為上一層列表並設 current 為該上一層 // 結束子列表並返回上一層  \n   No  → Decision: ch 是否為 ','? // 分隔符號，表示一個元素結束  \n    Yes → Step 6: 若已累積數字，將其轉為 NestedInteger 並加入 current，清空累積變數 // 處理分隔符號後的整數元素  \n    No  → Decision: ch 是否為 '-'? // 數字負號  \n     Yes → Step 7: 設定 negative flag 為 true，準備累積負數 // 記錄負號  \n     No → Step 8: ch 為數字字元，累積到 num 並考慮負號 // 數字字符累積  \nEnd // 完整字串遍歷結束  \n\n→ Decision: stack 是否為空? // 判斷是否還有父層未結束  \n Yes → Step 9: 回傳 current // 完成，返回最外層 NestedInteger  \n No  → Step 10: 取堆疊頂端作為結果，返回 // 若堆疊不空，回傳最外層列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass NestedInteger:\n    \"\"\"\n    代表一個可以是整數或列表的資料結構。\n    \"\"\"\n    def __init__(self, value=None):\n        if value is None:\n            self._list = []\n            self._int = None\n        else:\n            self._list = None\n            self._int = int(value)\n\n    def isInteger(self):\n        return self._int is not None\n\n    def add(self, ni):\n        if self._list is None:\n            self._list = []\n        self._list.append(ni)\n\n    def setInteger(self, value):\n        self._int = int(value)\n        self._list = None\n\n    def getInteger(self):\n        return self._int\n\n    def getList(self):\n        return self._list\n\n    def __str__(self):\n        \"\"\"\n        產生與輸入格式相同的字串表示。\n        \"\"\"\n        if self.isInteger():\n            return str(self._int)\n        else:\n            return '[' + ','.join(str(x) for x in self._list) + ']'\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        \"\"\"\n        將序列化字串轉回 NestedInteger 物件。\n        \"\"\"\n        # 單個整數情況\n        if not s or s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack = []\n        num = ''\n        negative = False\n\n        for ch in s:\n            if ch == '-':\n                negative = True\n            elif ch.isdigit():\n                num += ch\n            elif ch == '[':\n                stack.append(NestedInteger())\n            elif ch in ',]':\n                # 先將累積的數字加入目前列表\n                if num:\n                    value = int(num) if not negative else -int(num)\n                    stack[-1].add(NestedInteger(value))\n                    num = ''\n                    negative = False\n                # 看到閉括號時，把子列表加到上一層\n                if ch == ']' and len(stack) > 1:\n                    completed = stack.pop()\n                    stack[-1].add(completed)\n\n        # 最終結果在堆疊底部\n        return stack[0]\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從輸入字串取得實際的序列化字串。\n    輸入格式預期為 's = \"...\"' 或直接為字串。\n    \"\"\"\n    raw = raw.strip()\n    # 找到第一個雙引號與最後一個雙引號之間的內容\n    first_quote = raw.find('\"')\n    last_quote = raw.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        return raw[first_quote + 1:last_quote]\n    # 如果沒有引號，直接回傳\n    return raw\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = Solution().deserialize(s)\n    print(str(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"324\"",
          "expected_output": "324",
          "success": true,
          "output": "324"
        },
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "success": true,
          "output": "[123,[456,[789]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode477.json",
    "problem_index_in_file": 0,
    "title": "Total Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm. Input: array of integers. Need sum of Hamming distances over all pairs. Approach: For each bit position 0-31, count number of numbers with bit 1: count1. Then number of pairs with differing bits: count1 * (n - count1). Sum across bits. Return sum.\n\nWe need to output line by line virtual code steps with comments. Format:\n\nStart\n→ Step 1: Initialize sum = 0 // variable to accumulate result\n→ Step 2: n = length(nums) // number of elements\n→ Decision: 0 <= bit <= 31? // loop over bit positions\n   Yes → Step 3: count1 = 0 // reset count for this bit\n   → Step 4: for each num in nums? // iterate over array\n       → Decision: (num >> bit) & 1 == 1? // check if bit is set\n           Yes → Step 5: count1 = count1 + 1 // increment count\n   → Step 6: count0 = n - count1 // numbers with bit 0\n   → Step 7: sum = sum + count1 * count0 // add pairs differing at this bit\n   → Step 8: bit = bit + 1 // next bit\n   → Decision: bit <= 31? // continue\n       Yes → repeat\n       No → End\n\nAlso need return sum.\n\nInclude comment after each line. Ensure format with arrow etc. Use virtual code: Start, → Step, Decision, End.\n\nAlso need to return sum. Add Step: return sum.\n\nWe must follow formatting: each line `虛擬碼步驟 // 解釋`.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: sum ← 0 // 初始化累計變數\n→ Step 2: n ← length(nums) // 取得陣列長度\n→ Decision: bit = 0 <= 31? // 循環每一位元 (0~31)\n    Yes → Step 3: count1 ← 0 // 這一位元中 1 的數量\n    → Step 4: for each num in nums do // 遍歷所有數字\n        → Decision: ((num >> bit) & 1) == 1? // 判斷此位元是否為 1\n            Yes → Step 5: count1 ← count1 + 1 // 1 的數量加一\n    → Step 6: count0 ← n - count1 // 這一位元中 0 的數量\n    → Step 7: sum ← sum + count1 * count0 // 將不同位元對數加入總和\n    → Step 8: bit ← bit + 1 // 進到下一位元\n    → Decision: bit <= 31? // 是否還有位元需要處理\n        Yes → repeat\n        No → Step 9: return sum // 回傳最終結果\nEnd // 程式執行結束\n\nWe need to ensure each line has arrow arrow? Actually first lines start with Start, then arrow. The decision lines may have indentation and Yes → etc. Must match format exactly.\n\nAlso must use '→' before Step. And 'Decision:' lines. For nested we indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: sum ← 0 // 初始化累計變數\n→ Step 2: n ← length(nums) // 取得陣列長度\n→ Decision: bit = 0 <= 31? // 循環每一位元 (0~31)\n    Yes → Step 3: count1 ← 0 // 這一位元中 1 的數量\n    → Step 4: for each num in nums do // 遍歷所有數字\n        → Decision: ((num >> bit) & 1) == 1? // 判斷此位元是否為 1\n            Yes → Step 5: count1 ← count1 + 1 // 1 的數量加一\n    → Step 6: count0 ← n - count1 // 這一位元中 0 的數量\n    → Step 7: sum ← sum + count1 * count0 // 將不同位元對數加入總和\n    → Step 8: bit ← bit + 1 // 進到下一位元\n    → Decision: bit <= 31? // 是否還有位元需要處理\n        Yes → repeat\n        No → Step 9: return sum // 回傳最終結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef total_hamming_distance(nums):\n    total = 0\n    n = len(nums)\n    for i in range(32):\n        count1 = 0\n        for num in nums:\n            if (num >> i) & 1:\n                count1 += 1\n        count0 = n - count1\n        total += count1 * count0\n    return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析類似 \"nums = [4,14,2]\" 的輸入\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        nums = []\n    print(total_hamming_distance(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,14,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [4,14,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode115.json",
    "problem_index_in_file": 0,
    "title": "Distinct Subsequences",
    "description_snippet": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\n\nThe test...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm: count distinct subsequences of s equal to t. Classic DP: dp[i][j] count subseqs of s[0..i-1] equals t[0..j-1]. Use 1D or 2D. Let's output step-by-step explanation. Use Start, Decision, etc. Provide each step line with virtual code and comment. Need to produce code in natural language pseudo-code with arrow notation. The output must be in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrow ->. Provide structure: Start, End, Decision: etc.\n\nWe need to output step by step: input reading, initialize dp array, iterate, update dp, return result.\n\nWe can use 1D DP: dp[j] for current i. Use previous dp[j] from last i-1, and dp[j-1] from same i.\n\nPseudo-code:\n\nStart\n→ Read strings s, t // 取得 s 與 t\n→ Decision: t 空? // 檢查 t 是否為空\n    Yes → Return 1 // 空子序列只有一個\n    No → Decision: s 空? // s 是否為空\n        Yes → Return 0 // 不能產生 t\n        No →\n→ Initialize array dp length |t|+1 with 0 // dp[j] 代表 s 前 i 個字元對應 t 前 j 個字元的計數\n→ Set dp[0] = 1 // 空子序列\n→ For i from 1 to |s|: // 逐個處理 s\n    → For j from |t| down to 1: // 從尾到頭避免覆蓋\n        → Decision: s[i-1] == t[j-1]? // 比較字元\n            Yes → dp[j] = dp[j] + dp[j-1] // 若相同，累加\n            No  → dp[j] = dp[j] // 保持不變\n→ Return dp[|t|] // 回傳答案\nEnd\n\nBut need to format with arrow and Decision lines. Use \"→ Decision:\" for conditions. For loops we can show as \"→ For i from 1 to |s|:\" etc. Provide explanation. Need to ensure each line includes \" // 解釋\".\n\nAlso need to use arrows \"→\" for steps. The sample shows \"→ Step 1: ...\". So we can use \"Step 1:\" etc. But for loops maybe \"Step X:\".\n\nLet's produce:\n\nStart\n→ Step 1: 輸入字串 s, t // 取得輸入資料\n→ Decision: t 是否為空? // 判斷 t 是否為空串\n    Yes → Step 2: 回傳 1 // 空子序列只有一種\n    No  → Decision: s 是否為空? // 判斷 s 是否為空串\n        Yes → Step 3: 回傳 0 // 無法產生 t\n        No  →\n→ Step 4: 初始化 dp 陣列長度 |t|+1 為 0 // dp 用於存放子序列計數\n→ Step 5: 設定 dp[0] = 1 // 空子序列計數\n→ Step 6: 逐字元遍歷 s 從 i=1 到 |s|:\n    → Step 7: 內部循環 j 從 |t| 下降到 1:\n        → Decision: s[i-1] == t[j-1]? // 比對字符\n            Yes → Step 8: dp[j] = dp[j] + dp[j-1] // 更新計數\n            No  → Step 9: dp[j] = dp[j] // 保持原值\n→ Step 10: 回傳 dp[|t|] // 返回最終計數\nEnd\n\nNeed to include \"→\" at beginning of each step line. For decision blocks, we need indentation maybe spaces.\n\nWe also need to use arrow for nested steps. Format: \"→ Decision:\" then nested lines with indentation and \"Yes →\", \"No →\". Provide explanation after each line.\n\nLet's craft final output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 輸入字串 s, t // 取得輸入資料\n→ Decision: t 是否為空? // 判斷 t 是否為空串\n    Yes → Step 2: 回傳 1 // 空子序列只有一種\n    No  → Decision: s 是否為空? // 判斷 s 是否為空串\n        Yes → Step 3: 回傳 0 // 無法產生 t\n        No  →\n→ Step 4: 初始化 dp 陣列長度 |t|+1 為 0 // dp 用於存放子序列計數\n→ Step 5: 設定 dp[0] = 1 // 空子序列計數\n→ Step 6: 逐字元遍歷 s 從 i=1 到 |s|:\n    → Step 7: 內部循環 j 從 |t| 下降到 1:\n        → Decision: s[i-1] == t[j-1]? // 比對字符\n            Yes → Step 8: dp[j] = dp[j] + dp[j-1] // 更新計數\n            No  → Step 9: dp[j] = dp[j] // 保持原值\n→ Step 10: 回傳 dp[|t|] // 返回最終計數\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef numDistinct(s: str, t: str) -> int:\n    \"\"\"\n    計算 s 的子序列等於 t 的數量\n    使用 1 維 DP，dp[j] 表示目前已處理完 s 的前 i 個字元時\n    能對應到 t 的前 j 個字元的子序列數量。\n    \"\"\"\n    n = len(t)\n    dp = [0] * (n + 1)\n    dp[0] = 1  # 空子序列\n\n    for ch in s:\n        # 從後往前更新，避免覆寫 dp[j-1] 的值\n        for j in range(n, 0, -1):\n            if ch == t[j - 1]:\n                dp[j] += dp[j - 1]\n    return dp[n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    # 嘗試解析「s = \"xxx\", t = \"yyy\"」的格式\n    pattern = re.compile(r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*t\\s*=\\s*\"([^\"]*)\"')\n    match = pattern.search(data)\n\n    if match:\n        s, t = match.group(1), match.group(2)\n    else:\n        # 如果輸入是兩行分別為 s 與 t\n        parts = data.splitlines()\n        if len(parts) >= 2:\n            s, t = parts[0].strip(), parts[1].strip()\n        else:\n            # 只剩一行，嘗試以空白切割\n            parts = data.split()\n            s = parts[0]\n            t = parts[1] if len(parts) > 1 else \"\"\n\n    result = numDistinct(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode211.json",
    "problem_index_in_file": 0,
    "title": "Design Add and Search Words Data Structure",
    "description_snippet": "Design a data structure that supports adding new words and finding if a string matches any previousl...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. We need to design WordDictionary using trie perhaps. Provide steps: start, initialize root node with children dict and isEnd flag. addWord: iterate characters, create child nodes. search: recursively match dot. Use decision nodes. Let's produce steps.\n\nThe virtual code format: Start // 程式開始執行\n→ Step 1: 定義 TrieNode // 定義 trie 節點\n→ Step 2: 初始化 WordDictionary // 建構函式\n→ Step 3: addWord 方法\n→ Step 4: search 方法\nBut need decision flows for search. Provide recursion.\n\nWe need to maintain virtual code lines with arrow and explanation. Use Yes → No → for decisions.\n\nLet's produce step-by-step.\n\nWe might produce the following lines:\n\nStart // 程式開始執行\n→ Step 1: 創建 TrieNode 類別 // 定義節點結構\n    // 包含 children（map）和 isEnd（布林）\n→ Step 2: WordDictionary 初始化 // 建立根節點\n    → Step 2.1: root = new TrieNode() // 根節點\n→ Step 3: addWord(word) // 添加新單詞\n    → Decision: word 為空? // 檢查空字串\n        Yes → End // 空字串不處理\n        No  → Step 3.1: current = root // 從根節點開始\n    → Step 3.2: 對每個字符 c in word\n        → Decision: current.children 是否包含 c? // 檢查子節點\n            Yes → Step 3.3: current = current.children[c] // 進入已有節點\n            No  → Step 3.4: current.children[c] = new TrieNode(); current = current.children[c] // 建立新節點\n    → Step 3.5: current.isEnd = true // 標記單詞結尾\n→ Step 4: search(word) // 搜尋\n    → Decision: word 為空? // 檢查空字串\n        Yes → Step 4.1: return root.isEnd // 根節點是否為單詞\n        No  → Step 4.2: return searchRecursive(root, word, 0) // 進行遞迴搜尋\n    // 搜尋遞迴函式\n    → Step 4.3: 定義 searchRecursive(node, word, index)\n        → Decision: index == len(word)? // 到達字串結尾\n            Yes → Step 4.3.1: return node.isEnd // 是否匹配到單詞\n            No  → Step 4.3.2: currentChar = word[index] // 取得當前字符\n                → Decision: currentChar == '.'? // 點號特殊處理\n                    Yes → Step 4.3.3: 對每個子節點 child in node.children\n                            → Step 4.3.3.1: if searchRecursive(child, word, index+1) return true // 若任意子節點匹配成功則返回\n                    No  → Step 4.3.4: Decision: node.children 是否包含 currentChar? // 是否存在對應子節點\n                        Yes → Step 4.3.4.1: return searchRecursive(node.children[currentChar], word, index+1) // 進一步遞迴\n                        No  → Step 4.3.4.2: return false // 沒有匹配節點\nEnd // 程式執行結束\n\nBut we need to output each line as virtual code step with arrow and explanation. We need to format exactly as specified: Each line: `虛擬碼步驟` + space + `// 解釋/說明`. Use arrow `→` or `Yes →`, `No →`. Also we need to use `Start`, `End`. And maybe use indentation to reflect decision structure? But in the example, they used indentation lines with `Yes →` and `No →`. We'll mimic.\n\nLet's produce final output accordingly.\n\nWe need to ensure that we don't output actual code, just virtual steps. We should use comments to explain.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 類別 // 建立 trie 節點結構  \n  // 屬性：children（字典）、isEnd（布林）  \n→ Step 2: WordDictionary 初始化 // 建構 WordDictionary 物件  \n  → Step 2.1: root = 新 TrieNode() // 創造根節點  \n→ Step 3: addWord(word) // 新增單詞  \n  → Decision: word 為空?  \n   Yes → End // 空字串不處理  \n   No  → Step 3.1: current = root // 從根節點開始  \n    → Step 3.2: 對每個字元 c in word  \n     → Decision: current.children 包含 c?  \n      Yes → Step 3.2.1: current = current.children[c] // 進入已存在子節點  \n      No  → Step 3.2.2: current.children[c] = 新 TrieNode(); current = current.children[c] // 建立新節點  \n     → Step 3.3: current.isEnd = True // 標記單詞結尾  \n→ Step 4: search(word) // 搜尋匹配  \n  → Decision: word 為空?  \n   Yes → Step 4.1: return root.isEnd // 空字串匹配檢查  \n   No  → Step 4.2: return searchRecursive(root, word, 0) // 開始遞迴搜尋  \n  // 定義遞迴搜尋函式  \n  → Step 4.3: searchRecursive(node, word, index)  \n   → Decision: index == len(word)?  \n    Yes → Step 4.3.1: return node.isEnd // 已到末尾，檢查是否為完整單詞  \n    No  → Step 4.3.2: currentChar = word[index] // 取得當前字元  \n     → Decision: currentChar == '.'?  \n      Yes → Step 4.3.3: 對每個子節點 child in node.children  \n       → Step 4.3.3.1: if searchRecursive(child, word, index+1) return True // 任一子節點成功即為匹配  \n      No  → Step 4.3.4: Decision: node.children 包含 currentChar?  \n       Yes → Step 4.3.4.1: return searchRecursive(node.children[currentChar], word, index+1) // 直接往下遞迴  \n       No  → Step 4.3.4.2: return False // 沒有對應子節點，匹配失敗  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            ch = word[i]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], i + 1)\n        return dfs(self.root, 0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，預期格式為兩個 JSON 陣列\n    commands, args_list = json.loads(data)\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        else:\n            method = getattr(obj, cmd)\n            # args 可能為空列表\n            res = method(*args) if args else method()\n            results.append(res)\n    # 將結果轉為 LeetCode 風格輸出\n    out_parts = []\n    for r in results:\n        if r is None:\n            out_parts.append(\"null\")\n        elif isinstance(r, bool):\n            out_parts.append(\"true\" if r else \"false\")\n        else:\n            out_parts.append(str(r))\n    print(\"[\" + \",\".join(out_parts) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmptd3_iof7.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmptd3_iof7.py\", line 42, in main\n    commands, args_list = json.loads(data)\n                          ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode556.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element III",
    "description_snippet": "Given a positive integer n, find the smallest integer which has exactly the same digits existing in ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the algorithm to find next greater number with same digits (next permutation). Also handle no answer or overflow 32-bit. Provide each line with arrow, decision etc. Should include start, steps, decisions. Provide explanation comments.\n\nLet's design pseudocode:\n\nStart\n→ Step 1: convert n to list of digits (array) // get digits\n→ Decision: if array length 1? // trivial\n    No → continue\n→ Step 2: Find pivot index i from right where digits[i] < digits[i+1] // find first decreasing\n    If no such i -> No greater permutation\n        → Step 3: Return -1 // overflow? no\n    Yes → Continue\n→ Step 3: Find successor index j from right where digits[j] > digits[i]\n→ Step 4: Swap digits[i] and digits[j]\n→ Step 5: Reverse subarray from i+1 to end // ascending order\n→ Step 6: Convert digits back to number res\n→ Decision: if res > 2^31-1 then\n    Yes → Step 7: Return -1\n    No → Step 8: Return res\n\nAlso handle negative? not needed, positive.\n\nNeed to include 32-bit check.\n\nAlso need to convert number to digits: maybe use toString and split. Also reassembly: parseInt.\n\nLet's write virtual code accordingly. Each line arrow indent accordingly.\n\nMake sure to include decisions with Yes → and No →.\n\nWe must not output real code. Use structure.\n\nLet's craft.\n\nWe also may include initial comment: Step 0: Input n.\n\nWe need to maintain step numbers or not? Example uses Step 1, Step 2. Use Step numbering.\n\nOk.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 把 n 轉成數字陣列 digits = n 的每一個數位 // 取得所有數位  \n→ Decision: 如果 digits 的長度 < 2? // 只有一個數位時不可能有更大的排列  \n    Yes → Step 2: 返回 -1 // 無法產生更大的數字  \n    No  →  \n→ Step 3: 從右向左尋找第一個數位 digits[i] < digits[i+1] 的位置 i // pivot  \n→ Decision: 如果找不到 i? // 數位已是降序排列，無更大排列  \n    Yes → Step 4: 返回 -1 // 無更大的排列  \n    No  →  \n→ Step 5: 從右向左尋找第一個數位 digits[j] > digits[i] 的位置 j // successor  \n→ Step 6: 交換 digits[i] 與 digits[j] // 交換 pivot 與 successor  \n→ Step 7: 反轉 i+1 到最後的子陣列，使其升序排列 // 取得最小升序排列  \n→ Step 8: 將 digits 重新組成整數 res // 重新生成數字  \n→ Decision: 如果 res > 2147483647? // 32 位整數上限檢查  \n    Yes → Step 9: 返回 -1 // 超出 32 位範圍  \n    No  → Step 10: 返回 res // 成功得到更大的整數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def next_greater_element(self, n: int) -> int:\n        # Convert number to list of its digits\n        digits = list(str(n))\n        # Find pivot: first index from the right where digits[i] < digits[i+1]\n        i = len(digits) - 2\n        while i >= 0 and digits[i] >= digits[i + 1]:\n            i -= 1\n        if i == -1:\n            return -1  # already the largest permutation\n\n        # Find the smallest digit on the right of pivot that is greater than pivot\n        j = len(digits) - 1\n        while digits[j] <= digits[i]:\n            j -= 1\n\n        # Swap pivot and successor\n        digits[i], digits[j] = digits[j], digits[i]\n        # Reverse the suffix starting at i+1 to get the smallest ascending order\n        digits[i + 1:] = reversed(digits[i + 1:])\n\n        # Reconstruct integer\n        result = int(''.join(digits))\n        # Check 32-bit signed integer overflow\n        return result if result < 2 ** 31 else -1\n\ndef main():\n    # Read all input and extract the first integer value\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n    solver = Solution()\n    answer = solver.next_greater_element(n)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "21",
          "success": true,
          "output": "21"
        },
        {
          "example_index": 1,
          "input": "n = 21",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode507.json",
    "problem_index_in_file": 0,
    "title": "Perfect Number",
    "description_snippet": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, as per format. Use Start, End, Decision. Must be line by line. We need to check if a number is perfect. Steps: input n, compute sum of proper divisors, compare to n, output boolean. Use loop from 1 to sqrt(n). For each divisor d, add d and n/d if distinct and not n itself. Use variable sum. Finally decision: sum == n? Yes → true, No → false. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入整數 n // 從使用者或函式參數取得待檢查的數字  \n→ Step 2: 初始化 sum = 0 // 用來累加 n 的所有正整除子 (不含 n 本身)  \n→ Step 3: 初始化 i = 1 // 從 1 開始遍歷可能的除數  \n→ Decision: i * i <= n? // 檢查是否已遍歷到 sqrt(n) 為止  \n  Yes → Step 4: 如果 n mod i == 0? // i 是否為 n 的除數  \n    Yes → Step 5: sum += i // 加入除數 i  \n      如果 i != 1 且 i != n / i 且 n / i != n? // 避免重複與加上 n 本身  \n       Yes → sum += n / i // 加入對應的另一個除數  \n       No → // 只保留 i，或 i 為 1 或與 n 相等時不重複加  \n    No → // i 不是除數，跳過  \n  → Step 6: i += 1 // 進到下一個可能除數  \n  → Decision: i * i <= n? // 仍需繼續遍歷  \n    Yes → 回到 Step 4  \n    No → // 完成所有可能除數的累加  \n→ Decision: sum == n? // 判斷累加的除數和是否等於原數  \n  Yes → Step 7: 回傳 true // n 是完美數  \n  No → Step 8: 回傳 false // n 不是完美數  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    \"\"\"\n    判斷一個正整數是否為完美數\n    \"\"\"\n    def checkPerfectNumber(self, num: int) -> bool:\n        # 1 不是完美數，且小於 2 的數都不可能是完美數\n        if num < 2:\n            return False\n\n        # 先把 1 加進去，因為 1 是所有正整數的除數\n        sum_divisors = 1\n        i = 2\n\n        # 只需要遍歷到 sqrt(num)，不需要檢查所有 i\n        while i * i <= num:\n            if num % i == 0:\n                # i 是除數，加入總和\n                sum_divisors += i\n                j = num // i\n                # j 也是除數，若不是 i 本身就加入\n                if j != i:\n                    sum_divisors += j\n            i += 1\n\n        # 判斷累加的除數和是否等於原數\n        return sum_divisors == num\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 讀取輸入，允許前後有空白字元\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        n = int(raw_input)\n        solution = Solution()\n        is_perfect = solution.checkPerfectNumber(n)\n        # 輸出小寫字串 'true' 或 'false'\n        print(\"true\" if is_perfect else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "28",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode476.json",
    "problem_index_in_file": 0,
    "title": "Number Complement",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing complement of an integer. Provide step-by-step pseudocode. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Need Start End. Use Decision. Use steps. Let's create steps: start, input num, find binary length, create mask of same length with all 1s, complement = num XOR mask. Return complement. Explanation. Also check for zero maybe. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入整數 num // 讀取要取反的數值  \n→ Decision: num 為 0? // 判斷特殊情況，0 的二進位為 0  \n    Yes → Step 2: 回傳 1 // 0 的補數是 1（1 的二進位是 1）  \n    No → Step 3: 計算 num 的二進位長度 len = ⌊log₂(num)⌋ + 1 // 找出最高有效位的位置  \n→ Step 4: 建立全 1 的掩碼 mask = (1 << len) - 1 // 例如 len=3 時 mask=0b111  \n→ Step 5: 計算補數 complement = num XOR mask // 逐位翻轉 0→1、1→0  \n→ Step 6: 回傳 complement // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        \"\"\"\n        取得 num 的二進位位數\n        產生全 1 掩碼，與 num XOR 以得到補數\n        \"\"\"\n        if num == 0:\n            # 0 的二進位「0」取反為「1」即 1\n            return 1\n        bit_length = num.bit_length()\n        mask = (1 << bit_length) - 1\n        return num ^ mask\n\ndef main() -> None:\n    # 讀取整個輸入，允許形如 'num = 5' 或純數字\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input\")\n    num = int(match.group())\n    # 計算補數並輸出\n    result = Solution().findComplement(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode703.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in a Stream",
    "description_snippet": "You are part of a university admissions office and need to keep track of the kth highest test score ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudocode for the KthLargest class. Use virtual code with arrows. Each line must have \"虛擬碼步驟\" then space then // explanation. Use arrows like →. Use Decision lines, etc. No actual code. Provide class structure, constructor, add method. Must maintain kth largest, probably using min-heap of size k. Steps: init heap with first k numbers, if less than k, fill with all numbers. After adding new val, if heap size<k push val; else compare val with heap.top, if val>top, pop and push val. Then return heap.top (the kth largest). Provide pseudocode lines accordingly.\n\nLet's craft.\n\nStart\n→ Step 1: 定義 KthLargest 類別，屬性: k, minHeap // 儲存前 k 個最大值\n\nConstructor\n→ Step 2: KthLargest(k, nums) // 初始化，設定 k\n    → Step 3: Set self.k = k // 記錄 k\n    → Step 4: 建立空 minHeap // 儲存大小為 k 的最小堆\n    → Step 5: Decision: nums 是否為空? // 若輸入陣列非空\n        Yes → Step 6: for each num in nums: // 遍歷初始分數\n            → Step 7: Decision: minHeap 大小 < k? // 堆尚未滿 k\n                Yes → Step 8: push num 到 minHeap // 加入\n                No  → Step 9: Decision: num > minHeap.top? // 新數是否大於目前 kth 大\n                    Yes → Step 10: pop minHeap.top() // 移除最小\n                         → Step 11: push num // 加入新數\n                    No  → Step 12: // 跳過，因為 num 小於等於 kth 大\nEnd // 結束建構\n\nAdd Method\n→ Step 13: int add(val) // 新分數進來\n    → Step 14: Decision: minHeap 大小 < k? // 堆未滿 k\n        Yes → Step 15: push val 到 minHeap // 加入\n        No  → Step 16: Decision: val > minHeap.top()? // 是否超過目前 kth 大\n            Yes → Step 17: pop minHeap.top()\n                 → Step 18: push val\n            No  → Step 19: // val 不大於 kth，忽略\n    → Step 20: Return minHeap.top() // kth 最大值\n\nEnd // 末\n\nNeed to ensure each line has // explanation. Use arrows. Provide Start and End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 KthLargest 類別，屬性: k, minHeap // 用 min‑heap 只保留 k 個最大值  \n\n// ---------- 建構子 ----------\n→ Step 2: KthLargest(k, nums) // 初始化 KthLargest 物件  \n    → Step 3: Set self.k = k // 記錄目標順位  \n    → Step 4: 建立空 minHeap // 先建立最小堆  \n    → Decision: nums 是否為空? // 判斷初始分數陣列  \n        Yes → Step 5: // 若 nums 為空，直接結束建構  \n        No  → Step 6: for each num in nums: // 逐一加入初始分數  \n            → Step 7: Decision: minHeap 大小 < k? // 堆尚未滿 k 個  \n                Yes → Step 8: push num 到 minHeap // 直接加入  \n                No  → Step 9: Decision: num > minHeap.top()? // 檢查是否超過目前 kth 大  \n                    Yes → Step 10: pop minHeap.top() // 移除最小值  \n                         → Step 11: push num // 加入新的較大值  \n                    No  → Step 12: // num 小於等於 kth 大，忽略  \n\nEnd // 建構子結束  \n\n// ---------- add 方法 ----------\n→ Step 13: int add(val) // 新分數進來時執行  \n    → Decision: minHeap 大小 < k? // 堆是否已滿 k 個  \n        Yes → Step 14: push val 到 minHeap // 直接加入  \n        No  → Step 15: Decision: val > minHeap.top()? // 是否超過 kth 大  \n            Yes → Step 16: pop minHeap.top() // 移除最小值  \n                 → Step 17: push val // 加入新的較大值  \n            No  → Step 18: // val 不大於 kth，保持堆不變  \n    → Step 19: Return minHeap.top() // 回傳目前的 kth 最大值  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Parse input like: '[\"KthLargest\", \"add\", ...], [[3, [4, 5, 8, 2]], ...]'\n    ops, args = ast.literal_eval(data)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"KthLargest\":\n            obj = KthLargest(*arg)\n            results.append(None)          # constructor returns null\n        else:\n            # call method and record result\n            results.append(getattr(obj, op)(*arg))\n\n    # Print results in required format: [null, 4, ...]\n    output_str = '[' + ', '.join('null' if v is None else str(v) for v in results) + ']'\n    print(output_str)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "success": true,
          "output": "[null, 4, 5, 5, 8, 8]"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "success": true,
          "output": "[null, 7, 7, 7, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode315.json",
    "problem_index_in_file": 0,
    "title": "Count of Smaller Numbers After Self",
    "description_snippet": "Given an integer array nums, return an integer array counts where counts[i] is the number of smaller...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step for counting smaller elements to the right. Use virtual code with arrows, decisions, etc. Provide explanation each line. We must not output actual code. Use Start, End, Decision. Use Yes →, No →. Probably use a BIT or BST method. But easier: use brute force? Might be simpler. But typical solution uses Binary Indexed Tree. We'll write pseudocode. Each line should contain \"虛擬碼步驟\" and explanation. Provide arrow. Eg \"Start // 程式開始執行\".\n\nWe need to output line by line. Each line: \"虛擬碼步驟 // 解釋/說明\". Use virtual code arrow. Provide decisions. Use Start, End. So:\n\nStart\n→ Step 1: 初始化 result 數組長度與 nums 相同，填 0 // 佈建回傳陣列\n→ Step 2: 定義空白 Binary Indexed Tree (BIT) // 用於統計已處理元素的頻次\n→ Decision: 若 nums 可能包含負數? // BIT 通常使用正整數索引\n    Yes → Step 3: 將 nums 的所有值映射到 1..n 的排名 // 建立座標壓縮\n    No  → Step 3: 直接使用 nums 索引 + offset // 仍需要映射\n→ Step 4: 遍歷 nums 從右到左\n    → Decision: 選擇當前元素 x // 獲取其排名\n        Yes → Step 5: query BIT 累積頻次在 1..rank-1 的總和 // 小於 x 的數量\n        No  → Step 6: 記錄結果到 result[i]\n        → Decision: 更新 BIT 在 rank 號位置 +1 // 記錄此元素\n→ End // 完成\n\nBut need to maintain format with arrow lines, decisions nested etc. Provide each step as a line. Use indent for nested lines. Might need to add arrows inside decision. Eg:\n\n→ Decision: nums 可能包含負數? // 判斷是否需要座標壓縮\n    Yes → Step 3a: 建立 rank map ... \n    No  → Step 3b: ...\n\nWe need to ensure each line has \"虛擬碼步驟\" and explanation.\n\nLet's produce more explicit pseudocode:\n\nStart // 程式開始執行\n→ Step 1: let n = length(nums) // 取得陣列長度\n→ Step 2: result = array of size n, filled with 0 // 用於儲存每個位置右側小於數量\n→ Step 3: 若 nums 中有負數? // BIT 需要正整數索引\n    Yes → Step 4a: 建立 sorted_unique = sorted(set(nums)) // 去重後排序\n           → Step 5a: 建立 map val_to_rank: each val -> index+1 // 座標壓縮\n    No  → Step 4b: 建立 sorted_unique = sorted(nums) // 仍需去重\n           → Step 5b: 建立 map val_to_rank: each val -> index+1\n→ Step 6: BIT = array of size len(sorted_unique)+2, all 0 // BIT 以 1 為起點\n→ Step 7: 從 i = n-1 downto 0\n    → Step 7a: rank = val_to_rank[nums[i]] // 取得壓縮後索引\n    → Step 8: count_smaller = query(BIT, rank-1) // 累積頻次小於此值\n    → Step 9: result[i] = count_smaller // 記錄到結果\n    → Step 10: update(BIT, rank, +1) // 更新 BIT\n→ End // 程式結束，返回 result\n\nBut we need to use arrow lines, decisions. We should indent each nested step accordingly.\n\nWe need to include \"虛擬碼步驟\" but we can write step names like \"Step 1:\". Provide explanation after //.\n\nLet's produce the final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: let n = length(nums) // 取得陣列長度 n  \n→ Step 2: result = array of size n, all 0 // 用於儲存每個位置右側比該元素小的數量  \n→ Decision: nums 內是否含負數? // BIT 需要正整數索引  \n    Yes → Step 3a: sorted_vals = sorted(set(nums)) // 去重後排序，做座標壓縮  \n    Yes → Step 4a: for each val in sorted_vals, map[val] = index+1 // 建立值到排名的映射  \n    No  → Step 3b: sorted_vals = sorted(set(nums)) // 仍需去重後排序  \n    No  → Step 4b: for each val in sorted_vals, map[val] = index+1 // 建立值到排名的映射  \n→ Step 5: BIT = array of size len(sorted_vals)+2, all 0 // 初始化 Binary Indexed Tree（1 為起點）  \n→ Step 6: for i from n-1 downto 0  \n    → Step 6a: rank = map[nums[i]] // 取得該元素的壓縮排名  \n    → Step 7: count_smaller = query(BIT, rank-1) // 取得已處理元素中小於 nums[i] 的數量  \n    → Step 8: result[i] = count_smaller // 記錄到結果陣列  \n    → Step 9: update(BIT, rank, +1) // 在 BIT 中增加此元素的頻次  \n→ End // 程式執行結束，返回 result",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass BIT:\n    def __init__(self, size: int):\n        self.tree = [0] * (size + 1)\n        self.size = size\n\n    def update(self, index: int, delta: int) -> None:\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index: int) -> int:\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\nclass Solution:\n    def countSmaller(self, nums):\n        if not nums:\n            return []\n        sorted_unique = sorted(set(nums))\n        ranks = {num: i + 1 for i, num in enumerate(sorted_unique)}\n        bit = BIT(len(ranks))\n        res = []\n        for num in reversed(nums):\n            rank = ranks[num]\n            res.append(bit.query(rank - 1))\n            bit.update(rank, 1)\n        return res[::-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the list part after \"nums =\"\n    match = re.search(r'nums\\s*=\\s*(.+)', data, re.S)\n    if match:\n        nums_str = match.group(1).strip()\n    else:\n        nums_str = data\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # Fallback: try eval if literal_eval fails\n        nums = eval(nums_str)\n    sol = Solution()\n    result = sol.countSmaller(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,2,6,1]",
          "expected_output": "[2,1,1,0]",
          "success": true,
          "output": "[2, 1, 1, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-1]",
          "expected_output": "[0,0]",
          "success": true,
          "output": "[0, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode537.json",
    "problem_index_in_file": 0,
    "title": "Complex Number Multiplication",
    "description_snippet": "A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\nreal is the re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The user wants multiplication of complex numbers represented as strings like \"a+bi\". Need parse, multiply, return string. Steps: Start, parse first number, parse second, compute real and imaginary parts of product: (a*c - b*d) + (a*d + b*c)i. Build string. End. We need to provide virtual code with explanation per line. Also use Decision? Not necessary. But maybe decisions for parsing sign? Could include. Keep simple. Provide each line. Use arrows. Format exactly as example: each line \"虛擬碼步驟 // 解釋\". Use \"→\" arrow. Use Start End. Use Step 1 etc. Provide explanation after each. Use decision if needed. Use maybe \"Decision: if num contains '-'? parse accordingly.\" But we can assume format always \"real+imaginaryi\" or \"real-imaginaryi\" maybe. Provide generic parse: split by '+' or '-' before i. Use Decision to determine sign. Let's produce steps.\n\nWe should produce virtual code lines, not actual code. Use arrows and decision statements. Provide simple steps. Let's craft.\n\nStart // 程式開始\n\n→ Step 1: 讀取字符串 num1, num2 // 取得兩個複數輸入\n\n→ Step 2: 解析 num1 為 (real1, imag1) // 從格式中提取實部與虛部\n\n→ Decision: num1 是否包含 '-' 作為分隔符? // 判斷虛部符號\n\n    Yes → Step 3: 取負虛部 imag1 = -abs(imag1) // 虛部為負\n\n    No  → Step 3: 取正虛部 imag1 = abs(imag1) // 虛部為正\n\n同樣對 num2\n\n→ Step 4: 解析 num2 為 (real2, imag2) // 同上\n\n→ Decision: num2 是否包含 '-'? // 判斷虛部符號\n\n    Yes → Step 5: imag2 = -abs(imag2)\n\n    No  → Step 5: imag2 = abs(imag2)\n\n→ Step 6: 計算乘積實部 resultReal = real1*real2 - imag1*imag2 // 複數相乘公式\n\n→ Step 7: 計算乘積虛部 resultImag = real1*imag2 + imag1*real2 // 公式\n\n→ Step 8: 構造輸出字符串 resultStr = resultReal + \"+\" + resultImag + \"i\" // 轉回格式\n\n→ Decision: resultImag 是否小於 0? // 虛部負號處理\n\n    Yes → Step 9: resultStr = resultReal + \"-\" + abs(resultImag) + \"i\" // 加上負號\n\n    No  → Step 9: resultStr = resultReal + \"+\" + resultImag + \"i\" // 正號\n\n→ Step 10: 返回 resultStr // 結果輸出\n\nEnd // 程式執行結束\n\nBut we might compress decision for parsing: use find. It's okay. Ensure each line follows format: \"虛擬碼步驟 // 解釋\". Must include Start, End. Use arrows. The arrow lines start with \"→\". We need to include arrow in virtual code step. Also decision lines: \"Decision: ...\" but we used Step numbers. Should we use \"Decision:\" lines? The example shows Decision: block. For clarity maybe include:\n\nDecision: num1 中 '+' 還是 '-'? // ?\n\nBut we can show as:\n\nDecision: num1 是否包含 '-' 作為分隔符? // 判斷虛部符號\n\n    Yes → Step ... etc.\n\nWe need to ensure the format exactly: each line \"虛擬碼步驟 [space] // 解釋\". So we must not use indent? Indentation may be allowed but keep simple. Use spaces before arrow? In example they had \"→ Step 1:\" etc. We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字符串 num1, num2 // 取得兩個複數輸入  \n→ Step 2: 解析 num1 為 (real1, imag1) // 從格式中提取實部與虛部  \nDecision: num1 是否包含 '-' 作為分隔符? // 判斷虛部符號  \n Yes → Step 3: imag1 = -abs(imag1) // 虛部為負  \n No  → Step 3: imag1 = abs(imag1) // 虛部為正  \n→ Step 4: 解析 num2 為 (real2, imag2) // 同樣提取實部與虛部  \nDecision: num2 是否包含 '-' 作為分隔符? // 判斷虛部符號  \n Yes → Step 5: imag2 = -abs(imag2) // 虛部為負  \n No  → Step 5: imag2 = abs(imag2) // 虛部為正  \n→ Step 6: 計算乘積實部 resultReal = real1*real2 - imag1*imag2 // 複數相乘公式  \n→ Step 7: 計算乘積虛部 resultImag = real1*imag2 + imag1*real2 // 公式  \n→ Step 8: 構造輸出字符串 resultStr = resultReal + \"+\" + resultImag + \"i\" // 轉回格式  \nDecision: resultImag 是否小於 0? // 虛部負號處理  \n Yes → Step 9: resultStr = resultReal + \"-\" + abs(resultImag) + \"i\" // 加上負號  \n No  → Step 9: resultStr = resultReal + \"+\" + resultImag + \"i\" // 正號  \n→ Step 10: 返回 resultStr // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"\n        Multiply two complex numbers given as strings in the form \"real+imaginaryi\".\n        The returned string is also in the same form.\n        \"\"\"\n        def parse(s: str):\n            \"\"\"\n            Parse a string like \"1+-1i\" or \"-3-2i\" into a tuple (real, imag).\n            \"\"\"\n            s = s.strip()\n            # Regular expression to capture real and imaginary parts\n            pattern = re.compile(r'(?P<real>[+-]?\\d+)(?P<imag>[+-]\\d+)i')\n            m = pattern.fullmatch(s)\n            if not m:\n                raise ValueError(f\"Invalid complex number format: {s}\")\n            return int(m.group('real')), int(m.group('imag'))\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        # (a+bi) * (c+di) = (ac - bd) + (ad + bc)i\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_part}+{imag_part}i\"\n\nif __name__ == \"__main__\":\n    # Read the whole input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # The input format is: \"num1\", \"num2\"\n    # Split on the first comma to separate the two numbers\n    parts = data.split(',', 1)\n    if len(parts) != 2:\n        raise ValueError(\"Expected two complex numbers separated by a comma.\")\n\n    # Strip surrounding whitespace and quotes from each part\n    def clean(part: str) -> str:\n        return part.strip().strip('\"').strip(\"'\")\n\n    num1 = clean(parts[0])\n    num2 = clean(parts[1])\n\n    solution = Solution()\n    result = solution.complexNumberMultiply(num1, num2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"1+1i\", \"1+1i\"",
          "expected_output": "\"0+2i\"",
          "success": true,
          "output": "0+2i"
        },
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmppz0w1wov.py\", line 51, in <module>\n    result = solution.complexNumberMultiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppz0w1wov.py\", line 22, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmppz0w1wov.py\", line 19, in parse\n    raise ValueError(f\"Invalid complex number format: {s}\")\nValueError: Invalid complex number format: 1+-1i"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode609.json",
    "problem_index_in_file": 0,
    "title": "Find Duplicate File in System",
    "description_snippet": "Given a list paths of directory info, including the directory path, and all the files with contents ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem. We should output line by line, each line with virtual code step and comment. Use arrows. Start, End, Decision. We need to handle parsing of input list of strings, build map content->list of paths, then collect groups with size>=2. Steps: Start, Step 1 parse input array, Step 2 iterate each string, Step 3 split by space to separate directory and file entries, Step 4 for each file entry parse filename and content, Step 5 construct full path, Step 6 map content to list, Step 7 after loop, Step 8 iterate map to collect groups of size>1, Step 9 return result. Use decision for size>1. Use End. Provide comments. Provide arrow.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空字典 `contentMap`，鍵為檔案內容，值為檔案完整路徑列表 // 準備儲存相同內容的檔案  \n→ Step 2: 對輸入陣列 `paths` 逐個迭代 // 逐行處理每個目錄資訊  \n  → Step 3: 用空格切割 `pathStr`，第一段為目錄路徑 `dirPath`，其餘為檔案條目 // 分離目錄與檔案  \n    → Step 4: 對 `pathStr` 的每個檔案條目 `fileEntry` 進行迭代  \n      → Step 5: 使用 `(` 找到檔案名稱與內容的分界點  \n        → Decision: 若 `fileEntry` 包含 '('? // 確認格式合法  \n          Yes → Step 6: 取得 `fileName` 為 `fileEntry` 的子字串從開始到 '(' 前  \n          No → Step 6: 跳過此檔案條目 // 若格式不符，直接跳過  \n        → Step 7: 取得 `fileContent` 為 `fileEntry` 的子字串從 '(' 後到 ')' 前  \n      → Step 8: 組合完整路徑 `fullPath = dirPath + \"/\" + fileName` // 建立完整路徑  \n      → Step 9: 若 `contentMap` 尚無此 `fileContent` 鍵，則新增空清單  \n      → Step 10: 將 `fullPath` 加入 `contentMap[fileContent]` // 分類相同內容的檔案  \n→ Step 11: 初始化結果清單 `duplicates` // 用來儲存重複檔案組  \n→ Step 12: 對 `contentMap` 的每一項 `content, pathList` 進行迭代  \n    → Decision: `pathList` 的長度 > 1? // 需要至少兩個檔案才算重複  \n      Yes → Step 13: 將 `pathList` 加入 `duplicates` // 收集重複組  \n      No → Step 13: 不做任何事 // 單一檔案不加入  \n→ Step 14: 返回 `duplicates` // 完成重複檔案的搜尋  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"找出所有重複檔案的完整路徑。\"\"\"\n        content_map = defaultdict(list)\n\n        for path_str in paths:\n            # 先分割成目錄跟檔案資訊\n            parts = path_str.split()\n            if not parts:\n                continue\n            root = parts[0]                       # 目錄路徑\n            for file_info in parts[1:]:\n                # 例： \"1.txt(abcd)\" => name=\"1.txt\", content=\"abcd\"\n                if '(' not in file_info or not file_info.endswith(')'):\n                    continue  # 跳過格式錯誤的項目\n                name, content = file_info.split('(', 1)\n                content = content[:-1]  # 去掉最後的 ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # 只保留重複的內容\n        return [paths for paths in content_map.values() if len(paths) > 1]\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 移除可能的前綴 \"paths =\" 以及多餘空白\n    if raw_input.lower().startswith(\"paths\"):\n        raw_input = raw_input.split('=', 1)[1].strip()\n    try:\n        paths_list = ast.literal_eval(raw_input)\n    except Exception as e:\n        # 如果解析失敗，印空列表並結束\n        print([])\n        return\n\n    sol = Solution()\n    result = sol.findDuplicate(paths_list)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode208.json",
    "problem_index_in_file": 0,
    "title": "Implement Trie (Prefix Tree)",
    "description_snippet": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and r...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing Trie with insert, search, startsWith. It's not actual code, but pseudocode steps. Each line must have \"虛擬碼步驟\" then a space then \"// 解釋\". Use arrow →, Decision:, Start, End. We need to produce a flow that covers initialization, insert, search, startsWith. We can outline main functions.\n\nWe should produce a stepwise description: Start, initialize root node, etc. Insert: iterate characters, create nodes if missing, mark end. Search: iterate, check existence, final end flag. startsWith: iterate, check existence.\n\nLet's produce.\n\nWe should produce lines like:\n\nStart // 程式開始\n\n→ Step 1: 定義 TrieNode 類別 // 定義樹節點\n\n→ Step 2: 初始化 Trie 根節點 // 建立根節點\n\n→ Step 3: insert(word) // 插入單字\n\n etc.\n\nWe need to be careful with structure: For functions we can use \"Step\" or \"Function: insert\". Use arrows and decisions.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義 TrieNode 類別，內含 children(字典) 與 isEnd(布林) // 建立樹節點結構\n\n→ Step 2: 定義 Trie 類別，內含 root 為 TrieNode // 建立 Trie 主類別\n\n→ Step 3: Trie() → 初始化 root 為新 TrieNode // 建構子，創建根節點\n\n→ Step 4: Function: insert(word) // 定義插入功能\n\n    → Step 5: current ← root // 從根節點開始\n\n    → Step 6: 逐字元遍歷 word 的每個字元 ch\n\n        → Decision: current.children 是否包含 ch?\n\n            Yes → current ← current.children[ch] // 若已有節點，直接前往\n\n            No  → current.children[ch] ← 新 TrieNode ; current ← current.children[ch] // 建立新節點並前往\n\n    → Step 7: current.isEnd ← true // 將最後節點標記為單字結束\n\n→ Step 8: Function: search(word) // 定義搜尋功能\n\n    → Step 9: current ← root\n\n    → Step 10: 逐字元遍歷 word 的每個字元 ch\n\n        → Decision: current.children 是否包含 ch?\n\n            Yes → current ← current.children[ch] // 前往\n\n            No  → Return false // 找不到字元，直接回傳 false\n\n    → Step 11: Return current.isEnd // 若到達末節點且標記為結束則為 true，否則 false\n\n→ Step 12: Function: startsWith(prefix) // 定義前綴搜尋功能\n\n    → Step 13: current ← root\n\n    → Step 14: 逐字元遍歷 prefix 的每個字元 ch\n\n        → Decision: current.children 是否包含 ch?\n\n            Yes → current ← current.children[ch] // 前往\n\n            No  → Return false // 前綴不存在\n\n    → Step 15: Return true // 所有字元均存在，代表至少有一個單字以此前綴開始\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two lists\n    ops_part, args_part = data.split('],', 1)\n    ops = ast.literal_eval(ops_part + ']')\n    args = ast.literal_eval(args_part)\n\n    trie = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == 'Trie':\n            trie = Trie()\n            outputs.append(None)\n        elif op == 'insert':\n            trie.insert(arg[0])\n            outputs.append(None)\n        elif op == 'search':\n            res = trie.search(arg[0])\n            outputs.append(res)\n        elif op == 'startsWith':\n            res = trie.startsWith(arg[0])\n            outputs.append(res)\n        else:\n            outputs.append(None)\n\n    # Convert to the desired string representation\n    out_str = '[' + ', '.join(\n        'null' if r is None else ('true' if r else 'false')\n        for r in outputs\n    ) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "success": true,
          "output": "[null, null, true, false, true, null, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode268.json",
    "problem_index_in_file": 0,
    "title": "Missing Number",
    "description_snippet": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with arrow notation, explanation. We need algorithm: find missing number from 0..n inclusive but array size n distinct numbers, missing one. Typical solution: XOR all numbers with 0..n or sum formula. We produce virtual code: Start, compute XOR or sum. Let's choose XOR because simpler.\n\nSteps:\nStart\n→ Step 1: Initialize missing to 0 // start with 0\n→ Step 2: For i from 0 to n: missing ← missing XOR i // XOR all numbers 0..n\n→ Step 3: For each num in nums: missing ← missing XOR num // XOR array numbers\n→ Step 4: missing now holds missing number // result\n→ Step 5: Output missing\nEnd\n\nBut we need decision? Not necessary. Provide explanation each line.\n\nLet's craft.\n\nAlso we can include Decision to handle maybe input length? Not needed.\n\nWe produce exactly like format.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 missing = 0 // 初始值為 0\n→ Step 2: For i 在 0 到 n: missing ← missing XOR i // 先 XOR 所有 0..n 的數\n→ Step 3: For num 在 nums: missing ← missing XOR num // 再 XOR 陣列中的每個數\n→ Step 4: missing 就是缺失的數 // XOR 的性質使得重複的數被消除，剩下缺失者\n→ Step 5: 輸出 missing // 回傳缺失的數\nEnd // 程式執行結束\n\nBut we must use arrow format `→` after start. For loops we can use `→ Loop:`? But arrow with step. Let's keep as `→ Step 2: ...` as example. Acceptable.\n\nNow output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 missing = 0 // 初始化缺失值為 0  \n→ Step 2: For i 在 0 到 n: missing ← missing XOR i // 先把 0~n 之間所有數 XOR 掉  \n→ Step 3: For num 在 nums: missing ← missing XOR num // 再把陣列裡的每個數 XOR 掉  \n→ Step 4: missing 就是缺失的數 // XOR 的性質會把重複的數消掉，留下唯一缺失的數  \n→ Step 5: 輸出 missing // 回傳缺失的數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef missing_number(nums):\n    \"\"\"返回 0~n 範圍內缺失的唯一數字，使用 XOR 法。\"\"\"\n    n = len(nums)\n    missing = 0\n    # XOR 0~n 所有數\n    for i in range(n + 1):\n        missing ^= i\n    # 再 XOR 陣列中的每個數\n    for num in nums:\n        missing ^= num\n    return missing\n\ndef parse_input(data):\n    \"\"\"\n    從輸入字串中抽取整數列表。\n    支援形如 'nums = [3,0,1]' 或 '[3,0,1]' 等格式。\n    \"\"\"\n    # 找出第一個 '[' 到對應的 ']'\n    match = re.search(r'\\[.*?\\]', data, re.S)\n    if match:\n        list_str = match.group(0)\n        try:\n            return ast.literal_eval(list_str)\n        except Exception:\n            pass\n    # 直接嘗試解析整個輸入\n    try:\n        return ast.literal_eval(data)\n    except Exception:\n        return []\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    nums = parse_input(data)\n    result = missing_number(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [9,6,4,2,3,5,7,0,1]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode470.json",
    "problem_index_in_file": 0,
    "title": "Implement Rand10() Using Rand7()",
    "description_snippet": "Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation, no actual code, using virtual steps with arrow, etc. The problem: need rand10() using rand7(). Classic approach: generate two rand7() calls to get 1-49 range; accept 1-40; map to 1-10 using modulo; if out, repeat. Or use rejection sampling. So we will produce steps: Start, call rand7() twice to get first, second, produce combined number: (first-1)*7 + second => 1-49. Then Decision: if number <= 40? Yes → map to 1-10: (number-1)%10 +1; No → repeat. We need to express recursively or loop. Virtual code lines: Start, define function rand10, inside: loop start label, Step: call rand7, assign a, Step: call rand7, assign b, compute num = (a-1)*7 + b, Decision: if num <= 40? Yes → return ((num-1)%10)+1; No → goto loop start. End. Provide explanation each line.\n\nAlso mention that we cannot call other APIs. Provide steps accordingly. Use arrow syntax. We'll provide lines with step numbers maybe but not necessary. We just need \"虛擬碼步驟\" and explanation. Each line start with \"→\". Use \"Start\" and \"End\". For loops we can use \"Decision:\" with Yes/No. Maybe use label \"Loop:\".\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Function rand10() // 定義生成 1~10 的函式\n→ Loop: // 進入重試迴圈\n    → Step 1: a ← rand7() // 產生第一個 1~7 的隨機數\n    → Step 2: b ← rand7() // 產生第二個 1~7 的隨機數\n    → Step 3: num ← (a-1)*7 + b // 組合為 1~49 的數\n    → Decision: 如果 num ≤ 40? // 檢查是否在可接受範圍\n        Yes → Step 4: result ← ((num-1) mod 10) + 1 // 將 1~40 映射為 1~10\n        Yes → Return result // 回傳最終結果\n        No  → Go to Loop // 重新開始迴圈\nEnd // 程式結束\n\nWe should add \"→\" before each step; the Decision block uses indentation. Provide explanation after //.\n\nNeed to ensure no actual code. The \"Go to Loop\" maybe represented as \"→ Loop:\" but we cannot duplicate arrow. Perhaps use \"No → Loop:\" to jump. So Decision block:\n\nDecision: num ≤ 40? \n    Yes → Step 4: result ← ((num-1) mod 10) + 1 // 映射\n    Yes → Return result // 回傳\n    No  → Loop // 重新嘗試\n\nBut we used \"Yes\" twice, not allowed. We can combine: Yes → Step 4: result ← ... // mapping, then Next: Return result. Or use Yes → Return ((num-1) mod 10) + 1.\n\nSimplify: Yes → Return ((num-1) mod 10) + 1\n\nOk.\n\nLet's produce final output with each line in order. Ensure each line has virtual code step and explanation. We'll start with \"Start\". Then function definition line, etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function rand10() // 定義生成 1~10 的函式  \n→ Loop: // 進入重試迴圈  \n    → Step 1: a ← rand7() // 產生第一個 1~7 的隨機數  \n    → Step 2: b ← rand7() // 產生第二個 1~7 的隨機數  \n    → Step 3: num ← (a-1)*7 + b // 組合為 1~49 的數  \n    → Decision: num ≤ 40? // 檢查是否在可接受範圍  \n        Yes → Return ((num-1) mod 10) + 1 // 把 1~40 映射為 1~10 並回傳  \n        No  → Loop // 超出範圍，重新嘗試  \nEnd // 程式執行結束",
      "generated_code": "import random\nimport sys\n\n# 這裡的 rand7() 是唯一允許的隨機數產生器\ndef rand7():\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        產生 1~10 的均勻隨機數，僅使用 rand7()\n        \"\"\"\n        while True:\n            # 使用兩次 rand7() 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                # 只保留 1~40 的數字，並映射到 1~10\n                return 1 + (num - 1) % 10\n\ndef main():\n    # 從標準輸入讀取格式為 \"n = X\" 的字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析 n 的值\n    try:\n        _, value = data.split('=')\n        n = int(value.strip())\n    except Exception:\n        # 若解析失敗，直接返回\n        return\n\n    solver = Solution()\n    # 呼叫 rand10() n 次並收集結果\n    results = [solver.rand10() for _ in range(n)]\n    # 將結果輸出為 Python 列表字面量\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[7,9]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[7, 9]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[10,7,5]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[10, 7, 5]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode7.json",
    "problem_index_in_file": 0,
    "title": "Reverse Integer",
    "description_snippet": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code, no actual code. Should include steps to reverse digits, handle sign, overflow detection using 32-bit range. No 64-bit allowed. We must use 32-bit operations. Need to simulate overflow check: before pushing digit, check if result would overflow: typical algorithm: if res > INT_MAX/10 or (res == INT_MAX/10 and pop > 7) then overflow. Similarly for negative. Use signed range. Need to preserve sign. We'll do: get sign, work with positive abs value, reverse digits, then apply sign. Use 32-bit ints only. So algorithm steps:\n\nStart\n→ Step: Read input x\n→ Decision: If x == 0? (though unnecessary but fine)\n→ Step: Set sign = 1 if x >= 0 else -1\n→ Step: Set num = abs(x)\n→ Step: Set rev = 0\n→ While num != 0:\n   → Step: pop = num % 10\n   → Step: num = num / 10\n   → Decision: If rev > INT_MAX/10? (overflow potential)\n        Yes → Step: return 0\n   → Decision: If rev == INT_MAX/10 and pop > 7? // for positive max 2147483647\n        Yes → Step: return 0\n   → Step: rev = rev * 10 + pop\n→ Step: rev = rev * sign\n→ Decision: If rev < INT_MIN? (overflow for negative)\n        Yes → Step: return 0\n→ Step: return rev\nEnd\n\nBut we need to use virtual code style: Start, decisions with Yes→, No→. Need to include all lines.\n\nMake sure to mention overflow checks for both positive and negative. But the common approach uses rev > INT_MAX/10 or rev == INT_MAX/10 && pop > 7; for negative, since sign applied later, we can treat rev as positive and final sign will handle negative overflow: rev * sign might go below INT_MIN; but we can detect overflow earlier: when rev > INT_MAX/10 or rev == INT_MAX/10 && pop > 7 for positive. But for negative numbers, we can do similar: rev > INT_MAX/10 or rev == INT_MAX/10 && pop > 8? Because negative max is -2147483648, absolute 2147483648. When sign negative, we need to check if rev > INT_MAX/10 or rev == INT_MAX/10 and pop > 8. However easier: apply sign after building rev and then check if rev < INT_MIN or rev > INT_MAX, return 0. But rev uses positive range, we can't exceed INT_MAX? If rev could exceed INT_MAX before sign, but we check overflow before multiplication and addition anyway. Let's use typical algorithm with rev positive and sign, check overflow using rev > INT_MAX/10 or rev == INT_MAX/10 && pop > (sign==1?7:8). This handles both sign.\n\nSo steps: inside loop after pop extraction, before adding, check:\n\nIf rev > INT_MAX/10 → overflow → return 0\n\nIf rev == INT_MAX/10:\n   If sign==1 and pop > 7 → overflow\n   If sign==-1 and pop > 8 → overflow\n\nElse continue.\n\nAdd rev = rev *10 + pop.\n\nAfter loop, return rev * sign.\n\nWe need to show decisions.\n\nLet's produce lines accordingly.\n\nUse 32-bit constants: INT_MAX = 2147483647, INT_MIN = -2147483648.\n\nLet's format.\n\nRemember to keep no actual code. Use pseudo steps.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入整數 x // 從使用者取得要反轉的 32 位元整數  \n→ Decision: 如果 x == 0? // 特殊情況可直接回傳 0  \n  Yes → Step 2: 回傳 0 // 零的反轉仍為零  \n  No → Step 3: 判斷符號 sign ← 1 如果 x ≥ 0 否則 -1 // 確定正負號  \n→ Step 4: 計算 num ← |x| // 取得 x 的正整數部分  \n→ Step 5: 設定 rev ← 0 // 初始化反轉結果  \n→ Decision: num ≠ 0? // 若還有數字要處理  \n  Yes → \n   → Step 6: pop ← num % 10 // 取 num 的最後一位  \n   → Step 7: num ← num / 10 // 刪除最後一位  \n   → Decision: rev > 2147483647 / 10? // 檢查乘 10 會不會溢位  \n     Yes → Step 8: 回傳 0 // 產生正負號前就溢位  \n     No → \n      → Decision: rev == 2147483647 / 10? // 乘 10 正好等於上限時需再檢查 pop  \n       Yes → \n        → Decision: sign == 1 AND pop > 7? // 正整數的上限 2147483647  \n          Yes → Step 9: 回傳 0 // 正整數溢位  \n          No → \n           → Decision: sign == -1 AND pop > 8? // 負整數的下限 -2147483648 的絕對值 2147483648  \n            Yes → Step 10: 回傳 0 // 負整數溢位  \n            No → \n             → Step 11: rev ← rev * 10 + pop // 進行反轉累加  \n       No → \n           → Step 12: rev ← rev * 10 + pop // 正常情況下累加  \n   → No → \n    → Step 13: rev ← rev * sign // 將符號套回  \n→ Step 14: 回傳 rev // 回傳最終反轉值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"Reverse digits of a 32‑bit signed integer, return 0 on overflow.\"\"\"\n        INT_MAX = 2 ** 31 - 1\n        INT_MIN = -2 ** 31\n\n        sign = -1 if x < 0 else 1\n        num = abs(x)\n        rev = 0\n\n        while num != 0:\n            pop = num % 10\n            num //= 10\n\n            # Overflow check before multiplication\n            if rev > INT_MAX // 10:\n                return 0\n            if rev == INT_MAX // 10:\n                if sign == 1 and pop > 7:    # 2147483647\n                    return 0\n                if sign == -1 and pop > 8:   # 2147483648 (abs(INT_MIN))\n                    return 0\n\n            rev = rev * 10 + pop\n\n        rev *= sign\n        return rev\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # Extract first integer (handles formats like \"x = -123\" or just \"123\")\n    match = re.search(r'[-]?\\d+', data)\n    if not match:\n        return\n\n    x = int(match.group(0))\n    result = Solution().reverse(x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 123",
          "expected_output": "321",
          "success": true,
          "output": "321"
        },
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "success": true,
          "output": "-321"
        },
        {
          "example_index": 2,
          "input": "x = 120",
          "expected_output": "21",
          "success": true,
          "output": "21"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode67.json",
    "problem_index_in_file": 0,
    "title": "Add Binary",
    "description_snippet": "Given two binary strings a and b, return their sum as a binary string....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for adding two binary strings. Use step-by-step virtual code with explanations. No actual code. Use arrow symbols. Let's produce lines like Start, Step 1: Initialize carry to 0, etc. Use Decision branches for loops. We'll do a loop from end indices. Use pointers i, j. While i>=0 or j>=0 or carry. Append bit. Reverse result or build reversed then reverse at end.\n\nWe must adhere to output format. Each line: \"虛擬碼步驟 // 解釋\". Let's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定指標 i = a.length - 1, j = b.length - 1, carry = 0, result = 空字串 // 初始化索引與進位  \n→ Decision: 是否還有未處理位元? // 判斷是否仍需繼續加法  \n Yes → Step 2: 取出 a[i] 若 i ≥ 0 否則 0，存入 bitA // 取得 a 的當前位元  \n  → Step 3: 取出 b[j] 若 j ≥ 0 否則 0，存入 bitB // 取得 b 的當前位元  \n  → Step 4: 計算 sum = bitA + bitB + carry // 確定三位元之和  \n  → Step 5: 更新 carry = sum / 2 // 計算新的進位（0 或 1）  \n  → Step 6: 取得結果位元 digit = sum % 2 // 取模得到當前位元  \n  → Step 7: 把 digit 加到 result 的前面 // 建立結果字串  \n  → Step 8: i--, j-- // 移動到更高位元  \n  → 回到 Decision  \n No → Step 9: 如果 carry > 0，將 carry 加到 result 的前面 // 處理最後進位  \n→ End // 程式執行結束，result 為兩個二進位字串相加的結果",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        \"\"\"返回兩個二進位字串相加的結果（不帶前導零）。\"\"\"\n        i, j = len(a) - 1, len(b) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            total = carry\n            if i >= 0:\n                total += int(a[i])\n                i -= 1\n            if j >= 0:\n                total += int(b[j])\n                j -= 1\n            res.append(str(total % 2))\n            carry = total // 2\n\n        return ''.join(reversed(res))\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取兩個二進位字串。\n    支援兩種輸入格式：\n    1. a = \"11\", b = \"1\"\n    2. 11 1\n    \"\"\"\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    parts = data.strip().replace(',', ' ').split()\n    # 移除可能的 a= 或 b= 前綴\n    cleaned = [p.lstrip('a=') for p in parts]\n    cleaned = [p.lstrip('b=') for p in cleaned]\n    return cleaned[0], cleaned[1]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    a, b = parse_input(raw_input)\n    solution = Solution()\n    result = solution.addBinary(a, b)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"11\", b = \"1\"",
          "expected_output": "\"100\"",
          "success": true,
          "output": "100"
        },
        {
          "example_index": 1,
          "input": "a = \"1010\", b = \"1011\"",
          "expected_output": "\"10101\"",
          "success": true,
          "output": "10101"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode371.json",
    "problem_index_in_file": 0,
    "title": "Sum of Two Integers",
    "description_snippet": "Given two integers a and b, return the sum of the two integers without using the operators + and -....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. The requirement: Given two integers a and b, return sum without + and -. Classic bitwise addition algorithm: use while b != 0: carry = a & b; a = a ^ b; b = carry << 1; return a. Also handle sign? Usually Python int is infinite. We'll produce steps.\n\nNeed to follow format: Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc.\n\nWe must produce \"逐行\" and use arrow \"→\" for steps. Provide explanation after space. Each step line: e.g., \"→ Step 1: Set carry = a & b // 計算進位\" etc.\n\nLet's produce.\n\nAlso we may include Decision step to handle while b != 0.\n\nStructure:\n\nStart\n→ Step 1: 計算 carry = a & b // 取得相同位為1的進位\n→ Step 2: 計算 a = a ^ b // 將不產生進位的位相加\n→ Step 3: 計算 b = carry << 1 // 將進位左移一位\n→ Decision: 如果 b != 0? // 若還有進位，繼續\n    Yes → 回到 Step 1\n    No → End\nEnd\n\nBut we need to include a loop: can use Decision and Yes to loop.\n\nWe'll need to express loop with \"Yes → Step 1\". But also need to show that we go back.\n\nLet's write as:\n\nStart // 程式開始執行\n→ Step 1: Set carry = a & b // 計算進位\n→ Step 2: Set a = a ^ b // 計算不進位的和\n→ Step 3: Set b = carry << 1 // 進位左移\n→ Decision: b != 0? // 是否還有進位？\n    Yes → Step 1 // 若有，繼續計算\n    No  → End // 無進位，完成\nEnd // 結束，返回 a\n\nBut the requirement: \"虛擬碼步驟 + [空格] + // 解釋\". Also need to include the arrow symbol. So each line:\n\nStart // 程式開始執行\n→ Step 1: Set carry = a & b // 計算進位\n→ Step 2: Set a = a ^ b // 將不產生進位的位相加\n→ Step 3: Set b = carry << 1 // 將進位左移一位\n→ Decision: b != 0? // 判斷是否還有進位\n    Yes → Step 1 // 若有進位，回到 Step 1\n    No  → End // 若無進位，結束\nEnd // 返回結果 a\n\nWe may need to include \"Return a\" in the end step. Could add \"Return a\" as Step.\n\nMaybe: End // 返回 a // 返回計算結果\n\nBut End indicates program end; we can include \"Return a\" before End.\n\nSo:\n\n→ Step 4: Return a // 回傳計算完成的和\n\nThen Decision? Actually we return inside loop? We loop until b==0; after loop, return a.\n\nThus structure:\n\nStart\n→ Step 1: carry = a & b\n→ Step 2: a = a ^ b\n→ Step 3: b = carry << 1\n→ Decision: b != 0?\n    Yes → Step 1\n    No  → Step 4: Return a\nEnd\n\nBut Step 4: Return a // 回傳結果\n\nThus End after Return.\n\nLet's produce final.\n\nAlso maintain proper indentation for decision options.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: carry = a & b // 計算相同位為1的進位\n→ Step 2: a = a ^ b // 計算不產生進位的和\n→ Step 3: b = carry << 1 // 將進位左移一位\n→ Decision: b != 0? // 判斷是否還有進位需要繼續加法\n    Yes → Step 1 // 若有進位，重新進行三步\n    No  → Step 4: return a // 無進位，完成加法，回傳結果\nEnd // 程式執行結束\n\nBut we need each line after the step arrow include the explanation. For Decision, we need the arrow? It says \"Decision:\" is separate structure. So we do:\n\n→ Decision: b != 0? // 判斷是否還有進位需要繼續加法\n    Yes → Step 1 // 若有進位，重新進行三步\n    No  → Step 4: return a // 無進位，完成加法，回傳結果\n\nThis is good.\n\nNeed to confirm format: \"虛擬碼步驟 [空格] // 解釋/說明\". So each line should be like \"Start // 程式開始執行\". For decision lines, we might need to keep the arrow? The arrow is before the decision? Example given: \"→ Decision: 如果數字大於 0? // 檢查數值是否為正\". So we need arrow before Decision. For options: \"Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\". So we need arrow before Yes.\n\nThus for our Decision we should use \"→ Decision:\" preceded by arrow. Then indent the Yes and No lines with \"Yes →\" and \"No →\" respectively.\n\nThus final output:\n\nStart // 程式開始執行\n→ Step 1: carry = a & b // 計算相同位為1的進位\n→ Step 2: a = a ^ b // 計算不產生進位的和\n→ Step 3: b = carry << 1 // 將進位左移一位\n→ Decision: b != 0? // 判斷是否還有進位需要繼續加法\n    Yes → Step 1 // 若有進位，重新進行三步\n    No  → Step 4: return a // 無進位，完成加法，回傳結果\nEnd // 程式執行結束\n\nBut \"Step 4: return a\" is inside the No branch. That is correct.\n\nWe need to ensure that each line after \"Start\" and \"End\" are separate lines. Also indentation for Yes/No options: maybe use tab or spaces. Provide indentation like two spaces? We'll just add two spaces before Yes and No lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: carry = a & b // 計算相同位為1的進位  \n→ Step 2: a = a ^ b // 計算不產生進位的和  \n→ Step 3: b = carry << 1 // 將進位左移一位  \n→ Decision: b != 0? // 判斷是否還有進位需要繼續加法  \n  Yes → Step 1 // 若有進位，重新進行三步  \n  No  → Step 4: return a // 無進位，完成加法，回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getSum(self, a: int, b: int) -> int:\n        MASK = 0xFFFFFFFF        # 32-bit mask for unsigned integers\n        MAX_INT = 0x7FFFFFFF     # maximum positive 32-bit signed integer\n\n        while b != 0:\n            carry = (a & b) & MASK          # 進位\n            a = (a ^ b) & MASK              # 無進位之和\n            b = (carry << 1) & MASK         # 將進位左移一位\n\n        # 若結果為負數，將其轉換為負值\n        return a if a <= MAX_INT else ~(a ^ MASK)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 從輸入中提取所有整數\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) < 2:\n        print(\"Error: 至少需要兩個整數作為輸入。\")\n        sys.exit(1)\n    a, b = int(nums[0]), int(nums[1])\n\n    sol = Solution()\n    result = sol.getSum(a, b)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 1, b = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode593.json",
    "problem_index_in_file": 0,
    "title": "Valid Square",
    "description_snippet": "Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given 4 points (unordered) check if they form square. We need to output in virtual code lines with arrow and explanations. Each line: \"虛擬碼步驟 // 解釋\". Steps: Start, compute all pairwise distances squared, get unique distances, check counts: one small side repeated 4 times, one diagonal repeated 2 times. Also ensure smallest >0. Or alternative: use set of distances: there should be 2 distinct distances: side length appears 4 times, diagonal length appears 2 times, and diagonal = 2 * side (but squared: diag^2 = 2 * side^2). But we don't need numeric equality due to integer? Could just use counts.\n\nAlgorithm steps:\n\n- Start\n- Step 1: Read points p1,p2,p3,p4 // input points\n- Step 2: Create list of all 6 pairwise distances squared between points // compute squared distances\n- Step 3: Group distances into a map: distance value -> count\n- Step 4: If number of unique distances != 2 -> return false // not square\n- Step 5: Let (d1,c1),(d2,c2) be the two entries\n- Step 6: Determine smaller distance sideLen and its count\n- Step 7: Decision: If sideLen > 0 and (countSide ==4 and countDiag==2) // correct counts\n- Step 8: Decision: If countDiag ==2 and (diagLen == 2*sideLen) // diagonal property\n- Step 9: Return true else false\n- End\n\nBut we need to produce step-by-step virtual code.\n\nLet's produce lines:\n\nStart\n→ Step 1: p1, p2, p3, p4 ← input points // get four points\n→ Step 2: distList ← empty list // prepare list for distances\n→ Step 3: For each unordered pair (a,b) among {p1,p2,p3,p4}\n    → Compute squared distance d ← (a.x - b.x)^2 + (a.y - b.y)^2\n    → Append d to distList // store squared distance\n→ Step 4: distCountMap ← map from distance to frequency // count occurrences\n→ Step 5: For each d in distList\n    → Increment distCountMap[d] // tally\n→ Step 6: If size(distCountMap) ≠ 2 → return false // need two distinct distances\n→ Step 7: Extract entries (dist1, cnt1), (dist2, cnt2) from map\n→ Step 8: Decision: If dist1 < dist2\n    → sideLen ← dist1; sideCnt ← cnt1; diagLen ← dist2; diagCnt ← cnt2\n    → else\n    → sideLen ← dist2; sideCnt ← cnt2; diagLen ← dist1; diagCnt ← cnt1\n→ Step 9: Decision: If sideLen == 0 OR sideCnt ≠ 4 OR diagCnt ≠ 2 → return false // side must be positive and counts correct\n→ Step 10: Decision: If diagLen ≠ 2 * sideLen → return false // right angle condition\n→ Step 11: return true // all conditions satisfied\nEnd\n\nWe need to ensure each line with \"虛擬碼步驟 // 解釋\".\n\nUse arrow formatting: \"→\". For Decision lines: \"Decision:\" etc. Also indent substeps accordingly.\n\nLet's format accordingly. We should include Start and End.\n\nMake sure each line follows: \"虛擬碼步驟 // 解釋\".\n\nSo lines:\n\nStart // 程式開始執行\n→ Step 1: p1, p2, p3, p4 ← input points // 取得四個點\n→ Step 2: distList ← empty list // 建立距離列表\n→ Step 3: For each unordered pair (a, b) among {p1, p2, p3, p4} // 逐一計算所有點對的距離\n    → Compute d ← (a.x - b.x)^2 + (a.y - b.y)^2 // 計算平方距離\n    → Append d to distList // 加入列表\n→ Step 4: distCountMap ← map from distance to frequency // 準備統計表\n→ Step 5: For each d in distList\n    → Increment distCountMap[d] // 記錄每個距離出現次數\n→ Step 6: If size(distCountMap) ≠ 2 → return false // 需要兩種不同距離\n→ Step 7: (dist1, cnt1), (dist2, cnt2) ← entries of distCountMap // 取得兩個距離與其次數\n→ Step 8: Decision: If dist1 < dist2\n        → sideLen ← dist1; sideCnt ← cnt1; diagLen ← dist2; diagCnt ← cnt2 // 较小距離為邊長\n        → else\n        → sideLen ← dist2; sideCnt ← cnt2; diagLen ← dist1; diagCnt ← cnt1 // 较大距離為對角線\n→ Step 9: Decision: If sideLen == 0 OR sideCnt ≠ 4 OR diagCnt ≠ 2 → return false // 邊長不能為0且出現次數要正確\n→ Step 10: Decision: If diagLen ≠ 2 * sideLen → return false // 對角線長度必須為邊長的平方根乘以√2\n→ Step 11: return true // 所有檢查通過，形成正方形\nEnd // 程式結束\n\nEnsure correct indentation for substeps within Decision blocks? The requirement: Use arrows and Decision. In example they used indentation with spaces. So we need to match.\n\nProbably each substep is indented with spaces. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: p1, p2, p3, p4 ← input points // 取得四個點\n→ Step 2: distList ← empty list // 建立距離列表\n→ Step 3: For each unordered pair (a, b) among {p1, p2, p3, p4} // 逐一計算所有點對的距離\n    → Compute d ← (a.x - b.x)^2 + (a.y - b.y)^2 // 計算平方距離\n    → Append d to distList // 加入列表\n→ Step 4: distCountMap ← map from distance to frequency // 準備統計表\n→ Step 5: For each d in distList\n    → Increment distCountMap[d] // 記錄每個距離出現次數\n→ Step 6: If size(distCountMap) ≠ 2 → return false // 需要兩種不同距離\n→ Step 7: (dist1, cnt1), (dist2, cnt2) ← entries of distCountMap // 取得兩個距離與其次數\n→ Step 8: Decision: If dist1 < dist2\n        → sideLen ← dist1; sideCnt ← cnt1; diagLen ← dist2; diagCnt ← cnt2 // 较小距離為邊長\n        → else\n        → sideLen ← dist2; sideCnt ← cnt2; diagLen ← dist1; diagCnt ← cnt1 // 较大距離為對角線\n→ Step 9: Decision: If sideLen == 0 OR sideCnt ≠ 4 OR diagCnt ≠ 2 → return false // 邊長不能為0且出現次數要正確\n→ Step 10: Decision: If diagLen ≠ 2 * sideLen → return false // 對角線長度必須為邊長的平方根乘以√2\n→ Step 11: return true // 所有檢查通過，形成正方形\nEnd // 程式結束\n\nCheck formatting: For Decision: lines inside must have indentation of 4 spaces? In example they used two spaces. Let's follow 4 spaces.\n\nAlso need to ensure \"→ Decision:\" lines have indentation? The example: They had:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // ...\n\nSo we replicate.\n\nThus for Step 8 we need:\n\n→ Step 8: Decision: If dist1 < dist2\n        Yes → sideLen ← dist1; sideCnt ← cnt1; diagLen ← dist2; diagCnt ← cnt2 // ...\n        No  → sideLen ← dist2; sideCnt ← cnt2; diagLen ← dist1; diagCnt ← cnt1 // ...\n\nBut example uses \"Yes →\" and \"No →\". We can use Yes and No. Let's do:\n\n→ Step 8: Decision: If dist1 < dist2\n        Yes → sideLen ← dist1; sideCnt ← cnt1; diagLen ← dist2; diagCnt ← cnt2 // 较小距離為邊長\n        No  → sideLen ← dist2; sideCnt ← cnt2; diagLen ← dist1; diagCnt ← cnt1 // 较大距離為對角線\n\nSimilarly for Step 9 and 10.\n\nStep 9:\n\n→ Step 9: Decision: If sideLen == 0 OR sideCnt ≠ 4 OR diagCnt ≠ 2\n        Yes → return false // 無效正方形\n        No  → continue // 跳過此檢查\n\nBut we can't use continue? Instead we just go to next step. We'll do: No → // proceed\n\nSimilarly for Step 10.\n\nLet's craft accordingly.\n\nWe also need to maintain step numbering but not necessary. The requirement: Each line must have \"虛擬碼步驟\" and comment. So we can keep step labels but not mandatory.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: p1, p2, p3, p4 ← input points // 取得四個點的座標  \n→ Step 2: distList ← empty list // 建立儲存所有距離的列表  \n→ Step 3: For each unordered pair (a, b) among {p1, p2, p3, p4} // 逐一處理六對點  \n  → Compute d ← (a.x - b.x)^2 + (a.y - b.y)^2 // 計算平方距離  \n  → Append d to distList // 將平方距離加入列表  \n→ Step 4: distCountMap ← map from distance to frequency // 準備統計每個距離出現次數  \n→ Step 5: For each d in distList // 記錄距離頻率  \n  → Increment distCountMap[d] // 把相同距離的次數累加  \n→ Step 6: If size(distCountMap) ≠ 2 → return false // 正方形必須有兩種不同距離  \n→ Step 7: (dist1, cnt1), (dist2, cnt2) ← entries of distCountMap // 取得兩種距離與其次數  \n→ Step 8: Decision: If dist1 < dist2 // 判斷哪個距離較小  \n  Yes → sideLen ← dist1; sideCnt ← cnt1; diagLen ← dist2; diagCnt ← cnt2 // 较小距離為邊長  \n  No  → sideLen ← dist2; sideCnt ← cnt2; diagLen ← dist1; diagCnt ← cnt1 // 较大距離為對角線  \n→ Step 9: Decision: If sideLen == 0 OR sideCnt ≠ 4 OR diagCnt ≠ 2 // 檢查邊長正且出現次數正確  \n  Yes → return false // 不符合正方形條件  \n  No  → // 繼續後續檢查  \n→ Step 10: Decision: If diagLen ≠ 2 * sideLen // 對角線長度應為邊長的平方根乘以√2  \n  Yes → return false // 角度不為 90°  \n  No  → // 繼續  \n→ Step 11: return true // 所有條件滿足，構成正方形  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n        dists.sort()\n\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出所有 [x,y] 的配對\n    pairs = re.findall(r'\\[([-\\d]+),\\s*([-\\d]+)\\]', data)\n    if len(pairs) != 4:\n        # 如果格式不符合，直接輸出 false\n        print(\"false\")\n        sys.exit(0)\n\n    points = [[int(x), int(y)] for x, y in pairs]\n    sol = Solution()\n    is_square = sol.validSquare(*points)\n    print(\"true\" if is_square else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode35.json",
    "problem_index_in_file": 0,
    "title": "Search Insert Position",
    "description_snippet": "Given a sorted array of distinct integers and a target value, return the index if the target is foun...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps with explanations, following the specified format. The algorithm is binary search to find insertion position. Need to output virtual code lines: Start, Decision, steps, End. For each line, include explanation after //.\n\nWe should show steps: low, high, while low <= high, mid, compare mid value to target, adjust low/high accordingly. After loop, return low as insertion position.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: low ← 0 // 初始化低指標\n→ Step 2: high ← length(arr) - 1 // 初始化高指標\n→ Decision: low ≤ high? // 判斷是否還有搜尋範圍\n    Yes → Step 3: mid ← low + (high - low) / 2 // 計算中點\n    Yes → Decision: arr[mid] = target? // 檢查中點是否為目標\n        Yes → Step 4: return mid // 找到目標，返回索引\n        No  → Decision: arr[mid] < target? // 中點值小於目標\n            Yes → Step 5: low ← mid + 1 // 移動低指標至 mid+1\n            No  → Step 6: high ← mid - 1 // 移動高指標至 mid-1\n    No → Step 7: return low // 循環結束，返回插入位置\nEnd // 程式執行結束\n\nNeed to ensure arrow format: using `→` before step lines. For decisions, need to indent? In example, indent with spaces. Provide hierarchical indentation. Use `Decision:` and sub-indents.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: low ← 0 // 初始化低指標\n→ Step 2: high ← length(arr) - 1 // 初始化高指標\n→ Decision: low ≤ high? // 判斷是否還有搜尋範圍\n    Yes → Step 3: mid ← low + (high - low) / 2 // 計算中點\n    Yes → Decision: arr[mid] = target? // 檢查中點是否為目標\n        Yes → Step 4: return mid // 找到目標，返回索引\n        No  → Decision: arr[mid] < target? // 中點值小於目標\n            Yes → Step 5: low ← mid + 1 // 移動低指標至 mid+1\n            No  → Step 6: high ← mid - 1 // 移動高指標至 mid-1\n    No → Step 7: return low // 循環結束，返回插入位置\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        Binary search to find the insertion index of target in a sorted list.\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(text):\n    \"\"\"\n    Parse the input string of the form:\n        nums = [1,3,5,6], target = 5\n    and return the list of numbers and the target integer.\n    \"\"\"\n    nums_pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])'\n    target_pattern = r'target\\s*=\\s*([-]?\\d+)'\n    nums_match = re.search(nums_pattern, text)\n    target_match = re.search(target_pattern, text)\n    if not nums_match or not target_match:\n        raise ValueError(\"Input format is incorrect.\")\n    nums = ast.literal_eval(nums_match.group(1))\n    target = int(target_match.group(1))\n    return nums, target\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n\n    solution = Solution()\n    index = solution.searchInsert(nums, target)\n    print(index)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode154.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array II",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for finding minimum element in rotated sorted array with duplicates. Must reduce operation steps. Use binary search style but handle duplicates.\n\nWe output line by line steps. Use Start, End, Decision.\n\nLet's outline algorithm:\n\nStart\n→ Step 1: Initialize left = 0, right = length-1 // pointers\n→ Decision: While left < right? // loop condition\n    Yes →\n        → Step 2: mid = left + (right-left)/2 // middle index\n        → Decision: nums[mid] < nums[right]? // compare mid and right\n            Yes → right = mid // right moves to mid\n            No →\n                → Decision: nums[mid] > nums[right]? // mid greater than right\n                    Yes → left = mid + 1 // left moves to mid+1\n                    No →\n                        → right = right - 1 // duplicate case, reduce right by 1\n        → Step 3: Loop back // re-evaluate\n    No →\n        → Step 4: result = nums[left] // left is min\n→ End\n\nWe need to output each line with comment. Provide virtual code lines.\n\nMake sure to include arrow indentation as per example. Provide steps each on separate line. Use proper formatting.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 left = 0, right = nums.length - 1 // 設定左右指標  \n→ Decision: 左右指標是否相遇? (left < right) // 判斷是否還有待搜尋區間  \n    Yes →  \n        → Step 2: 計算 mid = left + (right - left) / 2 // 取得中點索引  \n        → Decision: nums[mid] < nums[right]? // 比較中點與右邊界  \n            Yes →  \n                → Step 3: right = mid // 最小值必定在左半區  \n            No →  \n                → Decision: nums[mid] > nums[right]? // 中點是否大於右邊界  \n                    Yes →  \n                        → Step 4: left = mid + 1 // 最小值在右半區  \n                    No →  \n                        → Step 5: right = right - 1 // 重複元素，縮小右邊界  \n        → Step 6: 循環回到決策點 // 重新檢查條件  \n    No →  \n        → Step 7: result = nums[left] // 左指標指向最小值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMin(self, nums):\n        \"\"\"Find the minimum element in a rotated sorted array that may contain duplicates.\"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:                     # nums[mid] == nums[right], shrink the search space\n                right -= 1\n        return nums[left] if nums else None\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    # Extract the list representation from the input\n    match = re.search(r'\\[.*\\]', data)\n    nums = eval(match.group()) if match else []\n\n    solution = Solution()\n    result = solution.findMin(nums)\n    print(result if result is not None else \"\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode638.json",
    "problem_index_in_file": 0,
    "title": "Shopping Offers",
    "description_snippet": "In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: find minimal cost to buy exact needs of items with special offers. This is a typical DP with memoization/backtracking search (DFS with memo). Need to handle up to 6 items (LeetCode constraints). We'll produce algorithm: define function dfs(remainingNeeds) -> min cost. Use dictionary memo. Base: if all zeros => 0. Try each special offer that can be applied (offer counts <= remaining). Compute newNeeds = remaining - offer. cost = offerPrice + dfs(newNeeds). Also compute direct cost: sum(need[i]*price[i]). Return min of these.\n\nWe produce pseudocode lines.\n\nWe need \"逐行\" output: each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols.\n\nOk. Let's craft.\n\nWe start with Start. Define variables. Then define function.\n\nWill use recursion.\n\nPseudo:\n\nStart // 程式開始執行\n→ Define price[], needs[], special[][] // 初始化價格、需求與特價\n→ Define memo as empty map // 用於記錄已計算的需求組合\n→ Define Function dfs(curNeeds) // 以需求組合為參數的遞迴\n    → If curNeeds all 0 → Return 0 // 無需購買任何商品，成本為0\n    → If curNeeds in memo → Return memo[curNeeds] // 若已計算過，直接回傳\n    → baseCost = sum(curNeeds[i] * price[i]) // 直接購買未使用特價的成本\n    → minCost = baseCost\n    → For each offer in special:\n        → canUse = True\n        → For i in 0..n-1:\n            → If offer[i] > curNeeds[i]: canUse = False; break // 特價不能超過需求\n        → If canUse:\n            → newNeeds = curNeeds - offer // 逐項減去特價購買數量\n            → offerCost = offer[n] + dfs(newNeeds) // 特價價格加下次遞迴成本\n            → If offerCost < minCost: minCost = offerCost\n    → memo[curNeeds] = minCost\n    → Return minCost\n→ 最終結果 = dfs(needs) // 從原始需求開始遞迴\n→ End // 程式執行結束\n\nBut each line needs arrow or structure. We need to indicate decisions. Use \"Decision:\" etc.\n\nWe can structure:\n\nStart\n→ Initialize variables\n→ Define memo\n→ Define function dfs\n    → Decision: if all curNeeds zero?\n        Yes → Return 0\n    → Decision: if curNeeds in memo?\n        Yes → Return memo[curNeeds]\n    → baseCost = ...\n    → minCost = baseCost\n    → For each offer:\n        → Decision: can use offer?\n            Yes → compute newNeeds, offerCost, update minCost\n    → memo[curNeeds] = minCost\n    → Return minCost\n→ Result = dfs(needs)\nEnd\n\nNeed to use \"→\" arrow. Use indentation. Use \"Decision:\" lines. Use \"Yes →\", \"No →\".\n\nOk produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define price[], needs[], special[][] // 初始化價格、需求與特價  \n→ Define memo as empty map // 用於記錄已計算的需求組合  \n→ Define Function dfs(curNeeds) // 以需求組合為參數的遞迴  \n    → Decision: curNeeds 全為 0? // 判斷是否已購完所有商品  \n        Yes → Return 0 // 無需再購買，成本為 0  \n    → Decision: curNeeds 在 memo? // 檢查是否已計算過此需求組合  \n        Yes → Return memo[curNeeds] // 直接回傳已存的最小成本  \n    → baseCost = sum( curNeeds[i] * price[i] ) // 直接按原價購買的成本  \n    → minCost = baseCost // 先以直接購買為基礎的最小成本  \n    → For each offer in special: // 遍歷所有特價方案  \n        → Decision: offer 可使用? // 檢查此特價的數量不超過剩餘需求  \n            Yes →  \n                → newNeeds = curNeeds - offer // 將需求減去此特價購買的數量  \n                → offerCost = offer[n] + dfs(newNeeds) // 特價價格加遞迴計算的新需求成本  \n                → Decision: offerCost < minCost? // 判斷是否更新最小成本  \n                    Yes → minCost = offerCost // 更新為更低成本  \n            No → // 若特價不合法，跳過此方案  \n    → memo[curNeeds] = minCost // 記錄此需求組合的最小成本  \n    → Return minCost // 回傳計算得到的最小成本  \n→ result = dfs(needs) // 從原始需求開始遞迴計算  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List\n\nclass Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs: List[int]) -> int:\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # cost without using any special offer\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # try each special offer\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:  # offer can be used\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(data: str):\n    # Regex pattern to extract the three lists\n    pattern = r'price\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*special\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*needs\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    price_str, special_str, needs_str = match.group(1), match.group(2), match.group(3)\n    price = ast.literal_eval(price_str)\n    special = ast.literal_eval(special_str)\n    needs = ast.literal_eval(needs_str)\n    return price, special, needs\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    price, special, needs = parse_input(data)\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpjc068l4w.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpjc068l4w.py\", line 47, in main\n    price, special, needs = parse_input(data)\n                            ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjc068l4w.py\", line 36, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp376p0i5r.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmp376p0i5r.py\", line 47, in main\n    price, special, needs = parse_input(data)\n                            ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp376p0i5r.py\", line 36, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode709.json",
    "problem_index_in_file": 0,
    "title": "To Lower Case",
    "description_snippet": "Given a string s, return the string after replacing every uppercase letter with the same lowercase l...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanation. Use Start, End, Decision, Step. We need to handle string s, iterate each character, if uppercase, replace with lowercase. Build new string. Output new string. Use typical pseudocode. Provide line by line. Use arrow for transitions. Use decision statements for checking uppercase. Must follow output format: each line \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe need to decide how many lines. Possibly:\n\nStart\n→ Step 1: 初始化 result 為空字符串 // 設置結果容器\n→ Step 2: 對 s 中的每個字符 c 進行迭代 // 遍歷輸入字符串\n    → Decision: c 是否為大寫字母? // 判斷是否需要轉換\n        Yes → Step 3: 將 c 的小寫形式追加到 result // 大寫轉為小寫\n        No  → Step 4: 將 c 直接追加到 result // 非大寫保持不變\n→ Step 5: 返回 result // 返回處理後的字符串\nEnd\n\nAlso need to indicate loops. Could use \"For each\" arrow. Use decision inside loop. Use indentation for nested lines. Use \"→\" for flow.\n\nOk. Let's format.\n\nWe'll produce exactly those lines. Ensure each line ends with // comment. We'll add indentation with spaces. Use arrow at each step. Use \"Decision:\" line. Indentation for nested steps. Use \"Yes →\" \"No →\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空字符串 // 設置用來累積結果的容器  \n→ Step 2: 對 s 中的每個字符 c 進行迭代 // 遍歷輸入字串的所有字符  \n  → Decision: c 是否為大寫字母? // 判斷此字符是否需要轉換  \n    Yes → Step 3: 將 c 的小寫形式追加到 result // 大寫轉為小寫並加入結果  \n    No  → Step 4: 將 c 直接追加到 result // 非大寫保持原樣並加入結果  \n→ Step 5: 返回 result // 傳回處理後的字串  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def toLowerCase(self, s: str) -> str:\n        \"\"\"Convert all uppercase letters in the string to lowercase.\"\"\"\n        result = []\n        for c in s:\n            # Check if the character is an uppercase letter\n            if 'A' <= c <= 'Z':\n                # Convert to lowercase by adding 32 to its ASCII code\n                result.append(chr(ord(c) + 32))\n            else:\n                result.append(c)\n        return ''.join(result)\n\nif __name__ == \"__main__\":\n    import sys\n\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # Try to extract the string inside double quotes if present\n    idx1 = data.find('\"')\n    if idx1 != -1:\n        idx2 = data.find('\"', idx1 + 1)\n        if idx2 != -1:\n            s = data[idx1 + 1:idx2]\n        else:\n            s = data\n    else:\n        s = data\n\n    # Process the string and output the result surrounded by double quotes\n    solution = Solution()\n    lowercased = solution.toLowerCase(s)\n    print(f'\"{lowercased}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello\"",
          "expected_output": "\"hello\"",
          "success": true,
          "output": "\"hello\""
        },
        {
          "example_index": 1,
          "input": "s = \"here\"",
          "expected_output": "\"here\"",
          "success": true,
          "output": "\"here\""
        },
        {
          "example_index": 2,
          "input": "s = \"LOVELY\"",
          "expected_output": "\"lovely\"",
          "success": true,
          "output": "\"lovely\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode153.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step with explanation. Provide algorithm for finding minimum in rotated sorted array unique elements, O(log n). Use binary search to find pivot where next element is smaller. Classic approach: while low < high: mid = low + (high-low)/2; if nums[mid] > nums[high] then low = mid+1 else high = mid. After loop, low is min. Need to produce pseudo-code with arrows, decisions. Provide each line as \"Step: ...\" etc. Should be detailed enough but not too many lines. Let's produce: Start, Step 1: Define low, high, input array. Step 2: While low < high. Step 3: Compute mid. Step 4: Decision: nums[mid] > nums[high]? Yes → set low = mid+1. No → set high = mid. End loop. Step final: return nums[low]. End.\n\nAdd comments in Chinese. Also include decision branches. Ensure arrow formatting.\n\nWe must not output actual code. Just virtual steps with arrow syntax.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 輸入 nums, n = length // 取得輸入陣列及長度\n\n→ Step 2: low ← 0, high ← n-1 // 初始化搜尋範圍\n\n→ Decision: low < high? // 判斷是否仍有多於一個元素未確定最小值\n    Yes → Step 3: mid ← low + (high - low) / 2 // 計算中點\n        Decision: nums[mid] > nums[high]? // 判斷 mid 是否在右側遞增段\n            Yes → Step 4: low ← mid + 1 // 最小值在右半段\n            No  → Step 5: high ← mid // 最小值在左半段或 mid 本身\n    No  → Step 6: return nums[low] // low == high 時找到最小值\nEnd // 程式結束\n\nBut we need Step 6 outside loop? Actually loop continues until low == high. So Step 6 can be after loop. Use End. Provide proper arrows: For loop, use Decision block. We'll need to embed the loop inside Decision block? Use \"Decision: low < high?\" then Yes block contains mid calculation and inner decision, and the loop restarts. This might be complex but we can structure as:\n\n→ Decision: low < high? \n    Yes → Step 3...\n    No → Step 6...\n\nBut we need to indicate that after inner decisions, we loop back. Use \"→ Step 3\" inside block, then after that \"→ Back to Decision\". Instead we can use \"→ Step 3\" then \"→ Step 4\" then \"→ Step 5\" then \"→ Step 7: Go back to Decision\". Could do simpler: Represent loop with a \"While low < high:\" but spec expects arrow and Decision. We'll use Decision: low < high? with Yes branch containing steps including re-evaluating low/high and then at end go back to Decision.\n\nThus pseudo:\n\nStart\n→ Step 1: input nums, n = length\n→ Step 2: low ← 0, high ← n-1\n→ Decision: low < high? // 是否還有多於一個元素未確定最小值\n    Yes → Step 3: mid ← low + (high - low) / 2\n        Decision: nums[mid] > nums[high]? // mid 在右側遞增段\n            Yes → Step 4: low ← mid + 1 // 移動到右半段\n            No  → Step 5: high ← mid // 移動到左半段\n        → Back to Decision: low < high? // 重新評估條件\n    No  → Step 6: return nums[low] // low==high 時為最小值\nEnd\n\nNeed to express \"Back to Decision\" maybe as a comment. Use arrow \"→\" for back? Could use \"←\" but spec uses arrows. Could just mention \"→ Decision: low < high?\" again. But we already have that as the outer decision. The block automatically loops? Might be okay. Use \"→\" to show loop back. Let's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 nums, n ← length(nums) // 取得輸入陣列及其長度  \n→ Step 2: low ← 0, high ← n-1 // 初始化搜尋範圍  \n\n→ Decision: low < high? // 是否仍有多於一個元素未確定最小值  \n    Yes → Step 3: mid ← low + (high - low) / 2 // 計算中點  \n        Decision: nums[mid] > nums[high]? // mid 是否在右側遞增段  \n            Yes → Step 4: low ← mid + 1 // 最小值在右半段  \n            No  → Step 5: high ← mid // 最小值在左半段或 mid 本身  \n        → Back to Decision: low < high? // 重新評估條件，繼續迴圈  \n    No  → Step 6: return nums[low] // low == high 時找到最小值  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        # 若陣列未旋轉，直接返回最小值\n        if nums[left] <= nums[right]:\n            return nums[left]\n        # 二分搜尋找轉折點\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1   # 最小值在右半段\n            else:\n                right = mid      # 最小值在左半段或 mid 本身\n        return nums[left]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取陣列部分，並將其轉成 Python list。\n    允許輸入類似 'nums = [3,4,5,1,2]' 的格式。\n    \"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    arr_str = data[start:end+1]\n    try:\n        return eval(arr_str, {\"__builtins__\": None}, {})\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    if not nums:\n        # 若解析失敗，嘗試直接 eval 整個輸入\n        try:\n            nums = eval(raw_input.strip(), {\"__builtins__\": None}, {})\n        except Exception:\n            nums = []\n    solution = Solution()\n    result = solution.findMin(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,4,5,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [11,13,15,17]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode552.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record II",
    "description_snippet": "An attendance record for a student can be represented as a string where each character signifies whe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step, explaining each line. Must not output actual code. It's a dynamic programming counting strings of length n with constraints: at most one 'A' (since strictly fewer than 2 absent days) and no 3 consecutive 'L's. Count modulo 1e9+7.\n\nWe should outline algorithm: DP over positions, count of absent used (0 or 1), consecutive late count (0-2). DP[i][a][l] number of sequences up to i. Transition adding P, L, A. Use modulo. Sum at end for i=n over all a,l. Complexity O(n). Provide pseudo-code.\n\nWe need to output line by line with explanation.\n\nLet's structure: Start → Step 1: initialize constants. → Step 2: initialize DP array. → Step 3: iterate positions 1..n. Within each: loop over a, l. → Step 4: transitions for each char. Use modulo. → Step 5: after loop, compute result. → End.\n\nAdd decision points maybe.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MOD ← 1_000_000_007 // 用於取模運算  \n→ Step 2: 建立 3 维 DP 陣列: DP[0..n][0..1][0..2] ← 0 // i 為已處理天數, a 為已缺席數(0 或 1), l 為連續遲到數  \n→ Step 3: 設置初始值: DP[0][0][0] ← 1 // 0 天時只有一種空序列  \n→ Decision: 是否還有天要處理?  \n    Yes → Step 4: 進入主迴圈: for i from 0 to n-1  \n        → Step 5: 針對每個狀態 a in {0,1}, l in {0,1,2}  \n            → Decision: DP[i][a][l] > 0?  \n                Yes → Step 6: Transition 添加 'P'  \n                    → Step 7: DP[i+1][a][0] ← (DP[i+1][a][0] + DP[i][a][l]) mod MOD  \n                    → Step 8: Transition 添加 'L' 若 l < 2  \n                        → Decision: l < 2?  \n                            Yes → Step 9: DP[i+1][a][l+1] ← (DP[i+1][a][l+1] + DP[i][a][l]) mod MOD  \n                No → Step 10: 跳過此無效狀態  \n        → Step 11: 在 i 的所有狀態處理完畢後, 進行 'A' 的轉移 (只在 a == 0 時可加入)  \n            → Decision: a == 0?  \n                Yes → Step 12: DP[i+1][1][0] ← (DP[i+1][1][0] + DP[i][0][l]) mod MOD  \n                No → Step 13: 不做任何操作  \n        → Step 14: i+1 天已處理完畢  \n    No → Step 15: 所有天數已處理完畢  \n→ Step 16: 計算答案: ans ← 0  \n    → for a in {0,1}  \n        → for l in {0,1,2}  \n            → ans ← (ans + DP[n][a][l]) mod MOD  \n→ Step 17: 輸出 ans // 符合條件的所有序列數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def checkRecord(self, n: int) -> int:\n        # dp[a][l] 代表已處理的天數中，缺席數 a（0 或 1）且最後連續遲到數 l（0~2）的有效序列個數\n        dp = [[0] * 3 for _ in range(2)]\n        dp[0][0] = 1  # 空序列\n\n        for _ in range(n):\n            new_dp = [[0] * 3 for _ in range(2)]\n            for a in range(2):          # 缺席數\n                for l in range(3):      # 連續遲到數\n                    val = dp[a][l]\n                    if not val:\n                        continue\n\n                    # 加入 'P'（Present）：遲到數歸零\n                    new_dp[a][0] = (new_dp[a][0] + val) % MOD\n\n                    # 加入 'A'（Absent）：只能在 a==0 時才允許\n                    if a == 0:\n                        new_dp[1][0] = (new_dp[1][0] + val) % MOD\n\n                    # 加入 'L'（Late）：遲到數遞增，不能超過 2\n                    if l < 2:\n                        new_dp[a][l + 1] = (new_dp[a][l + 1] + val) % MOD\n\n            dp = new_dp\n\n        # 所有天數處理完畢後，累加所有合法狀態\n        return sum(dp[a][l] for a in range(2) for l in range(3)) % MOD\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    n = int(data)\n    sol = Solution()\n    print(sol.checkRecord(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "10101",
          "expected_output": "183236316",
          "success": true,
          "output": "183236316"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode334.json",
    "problem_index_in_file": 0,
    "title": "Increasing Triplet Subsequence",
    "description_snippet": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i <...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. The algorithm: find increasing triplet subsequence. Standard approach: track first and second minimal values. Use loop: for each num, update first if num <= first; else if num <= second then update second; else return true. Finally return false.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化 first = ∞, second = ∞ // 用無限大作為初始值\n→ Step 2: 遍歷 nums 中每個 num // 逐一檢查元素\n    → Decision: 若 num <= first? // 若小於等於第一個最小值\n        Yes → Step 3: first = num // 更新第一個最小值\n        No  → Decision: 若 num <= second? // 檢查是否小於等於第二個最小值\n            Yes → Step 4: second = num // 更新第二個最小值\n            No  → Step 5: 返回 true // 發現三元組，結束\n→ Step 6: 返回 false // 迴圈結束後仍未找到三元組\nEnd\n\nMake sure each line is separate, with comments. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 first = ∞, second = ∞ // 用無限大作為初始值，表示尚未找到第一、第二個最小值  \n→ Step 2: 遍歷 nums 中每個 num // 逐一檢查陣列中的每個元素  \n    → Decision: 若 num <= first? // 如果當前數字不大於已知的最小值  \n        Yes → Step 3: first = num // 更新第一個最小值  \n        No  → Decision: 若 num <= second? // 否則檢查是否不大於已知的第二個最小值  \n            Yes → Step 4: second = num // 更新第二個最小值  \n            No  → Step 5: 返回 true // 發現一個 i < j < k 且 nums[i] < nums[j] < nums[k] 的三元組，結束程式  \n→ Step 6: 返回 false // 迴圈結束後仍未找到符合條件的三元組  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def increasingTriplet(self, nums):\n        \"\"\"Return True if there exists an increasing triplet subsequence.\"\"\"\n        first = second = float('inf')\n        for num in nums:\n            if num <= first:\n                first = num\n            elif num <= second:\n                second = num\n            else:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Support input formats like \"nums = [1,2,3]\"\n    if '=' in data:\n        _, arr_part = data.split('=', 1)\n        arr_part = arr_part.strip()\n    else:\n        arr_part = data\n    try:\n        nums = ast.literal_eval(arr_part)\n    except Exception:\n        nums = []\n    solution = Solution()\n    result = solution.increasingTriplet(nums)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [5,4,3,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,5,0,4,6]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode390.json",
    "problem_index_in_file": 0,
    "title": "Elimination Game",
    "description_snippet": "You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find last remaining number after repeatedly removing every other element, alternating direction. It's essentially Josephus problem variant. For n, the solution: find highest power of 2 <= n, let L = n - 2^k. If L==0 return n, else return 2*L. That is the last remaining. But the user asked for virtual code steps with explanations. Must produce line by line, using Start, Decision, etc. We should not give actual code, but pseudo steps. Provide steps to compute. We can incorporate calculation of highest power of 2. Use loops or bit operations. Provide virtual code that returns result.\n\nThus output lines:\n\nStart // start program\n→ Step 1: Initialize n from input // get n\n→ Decision: If n <= 0? // check valid\n    Yes → Step 2: Return error // invalid\n    No  → Step 3: Compute highest power of 2 ≤ n // find 2^k\n... but can use bit shifting or loop. Use loop: Set power=1; while power*2 <= n: power*=2.\n\nContinue:\n\n→ Step 4: Compute L = n - power // remainder\n→ Decision: If L == 0? // if n is power of two\n    Yes → Step 5: Result = n // last number is n\n    No  → Step 6: Result = 2 * L // else double remainder\n→ Step 7: Output Result // return final number\nEnd // finish\n\nBut also maybe incorporate explanation of alternate directions algorithm? Provide explanation. Provide virtual code steps accordingly. Should have arrow lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 n // 從使用者取得整數 n  \n→ Decision: n 是否小於等於 0? // 檢查輸入是否合法  \n  Yes → Step 2: 輸出錯誤訊息並結束 // n 必須為正整數  \n  No  → Step 3: 初始化 power = 1 // 設定最小 2 的冪  \n→ Decision: power * 2 小於等於 n? // 判斷是否可再乘 2  \n  Yes → Step 4: power = power * 2 // 將 power 更新為下一個 2 的冪  \n  No  → Step 5: 跳出迴圈 // 已得到最大的 2 的冪  \n→ Step 6: 計算 L = n - power // 計算 n 超過最大 2 的冪的餘數  \n→ Decision: L 等於 0? // 判斷 n 是否正好是 2 的冪  \n  Yes → Step 7: Result = n // 若是 2 的冪，最後剩下的數字就是 n  \n  No  → Step 8: Result = 2 * L // 否則最後剩下的數字是 2 乘餘數  \n→ Step 9: 輸出 Result // 回傳最後剩下的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef last_remaining(n: int) -> int:\n    \"\"\"Return the last remaining number after repeatedly removing every other element\n    while alternating direction.\"\"\"\n    # Find the largest power of two less than or equal to n\n    power = 1\n    while power << 1 <= n:\n        power <<= 1\n\n    remainder = n - power\n    # If n is exactly a power of two, the last number is n itself.\n    # Otherwise, the last number is twice the remainder.\n    return n if remainder == 0 else 2 * remainder\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract integer n from possible formats like \"n = 9\" or just \"9\"\n    if '=' in data:\n        try:\n            n = int(data.split('=')[1].strip())\n        except ValueError:\n            n = int(data.strip())\n    else:\n        n = int(data)\n\n    print(last_remaining(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 9",
          "expected_output": "6",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode456.json",
    "problem_index_in_file": 0,
    "title": "132 Pattern",
    "description_snippet": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j]...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps line by line with explanation. No actual code, just virtual steps. Use Start, Decision, End. For algorithm to detect 132 pattern, typical solution: iterate from right, maintain stack of potential nums[j] and track max_of_left. Let's produce pseudo steps:\n\nStart\n→ Input array nums // obtain input\n→ Decision: n < 3? // if less than 3 elements, no pattern\n    Yes → Output false // less than 3 elements cannot form pattern\n    No  → Step: Initialize empty stack // to store potential nums[j]\n→ For i from n-1 down to 0 // iterate reverse\n    Step: current = nums[i]\n    → Decision: current < max_of_left? // if current less than max_of_left, potential i\n        Yes → Output true // found pattern\n        No  → Step: while stack not empty and current > stack.top() // adjust stack\n            Step: max_of_left = stack.pop() // update max_of_left\n        → Decision: stack not empty? // if stack still has elements\n            Yes → Step: stack.push(current) // push current as potential nums[j]\n            No  → Step: stack.push(current) // push anyway (same)\n→ End // no pattern found\nOutput false // after loop\n\nBut we need to embed decisions and steps correctly. Provide explanation after each line.\n\nLet's craft pseudocode with arrows, indent etc. Use \"Decision:\" and \"Yes →\", \"No →\". Provide explanation comment after //.\n\nEnsure each line has \"虛擬碼步驟 // 解釋\".\n\nLet's create step names like Step 1, Step 2.\n\nWe need to reflect typical algorithm.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取陣列 nums  // 取得輸入的整數序列  \n→ Decision: nums.Length < 3?  // 判斷元素是否不足三個  \n    Yes → Step 2: 回傳 false  // 少於三個無法構成 132 模式  \n    No  → Step 3: 建立空棧 stack // 用於保存潛在的 nums[j]  \n→ Step 4: 初始化變數 max_of_left = -∞ // 用於記錄已遍歷部分的最大值  \n→ Step 5: 反向迴圈 i 從 nums.Length-1 下降到 0 // 從右往左掃描  \n    → Step 5a: current = nums[i] // 取目前元素作為 nums[i]  \n    → Decision: current < max_of_left?  // 檢查是否能成為 nums[i]  \n        Yes → Step 5b: 回傳 true  // 找到 132 模式  \n        No  → Step 5c: 內部 while stack 不是空且 current > stack.Top()  \n            → Step 5c1: max_of_left = stack.Pop() // 取出較小的 j 值，更新最大左值  \n        → Decision: stack 不是空?  // 判斷是否還有潛在的 nums[j]  \n            Yes → Step 5d: stack.Push(current) // 將 current 作為新的潛在 j  \n            No  → Step 5d: stack.Push(current) // 同樣推入，供後續比較  \n→ End // 已完成所有元素檢查  \n→ Step 6: 回傳 false  // 沒有任何 132 模式存在於陣列中。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    \"\"\"\n    解法：從右往左掃描，使用棧儲存可能的 nums[j]，同時維護一個 s3（即已知的最大 nums[i]）\n    - 若遇到 num < s3，則證明存在 132 模式。\n    - 否則，將棧中所有比 num 小的元素彈出，並把最後彈出的值作為新的 s3。\n    - 把 num 推入棧，繼續下一個元素。\n    \"\"\"\n    def find132pattern(self, nums):\n        stack = []\n        s3 = float('-inf')  # 代表已知的 nums[i] 的最大值\n        for num in reversed(nums):\n            if num < s3:\n                return True\n            while stack and stack[-1] < num:\n                s3 = stack.pop()\n            stack.append(num)\n        return False\n\ndef main():\n    # 讀取整個輸入，並嘗試解析出 list\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 去除可能的「nums = 」前綴\n    if '=' in raw_input:\n        _, raw_input = raw_input.split('=', 1)\n    raw_input = raw_input.strip()\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # 如果無法解析，直接結束\n        return\n\n    sol = Solution()\n    result = sol.find132pattern(nums)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,3,2,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode6.json",
    "problem_index_in_file": 0,
    "title": "ZigZag Conversion",
    "description_snippet": "Convert a string to a zigzag pattern and read line by line....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants pseudo-code for converting a string to a zigzag pattern and reading line by line. They want it in Traditional Chinese, step-by-step with comments, using arrows, etc.\n\nThey want the output in the specified format. Let's produce virtual code lines with comments. The algorithm: input string s, numRows. If numRows <=1 or len <= numRows, return s. We create array rows of string builders. For each char c in s, determine row index: row = index % (2*numRows-2); if row >= numRows, row = 2*numRows-2 - row. Append char to rows[row]. After loop, concatenate rows to result. Output result. We'll produce steps.\n\nLet's produce Start, input, decision, loop, etc.\n\nWe need to ensure each line follows format: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" or \"Decision:\" etc. The steps should be clear.\n\nLet's write:\n\nStart\n→ Step 1: 輸入字串 S 和行數 R // 取得輸入\n→ Decision: 若 R <= 1 或 |S| <= R? // 檢查特殊情況\n    Yes → Step 2: 回傳 S // 無需 zigzag\n    No  → Step 3: 建立行數為 R 的空字串陣列 rows // 用於儲存每行\n→ Step 4: 設定 cycle = 2*R - 2 // 一個完整上下週期長度\n→ Step 5: 針對每個字元 (索引 i, 字元 c) 進行\n    → Compute row = i % cycle\n    → Decision: 若 row >= R? // 判斷是否在下降階段\n        Yes → row = cycle - row // 反轉行號\n        No  → // row 保持不變\n    → Append c 到 rows[row] // 加入相應行\n→ Step 6: 初始化 result 為空字串 // 用於收集最終結果\n→ Step 7: 依序遍歷 rows 並將每行字串追加到 result // 讀取行\n→ End // 回傳 result\n\nLet's format each line. Ensure each line includes \"虛擬碼步驟 // 解釋\". For decision, we need \"Decision:\". For arrows, \"→\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 S 及行數 R // 取得輸入資料  \n→ Decision: R <= 1 或 |S| <= R? // 檢查是否需要特殊處理  \n  Yes → Step 2: 回傳 S // 若只有一行或字串短於行數，直接回傳原字串  \n  No  → Step 3: 建立 rows[0…R-1] 為空字串陣列 // 用來儲存每一行的字元  \n→ Step 4: 計算 cycle = 2*R - 2 // 一個完整上下週期的長度  \n→ Step 5: 針對 S 中每個字元 (索引 i, 字元 c) 進行  \n  → 計算 row = i % cycle // 找到在週期中的位置  \n  → Decision: row >= R? // 判斷是否處於下降階段  \n    Yes → row = cycle - row // 反轉行號以得到正確行  \n    No  → // row 保持不變  \n  → Append c 到 rows[row] // 把字元加入對應的行  \n→ Step 6: 初始化 result 為空字串 // 用來收集最終的 zigzag 字串  \n→ Step 7: 依序遍歷 rows[0…R-1] 並將每行字串追加到 result // 讀取行列  \n→ End // 回傳 result，程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"將字串轉換為 zigzag 模式後，按行讀取並回傳結果。\"\"\"\n        if numRows == 1 or numRows >= len(s):\n            return s\n        rows = [''] * numRows\n        index, step = 0, 1\n        for c in s:\n            rows[index] += c\n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n        return ''.join(rows)\n\ndef parse_input(raw: str):\n    \"\"\"\n    從 raw string 解析字串 s 與 numRows。\n    支援兩種格式：\n        1. s = '...字符串...', numRows = 3\n        2. 第一行是字串，第二行是數字\n    \"\"\"\n    # 先嘗試以正則式解析\n    s_match = re.search(r\"s\\s*=\\s*'([^']*)'\", raw)\n    num_match = re.search(r\"numRows\\s*=\\s*(\\d+)\", raw)\n    if s_match and num_match:\n        s = s_match.group(1)\n        numRows = int(num_match.group(1))\n        return s, numRows\n\n    # 若正則失敗，嘗試兩行輸入\n    lines = [line.strip() for line in raw.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        # 第一行可能是字串本身或有前綴\n        s_line = lines[0]\n        if s_line.startswith(\"s\"):\n            s_match = re.search(r\"='([^']*)'\", s_line)\n            if s_match:\n                s = s_match.group(1)\n            else:\n                # 直接取引號內文字\n                s = s_line.strip(\"'\")\n        else:\n            s = s_line.strip(\"'\")\n        try:\n            numRows = int(lines[1])\n        except ValueError:\n            numRows = int(re.search(r\"\\d+\", lines[1]).group())\n        return s, numRows\n\n    # 最後退回，假設整個輸入就是字串，且 numRows 為 1\n    return raw.strip(\"'\"), 1\n\ndef main():\n    raw_input = sys.stdin.read()\n    s, numRows = parse_input(raw_input)\n    result = Solution().convert(s, numRows)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "success": true,
          "output": "PAHNAPLSIIGYIR"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode140.json",
    "problem_index_in_file": 0,
    "title": "Word Break II",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for word break II problem. Steps: start, input s and wordDict, convert dict to set, initialize memo map, recursion function dfs(start) that returns list of sentences from start to end. In recursion, if start == len(s) return ['']. For each end from start+1 to len(s), if s[start:end] in dict, recursively get list from dfs(end), then for each sub in that list, combine with current word plus space if sub not empty. Memoize result. Finally return dfs(0). End.\n\nWe must output each line with virtual code and comment. Use arrows and Decision. Provide step-by-step. Let's craft.\n\nUse Start, →, Decision, Yes→, No→. Use End.\n\nWe'll use pseudocode:\n\nStart // begin\n→ Step 1: Input s, wordDict // get parameters\n→ Step 2: wordSet = Set(wordDict) // convert to set for O(1) lookups\n→ Step 3: memo = Map() // initialize memoization map\n→ Function dfs(start): // recursion to get sentences from start\n    → Decision: start == len(s)? // base case\n        Yes → Return [''] // empty string represents end\n        No\n    → Step 4: if memo contains start → Return memo[start] // memoization\n    → Step 5: result = [] // list to accumulate sentences\n    → Step 6: for end in range(start+1, len(s)+1):\n        → Decision: s[start:end] in wordSet?\n            Yes\n                → Step 7: subSentences = dfs(end) // recursive call\n                → Step 8: for sub in subSentences:\n                    → Step 9: sentence = s[start:end] + (sub ? ' ' + sub : '') // combine\n                    → Step 10: result.append(sentence) // add\n            No // do nothing\n    → Step 11: memo[start] = result // store in memo\n    → Step 12: return result // return list\n\n→ Step 13: output = dfs(0) // get all sentences\n→ End\n\nWe must format each line accordingly. Let's produce.\n\nNote: Use arrow \"→\" after each step, and use indentation for nested steps? Use spaces. The sample shows indentation for nested decisions. We'll replicate.\n\nWe'll also include indentation via spaces before arrow? In sample, arrow at start of line. We'll follow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 s, wordDict // 取得要分割的字串及字典\n→ Step 2: wordSet = Set(wordDict) // 把字典轉成集合，方便 O(1) 查詢\n→ Step 3: memo = Map() // 建立記憶化表，避免重複計算\n→ Function dfs(start): // 定義遞迴函式，從 index start 開始分割\n    → Decision: start == len(s)? // 判斷是否已到字串結尾\n        Yes → Return [''] // 回傳一個空字串，表示到達結束\n        No\n    → Decision: memo contains start? // 檢查是否已計算過此起點\n        Yes → Return memo[start] // 直接回傳已儲存的結果\n        No\n    → Step 4: result = [] // 用於存放從 start 開始的所有可能句子\n    → Step 5: for end in range(start+1, len(s)+1): // 嘗試所有可能的切割點\n        → Decision: s[start:end] in wordSet? // 檢查切割出的子字串是否在字典中\n            Yes\n                → Step 6: subSentences = dfs(end) // 取得從 end 位置開始的句子列表\n                → Step 7: for sub in subSentences: // 對每個子句子進行組合\n                    → Step 8: sentence = s[start:end] + (sub ? ' ' + sub : '') // 加上空格連接\n                    → Step 9: result.append(sentence) // 加入到結果中\n            No // 若不是字典單字，則跳過\n    → Step 10: memo[start] = result // 記錄此起點的所有結果\n    → Step 11: return result // 回傳從 start 開始的句子列表\n→ Step 12: output = dfs(0) // 從字串開頭開始，得到所有可能句子\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub_sentence in backtrack(end):\n                        if sub_sentence:\n                            res.append(word + \" \" + sub_sentence)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    # Extract the string s\n    s_match = re.search(r\"s\\s*=\\s*(['\\\"])(.*?)\\1\", data)\n    s = s_match.group(2) if s_match else \"\"\n\n    # Extract the wordDict list\n    dict_match = re.search(r\"wordDict\\s*=\\s*(\\[.*\\])\", data, re.DOTALL)\n    word_dict_str = dict_match.group(1) if dict_match else \"[]\"\n    wordDict = ast.literal_eval(word_dict_str)\n\n    result = Solution().wordBreak(s, wordDict)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "success": true,
          "output": "['cat sand dog', 'cats and dog']"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "success": true,
          "output": "['pine apple pen apple', 'pine applepen apple', 'pineapple pen apple']"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode396.json",
    "problem_index_in_file": 0,
    "title": "Rotate Function",
    "description_snippet": "You are given an integer array nums of length n.\n\nAssume arrk to be an array obtained by rotating nu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code, step by step, for algorithm to compute maximum rotation function value. It's classic problem: rotation function F(k). Efficient O(n) solution: compute sum of array, compute F(0), then iterative update: F(k+1) = F(k) + sum - n * arr[k]. Keep max.\n\nWe'll produce virtual code lines, with arrows. Use Start, End, Decision, etc.\n\nNeed to output each line with virtual code and comment. No actual code. Just steps. Use \"→\" arrows.\n\nLet's design steps:\n\nStart\n→ Step 1: 計算陣列長度 n\n→ Step 2: 計算總和 sum = Σ nums[i]\n→ Step 3: 計算 F(0) = Σ i * nums[i]\n→ Step 4: 初始化 maxVal = F(0)\n→ Step 5: 從 k = 0 到 n-2 循環\n    → Step 5.1: 更新 F(k+1) = F(k) + sum - n * nums[k]\n    → Step 5.2: 更新 maxVal = max(maxVal, F(k+1))\n→ End // 回傳 maxVal\n\nBut we need decision? We might add decision to check if k loop done.\n\nWe need arrow lines like \"→ Decision:\" for loop condition.\n\nLet's produce:\n\nStart\n→ Step 1: n ← length of nums // 取得陣列長度\n→ Step 2: sum ← 0 // 初始化總和\n    → For i from 0 to n-1:\n        → sum ← sum + nums[i] // 累加總和\n→ Step 3: F ← 0 // 初始化旋轉函數\n    → For i from 0 to n-1:\n        → F ← F + i * nums[i] // 計算 F(0)\n→ Step 4: maxVal ← F // 設定最大值為 F(0)\n→ Decision: k < n-1? // 檢查是否還有剩餘旋轉\n    Yes → Step 5: k ← 0 // 旋轉指標\n    While k < n-1:\n        → Step 5.1: F ← F + sum - n * nums[k] // 更新下一個旋轉函數\n        → Step 5.2: maxVal ← max(maxVal, F) // 更新最大值\n        → Step 5.3: k ← k + 1 // 移動到下一個旋轉\n        → Decision: k < n-1? // 是否繼續\n            Yes → (continue loop)\n            No  → End // 輸出 maxVal\n\nBut maybe we can simplify: Use loop with counter i from 0 to n-2.\n\nLet's produce a clean pseudo code:\n\nStart\n→ Step 1: n ← length(nums)\n→ Step 2: sum ← Σ nums[i] for i=0..n-1\n→ Step 3: current ← Σ i * nums[i] for i=0..n-1 // F(0)\n→ Step 4: maxVal ← current\n→ Step 5: for k from 0 to n-2:\n    → Step 5.1: current ← current + sum - n * nums[k] // 更新 F(k+1)\n    → Step 5.2: maxVal ← max(maxVal, current) // 更新最大值\n→ End // 回傳 maxVal\n\nAdd decision: For loop condition? Could show \"Decision: k < n-1?\" but it's okay.\n\nLet's produce lines with arrow. For loops we use \"→ For\" maybe. Use \"Decision:\" to indicate loop condition.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: sum ← 0 // 初始化總和\n    → For i from 0 to n-1:\n        → sum ← sum + nums[i] // 累加各元素得到總和\n→ Step 3: current ← 0 // 初始化旋轉函數 F(0)\n    → For i from 0 to n-1:\n        → current ← current + i * nums[i] // 計算 F(0)\n→ Step 4: maxVal ← current // 將 F(0) 設為目前最大值\n→ Decision: k < n-1? // 檢查是否還有剩餘旋轉\n    Yes → Step 5: k ← 0 // 旋轉索引初始化\n    → While k < n-1:\n        → Step 5.1: current ← current + sum - n * nums[k] // 更新 F(k+1)\n        → Step 5.2: maxVal ← max(maxVal, current) // 若更大則更新最大值\n        → Step 5.3: k ← k + 1 // 移動至下一個旋轉\n        → Decision: k < n-1? // 判斷是否繼續迴圈\n            Yes → (loop back to Step 5.1)\n            No  → End // 迴圈結束，返回最大值\nEnd // 程式執行結束，回傳 maxVal",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxRotateFunction(self, A):\n        n = len(A)\n        if n == 0:\n            return 0\n        total = sum(A)\n        # F(0)\n        current = sum(i * num for i, num in enumerate(A))\n        max_val = current\n        # Rotate clockwise by 1 repeatedly\n        for i in range(n - 1):\n            # element that moves from end to front in this rotation\n            moved = A[n - 1 - i]\n            current += total - n * moved\n            if current > max_val:\n                max_val = current\n        return max_val\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    result = sol.maxRotateFunction(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "success": true,
          "output": "26"
        },
        {
          "example_index": 1,
          "input": "nums = [100]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode307.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Mutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following types:\n\nUpdate the value of an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for implementing a NumArray class with constructor, update, sumRange using maybe a segment tree or BIT. Provide steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Include Start, End. Provide decisions. Let's write generic algorithm: Build segment tree. Then update leaf, recalc. sumRange: query.\n\nWe need to generate steps that a user could follow. Each step in pseudo code. Not actual code. Use arrows.\n\nLet's produce:\n\nStart\n→ Step 1: Define class NumArray\n→ Step 2: Declare array nums and tree array segTree, size n\n→ Step 3: Constructor: store n, build segTree from nums\n→ Decision: Is nums empty? etc.\n\nBut we can produce simple flow. Provide steps for build, update, query.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 NumArray，內部包含兩個陣列：nums（原始數值）與 segTree（區間樹）  \n→ Step 2: 宣告變數 n 代表 nums 長度  \n→ Step 3: 建構子 NumArray(nums)  \n  → 將輸入陣列複製至類別內部的 nums  \n  → 計算 segTree 大小為 4 * n（足以存放完整二叉樹）  \n  → 建立 segTree：呼叫 buildTree(node=1, start=0, end=n-1)  \n→ Step 4: 建立區間樹 buildTree(node, start, end)  \n  → 如果 start == end  \n    Yes → segTree[node] = nums[start] // 單一元素直接存入  \n    No → 繼續  \n  → 否則  \n    No → mid = (start + end) / 2  \n     → buildTree(node*2, start, mid) // 左子樹  \n     → buildTree(node*2+1, mid+1, end) // 右子樹  \n     → segTree[node] = segTree[node*2] + segTree[node*2+1] // 父節點為子節點和  \n→ Step 5: 更新方法 update(index, val)  \n  → 設置 nums[index] = val // 同步原始陣列  \n  → 呼叫 updateTree(node=1, start=0, end=n-1, idx=index, val=val)  \n→ Step 6: 更新區間樹 updateTree(node, start, end, idx, val)  \n  → 如果 start == end  \n    Yes → segTree[node] = val // 更新葉節點  \n    No → 繼續  \n  → 否則  \n    No → mid = (start + end) / 2  \n     → 如果 idx <= mid  \n      Yes → updateTree(node*2, start, mid, idx, val) // 更新左子樹  \n      No → updateTree(node*2+1, mid+1, end, idx, val) // 更新右子樹  \n     → segTree[node] = segTree[node*2] + segTree[node*2+1] // 重新計算父節點  \n→ Step 7: sumRange 方法 sumRange(left, right)  \n  → 回傳 queryTree(node=1, start=0, end=n-1, l=left, r=right)  \n→ Step 8: 查詢區間樹 queryTree(node, start, end, l, r)  \n  → 如果 r < start 或 l > end  \n    Yes → return 0 // 無交集  \n    No → 繼續  \n  → 如果 l <= start 且 end <= r  \n    Yes → return segTree[node] // 範圍完全覆蓋  \n    No → 繼續  \n  → mid = (start + end) / 2  \n  → leftSum = queryTree(node*2, start, mid, l, r) // 左子樹查詢  \n  → rightSum = queryTree(node*2+1, mid+1, end, l, r) // 右子樹查詢  \n  → return leftSum + rightSum // 合併結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        self.tree = [0] * (self.n + 1)\n        for i, val in enumerate(nums, 1):\n            self._update_tree(i, val)\n\n    def _update_tree(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to parse the input as two lists enclosed in brackets\n    try:\n        ops, args = json.loads('[' + data + ']')\n    except json.JSONDecodeError:\n        # Fallback: input may be two separate lines\n        lines = data.splitlines()\n        ops = json.loads(lines[0])\n        args = json.loads(lines[1])\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])   # arg is like [[1,2,3]]\n            results.append(None)\n        elif op == \"update\":\n            obj.update(arg[0], arg[1])\n            results.append(None)\n        elif op == \"sumRange\":\n            res = obj.sumRange(arg[0], arg[1])\n            results.append(res)\n        else:\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "success": true,
          "output": "[null, 9, null, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode342.json",
    "problem_index_in_file": 0,
    "title": "Power of Four",
    "description_snippet": "Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with \"虛擬碼步驟\" and comment. The requirement: no actual code, only pseudocode. Use arrows, Start, End, Decision, etc. We need to generate a step-by-step algorithm for checking if integer n is power of four.\n\nWe need to output lines: \"Start // 程式開始執行\" then steps.\n\nWe'll need to check if n <= 0 → false. Then check n & (n-1) == 0 to ensure it's power of two. Then check n % 4 == 1? Actually for powers of 4, they are powers of 2 and odd in binary? Wait powers of 4: 1,4,16,64,... In binary: 1=1, 4=100, 16=10000, 64=1000000. They are powers of two with only one 1 bit and that bit is at an even index? Actually the bit positions start from 0: 1 (bit0), 4 (bit2), 16(bit4). So the bit index is even. So we can check if n > 0 and (n & (n-1)) == 0 and (n-1) % 3 == 0? Wait known trick: n > 0 && (n & (n-1)) == 0 && (n-1) % 3 == 0. But simpler: n > 0 && (n & (n-1)) == 0 && (n & 0x55555555) == n. But we don't need specifics. Just algorithm: while n > 1: if n % 4 != 0 return false; n /= 4; end while; return true. But that would handle 1. So we need to consider n=1 as true. Steps:\n\nStart\n→ Step 1: Receive input integer n // 获得整数\n→ Decision: If n <= 0? // 负数或零不是 4 的幂\n    Yes → Step 2: Return false // 返回 false\n    No → Decision: If n == 1? // 1 是 4^0\n        Yes → Step 3: Return true // 返回 true\n        No → Step 4: While n > 1\n            → Decision: If n mod 4 != 0? // 当前数不是 4 的倍数\n                Yes → Step 5: Return false // 不是 4 的幂\n                No → Step 6: n = n / 4 // 除以 4 继续判断\n            → End While\n            → Step 7: Return true // 循环结束表示是 4 的幂\nEnd\n\nWe must format each line: \"虛擬碼步驟 // 解釋\". So each step must include arrow arrow. Let's produce accordingly.\n\nAlso note we need arrow \"→\" before steps.\n\nWe should produce like:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入整數 n // 取得使用者輸入的數字\n→ Decision: n <= 0? // 檢查數字是否小於等於 0\n    Yes → Step 2: 回傳 false // 不是 4 的冪\n    No → Decision: n == 1? // 1 為 4^0\n        Yes → Step 3: 回傳 true // 1 是 4 的冪\n        No → Step 4: While n > 1 // 對於 n 大於 1 的情況進行循環\n            → Decision: n mod 4 != 0? // 判斷 n 是否是 4 的倍數\n                Yes → Step 5: 回傳 false // 不是 4 的冪\n                No → Step 6: n = n / 4 // 除以 4 後繼續檢查\n            → End While\n            → Step 7: 回傳 true // 所有檢查通過，為 4 的冪\nEnd // 程式結束\n\nBut need to keep each line separate, including indentation for sub-steps? We can indent but each line should be separate. We can use indentation by spaces, but keep format same: arrow + step or decision. The example shows indent for sub-steps but still each line separate.\n\nWe'll output accordingly. Ensure no actual code. Just virtual code. Use Chinese comments.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入整數 n // 取得使用者輸入的數字  \n→ Decision: n <= 0? // 檢查數字是否小於等於 0  \n    Yes → Step 2: 回傳 false // 不是 4 的冪  \n    No → Decision: n == 1? // 1 為 4^0  \n        Yes → Step 3: 回傳 true // 1 是 4 的冪  \n        No → Step 4: While n > 1 // 對於 n 大於 1 的情況進行循環  \n            → Decision: n mod 4 != 0? // 判斷 n 是否是 4 的倍數  \n                Yes → Step 5: 回傳 false // 不是 4 的冪  \n                No → Step 6: n = n / 4 // 除以 4 後繼續檢查  \n            → End While  \n            → Step 7: 回傳 true // 所有檢查通過，為 4 的冪  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        \"\"\"\n        Determine whether an integer n is a power of four.\n        A number is a power of four if it is greater than 0,\n        is a power of two ((n & (n-1)) == 0),\n        and the position of its single set bit is even\n        which can be checked by (n-1) % 3 == 0.\n        \"\"\"\n        return n > 0 and (n & (n - 1)) == 0 and (n - 1) % 3 == 0\n\ndef main():\n    # Read the entire input from stdin\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        # No integer found; nothing to process\n        return\n    n = int(numbers[0])\n    sol = Solution()\n    result = sol.isPowerOfFour(n)\n    # Print lowercase 'true' or 'false'\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode327.json",
    "problem_index_in_file": 0,
    "title": "Count of Range Sum",
    "description_snippet": "Given an integer array nums and two integers lower and upper, return the number of range sums that l...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for counting range sums in array. Use algorithm: prefix sums and divide and conquer / mergesort. So steps: compute prefix sums, then count using modified merge sort counting inversions within range difference constraints. Provide step-by-step pseudo-code lines with explanations.\n\nWe must output each line: \"虛擬碼步驟 // 解釋\".\n\nLet's outline:\n\nStart\n→ Step 1: 轉換 nums 為前綴和 array prefix where prefix[0] = 0, prefix[i] = prefix[i-1] + nums[i-1] // Build prefix sums\n→ Step 2: Call function countRangeSum(prefix, 0, len(prefix)-1, lower, upper) // initiate recursive counting\n→ Step 3: Function countRangeSum(arr, left, right, lower, upper): // define recursive\n    → Decision: if left >= right? // if single element\n        Yes → Return 0 // no range sum between indices\n        No  → ...\n    → Step 4: mid = (left + right) // 2\n    → Step 5: count = countRangeSum(arr, left, mid, lower, upper) + countRangeSum(arr, mid+1, right, lower, upper) // count left & right\n    → Step 6: count += countWhileMerge(arr, left, mid, right, lower, upper) // count cross sums\n    → Step 7: sort arr[left:mid+1] and arr[mid+1:right+1] then merge -> arr[left:right+1] // merge\n    → Return count // return cumulative\n→ Step 8: Function countWhileMerge(arr, left, mid, right, lower, upper):\n    → Initialize count=0\n    → For each i from left to mid:\n        → Use two pointers lo=mid+1, hi=mid+1\n        → While lo <= right and arr[lo] - arr[i] < lower: lo++ // find lower bound\n        → While hi <= right and arr[hi] - arr[i] <= upper: hi++ // find upper bound\n        → count += hi - lo // number of j satisfying\n    → Return count\n→ End // output count\n\nNeed to express each line with arrow etc.\n\nWe can combine steps into single lines but need arrow after each.\n\nLet's produce pseudo-code with decisions.\n\nWe need to use \"Start\", \"End\" markers. Use \"Decision:\" with Yes → / No →.\n\nWe'll need to define functions and nested steps; each line inside function may need indentation.\n\nUse \"→\" for line within function; use indentation via spaces.\n\nWe should be consistent.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Step 1: 生成前綴和 array prefix 其中 prefix[0] = 0，prefix[i] = prefix[i-1] + nums[i-1] // 建立前綴和\n→ Step 2: 呼叫 countRangeSum(prefix, 0, len(prefix)-1, lower, upper) // 開始遞迴計算\n→ Function countRangeSum(arr, left, right, lower, upper): // 定義遞迴函式\n    → Decision: if left >= right? // 單一元素或空段\n        Yes → Return 0 // 無效區間，回傳 0\n        No  → // 進一步分割\n    → Step 3: mid = (left + right) // 2 // 找中點\n    → Step 4: count = countRangeSum(arr, left, mid, lower, upper) // 計算左半部\n    → Step 5: count += countRangeSum(arr, mid+1, right, lower, upper) // 計算右半部\n    → Step 6: count += countWhileMerge(arr, left, mid, right, lower, upper) // 計算跨區間\n    → Step 7: 合併 arr[left:mid+1] 與 arr[mid+1:right+1] 為已排序陣列 // merge step\n    → Return count // 回傳總計\n→ Function countWhileMerge(arr, left, mid, right, lower, upper): // 計算跨區間的有效範圍\n    → Step 8: 初始化 count = 0 // 計數器\n    → For i from left to mid:\n        → Step 9: lo = mid + 1; hi = mid + 1 // 指標初始\n        → While lo <= right and arr[lo] - arr[i] < lower: lo++ // 尋找低閾\n        → While hi <= right and arr[hi] - arr[i] <= upper: hi++ // 尋找高閾\n        → count += hi - lo // 加入符合的 j 個數\n    → Return count // 回傳跨區間計數\nEnd // 程式執行結束\n```\n\nBut we need each line separate with arrow. The loops and function definitions may be represented as steps; each \"Function\" line considered a step, then inside we use indentation. The lines inside should start with arrow.\n\nBut the example shows indentation by spaces. We can mimic.\n\nLet's format:\n\n```\nStart // 程式開始執行\n→ Step 1: 生成前綴和 prefix 其中 prefix[0] = 0，prefix[i] = prefix[i-1] + nums[i-1] // 建立前綴和\n→ Step 2: 呼叫 countRangeSum(prefix, 0, len(prefix)-1, lower, upper) // 開始遞迴計算\n→ Function countRangeSum(arr, left, right, lower, upper): // 定義遞迴函式\n    → Decision: if left >= right? // 單一元素或空段\n        Yes → Return 0 // 無效區間，回傳 0\n        No  → // 進一步分割\n    → Step 3: mid = (left + right) // 2 // 找中點\n    → Step 4: count = countRangeSum(arr, left, mid, lower, upper) // 計算左半部\n    → Step 5: count += countRangeSum(arr, mid+1, right, lower, upper) // 計算右半部\n    → Step 6: count += countWhileMerge(arr, left, mid, right, lower, upper) // 計算跨區間\n    → Step 7: 合併 arr[left:mid+1] 與 arr[mid+1:right+1] 為已排序陣列 // merge step\n    → Return count // 回傳總計\n→ Function countWhileMerge(arr, left, mid, right, lower, upper): // 計算跨區間的有效範圍\n    → Step 8: 初始化 count = 0 // 計數器\n    → For i from left to mid:\n        → Step 9: lo = mid + 1; hi = mid + 1 // 指標初始\n        → While lo <= right and arr[lo] - arr[i] < lower: lo++ // 尋找低閾\n        → While hi <= right and arr[hi] - arr[i] <= upper: hi++ // 尋找高閾\n        → count += hi - lo // 加入符合的 j 個數\n    → Return count // 回傳跨區間計數\nEnd // 程式執行結束\n```\n\nNeed to ensure each line has arrow and comment. Indentation lines inside function start with spaces and arrow.\n\nAlso we need to have \"→\" before lines inside function and before \"Decision:\" lines.\n\nThe \"Decision:\" line we included; inside we have \"Yes →\" and \"No →\" lines.\n\nOk.\n\nCheck compliance: each line ends with comment.\n\nMake sure no actual code beyond pseudocode. Good.\n\nWe should keep lines as separate lines.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 生成前綴和 prefix 其中 prefix[0] = 0，prefix[i] = prefix[i-1] + nums[i-1] // 建立前綴和\n→ Step 2: 呼叫 countRangeSum(prefix, 0, len(prefix)-1, lower, upper) // 開始遞迴計算\n→ Function countRangeSum(arr, left, right, lower, upper): // 定義遞迴函式\n    → Decision: if left >= right? // 單一元素或空段\n        Yes → Return 0 // 無效區間，回傳 0\n        No  → // 進一步分割\n    → Step 3: mid = (left + right) // 2 // 找中點\n    → Step 4: count = countRangeSum(arr, left, mid, lower, upper) // 計算左半部\n    → Step 5: count += countRangeSum(arr, mid+1, right, lower, upper) // 計算右半部\n    → Step 6: count += countWhileMerge(arr, left, mid, right, lower, upper) // 計算跨區間\n    → Step 7: 合併 arr[left:mid+1] 與 arr[mid+1:right+1] 為已排序陣列 // merge step\n    → Return count // 回傳總計\n→ Function countWhileMerge(arr, left, mid, right, lower, upper): // 計算跨區間的有效範圍\n    → Step 8: 初始化 count = 0 // 計數器\n    → For i from left to mid:\n        → Step 9: lo = mid + 1; hi = mid + 1 // 指標初始\n        → While lo <= right and arr[lo] - arr[i] < lower: lo++ // 尋找低閾\n        → While hi <= right and arr[hi] - arr[i] <= upper: hi++ // 尋找高閾\n        → count += hi - lo // 加入符合的 j 個數\n    → Return count // 回傳跨區間計數\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        # Build prefix sums\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        # Recursive merge sort that counts valid ranges\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            # Count cross ranges\n            i = j = mid\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            # Merge the two sorted halves\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串解析為 nums、lower、upper 三個參數。\n    支援多種輸入格式，例如：\n        nums = [-2,5,-1], lower = -2, upper = 2\n        [-2,5,-1]\n        -2\n        2\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], 0, 0\n\n    # 若輸入分為多行\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 3:\n        nums = ast.literal_eval(lines[0])\n        lower = int(lines[1])\n        upper = int(lines[2])\n        return nums, lower, upper\n\n    # 單行輸入，使用正則表達式提取\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    lower_match = re.search(r'lower\\s*=\\s*(-?\\d+)', data)\n    upper_match = re.search(r'upper\\s*=\\s*(-?\\d+)', data)\n\n    if nums_match and lower_match and upper_match:\n        nums = ast.literal_eval(nums_match.group(1))\n        lower = int(lower_match.group(1))\n        upper = int(upper_match.group(1))\n        return nums, lower, upper\n\n    # 如果找不到關鍵字，嘗試直接評估整個輸入\n    parts = data.split(',')\n    try:\n        nums = ast.literal_eval(parts[0])\n        lower = int(parts[1])\n        upper = int(parts[2])\n        return nums, lower, upper\n    except Exception:\n        # 最後的兜底：嘗試將整個輸入視為單行數值序列\n        tokens = re.findall(r'-?\\d+', data)\n        if len(tokens) >= 3:\n            nums = [int(tokens[i]) for i in range(len(tokens)-2)]\n            lower = int(tokens[-2])\n            upper = int(tokens[-1])\n            return nums, lower, upper\n\n    # 無法解析時回傳空值\n    return [], 0, 0\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums, lower, upper = parse_input(input_data)\n    solution = Solution()\n    result = solution.countRangeSum(nums, lower, upper)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0], lower = 0, upper = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode228.json",
    "problem_index_in_file": 0,
    "title": "Summary Ranges",
    "description_snippet": "You are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem. The user wants a virtual code that produces the smallest sorted list of ranges that cover all numbers in array exactly. This is typical \"summary ranges\" problem. We'll produce algorithm: iterate over array, track start of current range. When current number not consecutive, output range string of start to prev. Finally output last range.\n\nWe need to output virtual code line by line with explanation comment. Use Start, Decision, End, etc. Provide steps: Start, Input array, Set result list, If array empty return empty list, Initialize start = nums[0], prev = nums[0]. Loop i from 1 to len-1. In loop, decision: if nums[i] == prev + 1 then consecutive: set prev=nums[i]. else not consecutive: produce range string of start to prev, add to result, set start=nums[i], prev=nums[i]. After loop, produce last range for start to prev. Return result. End.\n\nWe need to follow arrow formatting: '→' before each step. Use decision lines.\n\nWe should be careful to mention variable names. Use \"nums\" input, \"result\" array. Provide arrow for each line.\n\nLet's craft the output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums // 取得已排序且不重複的整數陣列  \n→ Decision: 如果 nums 為空? // 檢查輸入是否為空陣列  \n  Yes → Step 1: 回傳 [] // 空陣列直接回傳空結果  \n  No → Step 2: result ← [] // 建立結果清單  \n    start ← nums[0] // 設定目前區間起點  \n    prev ← nums[0] // 記錄上一個處理的數字  \n→ Decision: 迴圈 i 從 1 到 len(nums)-1? // 若有多個元素進行迭代  \n  Yes → Loop: i ← i+1 // 逐個檢查後續數字  \n    Decision: nums[i] == prev + 1? // 判斷是否連續  \n      Yes → Step 3: prev ← nums[i] // 連續，更新 prev  \n      No → Step 4: result.add(FormatRange(start, prev)) // 非連續，輸出區間  \n         start ← nums[i] // 新區間起點  \n         prev ← nums[i] // 更新 prev 為新數字  \n         Loop 結束 // 回到迴圈判斷  \n  No → Step 5: result.add(FormatRange(start, prev)) // 迴圈結束後輸出最後區間  \n→ Step 6: 回傳 result // 結束程式，輸出區間清單  \nEnd // 程式執行結束  \n\n// FormatRange(start, end) 函式說明  \n→ Decision: start == end? // 判斷區間長度  \n  Yes → Return str(start) // 單一數字，只輸出數字  \n  No → Return str(start) + \"->\" + str(end) // 區間，輸出 a->b",
      "generated_code": "import sys\n\nclass Solution:\n    def summaryRanges(self, nums):\n        if not nums:\n            return []\n        res = []\n        start = end = nums[0]\n        for n in nums[1:]:\n            if n == end + 1:\n                end = n\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(f\"{start}->{end}\")\n                start = end = n\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(f\"{start}->{end}\")\n        return res\n\ndef parse_input(input_str):\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    if '=' in input_str:\n        _, expr = input_str.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = input_str\n    try:\n        nums = eval(expr, {}, {})\n    except Exception:\n        nums = []\n    if isinstance(nums, list):\n        return nums\n    return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = Solution().summaryRanges(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,2,4,5,7]",
          "expected_output": "[\"0->2\",\"4->5\",\"7\"]",
          "success": true,
          "output": "['0->2', '4->5', '7']"
        },
        {
          "example_index": 1,
          "input": "nums = [0,2,3,4,6,8,9]",
          "expected_output": "[\"0\",\"2->4\",\"6\",\"8->9\"]",
          "success": true,
          "output": "['0', '2->4', '6', '8->9']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode731.json",
    "problem_index_in_file": 0,
    "title": "My Calendar II",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code step by step, with explanation after each line, following the specified format: start, arrow, decision, etc. The pseudo code should explain algorithm for MyCalendarTwo.\n\nWe should include steps like maintain two lists: single bookings and double bookings. When book new event, check overlapping with double bookings. If overlap, reject. Else, for each overlap with single bookings, add overlapped segment to double bookings. Add the event to single bookings. Return true.\n\nWe should produce step-by-step pseudo code lines.\n\nLet's outline:\n\nStart\n\n→ Step 1: Initialize singleBookings list // store intervals\n→ Step 2: Initialize doubleBookings list // store intervals where two events overlap\n\nbook(start, end):\n\n→ Step 3: For each interval (s, e) in doubleBookings\n        If intervals overlap with [start, end) => return false\n\n→ Step 4: For each interval (s, e) in singleBookings\n        If overlap, compute overlapStart = max(s, start), overlapEnd = min(e, end)\n        Add [overlapStart, overlapEnd) to doubleBookings\n\n→ Step 5: Add [start, end) to singleBookings\n→ Step 6: Return true\n\nEdge cases: ensure inclusive-exclusive semantics. Use helper function overlaps. Provide pseudo code for overlap detection.\n\nLet's produce the output accordingly. Use \"Start\" and \"End\" for class initialization? Actually we can produce pseudo code for constructor and book method.\n\nWe need to produce virtual code line by line. The start of the whole algorithm? We can start with \"Start // MyCalendarTwo initialization\" etc.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize singleBookings as empty list // 存放所有已預約事件\n\n→ Step 2: Initialize doubleBookings as empty list // 存放所有雙重重疊區間\n\n→ Decision: 是否呼叫 book()？ // 判斷是否進入預約流程\n\nBut we need to produce algorithm steps for book function. Maybe we can outline the method as a block: \"Method book(start, end):\"\n\nUse arrows inside.\n\nSimplify: produce pseudo code block for book method after initialization lines.\n\nLet's structure:\n\nStart\n\n→ Step 1: singleBookings ← []\n\n→ Step 2: doubleBookings ← []\n\n→ Method book(start, end)\n\n    → Step 3: For each (s, e) in doubleBookings\n        → Decision: 是否與 [start, end) 有重疊?\n            Yes → Return false // 會形成三重預約\n            No  → continue\n\n    → Step 4: For each (s, e) in singleBookings\n        → Decision: 是否與 [start, end) 有重疊?\n            Yes → overlapStart ← max(s, start)\n                 overlapEnd   ← min(e, end)\n                 Add [overlapStart, overlapEnd) to doubleBookings\n            No  → continue\n\n    → Step 5: Add [start, end) to singleBookings\n\n    → Step 6: Return true\n\nEnd\n\nWe should include explanation after each line.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: singleBookings ← [] // 存放所有已預約事件的區間\n\n→ Step 2: doubleBookings ← [] // 存放所有兩個事件重疊的區間\n\n→ Method book(start, end) // 定義預約方法\n\n    → Step 3: For each (s, e) in doubleBookings\n        → Decision: 是否與 [start, end) 有重疊? // 檢查是否會形成三重預約\n            Yes → Return false // 會有三重重疊，拒絕此預約\n            No  → continue // 不影響三重預約，檢查下一個區間\n\n    → Step 4: For each (s, e) in singleBookings\n        → Decision: 是否與 [start, end) 有重疊? // 確定哪些已預約事件與新事件有重疊\n            Yes → overlapStart ← max(s, start) // 計算重疊區間的開始時間\n                 overlapEnd   ← min(e, end)   // 計算重疊區間的結束時間\n                 Add [overlapStart, overlapEnd) to doubleBookings // 將重疊區間加入雙重重疊集合\n            No  → continue // 無重疊，檢查下一個已預約事件\n\n    → Step 5: Add [start, end) to singleBookings // 將新事件加入已預約事件集合\n\n    → Step 6: Return true // 預約成功，且不會產生三重預約\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyCalendarTwo:\n    def __init__(self):\n        self.booked = []      # 存放所有已預約的區間\n        self.overlaps = []    # 存放所有兩個事件重疊的區間\n\n    def book(self, start: int, end: int) -> bool:\n        # 若新區間與已存在的雙重重疊區間相交，則會形成三重預約，拒絕\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n        # 對於所有已預約區間，若與新區間相交，將交集加入雙重重疊區間\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n        # 將新區間加入已預約區間\n        self.booked.append((start, end))\n        return True\n\ndef main():\n    # 讀取整個標準輸入並轉成兩個列表\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將輸入包裝成 JSON 陣列形式，方便解析\n    data = json.loads('[' + raw + ']')\n    ops, args = data[0], data[1]\n\n    results = []\n    calendar = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendarTwo\":\n            calendar = MyCalendarTwo()\n            results.append(None)          # 物件建構不回傳值\n        elif op == \"book\":\n            start, end = arg\n            res = calendar.book(start, end)\n            results.append(res)\n\n    # 將結果轉成題目要求的輸出格式\n    out_parts = []\n    for r in results:\n        if r is None:\n            out_parts.append('null')\n        else:\n            out_parts.append('true' if r else 'false')\n    print('[' + ', '.join(out_parts) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "success": true,
          "output": "[null, true, true, true, false, true, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode560.json",
    "problem_index_in_file": 0,
    "title": "Subarray Sum Equals K",
    "description_snippet": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing total number of subarrays with sum k. Use prefix sum + hashmap technique.\n\nSo steps:\n\nStart\n→ Initialize count = 0 // total subarray count\n→ Initialize prefixSum = 0\n→ Initialize hashmap (sum->count) with 0 -> 1 // prefix sum 0 occurs once\n→ For each num in nums:\n    → prefixSum += num // current cumulative sum\n    → If (prefixSum - k) exists in hashmap:\n          count += hashmap[prefixSum - k] // add number of previous prefix sums that make subarray sum k\n    → Increment hashmap[prefixSum] by 1 // record current prefix sum\n→ Return count\nEnd\n\nWe need each line with // explanation. Also use virtual arrows. Let's format: Start, then arrow lines. Use indentation for decision? There's no decision except if exist; but we can show Decision: if exists? Yes→... No→...\n\nBut simpler to just include Decision.\n\nLet's produce.\n\nRemember to not output actual code, just virtual steps.\n\nAlso mention array iteration.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化計數器 count 為 0 // 用於累積符合條件的子陣列個數  \n→ Step 2: 初始化前綴和 prefixSum 為 0 // 追蹤至目前為止的累加和  \n→ Step 3: 初始化哈希表 prefixCount，將 0 映射到 1 // 前綴和為 0 的情況（空子陣列前）  \n→ Decision: 遍歷 nums 中每個元素? // 逐一處理陣列元素  \n  Yes → Step 4: 將當前元素加到 prefixSum // 更新前綴和  \n   → Decision: (prefixSum - k) 是否存在於 prefixCount? // 檢查是否能形成和為 k 的子陣列  \n    Yes → Step 5: count += prefixCount[prefixSum - k] // 有對應前綴和，累加對應次數  \n    No  → // 不需要額外操作  \n   → Step 6: 在 prefixCount 中將 prefixSum 的計數加 1 // 記錄新的前綴和  \n→ Step 7: 返回 count // 回傳符合條件的子陣列總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    \"\"\"\n    求給定陣列 nums 中所有子陣列（連續子序列）之和等於 k 的數量。\n    \"\"\"\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        count = 0              # 符合條件的子陣列數量\n        prefix_sum = 0         # 當前前綴和\n        sum_map = {0: 1}       # 前綴和 0 出現一次（方便處理從頭開始的子陣列）\n\n        for num in nums:\n            prefix_sum += num\n            # 如果存在前綴和為 (prefix_sum - k)，則能形成和為 k 的子陣列\n            if prefix_sum - k in sum_map:\n                count += sum_map[prefix_sum - k]\n            # 記錄目前的前綴和\n            sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n        return count\n\ndef parse_input(data: str) -> (List[int], int):\n    \"\"\"\n    從輸入字串中解析出數字陣列 nums 與目標值 k。\n    支援格式如 \"[1,2,3], k = 3\" 或者 \"[1, 2, 3], k=3\"。\n    \"\"\"\n    # 取得中括號內的數字\n    nums = []\n    nums_match = re.search(r'\\[(.*?)\\]', data)\n    if nums_match:\n        nums_str = nums_match.group(1)\n        nums = list(map(int, re.findall(r'-?\\d+', nums_str)))\n\n    # 取得 k 的值\n    k = 0\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if k_match:\n        k = int(k_match.group(1))\n\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n\n    # 計算答案\n    result = Solution().subarraySum(nums, k)\n\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode600.json",
    "problem_index_in_file": 0,
    "title": "Non-negative Integers without Consecutive Ones",
    "description_snippet": "Given a positive integer n, return the number of the integers in the range [0, n] whose binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The task: given n, return count of numbers in [0, n] whose binary representation has no consecutive ones. Classic DP: count numbers <= n with no consecutive ones. Approach: compute fib DP for binary length. Then traverse bits of n from MSB downwards, keep track of previous bit and count.\n\nWe need to produce step-by-step pseudo code, not actual code. Provide explanation after each line. Use Start, Decision, etc.\n\nWe need to be careful to include decision for bit, previous bit, adding counts, etc. Probably steps:\n\nStart\n→ Step 1: Determine binary length of n // find number of bits\n→ Compute DP array f[i] = number of binary strings of length i without consecutive ones\n→ Step 2: Initialize count = 0, prev_bit = 0\n→ Step 3: For i from (len-1) downto 0:\n     Decision: If bit i of n == 1?\n         Yes → count += f[i] // add number of strings where current bit is 0 and remaining bits any valid\n           Decision: If prev_bit == 1?\n               Yes → Break // consecutive ones encountered, stop\n               No  → prev_bit = 1\n         No → prev_bit = 0\n→ Step 4: count += 1 // include n itself\n→ End\n\nAlso need to compute DP array: f[0] = 1, f[1] = 2; for i>=2: f[i] = f[i-1]+f[i-2].\n\nWe may add steps to compute f.\n\nLet's produce virtual code with arrows and explanation.\n\nBe careful about indentation.\n\nLet's output as per format. Each line: 虛擬碼步驟 + space + // 解釋.\n\nUse arrow for decisions: Decision: condition? and Yes/No arrow.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得 n 的二進位長度 len // 找出 n 所需的位數\n→ Step 2: 建立陣列 f[0…len]，計算長度不超過 i 的有效二進位字串數 // 用來快速查詢\n    → Step 2.1: f[0] ← 1 // 空字串算一種\n    → Step 2.2: f[1] ← 2 // 「0」與「1」\n    → Decision: 是否 i >= 2?\n        Yes → Step 2.3: f[i] ← f[i‑1] + f[i‑2] // 兩種情況相加\n        No  → End\n→ Step 3: 初始化 count ← 0, prev_bit ← 0 // 計數器與前一位記錄\n→ Step 4: 從最高位 i = len-1 逐位往下遍歷\n    → Decision: bit i of n 是否為 1?\n        Yes → \n            → Step 4.1: count ← count + f[i] // 把當前位為 0 時所有合法後續組合加入\n            → Decision: prev_bit 是否為 1?\n                Yes → Step 4.2: Break // 連續兩 1，已超出限制，停止\n                No  → Step 4.3: prev_bit ← 1 // 更新前一位為 1\n        No  → Step 4.4: prev_bit ← 0 // 當前位為 0，前一位重設\n→ Step 5: count ← count + 1 // 把 n 本身也算進去（已經檢查過不含連續 1）\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findIntegers(self, n: int) -> int:\n        # dp[i] 表示長度為 i 的二進制不含連續 1 的數量\n        dp = [0] * 32\n        dp[0] = 1\n        dp[1] = 2\n        for i in range(2, 32):\n            dp[i] = dp[i - 1] + dp[i - 2]\n\n        ans = 0\n        prev_bit = 0\n        # 逐位從最高位 (31) 到最低位\n        for i in reversed(range(31)):\n            if n & (1 << i):\n                ans += dp[i]          # 當前位為 0 時可有的合法後續組合\n                if prev_bit:          # 若前一位為 1，則出現連續 1，結束\n                    return ans\n                prev_bit = 1\n            else:\n                prev_bit = 0\n        return ans + 1  # 包含 n 本身\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中提取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    sol = Solution()\n    result = sol.findIntegers(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode282.json",
    "problem_index_in_file": 0,
    "title": "Expression Add Operators",
    "description_snippet": "Given a string num that contains only digits and an integer target, return all possibilities to inse...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for a solution to the problem. No actual code. Steps include Start, decisions, loops, recursion. Provide explanation after each line. Use arrow and indent. Format like example.\n\nWe need to cover: parse input, DFS/backtracking, handle leading zeros, operator precedence with multiplication. Probably use recursion with cumulative value and previous operand for '*' handling.\n\nWe need to produce all possibilities.\n\nWe can show algorithm in pseudocode: Start -> Step: parse string num, target -> Step: call DFS(position=0, path=\"\", evaluated=0, prev=0) -> Decision: if position==len(num) -> if evaluated==target -> add path to result. Return. Else loop end from pos+1 to len -> substring = num[pos:end] -> if substring has leading zeros and length>1 skip. numVal = int(substring). If pos==0: DFS(end, substring, numVal, numVal). Else: DFS(end, path+\"+\"+substring, evaluated+numVal, numVal). DFS(end, path+\"-\"+substring, evaluated-numVal, -numVal). DFS(end, path+\"*\"+substring, evaluated - prev + prev*numVal, prev*numVal). End. End. Output results.\n\nWe need to produce each line as \"虛擬碼步驟 // 解釋\". Use arrow and indent. Ensure Start and End. Provide Decision blocks with Yes/No.\n\nLet's craft.\n\nWe'll use indentation with tabs? We can indent using spaces as in example. Use arrow →, and Decision: with branches Yes →, No →.\n\nBe careful: \"虛擬碼步驟\" includes the arrow and statement. Then space then // explanation.\n\nWe will produce lines sequentially.\n\nLet's craft.\n\nLine1: Start // 程式開始執行\n\nLine2: → Step 1: 初始化 result 為空列表 // 用來儲存符合條件的表達式\n\nLine3: → Step 2: 定義遞迴函式 DFS(index, expr, evaluated, prev) // index: 當前處理的位置；expr: 當前構造的表達式；evaluated: 目前表達式的計算值；prev: 上一個操作數，用於乘法計算\n\nLine4: → Decision: 如果 index == len(num)? // 判斷是否已遍歷完整字串\n\nLine5:     Yes → Step 3: 如果 evaluated == target? // 檢查目前計算值是否符合目標\n\nLine6:         Yes → Step 4: 將 expr 加入 result // 符合條件，儲存表達式\n\nLine7:         No  → Step 5: 返回 // 不符合目標，結束此路徑\n\nLine8:     No  → Step 6: 循環 end 取值從 index+1 到 len(num) // 為下一個操作數選擇不同長度\n\nLine9:         → Step 7: 取 substring = num[index:end] // 可能的下一個操作數\n\nLine10:         → Decision: 如果 substring 有前導零且長度>1? // 防止帶前導零的數字\n\nLine11:             Yes → Step 8: 跳過此 substring // 跳過不合法的數字\n\nLine12:             No  → Step 9: 解析 numVal = int(substring) // 將子字串轉成數值\n\nLine13:             → Decision: 如果 index == 0? // 是否為第一個操作數\n\nLine14:                 Yes → Step 10: DFS(end, substring, numVal, numVal) // 第一個數字直接使用，prev=本數字\n\nLine15:                 No  → Step 11: DFS(end, expr + \"+\" + substring, evaluated + numVal, numVal) // 加法\n\nLine16:                 → Step 12: DFS(end, expr + \"-\" + substring, evaluated - numVal, -numVal) // 減法\n\nLine17:                 → Step 13: DFS(end, expr + \"*\" + substring, evaluated - prev + prev * numVal, prev * numVal) // 乘法，調整 evaluated 與 prev\n\nLine18: → Step 14: 呼叫 DFS(0, \"\", 0, 0) // 從頭開始深度優先搜索\n\nLine19: End // 程式執行結束\n\nCheck indentation: Use spaces to indent within decisions? Example uses indentation after Decision. We'll mimic.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空列表 // 用來儲存符合條件的表達式\n→ Step 2: 定義遞迴函式 DFS(index, expr, evaluated, prev) // index: 當前處理的位置；expr: 當前構造的表達式；evaluated: 目前表達式的計算值；prev: 上一個操作數，用於乘法計算\n→ Decision: 如果 index == len(num)? // 判斷是否已遍歷完整字串\n    Yes → Step 3: 如果 evaluated == target? // 檢查目前計算值是否符合目標\n        Yes → Step 4: 將 expr 加入 result // 符合條件，儲存表達式\n        No  → Step 5: 返回 // 不符合目標，結束此路徑\n    No  → Step 6: 循環 end 取值從 index+1 到 len(num) // 為下一個操作數選擇不同長度\n        → Step 7: 取 substring = num[index:end] // 可能的下一個操作數\n        → Decision: 如果 substring 有前導零且長度>1? // 防止帶前導零的數字\n            Yes → Step 8: 跳過此 substring // 跳過不合法的數字\n            No  → Step 9: 解析 numVal = int(substring) // 將子字串轉成數值\n            → Decision: 如果 index == 0? // 是否為第一個操作數\n                Yes → Step 10: DFS(end, substring, numVal, numVal) // 第一個數字直接使用，prev=本數字\n                No  → Step 11: DFS(end, expr + \"+\" + substring, evaluated + numVal, numVal) // 加法\n                → Step 12: DFS(end, expr + \"-\" + substring, evaluated - numVal, -numVal) // 減法\n                → Step 13: DFS(end, expr + \"*\" + substring, evaluated - prev + prev * numVal, prev * numVal) // 乘法，調整 evaluated 與 prev\n→ Step 14: 呼叫 DFS(0, \"\", 0, 0) // 從頭開始深度優先搜索\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                # 跳過帶有前導零的數字（除非數字本身為 0）\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    # 乘法需要調整已計算的值和上一個操作數\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 使用正則表達式提取 num 和 target\n    pattern = r'num\\s*=\\s*\"(\\d+)\"\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        # 如果輸入格式不正確，直接退出\n        sys.exit(0)\n\n    num_str = match.group(1)\n    target_val = int(match.group(2))\n\n    solution = Solution()\n    result = solution.addOperators(num_str, target_val)\n    # 使用 json.dumps 以符合題目示例的輸出格式\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1+2+3\",\"1*2*3\"]",
          "success": true,
          "output": "[\"1+2+3\", \"1*2*3\"]"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2+3*2\",\"2*3+2\"]",
          "success": true,
          "output": "[\"2+3*2\", \"2*3+2\"]"
        },
        {
          "example_index": 2,
          "input": "num = \"3456237490\", target = 9191",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode167.json",
    "problem_index_in_file": 0,
    "title": "Two Sum II - Input Array Is Sorted",
    "description_snippet": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the two sum problem using two pointers, constant space. Provide each line with \"虛擬碼步驟 // 解釋\". Start, End, Decision, arrows, etc. Use 1-indexed indices. Provide steps: initialize left=0, right=n-1, loop until left<right, sum=arr[left]+arr[right], compare with target, adjust pointers, when found return [left+1, right+1]. Ensure constant space. Provide virtual code line by line. Use arrow and decision. Also incorporate that input array sorted. Provide explanation for each step. Let's produce lines accordingly.\n\nNeed to follow format: `Start // 程式開始執行` etc.\n\nInclude arrows `→`. For loops maybe use Decision: 循環? We'll use Decision: 左指標 < 右指標? Yes → do... No → End.\n\nUse arrow inside loops.\n\nLet's craft:\n\nStart\n→ Initialize left = 0 // 左指標指向陣列起始位置\n→ Initialize right = numbers.length - 1 // 右指標指向陣列結尾位置\n→ Decision: left < right? // 檢查是否還有未比較的元素\n    Yes →\n        → Calculate sum = numbers[left] + numbers[right] // 兩指標指向的數字相加\n        → Decision: sum == target? // 是否達到目標值\n            Yes → Return [left+1, right+1] // 找到解，返回 1-indexed 位置\n            No →\n                → Decision: sum < target? // 需要更大的和\n                    Yes → left = left + 1 // 左指標右移\n                    No  → right = right - 1 // 右指標左移\n        → Decision: left < right? // 循環再次判斷\n            Yes → 回到 Calculate sum 步驟\n            No → End // 未找到（理論上不會發生）\nEnd // 程式結束\n\nBut we need arrow structure: maybe nested decisions. Let's keep simple.\n\nBut we must use \"Yes →\" and \"No →\". Also arrow lines within loops. Use \"→\" preceding each step. Use indentation.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0 // 初始化左指標為陣列最左端  \n→ Step 2: right = numbers.length - 1 // 初始化右指標為陣列最右端  \n\n→ Decision: left < right? // 檢查是否還有未比較的元素  \n    Yes →  \n        → Step 3: sum = numbers[left] + numbers[right] // 計算兩指標所指數字之和  \n        → Decision: sum == target? // 是否正好等於目標值  \n            Yes →  \n                → Step 4: Return [left + 1, right + 1] // 回傳 1-indexed 的索引對  \n                → End // 程式結束  \n            No →  \n                → Decision: sum < target? // 需要更大的和  \n                    Yes →  \n                        → Step 5: left = left + 1 // 左指標右移，嘗試更大的數字  \n                    No  →  \n                        → Step 6: right = right - 1 // 右指標左移，嘗試更小的數字  \n        → Decision: left < right? // 再次檢查是否仍有未比較的元素  \n            Yes → 回到 Step 3  \n            No  → End // 所有組合已檢查完（理論上不會發生）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        \"\"\"\n        使用雙指標法在已排序的陣列中找到兩個數字相加等於 target 的索引。\n        O(n) 時間、O(1) 空間。\n        \"\"\"\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            s = numbers[left] + numbers[right]\n            if s == target:\n                return [left + 1, right + 1]          # 1‑索引返回\n            elif s < target:\n                left += 1                              # 需要更大的和，左指標右移\n            else:\n                right -= 1                             # 需要更小的和，右指標左移\n        return None  # 理論上不會到這裡，因題目保證一定有解\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，範例格式：\n    'numbers = [2,7,11,15], target = 9'\n    \"\"\"\n    pattern = r'numbers\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"輸入格式錯誤\")\n    numbers = ast.literal_eval(match.group(1))\n    target = int(match.group(2))\n    return numbers, target\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    numbers, target = parse_input(raw)\n    sol = Solution()\n    ans = sol.twoSum(numbers, target)\n    # 按題目要求輸出格式不含空格\n    print(f'[{ans[0]},{ans[1]}]')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1,2]"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "success": true,
          "output": "[1,3]"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1,2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode682.json",
    "problem_index_in_file": 0,
    "title": "Baseball Game",
    "description_snippet": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, for solving this problem. The virtual code must be in the style described: start, step, decision arrows, etc. Each line: \"虛擬碼步驟 // 解釋/說明\". Provide lines for algorithm: initialize record (stack). Iterate operations. For each op: if number -> push int. If '+': sum of last two; push. If 'D': double last; push. If 'C': pop last. After loop sum stack. Return sum.\n\nWe must produce lines with arrows. Provide decisions where needed. Possibly loop: Decision: Is op numeric? Or use if-else. Provide decisions for each type.\n\nLet's produce:\n\nStart // 開始\n→ Initialize record as empty list // 建立記錄\n\n→ For each op in operations // 逐一處理每個操作\n\n  → Decision: 如果 op 是數字? // 檢查是否為數字\n\n    Yes → Step: 解析 op 為整數並 push 到 record // 存入新分數\n\n    No → Decision: op == '+'? // 加總上兩分\n\n        Yes → Step: 計算 record[-1] + record[-2] 並 push // 新分數為前兩分之和\n\n        No → Decision: op == 'D'? // 加倍上一分\n\n            Yes → Step: 取 record[-1] * 2 並 push // 新分數為上一分加倍\n\n            No → Decision: op == 'C'? // 失效上一分\n\n                Yes → Step: pop record[-1] // 移除上一分\n\n                No → Step: 錯誤處理 // 這裡不會發生\n\n  End For // 迴圈結束\n\n→ Step: sum = Σ record // 計算總分\n\n→ Return sum // 回傳總分\n\nEnd // 結束\n\nWe must ensure each line contains \"→\" and possibly nested decisions. Use indentation? The format shows using indent. Provide each line with arrow maybe. Example: \"→ Decision: ...\". Should we use arrow for nested lines? The example uses \"→ Decision:\" then indentation inside. We'll replicate.\n\nAlso need to use \"Yes →\" and \"No →\" arrow lines.\n\nAlso include \"End\" for loop? In example they didn't show explicit End for loop; but we can include \"End For\". But not necessary. But to maintain style maybe.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ record ← [] // 建立一個空的分數記錄\n→ For op in operations // 逐一處理每個操作\n  → Decision: op 是整數? // 判斷目前操作是否為數字\n    Yes → value ← Integer(op) // 解析文字為整數\n    → record.push(value) // 把新分數加入記錄\n    No → Decision: op == '+'? // 判斷是否為加總前兩分\n      Yes → sum ← record[-1] + record[-2] // 計算前兩分之和\n      → record.push(sum) // 加入新分數\n      No → Decision: op == 'D'? // 判斷是否為加倍上一分\n        Yes → double ← record[-1] * 2 // 計算上一分的兩倍\n        → record.push(double) // 加入新分數\n        No → Decision: op == 'C'? // 判斷是否為失效上一分\n          Yes → record.pop() // 移除最近一次的分數\n          No → // 這裡不會發生其他情況\n  End For // 迴圈結束\n→ total ← 0 // 初始化總分\n→ For score in record // 計算所有分數的總和\n  → total ← total + score // 累加每個分數\n  End For // 迴圈結束\n→ Return total // 回傳最終總分\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef calPoints(ops):\n    \"\"\"計算所有分數後的總和。\"\"\"\n    stack = []\n    for op in ops:\n        if op == \"C\":\n            stack.pop()\n        elif op == \"D\":\n            stack.append(2 * stack[-1])\n        elif op == \"+\":\n            stack.append(stack[-1] + stack[-2])\n        else:\n            stack.append(int(op))\n    return sum(stack)\n\ndef main():\n    \"\"\"從 stdin 讀取輸入，解析 ops 列表，輸出總分。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得等號右側的列表文字\n    if \"=\" in data:\n        ops_part = data.split(\"=\", 1)[1].strip()\n    else:\n        ops_part = data\n\n    try:\n        ops = ast.literal_eval(ops_part)\n    except Exception:\n        # 如果字面量解析失敗，嘗試以正則表達式抽取字符串\n        import re\n        ops = re.findall(r'\"([^\"]*)\"', ops_part)\n\n    result = calPoints(ops)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]",
          "expected_output": "30",
          "success": true,
          "output": "30"
        },
        {
          "example_index": 1,
          "input": "ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
          "expected_output": "27",
          "success": true,
          "output": "27"
        },
        {
          "example_index": 2,
          "input": "ops = [\"1\",\"C\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode981.json",
    "problem_index_in_file": 0,
    "title": "Time Based Key-Value Store",
    "description_snippet": "Design a time-based key-value data structure that can store multiple values for the same key at diff...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for TimeMap implementation. Provide step-by-step algorithm: maintain map from key to list of (timestamp, value) sorted by timestamp. set: append. get: binary search. So produce virtual code lines. Use Start, End, Decision. Provide each line with explanation. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告 TimeMap 類別，內部包含 hash map：key → list of (timestamp, value) // 用於儲存所有鍵值對，且每個鍵對應多個時間戳  \n→ Step 2: TimeMap() 初始化：將 hash map 設為空 // 建構子，準備接受 set 操作  \n→ Step 3: set(key, value, timestamp) // 新增鍵值對  \n    → Decision: hash map 是否已存在 key? // 檢查鍵是否已在結構中  \n        Yes → Step 4: 取得 key 對應的 list，將 (timestamp, value) 附加至列表尾部 // 直接追加，因時間戳遞增，保持列表有序  \n        No  → Step 5: 建立新 list，將 (timestamp, value) 放入，並將 list 存入 hash map，鍵為 key // 先前未出現的鍵，初始化列表  \n→ Step 6: get(key, timestamp) // 取得某時間點的值  \n    → Decision: hash map 是否含 key? // 若鍵不存在，直接回傳空字串  \n        No  → Step 7: 回傳 \"\" // 沒有任何記錄  \n        Yes → Step 8: 取得 key 對應的 list // 進行搜尋  \n            → Decision: list 是否為空? // 處理列表為空的特殊情況  \n                Yes → Step 9: 回傳 \"\" // 沒有任何 timestamp，回傳空字串  \n                No  → Step 10: 使用二分搜尋，找出最大的 timestamp_prev ≤ timestamp // 找到最接近且不超過的時間戳  \n                    → Decision: 是否找到符合條件的索引? // 若所有 timestamp 都大於輸入 timestamp  \n                        No  → Step 11: 回傳 \"\" // 沒有可用的值  \n                        Yes → Step 12: 回傳 list[index].value // 返回對應的值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nimport bisect\nfrom collections import defaultdict\n\n# 時間鍵值資料結構\nclass TimeMap:\n    def __init__(self):\n        # 每個 key 對應一個遞增排序的 (timestamp, value) 清單\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # 直接把 (timestamp, value) 附加到清單末端，因為 timestamp 會遞增\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        # 若 key 不存在，直接回傳空字串\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 取得第一個 > timestamp 的位置\n        # 用 (timestamp, chr(127)) 以確保時間戳相等時也能比上\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            # 所有時間戳都大於傳入的 timestamp，沒有符合條件\n            return \"\"\n        # 回傳最大的 timestamp_prev <= timestamp 的值\n        return arr[i - 1][1]\n\n# ---------- 主程式 ----------\ndef main() -> None:\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 輸入格式為兩個 list 以逗號分隔，例如:\n    # [\"TimeMap\",\"set\",\"get\"],[[],[\"a\",\"x\",1],[\"a\",1]]\n    # 我們將整個字串包裝成一個 tuple，方便 literal_eval 解析\n    try:\n        data = ast.literal_eval('(' + raw + ')')\n    except Exception:\n        # 若解析失敗，直接終止\n        return\n    ops, args_list = data\n\n    result = []\n    tm = None  # TimeMap 實例\n\n    for op, args in zip(ops, args_list):\n        if op == \"TimeMap\":\n            tm = TimeMap()\n            result.append(None)        # constructor 返回 null\n        elif op == \"set\":\n            tm.set(*args)\n            result.append(None)        # set 返回 null\n        elif op == \"get\":\n            val = tm.get(*args)\n            result.append(val)         # get 的結果\n        else:\n            # 其他操作（若有）可在此處擴充\n            result.append(None)\n\n    # 用 json.dumps 產生符合題目期望的輸出格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "success": true,
          "output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode31.json",
    "problem_index_in_file": 0,
    "title": "Next Permutation",
    "description_snippet": "A permutation of an array of integers is an arrangement of its members into a sequence or linear ord...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanations, line by line, following format. The algorithm: find next permutation in place.\n\nSteps: Start, find pivot i from end-1 while nums[i] >= nums[i+1], if no pivot, reverse entire array and return. Else find j from end while nums[j] <= nums[i], then swap nums[i], nums[j]. Then reverse subarray from i+1 to end. End.\n\nWe need to produce each line with \"虛擬碼步驟 // 解釋\". Use arrows. Should be clear.\n\nLet's produce lines:\n\nStart\n→ Step 1: 找出 pivot i 為最後一個 nums[i] < nums[i+1] 的索引 // 從右向左尋找第一個遞升位置\n→ Decision: 如果沒有找到 pivot? // 判斷是否已是最高排列\n    Yes → Step 2: 反轉整個陣列 // 使為最低排列\n    No  → Step 3: 找出 j 為最後一個 nums[j] > nums[i] 的索引 // 從右向左尋找第一個大於 pivot 的數字\n        → Step 4: 交換 nums[i] 與 nums[j] // 交換以生成更大的排列\n        → Step 5: 反轉子陣列 nums[i+1 … end] // 重新排序後半段為最小順序\nEnd\n\nBut each line must be exactly like \"Start // 程式開始執行\". For decisions, indent? In example they had indentation. We'll just use spaces for indent lines.\n\nWe need each line's code then comment. Use \"→\" arrow for steps.\n\nAlso \"Decision:\" line: \"Decision: 如果沒有找到 pivot?\" maybe better \"Decision: 是否沒有 pivot?\" But example: \"Decision: 如果數字大於 0?\" etc. Use same format.\n\nIn decision, \"Yes →\" and \"No →\".\n\nWe need constant memory.\n\nWe'll produce 7 lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 找出 pivot i 為最後一個 nums[i] < nums[i+1] 的索引 // 從右向左尋找第一個遞升位置  \n→ Decision: 是否沒有 pivot? // 判斷是否已是最高排列  \n  Yes → Step 2: 反轉整個陣列 // 使為最低排列，完成 next permutation  \n  No  → Step 3: 找出 j 為最後一個 nums[j] > nums[i] 的索引 // 從右向左尋找第一個大於 pivot 的數字  \n    → Step 4: 交換 nums[i] 與 nums[j] // 交換以生成更大的排列  \n    → Step 5: 反轉子陣列 nums[i+1 … end] // 重新排序後半段為最小順序，得到下個排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextPermutation(self, nums):\n        \"\"\"\n        Rearranges nums into the next lexicographically greater permutation.\n        If such arrangement is not possible, it rearranges nums into the lowest possible order.\n        The operation is performed in-place using only constant extra memory.\n        \"\"\"\n        n = len(nums)\n        i = n - 2\n\n        # 找出最後一個 nums[i] < nums[i+1] 的索引\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n\n        if i >= 0:\n            # 找出最後一個 nums[j] > nums[i] 的索引\n            j = n - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            # 交換 nums[i] 與 nums[j]\n            nums[i], nums[j] = nums[j], nums[i]\n\n        # 反轉子陣列 nums[i+1 … end] 以得到最小順序\n        left, right = i + 1, n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入格式，例如 'nums = [1,2,3]'\n    try:\n        _, list_part = data.split('=', 1)\n        nums = ast.literal_eval(list_part.strip())\n    except Exception:\n        # 如果輸入格式不符合，直接結束\n        sys.exit(0)\n\n    sol = Solution()\n    sol.nextPermutation(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1]",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,5]",
          "expected_output": "[1,5,1]",
          "success": true,
          "output": "[1, 5, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode678.json",
    "problem_index_in_file": 0,
    "title": "Valid Parenthesis String",
    "description_snippet": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is va...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for validating a string with '*' flexible. Classic solution uses two stacks or counters: track min and max possible open parentheses. We'll produce step-by-step pseudocode.\n\nWe'll output each line with arrow and explanation. Use Start, End, Decision. We'll include steps:\n\nStart\n→ Step 1: Initialize minOpen = 0, maxOpen = 0 // track range\n→ Step 2: For each character c in s // iterate\n    → Decision: If c == '('\n        Yes → Step 3: minOpen += 1; maxOpen += 1 // '(' increases both\n        No → Decision: If c == ')'\n            Yes → Step 4: minOpen -= 1; maxOpen -= 1 // ')' decreases both\n            No → Decision: If c == '*'\n                Yes → Step 5: minOpen -= 1; // treat as ')'\n                No  → Step 6: minOpen unchanged; // treat as empty\n                // For maxOpen: treat as '(' so maxOpen += 1\n                Step 5: maxOpen += 1 // '*' can be '(' for max\n            End Decision\n        End Decision\n    // After each char, clamp minOpen to at least 0\n    → Step 7: If minOpen < 0 then minOpen = 0 // cannot be negative\n    → Decision: If maxOpen < 0\n        Yes → Step 8: Return False // too many ')' early\n        No → Continue loop\n→ Step 9: After loop, if minOpen == 0 then Return True else Return False\nEnd\n\nNeed to fit format: each line starts with \"→\" except Start and End.\n\nWe need to indent decisions properly with Yes → and No →. For nested decisions, we need proper indentation. Use arrow lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 minOpen = 0, maxOpen = 0 // 追蹤可能的最小/最大左括號數  \n→ Step 2: 對於每個字符 c 在 s 中循環 // 遍歷整個字串  \n    → Decision: 如果 c == '('? // 左括號  \n        Yes → Step 3: minOpen += 1; maxOpen += 1 // 左括號同時增加最小與最大可開括號數  \n        No  → Decision: 如果 c == ')'? // 右括號  \n            Yes → Step 4: minOpen -= 1; maxOpen -= 1 // 右括號同時減少最小與最大可開括號數  \n            No  → Decision: 如果 c == '*'? // 星號  \n                Yes → Step 5: minOpen -= 1; // 以 ')' 處理時減少最小可開括號數  \n                No  → Step 6: /* star 為空，minOpen 不變 */  \n                Step 5: maxOpen += 1 // 以 '(' 處理時增加最大可開括號數  \n            End Decision  \n        End Decision  \n    // 循環每一步後，確保最小可開括號數不為負  \n    → Step 7: 如果 minOpen < 0 則 minOpen = 0 // 把負值修正為 0，因為不可能有負數個未配對左括號  \n    → Decision: 如果 maxOpen < 0? // 若最大可開括號數為負，表示已超過右括號數  \n        Yes → Step 8: 返回 False // 字串不合法，立即結束  \n        No  →  /* 繼續循環 */  \n→ Step 9: 循環結束後，如果 minOpen == 0 則 返回 True 否則 返回 False // 最後檢查所有左括號是否配對完畢  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def checkValidString(self, s: str) -> bool:\n        low, high = 0, 0  # track min/max possible unmatched '('\n        for c in s:\n            if c == '(':\n                low += 1\n                high += 1\n            elif c == ')':\n                if low > 0:\n                    low -= 1\n                high -= 1\n            else:  # '*'\n                if low > 0:\n                    low -= 1\n                high += 1\n            if high < 0:          # too many ')' encountered\n                return False\n        return low == 0           # all '(' must be matched\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 尝试从类似 \"s = \\\"(*)\\\"\" 的格式中提取字符串\n    match = re.search(r'[\"\\'](.*)[\"\\']', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若直接给出字符串（无引号或等号），直接使用整行内容\n        s = data\n\n    sol = Solution()\n    result = sol.checkValidString(s)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"(*)\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(*))\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode70.json",
    "problem_index_in_file": 0,
    "title": "Climbing Stairs",
    "description_snippet": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the classic climbing stairs problem. Provide algorithm, likely dynamic programming iterative. Steps: Start, initialize base cases, loop i=2 to n, compute dp[i] = dp[i-1] + dp[i-2], then output dp[n], End. Provide explanation each line.\n\nWe need to output lines with arrow \"→\". Format:\n\nStart // 程式開始執行\n→ Step 1: Input n // 取得階梯總數\n→ Step 2: If n <= 1 then Output 1 // base case, 1 way\n→ Step 3: Initialize dp[0] = 1, dp[1] = 1 // base dp values\n→ Step 4: For i from 2 to n // iterate remaining steps\n    → Step 4.1: dp[i] = dp[i-1] + dp[i-2] // sum ways\n→ Step 5: Output dp[n] // result\nEnd // 程式結束\n\nNeed to ensure each line has \"→\" arrow and explanation. Use \"Decision:\" for if conditions. Provide arrow for loop? The example used indentation for nested steps. We'll mimic.\n\nUse \"Decision:\" lines: Decision: If n <= 1? Yes → Output 1 No → Step 3 etc. But might be easier to keep simple.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 輸入 n // 取得階梯總數\n→ Decision: n <= 1? // 檢查基礎情況\n    Yes → Step 2: 輸出 1 // 只有一種走法\n    No  → Step 3: 初始化 dp[0] = 1, dp[1] = 1 // 兩個基礎走法\n→ Step 4: 從 i = 2 到 n 迭代 // 計算所有走法\n    → Step 4.1: dp[i] = dp[i-1] + dp[i-2] // 前一步或前兩步的總和\n→ Step 5: 輸出 dp[n] // 顯示總走法數\nEnd // 程式結束\n\nNeed to ensure each line has \"虛擬碼步驟 [space] // 解釋\". Use \"→\" arrow. For nested lines, indent with space or tab? The example used indentation after Decision. We can mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 取得階梯總數  \n→ Decision: n <= 1? // 檢查基礎情況  \n Yes → Step 2: 輸出 1 // 只有一種走法  \n No  → Step 3: 初始化 dp[0] = 1, dp[1] = 1 // 兩個基礎走法  \n→ Step 4: 從 i = 2 到 n 迭代 // 計算所有走法  \n → Step 4.1: dp[i] = dp[i-1] + dp[i-2] // 前一步或前兩步的總和  \n→ Step 5: 輸出 dp[n] // 顯示總走法數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        \"\"\"Return the number of distinct ways to climb to the top of n steps.\"\"\"\n        if n <= 2:\n            return n\n        first, second = 1, 2\n        for _ in range(3, n + 1):\n            first, second = second, first + second\n        return second\n\nif __name__ == \"__main__\":\n    # Read the entire input and extract the first integer found.\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    # Compute and print the result.\n    solution = Solution()\n    print(solution.climbStairs(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode372.json",
    "problem_index_in_file": 0,
    "title": "Super Pow",
    "description_snippet": "Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large pos...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing a^b mod 1337 where a positive integer, b large positive integer given as array of digits? Usually b is an array of digits of a large number. Need to compute a^b mod 1337. Use fast exponentiation with exponent reduction using Euler's theorem: phi(1337)=1337*(1-1/7)*(1-1/191)=1337*(6/7)*(190/191)=1337*(6*190)/(7*191)=1337*1140/1337=1140? Wait 1337=7*191, so phi=1337*(1-1/7)*(1-1/191)=1337*6/7*190/191=1337*(1140)/(1337)=1140. So a^b mod 1337, we can reduce exponent mod 1140 when a and 1337 coprime, else if not coprime use other method. Use repeated exponentiation: compute exponent_mod = b mod 1140, but if b >= 1140 and a not coprime need add 1140 to exponent_mod? Standard approach: compute exponent_mod = b mod 1140, but if exponent_mod == 0, set exponent_mod = 1140. Then result = pow_mod(a, exponent_mod, 1337). But also handle if a is divisible by 7 or 191. If a shares factor, we need to compute directly maybe using exponentiation with large exponent array: compute a^b mod 1337 via exponentiation by processing each digit: result=1; for each digit d in b: result = pow(result,10,1337)*pow(a,d,1337) mod 1337. Use fast pow for small exponents. That works for all. So algorithm:\n\nStart\n→ Step: read a, read array b\n→ Decision: b length 0? Not relevant\n→ Step: initialize result=1\n→ Step: For each digit d in b: \n   → Step: result = (pow_mod(result,10,1337) * pow_mod(a,d,1337)) mod 1337\n→ End, output result\n\nProvide virtual code with decisions etc. Provide comments in Chinese. Ensure each line with arrow and comment. Use \"→\" arrow for steps, \"Decision:\" lines, and \"End\". Use \"Yes\" \"No\" not needed maybe. We'll include decisions only if needed. Use \"Decision: If b is empty? \" maybe skip. Let's produce simple pseudocode.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 讀取正整數 a, 讀取數位陣列 b // 取得基底與指數的數字表示  \n→ Step: 設定 result = 1 // 初始累積值  \n→ Decision: b 為空嗎? // 檢查指數是否為 0（雖不常見但處理完整）  \n    Yes → Step: 輸出 result // 若 b 為空，a^0=1，直接輸出  \n    No  → Step: 進入迴圈處理每個數位  \n→ Step: 對於陣列 b 中的每個數位 d（從首位到末位）:  \n  → Step: result = (pow_mod(result, 10, 1337) * pow_mod(a, d, 1337)) mod 1337  \n   // pow_mod(x, e, m) 為快速冪演算：x^e mod m，e 為小整數  \n→ Step: 輸出 result // 最終計算完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nMOD = 1337\n\ndef super_pow(a, b):\n    \"\"\"計算 a^b (b 為數位陣列) 取模 MOD。\"\"\"\n    result = 1\n    for digit in b:\n        result = pow(result, 10, MOD) * pow(a, digit, MOD) % MOD\n    return result\n\ndef main():\n    # 從標準輸入讀取所有內容，並抓取所有整數\n    content = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', content)))\n\n    if not numbers:\n        return  # 沒有輸入，直接結束\n\n    a = numbers[0]          # 第一個數字是基底 a\n    b = numbers[1:]         # 其餘為指數的數位陣列\n\n    result = super_pow(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 2, b = [3]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "success": true,
          "output": "1024"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode466.json",
    "problem_index_in_file": 0,
    "title": "Count The Repetitions",
    "description_snippet": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for this problem. This is the Leetcode problem 466? Actually it's 466 but with n1, n2 etc. Problem is: maximum m such that str2 repeated m times can be subsequence of str1 repeated n1 times. The known solution uses mapping to find how many s2's are formed in each block of s1's repeated, and detect cycles to accelerate.\n\nWe need to produce step-by-step pseudocode with explanations. Use Start, Decision etc.\n\nLet's craft algorithm:\n\n1. Initialize counters: index_s2 = 0 (position in s2), count_s2 = 0 (how many s2 complete), seen map (key = index_s2 -> [i, count_s2]) where i is current count of s1 repeats processed.\n\n2. For i in 1..n1:\n   - For each char c in s1:\n       - If c == s2[index_s2]:\n           index_s2 +=1\n           if index_s2 == len(s2):\n               count_s2 +=1\n               index_s2 =0\n   - After processing one s1, check if index_s2 seen before:\n        if seen contains index_s2:\n           prev_i, prev_count = seen[index_s2]\n           cycle_len = i - prev_i\n           cycle_count = count_s2 - prev_count\n           remaining = n1 - i\n           times = remaining // cycle_len\n           count_s2 += times * cycle_count\n           i += times * cycle_len\n   - store seen[index_s2] = [i, count_s2]\n\n3. After loop, result = count_s2 // n2.\n\nReturn result.\n\nWe'll output virtual code lines with explanations.\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n\nWe need to use arrow lines like \"→\" to indicate continuation. Use Start, End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Init: str1 ← [s1, n1] // 建立重複字串 str1 的參考  \n→ Init: str2 ← [s2, n2] // 建立重複字串 str2 的參考  \n→ Init: idx_s2 ← 0 // 目前在 s2 中的索引位置  \n→ Init: cnt_s2 ← 0 // 已完整得到的 s2 次數  \n→ Init: seen ← 空字典 // 追蹤 (idx_s2 → [已處理的 s1 次數, cnt_s2])  \n→ Loop i 1 到 n1 步驟 // 逐個處理 str1 的每一個 s1 重複  \n    → For each char ch in s1 // 遍歷 s1 的每個字元  \n        Decision: ch == s2[idx_s2]? // 檢查字元是否與 s2 的對應位置相符  \n            Yes → idx_s2 ← idx_s2 + 1 // 成功匹配，索引往後移  \n                Decision: idx_s2 == len(s2)? // 完成一個完整的 s2？  \n                    Yes → cnt_s2 ← cnt_s2 + 1 // 计数加一  \n                        idx_s2 ← 0 // 回到 s2 的起始位置  \n                    No → // 尚未完成一個 s2，繼續匹配  \n        No → // ch 與 s2[idx_s2] 不符，直接跳過  \n    Decision: idx_s2 在 seen? // 是否已經在之前的 s1 末尾遇到相同 idx_s2？  \n        Yes → prev_i, prev_cnt ← seen[idx_s2] // 取出之前的紀錄  \n            cycle_len ← i - prev_i // 這段重複的 s1 次數  \n            cycle_cnt ← cnt_s2 - prev_cnt // 這段中得到的 s2 次數  \n            remain ← n1 - i // 還剩下多少 s1 未處理  \n            times ← remain // cycle_len // 這段模式可重複的次數  \n            cnt_s2 ← cnt_s2 + times * cycle_cnt // 批量增加 s2 次數  \n            i ← i + times * cycle_len // 跳過已計算的區塊  \n        No → // 沒有重複，繼續進行  \n    → seen[idx_s2] ← [i, cnt_s2] // 記錄當前 idx_s2 的狀態  \n→ Result ← cnt_s2 // n2 // 取整得到可獲得的 str2 重複次數  \nEnd // 程式執行結束。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        # index of current position in s2\n        index = 0\n        # how many complete s2 strings we have found\n        cnt_s2 = 0\n        # how many times we have processed s1\n        i = 0\n        # record: index -> (i, cnt_s2) when this index first appears\n        seen = {}\n        len_s1, len_s2 = len(s1), len(s2)\n\n        while i < n1:\n            # process one copy of s1\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len_s2:\n                        cnt_s2 += 1\n                        index = 0\n            i += 1\n\n            # if we have seen this index before, a cycle is detected\n            if index in seen:\n                prev_i, prev_cnt = seen[index]\n                cycle_len = i - prev_i          # length of the cycle in terms of s1 repeats\n                cycle_cnt = cnt_s2 - prev_cnt   # number of s2 strings per cycle\n                remaining = n1 - i              # s1 repeats left to process\n                times = remaining // cycle_len  # how many full cycles fit\n                cnt_s2 += times * cycle_cnt\n                i += times * cycle_len\n            # record current state\n            seen[index] = (i, cnt_s2)\n\n        # each str2 requires n2 copies of s2\n        return cnt_s2 // n2\n\n\ndef main():\n    data = sys.stdin.read()\n\n    # parse the input string\n    s1_match = re.search(r's1\\s*=\\s*\"([^\"]*)\"', data)\n    n1_match = re.search(r'n1\\s*=\\s*(\\d+)', data)\n    s2_match = re.search(r's2\\s*=\\s*\"([^\"]*)\"', data)\n    n2_match = re.search(r'n2\\s*=\\s*(\\d+)', data)\n\n    if not (s1_match and n1_match and s2_match and n2_match):\n        print(\"0\")\n        return\n\n    s1 = s1_match.group(1)\n    n1 = int(n1_match.group(1))\n    s2 = s2_match.group(1)\n    n2 = int(n2_match.group(1))\n\n    solution = Solution()\n    result = solution.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode526.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement",
    "description_snippet": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for algorithm to count beautiful arrangements. Problem known from Leetcode 1359. Solution: backtracking with bitmask, DFS, count. Use recursion. Provide step by step with decision arrows etc. Must not output actual code. Just virtual pseudocode.\n\nLet's produce:\n\nStart\n→ Initialize counter = 0 // store number of arrangements\n→ Define function DFS(pos, usedMask) // pos current index (1-indexed)\n    → Decision: if pos > n? // if all positions assigned\n        Yes → counter++ // increment\n        No → // continue\n    → For num from 1 to n:\n        → Decision: if num not used in usedMask? // check availability\n            Yes →\n                → Decision: if num % pos == 0 OR pos % num == 0? // beauty condition\n                    Yes →\n                        → Mark num used: newMask = usedMask | (1 << (num-1))\n                        → DFS(pos+1, newMask) // recurse to next position\n                    No → // skip\n            No → // skip\n→ Call DFS(1, 0)\n→ End // output counter\n\nBut need line format: each line with 虛擬碼步驟 then // explanation. Use arrows.\n\nWe can use indentation for nested decision branches. Format as sample: use \"Decision:\" lines with indented Yes/No lines. Use → for step lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize counter = 0 // 用於統計滿足條件的排列數量  \n\n→ Define function DFS(pos, usedMask) // pos 為目前要填入的序號，usedMask 表示已使用數字的位元掩碼  \n    → Decision: pos > n? // 判斷是否已經填完所有位置  \n        Yes → counter++ // 位置全部填滿且符合條件，計數加一  \n        No  → // 仍有位置未填，繼續搜尋  \n    → For num from 1 to n: // 逐一嘗試把每個數字放到目前位置  \n        → Decision: (usedMask >> (num-1)) & 1 == 0? // 檢查該數字是否已被使用  \n            Yes → // 數字未被使用  \n                → Decision: (num % pos == 0) OR (pos % num == 0)? // 判斷「漂亮排列」條件  \n                    Yes → // 條件滿足  \n                        → Set newMask = usedMask | (1 << (num-1)) // 標記 num 為已使用  \n                        → DFS(pos+1, newMask) // 進入下一個位置的遞迴  \n                    No → // 條件不滿足，跳過此數字  \n            No  → // 數字已被使用，跳過此數字  \n\n→ Call DFS(1, 0) // 從第一個位置開始，初始時沒有任何數字被使用  \nEnd // 程式執行結束，counter 即為美麗排列的總數量",
      "generated_code": "# 計算「美麗排列」的數量\n# 以位元掩碼（bitmask）做背包式回溯，時間複雜度可接受（n <= 15 在實際題目中足夠）\n\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        # 內部遞迴函式：pos 是目前要填的索引（1-indexed），mask 記錄已使用的數字\n        def dfs(pos: int, mask: int) -> int:\n            # 如果所有位置都已填完，代表找到一種合法排列\n            if pos > n:\n                return 1\n            total = 0\n            # 嘗試把每個尚未使用的數字放到位置 pos\n            for num in range(1, n + 1):\n                # 檢查 num 是否已被使用\n                if not (mask >> (num - 1)) & 1:\n                    # 判斷「美麗排列」條件\n                    if num % pos == 0 or pos % num == 0:\n                        total += dfs(pos + 1, mask | (1 << (num - 1)))\n            return total\n\n        return dfs(1, 0)\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 從標準輸入讀取整數 n\n    data = sys.stdin.read().strip()\n    if data:\n        n = int(data)\n        solution = Solution()\n        result = solution.countArrangement(n)\n        # 將答案輸出到標準輸出\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode324.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Sort II",
    "description_snippet": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for wiggle sort problem. Steps: iterate through array, ensure pattern by swapping when condition fails. Provide line-by-line. Use Start, End, Decision. Each line: virtual code step + comment. Use arrow syntax. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 i = 0 // 設定索引為 0\n→ While i < nums.length - 1: // 只要還有相鄰元素需要檢查\n    → Decision: 如果 (i % 2 == 0) // i 為偶數時，期望 nums[i] < nums[i+1]\n        Yes → Decision: 如果 nums[i] >= nums[i+1] // 條件不滿足，需交換\n            Yes → Step 2: 交換 nums[i] 與 nums[i+1] // 交換以維持 wiggle 條件\n            No  → Step 3: // 沒有交換，條件已滿足\n        No → Decision: 如果 nums[i] <= nums[i+1] // i 為奇數時，期望 nums[i] > nums[i+1]\n            Yes → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以維持 wiggle 條件\n            No  → Step 5: // 沒有交換，條件已滿足\n    → Step 6: i = i + 1 // 移動到下一個索引\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Reorder nums so that nums[0] < nums[1] > nums[2] < nums[3] ...\n        The algorithm sorts the array, then rearranges the sorted elements\n        into two halves and interleaves them.\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        half = (n + 1) // 2          # size of the left half\n        left = nums[:half][::-1]     # largest elements for even indices\n        right = nums[half:][::-1]    # remaining elements for odd indices\n        nums[::2] = left\n        nums[1::2] = right\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Extract the list of integers from a string that may contain\n    arbitrary text and the list in Python syntax, e.g.:\n        'nums = [1,5,1,1,6,4]'\n    \"\"\"\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or end <= start:\n        raise ValueError(\"Input does not contain a valid list.\")\n    list_str = input_str[start:end+1]\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    Solution().wiggleSort(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "success": true,
          "output": "[1, 6, 1, 5, 1, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "success": true,
          "output": "[2, 3, 1, 3, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode32.json",
    "problem_index_in_file": 0,
    "title": "Longest Valid Parentheses",
    "description_snippet": "Given a string containing just the characters '(' and ')', return the length of the longest valid (w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: longest valid parentheses substring. Likely dynamic programming or stack. Use stack solution. We'll produce steps: Start, read string, initialize stack with -1, iterate each char with index, if '(' push index, else pop, if stack empty push current index, else compute length currentIndex - stack.top. Track max. End. Provide explanation after each line.\n\nWe must output in specified format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow characters. For decisions: use Decision.\n\nLet's produce. Ensure use Start, End. Use \"→\" for continuation. For decision, we need indent? In example, Decision lines show indentation. Use indentation via spaces. We'll follow.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀入字串 S // 取得輸入的括號字串\n→ Step 2: 初始化 stack 並將 -1 推入 // 用於計算長度\n→ Step 3: 初始化 maxLen 為 0 // 追蹤最大有效長度\n→ Step 4: 針對每個字元 s[i] 進行迴圈 // i 從 0 到 len(S)-1\n    → Decision: s[i] 是否為 '('? // 判斷字元類型\n        Yes → Step 5a: 將 i 推入 stack // 位置作為開口括號的索引\n        No  → Step 5b: 從 stack 取出一項 // 嘗試配對\n            → Decision: stack 是否為空? // 取完後檢查是否還有可配對的開口\n                Yes → Step 6a: 將 i 推入 stack // 無開口，將當前索引作為基準\n                No  → Step 6b: 計算當前長度 = i - stack.top // 以最新未配對開口為界\n                    → Step 7: 若 當前長度 > maxLen 則更新 maxLen // 儲存最大值\nEnd // 程式執行結束\n\nWe need to add explanations. Also include arrow and indentation. For decisions we must use \"Decision:\" with indent. Use spaces before indent? Example shows 4 spaces indent. We'll mimic.\n\nWe must ensure each line has code and comment separated by a space. Provide short explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀入字串 S // 取得輸入的括號字串\n→ Step 2: 初始化 stack 並將 -1 推入 // 用於計算長度\n→ Step 3: 初始化 maxLen 為 0 // 追蹤最大有效長度\n→ Step 4: 針對每個字元 s[i] 進行迴圈 // i 從 0 到 len(S)-1\n    → Decision: s[i] 是否為 '('? // 判斷字元類型\n        Yes → Step 5a: 將 i 推入 stack // 位置作為開口括號的索引\n        No  → Step 5b: 從 stack 取出一項 // 嘗試配對\n            → Decision: stack 是否為空? // 取完後檢查是否還有可配對的開口\n                Yes → Step 6a: 將 i 推入 stack // 無開口，將當前索引作為基準\n                No  → Step 6b: 計算當前長度 = i - stack.top // 以最新未配對開口為界\n                    → Step 7: 若 當前長度 > maxLen 則更新 maxLen // 儲存最大值\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"Return the length of the longest valid parentheses substring.\"\"\"\n        stack = [-1]          # stores indices of unmatched '('; -1 as base for first valid pair\n        max_len = 0\n\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)                 # push index of '('\n            else:\n                stack.pop()                      # try to match with last '('\n                if not stack:\n                    stack.append(i)             # no matching '(', push current index as base\n                else:\n                    max_len = max(max_len, i - stack[-1])  # current valid length\n\n        return max_len\n\ndef main():\n    # Read all input, keep the first non-empty line\n    raw_lines = sys.stdin.read().splitlines()\n    line = ''\n    for l in raw_lines:\n        if l.strip():\n            line = l.strip()\n            break\n\n    if not line:\n        # Empty input -> empty string\n        s = ''\n    else:\n        # If the input contains \"s =\" we parse the value after '='\n        if '=' in line:\n            _, value = line.split('=', 1)\n            value = value.strip()\n        else:\n            value = line\n\n        # Strip surrounding quotes if any\n        if (value.startswith('\"') and value.endswith('\"')) or (value.startswith(\"'\") and value.endswith(\"'\")):\n            value = value[1:-1]\n        s = value\n\n    result = Solution().longestValidParentheses(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"(()\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \")()())\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode565.json",
    "problem_index_in_file": 0,
    "title": "Array Nesting",
    "description_snippet": "You are given an integer array nums of length n where nums is a permutation of the numbers in the ra...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for this problem. It's about finding longest cycle length in permutation mapping. Approach: iterate over indices, maintain visited set, for each unvisited start, traverse following pointers until cycle completes, count length, update max. Use visited array. Complexity O(n). Virtual code must be line-by-line with explanation. Use Start, Decision, etc. Let's produce steps.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 maxLen ← 0 // 用於儲存目前找到的最大集合長度  \n→ Step 2: 建立布林陣列 visited[0..n-1] ← false // 標記每個索引是否已被處理  \n→ Decision: 若未處理完所有索引? // 迴圈遍歷每個可能的起始位置  \n    Yes → Step 3: 對於 i 從 0 到 n-1  \n        → Decision: 若 visited[i] 為 true? // 這個索引已屬於已計算過的集合  \n            Yes → Step 4: 跳過此 i // 直接進入下一個索引  \n            No  → Step 5: 建立變數 current ← i // 從此索引開始構造 s[i]  \n                → Step 6: 建立變數 count ← 0 // 本集合的元素數量  \n                → Step 7: Decision: 當 current 尚未在 visited? // 仍未重複  \n                    Yes → Step 8: visited[current] ← true // 標記為已訪問  \n                        → Step 9: count ← count + 1 // 計數加一  \n                        → Step 10: current ← nums[current] // 移動到下一個指向的索引  \n                        → Step 11: Decision: 回到 Step 7  \n                    No  → Step 12: Decision: 若 count 大於 maxLen? // 更新最大長度  \n                        Yes → Step 13: maxLen ← count // 設為新的最大值  \n                        No  → Step 14: 無需更新  \n→ Step 15: End // 所有索引已處理  \n→ Step 16: 輸出 maxLen // 回傳最大的集合長度\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def arrayNesting(self, nums):\n        \"\"\"\n        取得最大的集合 s[k] 長度，亦即找出排列中最大的循環長度。\n        \"\"\"\n        n = len(nums)\n        visited = [False] * n   # 標記每個索引是否已經處理過\n        max_len = 0\n\n        for i in range(n):\n            if not visited[i]:\n                cur = i\n                count = 0\n                # 以 i 為起點追蹤循環，直到遇到已訪問過的索引為止\n                while not visited[cur]:\n                    visited[cur] = True\n                    cur = nums[cur]\n                    count += 1\n                max_len = max(max_len, count)\n        return max_len\n\ndef parse_input(input_str: str):\n    \"\"\"\n    將形如 'nums = [5,4,0,3,1,6,2]' 的字串轉換為 list[int]。\n    \"\"\"\n    try:\n        # 取出第一個 '[' 到最後一個 ']' 的子字串\n        start = input_str.index('[')\n        end = input_str.rindex(']') + 1\n        nums_str = input_str[start:end]\n        nums = ast.literal_eval(nums_str)\n        if isinstance(nums, list):\n            return nums\n    except Exception:\n        pass\n    return []\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    nums = parse_input(raw_input)\n    if not nums:\n        print(0)\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.arrayNesting(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,4,0,3,1,6,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode706.json",
    "problem_index_in_file": 0,
    "title": "Design HashMap",
    "description_snippet": "Design a HashMap without using any built-in hash table libraries.\n\nImplement the MyHashMap class:\n\nM...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. No actual code. We need to design a hash map. Use separate chaining or open addressing. Provide step-by-step. Let's design: Use array of buckets, each bucket is a linked list of pairs. Hash function: key % capacity. Methods: constructor init capacity, array of bucket heads. Put: compute bucket, traverse list, if key found update, else insert new node at head. Get: compute bucket, traverse, return value or -1. Remove: compute bucket, traverse, keep prev, if found remove node. Let's produce lines with Start, End. Each line has arrow →. Need to include indentation for decisions. Use Decision lines for conditions. Use comments in Chinese. Let's do it.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 HashMap  \n → Step 1.1: 設定初始容量 cap = 1000 // 固定桶數  \n → Step 1.2: 建立空 bucket 陣列 buckets[cap] // 每個 bucket 以 null 開頭  \n→ Step 1.3: 定義 Node 結構 {int key; int value; Node next;} // 節點儲存鍵值對  \n\n→ Step 2: 定義 hash(key) → key mod cap // 簡易哈希函式  \n\n→ Step 3: 進行 put(key, value) 操作  \n → Decision: key 是否已存在於 bucket? // 先定位 bucket  \n  → Step 3.1: bucketIdx ← hash(key)  \n  → Step 3.2: current ← buckets[bucketIdx]  \n  → Step 3.3: Decision: current == null? // 若 bucket 為空  \n    Yes → Step 3.4: 建立新節點 newNode(key, value) → buckets[bucketIdx] = newNode // 插入  \n    No  → Step 3.5: 迴圈 while(current != null)  \n      Decision: current.key == key?  \n       Yes → Step 3.6: current.value = value // 更新現有鍵值  \n       No → Step 3.7: current ← current.next // 移動到下一節點  \n      Decision: current == null? // 迴圈結束且未找到鍵  \n       Yes → Step 3.8: 建立 newNode(key, value) → newNode.next = buckets[bucketIdx] → buckets[bucketIdx] = newNode // 插入於頭部  \n       No → End // 迴圈結束  \n\n→ Step 4: 進行 get(key) 操作  \n → Step 4.1: bucketIdx ← hash(key)  \n  → Step 4.2: current ← buckets[bucketIdx]  \n  → Step 4.3: Decision: current == null?  \n    Yes → Step 4.4: return -1 // 未找到鍵  \n    No  → Step 4.5: 迴圈 while(current != null)  \n      Decision: current.key == key?  \n       Yes → Step 4.6: return current.value // 找到並返回值  \n       No → Step 4.7: current ← current.next // 繼續搜尋  \n      Decision: current == null?  \n       Yes → Step 4.8: return -1 // 迴圈結束未找到  \n       No → End  \n\n→ Step 5: 進行 remove(key) 操作  \n → Step 5.1: bucketIdx ← hash(key)  \n  → Step 5.2: current ← buckets[bucketIdx]  \n  → Step 5.3: prev ← null  \n  → Step 5.4: Decision: current == null?  \n    Yes → Step 5.5: End // bucket 為空，無需刪除  \n    No  → Step 5.6: 迴圈 while(current != null)  \n      Decision: current.key == key?  \n       Yes → Step 5.7: Decision: prev == null? // 目標節點在 bucket 首部  \n         Yes → Step 5.8: buckets[bucketIdx] = current.next // 替換首部  \n         No  → Step 5.9: prev.next = current.next // 連接前後節點  \n         End // 刪除完成  \n        No → Step 5.10: prev ← current → current ← current.next // 移動到下一節點  \n      Decision: current == null?  \n       Yes → Step 5.11: End // 迴圈結束未找到  \n       No → End  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyHashMap:\n    \"\"\"簡易哈希表，使用鏈式散列（separate chaining）。\"\"\"\n\n    def __init__(self):\n        # 使用固定大小的桶數，避免擴容\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        \"\"\"簡單的哈希函式，取模。\"\"\"\n        return key % self.size\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"插入或更新鍵值對。\"\"\"\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)  # 更新\n                return\n        bucket.append((key, value))  # 新增\n\n    def get(self, key: int) -> int:\n        \"\"\"取得鍵所對應的值，若不存在回傳 -1。\"\"\"\n        h = self._hash(key)\n        for k, v in self.buckets[h]:\n            if k == key:\n                return v\n        return -1\n\n    def remove(self, key: int) -> None:\n        \"\"\"若鍵存在，將其移除。\"\"\"\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket.pop(i)\n                return\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops_line = data[0]\n    args_line = data[1] if len(data) > 1 else '[]'\n    ops = ast.literal_eval(ops_line)\n    args = ast.literal_eval(args_line)\n\n    hashmap = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyHashMap\":\n            hashmap = MyHashMap()\n            results.append(None)\n        elif op == \"put\":\n            hashmap.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            results.append(hashmap.get(arg[0]))\n        elif op == \"remove\":\n            hashmap.remove(arg[0])\n            results.append(None)\n        else:\n            # 未知操作，忽略\n            results.append(None)\n\n    # 轉換 None 為 null，符合 LeetCode 輸出格式\n    out = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]",
          "expected_output": "[null, null, null, 1, -1, null, 1, null, -1]",
          "success": true,
          "output": "[null, null, null, 1, -1, null, 1, null, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode399.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Division",
    "description_snippet": "You are given an array of variable pairs equations and an array of real numbers values, where equati...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem is typical \"evaluate division\" using graph or union-find. We need to outline steps: build graph mapping variable to neighbors and ratios. For each query, run DFS or use union-find to get ratio. Return -1 if no path. We'll produce pseudo steps. Should be line by line.\n\nLet's produce start. Then Build graph. For each equation add edges both directions. Then process queries: For each query, if both variables present and find path, compute ratio else -1. We'll use DFS function.\n\nWill produce pseudocode structure. Use decisions, loops, recursion. Let's write each line with explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空圖 Graph // 建立變數與相鄰變數及比例的映射  \n→ Decision: 是否有任何等式? // 檢查 equations 是否為空  \n    No → End // 沒有等式直接結束 (所有查詢都回 -1)  \n→ Step 2: 對於每一個等式 (Ai, Bi, value) 做  \n    → Sub-Step: Graph[Ai][Bi] ← value // Ai / Bi = value  \n    → Sub-Step: Graph[Bi][Ai] ← 1 / value // Bi / Ai = 1/value  \n→ Step 3: 建立一個空答案列表 Answers  \n→ Step 4: 對於每一個查詢 (Cj, Dj) 做  \n    → Decision: Cj 與 Dj 是否都在 Graph? // 檢查變數是否已定義  \n        Yes → Step 5: 呼叫 DFS(Cj, Dj, visited=set(), acc=1) // 計算比例  \n            → Decision: DFS 是否回傳 None? // 找不到路徑  \n                Yes → Sub-Step: Append -1.0 到 Answers // 回傳 -1  \n                No  → Sub-Step: Append 回傳值到 Answers // 回傳計算結果  \n        No  → Step 6: Append -1.0 到 Answers // 任何一個變數未定義  \n→ Step 7: 回傳 Answers // 所有查詢結果  \nEnd // 程式執行結束  \n\n// DFS 函式  \n→ Function DFS(current, target, visited, acc): // 目前節點, 目標節點, 已訪問集合, 累積比例  \n    → Decision: current == target? // 是否達到目標  \n        Yes → Return acc // 成功，返回累積比例  \n        No  → visited.add(current) // 標記已訪問  \n    → For each neighbour, ratio in Graph[current]: // 遍歷相鄰節點  \n        → Decision: neighbour not in visited? // 避免循環  \n            Yes → Result ← DFS(neighbour, target, visited, acc * ratio) // 進一步遞迴  \n            → Decision: Result 不是 None? // 找到路徑  \n                Yes → Return Result // 傳回結果  \n                No  → Continue // 继续搜尋其他相鄰  \n    → Return None // 所有相鄰均失敗，回傳 None  \n// 以上即為虛擬碼及逐行解釋的結構化步驟。",
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Convert the input string into a dictionary\n    # Wrap it with braces to create a valid dict literal\n    data = eval('{' + raw + '}')\n    equations = data.get('equations', [])\n    values = data.get('values', [])\n    queries = data.get('queries', [])\n\n    sol = Solution()\n    ans = sol.calcEquation(equations, values, queries)\n    output = '[' + ','.join(f'{x:.5f}' for x in ans) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpnt6h7zmm.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpnt6h7zmm.py\", line 35, in main\n    data = eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]}\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpl6jztcj8.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpl6jztcj8.py\", line 35, in main\n    data = eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]}\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpp1ikd3vw.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpp1ikd3vw.py\", line 35, in main\n    data = eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]}\n     ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode707.json",
    "problem_index_in_file": 0,
    "title": "Design Linked List",
    "description_snippet": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for implementing MyLinkedList class with operations. Use singly or doubly? We can choose singly. Provide virtual steps for class initialization, methods. Use Start, End, Decision, arrow lines. Each line: 虛擬碼步驟 [space] // 解釋. Provide sequential steps. Likely design with Node class and MyLinkedList. Use attributes head, tail, size. Methods: get, addAtHead, addAtTail, addAtIndex, deleteAtIndex. Provide pseudo steps.\n\nWe need to generate pseudo code lines with arrows. Provide for each method: steps to perform. Not actual code. Just structure.\n\nOk produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類別，具有 val 與 next 屬性 // 建立節點結構  \n→ Step 2: 定義 MyLinkedList 類別，內含 head、tail、size 三個屬性 // 初始化連結串列  \n→ Step 3: MyLinkedList() 初始化 head、tail 為 null，size 為 0 // 建構子  \n\n→ Step 4: get(index)  \n    → Decision: 如果 index < 0 或 index ≥ size? // 檢查索引合法性  \n        No → Return -1 // 索引無效，返回 -1  \n        Yes → Step 5: 從 head 開始，走 index 步 // 找到指定節點  \n            → Step 6: Return node.val // 取得值  \n\n→ Step 7: addAtHead(val)  \n    → Step 8: 創建新節點 newNode(val) // 新節點  \n    → Step 9: newNode.next = head // 指向舊 head  \n    → Decision: 如果 head 為 null? // 判斷是否為空串列  \n        Yes → tail = newNode // 空串列時，尾節點也為新節點  \n        No  → 無操作  \n    → head = newNode // 更新 head  \n    → size++ // 尺寸加一  \n\n→ Step 10: addAtTail(val)  \n    → Step 11: 創建新節點 newNode(val) // 新節點  \n    → Decision: 如果 tail 為 null? // 判斷是否為空串列  \n        Yes → head = newNode // 空串列時，head 也為新節點  \n        No  → tail.next = newNode // 將新節點接到舊 tail  \n    → tail = newNode // 更新尾節點  \n    → size++ // 尺寸加一  \n\n→ Step 12: addAtIndex(index, val)  \n    → Decision: 如果 index > size? // 超過尾端  \n        No → 進行下一步  \n        Yes → Return // 不插入  \n    → Decision: 如果 index == 0? // 插入頭部  \n        Yes → addAtHead(val) // 直接呼叫 addAtHead  \n        No → Decision: 如果 index == size? // 插入尾部  \n            Yes → addAtTail(val) // 直接呼叫 addAtTail  \n            No  → Step 13: 從 head 走 index-1 步，取得 prevNode // 找到前一節點  \n                → Step 14: newNode = Node(val)  \n                → Step 15: newNode.next = prevNode.next // 指向後續節點  \n                → prevNode.next = newNode // 連接新節點  \n                → size++ // 尺寸加一  \n\n→ Step 16: deleteAtIndex(index)  \n    → Decision: 如果 index < 0 或 index ≥ size? // 索引無效  \n        No → Return // 不做任何事  \n        Yes → Step 17: 如果 index == 0? // 刪除頭節點  \n            Yes → head = head.next // 更新 head  \n                → Decision: 如果 head 為 null? // 刪完後空串列  \n                    Yes → tail = null // 尾節點也置空  \n            No → Decision: 如果 index == size-1? // 刪除尾節點  \n                Yes → Step 18: 從 head 走 index-1 步，取得 prevNode // 找到前一節點  \n                    → prevNode.next = null // 去除尾節點  \n                    → tail = prevNode // 更新尾節點  \n                No → Step 19: 從 head 走 index-1 步，取得 prevNode // 找到前一節點  \n                    → prevNode.next = prevNode.next.next // 跳過要刪除的節點  \n    → size-- // 尺寸減一  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyLinkedList:\n    class Node:\n        __slots__ = (\"val\", \"next\")\n        def __init__(self, val=0):\n            self.val = val\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def get(self, index):\n        if index < 0 or index >= self.size:\n            return -1\n        curr = self.head\n        for _ in range(index):\n            curr = curr.next\n        return curr.val\n\n    def addAtHead(self, val):\n        node = self.Node(val)\n        node.next = self.head\n        self.head = node\n        self.size += 1\n\n    def addAtTail(self, val):\n        node = self.Node(val)\n        if not self.head:\n            self.head = node\n        else:\n            curr = self.head\n            while curr.next:\n                curr = curr.next\n            curr.next = node\n        self.size += 1\n\n    def addAtIndex(self, index, val):\n        if index < 0:\n            index = 0\n        if index > self.size:\n            return\n        if index == 0:\n            self.addAtHead(val)\n            return\n        node = self.Node(val)\n        curr = self.head\n        for _ in range(index - 1):\n            curr = curr.next\n        node.next = curr.next\n        curr.next = node\n        self.size += 1\n\n    def deleteAtIndex(self, index):\n        if index < 0 or index >= self.size:\n            return\n        if index == 0:\n            self.head = self.head.next\n        else:\n            curr = self.head\n            for _ in range(index - 1):\n                curr = curr.next\n            curr.next = curr.next.next\n        self.size -= 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1]) if len(data) > 1 else []\n\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"MyLinkedList\":\n            obj = MyLinkedList()\n            results.append(None)\n        else:\n            method = getattr(obj, op)\n            res = method(*args) if args else method()\n            results.append(res)\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]",
          "expected_output": "[null, null, null, null, 2, null, 3]",
          "success": true,
          "output": "[null, null, null, null, 2, null, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode481.json",
    "problem_index_in_file": 0,
    "title": "Magical String",
    "description_snippet": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for counting number of '1's in first n numbers of magical string s. It's similar to LeetCode 873. Provide line-by-line virtual code with explanation. Use structure: Start, steps, decision, End. We should not output actual code but virtual code with arrow.\n\nWe need to produce steps: initialize string array s with '1', '2', '2', pointer idx=2 (next index to read), count ones, loop until length >= n, etc. Provide explanation after each line.\n\nOk produce lines. Use \"→\" arrow. Use indentation maybe with spaces. For decision use \"Decision:\".\n\nLet's produce.\n\nAlso ensure each line has virtual code step, space, comment. Eg: \"Start // 程式開始執行\". Use arrow for steps: \"→ Step 1: 初始化結果字符串 s = ['1', '2', '2'] // 以魔法字符串的前三個已知元素開始\". Actually s should start with \"1,2,2\". But we can use char array or list.\n\nThen pointer i=2, // pointer to read next group length. countOnes = 1 // because initial string contains one '1'.\n\nLoop while len(s) < n: generate next group: repeat length s[i] times with alternating char. Implementation: currentChar = '1' if s[last] == '2' else '2', but we can keep a toggle variable.\n\nWe will produce pseudo-code line by line. Provide explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果字符串 s = ['1', '2', '2'] // 以已知的前三個字符開始  \n→ Step 2: 初始化指標 i = 2 // 指向接下來需要讀取的組長  \n→ Step 3: 初始化計數 countOnes = 1 // 前三個字符中只有一個 '1'  \n→ Step 4: 初始化 toggle = False // False 表示下一個生成的字符為 '1'，True 為 '2'  \n→ Decision: 如果 len(s) < n? // 只要生成的字符數還不夠 n 就繼續  \n    Yes → Step 5: 計算 repeatTimes = int(s[i]) // 讀取當前指標位置的數字，作為重複次數  \n    → Step 6: 取 nextChar = '1' if toggle == False else '2' // 根據 toggle 決定要生成的字符  \n    → Step 7: 重複 repeatTimes 次  \n        → Step 8: s.append(nextChar) // 將生成的字符加入 s  \n        → Decision: 如果 nextChar == '1' and len(s) <= n? // 僅在生成到第 n 個字符時才累計  \n            Yes → Step 9: countOnes += 1 // 這次生成的是 '1'，統計加一  \n            No → // 不統計  \n    → Step 10: 切換 toggle = not toggle // 下一組要生成相反的字符  \n    → Step 11: i += 1 // 移到下一個組長位置  \n    → End // 回到 Decision 判斷  \n    No → // s 已足夠長，跳出循環  \n→ Step 12: Return countOnes // 回傳前 n 個字符中的 '1' 數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def magicalString(self, n: int) -> int:\n        \"\"\"\n        Return the number of '1's in the first n elements of the magical string.\n        \"\"\"\n        if n == 0:\n            return 0\n        # 初始已知的三個元素\n        s = [1, 2, 2]\n        # 指標 head 指向下一個用來決定重複次數的位置\n        head = 2\n        # 下一個要加入的數字（1 或 2）\n        num = 1\n\n        # 只要生成的長度還不足 n 就持續擴充\n        while len(s) < n:\n            # 根據 s[head] 的值決定要重複幾次\n            repeat_times = s[head]\n            s.extend([num] * repeat_times)\n            # 1 和 2 交替\n            num ^= 3\n            head += 1\n\n        # 只計算前 n 個元素中的 1 的數量\n        return s[:n].count(1)\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析出整數 n，計算並輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 用正則表達式提取第一個出現的整數\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return  # 若無數字，直接結束\n    n = int(nums[0])\n\n    solver = Solution()\n    result = solver.magicalString(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode200.json",
    "problem_index_in_file": 0,
    "title": "Number of Islands",
    "description_snippet": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. The problem is number of islands in a grid. We'll use DFS or BFS. We should produce step-by-step algorithm. Use Start, Decision, Step lines, etc. Use arrows. Provide brief explanation. Should be line-by-line. So output something like:\n\nStart // 程式開始執行\n→ Step 1: 取得格子行數 rows, 列數 cols // 初始化尺寸\n→ Step 2: 建立 visited[][] // 標記已訪問\n→ Decision: 是否所有格子都已遍歷? // 迴圈條件\n  Yes → End // 完成\n  No → Step 3: 從 0 到 rows-1 迴圈\n  → Step 4: 從 0 到 cols-1 迴圈\n  → Decision: grid[i][j] 為 '1' 且未訪問? // 找到未處理的陸\n    Yes → Step 5: islands++ // 新島\n    → Step 6: 呼叫 DFS(i,j) // 探索整個島\n    No → Next // 跳過\n\nDFS function:\n→ Step 7: If i<0 or i>=rows or j<0 or j>=cols or grid[i][j]!='1' or visited[i][j] return // 基本情況\n→ Step 8: visited[i][j]=true\n→ Step 9: Call DFS(i+1,j), DFS(i-1,j), DFS(i,j+1), DFS(i,j-1)\n\nReturn islands.\n\nBut we need to produce virtual code lines step-by-step; include Start and End. Probably use Decision: and Yes/No arrows. Use simple structure. No actual code. Just steps. Each line: \"虛擬碼步驟 // 解釋\". Provide explanation after a space.\n\nLet's craft. We'll produce main algorithm first, then define DFS function. Or we can embed function in steps. Use indentation? In example, indent inside decisions. We'll follow pattern: use 4 spaces or indent? They used indentation in example. We should indent inside decisions. Use \"Decision:\" line, then indent Yes/No with arrow.\n\nOk. Let's produce lines:\n\nStart // 程式開始\n→ Step 1: rows ← number of rows in grid // 取得行數\n→ Step 2: cols ← number of columns in grid // 取得列數\n→ Step 3: visited ← 2D boolean array rows × cols, all false // 建立已訪問標記\n→ Step 4: islands ← 0 // 初始化島數\n→ Decision: rows == 0 或 cols == 0? // 判斷是否空格\n    Yes → End // 空格直接結束\n    No → Step 5: For i from 0 to rows-1 // 行遍歷\n    → Step 6: For j from 0 to cols-1 // 列遍歷\n    → Decision: grid[i][j] == '1' 且 visited[i][j] == false? // 找未處理的陸\n        Yes → islands ← islands + 1 // 新島\n        → Step 7: DFS(i, j) // 探索整個島\n        No → // 繼續\n\n→ Step 8: Return islands // 結果\n\nNow define DFS:\n→ Step 9: Function DFS(r, c)\n    → Decision: r < 0 或 r ≥ rows 或 c < 0 或 c ≥ cols? // 超出邊界\n        Yes → Return // 結束\n        No → Decision: grid[r][c] != '1' 或 visited[r][c] == true? // 已非陸或已訪問\n            Yes → Return\n            No → Step 10: visited[r][c] ← true // 標記為已訪問\n            → Step 11: DFS(r+1, c) // 向下\n            → Step 12: DFS(r-1, c) // 向上\n            → Step 13: DFS(r, c+1) // 右\n            → Step 14: DFS(r, c-1) // 左\n            → Return\n\nEnd // 程式結束\n\nMake sure each line ends with // 解釋. Use \"Start\" and \"End\".\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: rows ← number of rows in grid // 取得行數  \n→ Step 2: cols ← number of columns in grid // 取得列數  \n→ Step 3: visited ← 2D boolean array rows × cols, all false // 建立已訪問標記  \n→ Step 4: islands ← 0 // 初始化島數  \n\n→ Decision: rows == 0 或 cols == 0? // 判斷格子是否為空  \n  Yes → End // 空格直接結束  \n  No → Step 5: For i from 0 to rows-1 // 行遍歷  \n\n   → Step 6: For j from 0 to cols-1 // 列遍歷  \n\n    → Decision: grid[i][j] == '1' 且 visited[i][j] == false? // 找未處理的陸  \n     Yes → islands ← islands + 1 // 新島  \n      → Step 7: DFS(i, j) // 探索整個島  \n     No → // 繼續下一格  \n\n→ Step 8: Return islands // 回傳島數  \n\n→ Step 9: Function DFS(r, c)  \n  → Decision: r < 0 或 r ≥ rows 或 c < 0 或 c ≥ cols? // 超出邊界  \n    Yes → Return // 結束  \n    No → Decision: grid[r][c] != '1' 或 visited[r][c] == true? // 非陸或已訪問  \n     Yes → Return  \n     No → Step 10: visited[r][c] ← true // 標記為已訪問  \n      → Step 11: DFS(r+1, c) // 向下  \n      → Step 12: DFS(r-1, c) // 向上  \n      → Step 13: DFS(r, c+1) // 向右  \n      → Step 14: DFS(r, c-1) // 向左  \n      → Return  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numIslands(self, grid):\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return\n            if grid[i][j] == '0' or visited[i][j]:\n                return\n            visited[i][j] = True\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    dfs(i, j)\n                    count += 1\n        return count\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n    # 如果輸入包含前置字串，例如 \"grid = ...\"\n    if raw_input.startswith(\"grid\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n    # 解析為 Python 物件\n    try:\n        grid = ast.literal_eval(raw_input)\n    except Exception as e:\n        # 若解析失敗，輸出 0\n        print(0)\n        sys.exit(0)\n    # 計算並輸出結果\n    result = Solution().numIslands(grid)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode762.json",
    "problem_index_in_file": 0,
    "title": "Prime Number of Set Bits in Binary Representation",
    "description_snippet": "Given two integers left and right, return the count of numbers in the inclusive range [left, right] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. For requirement: Given two integers left and right, count numbers in inclusive range with prime number of set bits. Need to produce pseudo-code in described format: Start, Steps, Decision, etc. Must output per line: virtual code step + space + // explanation. Use arrows, etc.\n\nWe should include steps: Start, for loop from left to right, compute set bits count, check if prime, increment count. Need helper to count bits and to check prime. Could use simple function or inline. But we need virtual steps; could include subroutines. Should keep steps clear. Use Decision for prime check. Use Start/End.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 設定計數器 result = 0 // 初始化計數\n→ Step 2: for num from left to right // 遍歷區間\n    → Decision: 是否為範圍內的每個數？ // 控制迴圈\n        Yes → Step 3: 計算 num 的 set bits = CountSetBits(num) // 取得位元數\n        → Decision: set bits 是否為質數？ // 判斷是否為質數\n            Yes → Step 4: result = result + 1 // 數量加一\n            No → Step 5: 跳過 // 無需操作\n→ Step 6: 輸出 result // 結果\nEnd // 程式結束\n\nBut we need CountSetBits and IsPrime as subroutines: Maybe we define virtual functions:\n\nStart // CountSetBits\n→ Step: count = 0\n→ for i from 0 to 31 // 取每個位元\n    → Decision: (num >> i) & 1 == 1 ?\n        Yes → count = count + 1\n→ Return count\nEnd\n\nAnd IsPrime:\nStart // IsPrime\n→ Step: if n < 2 return False // 小於2非質數\n→ for i from 2 to sqrt(n)\n    → Decision: n mod i == 0 ?\n        Yes → return False\n→ Return True\n\nBut in pseudo we may just inline.\n\nSimpler: We'll just have decision: if IsPrime(setBits) then increment.\n\nLet's produce as lines with arrow and comments.\n\nNeed each line ends with comment after space. Also use arrow arrow? Format uses \"→\" to indent steps. Also Decision uses \"Decision:\".\n\nLet's craft.\n\nWe'll start:\n\nStart // 程式開始執行\n→ Step 1: result = 0 // 初始化計數器\n→ Step 2: for num = left to right // 從 left 到 right\n    → Decision: num <= right ?\n        Yes → Step 3: setBits = CountSetBits(num) // 計算二進位 1 的個數\n        → Decision: IsPrime(setBits) ?\n            Yes → Step 4: result = result + 1 // 若為質數則累加\n            No  → Step 5: 無操作 // 不是質數不做任何事\n    → Step 6: num = num + 1 // 迴圈遞增\n→ Step 7: 輸出 result // 輸出符合條件的數量\nEnd // 程式執行結束\n\nWe also need CountSetBits and IsPrime subroutines defined separately. Use Start/End. Provide steps inside. Let's include them.\n\nCountSetBits:\nStart // CountSetBits 函式\n→ Step: count = 0\n→ Step: temp = num\n→ Decision: temp > 0 ?\n    Yes → Step: count = count + (temp & 1) // 若最低位為1加一\n    → Step: temp = temp >> 1 // 右移\n    → Decision: temp > 0 ?\n        Yes → repeat\n    No → ...\n→ Return count\nEnd\n\nBut maybe we can simplify.\n\nMaybe produce:\n\nStart // CountSetBits\n→ Step: count = 0\n→ Step: while num > 0\n    → Step: count = count + (num & 1) // 加上最低位\n    → Step: num = num >> 1 // 右移\n→ Return count\nEnd\n\nSimilarly IsPrime:\n\nStart // IsPrime\n→ Decision: n < 2 ?\n    Yes → Return False\n    No → ...\n→ Step: i = 2\n→ Decision: i * i <= n ?\n    Yes → Decision: n mod i == 0 ?\n        Yes → Return False\n        No → i = i + 1 → repeat\n    No → Return True\nEnd\n\nBut this might be too detailed. But requirement: provide virtual code step by step. Provide subroutines. Good.\n\nLet's output each line as per format: virtual code + space + // explanation. Use \"→\" for indentation. Must include \"Start\" and \"End\". For decision we use \"Decision:\".\n\nWe must not output actual code.\n\nLet's craft final answer accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = 0 // 初始化計數器  \n→ Step 2: for num = left to right // 從左端到右端遍歷所有數字  \n  → Decision: num <= right? // 迴圈判斷是否仍在範圍內  \n   Yes → Step 3: setBits = CountSetBits(num) // 計算 num 的二進位 1 的個數  \n    → Decision: IsPrime(setBits)? // 判斷 setBits 是否為質數  \n     Yes → Step 4: result = result + 1 // 若是質數則累加計數  \n     No  → Step 5: // 不是質數，什麼也不做  \n    → Step 6: num = num + 1 // 迴圈遞增  \n→ Step 7: 輸出 result // 輸出符合條件的數量  \nEnd // 程式執行結束  \n\n---  \n\nStart // CountSetBits 函式  \n→ Step 1: count = 0 // 初始化位元數  \n→ Step 2: temp = num // 用 temp 進行位移操作  \n→ Decision: temp > 0? // 判斷是否還有位元待處理  \n  Yes → Step 3: count = count + (temp & 1) // 若最低位為 1 加 1  \n   → Step 4: temp = temp >> 1 // 右移 1 位  \n   → Decision: temp > 0? // 重複直至 temp 為 0  \n    Yes → repeat Step 3-4  \n    No →  \n→ Return count // 回傳計算結果  \nEnd // CountSetBits 結束  \n\n---  \n\nStart // IsPrime 函式  \n→ Decision: n < 2? // 小於 2 的數不是質數  \n  Yes → Return False  \n  No →  \n→ Step 1: i = 2 // 從 2 開始檢查可否整除  \n→ Decision: i * i <= n? // 只需檢查到 sqrt(n)  \n  Yes → Decision: n mod i == 0? // 是否被 i 整除  \n   Yes → Return False // 不是質數  \n   No  → Step 2: i = i + 1 → repeat Decision  \n  No  → Return True // 所有檢查通過，為質數  \nEnd // IsPrime 結束",
      "generated_code": "import sys\nimport re\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}\n    count = 0\n    for num in range(left, right + 1):\n        if bin(num).count('1') in primes:\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) >= 2:\n        left, right = map(int, nums[:2])\n    else:\n        left = right = 0\n    print(count_prime_set_bits(left, right))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 6, right = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 10, right = 15",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode215.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in an Array",
    "description_snippet": "Given an integer array nums and an integer k, return the k^th largest element in the array.\n\nNote th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find kth largest element in array without sorting. Likely using quickselect or min-heap of size k. Let's choose QuickSelect algorithm: choose pivot, partition, recursively find kth largest. Use 0-index. Since we want kth largest, can transform to (n-k)th smallest. Steps: Start, input array and k, compute targetIndex = n-k. Call QuickSelect(array, left=0, right=n-1, targetIndex). In QuickSelect: if left==right return array[left]. Partition: pick pivot (e.g., last element). Partition such that elements <= pivot left, > pivot right? We want ascending. Then pivotIndex returned. If pivotIndex==targetIndex return array[pivotIndex]. Else if pivotIndex > targetIndex: recurse left side. Else recurse right side. End. Provide explanation each line. Use virtual code format with arrows.\n\nWe must not output real code. Provide virtual steps.\n\nMake sure each line has explanation comment after //.\n\nLet's produce steps: Start, input array, compute target index, call QuickSelect, define QuickSelect procedure, inside QuickSelect base case, partition, pivot selection, partition algorithm, return pivotIndex. Then decision on pivotIndex vs targetIndex, recursion left/right. After recursion returns result, return result. End.\n\nUse \"Start\" and \"End\". Use arrow \"→\" for steps. Use \"Decision:\" lines for conditional.\n\nEnsure each line has comment. Use \"Start\" at top. Use \"End\" at bottom.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得 整數陣列 nums 與 整數 k // 從使用者處取得輸入\n→ Step 2: 計算 targetIndex = nums.Length - k // 轉換為第 targetIndex 小的元素\n→ Step 3: 呼叫 QuickSelect(nums, 0, nums.Length-1, targetIndex) → result // 開始快速選擇演算法\n→ Step 4: 輸出 result // 回傳 kth 大的元素\nEnd // 程式執行結束\n\n// QuickSelect 函式的定義\n→ Step 5: 定義 Procedure QuickSelect(arr, left, right, targetIndex) // 快速選擇主程式\n→ Decision: 如果 left == right? // 只剩一個元素\n    Yes → Step 6: 回傳 arr[left] // 直接返回\n    No  → Decision: 執行 Partition 步驟? // 需要分區\n        // Partition 將陣列分為小於 pivot 與大於 pivot\n        Yes → Step 7: 選取 pivot = arr[right] // 以最右端作為 pivot\n        → Step 8: 初始化 i = left-1 // i 為小於 pivot 的區域邊界\n        → Step 9: 從 j = left 到 right-1 迴圈\n            → Decision: 如果 arr[j] <= pivot? // 判斷是否小於等於 pivot\n                Yes → Step 10: i++ ; 交換 arr[i] 與 arr[j] // 將小於等於 pivot 的元素放左邊\n                No  → Step 11: 無操作 // 直接跳過\n        → Step 12: 交換 arr[i+1] 與 arr[right] // 把 pivot 放到正確位置\n        → Step 13: 設置 pivotIndex = i+1 // pivot 的最終索引\n        → Step 14: Decision: 是否 pivotIndex == targetIndex? // 判斷是否已找到\n            Yes → Step 15: 回傳 arr[pivotIndex] // 找到目標元素\n            No  → Decision: 是否 pivotIndex > targetIndex? // 決定遞迴方向\n                Yes → Step 16: 呼叫 QuickSelect(arr, left, pivotIndex-1, targetIndex) → result // 在左半邊遞迴\n                No  → Step 17: 呼叫 QuickSelect(arr, pivotIndex+1, right, targetIndex) → result // 在右半邊遞迴\n        → Step 18: 回傳 result // 回傳遞迴結果\n    End // End of Partition 判斷\nEnd // End of QuickSelect 定義",
      "generated_code": "import sys\nimport re\nimport ast\nimport heapq\n\nclass Solution:\n    def findKthLargest(self, nums, k):\n        # 使用最小堆保持前 k 個最大值\n        heap = nums[:k]\n        heapq.heapify(heap)          # O(k)\n        for num in nums[k:]:\n            if num > heap[0]:\n                heapq.heapreplace(heap, num)  # pop 最小並 push num，保持堆大小 k\n        return heap[0]               # 堆頂即為第 k 大元素\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 從輸入字串中抽取 nums 列表與 k 整數\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match   = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not k_match:\n        return\n    nums = ast.literal_eval(nums_match.group(1))\n    k = int(k_match.group(1))\n\n    sol = Solution()\n    result = sol.findKthLargest(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode318.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Word Lengths",
    "description_snippet": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation after each. We need to cover algorithm for given problem: find max product of lengths of two words with no common letters.\n\nWe should use bitmask representation for each word to check overlap quickly. Steps: input array words, compute bitmask for each word, compute lengths. Then double loop over i<j, check if mask[i] & mask[j]==0, compute product and update max. If none, return 0.\n\nNeed to produce Start, End, Decision, Steps, etc.\n\nLet's produce:\n\nStart // program start\n→ Step 1: Initialize maxProduct = 0 // store maximum product\n→ Step 2: For each word in words, compute bitmask and length // create arrays mask[] and len[]\n→ Step 3: Nested loop over i from 0 to n-1 // iterate pairs\n    → Decision: If i == j? No // skip same index\n    → Decision: If mask[i] & mask[j] == 0? // check no common letters\n        Yes → Step 4: Compute product = len[i] * len[j] // product\n            → Decision: If product > maxProduct? \n                Yes → Step 5: maxProduct = product // update maximum\n                No → // do nothing\n→ Step 6: Return maxProduct // output result\n\nWe need to format as per specification: each line includes virtual code step and explanation.\n\nUse arrow notation: Start, → Step ... etc.\n\nLet's produce exactly.\n\nMake sure indentation and arrow lines consistent.\n\nWe also include nested Decision blocks.\n\nWe should include \"End\" at the end.\n\nEnsure no actual code, just virtual.\n\nLet's craft.\n\nAlso include comment after //.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set maxProduct = 0 // 初始化最大乘積為 0  \n→ Step 2: For each word in words  \n  → Step 2.1: Compute bitmask of word // 用 26 位元表示字母出現  \n  → Step 2.2: Store bitmask in mask[i]  \n  → Step 2.3: Store length of word in len[i] // 準備後續比較  \n→ Step 3: For i from 0 to n-1 // 外層迴圈  \n  → Decision: Is i == j? // 不需要比較同一個字串  \n   No → Step 3.1: For j from i+1 to n-1 // 內層迴圈  \n    → Decision: If (mask[i] & mask[j]) == 0? // 檢查兩字串是否無共用字母  \n     Yes → Step 3.2: product = len[i] * len[j] // 計算長度乘積  \n      → Decision: Is product > maxProduct?  \n       Yes → Step 3.3: maxProduct = product // 更新最大乘積  \n       No → // 不更新  \n     No → // 兩字串有共用字母，略過  \n→ Step 4: Return maxProduct // 輸出最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_product(words):\n    n = len(words)\n    masks = [0] * n\n    for i, w in enumerate(words):\n        mask = 0\n        for ch in w:\n            mask |= 1 << (ord(ch) - 97)  # 97 is ord('a')\n        masks[i] = mask\n\n    max_prod = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if masks[i] & masks[j] == 0:  # no common letters\n                prod = len(words[i]) * len(words[j])\n                if prod > max_prod:\n                    max_prod = prod\n    return max_prod\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list part between '[' and ']'\n    l = data.find('[')\n    r = data.rfind(']')\n    if l == -1 or r == -1:\n        # If input doesn't contain brackets, try to parse the whole string\n        try:\n            words = ast.literal_eval(data)\n        except Exception:\n            words = []\n    else:\n        list_str = data[l:r + 1]\n        try:\n            words = ast.literal_eval(list_str)\n        except Exception:\n            words = []\n\n    result = max_product(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode698.json",
    "problem_index_in_file": 0,
    "title": "Partition to K Equal Sum Subsets",
    "description_snippet": "Given an integer array nums and an integer k, return true if it is possible to divide this array int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code, line by line, with explanation comments. For the given problem: Partition into k equal sum subsets. Classic problem: check sum%k==0, target=sum/k, use backtracking or DFS with bitmask or multiset. Virtual code structure: Start, Step 1: compute sum, if not divisible -> false, Step 2: sort array descending, Step 3: init visited, Step 4: define DFS helper function. Steps with recursion.\n\nWe need to produce virtual code with arrows and decisions. Use structure: Start, then steps.\n\nWe should not output actual code, just pseudo steps. So we can do:\n\nStart // 程式開始執行\n→ Step 1: Calculate totalSum = sum(nums) // 計算總和\n→ Decision: 如果 totalSum % k != 0? // 檢查是否能均分\n    Yes → Step 2: return false // 無法均分，直接返回 false\n    No  → Step 3: target = totalSum / k // 計算每組應有的和\n→ Step 4: Sort nums in descending order // 先排除大數\n→ Step 5: Initialize boolean visited[nums.length] = false // 標記元素是否已被使用\n→ Step 6: Define DFS function dfs(startIndex, remainingK, currentSum) // 回溯\n    → Decision: 如果 remainingK == 0? // 已成功分配 k-1 組\n        Yes → Step 7: return true // 剩下的元素自動組成最後一組\n        No  → Decision: 如果 currentSum == target? // 現組已滿\n            Yes → Step 8: return dfs(0, remainingK - 1, 0) // 開始下一組\n            No  → Decision: 如果 startIndex >= nums.length? // 無更多元素\n                Yes → Step 9: return false // 失敗\n                No  → Step 10: Decision: 如果 visited[startIndex] 或 currentSum + nums[startIndex] > target? // 該元素不可用或會超過目標\n                    Yes → Step 11: return dfs(startIndex + 1, remainingK, currentSum) // 跳過該元素\n                    No  → Step 12: visited[startIndex] = true // 選擇該元素\n                        → Step 13: If dfs(startIndex + 1, remainingK, currentSum + nums[startIndex]) return true // 進一步搜索\n                        → Step 14: visited[startIndex] = false // 回溯\n                        → Step 15: return false // 這條路徑失敗\n→ Step 16: return dfs(0, k, 0) // 開始回溯\nEnd // 程式執行結束\n\nNeed to ensure each line with \"虛擬碼步驟 // 解釋\". Use arrow \"→\". The DFS function lines can be nested but we maintain arrows.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Calculate totalSum = sum(nums) // 計算陣列總和  \n→ Decision: 如果 totalSum % k != 0? // 檢查總和是否能被 k 平均分  \n  Yes → Step 2: return false // 無法平均分配，直接返回 false  \n  No  → Step 3: target = totalSum / k // 計算每個子集需要達到的和  \n→ Step 4: Sort nums in descending order // 先將數字由大到小排序，方便剪枝  \n→ Step 5: Initialize boolean visited[nums.length] = false // 標記每個數字是否已被使用  \n→ Step 6: Define function dfs(startIndex, remainingK, currentSum) // 回溯函式，尋找剩餘的子集  \n  Decision: 如果 remainingK == 0? // 已成功分配 k-1 個子集  \n   Yes → Step 7: return true // 剩餘元素自然構成最後一個子集，成功  \n   No  → Decision: 如果 currentSum == target? // 本子集已達到目標和  \n    Yes → Step 8: return dfs(0, remainingK - 1, 0) // 開始尋找下一個子集  \n    No  → Decision: 如果 startIndex >= nums.length? // 沒有更多元素可選  \n     Yes → Step 9: return false // 無法完成分配，失敗  \n     No  → Decision: 如果 visited[startIndex] 或 currentSum + nums[startIndex] > target? // 該元素已使用或超過目標和  \n      Yes → Step 10: return dfs(startIndex + 1, remainingK, currentSum) // 跳過此元素，繼續搜尋  \n      No  → Step 11: visited[startIndex] = true // 選擇此元素加入當前子集  \n       → Step 12: If dfs(startIndex + 1, remainingK, currentSum + nums[startIndex]) return true // 繼續搜尋，若成功則直接返回  \n       → Step 13: visited[startIndex] = false // 回溯，撤銷選擇  \n       → Step 14: return false // 該路徑失敗，回溯到上一層  \n→ Step 15: return dfs(0, k, 0) // 從第一個元素開始，尋找 k 個子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canPartitionKSubsets(self, nums, k):\n        total = sum(nums)\n        if total % k != 0:\n            return False\n        target = total // k\n        nums.sort(reverse=True)\n        n = len(nums)\n\n        # 若最大數超過目標和，直接失敗\n        if nums[0] > target:\n            return False\n\n        used = [False] * n\n\n        def dfs(start, curr_sum, remaining_k):\n            if remaining_k == 0:\n                return True\n            if curr_sum == target:\n                # 現有子集已滿，開始下一個子集\n                return dfs(0, 0, remaining_k - 1)\n\n            prev = -1  # 用於跳過相同數字的重複搜索\n            for i in range(start, n):\n                if used[i]:\n                    continue\n                if curr_sum + nums[i] > target:\n                    continue\n                if nums[i] == prev:\n                    continue\n\n                used[i] = True\n                if dfs(i + 1, curr_sum + nums[i], remaining_k):\n                    return True\n                used[i] = False\n                prev = nums[i]\n\n                # 若此子集的首個數字就無法成功，直接剪枝\n                if curr_sum == 0:\n                    return False\n            return False\n\n        return dfs(0, 0, k)\n\ndef parse_input(text: str):\n    \"\"\"從輸入文字解析出 nums 列表和 k 整數。\"\"\"\n    # 先嘗試尋找 'k = ...' 的形式\n    m_k = re.search(r'k\\s*=\\s*(-?\\d+)', text)\n    if m_k:\n        k = int(m_k.group(1))\n        before_k = text[:m_k.start()]\n\n        # 取得 nums 部分\n        m_nums = re.search(r'nums\\s*=\\s*(\\[.*?\\])', before_k, re.S)\n        if m_nums:\n            nums = eval(m_nums.group(1), {\"__builtins__\": None})\n        else:\n            nums = list(map(int, re.findall(r'-?\\d+', before_k)))\n    else:\n        # 沒有 'k ='，假設第二行是 k\n        parts = text.strip().splitlines()\n        if len(parts) >= 2:\n            nums = list(map(int, re.findall(r'-?\\d+', parts[0])))\n            k = int(re.findall(r'-?\\d+', parts[1])[0])\n        else:\n            # 只有一行，最後一個數字是 k\n            all_nums = list(map(int, re.findall(r'-?\\d+', text)))\n            k = all_nums[-1]\n            nums = all_nums[:-1]\n    return nums, k\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    nums, k = parse_input(data)\n    solution = Solution()\n    result = solution.canPartitionKSubsets(nums, k)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,3,5,2,1], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode740.json",
    "problem_index_in_file": 0,
    "title": "Delete and Earn",
    "description_snippet": "You are given an integer array nums. You want to maximize the number of points you get by performing...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code solution for LeetCode \"Delete and Earn\" problem. We should provide step-by-step virtual code. Each line with arrow arrow etc. Provide explanation. Use structure Start, End, Decision. It's dynamic programming: sort or use freq array. Virtual code: compute freq, maxVal. Then iterate over values from 0 to maxVal computing dp[i] = max(dp[i-1], dp[i-2] + i * freq[i]). Provide explanation.\n\nWe need to produce each line with \"→\" arrow. Might need indentation. We'll produce a flow.\n\nProbably:\n\nStart\n→ Step 1: Initialize frequency map // Count occurrences of each number\n→ Step 2: Determine maxVal // Find maximum number in array\n→ Step 3: Create dp array of size maxVal+1 // dp[i] max points up to value i\n→ Step 4: Set dp[0] = 0 // Base case\n→ Decision: If maxVal >= 1?\n    Yes → Step 5: dp[1] = 1 * freq[1] // Base case for value 1\n    No  → End\n→ For i from 2 to maxVal:\n    → Step 6: Compute take = i * freq[i] + dp[i-2] // Take current number\n    → Step 7: Compute skip = dp[i-1] // Skip current number\n    → Step 8: dp[i] = max(take, skip) // Choose best\n→ Step 9: Return dp[maxVal] // Max points\nEnd\n\nBut need virtual code style: \"Step X: ...\" etc. Provide explanation after //.\n\nAlso use arrows: \"→\" before each line. Indentation with spaces? Use 4 spaces indent for nested? Provide decision indentation.\n\nWe'll output accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 frequency map // 建立一個 map，統計每個數字出現的次數  \n→ Step 2: 確定最大值 maxVal // 找出陣列中最大的數字，用於後續迭代  \n→ Step 3: 建立 dp 陣列長度為 maxVal+1 // dp[i] 代表在考慮到 0~i 時，能取得的最大點數  \n→ Step 4: dp[0] = 0 // 0 沒有數字時點數為 0  \n→ Decision: maxVal 是否大於等於 1? // 判斷是否需要處理數字 1 的基礎情況  \n  Yes → Step 5: dp[1] = 1 * frequency[1] // 若存在數字 1，直接取得其所有點數  \n  No → End // 若最大值 < 1，直接結束，結果為 0  \n→ Decision: 是否需要執行從 2 開始的迴圈？ // 判斷 maxVal 是否大於等於 2  \n  Yes → For i from 2 to maxVal:  \n    → Step 6: compute take = i * frequency[i] + dp[i-2] // 若選擇刪除 i，則需加上前 i-2 的最佳點數  \n    → Step 7: compute skip = dp[i-1] // 若不選擇 i，直接使用前 i-1 的最佳點數  \n    → Step 8: dp[i] = max(take, skip) // 取兩種方案中的較大值  \n    End For  \n  No → // maxVal 為 1 時已在第 5 步處理完畢  \n→ Step 9: Return dp[maxVal] // 回傳在考慮所有數字時能取得的最大點數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef delete_and_earn(nums):\n    \"\"\"Return the maximum points that can be earned from the list `nums`.\"\"\"\n    if not nums:                      # 空陣列時直接返回 0\n        return 0\n\n    count = Counter(nums)             # 統計每個數字出現的次數\n    max_num = max(nums)               # 最大數字，用於 DP 陣列長度\n\n    # dp[i] 表示在考慮到 0~i 時能取得的最大點數\n    dp = [0] * (max_num + 1)\n    dp[1] = count.get(1, 0) * 1       # 基礎情況：只有數字 1 時的點數\n\n    for i in range(2, max_num + 1):\n        take = i * count.get(i, 0) + dp[i - 2]   # 刪除 i 時加上 dp[i-2]\n        skip = dp[i - 1]                        # 不刪除 i，直接使用 dp[i-1]\n        dp[i] = max(take, skip)                 # 選擇較佳方案\n\n    return dp[max_num]                     # 回傳最終答案\n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，並將其轉成 Python list\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    nums = ast.literal_eval(data)\n\n    result = delete_and_earn(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "[2,2,3,3,3,4]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode66.json",
    "problem_index_in_file": 0,
    "title": "Plus One",
    "description_snippet": "You are given a large integer represented as an integer array digits, where each digits[i] is the it...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, line by line, with \"虛擬碼步驟\" and \"// 解釋/說明\". Use Start, End, Decision, arrows.\n\nTask: \"You are given a large integer represented as an integer array digits ... Increment by one return array\".\n\nWe need pseudocode steps.\n\nWe will create steps: Start, Step: let i = len(digits)-1, Step: carry=1, loop while i>=0 and carry==1, add carry to digits[i], compute new digit and carry. Update digits[i], decrement i. After loop if carry==1, insert 1 at front. Return digits. End.\n\nWe need arrow syntax: \"→\" for step lines. \"Decision:\" for conditional. \"Yes →\", \"No →\". Indent with four spaces? Use as example.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 i = digits.length - 1 // 指向最右邊的位數\n→ Step 2: 設定 carry = 1 // 初始進位為 1（即加 1）\n→ Decision: i >= 0 AND carry == 1? // 判斷是否還有位需要處理\n    Yes → Step 3: digits[i] = digits[i] + carry // 將進位加到當前位\n    Yes → Step 4: carry = digits[i] // 取得新進位（0 或 1）\n    Yes → Step 5: digits[i] = digits[i] % 10 // 把位數限制在 0-9\n    Yes → Step 6: i = i - 1 // 移動到更高位\n    No  → Step 7: If carry == 1? // 處理最左邊仍有進位的情況\n        Yes → Step 8: 在 digits 前插入 1 // 新增最高位\n        No  → // 不需要插入，已處理完\n→ End // 程式執行結束\n\nNeed \"Step 7\" maybe not needed; but we can restructure: After loop exit, check if carry==1 then insert.\n\nWe need to use Decision for the loop condition, but pseudocode may use loop construct: while. But example uses Decision. We'll produce.\n\nWe need to keep each line as single \"虛擬碼步驟\" plus comment. For indentation maybe use spaces.\n\nWe must include \"Start\" and \"End\".\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 i = digits.length - 1 // 指向數字陣列最右邊的位元  \n→ Step 2: 設定 carry = 1 // 初始進位值（即加 1）  \n→ Decision: i >= 0 AND carry == 1? // 判斷還有位需要處理  \n    Yes → Step 3: digits[i] = digits[i] + carry // 將進位加到當前位  \n    Yes → Step 4: carry = digits[i] // 取得加法後的進位（0 或 1）  \n    Yes → Step 5: digits[i] = digits[i] % 10 // 保留單一位數 0~9  \n    Yes → Step 6: i = i - 1 // 移動到更高一位  \n    No  → // 進位已結束或已到最左位  \n→ Decision: carry == 1? // 最左位仍有進位？  \n    Yes → Step 7: 在 digits 前插入 1 // 新增最高位 1  \n    No  → // 無進位，直接返回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        Increment the integer represented by the list of digits by one.\n        :param digits: List[int]\n        :return: List[int]\n        \"\"\"\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    # Find the part after '=' which should be the list of digits\n    parts = input_data.split('=', 1)\n    if len(parts) == 2:\n        digits_str = parts[1].strip()\n    else:\n        digits_str = input_data\n\n    # Safely evaluate the list string into a Python list\n    try:\n        digits = ast.literal_eval(digits_str)\n        if not isinstance(digits, list):\n            raise ValueError\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    # Compute the result\n    result = Solution().plusOne(digits)\n\n    # Output the result list\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "digits = [1,2,3]",
          "expected_output": "[1,2,4]",
          "success": true,
          "output": "[1, 2, 4]"
        },
        {
          "example_index": 1,
          "input": "digits = [4,3,2,1]",
          "expected_output": "[4,3,2,2]",
          "success": true,
          "output": "[4, 3, 2, 2]"
        },
        {
          "example_index": 2,
          "input": "digits = [9]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode646.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Pair Chain",
    "description_snippet": "You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.\n\nA pair...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: longest chain of pairs (like maximum chain length, similar to Longest Chain problem, DP). Provide steps line by line with explanation. Not actual code. Use Start, End, Decision, arrows. So produce pseudocode. Steps: sort pairs by right ascending, iterate, dynamic programming: dp[i] length ending at i, for each i compute max over previous j where pairs[j][1] < pairs[i][0]. Or use greedy: longest chain equals longest increasing subsequence after sorting by right. Actually classic solution: sort by right, then greedily pick next pair with left > last chosen right, yields maximum chain length. But they might expect DP. We'll produce algorithm with sorting and DP. Provide explanation each line. Use arrow lines.\n\nLet's craft:\n\nStart\n→ Step 1: Sort pairs by right ascending // ensure increasing order of right endpoints\n→ Step 2: Initialize dp array of size n with 1 // each pair can start a chain of length 1\n→ Step 3: For i from 0 to n-1 // iterate over each pair as potential end\n    → Step 4: For j from 0 to i-1 // check earlier pairs\n        → Decision: If pairs[j].right < pairs[i].left? // can follow j\n            Yes → Step 5: dp[i] = max(dp[i], dp[j] + 1) // extend chain\n            No  → // do nothing\n→ Step 6: Return max value in dp // longest chain length\nEnd\n\nWe should include comments. Use correct arrow formatting. Add spaces. Provide explanation after each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort pairs by right ascending // 先依右端點遞增排序，方便後續判斷可否連接  \n→ Step 2: Initialize dp array of size n with 1 // dp[i] 表示以第 i 個 pair 為結尾的最大鏈長度，起始為 1  \n→ Step 3: For i from 0 to n-1 // 逐一將每個 pair 當作鏈的結尾  \n    → Step 4: For j from 0 to i-1 // 檢查所有前面的 pair  \n        → Decision: If pairs[j].right < pairs[i].left? // 能否在 j 後面接 i  \n            Yes → Step 5: dp[i] = max(dp[i], dp[j] + 1) // 若可連接，更新 dp[i] 為更長的鏈長度  \n            No  → // 無法連接，保持 dp[i] 不變  \n→ Step 6: Return max value in dp // 回傳 dp 中最大的鏈長度，即答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_longest_chain(pairs):\n    # 依右端點遞增排序\n    pairs.sort(key=lambda x: x[1])\n    curr = -float(\"inf\")  # 目前已選擇的 pair 的右端點\n    count = 0            # 目前形成的鏈長度\n    for a, b in pairs:\n        if a > curr:     # 能否接在前一個 pair 後面\n            curr = b\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 取得列表字串（忽略 'pairs = ' 等前綴）\n    idx = raw_input.find('[')\n    list_str = raw_input[idx:] if idx != -1 else raw_input\n\n    # 安全地解析為 Python 資料結構\n    try:\n        pairs = ast.literal_eval(list_str)\n    except Exception:\n        pairs = []\n\n    # 計算並輸出結果\n    print(find_longest_chain(pairs))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pairs = [[1,2],[2,3],[3,4]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "pairs = [[1,2],[7,8],[4,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode472.json",
    "problem_index_in_file": 0,
    "title": "Concatenated Words",
    "description_snippet": "Given an array of strings words (without duplicates), return all the concatenated words in the given...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code algorithm to find concatenated words in list. Use trie or DP. We'll produce steps: Build set, iterate words sorted by length, for each word use DP to check if can be formed by shorter words. Use recursion with memo. Provide steps line by line with explanation.\n\nWe need to output in requested format.\n\nLet's craft:\n\nStart\n→ Build trie or hash set of words\n→ Sort words by length ascending\n→ For each word in sorted list:\n    → If can form by other words? use DP\n        → If true: add to result\n    → Add word to set/trie for later usage\n→ Return result\nEnd\n\nNeed to detail DP step: Use boolean array dp[0..len]. dp[0] = true. For i from 1..len: for j from 0..i-1: if dp[j] and substring j..i in set: dp[i] = true break. At end dp[len] true and word count >1? We ensure at least two words by requiring that during DP we exclude whole word? Since sorted, shorter words available.\n\nBut we might have to handle case where word itself in set, but we exclude using itself? Since we add after processing. So okay.\n\nLet's produce virtual code lines.\n\nUse Decision nodes: Decision: Can word be formed? Yes → add to result.\n\nWe'll include loop etc.\n\nMake sure each line is \"虛擬碼步驟 // 解釋\" format. Use arrows.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 wordsSet 用於儲存已處理的單字 // 方便快速查詢  \n→ Step 2: 將輸入陣列 words 依字長升序排序 // 確保短字先被加入集合  \n→ Step 3: 建立空列表 result 用於存放連接詞  \n→ Step 4: 迭代每個單字 word 於 sortedWords  \n  → Decision: 能否用已處理的單字組成 word? // 判斷是否為連接詞  \n    Yes → Step 5: 將 word 加入 result // 確認是連接詞  \n    No  → // 不是連接詞，略過  \n  → Step 6: 將 word 加入 wordsSet // 為後續字提供構造基礎  \n→ Step 7: 回傳 result // 結果輸出  \nEnd // 程式執行結束  \n\n// ---------- 下面為「能否用已處理的單字組成 word」的虛擬碼 ----------\n\nDecision: 用已處理的單字能組成 word? // 判斷邏輯  \n  → Step 8: 初始化布林陣列 dp，長度 = len(word)+1，dp[0] = true // dp[i] 表示前 i 個字可被組成  \n  → Step 9: 從 i=1 到 len(word) 逐步判斷  \n    → Step 10: 針對每個 j 從 0 到 i-1  \n      → Decision: dp[j] 為 true 且 word[j:i] 存於 wordsSet? // 子字串可被組成且已知  \n        Yes → Step 11: dp[i] = true；跳出 j 迴圈 // 找到一個合法拆分  \n        No → // 續檢下一個 j  \n    → Step 12: 判斷 dp[len(word)] 是否為 true且至少兩個字已被使用 // 至少兩個子字  \n      Decision: dp[len(word)] 且拆分數 ≥2?  \n        Yes → 返回 true // 可組成連接詞  \n        No  → 返回 false // 無法組成  \n  → End // 完成判斷邏輯  \n\n// ---------- 以上為完整的虛擬碼流程說明 ----------",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        word_set = set(words)\n        memo = {}\n\n        def canForm(word):\n            if word in memo:\n                return memo[word]\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in word_set:\n                    if suffix in word_set or canForm(suffix):\n                        memo[word] = True\n                        return True\n            memo[word] = False\n            return False\n\n        result = []\n        for word in words:\n            if not word:\n                continue\n            word_set.remove(word)\n            if canForm(word):\n                result.append(word)\n            word_set.add(word)\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 支援 \"words = [...]\" 或直接傳入列表字串\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw_input\n\n    try:\n        words = ast.literal_eval(expr)\n    except Exception:\n        # 若無法解析，輸出空列表\n        print(json.dumps([]))\n        sys.exit(0)\n\n    solution = Solution()\n    concatenated_words = solution.findAllConcatenatedWordsInADict(words)\n\n    # 使用 json.dumps 以符合示例的雙引號格式輸出\n    print(json.dumps(concatenated_words))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "success": true,
          "output": "[\"catsdogcats\", \"dogcatsdog\", \"ratcatdogcat\"]"
        },
        {
          "example_index": 1,
          "input": "words = [\"cat\",\"dog\",\"catdog\"]",
          "expected_output": "[\"catdog\"]",
          "success": true,
          "output": "[\"catdog\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode341.json",
    "problem_index_in_file": 0,
    "title": "Flatten Nested List Iterator",
    "description_snippet": "You are given a nested list of integers nestedList. Each element is either an integer or a list whos...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing a NestedIterator class in a generic language. Provide step-by-step algorithm: use stack, push elements reversed, etc. Include virtual code with arrows, decisions.\n\nWe produce line-by-line virtual code steps: Start, constructor, next, hasNext, end.\n\nExplain each line.\n\nLet's craft.\n\nNeed to be in Traditional Chinese.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 NestedIterator 類別，內部擁有 stack 以儲存待處理的 NestedInteger // 建立迭代器類別與資料結構  \n→ Step 2: 定義 Constructor: NestedIterator(List<NestedInteger> nestedList) // 初始化方法  \n→ Decision: 若 nestedList 為空? // 檢查輸入是否為空  \n  Yes → Step 3: stack = 空堆疊 // 若無元素，直接初始化為空  \n  No  → Step 4: 反向遍歷 nestedList，對每個元素執行 PushOntoStack // 逆序入堆疊以保持正確順序  \n→ Step 5: Define PushOntoStack(item)  \n  Decision: 如果 item 是 integer? // 判斷項目類型  \n   Yes → stack.push(item) // 直接推入堆疊  \n   No  → 反向遍歷 item.getList()，對每個子項目執行 PushOntoStack // 針對子列表遞迴入堆疊  \n→ Step 6: 定義 hasNext()  \n  Decision: 若 stack 為空? // 檢查堆疊是否為空  \n   Yes → return false // 無更多整數  \n   No  → Decision: 若 stack.peek() 是 integer? // 檢查頂端是否為整數  \n    Yes → return true // 可取得下一個整數  \n    No  → 取出頂端子列表，對其元素進行 PushOntoStack(reversed) // 展開子列表，並繼續判斷  \n     返回 hasNext() // 重新檢查堆疊狀態  \n→ Step 7: 定義 next()  \n  Decision: 若 hasNext() 為 false? // 確保還有整數可取  \n   Yes → throw NoSuchElementException // 沒有更多元素時拋例外  \n   No  → return stack.pop().getInteger() // 取出並返回整數  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass NestedIterator:\n    \"\"\"\n    迭代器：將巢狀列表展平成單層整數序列。\n    內部使用棧 (stack) 來維護待處理的元素，確保回傳順序正確。\n    \"\"\"\n    def __init__(self, nestedList):\n        # 把整個巢狀結構倒序推入棧，這樣 pop() 時可以按原始順序取出\n        self.stack = []\n        for item in reversed(nestedList):\n            self.stack.append(item)\n\n    def next(self):\n        \"\"\"\n        取得下一個整數。前置條件：必須先呼叫 hasNext() 確認有元素。\n        \"\"\"\n        return self.stack.pop()\n\n    def hasNext(self):\n        \"\"\"\n        檢查是否還有整數可以取出。若棧頂為整數直接回傳 True，\n        若為子列表則展開並將子列表元素倒序推入棧，再重新判斷。\n        \"\"\"\n        while self.stack:\n            top = self.stack[-1]\n            if isinstance(top, int):\n                return True\n            # top 為列表，展開\n            self.stack.pop()\n            for item in reversed(top):\n                self.stack.append(item)\n        return False\n\n\ndef main():\n    \"\"\"\n    主函式：從標準輸入讀取巢狀列表，使用 NestedIterator 取得平坦化結果並輸出。\n    支援輸入格式：\n      nestedList = [[1,1],2,[1,1]]\n      [[1,1],2,[1,1]]\n      nestedList = [1,[4,[6]]]\n      [1,[4,[6]]]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取等號右側的表達式，若沒有等號則直接把整行作為表達式\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # 以安全方式解析 Python 表達式得到巢狀列表\n    nestedList = ast.literal_eval(expr)\n\n    iterator = NestedIterator(nestedList)\n    result = []\n\n    while iterator.hasNext():\n        result.append(iterator.next())\n\n    # 輸出結果，保持與範例相同的列表表示法\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nestedList = [[1,1],2,[1,1]]",
          "expected_output": "[1,1,2,1,1]",
          "success": true,
          "output": "[1, 1, 2, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "nestedList = [1,[4,[6]]]",
          "expected_output": "[1,4,6]",
          "success": true,
          "output": "[1, 4, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode485.json",
    "problem_index_in_file": 0,
    "title": "Max Consecutive Ones",
    "description_snippet": "Given a binary array nums, return the maximum number of consecutive 1's in the array....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. It's a typical problem: given binary array, find longest consecutive 1's. We need to produce line-by-line virtual code with comments.\n\nWe should use Start, → Step X: etc. Provide decisions and loops. We need to ensure each line is a step. We don't output actual code, just pseudo.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize currentCount = 0, maxCount = 0 // counter for current streak and maximum streak\n→ Step 2: For each num in nums // iterate through array\n    → Decision: 如果 num 等於 1? // check if current element is 1\n        Yes → Step 3: currentCount = currentCount + 1 // increment current streak\n        No  → Step 4: maxCount = max(maxCount, currentCount) // update max before resetting\n            → Step 5: currentCount = 0 // reset streak\n→ Step 6: 後置：maxCount = max(maxCount, currentCount) // after loop, account for trailing 1's\n→ Step 7: return maxCount // output result\nEnd\n\nWe need to add comments for each line. Also use the arrow \"→\". We need to produce \"Decision:\" lines and \"Yes →\", \"No →\". For loops we might need \"→ Loop: For each num in nums\". But keep simple.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 currentCount = 0, maxCount = 0 // 用來計算目前連續 1 的數量與最大值  \n→ Step 2: 循環遍歷 nums 中的每個元素 num // 逐個檢查每個位元  \n    → Decision: 如果 num 等於 1? // 判斷目前元素是否為 1  \n        Yes → Step 3: currentCount = currentCount + 1 // 連續 1 的計數加一  \n        No  → Step 4: maxCount = max(maxCount, currentCount) // 更新最大值並在遇到 0 時重置計數  \n            → Step 5: currentCount = 0 // 連續 1 結束，重置為 0  \n→ Step 6: 循環結束後再執行 maxCount = max(maxCount, currentCount) // 處理結尾可能連續的 1  \n→ Step 7: 回傳 maxCount // 回傳最大的連續 1 的數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_max_consecutive_ones(nums):\n    \"\"\"\n    計算二元陣列中最大連續 1 的長度。\n    \"\"\"\n    max_count = 0\n    count = 0\n    for num in nums:\n        if num == 1:\n            count += 1\n            max_count = max(max_count, count)\n        else:\n            count = 0\n    return max_count\n\ndef parse_input(input_str):\n    \"\"\"\n    從輸入字串中提取列表。預期格式如：\n    nums = [1,1,0,1,1,1]\n    \"\"\"\n    # 尋找 '=' 符號並取得其右側的內容\n    if '=' in input_str:\n        _, rhs = input_str.split('=', 1)\n    else:\n        rhs = input_str\n    rhs = rhs.strip()\n    # 使用 literal_eval 以安全方式解析成 Python 對象\n    try:\n        nums = ast.literal_eval(rhs)\n    except Exception:\n        # 如果解析失敗，返回空列表\n        nums = []\n    return nums\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 允許多行輸入，每行可能是 'nums = [...]'\n    total_result = None\n    for line in raw_input.splitlines():\n        if not line.strip():\n            continue\n        nums = parse_input(line)\n        if not isinstance(nums, list):\n            continue\n        result = find_max_consecutive_ones(nums)\n        # 只輸出最後一行的結果，若有多行則覆蓋\n        total_result = result\n\n    if total_result is not None:\n        print(total_result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,0,1,1,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode453.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for problem: given integer array, min moves to equalize by incrementing n-1 elements by 1 each move. Classic problem: Equivalent to decrementing one element by 1 each move; min moves = sum(nums) - n*min(nums). So algorithm: find min, compute sum, return sum - n*min. Steps: Input array, compute n, min, sum, compute moves, output. Provide virtual code with arrows and decisions.\n\nWe must produce line by line: Start, → Step etc. Provide explanation after //.\n\nWe must not output actual code. Just virtual steps. Use Decision if needed. Not many decisions. Possibly decision: if array empty? But input size n; assume n>0.\n\nWe produce:\n\nStart // program starts\n→ Step 1: read array nums // get input array\n→ Step 2: compute n = length of nums // number of elements\n→ Decision: if n == 0? // handle empty case\n    Yes → Step 3: output 0 // no moves needed\n    No  → Step 4: find min_val = minimum(nums) // smallest element\n        → Step 5: compute total_sum = sum(nums) // sum of all elements\n            → Step 6: compute moves = total_sum - n * min_val // formula\n                → Step 7: output moves // result\nEnd\n\nNeed to maintain format: each line includes step, arrow, comment.\n\nLet's format lines with indentation for decision branches: Use tab or spaces? Provide indentation. Use arrow before each step. Use Decision with Yes →, No →. Provide explanation after //. The arrow symbol for decision branches: Indent.\n\nMake sure to include \"Start\" and \"End\" lines without arrow? In example, Start and End not preceded by arrow. But decision uses arrow. Use \"Start\" at beginning. Then \"→ Step...\" lines. For Decision, write \"Decision: ...\" line and then \"Yes → ...\" lines indented.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: read array nums // 取得輸入的整數陣列  \n→ Step 2: compute n = length of nums // 取得陣列長度  \n→ Decision: n == 0? // 檢查陣列是否為空  \n Yes → Step 3: output 0 // 空陣列不需要任何移動  \n No  → Step 4: find min_val = minimum(nums) // 找出最小值  \n  → Step 5: compute total_sum = sum(nums) // 計算所有元素總和  \n   → Step 6: compute moves = total_sum - n * min_val // 公式：總和減去 n 倍最小值  \n    → Step 7: output moves // 輸出最小移動次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef min_moves(nums):\n    \"\"\"\n    依照題意：每次可將 n-1 個元素加 1，等價於每次減少 1 個元素。\n    最小步數等於所有元素總和減去 n 倍的最小值。\n    \"\"\"\n    return sum(nums) - min(nums) * len(nums)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析出方括號內的數字列表\n    match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not match:\n        # 如果沒有找到方括號，直接嘗試使用 eval\n        try:\n            nums = ast.literal_eval(data)\n            if not isinstance(nums, (list, tuple)):\n                raise ValueError\n        except Exception:\n            raise ValueError(\"輸入格式不正確，無法解析為數字列表\")\n    else:\n        nums_str = match.group(1)\n        # 可能存在空格，先去除空格\n        nums_str = nums_str.replace(' ', '')\n        if nums_str:\n            nums = [int(x) for x in nums_str.split(',')]\n        else:\n            nums = []\n\n    # 計算並輸出結果\n    result = min_moves(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode225.json",
    "problem_index_in_file": 0,
    "title": "Implement Stack using Queues",
    "description_snippet": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should suppo...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The task: Implement LIFO stack using two queues. Provide steps for push, pop, top, empty. Use virtual code lines. Must follow format: \"Start // 程式開始執行\" etc. Provide arrow lines. Use only queue operations.\n\nWe need to design algorithm. Two common ways: (1) Use one queue as main, another as helper during push to keep order. (2) Use one queue as main, maintain size, push new element to helper, move all others, then swap.\n\nSimplest: For push, enqueue x into queue2, then move all elements from queue1 to queue2, swap names. This way, queue1 always has elements in stack order: front is top.\n\nFor pop: dequeue from queue1.\n\nTop: peek front of queue1.\n\nEmpty: check if queue1 is empty.\n\nSo we need to write virtual code for class MyStack with init, push, pop, top, empty.\n\nAlso need to show start and end of program? The sample shows Start/End around algorithm but might just be demonstration of each method.\n\nWe can produce Start for initialization. Then each method is separate block? They want \"逐行\" produce lines. So we produce a sequence of steps that covers all functionalities, but maybe separate methods with comment.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: Initialize queue1 and queue2 // 兩個空隊列\n\n→ Method: push(x)\n\n    → Step 1.1: Enqueue x into queue2 // 將新元素放到輔助隊列\n    → Step 1.2: While queue1 not empty:\n        → Move front of queue1 to queue2 // 把舊元素移到輔助隊列\n    → Step 1.3: Swap queue1 and queue2 // 使queue1為新的堆疊\n\n→ Method: pop()\n\n    → Step 2.1: Dequeue from queue1 and store as result // 移除並返回頂部\n    → Step 2.2: Return result\n\n→ Method: top()\n\n    → Step 3.1: Peek front of queue1 // 取得頂部元素不移除\n    → Step 3.2: Return that value\n\n→ Method: empty()\n\n    → Step 4.1: Return whether queue1 is empty\n\nEnd // 程式結束\n\nBut we must follow exact format: each line \"虛擬碼步驟 [空格] // 解釋/說明\". And use arrow \"→\" and structure \"Decision:\" etc.\n\nSo we can do:\n\nStart // 程式開始執行\n→ Step: 初始化 queue1, queue2 // 兩個空隊列\n→ Method: push(x)\n    → Step: enqueue x into queue2 // 新元素放入輔助隊列\n    → Decision: queue1 不是空? // 檢查主隊列是否有元素\n        Yes → Step: 移動 queue1 前端到 queue2 // 把舊元素轉移\n        No  → // 不做任何事\n    → Step: 交換 queue1 與 queue2 // 讓 queue1 為堆疊\n→ Method: pop()\n    → Step: 從 queue1 前端出列並儲存為 result // 移除頂部\n    → Step: 回傳 result\n→ Method: top()\n    → Step: 取得 queue1 前端元素（peek） // 顯示頂部但不移除\n    → Step: 回傳該元素\n→ Method: empty()\n    → Step: 判斷 queue1 是否為空 // 回傳布林值\nEnd // 程式結束\n\nWe need to be careful about indentation? Not necessary but can use spaces. Each line separate.\n\nAlso for decision blocks, we should use \"Decision:\" line then \"Yes →\" or \"No →\". In sample they did indent with 4 spaces before the decision lines. We can mimic.\n\nLet's produce accordingly.\n\nAlso mention that all operations are standard queue ops.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 queue1, queue2 // 建立兩個空隊列  \n\n→ Method: push(x) // 將元素 x 推到堆疊頂部  \n    → Step: enqueue x into queue2 // 把新元素放進輔助隊列  \n    → Decision: queue1 是否為空? // 檢查主隊列是否有舊元素  \n        Yes → Step: 移動 queue1 前端元素至 queue2 // 把舊元素轉移到輔助隊列  \n        No  → // 主隊列已空，無需移動  \n    → Step: 交換 queue1 與 queue2 // 讓 queue1 為新的堆疊，queue2 清空  \n\n→ Method: pop() // 移除並返回堆疊頂部元素  \n    → Step: dequeue from queue1 並存為 result // 移除頂部元素  \n    → Step: return result // 回傳被移除的元素  \n\n→ Method: top() // 取得堆疊頂部元素但不移除  \n    → Step: peek front of queue1 // 查看前端元素  \n    → Step: return that value // 回傳頂部元素  \n\n→ Method: empty() // 判斷堆疊是否為空  \n    → Step: return queue1.isEmpty() // 回傳布林值  \n\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"LIFO stack implemented with two queues.\"\"\"\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        # Enqueue to auxiliary queue\n        self.q2.append(x)\n        # Move all elements from main queue to auxiliary\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        # Swap queues: q2 becomes the new main queue\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        # Front of q1 is the top of stack\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return not self.q1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Remove leading 'Input' keyword if present\n    if data.lower().startswith('input'):\n        data = data[data.find('['):]\n\n    # Wrap with brackets to parse as a list of two lists\n    try:\n        commands, args_list = ast.literal_eval('[' + data + ']')\n    except Exception:\n        print('[]')\n        return\n\n    # The first command is the class name; ignore it\n    commands = commands[1:]\n    stack = MyStack()\n    output = []\n\n    for cmd, arg in zip(commands, args_list):\n        if cmd == 'push':\n            stack.push(arg[0])\n            output.append('null')\n        elif cmd == 'pop':\n            output.append(str(stack.pop()))\n        elif cmd == 'top':\n            output.append(str(stack.top()))\n        elif cmd == 'empty':\n            output.append('false' if stack.empty() else 'true')\n        else:\n            # Unknown command: append null\n            output.append('null')\n\n    print('[' + ', '.join(output) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp3us2dv4n.py\", line 68, in <module>\n    main()\n  File \"/tmp/tmp3us2dv4n.py\", line 53, in main\n    stack.push(arg[0])\n               ~~~^^^\nIndexError: list index out of range"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode279.json",
    "problem_index_in_file": 0,
    "title": "Perfect Squares",
    "description_snippet": "Given an integer n, return the least number of perfect square numbers that sum to n.\n\nA perfect squa...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The algorithm: classic BFS or DP. Use DP: dp[i] minimal count. dp[0]=0. For i from1 to n: dp[i] = min(dp[i-j*j]+1). Complexity O(n*sqrt(n)). We'll produce steps. We'll start, input n, initialize array dp size n+1. For i=1 to n: set dp[i]=infinity. For i=1 to n: for j=1 while j*j<=i: dp[i] = min(dp[i], dp[i-j*j]+1). Finally output dp[n]. Use virtual steps. Use decision arrows? Might not need heavy decision but we can structure loops with arrows. Use Start, End. We'll use indentation to show loops? The example uses arrows for steps. We'll do:\n\nStart // start\n→ Step 1: 讀取 n // input integer\n→ Step 2: 建立 dp 陣列長度 n+1 // initialize dp array\n→ Step 3: 設 dp[0] = 0 // base case\n→ Decision: i 從 1 到 n? // loop outer\n    Yes → Step 4: 將 dp[i] 設為無窮大 // initial value\n    → Decision: j 從 1 到 sqrt(i)? // inner loop\n        Yes → Step 5: 若 i - j*j >= 0, 設 dp[i] = min(dp[i], dp[i - j*j] + 1) // update\n        No  → End of inner loop\n    → End of inner loop\n→ End of outer loop\n→ Step 6: 輸出 dp[n] // result\nEnd // finish\n\nBut need to format each line: \"Step 1: ... // explanation\". Use arrow for loops. They might want \"Decision: i <= n?\" etc. We can show each step. Use indentation? Not necessary but can use nested arrows.\n\nMake sure each line is unique. Provide explanation.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得輸入值\n→ Step 2: 建立長度為 n+1 的整數陣列 dp // 用來儲存最小個數\n→ Step 3: 設 dp[0] = 0 // 基礎情況，0 需要 0 個平方數\n→ Decision: i = 1 to n? // 開始外層迴圈\n    Yes → Step 4: 將 dp[i] 設為無窮大 // 初始值\n    → Decision: j = 1 to floor(sqrt(i))? // 開始內層迴圈\n        Yes → Step 5: 計算 remain = i - j*j // 可用的剩餘數\n        → Decision: remain >= 0? // 檢查剩餘是否有效\n            Yes → Step 6: dp[i] = min(dp[i], dp[remain] + 1) // 更新最小值\n            No  → // 不需處理\n        No  → // 跳出內層迴圈\n    → End of inner loop\n→ End of outer loop\n→ Step 7: 輸出 dp[n] // 結果\nEnd // 程式執行結束\n\nWe need to ensure formatting consistent: \"Step X: ... // explanation\". Also for decisions we need \"Decision:\" lines with arrows and nested Yes/No. In the example, they used indentation inside. We'll follow similar.\n\nBut maybe we can streamline: Use Decision: i <= n? Yes → ... No → End of outer loop. But we need to indicate loop termination. Might not need explicit No. Use arrow from Decision to Step 4. Let's craft.\n\nBetter:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得輸入值\n→ Step 2: 建立 dp[0..n] 陣列 // 用於儲存最小平方數個數\n→ Step 3: dp[0] ← 0 // 基礎情況\n→ Decision: i = 1 to n? // 外層迴圈\n    Yes → Step 4: dp[i] ← +∞ // 初始化\n    → Decision: j = 1 while j*j ≤ i? // 內層迴圈\n        Yes → Step 5: rem ← i - j*j // 计算剩餘\n        → Decision: rem ≥ 0? // 判断合法\n            Yes → Step 6: dp[i] ← min(dp[i], dp[rem] + 1) // 更新\n            No  → // 無需處理\n        No  → // 結束內層迴圈\n    → End of inner loop\n→ End of outer loop\n→ Step 7: 輸出 dp[n] // 結果\nEnd // 程式執行結束\n\nBut \"Decision\" lines for loops should maybe use \"Decision: i ≤ n?\" with Yes → etc. Let's use simple. Each step on new line.\n\nWe might use \"→ Step 4: dp[i] ← +∞\" inside loop. Use indentation? Provide lines for loops.\n\nWe must ensure every line includes code and explanation.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得使用者輸入的目標數  \n→ Step 2: 建立 dp[0..n] 陣列 // 用於儲存每個數字最少需要的平方數個數  \n→ Step 3: dp[0] ← 0 // 基礎情況，0 需要 0 個平方數  \n→ Decision: i = 1 to n? // 開始外層迴圈，逐個計算 dp[i]  \n    Yes → Step 4: dp[i] ← +∞ // 初始化 dp[i] 為無窮大，待更新  \n    → Decision: j = 1 while j*j ≤ i? // 內層迴圈，枚舉所有平方數 j*j ≤ i  \n        Yes → Step 5: rem ← i - j*j // 計算剩餘部分 rem  \n        → Decision: rem ≥ 0? // 檢查剩餘是否有效  \n            Yes → Step 6: dp[i] ← min(dp[i], dp[rem] + 1) // 用 dp[rem] 加一更新最小值  \n            No  → // 若 rem 為負值，則不處理（實際不會發生）  \n        No  → // 內層迴圈結束，所有 j 都已檢查完畢  \n    → End of inner loop  \n→ End of outer loop  \n→ Step 7: 輸出 dp[n] // 顯示最小平方數個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_squares(n: int) -> int:\n    \"\"\"\n    Return the least number of perfect square numbers that sum to n.\n    \"\"\"\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n    return dp[n]\n\ndef main() -> None:\n    \"\"\"\n    Read an integer from standard input, compute the result,\n    and print it to standard output.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # Extract the first integer found (handles formats like \"n = 12\")\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n\n    result = num_squares(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 13",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode330.json",
    "problem_index_in_file": 0,
    "title": "Patching Array",
    "description_snippet": "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for problem: Given sorted array nums and integer n, add patches to array so that any number in [1,n] can be formed as sum of some elements. Minimum patches. Classic \"Patching Array\" Leetcode 330. Algorithm: maintain current reachable sum range [1, missing-1] where missing is first number that cannot be formed. Initialize missing=1, patches=0, i=0. While missing <= n: if i<nums.size and nums[i] <= missing: extend reachable to missing += nums[i], i++; else patch: missing += missing (add patch equal to missing), patches++.\n\nWe need produce virtual code line by line with explanation.\n\nAlso need to handle Start, End, Decision. Provide arrow.\n\nLet's generate steps:\n\nStart // 程式開始\n→ Step 1: 初始化 missing = 1, patches = 0, index = 0 // 設定可達範圍與指標\n→ Decision: missing <= n? // 判斷是否仍需覆蓋數字\n    Yes → Decision: index < nums.length AND nums[index] <= missing? // 檢查陣列元素是否可延伸可達範圍\n        Yes → Step 2: missing += nums[index] // 用現有元素擴大可達範圍\n                → Step 3: index++ // 移動到下一個陣列元素\n                → Decision: missing <= n? // 重新判斷是否結束\n                    ...\n        No → Step 4: missing += missing // 添加補丁，等於目前缺失值\n                → Step 5: patches++ // 記錄補丁數量\n                → Decision: missing <= n? // 重新判斷\n...\nFinally, End // 返回 patches\n\nBut need to format as per example: Use \"Start\" and \"End\". Use \"Decision:\" lines with Yes→, No→.\n\nWe need each line: \"虛擬碼步驟 // 解釋\".\n\nSo write like:\n\nStart // 程式開始執行\n→ Step 1: missing = 1, patches = 0, i = 0 // 初始化可達範圍與索引\n→ Decision: missing <= n? // 檢查是否還有未覆蓋的數字\n    Yes → Decision: i < nums.length AND nums[i] <= missing? // 判斷當前陣列元素是否能擴大範圍\n        Yes → Step 2: missing += nums[i] // 用 nums[i] 擴大可達範圍\n                → Step 3: i += 1 // 移動索引\n                → Decision: missing <= n? // 重新判斷\n                    Yes → … (loop)\n                    No → End // 完成\n        No → Step 4: missing += missing // 插入補丁\n                → Step 5: patches += 1 // 記錄補丁\n                → Decision: missing <= n? // 重新判斷\n                    Yes → … (loop)\n                    No → End\n\nBut need to avoid recursion; we can use a loop: while missing <= n: ... So maybe use a loop construct. But virtual code may represent loop as decision repeated. Might be easier: Use \"While\" step.\n\nBut example uses Decision loops. We'll implement as loop:\n\n→ Step 6: while missing <= n do\n    ...\nend while\n\nBut maybe use Decision and then Yes→, No→ with loop back. Let's attempt:\n\n→ Decision: missing <= n? // 是否仍需要補丁\n    Yes → Step 6: if i < nums.length AND nums[i] <= missing then\n                → Step 7: missing += nums[i]\n                → Step 8: i += 1\n                → Decision: missing <= n? // 繼續判斷\n                    Yes → (back to Decision)\n                    No → End\n            else\n                → Step 9: missing += missing\n                → Step 10: patches += 1\n                → Decision: missing <= n? // 繼續判斷\n                    Yes → (back to Decision)\n                    No → End\n\nBut this may be complex.\n\nSimpler: Represent loop as:\n\n→ Step 6: while missing <= n do\n    → Decision: i < nums.length AND nums[i] <= missing?\n        Yes → missing += nums[i]\n            → i += 1\n        No → missing += missing\n            → patches += 1\n    End while\n→ Step 7: return patches\n\nWe need to provide explanation after each line.\n\nWe also need to output line by line.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: missing = 1 // 目前能形成的最大連續範圍上限\n→ Step 2: patches = 0 // 已添加的補丁數量\n→ Step 3: i = 0 // 數組索引\n→ Decision: missing <= n? // 是否還有未覆蓋的數字\n    Yes → Step 4: if i < nums.length AND nums[i] <= missing then // 檢查是否能用當前數字擴大範圍\n        Yes → Step 5: missing += nums[i] // 用 nums[i] 擴大可達範圍\n            → Step 6: i += 1 // 移動到下一個數字\n        No → Step 7: missing += missing // 插入補丁，等於缺失值\n            → Step 8: patches += 1 // 記錄補丁數量\n    No → End // 結束循環\n→ Step 9: return patches // 回傳最小補丁數\n\nBut need to use arrow for step numbers, but not necessary. Format is \"虛擬碼步驟 // 解釋\". So each line has code plus comment.\n\nAlso use arrows \"→\". They want \"Start\", \"Decision:\", etc. We can write:\n\nStart // 程式開始\n→ Step 1: missing = 1 // 目前可達範圍上限\n→ Step 2: patches = 0 // 補丁計數\n→ Step 3: i = 0 // 數組指標\n→ Decision: missing <= n? // 是否還有未覆蓋的數字\n    Yes → Step 4: if i < nums.length AND nums[i] <= missing then // 可用數字擴充範圍\n        Yes → Step 5: missing += nums[i] // 以 nums[i] 擴張\n            → Step 6: i += 1 // 進行下一個\n        No → Step 7: missing += missing // 補丁，等於缺失值\n            → Step 8: patches += 1 // 補丁計數加一\n    No → End // 跳出循環\n→ Step 9: return patches // 回傳結果\n\nBut the \"Decision\" block's Yes and No branches need to loop back. The code above is not looping. To properly represent loop, we might need to include \"←\" to indicate loop back to decision. But requirement didn't mention loop back arrow; they just show arrow. But can include \"←\" to indicate return. However example didn't use loops, just nested decisions.\n\nBetter to use while loop as step: \"Step 4: while missing <= n do\" and inside.\n\nBut they asked to use arrows like →, Yes→, No→. They didn't mention while loops but we can use \"while\". But example didn't include while. Let's include while for clarity.\n\nLet's do:\n\nStart // 程式開始\n→ Step 1: missing = 1 // 目前可形成的最大連續數\n→ Step 2: patches = 0 // 補丁數量\n→ Step 3: i = 0 // 數組指標\n→ Step 4: while missing <= n do // 循環至覆蓋到 n\n    → Decision: i < nums.length AND nums[i] <= missing? // 能否使用現有元素擴大範圍\n        Yes → Step 5: missing += nums[i] // 用 nums[i] 擴張\n            → Step 6: i += 1 // 移動到下一個\n        No → Step 7: missing += missing // 插入補丁\n            → Step 8: patches += 1 // 補丁計數加一\n    → End while\n→ Step 9: return patches // 回傳最小補丁數\n\nWe need to label each line. The \"while\" and \"End while\" might be considered steps. Provide explanation.\n\nLet's produce final answer accordingly.\n\nEnsure each line contains arrow and comment. Use \"→\" before each line? Example shows \"→ Step 1:\" but not \"Start\". For Start, no arrow. Let's maintain consistent formatting.\n\nI'll produce:\n\nStart // 程式開始執行\n→ Step 1: missing = 1 // 目前能形成的最大連續範圍上限\n→ Step 2: patches = 0 // 已添加的補丁數量\n→ Step 3: i = 0 // 數組索引\n→ Step 4: while missing <= n do // 循環直到覆蓋到 n\n    → Decision: i < nums.length AND nums[i] <= missing? // 能否使用當前數字擴大可達範圍\n        Yes → Step 5: missing += nums[i] // 用 nums[i] 擴張可達範圍\n            → Step 6: i += 1 // 移動索引到下一個\n        No → Step 7: missing += missing // 插入補丁，等於缺失值\n            → Step 8: patches += 1 // 補丁計數加一\n    → End while\n→ Step 9: return patches // 回傳最小補丁數\n\nLet's output that.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: missing = 1 // 目前能形成的最大連續範圍上限  \n→ Step 2: patches = 0 // 已添加的補丁數量  \n→ Step 3: i = 0 // 數組索引  \n→ Step 4: while missing <= n do // 循環直到覆蓋到 n  \n  → Decision: i < nums.length AND nums[i] <= missing? // 能否使用當前數字擴大可達範圍  \n   Yes → Step 5: missing += nums[i] // 用 nums[i] 擴張可達範圍  \n    → Step 6: i += 1 // 移動索引到下一個  \n   No → Step 7: missing += missing // 插入補丁，等於缺失值  \n    → Step 8: patches += 1 // 補丁計數加一  \n  → End while  \n→ Step 9: return patches // 回傳最小補丁數",
      "generated_code": "import sys\nimport re\n\ndef min_patches(nums, n):\n    \"\"\"Return the minimum number of patches needed so that every number\n    in [1, n] can be represented as the sum of some elements from nums.\"\"\"\n    patches = 0\n    miss = 1          # The smallest number that cannot be formed yet\n    i = 0             # Index in nums\n\n    while miss <= n:\n        # If the current number can extend the reachable range, use it\n        if i < len(nums) and nums[i] <= miss:\n            miss += nums[i]\n            i += 1\n        # Otherwise, patch the missing value\n        else:\n            miss += miss\n            patches += 1\n    return patches\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract all integers (handles negative numbers if present)\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # Expect at least one number for n and at least one number for the array\n    if len(numbers) < 2:\n        print(0)\n    else:\n        # The last integer is n, the rest form the array\n        nums = numbers[:-1]\n        n = numbers[-1]\n        # Ensure nums is sorted as per problem statement\n        nums.sort()\n        result = min_patches(nums, n)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3], n = 6",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,10], n = 20",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,2], n = 5",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode210.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule II",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for topological sort (Kahn's algorithm) to find course ordering. Should handle cycle detection. Provide line by line steps. Format: \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc. Ensure each line has arrow.\n\nWe must not produce actual code but pseudo steps. We'll produce steps: Start, initialize adjacency list, indegree array, queue, etc. Use Decision for cycle detection at end: if result length equals numCourses.\n\nLet's craft lines:\n\nStart // start\n→ Step 1: 建立鄰接表與入度陣列 // create adjacency list and indegree\n→ Step 2: 迭代 prerequisites，更新鄰接表與入度 // process prerequisites\n→ Step 3: 初始化佇列，把所有入度為 0 的課程加入佇列 // queue initialization\n→ Step 4: 建立空的結果陣列 // result list\n→ Decision: 佇列是否為空? // check queue\n    Yes → End // no courses left\n    No → Step 5: 取出佇列頭部課程，加入結果陣列 // pop\n    → Step 6: 針對該課程的鄰接課程，入度減 1\n    → Decision: 鄰接課程入度是否為 0?\n        Yes → Step 7: 把鄰接課程加入佇列\n        No  → // do nothing\n    → Step 8: 回到 Decision: 佇列是否為空? // loop\n→ Decision: 結果長度是否等於 numCourses?\n    Yes → Step 9: 回傳結果陣列 // return order\n    No  → Step 10: 回傳空陣列 // impossible\n\nEnd\n\nWe need to output in that format. Ensure each line includes \"// 解釋\". Use \"Step X:\" lines. Use \"Decision:\" lines with indent? They did show indentation in sample: \"Decision: ...\". We can mimic.\n\nLet's write each line. Use arrows \"→\". Use \"Start\" line. Provide comments.\n\nWe need to maintain \"Step 1:\", \"Step 2:\", etc. Provide \"Decision:\" lines with nested \"Yes →\" and \"No →\". Provide \"End\". Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立鄰接表 (adj) 與入度陣列 (indeg) // 用於儲存課程關係與每門課的前置課程數量  \n→ Step 2: 迭代 prerequisites，對於每對 [a, b]  \n  → adj[b] 加入 a // b 必須先修完，才能修 a  \n  → indeg[a] 加 1 // a 的入度增加  \n→ Step 3: 初始化佇列 queue，將所有 indeg 為 0 的課程加入 queue // 無前置課程的課程先可修  \n→ Step 4: 建立空的結果陣列 order // 存放最終的課程順序  \n→ Decision: queue 是否為空? // 檢查是否還有可修的課程  \n  Yes → End // 佇列空，結束循環  \n  No → Step 5: 取出 queue 的頭部課程 cur，加入 order // 先修 cur  \n   → Step 6: 對於 cur 的每個鄰接課程 next in adj[cur]  \n    → indeg[next] 減 1 // 已修完一個前置課程  \n    → Decision: indeg[next] 是否為 0? // 是否已無剩餘前置課程  \n     Yes → Step 7: 把 next 加入 queue // 可修課程加入佇列  \n     No → // 留待其他前置課程完成後再入佇列  \n   → Step 8: 回到 Decision: queue 是否為空? // 繼續循環  \n→ Decision: order 的長度是否等於 numCourses? // 判斷是否已安排所有課程  \n  Yes → Step 9: 回傳 order // 成功取得課程順序  \n  No  → Step 10: 回傳空陣列 // 存在循環，無法完成所有課程  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        \n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n        \n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n        \n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return order if len(order) == numCourses else []\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract numCourses\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    numCourses = int(num_match.group(1)) if num_match else 0\n\n    # Extract prerequisites list\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*\\]\\])', data, re.S)\n    if pre_match:\n        pre_str = pre_match.group(1)\n    else:\n        pre_str = '[]'\n    prerequisites = ast.literal_eval(pre_str)\n\n    sol = Solution()\n    order = sol.findOrder(numCourses, prerequisites)\n    print(order)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "success": true,
          "output": "[0, 1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode516.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Subsequence",
    "description_snippet": "Given a string s, find the longest palindromic subsequence's length in s.\n\nA subsequence is a sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing longest palindromic subsequence length. Use DP. Steps: start, input string, length n, initialize DP table n x n with 0, fill base case: dp[i][i] = 1. Then for lengths from 2 to n: for i from 0 to n-len: j = i+len-1. If s[i]==s[j], dp[i][j] = dp[i+1][j-1] + 2; else dp[i][j] = max(dp[i+1][j], dp[i][j-1]). Finally output dp[0][n-1]. End.\n\nNeed to output each line as virtual code and explanation. Use arrow arrow. Each line with format \"虛擬碼步驟 // 解釋\". Use Start, End, Decision maybe not needed heavily.\n\nLet's produce step-by-step.\n\nEnsure each line: \"Start // 程式開始執行\". Then next lines: \"→ Step 1: 輸入字串 s // 從使用者取得輸入字串\". Then compute n. \"→ Step 2: 設定 n = 長度(s) // 取得字串長度\". Then create 2D array. \"→ Step 3: 建立 dp[n][n]，並初始化為 0 // 用來儲存子問題答案\". Then base case: \"→ Step 4: 對 i in 0..n-1: dp[i][i] = 1 // 單字元本身為回文子序列長度 1\". Then fill table by increasing substring length: \"→ Step 5: 對 subLen from 2 to n: // 逐漸考慮更長子字串\". Inside: \"→ Step 6: 對 i from 0 to n - subLen: // 確定子字串起點\". Then compute j. \"→ Step 7: 設定 j = i + subLen - 1 // 子字串終點\". Then decision: \"→ Decision: s[i] == s[j] ?\". Yes: \"Yes → Step 8: dp[i][j] = dp[i+1][j-1] + 2 // 若首尾相等，兩端各加 1\". No: \"No  → Step 9: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取子字串不包含首或尾的最大值\". After loops: \"→ Step 10: 輸出 dp[0][n-1] // 最長回文子序列長度\". \"End // 程式執行結束\".\n\nMake sure each line with virtual code then comment. Use arrow for indentation maybe. Use \"→\" as per format. Each line must have a space between virtual code and // comment.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者取得輸入字串  \n→ Step 2: 設定 n = 長度(s) // 取得字串長度  \n→ Step 3: 建立 dp[n][n]，並初始化為 0 // 用來儲存子問題答案  \n→ Step 4: 對 i in 0..n-1: dp[i][i] = 1 // 單字元本身為回文子序列長度 1  \n→ Step 5: 對 subLen from 2 to n: // 逐漸考慮更長子字串  \n    → Step 6: 對 i from 0 to n - subLen: // 確定子字串起點  \n        → Step 7: 設定 j = i + subLen - 1 // 子字串終點  \n        → Decision: s[i] == s[j] ?  \n            Yes → Step 8: dp[i][j] = dp[i+1][j-1] + 2 // 若首尾相等，兩端各加 1  \n            No  → Step 9: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取子字串不包含首或尾的最大值  \n→ Step 10: 輸出 dp[0][n-1] // 最長回文子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef longest_palindromic_subseq_length(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[i][j] will hold the length of the longest palindromic subsequence in s[i:j+1]\n    dp = [[0] * n for _ in range(n)]\n\n    # Fill dp table from bottom up\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1  # single character is always a palindrome of length 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\n\ndef main() -> None:\n    # Read the input string from stdin\n    s = sys.stdin.readline().strip()\n\n    # Remove surrounding double quotes if present (e.g., input like \"bbbab\")\n    if len(s) >= 2 and s[0] == '\"' and s[-1] == '\"':\n        s = s[1:-1]\n\n    result = longest_palindromic_subseq_length(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode4.json",
    "problem_index_in_file": 0,
    "title": "Median of Two Sorted Arrays",
    "description_snippet": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for median of two sorted arrays, O(log(m+n)) solution. Typically we do binary search on smaller array to find partition. We'll produce pseudo-code with steps, decisions, etc. Use virtual code arrows. Provide short explanations per line.\n\nWe need to ensure each line includes virtual code step then comment.\n\nWe'll start with Start, then Step: ensure nums1 smaller, else swap. Then define low, high. While low <= high. Compute partitionX, partitionY. Then get maxLeftX, minRightX, maxLeftY, minRightY. Decision: if maxLeftX <= minRightY && maxLeftY <= minRightX, we found correct partition. Then if total odd, median is min(minRightX, minRightY). Else median is average of max(maxLeftX, maxLeftY) and min(minRightX, minRightY). Then break or return. Else if maxLeftX > minRightY, move high. Else move low. End loop. End program.\n\nWe need to use virtual code arrows: \"→\". Decision with Yes → / No →. Use \"Decision:\".\n\nWe'll produce each line accordingly.\n\nWe need to avoid actual code but pseudocode. Use descriptive actions: \"Initialize low = 0\" etc.\n\nLet's create.\n\nAlso we must include \"Start // 程式開始執行\" etc.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 如果 nums1 長度 > nums2 長度, 交換 nums1 與 nums2 // 確保 nums1 為較短陣列  \n→ Step 2: 設定 low = 0, high = nums1.length // 初始化二分搜尋範圍  \n→ Decision: low ≤ high? // 判斷是否還有搜尋空間  \n    Yes → Step 3: partitionX = (low + high) / 2 // 取 nums1 的中點作為分割點  \n    → Step 4: partitionY = (nums1.length + nums2.length + 1) / 2 - partitionX // 計算 nums2 的對應分割點  \n    → Step 5: maxLeftX = (partitionX == 0) ? -∞ : nums1[partitionX - 1] // 左側最大值或負無窮  \n    → Step 6: minRightX = (partitionX == nums1.length) ? +∞ : nums1[partitionX] // 右側最小值或正無窮  \n    → Step 7: maxLeftY = (partitionY == 0) ? -∞ : nums2[partitionY - 1] // 左側最大值或負無窮  \n    → Step 8: minRightY = (partitionY == nums2.length) ? +∞ : nums2[partitionY] // 右側最小值或正無窮  \n    → Decision: maxLeftX ≤ minRightY && maxLeftY ≤ minRightX? // 檢查分割是否正確  \n        Yes → Decision: (nums1.length + nums2.length) % 2 == 1? // 整體長度奇偶判斷  \n            Yes → Step 9: median = min(minRightX, minRightY) // 奇數時取右側最小值  \n            No  → Step 10: median = (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2.0 // 偶數時取左右最大最小平均  \n        → End // 結束搜尋，輸出 median  \n        No  → Decision: maxLeftX > minRightY? // 如果 nums1 左側最大值太大  \n            Yes → Step 11: high = partitionX - 1 // 將搜尋範圍縮小到左側  \n            No  → Step 12: low = partitionX + 1 // 將搜尋範圍縮小到右側  \n    → End // 迴圈結束條件  \n    No → End // 迴圈結束條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # 確保 nums1 為較短陣列\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        total = m + n\n        half = total // 2\n\n        left, right = 0, m - 1\n        while True:\n            i = (left + right) // 2\n            j = half - i - 2\n\n            Aleft = nums1[i] if i >= 0 else float('-inf')\n            Aright = nums1[i + 1] if (i + 1) < m else float('inf')\n            Bleft = nums2[j] if j >= 0 else float('-inf')\n            Bright = nums2[j + 1] if (j + 1) < n else float('inf')\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0\n            elif Aleft > Bright:\n                right = i - 1\n            else:\n                left = i + 1\n\ndef parse_list(name: str, text: str) -> List[int]:\n    pattern = rf'{name}\\s*=\\s*\\[([^\\]]*)\\]'\n    match = re.search(pattern, text)\n    if not match:\n        return []\n    nums_str = match.group(1).strip()\n    if not nums_str:\n        return []\n    return [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums1 = parse_list('nums1', data)\n    nums2 = parse_list('nums2', data)\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "success": true,
          "output": "2.00000"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "expected_output": "2.50000",
          "success": true,
          "output": "2.50000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode201.json",
    "problem_index_in_file": 0,
    "title": "Bitwise AND of Numbers Range",
    "description_snippet": "Given two integers left and right that represent the range [left, right], return the bitwise AND of ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in steps: compute bitwise AND of all numbers between left and right inclusive. Standard solution: shift right until left == right, count shifts, then shift back. Or find common prefix. So steps: Start; input left, right; shiftCount=0; while left < right: left = left >> 1; right = right >> 1; shiftCount++ ; after loop; result = left << shiftCount; output result; End.\n\nProvide each line with virtual code arrow and comment. Use decision and arrows. Ensure use of Start, End, Decision. Provide step lines with arrow like \"→ Step 1: 讀取 left, right\" etc. Use Chinese comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取兩個整數 left, right // 取得區間起點與終點  \n→ Step 2: 初始化 shiftCount ← 0 // 記錄右移的位數  \n→ Decision: 是否 left < right? // 判斷區間是否還有多個數字  \n  Yes → Step 3: left ← left >> 1 // 把 left 右移一位  \n    right ← right >> 1 // 把 right 右移一位  \n    shiftCount ← shiftCount + 1 // 計數  \n    ← 回到 Decision: 是否 left < right? // 重複直到兩數相等  \n  No  → Step 4: result ← left << shiftCount // 把共同前綴左移回去  \n→ Step 5: 輸出 result // 給出區間內所有數字的位與結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef range_bitwise_and(left: int, right: int) -> int:\n    \"\"\"計算從 left 到 right（包含）所有數字的位與結果。\"\"\"\n    shift = 0\n    while left < right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取左、右邊界，輸出區間內所有數字的位與。\"\"\"\n    data = sys.stdin.read()\n    # 從輸入中提取所有整數\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) >= 2:\n        left, right = numbers[0], numbers[1]\n    elif len(numbers) == 1:\n        # 只給一個數字時，視為 left == right\n        left = right = numbers[0]\n    else:\n        # 沒有可用數字，直接退出\n        return\n    result = range_bitwise_and(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 5, right = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 0, right = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "left = 1, right = 2147483647",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode313.json",
    "problem_index_in_file": 0,
    "title": "Super Ugly Number",
    "description_snippet": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, explaining each. The algorithm: typical super ugly numbers: maintain array ugly[0..n-1], start with 1. Maintain indices for each prime in primes, and next multiple for each prime. For i from 1 to n-1, find min of next multiples, set ugly[i] = min. Then for each prime whose next multiple equals min, increment its index and compute new next multiple. At the end, return ugly[n-1].\n\nSo produce steps.\n\nWe need to use virtual code with arrows, decisions.\n\nLet's craft.\n\nStart\n→ Initialize array ugly[0..n-1] // allocate result array\n→ Set ugly[0] = 1 // first super ugly number\n\n→ Initialize indices array idx[0..len(primes)-1] = 0 // each prime index starts at 0\n→ Initialize next array nextVal[0..len(primes)-1] = primes // next multiple of each prime\n\n→ For i from 1 to n-1: // iterate to compute remaining ugly numbers\n    → Decision: compute minVal = minimum of nextVal // find smallest next candidate\n    → ugly[i] = minVal // set current ugly number\n\n    → Decision: For each j in 0..len(primes)-1: // update primes that contributed to minVal\n        → Decision: if nextVal[j] == minVal? // if prime j's next multiple equals minVal\n            → idx[j] += 1 // move index forward\n            → nextVal[j] = primes[j] * ugly[idx[j]] // compute new next multiple\n\n→ End // finish computation\n→ Return ugly[n-1] // nth super ugly number\n\nBut need each line as virtual code with explanation. Use Start, End, Decision. For loops, we can represent with Decision? Could use Decision: \"是否到達 n-1?\" but we can simply denote a loop with decision: \"i < n?\" etc.\n\nLet's format.\n\nWe'll produce:\n\nStart // 程式開始\n\n→ Initialize array ugly[0..n-1] // 建立儲存超醜數字的陣列\n→ ugly[0] = 1 // 第一個超醜數字為 1\n\n→ Initialize indices idx[0..k-1] = 0 // 每個質數的索引起始於 0\n→ Initialize nextVal[0..k-1] = primes // 每個質數的下一候選倍數\n\n→ Decision: i = 1 // 設定迴圈變數\n    → Decision: i < n? // 迴圈條件：尚未計算到第 n 個\n        → Step: minVal = min(nextVal) // 找出最小的下一候選\n        → ugly[i] = minVal // 目前的超醜數字\n        → Decision: j = 0 // 內部迴圈索引\n            → Decision: j < k? // 針對每個質數\n                → Decision: nextVal[j] == minVal? // 這個質數是否產生了 minVal\n                    → idx[j] += 1 // 移到下一個索引\n                    → nextVal[j] = primes[j] * ugly[idx[j]] // 更新下一候選\n                → j += 1 // 移動到下一個質數\n            → End // 結束內部迴圈\n        → i += 1 // 進入下一個位置\n    → End // 結束迴圈\n→ End // 程式執行結束\n→ Return ugly[n-1] // 傳回第 n 個超醜數字\n\nBut they want each line with \"虛擬碼步驟\" and \"// 解釋\". Use arrow for steps.\n\nMake sure to use `Decision:` for branching.\n\nWe need to maintain the arrow indentation.\n\nLet's produce final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Initialize array ugly[0..n-1] // 建立儲存超醜數字的陣列\n→ ugly[0] = 1 // 第一個超醜數字為 1\n→ Initialize indices idx[0..k-1] = 0 // 每個質數的索引起始於 0\n→ Initialize nextVal[0..k-1] = primes // 每個質數的下一候選倍數\n\n→ Decision: i = 1 // 設定迴圈變數\n    → Decision: i < n? // 迴圈條件：尚未計算到第 n 個\n        → Step: minVal = min(nextVal) // 找出最小的下一候選\n        → ugly[i] = minVal // 設定目前的超醜數字\n        → Decision: j = 0 // 內部迴圈索引\n            → Decision: j < k? // 針對每個質數進行檢查\n                → Decision: nextVal[j] == minVal? // 該質數是否產生了最小值\n                    → idx[j] += 1 // 移到下一個索引\n                    → nextVal[j] = primes[j] * ugly[idx[j]] // 更新下一候選\n                → j += 1 // 移動到下一個質數\n            → End // 結束內部迴圈\n        → i += 1 // 進入下一個位置\n    → End // 結束迴圈\n→ End // 程式執行結束\n→ Return ugly[n-1] // 傳回第 n 個超醜數字\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthSuperUglyNumber(self, n, primes):\n        ugly = [1]\n        indices = [0] * len(primes)\n        vals = list(primes)\n        for _ in range(1, n):\n            next_ugly = min(vals)\n            ugly.append(next_ugly)\n            for i in range(len(primes)):\n                if vals[i] == next_ugly:\n                    indices[i] += 1\n                    vals[i] = ugly[indices[i]] * primes[i]\n        return ugly[-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if not numbers:\n        sys.exit()\n    n = numbers[0]\n    primes = numbers[1:]\n    solution = Solution()\n    result = solution.nthSuperUglyNumber(n, primes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12, primes = [2,7,13,19]",
          "expected_output": "32",
          "success": true,
          "output": "32"
        },
        {
          "example_index": 1,
          "input": "n = 1, primes = [2,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode448.json",
    "problem_index_in_file": 0,
    "title": "Find All Numbers Disappeared in an Array",
    "description_snippet": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step. The problem: given array nums of length n with values 1..n, find missing numbers. Approach: iterate and mark presence. Usually, use negative marking or set. Since we cannot use actual code, we need to write virtual steps. For each number x in nums, mark presence at index x-1 by negative sign. Then iterate indices 0..n-1; if index i has positive value, then i+1 missing. Also handle if values already negative.\n\nVirtual code lines with explanation. Use Start, End, Decision. Need to use arrow notation. Also no actual code, just steps.\n\nLet's produce lines.\n\nStart // start\n\n→ Step 1: Let n = length of nums // get array length\n\n→ Step 2: For each index i from 0 to n-1 // iterate over array\n\n    → Step 2a: Let val = absolute value of nums[i] // get positive value\n\n    → Step 2b: Set nums[val-1] = negative absolute of nums[val-1] // mark presence\n\n→ Step 3: Create empty list result // to store missing numbers\n\n→ Step 4: For each index i from 0 to n-1 // scan for positives\n\n    → Decision: If nums[i] > 0? // if value not marked negative\n\n        Yes → Step 4a: Append i+1 to result // missing number\n\n        No  → // do nothing\n\n→ End // return result\n\nBut we need arrow style: Start, → Step, Decision, Yes→, No→. And we need each line with explanation.\n\nWe must not output actual code, but steps.\n\nLet's format accordingly. Each line as per sample: `虛擬碼步驟 // 解釋`. Use arrows inside steps: `→ Step 1: ...`.\n\nWe should include `Start // 程式開始執行`.\n\nMake sure each line with explanation. Use decision with nested Yes/No.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = length of nums // 取得陣列長度  \n→ Step 2: For each index i from 0 to n-1 // 逐個遍歷 nums  \n  → Step 2a: Let val = absolute value of nums[i] // 取出正確的數值  \n  → Step 2b: Set nums[val-1] = negative absolute of nums[val-1] // 在對應位置標記已出現  \n→ Step 3: Create empty list result // 用於存放缺失的數字  \n→ Step 4: For each index i from 0 to n-1 // 再次掃描 nums  \n  → Decision: If nums[i] > 0? // 檢查該位置是否未被標記  \n    Yes → Step 4a: Append i+1 to result // 位置 i+1 為缺失的數字  \n    No  → // 已標記，表示該數字已存在，無需處理  \nEnd // 程式執行結束，返回 result",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDisappearedNumbers(self, nums):\n        n = len(nums)\n        for num in nums:\n            idx = abs(num) - 1\n            nums[idx] = -abs(nums[idx])\n        return [i + 1 for i in range(n) if nums[i] > 0]\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 抓取所有數字（包含負號）\n    nums = [int(x) for x in re.findall(r'-?\\d+', data)]\n    solution = Solution()\n    result = solution.findDisappearedNumbers(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[5,6]",
          "success": true,
          "output": "[5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode273.json",
    "problem_index_in_file": 0,
    "title": "Integer to English Words",
    "description_snippet": "Convert a non-negative integer num to its English words representation....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code to convert a non-negative integer to English words representation. Provide step-by-step virtual pseudocode lines, with explanation after each. Must use the format: each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nNeed to cover main logic: handle zero, split number into groups of three digits (units, thousands, millions, billions). For each group, convert to words using mapping for ones, teens, tens, and hundreds. Build list of words. Combine with scale names. Return string.\n\nWe should produce a virtual algorithm, not actual code, but stepwise.\n\nEnsure lines are sequential: Start, input, decision for zero, loop over groups, convert group, append scale, etc. End.\n\nWe need to use arrow arrows \"→\" and \"Yes →\", \"No →\" for decisions. Ensure each line contains virtual step followed by comment.\n\nWe must not output actual code but pseudocode.\n\nWe need to output in Traditional Chinese.\n\nLet's construct:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入非負整數 num // 取得輸入數字\n\n→ Decision: 如果 num 等於 0? // 判斷是否為零\n\n    Yes → Step 2: 輸出 'Zero' // 直接回傳 \"Zero\"\n\n    No → Step 3: 初始化 wordsList 空串 // 用於儲存單詞\n\n→ Step 4: 定義 scaleNames = [\"\", \"Thousand\", \"Million\", \"Billion\"] // 各級別名稱\n\n→ Step 5: 定義 helper函式 convertTriplet(n) // 將三位數轉成文字\n\n    → Step 5.1: 若 n 為 0 返回空串 // 無需輸出\n\n    → Step 5.2: 建立三個映射：ones, teens, tens // 常用數字對應\n\n    → Step 5.3: 若 n>=100: 取百位，加入 ones[hundreds] + 'Hundred' // 百位部分\n\n    → Step 5.4: 取十位與個位 remainder = n % 100 // 兩位數部分\n\n    → Step 5.5: 若 remainder 介於 10~19: 加入 teens[remainder] // 十到十九\n\n    → Step 5.6: 否則 若 remainder>=20: 加入 tens[remainder/10] // 十位\n\n    → Step 5.7: 若 remainder%10>0: 加入 ones[remainder%10] // 個位\n\n    → Step 5.8: 返回合併後的字串 // 完成三位數轉換\n\n→ Step 6: 將 num 以三位數為單位切割並存入 list groups // 從右到左\n\n→ Step 7: for i in 0..len(groups)-1: // 遍歷每個三位組\n\n    → Step 7.1: 將 groups[i] 轉成文字 words = convertTriplet(groups[i]) // 轉換\n\n    → Decision: 如果 words 非空? // 有內容才加入\n\n        Yes → Step 7.2: 若 i>0: words += ' ' + scaleNames[i] // 加上級別名稱\n\n        Yes → Step 7.3: 將 words 插入 wordsList 開頭 // 先前級別要在前面\n\n        No → Step 7.4: 不做任何事 // 空組略過\n\n→ Step 8: 將 wordsList 合併成空格分隔字串 result // 最終結果\n\n→ Step 9: 輸出 result // 回傳英文表達\n\nEnd // 程式執行結束\n\nNeed to ensure each line with \"→\" arrow etc. Also \"Start\" and \"End\". Use indentation for decisions.\n\nAlso include mapping details maybe summarised.\n\nWe must keep each line separate with no code. Provide commentary.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入非負整數 num // 取得輸入數字  \n→ Decision: 如果 num 等於 0? // 判斷是否為零  \n Yes → Step 2: 輸出 'Zero' // 直接回傳 \"Zero\"  \n No  → Step 3: 初始化 wordsList 為空串 // 用於儲存所有單詞  \n→ Step 4: 定義 scaleNames = [\"\", \"Thousand\", \"Million\", \"Billion\"] // 各級別名稱  \n→ Step 5: 定義 helper 函式 convertTriplet(n) // 將三位數轉成文字  \n → Step 5.1: 若 n 為 0 返回空串 // 無需輸出任何文字  \n → Step 5.2: 建立 ones, teens, tens 的映射表 // 對應數字到文字  \n → Step 5.3: 若 n ≥ 100: 取百位，加入 ones[hundreds] + 'Hundred' // 百位部分  \n → Step 5.4: remainder = n % 100 // 取十位與個位兩位數  \n → Step 5.5: 若 10 ≤ remainder ≤ 19: 加入 teens[remainder] // 10~19 的特殊詞  \n → Step 5.6: 否則 若 remainder ≥ 20: 加入 tens[remainder / 10] // 十位詞  \n → Step 5.7: 若 remainder % 10 > 0: 加入 ones[remainder % 10] // 個位詞  \n → Step 5.8: 返回合併後的字串 // 完成三位數轉換  \n→ Step 6: 將 num 以三位數為單位切割並存入 groups 列表（從右到左） // 例如 1234567 → [567, 234, 1]  \n→ Step 7: 從 i = 0 到 len(groups)-1 遍歷每個三位組  \n → Step 7.1: words = convertTriplet(groups[i]) // 轉換成文字  \n → Decision: 如果 words 非空? // 有內容才處理  \n  Yes → Step 7.2: 若 i > 0: words += ' ' + scaleNames[i] // 加上級別名稱（Thousand/Million/Billion）  \n  Yes → Step 7.3: wordsList 插入 words 到最前面 // 先前級別放在前面  \n  No  → Step 7.4: 不做任何事 // 空組略過  \n→ Step 8: 將 wordsList 合併成以空格分隔的字串 result // 形成最終英文句子  \n→ Step 9: 輸出 result // 回傳最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        # Helper functions for conversion\n        def one(n: int) -> str:\n            ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n            return ones[n]\n\n        def two_less_20(n: int) -> str:\n            teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\n                     \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            return teens[n - 10]\n\n        def ten(n: int) -> str:\n            tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\",\n                    \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            return tens[n]\n\n        def two(n: int) -> str:\n            if n == 0:\n                return \"\"\n            if n < 10:\n                return one(n)\n            if n < 20:\n                return two_less_20(n)\n            tens_part = n // 10\n            rest = n % 10\n            return ten(tens_part) + (\" \" + one(rest) if rest != 0 else \"\")\n\n        def three(n: int) -> str:\n            hundred = n // 100\n            rest = n % 100\n            if hundred != 0 and rest != 0:\n                return one(hundred) + \" Hundred \" + two(rest)\n            if hundred != 0 and rest == 0:\n                return one(hundred) + \" Hundred\"\n            return two(rest)\n\n        parts = []\n        billion = num // 1_000_000_000\n        if billion:\n            parts.append(three(billion) + \" Billion\")\n        million = (num % 1_000_000_000) // 1_000_000\n        if million:\n            parts.append(three(million) + \" Million\")\n        thousand = (num % 1_000_000) // 1_000\n        if thousand:\n            parts.append(three(thousand) + \" Thousand\")\n        rest = num % 1_000\n        if rest:\n            parts.append(three(rest))\n        return \" \".join(parts)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r\"\\d+\", data)\n    num = int(match.group()) if match else 0\n    result = Solution().numberToWords(num)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 123",
          "expected_output": "\"One Hundred Twenty Three\"",
          "success": true,
          "output": "One Hundred Twenty Three"
        },
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "success": true,
          "output": "Twelve Thousand Three Hundred Forty Five"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "success": true,
          "output": "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode632.json",
    "problem_index_in_file": 0,
    "title": "Smallest Range Covering Elements from K Lists",
    "description_snippet": "You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find smallest range covering at least one element from each k sorted lists. Classic problem: use min-heap to maintain current minimum among chosen elements, track current maximum. We iterate over k lists with pointers. Steps: initialize heap with first element of each list along with list index and element index. Keep current_max = max of those. Best_range = [min, current_max] initially. Then loop: pop min from heap, update range if smaller. Move pointer in that list to next element, if exists push into heap and update current_max if needed. Continue until any list exhausted.\n\nWe need virtual code line-by-line, with arrow and explanation. Use Start, End, Decision.\n\nLet's craft steps.\n\nLine 1: Start // Start program\nLine 2: → Step 1: 初始化最小堆和 current_max // push first element of each list into heap, record list and index\nBut we need details: For i in 0..k-1: push (lists[i][0], i, 0) into heap. Update current_max = max(current_max, lists[i][0]).\nLine 3: → Step 2: 設定 best_range 為 [heap.min, current_max] // initial range\nLoop: Step 3: Decision: 堆非空? // While heap not empty (should be k always). Actually we will loop until any list exhausted. So we check if any list has more elements? We'll use a loop: while True.\nBetter to use Decision: 是否有列表還沒結束? but we can use condition on popped element index +1 < len(lists[idx]).\nWe'll handle inside loop.\n\nStep: while heap not empty:\npop min_val, list_idx, elem_idx\nupdate range if smaller\nif elem_idx + 1 == len(lists[list_idx]): break // cannot extend further\nelse:\npush next element from that list into heap\nupdate current_max if needed\ncontinue\n\nLet's produce each line.\n\nWe need arrow for each step. Provide explanation. Use decision branches.\n\nWe should not produce code, only virtual steps.\n\nLet's write.\n\nStart // 程式開始執行\n\n→ Step 1: 建立最小堆 heap 並把每個列表的第一個數字加入堆中，同時記錄其列表索引和元素索引 // 初始化堆和索引\n\n→ Decision: 為每個列表 i 從 0 到 k-1 進行以下操作? // 逐一處理每個列表\n\n    Yes → Step 2: 取 lists[i][0]，push (lists[i][0], i, 0) 到 heap // 把第一個元素加入堆\n        // Update current_max = max(current_max, lists[i][0]) // 追蹤目前最大的元素\n\n← 回到 Decision\n\n→ Step 3: 設定 best_low = heap.peek().value，best_high = current_max // 初始最佳區間為最小堆頂到最大值\n\n→ Step 4: 開始迴圈 while heap 不為空 // 進行尋找最佳區間\n\n    → Decision: 取堆頂元素 min_val, list_idx, elem_idx // 從堆中取最小值\n        Yes → Step 5: 若 current_max - min_val < best_high - best_low 或 (相等且 min_val < best_low) 則更新 best_low = min_val, best_high = current_max // 更新更小區間\n\n    → Decision: 是否還有下一個元素在 list_idx 列表中？ // 檢查是否可以往前推\n        Yes → Step 6: 取得 next_val = lists[list_idx][elem_idx + 1]，push (next_val, list_idx, elem_idx + 1) 到 heap // 把下一個元素推入堆\n            // Update current_max = max(current_max, next_val) // 更新最大值\n\n        No  → Step 7: 跳出迴圈 // 任何一個列表已無更多元素，結束\n\n→ End // 程式執行結束\n\nBut we need arrow formatting: \"→\" before each step, and decisions with Yes → etc. Also include explanations.\n\nMake sure each line has \"虛擬碼步驟 [space] // 解釋\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立最小堆 heap 並將每個列表的第一個數字 push 入堆，並記錄其列表索引與元素索引 // 初始化堆與索引  \n→ Decision: 為每個列表 i 從 0 到 k-1 進行以下操作? // 逐一處理每個列表  \n  Yes → Step 2: 取 lists[i][0]，push (lists[i][0], i, 0) 到 heap // 把第一個元素加入堆  \n   // 更新 current_max = max(current_max, lists[i][0]) // 追蹤目前最大的元素  \n← 回到 Decision  \n→ Step 3: 設定 best_low = heap.peek().value，best_high = current_max // 初始最佳區間為最小堆頂到最大值  \n→ Step 4: 開始迴圈 while heap 不為空 // 進行尋找最佳區間  \n  → Decision: 取堆頂元素 min_val, list_idx, elem_idx // 從堆中取最小值  \n   Yes → Step 5: 若 current_max - min_val < best_high - best_low 或 (相等且 min_val < best_low) 則更新 best_low = min_val, best_high = current_max // 更新更小區間  \n  → Decision: 是否還有下一個元素在 list_idx 列表中？ // 檢查是否可以往前推  \n   Yes → Step 6: 取得 next_val = lists[list_idx][elem_idx + 1]，push (next_val, list_idx, elem_idx + 1) 到 heap // 把下一個元素推入堆  \n    // 更新 current_max = max(current_max, next_val) // 更新最大值  \n   No → Step 7: 跳出迴圈 // 任何一個列表已無更多元素，結束  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def smallestRange(self, nums):\n        # 初始化最小堆與最大值\n        heap = []\n        max_val = float('-inf')\n        for i, lst in enumerate(nums):\n            heapq.heappush(heap, (lst[0], i, 0))  # (值, 列表索引, 列表內索引)\n            max_val = max(max_val, lst[0])\n\n        # 初始最佳區間\n        min_range = float('inf')\n        start = end = -1\n\n        while True:\n            min_val, list_idx, elem_idx = heapq.heappop(heap)\n\n            # 檢查是否得到更小的區間\n            if max_val - min_val < min_range or (max_val - min_val == min_range and min_val < start):\n                min_range = max_val - min_val\n                start, end = min_val, max_val\n\n            # 若該列表還有下一個元素，推入堆並更新最大值\n            if elem_idx + 1 < len(nums[list_idx]):\n                next_val = nums[list_idx][elem_idx + 1]\n                heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n                max_val = max(max_val, next_val)\n            else:\n                break  # 任何一個列表已無更多元素，結束\n\n        return [start, end]\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串解析成 nums 列表。支援形如\n    'nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]' 的格式。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    # 使用 eval 取得列表，僅允許空環境以減少風險\n    return eval(expr, {}, {})\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    solution = Solution()\n    result = solution.smallestRange(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]",
          "expected_output": "[20,24]",
          "success": true,
          "output": "[20, 24]"
        },
        {
          "example_index": 1,
          "input": "nums = [[1,2,3],[1,2,3],[1,2,3]]",
          "expected_output": "[1,1]",
          "success": true,
          "output": "[1, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode567.json",
    "problem_index_in_file": 0,
    "title": "Permutation in String",
    "description_snippet": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: check if s2 contains permutation of s1. Standard sliding window with frequency count. We'll output line by line with comments. Use Start, Decision etc. We'll not give actual code. We'll produce virtual steps: Start; compute lengths; if len(s1)>len(s2) return false; Build frequency map for s1; Build initial window in s2; compare; iterate sliding; update counts; compare; if any match return true; End.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use arrow notation. Format: \"Start // 程式開始執行\" etc. Let's produce.\n\nWe'll need to express Decision: \"如果 s1 長度 > s2 長度?\" etc. We'll produce steps accordingly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 s1 的長度 n，s2 的長度 m // 取得兩字串長度  \n→ Decision: 如果 n > m? // 若 s1 長度大於 s2，則不可能存在排列  \n  Yes → Step 2: 回傳 false // 直接回傳結果  \n  No  → Step 3: 建立 s1 的字元頻率表 freqS1 // 以陣列或字典記錄每個字元出現次數  \n→ Step 4: 初始化 s2 前 n 個字元的頻率表 windowFreq // 用來比對滑動視窗  \n→ Decision: 如果 freqS1 == windowFreq? // 初始視窗是否已匹配  \n  Yes → Step 5: 回傳 true // 找到符合排列的子字串  \n  No  → Step 6: 設定 left = 0，right = n // 初始化滑動視窗範圍  \n→ Step 7: While right < m // 將視窗滑動直到 s2 結尾  \n  → Step 7a: 進入右端字元 c = s2[right]  \n  → Step 7b: windowFreq[c]++ // 加入新字元到頻率表  \n  → Step 7c: If windowFreq[s2[left]] > freqS1[s2[left]]? // 檢查左端字元是否多餘  \n    Yes → Step 7d: windowFreq[s2[left]]-- // 移除左端字元  \n      left++ // 左指標右移，縮小視窗  \n  → Step 7e: right++ // 右指標右移，擴大視窗  \n  → Decision: 如果 freqS1 == windowFreq? // 滑動後頻率表是否相等  \n    Yes → Step 7f: 回傳 true // 找到符合排列的子字串  \n    No  → Step 7g: 進入下一輪迴圈  \n→ Step 8: 回傳 false // 未找到任何符合排列的子字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        \"\"\"\n        判斷 s2 是否包含 s1 的任意排列\n        \"\"\"\n        len1, len2 = len(s1), len(s2)\n        # s1 太長時直接無法匹配\n        if len1 > len2:\n            return False\n\n        # 計算 s1 的字元頻率\n        s1_count = Counter(s1)\n        # 初始滑動窗口的頻率\n        window_count = Counter(s2[:len1])\n\n        # 初始窗口是否已匹配\n        if s1_count == window_count:\n            return True\n\n        # 滑動窗口，右移至 s2 結尾\n        for i in range(len1, len2):\n            start_char = s2[i - len1]  # 將離開窗口的字元\n            end_char = s2[i]          # 將進入窗口的字元\n\n            # 加入新字元\n            window_count[end_char] += 1\n            # 移除舊字元\n            window_count[start_char] -= 1\n            if window_count[start_char] == 0:\n                del window_count[start_char]\n\n            # 比較頻率表是否相等\n            if window_count == s1_count:\n                return True\n\n        # 沒有任何窗口匹配\n        return False\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析 s1 與 s2，假設格式為 s1 = \"ab\", s2 = \"eidbaooo\"\n    # 取引號內的字串作為實際值\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) < 2:\n        # 如果格式不符，直接返回\n        return\n    s1, s2 = parts[0], parts[1]\n\n    solution = Solution()\n    result = solution.checkInclusion(s1, s2)\n    # 輸出小寫字串以符合範例\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode89.json",
    "problem_index_in_file": 0,
    "title": "Gray Code",
    "description_snippet": "An n-bit gray code sequence is a sequence of 2^n integers where:\n\nEvery integer is in the inclusive ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to produce a Gray code sequence. It's a known algorithm: recursively generate Gray code by reflecting. Or use bit manipulation: for i from 0 to 2^n-1, gray = i ^ (i>>1). Provide steps. Use Start, End, Decision, etc. We'll produce steps.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows and indent.\n\nWe'll produce steps: Start, Step1: input n. Step2: compute total = 2^n. Step3: create list. Step4: for i in 0..total-1: compute gray = i ^ (i>>1), append. Step5: return list. End.\n\nAlso include decision? Not necessary. But maybe include decision: if n <=0? But we can just skip.\n\nMake sure each line is separate.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得 Gray code 的位數\n→ Step 2: 計算 total = 2^n // 需要產生的序列長度\n→ Step 3: 初始化空列表 gray_list // 用來存放 Gray code\n→ Step 4: 循環 i 從 0 到 total-1 // 產生每個數字\n    → Step 4.1: 計算 gray = i XOR (i >> 1) // 生成 Gray code\n    → Step 4.2: 將 gray 加入 gray_list // 存入序列\n→ Step 5: 回傳 gray_list // 結果為 n 位 Gray code 序列\nEnd // 程式執行結束\n\nWe need to ensure \"Step\" and \"Decision\" formatting. Use arrow and indentation. Provide explanation in Chinese.\n\nWe should use \"Decision:\" if there's a decision but not needed. But okay.\n\nAdd \"Decision:\" for n<=0? Might be optional. Let's add:\n\n→ Decision: n <= 0? // 檢查輸入是否合法\n    Yes → Step X: 返回空列表 // 如果 n 為 0 或負，返回空序列\n    No → proceed\n\nBut we can just include. But we can keep simple.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得 Gray code 的位數  \n→ Decision: n ≤ 0? // 檢查輸入是否合法  \n  Yes → Step 2a: 回傳空列表 [] // n 為 0 或負數時直接回傳空序列  \n  No  → Step 2: 計算 total = 2^n // 需要產生的序列長度  \n→ Step 3: 初始化空列表 gray_list // 用來存放 Gray code  \n→ Step 4: 循環 i 從 0 到 total-1 // 產生每個數字  \n  → Step 4.1: 計算 gray = i XOR (i >> 1) // 生成 Gray code，鄰近數只差一位  \n  → Step 4.2: 將 gray 加入 gray_list // 存入序列  \n→ Step 5: 回傳 gray_list // 結果為 n 位 Gray code 序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef gray_code(n: int):\n    \"\"\"產生 n 位 Gray code 序列。\"\"\"\n    result = [0]\n    for i in range(n):\n        add = 1 << i\n        result += [x + add for x in reversed(result)]\n    return result\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 從輸入中提取第一個整數（可能是「n = 2」這類格式）\n    match = re.search(r'(-?\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n    seq = gray_code(n)\n    # 將結果直接輸出為 Python 列表字面量\n    print(seq)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,3,2]",
          "success": true,
          "output": "[0, 1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode16.json",
    "problem_index_in_file": 0,
    "title": "3Sum Closest",
    "description_snippet": "Given an integer array nums of length n and an integer target, find three integers in nums such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code (step-by-step) with explanations, following format. The task: given array and target, find 3 sum closest. Classic 3Sum Closest. Approach: sort array, then for each i, two-pointer j,k, compute sum and track closest. Provide steps.\n\nWe need to output each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrow lines.\n\nBe careful to use Chinese simplified? The requirement: \"用繁體中文回答.\" So explanations in Traditional Chinese. Virtual code steps can be English? but we can keep pseudo steps in English but comments in Traditional Chinese. Probably fine. Use arrow.\n\nWe need to produce line-by-line steps.\n\nLet's craft:\n\nStart // 開始程式\n\n→ Step 1: Sort nums ascending // 先對陣列排序以便使用雙指針\n\n→ Step 2: Initialize closestSum to sum of first three elements // 初始化最近和\n\n→ Decision: For i from 0 to n-3? // 迴圈遍歷第一個數\n\n    → Step 3: Set left = i+1, right = n-1 // 設定左右指標\n\n    → Decision: While left < right? // 雙指針迴圈\n\n        → Step 4: currentSum = nums[i] + nums[left] + nums[right] // 計算當前三數和\n\n        → Decision: If |currentSum - target| < |closestSum - target|? // 是否更新最近和\n\n            Yes → Step 5: closestSum = currentSum // 更新最近和\n\n        → Decision: If currentSum == target? // 完全等於目標\n\n            Yes → Step 6: Return target // 找到最優答案\n\n        No → Decision: If currentSum > target? // 和大於目標\n\n            Yes → Step 7: right = right - 1 // 右指標左移\n\n            No → Step 8: left = left + 1 // 左指標右移\n\n    → End While // 雙指針結束\n\n→ End For // 第一個數迴圈結束\n\n→ Step 9: Return closestSum // 返回最近和\n\nEnd // 程式結束\n\nMake sure to use arrows properly: For decision blocks indent. Use the same formatting as sample.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先對陣列進行升序排序，方便後續使用雙指針\n→ Step 2: Initialize closestSum to nums[0] + nums[1] + nums[2] // 用前三個數初始化最近和\n→ Decision: For i from 0 to n-3? // 以 i 為第一個數進行遍歷\n    → Step 3: Set left = i + 1, right = n - 1 // 設定左、右指標分別為 i 的下一個和陣列末端\n    → Decision: While left < right? // 當左指標小於右指標時持續執行\n        → Step 4: currentSum = nums[i] + nums[left] + nums[right] // 計算當前三數之和\n        → Decision: If |currentSum - target| < |closestSum - target|? // 判斷是否更新最近和\n            Yes → Step 5: closestSum = currentSum // 更新最近和為更接近目標的值\n        → Decision: If currentSum == target? // 若正好等於目標值\n            Yes → Step 6: Return target // 直接返回目標值，已是最優答案\n        No → Decision: If currentSum > target? // 若和大於目標\n            Yes → Step 7: right = right - 1 // 右指標左移，減小和\n            No → Step 8: left = left + 1 // 左指標右移，增大和\n    → End While // 雙指針循環結束\n→ End For // 第一個數的循環結束\n→ Step 9: Return closestSum // 返回最接近目標的三數之和\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        \"\"\"Return the sum of three integers in nums closest to target.\"\"\"\n        nums.sort()\n        n = len(nums)\n        closest_sum = float('inf')\n\n        for i in range(n - 2):\n            left, right = i + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if abs(total - target) < abs(closest_sum - target):\n                    closest_sum = total\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    return total\n        return closest_sum\n\ndef parse_input(input_text):\n    \"\"\"從輸入文本中提取 nums 列表和 target 整數.\"\"\"\n    # 提取數組\n    list_match = re.search(r'\\[.*?\\]', input_text)\n    nums = ast.literal_eval(list_match.group()) if list_match else []\n\n    # 提取目標值\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', input_text)\n    target = int(target_match.group(1)) if target_match else 0\n\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    input_text = sys.stdin.read()\n    nums, target = parse_input(input_text)\n\n    # 求解並輸出結果\n    sol = Solution()\n    result = sol.threeSumClosest(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,2,1,-4], target = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,0], target = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode747.json",
    "problem_index_in_file": 0,
    "title": "Largest Number At Least Twice of Others",
    "description_snippet": "You are given an integer array nums where the largest integer is unique.\n\nDetermine whether the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode, line by line with arrow syntax and explanation. Need to handle input: array nums. Steps: find max value and second max? Determine if max >= 2 * each other. Return index if condition true else -1.\n\nUse decision steps. Ensure uniqueness. Use loop. Probably track max index and max value, second max value. Or track max and second max while iterating.\n\nLet's design:\n\nStart\n→ Step 1: 初始化 maxVal = -∞, secondMax = -∞, maxIdx = -1 // prepare variables\n→ Step 2: 對每個元素 nums[i] 做循環\n    → Decision: 如果 nums[i] > maxVal?\n        Yes → secondMax = maxVal; maxVal = nums[i]; maxIdx = i\n        No → Decision: 如果 nums[i] > secondMax?\n            Yes → secondMax = nums[i]\n            No → // nothing\n→ Step 3: 判斷 maxVal >= 2 * secondMax ?\n    → Decision: 如果 true?\n        Yes → Return maxIdx\n        No → Return -1\nEnd\n\nBut careful: if array length 1, secondMax remains -∞, but condition should be true because largest at least twice as any other number (none). We can treat secondMax as 0? Actually no other numbers; we can treat condition as true. Might set secondMax = -∞ then maxVal >= 2 * (-∞) always true. But returning index ok. But we might need to treat secondMax if -∞. But easier: if nums length 1 return 0. Let's incorporate.\n\nAlternate approach: After loop, check if maxVal >= 2 * secondMax. If length 1, return 0.\n\nLet's add step for length 1.\n\nAdd Step before loop: Check if length of nums <=1 return 0.\n\nBut the requirement: If only one element, it's largest and no others; consider as true.\n\nSo Steps:\n\nStart\n→ Step 1: 如果 nums 的長度 == 1? // check single element\n    Yes → Return 0 // index 0\n    No → // proceed\n→ Step 2: 初始化 maxVal = -∞, secondMax = -∞, maxIdx = -1\n→ Step 3: 對每個元素 nums[i] 做循環\n    → Decision: nums[i] > maxVal ?\n        Yes → secondMax = maxVal; maxVal = nums[i]; maxIdx = i\n        No → Decision: nums[i] > secondMax ?\n            Yes → secondMax = nums[i]\n            No → // nothing\n→ Step 4: Decision: maxVal >= 2 * secondMax ?\n    Yes → Return maxIdx\n    No → Return -1\nEnd\n\nNeed to output line by line with arrow and explanation.\n\nAlso include indentation for decision branches.\n\nWe'll output exactly as format:\n\nStart // 程式開始執行\n→ Step 1: ... // explanation\n\nBut for decisions we need \"Decision:\" lines.\n\nLet's craft.\n\nMake sure each line has a virtual code step + explanation. For indentation, use 4 spaces before nested lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 如果 nums 的長度等於 1? // 檢查陣列是否只有一個元素\n    Yes → Step 1: 回傳 0 // 唯一元素即為最大且自動符合條件\n    No  → Step 2: 初始化 maxVal = -∞, secondMax = -∞, maxIdx = -1 // 用於追蹤最大值、第二大值與最大值索引\n→ Step 3: 對每個元素 nums[i] 做循環 // 遍歷整個陣列\n    → Decision: nums[i] > maxVal? // 判斷當前元素是否為新的最大值\n        Yes → Step 3.1: secondMax = maxVal; maxVal = nums[i]; maxIdx = i // 更新第二大值、最大值與其索引\n        No  → Decision: nums[i] > secondMax? // 若不是最大值，檢查是否為新的第二大值\n            Yes → Step 3.2: secondMax = nums[i] // 更新第二大值\n            No  → // 既不是最大也不是第二大，保持不變\n→ Step 4: Decision: maxVal >= 2 * secondMax? // 判斷最大值是否至少為所有其他數字的兩倍\n    Yes → Step 4.1: 回傳 maxIdx // 符合條件，回傳最大值索引\n    No  → Step 4.2: 回傳 -1 // 不符合條件，回傳 -1\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def dominantIndex(self, nums):\n        \"\"\"\n        Determine whether the largest element is at least twice every other element.\n        Return its index if true, otherwise -1.\n        \"\"\"\n        if not nums:\n            return -1\n        n = len(nums)\n        if n == 1:\n            return 0\n\n        # Find maximum and second maximum values and the index of the maximum\n        max_val = -float('inf')\n        second_max = -float('inf')\n        max_idx = -1\n\n        for i, num in enumerate(nums):\n            if num > max_val:\n                second_max = max_val\n                max_val = num\n                max_idx = i\n            elif num > second_max:\n                second_max = num\n\n        # Check the dominance condition\n        if max_val >= 2 * second_max:\n            return max_idx\n        else:\n            return -1\n\nif __name__ == \"__main__\":\n    # Read the input list from stdin\n    input_line = sys.stdin.read().strip()\n    # Parse the list; supports formats like \"[3,6,1,0]\"\n    nums = ast.literal_eval(input_line)\n\n    # Compute and print the result\n    solution = Solution()\n    result = solution.dominantIndex(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,6,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode65.json",
    "problem_index_in_file": 0,
    "title": "Valid Number",
    "description_snippet": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numb...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps to check if string s is a valid number per the described grammar. We must follow the format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc.\n\nWe need to propose algorithm: parse string, maybe trim spaces, check sign, integer/decimal, optional exponent, etc.\n\nWe should produce step-by-step pseudo-code lines, each line with arrow \"→\" etc. The arrow indicates next step; Decision lines for branching.\n\nGoal: Provide virtual code that covers all cases.\n\nLet's design algorithm:\n\n- Start\n- Step: Trim whitespace from s\n- Step: If s empty, return false\n- Step: index = 0\n- Step: Check optional sign at start\n- Step: Parse integer part (digits)\n- Step: If current char is '.', parse fractional part\n- Step: Determine if we have digits before or after dot, ensuring at least one digit either side\n- Step: After integer/decimal, check for exponent: if 'e' or 'E'\n- Step: If exponent, parse optional sign, parse digits; must have at least one digit\n- Step: Ensure index reached end of string\n- End return true/false\n\nBut the requirement is to generate virtual code lines, not actual code. Each line should include explanation.\n\nWe need to ensure we cover all definitions: integer number with optional exponent, decimal number with optional exponent, optional sign before integer or decimal.\n\nLet's produce a stepwise pseudocode:\n\nStart\n→ Step 1: Trim leading/trailing spaces from s // 去除空白\n→ Decision: 若 s 為空？ // 判斷字串是否為空\n    Yes → End // 返回 false\n→ Step 2: idx ← 0 // 初始化指標\n→ Step 3: If s[idx] 為 '+' 或 '-' Then idx++ // 處理前綴符號\n→ Step 4: hasDigits ← False // 是否已讀到數字\n→ Step 5: While idx < len(s) AND s[idx] 是數字 Then idx++; hasDigits ← True // 讀取整數部分\n→ Step 6: If idx < len(s) AND s[idx] = '.' Then\n        idx++ // 跳過小數點\n        fracHasDigits ← False\n        While idx < len(s) AND s[idx] 是數字 Then idx++; fracHasDigits ← True\n        // 判斷小數點前後至少有一個數字\n        Decision: hasDigits OR fracHasDigits?\n            No → End // 無數字，返回 false\n            Yes → Continue\n    EndIf\n→ Decision: hasDigits OR (idx已跳過小數點前後至少一個數字)? // 確認已讀到數字\n    No → End // 例如單單一個 '.' 或空字串\n    Yes → Continue\n→ Step 7: If idx < len(s) AND (s[idx] = 'e' OR s[idx] = 'E') Then\n        idx++ // 跳過 e/E\n        // 指數部分\n        expSignHandled ← False\n        If idx < len(s) AND (s[idx] = '+' OR s[idx] = '-') Then idx++ // 指數符號\n        expDigits ← 0\n        While idx < len(s) AND s[idx] 是數字 Then idx++; expDigits++\n        Decision: expDigits > 0?\n            No → End // 指數必須至少一個數字\n            Yes → Continue\n    EndIf\n→ Decision: idx == len(s)?\n    Yes → End // 所有字元已處理，合法\n    No → End // 多餘字元，非法\n\nBut the instructions ask for each line to include the arrow or decision arrow etc. We need to use \"→\" for normal steps, \"Decision:\" for branching. For decisions, we need to indent Yes → and No → sub-steps.\n\nMake sure each line includes \" // 解釋\".\n\nAlso note that we cannot output actual code but virtual code steps.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Step 1: Trim leading/trailing spaces from s // 去除字串前後空白\n→ Decision: If s is empty? // 判斷字串是否為空\n    Yes → End // 字串空，非合法數字，終止\n→ Step 2: idx ← 0 // 初始化指標\n→ Step 3: If s[idx] is '+' or '-' Then idx++ // 處理可選符號\n→ Step 4: hasDigits ← False // 追蹤是否已讀到數字\n→ Step 5: While idx < len(s) AND s[idx] is digit Do idx++; hasDigits ← True // 讀取整數部分\n→ Decision: If idx < len(s) AND s[idx] = '.'? // 判斷是否有小數點\n    Yes →\n        idx++ // 跳過 '.'\n        fracHasDigits ← False\n        While idx < len(s) AND s[idx] is digit Do idx++; fracHasDigits ← True // 讀取小數部分\n        Decision: hasDigits OR fracHasDigits? // 至少一邊有數字\n            No → End // 無數字，非法\n            Yes → Continue\n    No → Continue\n→ Decision: hasDigits OR (idx < len(s) AND s[idx] = '.' AND (previous fracHasDigits or hasDigits))? // 確保至少有一個數字\n    No → End // 如單純 '.' 或空\n    Yes → Continue\n→ Decision: If idx < len(s) AND (s[idx] = 'e' OR s[idx] = 'E')? // 是否有指數\n    Yes →\n        idx++ // 跳過 'e' / 'E'\n        If idx < len(s) AND (s[idx] = '+' OR s[idx] = '-') Then idx++ // 指數符號\n        expDigits ← 0\n        While idx < len(s) AND s[idx] is digit Do idx++; expDigits++\n        Decision: expDigits > 0? // 指數必須至少一個數字\n            No → End // 指數無數字，非法\n            Yes → Continue\n    No → Continue\n→ Decision: idx == len(s)? // 是否已處理完所有字元\n    Yes → End // 合法數字，返回真\n    No → End // 多餘字元，非法\n\nBut we must keep each line simple: each line must include the arrow and then explanation. Use indentation for decisions. For example:\n\nDecision: If idx < len(s) AND s[idx] = '.'? // 判斷是否有小數點\n    Yes → idx++ // 跳過 '.'\n    Yes → fracHasDigits ← False // 初始化\n    ... Wait, need to maintain structure: maybe we need to treat block as sub-steps after Yes. But each line can have arrow and explanation. Use indentation? The format example shows:\n\nDecision: 如果數字大於 0? \n    Yes → Step 2: 輸出 '正數' \n    No  → Decision: 如果數字等於 0?\n\nThus each Yes or No branch is a single line containing arrow and explanation. We cannot have multi-lines within the Yes branch, but can indent each line.\n\nThus we need to flatten each sub-step as a new line after Yes arrow. But we need to maintain context. Perhaps we should structure each block as nested decisions. Let's design accordingly.\n\nWe can do nested decisions: after Yes, we can proceed with next step, but we need to keep arrow lines. Let's try.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Trim leading/trailing spaces from s // 去除字串前後空白\n→ Decision: s 為空? // 判斷字串是否為空\n    Yes → End // 字串空，非合法數字，終止\n→ Step 2: idx ← 0 // 初始化指標\n→ Step 3: If s[idx] 是 '+' 或 '-' Then idx++ // 處理可選符號\n→ Step 4: hasDigits ← False // 追蹤是否已讀到數字\n→ Step 5: While idx < len(s) AND s[idx] 是數字 Do idx++; hasDigits ← True // 讀取整數部分\n→ Decision: idx < len(s) AND s[idx] = '.'? // 判斷是否有小數點\n    Yes → idx++ // 跳過 '.'\n    Yes → fracHasDigits ← False // 初始化小數位追蹤\n    Yes → While idx < len(s) AND s[idx] 是數字 Do idx++; fracHasDigits ← True // 讀取小數部分\n    Yes → Decision: hasDigits OR fracHasDigits? // 至少一邊有數字\n        No → End // 無數字，非法\n        Yes → Continue\n    No → Continue\n→ Decision: hasDigits OR (prev小數點判斷中 hasDigits 或 fracHasDigits)? // 確保至少一個數字\n    No → End // 如單純 '.' 或空\n    Yes → Continue\n→ Decision: idx < len(s) AND (s[idx] = 'e' OR s[idx] = 'E')? // 是否有指數\n    Yes → idx++ // 跳過 'e' / 'E'\n    Yes → If idx < len(s) AND (s[idx] = '+' OR s[idx] = '-') Then idx++ // 指數符號\n    Yes → expDigits ← 0 // 指數數字計數\n    Yes → While idx < len(s) AND s[idx] 是數字 Do idx++; expDigits++\n    Yes → Decision: expDigits > 0? // 指數必須至少一個數字\n        No → End // 指數無數字，非法\n        Yes → Continue\n    No → Continue\n→ Decision: idx == len(s)? // 是否已處理完所有字元\n    Yes → End // 合法數字，返回真\n    No → End // 多餘字元，非法\n\nBut the example uses \"Decision:\" lines and \"Yes →\" etc. However each Yes line can include a step. But we need to maintain nested decisions. It's okay.\n\nBut to be safe, we can keep each line simple: a step arrow plus explanation. For multi-step block, we can nest Decision lines.\n\nLet's produce final answer with proper indentation and arrow.\n\nAlso we need to use \"Yes →\" and \"No →\" after each Decision line. In the sample, they use \"Decision: 如果數字大於 0?\" then Yes → Step 2: ...; No → Decision: ... So we follow that style.\n\nThus for each decision, we create two lines: \"Yes → ...\" and \"No → ...\" with corresponding explanation.\n\nWhen we need to chain multiple steps inside a Yes branch, we can either combine them into a single step line or create nested decisions. But the instruction: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line is a single step. So if we need multiple steps inside a branch, we should use nested decisions: e.g., after Yes, we can put another Decision: But that may be confusing.\n\nSimplify: Use a linear sequence of steps with while loops etc. We can write loops as one line: \"While idx < len(s) AND s[idx] 是數字 Do idx++; hasDigits ← True\" That's fine. For branching, we use Decision.\n\nThus, we might not need nested decisions; we can use single decisions for each branch. For example:\n\nDecision: idx < len(s) AND s[idx] = '.'?\n    Yes → idx++ // 跳過 '.'\n    No  → Continue\n\nBut we also need to parse fractional digits after '.' inside Yes branch. That is another step. So we need to add steps after the Yes branch.\n\nWe can structure as:\n\nDecision: idx < len(s) AND s[idx] = '.'?\n    Yes → idx++ // 跳過 '.'\n    No  → Continue\n\nThen step: fracHasDigits ← False // 初始化\nThen step: While idx < len(s) AND s[idx] 是數字 Do idx++; fracHasDigits ← True // 讀取小數部分\n\nBut the fractional parsing should only happen if '.' existed. But we can still run it after; but we need to condition on earlier Yes? This is complicated. To keep simple, we can treat '.' presence as a step; we can parse fractional part only if '.' existed. We'll use decision to set a flag.\n\nSimpler: We'll parse integer part, optional dot with fractional, ensuring at least one digit. Implementation:\n\n- Parse integer part digits -> count.\n- If '.' then parse fractional digits -> count.\n- Ensure that (intCount > 0 or fracCount > 0). That ensures at least one digit before or after decimal.\n\nThus we can do:\n\nStep: intCount ← 0\nStep: While idx < len(s) AND s[idx] 是數字 Do idx++; intCount++\nStep: fracCount ← 0\nDecision: idx < len(s) AND s[idx] = '.'? // 有小數點?\n    Yes → idx++ // 跳過 '.'\n    No  → Continue\nStep: While idx < len(s) AND s[idx] 是數字 Do idx++; fracCount++\nDecision: intCount > 0 OR fracCount > 0? // 至少有一個數字\n    No  → End // 無數字，非法\n    Yes → Continue\n\nThat seems simpler.\n\nSimilarly for exponent:\n\nStep: expCount ← 0\nDecision: idx < len(s) AND (s[idx] = 'e' OR s[idx] = 'E')? // 有指數?\n    Yes → idx++ // 跳過 e/E\n    No  → Continue\nDecision: idx < len(s) AND (s[idx] = '+' OR s[idx] = '-')? // 指數符號\n    Yes → idx++ // 跳過符號\n    No  → Continue\nStep: While idx < len(s) AND s[idx] 是數字 Do idx++; expCount++\nDecision: expCount > 0? // 指數必須有數字\n    No  → End // 無指數數字，非法\n    Yes → Continue\n\nThen final check:\n\nDecision: idx == len(s)?\n    Yes → End // 合法\n    No  → End // 多餘字元，非法\n\nNow we can produce lines accordingly. Let's do that.\n\nWe need to produce each line with arrow or Decision: etc.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: s ← Trim(s) // 移除前後空白\n→ Decision: s 為空? // 判斷字串是否為空\n    Yes → End // 空字串不是合法數字\n→ Step 2: idx ← 0 // 指標初始化\n→ Step 3: If s[idx] 為 '+' 或 '-' Then idx++ // 處理可選前綴符號\n→ Step 4: intCount ← 0 // 整數部分數字計數\n→ Step 5: While idx < len(s) AND s[idx] 是數字 Do idx++; intCount++ // 讀取整數數字\n→ Step 6: fracCount ← 0 // 小數部分數字計數\n→ Decision: idx < len(s) AND s[idx] = '.'? // 判斷是否有小數點\n    Yes → idx++ // 跳過 '.'\n    No  → Continue\n→ Step 7: While idx < len(s) AND s[idx] 是數字 Do idx++; fracCount++ // 讀取小數數字\n→ Decision: intCount > 0 OR fracCount > 0? // 至少有一個數字\n    No → End // 例如單純 '.' 或空字串\n    Yes → Continue\n→ Step 8: expCount ← 0 // 指數數字計數\n→ Decision: idx < len(s) AND (s[idx] = 'e' OR s[idx] = 'E')? // 判斷是否有指數\n    Yes → idx++ // 跳過 e/E\n    No  → Continue\n→ Decision: idx < len(s) AND (s[idx] = '+' OR s[idx] = '-')? // 指數符號\n    Yes → idx++ // 跳過符號\n    No  → Continue\n→ Step 9: While idx < len(s) AND s[idx] 是數字 Do idx++; expCount++ // 讀取指數數字\n→ Decision: expCount > 0? // 指數必須至少一個數字\n    No → End // 指數缺少數字，非法\n    Yes → Continue\n→ Decision: idx == len(s)? // 是否已讀完所有字元\n    Yes → End // 合法數字\n    No  → End // 多餘字元，非法\n\nBut we need to incorporate the Continue lines: \"Continue\" means go to next step. We don't have a syntax for Continue, but we can just proceed. In the sample, they just use \"Continue\" as a comment? They didn't show. We'll just not use \"Continue\". Instead, we simply follow the flow: after a Decision Yes branch that leads to a step, we keep going. But we need to keep a linear path. So after \"Yes → idx++\" we then parse fractional digits etc.\n\nBut to keep simple, we can restructure:\n\nDecision: idx < len(s) AND s[idx] = '.'?\n    Yes → idx++ // 跳過 '.'\n    No  → // 沒有小數點，直接跳到指數檢查\n\nWe can just keep a line \"Step 7\" that runs regardless: While idx < len(s) AND s[idx] 是數字 Do idx++; fracCount++ // 讀取小數數字. But if we had no dot, this loop would read digits from the integer part after dot? Wait, we only want to read digits after dot. If we didn't have dot, we should not read. But the loop would run only if there are digits after current idx. If no dot, idx is at position after integer digits. So this loop will not run because next char may be 'e' or end. So it is fine to run. But we also need to ensure we didn't skip reading fractional digits when there was a dot. We already moved idx++ for dot. So this loop will read digits after dot. Good.\n\nThus we don't need nested decisions for the fractional part: we just run the loop.\n\nThus we can rewrite:\n\nStart\n→ Step 1: s ← Trim(s) // ...\n→ Decision: s 為空? // ...\n    Yes → End\n→ Step 2: idx ← 0\n→ Step 3: If s[idx] 是 '+' 或 '-' Then idx++ // ...\n→ Step 4: intCount ← 0\n→ Step 5: While idx < len(s) AND s[idx] 是數字 Do idx++; intCount++ // 整數\n→ Step 6: fracCount ← 0\n→ Decision: idx < len(s) AND s[idx] = '.'? // 有小數點\n    Yes → idx++ // 跳過 '.'\n    No  → // 無小數點\n→ Step 7: While idx < len(s) AND s[idx] 是數字 Do idx++; fracCount++ // 小數\n→ Decision: intCount > 0 OR fracCount > 0? // 至少一個數字\n    No → End\n    Yes → // 繼續\n→ Step 8: expCount ← 0\n→ Decision: idx < len(s) AND (s[idx] = 'e' OR s[idx] = 'E')? // 有指數\n    Yes → idx++ // 跳過 e/E\n    No  → // 無指數\n→ Decision: idx < len(s) AND (s[idx] = '+' OR s[idx] = '-')? // 指數符號\n    Yes → idx++ // 跳過符號\n    No  → // 無符號\n→ Step 9: While idx < len(s) AND s[idx] 是數字 Do idx++; expCount++ // 指數數字\n→ Decision: expCount > 0? // 指數有數字\n    No → End\n    Yes → // 繼續\n→ Decision: idx == len(s)? // 所有字元已處理\n    Yes → End // 合法\n    No  → End // 多餘字元\n\nWe need to ensure we have \"Continue\" or just ignore.\n\nBut we need to produce each line with explanation. Let's write final answer accordingly.\n\nWe'll avoid \"Continue\" lines, just rely on flow.\n\nAlso we should consider that if we have no exponent, we skip parsing exponent. But we still run the loop Step 9 only if there were exponent digits; if no exponent, expCount will remain 0, but we then Decision: expCount > 0? No -> End (illegal). Wait, that's wrong: If there's no exponent, expCount remains 0, but we should not treat that as illegal. So we need to ensure that decision only triggers if we had exponent. So we need a flag to indicate whether we had exponent. Let's add flag expSeen.\n\nSimplify: We can parse exponent part conditionally: After integer/decimal part, check if idx < len(s) AND (s[idx]=='e' OR s[idx]=='E'). If true, parse exponent, else skip. So we need a decision that encloses subsequent steps. We can use nested decision: Decision: idx < len(s) AND (s[idx] = 'e' OR s[idx] = 'E')?\n    Yes → (parse exponent)\n    No  → // skip exponent parse\n\nThus we can produce steps for parsing exponent inside Yes branch only. We'll need nested decisions inside Yes branch.\n\nLet's structure:\n\nDecision: idx < len(s) AND (s[idx] = 'e' OR s[idx] = 'E')? // 有指數?\n    Yes →\n        Step 8: idx++ // 跳過 e/E\n        Decision: idx < len(s) AND (s[idx] = '+' OR s[idx] = '-')? // 指數符號\n            Yes → idx++ // 跳過符號\n            No  → // 無符號\n        Step 9: expCount ← 0 // 指數數字計數\n        Step 10: While idx < len(s) AND s[idx] 是數字 Do idx++; expCount++ // 讀取指數數字\n        Decision: expCount > 0? // 指數必須至少一個數字\n            No  → End // 指數缺少數字，非法\n            Yes → // 繼續\n    No  → // 沒有指數，直接跳到結尾檢查\n\nThen final check: Decision: idx == len(s)? // 已處理完字元\n    Yes → End // 合法\n    No  → End // 多餘字元\n\nThis seems correct.\n\nNow produce each line accordingly. We need to include arrow or decision arrow. Use indentation for nested decisions.\n\nLet's produce final answer with proper format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: s ← Trim(s) // 移除字串前後空白  \n→ Decision: s 為空? // 判斷字串是否為空  \n    Yes → End // 空字串不是合法數字  \n→ Step 2: idx ← 0 // 指標初始化  \n→ Step 3: If s[idx] 為 '+' 或 '-' Then idx++ // 處理可選前綴符號  \n→ Step 4: intCount ← 0 // 整數部分數字計數  \n→ Step 5: While idx < len(s) AND s[idx] 是數字 Do idx++; intCount++ // 讀取整數數字  \n→ Step 6: fracCount ← 0 // 小數部分數字計數  \n→ Decision: idx < len(s) AND s[idx] = '.'? // 判斷是否有小數點  \n    Yes → idx++ // 跳過 '.'  \n    No  → // 沒有小數點  \n→ Step 7: While idx < len(s) AND s[idx] 是數字 Do idx++; fracCount++ // 讀取小數數字  \n→ Decision: intCount > 0 OR fracCount > 0? // 至少有一個數字  \n    No → End // 例如單純 '.' 或空字串  \n    Yes → // 繼續進行指數處理  \n→ Decision: idx < len(s) AND (s[idx] = 'e' OR s[idx] = 'E')? // 有指數部分?  \n    Yes → // 開始處理指數  \n        → Step 8: idx++ // 跳過 'e' 或 'E'  \n        → Decision: idx < len(s) AND (s[idx] = '+' OR s[idx] = '-')? // 指數符號?  \n            Yes → idx++ // 跳過符號  \n            No  → // 無符號  \n        → Step 9: expCount ← 0 // 指數數字計數  \n        → Step 10: While idx < len(s) AND s[idx] 是數字 Do idx++; expCount++ // 讀取指數數字  \n        → Decision: expCount > 0? // 指數必須至少一個數字  \n            No → End // 指數缺少數字，非法  \n            Yes → // 繼續到結尾檢查  \n    No → // 沒有指數，直接進行結尾檢查  \n→ Decision: idx == len(s)? // 是否已處理完所有字元  \n    Yes → End // 合法數字，返回真  \n    No  → End // 多餘字元，非法",
      "generated_code": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        if not s:\n            return False\n        num_seen = False\n        dot_seen = False\n        e_seen = False\n        for i, char in enumerate(s):\n            if char.isdigit():\n                num_seen = True\n            elif char == '.':\n                if dot_seen or e_seen:\n                    return False\n                dot_seen = True\n            elif char in 'eE':\n                if e_seen or not num_seen:\n                    return False\n                e_seen = True\n                num_seen = False\n            elif char in '+-':\n                if i != 0 and s[i - 1] not in 'eE':\n                    return False\n            else:\n                return False\n        return num_seen\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    data = sys.stdin.read().strip()\n    if not data:\n        print(False)\n        sys.exit()\n\n    # Extract the string value if the input is in the form s = \"...\"\n    if '\"' in data:\n        first = data.find('\"')\n        last = data.rfind('\"')\n        if first != -1 and last != -1 and first < last:\n            s = data[first + 1:last]\n        else:\n            s = data\n    else:\n        s = data\n\n    solution = Solution()\n    print(solution.isNumber(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"0\"",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "s = \"e\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        },
        {
          "example_index": 2,
          "input": "s = \".\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode121.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou wan...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps. Use virtual code with arrows. Provide explanation each line. Start, Decision, etc. We need to solve max profit single transaction. Steps: Start, initialize minPrice to +∞, maxProfit to 0, iterate over prices: update minPrice, calculate profit, update maxProfit. Finally output maxProfit.\n\nWe need to keep structure. Provide arrows. We need \"→\" to indent? We follow example: Start → Step 1: ... etc. So each line should have \"虛擬碼步驟\" then space then \"// 解釋\". Use arrows for flow. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 minPrice 為無限大 // 用於記錄迴圈中遇到的最低股價  \n→ Step 2: 設定 maxProfit 為 0 // 用於記錄迴圈中遇到的最高利潤  \n→ Step 3: 循環遍歷 prices 陣列，指標為 i // 逐日檢查股價  \n  → Decision: 如果 prices[i] < minPrice? // 判斷是否找到新的最低價  \n   Yes → Step 4: 設定 minPrice = prices[i] // 更新最低價  \n   No  → // 保持原值  \n  → Step 5: 計算 profit = prices[i] - minPrice // 以當前最低價為買入點，計算利潤  \n  → Decision: 如果 profit > maxProfit? // 判斷是否比目前已知利潤更高  \n   Yes → Step 6: 設定 maxProfit = profit // 更新最高利潤  \n   No  → // 保持原值  \n→ Step 7: 輸出 maxProfit // 回傳最大可獲得的利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_profit(prices):\n    \"\"\"Return the maximum profit from a single buy/sell transaction.\"\"\"\n    if not prices:                     # 空陣列直接回傳 0\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for price in prices[1:]:\n        max_profit = max(max_profit, price - min_price)\n        min_price = min(min_price, price)\n    return max_profit\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整行輸入\n    data = sys.stdin.read().strip()\n    # 期望輸入形式如 \"prices = [7,1,5,3,6,4]\"\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n        try:\n            prices = ast.literal_eval(expr.strip())\n        except Exception:\n            prices = []\n    else:\n        # 若直接給出列表字串\n        try:\n            prices = ast.literal_eval(data)\n        except Exception:\n            prices = []\n\n    result = max_profit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode44.json",
    "problem_index_in_file": 0,
    "title": "Wildcard Matching",
    "description_snippet": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for wildcard pattern matching. Use a typical DP approach: dp[i][j] true if first i chars of s match first j chars of p. Use DP table or recursion with memoization. Since virtual code, use steps and decisions. Provide each line with explanation.\n\nWe need to be thorough. We'll use Start, input, define DP array, initialize dp[0][0], handle '*' in pattern. Loop i from 0..len(s), j from 1..len(p) fill. Finally return dp[len(s)][len(p)]. Should cover entire string.\n\nLet's create virtual code:\n\nStart\n→ Step 1: Read input string s and pattern p // Get input\n→ Step 2: Let n = length of s, m = length of p // Sizes\n→ Step 3: Initialize 2D boolean array dp[n+1][m+1] all false // DP table\n→ Step 4: Set dp[0][0] = true // Empty pattern matches empty string\n→ Step 5: For j from 1 to m // Handle leading '*' in pattern\n    → Decision: If p[j-1] == '*'\n        → Yes → dp[0][j] = dp[0][j-1] // '*' can match empty\n        → No  → dp[0][j] = false // non-asterisk cannot match empty\n→ Step 6: For i from 1 to n // Iterate over string chars\n    → For j from 1 to m // Iterate over pattern chars\n        → Decision: If p[j-1] == '*'\n            → Yes → dp[i][j] = dp[i][j-1] OR dp[i-1][j] // '*' matches empty or one more char\n            → No\n                → Decision: If p[j-1] == '?' OR p[j-1] == s[i-1]\n                    → Yes → dp[i][j] = dp[i-1][j-1] // Match single char\n                    → No  → dp[i][j] = false // No match\n→ Step 7: Result = dp[n][m] // Full match status\n→ End // 返回結果\n\nNeed to keep virtual code with arrows, indentation. Provide explanation after each line. Should maintain structure. Use \"→\" arrow and indentation. Provide decision branches. Use \"Decision:\" lines.\n\nLet's craft final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s 與模式 p // 取得待比對的字串與模式\n→ Step 2: 設定 n = s 的長度, m = p 的長度 // 確定字串與模式長度\n→ Step 3: 建立 2D 布林陣列 dp[n+1][m+1] 並初始化為 false // 用於存放子問題結果\n→ Step 4: dp[0][0] ← true // 空模式與空字串相符\n→ Step 5: 迴圈 j 取 1 至 m // 處理前導 '*' 可匹配空字串的情況\n    → Decision: p[j-1] 為 '*'\n        → Yes → dp[0][j] ← dp[0][j-1] // '*' 可匹配空字串\n        → No  → dp[0][j] ← false // 其他符號無法匹配空字串\n→ Step 6: 迴圈 i 取 1 至 n // 逐字串處理\n    → 迴圈 j 取 1 至 m // 逐模式處理\n        → Decision: p[j-1] 為 '*'\n            → Yes → dp[i][j] ← dp[i][j-1] OR dp[i-1][j] // '*' 匹配空字串或多個字元\n            → No\n                → Decision: p[j-1] 為 '?' 或 p[j-1] = s[i-1]\n                    → Yes → dp[i][j] ← dp[i-1][j-1] // 單一字元相符\n                    → No  → dp[i][j] ← false // 不相符\n→ Step 7: Result ← dp[n][m] // 檢查整個字串是否完全匹配\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"Wildcard pattern matching with '?' and '*'.\"\"\"\n        m, n = len(s), len(p)\n        # dp[i][j] == True  <=>  s[:i] matches p[:j]\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # Patterns that can match an empty string\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '?':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    # '*' matches empty (dp[i][j-1]) or one more char (dp[i-1][j])\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                # else dp[i][j] remains False\n\n        return dp[m][n]\n\ndef parse_input(content: str):\n    \"\"\"\n    Extract two quoted strings (s and p) from the input.\n    Supports inputs like: s = \"aa\", p = \"a\"\n    \"\"\"\n    quoted = re.findall(r'\"(.*?)\"', content)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # Fallback: split by whitespace if no quotes found\n    parts = content.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    return \"\", \"\"\n\ndef main():\n    data = sys.stdin.read()\n    s, p = parse_input(data)\n    sol = Solution()\n    result = sol.isMatch(s, p)\n    # Output exactly 'true' or 'false' as per examples\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"cb\", p = \"?a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode216.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum III",
    "description_snippet": "Find all valid combinations of k numbers that sum up to n such that the following conditions are tru...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step. Use virtual code with arrows. No actual code. Conditions: numbers 1-9, each at most once, combinations of k numbers sum to n. So essentially combination sum of size k. Use backtracking.\n\nWe need to produce lines with \"Start\", \"→ Step ...\" etc. Provide explanations. Ensure uniqueness automatically due to not revisiting numbers. Use sorted numbers 1-9.\n\nWe'll produce pseudocode:\n\nStart\n→ Initialize result list // hold combinations\n→ Define recursive function backtrack(startIndex, remainingSum, remainingCount, currentCombo)\n    // startIndex: index in 1..9 array\n    // remainingSum: sum needed\n    // remainingCount: how many numbers left to pick\n    // currentCombo: current combination\n\n→ In backtrack:\n    Decision: If remainingCount == 0?\n        Yes → Decision: If remainingSum == 0?\n                Yes → Step: Append copy of currentCombo to result // valid combo\n                No → Step: Return // sum mismatch\n        No → Decision: If remainingSum <= 0? // early exit if negative or sum exceeded\n                Yes → Step: Return // cannot reach sum\n                No → Decision: If startIndex > 9? // no more numbers\n                        Yes → Step: Return\n                        No → Step: For each i from startIndex to 9:\n                                Step: Append i to currentCombo\n                                Step: backtrack(i+1, remainingSum - i, remainingCount -1, currentCombo)\n                                Step: Remove last from currentCombo\n\nBut we need to produce as lines. Use arrow style.\n\nWill produce steps accordingly.\n\nWe need \"Start\" and \"End\".\n\nLet's craft.\n\nMake sure to include explanation after each line.\n\nAlso avoid actual code like arrays. Just generic steps.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize ResultList // 用來儲存所有符合條件的組合  \n→ 定義遞迴函式 Backtrack(起始索引, 剩餘和, 剩餘數量, 當前組合)  \n    // 起始索引：從哪個數字開始選擇  \n    // 剩餘和：目前還需要達到的總和  \n    // 剩餘數量：還需挑選的數字個數  \n    // 當前組合：已經挑選的數字集合  \n→ 在 Backtrack 內  \n    → Decision: 如果 剩餘數量 == 0?  \n        Yes → Decision: 如果 剩餘和 == 0?  \n                Yes → Step: 將 當前組合 的拷貝加入 ResultList // 找到一組合法的組合  \n                No  → Step: Return // 數量正好但和不符，結束此分支  \n        No  → Decision: 如果 剩餘和 <= 0?  \n                Yes → Step: Return // 已超過或為負，無法繼續  \n                No  → Decision: 如果 起始索引 > 9?  \n                        Yes → Step: Return // 沒有可用數字，結束此分支  \n                        No  → Step: For i from 起始索引 到 9:  \n                                Step: 將 i 加入 當前組合 // 選擇數字  \n                                Step: Backtrack(i + 1, 剩餘和 - i, 剩餘數量 - 1, 當前組合) // 進行下一層遞迴  \n                                Step: 移除 當前組合 中最後一個數字 // 回溯，嘗試其他數字  \n\n→ 執行 Backtrack(1, n, k, 空組合) // 從 1 開始，總和為 n，需選 k 個  \n→ Return ResultList // 把所有找到的合法組合回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int):\n        res = []\n\n        def backtrack(start: int, path: list, total: int):\n            if len(path) == k and total == n:\n                res.append(path[:])\n                return\n            if len(path) > k or total > n:\n                return\n            for i in range(start, 10):\n                path.append(i)\n                backtrack(i + 1, path, total + i)\n                path.pop()\n\n        backtrack(1, [], 0)\n        return res\n\ndef format_output(combos):\n    if not combos:\n        return '[]'\n    return '[' + ','.join('[' + ','.join(map(str, combo)) + ']' for combo in combos) + ']'\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        k, n = 0, 0\n    else:\n        k, n = nums[0], nums[1]\n    sol = Solution()\n    result = sol.combinationSum3(k, n)\n    print(format_output(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 3, n = 7",
          "expected_output": "[[1,2,4]]",
          "success": true,
          "output": "[[1,2,4]]"
        },
        {
          "example_index": 1,
          "input": "k = 3, n = 9",
          "expected_output": "[[1,2,6],[1,3,5],[2,3,4]]",
          "success": true,
          "output": "[[1,2,6],[1,3,5],[2,3,4]]"
        },
        {
          "example_index": 2,
          "input": "k = 4, n = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode721.json",
    "problem_index_in_file": 0,
    "title": "Accounts Merge",
    "description_snippet": "Given a list of accounts where each element accounts[i] is a list of strings, where the first elemen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines, each line with // explanation. We need to use the arrow notation and Decision, etc. We'll produce a pseudocode to merge accounts using union-find or DFS. Steps: build graph mapping email to name and adjacency. Then DFS to group emails. Then sort each group, prepend name. Output list.\n\nWe must use \"Start\" and \"End\". Provide each step with explanation. Use indentation for decisions. Use arrow syntax. Provide lines: \"Start\", \"→ Step 1: Initialize graph and name mapping\", etc. Use arrow for decisions like \"Decision: If email already visited?\" but we might not need many decisions.\n\nWe can do:\n\nStart // program starts\n→ Step 1: Create adjacency map emailToNeighbors and map email to name // map each email to its name and connect emails within same account\n→ Decision: For each account in accounts? // iterate accounts\n    → Step 2: For i from 1 to len(account)-1:\n        → Step 3: Add edge between account[0] and account[i] in adjacency map // connect emails within same account\n        → Step 4: Store name mapping for account[i] // record name\n→ Step 5: Initialize visited set // to keep track of processed emails\n→ Step 6: Initialize result list // to hold merged accounts\n→ Decision: For each email in adjacency map? // iterate all emails\n    → Decision: If email not visited? // if new component\n        → Step 7: Perform DFS starting at email to collect all emails in this component // gather emails\n        → Step 8: Sort collected emails // sort\n        → Step 9: Prepend name retrieved from email-to-name map // add name\n        → Step 10: Append merged account to result // add to output\n→ End // program ends\n\nWe need to use arrows and Decision syntax exactly as required. Each line must have \"虛擬碼步驟\" and then // 解釋/說明.\n\nWe'll output in Traditional Chinese.\n\nLet's construct. Use \"→\" before steps, \"Decision:\" lines. Use indentation maybe 4 spaces? Provide as sample. We'll keep consistent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 emailToNeighbors 與 emailToName 的兩個字典 // 先將每個 email 連接同一帳號的其他 email，並記錄 email 對應的姓名  \n→ Decision: 針對每筆帳號 accounts 做迴圈? // 逐一處理所有帳號  \n  → Step 2: 取帳號中的姓名 name = account[0] // 取得此帳號的姓名  \n  → Decision: 針對帳號中的每個 email 做迴圈? // 連結同帳號內所有 email  \n    → Step 3: 對每個 email e，將 e 加入 emailToNeighbors[name]，並把 e 的鄰居設為帳號中其他 email // 形成圖的邊  \n    → Step 4: 在 emailToName 記錄 email e 對應的姓名 name // 方便後續取得姓名  \n→ Step 5: 建立空集合 visited 用於標記已訪問的 email // 避免重複 DFS  \n→ Step 6: 建立空清單 result 存放合併後的帳號 // 最終輸出結果  \n→ Decision: 對 emailToNeighbors 中的每個 email 做迴圈? // 探索所有 email  \n  → Decision: 若 email 尚未在 visited? // 新的組合  \n    → Step 7: 執行 DFS，收集從此 email 開始能夠到達的所有 email // 找出同一個人的所有 email  \n    → Step 8: 把收集到的 email 集合轉成 list 並排序 // 依字典序排好  \n    → Step 9: 取得其中一個 email 的姓名，並以 [name] + sortedEmails 作為合併帳號 // 加入姓名作為首項  \n    → Step 10: 把合併後的帳號 append 到 result // 將結果加入輸出清單  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\ndef main():\n    data = sys.stdin.read()\n    data = data.strip()\n    if data.startswith(\"accounts\"):\n        data = data.split(\"=\", 1)[1]\n    data = data.strip()\n    accounts = ast.literal_eval(data)\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "expected_output": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "success": true,
          "output": "[['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com']]"
        },
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode763.json",
    "problem_index_in_file": 0,
    "title": "Partition Labels",
    "description_snippet": "You are given a string s. We want to partition the string into as many parts as possible so that eac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the problem: Partition string into as many parts as possible such that each letter appears in at most one part. This is a known problem: \"Partition Labels\". Approach: first find last occurrence index of each character. Then iterate, keep maxLast; when index equals maxLast, cut. So produce a step-by-step pseudo algorithm.\n\nWe need to output line by line: \"虛擬碼步驟 // 解釋\". Each line must start with arrow or Start or Decision etc. Use arrow arrows. For loops etc. Provide simple steps.\n\nWe need to ensure not to output actual code. Just virtual steps. So we need to produce a list of steps in this pseudo style.\n\nExample format: \"Start // 程式開始執行\". Then \"→ Step 1: 初始化字母至最後出現索引字典 // 建立每個字母最後一次出現的位置\". Then \"→ Step 2: 初始化 maxLast = 0, start = 0, result list = empty\". Then \"→ Step 3: 從頭到尾遍歷字符串\". Then inside we may use Decision to update maxLast, check when i == maxLast etc.\n\nWe'll need to produce each line with // explanation. The line after Step 3 includes sub-steps maybe within a loop. Use indentation? The format example uses indent for nested decisions. We'll replicate.\n\nAlso we must handle the \"return list of integers\". So final step: output result.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 建立一個映射，記錄每個字母在字符串中的最後一次出現索引 // 用於後續決定分割位置\n\nLine 3: → Step 2: 初始化變數 maxLast = -1、currentStart = 0、parts = 空列表 // 用於追蹤目前區塊的最大終點、起點與結果\n\nLine 4: → Step 3: 從索引 0 開始遍歷整個字符串 s，使用變數 i 表示當前索引 // 主迴圈\n\nThen inside loop:\n\nLine 5: →     Decision: 更新 maxLast 為 max(maxLast, lastIndexOf(s[i])) // 調整區塊的最遠終點\n\nLine 6: →     Decision: 如果 i 等於 maxLast? // 判斷是否可以切割\n\nThen Yes branch:\n\nLine 7: →         Yes → Step 4: 將區塊長度 (i - currentStart + 1) 加入 parts // 記錄此區塊大小\n\nLine 8: →         Yes → Step 5: 把 currentStart 更新為 i + 1 // 為下一個區塊準備起點\n\nThen No branch: nothing.\n\nAfter loop:\n\nLine 9: → Step 6: 返回 parts // 結果輸出\n\nEnd: Line 10: End // 程式執行結束\n\nCheck for consistency: we used arrow for steps. Also indent for Decision branches. That's fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個映射，記錄每個字母在字符串中的最後一次出現索引 // 用於後續決定分割位置  \n→ Step 2: 初始化變數 maxLast = -1、currentStart = 0、parts = 空列表 // 用於追蹤目前區塊的最大終點、起點與結果  \n→ Step 3: 從索引 0 開始遍歷整個字符串 s，使用變數 i 表示當前索引 // 主迴圈  \n    → Decision: 更新 maxLast 為 max(maxLast, lastIndexOf(s[i])) // 調整區塊的最遠終點  \n    → Decision: 如果 i 等於 maxLast? // 判斷是否可以切割  \n        Yes → Step 4: 將區塊長度 (i - currentStart + 1) 加入 parts // 記錄此區塊大小  \n        Yes → Step 5: 把 currentStart 更新為 i + 1 // 為下一個區塊準備起點  \n→ Step 6: 返回 parts // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef partition_labels(s: str):\n    \"\"\"Return the sizes of partitions so that each letter appears in at most one part.\"\"\"\n    if not s:\n        return []\n\n    # Record the last occurrence index of each character\n    last_index = {c: i for i, c in enumerate(s)}\n\n    partitions = []\n    start = end = 0\n\n    for i, c in enumerate(s):\n        end = max(end, last_index[c])   # Update the furthest point this partition must reach\n        if i == end:                    # When current index reaches the furthest point, we can cut\n            partitions.append(i - start + 1)\n            start = i + 1               # Start next partition\n\n    return partitions\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the string value from the input, handling optional 's = \"...\"' format.\"\"\"\n    raw = raw.strip()\n    if not raw:\n        return \"\"\n    if '=' in raw:\n        _, val = raw.split('=', 1)\n        val = val.strip()\n    else:\n        val = raw\n    # Remove surrounding quotes if present\n    if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):\n        val = val[1:-1]\n    return val\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = partition_labels(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ababcbacadefegdehijhklij\"",
          "expected_output": "[9,7,8]",
          "success": true,
          "output": "[9, 7, 8]"
        },
        {
          "example_index": 1,
          "input": "s = \"eccbbbbdec\"",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode126.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder II",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for this algorithm: find all shortest transformation sequences (word ladder II). The algorithm: BFS to build graph distances, then DFS or backtracking to find all paths from beginWord to endWord using only edges that move closer to endWord (distance decreasing). Use BFS to compute distance from beginWord to each word. Then DFS exploring neighbors that are one letter apart and have distance distance[current]+1. Complexity. We'll produce virtual code.\n\nWe need to output in lines: e.g., \"Start // 程式開始執行\".\n\nWe should incorporate data structures: Set of wordList, adjacency building maybe via wildcard patterns or on the fly. For virtual code, we can keep high level.\n\nWe'll produce:\n\nStart\n→ Initialize wordSet = Set(wordList)\n→ If endWord not in wordSet: return empty list\n→ Initialize distances = map beginWord->0\n→ BFS queue = [beginWord]\n→ While queue not empty: pop word\n   For each neighbor one-letter difference in wordSet:\n      If neighbor not in distances:\n          distances[neighbor] = distances[word]+1\n          queue append neighbor\n→ After BFS, if endWord not in distances: return empty list\n→ Define result list\n→ DFS function dfs(current, path)\n   If current == endWord: append copy of path to result\n   Else:\n      For each neighbor one-letter difference:\n         If distances[neighbor] == distances[current]+1:\n            dfs(neighbor, path+[neighbor])\n→ Call dfs(beginWord, [beginWord])\n→ Return result\n\nAlso need to mention building neighbors: generate all possible patterns, or directly generate by changing each char.\n\nWe will include comments.\n\nEnsure each line has virtual code step and comment. Use arrows and decisions. Also \"Decision:\" lines for loops maybe.\n\nWe'll output line by line.\n\nLet's craft lines.\n\nStart // 程式開始執行\n→ Step 1: wordSet ← Set(wordList) // 將字典轉為集合以便 O(1) 查找\n→ Decision: 如果 endWord 不在 wordSet? // 檢查目標字是否存在\n    Yes → Step 2: Return [] // 若不存在則無任何轉換序列\n    No  → Step 3: distances ← {beginWord: 0} // 初始化距離表，起點距離為 0\n→ Step 4: queue ← [beginWord] // BFS 隊列\n→ Decision: while queue 不為空? // BFS 循環\n    Yes →\n        → Step 5: current ← queue.pop_front() // 取出隊首單字\n        → Step 6: for each word curWord of current with one letter difference? // 生成鄰居\n            → Decision: curWord 是否在 wordSet? // 邊界檢查\n                Yes →\n                    → Decision: curWord 是否已在 distances? // 是否已訪問\n                        Yes → // 跳過已訪問的節點\n                        No  → \n                            → Step 7: distances[curWord] ← distances[current] + 1 // 記錄最短距離\n                            → Step 8: queue.append(curWord) // 將鄰居加入隊列\n    No  → // BFS 完成\n→ Decision: endWord 是否在 distances? // 檢查是否能達到終點\n    Yes → Step 9: result ← [] // 用於存儲所有最短路徑\n    No  → Step 10: Return [] // 無路徑可達\n→ Step 11: define function dfs(node, path) // 從 beginWord 深度優先搜索所有最短路徑\n    → Decision: node == endWord? // 到達終點？\n        Yes →\n            → Step 12: result.append(copy(path)) // 將完整路徑加入結果\n        No  →\n            → Step 13: for each word next of node with one letter difference? // 生成鄰居\n                → Decision: distances[next] == distances[node] + 1? // 還是屬於最短路徑\n                    Yes →\n                        → Step 14: dfs(next, path + [next]) // 進一步遞迴\n→ Step 15: dfs(beginWord, [beginWord]) // 開始深度優先搜索\n→ End // 程式結束，返回結果\n\nBut need to output each line with the pattern \"虛擬碼步驟 [space] // 解釋\". Use arrow for steps? They gave example: \"→ Step 1: ...\" etc. Let's follow that.\n\nNeed to use \"Start\" \"End\". Provide decisions with indentation.\n\nWe'll use arrow indent: \"→ Decision:\" and \"Yes →\" \"No →\".\n\nEnsure each line ends with comment after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: wordSet ← Set(wordList) // 將字典轉為集合以便 O(1) 查找  \n→ Decision: 若 endWord 不在 wordSet? // 檢查目標字是否存在  \n    Yes → Step 2: Return [] // 若不存在則無任何轉換序列  \n    No  → Step 3: distances ← {beginWord: 0} // 初始化距離表，起點距離為 0  \n→ Step 4: queue ← [beginWord] // BFS 隊列  \n→ Decision: while queue 不為空? // BFS 循環  \n    Yes →  \n        → Step 5: current ← queue.pop_front() // 取出隊首單字  \n        → Step 6: for each word curWord of current with one letter difference? // 生成鄰居  \n            → Decision: curWord 是否在 wordSet? // 邊界檢查  \n                Yes →  \n                    → Decision: curWord 是否已在 distances? // 是否已訪問  \n                        Yes → // 跳過已訪問的節點  \n                        No →  \n                            → Step 7: distances[curWord] ← distances[current] + 1 // 記錄最短距離  \n                            → Step 8: queue.append(curWord) // 將鄰居加入隊列  \n    No → // BFS 完成  \n→ Decision: endWord 是否在 distances? // 檢查是否能達到終點  \n    Yes → Step 9: result ← [] // 用於存儲所有最短路徑  \n    No → Step 10: Return [] // 無路徑可達  \n→ Step 11: define function dfs(node, path) // 從 beginWord 深度優先搜索所有最短路徑  \n    → Decision: node == endWord? // 到達終點？  \n        Yes →  \n            → Step 12: result.append(copy(path)) // 將完整路徑加入結果  \n        No →  \n            → Step 13: for each word next of node with one letter difference? // 生成鄰居  \n                → Decision: distances[next] == distances[node] + 1? // 還是屬於最短路徑  \n                    Yes →  \n                        → Step 14: dfs(next, path + [next]) // 進一步遞迴  \n→ Step 15: dfs(beginWord, [beginWord]) // 開始深度優先搜索  \nEnd // 程式結束，返回結果",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS: find shortest distance to each word and record parents\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef parse_input(data: str):\n    \"\"\"Parse input like\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\"]\n    \"\"\"\n    begin_match = re.search(r'beginWord\\s*=\\s*\"([^\"]*)\"', data)\n    end_match = re.search(r'endWord\\s*=\\s*\"([^\"]*)\"', data)\n    list_match = re.search(r'wordList\\s*=\\s*\\[([^\\]]*)\\]', data)\n\n    if not begin_match or not end_match or not list_match:\n        return None, None, []\n\n    beginWord = begin_match.group(1)\n    endWord = end_match.group(1)\n\n    # Extract all quoted strings inside the list\n    wordList = re.findall(r'\"([^\"]*)\"', list_match.group(0))\n    return beginWord, endWord, wordList\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n    beginWord, endWord, wordList = parse_input(input_data)\n    if beginWord is None:\n        print([])\n    else:\n        solution = Solution()\n        result = solution.findLadders(beginWord, endWord, wordList)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "success": true,
          "output": "[['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode436.json",
    "problem_index_in_file": 0,
    "title": "Find Right Interval",
    "description_snippet": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code (pseudocode) line by line with explanations, no actual code. It's about right interval problem. Need steps: sort intervals with start, store original index, loop each interval find next start >= end via binary search or two pointers, output array. Provide virtual code lines like Start, → Step 1: Build list with (start, end, index) // etc. Use Decision, loops, etc.\n\nLet's produce. Use Start, End. Use arrows for each step. Provide explanation after //.\n\nWe should maintain clarity. Provide loops and binary search as steps. Use Decision for binary search.\n\nLet's produce lines.\n\nWe should include pseudo code for sorting, building list, initializing result array, then for each interval, binary search for first start >= end, if found set result[idx] = foundIndex else -1.\n\nAlso maybe include Step names like Step 1, Step 2 etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將每個 interval 轉換為 {start, end, originalIndex} 並放入 list // 用來保留原始位置\n→ Step 2: 依照 start 升序排序 list // 方便後續二分搜尋\n→ Step 3: 初始化 result 陣列長度為 intervals 的個數，全部設為 -1 // 預設沒有右區間\n→ Decision: 對於 list 中的每個 interval (loop) // 為每個 interval 找右區間\n    Yes → Step 4: 取得 interval 的 end 值 // 用於搜尋\n    → Step 5: 使用二分搜尋於已排序的 list 找第一個 start >= end // 找最靠近的右區間\n    → Decision: 如果二分搜尋成功找到位置 pos ?\n        Yes → Step 6: result[originalIndex] = list[pos].originalIndex // 設定對應右區間索引\n        No  → Step 7: result[originalIndex] remains -1 // 若找不到，保持預設值\nEnd // 程式執行結束，回傳 result 陣列",
      "generated_code": "import sys\nimport ast\nimport bisect\n\nclass Solution:\n    def findRightInterval(self, intervals):\n        \"\"\"\n        依照右區間邏輯尋找每個 interval 的右區間索引。\n        1. 建立(start, 原始索引)的列表並排序，方便二分搜尋。\n        2. 針對每個 interval，利用 bisect_left 找第一個 start >= end。\n        3. 若找到，將對應的原始索引存入結果；否則存 -1。\n        \"\"\"\n        # 建立 (start, 原始索引) 並排序\n        starts = sorted((interval[0], i) for i, interval in enumerate(intervals))\n        res = []\n\n        for interval in intervals:\n            # 需要找的最小 start >= current interval 的 end\n            idx = bisect.bisect_left(starts, (interval[1],))\n            if idx < len(starts):\n                res.append(starts[idx][1])\n            else:\n                res.append(-1)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，解析成 intervals\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 支援形如 \"intervals = [[1,2]]\" 或僅僅 \"[[1,2]]\"\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n    else:\n        expr = raw_input\n\n    # 只使用安全的 literal_eval 解析列表\n    try:\n        intervals = ast.literal_eval(expr.strip())\n    except Exception:\n        # 若解析失敗，直接結束\n        sys.exit(1)\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.findRightInterval(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2]]",
          "expected_output": "[-1]",
          "success": true,
          "output": "[-1]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[3,4],[2,3],[1,2]]",
          "expected_output": "[-1,0,1]",
          "success": true,
          "output": "[-1, 0, 1]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,4],[2,3],[3,4]]",
          "expected_output": "[-1,2,-1]",
          "success": true,
          "output": "[-1, 2, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode517.json",
    "problem_index_in_file": 0,
    "title": "Super Washing Machines",
    "description_snippet": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm solving the LeetCode problem \"Super Washing Machines\". It's about balancing dresses across machines. Standard solution: if total not divisible by n, return -1. Else target = total / n. Iterate through machines, compute cumulative diff (prefix sum minus target*index). The answer is max of abs(cum_diff) and diff_i. Actually algorithm: maxMoves = 0; cumulative = 0; for i from 0 to n-1: cumulative += machines[i] - target; maxMoves = max(maxMoves, abs(cumulative), machines[i]-target). Return maxMoves. But typical solution uses max of abs(cumulative) and diff (positive). But we can produce a stepwise pseudocode. We must output line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrow and decision. Should start with Start, End.\n\nLet's craft algorithm.\n\nWe need to define steps:\n\nStart // Start\n→ Step 1: total ← sum of machines // compute total dresses\n→ Decision: If total mod n != 0? // check feasibility\n    Yes → Step 2: Return -1 // impossible\n    No  → Step 3: target ← total / n // target dresses per machine\n→ Step 4: maxMoves ← 0 // initialize answer\n→ Step 5: cumulative ← 0 // running balance\n→ For i from 0 to n-1: // iterate machines\n    → Step 6: diff ← machines[i] - target // difference at this machine\n    → Step 7: cumulative ← cumulative + diff // update balance\n    → Step 8: maxMoves ← max(maxMoves, abs(cumulative), diff) // update moves\n→ Step 9: Return maxMoves // result\nEnd\n\nWe need to format lines accordingly, with arrow and decision block. Use indentation for decision branches.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: total ← sum(machines) // 計算總衣服數\n→ Decision: If total mod n ≠ 0? // 是否能平均分配\n    Yes → Step 2: Return -1 // 直接回傳不可能\n    No  → Step 3: target ← total / n // 每台機器應有的衣服數\n→ Step 4: maxMoves ← 0 // 初始化最小移動次數\n→ Step 5: cumulative ← 0 // 初始累積差值\n→ Decision: 迴圈 i 從 0 到 n-1? // 開始遍歷每台機器\n    Yes → Step 6: diff ← machines[i] - target // 本台機器與目標的差距\n    Yes → Step 7: cumulative ← cumulative + diff // 更新累積差值\n    Yes → Step 8: maxMoves ← max(maxMoves, abs(cumulative), diff) // 取最大所需移動\n    No  → Step 9: Return maxMoves // 完成遍歷後回傳答案\nEnd // 程式結束\n\nBut the decision for loop isn't typical. Could use For loop block. But requirement uses Decision and arrows. We can treat loop as Decision: if i < n? else exit.\n\nBetter produce pseudocode with For loop notation, but keep Decision block for while.\n\nMaybe produce:\n\n→ Decision: i < n? // 迴圈條件\n    Yes → Step 6 ...\n    No  → Step 9: Return maxMoves\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: total ← sum(machines) // 計算總衣服數\n→ Decision: If total mod n ≠ 0? // 檢查是否能平均分配\n    Yes → Step 2: Return -1 // 無法平均，直接返回 -1\n    No  → Step 3: target ← total / n // 計算每台機器目標衣服數\n→ Step 4: maxMoves ← 0 // 初始化最大移動次數\n→ Step 5: cumulative ← 0 // 初始化累積差值\n→ Step 6: i ← 0 // 初始化迴圈索引\n→ Decision: i < n? // 迴圈條件\n    Yes → Step 7: diff ← machines[i] - target // 本機器與目標差距\n    Yes → Step 8: cumulative ← cumulative + diff // 更新累積差值\n    Yes → Step 9: maxMoves ← max(maxMoves, abs(cumulative), diff) // 更新最大移動次數\n    Yes → Step 10: i ← i + 1 // 進入下一台機器\n    No  → Step 11: Return maxMoves // 迴圈結束，回傳答案\nEnd // 程式結束\n\nWe need each line to contain virtual code and explanation. That satisfies format.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: total ← sum(machines) // 計算總衣服數  \n→ Decision: If total mod n ≠ 0? // 檢查是否能平均分配  \n Yes → Step 2: Return -1 // 無法平均，直接返回 -1  \n No  → Step 3: target ← total / n // 計算每台機器目標衣服數  \n→ Step 4: maxMoves ← 0 // 初始化最大移動次數  \n→ Step 5: cumulative ← 0 // 初始化累積差值  \n→ Step 6: i ← 0 // 初始化迴圈索引  \n→ Decision: i < n? // 迴圈條件  \n Yes → Step 7: diff ← machines[i] - target // 本機器與目標差距  \n Yes → Step 8: cumulative ← cumulative + diff // 更新累積差值  \n Yes → Step 9: maxMoves ← max(maxMoves, abs(cumulative), diff) // 更新最大移動次數  \n Yes → Step 10: i ← i + 1 // 進入下一台機器  \n No  → Step 11: Return maxMoves // 迴圈結束，回傳答案  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinMoves(self, machines):\n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        target = total // n\n        max_moves = 0\n        cumulative = 0\n        for load in machines:\n            diff = load - target\n            cumulative += diff\n            max_moves = max(max_moves, abs(cumulative), diff)\n        return max_moves\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    machines = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.findMinMoves(machines)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,0,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,2,0]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode657.json",
    "problem_index_in_file": 0,
    "title": "Robot Return to Origin",
    "description_snippet": "There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation for the problem. The virtual code should reflect algorithm: iterate moves, keep x,y counters, increment/decrement accordingly, then check if x==0 && y==0. Provide each line with \"→\" or \"Start\", \"End\", \"Decision:\" etc. We'll produce step-by-step. Ensure each line has '虛擬碼步驟' followed by space then '// 解釋/說明'.\n\nWe'll do:\n\nStart\n→ Initialize x = 0, y = 0 // 設定初始座標\n→ For each char c in moves // 逐字遍歷指令\n    → Decision: c == 'R'? // 判斷是右移\n        Yes → x = x + 1 // x +1\n        No  → Decision: c == 'L'? // 判斷左移\n            Yes → x = x - 1\n            No  → Decision: c == 'U'? // 判斷上移\n                Yes → y = y + 1\n                No  → Decision: c == 'D'? // 判斷下移\n                    Yes → y = y - 1\n                    No  → // 無效指令忽略\nEnd // 完成所有移動\n→ Decision: x == 0 and y == 0? // 檢查是否回到原點\n    Yes → Return true // 回到原點\n    No  → Return false // 未回到原點\n\nMake sure each line includes arrow and explanation. Use appropriate indentation maybe but not necessary. Ensure each line is separate. Ensure the virtual code uses \"Start\", \"End\", \"Decision:\" etc. Provide no real code. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ x = 0, y = 0 // 設定初始座標為 (0,0)\n→ For each character c in moves // 逐字遍歷指令字串\n    → Decision: c == 'R'? // 判斷是否為右移\n        Yes → x = x + 1 // 右移，x 加 1\n        No  → Decision: c == 'L'? // 判斷是否為左移\n            Yes → x = x - 1 // 左移，x 減 1\n            No  → Decision: c == 'U'? // 判斷是否為上移\n                Yes → y = y + 1 // 上移，y 加 1\n                No  → Decision: c == 'D'? // 判斷是否為下移\n                    Yes → y = y - 1 // 下移，y 減 1\n                    No  → // 無效指令，忽略\nEnd // 完成所有移動\n→ Decision: x == 0 and y == 0? // 檢查是否回到原點\n    Yes → Return true // 回到原點，返回 true\n    No  → Return false // 未回到原點，返回 false",
      "generated_code": "import sys\n\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        \"\"\"判斷機器人是否回到原點。\"\"\"\n        x = y = 0\n        for move in moves:\n            if move == 'U':\n                y += 1\n            elif move == 'D':\n                y -= 1\n            elif move == 'L':\n                x -= 1\n            elif move == 'R':\n                x += 1\n        return x == 0 and y == 0\n\ndef main() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 若輸入為形式 like moves = \"UD\" ，則抽取雙引號中的字串\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        moves = data[start + 1:end]\n    else:\n        # 直接以輸入本身作為 moves\n        moves = data\n\n    solution = Solution()\n    result = solution.judgeCircle(moves)\n    # 輸出 true 或 false\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "moves = \"UD\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "moves = \"LL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode738.json",
    "problem_index_in_file": 0,
    "title": "Monotone Increasing Digits",
    "description_snippet": "An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisf...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps in Chinese. Task: Given n, find largest number <= n with monotone increasing digits (digits non-decreasing). This is known Leetcode 738. Approach: Convert n to digits array. Find first position where digits[i] > digits[i+1]. Decrement digits[i] by 1, set all following digits to 9. Then ensure preceding digits are also monotonic: after decrement may cause previous digits to violate condition; so we backtrack: while i>0 and digits[i-1] > digits[i], decrement digits[i-1] and set all following to 9. Then output number.\n\nVirtual code step by step. Use structure: Start, Step, Decision, etc.\n\nWe should show loops. Let's write steps:\n\nStart\n→ Step 1: Convert n to string digits array // 取得 n 的各位數字\n→ Step 2: Find first index i where digits[i] > digits[i+1] // 進行一次掃描\n→ Decision: 是否存在不遞增的相鄰對？ // 判斷是否需要調整\n    Yes → Step 3: 讓 digits[i] 減 1 // 降低該位\n    Yes → Step 4: 將 i+1 之後所有位設為 9 // 使數字最大\n    Yes → Step 5: i ← i - 1 // 回溯檢查前一位\n    Yes → Decision: i >= 0 AND digits[i] > digits[i+1]? // 檢查前一位是否仍違規\n        Yes → Repeat Step 3-5 // 迴圈\n        No → Step 6: 轉換 digits 為整數並返回 // 返回結果\n    No → Step 7: 直接將 digits 轉為整數並返回 // 原數已滿足條件\nEnd\n\nBut need to use arrow \"Yes →\" and \"No →\". We need to use virtual code arrows. Provide explanation after each line.\n\nWe need to ensure that the structure uses arrows and indentation maybe. Let's produce.\n\nWe should maintain each line with explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 把 n 轉成字串並拆分為數字陣列 digits // 取得每一位數字  \n→ Step 2: 找到第一個索引 i 使得 digits[i] > digits[i+1] // 搜尋不遞增的位置  \n→ Decision: 有沒有發現 digits[i] > digits[i+1]? // 判斷是否需要調整  \n    Yes → Step 3: 把 digits[i] 減 1 // 降低該位以尋求更小的合法數字  \n    Yes → Step 4: 將 i+1 之後的所有位數設為 9 // 使後續位數盡量大  \n    Yes → Step 5: i ← i - 1 // 回溯到前一位重新檢查是否還違規  \n    Yes → Decision: i >= 0 且 digits[i] > digits[i+1]? // 前一位是否仍違規  \n        Yes → Repeat Step 3,4,5,Decision // 依序重複調整直到合法  \n        No  → Step 6: 將 digits 重新拼成整數並返回 // 取得最終結果  \n    No  → Step 7: 直接把 digits 轉回整數並返回 // 原數已是遞增數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def monotoneIncreasingDigits(self, n: int) -> int:\n        # 把數字轉成字元陣列\n        digits = list(str(n))\n        i = 1\n        # 找到第一個不遞增的位置\n        while i < len(digits) and digits[i] >= digits[i - 1]:\n            i += 1\n        if i < len(digits):\n            # 從該位置往前回溯，修正前面可能的違規\n            while i > 0 and digits[i] < digits[i - 1]:\n                digits[i - 1] = str(int(digits[i - 1]) - 1)\n                i -= 1\n            # 後面所有位都設成 9，讓整數最大\n            for j in range(i + 1, len(digits)):\n                digits[j] = '9'\n        return int(''.join(digits))\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 從輸入中提取第一個整數\n    m = re.search(r'\\d+', data)\n    if m:\n        n = int(m.group())\n    else:\n        n = 0\n    # 計算並輸出結果\n    sol = Solution()\n    print(sol.monotoneIncreasingDigits(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "n = 1234",
          "expected_output": "1234",
          "success": true,
          "output": "1234"
        },
        {
          "example_index": 2,
          "input": "n = 332",
          "expected_output": "299",
          "success": true,
          "output": "299"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode729.json",
    "problem_index_in_file": 0,
    "title": "My Calendar I",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for this task. We need to explain step by step. Use Start, End, Decision: etc. No actual code. Virtual code lines. We need to represent algorithm: maintain a list of intervals, when book called, check for conflicts. Use binary search or sorted list. We can just present logic: on book, for each existing event, if overlap, return false else add and return true. But better to keep sorted list and find insertion position, then check neighbors for overlap. Virtual code: maintain sorted list of pairs.\n\nThus steps:\n\nStart // init MyCalendar\n→ Step: initialize empty event list // list of intervals\n\nWhen book(start, end):\n\n→ Step: create new interval [start, end)\n→ Decision: find index to insert sorted by start // binary search\n    Yes -> index determined\n→ Decision: check previous event if exists and end > prev.start? // actually need check prev.end > start\n    Yes → Step: return false // overlap\n→ Decision: check next event if exists and end > next.start? // Actually check end > next.start\n    Yes → Step: return false\n→ Step: insert event at index // insert into list\n→ Step: return true\n\nEnd // End of book method.\n\nWe also have MyCalendar() constructor.\n\nThus produce lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 MyCalendar 物件 // 建立一個空的事件列表  \n→ Step: events ← 空列表 // 用來儲存已預約的 [start, end) 事件  \n\n---  \nStart Book(start, end) // 呼叫 book 方法  \n→ Step: newInterval ← [start, end) // 先建立欲加入的區間  \n→ Decision: 在 events 中找出可插入的新區間起始位置 idx (按 start 排序) // 以二分搜尋取得索引  \n    Yes → Step: idx ← 計算得到的插入索引 // idx 為插入位置  \n→ Decision: 若 idx > 0 且 events[idx-1].end > start? // 檢查前一個事件是否與新區間重疊  \n    Yes → Step: return false // 有重疊，拒絕預約  \n    No  → Decision: 若 idx < events.size() 且 end > events[idx].start? // 檢查後一個事件是否重疊  \n        Yes → Step: return false // 有重疊，拒絕預約  \n        No  → Step: events.insert(idx, newInterval) // 插入新事件到正確位置  \n→ Step: return true // 預約成功  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyCalendar:\n    \"\"\"簡易的日曆，防止時間重疊。\"\"\"\n\n    def __init__(self):\n        # 存儲已預約的事件，格式為 (start, end)\n        self.bookings = []\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"若能成功預約則回傳 True，否則回傳 False。\"\"\"\n        for s, e in self.bookings:\n            # 兩個區間有重疊的條件\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef parse_input(data: str):\n    \"\"\"把輸入的字串轉成 ops 與 params。\"\"\"\n    # 找到第一個 '],'，把前面作為 ops，後面作為 params\n    idx = data.find('],')\n    if idx == -1:\n        raise ValueError(\"Input format error\")\n    ops_str = data[:idx+1]\n    params_str = data[idx+2:].strip()\n    ops = ast.literal_eval(ops_str)\n    params = ast.literal_eval(params_str)\n    return ops, params\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    ops, params = parse_input(raw)\n\n    result = []\n    calendar = None\n    for op, param in zip(ops, params):\n        if op == \"MyCalendar\":\n            calendar = MyCalendar()\n            result.append(None)\n        elif op == \"book\":\n            start, end = param\n            res = calendar.book(start, end)\n            result.append(res)\n        else:\n            # 其他操作未實作，略過\n            result.append(None)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true]'\nGot (Norm):      '[None,True,False,True]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true]'\nRaw Got:      '[None, True, False, True]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode278.json",
    "problem_index_in_file": 0,
    "title": "First Bad Version",
    "description_snippet": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode steps line by line with explanations. Problem: find first bad version using binary search minimize calls. Output in Chinese (繁體). Include arrows. Provide each line: e.g., Start, Step 1: Initialize low, high, etc. Then Decision, Yes, No. Also use End.\n\nMake sure each line has \"虛擬碼步驟\" and comment. Use format: `虛擬碼步驟 // 解釋`. Eg: `Start // 程式開始執行`. Use arrows: `→` etc. Indent decisions. Provide each step. Should avoid actual code but structure.\n\nLet's craft:\n\nStart\n→ Step 1: low = 1 // 初始最小版本號\n→ Step 2: high = n // 初始最大版本號\n→ Decision: low <= high? // 仍有未檢查版本範圍\n    Yes →\n        → Step 3: mid = low + (high - low) // 計算中點避免溢位\n        → Step 4: Call isBadVersion(mid) // 檢查中點是否為壞版本\n        → Decision: isBadVersion(mid)? // 中點是否壞\n            Yes →\n                → Step 5: high = mid - 1 // 壞版本至少在 mid 或更早\n                → Step 6: Record mid as current candidate // 記錄可能的第一壞版本\n            No →\n                → Step 7: low = mid + 1 // 壞版本必在更高版本\n    No →\n→ End // 找到第一壞版本\nNote: At end low will be candidate.\n\nBut need line by line. Also maybe need to show return low or candidate. Use End step.\n\nLet's format each line:\n\nStart // 程式開始執行\n→ Step 1: low = 1 // 設定搜尋範圍下界\n→ Step 2: high = n // 設定搜尋範圍上界\n→ Decision: low <= high? // 判斷是否還有未搜尋的版本\n    Yes →\n        → Step 3: mid = low + (high - low) // 取中間版本\n        → Step 4: Call isBadVersion(mid) // 呼叫 API 判斷中點是否壞\n        → Decision: isBadVersion(mid)? // 判斷中點是否為壞版本\n            Yes →\n                → Step 5: high = mid - 1 // 壞版本至少在 mid 或更早\n                → Step 6: Record mid // 暫存目前可能的第一壞版本\n            No  →\n                → Step 7: low = mid + 1 // 壞版本必在更高版本\n    No →\n→ End // 搜尋結束，low 即為第一個壞版本\n\nNeed to mention return low. Perhaps add Step 8: Return low. Add at end.\n\nLet's add Step 8 after loop ends but before End.\n\nAdd \"→ Step 8: Return low // 回傳第一個壞版本\" then End.\n\nBut loop end: Decision No branch? We need loop until low > high. Could use while structure. But our pseudocode uses decision loops.\n\nWe can express that after No branch we go back to Decision: low <= high? again. So maybe we need to add \"←\" back arrow.\n\nBut we can simply illustrate as iterative.\n\nBetter structure:\n\nStart\n→ Step 1: low = 1\n→ Step 2: high = n\n→ Decision: low <= high? // 仍有搜尋範圍\n    Yes →\n        → Step 3: mid = low + (high - low)\n        → Step 4: isBad = isBadVersion(mid)\n        → Decision: isBad? // 中點是否壞\n            Yes →\n                → Step 5: high = mid - 1\n                → Step 6: Record mid\n            No  →\n                → Step 7: low = mid + 1\n        ← 回到 Decision: low <= high? // 重新檢查\n    No  →\n→ Step 8: Return low // low 指向第一壞版本\nEnd\n\nBut formatting of loop arrow maybe unclear. But can show as indentation and after No branch go back to Decision: low <= high? using arrow. Might be accepted.\n\nLet's craft final answer accordingly. Ensure each line ends with comment. Use appropriate Chinese comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 1 // 設定搜尋範圍下界  \n→ Step 2: high = n // 設定搜尋範圍上界  \n→ Decision: low <= high? // 判斷是否還有未搜尋的版本  \n    Yes →  \n        → Step 3: mid = low + (high - low) // 取中間版本，避免整數溢位  \n        → Step 4: isBad = isBadVersion(mid) // 呼叫 API 判斷中點是否為壞版本  \n        → Decision: isBad? // 判斷中點是否壞  \n            Yes →  \n                → Step 5: high = mid - 1 // 壞版本至少在 mid 或更早  \n                → Step 6: Record mid // 暫存目前可能的第一壞版本  \n            No →  \n                → Step 7: low = mid + 1 // 壞版本必在更高版本  \n        ← 回到 Decision: low <= high? // 重新檢查搜尋範圍  \n    No →  \n→ Step 8: Return low // low 已指向第一個壞版本  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# Define the API that will be used by the Solution class.\n# The actual bad version will be set later in main.\nbad_version = None\ndef isBadVersion(version: int) -> bool:\n    \"\"\"Return True if the given version is bad.\"\"\"\n    return version >= bad_version\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        \"\"\"Find the first bad version using binary search.\"\"\"\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\ndef main() -> None:\n    \"\"\"Read input, find the first bad version, and print the result.\"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n    # Extract all integers from the input string.\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, bad = nums[0], nums[1]\n\n    # Set the global bad_version for the API.\n    global bad_version\n    bad_version = bad\n\n    # Solve the problem and print the answer.\n    result = Solution().firstBadVersion(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode81.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array II",
    "description_snippet": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line with explanation. The problem: find target in rotated sorted array with duplicates. Need efficient algorithm: use binary search variant handling duplicates: find pivot or just search with modified binary search. Approach: typical algorithm: while low <= high: mid = (low+high)//2; if nums[mid]==target return true; else if nums[low]==nums[mid]==nums[high] then low++ high--; else if nums[low]<=nums[mid] (left side sorted) then check if target between low and mid -> adjust high else low=mid+1; else right side sorted similar.\n\nWe output each line as virtual code with explanation.\n\nNeed to include Start, End, Decision. Also need arrow arrows.\n\nLet's create stepwise pseudocode.\n\nLine1: Start // program start\n\nLine2: → Step 1: Initialize low = 0, high = len(nums)-1 // set search boundaries\n\nLine3: → Decision: while low <= high? // check loop condition\n\n    Yes → Step 2: mid = (low + high) // 2 // compute middle index\n\n    Step 3: Decision: if nums[mid] == target? // target found?\n\n        Yes → Step 4: Return true // target exists\n\n        No  → Decision: if nums[low] == nums[mid] == nums[high]? // duplicates block\n\n            Yes → Step 5: low = low + 1 // skip duplicate low\n\n                → Step 6: high = high - 1 // skip duplicate high\n\n                → Step 7: Continue // back to while condition\n\n            No  → Decision: if nums[low] <= nums[mid]? // left side sorted\n\n                Yes → Decision: if nums[low] <= target < nums[mid]? // target in left half\n\n                    Yes → Step 8: high = mid - 1 // search left\n\n                    No  → Step 9: low = mid + 1 // search right\n\n                No  → Decision: if nums[mid] < target <= nums[high]? // target in right half\n\n                    Yes → Step 10: low = mid + 1 // search right\n\n                    No  → Step 11: high = mid - 1 // search left\n\nEnd // exit loop\n\n→ Step 12: Return false // target not found\n\nWe need to use arrow formatting: '→' before each step. For decision we need 'Decision:' line. Also nested decisions: indent with spaces. We must use 'Yes →' and 'No →'.\n\nMake sure each line has one step with comment. Use spaces. Provide explanation after //.\n\nLet's craft final output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: low = 0, high = len(nums) - 1 // 設定搜尋範圍\n→ Decision: low <= high? // 檢查是否還有未搜尋的區段\n    Yes → Step 2: mid = (low + high) // 2 // 計算中間索引\n    Step 3: Decision: nums[mid] == target? // 目標是否已找到\n        Yes → Step 4: Return true // 找到目標，結束\n        No  → Decision: nums[low] == nums[mid] == nums[high]? // 是否有重複值遮蔽排序區段\n            Yes → Step 5: low = low + 1 // 逐步移除左端重複值\n                → Step 6: high = high - 1 // 逐步移除右端重複值\n                → Step 7: Continue // 回到 while 條件檢查\n            No  → Decision: nums[low] <= nums[mid]? // 左半段是否已排序\n                Yes → Decision: nums[low] <= target < nums[mid]? // 目標在左半段\n                    Yes → Step 8: high = mid - 1 // 將搜尋範圍縮至左半段\n                    No  → Step 9: low = mid + 1 // 將搜尋範圍縮至右半段\n                No  → Decision: nums[mid] < target <= nums[high]? // 目標在右半段\n                    Yes → Step 10: low = mid + 1 // 將搜尋範圍縮至右半段\n                    No  → Step 11: high = mid - 1 // 將搜尋範圍縮至左半段\nEnd // 迴圈結束，未找到目標\n→ Step 12: Return false // 目標不存在於陣列中\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Expect input like: nums = [2,5,6,0,0,1,2], target = 0\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        # If the pattern doesn't match, try to parse a simpler format\n        # e.g., \"[1,2,3] 4\"\n        parts = data.replace(',', ' ').split()\n        try:\n            nums = eval(parts[0])\n            target = int(parts[1])\n        except Exception:\n            nums = []\n            target = 0\n    else:\n        nums = eval(match.group(1))\n        target = int(match.group(2))\n\n    result = Solution().search(nums, target)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,5,6,0,0,1,2], target = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [2,5,6,0,0,1,2], target = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode648.json",
    "problem_index_in_file": 0,
    "title": "Replace Words",
    "description_snippet": "In English, we have a concept called root, which can be followed by some other word to form another ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line explaining algorithm. The task: root dictionary, sentence, replace derivatives with root. If multiple roots match, choose shortest. Approach: Build a trie of roots for efficient matching. For each word in sentence, traverse trie; if match found, replace with root; else keep word. If multiple roots possible due to overlapping, the trie ensures earliest match because we stop at first matched root (since we prefer shortest). Implementation steps: Build trie from roots. Split sentence into words. For each word, search. Complexity O(total characters). Output sentence.\n\nWe need to produce steps using virtual code format: Start, → Step, Decision, etc. Use arrows and comments.\n\nLet's create pseudo-code. Example lines:\n\nStart // 程式開始\n\n→ Step 1: 初始化 Trie 節點 // 建立空樹\n\n→ For each root in dictionary: // 插入根字\n    → Step 2: 插入 root 到 Trie // 建構字典\n\n→ Step 3: 以空格拆分句子為 words // 取得單詞\n\n→ For each word in words:\n    → Decision: 是否存在在 Trie 的前綴？ // 查找\n        Yes → Step 4: 取得最短匹配根 // 透過 Trie 搜尋\n        No  → Step 5: 保留原單詞\n\n→ Step 6: 將所有處理後的單詞以空格連接 // 形成句子\n\n→ End // 輸出結果\n\nNeed to include explanation after each line. Use proper formatting.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的 Trie 樹節點 rootNode // 用於儲存所有根字  \n→ Decision: 迭代 dictionary 中的每個 root // 準備插入  \n    Yes → Step 2: 把 root 字串逐字插入 Trie，標記結束點 // 建構前綴樹  \n    No  → （無） // 迭代結束  \n→ Step 3: 以空格分割 sentence 為 words 陣列 // 取得句子中的每個單字  \n→ For each word in words: // 逐一處理每個單字  \n    → Decision: 該 word 是否有任何前綴在 Trie 中? // 判斷是否能被替換  \n        Yes → Step 4: 從 Trie 開始沿著 word 逐字探索，尋找最短的結束點 // 找到最短根  \n        No  → Step 5: 將原 word 直接加入結果陣列 // 沒有匹配的根  \n→ Step 6: 將結果陣列中的單字用空格連接成新句子 // 產生最終輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def replaceWords(self, dictionary, sentence):\n        # 建立 Trie\n        trie = {}\n        END = True\n\n        for root in dictionary:\n            node = trie\n            for ch in root:\n                node = node.setdefault(ch, {})\n            node[END] = root\n\n        def replace(word):\n            node = trie\n            for ch in word:\n                if ch not in node:\n                    break\n                node = node[ch]\n                if END in node:\n                    return node[END]\n            return word\n\n        return ' '.join(map(replace, sentence.split()))\n\n\ndef parse_input(text: str):\n    \"\"\"\n    解析輸入字串，取得 dictionary 與 sentence\n    期望輸入格式為：\n    dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\n    \"\"\"\n    # 匹配 dictionary 與 sentence\n    m = re.search(r'dictionary\\s*=\\s*\\[(.*?)\\]\\s*,\\s*sentence\\s*=\\s*\"(.*?)\"', text, re.S)\n    if not m:\n        raise ValueError(\"輸入格式不正確\")\n    dict_str, sentence = m.group(1), m.group(2)\n\n    # 解析 dictionary list\n    # 先使用 eval 讀取列表（列表中的元素已被雙引號包住）\n    try:\n        dictionary = eval(f'[{dict_str}]')\n    except Exception:\n        # 若 eval 失敗，則使用正則手動解析\n        dictionary = [x.strip().strip('\"').strip(\"'\") for x in re.findall(r'([\"\\'])(.*?)\\1', dict_str)]\n\n    return dictionary, sentence\n\n\ndef main():\n    input_text = sys.stdin.read()\n    if not input_text.strip():\n        return\n    dictionary, sentence = parse_input(input_text)\n    solution = Solution()\n    result = solution.replaceWords(dictionary, sentence)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"",
          "expected_output": "\"the cat was rat by the bat\"",
          "success": true,
          "output": "the cat was rat by the bat"
        },
        {
          "example_index": 1,
          "input": "dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"",
          "expected_output": "\"a a b c\"",
          "success": true,
          "output": "a a b c"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode435.json",
    "problem_index_in_file": 0,
    "title": "Non-overlapping Intervals",
    "description_snippet": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: given intervals, remove minimum to make non-overlapping. Standard algorithm: sort by end time, iterate, count non-overlapping; answer = total - count. Use greedy. Provide steps. Each line: Virtual Code Step + // explanation. Use arrows. Provide Start, End. Use Decision. Provide Yes/No branches.\n\nLet's craft.\n\nStep 1: Start.\n\nStep 2: Input intervals.\n\nStep 3: Sort intervals by end ascending.\n\nStep 4: Initialize count=0, current_end=-∞.\n\nStep 5: For each interval in sorted:\n\nDecision: if interval.start >= current_end? If yes: keep interval, set current_end = interval.end, count++.\n\nAfter loop: answer = total_intervals - count.\n\nOutput answer.\n\nEnd.\n\nAdd necessary arrows.\n\nOk. Ensure each line includes \"→\". Provide indentation for decisions. Use 'Decision:' etc. Provide comment after //.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 intervals // 取得所有區間的清單  \n→ Step 2: 以 intervals[i][1]（結束時間）升序排序 intervals // 方便採用貪心選取  \n→ Step 3: 初始化 count ← 0 // 用來計算保留的非重疊區間數量  \n→ Step 4: 初始化 current_end ← -∞ // 代表目前已選區間的結束時間  \n→ Step 5: 對每個區間 interval 在排序後的 intervals 執行  \n  Decision: 如果 interval[0] (開始時間) ≥ current_end? // 檢查是否與前一區間無重疊  \n   Yes → Step 6: 設 current_end ← interval[1] // 更新目前選取區間的結束時間  \n    → Step 7: count ← count + 1 // 保留此區間  \n   No  → Step 8: 跳過此區間 // 與前一區間重疊，需移除  \n→ Step 9: 計算 answer ← len(intervals) - count // 最少移除數 = 總數 - 保留數  \n→ Step 10: 輸出 answer // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def eraseOverlapIntervals(self, intervals):\n        if not intervals:\n            return 0\n\n        # 先按照結束時間升序排序\n        intervals.sort(key=lambda x: x[1])\n\n        # 用於追蹤目前已選區間的結束時間\n        end = intervals[0][1]\n        count = 1  # 已保留的非重疊區間數\n\n        for i in range(1, len(intervals)):\n            if intervals[i][0] >= end:\n                # 這個區間與前一個保留區間不重疊，保留它\n                end = intervals[i][1]\n                count += 1\n\n        # 需要移除的區間數 = 總數 - 保留數\n        return len(intervals) - count\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 取出第一個 '[' 開始的子字串，再用 literal_eval 解析成 list\n    start = data.find('[')\n    if start == -1:\n        intervals = []\n    else:\n        intervals_str = data[start:]\n        intervals = ast.literal_eval(intervals_str)\n\n    sol = Solution()\n    result = sol.eraseOverlapIntervals(intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[1,2],[1,2]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode710.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Blacklist",
    "description_snippet": "You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the algorithm design. Not actual code. We need to produce virtual pseudocode lines. The algorithm: typical solution is mapping blacklisted numbers above a threshold. Steps: compute M = n - len(blacklist). Build a set of blacklisted numbers. For each blacklisted number less than M, map to a whitelisted number from top. Then pick random integer in [0,M-1], if mapped, return mapping else return original. Provide explanation each line. Let's produce steps:\n\nStart, initialize, etc.\n\nWe need to produce line by line pseudocode.\n\nLet's produce:\n\nStart\n→ Step 1: Compute M = n - |blacklist| // number of allowed numbers\n→ Step 2: Create set B from blacklist // for O(1) lookup\n→ Step 3: Initialize empty map W // for blacklisted numbers below M\n→ Step 4: Set pointer w = n-1 // start from top of range\n→ Decision: If w in B? // find whitelisted numbers from top\n    Yes → Decrement w until w not in B // skip blacklisted\n    No  → Continue\n→ Decision: While there exists b in B with b < M? // map low blacklisted to high whitelisted\n    Yes → W[b] = w // map\n        w = w-1 // move pointer\n        continue loop\n    No  → Exit loop\n→ End Initialization // mapping ready\n→ Step 5: pick() // method\n    → Generate k = random integer in [0, M-1] // uniform\n    → Decision: If k in W? // is mapped\n        Yes → Return W[k] // whitelisted number\n        No  → Return k // allowed number\n\nAdd End.\n\nWe need to include \"End\" for whole algorithm? Use End after pick method.\n\nLet's output.\n\nEnsure each line has virtual code and comment. Use arrow \"→\" preceding each step? The example uses \"→ Step 1:\". We should follow that. Use indentation for nested decision branches. Use \"Decision:\" lines.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: M = n - |blacklist| // 計算可用數字的總數\n→ Step 2: B = Set(blacklist) // 建立黑名單集合，方便 O(1) 查詢\n→ Step 3: W = EmptyMap() // 用於映射低於 M 的黑名單數字到高位的白名單數字\n→ Step 4: w = n - 1 // 從最大值開始向下尋找可用白名單數字\n→ Decision: w in B? // 若 w 仍是黑名單，需遞減\n    Yes → w = w - 1 // 跳過黑名單數字\n    No  → // w 現在是白名單\n→ Decision: Exists b in B where b < M? // 是否還有低於 M 的黑名單數字需要映射\n    Yes → \n        → W[b] = w // 把低位黑名單映射到高位白名單\n        → w = w - 1 // 更新指標至下一個可能的白名單\n        → // 重複判斷\n    No  → // 所有必要的映射已完成\nEnd // 初始化完成\n\n→ Method: pick() // 取得隨機合法數字\n    → Step 5: k = RandomInt(0, M-1) // 在 [0, M-1] 之間均勻抽取\n    → Decision: k in W? // k 是否被映射（即原本是黑名單）\n        Yes → Return W[k] // 回傳映射後的合法數字\n        No  → Return k // 直接回傳合法數字\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # Number of allowed integers\n        self.size = n - len(blacklist)\n        # Map blacklisted numbers < size to whitelisted numbers >= size\n        self.mapping = {}\n        black_set = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                # Find next whitelisted number from the top\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # Random index in the compact range\n        idx = random.randint(0, self.size - 1)\n        # Return mapped value if it exists, otherwise the index itself\n        return self.mapping.get(idx, idx)\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n\n    # Parse commands and arguments\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)  # Constructor returns null\n        else:\n            method = getattr(obj, cmd)\n            results.append(method(*args))\n\n    # Output results in JSON format (None -> null)\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,0,0,4,1,4,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 0, 0, 4, 1, 4, 6]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode677.json",
    "problem_index_in_file": 0,
    "title": "Map Sum Pairs",
    "description_snippet": "Design a map that allows you to do the following:\n\nMaps a string key to a given value.\nReturns the s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, explaining. We need to design a MapSum class that can insert key-value and sum prefixes. This is a classic Trie with sum values. We need to produce steps, including initialization, insert, sum. Use virtual code syntax with arrows. Provide explanation after each line.\n\nWe need to output lines like \"Start // 程式開始執行\" etc. But we need to produce steps that define the algorithm.\n\nWe might structure as:\n\nStart // initialize MapSum\n→ Step 1: Define Node structure with children map and sum field // Trie node\n→ Step 2: Define MapSum class with root node // Root\n→ Step 3: Define insert method // Insert key\n→ Step 4: In insert, traverse and update sum\n→ Step 5: Define sum method // Sum prefix\n→ Step 6: In sum, traverse and return sum\nEnd\n\nBut we need to output \"逐行\" lines, each with \"虛擬碼步驟\" + \" // 解釋\". Use arrows for steps. Use \"Start\" \"End\" for program. Use \"Decision:\" if needed. The design may not need decisions.\n\nWe must not output actual code. Just pseudo-steps.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode，包含 children: map<char, TrieNode> 和 sum: int // 節點儲存子節點與前綴總和\n→ Step 2: 定義 MapSum 類別，包含 root: TrieNode 和 keyMap: map<string, int> // 以便更新已存在鍵的差值\n→ Step 3: MapSum() 初始化 root 為空節點，keyMap 為空 // 建構子\n→ Step 4: insert(key, val) // 插入或更新鍵值\n→     Decision: key 是否已存在?\n        Yes → oldVal ← keyMap[key] // 取得舊值\n        No  → oldVal ← 0 // 無舊值\n→     delta ← val - oldVal // 需要更新的差值\n→     keyMap[key] ← val // 更新 keyMap\n→     node ← root // 從根節點開始\n→     For each ch in key:\n→         node.sum ← node.sum + delta // 更新前綴總和\n→         If ch 不在 node.children:\n→             node.children[ch] ← new TrieNode() // 建立子節點\n→         node ← node.children[ch] // 移動到子節點\n→     node.sum ← node.sum + delta // 最後節點的總和也更新\n→ Step 5: sum(prefix) // 計算前綴總和\n→     node ← root // 從根節點開始\n→     For each ch in prefix:\n→         If ch 不在 node.children: Return 0 // 無此前綴\n→         node ← node.children[ch] // 移動到子節點\n→     Return node.sum // 前綴總和\nEnd // 程式執行結束\n\nWe need to ensure we include arrows and decisions properly. Use \"Decision:\" lines with indent. Also note that inside loop, we need to show steps. Use \"For each ch in key:\" etc.\n\nWe should keep it simple but show logic. Ensure each line has virtual code + // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode，包含 children: map<char, TrieNode> 與 sum: int // Trie 節點儲存子節點與該節點前綴的總和  \n→ Step 2: 定義 MapSum 類別，包含 root: TrieNode 與 keyMap: map<string, int> // keyMap 方便更新已存在鍵的差值  \n→ Step 3: MapSum() 初始化 root 為新 TrieNode，keyMap 為空 map // 建構子設定初始狀態  \n→ Step 4: insert(key, val) // 插入或更新鍵值  \n→     Decision: key 是否已存在? // 判斷是否為更新操作  \n        Yes → oldVal ← keyMap[key] // 取得舊值  \n        No  → oldVal ← 0 // 無舊值  \n→     delta ← val - oldVal // 計算需要更新的差值  \n→     keyMap[key] ← val // 更新 keyMap 以備未來查詢  \n→     node ← root // 從根節點開始遍歷  \n→     For each ch in key: // 逐字處理鍵  \n→         node.sum ← node.sum + delta // 更新目前節點的前綴總和  \n→         If ch 不在 node.children: // 若子節點不存在  \n→             node.children[ch] ← new TrieNode() // 創建新節點  \n→         node ← node.children[ch] // 轉到子節點  \n→     node.sum ← node.sum + delta // 最後節點也需更新總和  \n→ Step 5: sum(prefix) // 計算前綴總和  \n→     node ← root // 從根節點開始  \n→     For each ch in prefix: // 逐字遍歷前綴  \n→         If ch 不在 node.children: // 若不存在該前綴  \n→             Return 0 // 沒有任何鍵符合  \n→         node ← node.children[ch] // 移動到子節點  \n→     Return node.sum // 回傳前綴對應的總和值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_map = {}\n\n    def insert(self, key: str, val: int) -> None:\n        # 計算差值，方便更新前綴總和\n        delta = val - self.key_map.get(key, 0)\n        self.key_map[key] = val\n\n        node = self.root\n        node.sum += delta\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main() -> None:\n    # 讀取所有非空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not lines:\n        return\n\n    ops = ast.literal_eval(lines[0])      # 例如 [\"MapSum\", \"insert\", \"sum\", ...]\n    args = ast.literal_eval(lines[1])     # 例如 [[], [\"apple\", 3], [\"ap\"], ...]\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MapSum\":\n            obj = MapSum()\n            result.append(None)           # null 對應於 None\n        elif op == \"insert\":\n            obj.insert(*arg)\n            result.append(None)\n        elif op == \"sum\":\n            result.append(obj.sum(*arg))\n\n    # 輸出 JSON 格式，None 會自動轉為 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpxlf1jh7z.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpxlf1jh7z.py\", line 43, in main\n    args = ast.literal_eval(lines[1])     # 例如 [[], [\"apple\", 3], [\"ap\"], ...]\n                            ~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode137.json",
    "problem_index_in_file": 0,
    "title": "Single Number II",
    "description_snippet": "Given an integer array nums where every element appears three times except for one, which appears ex...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code step-by-step for algorithm: Find single element in array where every other appears three times. Classic bitwise solution: maintain ones and twos bitmasks.\n\nPseudocode: Start, initialize ones=0, twos=0. For each num: update ones = (ones XOR num) & ~twos; twos = (twos XOR num) & ~ones; After loop return ones.\n\nAlternatively use counting bits: iterate bits 0-31 accumulate counts %3.\n\nBut they want constant space, linear time. We'll produce bitmask solution.\n\nWe'll produce lines with arrows and explanation.\n\nNeed to output each line with \"虛擬碼步驟 // 解釋\". Use arrow \"→\".\n\nInclude Start, End. Use Decision maybe for loops.\n\nLet's produce:\n\nStart // 開始執行\n→ Initialize ones = 0 // 用來儲存出現一次的位\n→ Initialize twos = 0 // 用來儲存出現兩次的位\n→ Decision: 對於陣列中每個元素 num? // 迴圈遍歷\n    → Step: 更新 ones = (ones XOR num) & ~twos // 新數字加入一次，已在 twos 的位不變\n    → Step: 更新 twos = (twos XOR num) & ~ones // 新數字加入兩次，已在 ones 的位不變\n    → Continue // 繼續迴圈\n→ End Loop // 迴圈結束\n→ Step: 回傳 ones // ones 中即為只出現一次的數\nEnd // 程式結束\n\nBut need to use arrows for each line. We can include indentation for Decision. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize ones = 0 // 用來儲存每一位只出現一次的數字  \n→ Initialize twos = 0 // 用來儲存每一位出現兩次的數字  \n\n→ Decision: 迭代陣列 nums 中的每個元素 num?  \n → Step: 更新 ones = (ones XOR num) & ~twos // 將 num 加入 ones，若該位已在 twos 中則忽略  \n → Step: 更新 twos = (twos XOR num) & ~ones // 將 num 加入 twos，若該位已在 ones 中則忽略  \n → Continue // 繼續迴圈  \n\n→ End // 迴圈結束  \n\n→ Step: 回傳 ones // ones 只包含出現一次的數字的位，為答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def singleNumber(self, nums):\n        ones, twos = 0, 0\n        for num in nums:\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n        return ones\n\ndef parse_input(text: str):\n    \"\"\"\n    將輸入文字中含有的列表解析成 Python list。\n    允許輸入類似 'nums = [2,2,3,2]' 或直接 '[2,2,3,2]'。\n    \"\"\"\n    # 先找方括號中的內容\n    match = re.search(r'\\[(.*?)\\]', text)\n    if not match:\n        return []\n\n    # 只保留括號內的字串，並使用 eval 轉成 list\n    inner = match.group(1)\n    # 若內容是空字串，直接回傳空列表\n    if not inner.strip():\n        return []\n    return eval(f'[{inner}]')\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有文字\n    raw_input = sys.stdin.read()\n    # 解析成整數列表\n    nums = parse_input(raw_input)\n\n    # 計算結果\n    result = Solution().singleNumber(nums)\n\n    # 輸出結果到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "success": true,
          "output": "99"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode478.json",
    "problem_index_in_file": 0,
    "title": "Generate Random Point in a Circle",
    "description_snippet": "Given the radius and the position of the center of a circle, implement the function randPoint which ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: given radius and center, generate uniform random point inside circle. Use polar coordinates: random angle theta uniform [0,2π), random radius r = sqrt(random_uniform[0,1]) * radius. Then x = x_center + r*cos(theta), y = y_center + r*sin(theta). We'll write steps: initialize radius, x_center, y_center; randPoint: generate uniform u1, u2; theta = 2π*u1; r = sqrt(u2)*radius; x = x_center + r*cos(theta); y = y_center + r*sin(theta); return [x,y].\n\nWe need virtual code lines with explanation. Use arrow \"→\". Start and End. Provide decision if any? Not necessary. We can show random generation. Use Step labels.\n\nWe produce lines. Use \"Start\" then \"→ Step 1: 讀取半徑 radius, x_center, y_center\" but that's inside constructor. We'll produce constructor steps then method. Probably need to show entire class. So structure: Start, Step: 初始化Solution, End? Actually we need method randPoint. So maybe \"Start\" then \"→ Step 1: 存儲半徑 radius, x_center, y_center\" then \"→ Step 2: randPoint() 函數\" then inside generate random. We'll produce separate steps inside randPoint.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\" format.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: Solution(radius, x_center, y_center) // 初始化物件並儲存半徑與圓心座標\n→ Step 2: randPoint() // 定義產生隨機點的函式\n    → Step 2.1: u1 = random_uniform_0_1() // 產生 0~1 之間的隨機數，用於角度\n    → Step 2.2: u2 = random_uniform_0_1() // 產生 0~1 之間的隨機數，用於半徑\n    → Step 2.3: theta = 2π * u1 // 將 u1 轉換為 0~2π 的角度\n    → Step 2.4: r = sqrt(u2) * radius // 取平方根確保半徑分佈均勻\n    → Step 2.5: x = x_center + r * cos(theta) // 轉換為 Cartesian 坐標\n    → Step 2.6: y = y_center + r * sin(theta) // 轉換為 Cartesian 坐標\n    → Step 2.7: return [x, y] // 返回隨機點座標\nEnd // 程式執行結束\n\nYes. Provide explanation after each line. Ensure each line includes explanation. The lines inside method should be indented? Not required but we can maintain. Use arrow lines. Provide \"→\" for each step. For nested steps maybe indent. Use \"→\" for each line. We can also use \"→\" for each step inside method. Provide explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Solution(radius, x_center, y_center) // 初始化物件並儲存半徑與圓心座標  \n→ Step 2: randPoint() // 定義產生隨機點的函式  \n    → Step 2.1: u1 = random_uniform_0_1() // 產生 0~1 之間的隨機數，用於角度  \n    → Step 2.2: u2 = random_uniform_0_1() // 產生 0~1 之間的隨機數，用於半徑  \n    → Step 2.3: theta = 2π * u1 // 將 u1 轉換為 0~2π 的角度  \n    → Step 2.4: r = sqrt(u2) * radius // 取平方根確保半徑分佈均勻  \n    → Step 2.5: x = x_center + r * cos(theta) // 轉換為 Cartesian 坐標  \n    → Step 2.6: y = y_center + r * sin(theta) // 轉換為 Cartesian 坐標  \n    → Step 2.7: return [x, y] // 返回隨機點座標  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機角度\n        theta = random.uniform(0, 2 * math.pi)\n        # 隨機半徑，sqrt 保證均勻分佈\n        r = self.radius * math.sqrt(random.random())\n        # 轉換為直角座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    methods = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    results = []\n    instance = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            instance = Solution(*args)\n            results.append(None)\n        else:\n            func = getattr(instance, method)\n            results.append(func(*args))\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.8400636824342482,0.017543703110113135],[0.15135165753317772,-0.8987176855177527],[-0.021313481589751757,-0.30744713050589356]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.8400636824342482, 0.017543703110113135], [0.15135165753317772, -0.8987176855177527], [-0.021313481589751757, -0.30744713050589356]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode77.json",
    "problem_index_in_file": 0,
    "title": "Combinations",
    "description_snippet": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all combinations of k numbers from 1..n. The algorithm: backtracking DFS. Steps: Start, define result list, call backtrack(start, path). backtrack: if len(path)==k, add copy to result. else for i from start to n: path add i, backtrack(i+1, path), remove last. Return result. We need to output in given format: each line with virtual code step and comment. Use arrows, Start, End, Decision, etc. Ensure we use \"→\" for sequential steps. Also use indentation for decisions.\n\nWe'll produce steps: Start, → Step: initialize result list, → Step: define backtrack function, → Step: call backtrack(1, []), → Decision: if len(path)==k? Yes→Add to result No→Loop i. For loop: Decision: if i>n? maybe we can integrate in loop. We'll keep simpler: In backtrack, for i from start to n: Step: add i to path, → Step: backtrack(i+1, path), → Step: remove last from path. End.\n\nFinally End. Provide comments. Let's produce lines.\n\nAlso use proper virtual code: \"Step\" maybe \"Action\". We'll just use \"Step\" like example. Use \"Decision:\" etc.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step: 建立空的結果列表 results = [] // 用於儲存所有組合\n→ Step: 定義遞迴函式 backtrack(start, path) // 產生組合\n→ Step: 呼叫 backtrack(1, []) // 從 1 開始遞迴\n→ Decision: path 長度是否等於 k? // 檢查是否已選 k 個數字\n    Yes → Step: 把 path 複製後加入 results // 找到一個合法組合\n    No  → Step: 循環 i 從 start 到 n\n        → Step: path 加入 i // 加入目前數字\n        → Step: backtrack(i+1, path) // 以 i+1 為下一個起點繼續遞迴\n        → Step: path 移除最後一個元素 // 回溯，移除 i，嘗試其他數字\n→ Step: 回傳 results // 返回所有組合\nEnd // 程式執行結束\n\nMake sure to include the arrows appropriately. Also \"→ Decision:\" should be aligned. Also each line after the arrow includes comment. Use \"[空格]\" then comment. Provide arrow for decisions indent maybe two spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 建立空的結果列表 results = [] // 用於儲存所有組合  \n→ Step: 定義遞迴函式 backtrack(start, path) // 產生組合  \n→ Step: 呼叫 backtrack(1, []) // 從 1 開始遞迴  \n→ Decision: path 長度是否等於 k? // 檢查是否已選 k 個數字  \n  Yes → Step: 把 path 複製後加入 results // 找到一個合法組合  \n  No  → Step: 循環 i 從 start 到 n // 嘗試所有可能的數字  \n    → Step: path 加入 i // 加入目前數字  \n    → Step: backtrack(i+1, path) // 以 i+1 為下一個起點繼續遞迴  \n    → Step: path 移除最後一個元素 // 回溯，移除 i，嘗試其他數字  \n→ Step: 回傳 results // 返回所有組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef combine(n: int, k: int):\n    \"\"\"\n    回傳從 1..n 選 k 個數字的所有組合。\n    使用深度優先搜尋（DFS）與回溯法。\n    \"\"\"\n    res = []\n\n    def backtrack(start: int, path: list):\n        # 判斷是否已選 k 個數字\n        if len(path) == k:\n            res.append(path[:])  # 加入結果\n            return\n        # 從 start 開始嘗試所有可能的數字\n        for i in range(start, n + 1):\n            path.append(i)           # 加入目前數字\n            backtrack(i + 1, path)   # 以 i+1 為下一個起點繼續遞迴\n            path.pop()               # 回溯：移除最後一個數字\n\n    backtrack(1, [])  # 從 1 開始遞迴\n    return res\n\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析 n 與 k，計算並輸出所有組合。\n    \"\"\"\n    data = sys.stdin.read()\n    # 取出所有整數（可處理「n = 4, k = 2」或「4 2」等格式）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = combine(n, k)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4, k = 2",
          "expected_output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
          "success": true,
          "output": "[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode365.json",
    "problem_index_in_file": 0,
    "title": "Water and Jug Problem",
    "description_snippet": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Ret...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: \"Water Jug problem\". Provide algorithm steps: using GCD condition. Steps: compute gcd(x,y). If target> x+y return false. If target % gcd==0 return true else false. So produce virtual code. Provide each line with comment. Use arrow etc. Use Start, Decision, etc. No actual code. Just pseudo steps. Ensure each line has \"→\" etc. Let's produce:\n\nStart\n→ Step 1: Compute gcd = GCD(x,y) // calculate greatest common divisor\n→ Decision: target > x + y? // check if target exceeds total capacity\n    Yes → Step 2: Return False // cannot measure more than total capacity\n    No  →\n→ Decision: target % gcd == 0? // check divisibility by gcd\n    Yes → Step 3: Return True // reachable\n    No  → Step 4: Return False // not reachable\nEnd\n\nMake sure format. Provide each line with comment. Also add indentation for nested decisions. Use arrow. Ok.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得 x, y, target 的值 // 從使用者或測試資料取得兩個壺的容量與目標量\n→ Step 2: 計算 gcd = GCD(x, y) // 先算出兩個容量的最大公因數\n→ Decision: target > x + y? // 目標量是否超過兩個壺的總容量\n    Yes → Step 3: 回傳 False // 超過總容量則不可能達成\n    No  →\n→ Decision: target % gcd == 0? // 目標量是否能被 gcd 整除\n    Yes → Step 4: 回傳 True // 可達成目標量\n    No  → Step 5: 回傳 False // 無法達成目標量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\n\nclass Solution:\n    def canMeasureWater(self, x: int, y: int, target: int) -> bool:\n        # 如果目標量大於兩個壺的總容量，直接無法達成\n        if target > x + y:\n            return False\n        # 只有當目標量能被兩個容量的最大公因數整除時才能達成\n        return target % math.gcd(x, y) == 0\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 透過正則抓取所有整數\n    numbers = [int(num) for num in re.findall(r'-?\\d+', data)]\n    if len(numbers) < 3:\n        return\n    x, y, target = numbers[0], numbers[1], numbers[2]\n    sol = Solution()\n    result = sol.canMeasureWater(x, y, target)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    import re\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 3, y = 5, target = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = 2, y = 6, target = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 1, y = 2, target = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode689.json",
    "problem_index_in_file": 0,
    "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
    "description_snippet": "Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code for the described algorithm: find three non-overlapping subarrays of length k with maximum sum. Standard LeetCode problem \"Maximum Sum of 3 Non-Overlapping Subarrays\". Approach: compute sums of each k-length subarray, then use DP or prefix best arrays. We can produce a step-by-step algorithm in virtual code.\n\nWe need to output lines, each line: virtual step + space + comment.\n\nWe'll produce Start, End, Decision, etc. We must not output actual code.\n\nSo lines:\n\nStart\n→ Compute array sum of length k subarrays: sums[i]\n→ Compute left best indices: left[i] = index of max sum in [0..i]\n→ Compute right best indices: right[i] = index of max sum in [i..end]\n→ For middle index j from k to n-2k:\n    → leftIdx = left[j-k]\n    → rightIdx = right[j+k]\n    → total = sums[leftIdx] + sums[j] + sums[rightIdx]\n    → if total > bestSum or (total==bestSum and [leftIdx,j,rightIdx] lexicographically smaller):\n        → bestSum = total\n        → result = [leftIdx, j, rightIdx]\nEnd\n\nWe need to include explanation after each line.\n\nWe need to ensure arrow formatting: \"→\" and indentation for decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得陣列長度 n = nums.length // 取得輸入陣列長度\n→ Step 2: 建立 sums[0 … n-k] 並為每個起始位置計算 k 長度子陣列之和 // 前置工作，計算所有可能的子陣列總和\n→ Decision: 如果 k > n? // 確認 k 是否合法\n    Yes → End // k 大於陣列長度，直接結束\n    No  → \n→ Step 3: 建立 leftBest[0 … n-k] // leftBest[i] 代表 0~i 內最大 sums 的起始位置\n    → leftBest[0] = 0 // 初始值\n    → For i = 1 to n-k:\n        → if sums[i] > sums[leftBest[i-1]]? // 判斷是否更新左側最佳位置\n            Yes → leftBest[i] = i\n            No  → leftBest[i] = leftBest[i-1]\n→ Step 4: 建立 rightBest[0 … n-k] // rightBest[i] 代表 i~n-k 內最大 sums 的起始位置\n    → rightBest[n-k] = n-k // 初始值\n    → For i = n-k-1 down to 0:\n        → if sums[i] >= sums[rightBest[i+1]]? // 判斷是否更新右側最佳位置（>= 以確保字典序最小）\n            Yes → rightBest[i] = i\n            No  → rightBest[i] = rightBest[i+1]\n→ Step 5: 初始化 bestSum = -∞, result = [] // 用於儲存最佳總和及其三個起始位置\n→ For j = k to n-2k: // j 為中間子陣列的起始位置\n    → leftIdx = leftBest[j-k] // 左側最佳位置\n    → rightIdx = rightBest[j+k] // 右側最佳位置\n    → total = sums[leftIdx] + sums[j] + sums[rightIdx] // 計算三段總和\n    → Decision: total > bestSum? // 判斷是否比目前最佳更好\n        Yes → bestSum = total, result = [leftIdx, j, rightIdx] // 更新最佳結果\n        No  → Decision: total == bestSum? // 若相等，需比較字典序\n            Yes → if [leftIdx, j, rightIdx] lexicographically smaller than result? // 比較字典序\n                Yes → result = [leftIdx, j, rightIdx] // 更新為字典序較小的結果\n                No  → No change\n            No  → No change\n→ End // 程式執行結束，result 為所求三個子陣列的起始位置\n\n這份虛擬碼描述了從輸入數組計算子陣列和，使用前綴最佳與後綴最佳來快速決定左、中、右三段的位置，並在迴圈中選擇總和最大的組合，若多組等和則取字典序最小的三個起始位置。",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums, k):\n        n = len(nums)\n        # Compute sums of all k-length subarrays\n        w = [0] * (n - k + 1)\n        window_sum = sum(nums[:k])\n        w[0] = window_sum\n        for i in range(1, n - k + 1):\n            window_sum += nums[i + k - 1] - nums[i - 1]\n            w[i] = window_sum\n\n        # left[i] = index of max sum subarray in w[0..i]\n        left = [0] * len(w)\n        best = 0\n        for i in range(len(w)):\n            if w[i] > w[best]:\n                best = i\n            left[i] = best\n\n        # right[i] = index of max sum subarray in w[i..end]\n        right = [0] * len(w)\n        best = len(w) - 1\n        for i in range(len(w) - 1, -1, -1):\n            if w[i] >= w[best]:\n                best = i\n            right[i] = best\n\n        # Find best combination\n        best_sum = -1\n        result = []\n        for mid in range(k, len(w) - k):\n            left_idx = left[mid - k]\n            right_idx = right[mid + k]\n            total = w[left_idx] + w[mid] + w[right_idx]\n            if total > best_sum:\n                best_sum = total\n                result = [left_idx, mid, right_idx]\n        return result\n\ndef parse_input(data: str):\n    \"\"\"Parse input like 'nums = [1,2,1,2,6,7,5,1], k = 2'.\"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if not nums_match or not k_match:\n        raise ValueError(\"Invalid input format.\")\n    nums_str = nums_match.group(1)\n    k_str = k_match.group(1)\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read().strip()\n    if not raw_data:\n        sys.exit()\n    nums, k = parse_input(raw_data)\n    solution = Solution()\n    result = solution.maxSumOfThreeSubarrays(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,2,6,7,5,1], k = 2",
          "expected_output": "[0,3,5]",
          "success": true,
          "output": "[0, 3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,2,1,2,1,2,1], k = 2",
          "expected_output": "[0,2,4]",
          "success": true,
          "output": "[0, 2, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode680.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome II",
    "description_snippet": "Given a string s, return true if the s can be palindrome after deleting at most one character from i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode line by line with explanations. Use the arrow format. We need to provide Start, steps, decision, End. Provide algorithm: two pointers, compare, if mismatch, try skip left or right. Return true if palindrome. Pseudocode. Use step numbers. Provide explanatory comments after //. Ensure each line follows \"虛擬碼步驟 [space] // 解釋\".\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義指標 left ← 0, right ← length(s) - 1 // 初始化左右指標  \n→ Decision: 是否還存在可比較的字符? (left < right) // 檢查是否已經完成比較  \n    Yes → Step 2: 如果 s[left] == s[right]? // 判斷左右兩端字符是否相等  \n        Yes → Step 3: left ← left + 1, right ← right - 1 // 相等則兩端縮小  \n        No  → Decision: 只允許刪除一個字符? (已刪除? false) // 檢查是否已經刪除過  \n            Yes → Step 4: Return false // 已刪除過且仍不相等，無法成為回文  \n            No  → Decision: 嘗試刪除左側字符? (s[left+1] == s[right])  \n                Yes → Step 5: left ← left + 2, right ← right - 1 // 刪除左側字符後繼續比較  \n                No  → Decision: 嘗試刪除右側字符? (s[left] == s[right-1])  \n                    Yes → Step 6: left ← left + 1, right ← right - 2 // 刪除右側字符後繼續比較  \n                    No  → Step 7: Return false // 兩種刪除都不行，返回假  \n    No  → Step 8: Return true // 所有字符已匹配，或只剩一個字符，符合條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        \"\"\"判斷字串 s 是否能在刪除最多一個字元後成為回文。\"\"\"\n        def is_palindrome_range(i: int, j: int) -> bool:\n            \"\"\"檢查 s[i:j+1] 是否為回文。\"\"\"\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] != s[j]:\n                # 只允許刪除一次，嘗試刪除左側或右側字元\n                return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1)\n            i += 1\n            j -= 1\n        return True\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入，支持「s = \"xxx\"」或直接輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入字串\n    if '=' in data:\n        s_part = data.split('=', 1)[1].strip()\n    else:\n        s_part = data\n\n    # 去除可能存在的單引號或雙引號\n    if (s_part.startswith('\"') and s_part.endswith('\"')) or \\\n       (s_part.startswith(\"'\") and s_part.endswith(\"'\")):\n        s_part = s_part[1:-1]\n\n    solution = Solution()\n    result = solution.validPalindrome(s_part)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aba\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"abca\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"abc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode730.json",
    "problem_index_in_file": 0,
    "title": "Count Different Palindromic Subsequences",
    "description_snippet": "Given a string s, return the number of different non-empty palindromic subsequences in s. Since the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the described problem: count distinct non-empty palindromic subsequences of string s. The algorithm: dynamic programming with 4 pointers? Standard solution uses DP[i][j] count of distinct palindromic subsequences in substring s[i..j]. Recurrence uses next/prev occurrences of each character. Complexity O(26 * n^2). Provide virtual code line by line with explanations. Need to output virtual code with arrows and decisions. Should include Start, End. Provide steps: Input string s, define MOD, build next/prev arrays, DP table. Iterate length 1 to n. Base case for length 1: DP[i][i] =1. For longer lengths: let l=i, r=j, if s[l]!=s[r]: DP[l][r] = DP[l+1][r] + DP[l][r-1] - DP[l+1][r-1]; else: find nl = next occurrence of s[l] after l, nr = prev occurrence of s[r] before r; if nl>nr (no same char inside): DP[l][r] = 2*DP[l+1][r-1] +2; else if nl==nr (one same char inside): DP[l][r] = 2*DP[l+1][r-1] +1; else: DP[l][r] = 2*DP[l+1][r-1] - DP[nl+1][nr-1]. Mod adjust.\n\nFinally answer DP[0][n-1] mod MOD.\n\nWe need to produce virtual code steps line by line. Each line: \"虛擬碼步驟 // 解釋\". We need arrow syntax and decisions. Example: \"Start // 程式開始執行\". For loops we can use arrows: \"→ For i in 0..n-1\". Provide decision steps.\n\nLet's craft.\n\nWe can also incorporate next and prev array building: compute nextPos[26][n] etc. Use arrays. We'll show loops.\n\nBe careful to maintain formatting: each line ends with // and explanation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: s // 讀取給定字串  \n→ Let n ← length(s) // 取得字串長度  \n→ Let MOD ← 10^9 + 7 // 取模數  \n→ Initialise next[26][n] ← -1 // 下一個相同字元的位置表  \n→ Initialise prev[26][n] ← -1 // 上一個相同字元的位置表  \n\n→ // 建立 next 陣列（從右往左掃描）  \n    → For i from n-1 downto 0  \n        → For c from 0 to 25  \n            → Decision: 若 c == s[i] ?  \n                Yes → next[c][i] ← i // 本位為相同字元  \n                No  → next[c][i] ← next[c][i+1] // 取右側下一個位置  \n→ // 建立 prev 陣列（從左往右掃描）  \n    → For i from 0 to n-1  \n        → For c from 0 to 25  \n            → Decision: 若 c == s[i] ?  \n                Yes → prev[c][i] ← i // 本位為相同字元  \n                No  → prev[c][i] ← prev[c][i-1] // 取左側上一個位置  \n\n→ 初始化 DP[n][n] ← 0 // DP[i][j] 表示子字串 s[i..j] 的不同回文子序列數  \n→ // 長度為 1 的子字串  \n    → For i from 0 to n-1  \n        → DP[i][i] ← 1 // 單個字元本身即為回文  \n\n→ // 逐長度遞推填 DP  \n    → For len from 2 to n  \n        → For l from 0 to n-len  \n            → Let r ← l + len - 1 // 右端位置  \n            → Decision: 若 s[l] != s[r] ?  \n                Yes →  \n                    → DP[l][r] ← DP[l+1][r] + DP[l][r-1] - DP[l+1][r-1] // 合併子問題  \n                    → DP[l][r] ← (DP[l][r] % MOD + MOD) % MOD // 防止負數  \n                No →  \n                    → Let nl ← next[ s[l] ][l] // 下一個同字元位置  \n                    → Let nr ← prev[ s[r] ][r] // 上一個同字元位置  \n                    → Decision: 若 nl > nr ? // 子字串內無同字元  \n                        Yes →  \n                            → DP[l][r] ← 2 * DP[l+1][r-1] + 2 // 新增兩種結尾  \n                            → DP[l][r] ← DP[l][r] % MOD  \n                        No → Decision: 若 nl == nr ? // 子字串內恰好一個同字元  \n                            Yes →  \n                                → DP[l][r] ← 2 * DP[l+1][r-1] + 1 // 新增一種結尾  \n                                → DP[l][r] ← DP[l][r] % MOD  \n                            No → // 子字串內有多於一個同字元  \n                                → DP[l][r] ← 2 * DP[l+1][r-1] - DP[nl+1][nr-1] // 去除重複  \n                                → DP[l][r] ← (DP[l][r] % MOD + MOD) % MOD  \n\n→ // 結果  \n→ Output: DP[0][n-1] % MOD // 取得整個字串的答案  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                l, r = i + 1, j - 1\n                while l <= r and s[l] != s[i]:\n                    l += 1\n                while l <= r and s[r] != s[i]:\n                    r -= 1\n                if l > r:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n                elif l == r:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] * 2 - dp[l + 1][r - 1]\n            else:\n                dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n            dp[i][j] = (dp[i][j] + MOD) % MOD\n    return dp[0][n - 1] % MOD\n\ndef parse_input() -> str:\n    data = sys.stdin.read()\n    data = data.strip()\n    # Try to extract s = \"...\"\n    m = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    if m:\n        return m.group(1)\n    # If not found, remove any surrounding quotes and whitespace\n    return data.strip().strip('\"')\n\nif __name__ == \"__main__\":\n    s = parse_input()\n    result = count_palindromic_subsequences(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "success": true,
          "output": "104860361"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode5.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Substring",
    "description_snippet": "Given a string s, return the longest palindromic substring in s....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for longest palindromic substring problem. Use virtual code steps line by line, with explanations. Use arrows and structure. Should avoid actual code. Use Start, End, Decision: etc. Probably include steps: Start, set variables, iterate over each character as center, expand left/right, keep longest. So produce pseudocode lines like:\n\nStart // begin\n→ Step 1: Initialize longest as empty // set initial longest substring\n→ Step 2: For each index i in s: // iterate over each char\n    → Step 2a: ExpandOdd(i) // odd-length palindrome\n    → Step 2b: ExpandEven(i) // even-length palindrome\n    → Decision: If new palindrome longer than longest? // compare lengths\n        Yes → Update longest // store new longer palindrome\n        No → Continue\n→ End // finish\n\nWe need to include decisions. For expansion, we need separate substeps: ExpandOdd center at i: left=i-1, right=i+1, while left>=0 && right<n && s[left]==s[right] { left--; right++; } substring = s[left+1:right]; return length, etc.\n\nBut each line should be one pseudocode step. Use arrows. Must maintain readability.\n\nAlso need to include variable definitions: s length n.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: n ← length(s) // 獲取字串長度\n\nLine 3: → Step 2: longest ← \"\" // 初始化最長回文子字串\n\nLine 4: → Step 3: For i from 0 to n-1: // 遍歷每個字符作為中心\n\nLine 5: → Step 4: left ← i-1 ; right ← i+1 // 為奇數長度設定左右指標\n\nLine 6: → Decision: 是否 s[left]==s[right] 且 left>=0 且 right<n? // 檢查是否可展開\n\nLine 7:     Yes → Step 5: ExpandOdd while left>=0 and right<n and s[left]==s[right] { left--; right++; } // 擴展奇數長度回文\n\nLine 8:     Yes → Step 6: currentOdd ← substring(s, left+1, right) // 取得擴展後的子字串\n\nLine 9:     No  → Step 6: currentOdd ← s[i] // 單個字符本身\n\nLine 10: → Decision: length(currentOdd) > length(longest)? // 判斷是否更新最長\n\nLine 11:     Yes → Step 7: longest ← currentOdd // 更新最長回文\n\nLine 12:     No  →  // 不更新\n\nLine 13: → Step 8: left ← i ; right ← i+1 // 為偶數長度設定左右指標\n\nLine 14: → Decision: s[left]==s[right] 且 left>=0 且 right<n? // 檢查是否可展開\n\nLine 15:     Yes → Step 9: ExpandEven while left>=0 and right<n and s[left]==s[right] { left--; right++; } // 擴展偶數長度回文\n\nLine 16:     Yes → Step 10: currentEven ← substring(s, left+1, right) // 取得擴展後的子字串\n\nLine 17:     No  → Step 10: currentEven ← \"\" // 無偶數長度回文\n\nLine 18: → Decision: length(currentEven) > length(longest)? // 判斷是否更新最長\n\nLine 19:     Yes → Step 11: longest ← currentEven // 更新最長回文\n\nLine 20:     No  →  // 不更新\n\nLine 21: End // 程式結束\n\nBut we also need to include the for loop end etc. But the pseudocode steps are enough. Might need to include comments for each line.\n\nLet's ensure each line ends with comment. Use arrow for each step. For decisions, indent substeps.\n\nNeed to produce lines exactly in format. So let's craft the final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(s) // 取得字串 s 的長度  \n→ Step 2: longest ← \"\" // 初始化最長回文子字串為空  \n→ Step 3: For i from 0 to n-1: // 遍歷每個字符作為中心  \n  → Step 4: left ← i-1 ; right ← i+1 // 設定奇數長度回文的左右指標  \n  → Decision: left ≥ 0 AND right < n AND s[left] = s[right] ? // 判斷能否展開  \n   Yes → Step 5: ExpandOdd: while left ≥ 0 AND right < n AND s[left] = s[right] do { left ← left-1 ; right ← right+1 } // 擴展奇數長度回文  \n   Yes → Step 6: currentOdd ← substring(s, left+1, right) // 取得擴展後的子字串  \n   No → Step 6: currentOdd ← s[i] // 單個字符本身  \n  → Decision: length(currentOdd) > length(longest) ? // 判斷是否更新最長回文  \n   Yes → Step 7: longest ← currentOdd // 更新最長回文  \n   No → // 不更新  \n  → Step 8: left ← i ; right ← i+1 // 設定偶數長度回文的左右指標  \n  → Decision: left ≥ 0 AND right < n AND s[left] = s[right] ? // 判斷能否展開  \n   Yes → Step 9: ExpandEven: while left ≥ 0 AND right < n AND s[left] = s[right] do { left ← left-1 ; right ← right+1 } // 擴展偶數長度回文  \n   Yes → Step 10: currentEven ← substring(s, left+1, right) // 取得擴展後的子字串  \n   No → Step 10: currentEven ← \"\" // 無偶數長度回文  \n  → Decision: length(currentEven) > length(longest) ? // 判斷是否更新最長回文  \n   Yes → Step 11: longest ← currentEven // 更新最長回文  \n   No → // 不更新  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        找出字串 s 中最長的回文子字串。\n        \"\"\"\n        res = \"\"\n        n = len(s)\n        for i in range(n):\n            # 奇數長度回文，中心在 i\n            tmp = self.expandFromCenter(s, i, i)\n            if len(tmp) > len(res):\n                res = tmp\n            # 偶數長度回文，中心在 i 和 i+1\n            tmp = self.expandFromCenter(s, i, i + 1)\n            if len(tmp) > len(res):\n                res = tmp\n        return res\n\n    def expandFromCenter(self, s: str, left: int, right: int) -> str:\n        \"\"\"\n        從指定的左、右指標開始向外擴展，返回最大回文子字串。\n        \"\"\"\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取字串 s，輸出最長回文子字串。\n    假設輸入格式為：s = 'babad' 或 s = \"babad\" 等形式。\n    \"\"\"\n    data = sys.stdin.read()\n    # 取得第一個單引號或雙引號之間的內容\n    match = re.search(r\"['\\\"]([^'\\\"]*)['\\\"]\", data)\n    s = match.group(1) if match else \"\"\n    sol = Solution()\n    result = sol.longestPalindrome(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "success": true,
          "output": "bab"
        },
        {
          "example_index": 1,
          "input": "s = 'cbbd'",
          "expected_output": "'bb'",
          "success": true,
          "output": "bb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode454.json",
    "problem_index_in_file": 0,
    "title": "4Sum II",
    "description_snippet": "Given four integer arrays A, B, C, and D all of length n, return the number of tuples (i, j, k, l) s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm steps for counting quadruples summing to zero from four arrays A,B,C,D of length n. Approach: compute all pair sums of A+B and C+D, store counts, then for each sum in A+B, look for opposite in C+D. Complexity O(n^2). We'll produce virtual steps line by line with explanations.\n\nLet's produce start, read arrays? But arrays are given. Steps: Initialize hash map sumABCounts, iterate i over A, j over B, compute s = A[i]+B[j], increment map. Then iterate k over C, l over D, compute s2 = -(C[k]+D[l]), if sumABCounts contains s2, add count to result. End.\n\nAdd decisions? Not many decisions, but we can use Decision: if map contains key? Yes->add. No->continue.\n\nLet's produce virtual steps with arrow. Use Start, End. Use Step numbers maybe.\n\nLet's produce:\n\nStart // program starts\n→ Step 1: Initialize map sumABCounts as empty // 用於存 A+B 的總和頻率\n→ Decision: 是否需要處理 A? // 若 A 为空则直接结束（可选）\n    Yes → Step 2: 对 i 从 0 到 n-1 遍历\n        → Step 3: 对 j 从 0 到 n-1 遍历\n            → Step 4: 计算 sum = A[i] + B[j]\n            → Step 5: 若 sum 在 map 中，则 map[sum]++ 否则 map[sum] = 1 // 统计 A+B 的组合数\n    No  → … (忽略，直接往下)\n\n→ Step 6: Initialize result = 0 // 存储满足条件的四元组数\n→ Decision: 是否需要处理 C? // 同上\n    Yes → Step 7: 对 k 从 0 到 n-1 遍历\n        → Step 8: 对 l 从 0 到 n-1 遍历\n            → Step 9: 计算 need = -(C[k] + D[l]) // 需要在 A+B 中出现的相反数\n            → Decision: map 是否包含 need? // 检查是否存在匹配\n                Yes → Step 10: result += map[need] // 加上匹配组合数\n                No  → Step 11: 跳过 // 没有匹配，继续循环\n    No  → … (忽略)\n\n→ Step 12: 输出 result // 返回四元组数量\nEnd // 程序结束\n\nBut we need each line with arrow and explanation after //.\n\nAlso maintain consistent indentation. Use arrows for nested loops, decisions.\n\nWe need to format each line as \"虛擬碼步驟 // 解釋\". The virtual code can include indents? The example uses indentation for nested steps. We'll mimic similar.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 sumABCounts 為空哈希表 // 用於存 A+B 的總和及其出現頻次  \n→ Decision: 是否需要處理 A？ // 若 A 為空直接跳到結束  \n    Yes → Step 2: 對 i 從 0 到 n-1 迴圈  \n        → Step 3: 對 j 從 0 到 n-1 迴圈  \n            → Step 4: 計算 sum = A[i] + B[j] // 取得一個 A[i] 與 B[j] 的和  \n            → Decision: sum 是否已在 sumABCounts？ // 判斷此和是否已被記錄  \n                Yes → Step 5: sumABCounts[sum] ← sumABCounts[sum] + 1 // 頻次累加  \n                No  → Step 6: sumABCounts[sum] ← 1 // 新增此和並設定頻次為 1  \n\n→ Step 7: 初始化 result ← 0 // 用於儲存符合條件的四元組數量  \n→ Decision: 是否需要處理 C？ // 若 C 為空直接跳到輸出  \n    Yes → Step 8: 對 k 從 0 到 n-1 迴圈  \n        → Step 9: 對 l 從 0 到 n-1 迴圈  \n            → Step 10: 計算 need = -(C[k] + D[l]) // 需要在 A+B 中出現的相反數  \n            → Decision: sumABCounts 是否包含 need？ // 檢查是否存在匹配  \n                Yes → Step 11: result ← result + sumABCounts[need] // 加上匹配組合數  \n                No  → Step 12: 跳過 // 無匹配，繼續下一個 (k,l)  \n\n→ Step 13: 輸出 result // 回傳四元組總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef four_sum_count(A, B, C, D):\n    \"\"\"Count the number of quadruples (i, j, k, l) such that\n    A[i] + B[j] + C[k] + D[l] == 0.\"\"\"\n    # Count all possible sums of elements from A and B\n    ab_counter = Counter(a + b for a in A for b in B)\n    # For each sum from C and D, look for its negative in the counter\n    count = 0\n    for c in C:\n        for d in D:\n            count += ab_counter.get(-(c + d), 0)\n    return count\n\ndef parse_input(text):\n    \"\"\"Extract the four lists A, B, C, D from the input text.\"\"\"\n    pattern = r'([ABCD])\\s*=\\s*(\\[.*?\\])'\n    matches = re.findall(pattern, text, re.DOTALL)\n    data = {}\n    for var, lst in matches:\n        data[var] = ast.literal_eval(lst)\n    return data['A'], data['B'], data['C'], data['D']\n\ndef main():\n    # Read entire input from stdin\n    raw_input = sys.stdin.read()\n    # Parse the four arrays\n    A, B, C, D = parse_input(raw_input)\n    # Compute the result\n    result = four_sum_count(A, B, C, D)\n    # Print the answer to stdout\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "A = [0], B = [0], C = [0], D = [0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode50.json",
    "problem_index_in_file": 0,
    "title": "Pow(x, n)",
    "description_snippet": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n)....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for pow(x, n). Should include Start, Decision, etc. Need to consider negative n? Usually pow for integer exponent n. We might implement exponentiation by squaring. Provide steps. Let's produce virtual code with algorithm: handle negative n by computing 1/(pow(x, -n)). Then use fast exponentiation. Let's do iterative method: result=1; while n>0: if n odd result*=x; x*=x; n//=2. Provide virtual steps.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrows. Format: \"Start // 程式開始執行\". Then each line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 檢查 n 是否為負數 // 判斷指數是否為負\n    Yes → Step 2: 設置 sign = -1 // 標記需要取倒數\n    No  → Step 2: 設置 sign = 1 // 正數指數\n→ Step 3: 將 n 取絕對值 // 確保 n 為非負\n→ Step 4: 初始化 result = 1 // 結果初始為 1\n→ Step 5: 初始化 base = x // 基數初始為 x\n→ Decision: n 是否大於 0? // 開始快速冪迴圈\n    Yes → Decision: n 是否為奇數? // 判斷是否需要乘以基數\n        Yes → Step 6: result = result * base // result 乘以 base\n        No  → // 不做乘法\n    → Step 7: base = base * base // 基數平方\n    → Step 8: n = n // 2 // n 除以 2（整除）\n    → Go back to Decision: n 是否大於 0?\n    No  → Step 9: If sign == -1? // 判斷是否需要取倒數\n        Yes → Step 10: result = 1 / result // 取倒數\n        No  → // 保持結果不變\n→ Step 11: Return result // 回傳計算結果\nEnd // 程式執行結束\n\nNeed to include arrows? Use \"→\". Indent decisions with Yes → and No →.\n\nMake sure each line has 虛擬碼步驟 and comment. Use the same format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 n 是否為負數 // 判斷指數是否為負  \n  Yes → Step 2: 設置 sign = -1 // 標記需要取倒數  \n  No  → Step 2: 設置 sign = 1 // 正數指數  \n→ Step 3: 將 n 取絕對值 // 確保 n 為非負  \n→ Step 4: 初始化 result = 1 // 結果初始為 1  \n→ Step 5: 初始化 base = x // 基數初始為 x  \n→ Decision: n 是否大於 0? // 開始快速冪迴圈  \n  Yes → Decision: n 是否為奇數? // 判斷是否需要乘以基數  \n    Yes → Step 6: result = result * base // result 乘以 base  \n    No  → // 不做乘法  \n  → Step 7: base = base * base // 基數平方  \n  → Step 8: n = n // 2 // n 除以 2（整除）  \n  → Go back to Decision: n 是否大於 0?  \n  No → Step 9: If sign == -1? // 判斷是否需要取倒數  \n    Yes → Step 10: result = 1 / result // 取倒數  \n    No  → // 保持結果不變  \n→ Step 11: Return result // 回傳計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef my_pow(x: float, n: int) -> float:\n    \"\"\"計算 x^n 的快速冪，使用遞迴平方法。\"\"\"\n    if n == 0:\n        return 1.0\n    if n < 0:\n        x = 1.0 / x\n        n = -n\n\n    def fast_pow(x: float, n: int) -> float:\n        if n == 0:\n            return 1.0\n        half = fast_pow(x, n // 2)\n        if n % 2 == 0:\n            return half * half\n        else:\n            return half * half * x\n\n    return fast_pow(x, n)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 從輸入字串中擷取所有數字，支持負號和小數\n    nums = re.findall(r'-?\\d+\\.?\\d*', data)\n    if len(nums) < 2:\n        return\n\n    x = float(nums[0])\n    n = int(float(nums[1]))  # 允許「10」或「10.0」兩種形式\n    result = my_pow(x, n)\n    print(f\"{result:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 2.00000, n = 10",
          "expected_output": "1024.00000",
          "success": true,
          "output": "1024.00000"
        },
        {
          "example_index": 1,
          "input": "x = 2.10000, n = 3",
          "expected_output": "9.26100",
          "success": true,
          "output": "9.26100"
        },
        {
          "example_index": 2,
          "input": "x = 2.00000, n = -2",
          "expected_output": "0.25000",
          "success": true,
          "output": "0.25000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode8.json",
    "problem_index_in_file": 0,
    "title": "String to Integer (atoi)",
    "description_snippet": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe al...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code, step-by-step, for myAtoi as described. Must be in Chinese (繁體). Each line: virtual code step, space, // explanation.\n\nUse Start, End, Decision, arrow →, Yes →, No → etc. No actual code, just structure.\n\nLet's craft steps: Start, Step 1: Input string s. Step 2: Initialize index i = 0, n = length of s. Step 3: Skip leading whitespace. Decision: check if index < n and s[i] == ' '. If yes → increment i, loop. After loop.\n\nStep 4: Determine sign: Decision: if i < n and s[i] == '-'? Yes → sign = -1, i++; No → Decision: if s[i]== '+'? Yes → sign = 1, i++; No → sign = 1 (default). After sign determination.\n\nStep 5: Skip leading zeros? Actually conversion: skip zeros before digits? Could combine in conversion loop: read digits while isdigit. Decision: if i < n and isdigit(s[i])? Yes → accumulate value. We need to handle overflow: before multiplying, check if value > (INT_MAX - digit)/10. Use thresholds.\n\nBut the algorithm says skip leading zeros until non-digit or end. So we can skip zeros first: Decision: while i < n and s[i] == '0' → i++. Then conversion: loop digits.\n\nImplement conversion: initialize num = 0. While i < n and s[i] is digit: get digit. Decision: check overflow. If num > INT_MAX/10 or (num == INT_MAX/10 and digit > 7)? For sign negative? Use signed thresholds: if sign == 1 and num > INT_MAX/10 or (num == INT_MAX/10 and digit > 7) → overflow. Set num = INT_MAX; break. If sign == -1 and num > INT_MAX/10 or (num == INT_MAX/10 and digit > 8) → overflow, set num = INT_MIN; break. Else num = num*10 + digit; i++.\n\nAfter loop, result = sign * num. But we might have set overflow earlier.\n\nBut the spec: rounding after conversion if out of range. So we can just compute num as unsigned long, then apply sign, then clamp.\n\nSimpler: convert all digits into a long long, then apply sign and clamp.\n\nSo virtual steps: Step 5: Initialize num = 0. Decision: while i < n and isdigit(s[i])? Yes → Step 6: digit = s[i] - '0'; Step 7: num = num * 10 + digit; i++; Loop. After loop: Step 8: result = sign * num. Step 9: Decision: if result < INT_MIN? Yes → result = INT_MIN; No → Decision: if result > INT_MAX? Yes → result = INT_MAX; End.\n\nReturn result.\n\nAlso handle no digits: if no digit read (num remains 0), result 0.\n\nLet's craft the virtual code.\n\nInclude Start, End.\n\nUse arrow lines. We'll format like:\n\nStart // 程式開始執行\n→ Step 1: Initialize i = 0, n = length(s) // 設定指標和字串長度\n...\n\nWe need to use Decision: lines with Yes → and No →.\n\nWe need to handle loops with indentation maybe using arrows.\n\nLet's create lines.\n\nProbably something like:\n\n→ Decision: while i < n and s[i] == ' '?\n    Yes → i = i + 1 // 跳過空白\n    No  → // 進入下一步\n\nBut better: Use loop structure.\n\nBut spec only requires arrow and decision. We'll use simple Decision with Yes/No. For loops, we can use Decision repeated? Might be confusing but okay.\n\nWe'll just write while loop as Decision with Yes → then continue loop, No → skip. But might be too complex. Instead, we can write a comment that indicates loop.\n\nOk, let's produce.\n\nAlso include comments in Chinese.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 i = 0, n = s.length() // 初始化索引與字串長度  \n→ Step 2: 建立變數 sign = 1, num = 0 // 預設正號與整數累積  \n→ Decision: i < n 且 s[i] == ' ' ? // 跳過前導空白  \n    Yes → i = i + 1 // 移至下一個字元  \n    No  → // 空白處理完成  \n→ Step 3: 判斷符號  \n    Decision: i < n 且 s[i] == '-' ?  \n        Yes → sign = -1; i = i + 1 // 負號且移動索引  \n        No  → Decision: i < n 且 s[i] == '+' ?  \n            Yes → sign = 1; i = i + 1 // 正號且移動索引  \n            No  → // 無符號，保持預設正號  \n→ Step 4: 跳過前導零  \n    Decision: i < n 且 s[i] == '0' ?  \n        Yes → i = i + 1 // 仍是零，繼續跳過  \n        No  → // 零已跳過完畢  \n→ Step 5: 讀取數字並累積  \n    Decision: i < n 且 isdigit(s[i]) ?  \n        Yes → Step 5a: digit = s[i] - '0' // 取得數字  \n               Step 5b: num = num * 10 + digit // 累積  \n               Step 5c: i = i + 1 // 移動到下一個字元  \n               Step 5d: 回到 Step 5 (再次判斷)  \n        No  → // 數字讀取結束  \n→ Step 6: 應用符號  \n    result = sign * num // 計算帶符號的整數  \n→ Decision: result < INT_MIN ?  \n    Yes → result = INT_MIN // 超過下限時修正  \n    No  → Decision: result > INT_MAX ?  \n        Yes → result = INT_MAX // 超過上限時修正  \n        No  → // 範圍內，保持結果  \n→ End // 程式結束，返回 result",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        # 移除前導空白\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        idx = 0\n\n        # 判斷符號\n        if s[0] == '+':\n            idx += 1\n        elif s[0] == '-':\n            sign = -1\n            idx += 1\n\n        result = 0\n        # 轉換數字\n        while idx < len(s) and s[idx].isdigit():\n            result = result * 10 + int(s[idx])\n            idx += 1\n\n        result *= sign\n\n        INT_MAX = 2 ** 31 - 1\n        INT_MIN = -2 ** 31\n        # 限制在 32 位整數範圍內\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n        return result\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中抽取引號內的內容\n    match = re.search(r'\"(.*)\"', data)\n    s = match.group(1) if match else data.strip()\n\n    solution = Solution()\n    result = solution.myAtoi(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"42\"",
          "expected_output": "42",
          "success": true,
          "output": "42"
        },
        {
          "example_index": 1,
          "input": "s = \" -042\"",
          "expected_output": "-42",
          "success": true,
          "output": "-42"
        },
        {
          "example_index": 2,
          "input": "s = \"1337c0d3\"",
          "expected_output": "1337",
          "success": true,
          "output": "1337"
        },
        {
          "example_index": 3,
          "input": "s = \"0-1\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 4,
          "input": "s = \"words and 987\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode151.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String",
    "description_snippet": "Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-spa...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for reversing words in string with trimming spaces and handling multiple spaces. Steps: Trim s, split by spaces ignoring empties, reverse list, join with single space. Also need to handle empty string maybe. Provide start, decisions. Virtual code lines. Each line has step and comment. Use arrows. Let's produce.\n\nPotential steps:\nStart\n→ Step 1: Define function reverseWords(s)\n→ Step 2: Initialize empty list words\n→ Decision: If s is empty? -> No\n    Yes → Return empty string // if input empty\n    No  → Continue\n→ Step 3: Trim leading/trailing spaces: trimmed = trim(s) // remove outer spaces\n→ Step 4: Split trimmed by spaces into tokens: tokens = split(trimmed, ' ') // may contain multiple spaces, but trimmed ensures no leading/trailing, but internal multiple spaces still produce empty tokens\nBut easier: Use split by whitespace regex or loop over characters to build words, ignoring consecutive spaces. But virtual code can show logic: Loop char in trimmed, accumulate word when char not space, push word when space encountered, ignore consecutive spaces.\n\nLet's outline.\n\n→ Step 5: Initialize currentWord = \"\"\n→ Step 6: For each char in trimmed:\n   → Decision: If char != space? Yes\n       → Append char to currentWord\n   → Decision: Else (space)? Yes\n       → If currentWord not empty: Append currentWord to words, set currentWord = \"\"\n→ After loop: If currentWord not empty: Append currentWord to words // last word\n\nNow words list has words in original order.\n\n→ Step 7: Reverse words list: reversedWords = reverse(words)\n\n→ Step 8: Join reversedWords with single space: result = join(reversedWords, ' ')\n\n→ Step 9: Return result\n\n→ End\n\nAdd comments accordingly.\n\nWe should keep each line separate and provide arrow and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 reverseWords(s) // 開始定義處理字串的函式  \n→ Decision: s 是否為空字串？ // 檢查輸入是否為空  \n  Yes → Step 2: 返回 \"\" // 空輸入直接返回空字串  \n  No  → Step 3: 取 s 的 trim() 值 → trimmed // 去除前後空白，得到中間不含首尾空格的字串  \n→ Step 4: 初始化 words = [] // 用來儲存每個單詞的空陣列  \n→ Step 5: 初始化 currentWord = \"\" // 用來臨時累積字元的變數  \n→ Step 6: 對 trimmed 的每個字元 ch 進行迴圈  \n  Decision: ch 是否為空白？ // 判斷字元是否是空格  \n   Yes → Decision: currentWord 是否為空？  \n     Yes → Step 7: 跳過 // 連續空格直接忽略  \n     No  → Step 8: 把 currentWord 推入 words，並重置 currentWord = \"\" // 完成一個單詞的收集  \n   No  → Step 9: 把 ch 加到 currentWord // 不是空格，累積字元  \n→ Step 10: 迴圈結束後，Decision: currentWord 是否為空？ // 處理最後一個單詞  \n  Yes → Step 11: 跳過 // 若最後無多餘字元則不作處理  \n  No  → Step 12: 把 currentWord 推入 words // 把最後一個單詞加入列表  \n→ Step 13: words = reverse(words) // 反轉單詞順序  \n→ Step 14: result = join(words, \" \") // 用單個空格將單詞連結成字串  \n→ Step 15: 返回 result // 將處理後的字串返回  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"\n        1. 去除首尾空格\n        2. 以空格分割成單詞，內部多餘空格自動忽略\n        3. 反轉單詞順序\n        4. 用單一空格連接\n        \"\"\"\n        # Step 1: 先去除前後多餘空格\n        trimmed = s.strip()\n        # Step 2: 以空格分割，過濾掉多餘空格\n        words = trimmed.split()\n        # Step 3: 反轉\n        words.reverse()\n        # Step 4: 以單一空格連接\n        return ' '.join(words)\n\ndef main():\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n\n    # 去除首尾空白字元\n    raw_input = raw_input.strip()\n\n    # 如果輸入形式為「s = \"....\"」等，取等號後面部分\n    if '=' in raw_input:\n        _, after_eq = raw_input.split('=', 1)\n        s = after_eq.strip()\n    else:\n        s = raw_input\n\n    # 移除可能存在的雙引號或單引號包裹\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n\n    solution = Solution()\n    result = solution.reverseWords(s)\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"the sky is blue\"",
          "expected_output": "\"blue is sky the\"",
          "success": true,
          "output": "blue is sky the"
        },
        {
          "example_index": 1,
          "input": "s = \"  hello world  \"",
          "expected_output": "\"world hello\"",
          "success": true,
          "output": "world hello"
        },
        {
          "example_index": 2,
          "input": "s = \"a good   example\"",
          "expected_output": "\"example good a\"",
          "success": true,
          "output": "example good a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode27.json",
    "problem_index_in_file": 0,
    "title": "Remove Element",
    "description_snippet": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Problem: remove element val from array in place, return new length k, with first k elements not equal to val. Standard two-pointer solution. Provide step-by-step virtual code. Use Start, Decision, etc.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化 i = 0 // i 指向處理到的索引\n→ Step 2: 初始化 n = nums.length // 數組長度\n→ Decision: i < n? // 是否還有未處理元素\n    Yes → Step 3: 如果 nums[i] == val? // 判斷當前元素是否為要刪除的值\n        Yes → Step 4: i = i + 1 // 跳過此元素\n        No  → Step 5: 把 nums[i] 與 nums[n-1] 交換 // 把非 val 放到結尾\n             → Step 6: n = n - 1 // 將已處理的尾部元素數量減一\n             → Step 7: i = i + 1 // 继续处理下一个索引\n    No → Step 8: k = n // n 現在等於不包含 val 的元素個數\n→ End\n\nNeed to incorporate exchange step. Also need to use arrows accordingly. Provide each line with comment. Use proper indentation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = 0 // 設定處理索引  \n→ Step 2: n = nums.length // 取得原始陣列長度  \n→ Decision: i < n? // 是否還有元素需要檢查  \n Yes → Decision: nums[i] == val? // 當前元素是否是要移除的值  \n  Yes → Step 3: i = i + 1 // 跳過該元素，直接往下  \n  No  → Step 4: nums[i] ↔ nums[n-1] // 把非 val 元素移到陣列尾部  \n    → Step 5: n = n - 1 // 將已處理的尾部元素數量減一  \n    → Step 6: i = i + 1 // 繼續檢查下一個索引  \n No  → Step 7: k = n // n 現在等於不含 val 的元素數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef removeElement(nums, val):\n    \"\"\"將 nums 中所有等於 val 的元素移除，返回新長度 k。\"\"\"\n    slow = 0\n    for fast in range(len(nums)):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n    return slow\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # 先試圖抓取「nums = [...], val = ...」這樣的格式\n    pattern = r'nums\\s*=\\s*\\[(.*?)\\]\\s*,\\s*val\\s*=\\s*(-?\\d+)'\n    m = re.search(pattern, data, re.DOTALL)\n    if m:\n        nums_str = m.group(1)\n        nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n        val = int(m.group(2))\n    else:\n        # 若輸入分多行，嘗試從每行中分別抽取\n        nums = []\n        val = 0\n        for line in data.splitlines():\n            if 'nums' in line:\n                nums_str = re.search(r'\\[(.*?)\\]', line)\n                if nums_str:\n                    nums = [int(x.strip()) for x in nums_str.group(1).split(',') if x.strip()]\n            if 'val' in line:\n                val_match = re.search(r'val\\s*=\\s*(-?\\d+)', line)\n                if val_match:\n                    val = int(val_match.group(1))\n\n    original_len = len(nums)\n    k = removeElement(nums, val)\n\n    # 建立輸出字串，後面用 '_' 表示未使用的空位\n    elems = [str(nums[i]) for i in range(k)]\n    underscores = ['_'] * (original_len - k)\n    all_elems = elems + underscores\n    output = f\"{k}, nums = [{','.join(all_elems)}]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "success": true,
          "output": "2, nums = [2,2,_,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "success": true,
          "output": "5, nums = [0,1,3,0,4,_,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode357.json",
    "problem_index_in_file": 0,
    "title": "Count Numbers with Unique Digits",
    "description_snippet": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting numbers with unique digits less than 10^n. Classic LeetCode problem. Steps: start, if n==0 return 1? Actually count includes 0? For n=0 count=1 (empty). Implementation: count=1; if n==0 return 1; count=1; for i in 1 to n: multiply by (10-i+1)? Actually count of numbers with unique digits of length i: 9 * P(9, i-1). So cumulative sum. Use loops.\n\nWe need to output step by step virtual code lines with explanation. Use Start, End, Decision, Yes/No arrows. Provide each line with virtual code plus comment. Avoid actual code, just structure.\n\nLet's produce. Use Start // start. Then Step 1: input n. Step 2: initialize count=1 // includes zero. Step 3: if n==0 → End return count. Use Decision. Then loop i from 1 to n: Step: initialize mult=9; For j=1 to i-1: mult *= (9 - j); Step: count += mult. After loop End. But we need to represent loops as arrows? Use 'For' step with nested? Might use Decision to handle loop. Provide simple representation.\n\nLet's craft lines. Use virtual code syntax: Start, → Step, → Decision: etc. Provide concise.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得整數 n // 從使用者取得欲計算的位數  \n→ Decision: n 是否等於 0? // 判斷是否為最簡情況  \n    Yes → Step 2: 設置 count = 1 // 只包含 0  \n    No  → Step 3: 設置 count = 1 // 包含 0 的基礎計數  \n→ Step 4: 設置 i = 1 // 迭代 1 到 n 的長度  \n→ Decision: i <= n? // 判斷是否還有更長的數字  \n    Yes → Step 5: 設置 mult = 9 // 第 1 位可選 1-9  \n    → Step 6: 設置 j = 1 // 內部迴圈用於計算 (9-j) 的乘積  \n    → Decision: j < i? // 是否還有剩餘位需要計算  \n        Yes → Step 7: mult = mult * (9 - j) // 乘上可用數字數量  \n        → Step 8: j = j + 1 // 移至下一位  \n        No  → Step 9: count = count + mult // 將本長度的可用數量加入總計  \n    → Step 10: i = i + 1 // 移至下一個長度  \n    No  → End // 所有長度計算完畢  \nEnd // 程式執行結束，count 為所有唯一數字的總數",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countNumbersWithUniqueDigits(self, n: int) -> int:\n        if n == 0:\n            return 1\n        n = min(n, 10)  # 超過 10 位數會重複\n        res = 10  # 0-9 共 10 個\n        unique = 9  # 第二位開始的可用數字數\n        available = 9  # 第一位已選 1-9 後剩餘可用數字\n        for _ in range(2, n + 1):\n            unique *= available\n            res += unique\n            available -= 1\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    sol = Solution()\n    result = sol.countNumbersWithUniqueDigits(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "success": true,
          "output": "91"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode392.json",
    "problem_index_in_file": 0,
    "title": "Is Subsequence",
    "description_snippet": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\nA subsequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code line by line with arrow, comments. For this problem. Steps: Start, initialize indices i j 0, while i< s.len and j < t.len, compare, increment accordingly, decision to return true/false. Ensure arrow formatting. Use `Decision:` etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 i = 0, j = 0 // 初始化指向 s 與 t 的索引  \n→ Decision: i < len(s) 且 j < len(t) ? // 判斷是否還有字元需要比對  \n Yes → Step 2: 如果 s[i] == t[j] ? // 比對當前字元是否相同  \n  Yes → Step 3: i = i + 1 // s 的字元匹配，移動到 s 的下一個  \n  No  → Step 4: // s 的字元不匹配，僅移動 t  \n     j = j + 1  \n     → 回到 Decision: i < len(s) 且 j < len(t) ?  \n     Yes →（重複 Step 2）  \n     No  → Step 5: // 已遍歷完 t 或 s  \n      → Decision: i == len(s) ? // s 是否已全部匹配  \n       Yes → Step 6: Return true // s 是 t 的子序列  \n       No  → Step 7: Return false // s 不是 t 的子序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        \"\"\"判斷 s 是否為 t 的子序列。\"\"\"\n        # 空字串永遠是子序列\n        if not s:\n            return True\n\n        idx_s = 0  # s 的目前索引\n        for ch in t:\n            if ch == s[idx_s]:\n                idx_s += 1\n                if idx_s == len(s):   # 已經全部匹配完成\n                    return True\n        return False   # t 結束但還有 s 的字元未匹配\n\n\ndef main() -> None:\n    # 讀取整行輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從字串中抓取兩個引號內的內容作為 s 與 t\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) < 2:\n        # 若輸入格式不符，直接退出\n        return\n    s, t = matches[0], matches[1]\n\n    sol = Solution()\n    result = sol.isSubsequence(s, t)\n    # 按題目要求輸出 \"true\" 或 \"false\"\n    print(\"true\" if result else \"false\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\", t = \"ahbgdc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"axc\", t = \"ahbgdc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode91.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways",
    "description_snippet": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for decoding ways problem. Provide line-by-line with arrow, decisions. Use Start, End. Provide short explanations. Use only virtual code, no real code. Ensure Chinese comments. Let's design algorithm: dynamic programming: dp[i] number of ways for prefix length i. dp[0]=1. For i from 1 to n: if s[i-1] != '0', dp[i]+=dp[i-1]. If i>=2 and substring s[i-2..i-1] between 10 and 26, dp[i]+=dp[i-2]. Finally return dp[n]. Also handle leading zeros.\n\nWe must present virtual code line by line. Use arrows. Format: `Start // ...`. Next line arrow. Use \"→\". Use Decision. We'll represent loops, conditions, etc.\n\nLet's produce steps:\n\nStart // 程式開始執行\n\n→ Step 1: 獲取輸入字符串 s // 取得要解碼的數字字串\n\n→ Step 2: 初始化 dp 數組長度 n+1，dp[0] = 1 // dp[i] 表示前 i 個字符的解碼方式數\n\n→ Step 3: 遍歷 i 從 1 到 n // 為每個位置計算解碼方式\n\n    → Decision: s[i-1] 是否為 '0'? // 判斷單獨一位是否可解碼\n\n        Yes → Step 4a: dp[i] = 0 // '0' 不能單獨解碼，暫時設 0\n\n        No  → Step 4b: dp[i] = dp[i-1] // 其它數字可單獨解碼，累加前一個位置的解碼數\n\n    → Decision: i >= 2 且 substring s[i-2..i-1] 介於 \"10\" 與 \"26\" 之間? // 檢查兩位數是否有效\n\n        Yes → Step 5: dp[i] = dp[i] + dp[i-2] // 加上兩位數解碼方式\n\n        No  → Step 5b: // 兩位數無效，保持原 dp[i] 變化\n\n→ Step 6: 回傳 dp[n] // 最後的解碼方式總數\n\nEnd // 程式執行結束\n\nBut we must use virtual code lines with explanation after space. We should not produce actual code but pseudo. Use arrows for each step.\n\nNeed to show Decision lines with indentation? They show arrow plus Decision: label. Provide Yes→ and No→ substeps. Use indentation maybe with spaces or tab. Provide each line.\n\nLet's craft.\n\nUse \"Step 1:\" etc. Use arrow \"→\" before each. Use Decision lines like:\n\nDecision: s[i-1] == '0'? // check\n\n    Yes → Step 4a: dp[i] = 0\n\n    No  → Step 4b: dp[i] = dp[i-1]\n\nSimilarly for second decision.\n\nAlso include loop start? Might use Decision: i <= n? But we can use a loop representation: \"→ Decision: i <= n?\" etc. But easier: use \"→ Step 3: 循環 i = 1..n\" and inside.\n\nWe must produce valid structure with Start, End.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: s ← 輸入的數字字串 // 取得待解碼字串\n\n→ Step 2: n ← 長度(s) // 獲取字串長度\n\n→ Step 3: dp[0] ← 1 // 初始化 dp[0] 為 1\n\n→ Decision: n > 0? // 若字串非空\n\n    Yes → Step 4: dp[1] ← (s[0] != '0') ? 1 : 0 // 第一個字符是否可解碼\n\n    No  → Step 4b: // 字串為空，直接返回 1\n\n→ Step 5: for i ← 2 to n do // 從第二個字符開始遍歷\n\n    → Decision: s[i-1] != '0'? // 單位數是否有效\n\n        Yes → Step 5a: dp[i] ← dp[i-1] // 加上一個合法單位數解碼方式\n\n        No  → Step 5a: dp[i] ← 0 // 單位數無效，暫時設為 0\n\n    → Decision: 10 <= 整數(s[i-2..i-1]) <= 26? // 兩位數是否有效\n\n        Yes → Step 5b: dp[i] ← dp[i] + dp[i-2] // 加上兩位數解碼方式\n\n        No  → Step 5b: // 無效，保持 dp[i] 變化\n\n→ Step 6: return dp[n] // 回傳最終解碼方式數\n\nEnd // 程式執行結束\n\nBut we need to use virtual code syntax with arrow, Decision etc. Provide line-by-line.\n\nEnsure that each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: s ← 輸入的數字字串 // 取得待解碼的字串  \n→ Step 2: n ← 長度(s) // 獲取字串長度  \n→ Step 3: dp[0] ← 1 // dp[0] 表示空前綴的解碼方式數為 1  \n→ Decision: n > 0? // 若字串非空  \n Yes → Step 4: dp[1] ← (s[0] ≠ '0') ? 1 : 0 // 第一個字符是否能單獨解碼  \n No  → Step 4b: return 1 // 空字串只有一種解碼方式（空解碼）  \n→ Step 5: for i ← 2 to n do // 從第二個字符開始迭代  \n → Decision: s[i-1] ≠ '0'? // 單位數是否有效  \n  Yes → Step 5a: dp[i] ← dp[i-1] // 加上單位數解碼方式  \n  No  → Step 5a: dp[i] ← 0 // 單位數無效，暫時設為 0  \n → Decision: 10 ≤ 整數(s[i-2..i-1]) ≤ 26? // 兩位數是否有效  \n  Yes → Step 5b: dp[i] ← dp[i] + dp[i-2] // 加上兩位數解碼方式  \n  No  → Step 5b: // 兩位數無效，保持 dp[i] 原值  \n→ Step 6: return dp[n] // 返回整個字串的解碼方式總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_decodings(s: str) -> int:\n    if not s or s[0] == '0':\n        return 0\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        if s[i - 1] != '0':\n            dp[i] += dp[i - 1]\n        two_digit = int(s[i - 2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Try to extract the digits from formats like s = \"12\" or just 12\n    match = re.search(r'\"(\\d+)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        match = re.search(r's\\s*=\\s*(\\d+)', raw_input)\n        if match:\n            s = match.group(1)\n        else:\n            # Fallback: use the raw input as the string\n            s = raw_input\n\n    result = num_decodings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"12\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"226\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"06\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode649.json",
    "problem_index_in_file": 0,
    "title": "Dota2 Senate",
    "description_snippet": "In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code describing algorithm. Problem is Dota2 Senate problem similar to Leetcode 649. Approach: use queues for positions of R and D. While both non-empty: pop front of each, compare indices, the one with smaller index bans the other, and push its index + n back. At end return party.\n\nWe produce steps line by line with explanation. Use Start, Decision, etc. Need to output in specified format: each line: virtual code step + space + // explanation.\n\nWe should provide the algorithm steps, not actual code. We can mention data structures. Provide pseudo-steps.\n\nWe need to produce a sequence of steps describing algorithm. Let's outline:\n\nStart\n→ Step 1: Initialize queue_R with indices of 'R' in senate string // collect Radiant senators positions\n→ Step 2: Initialize queue_D with indices of 'D' in senate string // collect Dire senators positions\n→ Decision: While queue_R not empty and queue_D not empty? // loop until one party eliminated\n    → Step 3: Remove front of queue_R, front of queue_D // get earliest active senators\n    → Decision: Compare idx_R < idx_D? // which senator acts first\n        Yes → Step 4: Enqueue idx_R + n into queue_R // Radiant bans Dire, Radiant gets next turn\n        No  → Step 5: Enqueue idx_D + n into queue_D // Dire bans Radiant, Dire gets next turn\n    → Step 6: Continue loop // repeat\n→ Decision: If queue_R not empty? // Radiant still has senators\n    Yes → End with \"Radiant\" // Radiant wins\n    No  → End with \"Dire\" // Dire wins\n\nThat's it. Provide each line with explanation. Use arrow notation. Ensure each line has virtual code step and explanation. Use Start, End. Use Decision.\n\nLet's write lines. Use \"Start //\". Each step arrow: \"→\". Provide decision indentation with spaces. Ensure arrow for Yes and No.\n\nMake sure to use proper indentation for decision branches. Provide only the pseudo steps.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 queue_R 為所有 'R' 的索引 // 收集 Radiant 參與者的位置  \n→ Step 2: 初始化 queue_D 為所有 'D' 的索引 // 收集 Dire 參與者的位置  \n→ Decision: 若 queue_R 與 queue_D 都不為空? // 兩方仍有活躍議員  \n    Yes → Step 3: 取出 queue_R 的前一個索引 idx_R，queue_D 的前一個索引 idx_D // 取得兩個最早還能行動的議員  \n    → Decision: idx_R < idx_D? // 判斷誰先行動  \n        Yes → Step 4: 將 idx_R + n 入隊 queue_R // Radiant 議員禁用 Dire，並安排其下一輪行動  \n        No  → Step 5: 將 idx_D + n 入隊 queue_D // Dire 議員禁用 Radiant，並安排其下一輪行動  \n    → Step 6: 重複 Decision: 循環到一方被清空  \n→ Decision: 若 queue_R 不為空? // Radiant 仍有活躍議員  \n    Yes → End // Radiant 宣布勝利  \n    No  → End // Dire 宣布勝利",
      "generated_code": "import sys\nfrom collections import deque\n\ndef predict_party_victory(senate: str) -> str:\n    n = len(senate)\n    radiant = deque()\n    dire = deque()\n\n    for i, s in enumerate(senate):\n        if s == 'R':\n            radiant.append(i)\n        else:\n            dire.append(i)\n\n    while radiant and dire:\n        r_index = radiant.popleft()\n        d_index = dire.popleft()\n        if r_index < d_index:\n            radiant.append(r_index + n)\n        else:\n            dire.append(d_index + n)\n\n    return \"Radiant\" if radiant else \"Dire\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the senate string from input. It may be given directly or in the form: senate = \"RD\"\n    if '\"' in data or \"'\" in data:\n        # Find the first quoted substring\n        start = data.find('\"')\n        if start == -1:\n            start = data.find(\"'\")\n        end = data.find('\"', start + 1) if data[start] == '\"' else data.find(\"'\", start + 1)\n        senate = data[start + 1:end]\n    else:\n        # Assume the entire input is the string or the last token\n        senate = data.split()[-1]\n\n    result = predict_party_victory(senate)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "senate = \"RD\"",
          "expected_output": "\"Radiant\"",
          "success": true,
          "output": "Radiant"
        },
        {
          "example_index": 1,
          "input": "senate = \"RDD\"",
          "expected_output": "\"Dire\"",
          "success": true,
          "output": "Dire"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode523.json",
    "problem_index_in_file": 0,
    "title": "Continuous Subarray Sum",
    "description_snippet": "Given an integer array nums and an integer k, return true if nums has a good subarray or false other...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: given integer array nums and integer k, determine if there exists a subarray of length >=2 whose sum is a multiple of k. Standard solution uses prefix sums modulo k. We should produce virtual steps.\n\nWe need to output line by line with \"虛擬碼步驟\" and comment after space. Use arrows.\n\nWe need to consider edge cases: k=0? Problem says 0 is always a multiple of k. But if k==0, need subarray sum equal to 0. So we can handle separately. But virtual code can cover that.\n\nWe'll generate steps:\n\nStart\n→ Initialize hash map remIndex to store first occurrence of remainder to index\n→ Insert remainder 0 with index -1 to handle subarray from start\n→ Initialize sum = 0\n→ For each index i from 0 to length-1:\n    → sum += nums[i]\n    → If k != 0:\n        → rem = sum % k\n        → If rem < 0: rem += abs(k)  // ensure positive remainder\n      else:\n        → rem = sum\n    → If rem exists in remIndex:\n        → prev = remIndex[rem]\n        → If i - prev >= 2: return true\n    → Else: store remIndex[rem] = i\n→ End // no such subarray, return false\n\nReturn statements in virtual code.\n\nWe'll produce comments accordingly.\n\nAlso, handle k==0: we use sum directly.\n\nAlso note that array length may be less than 2, then return false.\n\nWe need to use virtual arrow syntax. For decision points: use Decision: if condition?\n\nBut we can use simple steps. The format: \"虛擬碼步驟 // 解釋\".\n\nLet's produce:\n\nStart\n→ Step 1: 判斷 nums 長度 < 2? // 若不足兩個元素則無子陣列符合長度要求\n    Yes → Step 2: 回傳 false // 直接結束\n    No  → Continue\n→ Step 3: 初始化哈希表 remainderIndex，並將 remainder 0 對應索引 -1 // 方便計算從開頭開始的子陣列\n→ Step 4: sum ← 0 // 用來累積前綴和\n→ Decision: k 等於 0? // 特殊處理模 0 的情況\n    Yes → Step 5: 迴圈 i 從 0 到 nums.length-1\n          → sum ← sum + nums[i]\n          → If sum == 0? // 子陣列總和為 0\n                Yes → Step 6: 若 i - remainderIndex[0] >= 2? // 前一次 0 remainder\n                        Yes → Step 7: 回傳 true\n                        No  → 進一步處理\n                No  → 進一步處理\n          → remainderIndex[0] ← i // 記錄最後一次 0 累積\n          → 若 i - remainderIndex[0] >= 2? // 檢查前一次 0\n                Yes → Step 8: 回傳 true\n                No  → 連續迴圈\n          // 以上為 k==0 的簡化流程\n    No  → Step 9: 迴圈 i 從 0 到 nums.length-1\n          → sum ← sum + nums[i]\n          → rem ← sum mod k\n          → If rem < 0? // 正規化為正餘數\n                Yes → rem ← rem + abs(k)\n          → If remainderIndex 含 rem?\n                Yes → prev ← remainderIndex[rem]\n                    If i - prev >= 2? // 長度檢查\n                        Yes → Step 10: 回傳 true\n                        No  → 連續迴圈\n                No  → remainderIndex[rem] ← i // 記錄首次出現\n→ Step 11: 回傳 false // 沒有符合條件的子陣列\n\nBut maybe too verbose. Virtual code needs to be simple. We can condense decisions.\n\nWe can structure:\n\nStart\n→ If nums.length < 2: // 先檢查長度\n    Yes → Return false\n→ Initialize remainderIndex map\n→ remainderIndex[0] ← -1\n→ sum ← 0\n→ For i from 0 to nums.length-1:\n    → sum ← sum + nums[i]\n    → If k == 0:\n        → rem ← sum\n      Else:\n        → rem ← sum mod k\n        → If rem < 0: rem ← rem + abs(k)\n    → If rem in remainderIndex:\n        → prev ← remainderIndex[rem]\n        → If i - prev >= 2: Return true\n    → Else:\n        → remainderIndex[rem] ← i\n→ Return false\n\nWe need to use Decision blocks for k==0.\n\nLet's produce.\n\nUse \"Decision:\" lines. For loops, we can just use \"→ For i ...:\".\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: 判斷 nums 數組長度 < 2? // 子陣列至少需要兩個元素\n    Yes → Step 2: 回傳 false // 長度不足，直接結束\n    No  → Continue\n→ Step 3: 初始化 remainderIndex 哈希表，並將 remainder 0 的索引設為 -1 // 方便處理從頭開始的子陣列\n→ Step 4: sum ← 0 // 用於累計前綴和\n→ Step 5: For i 0 到 nums.length-1: // 遍歷每個元素\n    → sum ← sum + nums[i] // 更新前綴和\n    → Decision: k 等於 0? // 特殊處理模 0 的情況\n        Yes → rem ← sum // 子陣列和直接作為餘數\n        No  → rem ← sum mod k // 取模\n              → Decision: rem < 0? // 負餘數修正為正\n                  Yes → rem ← rem + abs(k)\n    → Decision: rem 在 remainderIndex? // 已經出現過此餘數\n        Yes → prev ← remainderIndex[rem]\n              → Decision: i - prev >= 2? // 子陣列長度至少 2\n                  Yes → Step 6: 回傳 true // 找到符合條件的子陣列\n                  No  → Continue\n        No  → remainderIndex[rem] ← i // 記錄此餘數首次出現的索引\n→ Step 7: 回傳 false // 未找到符合條件的子陣列\n\nMake sure format lines exactly with \"虛擬碼步驟 // 解釋\".\n\nWe also need to use \"→\" and indentation for decisions. In the example, decisions show indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 判斷 nums 數組長度 < 2? // 子陣列至少需要兩個元素  \n  Yes → Step 2: 回傳 false // 長度不足，直接結束  \n  No  → Continue  \n→ Step 3: 初始化 remainderIndex 哈希表，並將 remainder 0 的索引設為 -1 // 方便處理從頭開始的子陣列  \n→ Step 4: sum ← 0 // 用於累計前綴和  \n→ Step 5: For i 0 到 nums.length-1: // 遍歷每個元素  \n  → sum ← sum + nums[i] // 更新前綴和  \n  → Decision: k 等於 0? // 特殊處理模 0 的情況  \n    Yes → rem ← sum // 子陣列和直接作為餘數  \n    No  → rem ← sum mod k // 取模  \n      Decision: rem < 0? // 負餘數修正為正  \n       Yes → rem ← rem + abs(k)  \n  → Decision: rem 在 remainderIndex? // 已經出現過此餘數  \n    Yes → prev ← remainderIndex[rem]  \n      Decision: i - prev >= 2? // 子陣列長度至少 2  \n       Yes → Step 6: 回傳 true // 找到符合條件的子陣列  \n       No  → Continue  \n    No  → remainderIndex[rem] ← i // 記錄此餘數首次出現的索引  \n→ Step 7: 回傳 false // 未找到符合條件的子陣列",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkSubarraySum(self, nums, k):\n        \"\"\"\n        判斷 nums 是否存在至少長度為 2 的子陣列，其和為 k 的倍數。\n        使用前綴和取模 k 的方式，利用哈希表儲存每個餘數第一次出現的位置。\n        \"\"\"\n        mod_map = {0: -1}          # 初始餘數 0 的位置設為 -1，方便處理從起始位置開始的子陣列\n        total = 0\n        for i, num in enumerate(nums):\n            total += num\n            if k != 0:            # k 為 0 時直接使用總和\n                total %= k\n            if total in mod_map:\n                if i - mod_map[total] > 1:   # 子陣列長度至少 2\n                    return True\n            else:\n                mod_map[total] = i          # 記錄此餘數首次出現的位置\n        return False\n\ndef main():\n    \"\"\"\n    讀取標準輸入，格式預期為 '[a1,a2,...,an], k'。\n    解析後呼叫 Solution.checkSubarraySum，並輸出 'true' 或 'false'。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        # 直接用 literal_eval 解析整個輸入，預期得到 (nums, k) 的 tuple\n        nums, k = ast.literal_eval(data)\n    except Exception:\n        # 若輸入格式不符，嘗試手動分離\n        parts = data.rsplit(',', 1)\n        nums_str = parts[0].strip()\n        k_str = parts[1].strip()\n        nums = ast.literal_eval(nums_str)\n        k = int(k_str)\n\n    solution = Solution()\n    result = solution.checkSubarraySum(nums, k)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[23,2,4,6,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "[23,2,6,4,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "[23,2,6,4,7], 13",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode41.json",
    "problem_index_in_file": 0,
    "title": "First Missing Positive",
    "description_snippet": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the algorithm that finds smallest missing positive integer in O(n) time, O(1) space. Classic solution: Use array index marking. Steps: First, segregate positive numbers? Usually algorithm: 1) Place each number x in index x-1 if 1<=x<=n. Then scan. Complexity O(n). Provide virtual code steps line by line.\n\nWe produce lines: Start, Step 1: n = length, Step 2: Partition positive numbers to front? Actually simpler: For i from 0 to n-1: while nums[i] in [1, n] and nums[nums[i]-1] != nums[i]: swap. Then scan for first index i where nums[i] != i+1, return i+1. End. This uses O(1) space.\n\nWe need to produce virtual code with arrows and explanations. Use `→` after decision arrows.\n\nWe will produce code lines:\n\nStart // 程式開始\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: for i from 0 to n-1 do // 遍歷每個元素\n    → Decision: 如果 nums[i] 介於 1 與 n 且 nums[nums[i]-1] ≠ nums[i]? // 判斷是否需要交換\n        Yes → Step 3: swap(nums[i], nums[nums[i]-1]) // 將元素放到正確位置\n        No → Step 4: i ← i+1 // 移至下一個索引\nEnd for // 結束迴圈\n\n→ Step 5: for i from 0 to n-1 do // 再次掃描\n    → Decision: 如果 nums[i] ≠ i+1? // 找到第一個不對應的\n        Yes → Step 6: return i+1 // 回傳最小缺失正整數\n        No → Step 7: continue // 繼續\nEnd for // 結束掃描\n\n→ Step 8: return n+1 // 若全部正好，回傳 n+1\n\nEnd // 程式結束\n\nBut we must keep each line a single step with explanation. Use indentation for decisions. Provide arrow style.\n\nLet's format as per requirement:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: for i ← 0 to n-1 do // 迭代所有元素\n    → Decision: nums[i] 在 1~n 且 nums[nums[i]-1] ≠ nums[i]? // 檢查是否需要交換\n        Yes → Step 3: swap(nums[i], nums[nums[i]-1]) // 交換元素到正確位置\n        No  → Step 4: i ← i+1 // 跳過，進入下一循環\nEnd for // 結束第一次迭代\n→ Step 5: for i ← 0 to n-1 do // 再次掃描已排列的陣列\n    → Decision: nums[i] ≠ i+1? // 找到第一個不匹配的位置\n        Yes → Step 6: return i+1 // 回傳最小缺失正整數\n        No  → Step 7: continue // 繼續檢查\nEnd for // 結束第二次迭代\n→ Step 8: return n+1 // 若全部符合，缺失數為 n+1\nEnd // 程式結束\n\nBut we need each line as `虛擬碼步驟 [space] // 解釋`. So we need each line with single step.\n\nThe for loops can be represented as single steps? But we need to preserve structure. Use lines for loops and decisions nested.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: for i ← 0 to n-1 do // 迭代每個元素\n    → Decision: nums[i] 在 1~n 且 nums[nums[i]-1] ≠ nums[i]? // 檢查是否需要交換\n        Yes → Step 3: swap(nums[i], nums[nums[i]-1]) // 將元素移至正確索引\n        No  → Step 4: i ← i+1 // 跳過此索引，繼續迴圈\nEnd for // 完成第一次排布\n→ Step 5: for i ← 0 to n-1 do // 再次掃描陣列\n    → Decision: nums[i] ≠ i+1? // 找到第一個不對應位置\n        Yes → Step 6: return i+1 // 回傳最小缺失正整數\n        No  → Step 7: continue // 繼續下一個索引\nEnd for // 完成第二次掃描\n→ Step 8: return n+1 // 若所有位置正確，缺失數為 n+1\nEnd // 程式結束\n\nBut we need arrow for each step. Use \"→\" before each line. For indentation lines we need indent. Provide explanation after each line.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: for i ← 0 to n-1 do // 迭代每個元素\n    → Decision: nums[i] 在 1~n 且 nums[nums[i]-1] ≠ nums[i]? // 檢查是否需要交換\n        Yes → Step 3: swap(nums[i], nums[nums[i]-1]) // 將元素移至正確索引\n        No  → Step 4: i ← i+1 // 跳過此索引，繼續迴圈\nEnd for // 完成第一次排布\n→ Step 5: for i ← 0 to n-1 do // 再次掃描陣列\n    → Decision: nums[i] ≠ i+1? // 找到第一個不對應位置\n        Yes → Step 6: return i+1 // 回傳最小缺失正整數\n        No  → Step 7: continue // 繼續下一個索引\nEnd for // 完成第二次掃描\n→ Step 8: return n+1 // 若所有位置正確，缺失數為 n+1\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport ast\n\ndef first_missing_positive(nums):\n    \"\"\"\n    找出最小缺失正整數。\n    時間複雜度：O(n)\n    空間複雜度：O(1)\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        # 只把 1~n 的數放到對應位置\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    # 再掃描一次，找第一個不對應的位置\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取方括號內的列表\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        nums_str = data[start:end + 1]\n        nums = ast.literal_eval(nums_str)\n    except ValueError:\n        # 若直接是列表字串，直接解析\n        nums = ast.literal_eval(data)\n\n    result = first_missing_positive(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,0]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [3,4,-1,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [7,8,9,11,12]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode551.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record I",
    "description_snippet": "You are given a string s representing an attendance record for a student where each character signif...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision: etc.\n\nWe should produce algorithm: iterate string, count A's, track consecutive L. Return false if A >= 2 or consecutive L >= 3. End.\n\nUse Start, → Step, Decision:.\n\nLet's craft. Use 虛擬碼 steps: \"Start\". Then \"→ Initialize absCount = 0\". \"→ Initialize consecLate = 0\". \"→ For each char ch in s\". Inside loop: decision for ch. If ch == 'A', increment absCount. If absCount >=2 -> Return false. Else if ch == 'L', increment consecLate. If consecLate >=3 -> Return false. Else if ch == 'P', set consecLate = 0. After loop: return true. End.\n\nMake each line as per format.\n\nNeed to use virtual code syntax: \"→ Step 1: ...\" maybe \"→ Step: ...\". Should use arrow for flow. Also \"Decision:\" lines. Provide explanation comments.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 absCount = 0 // 初始化缺勤計數\n→ Step 2: 設定 consecLate = 0 // 初始化連續遲到計數\n→ Step 3: 針對 s 中每個字符 ch 進行迴圈 // 逐天檢查出勤狀況\n    → Decision: 若 ch 為 'A'? // 檢查是否缺勤\n        Yes → Step 4: absCount += 1 // 記錄一次缺勤\n        Yes → Decision: absCount ≥ 2? // 檢查缺勤是否已達 2 天\n            Yes → Step 5: Return False // 不符合獎勵條件\n            No  → Step 6: // 繼續下一天\n    → Decision: 若 ch 為 'L'? // 檢查是否遲到\n        Yes → Step 7: consecLate += 1 // 記錄一次遲到\n        Yes → Decision: consecLate ≥ 3? // 檢查連續遲到是否已達 3 天\n            Yes → Step 8: Return False // 不符合獎勵條件\n            No  → Step 9: // 繼續下一天\n    → Decision: 若 ch 為 'P'? // 正常出席\n        Yes → Step 10: consecLate = 0 // 重置遲到計數\nEnd // 迴圈結束\n\n→ Step 11: Return True // 所有條件皆滿足，符合獎勵\n\nBut we need to maintain arrow structure: The loop line may contain nested decisions. We must maintain indentation? The example uses indentation for decisions. We should mimic that.\n\nMake each line with arrow \"→\". The decisions with Yes/No arrows. Use \"Yes →\" and \"No →\" lines.\n\nWe need to provide one line per step. The decisions lines are multiple lines.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: 設定 absCount = 0 // 初始化缺勤計數\n→ Step 2: 設定 consecLate = 0 // 初始化連續遲到計數\n→ Step 3: 針對 s 中每個字符 ch 進行迴圈 // 逐天檢查出勤狀況\n    → Decision: 若 ch 為 'A'? // 檢查缺勤\n        Yes → Step 4: absCount += 1 // 記錄缺勤\n        Yes → Decision: absCount ≥ 2? // 檢查缺勤是否已達 2 天\n            Yes → Step 5: Return False // 不符合獎勵條件\n            No  → Step 6: // 繼續下一天\n    → Decision: 若 ch 為 'L'? // 檢查遲到\n        Yes → Step 7: consecLate += 1 // 記錄遲到\n        Yes → Decision: consecLate ≥ 3? // 檢查連續遲到是否已達 3 天\n            Yes → Step 8: Return False // 不符合獎勵條件\n            No  → Step 9: // 繼續下一天\n    → Decision: 若 ch 為 'P'? // 正常出席\n        Yes → Step 10: consecLate = 0 // 重置遲到計數\nEnd // 迴圈結束\n→ Step 11: Return True // 所有條件皆滿足，符合獎勵\n\nBut we need to ensure each line ends with // explanation. The arrow line for decisions also has explanation. For \"Decision:\" line explanation after colon. The example uses \"Decision: 如果數字大於 0?\" with explanation after. So we can mimic.\n\nLet's produce final answer accordingly. Ensure each line has \"虛擬碼步驟\" + \" // 解釋/說明\". So need to include explanation for each line. For decision lines, explanation after \"Decision:\". For yes/no lines, explanation after.\n\nCheck format: Each line includes \"→ Decision: ...\" or \"→ Step: ...\" etc. Use space after \"→\". Provide explanation after //.\n\nEnsure Start and End lines as per example.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 absCount = 0 // 初始化缺勤計數  \n→ Step 2: 設定 consecLate = 0 // 初始化連續遲到計數  \n→ Step 3: 針對 s 中每個字符 ch 進行迴圈 // 逐天檢查出勤狀況  \n    → Decision: 若 ch 為 'A'? // 檢查是否缺勤  \n        Yes → Step 4: absCount += 1 // 記錄一次缺勤  \n        Yes → Decision: absCount ≥ 2? // 檢查缺勤是否已達 2 天  \n            Yes → Step 5: Return False // 不符合獎勵條件，結束  \n            No → Step 6: // 繼續處理下一天  \n    → Decision: 若 ch 為 'L'? // 檢查是否遲到  \n        Yes → Step 7: consecLate += 1 // 記錄一次遲到  \n        Yes → Decision: consecLate ≥ 3? // 檢查連續遲到是否已達 3 天  \n            Yes → Step 8: Return False // 不符合獎勵條件，結束  \n            No → Step 9: // 繼續處理下一天  \n    → Decision: 若 ch 為 'P'? // 正常出席  \n        Yes → Step 10: consecLate = 0 // 重置遲到計數  \nEnd // 迴圈結束，已完成所有天的檢查  \n→ Step 11: Return True // 所有條件皆滿足，符合獎勵條件",
      "generated_code": "class Solution:\n    def checkRecord(self, s: str) -> bool:\n        \"\"\"\n        判斷學生是否符合獎勵條件\n        1. 缺勤天數 < 2\n        2. 沒有連續 3 天遲到\n        \"\"\"\n        # 計算缺勤天數\n        absent_count = s.count('A')\n        if absent_count >= 2:\n            return False\n        # 檢查是否有連續三天遲到\n        if 'LLL' in s:\n            return False\n        return True\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 讀取輸入（可能包含引號），並去除兩端空白與引號\n    raw_input = sys.stdin.read().strip()\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        s = raw_input[1:-1]\n    else:\n        s = raw_input\n\n    solution = Solution()\n    result = solution.checkRecord(s)\n    # 以小寫字母輸出結果\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"PPALLP\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"PPALLL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode26.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. Use Start, Decision, arrows etc. We'll need to implement two-pointer technique. Let's generate step-by-step.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化指標 i = 0 // i 指向目前唯一元素的最後位置  \n→ Decision: 如果 nums 的長度為 0? // 檢查空陣列的特殊情況  \n  Yes → Step 2: 回傳 0 // 空陣列沒有唯一元素  \n  No → Step 3: 初始化指標 j = 1 // j 用於掃描陣列中的每個元素  \n→ Step 4: 循環 j < nums.length // 迭代整個陣列  \n  → Decision: nums[j] != nums[i]? // 判斷是否遇到新的唯一元素  \n   Yes → Step 5: i = i + 1 // 移動唯一元素的尾指標  \n    → Step 6: nums[i] = nums[j] // 把新的唯一元素放到 i 的位置  \n   No → Step 7: 進入下一次迴圈 // 與前一個唯一元素相同，忽略  \n  → Step 8: j = j + 1 // 先前 j 往右移動，繼續掃描  \n→ Step 9: 回傳 i + 1 // i 是最後唯一元素的索引，長度為 i+1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef remove_duplicates(nums):\n    \"\"\"\n    移除已排序陣列中的重複元素，原地完成。\n    返回唯一元素的個數 k。\n    \"\"\"\n    if not nums:\n        return 0\n\n    slow = 0  # 指向最後一個唯一元素的位置\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出數字列表。\n    允許的格式類似 'nums = [1,2,3]'。\n    \"\"\"\n    if '=' in data:\n        _, right = data.split('=', 1)\n        list_str = right.strip()\n    else:\n        list_str = data.strip()\n    # 安全地解析列表\n    try:\n        nums = ast.literal_eval(list_str)\n        if not isinstance(nums, list):\n            raise ValueError\n    except Exception:\n        # 若解析失敗，回傳空列表\n        nums = []\n    return nums\n\ndef format_output(k, nums):\n    \"\"\"\n    將結果格式化為要求的輸出形式。\n    例如：2, nums = [1,2,_]\n    \"\"\"\n    parts = [str(x) for x in nums[:k]] + ['_'] * (len(nums) - k)\n    inner = ','.join(parts)\n    return f\"{k}, nums = [{inner}]\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    k = remove_duplicates(nums)\n    output = format_output(k, nums)\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "success": true,
          "output": "2, nums = [1,2,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "success": true,
          "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode414.json",
    "problem_index_in_file": 0,
    "title": "Third Maximum Number",
    "description_snippet": "Given an integer array nums, return the third distinct maximum number in this array. If the third ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation, line by line. Use arrow and Start End. Must not output actual code. Provide steps for algorithm: find third distinct maximum. We can use set or variables. Steps: start, init max1, max2, max3 as null, iterate array, if num == any max skip, else if > max1, shift, etc. After loop, if max3 exists return it else return max1. Provide explanation. Ensure each line has virtual code and // explanation. Use \"Start\" and \"End\". Use arrows \"→\" and decisions \"Decision:\" with Yes/No. Let's craft.\n\nWe'll do:\n\nStart\n→ Step 1: Initialize max1, max2, max3 as null // set placeholders\n→ Step 2: For each num in nums // iterate\n    → Decision: If num == max1 or num == max2 or num == max3? // skip duplicates\n        Yes → Continue // skip to next number\n        No  → Decision: If max1 is null or num > max1? // new highest\n            Yes → Step 3: Set max3 = max2, max2 = max1, max1 = num // shift\n            No  → Decision: If max2 is null or num > max2? // second highest\n                Yes → Step 4: Set max3 = max2, max2 = num\n                No  → Decision: If max3 is null or num > max3? // third highest\n                    Yes → Step 5: Set max3 = num\n                    No  → Continue\n→ Decision: If max3 is null? // no third distinct\n    Yes → Step 6: Return max1\n    No  → Step 7: Return max3\nEnd\n\nNeed to ensure each line follows format with a single space between virtual code and comment. Also use arrow. For decision branches, indent but maintain same pattern. Let's output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 max1, max2, max3 為 null // 用於存放前三名最大值\n→ Step 2: 循環遍歷 nums 中每個 num // 逐個處理每個數字\n    → Decision: num 是否等於 max1 或 max2 或 max3？ // 避免重複值\n        Yes → Continue // 重複值直接跳過\n        No  → Decision: max1 為 null 或 num > max1？ // 檢查是否為新的最大值\n            Yes → Step 3: 設置 max3 = max2, max2 = max1, max1 = num // 右移更新三個最大值\n            No  → Decision: max2 為 null 或 num > max2？ // 檢查是否為第二大值\n                Yes → Step 4: 設置 max3 = max2, max2 = num // 右移更新第二、第三大值\n                No  → Decision: max3 為 null 或 num > max3？ // 檢查是否為第三大值\n                    Yes → Step 5: 設置 max3 = num // 更新第三大值\n                    No  → Continue // 小於前三名，跳過\n→ Decision: max3 為 null？ // 判斷是否存在第三大值\n    Yes → Step 6: 回傳 max1 // 無第三大，返回最大值\n    No  → Step 7: 回傳 max3 // 返回第三大值\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def thirdMax(self, nums):\n        # 去重後找到第三大的不同數字\n        first = second = third = float('-inf')\n        seen = set(nums)\n        for num in seen:\n            if num > first:\n                third = second\n                second = first\n                first = num\n            elif num > second:\n                third = second\n                second = num\n            elif num > third:\n                third = num\n        return third if len(seen) >= 3 else first\n\ndef parse_input(data: str):\n    # 去除可能的空白並解析 nums 列表\n    data = data.strip()\n    match = re.search(r'nums\\s*=\\s*(\\[.*\\])', data)\n    if match:\n        return eval(match.group(1))\n    # 若輸入直接是列表字面量\n    return eval(data)\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    result = Solution().thirdMax(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,2,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode639.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways II",
    "description_snippet": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n'A' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: typical decode ways with '*'. It's like Leetcode 639. We'll produce step-by-step pseudo code with branching. Need to include Start, End, Decision, etc. Let's produce algorithm: dynamic programming with dp[i] ways for prefix up to i. We'll handle '*' single and double contributions. Provide modular arithmetic. We produce each line of virtual code. We'll need to cover initialization, loop, cases. Provide explanation comments. Let's produce lines:\n\nStart // begin\n\n→ Step 1: set MOD = 1e9+7\n\n→ Step 2: let n = length of s\n\n→ Decision: If n == 0? // handle empty string\n\n    Yes → Step 3: return 0 // no decoding\n\n    No  → continue\n\n→ Step 4: initialize dp[0] = 1 // empty string has one way\n\n→ Step 5: compute dp[1] based on first char\n\nDecision: s[0] == '*'? // first char\n\n    Yes → dp[1] = 9\n\n    No → dp[1] = 1 if s[0] != '0' else 0\n\n→ For i from 2 to n:\n\n    → Step 6: set ways = 0\n\n    → Decision: current char s[i-1] // note indexing\n\n        If s[i-1] == '*' then\n\n            → ways += 9 * dp[i-1] // single digit choices 1-9\n\n        else if s[i-1] != '0' then\n\n            → ways += dp[i-1] // single digit mapping\n\n    → Decision: consider two-digit pair s[i-2]s[i-1]\n\n        If s[i-2] == '*' and s[i-1] == '*' then\n\n            // '**' can be 11-19 and 21-26\n\n            → ways += 15 * dp[i-2] // 9 + 6\n\n        else if s[i-2] == '*' then\n\n            // first is '*', second is digit\n\n            If s[i-1] <= '6' then\n\n                → ways += 2 * dp[i-2] // '*1'..'*6' can be 11-16,21-26\n\n            else\n\n                → ways += 1 * dp[i-2] // '*7'..'*9' can only be 17-19\n\n        else if s[i-1] == '*' then\n\n            // second is '*', first is digit\n\n            If s[i-2] == '1' then\n\n                → ways += 9 * dp[i-2] // 11-19\n\n            else if s[i-2] == '2' then\n\n                → ways += 6 * dp[i-2] // 21-26\n\n        else\n\n            // both digits\n\n            Let num = int(s[i-2]s[i-1])\n\n            If 10 <= num <= 26 then\n\n                → ways += dp[i-2]\n\n    → Step 7: dp[i] = ways mod MOD\n\n→ End // after loop\n\n→ Step 8: return dp[n]\n\nWe need each line with comment. We'll use arrows. Also include proper indentation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MOD = 1000000007 // 用於取模運算\n→ Step 2: 取得輸入字串長度 n = len(s)\n→ Decision: 如果 n == 0? // 空字串沒有合法解碼\n    Yes → Step 3: 回傳 0 // 無法解碼\n    No  → 繼續\n→ Step 4: 建立 dp 陣列，dp[0] = 1 // 空字串只有一種解碼方式\n→ Decision: s[0] 為 '*'? // 第一個字元處理\n    Yes → dp[1] = 9 // '*' 可以代表 1~9\n    No  → dp[1] = 1 if s[0] != '0' else 0 // 非 0 時有一種解碼\n→ For i from 2 到 n:\n    → Step 5: ways = 0 // 初始化此位置的解碼方式總數\n    → Decision: s[i-1] 為 '*'? // 單字元解碼\n        Yes → ways += 9 * dp[i-1] // 1~9 共 9 種\n        No  → 如果 s[i-1] != '0' 則 ways += dp[i-1] // 單位有效\n    → Decision: s[i-2]s[i-1] 兩位組合情形\n        If s[i-2] == '*' 且 s[i-1] == '*': // \"**\"\n            → ways += 15 * dp[i-2] // 11-19 (9 種) + 21-26 (6 種)\n        Else if s[i-2] == '*': // \"*d\"\n            If s[i-1] <= '6':\n                → ways += 2 * dp[i-2] // 11-16 或 21-26\n            Else:\n                → ways += 1 * dp[i-2] // 17-19\n        Else if s[i-1] == '*': // \"d*\"\n            If s[i-2] == '1':\n                → ways += 9 * dp[i-2] // 11-19\n            Else if s[i-2] == '2':\n                → ways += 6 * dp[i-2] // 21-26\n        Else: // \"dd\"\n            Let num = int(s[i-2:i]) // 兩位數\n            If 10 <= num <= 26:\n                → ways += dp[i-2] // 兩位數有效\n    → Step 6: dp[i] = ways mod MOD // 取模後存入 dp\n→ End // 迴圈結束\n→ Step 7: 回傳 dp[n] // 最終字串的解碼方式數量\nEnd // 程式結束執行",
      "generated_code": "import sys\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n        if n == 0:\n            return 0\n\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        # handle first character\n        if s[0] == '*':\n            dp[1] = 9\n        elif s[0] != '0':\n            dp[1] = 1\n\n        for i in range(2, n + 1):\n            ways = 0\n            cur = s[i - 1]\n            prev = s[i - 2]\n\n            # single character decoding\n            if cur == '*':\n                ways += 9 * dp[i - 1]\n            elif cur != '0':\n                ways += dp[i - 1]\n\n            # two-character decoding\n            if prev == '*' and cur == '*':\n                # ** can be 11-19 (9) or 21-26 (6)\n                ways += 15 * dp[i - 2]\n            elif prev == '*':\n                if cur <= '6':\n                    ways += 2 * dp[i - 2]\n                else:\n                    ways += 1 * dp[i - 2]\n            elif cur == '*':\n                if prev == '1':\n                    ways += 9 * dp[i - 2]\n                elif prev == '2':\n                    ways += 6 * dp[i - 2]\n            else:\n                num = int(prev + cur)\n                if 10 <= num <= 26:\n                    ways += dp[i - 2]\n\n            dp[i] = ways % MOD\n\n        return dp[n]\n\n\ndef parse_input(raw: str) -> str:\n    raw = raw.strip()\n    if not raw:\n        return ''\n    # handle formats like 's = \"*\"' or '\"*\"' or '*'\n    if '=' in raw:\n        _, val = raw.split('=', 1)\n        val = val.strip()\n    else:\n        val = raw\n    if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):\n        return val[1:-1]\n    return val\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.numDecodings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"*\"",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "s = \"1*\"",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 2,
          "input": "s = \"2*\"",
          "expected_output": "15",
          "success": true,
          "output": "15"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode367.json",
    "problem_index_in_file": 0,
    "title": "Valid Perfect Square",
    "description_snippet": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for checking perfect square using algorithm without sqrt. Possibly binary search or integer square root via Newton method. Provide virtual code steps.\n\nWe should output line by line, each line: \"虛擬碼步驟 // 解釋\".\n\nNeed to include Start, End, Decision etc.\n\nLet's design algorithm: Use binary search between 1 and num. If num=1 return true.\n\nPseudo:\n\nStart\n→ If num < 1? Actually positive integer.\n\n→ Step 1: Set low = 1, high = num\n→ Decision: while low <= high? Use loop.\n\n→ Step 2: mid = (low + high) / 2\n→ Step 3: square = mid * mid\n→ Decision: If square == num? Yes → return true; No → Decision: If square < num? Yes → low = mid + 1; No → high = mid - 1\n\nEnd with return false.\n\nWe need to show loop using Decision and branches.\n\nLet's produce lines accordingly.\n\nWe must not output real code; just virtual steps.\n\nLet's craft:\n\nStart // 程式開始\n→ Decision: 是否為正整數? // 檢查輸入是否合法 (num >=1)\n    Yes → Step 1: 設定 low = 1, high = num // 初始化搜尋範圍\n    No  → Step 1: 直接回傳 false // 非正整數不能為完全平方\n→ Decision: low <= high? // 判斷是否仍在搜尋範圍內\n    Yes → Step 2: mid = (low + high) / 2 // 取中間值\n    → Step 3: square = mid * mid // 計算平方\n    → Decision: square == num? // 檢查是否相等\n        Yes → Step 4: 回傳 true // 找到完全平方\n        No  → Decision: square < num? // 小於目標\n            Yes → Step 5: low = mid + 1 // 搜尋較大數\n            No  → Step 6: high = mid - 1 // 搜尋較小數\n    → Decision: low <= high? // 重新檢查條件\n        Yes → 迴圈往前走\n        No  → Step 7: 回傳 false // 未找到\nEnd // 程式結束\n\nBut we need loop construct; maybe use \"Loop:\" label. The format: Use Decision and arrow.\n\nMaybe represent loop with Decision: low <= high? and then at end go back to start of loop.\n\nBetter to use label: \"Loop:\" and go back.\n\nBut instructions say use Decision: and arrow etc. So we can emulate loop by Decision and arrow back to previous step.\n\nLet's craft:\n\nStart\n→ Decision: num < 1? // 檢查正整數\n    Yes → Step 1: 回傳 false // 非正整數\n    No  → Step 2: low = 1, high = num // 初始化\n→ Loop: Decision: low <= high? // 是否還在搜尋範圍內\n    Yes → Step 3: mid = (low + high) / 2 // 計算中位\n    → Step 4: square = mid * mid // 取得平方\n    → Decision: square == num? // 檢查是否相等\n        Yes → Step 5: 回傳 true // 找到\n        No  → Decision: square < num? // 小於\n            Yes → Step 6: low = mid + 1 // 右移\n            No  → Step 7: high = mid - 1 // 左移\n    → Decision: low <= high? // 迴圈條件\n        Yes → 回到 Loop // 重新判斷\n        No  → Step 8: 回傳 false // 未找到\nEnd\n\nBut we need to ensure each line format: \"虛擬碼步驟 // 解釋\".\n\nLet's list each line accordingly.\n\nWe might separate \"Loop:\" but not necessary. Just treat decision again.\n\nWe must include arrow symbol for branching: \"Yes →\" and \"No →\".\n\nLet's craft lines:\n\n1. Start // 程式開始\n2. → Decision: num < 1? // 檢查輸入是否為正整數\n   - Yes → Step 1: 回傳 false // 非正整數直接返回\n   - No  → Step 2: low = 1, high = num // 初始化搜尋區間\n3. → Decision: low <= high? // 是否仍在搜尋區間內\n   - Yes → Step 3: mid = (low + high) / 2 // 計算中間值\n   -  (then follow)\n4. → Step 4: square = mid * mid // 計算平方\n5. → Decision: square == num? // 檢查是否相等\n   - Yes → Step 5: 回傳 true // 找到完全平方\n   - No  → Decision: square < num? // 小於目標\n       - Yes → Step 6: low = mid + 1 // 搜尋更大的數\n       - No  → Step 7: high = mid - 1 // 搜尋更小的數\n6. → Decision: low <= high? // 迴圈條件\n   - Yes → 回到 Decision: low <= high? // 重新判斷\n   - No  → Step 8: 回傳 false // 未找到\n7. End // 程式結束\n\nBut we need to ensure each line printed individually. For multi-branch lines, we might have separate lines for each branch.\n\nWe need to output line by line. Possibly use indentation but not necessary. Format: \"虛擬碼步驟 // 解釋\". For decision, we should include branch lines. Each branch is a separate line.\n\nLet's produce:\n\nStart // 程式開始\n→ Decision: num < 1? // 檢查輸入是否為正整數\n    Yes → Step 1: 回傳 false // 非正整數直接返回\n    No  → Step 2: low = 1, high = num // 初始化搜尋區間\n→ Decision: low <= high? // 是否仍在搜尋區間內\n    Yes → Step 3: mid = (low + high) / 2 // 計算中間值\n    No  → Step 4: 回傳 false // 搜尋完畢未找到\n→ Step 5: square = mid * mid // 計算平方\n→ Decision: square == num? // 檢查是否相等\n    Yes → Step 6: 回傳 true // 找到完全平方\n    No  → Decision: square < num? // 小於目標\n        Yes → Step 7: low = mid + 1 // 搜尋更大的數\n        No  → Step 8: high = mid - 1 // 搜尋更小的數\n→ Decision: low <= high? // 迴圈條件\n    Yes → 回到 Decision: low <= high? // 重新判斷\n    No  → Step 9: 回傳 false // 未找到\nEnd // 程式結束\n\nBut we repeated the Decision: low <= high? earlier. Actually we need to loop until condition fails. Represent loop by decision and then go back.\n\nHowever the above sequence has two Decision: low <= high?. That's okay but may be confusing.\n\nAlternatively, we can label steps. But keep simple.\n\nBetter approach:\n\nStart\n→ Decision: num < 1?\n    Yes → Step 1: return false\n    No  → Step 2: low = 1, high = num\n→ LoopStart: Decision: low <= high?\n    Yes → Step 3: mid = (low + high) / 2\n    → Step 4: square = mid * mid\n    → Decision: square == num?\n        Yes → Step 5: return true\n        No  → Decision: square < num?\n            Yes → Step 6: low = mid + 1\n            No  → Step 7: high = mid - 1\n    → Go to LoopStart // loop again\n    No  → Step 8: return false\nEnd\n\nBut we need each line separate. For \"Go to LoopStart\" maybe \"→ LoopStart\" or \"→\" back.\n\nBetter produce as:\n\nStart // 程式開始\n→ Decision: num < 1? // 檢查輸入是否為正整數\n    Yes → Step 1: 回傳 false // 非正整數直接返回\n    No  → Step 2: low = 1, high = num // 初始化搜尋區間\n→ Decision: low <= high? // 進入搜尋迴圈\n    Yes → Step 3: mid = (low + high) / 2 // 取中間值\n    → Step 4: square = mid * mid // 計算平方\n    → Decision: square == num? // 檢查是否相等\n        Yes → Step 5: 回傳 true // 找到完全平方\n        No  → Decision: square < num? // 小於目標\n            Yes → Step 6: low = mid + 1 // 搜尋更大的數\n            No  → Step 7: high = mid - 1 // 搜尋更小的數\n    → Decision: low <= high? // 迴圈條件再次判斷\n        Yes → 回到 Decision: low <= high? // 重新進入迴圈\n        No  → Step 8: 回傳 false // 未找到\nEnd // 程式結束\n\nBut the \"回到 Decision: low <= high?\" line may be confusing. Use \"→\" to go back.\n\nWe can represent as \"→ Step 3\" again? Actually to loop, we can simply treat the loop as the outer decision repeating until false. But we cannot actually show iteration arrow.\n\nSimpler: Use while loop concept: Represent as \"LoopStart:\" then decisions.\n\nLet's attempt:\n\nStart // 程式開始\n→ Decision: num < 1? // 檢查輸入是否為正整數\n    Yes → Step 1: 回傳 false // 非正整數直接返回\n    No  → Step 2: low = 1, high = num // 初始化搜尋區間\n→ LoopStart: Decision: low <= high? // 迴圈開始\n    Yes → Step 3: mid = (low + high) / 2 // 計算中間值\n    → Step 4: square = mid * mid // 計算平方\n    → Decision: square == num? // 檢查是否相等\n        Yes → Step 5: 回傳 true // 找到完全平方\n        No  → Decision: square < num? // 小於目標\n            Yes → Step 6: low = mid + 1 // 搜尋更大的數\n            No  → Step 7: high = mid - 1 // 搜尋更小的數\n    → 回到 LoopStart // 重新判斷\n    No  → Step 8: 回傳 false // 未找到\nEnd // 程式結束\n\nThis is okay.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Decision: num < 1? // 檢查輸入是否為正整數  \n Yes → Step 1: 回傳 false // 非正整數直接返回  \n No  → Step 2: low = 1, high = num // 初始化搜尋區間  \n→ LoopStart: Decision: low <= high? // 進入搜尋迴圈  \n Yes → Step 3: mid = (low + high) / 2 // 計算中間值  \n  → Step 4: square = mid * mid // 計算平方  \n  → Decision: square == num? // 檢查是否相等  \n   Yes → Step 5: 回傳 true // 找到完全平方  \n   No  → Decision: square < num? // 小於目標  \n    Yes → Step 6: low = mid + 1 // 搜尋更大的數  \n    No  → Step 7: high = mid - 1 // 搜尋更小的數  \n  → 回到 LoopStart // 重新判斷條件  \n No  → Step 8: 回傳 false // 搜尋完畢未找到  \nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        if num < 2:\n            return True\n        left, right = 2, num // 2\n        while left <= right:\n            mid = (left + right) // 2\n            guess = mid * mid\n            if guess == num:\n                return True\n            elif guess > num:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 支援「num = 16」或直接「16」等輸入格式\n    if '=' in data:\n        try:\n            num = int(data.split('=')[-1].strip())\n        except ValueError:\n            # 若轉換失敗，直接退出\n            sys.exit(0)\n    else:\n        try:\n            num = int(data)\n        except ValueError:\n            sys.exit(0)\n\n    solution = Solution()\n    result = solution.isPerfectSquare(num)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "num = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode53.json",
    "problem_index_in_file": 0,
    "title": "Maximum Subarray",
    "description_snippet": "Given an integer array nums, find the subarray with the largest sum, and return its sum....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Kadane's algorithm. Must follow format. Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols. Provide Start, End, Decision. Use Step labels. For loop etc. Need to be \"逐行\" meaning each line a step. So we list steps like:\n\nStart // 開始\n\n→ Step 1: Initialize maxSum = nums[0] // 初始化最大子序列和\n\n→ Step 2: Initialize currentSum = nums[0] // 初始化當前子序列和\n\n→ Step 3: For each element nums[i] from i=1 to n-1 // 遍歷剩餘元素\n\n→ Decision: currentSum < 0? // 判斷是否將 currentSum 重新設為 0 或保留\n\nBut standard Kadane uses currentSum = max(nums[i], currentSum + nums[i]); So we can break into decisions: currentSum + nums[i] > nums[i]? Yes currentSum = currentSum + nums[i]; else currentSum = nums[i]; Then update maxSum if currentSum > maxSum. End loop. End // return maxSum.\n\nNeed to produce \"虛擬碼步驟\" each line. Provide explanation. Use arrow arrow. Should use \"→\" before steps, \"Decision:\" etc. We must maintain format. Let's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 初始化 maxSum = nums[0] // 設定最大子序列和為第一個元素\n\nLine 3: → Step 2: 初始化 currentSum = nums[0] // 設定當前子序列和為第一個元素\n\nLine 4: → Step 3: 從 i = 1 到 nums.length - 1 迴圈 // 逐個遍歷陣列剩餘元素\n\nLine 5: → Decision: currentSum + nums[i] > nums[i]? // 判斷是否延續前一個子序列或重新開始\n\nLine 6:     Yes → Step 4: currentSum = currentSum + nums[i] // 延續前一個子序列\n\nLine 7:     No  → Step 5: currentSum = nums[i] // 重新以目前元素開始新子序列\n\nLine 8: → Decision: currentSum > maxSum? // 判斷是否更新最大子序列和\n\nLine 9:     Yes → Step 6: maxSum = currentSum // 更新最大子序列和\n\nLine 10:    No  → Step 7: （不變） // 保持現有最大值\n\nLine 11: End of Loop // 迴圈結束\n\nLine 12: End // 程式執行結束，返回 maxSum\n\nBut we need each line in format: 虛擬碼步驟 // 解釋. So we need to add comment after. Also each line must start with \"Start\" or \"→ Step\" or \"→ Decision\" etc. The \"End of Loop\" maybe not necessary but we can use \"End Loop\" or just continue. Actually the format requires only Start, End, Decision. But for loop we can have Step with \"For each element...\" but not necessary to have End Loop. We can just indicate end of loop by dedent or comment. But we should keep consistency: Use \"→ Step 3: For each element ...\".\n\nBetter: After Step 3, we could add a nested indentation but format may not require indentation. We can just show \"→ Step 3: For each element nums[i] from i=1 to n-1\" and then inside we show Decision and steps. The end of loop can be implied after last step. We'll include a line \"End // 迴圈結束\" but may conflict with format? It's okay as generic comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxSum = nums[0] // 設定最大子序列和為第一個元素\n→ Step 2: 初始化 currentSum = nums[0] // 設定當前子序列和為第一個元素\n→ Step 3: 從 i = 1 到 nums.length - 1 迴圈 // 逐個遍歷陣列剩餘元素\n→ Decision: currentSum + nums[i] > nums[i]? // 判斷是否延續前一個子序列或重新開始\n    Yes → Step 4: currentSum = currentSum + nums[i] // 延續前一個子序列\n    No  → Step 5: currentSum = nums[i] // 重新以目前元素開始新子序列\n→ Decision: currentSum > maxSum? // 判斷是否更新最大子序列和\n    Yes → Step 6: maxSum = currentSum // 更新最大子序列和\n    No  → Step 7: （不變） // 保持現有最大值\nEnd // 程式執行結束，返回 maxSum",
      "generated_code": "import sys\nimport ast\n\ndef max_sub_array(nums):\n    \"\"\"\n    使用 Kadane 演算法計算最大子陣列和\n    :param nums: List[int]，輸入整數陣列\n    :return: int，最大子陣列和\n    \"\"\"\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入，支援 'nums = [1, 2, -3]' 或直接 '[1, 2, -3]'\n    if '=' in data:\n        _, value_part = data.split('=', 1)\n        nums_str = value_part.strip()\n    else:\n        nums_str = data\n\n    try:\n        nums = ast.literal_eval(nums_str)\n        if not isinstance(nums, list):\n            raise ValueError\n    except Exception:\n        print(\"輸入格式錯誤，請輸入有效的整數陣列\")\n        sys.exit(1)\n\n    result = max_sub_array(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [5,4,-1,7,8]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode14.json",
    "problem_index_in_file": 0,
    "title": "Longest Common Prefix",
    "description_snippet": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations. Need to output in traditional Chinese. Use arrow notation. Let's craft algorithm: Start -> if array empty return \"\". Set prefix = first string. Loop each string from second to end: while current string doesn't start with prefix, shorten prefix by removing last char; if prefix empty return \"\". After loop, return prefix. Then End. Provide comments after each line. Use 虛擬碼步驟. Let's output lines:\n\nStart // 程式開始執行\n→ Step 1: 接收字串陣列 words // 取得輸入字串陣列\n→ Decision: 如果 words 為空? // 檢查是否有任何字串\n    Yes → Step 2: 回傳 \"\" // 沒有字串時回傳空字串\n    No  → Step 3: 設定 prefix = words[0] // 以第一個字串作為初始前綴\n→ Decision: 迭代 words[1..]? // 從第二個字串開始逐一檢查\n    Yes → Step 4: 設定 current = words[i] // 取目前字串\n    → Decision: current 以 prefix 開頭? // 檢查是否包含前綴\n        Yes → Step 5: 繼續迭代下一個字串 // 若包含，保持 prefix\n        No  → Step 6: 降低 prefix 長度 直到符合 or 空 // 收縮前綴\n        → Decision: prefix 為空? // 檢查前綴是否已空\n            Yes → Step 7: 回傳 \"\" // 無公共前綴，結束\n            No  → 回到 Decision: current 以 prefix 開頭? // 重新檢查\n    No  → Step 8: 回傳 prefix // 所有字串都已檢查完畢，返回前綴\nEnd // 程式執行結束\n\nNeed to ensure each line has arrow and comment. Let's format.\n\nBut need to maintain \"虛擬碼步驟\" plus explanation. Use '→' for flow. Use \"Decision:\" lines.\n\nAlso, Step 7: 回傳 \"\" // ... should be arrow? After decision yes, we output Step 7. Then end.\n\nAlso need to ensure \"Yes →\", \"No →\" indentation. Provide correct indentation? In example, indentation indicated but not required. We'll keep simple.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收字串陣列 words // 取得輸入字串陣列  \n→ Decision: 如果 words 為空? // 檢查是否有任何字串  \n Yes → Step 2: 回傳 \"\" // 沒有字串時回傳空字串  \n No  → Step 3: 設定 prefix = words[0] // 以第一個字串作為初始前綴  \n→ Decision: 迭代 words[1..] 有剩餘字串? // 從第二個字串開始逐一檢查  \n Yes → Step 4: 設定 current = words[i] // 取目前字串  \n  → Decision: current 以 prefix 開頭? // 檢查是否包含前綴  \n   Yes → Step 5: 繼續迭代下一個字串 // 若包含，保持 prefix  \n   No  → Step 6: 降低 prefix 長度直到符合或空 // 收縮前綴  \n    → Decision: prefix 為空? // 檢查前綴是否已空  \n     Yes → Step 7: 回傳 \"\" // 無公共前綴，結束  \n     No  → 回到 Decision: current 以 prefix 開頭? // 重新檢查  \n No  → Step 8: 回傳 prefix // 所有字串已檢查完畢，返回前綴  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n        prefix = strs[0]\n        for s in strs[1:]:\n            while not s.startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n        return prefix\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找出第一個 '[' 與最後一個 ']'，取出 JSON 陣列字串\n    left = data.find('[')\n    right = data.rfind(']')\n    if left != -1 and right != -1 and right > left:\n        arr_str = data[left:right+1]\n    else:\n        # 若找不到括號，直接把整段字串當成陣列字串\n        arr_str = data\n\n    # 解析 JSON 陣列\n    try:\n        strs = json.loads(arr_str)\n    except Exception:\n        # 若 JSON 解析失敗，採用簡易分割方式\n        strs = [s.strip().strip('\"').strip(\"'\") for s in arr_str.split(',') if s.strip()]\n\n    sol = Solution()\n    result = sol.longestCommonPrefix(strs)\n\n    # 輸出結果，需加上雙引號\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "expected_output": "\"fl\"",
          "success": true,
          "output": "\"fl\""
        },
        {
          "example_index": 1,
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode72.json",
    "problem_index_in_file": 0,
    "title": "Edit Distance",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of operations required to convert word1...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing edit distance dynamic programming. Steps: Start, input word1, word2, compute lengths, initialize dp table of size (m+1)x(n+1). Fill base cases, then nested loops, compute min. Output result. Use decisions. Provide explanations. Use arrow formatting. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得字串 word1, word2 // 從使用者取得兩個輸入字串  \n→ Step 2: 計算 m = 長度(word1), n = 長度(word2) // 獲取兩字串長度  \n→ Step 3: 初始化 2D 陣列 dp[0..m][0..n] // 建立 DP 表格  \n→ Decision: 需要設定 dp[0][0] // 初始化表格  \n    Yes → Step 4: dp[0][0] ← 0 // 零長度字串轉換為零長度字串不需要操作  \n→ Decision: 填入第一行，表示從空字串轉換到 word2 的前 i 個字母  \n    Yes → Loop i from 1 to n  \n        → Step 5: dp[0][i] ← i // 只需插入 i 個字母  \n→ Decision: 填入第一列，表示從 word1 的前 i 個字母轉換到空字串  \n    Yes → Loop i from 1 to m  \n        → Step 6: dp[i][0] ← i // 只需刪除 i 個字母  \n→ Step 7: 外層迴圈 i 從 1 到 m  \n    → Step 8: 內層迴圈 j 從 1 到 n  \n        → Decision: word1[i-1] 與 word2[j-1] 是否相等? // 檢查目前字元是否相同  \n            Yes → Step 9: dp[i][j] ← dp[i-1][j-1] // 字元相同，成本為前一步  \n            No → Step 10: dp[i][j] ← 1 + Min( dp[i-1][j]   // 刪除 word1[i-1] 的成本  \n                                          dp[i][j-1]   // 插入 word2[j-1] 的成本  \n                                          dp[i-1][j-1] // 替換 word1[i-1] 為 word2[j-1] 的成本 )  \n→ Step 11: 回傳 dp[m][n] // 最小編輯距離即為答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_distance(word1: str, word2: str) -> int:\n    \"\"\"計算最小編輯距離（insert, delete, replace）\"\"\"\n    m, n = len(word1), len(word2)\n    # dp[i][j] = 將 word1[:i] 轉換成 word2[:j] 所需的最小操作數\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # 初始化第一列和第一行\n    for i in range(m + 1):\n        dp[i][0] = i          # 只刪除 i 個字元\n    for j in range(n + 1):\n        dp[0][j] = j          # 只插入 j 個字元\n\n    # 填表\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],      # 刪除\n                    dp[i][j - 1],      # 插入\n                    dp[i - 1][j - 1]   # 替換\n                )\n    return dp[m][n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出所有雙引號中的內容\n    words = re.findall(r'\"([^\"]*)\"', data)\n    if len(words) >= 2:\n        word1, word2 = words[0], words[1]\n    else:\n        # 若沒有雙引號，嘗試直接分割\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            word1, word2 = parts[0], parts[1]\n        else:\n            word1 = word2 = \"\"\n    result = min_distance(word1, word2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode765.json",
    "problem_index_in_file": 0,
    "title": "Couples Holding Hands",
    "description_snippet": "There are n couples sitting in 2n seats arranged in a row and want to hold hands.\n\nThe people and se...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for this problem: given an array row of length 2n representing IDs of people seated. Couples are pairs (0,1),(2,3),..., we need min swaps to make each couple sit next to each other. This is known problem: We can treat as graph where seats are pairs. Approach: iterate seats in steps of 2. For each pair, if persons are not a correct couple, swap with partner of person. Count swaps.\n\nBut for virtual code, we need step-by-step pseudocode with decision arrows, explanations.\n\nWe'll create Start, for i=0 to length-1 step 2. If row[i] and row[i+1] form a couple (i.e., row[i] /2 == row[i+1]/2), continue. Else, find index j such that row[j]== partner of row[i]. partner = row[i] XOR 1? Actually partner = row[i]^1. Because pairs are (0,1),(2,3). XOR 1 flips last bit. Then swap row[j] with row[i+1]. Increase swap count.\n\nReturn count.\n\nWe'll produce virtual code lines accordingly.\n\nWe should output each line like \"Start // 程式開始執行\" etc.\n\nLet's produce.\n\nMake sure each line has virtual code and comment.\n\nWe'll need to use arrows for decisions: e.g., \"Decision: 如果 row[i] 與 row[i+1] 為一對夫妻?\".\n\nAlso inside, \"Yes → Continue\" else \"No → 找到配偶位置\" etc.\n\nWe'll need a loop: \"Step 1: 迭代 i = 0; i < length; i += 2 // 每次檢查相鄰兩個座位\"\n\nWe'll include \"Step 2: 判斷是否為配偶\". Decision arrow. Then inside \"Yes → 無需交換\" and \"No → Step 3\".\n\n\"Step 3: 找到配偶座位 index\" -> loop over j to find row[j]== partner.\n\n\"Step 4: 交換 row[j] 與 row[i+1] // 交換兩人座位\" and increment swap count.\n\nAfter loop, \"Step 5: 回傳 swapCount\".\n\nOk.\n\nAlso we might want to note that partner = row[i] ^ 1. Use XOR.\n\nLet's produce accordingly.\n\nMake sure no real code, just virtual steps.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設置變數 swapCount = 0, length = row.length // 初始化交換次數與座位總數  \n→ Step 2: 迭代 i = 0; i < length; i += 2 // 每次檢查相鄰兩個座位  \n  Decision: 如果 row[i] 與 row[i+1] 為一對夫妻? // 檢查這兩個人是否已成對  \n   Yes → Step 2a: 繼續下一對 // 已配對，無需操作  \n   No  → Step 3: 找到 row[i] 的配偶座位 j // 需要交換以成對  \n    Step 3a: partner = row[i] XOR 1 // 取得配偶的 ID（偶數配偶為+1，奇數為-1）  \n    Step 3b: 迭代 j = i+2; j < length; j++ // 從剩餘座位尋找配偶  \n     Decision: 如果 row[j] == partner? // 找到配偶位置  \n      Yes → Step 3c: 交換 row[j] 與 row[i+1] // 將配偶移到相鄰座位  \n       swapCount += 1 // 交換次數加一  \n       跳出尋找迴圈  \n      No  → 繼續搜尋 j++  \n    Step 4: 回到外層迴圈 i += 2 // 完成此對座位後繼續下一對  \n→ Step 5: 回傳 swapCount // 返回最小交換次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_swaps_couples(row):\n    n = len(row)\n    pos = [0] * n\n    for i, x in enumerate(row):\n        pos[x] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] ^ 1\n        if row[i + 1] != partner:\n            partner_idx = pos[partner]\n            # swap the partner into the correct position\n            row[i + 1], row[partner_idx] = row[partner_idx], row[i + 1]\n            # update positions after the swap\n            pos[row[partner_idx]] = partner_idx\n            pos[row[i + 1]] = i + 1\n            swaps += 1\n    return swaps\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract all integer values from the input\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if not numbers:\n        print(0)\n    else:\n        result = min_swaps_couples(numbers)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "row = [0,2,1,3]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "row = [3,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode374.json",
    "problem_index_in_file": 0,
    "title": "Guess Number Higher or Lower",
    "description_snippet": "We are playing the Guess Game. The game is as follows: \n\nI pick a number from 1 to n. You have to gu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for the guess game, with step-by-step algorithm using guess API. We must output line by line, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow.\n\nWe need to describe binary search approach.\n\nThe algorithm: Start, set low=1, high=n, while low <= high: mid=(low+high)//2; call guess(mid); if result==0 return mid; else if result<0: high=mid-1; else low=mid+1. End.\n\nWe produce virtual code lines.\n\nWe must include virtual code steps like \"Step 1: Set low=1\". Use arrows.\n\nWe must maintain proper structure: Start, decisions, loops maybe \"While\" not specified but can use Decision: While low <= high?.\n\nWe can structure as Decision: low <= high? then inside. Use arrow for loop. Use Yes and No arrows.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: low ← 1 // 初始化最低猜測值\n→ Step 2: high ← n // 初始化最高猜測值\n→ Decision: low ≤ high? // 判斷是否還有範圍可猜\n    Yes → Step 3: mid ← (low + high) // 2 // 計算中間值\n    → Step 4: result ← guess(mid) // 呼叫 API 取得回覆\n    → Decision: result == 0? // 判斷是否猜中\n        Yes → Step 5: Return mid // 回傳正確答案\n        No → Decision: result < 0? // 猜的數字太大\n            Yes → Step 6: high ← mid - 1 // 將上界縮小\n            No  → Step 7: low ← mid + 1 // 將下界縮大\n    // 迴圈回到 Decision: low ≤ high? \n    No  → End // 範圍已空，結束\nEnd // 程式執行結束\n\nBut we must ensure proper indentation for decision. They used indentation in example. We need to follow format exactly: Indent decisions with spaces? In example they had \"Decision:\" lines then Yes →, No → lines inside. We must use \"Decision:\" line and indent Yes/No arrows with 4 spaces maybe. Example had:\n\nDecision: 如果數字大於 0? // ...\n    Yes → Step 2: ...\n    No  → Decision: ...\n\nSo we must indent 4 spaces before Yes → and No →. We'll use same style.\n\nSo produce output accordingly. Ensure no code blocks. Just plain lines.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 1 // 初始化最低猜測值  \n→ Step 2: high ← n // 初始化最高猜測值  \n→ Decision: low ≤ high? // 判斷是否還有範圍可猜  \n    Yes → Step 3: mid ← (low + high) // 2 // 計算中間值  \n    → Step 4: result ← guess(mid) // 呼叫 API 取得回覆  \n    → Decision: result == 0? // 判斷是否猜中  \n        Yes → Step 5: Return mid // 回傳正確答案  \n        No  → Decision: result < 0? // 猜的數字太大  \n            Yes → Step 6: high ← mid - 1 // 將上界縮小  \n            No  → Step 7: low ← mid + 1 // 將下界縮大  \n    // 迴圈回到 Decision: low ≤ high?  \n    No  → End // 範圍已空，結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\n# Global variable to store the hidden number\npick = None\n\ndef guess(num: int) -> int:\n    \"\"\"\n    模擬猜數字 API。\n    返回：\n    -1  如果猜的數字大於隱藏數字\n     1  如果猜的數字小於隱藏數字\n     0  如果猜對\n    \"\"\"\n    global pick\n    if num > pick:\n        return -1\n    elif num < pick:\n        return 1\n    else:\n        return 0\n\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        \"\"\"\n        使用二分搜尋來猜中隱藏數字。\n        \"\"\"\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res < 0:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1  # 應該不會到這裡\n\ndef parse_input(line: str):\n    \"\"\"\n    解析輸入格式，例如：'n = 10, pick = 6'\n    回傳 (n, pick)\n    \"\"\"\n    parts = line.split(',')\n    n_val = pick_val = None\n    for part in parts:\n        part = part.strip()\n        if part.startswith('n'):\n            n_val = int(part.split('=')[1].strip())\n        elif part.startswith('pick'):\n            pick_val = int(part.split('=')[1].strip())\n    return n_val, pick_val\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取資料，呼叫解法並輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n, pick_val = parse_input(data)\n    global pick\n    pick = pick_val\n    solution = Solution()\n    result = solution.guessNumber(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10, pick = 6",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode18.json",
    "problem_index_in_file": 0,
    "title": "4Sum",
    "description_snippet": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for 4-sum problem. Provide lines like Start, sorting, loops, two-pointer etc. Use virtual arrows.\n\nWe need to produce each line with explanation. Let's craft:\n\nStart\n→ Step 1: Sort nums // Sorting simplifies duplicate removal and two-pointer technique\n→ Step 2: Initialize result list // 存放四元組\n→ Decision: If length of nums < 4? // 沒足夠元素\n    Yes → End // 結束\n    No → Continue\n→ Step 3: For i from 0 to n-4 // 第1個指標\n    → Decision: If i > 0 and nums[i] == nums[i-1]? // 跳過重複\n        Yes → Continue\n        No → ...\n    → Step 4: For j from i+1 to n-3 // 第2個指標\n        → Decision: If j > i+1 and nums[j] == nums[j-1]? // 跳過重複\n            Yes → Continue\n            No →\n        → Step 5: left = j+1; right = n-1 // 第3和第4指標\n        → Decision: While left < right\n            → Step 6: sum = nums[i] + nums[j] + nums[left] + nums[right] // 計算四數之和\n            → Decision: If sum == target? \n                Yes → Append quadruplet // 加入結果\n                    → Step 7: While left < right and nums[left] == nums[left+1] // 跳過左重複\n                        left++\n                    → Step 8: While left < right and nums[right] == nums[right-1] // 跳過右重複\n                        right--\n                    → left++; right--\n                No →\n                    → Decision: If sum < target?\n                        Yes → left++ // 需要更大和\n                        No → right-- // 需要更小和\n→ End // 完成\n\nWe need each line with `//` comment.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums // 將輸入陣列按升序排列，方便後續去重與兩指標搜尋  \n→ Step 2: Initialize result // 建立空列表，用來儲存符合條件的四元組  \n→ Decision: If len(nums) < 4? // 若元素不足四個，無法形成四元組  \n Yes → End // 結束程式  \n No  → Continue // 進入後續邏輯  \n→ Step 3: For i from 0 to n-4 // 第一個指標，遍歷前 n-4 個位置  \n → Decision: If i > 0 and nums[i] == nums[i-1]? // 同值避免重複四元組  \n  Yes → Continue // 跳過重複的第一個元素  \n  No  → Continue to next block  \n → Step 4: For j from i+1 to n-3 // 第二個指標，從 i+1 開始  \n  → Decision: If j > i+1 and nums[j] == nums[j-1]? // 同值避免重複的第二個元素  \n   Yes → Continue // 跳過重複  \n   No  → Continue  \n  → Step 5: left = j+1; right = n-1 // 第三、四個指標分別指向剩餘範圍的左右端  \n  → Decision: While left < right  \n   → Step 6: sum = nums[i] + nums[j] + nums[left] + nums[right] // 計算目前四個數字之和  \n   → Decision: If sum == target?  \n    Yes → Append [nums[i], nums[j], nums[left], nums[right]] to result // 符合目標，加入結果  \n     → Step 7: While left < right and nums[left] == nums[left+1] // 移動左指標至下一個不同值  \n      left++  \n     → Step 8: While left < right and nums[right] == nums[right-1] // 移動右指標至前一個不同值  \n      right--  \n     → left++; right-- // 將指標移回下一個可能組合  \n    No → Decision: If sum < target?  \n     Yes → left++ // 和不足，左指標往右移以增大和  \n     No  → right-- // 和過大，右指標往左移以減小和  \n→ End // 程式執行結束，結果已儲存於 result 中",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fourSum(self, nums, target):\n        \"\"\"\n        Find all unique quadruplets in nums that sum to target.\n        \"\"\"\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            # skip duplicate first element\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                # skip duplicate second element\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        # skip duplicates for the third element\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        # skip duplicates for the fourth element\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n    # Extract nums list and target integer using regex\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        print(\"[]\")\n        sys.exit(0)\n    nums = eval(nums_match.group(1))\n    target = int(target_match.group(1))\n\n    sol = Solution()\n    result = sol.fourSum(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "success": true,
          "output": "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "success": true,
          "output": "[[2, 2, 2, 2]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode509.json",
    "problem_index_in_file": 0,
    "title": "Fibonacci Number",
    "description_snippet": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step explanation. Use Start, End, Decision. Should produce lines like:\n\nStart // 程式開始執行\n→ Step 1: input n // Get input\n→ Decision: If n == 0? // base case\n  Yes → Step 2: output 0 // ...\n  No → Decision: if n == 1? // ...\n    Yes → Step 3: output 1\n    No → Step 4: set a=0, b=1 // initialize\n    → Step 5: for i from 2 to n:\n       → Step 6: temp = a + b\n       → Step 7: a = b\n       → Step 8: b = temp\n    → Step 9: output b\nEnd\n\nWe need to ensure each line with `虛擬碼步驟` + space + `// 解釋`. Use arrow \"→\". For decisions we indent with spaces. Should maintain formatting.\n\nMake sure to use \"Yes →\" \"No →\" within decision. Should not output actual code. Provide explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 從使用者處取得 Fibonacci 索引  \n→ Decision: n 是否等於 0? // 檢查是否為最小基底  \n  Yes → Step 2: 輸出 0 // F(0) = 0，直接回傳  \n  No → Decision: n 是否等於 1? // 確認第二個基底  \n    Yes → Step 3: 輸出 1 // F(1) = 1，直接回傳  \n    No → Step 4: 初始化 a = 0, b = 1 // 設定前兩項的值  \n    → Step 5: 循環 i 從 2 到 n  \n      → Step 6: temp = a + b // 計算下一個 Fibonacci 數  \n      → Step 7: a = b // 更新上一項為前一個值  \n      → Step 8: b = temp // 更新目前項為新的值  \n    → Step 9: 輸出 b // 最後一個 b 即為 F(n)  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef fib(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出第一個符合整數的模式\n    match = re.search(r\"-?\\d+\", data)\n    if match:\n        n = int(match.group())\n        result = fib(n)\n        print(result)\n    else:\n        # 若無整數輸入，則不輸出任何內容\n        pass",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode15.json",
    "problem_index_in_file": 0,
    "title": "3Sum",
    "description_snippet": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step for algorithm to find all unique triplets in an integer array that sum to zero, no duplicates.\n\nThe algorithm: sort array, iterate i from 0 to n-3, skip duplicates, use two pointers left = i+1, right = n-1, while left<right: sum = nums[i]+nums[left]+nums[right]; if sum==0 add triplet; move left/right skipping duplicates. If sum<0 left++; else right--. End. Return list.\n\nWe need to produce each line with \"虛擬碼步驟\" and comment. We need to use arrow syntax: Start, Decision:, Yes →, No →, etc. Also must not output actual code, only virtual steps.\n\nWe need to generate line-by-line steps. For example:\n\nStart // 程式開始\n\n→ Step 1: 輸入整數陣列 nums // 取得輸入\n\n→ Step 2: 計算陣列長度 n // 取得長度\n\n→ Decision: n < 3? // 判斷是否足夠三個元素\n\n    Yes → End // 如果不足，直接結束，無結果\n\n    No  → Step 3: 將 nums 排序 // 為了方便跳過重複與雙指標\n\n→ Step 4: 建立空集合 result // 用來存結果\n\n→ For i from 0 to n-3: // 以 i 為第一個指標\n\n    → Decision: i > 0 且 nums[i] == nums[i-1]? // 跳過重複的第一個\n\n        Yes → Continue // 跳到下一個 i\n\n        No  → Step 5: left = i+1, right = n-1 // 設定雙指標\n\n        → While left < right:\n\n            → Step 6: sum = nums[i] + nums[left] + nums[right] // 計算和\n\n            → Decision: sum == 0? // 判斷是否為三元組\n\n                Yes →\n\n                    → Step 7: 加入 [nums[i], nums[left], nums[right]] 到 result // 添加結果\n\n                    → Step 8: left++ // 移動左指標\n\n                    → Step 9: right-- // 移動右指標\n\n                    → Decision: left < right 且 nums[left] == nums[left-1]? // 跳過重複左\n\n                        Yes → left++ // 重複，繼續移動\n\n                        No  → // no action\n\n                    → Decision: left < right 且 nums[right] == nums[right+1]? // 跳過重複右\n\n                        Yes → right-- // 重複，繼續移動\n\n                        No  → // no action\n\n                No →\n\n                    → Decision: sum < 0? // 和小於0\n\n                        Yes → left++ // 左指標右移\n\n                        No  → right-- // 右指標左移\n\n→ End // 結束，返回 result\n\nBut we need each line as separate step with comment. Also we must use \"Decision:\" etc.\n\nWe need to make sure each step includes arrow and comment. Use \"→\" to indent.\n\nThe format: each line must contain \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nNeed to ensure indentation and decisions properly.\n\nLet's produce the steps:\n\n1. Start // 程式開始執行\n2. → Step 1: 輸入整數陣列 nums // 取得使用者輸入\n3. → Step 2: 計算陣列長度 n // 用於後續判斷\n4. → Decision: n < 3? // 是否有足夠元素組成三元組\n    - Yes → End // 無法構造，直接結束\n    - No  → Step 3: 將 nums 進行升序排序 // 為了後續使用雙指標與跳重複\n5. → Step 4: 建立空集合 result // 用來儲存符合條件的三元組\n6. → For i = 0 to n-3: // 以 i 為第一個元素索引\n    - → Decision: i > 0 且 nums[i] == nums[i-1]? // 跳過重複的首元素\n        - Yes → Continue // 跳到下一個 i\n        - No  → Step 5: 設定 left = i + 1, right = n - 1 // 初始化雙指標\n        - → While left < right:\n            - → Step 6: sum = nums[i] + nums[left] + nums[right] // 計算三元組和\n            - → Decision: sum == 0? // 是否符合條件\n                - Yes →\n                    - → Step 7: 將 [nums[i], nums[left], nums[right]] 加入 result // 添加到結果集\n                    - → Step 8: left++ // 移動左指標\n                    - → Step 9: right-- // 移動右指標\n                    - → Decision: left < right 且 nums[left] == nums[left - 1]? // 跳過重複左指標\n                        - Yes → left++ // 進一步移動\n                        - No  → // 無操作\n                    - → Decision: left < right 且 nums[right] == nums[right + 1]? // 跳過重複右指標\n                        - Yes → right-- // 進一步移動\n                        - No  → // 無操作\n                - No →\n                    - → Decision: sum < 0? // 和小於零\n                        - Yes → left++ // 左指標右移\n                        - No  → right-- // 右指標左移\n7. → End // 程式執行結束，返回 result\n\nBut we need to make sure each line is separate with \"→\". In this representation, there are nested steps; each nested line must also start with \"→\". For indentation, we can use multiple arrows? Or just one arrow per line, but indent with spaces? The requirement says use arrow (→, Yes →, No →). They didn't specify multiple arrows per indentation. Use \"→\" to start each step, and for decisions we add \"Decision:\" and then indent following lines with maybe 4 spaces.\n\nLet's produce final answer with lines, each with arrow and comment. Ensure all lines start with \"Start\" or \"→\" or \"Decision:\" etc.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 取得使用者輸入  \n→ Step 2: 計算陣列長度 n // 用於後續判斷  \n→ Decision: n < 3? // 是否有足夠元素組成三元組  \n Yes → End // 無法構造，直接結束  \n No  → Step 3: 將 nums 進行升序排序 // 為了後續使用雙指標與跳重複  \n→ Step 4: 建立空集合 result // 用來儲存符合條件的三元組  \n→ For i = 0 to n-3: // 以 i 為第一個元素索引  \n → Decision: i > 0 且 nums[i] == nums[i-1]? // 跳過重複的首元素  \n  Yes → Continue // 跳到下一個 i  \n  No  → Step 5: 設定 left = i + 1, right = n - 1 // 初始化雙指標  \n  → While left < right: // 雙指標循環  \n   → Step 6: sum = nums[i] + nums[left] + nums[right] // 計算三元組和  \n   → Decision: sum == 0? // 是否符合條件  \n    Yes →  \n     → Step 7: 將 [nums[i], nums[left], nums[right]] 加入 result // 添加到結果集  \n     → Step 8: left++ // 移動左指標  \n     → Step 9: right-- // 移動右指標  \n     → Decision: left < right 且 nums[left] == nums[left - 1]? // 跳過重複左指標  \n      Yes → left++ // 進一步移動  \n      No  → // 無操作  \n     → Decision: left < right 且 nums[right] == nums[right + 1]? // 跳過重複右指標  \n      Yes → right-- // 進一步移動  \n      No  → // 無操作  \n    No →  \n     → Decision: sum < 0? // 和小於零  \n      Yes → left++ // 左指標右移  \n      No  → right-- // 右指標左移  \n→ End // 程式執行結束，返回 result",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def threeSum(self, nums):\n        nums.sort()\n        res = []\n        n = len(nums)\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            left, right = i + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total == 0:\n                    res.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif total < 0:\n                    left += 1\n                else:\n                    right -= 1\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Parse input, expecting format like \"nums = [ ... ]\" or just a list\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n    else:\n        expr = data\n    try:\n        nums = ast.literal_eval(expr.strip())\n    except Exception as e:\n        # If parsing fails, treat the entire input as a list literal\n        nums = ast.literal_eval(data.strip())\n    solution = Solution()\n    result = solution.threeSum(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,1,2,-1,-4]",
          "expected_output": "[[-1,-1,2],[-1,0,1]]",
          "success": true,
          "output": "[[-1, -1, 2], [-1, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,0,0]",
          "expected_output": "[[0,0,0]]",
          "success": true,
          "output": "[[0, 0, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode474.json",
    "problem_index_in_file": 0,
    "title": "Ones and Zeroes",
    "description_snippet": "You are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line with explanation. Problem: given array of binary strings, choose largest subset such that at most m zeros and n ones. Classic 0/1 knapsack DP with two dimensions. We'll produce algorithm steps: count zeros and ones for each string, DP array [m+1][n+1] initialized 0. Iterate strings, for each update dp from m to 0 and n to 0 reverse. Use virtual code steps. No actual code. Provide explanation after each line.\n\nLet's write.\n\nStart\n→ Step 1: Initialize dp 2D array size (m+1)×(n+1) with zeros // 用於儲存每個0、1限制下最大子集大小\n→ Step 2: For each string s in strs // 逐一處理每個二進位字串\n    → Step 2a: Count zeros z in s // 计算该字符串中 0 的数量\n    → Step 2b: Count ones o in s // 计算该字符串中 1 的数量\n    → Decision: 如果 z > m 或 o > n? // 若单个字符串已超限，直接跳过\n        Yes → Step 2c: Continue // 跳过此字符串\n        No  → Step 3: Update dp in reverse order // 更新 DP，防止同字符串被多次计数\n            → For i from m down to z\n                → For j from n down to o\n                    → Step 3a: dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // 取加入或不加入当前字符串的最大值\n→ Step 4: Result = dp[m][n] // 取完整限制下的最大子集大小\n→ End // 输出结果\n\nBut we need each line as \"虛擬碼步驟 [space] // 解釋\". Use arrows. For loops use →? Use nested indentation? The format example uses indent for nested decisions. We should follow same style. So each line maybe:\n\nStart // 程式開始執行\n→ Step 1: Initialize dp 2D array (m+1)×(n+1) with zeros // ...\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 2 維 DP 陣列 dp，大小為 (m+1) × (n+1)，全部初值為 0 // 用於記錄各種 0、1 限制下可達到的最大子集大小  \n→ Step 2: 遍歷每個二進位字串 s 於 strs // 逐一考慮加入或不加入每個字串  \n  → Step 2a: 計算 s 中 0 的數量 z // 需要用來更新 0 的限制  \n  → Step 2b: 計算 s 中 1 的數量 o // 需要用來更新 1 的限制  \n  → Decision: 如果 z > m 或 o > n? // 單個字串已超出任一限制，無法加入  \n    Yes → Step 2c: 跳過此字串 // 直接進下一個字串  \n    No  → Step 3: 以倒序更新 dp // 防止同一字串被多次計算  \n     → For i 由 m 降至 z  \n      → For j 由 n 降至 o  \n       → Step 3a: dp[i][j] = max(dp[i][j], dp[i‑z][j‑o] + 1) // 加入此字串後的子集大小與不加的最大值比較  \n→ Step 4: 結果為 dp[m][n] // 完整限制下可得到的最大子集大小  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        \"\"\"\n        0/1 雙重背包: dp[i][j] 表示使用 i 個 0 與 j 個 1 能夠取得的最大字串數\n        \"\"\"\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序更新，避免同一個字串被重複使用\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 strs、m、n。支援多種輸入格式，例如：\n    - strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    - [\"10\",\"0001\",\"111001\",\"1\",\"0\"]\n      5 3\n    \"\"\"\n    data = data.strip()\n    # 先嘗試使用正則表達式抓取三個參數\n    strs_match = re.search(r'strs\\s*=\\s*(\\[.*?\\])', data)\n    m_match = re.search(r'm\\s*=\\s*(\\d+)', data)\n    n_match = re.search(r'n\\s*=\\s*(\\d+)', data)\n\n    if strs_match and m_match and n_match:\n        strs = eval(strs_match.group(1))\n        m = int(m_match.group(1))\n        n = int(n_match.group(1))\n        return strs, m, n\n\n    # 如果第一種方式失敗，假設輸入是兩行：第一行為陣列，第二行為兩個整數\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        strs = eval(lines[0].strip())\n        m, n = map(int, lines[1].strip().split())\n        return strs, m, n\n\n    # 失敗則拋例外\n    raise ValueError(\"無法解析輸入\")\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    strs, m, n = parse_input(raw_data)\n    result = Solution().findMaxForm(strs, m, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode227.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator II",
    "description_snippet": "Given a string s which represents an expression, evaluate this expression and return its value.\n\nThe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for evaluating an arithmetic expression string with + - * / (maybe parentheses? The problem statement didn't mention parentheses but typical LeetCode 227 Basic Calculator II includes only non-negative integers and operators + - * /. No parentheses. So implement algorithm: use stack or variable for last number and operator.\n\nWe must produce virtual code steps with arrow, Start, End, Decision. Each line has code and comment. No actual code. Just virtual steps. Provide sequential steps. Use arrow to show flow. We'll include steps: Preprocess string: iterate through characters, accumulate number, when operator or end, apply previous operator to stack or last number.\n\nWe also need division truncating toward zero: we can handle by integer division with sign.\n\nLet's produce.\n\nWe will show:\n\nStart\n→ Step 1: Initialize variables: stack ← empty list, num ← 0, op ← '+'\n→ Step 2: For each character ch in string s plus a sentinel '+':\n    → Decision: If ch is whitespace? No → skip\n    → Decision: If ch is digit? Yes → accumulate num ← num*10 + int(ch)\n    → Decision: If ch is operator or at end? Yes → Process previous operator:\n        → Decision: If op == '+': stack.append(num)\n        → Decision: If op == '-': stack.append(-num)\n        → Decision: If op == '*': temp ← stack.pop() * num; stack.append(temp)\n        → Decision: If op == '/': temp ← stack.pop(); stack.append(int(temp/num)) // trunc toward zero\n        → Step 3: Set op ← ch; num ← 0\n→ Step 4: Sum stack to result\n→ End\n\nBut we need to produce line-by-line with arrows.\n\nWe might structure with loops and decisions.\n\nWe need to use arrow \"→\" between steps.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize stack ← [], num ← 0, op ← '+'\n→ Step 2: Append a sentinel '+' to expression to force final processing\n→ Step 3: For each ch in expression:\n    → Decision: ch is whitespace? No → skip\n    → Decision: ch is digit? Yes → num ← num * 10 + int(ch)\n    → Decision: ch is operator? Yes → Process previous op:\n        → Decision: op == '+': stack.append(num)\n        → Decision: op == '-': stack.append(-num)\n        → Decision: op == '*': temp ← stack.pop() * num; stack.append(temp)\n        → Decision: op == '/': temp ← stack.pop(); stack.append(int(temp/num))\n        → Step 4: op ← ch; num ← 0\n→ Step 5: result ← sum(stack)\n→ End\n\nBut we need to use \"→\" for decisions too. Use indentation.\n\nLet's produce a final answer with each line including code and comment. Use \"Decision:\" lines. Example: \"Decision: ch is digit?\". We need to include indentation. Use spaces.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: stack ← [] // 建立堆疊存儲已計算數字\n→ Step 2: num ← 0 // 用於累積當前數字\n→ Step 3: op ← '+' // 前一個操作符，初始為加法\n→ Step 4: expr ← s + '+' // 在字串末尾加入假操作符，確保最後一個數字被處理\n→ Step 5: For each ch in expr:\n    → Decision: ch is whitespace? // 判斷是否為空白字元\n        Yes → Continue // 跳過空白\n        No  →\n            → Decision: ch is digit? // 判斷是否為數字字符\n                Yes → num ← num * 10 + int(ch) // 累積數字\n                No  →\n                    → Decision: ch is operator? // 判斷是否為 + - * / 字元\n                        Yes →\n                            → Decision: op == '+'? // 處理前一個操作符\n                                Yes → stack.append(num)\n                                No →\n                                    → Decision: op == '-'\n                                        Yes → stack.append(-num)\n                                        No →\n                                            → Decision: op == '*'\n                                                Yes → temp ← stack.pop() * num; stack.append(temp)\n                                                No →\n                                                    → Decision: op == '/'\n                                                        Yes → temp ← stack.pop(); stack.append(int(temp/num))\n                                                    No → // 其他符號不處理\n                            → Step 6: op ← ch // 更新操作符\n                            → Step 7: num ← 0 // 重置數字累積\n→ Step 8: result ← sum(stack) // 求和得到最終結果\n→ End // 程式結束\n\nMake sure each line has \"虛擬碼步驟\" + comment. Should not include code. Use arrow. The format: \"Start // comment\" etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: stack ← [] // 建立堆疊存儲已計算數字  \n→ Step 2: num ← 0 // 用於累積當前數字  \n→ Step 3: op ← '+' // 前一個操作符，初始為加法  \n→ Step 4: expr ← s + '+' // 在字串末尾加入假操作符，確保最後一個數字被處理  \n→ Step 5: For each ch in expr:  \n  → Decision: ch is whitespace? // 判斷是否為空白字元  \n   Yes → Continue // 跳過空白  \n   No →  \n    → Decision: ch is digit? // 判斷是否為數字字符  \n     Yes → num ← num * 10 + int(ch) // 累積數字  \n     No →  \n      → Decision: ch is operator? // 判斷是否為 + - * / 字元  \n       Yes →  \n        → Decision: op == '+'? // 處理前一個操作符  \n         Yes → stack.append(num) // 加法：把數字放入堆疊  \n         No →  \n          → Decision: op == '-'\n           Yes → stack.append(-num) // 減法：把數字的負值放入堆疊  \n           No →  \n            → Decision: op == '*'\n             Yes → temp ← stack.pop() * num; stack.append(temp) // 乘法：把上一個數字與現在的數字相乘  \n             No →  \n              → Decision: op == '/'\n                Yes → temp ← stack.pop(); stack.append(int(temp/num)) // 除法：取整除，向 0 截斷  \n                No → // 其他符號不處理  \n                 \n              → Step 6: op ← ch // 更新操作符  \n              → Step 7: num ← 0 // 重置數字累積  \n→ Step 8: result ← sum(stack) // 求和得到最終結果  \n→ End // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        stack = []\n        num = 0\n        sign = '+'\n        s += '+'  # 方便最後處理最後一個數字\n\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-*/':\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    top = stack.pop()\n                    # int() truncates toward zero\n                    stack.append(int(top / num))\n                sign = c\n                num = 0\n            # 其它字符（空白）直接忽略\n\n        return sum(stack)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 將輸入中的字串提取出來，假設格式為 s = \"...\"\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        expr = data[start + 1:end]\n    else:\n        expr = data  # 若沒有引號，直接使用整個輸入\n\n    result = Solution().calculate(expr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3+2*2\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \" 3/2 \"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \" 3+5 / 2 \"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode673.json",
    "problem_index_in_file": 0,
    "title": "Number of Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the number of longest increasing subsequences.\n\nNotice that the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for algorithm: count longest increasing subsequences. Classic DP: maintain length[i] and count[i], iterate j<i. Provide explanation for each line. Use arrows. Provide structure: Start, for loops, decision, updates. We'll produce code like:\n\nStart\n→ Step 1: Initialize arrays len[n] = 1, cnt[n] = 1 // each element is LIS length 1, count 1\n→ Step 2: For i from 0 to n-1 // iterate each element\n    → Step 3: For j from 0 to i-1 // check previous elements\n        → Decision: if nums[j] < nums[i]? // strictly increasing\n            Yes → Decision: if len[j] + 1 > len[i]? // longer subsequence found\n                Yes → Step 4: len[i] = len[j] + 1 // update length\n                    → Step 5: cnt[i] = cnt[j] // copy count\n                No  → Decision: if len[j] + 1 == len[i]? // same length\n                    Yes → Step 6: cnt[i] += cnt[j] // add counts\n                    No → // nothing\n        No → // skip\n→ Step 7: Find maxLen = max(len) // longest length\n→ Step 8: Sum counts where len[i] == maxLen // total LIS count\n→ End\n\nWe need to provide explanations after each line. Format lines with virtual code and // explanation. Use \"→\" and indentation for decisions. Must be per line. Provide maybe indentation for decision branches. Ensure every line is a separate line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化長度陣列 len[n] = 1，計數陣列 cnt[n] = 1 // 每個元素本身是長度為 1 的遞增子序列，計數為 1  \n→ Step 2: 從 i = 0 到 n-1 迭代每個元素 // 外層循環處理所有位置  \n    → Step 3: 從 j = 0 到 i-1 迭代前面元素 // 檢查前面的候選子序列  \n        → Decision: 如果 nums[j] < nums[i]? // 必須嚴格遞增  \n            Yes → Decision: 如果 len[j] + 1 > len[i]? // 找到更長的子序列  \n                Yes → Step 4: len[i] = len[j] + 1 // 更新長度  \n                    → Step 5: cnt[i] = cnt[j] // 計數改為前面子序列的計數  \n                No  → Decision: 如果 len[j] + 1 == len[i]? // 同長度的子序列  \n                    Yes → Step 6: cnt[i] += cnt[j] // 累加計數  \n                    No → // 無需更動  \n        No → // nums[j] >= nums[i]，跳過  \n→ Step 7: 找出最大長度 maxLen = max(len) // 求最長子序列長度  \n→ Step 8: 初始化總計數 total = 0  \n    → Step 9: 從 i = 0 到 n-1 迭代  \n        → Decision: 如果 len[i] == maxLen? // 僅統計最大長度的子序列  \n            Yes → Step 10: total += cnt[i] // 加總計數  \n            No  → // 跳過  \n→ End // 程式執行結束，total 為長度最大遞增子序列的總數",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findNumberOfLIS(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        # lengths[i] = length of LIS ending at i\n        # counts[i] = number of LIS ending at i\n        lengths = [1] * n\n        counts = [1] * n\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if lengths[j] + 1 > lengths[i]:\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                    elif lengths[j] + 1 == lengths[i]:\n                        counts[i] += counts[j]\n\n        longest = max(lengths)\n        return sum(c for l, c in zip(lengths, counts) if l == longest)\n\ndef parse_input() -> list[int]:\n    \"\"\"\n    Parse the input from stdin. The input may be in the form\n    'nums = [1,3,5,4,7]' or just a plain list like '[1,3,5]'.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return []\n\n    # Find the first list-like substring\n    match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not match:\n        return []\n\n    list_str = '[' + match.group(1) + ']'\n    return ast.literal_eval(list_str)\n\ndef main():\n    nums = parse_input()\n    result = Solution().findNumberOfLIS(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode686.json",
    "problem_index_in_file": 0,
    "title": "Repeated String Match",
    "description_snippet": "Given two strings a and b, return the minimum number of times you should repeat string a so that str...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, with explanation after each line. Need to process: find min repeats of a so that b is substring. Approach: compute repeats needed: at least ceil(len(b)/len(a)), then maybe +1. Check by concatenating a repeats times and check substring. If not found after repeats+1, return -1.\n\nWe output virtual code with Start, End, Decision, Step lines. Each line \"虛擬碼步驟 // 解釋\".\n\nWe need to use arrow syntax. Let's produce:\n\nStart\n→ Step 1: Calculate lenA = length of a // get length of a\n→ Step 2: Calculate lenB = length of b // get length of b\n→ Step 3: Compute minRepeats = ceil(lenB / lenA) // minimum repeats needed so that repeated string length >= lenB\n→ Step 4: repeated = \"\" // initialize concatenated string\n→ Step 5: repeatCounter = 0 // initialize counter\n→ Decision: while repeatCounter < minRepeats? // ensure repeated string length >= lenB\n    Yes → Step 6: repeated = repeated + a // append a to repeated\n    Yes → Step 7: repeatCounter = repeatCounter + 1 // increment counter\n    Yes → (loop back to Decision)\n→ Decision: Is b substring of repeated? // check if b appears in repeated\n    Yes → Step 8: return repeatCounter // min repeats found\n    No  → Decision: Is repeatCounter + 1 <= 2 * ceil(lenB / lenA) + 1? // allow one more repeat\n        Yes → Step 9: repeated = repeated + a // append one more a\n        Yes → Step 10: repeatCounter = repeatCounter + 1 // increment\n        Yes → Decision: Is b substring of repeated? // check again\n            Yes → Step 11: return repeatCounter // found after extra repeat\n            No  → Step 12: return -1 // impossible\n        No  → Step 13: return -1 // no more repeats allowed\nEnd\n\nBut we need a more concise approach: Actually typical solution: repeat a until length >= len(b)*2 maybe. But we can propose algorithm: For i from minRepeats to minRepeats+2, repeat string i times and check. Return first that works else -1.\n\nSo produce steps:\n\nStart\n→ Step 1: Compute lenA = length of a\n→ Step 2: Compute lenB = length of b\n→ Step 3: Compute base = ceil(lenB / lenA) // minimum repeats to cover b length\n→ Step 4: For repeats from base to base + 2: // at most two extra repeats\n    → Step 5: repeated = a repeated repeats times // build repeated string\n    → Decision: If b is substring of repeated? // check\n        Yes → Step 6: return repeats // minimal repeats found\n        No  → (continue loop)\n→ Step 7: return -1 // b cannot be found\nEnd\n\nWe need to format each line with `虛擬碼步驟 // 解釋`. Let's produce each line accordingly.\n\nWe might need to show loops and decisions.\n\nThe virtual code lines must include arrow `→`. For loops: maybe we write `→ For repeats = base to base + 2:`. And then indent decisions inside.\n\nBetter: Use indentation like:\n\n→ Step 1: ...\n→ Step 2: ...\n→ Step 3: ...\n→ For repeats from base to base + 2: // 循環嘗試不同重複次數\n    → Step 4: repeated = a repeated repeats times // 生成重複字串\n    → Decision: If b 是 repeated 的子字串? // 檢查是否包含\n        Yes → Step 5: return repeats // 找到最小重複數\n        No  → (loop continues)\n→ Step 6: return -1 // 仍未找到，返回 -1\nEnd\n\nBut we need to show decision and steps properly.\n\nWe should use `Yes →` and `No →` arrows.\n\nOk let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 lenA = a 的長度 // 取得字串 a 的長度  \n→ Step 2: 計算 lenB = b 的長度 // 取得字串 b 的長度  \n→ Step 3: 計算 base = ceil(lenB / lenA) // 需要的最少重複次數，以確保重複後的長度至少與 b 相同或更長  \n→ For repeats 從 base 到 base + 2: // 依序嘗試基礎次數以及再多一次或兩次  \n  → Step 4: 建立 repeated = a 重複 repeats 次 // 生成重複後的字串  \n  → Decision: b 是否是 repeated 的子字串? // 檢查 b 是否存在於重複字串中  \n   Yes → Step 5: 回傳 repeats // 找到最小符合條件的重複次數  \n   No  → (回到 For 迴圈，嘗試下一個 repeats)  \n→ Step 6: 回傳 -1 // 兩次額外重複後仍無法包含 b，表示不可能  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport math\n\ndef repeated_string_match(a: str, b: str) -> int:\n    \"\"\"\n    Return the minimal number of repetitions of string `a`\n    such that `b` becomes a substring of the repeated string.\n    If impossible, return -1.\n    \"\"\"\n    # Minimum repetitions needed so that the repeated string is at least as long as `b`\n    repeat = (len(b) + len(a) - 1) // len(a)   # ceil division\n    s = a * repeat\n    if b in s:\n        return repeat\n    # Try one more repetition in case `b` straddles the boundary\n    s += a\n    if b in s:\n        return repeat + 1\n    return -1\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input string to extract the two strings `a` and `b`.\n    The input may contain quoted strings like:\n        a = \"abcd\", b = \"cdabcdab\"\n    or just two whitespace separated tokens. This parser handles\n    the quoted format first, then falls back to whitespace tokens.\n    \"\"\"\n    # Find all quoted substrings\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # Fallback: split by whitespace and take first two tokens\n    tokens = data.strip().split()\n    if len(tokens) >= 2:\n        return tokens[0], tokens[1]\n    raise ValueError(\"Invalid input format\")\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read()\n    a, b = parse_input(raw_input)\n    result = repeated_string_match(a, b)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"abcd\", b = \"cdabcdab\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = \"a\", b = \"aa\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode152.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product Subarray",
    "description_snippet": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for maximum product subarray. Use dynamic programming tracking max and min. Steps. Provide each line with // explanation. Use arrows. Start, End. Ensure lines have virtual code step and explanation. Use structure.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 max_so_far, min_so_far, result 為 nums[0] // 設定第一個數為初始最大、最小子陣列積與整體最大值\n→ Step 2: 從索引 1 開始遍歷 nums // 循環處理剩餘元素\n    → Decision: 當前數字 nums[i] 是否小於 0? // 判斷符號以決定最大最小互換\n        Yes → Step 3: 交換 max_so_far 與 min_so_far // 乘以負數時最大最小會互換\n        No  → Step 4: 直接不變 // 正數不影響交換\n    → Step 5: max_so_far ← max(nums[i], max_so_far * nums[i]) // 更新當前最大子陣列積\n    → Step 6: min_so_far ← min(nums[i], min_so_far * nums[i]) // 更新當前最小子陣列積\n    → Step 7: result ← max(result, max_so_far) // 以當前最大子陣列積更新全局最大值\n→ End // 程式執行結束，返回 result\n\n(Note: 每行虛擬碼後面均附有簡短解釋。)",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProduct(self, nums):\n        # 若陣列為空，回傳 0\n        if not nums:\n            return 0\n\n        # 初始化目前最大、最小子陣列積以及整體最大值\n        max_prod = min_prod = result = nums[0]\n\n        # 從第二個元素開始遍歷\n        for num in nums[1:]:\n            # 若目前數字為負，最大與最小會互相交換\n            if num < 0:\n                max_prod, min_prod = min_prod, max_prod\n\n            # 更新最大子陣列積：取「單獨數字」或「前最大乘以數字」\n            max_prod = max(num, max_prod * num)\n\n            # 更新最小子陣列積：取「單獨數字」或「前最小乘以數字」\n            min_prod = min(num, min_prod * num)\n\n            # 以目前最大子陣列積更新整體最大值\n            result = max(result, max_prod)\n\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從字串中擷取所有整數（包含負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # 執行解法並輸出結果\n    print(Solution().maxProduct(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-2,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [-2,0,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode494.json",
    "problem_index_in_file": 0,
    "title": "Target Sum",
    "description_snippet": "You are given an integer array nums and an integer target.\n\nYou want to build an expression out of n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: target sum by adding + or - before each number. This is classic DP or recursion with memoization. For each index, we add/subtract value and continue. Count number of ways to reach target.\n\nWe need step-by-step virtual code with explanation. Should be in Chinese (繁體). Use virtual code arrows and decision.\n\nLet's produce algorithm:\n\nStart\n→ Input: nums array, target integer //取得輸入\n→ Define function dfs(index, current_sum) //遞迴函式\n    → If index == length(nums): //已處理所有數字\n        → If current_sum == target: //檢查是否等於目標\n            Yes → Return 1 //找到一種表達式\n            No → Return 0 //不等於目標\n    → else: //還有數字要處理\n        → Compute result = 0 //累加\n        → result += dfs(index+1, current_sum + nums[index]) //加號\n        → result += dfs(index+1, current_sum - nums[index]) //減號\n        → Return result //返回總數\n\nBut we need memoization: use memo table map[(index, current_sum)].\n\nImplementation details: dp recursion with memoization.\n\nWe also may implement iterative DP: start with map of sums counts after each number.\n\nWe need virtual code lines with explanation.\n\nWe'll produce a simple recursive with memo. Provide steps.\n\nAlso include the final count. Steps:\n\nStart //程式開始執行\n→ Step 1: 輸入數列 nums 與目標 target //取得輸入\n→ Step 2: 建立 memo 表 (index, current_sum) → 記錄已計算結果 //設定快取\n→ Step 3: 定義遞迴函式 Count(index, current_sum) //計算方式\n    → Decision: 若 index == nums.length? //已到尾端\n        Yes → Decision: current_sum == target? //是否達到目標\n            Yes → Step 4: Return 1 //找到一種表達式\n            No  → Step 5: Return 0 //無解\n        No  → Step 6: 若 memo 有此 (index,current_sum)? //快取\n                Yes → Step 7: Return memo value\n                No  → Step 8: 計算 res = Count(index+1, current_sum + nums[index]) + Count(index+1, current_sum - nums[index]) //遞迴\n                    → Step 9: memo[(index,current_sum)] = res //存入快取\n                    → Step 10: Return res //返回\n\n→ Step 11: 呼叫 Count(0,0) //從索引0開始，和為0\n→ Step 12: Output 結果 //顯示計算結果\nEnd\n\nBut need arrow style: \"→ Step X:\" etc. Provide each line with explanation comment after //.\n\nAlso we need Decision lines: \"Decision:\" and sub-branches.\n\nLet's produce accordingly.\n\nWe also need to include memoization inside recursion but may present as separate steps. The algorithm is basically recursion with memo. We'll produce each line.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 輸入整數陣列 nums 與目標 target //取得輸入\n→ Step 2: 建立空 memo 表格 //用來記錄已計算的 (index, current_sum) 結果\n→ Step 3: 定義遞迴函式 Count(index, current_sum) //計算從 index 開始剩下的數字能得到目標的方式數\n    → Decision: 如果 index 等於 nums.length? //已處理完所有數字\n        Yes → Decision: 如果 current_sum 等於 target? //是否達到目標\n            Yes → Step 4: Return 1 //找到一個有效表達式\n            No  → Step 5: Return 0 //不符合目標\n        No  → Decision: 是否在 memo 有 (index, current_sum)? //檢查快取\n            Yes → Step 6: Return memo[(index, current_sum)] //直接回傳快取結果\n            No  → Step 7: 計算 res = Count(index+1, current_sum + nums[index]) //加號方案\n            → Step 8: res += Count(index+1, current_sum - nums[index]) //減號方案\n            → Step 9: memo[(index, current_sum)] = res //存入快取\n            → Step 10: Return res //回傳累計結果\n→ Step 11: 呼叫 Count(0, 0) 並將回傳值存於 variable result //從索引 0 開始，初始總和為 0\n→ Step 12: 輸出 result //顯示符合 target 的不同表達式數量\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\nimport ast\n\ndef find_target_sum_ways(nums, target):\n    dp = defaultdict(int)\n    dp[0] = 1\n    for num in nums:\n        next_dp = defaultdict(int)\n        for s, cnt in dp.items():\n            next_dp[s + num] += cnt\n            next_dp[s - num] += cnt\n        dp = next_dp\n    return dp[target]\n\ndef parse_input(data: str):\n    \"\"\"Parse input that may be in the form:\n       nums = [1,1,1,1,1], target = 3\n       or may be three separate lines:\n       5\n       1 1 1 1 1\n       3\n    \"\"\"\n    data = data.strip()\n    # Try the 'nums = [...] , target = ...' pattern first\n    m = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)', data)\n    if m:\n        nums_str = m.group(1)\n        target = int(m.group(2))\n        nums = ast.literal_eval(nums_str)\n        return nums, target\n\n    # Fallback: assume the input is line separated\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 3:\n        # First line might be the length (ignore if it matches the number of elements)\n        try:\n            n = int(lines[0])\n            nums = list(map(int, lines[1].split()))\n            target = int(lines[2])\n            # If the first line is indeed the length, we can ignore it\n            if len(nums) == n:\n                return nums, target\n            else:\n                # Maybe the first line is part of nums\n                nums = list(map(int, lines[0].split())) + nums\n                target = int(lines[2])\n                return nums, target\n        except ValueError:\n            pass\n    # If we cannot parse, raise an error\n    raise ValueError(\"Input format not recognized.\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    result = find_target_sum_ways(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1], target = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode447.json",
    "problem_index_in_file": 0,
    "title": "Number of Boomerangs",
    "description_snippet": "You are given n points in the plane that are all distinct, where points[i] = [x_i, y_i]. A boomerang...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for computing number of boomerangs. The output should be line-by-line virtual code with explanation comments. Use arrow syntax, Start, End, Decision. Each line: virtual step + \" // 解釋/說明\". Use '→' for continuation.\n\nWe should outline steps: Input array of points. Initialize total count = 0. For each point i, compute distances to all other points j. Use dictionary map distance->count. For each distance d, add count*(count-1) to total (since order matters). At end output total.\n\nUse virtual code lines: Start, → Step 1: Initialize total = 0, etc.\n\nNeed to be careful: Use arrows: Start, → Step, → Decision. Use indentation for nested.\n\nAlso use Yes → and No → for decision.\n\nLet's craft code.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: total ← 0 // 初始化總計數\n\nLine 3: → Step 2: pointsCount ← length(points) // 取得點數\n\nLine 4: → Decision: 是否為空? // 檢查點陣列是否為空\n\nLine 5:     Yes → End // 若無點，直接結束\n\nLine 6:     No  → Loop i from 0 to pointsCount-1 // 逐一處理每個基準點\n\nWithin loop:\n\nLine 7:         → Step 3: distCount ← empty map // 建立距離-計數對應表\n\nLine 8:         → Loop j from 0 to pointsCount-1, j ≠ i // 計算與其他點距離\n\nLine 9:             → Step 4: dx ← points[j].x - points[i].x // 差值x\n\nLine 10:            → Step 5: dy ← points[j].y - points[i].y // 差值y\n\nLine 11:            → Step 6: dist ← dx*dx + dy*dy // squared distance\n\nLine 12:            → Step 7: distCount[dist] ← distCount.get(dist,0)+1 // 更新計數\n\nAfter inner loop:\n\nLine 13:        → Step 8: For each (dist, cnt) in distCount // 遍歷每個距離\n\nLine 14:            → Decision: cnt >= 2? // 需要至少兩個點同距離才能組成boomerang\n\nLine 15:                Yes → Step 9: total ← total + cnt*(cnt-1) // 加入排列數\n\nLine 16:                No  → Step 10: // 跳過\n\nAfter outer loop:\n\nLine 17: → Step 11: Return total // 回傳結果\n\nLine 18: End // 程式結束\n\nWe need to use arrow for loops? Not necessary but can use \"→ Loop\" as pseudo.\n\nLet's ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". The arrow should be included as part of the step. E.g., \"→ Step 1: total ← 0 // 初始化總計數\".\n\nAlso indentation for nested decisions can be using tabs? In example they used spaces. We'll just indent.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: total ← 0 // 初始化總計數  \n→ Step 2: pointsCount ← length(points) // 取得點數  \n→ Decision: pointsCount == 0? // 檢查是否沒有任何點  \n    Yes → End // 若無點，直接結束  \n    No  → Loop i from 0 to pointsCount-1 // 逐一處理每個基準點  \n        → Step 3: distCount ← empty map // 建立距離-計數對應表  \n        → Loop j from 0 to pointsCount-1, j ≠ i // 計算與其他點距離  \n            → Step 4: dx ← points[j].x - points[i].x // 計算x差值  \n            → Step 5: dy ← points[j].y - points[i].y // 計算y差值  \n            → Step 6: dist ← dx*dx + dy*dy // 計算平方距離  \n            → Step 7: distCount[dist] ← distCount.get(dist,0)+1 // 更新距離計數  \n        → Step 8: For each (dist, cnt) in distCount // 遍歷每個距離  \n            → Decision: cnt >= 2? // 需要至少兩個點同距離才能組成 boomerang  \n                Yes → Step 9: total ← total + cnt*(cnt-1) // 加入排列數  \n                No  → Step 10: // 跳過  \n→ Step 11: Return total // 回傳總計數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef number_of_boomerangs(points):\n    total = 0\n    for x1, y1 in points:\n        dist_count = defaultdict(int)\n        for x2, y2 in points:\n            if x1 != x2 or y1 != y2:\n                d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n                dist_count[d] += 1\n        for cnt in dist_count.values():\n            total += cnt * (cnt - 1)\n    return total\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    # 允許輸入格式為 \"points = [[...]]\" 或直接 \"[[...]]\"\n    if raw.lower().startswith(\"points\"):\n        raw = raw.split(\"=\", 1)[1].strip()\n    points = ast.literal_eval(raw)\n    print(number_of_boomerangs(points))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[0,0],[1,0],[2,0]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,1],[2,2],[3,3]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "points = [[1,1]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode384.json",
    "problem_index_in_file": 0,
    "title": "Shuffle an Array",
    "description_snippet": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm design: shuffle algorithm. The algorithm likely uses Fisher-Yates shuffle.\n\nWe need to output each step line with explanation. Need to include class methods.\n\nUse Start, End, Decision.\n\nWe need to include initialization, reset, shuffle.\n\nLet's outline:\n\nStart\n→ Step: Store original array copy // store original for reset\n→ Decision: ?\n\nMaybe we need to show structure: In constructor: copy array.\n\nreset method: return original copy.\n\nshuffle method: perform Fisher-Yates: iterate i from last to 1: choose random j between 0 and i inclusive; swap arr[i] with arr[j].\n\nWe need to show algorithm in virtual code.\n\nLet's produce steps:\n\nStart // Program start\n→ Step: Store original array // Save copy for reset\n→ End // End of constructor\n\nBut we need separate for methods.\n\nWe could do:\n\nStart // Program start\n→ Step: Constructor with nums\n    → Decision: None? maybe just assignment.\n→ End // end constructor\nSimilarly for reset and shuffle.\n\nBut to show algorithm, include loops.\n\nLet's produce pseudo-code lines:\n\nStart\n→ Step: Initialize Solution with nums // constructor\n    → Step: original ← copy(nums) // deep copy\n    → Step: current ← copy(nums) // working array\n→ End // constructor end\n→ Step: reset() // method\n    → Return original // restore original array\n→ End // reset method end\n→ Step: shuffle() // method\n    → Step: arr ← copy(current) // copy for shuffling\n    → Step: n ← length(arr)\n    → Step: for i from n-1 downto 1\n        → Decision: generate random j between 0 and i inclusive\n            → Step: swap arr[i] with arr[j]\n    → Return arr\n→ End // shuffle method end\nEnd\n\nBut we need to output each line individually.\n\nLet's produce each line as a step with comment.\n\nWe also need to use arrow \"→\".\n\nUse indent? The example shows indent for decisions.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step: Constructor(Solution) receives nums // 建構子接收原始陣列\nLine 3: → Step: original ← copy(nums) // 先備份原始陣列以便重設\nLine 4: → Step: current ← copy(nums) // 設定工作陣列為原始值\nLine 5: → End // 結束建構子\nLine 6: → Step: reset() // 方法：重設陣列\nLine 7: → Decision: 需返回原始陣列? // 直接返回備份\nLine 8:     Yes → Step: return original // 回傳原始順序\nLine 9:     No  → Step: return current // 若想返回工作陣列\nLine 10: → End // 結束 reset 方法\nLine 11: → Step: shuffle() // 方法：隨機打亂陣列\nLine 12: → Step: arr ← copy(current) // 複製一份工作陣列以進行打亂\nLine 13: → Step: n ← length(arr) // 取得陣列長度\nLine 14: → Step: for i from n-1 downto 1\nLine 15:     → Decision: choose j in [0, i] 隨機整數 // 產生隨機索引\nLine 16:         Yes → Step: swap arr[i] and arr[j] // 交換元素\nLine 17: → End // 迴圈結束\nLine 18: → Step: return arr // 回傳打亂後陣列\nLine 19: → End // 結束 shuffle 方法\nLine 20: End // 程式執行結束\n\nBut we should reflect that shuffle uses Fisher-Yates.\n\nNeed to avoid too many decision lines.\n\nBetter to show simpler.\n\nUse the arrow.\n\nLet's produce.\n\nAlso include indentation for nested steps.\n\nMake sure each line is unique.\n\nWe should maintain clarity.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Constructor(Solution) receives nums // 建構子接收原始陣列  \n→ Step: original ← copy(nums) // 儲存原始陣列備份以供 reset  \n→ Step: current ← copy(nums) // 建立工作陣列，初始值為原始陣列  \n→ End // 結束建構子  \n\n→ Step: reset() // 方法：重設陣列  \n→ Decision: 需要回傳原始陣列? // 直接使用備份  \n Yes → Step: return original // 回傳原始順序  \n No  → Step: return current // 若需回傳工作陣列  \n→ End // 結束 reset 方法  \n\n→ Step: shuffle() // 方法：隨機打亂陣列  \n→ Step: arr ← copy(current) // 複製工作陣列進行打亂，保持 current 不變  \n→ Step: n ← length(arr) // 取得陣列長度  \n→ Step: for i from n-1 downto 1 // Fisher‑Yates 迴圈  \n → Decision: generate random j in [0, i] // 隨機選擇交換索引  \n  Yes → Step: swap arr[i] and arr[j] // 交換元素  \n→ End // 迴圈結束  \n→ Step: return arr // 回傳打亂後的陣列  \n→ End // 結束 shuffle 方法  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的副本\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return self.original\n\n    def shuffle(self):\n        # 使用 Fisher-Yates 洗牌算法\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    # 讀取整個 stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入包裝成一個 tuple，方便用 ast.literal_eval 解析\n    try:\n        commands, args = ast.literal_eval(f'({data})')\n    except Exception as e:\n        # 若解析失敗，直接結束\n        sys.exit(1)\n\n    outputs = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == 'Solution':\n            obj = Solution(arg[0])  # arg[0] 是 nums 列表\n            outputs.append(None)\n        elif obj is not None:\n            # 呼叫對應的方法\n            method = getattr(obj, cmd)\n            result = method(*arg)\n            outputs.append(result)\n        else:\n            # 如果沒有實例化就呼叫方法，忽略\n            outputs.append(None)\n\n    # 使用 json.dumps 來格式化輸出，確保 None 轉為 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,3,1],[1,2,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 3, 1], [1, 2, 3], [2, 1, 3]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode405.json",
    "problem_index_in_file": 0,
    "title": "Convert a Number to Hexadecimal",
    "description_snippet": "Given a 32-bit integer num, return a string representing its hexadecimal representation. For negativ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Provide steps: handle negative by adding 2^32, convert to hex by repeatedly dividing by 16 mapping to digits. Remove leading zeros. Use lowercase. Steps: Start, handle zero case, if num==0 then output \"0\", end. Else, if negative: num += 2^32. Then loop: while num>0: digit = num % 16; map to char; prepend to result string; num //= 16. After loop, output result. End. Use decision structure. Provide explanation. Ensure no built-in methods like hex(). Use mapping array. Use string operations. Represent adding 2^32 as 4294967296. Use mapping array: digits = ['0', '1', ...]. We'll use index. Use a variable result. Prepend char: result = char + result. Provide steps.\n\nLet's produce virtual code with lines. Use arrow. Ensure each line has explanation. Let's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告整數 num 及字串 result = \"\" // 取得輸入值與準備結果  \n→ Decision: 如果 num == 0? // 檢查是否為零  \n    Yes → Step 2: 輸出 \"0\" // 零的十六進位表示為 \"0\"  \n    No  → Decision: 如果 num < 0? // 判斷是否為負數  \n        Yes → Step 3: num = num + 4294967296 // 對負數加 2^32 取得兩補數表示  \n        No  → // 正數保持不變  \n→ Step 4: 定義陣列 digits = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"] // 十六進位對應字元  \n→ Step 5: While num > 0 // 逐位轉換直到數字為 0  \n    → Step 5a: digit = num % 16 // 取得最低位的十六進位數值  \n    → Step 5b: char = digits[digit] // 對應字元  \n    → Step 5c: result = char + result // 將字元加到結果前面，保持正確順序  \n    → Step 5d: num = num // 16 // 去掉已處理的最低位  \n→ Step 6: 輸出 result // 輸出最終的十六進位字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef to_hex(num: int) -> str:\n    \"\"\"Return the hexadecimal string of a 32‑bit integer.\"\"\"\n    # Special case for zero\n    if num == 0:\n        return \"0\"\n\n    # Handle negative numbers using two's complement\n    if num < 0:\n        num += 4294967296  # 2**32\n\n    digits = ['0', '1', '2', '3', '4', '5', '6', '7',\n              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']\n\n    res = \"\"\n    while num > 0:\n        res = digits[num % 16] + res\n        num //= 16\n\n    return res\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract the first integer (handles formats like \"num = 26\" or just \"26\")\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        sys.exit()  # No integer found; nothing to do\n\n    num = int(match.group())\n    # Compute and output the hexadecimal representation\n    print(to_hex(num))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 26",
          "expected_output": "1a",
          "success": true,
          "output": "1a"
        },
        {
          "example_index": 1,
          "input": "num = -1",
          "expected_output": "ffffffff",
          "success": true,
          "output": "ffffffff"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode722.json",
    "problem_index_in_file": 0,
    "title": "Remove Comments",
    "description_snippet": "Given a C++ program, remove comments from it. The program source is an array of strings source where...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The user wants the algorithm for removing comments from C++ code. We should output virtual code steps line by line, each with explanation. Use arrows, decisions. Provide steps for iterating lines, scanning characters, handling block and line comments, building result lines, skipping empty lines, final return.\n\nWe need to not output actual code, only virtual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions.\n\nLet's outline: Start. Initialize result list, blockComment flag false, temp string for building line. For each line in source: set i=0. While i < line.length: If blockComment: check for \"*/\" -> if found set blockComment false and move i past \"*/\", else break to next line. If not in blockComment: check for \"//\" -> if found break to next line (ignore rest). Else check for \"/*\" -> if found set blockComment true, move i past \"/*\". Else add current char to temp, i++. After line ends, if not in blockComment and temp not empty, add temp to result. Reset temp for next line. After all lines, return result.\n\nEdge: when block comment spans multiple lines, we need to keep collecting. We skip lines that become empty.\n\nAdd decision to check block comment state, and to skip line when line comment encountered. Use arrows.\n\nLet's write steps.\n\nWill use \"→\" arrow. Decision: ... Yes/No.\n\nWe also need to handle implicit newline deletion: If block comment ends and the rest of line after '*/' is ignored? Actually after closing block comment we resume scanning same line. So we handle that.\n\nOk.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果清單 result ← 空列表 // 用於儲存去除註解後的程式碼行  \n→ Step 2: 初始化 blockCommentFlag ← False // 標誌是否處於區塊註解內  \n→ Step 3: 初始化 tempLine ← 空字串 // 用於累積目前行的有效程式碼  \n\n→ Decision: 遍歷每一行 source[i]？ // 對源碼中的每一行進行處理  \n    Yes → Step 4: 設定 i ← 0 // 初始化字元索引  \n    → While i < length(source[i])? // 在行內逐字元掃描  \n        Yes → Decision: blockCommentFlag 為 True? // 是否已進入區塊註解  \n            Yes → Step 5: 判斷是否遇到 \"*/\"？  \n                → Decision: 從 i 開始兩字元為 \"*/\"?  \n                    Yes → Step 6: blockCommentFlag ← False // 結束區塊註解  \n                    → Step 7: i ← i + 2 // 跳過 \"*/\"  \n                    No  → Step 8: i ← i + 1 // 仍在區塊註解，忽略此字元  \n                → Loop back到 While  \n            No  → Decision: 從 i 開始兩字元為 \"//\"? // 判斷是否為行註解  \n                Yes → Step 9: 跳出 While // 跳過此行剩餘字元  \n                No  → Decision: 從 i 開始兩字元為 \"/*\"? // 判斷是否為區塊註解起始  \n                    Yes → Step 10: blockCommentFlag ← True // 開始區塊註解  \n                    → Step 11: i ← i + 2 // 跳過 \"/*\"  \n                    No  → Step 12: 將 source[i][j] 加到 tempLine // 累積有效字元  \n                    → Step 13: i ← i + 1 // 移動到下一個字元  \n                → Loop back到 While  \n        → End While  \n\n→ Decision: blockCommentFlag 為 False 且 tempLine 不是空？ // 行結束後檢查是否有有效程式碼  \n    Yes → Step 14: 將 tempLine 加入 result // 存入結果清單  \n    No  → Step 15: 不加入任何內容 // 空行不輸出  \n→ Step 16: 重置 tempLine ← 空字串 // 為下一行做準備  \n\n→ End of For each line loop  \n→ Step 17: 回傳 result // 完成註解移除，返回結果清單  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n        new_line = []\n\n        for line in source:\n            i = 0\n            if not in_block:\n                new_line = []\n            while i < len(line):\n                if not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '*':\n                    in_block = True\n                    i += 1  # skip '*'\n                elif in_block and i + 1 < len(line) and line[i] == '*' and line[i + 1] == '/':\n                    in_block = False\n                    i += 1  # skip '/'\n                elif not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '/':\n                    break  # line comment: skip rest of line\n                elif not in_block:\n                    new_line.append(line[i])\n                i += 1\n            if new_line and not in_block:\n                res.append(\"\".join(new_line))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n    # Extract the list part after '='\n    try:\n        _, rhs = data.split('=', 1)\n    except ValueError:\n        rhs = data\n    rhs = rhs.strip()\n    source = ast.literal_eval(rhs)\n    solution = Solution()\n    result = solution.removeComments(source)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]",
          "expected_output": "[\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]",
          "success": true,
          "output": "['int main()', '{ ', '  ', 'int a, b, c;', 'a = b + c;', '}']"
        },
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "success": true,
          "output": "['ab']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode292.json",
    "problem_index_in_file": 0,
    "title": "Nim Game",
    "description_snippet": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the Nim game: determine if you can win given optimal play. Classic: winning positions are when n % 4 != 0. So virtual code: Start, input n, decision if n % 4 != 0 then true else false. We need to output step-by-step with virtual code and explanation per line.\n\nFormat: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 取得 n // 從輸入取得石子數\n→ Decision: n % 4 != 0? // 檢查 n 是否為非 4 的倍數\n    Yes → Step 2: 輸出 true // 你能贏\n    No  → Step 3: 輸出 false // 你無法贏\nEnd // 程式結束\n\nBut we must ensure we use proper formatting. For decisions we use \"Decision:\" and Yes/No arrows.\n\nAlso we need to output each line as described. Should include \"Start\", \"End\". The virtual code lines may contain colon. Should use arrow \"→\" before step lines. For decision: use \"Decision:\". Use Yes → and No → lines.\n\nThus final output: 5 lines? Start, Step1, Decision, Yes branch, No branch, End. Actually lines: Start, Step1, Decision, Yes branch, No branch, End. 6 lines.\n\nMake sure each line has \" // \" explanation. Ensure no actual code, just virtual steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 取得 n // 從輸入取得石子數  \n→ Decision: n % 4 != 0? // 判斷 n 是否為 4 的倍數  \n Yes → Step 2: 輸出 true // 你能贏  \n No  → Step 3: 輸出 false // 你無法贏  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取第一個整數（n）\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n\n    # 判斷是否能贏\n    can_win = n % 4 != 0\n\n    # 輸出小寫字串 'true' 或 'false'\n    print(str(can_win).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode263.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number",
    "description_snippet": "An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.\n\nGiv...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Use Start, Decision, etc. Should handle n > 0. Ugly number if divisible only by 2,3,5. Approach: while n divisible by 2,3,5 divide. Finally if n==1 true else false.\n\nEdge case n<=0 false. Also handle 1? 1 is ugly.\n\nImplement Steps:\n\nStart // program start\n→ Step 1: Input integer n // get number\n→ Decision: 如果 n <= 0? // non-positive not ugly\n    Yes → Step 2: Return False // not ugly\n    No  → Step 3: While n divisible by 2? // loop to divide by 2\n        Yes → n = n / 2 // remove factor\n        No  → Decision: n divisible by 3?\n            Yes → n = n / 3 // remove\n            No  → Decision: n divisible by 5?\n                Yes → n = n / 5 // remove\n                No  → Exit loop? Actually need to repeat until no divisors. Could use outer loop.\n\nSimpler: Use while loop:\n\n→ Decision: n > 1? // need to loop\n    Yes → Decision: n divisible by 2? // if yes divide\n        Yes → n = n / 2 → Repeat outer loop\n        No → Decision: n divisible by 3?\n            Yes → n = n / 3 → Repeat outer loop\n            No → Decision: n divisible by 5?\n                Yes → n = n / 5 → Repeat outer loop\n                No → Break loop // no more divisions\n    No → // loop done\n\nAfter loop: Decision: n == 1? // if equals 1 return true else false.\n\nWe can write in pseudocode steps: use Step labels.\n\nLet's construct.\n\nStart\n→ Input n\n→ Decision: n <= 0?\n    Yes → Return False\n    No  → Step 4: While n > 1:\n        → Decision: n mod 2 == 0?\n            Yes → n = n / 2 → Continue loop\n            No → Decision: n mod 3 == 0?\n                Yes → n = n / 3 → Continue loop\n                No → Decision: n mod 5 == 0?\n                    Yes → n = n / 5 → Continue loop\n                    No → Exit loop\n    → Decision: n == 1?\n        Yes → Return True\n        No  → Return False\nEnd\n\nWe need to output each line with explanation. Use arrows as per format. Provide virtual code step. Let's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 從使用者處取得正整數\n→ Decision: n <= 0? // 檢查是否為非正數\n    Yes → Step 2: 返回 False // 非正數不是丑數\n    No  → Step 3: 開始除以 2、3、5 的循環 // 清除 2、3、5 以外的因子\n→ Decision: n > 1? // 如果還有大於 1 的因子，繼續循環\n    Yes → Decision: n mod 2 == 0? // 先檢查是否能被 2 整除\n        Yes → n = n / 2 // 去除一個 2\n        No  → Decision: n mod 3 == 0? // 再檢查 3\n            Yes → n = n / 3 // 去除一個 3\n            No  → Decision: n mod 5 == 0? // 最後檢查 5\n                Yes → n = n / 5 // 去除一個 5\n                No  → 退出循環 // 無法再除，結束\n    No  → // n 已經縮減到 1 或 0，循環結束\n→ Decision: n == 1? // 最終檢查是否所有因子都被去除\n    Yes → Step 4: 返回 True // 丑數\n    No  → Step 5: 返回 False // 否則不是丑數\nEnd // 程式執行結束\n\nBut we need line by line with arrow. Should maintain the structure: Step numbers, Decision etc. Use indentation for nested decisions.\n\nMake sure each line ends with // explanation. For nested, we still have line starting with appropriate arrow and text.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者處取得正整數  \n→ Decision: n <= 0? // 檢查是否為非正數  \n  Yes → Step 2: 返回 False // 非正數不是丑數  \n  No  → Step 3: 開始除以 2、3、5 的循環 // 清除 2、3、5 以外的因子  \n→ Decision: n > 1? // 若 n 大於 1，仍需進行除法循環  \n  Yes → Decision: n mod 2 == 0? // 先檢查是否能被 2 整除  \n    Yes → n = n / 2 // 去除一個 2  \n    No  → Decision: n mod 3 == 0? // 再檢查 3  \n      Yes → n = n / 3 // 去除一個 3  \n      No  → Decision: n mod 5 == 0? // 最後檢查 5  \n        Yes → n = n / 5 // 去除一個 5  \n        No  → 退出循環 // 無法再除，結束循環  \n  No  → // n 已經縮減到 1，循環結束  \n→ Decision: n == 1? // 最終檢查是否所有因子都被去除  \n  Yes → Step 4: 返回 True // 是丑數  \n  No  → Step 5: 返回 False // 否則不是丑數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isUgly(self, n: int) -> bool:\n        \"\"\"Return True if n is an ugly number (only prime factors 2, 3, 5).\"\"\"\n        if n <= 0:\n            return False\n        for p in (2, 3, 5):\n            while n % p == 0:\n                n //= p\n        return n == 1\n\ndef main() -> None:\n    \"\"\"Read input, determine if the number is ugly, and print result.\"\"\"\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the first integer found in the input\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        # No integer found; treat as invalid input\n        print(\"false\")\n        return\n    n = int(match.group())\n\n    sol = Solution()\n    result = sol.isUgly(n)\n    # Output in lowercase as specified\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode78.json",
    "problem_index_in_file": 0,
    "title": "Subsets",
    "description_snippet": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for generating all subsets of a set of unique elements. Use virtual code with arrow. Provide step-by-step, with decisions, recursion or iterative. Provide explanation after each line.\n\nLet's design a DFS/backtracking approach. Steps:\n\nStart\n→ Step 1: Input nums // array of unique integers\n→ Step 2: Initialize result as empty list // store subsets\n→ Step 3: Define function backtrack(start, current) // recursive\n    → Step 3a: Append copy of current to result // add subset\n    → Step 3b: For i from start to len(nums)-1\n        → Decision: If i within bounds\n            Yes → Step 3b1: Append nums[i] to current // include element\n            Yes → Step 3b2: backtrack(i+1, current) // recurse\n            Yes → Step 3b3: Remove last from current // backtrack\n→ Step 4: Call backtrack(0, []) // start recursion\n→ Step 5: Return result // output subsets\n\nWe need arrow formatting exactly. Each line: \"虛擬碼步驟 // 解釋\". Use arrows as described.\n\nLet's produce.\n\nAlso, include Start, End.\n\nLet's craft.\n\nUse indentation? The example shows indentation with spaces and new lines for Decision and Yes/No lines. We'll use similar.\n\nWe'll show \"Step 1:\", \"Step 2:\" etc.\n\nWe need to include the Decision step lines. In this design, the Decision for loop boundaries may be omitted or can just use the for loop.\n\nBetter to show Decision: 是否超出界限? But not necessary.\n\nWe'll show:\n\nStart // 程式開始執行\n→ Step 1: nums ← Input() // 取得唯一元素整數陣列\n→ Step 2: result ← [] // 儲存所有子集\n→ Step 3: Define backtrack(start, current) // 遞迴函式\n    → Step 3a: result.append(copy(current)) // 加入目前子集\n    → Step 3b: For i from start to len(nums)-1\n        → Decision: i < len(nums) ?\n            Yes → Step 3b1: current.append(nums[i]) // 加入元素\n            Yes → Step 3b2: backtrack(i+1, current) // 繼續遞迴\n            Yes → Step 3b3: current.pop() // 移除元素回溯\n→ Step 4: backtrack(0, []) // 開始遞迴\n→ Step 5: Return result // 回傳所有子集\nEnd // 程式執行結束\n\nNeed to ensure \"→\" at beginning of each line. Indentation within function maybe spaces, but each line starts with \"→\" for top-level. For nested, we can indent with spaces before \"→\". The example uses spaces before arrows. We'll mimic.\n\nUse \"→\" preceded by 4 spaces for nested lines. Eg \"    →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← Input() // 取得唯一元素整數陣列  \n→ Step 2: result ← [] // 儲存所有子集  \n→ Step 3: Define backtrack(start, current) // 遞迴函式  \n    → Step 3a: result.append(copy(current)) // 加入目前子集  \n    → Step 3b: For i from start to len(nums)-1  \n        → Decision: i < len(nums) ?  \n            Yes → Step 3b1: current.append(nums[i]) // 加入元素  \n            Yes → Step 3b2: backtrack(i+1, current) // 繼續遞迴  \n            Yes → Step 3b3: current.pop() // 移除元素回溯  \n→ Step 4: backtrack(0, []) // 開始遞迴  \n→ Step 5: Return result // 回傳所有子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            # 加入目前子集\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                # 包含 nums[i]\n                path.append(nums[i])\n                # 進一步遞迴\n                backtrack(i + 1, path)\n                # 回溯，移除最後加入的元素\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，移除換行、空白\n    data = sys.stdin.read().strip()\n    # 從輸入中提取列表字串\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums = eval(match.group(0))\n    else:\n        nums = []\n\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode423.json",
    "problem_index_in_file": 0,
    "title": "Reconstruct Original Digits from English",
    "description_snippet": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo code that solves: Given a string s that contains scrambled English words for digits 0-9, reconstruct digits in ascending order. This is the LeetCode problem 423. Approach: Count letters, identify unique letters for digits: 'Z' -> 0, 'W' -> 2, 'U' -> 4, 'X' -> 6, 'G' -> 8, 'O' -> 1 (after 0,2,4), 'H' -> 3 (after 8), 'F' -> 5 (after 4), 'S' -> 7 (after 6), 'I' -> 9 (after 5,6,8). So algorithm: Count frequency of each letter in s. For each digit in order of unique letters: determine count, subtract letters of that digit word times count. Append digit count times to result. Then finally sort digits ascending or produce in ascending numeric order: We can simply append in order 0-9 according to count. So pseudo-code.\n\nNeed to output line-by-line virtual code, each line with comment. Use Start, End, Decision, arrows. Let's produce pseudo-code: Start -> Step: Count letters. Then for each digit unique letter in specific order: process. We'll use Decision steps for each. We need to handle subtraction.\n\nLet's design steps:\n\nStart // begin\n→ Step 1: Initialize letterCount[26] ← 0 // count letters\n→ Step 2: For each char c in s: letterCount[c - 'A'] ← letterCount[c - 'A'] + 1 // count\n→ Step 3: Initialize result[10] ← 0 // digit counts\n\nNow for each unique mapping: sequence array: [('Z',0,'ZERO'), ('W',2,'TWO'), ('U',4,'FOUR'), ('X',6,'SIX'), ('G',8,'EIGHT'), ('O',1,'ONE'), ('H',3,'THREE'), ('F',5,'FIVE'), ('S',7,'SEVEN'), ('I',9,'NINE')]\n\nWe can loop: For each pair uniqueChar, digit, word: \n    count ← letterCount[uniqueChar] \n    if count > 0: \n        result[digit] ← count \n        For each letter in word: letterCount[letter] ← letterCount[letter] - count\n\nThus we can implement as steps.\n\nThen output ascending: \n→ Step 4: Initialize outputString ← \"\" \n→ Decision: For digit 0 to 9? \n    Yes → Step 5: Append digit repeated result[digit] times to outputString \n→ End // finish\n\nLet's write pseudo code lines with decision loops.\n\nWe must provide each line as \"虛擬碼步驟 // 解釋\". Use arrow.\n\nWill produce something like:\n\nStart // 程式開始執行\n→ Step 1: Initialize letterCount[26] ← 0 // 建立 26 個字母計數器\n→ Step 2: For each char c in s: letterCount[c - 'A'] ← letterCount[c - 'A'] + 1 // 對輸入字串進行字母頻率統計\n→ Step 3: Initialize digitCount[10] ← 0 // 建立 10 個數字計數器\n→ Step 4: Define uniqueMapping ← [( 'Z', 0, \"ZERO\"), ('W', 2, \"TWO\"), ('U',4,\"FOUR\"), ('X',6,\"SIX\"), ('G',8,\"EIGHT\"), ('O',1,\"ONE\"), ('H',3,\"THREE\"), ('F',5,\"FIVE\"), ('S',7,\"SEVEN\"), ('I',9,\"NINE\")] // 唯一字母對應數字與單詞\n→ Step 5: For each (uni, num, word) in uniqueMapping:\n        // 依序處理唯一字母\n        count ← letterCount[uni - 'A'] // 取得該唯一字母出現的次數\n        if count > 0:\n            digitCount[num] ← count // 記錄數字出現次數\n            For each letter l in word:\n                letterCount[l - 'A'] ← letterCount[l - 'A'] - count // 減去已消耗的字母\n→ Step 6: Initialize resultStr ← \"\" // 建立結果字串\n→ Decision: For digit from 0 to 9? // 依序將每個數字加入結果\n    Yes → Step 7: Append digit repeated digitCount[digit] times to resultStr // 將數字重複追加\n    No  → (skip)\n→ End // 程式結束\n\nBut we need to keep the style: Use arrows for decision branches: \"Yes → ...\". We may use nested decisions for each digit. But easier: Use a loop but pseudo code style: \"→ Decision: 是否完成 10 個數字?\". Let's just implement a loop. Use \"Decision: 是否已經處理完 10 個數字?\" but we can just use a loop as part of pseudo code: \"→ For digit 0 to 9: Append\".\n\nBut instructions: \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\" So we should incorporate Decision for loops. We can show Decision: for each digit in 0..9? But we can also just show for loop line.\n\nLet's create pseudo code lines as:\n\nStart // 程式開始執行\n→ Step 1: Initialize letterCount[26] ← 0 // 建立 26 個字母計數器\n→ Step 2: For each char c in s: letterCount[c - 'A'] ← letterCount[c - 'A'] + 1 // 計算每個字母的出現頻率\n→ Step 3: Initialize digitCount[10] ← 0 // 建立 10 個數字計數器\n→ Step 4: Define uniqueList ← [ ('Z',0,\"ZERO\"), ('W',2,\"TWO\"), ('U',4,\"FOUR\"), ('X',6,\"SIX\"), ('G',8,\"EIGHT\"), ('O',1,\"ONE\"), ('H',3,\"THREE\"), ('F',5,\"FIVE\"), ('S',7,\"SEVEN\"), ('I',9,\"NINE\") ] // 唯一字母映射\n→ Step 5: For each (uni, num, word) in uniqueList:\n        // 處理每一個唯一字母對應的數字\n        count ← letterCount[uni - 'A'] // 取得該字母的計數\n        if count > 0:\n            digitCount[num] ← count // 記錄該數字的出現次數\n            For each letter l in word:\n                letterCount[l - 'A'] ← letterCount[l - 'A'] - count // 減去已消耗的字母\n→ Step 6: Initialize resultStr ← \"\" // 結果字串\n→ Decision: 是否已處理完 10 個數字? // 檢查是否已完成 0~9 的累加\n    No  → For digit from 0 to 9:\n            Append digit repeated digitCount[digit] times to resultStr\n→ End // 程式結束\n\nBut better: Use a loop with Decision for each digit: \"Decision: 是否還有未處理的數字?\" But it's okay.\n\nWe need each line must include \"虛擬碼步驟\" + space + comment. So we need to maintain one line per step. In loops we might combine loops into a single step line? For clarity we can keep loops inside the step. But we might need multiple lines for loops and decisions.\n\nSimpler: Use following lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化字母計數器 letterCount[26] ← 0 // 先建 26 個字母的計數器\n→ Step 2: 對 s 中每個字元 c 做一次迴圈: letterCount[c-'A'] ← letterCount[c-'A'] + 1 // 統計字母頻率\n→ Step 3: 初始化數字計數器 digitCount[10] ← 0 // 先建 10 個數字的計數器\n→ Step 4: 定義唯一字母映射 uniqueList ← [ ('Z',0,\"ZERO\"), ('W',2,\"TWO\"), ('U',4,\"FOUR\"), ('X',6,\"SIX\"), ('G',8,\"EIGHT\"), ('O',1,\"ONE\"), ('H',3,\"THREE\"), ('F',5,\"FIVE\"), ('S',7,\"SEVEN\"), ('I',9,\"NINE\") ] // 唯一字母到數字的對應\n→ Step 5: 對 uniqueList 中每一項 (uni, num, word) 做一次迴圈:\n        // 逐個處理唯一字母\n        count ← letterCount[uni-'A'] // 取得唯一字母的計數\n        if count > 0:\n            digitCount[num] ← count // 記錄該數字出現的次數\n            對 word 中每個字元 l 做一次迴圈:\n                letterCount[l-'A'] ← letterCount[l-'A'] - count // 把已用掉的字母減少\n→ Step 6: 初始化 resultStr ← \"\" // 用來存放最終的數字字串\n→ Step 7: 從 0 到 9 做一次迴圈:\n        // 依次把每個數字按出現次數追加到結果字串\n        Append digitCount[digit] 次的 digit 轉成字元到 resultStr\n→ End // 程式結束\n\nWe need arrow lines with Decision maybe not necessary but we can keep them simple.\n\nBut the instruction: Use \"Decision:\" for decisions. So we should add Decision lines for if statements: For each count>0 etc.\n\nLet's produce step 5 with decisions:\n\n→ Step 5: For each (uni, num, word) in uniqueList:\n        // 逐項處理唯一字母\n        count ← letterCount[uni-'A']\n        Decision: count > 0? // 是否該數字存在?\n            Yes → digitCount[num] ← count\n                For each l in word:\n                    letterCount[l-'A'] ← letterCount[l-'A'] - count\n            No  → (skip)\n\nBut we need separate lines for each arrow: e.g.:\n\n→ Step 5: For each (uni, num, word) in uniqueList: // 逐項處理唯一字母\n→ Decision: count > 0? // 檢查此數字是否存在\n    Yes → digitCount[num] ← count // 記錄數字次數\n        For each l in word:\n            letterCount[l-'A'] ← letterCount[l-'A'] - count // 消耗字母\n    No  → // 什麼也不做\n\nBut the pseudo code might not support nested loops inside a step. We can break into multiple steps.\n\nLet's produce more detailed lines:\n\nStart // 程式開始執行\n→ Step 1: Initialize letterCount[26] ← 0 // 建立 26 個字母計數器\n→ Step 2: For each char c in s: letterCount[c-'A'] ← letterCount[c-'A'] + 1 // 統計字母頻率\n→ Step 3: Initialize digitCount[10] ← 0 // 建立 10 個數字計數器\n→ Step 4: Define uniqueList ← [ ('Z',0,\"ZERO\"), ('W',2,\"TWO\"), ('U',4,\"FOUR\"), ('X',6,\"SIX\"), ('G',8,\"EIGHT\"), ('O',1,\"ONE\"), ('H',3,\"THREE\"), ('F',5,\"FIVE\"), ('S',7,\"SEVEN\"), ('I',9,\"NINE\") ] // 唯一字母映射\n→ Step 5: For each item in uniqueList:\n        // 逐項處理\n        → Step 5.1: Extract uni, num, word\n        → Step 5.2: count ← letterCount[uni-'A'] // 取得唯一字母的數量\n        → Decision: count > 0? // 是否存在該數字？\n            Yes → Step 5.3: digitCount[num] ← count // 記錄次數\n                → Step 5.4: For each l in word:\n                    letterCount[l-'A'] ← letterCount[l-'A'] - count // 消耗字母\n            No  → // 無需處理\n→ Step 6: Initialize resultStr ← \"\" // 結果字串\n→ Step 7: For digit from 0 to 9:\n        // 依序追加\n        → Step 7.1: repeatCount ← digitCount[digit]\n        → Step 7.2: Append repeatCount 次的 digit 到 resultStr\n→ End // 程式結束\n\nThis satisfies each line requirement.\n\nBut we need to use arrows for each line. We need to keep lines minimal but also include arrows. Use arrow for each step: \"→ Step 1:\" etc. For decisions: \"Decision:\" lines.\n\nWe need to ensure each line is separate. Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize letterCount[26] ← 0 // 建立 26 個字母計數器  \n→ Step 2: For each char c in s: letterCount[c-'A'] ← letterCount[c-'A'] + 1 // 統計每個字母出現頻率  \n→ Step 3: Initialize digitCount[10] ← 0 // 建立 10 個數字計數器  \n→ Step 4: Define uniqueList ← [ ('Z',0,\"ZERO\"), ('W',2,\"TWO\"), ('U',4,\"FOUR\"), ('X',6,\"SIX\"), ('G',8,\"EIGHT\"), ('O',1,\"ONE\"), ('H',3,\"THREE\"), ('F',5,\"FIVE\"), ('S',7,\"SEVEN\"), ('I',9,\"NINE\") ] // 唯一字母對應的數字與單詞  \n→ Step 5: For each (uni, num, word) in uniqueList: // 逐項處理唯一字母  \n → Step 5.1: count ← letterCount[uni-'A'] // 取得該唯一字母的數量  \n → Decision: count > 0? // 判斷此數字是否存在  \n  Yes → Step 5.2: digitCount[num] ← count // 記錄此數字出現次數  \n   → Step 5.3: For each l in word: // 消耗已用字母  \n    letterCount[l-'A'] ← letterCount[l-'A'] - count // 把對應字母的計數減去  \n  No  → // 不做任何操作  \n→ Step 6: Initialize resultStr ← \"\" // 用來存放最終的數字字串  \n→ Step 7: For digit from 0 to 9: // 依序將每個數字加入結果  \n → Step 7.1: repeatCount ← digitCount[digit] // 取得該數字的出現次數  \n → Step 7.2: Append repeatCount 次的 digit 轉成字元到 resultStr // 追加到結果字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        count = Counter(s)\n        out = {}\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n        return ''.join(k * out[k] for k in sorted(out.keys()))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the string after an optional \"s = \" and remove surrounding quotes\n    if '=' in data:\n        _, data = data.split('=', 1)\n        data = data.strip()\n    data = data.strip('\"').strip(\"'\")\n    s = data\n    solution = Solution()\n    result = solution.originalDigits(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "success": true,
          "output": "012"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "success": true,
          "output": "45"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode479.json",
    "problem_index_in_file": 0,
    "title": "Largest Palindrome Product",
    "description_snippet": "Given an integer n, return the largest palindromic integer that can be represented as the product of...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for the problem: largest palindrome product of two n-digit numbers, modulo 1337. This is classic Leetcode 872: largest palindrome product. Approach: iterate a from high to low; for each a, compute b = int(sqrt(p)) where p = a*a ... but typical solution: iterate a from max to min, and b from a to min, compute product, check palindrome. But better: iterate a from max to min, for each a, iterate b from a to min, but we want largest palindrome. But we can generate palindrome candidates by constructing palindrome from a and b? Actually known solution: iterate a from high to low, b from a to low; compute product; if product < current_max break; else check palindrome. Complexity O(n^2). For n-digit numbers, max = 10^n-1, min = 10^(n-1). Since n up to 4? Actually constraints n <= 4. So fine.\n\nWe need to produce virtual code step by step. Use Start, Decision, etc.\n\nWe need to include each step: define max, min, result, loop a, inner loop b, compute product, check if product <= result? Actually we want largest palindrome. We can keep result. When product < result, break inner loop because as b decreases product decreases. Then check palindrome function. If palindrome and product > result set result.\n\nAfter loops, return result % 1337.\n\nAlso need palindrome check: convert to string and compare with reversed.\n\nWe must not output actual code, just virtual steps.\n\nWe need to incorporate loops, decisions, variable assignments.\n\nAlso we need to note that loops over a and b descending.\n\nWe should output each line with comment.\n\nUse arrow: →.\n\nNeed to indent decisions appropriately.\n\nLet's produce.\n\nWe will structure as:\n\nStart\n→ Set max = 10^n - 1 // highest n-digit\n→ Set min = 10^(n-1) // lowest n-digit\n→ Set result = 0 // current largest palindrome\n→ Decision: For a from max downto min? Use loop\nBut we need step: For a from max downto min:\n→ Step: For a = max; a >= min; a--\n    -> Step: For b = a; b >= min; b--\n        -> Step: Set product = a * b\n        -> Decision: If product <= result? If yes, break inner loop? Actually if product <= result, break inner loop because further b will produce smaller product.\nBut we need to break when product <= result? But product may be bigger but still less than current max. Actually if product <= result, we cannot find larger palindrome with this a, so break inner loop.\n→ Decision: If product <= result? // Check if cannot beat current max\n    Yes → Step: Break inner loop // Since b decreasing\n    No  → Step: Decision: Is product palindrome? // Check palindrome\n        Yes → Step: If product > result? // Only if larger\n            → Step: Set result = product\n        No  → Step: Continue loop\nAfter loops, End\n→ Step: Return result % 1337\n\nNeed to add palindrome function:\n\nWe can define a function IsPalindrome(x):\n→ Step: Convert x to string s\n→ Step: Set rev = reverse(s)\n→ Decision: s == rev?\n    Yes → Step: Return True\n    No  → Step: Return False\n\nWe need to integrate this.\n\nBut as virtual code we can call IsPalindrome(product) inside decision.\n\nWe can include function definition earlier.\n\nSo final output lines will include function definition and main.\n\nMake sure each line has comment. Use proper indentation with arrow.\n\nLet's produce lines.\n\nAlso need to consider we cannot use actual code, just pseudo. So we can include function definitions.\n\nWe should not output anything else.\n\nWe need to ensure each line ends with comment.\n\nWe must not output actual code, just virtual steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 IsPalindrome(x) // 檢查整數是否為回文  \n→     Step 1.1: 將 x 轉成字串 s // 取得整數字串表示  \n→     Step 1.2: 取 s 的反轉字串 rev // 取得逆序字串  \n→     Decision: s 與 rev 是否相等? // 判斷是否為回文  \n→         Yes → Step 1.3: 回傳 True // 是回文  \n→         No  → Step 1.4: 回傳 False // 不是回文  \n\n→ Step 2: 計算最大 n 位數 max = 10^n - 1 // 最高 n 位數  \n→ Step 3: 計算最小 n 位數 min = 10^(n-1) // 最低 n 位數  \n→ Step 4: 設置變數 result = 0 // 儲存目前找到的最大回文  \n\n→ Step 5: Decision: a 從 max 迴圈到 min? // 外層循環  \n→     Yes → For a = max downto min  \n→         Step 5.1: Decision: b 從 a 迴圈到 min? // 內層循環  \n→             Yes → For b = a downto min  \n→                 Step 5.1.1: 計算 product = a * b // 乘積  \n→                 Decision: product <= result? // 能否比目前最大更大？  \n→                     Yes → Step 5.1.2: Break inner loop // 無法再尋找更大，跳出  \n→                     No  → Decision: IsPalindrome(product)? // 判斷回文  \n→                         Yes → Decision: product > result? // 是否為新的最大？  \n→                             Yes → Step 5.1.3: 設置 result = product // 更新最大  \n→                             No  → Step 5.1.4: 繼續迴圈 // 跳過此乘積  \n→                         No  → Step 5.1.5: 繼續迴圈 // 不是回文，忽略  \n→             No  → Step 5.2: 繼續外層循環 // 內層結束  \n→     No  → Step 5.3: 結束所有迴圈  \n\n→ Step 6: 回傳 result mod 1337 // 將結果取模後輸出  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def largestPalindrome(self, n: int) -> int:\n        \"\"\"\n        Return the largest palindromic integer that can be represented\n        as the product of two n‑digit integers, modulo 1337.\n        For n == 1 the answer is 9.\n        For n > 1 we use pre‑computed values that are already reduced modulo 1337.\n        \"\"\"\n        if n == 1:\n            return 9\n        # Pre‑computed results for n = 2..8 (modulo 1337)\n        precomputed = [0, 9, 987, 123, 597, 677, 1218, 877, 475]\n        return precomputed[n]\n\n\ndef main() -> None:\n    \"\"\"\n    Reads an integer n from standard input, computes the answer\n    using the Solution class, and prints the result to standard output.\n    \"\"\"\n    import sys\n    import re\n\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the first integer from the input (handles inputs like \"n = 2\")\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    sol = Solution()\n    result = sol.largestPalindrome(n)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "987",
          "success": true,
          "output": "987"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2410.json",
    "problem_index_in_file": 0,
    "title": "Maximum Matching of Players With Trainers",
    "description_snippet": "You are given a 0-indexed integer array players, where players[i] represents the ability of the i^th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code to solve the problem: maximum matching between players ability and trainers capacity. It's essentially find maximum cardinality matching in bipartite graph where edges exist if ability <= capacity. This can be solved by greedy sorting: sort both arrays, then use two pointers to match smallest ability with smallest capacity that can accommodate. Equivalent to maximize matches.\n\nSo algorithm: sort players ascending, sort trainers ascending. i=0, j=0, count=0. While i<n and j<m: if players[i] <= trainers[j]: count++; i++; j++; else: j++; // trainer too weak, skip.\n\nReturn count.\n\nNow produce virtual code lines with explanation.\n\nWe should also start with Start, End. Use virtual arrows.\n\nWe must use `虛擬碼步驟 // 解釋/說明` format. Provide each line. Provide arrows.\n\nWe need to include decision steps.\n\nLet's craft:\n\nStart\n→ Step 1: Sort players ascending // 對玩家能力進行升序排序\n→ Step 2: Sort trainers ascending // 對教練訓練容量進行升序排序\n→ Step 3: Initialize i = 0, j = 0, matches = 0 // 索引與匹配計數\n→ Decision: i < len(players) AND j < len(trainers)? // 是否還有未處理的玩家或教練\n    Yes → Decision: players[i] <= trainers[j]? // 玩家是否能被此教練匹配\n        Yes → Step 4: matches += 1 // 成功匹配\n              → Step 5: i += 1 // 移到下一個玩家\n              → Step 6: j += 1 // 移到下一個教練\n        No  → Step 7: j += 1 // 這名教練無法匹配，嘗試下一名教練\n    No  → Step 8: Return matches // 所有可能匹配已完成\nEnd\n\nCheck format: each line `虛擬碼步驟 // 解釋`. The decisions lines should include arrow and indentation. Use `Decision:` lines as shown.\n\nLet's ensure arrow formatting: \"Decision:\" lines have arrow? In example: `Decision: 如果數字大於 0?` then `Yes →`. So we do same.\n\nLine numbers not needed.\n\nAlso need to indicate `Start` and `End`.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort players ascending // 對玩家能力進行升序排序  \n→ Step 2: Sort trainers ascending // 對教練訓練容量進行升序排序  \n→ Step 3: Initialize i = 0, j = 0, matches = 0 // 索引與匹配計數  \n→ Decision: i < len(players) AND j < len(trainers)? // 是否還有未處理的玩家或教練  \n  Yes → Decision: players[i] <= trainers[j]? // 玩家是否能被此教練匹配  \n   Yes → Step 4: matches += 1 // 成功匹配  \n    → Step 5: i += 1 // 移到下一個玩家  \n    → Step 6: j += 1 // 移到下一個教練  \n   No → Step 7: j += 1 // 這名教練無法匹配，嘗試下一名教練  \n  No → Step 8: Return matches // 所有可能匹配已完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef max_match(players, trainers):\n    \"\"\"Return the maximum number of valid player–trainer matchings.\"\"\"\n    players.sort()\n    trainers.sort()\n    i = j = matches = 0\n    while i < len(players) and j < len(trainers):\n        if players[i] <= trainers[j]:\n            matches += 1\n            i += 1\n        j += 1\n    return matches\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract the two lists from input like:\n    'players = [4,7,9], trainers = [8,2,5,8]'\n    \"\"\"\n    pattern = r'players\\s*=\\s*(\\[.*?\\])\\s*,\\s*trainers\\s*=\\s*(\\[.*?\\])'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        # Fallback: try to read two separate list literals on each line\n        lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            return ast.literal_eval(lines[0]), ast.literal_eval(lines[1])\n        raise ValueError(\"Input format not recognized.\")\n    players_str, trainers_str = match.group(1), match.group(2)\n    return ast.literal_eval(players_str), ast.literal_eval(trainers_str)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    players, trainers = parse_input(raw_input)\n    result = max_match(players, trainers)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "players = [4,7,9], trainers = [8,2,5,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "players = [1,1,1], trainers = [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode704.json",
    "problem_index_in_file": 0,
    "title": "Binary Search",
    "description_snippet": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search. Output each line with \"虛擬碼步驟 // 解釋\". Must include arrows, Start, End, Decision. Use Chinese. No actual code. Let's produce.\n\nStructure: Start, Step 1: 初始化 low, high. Step 2: while low <= high. Decision: mid = (low+high)//2. Then check nums[mid] == target. If yes return mid. Else if nums[mid] < target: low=mid+1. Else high=mid-1. After loop return -1. End.\n\nNeed each line with arrow? The format example uses \"→ Step 1:\" lines. We need to indent decisions. Use spaces. Let's produce.\n\nAlso mention O(log n) runtime.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 low = 0 // 初始化最左邊索引  \n→ Step 2: 設定 high = nums.length - 1 // 初始化最右邊索引  \n→ Decision: 若 low ≤ high? // 只要搜尋範圍還有元素  \n Yes → Step 3: 計算 mid = (low + high) // 2 // 取得中間索引  \n  → Decision: 若 nums[mid] = target? // 中間值是否為目標  \n   Yes → Step 4: 回傳 mid // 找到目標，返回其索引  \n   No → Decision: 若 nums[mid] < target? // 目標在右半邊？  \n    Yes → Step 5: 設定 low = mid + 1 // 移動左指標至右邊  \n    No → Step 6: 設定 high = mid - 1 // 移動右指標至左邊  \n No → Step 7: 回傳 -1 // 搜尋範圍已無元素，目標不存在  \nEnd // 程式執行結束，完成 O(log n) 時間複雜度的搜尋流程",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析出 nums 列表和 target 整數。\"\"\"\n    # 找出第一個中括號內的數字序列\n    list_match = re.search(r'\\[.*?\\]', data)\n    if not list_match:\n        return [], None\n    nums = ast.literal_eval(list_match.group())\n    # 找出 target = 之後的整數\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    target = int(target_match.group(1)) if target_match else None\n    return nums, target\n\ndef main():\n    data = sys.stdin.read()\n    nums, target = parse_input(data)\n    if target is None:\n        print(-1)\n        return\n    sol = Solution()\n    result = sol.search(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode724.json",
    "problem_index_in_file": 0,
    "title": "Find Pivot Index",
    "description_snippet": "Given an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. Problem: find pivot index. Steps: compute total sum, iterate, track left sum, check equality. Output leftmost index or -1. Provide virtual code lines with comments. Use arrow, Decision, Start, End. Must be in Traditional Chinese. Let's write.\n\nPossible steps:\n\nStart\n→ Step 1: Compute totalSum = sum(nums)\n→ Step 2: leftSum = 0\n→ Step 3: For index i from 0 to len(nums)-1\n   → Step 4: rightSum = totalSum - leftSum - nums[i]\n   → Decision: If leftSum == rightSum?\n        Yes → Step 5: Return i // pivot found\n        No → Step 6: leftSum += nums[i] // move to next index\n→ Step 7: Return -1 // no pivot found\nEnd\n\nWe must incorporate the loop structure with decision. Use Decision inside loop. Might use loop structure with Decision. Use proper arrow.\n\nWe should use \"→\" for each step, indent for substeps. Use \"Decision:\" with Yes and No arrows. Ensure each line has \"虛擬碼步驟 // 解釋\". Provide line number? Not necessary. Just each line.\n\nLet's produce.\n\nMake sure to use \"Start\" \"End\" etc.\n\nWe'll use \"Step 1: ...\" etc.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 totalSum = 所有 nums 元素的總和 // 先求整體總和  \n→ Step 2: 設定 leftSum = 0 // 左側已累積的和，起始為 0  \n→ Step 3: For i 從 0 到 nums.length-1 做  \n  → Step 4: 計算 rightSum = totalSum - leftSum - nums[i] // 右側總和  \n  → Decision: leftSum 是否等於 rightSum? // 判斷當前索引是否為 pivot  \n   Yes → Step 5: Return i // 找到最左側的 pivot，直接回傳  \n   No  → Step 6: leftSum += nums[i] // 累加目前元素，移動至下一個索引  \n→ Step 7: Return -1 // 沒有任何索引滿足條件，回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def pivotIndex(self, nums):\n        total = sum(nums)\n        left_sum = 0\n        for i, num in enumerate(nums):\n            if left_sum == total - left_sum - num:\n                return i\n            left_sum += num\n        return -1\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 若輸入包含 'nums =', 取等號後面部分\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data\n    # 將字串轉成 Python list\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 如果轉換失敗，輸出 -1\n        print(-1)\n        return\n    if not isinstance(nums, list):\n        print(-1)\n        return\n    sol = Solution()\n    result = sol.pivotIndex(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,3,6,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode761.json",
    "problem_index_in_file": 0,
    "title": "Special Binary String",
    "description_snippet": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm. Provide each line with arrow and explanation. The problem: given a special binary string s, we can swap any two consecutive non-empty special substrings. We need lexicographically largest resulting string after operations. Known solution: recursion: find max lexicographic by splitting into maximal special substrings and sorting them descending lexicographically.\n\nAlgorithm:\n\n- function helper(s):\n    - if s empty: return\n    - split s into list of special substrings by counting balance.\n    - for each substring, recursively compute largest.\n    - sort substrings in descending lexicographic order.\n    - return concatenation.\n\nReturn helper(s). Implementation steps: define function solve(s). Use stack to split. Complexity O(n^2). Provide virtual code.\n\nLet's produce step by step. Use Start/End. Use Decision, loops. Ensure each line has explanation.\n\nLet's write.\n\nWe'll need to show: Start; Step: function solve(s); etc. Use recursion. Provide sorting.\n\nWill produce a concise but step-by-step virtual algorithm.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 solve(s) // 用來處理給定的特殊二進位字串並回傳最大字串\n→ Decision: 如果 s 為空字串? // 只需返回空值\n    Yes → Step 2: 回傳 \"\" // 空字串不需要處理\n    No  → Step 3: 建立空清單 parts // 用來存放拆分出的特殊子字串\n→ Step 4: 設定 balance ← 0 // 用於追蹤 1 與 0 的差值\n→ Step 5: 設定 startIdx ← 0 // 目前子字串的起始索引\n→ For i 從 0 到 s.length-1 // 逐字元遍歷\n    → Decision: s[i] 是否為 '1'? // 更新 balance\n        Yes → Step 6: balance ← balance + 1 // 1 的數量加 1\n        No  → Step 7: balance ← balance - 1 // 0 的數量加 1\n    → Decision: balance 是否為 0? // 找到一個完整的特殊子字串\n        Yes → Step 8: parts.add( s.substring(startIdx, i+1) ) // 加入子字串\n            → Step 9: startIdx ← i+1 // 下一個子字串的起始位置\n→ Step 10: For 每個 part in parts // 針對每個拆分出的子字串遞迴處理\n    → Step 11: part ← solve(part) // 取得該子字串的最大排列\n→ Step 12: parts.sort(按字典序降序) // 以字典序從大到小排序\n→ Step 13: 定義 result ← \"\" // 用來累加排序後的子字串\n→ For 每個 part in parts\n    → Step 14: result ← result + part // 連接到結果字串\n→ Step 15: 回傳 result // 返回此層遞迴得到的最大字串\nEnd // 程式執行結束\nStart // 主程式入口\n→ Step 1: 輸入特殊二進位字串 s // 從使用者或測試輸入取得 s\n→ Step 2: 呼叫 solve(s) 並將結果存入 ans // 取得最大的字串\n→ Step 3: 輸出 ans // 將結果顯示給使用者\nEnd // 程式結束。",
      "generated_code": "import sys\nimport re\n\ndef make_largest_special(s: str) -> str:\n    \"\"\"\n    取得給定特殊二進位字串 s 的字典序最大化結果。\n    \"\"\"\n    if not s:\n        return \"\"\n\n    parts = []            # 先把 s 拆成所有「最大」的特殊子字串\n    count = 0             # 追蹤 1 與 0 的差值\n    start = 0             # 當前子字串的起始位置\n\n    for i, c in enumerate(s):\n        if c == '1':\n            count += 1\n        else:            # c == '0'\n            count -= 1\n\n        if count == 0:   # 找到一個完整的特殊子字串\n            inner = make_largest_special(s[start + 1 : i])  # 內部再遞迴處理\n            parts.append('1' + inner + '0')\n            start = i + 1\n\n    parts.sort(reverse=True)          # 以字典序降序排序\n    return \"\".join(parts)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n\n    # 取出雙引號內的字串，如果沒有雙引號則直接使用原始輸入\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data.strip('\"')\n\n    result = make_largest_special(s)\n    # 按題目示例輸出帶雙引號的結果\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"11011000\"",
          "expected_output": "\"11100100\"",
          "success": true,
          "output": "\"11100100\""
        },
        {
          "example_index": 1,
          "input": "s = \"10\"",
          "expected_output": "\"10\"",
          "success": true,
          "output": "\"10\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode461.json",
    "problem_index_in_file": 0,
    "title": "Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining computing Hamming distance between two integers. Use steps: XOR, count bits, loop or builtin. Provide virtual steps. Format lines with \"虛擬碼步驟\" then space then comment. Use arrow notation. So Start → Step1 → Decision etc. We can do:\n\nStart\n→ Step 1: Compute xor = x XOR y // find bits that differ\n→ Step 2: Initialize count = 0 // counter for bits\n→ Decision: While xor > 0? // loop until all bits processed\n    Yes → Step 3: If xor & 1 == 1 then count++ // check least significant bit\n    Yes → Step 4: xor = xor >> 1 // shift right to next bit\n    No  → End of loop\n→ Step 5: Return count // final Hamming distance\n\nNeed to include decision branches with Yes/No arrow. Ensure each line includes // explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: xor ← x XOR y // 先計算兩數的 XOR，得到差異位元的標誌  \n→ Step 2: count ← 0 // 初始化差異位數計數器  \n→ Decision: xor > 0? // 若還有未處理的位元  \n Yes → Step 3: If xor AND 1 = 1 then count ← count + 1 // 若最低位為 1，則差異數量加一  \n Yes → Step 4: xor ← xor SHR 1 // 右移一位，處理下一個位元  \n No  → Step 5: Return count // 所有位元處理完畢，返回 Hamming 距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef hamming_distance(x: int, y: int) -> int:\n    \"\"\"計算兩個整數的 Hamming 距離\"\"\"\n    xor = x ^ y                     # 取得不同位元\n    distance = 0\n    while xor:\n        distance += xor & 1          # 若最低位是 1，計數加一\n        xor >>= 1                    # 右移處理下一位\n    return distance\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n\n    # 取出字串中的所有整數，順序為 x、y\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) < 2:\n        print(\"0\")\n    else:\n        x, y = nums[0], nums[1]\n        result = hamming_distance(x, y)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 1, y = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 3, y = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode754.json",
    "problem_index_in_file": 0,
    "title": "Reach a Number",
    "description_snippet": "You are standing at position 0 on an infinite number line. There is a destination at position target...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step explaining algorithm to compute minimum number of moves to reach target on infinite line. Classic problem: minimal steps to reach target with steps 1,2,...,k either + or -. The solution: find smallest k such that sum_{i=1}^k i >= |target| and parity matches: (sum - target) % 2 == 0. Approach: compute cumulative sum, increase k until conditions satisfied.\n\nWe'll produce virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions.\n\nLet's produce:\n\nStart\n→ Step 1: 設 targetAbs ← absolute value of target // 獲得目標距離的正值\n→ Step 2: 初始化 sum ← 0, moves ← 0 // sum 是已走步長之和，moves 是步數計數\n→ Decision: 是否達到目標? // 檢查是否已滿足條件\n    Yes → End // 完成\n    No  → Step 3: moves ← moves + 1 // 增加一步\n→ Step 4: sum ← sum + moves // 更新總步長\n→ Step 5: 是否滿足 sum >= targetAbs 且 (sum - targetAbs) % 2 == 0? // 判斷是否可到達\n    Yes → End // 確認最小步數\n    No  → 回到 Decision: 是否達到目標? // 重新檢查\nEnd\n\nBut we need to loop until condition. Maybe use while loop representation: Decision: sum < targetAbs or parity mismatch?\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: targetAbs ← abs(target) // 取得目標距離的正值\n→ Step 2: sum ← 0 // 已經累加的總步長\n→ Step 3: moves ← 0 // 已經執行的步數\n→ Decision: sum < targetAbs OR (sum - targetAbs) % 2 != 0? // 檢查是否仍需多步\n    Yes → Step 4: moves ← moves + 1 // 增加下一步數\n    → Step 5: sum ← sum + moves // 累加步長\n    → 回到 Decision // 重新判斷\n    No  → End // 找到最小步數，結束\n\nBut the arrow structure: we need to represent loops. In example, they used indentation. We'll do:\n\nStart // 程式開始執行\n→ Step 1: targetAbs ← abs(target) // 取得目標距離的正值\n→ Step 2: sum ← 0 // 初始總步長\n→ Step 3: moves ← 0 // 初始步數\n→ Decision: sum < targetAbs OR (sum - targetAbs) % 2 != 0? // 還需要再走\n    Yes → Step 4: moves ← moves + 1 // 走下一步\n    → Step 5: sum ← sum + moves // 更新總步長\n    → 回到 Decision // 再次檢查\n    No  → End // 已達到最小步數\nEnd // 程式結束\n\nBut maybe we need to show \"Repeat until\" style. Use a loop structure:\n\nStart\n→ Step 1...\n→ Loop: while (sum < targetAbs || (sum - targetAbs) % 2 != 0)\n    → Step 4...\n    → Step 5...\nEnd\n\nHowever they want \"虛擬碼步驟\" lines with arrow. Let's produce as above.\n\nWe might also include comment \"此演算法複雜度 O(√target)\" but not necessary.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: targetAbs ← abs(target) // 取得目標距離的正值  \n→ Step 2: sum ← 0 // 已累加的總步長  \n→ Step 3: moves ← 0 // 已執行的步數  \n→ Decision: sum < targetAbs OR (sum - targetAbs) % 2 != 0? // 還需要再走嗎？  \n&nbsp;&nbsp;&nbsp;Yes → Step 4: moves ← moves + 1 // 增加下一步的步長  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: sum ← sum + moves // 更新總步長  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ 回到 Decision // 再次檢查條件  \n&nbsp;&nbsp;&nbsp;No  → End // 找到最小步數，結束執行  \nEnd // 程式結束\n\n這段虛擬碼實現了從 0 開始，以步長 1,2,3,… 每一步可向左或向右走，最終到達目標位置的最小步數計算。透過累加總步長並檢查「足夠且與目標距離差為偶數」的條件，即可確定最小步數。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reachNumber(self, target: int) -> int:\n        target = abs(target)\n        step = 0\n        sum_ = 0\n        while sum_ < target or (sum_ - target) % 2 != 0:\n            step += 1\n            sum_ += step\n        return step\n\nif __name__ == \"__main__\":\n    # 讀取輸入，允許「target = 2」等格式\n    data = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', data)\n    target = int(numbers[0]) if numbers else 0\n\n    solution = Solution()\n    result = solution.reachNumber(target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "target = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode621.json",
    "problem_index_in_file": 0,
    "title": "Task Scheduler",
    "description_snippet": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CP...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for scheduling tasks with cooldown. Classic problem: given tasks array and cooldown n, find least intervals. Approach: count frequencies, find max freq, count how many tasks have that max freq, compute idle slots: (maxFreq-1)*(n+1) - sum of min(freq, maxFreq-1) etc. Or alternative: formula: max((len(tasks) - (maxFreq-1)*(n+1) - ...?). Standard solution: compute max frequency fMax, number of tasks with that frequency cntMax, idle slots = (fMax-1)*(n+1) - (len(tasks) - cntMax*fMax). The result is max(len(tasks), idleSlots + len(tasks)). Let's produce pseudocode.\n\nWe must produce line by line virtual code with arrows and comments. Provide steps: Start, Step: Count frequencies, Step: find maxFreq and count tasks with that freq, Step: compute empty slots, Step: compute available slots, Step: compute idle slots, Step: compute result, End. Provide decision maybe if idle slots negative.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個字典 freq 用來統計每個任務字母出現的次數 // 方便後續計算頻率  \n→ Step 2: 迭代 tasks，對每個字母 c： freq[c] ← freq[c] + 1 // 生成頻率表  \n→ Step 3: 取得最高頻率 maxFreq 以及具有此頻率的任務數 cntMax  \n    → Decision: 如果 freq 中有多個字母出現 maxFreq 次? // 檢查是否有多個最頻繁任務  \n        Yes → cntMax ← count of letters with freq == maxFreq // 取得最大頻率任務的個數  \n        No  → cntMax ← 1 // 只有一個最頻繁任務  \n→ Step 4: 計算空閒槽位 emptySlots = (maxFreq - 1) * (n + 1) // 每個最頻繁任務之間至少 n 個空間  \n→ Step 5: 計算已占用的槽位 occupiedSlots = len(tasks) - cntMax * maxFreq // 除掉所有最頻繁任務後剩下的任務數  \n→ Step 6: 計算需要的空閒時間 idleTime = emptySlots - occupiedSlots // 需要插入的 idle 時間  \n    → Decision: idleTime 需要負值? // 若負值表示已足夠填滿空閒槽  \n        Yes → idleTime ← 0 // 無需額外 idle 時間  \n        No  → // 保持 idleTime 原值  \n→ Step 7: 計算最小 CPU 週期總數 totalIntervals = len(tasks) + idleTime // 任務數加上必要的 idle 時間  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"計算完成所有任務所需的最少 CPU 週期數。\"\"\"\n    freq = Counter(tasks)                      # 每個任務的出現次數\n    max_freq = max(freq.values())              # 最大頻率\n    max_count = sum(1 for c in freq.values() if c == max_freq)  # 同時擁有最大頻率的任務數量\n\n    # 空閒槽位 + 已占用槽位的總數\n    intervals = (max_freq - 1) * (n + 1) + max_count\n    return max(intervals, len(tasks))          # 若無需 idle 時間則直接回傳任務總數\n\ndef parse_input(raw):\n    \"\"\"\n    從標準輸入的文字中解析 tasks 與 n。\n    支援類似 'tasks = [\"A\",\"B\"], n = 2' 的格式。\n    \"\"\"\n    raw = raw.replace('\\n', ' ')   # 去除換行，方便正則表達式匹配\n    tasks = []\n\n    # 抓取 tasks 列表\n    m = re.search(r'tasks\\s*=\\s*\\[(.*?)\\]', raw)\n    if m:\n        items = m.group(1).split(',')\n        for it in items:\n            it = it.strip()\n            if not it:\n                continue\n            # 去除前後的引號\n            if (it.startswith('\"') and it.endswith('\"')) or (it.startswith(\"'\") and it.endswith(\"'\")):\n                it = it[1:-1]\n            tasks.append(it)\n\n    # 抓取 n 的值\n    m = re.search(r'n\\s*=\\s*(-?\\d+)', raw)\n    n = int(m.group(1)) if m else 0\n\n    return tasks, n\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    tasks, n = parse_input(data)\n    print(least_interval(tasks, n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode355.json",
    "problem_index_in_file": 0,
    "title": "Design Twitter",
    "description_snippet": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. It's design of simplified Twitter. The virtual code must describe class initialization, data structures, and each method. Probably like:\n\nStart\n\n→ Step: 初始化 Twitter // 初始化数据结构\n\n→ Step: postTweet // add tweet\n\n→ Step: getNewsFeed // retrieve 10\n\n→ Step: follow\n\n→ Step: unfollow\n\nUse arrows and Decision blocks where needed.\n\nWe need step-by-step process. Should be a conceptual algorithm.\n\nWe'll produce a virtual code with steps:\n\nStart\n→ Step 1: 建立 Twitter 類別並初始化資料結構\n→ Step 2: 定義 followees map: userId -> set of followees\n→ Step 3: 定義 tweets list: list of (userId, tweetId, timestamp)\n→ Step 4: 定義 timestamp counter\n\nMethods:\n\npostTweet: \n→ Step 5: 新增 tweet 進 tweets 列表並遞增 timestamp\n\ngetNewsFeed:\n→ Step 6: 取得 target user 的 followees + 自己\n→ Step 7: 逆序遍歷 tweets，收集前 10 tweetId 只要屬於上述集合\n→ Step 8: 返回結果\n\nfollow:\n→ Step 9: 若未在 followees map 則建立\n→ Step 10: 將 followeeId 加入 followerId 的 set\n\nunfollow:\n→ Step 11: 若存在，移除\n\nEnd.\n\nWe can use Decision block to check existence, etc.\n\nAlso maybe we need to clarify ordering.\n\nLet's produce each line as virtual code. Provide arrows, decisions, etc. Use bullet style.\n\nMake sure each line: `虛擬碼步驟 // 解釋`.\n\nLet's craft.\n\nWe'll output step lines sequentially.\n\nMake sure to follow format exactly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Twitter 類別並初始化資料結構 // 準備用於存儲使用者關係與推文  \n→ Step 2: 定義 followees: Map<userId, Set<followeeId>> // 追蹤每個使用者的粉絲目標  \n→ Step 3: 定義 tweets: List<tuple(userId, tweetId, timestamp)> // 儲存所有推文並排序  \n→ Step 4: 定義 timestampCounter = 0 // 用於標記推文的先後順序  \n\n// 方法: postTweet  \n→ Step 5: postTweet(userId, tweetId) → Increment timestampCounter // 產生新的時間戳  \n→ Decision: 是否已存在此使用者? // 檢查是否需要創建空推文列表  \n    Yes → No action // 已存在不需要操作  \n    No  → No action // 簡化說明，無需額外步驟  \n→ Step 6: Append (userId, tweetId, timestampCounter) 到 tweets // 新推文加入列表  \n\n// 方法: getNewsFeed  \n→ Step 7: getNewsFeed(userId) → 定義 feedSet = followees.get(userId) ∪ {userId} // 包含自己和所有粉絲  \n→ Step 8: 定義 result = [] // 存儲最終推文 ID  \n→ Step 9: 從 tweets 的最後一筆開始往前遍歷 // 逆序遍歷以獲得最新推文  \n    → Decision: result.size() == 10? // 已收集到 10 筆推文  \n        Yes → Break // 結束遍歷  \n        No  → Decision: 推文的 userId ∈ feedSet? // 推文作者是否屬於關注範圍  \n            Yes → Append tweetId 到 result // 收集推文 ID  \n            No  → No action // 跳過非關注推文  \n→ Step 10: 返回 result // 以最新到最舊排序的 10 條推文 ID  \n\n// 方法: follow  \n→ Step 11: follow(followerId, followeeId) → 若 followerId 不在 followees 中則建立空集合  \n→ Decision: followeeId 是否已在 followerId 的集合中?  \n    Yes → No action // 已追蹤不做變更  \n    No  → Step 12: 添加 followeeId 到 followerId 的集合 // 建立關注關係  \n\n// 方法: unfollow  \n→ Step 13: unfollow(followerId, followeeId) → 若 followerId 在 followees 中  \n    → Decision: followeeId 是否存在於 followerId 的集合中?  \n        Yes → Step 14: 從 followerId 的集合中移除 followeeId // 取消關注  \n        No  → No action // 無關注關係不處理  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0  # global timestamp\n        self.tweets = defaultdict(list)   # userId -> list of (time, tweetId)\n        self.following = defaultdict(set) # userId -> set of followeeId\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # ensure the user follows themselves\n        self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int) -> list:\n        res = []\n        if userId not in self.following:\n            return res\n        follow_set = self.following[userId]\n        heap = []  # max-heap by negative timestamp\n        for fid in follow_set:\n            tws = self.tweets.get(fid, [])\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].add(followeeId)\n        # ensure the follower follows themselves\n        self.following[followerId].add(followerId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followeeId in self.following.get(followerId, set()):\n            self.following[followerId].remove(followeeId)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Wrap the input into a JSON array so it can be parsed\n    ops, args = json.loads(f'[{data}]')\n\n    outputs = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Twitter\":\n            obj = Twitter()\n            outputs.append(None)\n        elif op == \"postTweet\":\n            obj.postTweet(*arg)\n            outputs.append(None)\n        elif op == \"getNewsFeed\":\n            outputs.append(obj.getNewsFeed(*arg))\n        elif op == \"follow\":\n            obj.follow(*arg)\n            outputs.append(None)\n        elif op == \"unfollow\":\n            obj.unfollow(*arg)\n            outputs.append(None)\n    print(json.dumps(outputs))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "success": true,
          "output": "[null, null, [5], null, null, [6, 5], null, [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode670.json",
    "problem_index_in_file": 0,
    "title": "Maximum Swap",
    "description_snippet": "You are given an integer num. You can swap two digits at most once to get the maximum valued number....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode in lines with arrows and comments, explaining each step. The requirement: use Start, End, Decision, Yes →, No →. Provide step-by-step logic for maximizing number with at most one swap.\n\nWe need to consider algorithm: find first digit that has a larger digit later (rightmost largest), and swap with the largest digit to its right, but the rightmost occurrence of that largest digit.\n\nSimplify: For each index i from 0 to n-1, find max digit to right of i. If max > digit[i], record best swap. The best swap should be the rightmost such pair: choose i as earliest index with possible swap? Actually to maximize, we want to swap the first digit that can be increased with the largest digit to its right (rightmost occurrence of that digit). Implementation: Traverse from right to left, keep track of max digit seen and its index. For each i, if digit[i] < max_digit, record swap (i, max_index). After loop, if found swap, perform it. Complexity O(n).\n\nWe need to output pseudocode lines step by step.\n\nInclude input conversion to string or array. Steps:\n\nStart\n→ Step 1: Convert num to string array digits\n→ Step 2: Initialize max_digit = -1, max_index = -1, swap_i = -1, swap_j = -1\n→ Step 3: For i from len(digits)-1 down to 0:\n→ Decision: Is digits[i] > max_digit? \n    Yes → Update max_digit, max_index\n    No  → Decision: Is digits[i] < max_digit?\n        Yes → Record swap_i = i, swap_j = max_index\n        No → do nothing\n→ Step 4: If swap_i != -1, swap digits[swap_i] and digits[swap_j]\n→ Step 5: Convert digits back to integer\nEnd\n\nAdd explanation comments.\n\nMake sure to use proper arrow indentation.\n\nLet's write pseudocode accordingly. Use \"→\" for steps, \"Decision:\" for condition, \"Yes →\" and \"No →\" for branches. Use indentation maybe 4 spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入整數 num 轉成字符陣列 digits // 方便逐位操作  \n→ Step 2: 初始化 max_digit = -1, max_index = -1, swap_i = -1, swap_j = -1 // 追蹤右側最大數字及其位置，以及待交換位置  \n→ Step 3: 從右往左遍歷 digits，i 從 len(digits)-1 迭代到 0  \n  Decision: 如果 digits[i] > max_digit? // 檢查當前位是否比已知右側最大還大  \n   Yes → Step 3a: 更新 max_digit = digits[i], max_index = i // 右側新最大數字  \n   No  → Decision: 如果 digits[i] < max_digit? // 能否與右側更大數字交換  \n    Yes → Step 3b: 設 swap_i = i, swap_j = max_index // 記錄交換位置  \n    No → // 目前位已是局部最大，無需變動  \n→ Step 4: 如果 swap_i != -1, 執行 swap digits[swap_i] 與 digits[swap_j] // 進行一次交換  \n→ Step 5: 將 digits 重新合併為整數 new_num // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def maximumSwap(self, num: int) -> int:\n        \"\"\"\n        將整數轉為字串陣列，使用一次交換取得最大的數字。\n        先建立每個數字最後出現的位置索引，然後從左到右遍歷，\n        尋找右側更大的數字，若能交換即立即返回結果。\n        \"\"\"\n        digits = list(str(num))\n        # last[i] = 最後一次出現數字 i 的索引\n        last = {int(ch): idx for idx, ch in enumerate(digits)}\n\n        for i, ch in enumerate(digits):\n            cur = int(ch)\n            # 從 9 降到 cur+1，尋找能交換的更大數字\n            for d in range(9, cur, -1):\n                if d in last and last[d] > i:\n                    # 交換並立即回傳\n                    j = last[d]\n                    digits[i], digits[j] = digits[j], digits[i]\n                    return int(\"\".join(digits))\n        return int(\"\".join(digits))\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析數字並輸出最大值。\n    輸入範例：`num = 2736` 或僅 `2736`。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 嘗試解析 `num = X` 的格式\n    if '=' in data:\n        try:\n            _, num_str = data.split('=', 1)\n            num = int(num_str.strip())\n        except ValueError:\n            # 若解析失敗，嘗試直接轉整數\n            num = int(data.replace('num', '').strip())\n    else:\n        num = int(data)\n\n    result = Solution().maximumSwap(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 2736",
          "expected_output": "7236",
          "success": true,
          "output": "7236"
        },
        {
          "example_index": 1,
          "input": "num = 9973",
          "expected_output": "9973",
          "success": true,
          "output": "9973"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode303.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Immutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of th...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for a solution: implement a NumArray class with sumRange using prefix sums. Provide step-by-step algorithm. Use virtual arrows. Provide explanation after each line. No real code. Should output step-by-step algorithm: Start, initialize prefix sum array, compute cumulative sums, sumRange uses prefix difference. Provide pseudo steps.\n\nLet's produce lines:\n\nStart\n→ Step 1: Create class NumArray\n→ Step 2: 在建構子中接收 nums 並建立 prefixSum 陣列\n→ Step 3: prefixSum[0] = 0 // 用於簡化計算\n→ Step 4: 循環 i 0 到 nums.length-1\n→ Step 5: prefixSum[i+1] = prefixSum[i] + nums[i] // 計算前綴和\n→ Step 6: 定義 sumRange(left,right)\n→ Step 7: return prefixSum[right+1] - prefixSum[left] // 計算區間和\nEnd\n\nBut we need to keep each line with arrow and comment. Use decision? None. But we can still show steps. Use \"Start\" and \"End\". Provide arrow each line. Each line must be: \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nSo output lines exactly as required.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立類別 NumArray // 定義要實作的類別  \n→ Step 2: 在建構子中接收輸入陣列 nums 並初始化前綴和陣列 prefixSum // 前綴和方便快速求區間和  \n→ Step 3: 設定 prefixSum[0] = 0 // 以 0 作為基準，避免邊界處理  \n→ Step 4: 從 i = 0 到 i < nums.length 進行迴圈 // 逐個累加元素以建立前綴和  \n→ Step 5: 在迴圈內執行 prefixSum[i+1] = prefixSum[i] + nums[i] // 計算第 i+1 個前綴和  \n→ Step 6: 定義方法 sumRange(left, right) // 回傳區間和的函式  \n→ Step 7: 直接回傳 prefixSum[right+1] - prefixSum[left] // 利用前綴和差得到答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef parse_input(data: str):\n    \"\"\"將輸入字串解析成命令清單與對應參數清單\"\"\"\n    lines = data.strip().splitlines()\n    if not lines:\n        return [], []\n    if len(lines) == 1:\n        # 可能是單行輸入，將整行包在方括號後解析\n        data = '[' + lines[0].strip() + ']'\n        parsed = ast.literal_eval(data)\n    else:\n        # 分別解析兩行\n        parsed = [ast.literal_eval(lines[0].strip()), ast.literal_eval(lines[1].strip())]\n    return parsed[0], parsed[1]\n\ndef main():\n    raw_input = sys.stdin.read()\n    commands, args_list = parse_input(raw_input)\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"NumArray\":\n            # args 可能是 [[...]] 或 [...]，取內部陣列\n            if isinstance(args, list) and args and isinstance(args[0], list):\n                arr = args[0]\n            else:\n                arr = args\n            obj = NumArray(arr)\n            results.append(None)\n        elif cmd == \"sumRange\":\n            left, right = args\n            results.append(obj.sumRange(left, right))\n        else:\n            # 未知命令，忽略\n            results.append(None)\n\n    # 輸出結果，使用 json 以得到 null 的表示\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "success": true,
          "output": "[null, 1, -1, -3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode80.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array II",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code (pseudocode) line by line, each line with explanation comment. Need to use Start, End, Decision:, arrow syntax.\n\nUser requirement: remove duplicates from sorted array so each element appears at most twice. Return k and modify array in place. O(1) memory. Classic Leetcode 80: Remove Duplicates from Sorted Array II.\n\nWe need to produce pseudocode: Approach: use two-pointer method. Write pseudo lines with arrow and comments.\n\nWe should start: Start. Then Step: If nums length <= 2: return length. Then init i pointer? Usually use writeIndex starting at 2, and iterate from index 2 to end. For each index j, if nums[j] != nums[writeIndex-2] then nums[writeIndex] = nums[j]; writeIndex++.\n\nAlso explain decisions: check if current element is equal to element two positions behind writeIndex; if not equal, copy.\n\nAlso return writeIndex.\n\nNeed to output lines: each line like \"→ Step: ...\" with comment after //. Use indentation? Example shows indent with spaces. We need to keep consistent.\n\nWe should include Decision: maybe not necessary but could include.\n\nLet's produce step by step:\n\nStart\n→ Step 1: n ← length(nums) // 獲取陣列長度\n→ Decision: 如果 n ≤ 2? // 若長度 ≤ 2，直接返回\n    Yes → Step 2: return n // 陣列長度不超過 2，已符合條件\n    No  → Step 3: writeIndex ← 2 // 初始化寫入指標，保留前兩個位置\n→ Step 4: 從 index 2 開始遍歷整個陣列 // 循環檢查每個元素\n    → Step 5: current ← nums[i] // 取得當前元素\n    → Decision: 如果 current 與 nums[writeIndex-2] 相等? // 判斷是否已出現兩次\n        Yes → Step 6: // 跳過此元素，已達到最大重複數量\n        No  → Step 7: nums[writeIndex] ← current // 複製元素到寫入位置\n            → Step 8: writeIndex ← writeIndex + 1 // 移動寫入指標\n→ Step 9: return writeIndex // 回傳有效元素個數\nEnd\n\nBut we need each line separate. Indentation for Decision branches might be represented by nested lines or indent spaces. The example shows indentation with 4 spaces per indent. We'll follow similar style.\n\nWe need each line with virtual code step plus // explanation. The line content may be \"Decision: ...?\" with arrow indent. Let's produce as lines.\n\nWe must not include actual code. Just virtual steps.\n\nLet's produce final answer in Chinese.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: n ≤ 2? // 若長度不超過 2，已符合條件  \n  Yes → Step 2: return n // 直接回傳長度  \n  No  → Step 3: writeIndex ← 2 // 初始化寫入指標，保留前兩個元素位置  \n→ Step 4: 從 i = 2 開始遍歷到 n-1 // 循環檢查每個元素  \n  → Step 5: current ← nums[i] // 取得當前元素  \n  → Decision: current == nums[writeIndex-2]? // 判斷是否已出現兩次  \n    Yes → // 跳過此元素，已達到最大重複數量  \n    No  → Step 6: nums[writeIndex] ← current // 複製元素到寫入位置  \n      → Step 7: writeIndex ← writeIndex + 1 // 移動寫入指標  \n→ Step 8: return writeIndex // 回傳有效元素個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n        write_index = 2  # 保留前兩個元素\n        for i in range(2, len(nums)):\n            if nums[i] != nums[write_index - 2]:\n                nums[write_index] = nums[i]\n                write_index += 1\n        return write_index\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data.startswith(\"nums =\"):\n        data = data.split(\"=\", 1)[1].strip()\n    nums = ast.literal_eval(data)\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n    result = nums[:k] + [\"_\"] * (len(nums) - k)\n    print(f\"{k}, nums = {result}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[1,1,2,2,3,_]'\nGot (Norm):      '5,nums=[1,1,2,2,3,\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [1,1,2,2,3,_]'\nRaw Got:      \"5, nums = [1, 1, 2, 2, 3, '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '7,nums=[0,0,1,1,2,3,3,_,_]'\nGot (Norm):      '7,nums=[0,0,1,1,2,3,3,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '7, nums = [0,0,1,1,2,3,3,_,_]'\nRaw Got:      \"7, nums = [0, 0, 1, 1, 2, 3, 3, '_', '_']\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode29.json",
    "problem_index_in_file": 0,
    "title": "Divide Two Integers",
    "description_snippet": "Given two integers dividend and divisor, divide two integers without using multiplication, division,...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode in Chinese with explanations, using arrows, Start, End, Decision etc. Provide lines.\n\nWe need to implement integer division without *, /, mod. Approach: use bit shifting subtraction (like long division). Steps:\n\n- Handle edge cases: dividend == INT_MIN && divisor == -1 => overflow, return INT_MAX.\n\n- Determine sign: negative if XOR of signs.\n\n- Convert both dividend and divisor to long (abs value) to avoid overflow: use absolute of int values.\n\n- Use bit shifting to compute quotient: while dividend_abs >= divisor_abs: find maximum shift such that (divisor_abs << shift) <= dividend_abs; subtract and accumulate.\n\n- After loop, apply sign to quotient.\n\n- Clamp to INT_MAX / INT_MIN.\n\nReturn quotient.\n\nWe need to produce each line with virtual code steps, explanation in comment.\n\nLet's produce:\n\nStart\n→ Step 1: 定義 INT_MAX = 2^31-1, INT_MIN = -2^31 // 32-bit 限制\n→ Step 2: 若 dividend = INT_MIN 且 divisor = -1 → Return INT_MAX // 防止溢位\n→ Decision: 若 dividend 或 divisor 為負? // 判斷符號\n    Yes → Step 3: 計算 negative = (dividend < 0) XOR (divisor < 0) // 符號\n    No  → Step 3: 設 negative = False\n→ Step 4: 將 dividend 與 divisor 轉為長整數並取絕對值\n    dividend_abs = abs(dividend)\n    divisor_abs = abs(divisor)\n→ Step 5: 初始化 quotient = 0 // 儲存商\n→ Decision: dividend_abs < divisor_abs? // 是否能進行除法\n    Yes → Step 6: If negative → quotient = -quotient else quotient = quotient // 但此時 quotient 0\n    No  → Step 7: Loop while dividend_abs >= divisor_abs\n        → Step 8: 設 shift = 0\n        → Decision: (divisor_abs << (shift+1)) <= dividend_abs ?\n            Yes → shift = shift + 1 → Continue\n            No  → Break\n        → Step 9: dividend_abs -= divisor_abs << shift\n        → Step 10: quotient += 1 << shift\n    → End Loop\n→ Step 11: 若 negative → quotient = -quotient\n→ Decision: quotient > INT_MAX ?\n    Yes → Step 12: Return INT_MAX\n    No  → Decision: quotient < INT_MIN ?\n        Yes → Step 13: Return INT_MIN\n        No  → Step 14: Return quotient\nEnd\n\nBut we must format exactly: Each line with virtual code, comment.\n\nLet's produce with arrows and indentation for decisions. Use \"Decision:\" for if else. Use \"Yes →\", \"No →\".\n\nWe must not output actual code, but virtual steps. So use plain words. Ensure each line is like:\n\n→ Step 1: ... // explanation\n\nAlso decisions need nested lines.\n\nWe need to avoid real code.\n\nWe'll use \"→ Decision: ...\" lines.\n\nLet's craft.\n\nAlso need to ensure no real code: e.g., don't write abs() function? That's okay as pseudo. Just use \"取絕對值\". Avoid actual math operations like division, multiplication. But we need bit shift. It's allowed.\n\nWe should use long variable names.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 INT_MAX = 2^31 - 1, INT_MIN = -2^31 // 定義 32‑bit 整數範圍  \n→ Step 2: 若 dividend = INT_MIN 且 divisor = -1 → Return INT_MAX // 防止超出範圍  \n→ Decision: dividend 或 divisor 為負? // 判斷符號  \n Yes → Step 3: 設 negative = (dividend < 0) XOR (divisor < 0) // 符號為負  \n No  → Step 3: 設 negative = False // 符號為正  \n→ Step 4: 取 dividend 與 divisor 的絕對值，並轉成長整數  \n dividend_abs = abs(dividend)  \n divisor_abs  = abs(divisor)  \n→ Step 5: 初始化 quotient = 0 // 商的累積  \n→ Decision: dividend_abs < divisor_abs? // 是否無法進行除法  \n Yes → Step 6: 若 negative → quotient = 0  \n No  → Step 7: 進入除法迴圈  \n  → Step 8: 只要 dividend_abs >= divisor_abs，重複下列  \n    → Step 9: 設 shift = 0  \n    → Decision: (divisor_abs << (shift+1)) <= dividend_abs? // 找最大移位  \n      Yes → shift = shift + 1 → 重新判斷  \n      No  → 退出搜尋  \n    → Step 10: dividend_abs -= divisor_abs << shift // 減去最大可移位倍數  \n    → Step 11: quotient += 1 << shift // 商加上相應位數  \n    → End Step 8  \n→ Step 12: 若 negative → quotient = -quotient // 取負號  \n→ Decision: quotient > INT_MAX? // 超出上限  \n Yes → Step 13: Return INT_MAX  \n No  → Decision: quotient < INT_MIN? // 超出下限  \n  Yes → Step 14: Return INT_MIN  \n  No  → Step 15: Return quotient // 正常商  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # 32-bit signed integer limits\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        # Handle overflow case\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n\n        # Determine sign of the result\n        negative = (dividend < 0) != (divisor < 0)\n\n        # Work with absolute values to simplify the algorithm\n        dividend_abs = abs(dividend)\n        divisor_abs = abs(divisor)\n\n        quotient = 0\n\n        # Main division loop using bit shifts\n        while dividend_abs >= divisor_abs:\n            temp = divisor_abs\n            multiple = 1\n            # Double temp and multiple until temp exceeds dividend_abs\n            while dividend_abs >= (temp << 1):\n                temp <<= 1\n                multiple <<= 1\n            # Subtract the largest shifted divisor found\n            dividend_abs -= temp\n            quotient += multiple\n\n        # Apply sign\n        if negative:\n            quotient = -quotient\n\n        # Clamp to 32-bit signed integer range\n        if quotient > INT_MAX:\n            return INT_MAX\n        if quotient < INT_MIN:\n            return INT_MIN\n        return quotient\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', data)\n    if len(numbers) < 2:\n        sys.exit(0)  # Not enough input\n    dividend, divisor = int(numbers[0]), int(numbers[1])\n    sol = Solution()\n    result = sol.divide(dividend, divisor)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dividend = 10, divisor = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "dividend = 7, divisor = -3",
          "expected_output": "-2",
          "success": true,
          "output": "-2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode290.json",
    "problem_index_in_file": 0,
    "title": "Word Pattern",
    "description_snippet": "Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match,...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: pattern to string mapping bijection. We need to output step-by-step pseudo code lines with comments, using arrows and decisions. Must be line by line. Should be in Traditional Chinese. Use structure: Start, → Step, Decision, etc. Should not output actual code. Provide explanation after //.\n\nWe should include steps: parse s into words list, check lengths, create two maps (pattern to word, word to pattern). Iterate, for each char in pattern, get word. If pattern->word exists and mismatched -> return false. If word->pattern exists and mismatched -> false. Else add mapping. After loop return true. Also need to handle count mismatch.\n\nWe produce lines accordingly. Use indentation maybe? The sample uses indentation for nested decisions. We'll follow same style.\n\nLet's craft.\n\nStart\n→ Step 1: 將 s 依空白切割為 words 列表 // 取得字串中的單字\n→ Decision: 如果 pattern 長度 ≠ words 數量? // 長度必須相等\n    Yes → Step 2: 回傳 false // 直接不符合\n    No → Continue\n→ Step 3: 建立空字典 pattern_to_word // pattern ↔ word\n→ Step 4: 建立空字典 word_to_pattern // word ↔ pattern\n→ Step 5: 從 0 到 pattern 長度-1 進行迴圈 // 逐個比較\n    → Decision: pattern[i] 在 pattern_to_word? // 是否已有 mapping\n        Yes → Step 6: 若 pattern_to_word[pattern[i]] ≠ words[i]? // mapping 不符\n                Yes → Step 7: 回傳 false\n                No  → Continue\n        No  → Decision: words[i] 在 word_to_pattern? // 該 word 是否已被別的 pattern 佔用\n            Yes → Step 8: 若 word_to_pattern[words[i]] ≠ pattern[i]? // 再次檢查\n                    Yes → Step 9: 回傳 false\n                    No  → Continue\n            No  → Step 10: pattern_to_word[pattern[i]] ← words[i] // 建立 mapping\n                    Step 11: word_to_pattern[words[i]] ← pattern[i] // 建立對應\n→ Step 12: 回傳 true // 所有檢查通過\nEnd\n\nNeed to include arrows and comments after each line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 s 依空白切割為 words 列表 // 取得字串中的單字  \n→ Decision: 如果 pattern 長度 ≠ words 數量? // 長度必須相等  \n    Yes → Step 2: 回傳 false // 直接不符合  \n    No  → Continue // 仍需進一步比對  \n→ Step 3: 建立空字典 pattern_to_word // pattern ↔ word  \n→ Step 4: 建立空字典 word_to_pattern // word ↔ pattern  \n→ Step 5: 從 0 到 pattern 長度-1 進行迴圈 // 逐個比較  \n    → Decision: pattern[i] 在 pattern_to_word? // 是否已有 mapping  \n        Yes → Step 6: 若 pattern_to_word[pattern[i]] ≠ words[i]? // mapping 不符  \n                 Yes → Step 7: 回傳 false  \n                 No  → Continue // 符合，繼續迴圈  \n        No  → Decision: words[i] 在 word_to_pattern? // 該 word 是否已被別的 pattern 佔用  \n                 Yes → Step 8: 若 word_to_pattern[words[i]] ≠ pattern[i]? // 再次檢查  \n                     Yes → Step 9: 回傳 false  \n                     No  → Continue // 符合，繼續迴圈  \n                 No  → Step 10: pattern_to_word[pattern[i]] ← words[i] // 建立 mapping  \n                  Step 11: word_to_pattern[words[i]] ← pattern[i] // 建立對應  \n→ Step 12: 回傳 true // 所有檢查通過  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n\n        char_to_word = {}\n        word_to_char = {}\n\n        for c, w in zip(pattern, words):\n            if c in char_to_word:\n                if char_to_word[c] != w:\n                    return False\n            else:\n                char_to_word[c] = w\n\n            if w in word_to_char:\n                if word_to_char[w] != c:\n                    return False\n            else:\n                word_to_char[w] = c\n\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 抓取 pattern 與 s 的值（假設輸入格式類似 pattern = \"abba\", s = \"dog cat cat dog\"）\n    pattern_match = re.search(r'pattern\\s*=\\s*\"([^\"]+)\"', data)\n    s_match = re.search(r's\\s*=\\s*\"([^\"]+)\"', data)\n\n    if not pattern_match or not s_match:\n        # 如果找不到預期的格式，直接輸出 false\n        print('false')\n        return\n\n    pattern = pattern_match.group(1)\n    s = s_match.group(1)\n\n    solution = Solution()\n    result = solution.wordPattern(pattern, s)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode581.json",
    "problem_index_in_file": 0,
    "title": "Shortest Unsorted Continuous Subarray",
    "description_snippet": "Given an integer array nums, you need to find one continuous subarray such that if you only sort thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: given integer array nums, find shortest continuous subarray that if sorted makes whole array sorted. Return its length.\n\nWe need to output step-by-step pseudocode with explanations, using the required format.\n\nSo we need to design algorithm: standard solution: find left boundary L where array stops increasing from left, find right boundary R where array stops increasing from right; then find min and max in subarray L..R; expand L backward while nums[i] > min; expand R forward while nums[i] < max; length = max(0, R-L+1).\n\nWe'll produce pseudocode lines accordingly.\n\nWe need to ensure each line has format: \"虛擬碼步驟 // 解釋\".\n\nUse Start, End, Decision, etc.\n\nOk produce.\n\nLet's create steps:\n\nStart\n\n→ Step 1: Initialize n ← length(nums) // get array length\n\n→ Step 2: If n <= 1 → Step 3: Return 0 // single element already sorted\n\n→ Decision: 找左邊界 L\n\n→ Step 4: L ← 0\n\n→ Step 5: While L+1 < n AND nums[L] <= nums[L+1] → L ← L + 1 // move L while increasing\n\n→ Decision: 若 L == n-1? // 整個陣列已排序\n\n    Yes → Step 6: Return 0\n\n    No →\n\n→ Decision: 找右邊界 R\n\n→ Step 7: R ← n-1\n\n→ Step 8: While R-1 >= 0 AND nums[R-1] <= nums[R] → R ← R - 1 // move R while increasing\n\n→ Step 9: Find subarray minimum and maximum between L and R\n\n→ Step 10: minVal ← min(nums[L..R]) // compute min\n\n→ Step 11: maxVal ← max(nums[L..R]) // compute max\n\n→ Step 12: While L-1 >= 0 AND nums[L-1] > minVal → L ← L - 1 // expand left\n\n→ Step 13: While R+1 < n AND nums[R+1] < maxVal → R ← R + 1 // expand right\n\n→ Step 14: Return R - L + 1 // length of shortest subarray\n\nEnd\n\nBut we need to include arrow indications.\n\nWe also need to handle decisions.\n\nWe should also maybe include step for computing min and max via loop.\n\nSimplify: We'll produce a step that loops to find min and max.\n\nAlternatively we can just mention \"Compute minVal and maxVal\".\n\nOk produce final answer.\n\nEnsure each line ends with // 解釋.\n\nAlso arrow \"→\" etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: If n ≤ 1 → Step 3: Return 0 // 單元素或空陣列已排序  \n→ Decision: 是否已全部排序?  \n    Yes → Step 3: Return 0 // 若已排序則直接回傳 0  \n    No  →  \n→ Step 4: L ← 0 // 設定左邊界起點  \n→ Step 5: While L + 1 < n AND nums[L] ≤ nums[L + 1] → L ← L + 1 // 從左往右找第一個不遞增的位置  \n→ Decision: 若 L = n - 1? // 檢查是否整體已排序  \n    Yes → Step 3: Return 0 // 已排序，回傳 0  \n    No  →  \n→ Step 6: R ← n - 1 // 設定右邊界終點  \n→ Step 7: While R - 1 ≥ 0 AND nums[R - 1] ≤ nums[R] → R ← R - 1 // 從右往左找第一個不遞增的位置  \n→ Step 8: minVal ← nums[L] // 初始化最小值  \n→ Step 9: maxVal ← nums[L] // 初始化最大值  \n→ Step 10: i ← L + 1  \n→ Step 11: While i ≤ R →  \n    → minVal ← min(minVal, nums[i]) // 更新最小值  \n    → maxVal ← max(maxVal, nums[i]) // 更新最大值  \n    → i ← i + 1  \n→ Step 12: While L - 1 ≥ 0 AND nums[L - 1] > minVal → L ← L - 1 // 如左邊有比最小值大的數，擴大左邊界  \n→ Step 13: While R + 1 < n AND nums[R + 1] < maxVal → R ← R + 1 // 如右邊有比最大值小的數，擴大右邊界  \n→ Step 14: Return R - L + 1 // 回傳最短子陣列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findUnsortedSubarray(self, nums):\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        # Find left boundary where the ascending order breaks\n        left = 0\n        while left + 1 < n and nums[left] <= nums[left + 1]:\n            left += 1\n        if left == n - 1:  # already sorted\n            return 0\n\n        # Find right boundary where the ascending order breaks\n        right = n - 1\n        while right - 1 >= 0 and nums[right - 1] <= nums[right]:\n            right -= 1\n\n        # Compute min and max in the unsorted part\n        sub_min = min(nums[left:right+1])\n        sub_max = max(nums[left:right+1])\n\n        # Expand left boundary if needed\n        while left > 0 and nums[left - 1] > sub_min:\n            left -= 1\n\n        # Expand right boundary if needed\n        while right < n - 1 and nums[right + 1] < sub_max:\n            right += 1\n\n        return right - left + 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the list of integers from the input\n    # Expect input like: nums = [2,6,4,8,10,9,15]\n    match = re.search(r'\\[(.*?)\\]', data)\n    if match:\n        nums_str = match.group(1)\n        # Safely evaluate the numbers\n        nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    else:\n        nums = []\n\n    result = Solution().findUnsortedSubarray(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode400.json",
    "problem_index_in_file": 0,
    "title": "Nth Digit",
    "description_snippet": "Given an integer n, return the n^th digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The problem: given integer n, return the nth digit of infinite integer sequence of concatenated positive integers. Need to compute the digit at position n in the infinite string \"123456789101112...\".\n\nWe need to produce virtual code step-by-step, using structure Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" to indicate next step. We need to consider algorithm: Determine the block of digits (1-digit numbers 1-9, 2-digit numbers 10-99, etc.). Count digits: 9*1=9, 90*2=180, etc. Subtract until find block. Then find the exact number and digit offset.\n\nThus steps:\n\nStart\n\n→ Step: Read n\n\n→ Decision: Is n <= 9? // 1-digit block\n\n    Yes → Step: Return n as digit // Because nth digit is n itself\n\n    No → Step: n = n - 9 // subtract 1-digit block\n\n    → Decision: Is n <= 180? // 2-digit block\n\n        Yes → Step: number = 10 + (n-1)/2 // integer division\n\n        → Step: digitIndex = (n-1)%2\n\n        → Step: digit = digitIndex==0 ? first digit of number : second digit\n\n        → Step: Return digit\n\n        No → n = n - 180\n\n        → Decision: Is n <= 2700? // 3-digit block etc.\n\nWe can generalize with loop.\n\nBut produce step-by-step.\n\nLet's produce a concise but thorough algorithm.\n\nUse variables: length=1; count=9; start=1; while n>length*count: n -= length*count; length++; count*=10; start*=10; Then number = start + (n-1)/length; digitIndex=(n-1)%length; digit=the digitIndex-th char of number. Return digit.\n\nWe can break into steps:\n\nStep 1: Read n\n\nStep 2: length=1; count=9; start=1;\n\nStep 3: Decision: while n > length*count? // Check if n beyond current block\n\n    Yes → Step: n -= length*count; length++; count*=10; start*=10; // move to next block\n\n    No → Go to Step 4\n\nStep 4: number = start + (n-1)/length\n\nStep 5: digitIndex = (n-1)%length\n\nStep 6: Convert number to string and get digit at digitIndex\n\nStep 7: Return digit\n\nStep 8: End\n\nBut we should produce with arrow notation: \"→\" for next step; decision lines with Yes → / No →.\n\nLet's create lines accordingly.\n\nNeed to include explanations.\n\nMake sure to adhere to formatting: each line: \"虛擬碼步驟 // 解釋\"\n\nUse \"Start\" \"End\".\n\nWe can produce multiple decisions but maintain clarity.\n\nWe may also need to show loop as decision.\n\nLet's create:\n\nStart // 程式開始執行\n\n→ Step 1: Read input n // 取得輸入整數\n\n→ Step 2: Set length = 1, count = 9, start = 1 // 初始化區段參數\n\n→ Decision: n > length * count? // 判斷 n 是否超過目前區段長度\n\n    Yes → Step 3: n = n - length * count // 移除已經排除的區段\n    → Step 4: length = length + 1 // 區段位數加1\n    → Step 5: count = count * 10 // 區段個數乘10\n    → Step 6: start = start * 10 // 區段起始數字乘10\n    → Decision: n > length * count? // 重新判斷，進入迴圈\n        Yes → Go back to Step 3\n        No  → Go to Step 7\n\n    No  → Go to Step 7\n\n→ Step 7: number = start + (n - 1) / length // 找到對應的數字\n\n→ Step 8: digitIndex = (n - 1) % length // 找到數字中的哪一位\n\n→ Step 9: digit = getDigit(number, digitIndex) // 取得該位數字\n\n→ Step 10: Output digit // 回傳結果\n\nEnd // 程式結束\n\nBut we need to ensure arrow notation: \"Yes →\" \"No →\" etc.\n\nAlso need to maintain proper indentation? The sample uses indentation for decisions. We can replicate.\n\nLet's produce final answer.\n\nEnsure each line is a step.\n\nWill produce using bullet lines? No just lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read input n // 取得使用者輸入的整數 n  \n→ Step 2: Set length = 1, count = 9, start = 1 // 初始化位數、數字個數與區段起始值  \n→ Decision: n > length * count? // 判斷 n 是否超過目前區段長度  \n Yes → Step 3: n = n - length * count // 移除已經排除的區段  \n → Step 4: length = length + 1 // 區段位數加 1  \n → Step 5: count = count * 10 // 区段個數乘以 10（例如 1-9 → 10-99）  \n → Step 6: start = start * 10 // 區段起始數字乘以 10（1 → 10 → 100）  \n → Decision: n > length * count? // 重新判斷，若仍超過則重複上述步驟  \n  Yes → Go back to Step 3  \n  No  → Go to Step 7  \n No  → Go to Step 7  \n→ Step 7: number = start + (n - 1) / length // 找到對應的數字  \n→ Step 8: digitIndex = (n - 1) % length // 找到數字中的哪一位（0 為第一位）  \n→ Step 9: digit = getDigit(number, digitIndex) // 取得該位數字（以字串或數學取模方式）  \n→ Step 10: Output digit // 回傳最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findNthDigit(self, n: int) -> int:\n        length = 1          # current digit length\n        count = 9           # numbers with this digit length\n        start = 1           # first number with this digit length\n\n        # 找到包含第 n 位數字的區段\n        while n > length * count:\n            n -= length * count\n            length += 1\n            count *= 10\n            start *= 10\n\n        # 確定對應的數字\n        start += (n - 1) // length\n        s = str(start)\n        # 取得對應位置的數字\n        return int(s[(n - 1) % length])\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入中抽取第一個數字，無論輸入格式如何\n    m = re.search(r'\\d+', data)\n    if not m:\n        return\n    n = int(m.group(0))\n    solution = Solution()\n    print(solution.findNthDigit(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 11",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode769.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted",
    "description_snippet": "You are given an integer array arr of length n that represents a permutation of the integers in the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps to solve problem: Given array arr permutation [0,n-1], split into maximum chunks such that sorting each chunk and concatenating yields sorted array. Known solution: Count number of positions where max so far equals index. Steps: iterate, track max, when max == index, increment chunks. Return count. Provide virtual code lines with explanation. Use Start, End, Decision. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrow arrows. Provide lines sequentially. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 n ← length(arr) // 取得陣列長度  \n→ Step 2: 定義變數 max_so_far ← -1 // 追蹤目前為止的最大值  \n→ Step 3: 定義變數 chunks ← 0 // 目前已確定的區塊數  \n→ Step 4: 從 i = 0 到 n-1 逐位遍歷陣列  \n  → Step 4.1: max_so_far ← max(max_so_far, arr[i]) // 更新最大值  \n  → Decision: 如果 max_so_far == i? // 檢查是否能結束一個區塊  \n   Yes → Step 4.2: chunks ← chunks + 1 // 確定一個區塊  \n   No  → Step 4.3: 進行下一個迴圈迭代  \n→ Step 5: 回傳 chunks // 最終能分割的最大區塊數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef max_chunks_to_sorted(arr):\n    \"\"\"Return the largest number of chunks that can be sorted individually\n    to make the whole array sorted.\"\"\"\n    chunks = 0\n    left_max = -1\n    for i, val in enumerate(arr):\n        left_max = max(left_max, val)\n        if left_max == i:\n            chunks += 1\n    return chunks\n\ndef parse_input(input_str: str):\n    \"\"\"Parse the input string to extract the integer list.\n    The input is expected to contain a list, e.g. 'arr = [4,3,2,1,0]'.\n    \"\"\"\n    # Find the first '[' and the matching ']'\n    match = re.search(r'\\[.*\\]', input_str, re.S)\n    if not match:\n        raise ValueError(\"Input does not contain a list.\")\n    list_str = match.group(0)\n    # Use literal_eval for safety\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    arr = parse_input(raw_input)\n    result = max_chunks_to_sorted(arr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [4,3,2,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [1,0,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode504.json",
    "problem_index_in_file": 0,
    "title": "Base 7",
    "description_snippet": "Given an integer num, return a string of its base 7 representation....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for converting integer to base 7 string. Need step-by-step, include decisions, loops, start end. Use arrow and comments. Ensure each line is: virtual code + space + // explanation. Use Start, End, Decision. Use steps.\n\nWe should include handling negative numbers, zero, conversion using division and remainder. Use a stack or build string reversed. Outline:\n\nStart\n→ Step 1: 如果 num == 0? // special case\n    Yes → Step 2: result = \"0\" // set result\n    No  → Decision: 是否負數?\n        Yes → Step 3: isNegative = true; num = -num; // handle negative\n        No  → Step 3: isNegative = false // positive\n→ Step 4: 建立空字符串 result = \"\"\n→ Decision: num > 0? // loop while num > 0\n    Yes → Step 5: remainder = num mod 7; num = num / 7; // get digit\n        → Step 6: prepend digit to result // add to front\n        → Decision: num > 0? // loop again\n            Yes → repeat Step 5\n            No  → Decision: isNegative?\n                Yes → Step 7: result = \"-\" + result // add negative sign\n                No  → Step 7: // nothing\n→ Step 8: Return result // output\nEnd\n\nBut we must maintain structure: use arrows and indentation. Provide each line. Let's craft.\n\nWe need to ensure each line includes \"虛擬碼步驟\" and comment. Use Chinese explanation.\n\nLet's output lines:\n\nStart // 程式開始執行\n→ Decision: 若 num 為 0? // 檢查是否為 0\n    Yes → Step 1: result ← \"0\" // 設置結果為 \"0\"\n    No  → Decision: 是否為負數? // 判斷是否為負號\n        Yes → Step 2: isNegative ← true; num ← -num // 轉為正數並記錄符號\n        No  → Step 2: isNegative ← false // 正數直接記錄\n→ Step 3: result ← \"\" // 初始化結果字串\n→ Decision: num > 0? // 當 num 大於 0 時進入迴圈\n    Yes → Step 4: remainder ← num mod 7 // 取餘數作為當前位數\n        → Step 5: num ← num div 7 // 除以 7\n        → Step 6: result ← remainder + result // 將位數加到結果前面\n        → Decision: num > 0? // 仍有更高位需要處理\n            Yes → repeat Step 4\n            No  → Decision: isNegative? // 是否需要加負號\n                Yes → Step 7: result ← \"-\" + result // 在前面加負號\n                No  → Step 7: // 不做任何事\n→ Step 8: Return result // 回傳最終字串\nEnd // 程式執行結束\n\nBut need to maintain \"虛擬碼步驟\" wording; use \"Step X\". We need to use arrow and Decision lines. Each line must be: 虛擬碼步驟 [space] // 解釋.\n\nThus we produce lines like: \"Start // 程式開始執行\". Next: \"→ Decision: 若 num 為 0? // 檢查是否為 0\". Then indent \"Yes → Step 1: result ← '0' // 設置結果為 '0'\". But \"Step 1\" not needed if it's within Decision. However maintain.\n\nWe need consistent numbering? Not required. But we can number for clarity.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 num 為 0? // 檢查輸入是否為 0  \n Yes → Step 1: result ← \"0\" // 直接回傳 \"0\"  \n No  → Decision: 是否為負數? // 判斷是否需要處理負號  \n  Yes → Step 2: isNegative ← true; num ← -num // 取正數並記錄符號  \n  No  → Step 2: isNegative ← false // 正數不改變  \n→ Step 3: result ← \"\" // 初始化結果字串  \n→ Decision: num > 0? // 若 num 還有位數需要轉換  \n Yes → Step 4: remainder ← num mod 7 // 取得目前最低位數字  \n  → Step 5: num ← num div 7 // 去除已處理位數  \n  → Step 6: result ← remainder + result // 把位數放到結果前面  \n  → Decision: num > 0? // 是否還有更高位？  \n   Yes → repeat Step 4  \n   No  → Decision: isNegative? // 轉完位數後處理符號  \n    Yes → Step 7: result ← \"-\" + result // 加上負號  \n    No  → Step 7: // 無需處理  \n→ Step 8: Return result // 傳回最終的 base‑7 字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        if num == 0:\n            return \"0\"\n        neg = num < 0\n        num = abs(num)\n        digits = []\n        while num > 0:\n            digits.append(str(num % 7))\n            num //= 7\n        if neg:\n            digits.append('-')\n        return ''.join(reversed(digits))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().split()\n    if not data:\n        sys.exit()\n    num = int(data[0])\n    result = Solution().convertToBase7(num)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "100",
          "expected_output": "\"202\"",
          "success": true,
          "output": "202"
        },
        {
          "example_index": 1,
          "input": "-7",
          "expected_output": "\"-10\"",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode460.json",
    "problem_index_in_file": 0,
    "title": "LFU Cache",
    "description_snippet": "Design and implement a data structure for a Least Frequently Used (LFU) cache.\n\nImplement the LFUCac...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for implementing LFU cache. Provide each step with explanation. Use arrow and decision. Need to design data structures: capacity, key->value and freq, freq->OrderedDict of keys to maintain LRU within same freq. Need minFreq. get: if key not exist return -1; else increase freq: remove from old freq list, add to new freq list; update minFreq if needed. put: if capacity zero return; if key exists: update value and freq like get; else if capacity full: evict key with minFreq, earliest (leftmost) in freq list; then insert new key with freq=1, update minFreq=1. Provide pseudocode lines. Use \"→\" arrows. Provide decisions. Use Start, End. Provide brief explanations after //. Let's craft.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\".\n\nWe need to output only virtual code steps, not actual code. We'll need to define data structures: mapKeyToValFreq, mapFreqToOrderedKeys, minFreq.\n\nWe can use conceptual operations like \"Insert key into freq list\". Use \"Remove key from freq list\". Use \"Evict key\".\n\nLet's produce a step-by-step algorithm.\n\nWill produce multiple blocks: initialization, get, put. But since virtual code must be sequential, we can include definitions of helper functions inline. Use Start. Then steps for constructor, get, put. But easier: produce pseudo code for each method separately. Use \"Start\" and \"End\" for each method. Provide explanation lines.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: Define capacity, minFreq, keyMap, freqMap // 初始化變數\n\nBut need to show each method: maybe we treat as overall design.\n\nLet's craft like:\n\nStart // 程式開始\n→ Step 1: 初始化容量 capacity // 儲存 LFUCache 容量\n→ Step 2: 初始化 minFreq = 0 // 目前最低頻率\n→ Step 3: 初始化 keyMap: key -> (value, freq) // 儲存鍵值及頻率\n→ Step 4: 初始化 freqMap: freq -> LinkedHashSet of keys // 每頻率對應鍵集合，保持 LRU\n\nThen define get function:\n\nStart Get(key) // get 方法開始\n→ Step 5: 如果 key 不在 keyMap 中 → 返回 -1\n→ Decision: Key exists?\n    Yes → Step 6: (value, freq) = keyMap[key] // 取得值與頻率\n    → Step 7: 移除 key 從 freqMap[freq] // 從舊頻率集合移除\n    → Decision: freqMap[freq] 為空? \n        Yes → Step 8: 刪除 freqMap[freq] // 清除空集合\n        No → 不作\n    → Step 9: freq = freq + 1 // 更新頻率\n    → Step 10: keyMap[key] = (value, freq) // 更新 keyMap\n    → Step 11: 若 freqMap 中無 freq 則新增空集合 // 建立新頻率集合\n    → Step 12: 將 key 加入 freqMap[freq] 的尾部 // 保持 LRU\n    → Decision: freq - 1 == minFreq 且 freqMap[minFreq] 為空?\n        Yes → Step 13: minFreq = freq // 更新最小頻率\n        No → 不變\n    → Step 14: 返回 value\n\nEnd Get\n\nSimilarly for put.\n\nBut need to ensure O(1). Use LinkedHashSet or OrderedDict concept.\n\nLet's produce.\n\nWe should incorporate decision arrow lines. Use \"Yes →\" and \"No →\".\n\nWe must maintain each line: 虛擬碼步驟 + \" // 解釋\".\n\nAlso use \"→\" arrow lines.\n\nAlso we need to show Step numbers maybe.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 定義變數 capacity, minFreq ← 0, keyMap ← 空映射, freqMap ← 空映射 // 儲存容量、最小頻率、鍵值對與頻率對應的鍵集合\n\n// -----------------------------\n// get 方法\nStart Get(key) // get 方法開始\n\n→ Step 2: 若 key 不在 keyMap 中 → 返回 -1 // 沒有該鍵，直接回傳 -1\n\nDecision: key 是否存在? // 檢查 key 是否在 keyMap\n    Yes →\n        → Step 3: (value, freq) ← keyMap[key] // 取得目前的值與頻率\n        → Step 4: 從 freqMap[freq] 中移除 key // 從舊頻率集合移除該鍵\n        → Decision: freqMap[freq] 為空? // 檢查舊頻率集合是否已空\n            Yes →\n                → Step 5: 刪除 freqMap[freq] // 清除空集合\n            No → 不做任何事\n        → Step 6: freq ← freq + 1 // 更新頻率\n        → Step 7: keyMap[key] ← (value, freq) // 更新 keyMap 中的頻率\n        → Decision: freqMap 中無 freq? // 檢查新頻率集合是否存在\n            Yes →\n                → Step 8: freqMap[freq] ← 新空集合 // 建立新的頻率集合\n            No → 不做任何事\n        → Step 9: 將 key 加入 freqMap[freq] 的尾部 // 保持 LRU 順序\n        → Decision: (freq - 1 == minFreq) 且 freqMap[minFreq] 為空? // 是否需要更新最小頻率\n            Yes →\n                → Step 10: minFreq ← freq // 更新最小頻率為新頻率\n            No → 不變\n        → Step 11: 返回 value // 返回對應的值\n    No → 返回 -1 // 這個分支在 Step 2 已處理\n\nEnd Get // get 方法結束\n\n// -----------------------------\n// put 方法\nStart Put(key, value) // put 方法開始\n\n→ Step 12: 若 capacity == 0 → 直接返回 // 空容量不做任何事\n→ Decision: key 是否存在於 keyMap? // 檢查鍵是否已存在\n    Yes →\n        → Step 13: keyMap[key] ← (value, keyMap[key].freq) // 更新值，頻率保持不變\n        → Step 14: 執行 get(key) 以更新頻率並維持 LRU // 重新調用 get 來統一更新流程\n    No →\n        → Decision: keyMap 的大小 == capacity? // 檢查是否已滿\n            Yes →\n                → Step 15: minKey ← freqMap[minFreq].最前面的鍵 // 取得最小頻率中最舊的鍵\n                → Step 16: 從 freqMap[minFreq] 中移除 minKey // 移除該鍵\n                → Step 17: 從 keyMap 中移除 minKey // 從 keyMap 刪除對應條目\n            No → 不做任何事\n        → Step 18: keyMap[key] ← (value, 1) // 新鍵的頻率設為 1\n        → Step 19: minFreq ← 1 // 新鍵是最小頻率，更新 minFreq\n        → Decision: freqMap 中無 1? // 檢查頻率 1 的集合是否存在\n            Yes →\n                → Step 20: freqMap[1] ← 新空集合 // 建立頻率 1 的集合\n            No → 不做任何事\n        → Step 21: 將 key 加入 freqMap[1] 的尾部 // 放入最右側，保持 LRU\n\nEnd Put // put 方法結束\n\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}                      # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)   # freq -> OrderedDict of keys (LRU order)\n\n    def _update(self, key: int):\n        \"\"\"Internal helper to increase frequency of a key.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current frequency bucket\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next frequency bucket\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value but keep frequency unchanged\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (and LRU among them)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key with frequency 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Convert input string into a tuple of two lists\n    ops_and_params = ast.literal_eval('(' + raw_input + ')')\n    operations, params = ops_and_params\n\n    result = []\n    cache = None\n    for op, param in zip(operations, params):\n        if op == \"LFUCache\":\n            cache = LFUCache(param[0])\n            result.append(None)           # constructor returns null\n        elif op == \"put\":\n            cache.put(param[0], param[1])\n            result.append(None)           # put returns null\n        elif op == \"get\":\n            res = cache.get(param[0])\n            result.append(res)\n        else:\n            # unknown operation, ignore\n            result.append(None)\n\n    # Print results using JSON format (null instead of None)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "success": true,
          "output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode241.json",
    "problem_index_in_file": 0,
    "title": "Different Ways to Add Parentheses",
    "description_snippet": "Given a string expression of numbers and operators, return all possible results from computing all t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for computing all possible results from different ways to group numbers/operators. It's classic divide and conquer dynamic programming with recursion. We need to produce virtual code lines with comments. Use Start, End, Decision etc. Must be line by line. We should cover parsing input string to numbers and operators, then recursion to compute all results, caching. Also mention complexity.\n\nLet's produce steps:\n\nStart\n→ Step 1: Read expression string // input\n→ Step 2: Parse expression into two lists: nums and ops // split numbers and operators\n→ Decision: If expression length <= 1? // base case: single number\n    Yes → Step 3: Return list containing that number // only result\n    No → Step 4: Initialize empty result list // prepare to accumulate\n    → Step 5: For each operator position i in ops // iterate splits\n        → Step 6: left = compute(nums[0..i], ops[0..i-1]) // results left side\n        → Step 7: right = compute(nums[i+1..], ops[i+1..]) // results right side\n        → Step 8: For each l in left:\n            → Step 9: For each r in right:\n                → Step 10: result = apply(op[i], l, r) // compute\n                → Step 11: Append result to result list // store\n    → Step 12: Return result list // after all splits\n→ Step 13: Cache results for subexpression // memoization\nEnd\n\nBut we need virtual code lines and comments. Use arrow for steps.\n\nWe also need to reflect memoization.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: Define function compute(expr) // 主計算函式\n→ Decision: If expr already in memo? // 檢查是否已計算\n    Yes → Step 2: Return memo[expr] // 直接返回結果\n    No  →\n        → Step 3: If expr 沒有運算符? // 單一數字\n            → Decision: If no operator? // 檢查\n                Yes → Step 4: memo[expr] = [convert_to_int(expr)] // 只一個結果\n                No  →\n                    → Step 5: Initialize results = [] // 儲存所有可能結果\n                    → Step 6: For each operator index i in expr where char is +,-,*:\n                        → Step 7: left_expr = expr[0:i] // 左子式\n                        → Step 8: right_expr = expr[i+1:] // 右子式\n                        → Step 9: left_results = compute(left_expr) // 左部結果\n                        → Step 10: right_results = compute(right_expr) // 右部結果\n                        → Step 11: For each l in left_results:\n                            → Step 12: For each r in right_results:\n                                → Step 13: results.append(apply(op, l, r)) // 計算並加入\n                    → Step 14: memo[expr] = results // 緩存\n        → Step 15: Return memo[expr] // 結果回傳\n→ Step 16: Call compute(input_expr) // 執行\n→ Step 17: Output results // 顯示\n\nBut we need to show parsing of numbers and operators? The above uses string splitting on operators, but easier. But requirement: expression string of numbers and operators, we can parse using scanning. Use compute on subexpressions by string index? Another approach: convert to list of numbers and operators. But simpler: compute on subexpression string segments.\n\nThe virtual code lines: each step line preceded by arrow? Use \"→ Step X:\" etc.\n\nMake sure to use the arrow and Decision: format.\n\nAlso note memoization: use dictionary.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 memo 為空字典 // 用於快取子表達式結果  \n→ Step 2: 定義遞迴函式 compute(expr) // 計算給定子表達式所有可能結果  \n→ Decision: 如果 expr 在 memo 中? // 檢查是否已計算  \n  Yes → Step 3: Return memo[expr] // 直接回傳快取結果  \n  No →  \n   → Decision: expr 中是否含有運算符? // 判斷是否為單一數字  \n    Yes → Step 4: 初始化 results 為空列表 // 用於儲存所有組合結果  \n     → Step 5: 對 expr 中每個運算符位置 i 進行迴圈  \n      → Step 6: left_expr ← expr[0:i] // 取左子表達式  \n      → Step 7: right_expr ← expr[i+1:] // 取右子表達式  \n      → Step 8: left_results ← compute(left_expr) // 計算左部結果  \n      → Step 9: right_results ← compute(right_expr) // 計算右部結果  \n      → Step 10: 對每個 l 在 left_results  \n       → Step 11: 對每個 r 在 right_results  \n        → Step 12: result ← apply(expr[i], l, r) // 執行對應運算符  \n         → Step 13: results.append(result) // 加入結果  \n      → Step 14: memo[expr] ← results // 將子表達式結果快取  \n      → Step 15: Return results // 回傳所有可能結果  \n    No → Step 16: memo[expr] ← [int(expr)] // 單一數字，轉成整數後回傳  \n     → Step 17: Return memo[expr] // 回傳單一結果  \n→ Step 18: all_results ← compute(input_expr) // 以整個輸入字串為起點計算  \n→ Step 19: 輸出 all_results // 顯示所有可能結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import List, Dict\n\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        memo: Dict[str, List[int]] = {}\n\n        def ways(expr: str) -> List[int]:\n            if expr in memo:\n                return memo[expr]\n\n            res: List[int] = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i + 1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:  # '*'\n                                res.append(l * r)\n\n            if not res:  # no operator found, single number\n                res.append(int(expr))\n\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract the expression string inside quotes if present\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        # Fallback: assume format expression = <expr>\n        parts = data.split('=', 1)\n        expr = parts[1].strip() if len(parts) > 1 else data\n\n    # Compute all possible results\n    solution = Solution()\n    results = solution.diffWaysToCompute(expr)\n\n    # Output the list of results\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[2,0]",
          "success": true,
          "output": "[2, 0]"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-10,-14,-10,10]",
          "success": true,
          "output": "[-34, -10, -14, -10, 10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode260.json",
    "problem_index_in_file": 0,
    "title": "Single Number III",
    "description_snippet": "Given an integer array nums, in which exactly two elements appear only once and all the other elemen...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line with comments. Virtual code arrow, decisions, etc. The algorithm: XOR all elements -> xor of two unique numbers (x^y). Find rightmost set bit. Partition into two groups based on that bit and XOR each group to find unique numbers. Constant space, linear time. So produce pseudocode with steps: Start, Input array, Compute xorAll, Find mask, Initialize num1, num2, For each num, if num & mask -> xor1 else xor2. Output num1,num2. End. Also handle decisions if necessary.\n\nWe must follow format: each line \"虛擬碼步驟 // 解釋\" with arrow. Use \"→\" for steps. Use \"Decision:\" where needed. But we can avoid decisions for simplicity but may include a decision to find rightmost bit? We can do \"Step: Find rightmost set bit\" which is not a decision. So no decision nodes needed. But we can include Decision: Check if bit is set? For partitioning. We'll just use \"Decision: if num & mask?\".\n\nLet's produce steps.\n\nWe'll output:\n\nStart // 程式開始執行\n→ Step 1: 計算所有元素的 XOR (xorAll) // 兩個唯一數字的 XOR\n→ Step 2: 找到 xorAll 中最右邊的 1 位 (mask) // 兩個唯一數字必有不同位\n→ Step 3: 初始化兩個唯一數字變數 num1 = 0, num2 = 0 // 以 0 作為初始值\n→ Step 4: 對陣列中的每個元素進行迴圈\n    → Decision: 如果元素與 mask 的 AND 為 1? // 判斷是否屬於第一組\n        Yes → Step 5: num1 = num1 XOR 元素 // 在第一組中 XOR，最後得到唯一數字\n        No  → Step 5: num2 = num2 XOR 元素 // 在第二組中 XOR，最後得到唯一數字\n→ Step 6: 輸出 num1, num2 // 兩個唯一數字\n\nEnd // 程式執行結束\n\nMake sure each line ends with comment. Use appropriate arrow.\n\nLet's format each line. For nested lines, we can indent? The example uses indentation. We'll replicate.\n\nReturn as plain text.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算所有元素的 XOR (xorAll) // 兩個唯一數字的 XOR  \n→ Step 2: 找到 xorAll 中最右邊的 1 位 (mask) // 兩個唯一數字必有不同位  \n→ Step 3: 初始化兩個唯一數字變數 num1 = 0, num2 = 0 // 以 0 作為初始值  \n→ Step 4: 對陣列中的每個元素進行迴圈  \n  → Decision: 如果元素與 mask 的 AND 為 1? // 判斷屬於哪一組  \n   Yes → Step 5: num1 = num1 XOR 元素 // 在第一組中 XOR，最後得到唯一數字  \n   No  → Step 5: num2 = num2 XOR 元素 // 在第二組中 XOR，最後得到唯一數字  \n→ Step 6: 輸出 num1, num2 // 兩個唯一數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def singleNumber(self, nums):\n        \"\"\"\n        Find the two numbers that appear only once in an array where all\n        other numbers appear exactly twice.\n        \"\"\"\n        xor = 0\n        for num in nums:\n            xor ^= num\n\n        # xor now holds the XOR of the two unique numbers.\n        # Find a bit that is set in xor (at least one bit will differ).\n        diff_bit = xor & -xor  # isolate the rightmost set bit\n\n        a = b = 0\n        for num in nums:\n            if num & diff_bit:\n                a ^= num\n            else:\n                b ^= num\n        return [a, b]\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # The input might be like 'nums = [1,2,1,3,2,5]'\n    # Strip the leading variable name if present\n    if data.startswith(\"nums\"):\n        try:\n            _, nums_str = data.split(\"=\", 1)\n            nums = eval(nums_str.strip())\n        except Exception:\n            # Fallback: try to evaluate the whole string\n            nums = eval(data)\n    else:\n        # Directly evaluate the input as a Python literal\n        nums = eval(data)\n\n    sol = Solution()\n    result = sol.singleNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,3,2,5]",
          "expected_output": "[3,5]",
          "success": true,
          "output": "[3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0]",
          "expected_output": "[-1,0]",
          "success": true,
          "output": "[-1, 0]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,1]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode224.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator",
    "description_snippet": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and r...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for a basic calculator evaluating a string expression, no eval. Should support + - * /. Typically use stack. The problem: evaluate string s. It's likely Leetcode 224 Basic Calculator II. We'll produce pseudocode: parse number, handle signs, use stack for + - * /. We'll produce lines with arrow and explanation.\n\nWe need start, end, decision. We'll produce each step line. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 變數 `stack ← 空堆疊` // 用於暫存數字與運算結果  \n→ Step 2: 變數 `num ← 0` // 目前正在解析的數字  \n→ Step 3: 變數 `sign ← '+'` // 上一次遇到的運算符，預設為加號  \n→ Decision: 如果 s 為空?  \n  Yes → End // 空字串直接結束  \n  No  → Proceed  \n\n→ Step 4: 迴圈 `i ← 0` 到 `i < s.length`  \n  → Decision: s[i] 是數字?  \n   Yes → Step 5: `num ← num * 10 + (s[i] - '0')` // 把數字拼接到 num  \n   No → Decision: s[i] 是空白?  \n    Yes → Continue // 跳過空白字元  \n    No → Decision: s[i] 是運算符 (+ - * /)?  \n     Yes → Step 6:  \n      → Decision: sign 是 '+'?  \n       Yes → Step 7: `stack.push(num)` // 加號：把 num 推入堆疊  \n       No → Decision: sign 是 '-'?  \n        Yes → Step 7: `stack.push(-num)` // 減號：負數推入堆疊  \n        No → Decision: sign 是 '*'?  \n         Yes → Step 7:  \n          → `prev ← stack.pop()`  \n          → `stack.push(prev * num)` // 乘法：先取堆疊頂再乘  \n          No → Decision: sign 是 '/'?  \n           Yes → Step 7:  \n            → `prev ← stack.pop()`  \n            → `stack.push(prev / num)` // 除法：先取堆疊頂再除  \n            No → End // 未預期符號，安全退出  \n              \n          → Step 8: `num ← 0` // 重置 num 以準備下一個數字  \n          → `sign ← s[i]` // 更新 sign 為目前運算符  \n          → Continue  \n          No → End // 未處理的字符，安全退出  \n  → Continue // 結束此迴圈迭代  \n\n→ Step 9: 迴圈結束後，最後一個數字未被處理  \n  → Decision: sign 是 '+'?  \n   Yes → Step 10: `stack.push(num)`  \n   No → Decision: sign 是 '-'?  \n    Yes → Step 10: `stack.push(-num)`  \n    No → Decision: sign 是 '*'?  \n     Yes → Step 10:  \n      → `prev ← stack.pop()`  \n      → `stack.push(prev * num)`  \n      No → Decision: sign 是 '/'?  \n       Yes → Step 10:  \n        → `prev ← stack.pop()`  \n        → `stack.push(prev / num)`  \n\n→ Step 11: 變數 `result ← 0` // 儲存最終結果  \n→ 步驟 `while stack 非空`  \n  → `result ← result + stack.pop()` // 將堆疊中所有數字相加  \n\n→ Step 12: 回傳 `result` // 結果即為表達式的計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        \"\"\"計算只包含 +、-、括號的算式結果。\"\"\"\n        stack = []          # 儲存先前的結果和符號\n        res = 0             # 當前累積的結果\n        num = 0             # 正在解析的數字\n        sign = 1            # 上一次遇到的符號 (+ -> 1, - -> -1)\n\n        i = 0\n        while i < len(s):\n            c = s[i]\n            if c.isdigit():\n                # 把數字拼接起來\n                num = num * 10 + int(c)\n            elif c == ' ':\n                # 空白忽略\n                pass\n            elif c in '+-':\n                # 在遇到 + 或 - 時，先把前面算好的數字加入結果\n                res += sign * num\n                num = 0\n                sign = 1 if c == '+' else -1\n            elif c == '(':\n                # 進入小括號：把目前的結果與符號暫存起來\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                # 小括號結束：把括號內的結果與外部符號結合\n                res += sign * num\n                num = 0\n                res *= stack.pop()     # 括號前的符號\n                res += stack.pop()     # 括號前的累積結果\n            i += 1\n\n        # 最後一個數字還未加入\n        res += sign * num\n        return res\n\ndef parse_input(raw: str) -> str:\n    \"\"\"從原始輸入中抽取算式字串。\"\"\"\n    raw = raw.strip()\n    if raw.startswith('s'):\n        # 例子中輸入為 s = \"...\"\n        start = raw.find('\"')\n        end = raw.rfind('\"')\n        if start != -1 and end != -1 and end > start:\n            return raw[start+1:end]\n    # 若不是上述格式，直接移除雙引號並去除空白\n    return raw.strip().strip('\"')\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    expression = parse_input(raw_input)\n    solution = Solution()\n    result = solution.calculate(expression)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode561.json",
    "problem_index_in_file": 0,
    "title": "Array Partition",
    "description_snippet": "Given an integer array nums of 2n integers, group these integers into n pairs (a_1, b_1), (a_2, b_2)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for algorithm to maximize sum of min of each pair. The optimal strategy is sort array, then sum every other element starting from index 0? Actually to maximize sum of min of pairs, we should pair smallest with next smallest, etc. So sorted ascending, then sum elements at even indices. Provide virtual code steps. Output in required format. Ensure each line with \"虛擬碼步驟 // 解釋\" and arrow syntax. Include Start, End, Decision etc. The algorithm is simple. Need to incorporate sorting. Use Decision? Might not need decisions. Just linear steps. But can include Decision: If length even? etc. We'll produce simple steps.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入整數陣列 nums // 取得包含 2n 個整數的陣列\n→ Step 2: 取得陣列長度 len = nums.length // 取得陣列長度\n→ Decision: 如果 len % 2 != 0? // 檢查長度是否為偶數（符合題目要求）\n    Yes → Step 3: 報錯 \"輸入長度必須為偶數\" // 若長度不為偶數則終止\n    No  → Step 4: 對 nums 進行升序排序 // 將陣列從小到大排列\n→ Step 5: 初始化 sum = 0 // 用於累加最小值的總和\n→ Step 6: 從 i = 0 迭代到 len-1，步長為 2 // 只取偶數索引元素\n    Yes → Step 7: sum = sum + nums[i] // 把 nums[i]（即 pair 的最小值）加入 sum\n    No  → // 循環結束\n→ Step 8: 回傳 sum // 返回最大化後的最小值總和\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def arrayPairSum(self, nums):\n        \"\"\"\n        將陣列升序排序後，累加偶數索引位置的元素即可得到最小值總和的最大值。\n        \"\"\"\n        nums.sort()          # 先排序\n        return sum(nums[::2])  # 取偶數索引的元素相加\n\ndef main():\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 將字串轉換成 Python list\n    # 支援形如 \"[1,4,3,2]\" 的輸入\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # 若輸入格式不符合，直接終止\n        print(\"Invalid input format\")\n        return\n\n    # 確保輸入是列表且長度為偶數\n    if not isinstance(nums, list) or len(nums) % 2 != 0:\n        print(\"Input must be a list of even length\")\n        return\n\n    # 執行解題邏輯\n    solution = Solution()\n    result = solution.arrayPairSum(nums)\n\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,4,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "[6,2,6,5,1,2]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode55.json",
    "problem_index_in_file": 0,
    "title": "Jump Game",
    "description_snippet": "You are given an integer array nums. You are initially positioned at the array's first index, and ea...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for Jump Game problem. Use Start, Decision, etc. Provide one step per line, arrow. Need to include explanation after //.\n\nWe must not produce actual code, only pseudocode lines. Use virtual code style like \"→ Step 1: ...\" etc.\n\nWe need algorithm: greedy O(n) or DP. Use greedy: track farthest reach, iterate index i, if i > farthest then cannot, return false. If farthest >= last index return true.\n\nWe need to output lines:\n\nStart\n→ Step 1: 初始化 farthest = 0 // 起始最遠可達點\n→ Step 2: 取得陣列長度 n // 獲取總長度\n→ Decision: 如果 n == 1? // 只一個元素就已到達終點\n    Yes → Step 3: 回傳 true // 直接成功\n    No → Step 4: 迭代 i 從 0 到 n-1 // 遍歷每個位置\n        → Step 5: 更新 farthest = max(farthest, i + nums[i]) // 更新最遠可達距離\n        → Decision: 如果 farthest >= n-1? // 可以到達最後索引\n            Yes → Step 6: 回傳 true // 成功\n        → Decision: 如果 i > farthest? // 当前位置已超出最遠可達\n            Yes → Step 7: 回傳 false // 無法再前進\n        → Decision: 迭代結束? // 完成遍歷\n            Yes → Step 8: 回傳 true // 已經到達最後\nEnd\n\nBut need to format correctly with arrow and decision indent. Must use arrow → at each step. Decision lines: \"Decision:\" then options with Yes → and No →.\n\nWe also must use End at end.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 farthest = 0 // 設定最遠可達索引為 0  \n→ Step 2: 取得陣列長度 n // n = nums.length  \n→ Decision: 如果 n == 1? // 只剩一個元素就已經在終點  \n  Yes → Step 3: 回傳 true // 直接成功  \n  No  → Step 4: 迭代 i 從 0 到 n-1 // 遍歷所有位置  \n    → Step 5: 更新 farthest = max(farthest, i + nums[i]) // 更新最遠可達距離  \n    → Decision: 如果 farthest >= n-1? // 已經能到達最後一個索引  \n      Yes → Step 6: 回傳 true // 成功  \n      No  → Decision: 如果 i > farthest? // 當前位置超出最遠可達  \n        Yes → Step 7: 回傳 false // 無法再前進  \n        No  → Decision: 迭代結束? // 已遍歷完所有索引  \n         Yes → Step 8: 回傳 true // 完成遍歷後仍可到達終點  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def canJump(self, nums):\n        max_reach = 0\n        n = len(nums)\n        for i in range(n):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\ndef parse_nums(input_str: str):\n    # 找出第一個方括號內的內容並解析為 list\n    match = re.search(r'\\[.*?\\]', input_str)\n    if not match:\n        return []\n    return ast.literal_eval(match.group(0))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_nums(data)\n    sol = Solution()\n    result = sol.canJump(nums)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,0,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode220.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate III",
    "description_snippet": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indice...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line explaining algorithm for checking pairs satisfying conditions. Probably two nested loops with early exit or sliding window + map approach. We'll design simple nested loops for clarity. Provide steps like Start, iterate i, iterate j, check conditions, if found true, output true. At end output false. Include decisions. Let's craft.\n\nWe need virtual code steps: use Start, for i, for j, Decision: i != j? but we can skip self. Decision: abs(i-j) <= indexDiff? then next. Decision: abs(nums[i]-nums[j]) <= valueDiff? then Yes → return true. After loops return false. End.\n\nLet's produce lines with arrow for steps, using \"→\". Use decision lines with Yes/No.\n\nBe careful: Use \"→ Step: ...\". The sample uses \"→ Step 1:\". We can adopt \"→ Step: ...\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 取得輸入數組 nums、整數 indexDiff 與 valueDiff // 準備輸入資料  \n→ Step: 定義變數 n = nums 的長度 // 用於迴圈上限  \n→ Decision: n 是否大於 1? // 若只有一個元素則不可能有 i≠j  \n  Yes → Proceed  \n  No → Step: 回傳 false // 直接結束，無符合條件  \n→ Step: 建立布林變數 found = false // 標記是否找到符合條件的對  \n→ Step: for i 從 0 到 n-1 // 外層迴圈  \n  → Step: for j 從 0 到 n-1 // 內層迴圈  \n     → Decision: i 與 j 是否不同? // 只考慮 i≠j  \n       Yes → Decision: |i-j| 是否小於等於 indexDiff? // 檢查索引差距  \n         Yes → Decision: |nums[i]-nums[j]| 是否小於等於 valueDiff? // 檢查數值差距  \n            Yes → Step: found = true // 找到符合條件的對  \n              → Step: 跳出所有迴圈 // 一旦找到即結束搜尋  \n              No → Continue // 數值差距不符合，繼續下一個 j  \n        No → Continue // 索引差距不符合，繼續下一個 j  \n     No → Continue // i 與 j 相同，繼續下一個 j  \n→ Decision: found 是否為 true? // 判斷是否找到符合條件的對  \n  Yes → Step: 回傳 true // 存在符合條件的索引對  \n  No → Step: 回傳 false // 所有組合檢查完仍無符合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom bisect import bisect_left, insort\n\ndef parse_input(text: str):\n    \"\"\"從輸入文字中解析 nums、indexDiff 與 valueDiff。\"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', text)\n    nums = eval(nums_match.group(1)) if nums_match else []\n\n    idx_match = re.search(r'indexDiff\\s*=\\s*(-?\\d+)', text)\n    index_diff = int(idx_match.group(1)) if idx_match else 0\n\n    val_match = re.search(r'valueDiff\\s*=\\s*(-?\\d+)', text)\n    value_diff = int(val_match.group(1)) if val_match else 0\n\n    return nums, index_diff, value_diff\n\ndef contains_nearby_almost_duplicate(nums, k, t):\n    \"\"\"\n    使用滑動窗口 + 有序列表的做法，時間 O(n log k)。\n    \"\"\"\n    if k <= 0 or t < 0:\n        return False\n\n    window = []  # 有序列表\n    for i, num in enumerate(nums):\n        # 在 window 中尋找最小的 >= num - t 的位置\n        left = bisect_left(window, num - t)\n        # 若此位置在範圍內，且元素與 num 差值 <= t\n        if left < len(window) and abs(window[left] - num) <= t:\n            return True\n\n        # 將目前數字插入窗口\n        insort(window, num)\n\n        # 若窗口長度超過 k，移除最舊的數字\n        if len(window) > k:\n            # nums[i - k] 是最舊的數字，從 window 中刪除\n            remove_val = nums[i - k]\n            remove_idx = bisect_left(window, remove_val)\n            if remove_idx < len(window) and window[remove_idx] == remove_val:\n                window.pop(remove_idx)\n\n    return False\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    nums, index_diff, value_diff = parse_input(raw_input)\n\n    # 呼叫解法並輸出結果\n    result = contains_nearby_almost_duplicate(nums, index_diff, value_diff)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode229.json",
    "problem_index_in_file": 0,
    "title": "Majority Element II",
    "description_snippet": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for finding all elements that appear more than floor(n/3) times. This is essentially Boyer-Moore majority vote for k=3. We should provide steps: 1) candidate selection with two candidates, 2) counting candidates, 3) output those > n/3. We'll follow the format: Start, → Step, → Decision, Yes/No →. Provide each line with explanation comment.\n\nLet's produce pseudocode lines.\n\nLine 1: Start\n\nLine 2: → Initialize candidate1 = None, count1 = 0, candidate2 = None, count2 = 0 // 初始化兩個候選人與計數\n\nLine 3: → For each element num in array // 逐個遍歷數組\n\nLine 4:     → Decision: If num equals candidate1? // 檢查是否匹配候選人1\n\nLine 5:         Yes → Increment count1 // 匹配則計數加一\n\nLine 6:         No → Decision: If num equals candidate2? // 若不匹配候選人1，再檢查候選人2\n\nLine 7:             Yes → Increment count2 // 匹配則計數加一\n\nLine 8:             No → Decision: If count1 == 0? // 若兩個都不匹配，且 count1 為零\n\nLine 9:                 Yes → Set candidate1 = num, count1 = 1 // 重新設定候選人1\n\nLine 10:                 No → Decision: If count2 == 0? // 否則檢查 count2 是否為零\n\nLine 11:                     Yes → Set candidate2 = num, count2 = 1 // 重新設定候選人2\n\nLine 12:                     No → Decrement count1 and count2 // 兩個計數都不為零，遞減\n\nLine 13: → After loop, reset count1 = 0, count2 = 0 // 重新計數以驗證候選人\n\nLine 14: → For each element num in array // 再次遍歷\n\nLine 15:     → Decision: If num equals candidate1? // 確認候選人1\n\nLine 16:         Yes → Increment count1 // 計數\n\nLine 17:         No → Decision: If num equals candidate2? // 確認候選人2\n\nLine 18:             Yes → Increment count2 // 計數\n\nLine 19: → Initialize result list = [] // 用於存儲最終結果\n\nLine 20: → Decision: If count1 > n/3? // 檢查候選人1是否符合條件\n\nLine 21:     Yes → Append candidate1 to result // 添加到結果\n\nLine 22:     No → // 不添加\n\nLine 23: → Decision: If count2 > n/3? // 檢查候選人2\n\nLine 24:     Yes → Append candidate2 to result // 添加\n\nLine 25:     No → // 不添加\n\nLine 26: End // 完成\n\nWe need to include \"Start\" and \"End\" as separate lines. Also ensure each line ends with // comment. Use arrow and decision formatting. Use \"→\" after Start.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize candidate1 = None, count1 = 0, candidate2 = None, count2 = 0 // 初始化兩個候選人與計數  \n→ For each element num in array // 逐個遍歷數組  \n  → Decision: If num equals candidate1? // 檢查是否匹配候選人1  \n    Yes → Increment count1 // 匹配則計數加一  \n    No → Decision: If num equals candidate2? // 若不匹配候選人1，再檢查候選人2  \n      Yes → Increment count2 // 匹配則計數加一  \n      No → Decision: If count1 == 0? // 若兩個都不匹配，且 count1 為零  \n        Yes → Set candidate1 = num, count1 = 1 // 重新設定候選人1  \n        No → Decision: If count2 == 0? // 否則檢查 count2 是否為零  \n          Yes → Set candidate2 = num, count2 = 1 // 重新設定候選人2  \n          No → Decrement count1 and count2 // 兩個計數都不為零，遞減  \n→ After loop, reset count1 = 0, count2 = 0 // 重新計數以驗證候選人  \n→ For each element num in array // 再次遍歷  \n  → Decision: If num equals candidate1? // 確認候選人1  \n    Yes → Increment count1 // 計數  \n    No → Decision: If num equals candidate2? // 確認候選人2  \n      Yes → Increment count2 // 計數  \n→ Initialize result list = [] // 用於存儲最終結果  \n→ Decision: If count1 > n/3? // 檢查候選人1是否符合條件  \n  Yes → Append candidate1 to result // 添加到結果  \n  No → // 不添加  \n→ Decision: If count2 > n/3? // 檢查候選人2  \n  Yes → Append candidate2 to result // 添加  \n  No → // 不添加  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def majorityElement(self, nums):\n        if not nums:\n            return []\n        candidate1, candidate2 = None, None\n        count1, count2 = 0, 0\n        # First pass: find possible candidates\n        for num in nums:\n            if candidate1 == num:\n                count1 += 1\n            elif candidate2 == num:\n                count2 += 1\n            elif count1 == 0:\n                candidate1, count1 = num, 1\n            elif count2 == 0:\n                candidate2, count2 = num, 1\n            else:\n                count1 -= 1\n                count2 -= 1\n        # Second pass: verify candidates\n        result = []\n        n = len(nums)\n        count1 = count2 = 0\n        for num in nums:\n            if num == candidate1:\n                count1 += 1\n            elif num == candidate2:\n                count2 += 1\n        if count1 > n // 3:\n            result.append(candidate1)\n        if count2 > n // 3:\n            result.append(candidate2)\n        return result\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])\n    else:\n        # Extract the list part between '[' and ']'\n        start = raw_input.find('[')\n        end = raw_input.rfind(']')\n        if start == -1 or end == -1 or start > end:\n            nums = []\n        else:\n            list_str = raw_input[start:end+1]\n            try:\n                nums = ast.literal_eval(list_str)\n                if not isinstance(nums, list):\n                    nums = []\n            except Exception:\n                nums = []\n        solution = Solution()\n        result = solution.majorityElement(nums)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "[3]",
          "success": true,
          "output": "[3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode748.json",
    "problem_index_in_file": 0,
    "title": "Shortest Completing Word",
    "description_snippet": "Given a string licensePlate and an array of strings words, find the shortest completing word in word...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps. No actual code. Provide steps line by line with explanations. Should handle ignoring numbers/spaces, case-insensitive, letter counts. Find shortest completing word, tie-breaking by first occurrence. Approach: preprocess licensePlate: count letters ignoring case. Then iterate words; for each word, check if it contains required counts. Keep track of min length and result. Output result. Use Start, Decision, End.\n\nNeed to produce virtual steps. Let's craft:\n\nStart\n→ Step 1: Initialize letterCount array of size 26 to zero // store required letter frequencies from licensePlate\n→ Step 2: For each character ch in licensePlate // preprocess licensePlate\n    → Decision: If ch is alphabetic?\n        Yes → Step 3: Convert ch to lowercase\n        → Step 4: Increment letterCount[ch - 'a']\n        No → Skip // ignore digits/spaces\n→ Step 5: Initialize bestWord = empty string, bestLength = infinity // to store result\n→ Step 6: For each word in words // iterate over candidates\n    → Step 7: Initialize wordCount array of size 26 to zero\n    → Step 8: For each character w in word\n        → Decision: If w is alphabetic?\n            Yes → Step 9: Convert w to lowercase\n            → Step 10: Increment wordCount[w - 'a']\n            No → Skip\n    → Step 11: Initialize isCompleting = true\n    → Step 12: For i from 0 to 25\n        → Decision: If letterCount[i] > wordCount[i]?\n            Yes → Step 13: isCompleting = false\n            → Step 14: Break // insufficient letter\n            No → Continue\n    → Decision: If isCompleting and (bestWord empty or word.length < bestLength)?\n        Yes → Step 15: bestWord = word\n        → Step 16: bestLength = word.length\n        No → Continue // keep current best\n→ Step 17: Return bestWord // shortest completing word\nEnd\n\nWe must ensure each line has `虛擬碼步驟` then space then `// 解釋`. Use the arrows properly.\n\nWe also need to indicate arrow lines. Use \"→\" before steps. For Decision blocks, indent maybe. Use spaces after each arrow line? In example they use \"→ Step 1:\" etc. We'll do same.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize letterCount[26] = 0 // 用於儲存 licensePlate 中每個字母所需的最小出現次數  \n→ Step 2: For each character ch in licensePlate // 逐字母處理 licensePlate  \n  → Decision: 是否為字母?  \n   Yes → Step 3: ch = toLowerCase(ch) // 轉為小寫，忽略大小寫差異  \n    → Step 4: letterCount[ch - 'a']++ // 記錄字母頻次  \n   No → Skip // 直接忽略數字、空格等非字母字符  \n→ Step 5: bestWord = \"\" // 儲存目前最短符合條件的單字  \n→ Step 6: bestLen = Infinity // 最短長度初始為無限大  \n→ Step 7: For each word in words // 逐一檢查每個候選單字  \n  → Step 8: Initialize wordCount[26] = 0 // 該單字內字母頻次  \n  → Step 9: For each character w in word  \n    → Decision: 是否為字母?  \n     Yes → Step 10: w = toLowerCase(w) // 轉小寫  \n      → Step 11: wordCount[w - 'a']++ // 記錄頻次  \n     No → Skip // 忽略非字母字符  \n  → Step 12: isCompleting = true // 假設此單字符合條件  \n  → Step 13: For i from 0 to 25  \n    → Decision: letterCount[i] > wordCount[i]?  \n     Yes → Step 14: isCompleting = false // 不符合需求  \n      → Break // 直接跳出循環  \n    No → Continue // 依然符合  \n  → Decision: isCompleting AND (bestWord ==\"\" OR word.length < bestLen)?  \n   Yes → Step 15: bestWord = word // 更新最短符合條件的單字  \n     → Step 16: bestLen = word.length  \n   No → Skip // 保留現有最短單字  \n→ Step 17: Return bestWord // 回傳最短符合條件的單字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def shortestCompletingWord(self, licensePlate: str, words: list[str]) -> str:\n        # Count required letters from licensePlate (case‑insensitive)\n        plate_count = Counter(c.lower() for c in licensePlate if c.isalpha())\n\n        best_word = None\n        best_len = float('inf')\n        for word in words:\n            word_count = Counter(word)\n            # Check if all required letters are present enough times\n            if all(word_count[c] >= plate_count[c] for c in plate_count):\n                if len(word) < best_len:\n                    best_word = word\n                    best_len = len(word)\n        return best_word\n\ndef parse_input(data: str):\n    \"\"\"Parse the single line input into licensePlate string and list of words.\"\"\"\n    # Pattern matches: licensePlate = \"string\", words = [\"word1\",\"word2\",...]\n    pattern = r'licensePlate\\s*=\\s*\"([^\"]*)\",\\s*words\\s*=\\s*\\[(.*?)\\]'\n    m = re.search(pattern, data, re.DOTALL)\n    if not m:\n        raise ValueError(\"Input format is incorrect\")\n    license_plate = m.group(1)\n    words_part = m.group(2)\n    # Extract each word inside double quotes\n    words = re.findall(r'\"([^\"]*)\"', words_part)\n    return license_plate, words\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    license_plate, words = parse_input(data)\n    solver = Solution()\n    result = solver.shortestCompletingWord(license_plate, words)\n    # Output in the same format as examples: with surrounding double quotes\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]",
          "expected_output": "\"steps\"",
          "success": true,
          "output": "\"steps\""
        },
        {
          "example_index": 1,
          "input": "licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]",
          "expected_output": "\"pest\"",
          "success": true,
          "output": "\"pest\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode136.json",
    "problem_index_in_file": 0,
    "title": "Single Number",
    "description_snippet": "Given a non-empty array of integers nums, every element appears twice except for one. Find that sing...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with line-by-line steps, using the arrow format, etc. The task: find single element in array where all others appear twice. Use XOR. Linear time, constant space. So pseudo-code: Start; Step: Initialize result = 0; For each num in nums: result = result XOR num; End loop; Output result; End.\n\nWe must output in lines each with virtual code and comment.\n\nUse arrow '→', 'Start', 'End', 'Decision:' only needed maybe for loops. For loop use '→ Step 1: 初始化 result = 0 // ...' then '→ Step 2: for each num in nums: result = result XOR num // ...' but need loop structure; maybe '→ Decision: nums not empty? // ensures array non-empty' but we can skip as given non-empty.\n\nBetter: Use '→ Step 1: 初始化 result = 0 // 起始 XOR 結果為 0' then '→ Step 2: 循環遍歷 nums: result = result XOR num // 逐個 XOR，重複的元素會抵消' then '→ Step 3: 輸出 result // result 即為唯一元素' End.\n\nWe must keep 'Start' and 'End' lines.\n\nWe need to ensure each line: \"虛擬碼步驟 [space] // 解釋\". Use '→' arrow for each step except Start and End? In sample they used 'Start', '→ Step 1', etc. So we follow.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化 XOR 結果為 0\n→ Step 2: for each num in nums do result ← result XOR num // 逐一 XOR，重複元素抵消\n→ Step 3: return result // result 即為唯一出現一次的元素\nEnd // 程式執行結束\n\nWe must ensure using \"←\" arrow for assignment, but sample uses colon. Use assignment \"←\" for clarity. Or \"result = 0\". We'll use \"←\" as assignment.\n\nAlso the loop: \"for each num in nums do ...\".\n\nLet's produce that.\n\nEnsure each line ends with comment. Good.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化 XOR 結果為 0\n→ Step 2: for each num in nums do result ← result XOR num // 逐一 XOR，重複元素抵消\n→ Step 3: return result // result 即為唯一出現一次的元素\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list part from input like 'nums = [1,2,3]'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # If no brackets, try to evaluate entire data\n        try:\n            nums = ast.literal_eval(data)\n        except Exception:\n            nums = []\n    else:\n        nums_str = data[start:end+1]\n        try:\n            nums = ast.literal_eval(nums_str)\n        except Exception:\n            nums = []\n\n    sol = Solution()\n    result = sol.singleNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,1,2,1,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1991.json",
    "problem_index_in_file": 0,
    "title": "Find the Middle Index in Array",
    "description_snippet": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for finding leftmost middle index. Provide line by line virtual code with comments. Should not produce actual code, just virtual. Use arrows etc. We need to design algorithm: compute prefix sums or cumulative sums. Then iterate indices, maintain left sum and right sum. Right sum can be total sum - left sum - current element. Or maintain right sum separately. We can compute total sum first, then loop, updating left sum. For each index, if left sum == total sum - left sum - nums[i], record and return earliest index. If none, return -1.\n\nAlso consider boundary cases: left sum initially 0, right sum initially total sum. In loop: for index i, right sum = total sum - left sum - nums[i]; check equality. Then add nums[i] to left sum after checking? Actually before adding, left sum is sum of elements before i, right sum is sum after i. So compute equality before adding nums[i] to left sum. Then after check, left sum += nums[i].\n\nAlternatively compute prefix sums.\n\nWe'll produce virtual code. Need start, decisions, loops. Use \"Start\", \"→\" for each step. Provide comments.\n\nWe'll produce something like:\n\nStart\n→ Step 1: Compute totalSum = sum of all elements in nums // 計算陣列總和\n→ Step 2: Set leftSum = 0 // 左側已處理元素之和，起始為 0\n→ Step 3: For each index i from 0 to nums.length-1 // 逐一檢查每個位置\n    → Decision: Compute rightSum = totalSum - leftSum - nums[i] // 右側和\n        → Decision: If leftSum == rightSum? // 判斷是否為中間索引\n            Yes → Step 4: Return i // 找到左邊最小的中間索引\n            No  → Step 5: leftSum += nums[i] // 更新左側和，繼續下一個索引\n→ Step 6: Return -1 // 沒有找到符合條件的索引\nEnd\n\nBut we need to adhere to format: each line as \"虛擬碼步驟 // 解釋\". Use arrows for decisions. Also indent decisions properly. The format example shows indentation with spaces.\n\nWe should produce something like:\n\nStart // 程式開始執行\n→ Step 1: 計算 totalSum = sum(nums) // 求陣列總和\n→ Step 2: 初始化 leftSum = 0 // 左側已處理元素之和\n→ Step 3: 循環 i 從 0 到 nums.length-1 // 逐個檢查索引\n    → Decision: 計算 rightSum = totalSum - leftSum - nums[i] // 右側元素之和\n        → Decision: 是否 leftSum == rightSum? // 判斷是否為中間索引\n            Yes → Step 4: 返回 i // 找到最左側中間索引\n            No  → Step 5: 更新 leftSum += nums[i] // 加入目前元素到左側和\n→ Step 6: 返回 -1 // 未找到任何中間索引\nEnd // 程式結束\n\nMake sure each line ends with comment. Use arrow \"→\" for steps, \"Decision:\" for decisions. The \"Yes →\" and \"No →\" lines inside decisions. Indentation with spaces. Provide each line.\n\nAlso we need to include \"Start\" and \"End\". Possibly include \"Return\" as step. Also include \"Compute totalSum\" step. The line numbering optional? The example didn't include numbers, just steps.\n\nLet's craft accordingly.\n\nWe'll output each line.\n\nCheck format: \"虛擬碼步驟 [空格] // 解釋\". The arrow and decisions also considered part of virtual code. We must maintain consistent indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 totalSum = sum(nums) // 求陣列所有元素之總和  \n→ Step 2: 初始化 leftSum = 0 // 左側已處理元素之和，初始為 0  \n→ Step 3: 循環 i 從 0 到 nums.length-1 // 逐個檢查每個索引  \n    → Decision: 計算 rightSum = totalSum - leftSum - nums[i] // 右側元素之和  \n        → Decision: 是否 leftSum == rightSum? // 判斷是否為中間索引  \n            Yes → Step 4: 返回 i // 找到左邊最小的中間索引，立即結束  \n            No  → Step 5: 更新 leftSum += nums[i] // 加入目前元素到左側和，繼續下一個索引  \n→ Step 6: 返回 -1 // 未找到任何符合條件的索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMiddleIndex(self, nums):\n        total = sum(nums)\n        left_sum = 0\n        for i, num in enumerate(nums):\n            if left_sum == total - left_sum - num:\n                return i\n            left_sum += num\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit()\n    # 尋找第一個 '[' 與最後一個 ']'，並從中提取列表字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        # 若找不到合法的列表，直接輸出 -1\n        print(-1)\n        sys.exit()\n    list_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 解析失敗也回傳 -1\n        print(-1)\n        sys.exit()\n    solution = Solution()\n    result = solution.findMiddleIndex(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-1,8,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,-1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,5]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode520.json",
    "problem_index_in_file": 0,
    "title": "Detect Capital",
    "description_snippet": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll le...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, no real code, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. Provide steps for algorithm to check capital usage. Provide step-by-step algorithm:\n\nStart\n→ Step 1: Determine length n // Get string length\n→ Decision: n == 0? maybe skip but not necessary\n→ Step 2: Check if all characters are uppercase\n→ Decision: if true → Step 3: return true // All uppercase\n→ Step 4: Check if all characters are lowercase\n→ Decision: if true → Step 5: return true // All lowercase\n→ Step 6: Check if first char uppercase and rest lowercase\n→ Decision: if true → Step 7: return true\n→ Step 8: return false\nEnd\n\nBut each step could involve loops; we can break into more detailed steps. Provide each line with arrow.\n\nWe need to use arrow \"→\" for normal flow, \"Yes →\", \"No →\". Each step explanation.\n\nLet's produce.\n\nNote: We can include loops: Step 2: Set flagAllUpper = true; Step 3: For i from 0 to n-1: if char not uppercase, flagAllUpper = false; break; etc.\n\nSimpler: We'll describe logic using decisions: Check if first letter uppercase? etc.\n\nBetter: Use three cases: case 1: all uppercase, case 2: all lowercase, case 3: first uppercase rest lowercase. We'll implement like:\n\n→ Step 1: Initialize flags allUpper=true, allLower=true, firstUpperRestLower=true // flags\n\n→ Step 2: For each index i from 0 to n-1:\n→ Decision: If i==0 then:\n→ Decision: Is first char uppercase? \n→ Yes → keep firstUpperRestLower\n→ No → set firstUpperRestLower=false\n→ Step 3: If char uppercase? set allLower=false\n→ If char lowercase? set allUpper=false\n→ End for loop\n\n→ Decision: If allUpper or allLower or firstUpperRestLower? return true else false.\n\nSimplify.\n\nBut need to show step by step. Provide each line as a step.\n\nLet's produce final virtual code accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得字串長度 n // 先確定字串長度\n→ Step 2: 初始化三個布林旗標\n  allUpper = true // 是否全為大寫\n  allLower = true // 是否全為小寫\n  firstUpperRestLower = true // 是否首字母大寫其餘小寫\n// 三個旗標初始均為 true，隨後逐字檢查更新\n→ Step 3: 從 i = 0 開始迭代至 i = n-1 // 遍歷每個字元\n  Decision: i == 0? // 第一個字元\n   Yes → Decision: 第一個字元是否為大寫？\n    Yes → firstUpperRestLower 保持 true // 首字母符合規則\n    No  → firstUpperRestLower = false // 首字母不是大寫，取消此規則\n   No  → // 非首字元\n    Decision: 此字元是否為大寫？\n     Yes → allLower = false // 若有大寫字元，不能全小寫\n     No  → allUpper = false // 若有小寫字元，不能全大寫\n// 迴圈結束後三個旗標已反映整個字串的大小寫特徵\n→ Step 4: Decision: allUpper 或 allLower 或 firstUpperRestLower?\n  Yes → Step 5: 回傳 true // 至少滿足一個規則\n  No  → Step 6: 回傳 false // 都不符合，大小寫用法錯誤\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef detectCapitalUse(word: str) -> bool:\n    \"\"\"\n    判斷字串 word 的大小寫用法是否正確。\n    只要符合下列三種情況之一就回傳 True：\n    1. 全部大寫\n    2. 全部小寫\n    3. 首字母大寫，其餘小寫\n    \"\"\"\n    return word.isupper() or word.islower() or word.istitle()\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，移除可能存在的引號與空白，\n    判斷大小寫用法，並以小寫字串 'true' / 'false' 送出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入被引號包住，將引號移除\n    if (data[0] == '\"' and data[-1] == '\"') or (data[0] == \"'\" and data[-1] == \"'\"):\n        data = data[1:-1]\n\n    word = data.strip()\n    result = detectCapitalUse(word)\n    # print 以小寫字串形式輸出，符合題目示例\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"USA\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"FlaG\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode171.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Number",
    "description_snippet": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code step by step with explanations. Use the given format: each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision. We need to handle string columnTitle. For each character compute value: for each letter, convert to number: ord(letter)-ord('A')+1, multiply accumulator by 26, add value. Then output number. We need to show loop over characters. Use Decision to handle loop condition. Use variables: result = 0, index = 0, length = length(columnTitle). Use while index < length. Each iteration: char = columnTitle[index]; value = char->number; result = result * 26 + value; index++. After loop, output result. Provide pseudo-code. Ensure each line has arrow. Use Start. Use Decision. Also include step to convert char to number. Use string indexing. Provide explanation.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result = 0 // 記錄最終列號\n→ Step 2: 初始化 index = 0 // 記錄目前字元位置\n→ Step 3: 計算 length = length(columnTitle) // 取得字串長度\n→ Decision: 如果 index < length? // 判斷是否還有字元要處理\n    Yes →\n        → Step 4: char = columnTitle[index] // 取出目前字元\n        → Step 5: value = (ASCII(char) - ASCII('A') + 1) // 將字母轉為數值 1~26\n        → Step 6: result = result * 26 + value // 更新列號\n        → Step 7: index = index + 1 // 移至下一字元\n        → Decision: 返回 Decision: 如果 index < length? // 重新檢查\n            Yes → 重複步驟 4-7\n            No →\n        // Loop ends\n    No →\n→ Step 8: 輸出 result // 回傳最終列號\nEnd // 程式執行結束\n\nBut we need to format each line with arrow. For loops, we use Decision and Yes/No. The \"重複步驟 4-7\" we can indicate as \"→ Decision: ...\". But it's okay to show that the loop goes back to Decision. Also, each line should have a single virtual step, not group. The decision block should contain nested lines.\n\nLet's write in full:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化列號為 0\n→ Step 2: index ← 0 // 初始化索引為 0\n→ Step 3: length ← length(columnTitle) // 取得字串長度\n→ Decision: index < length? // 是否還有字元需要處理\n    Yes →\n        → Step 4: char ← columnTitle[index] // 取得目前字元\n        → Step 5: value ← (ASCII(char) - ASCII('A') + 1) // 把字母轉成數值 1-26\n        → Step 6: result ← result * 26 + value // 更新列號\n        → Step 7: index ← index + 1 // 移動到下一個字元\n        → Decision: index < length? // 檢查是否還有字元\n            Yes → (回到 Step 4)\n            No →\n    No →\n→ Step 8: output result // 回傳最終列號\nEnd // 程式執行結束\n\nNeed to ensure each line has arrow. For nested decision we indent? It's okay. Each line: \"→ Step 4: ...\". For decision: \"→ Decision: ...\". For nested decisions, we indent lines. Provide explanation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 初始化最終列號為 0  \n→ Step 2: index ← 0 // 初始化字串索引為 0  \n→ Step 3: length ← length(columnTitle) // 取得輸入字串長度  \n→ Decision: index < length? // 判斷是否還有字元待處理  \n  Yes →  \n   → Step 4: char ← columnTitle[index] // 取得目前字元  \n   → Step 5: value ← (ASCII(char) - ASCII('A') + 1) // 把字母轉為 1~26 的數值  \n   → Step 6: result ← result * 26 + value // 更新列號  \n   → Step 7: index ← index + 1 // 移至下一字元  \n   → Decision: index < length? // 再次檢查是否還有字元  \n    Yes → 回到 Step 4  \n    No →  \n  No →  \n→ Step 8: output result // 回傳最終列號  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        \"\"\"\n        將 Excel 標題轉成對應的列號。\n        方法：從左到右遍歷字母，將每個字母轉為 1~26 的數值，\n        並以 26 為基底累加得到最終結果。\n        \"\"\"\n        result = 0\n        for char in columnTitle:\n            result = result * 26 + (ord(char) - ord('A') + 1)\n        return result\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入，解析出 columnTitle 的值，呼叫 Solution.titleToNumber，\n    並將結果輸出到標準輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 期望輸入格式類似:  columnTitle = 'A'  或  'AB'\n    title = None\n    if '=' in data:\n        _, value = data.split('=', 1)\n        value = value.strip()\n    else:\n        value = data\n\n    # 去除可能存在的單引號或雙引號\n    if (value.startswith(\"'\") and value.endswith(\"'\")) or (value.startswith('\"') and value.endswith('\"')):\n        title = value[1:-1]\n    else:\n        title = value\n\n    solution = Solution()\n    print(solution.titleToNumber(title))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnTitle = 'A'",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "columnTitle = 'AB'",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 2,
          "input": "columnTitle = 'ZY'",
          "expected_output": "701",
          "success": true,
          "output": "701"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode39.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum",
    "description_snippet": "Given an array of distinct integers candidates and a target integer target, return a list of all uni...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for backtracking combination sum. Each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Provide line-by-line. Let's generate algorithm:\n\nStart\n→ Read candidates array\n→ Read target\n→ Sort candidates (optional)\n→ Initialize result list\n→ Define recursive function backtrack(start, combination, remaining)\n    → Decision: remaining == 0? → Yes: add copy of combination to result\n    → Decision: remaining < 0? → Yes: return (prune)\n    → For i from start to len(candidates)-1:\n        → Append candidates[i] to combination\n        → backtrack(i, combination, remaining - candidates[i]) // allow reuse\n        → Remove last element from combination (backtrack)\n→ Call backtrack(0, [], target)\n→ Return result\nEnd\n\nBut we need to produce each line as \"虛擬碼步驟 // 解釋\".\n\nLet's produce step by step. Use arrows. For function definition maybe we can write \"→ Function backtrack(start, combination, remaining)\".\n\nAlso need to use \"Decision:\" lines. Use indentation? The example uses indentation but not required; but can use tab/spaces.\n\nLet's produce with \"→\" each step. Use consistent style. Let's produce pseudocode.\n\nBe careful: each line must be one line with \"虛擬碼步驟\" then a space then \"// 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 candidates 數組 // 取得候選整數陣列  \n→ Step 2: 輸入 target 整數 // 目標和  \n→ Step 3: result ← 空列表 // 用來存放所有符合的組合  \n→ Step 4: 輸入 candidates 之後按升序排序 // 為方便剪枝  \n→ Step 5: 定義遞迴函式 backtrack(start, combination, remaining) // 計算組合  \n\n    → Decision: remaining = 0? // 檢查是否已達到目標  \n        Yes → Step 5a: result ← result ∪ {combination的複本} // 存入完整組合  \n        No → Decision: remaining < 0? // 檢查是否超過目標  \n            Yes → Step 5b: return // 超過目標，結束此路徑  \n            No → Step 5c: 從 start 開始遍歷 candidates  \n\n                → For i from start to len(candidates)-1: // 選擇候選數  \n                    → Step 5c1: combination ← combination ∪ {candidates[i]} // 加入目前數字  \n                    → Step 5c2: backtrack(i, combination, remaining - candidates[i]) // 允許重複使用同一數字  \n                    → Step 5c3: combination ← combination - {最後一個元素} // 回溯，移除最後加入的數字  \n\n→ Step 6: backtrack(0, 空組合, target) // 開始遞迴搜索  \n→ Step 7: return result // 回傳所有獨特組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 解析 candidates 列表\n    cand_match = re.search(r'candidates\\s*=\\s*(\\[.*?\\])', data)\n    # 解析 target 整數\n    tgt_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if not cand_match or not tgt_match:\n        print(\"[]\")\n        sys.exit(0)\n\n    candidates = ast.literal_eval(cand_match.group(1))\n    target = int(tgt_match.group(1))\n\n    # 進行組合計算\n    solution = Solution()\n    result = solution.combinationSum(sorted(candidates), target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "success": true,
          "output": "[[2, 2, 3], [7]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "success": true,
          "output": "[[2, 2, 2, 2], [2, 3, 3], [3, 5]]"
        },
        {
          "example_index": 2,
          "input": "candidates = [2], target = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode525.json",
    "problem_index_in_file": 0,
    "title": "Contiguous Array",
    "description_snippet": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Use Start, Decision etc. Use arrow. Use \"→\". Provide steps for solution: treat 0 as -1, prefix sum, hash map to store first index of each sum. Keep max length. Then End.\n\nLet's produce lines:\n\nStart // start\n→ Step 1: 初始化哈希表 sumIndexMap = {0: -1} // sum 0 first seen before array start\n→ Step 2: 初始化變量 sum = 0 // prefix sum\n→ Step 3: 初始化變量 maxLen = 0 //最大長度\n→ Step 4: 循環遍歷 nums 並獲取索引 i 和元素 val //遍歷陣列\n    → Step 4a: sum += (val == 0 ? -1 : 1) //將0視為-1，1視為+1更新前綜合和\n    → Decision: sum 是否已存在於 sumIndexMap? //檢查前綜合和是否重複\n        Yes → Step 4b: currentLen = i - sumIndexMap[sum] //計算子陣列長度\n        Yes → Decision: currentLen > maxLen? //是否比目前最大長度長\n            Yes → Step 4c: maxLen = currentLen //更新最大長度\n            No  → //不更新\n        No  → Step 4d: sumIndexMap[sum] = i //首次遇到此前綜合和，記錄索引\n→ End //結束，maxLen即為答案\n\nNeed to include explanations after //.\n\nMake sure each line has \"→\" for steps, except Start and End lines.\n\nUse \"Decision:\" for decision.\n\nOk. Provide.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化哈希表 sumIndexMap = {0: -1} // 前綜合和 0 首次出現在虛擬位置 -1  \n→ Step 2: 初始化變量 sum = 0 // 追蹤從開始到目前為止的前綜合和  \n→ Step 3: 初始化變量 maxLen = 0 // 目前發現的最大等長子陣列長度  \n→ Step 4: 循環遍歷 nums，取得索引 i 和元素 val // 逐個檢查陣列元素  \n    → Step 4a: sum += (val == 0 ? -1 : 1) // 把 0 視為 -1，1 視為 +1，更新前綜合和  \n    → Decision: sum 是否已存在於 sumIndexMap? // 判斷此前綜合和是否已見過  \n        Yes → Step 4b: currentLen = i - sumIndexMap[sum] // 計算從前一次出現到現在的子陣列長度  \n        Yes → Decision: currentLen > maxLen? // 檢查是否超過目前最大長度  \n            Yes → Step 4c: maxLen = currentLen // 更新最大長度  \n            No  → // 無需更新，保持現有 maxLen  \n        No  → Step 4d: sumIndexMap[sum] = i // 首次遇到此前綏和，記錄其索引  \n→ End // 程式執行結束，maxLen 即為答案。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxLength(self, nums):\n        # 用字典記錄前綜合和第一次出現的索引\n        count_map = {0: -1}\n        max_len = 0\n        count = 0\n        for i, num in enumerate(nums):\n            # 把 0 視為 -1，1 視為 +1\n            count += 1 if num == 1 else -1\n            if count in count_map:\n                # 已經遇過相同的前綜合和，計算子陣列長度\n                max_len = max(max_len, i - count_map[count])\n            else:\n                # 首次遇到此前綜合和，記錄索引\n                count_map[count] = i\n        return max_len\n\ndef main():\n    # 從標準輸入讀取整個輸入，並去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 解析輸入為 Python 列表\n    nums = ast.literal_eval(raw_input)\n    solution = Solution()\n    result = solution.findMaxLength(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[0,1,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,1,1,1,1,1,0,0,0]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode207.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the classic course schedule problem (detect cycle in directed graph). Use DFS or Kahn's algorithm. Provide step-by-step pseudocode lines with explanations. Ensure we use Start, End, Decision: and arrow. Each line: \"Step X: ...\" and comment. We need to handle input: numCourses, prerequisites list. Provide pseudocode that uses adjacency list and visited state arrays: 0=unvisited, 1=visiting, 2=visited. Then DFS each node. If cycle detected return false else true.\n\nLet's write lines:\n\nStart // program starts\n→ Step 1: Build adjacency list from prerequisites // create graph\n→ Step 2: Initialize visited array of size numCourses with 0 // all unvisited\n→ Decision: For each course from 0 to numCourses-1? // iterate courses\n    Yes → Step 3: If visited[course] == 0, call DFS(course) // start DFS\n    No  → // nothing\n→ Step 4: If DFS returned false for any course, set result false else true // track cycle detection\n→ End // output result\n\nBut need to incorporate DFS function as separate block.\n\nLet's create a function DFS(course):\n\nDFS(course):\n→ Step 5: Set visited[course] = 1 // mark as visiting\n→ Decision: For each neighbor in adjacency[course]? // iterate prerequisites\n    Yes → Step 6: If visited[neighbor] == 1, return false // cycle found\n    No → Decision: If visited[neighbor] == 0? // not visited\n        Yes → Step 7: If DFS(neighbor) == false, return false // propagate cycle\n        No → // already visited, continue\n→ Step 8: Set visited[course] = 2 // mark as finished\n→ Step 9: Return true // no cycle in this path\n\nAlso need to handle result accumulation.\n\nSimplify: Use global flag cycleFound. In pseudocode, when DFS returns false, we set flag and break.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: Create adjacency list adj of size numCourses // 建立鄰接表\n→ Step 2: For each pair [a,b] in prerequisites: adj[b].add(a) // 邏輯: b 必須先於 a\n→ Step 3: Initialize visited array of length numCourses with 0 // 0=未訪問,1=正在訪問,2=已完成\n→ Step 4: Set canFinish = true // 預設可完成\n→ Decision: For course from 0 to numCourses-1? // 遍歷所有課程\n    Yes → Step 5: If visited[course] == 0 and canFinish == true, call DFS(course) // 開始 DFS\n    No  → // nothing\n→ Step 6: Return canFinish // 結果\n\nDFS(course):\n→ Step 7: visited[course] = 1 // 標記為正在訪問\n→ Decision: For each next in adj[course]? // 遍歷相鄰節點\n    Yes → Step 8: If visited[next] == 1, set canFinish = false; return // 循環檢測\n    No  → Decision: If visited[next] == 0? // 未訪問\n        Yes → Step 9: Call DFS(next); if canFinish == false return // 早期退出\n        No → // 已完成，繼續\n→ Step 10: visited[course] = 2 // 標記為已完成\n→ Step 11: Return // 完成 DFS\n\nBut need to keep global canFinish. Alternatively, DFS returns boolean.\n\nLet's produce final pseudo:\n\nStart\n→ Step 1: Initialize adjacency list adj[0..numCourses-1] as empty lists // 建立圖\n→ Step 2: For each pair [a,b] in prerequisites: add a to adj[b] // b 必須先於 a\n→ Step 3: visited[0..numCourses-1] = 0 // 0=未訪問,1=正在訪問,2=已完成\n→ Step 4: result = true // 預設能完成\n→ Decision: For course from 0 to numCourses-1? // 检查所有課程\n    Yes → Step 5: If visited[course] == 0, call DFS(course) // 未訪問的課程\n    No  → // 已訪問，跳過\n→ Step 6: Return result // 輸出是否能完成所有課程\n\nDFS(course):\n→ Step 7: visited[course] = 1 // 標記為「正在訪問」\n→ Decision: For neighbor in adj[course]? // 遍歷後續課程\n    Yes → Step 8: If visited[neighbor] == 1, result = false; return // 找到循環\n    No  → Decision: If visited[neighbor] == 0? // 還未訪問\n        Yes → Step 9: Call DFS(neighbor); if result == false return // 传播失敗\n        No → // 已完成，繼續\n→ Step 10: visited[course] = 2 // 標記為「已完成」\n→ Step 11: Return // DFS 完成\n\nWe should also include \"End\" after step 6.\n\nBut also need to include \"End\" after DFS? Since DFS is a subroutine, we might not need to add End. But we can add an \"End DFS\" line maybe. But keep simple.\n\nWe must use the specified format: each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow \"→\" before each step except Start and End? In example, they had Start then arrow then steps. So we follow that. Use \"Decision:\" for if statements, \"Yes →\" and \"No →\".\n\nMake sure to include \"Start\" and \"End\". Provide the pseudocode lines accordingly. Also need to use \"Step 1:\" etc. The example uses \"Step 1:\" preceded by arrow? The example: \"→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\". So we will follow same.\n\nAlso include \"→ End // 程式執行結束\" after final return.\n\nWe need to include subroutine indentation. In example, they didn't indent sub-steps. They just used decisions within decisions. So we will structure:\n\nStart\n→ Step 1: ...\n→ Step 2: ...\n→ Step 3: ...\n→ Step 4: ...\n→ Decision: For course from 0 to numCourses-1? \n    Yes → Step 5: ...\n    No  → ...\n→ Step 6: Return result\n→ End\n\nDFS(course):\n→ Step 7: ...\n→ Decision: For neighbor in adj[course]?\n    Yes → Step 8: ...\n    No  → Decision: ...\n        Yes → Step 9: ...\n        No → ...\n→ Step 10: ...\n→ Step 11: Return\n\nBut we also need to include \"End\" after main flow. Might not need \"End\" for subroutine but maybe \"End DFS\".\n\nWe must keep each line separated by newline. Provide final answer in Chinese.\n\nLet's craft final pseudocode lines. Use \"虛擬碼步驟\" not necessary but we can just write the pseudocode.\n\nBe careful to include \"Decision:\" lines and Yes/No arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 adjacency list adj[0..numCourses-1] 為空列表 // 建立圖  \n→ Step 2: 對每個 pair [a, b] in prerequisites: adj[b].add(a) // b 必須先於 a  \n→ Step 3: visited[0..numCourses-1] = 0 // 0=未訪問,1=正在訪問,2=已完成  \n→ Step 4: result = true // 預設能完成所有課程  \n→ Decision: 是否有 course 從 0 到 numCourses-1？ // 遍歷所有課程  \n  Yes → Step 5: 若 visited[course] == 0，則呼叫 DFS(course) // 未訪問則開始 DFS  \n  No  → // 已遍歷完所有課程  \n→ Step 6: Return result // 回傳是否能完成所有課程  \n→ End // 程式執行結束  \n\nDFS(course): // 子程序，檢查是否存在循環  \n → Step 7: visited[course] = 1 // 標記為「正在訪問」  \n → Decision: 是否有 neighbor 在 adj[course]？ // 遍歷後續課程  \n  Yes → Step 8: 若 visited[neighbor] == 1，則 result = false 並 Return // 找到循環  \n  No  → Decision: visited[neighbor] == 0？ // 還未訪問  \n    Yes → Step 9: 呼叫 DFS(neighbor)；若 result == false 則 Return // 及時傳遞失敗  \n    No  → // 已完成，繼續遍歷其他 neighbor  \n → Step 10: visited[course] = 2 // 標記為「已完成」  \n → Step 11: Return // DFS 完成，返回上層  \n\n（以上虛擬碼以逐行方式說明了建立圖、深度優先搜尋與循環偵測的流程。)",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return visited == numCourses\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n\n    # Extract numCourses\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    if not num_match:\n        print(\"false\")\n        sys.exit(0)\n    numCourses = int(num_match.group(1))\n\n    # Extract prerequisites list\n    prereq_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data, re.S)\n    if prereq_match:\n        prereq_str = prereq_match.group(1)\n        try:\n            prerequisites = ast.literal_eval(prereq_str)\n        except Exception:\n            prerequisites = []\n    else:\n        prerequisites = []\n\n    solution = Solution()\n    result = solution.canFinish(numCourses, prerequisites)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode459.json",
    "problem_index_in_file": 0,
    "title": "Repeated Substring Pattern",
    "description_snippet": "Given a string s, check if it can be constructed by taking a substring of it and appending multiple ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode line by line, no actual code. It's a typical problem: given a string s, determine if it can be constructed by repeating a substring. Approach: find smallest length divisor of string length where substring repeated forms s. Or iterate over possible substring lengths.\n\nWe produce pseudocode:\n\nStart\n→ Step 1: Compute length n of s\n→ Step 2: For each possible substring length len from 1 to n/2:\n   → Decision: If n mod len == 0? // Only consider lengths dividing n\n       Yes → Step 3: Extract candidate substring t = first len chars\n       → Step 4: Build repeated string repeated = t repeated (n/len) times\n       → Decision: If repeated == s? // Check if repeats form original\n           Yes → Step 5: Return true // Found repeating pattern\n           No  → Continue loop\n   No → Continue loop\n→ Step 6: Return false // No pattern found\nEnd\n\nWe should also possibly include early exit. The pseudocode can use loops and conditions. Use Decision and Yes/No. Provide brief explanations after //.\n\nWe need to follow output format: each line includes \"虛擬碼步驟\" and \"// 解釋/說明\". Use arrow '→', 'Decision:' etc.\n\nWe must ensure to not output actual code. Use descriptive steps. Let's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 計算字串 s 的長度 n // 取得總字元數\n→ Step 2: 從 1 到 n/2 逐個檢查可能的子字串長度 len // 確定候選子字串長度\n    → Decision: 如果 n mod len == 0? // 只考慮能整除總長度的長度\n        Yes → Step 3: 取前 len 個字元作為候選子字串 t // 取得可能重複的基底\n        → Step 4: 將 t 重複 (n / len) 次得到候選結果 repeated // 形成完整重複字串\n        → Decision: 如果 repeated == s? // 檢查是否與原字串相同\n            Yes → Step 5: 回傳 true // 找到可重複子字串\n            No  → Step 6: 繼續下一個 len // 失敗則嘗試下一個長度\n        No → Step 7: 繼續下一個 len // 長度無法整除，跳過\n→ Step 8: 回傳 false // 所有長度都失敗，無法重複構造\nEnd // 程式執行結束\n\nMake sure each line is separate. Use proper indent? They didn't require indent but for readability we can indent. But each line must contain the step and explanation.\n\nMake sure to keep arrow '→', 'Decision:'.\n\nThus produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算字串 s 的長度 n // 取得總字元數  \n→ Step 2: 從 1 到 n/2 逐個檢查可能的子字串長度 len // 確定候選子字串長度  \n    → Decision: 如果 n mod len == 0? // 只考慮能整除總長度的長度  \n        Yes → Step 3: 取前 len 個字元作為候選子字串 t // 取得可能重複的基底  \n        → Step 4: 將 t 重複 (n / len) 次得到候選結果 repeated // 形成完整重複字串  \n        → Decision: 如果 repeated == s? // 檢查是否與原字串相同  \n            Yes → Step 5: 回傳 true // 找到可重複子字串  \n            No  → Step 6: 繼續下一個 len // 失敗則嘗試下一個長度  \n        No → Step 7: 繼續下一個 len // 長度無法整除，跳過  \n→ Step 8: 回傳 false // 所有長度都失敗，無法重複構造  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        \"\"\"\n        檢查字串 s 是否可以由重複某個子字串構成。\n        \"\"\"\n        n = len(s)\n        # 只檢查能整除長度的子字串長度\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                if s[:i] * (n // i) == s:\n                    return True\n        return False\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取字串 s，並輸出是否可重複構造的結果。\n    支援輸入格式如：s = \"abab\" 或僅字串本身。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入\n    if '=' in data:\n        # 取等號右側的部分\n        _, value = data.split('=', 1)\n        s = value.strip()\n    else:\n        s = data\n\n    # 去除外層引號（若有）\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n\n    solution = Solution()\n    result = solution.repeatedSubstringPattern(s)\n    # 輸出小寫布林字串\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"abcabcabcabc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode528.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Weight",
    "description_snippet": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith in...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for a weighted random selection algorithm, likely using prefix sums and binary search. Provide line-by-line with explanation. Use Start, End, Decision. Include array precomputation. Let's craft.\n\nWe'll have steps:\n\nStart // start\n→ Step 1: 初始化前綴和陣列 prefix // compute cumulative weights\n→ Step 2: 計算總重量 total = prefix.last // total weight\n→ Step 3: 定義函數 pickIndex()\n    → Step 3.1: 產生 random 數 r in [1, total] // inclusive\n    → Step 3.2: 在 prefix 陣列中做二分查找 r\n        → Decision: r <= prefix[mid]? // binary search condition\n            Yes → Step 3.2.1: 將 right = mid-1 // move left\n            No  → Step 3.2.2: 將 left = mid+1 // move right\n    → Step 3.3: 回傳 left // found index\n→ End // 完成\n\nAlso need explanation. We'll format each line with code and comment.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立前綴和陣列 prefix ← [] // 用於儲存累積權重  \n→ Step 2: 對於每個 weight w[i]  \n  → Step 2.1: prefix.append( (prefix.last ?? 0) + w[i] ) // 加上上一個累積值  \n→ Step 3: 計算總重量 total ← prefix.last! // 最後一個前綴和即為總和  \n→ Step 4: 定義函數 pickIndex()  \n  → Step 4.1: 產生隨機整數 r ← randomInt(1, total) // 1 到 total 之間  \n  → Step 4.2: 初始化 left ← 0, right ← prefix.count - 1 // 二分搜尋範圍  \n  → Step 4.3: Decision: r <= prefix[mid]? // 判斷是否在左半邊  \n    Yes → Step 4.3.1: right ← mid - 1 // 右邊界左移  \n    No  → Step 4.3.2: left ← mid + 1 // 左邊界右移  \n  → Step 4.4: 回傳 left // 找到對應的索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"建立前綴和，方便快速查找索引\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機選擇一個索引，機率與權重成正比\"\"\"\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入（可能包含多行），並去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    # LeetCode 的測試格式為：[\"Solution\",\"pickIndex\"], [[[1]],[]]\n    # 把整個輸入包成一個 JSON 陣列，方便解析\n    json_str = '[' + raw_input + ']'\n    ops, args = json.loads(json_str)\n\n    results = []\n    instance = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg 形如 [[1]]，取內部列表作為 w\n            instance = Solution(arg[0])\n            results.append(None)  # 建構子不回傳值\n        elif op == \"pickIndex\":\n            results.append(instance.pickIndex())\n        else:\n            # 若有其他方法，直接呼叫\n            results.append(getattr(instance, op)(*arg))\n    # 輸出結果，使用 JSON 形式\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "success": true,
          "output": "[null, 0]"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 0, 1, 1]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode394.json",
    "problem_index_in_file": 0,
    "title": "Decode String",
    "description_snippet": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with comments. The requirement: use Start, End, Decision, arrows, etc. Provide algorithm to decode string like k[encoded_string]. Classic stack-based or recursion. Let's produce pseudocode with stack. Use two stacks: nums and strings. Iterate over chars.\n\nWe need to output each line as: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" to indicate step following previous. Use Decision with Yes/No. Also Start/End. Format: Start // 程式開始執行\n\nSo let's craft:\n\nStart // 程式開始執行\n→ Initialize empty stack for numbers // 用來存儲重複次數\n→ Initialize empty stack for strings // 用來存儲前置字串\n→ Initialize current_num = 0 // 當前讀取的數字\n→ Initialize current_str = \"\" // 當前累積的字串\n→ For each character c in input string // 遍歷輸入字元\n    → Decision: c 是數字? // 判斷是否為數字\n        Yes → current_num = current_num * 10 + int(c) // 建構多位數\n        No  → Decision: c 是 '['? // 判斷是否為左括號\n            Yes → Push current_str onto string stack // 將目前字串存到堆疊\n                → Push current_num onto number stack // 將重複次數存到堆疊\n                → Reset current_str = \"\" // 清空目前字串\n                → Reset current_num = 0 // 清空目前數字\n            No  → Decision: c 是 ']'? // 判斷是否為右括號\n                Yes → Pop repeat_count from number stack // 取出重複次數\n                → Pop prev_str from string stack // 取出前置字串\n                → current_str = prev_str + current_str * repeat_count // 重複並合併\n                → (no other action)\n                No  → current_str += c // 普通字元，追加到目前字串\n→ End of loop // 完成遍歷\n→ Output current_str // 回傳解碼後的字串\nEnd // 程式執行結束\n\nMake sure each line uses \"→\" at start except Start and End. The Decision lines must have nested Yes → and No → lines indented maybe. Use the same format as example. Use indentation with spaces? In example, Decision block has \"Yes →\" on same line, indented further lines. Use that.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize empty stack for numbers // 用來存儲重複次數  \n→ Initialize empty stack for strings // 用來存儲前置字串  \n→ Initialize current_num = 0 // 當前讀取的數字  \n→ Initialize current_str = \"\" // 當前累積的字串  \n→ For each character c in input string // 遍歷輸入字元  \n  → Decision: c 是數字? // 判斷是否為數字  \n    Yes → current_num = current_num * 10 + int(c) // 建構多位數  \n    No  → Decision: c 是 '['? // 判斷是否為左括號  \n      Yes → Push current_str onto string stack // 將目前字串存到堆疊  \n       → Push current_num onto number stack // 將重複次數存到堆疊  \n       → Reset current_str = \"\" // 清空目前字串  \n       → Reset current_num = 0 // 清空目前數字  \n      No  → Decision: c 是 ']'? // 判斷是否為右括號  \n        Yes → Pop repeat_count from number stack // 取出重複次數  \n         → Pop prev_str from string stack // 取出前置字串  \n         → current_str = prev_str + current_str * repeat_count // 重複並合併  \n        No  → current_str += c // 普通字元，追加到目前字串  \n→ End of loop // 完成遍歷  \n→ Output current_str // 回傳解碼後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_num = 0\n        current_str = ''\n        for char in s:\n            if char.isdigit():\n                current_num = current_num * 10 + int(char)\n            elif char == '[':\n                stack.append((current_str, current_num))\n                current_str = ''\n                current_num = 0\n            elif char == ']':\n                last_str, num = stack.pop()\n                current_str = last_str + current_str * num\n            else:\n                current_str += char\n        return current_str\n\nif __name__ == \"__main__\":\n    # Read input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the string inside quotes if present\n    if '\"' in data:\n        first = data.find('\"')\n        last = data.rfind('\"')\n        s = data[first + 1:last]\n    else:\n        s = data\n\n    solution = Solution()\n    result = solution.decodeString(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3[a]2[bc]\"",
          "expected_output": "\"aaabcbc\"",
          "success": true,
          "output": "aaabcbc"
        },
        {
          "example_index": 1,
          "input": "s = \"3[a2[c]]\"",
          "expected_output": "\"accaccacc\"",
          "success": true,
          "output": "accaccacc"
        },
        {
          "example_index": 2,
          "input": "s = \"2[abc]3[cd]ef\"",
          "expected_output": "\"abcabccdcdcdef\"",
          "success": true,
          "output": "abcabccdcdcdef"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode191.json",
    "problem_index_in_file": 0,
    "title": "Number of 1 Bits",
    "description_snippet": "Given a positive integer n, write a function that returns the number of set bits in its binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code step-by-step for a function that returns the number of set bits in the binary representation of a positive integer n. The user wants \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋.\" Use arrow, Start, End, Decision, etc. The user specifically says \"請勿輸出實際程式碼，只輸出結構化的步驟.\" So we should give pseudocode with steps like \"Start // Program starts\", \"→ Function CountSetBits(n) // define function\" maybe. Use decisions to check if n==0 then return 0, else count bits. Implementation: use while loop: while n>0: if n & 1: count++ ; n >>= 1. But we should express it in virtual code, using arrows and decisions. Also maybe handle positive integer only, but we can still check negative or zero input. The user wants a function that returns the number of set bits. Let's design:\n\nStart\n→ Function CountSetBits(n) // start function\n    → Initialize count = 0 // counter\n    → While n > 0 // while number has bits left\n        → Decision: if (n & 1) == 1 // check LSB\n            Yes → count = count + 1 // increment\n        No → // do nothing\n        → n = n >> 1 // shift right\n    → End While\n    → Return count // return count\nEnd\n\nBut we need arrow formatting as in example: \"Start // 程式開始執行\" etc.\n\nWe must include \"→\" arrow. Use \"Decision:\" lines.\n\nLet's produce the output with each line of virtual code followed by a comment in Chinese.\n\nWe also need to make sure each line is separate. We'll use \"→ Function CountSetBits(n) // 定義函式\" etc.\n\nLet's produce the output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function CountSetBits(n) // 定義計算設置位數的函式  \n    → 初始化 count = 0 // 設置計數器為 0  \n    → Decision: n > 0? // 檢查輸入是否為正整數  \n        Yes → While n > 0 // 當 n 仍有位元時循環  \n            → Decision: (n & 1) == 1? // 判斷最低有效位是否為 1  \n                Yes → count = count + 1 // 若為 1，計數器加 1  \n                No → // 若為 0，保持計數器不變  \n            → n = n >> 1 // 將 n 右移一位，處理下一位元  \n        End While // 循環結束  \n        No  → // 若 n <= 0，直接跳過循環  \n    → Return count // 回傳最終計數值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef hamming_weight(n: int) -> int:\n    \"\"\"Return the number of set bits (Hamming weight) of a positive integer n.\"\"\"\n    count = 0\n    while n:\n        count += n & 1   # add 1 if the least significant bit is set\n        n >>= 1          # shift right to process the next bit\n    return count\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract the first integer found in the input (handles formats like \"n = 11\")\n    match = re.search(r'(-?\\d+)', data)\n    if not match:\n        return  # No integer found; nothing to output\n    n = int(match.group(1))\n    # Compute and print the Hamming weight\n    print(hamming_weight(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 128",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2147483645",
          "expected_output": "30",
          "success": true,
          "output": "30"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1337.json",
    "problem_index_in_file": 0,
    "title": "The K Weakest Rows in a Matrix",
    "description_snippet": "You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civili...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code lines with explanation for algorithm to find k weakest rows. The matrix with each row sorted 1s then 0s. Approach: For each row count soldiers via binary search or linear scan. Store (count, index). Sort by count ascending then index ascending. Return first k indices.\n\nNeed virtual code line by line with comments. Use arrow structure. Provide steps: Start, for each row compute soldiers, store, then sort, then select k, then output. Use Decision? maybe not needed. We'll use loops.\n\nLet's produce.\n\nNeed format: each line \"虛擬碼步驟 // 解釋\" with arrow.\n\nLet's produce steps:\n\nStart\n→ Step 1: Initialize empty list rowsInfo\n→ For each row r with index i from 0 to m-1:\n   → Compute count = CountSoldiers(mat[i]) // count 1s\n   → Append (count, i) to rowsInfo\n→ Step 2: Sort rowsInfo by count ascending then index ascending\n→ Step 3: Initialize empty list weakest\n→ For each tuple in first k of rowsInfo:\n   → Append index to weakest\n→ Step 4: Return weakest\nEnd\n\nDefine CountSoldiers using binary search:\n\nDefine CountSoldiers(row):\n   → Left = 0, Right = len(row)-1, Result = 0\n   → While Left <= Right:\n      → Mid = (Left+Right)//2\n      → If row[Mid] == 1:\n            Result = Mid+1\n            Left = Mid+1\n         Else:\n            Right = Mid-1\n   → Return Result\n\nWe'll need to incorporate this into pseudo code.\n\nLet's write.\n\nUse arrow lines with indent.\n\nWe need to show decisions? The CountSoldiers includes decision if row[mid]==1.\n\nLet's produce each line.\n\nRemember each line must have virtual code then space then comment.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: rowsInfo ← empty list // 用來儲存每列的兵力數量與索引  \n→ For i ← 0 To m-1 Do // 遍歷所有列  \n  → count ← CountSoldiers(mat[i]) // 計算第 i 列的 1 的數量  \n  → Append (count, i) to rowsInfo // 將結果加入清單  \n→ End For  \n→ Step 2: Sort rowsInfo by (count asc, index asc) // 依兵力再依索引排序  \n→ Step 3: weakest ← empty list // 存放前 k 列的索引  \n→ For each (cnt, idx) in first k elements of rowsInfo Do  \n  → Append idx to weakest // 取出最弱的 k 列索引  \n→ End For  \n→ Step 4: Return weakest // 回傳結果  \nEnd // 程式執行結束  \n\n// ---------- 辅助函数 ----------  \n→ Function CountSoldiers(row)  \n  → left ← 0, right ← len(row)-1, result ← 0 // 初始化左右指標與結果  \n  → While left ≤ right Do  \n    → mid ← (left + right) // 2 // 取中點  \n      → Decision: row[mid] == 1? // 判斷中點是否為 1  \n        Yes → result ← mid + 1, left ← mid + 1 // 右移，記錄位置  \n        No  → right ← mid - 1 // 左移  \n    → End While  \n  → Return result // 回傳 1 的總數  \n→ End Function",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef count_soldiers(row):\n    \"\"\"用二分搜尋找出 row 中 1 的數量\"\"\"\n    left, right = 0, len(row)\n    while left < right:\n        mid = (left + right) // 2\n        if row[mid] == 1:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef k_weakest_rows(mat, k):\n    \"\"\"計算每列的兵力數量，排序後取前 k 個索引\"\"\"\n    soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n    soldiers.sort()                     # 先按兵力，若相同則按索引升冪\n    return [idx for _, idx in soldiers[:k]]\n\ndef parse_input():\n    \"\"\"從 stdin 解析 mat 與 k 的值，支援多種輸入格式\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], 0\n    # 先嘗試找到 'mat = ...' 與 'k = ...' 的格式\n    mat_match = re.search(r'mat\\s*=\\s*(\\[\\[.*?\\]\\])', data, re.S)\n    k_match   = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if mat_match and k_match:\n        mat_str = mat_match.group(1)\n        k_str   = k_match.group(1)\n        mat = ast.literal_eval(mat_str)\n        k   = int(k_str)\n        return mat, k\n    # 若沒有上述格式，嘗試按行解析：第一行是矩陣，第二行是 k\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        mat = ast.literal_eval(lines[0])\n        k   = int(lines[1].strip())\n        return mat, k\n    # 最後退回空矩陣與 0\n    return [], 0\n\nif __name__ == \"__main__\":\n    mat, k = parse_input()\n    result = k_weakest_rows(mat, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "success": true,
          "output": "[2, 0, 3]"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "success": true,
          "output": "[0, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode753.json",
    "problem_index_in_file": 0,
    "title": "Cracking the Safe",
    "description_snippet": "There is a safe protected by a password. The password is a sequence of n digits where each digit can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps to generate a minimal-length string that ensures the correct password (a sequence of n digits from 0 to k-1) appears as a contiguous substring. This is essentially generating a De Bruijn sequence of order n over alphabet size k. The minimal length is k^n + n -1. So algorithm: generate De Bruijn sequence using standard algorithm (preferably prefer lexicographic minimal). Steps: start with n-1 zeros, DFS to visit all k^n substrings, output sequence. We'll produce pseudo-code step by step with explanations. No actual code, just steps. We'll use Start, End, Decision. Provide line by line.\n\nWe need to incorporate that password unknown; we need a string that will guarantee that any n-length password appears. That's the De Bruijn sequence. Provide pseudo-code generating such sequence.\n\nLet's produce pseudo-code: \n\nStart\n\n→ Initialize variables: k, n\n\n→ Create empty list 'sequence' // will store digits\n\n→ Define function DFS(node) // node is string of length n-1\n\n    → Decision: If visited count equals k^n? // all substrings visited\n\n        Yes → Return // finished\n\n        No →\n\n            → For digit from 0 to k-1\n\n                → newNode = node + digit\n\n                → If edge (node,digit) not visited\n\n                    → Mark edge visited\n\n                    → Append digit to sequence\n\n                    → DFS(newNode[1:]) // drop first char to keep length n-1\n\n    // end function\n\n→ Call DFS('0'*(n-1))\n\n→ After DFS, prepend '0'*(n-1) to sequence // starting node\n\n→ Output sequence // string of length k^n + n -1\n\nEnd\n\nAdd explanations.\n\nLet's craft lines.\n\nMake sure each line has \"虛擬碼步驟\" plus \"// 解釋\".\n\nUse arrow \"→\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read integer k, n // 取得字母表大小與密碼長度  \n→ Init list sequence ← empty // 用於儲存最終輸出的數字序列  \n→ Init set visited ← empty // 追蹤已使用的邊（子序列）  \n→ Define function DFS(node: string of length n-1) // 深度優先搜尋所有 n 位子序列  \n  Decision: if |visited| = k^n? // 所有可能的 n 位組合已被探索完畢？  \n   Yes → Return // 完成搜尋，回到上一層  \n   No →  \n    For digit in 0 to k-1 // 嘗試每個可能的下一位數字  \n     newNode ← node + digit // 產生新的節點（包含新加的數字）  \n     Edge ← (node, digit) // 代表從 node 到 newNode 的邊  \n     Decision: if Edge ∈ visited? // 這條邊是否已被走過？  \n      Yes → Continue // 若已走過，跳過此 digit  \n      No →  \n       visited ← visited ∪ {Edge} // 標記邊已被使用  \n       sequence.append(digit) // 把新加的數字加入輸出序列  \n       DFS(newNode[1:]) // 以 newNode 的後 n-1 位作為下一個節點  \n       // DFS 會遞迴直到所有邊都被使用  \n       // 這樣確保每個長度 n 的子序列都出現一次  \n       // 透過後遞迴結束後回到上一層  \n       // 依序完成所有可能的延伸  \n       // 此過程完成後，sequence 將包含所有必要的後綴  \n→ Call DFS('0' * (n-1)) // 從 n-1 個 0 開始探索，確保序列以最低字母表起始  \n→ Prepend ('0' * (n-1)) to sequence // 加上起始節點的前 n-1 個 0，完成 De Bruijn 序列  \n→ Output sequence as string // 這串長度為 k^n + n - 1，能包含任意 n 位密碼  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef crack_safe(n: int, k: int) -> str:\n    \"\"\"Generate a De Bruijn sequence for alphabet size k and window length n.\"\"\"\n    seen = set()\n    res = []\n\n    def dfs(node: str):\n        for x in map(str, range(k)):\n            nei = node + x\n            if nei not in seen:\n                seen.add(nei)\n                dfs(nei[1:])\n                res.append(x)\n\n    start = \"0\" * (n - 1)\n    dfs(start)\n    return \"\".join(res) + start\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r\"\\d+\", data)))\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n        print(crack_safe(n, k))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 2, k = 2",
          "expected_output": "\"01100\"",
          "success": true,
          "output": "01100"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode172.json",
    "problem_index_in_file": 0,
    "title": "Factorial Trailing Zeroes",
    "description_snippet": "Given an integer n, return the number of trailing zeroes in n!. \n\nNote that n! = n * (n - 1) * (n - ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. We need to not output actual code, just steps.\n\nThe algorithm: count number of factors of 5 in n! because each trailing zero requires a factor 10 = 2*5. Count factors of 5. Use while loop dividing n by 5 until n==0, sum floor division.\n\nSteps: Start. Step: initialize count=0. Step: set divisor=5. Step: while n/divisor > 0: add n/divisor to count. Step: divisor*=5. End: return count. Also handle input, output.\n\nWe need virtual code lines: Start, then step lines, decisions. Use arrow syntax.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 從使用者取得要計算 n!\n→ Step 2: 初始化變數 count ← 0 // 用於累計 5 的倍數\n→ Step 3: 初始化變數 divisor ← 5 // 第一次檢查 5 的倍數\n→ Decision: 是否 n/divisor > 0? // 判斷是否還有可被 divisor 整除的數\n    Yes → Step 4: count ← count + floor(n/divisor) // 加上此層次的 5 的個數\n    Yes → Step 5: divisor ← divisor * 5 // 移到下一層 25, 125...\n    No  → Step 6: End // 所有層次已計算完畢\n→ Step 7: 輸出 count // 顯示 n! 的尾隨零數量\nEnd // 程式執行結束\n\nBut we need to reflect that after incrementing divisor we loop back to decision. So we might have a loop arrow. Let's structure:\n\nStart\n→ Step 1: read n\n→ Step 2: count ← 0\n→ Step 3: divisor ← 5\n→ Decision: n/divisor > 0? \n    Yes → Step 4: count ← count + n/divisor\n    Yes → Step 5: divisor ← divisor * 5\n    Yes → Decision: n/divisor > 0? // loop back\n    No → Step 6: output count\nEnd\n\nBut we need to show the loop. Use arrow back to decision. We'll use \"→ Decision:\" with indentation. Provide explanation after each line.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 從使用者取得要計算 n!  \n→ Step 2: 初始化變數 count ← 0 // 用於累計 5 的倍數個數  \n→ Step 3: 初始化變數 divisor ← 5 // 第一次檢查 5、25、125 等  \n→ Decision: n ÷ divisor > 0? // 是否還有可被 divisor 整除的數  \n  Yes → Step 4: count ← count + floor(n ÷ divisor) // 加上此層次的 5 的個數  \n  Yes → Step 5: divisor ← divisor * 5 // 移到下一層 25、125…  \n  Yes → Decision: n ÷ divisor > 0? // 重新檢查下一層，形成迴圈  \n  No  → Step 6: 輸出 count // 所有層次已計算完畢，顯示尾隨零的數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef trailing_zeroes(n: int) -> int:\n    \"\"\"計算 n! 的尾隨零數量。\"\"\"\n    count = 0\n    while n > 0:\n        n //= 5          # 只保留 5 的倍數層次\n        count += n\n    return count\n\ndef main() -> None:\n    # 讀取全部輸入，並抓取第一個整數作為 n\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    print(trailing_zeroes(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode720.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary",
    "description_snippet": "Given an array of strings words representing an English Dictionary, return the longest word in words...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: find longest word that can be built one char at a time by other words. So typical algorithm: sort words lexicographically by length and lexicographic order, use set to keep valid prefixes. Iterate, for each word check if all prefixes exist. Keep longest.\n\nBut we produce virtual code, not actual code. Need step-by-step, with arrows, decisions, etc.\n\nLet's craft steps: Start, sort words, initialize set, variable result. For each word in sorted list: if word length 1 or first char word minus last char exists in set, then add word to set; if word longer than result or equal length but lexicographically smaller, update result. End.\n\nAlso handle empty case.\n\nWe must produce each line as \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: Sort words by ascending length, then lexicographic order // 為了一次掃描即可找到答案\n\n→ Step 2: Initialize HashSet validWords ← empty set // 用來存已確認能逐字構成的單詞\n\n→ Step 3: Initialize result ← \"\" // 儲存目前最佳單詞\n\n→ For each word w in sorted words // 遍歷每個單詞\n\n    → Decision: 如果 w 的長度為 1 或 (w 除去最後一個字元的子字串) 存在於 validWords? // 檢查是否能由已知單詞構成\n\n        Yes → Step 4: validWords.add(w) // 將此單詞加入可用集合\n\n        Yes → Decision: w 長度 > result 長度 或 (長度相同且 w lexicographically < result)？ // 判斷是否更新最佳\n\n            Yes → Step 5: result ← w // 更新最佳單詞\n\n        No → (不執行更新)\n\n    No → (跳過此單詞，因為無法構成)\n\nEnd // 返回 result 或空字串\n\nBut we need to output each step line individually with arrows. Let's write each line:\n\nStart // 程式開始執行\n→ Step 1: words ← Sort(words, key=(len, lexicographic)) // 先根據長度及字典序排序\n→ Step 2: validWords ← {} // 用於存放已確認可逐字構成的單字\n→ Step 3: result ← \"\" // 儲存目前最佳答案\n→ For each w in words // 遍歷排序後的單字\n    → Decision: w.len == 1 OR (w[:-1] in validWords)? // 檢查 w 是否可由先前單字一步一步構成\n        Yes → Step 4: validWords.add(w) // 將 w 加入可用集合\n        Yes → Decision: w.len > result.len OR (w.len == result.len AND w < result)? // 判斷是否為更佳答案\n            Yes → Step 5: result ← w // 更新最佳答案\n        No → (不更新)\n    No → (跳過此 w，因無法構成)\nEnd // 程式結束，返回 result\n\nBut need \"虛擬碼步驟\" plus comment each line. Also use arrow formatting: \"→\" etc. Let's produce each line accordingly.\n\nEnsure each line is a separate line. Provide arrow at start of each line except Start maybe not arrow? Format example uses \"→ Step 1:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: words ← Sort(words, key=(len, lexicographic)) // 先根據長度及字典序排序  \n→ Step 2: validWords ← {} // 用於存放已確認可逐字構成的單字  \n→ Step 3: result ← \"\" // 儲存目前最佳答案  \n→ For each w in words // 遍歷排序後的單字  \n    → Decision: w.len == 1 OR (w[:-1] in validWords)? // 檢查 w 是否可由先前單字一步一步構成  \n        Yes → Step 4: validWords.add(w) // 將 w 加入可用集合  \n        Yes → Decision: w.len > result.len OR (w.len == result.len AND w < result)? // 判斷是否為更佳答案  \n            Yes → Step 5: result ← w // 更新最佳答案  \n            No  → (不更新)  \n        No → (跳過此 w，因無法構成)  \nEnd // 程式結束，返回 result（若仍為空字串則代表無法構成任何單字）",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def longestWord(self, words):\n        word_set = set(words)\n        longest = \"\"\n        for word in words:\n            # Check that all prefixes exist\n            if all(word[:k] in word_set for k in range(1, len(word) + 1)):\n                if len(word) > len(longest) or (len(word) == len(longest) and word < longest):\n                    longest = word\n        return longest\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Extract all words enclosed in double quotes\n    words = re.findall(r'\"([^\"]*)\"', raw_input)\n    # If no quoted strings are found, treat the entire input as a JSON-like list\n    if not words:\n        try:\n            words = eval(raw_input.strip())\n        except Exception:\n            words = []\n\n    solution = Solution()\n    result = solution.longestWord(words)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]",
          "expected_output": "world",
          "success": true,
          "output": "world"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]",
          "expected_output": "apple",
          "success": true,
          "output": "apple"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode131.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for algorithm: partition string into all palindrome partitions. Use backtracking. We'll produce steps: Start, input string, initialize result, define backtrack function with index and current path. Check palindrome for substrings. Recursively backtrack. At end, output result.\n\nWe need each line with `虛擬碼步驟 // 解釋`.\n\nUse arrow: `→`. Use Decision etc.\n\nLet's craft.\n\nAlso ensure no actual code, only virtual.\n\nWe will create pseudo algorithm.\n\nWe must produce step-by-step. For recursion, we can denote: Step: Backtrack(currentIndex, currentPath). At each loop, iterate end from currentIndex to len(s). Extract substring. Decision: Is palindrome? If yes → add to path → if end==len(s)-1 → add path copy to result → else → backtrack(end+1, path). After recursion, remove last added substring to backtrack.\n\nWe must not output real code. Use pseudo.\n\nLet's produce.\n\nStart // 程式開始執行\n\n→ Input: s // 取得輸入字串\n\n→ Init: result = [] // 用於儲存所有分割結果\n\n→ Function: Backtrack(start, path) // 定義遞迴回溯函式\n\n    → Decision: start == len(s)? // 檢查是否已到字串結尾\n\n        Yes → Append copy of path to result // 完整分割加入結果\n\n        No  → Loop end from start to len(s)-1 // 遍歷所有可能結束位置\n\n            → Substring = s[start:end+1] // 取得子字串\n\n            → Decision: Substring is palindrome? // 判斷是否為回文\n\n                Yes → Append Substring to path // 將合法子字串加入目前分割\n\n                → Recursion: Backtrack(end+1, path) // 進一步分割剩餘字串\n\n                → Remove last element from path // 回溯，移除剛剛加入的子字串\n\n→ Call: Backtrack(0, []) // 從字串起始位置開始回溯\n\n→ Return result // 回傳所有合法分割\n\nEnd // 程式執行結束\n\nBut must follow arrow formatting exactly: `→` at beginning of each line. For nested decision we can indent with spaces? Example shows indent.\n\nWe'll follow same style: Indentation with spaces before arrow.\n\nWe need to include \"Decision:\" prefix. And \"Yes →\" \"No →\" lines.\n\nLet's produce with correct formatting.\n\nWe'll include comments.\n\nAlso include Start and End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: s // 取得輸入字串  \n→ Init: result = [] // 用於儲存所有分割結果  \n\n→ Function: Backtrack(start, path) // 定義遞迴回溯函式  \n    → Decision: start == len(s)？ // 檢查是否已到字串結尾  \n        Yes → Append copy of path to result // 完整分割加入結果  \n        No  → Loop end from start to len(s)-1 // 遍歷所有可能結束位置  \n            → Substring = s[start:end+1] // 取得子字串  \n            → Decision: Substring is palindrome? // 判斷是否為回文  \n                Yes → Append Substring to path // 將合法子字串加入目前分割  \n                → Recursion: Backtrack(end+1, path) // 進一步分割剩餘字串  \n                → Remove last element from path // 回溯，移除剛剛加入的子字串  \n\n→ Call: Backtrack(0, []) // 從字串起始位置開始回溯  \n→ Return result // 回傳所有合法分割  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef partition(s: str):\n    res = []\n\n    def dfs(start, path):\n        if start == len(s):\n            res.append(path.copy())\n            return\n        for end in range(start + 1, len(s) + 1):\n            sub = s[start:end]\n            if sub == sub[::-1]:  # palindrome check\n                path.append(sub)\n                dfs(end, path)\n                path.pop()\n\n    dfs(0, [])\n    return res\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # 將輸入中第一組雙引號內的文字作為字串 s\n    match = re.search(r'\"(.*)\"', data)\n    s = match.group(1) if match else data.strip()\n    result = partition(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
          "success": true,
          "output": "[['a', 'a', 'b'], ['aa', 'b']]"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode43.json",
    "problem_index_in_file": 0,
    "title": "Multiply Strings",
    "description_snippet": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code in traditional Chinese with explanations for algorithm: multiply two non-negative integer strings without using BigInteger or direct int conversion.\n\nWe need to produce step-by-step pseudocode with arrows etc.\n\nWe must produce a structured algorithm: typical approach is grade-school multiplication: for each digit in num2 from rightmost, multiply with num1, shift accordingly, accumulate result. We can implement result array of length len(num1)+len(num2), store each multiplication and carry.\n\nWe must produce each step with comments.\n\nAlso we need to include Start, End, Decision. The algorithm is straightforward.\n\nWe need to produce virtual code line by line. For each step include explanation after \"//\".\n\nWe need to be careful: The format requires each line \"虛擬碼步驟 [space] // 解釋\". Each line ends with comment.\n\nLet's craft pseudocode.\n\nPossible steps:\n\nStart // 開始\n→ Step 1: len1 ← length(num1) // 取得字串長度\n→ Step 2: len2 ← length(num2) // 取得字串長度\n→ Step 3: result ← array of zeros of size len1+len2 // 用來存儲乘積\n→ Decision: 如果 num1 為 \"0\" 或 num2 為 \"0\"? // 檢查是否有零\n    Yes → Step 4: return \"0\" // 若任一為零，直接回傳\n    No  →\n→ Step 5: for i from len1-1 downto 0 // 從 num1 的最低位開始\n    → Step 6: digit1 ← num1[i] - '0' // 轉成數字\n    → Step 7: for j from len2-1 downto 0 // 從 num2 的最低位開始\n        → Step 8: digit2 ← num2[j] - '0' // 轉成數字\n        → Step 9: product ← digit1 * digit2 + result[i+j+1] // 乘法加上已有值\n        → Step 10: result[i+j+1] ← product mod 10 // 存儲低位\n        → Step 11: result[i+j] ← result[i+j] + product / 10 // 加上進位到更高位\n    → End for // 完成 num2 內層迴圈\n→ End for // 完成 num1 內層迴圈\n→ Step 12: resStr ← \"\" // 初始化結果字串\n→ Decision: result[0] 等於 0? // 判斷是否有首位零\n    Yes → startIdx ← 1 // 跳過首位零\n    No  → startIdx ← 0\n→ Step 13: for k from startIdx to len1+len2-1\n    → Step 14: resStr ← resStr + char(result[k] + '0') // 轉成字符拼接\n→ End for // 結束拼接\n→ Step 15: return resStr // 回傳乘積字串\nEnd // 結束\n\nWe might want to include the inner loops with arrows, but indentation maybe not required but we can show nested with indentation.\n\nMake sure each line ends with comment.\n\nNeed to ensure we follow the format strictly: each line starts with virtual code step, then a space, then // explanation.\n\nWe should not use actual code. The steps should be in Chinese.\n\nWe also must include \"Decision:\" lines with \"Yes →\" and \"No →\".\n\nWe need to make sure the arrow lines inside loops show indentation? The example shows indentation after the Decision but not strictly required.\n\nBetter to maintain structure: Start, End, Decision, etc.\n\nLet's produce.\n\nWe need to not produce any code or actual implementation but just pseudocode lines.\n\nWe also need to keep each line distinct.\n\nWe'll produce:\n\nStart // 程式開始\n→ Step 1: len1 ← length(num1) // 取得 num1 的長度\n→ Step 2: len2 ← length(num2) // 取得 num2 的長度\n→ Step 3: result ← array of zeros of size len1 + len2 // 用於儲存乘積\n→ Decision: num1 = \"0\" 或 num2 = \"0\"? // 判斷是否有零\n    Yes → Step 4: return \"0\" // 直接回傳\n    No  →\n→ Step 5: for i from len1-1 down to 0 // 逐位處理 num1\n    → Step 6: digit1 ← num1[i] - '0' // 將字元轉為數字\n    → Step 7: for j from len2-1 down to 0 // 逐位處理 num2\n        → Step 8: digit2 ← num2[j] - '0' // 將字元轉為數字\n        → Step 9: product ← digit1 * digit2 + result[i+j+1] // 計算乘積加上已有值\n        → Step 10: result[i+j+1] ← product mod 10 // 存低位\n        → Step 11: result[i+j] ← result[i+j] + product div 10 // 加進位\n    → End for // num2 完成\n→ End for // num1 完成\n→ Step 12: startIdx ← 0 // 起始索引\n→ Decision: result[0] == 0? // 是否首位為 0\n    Yes → startIdx ← 1 // 跳過首位零\n    No  →\n→ Step 13: resStr ← \"\" // 初始化結果字串\n→ Step 14: for k from startIdx to len1+len2-1 // 轉換數字到字串\n    → Step 15: resStr ← resStr + char(result[k] + '0') // 拼接\n→ End for // 完成拼接\n→ Step 16: return resStr // 回傳乘積\nEnd // 程式結束\n\nBut we need each line exactly one step; for loops we may need to use Start? But example shows \"→ Step 1:\" etc.\n\nWe can include \"→ End for\" as a line.\n\nLet's keep each line separate.\n\nWill produce:\n\nStart // 程式開始\n\n→ Step 1: len1 ← length(num1) // 取得 num1 的長度\n\n→ Step 2: len2 ← length(num2) // 取得 num2 的長度\n\n→ Step 3: result ← array of zeros of size len1 + len2 // 用於儲存乘積\n\n→ Decision: num1 = \"0\" 或 num2 = \"0\"? // 判斷是否有零\n\n    Yes → Step 4: return \"0\" // 直接回傳\n\n    No  →\n\n→ Step 5: for i from len1-1 down to 0 // 從 num1 最低位開始\n\n    → Step 6: digit1 ← num1[i] - '0' // 轉為數字\n\n    → Step 7: for j from len2-1 down to 0 // 從 num2 最低位開始\n\n        → Step 8: digit2 ← num2[j] - '0' // 轉為數字\n\n        → Step 9: product ← digit1 * digit2 + result[i+j+1] // 乘法加已有值\n\n        → Step 10: result[i+j+1] ← product mod 10 // 存低位\n\n        → Step 11: result[i+j] ← result[i+j] + product div 10 // 加進位\n\n    → End for // num2 內層結束\n\n→ End for // num1 外層結束\n\n→ Step 12: startIdx ← 0 // 預設起始索引\n\n→ Decision: result[0] == 0? // 檢查是否首位為 0\n\n    Yes → startIdx ← 1 // 跳過首位零\n\n    No  →\n\n→ Step 13: resStr ← \"\" // 初始化結果字串\n\n→ Step 14: for k from startIdx to len1+len2-1 // 將數字轉為字元\n\n    → Step 15: resStr ← resStr + char(result[k] + '0') // 拼接字元\n\n→ End for // 完成拼接\n\n→ Step 16: return resStr // 回傳乘積字串\n\nEnd // 程式結束\n\nWe must ensure no actual code but pseudocode style. The \"→\" lines show arrows.\n\nBut we need each line with a space after the code and then \"//\". Example uses \"→ Step 1:\" etc. We'll maintain that.\n\nWe need to avoid code like 'char(result[k] + '0')' because that's actual code. But maybe it's acceptable because it's pseudocode; but the user asked not to output actual code, but just structured steps. So we can use abstract representation \"char(result[k] + '0')\" is okay as part of pseudocode; but maybe we can phrase as \"convert result[k] to char\". We can modify to be more high-level: \"resStr ← resStr + (result[k] + '0')\" or \"resStr ← resStr + digitToChar(result[k])\". Let's keep as \"digitToChar(result[k])\" to avoid actual code.\n\nThus Step 15: resStr ← resStr + digitToChar(result[k]) // 拼接字元\n\nAlso Step 3: result ← array of zeros of size len1 + len2 // 用於儲存乘積\n\nThat's okay.\n\nAlso Step 10: result[i+j+1] ← product mod 10 // 存低位\n\nBetter use mod as remainder. Step 11: result[i+j] ← result[i+j] + product div 10 // 加進位\n\nNow we need to ensure \"Step\" lines are separate.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: len1 ← length(num1) // 取得 num1 的長度  \n→ Step 2: len2 ← length(num2) // 取得 num2 的長度  \n→ Step 3: result ← array of zeros of size len1 + len2 // 用於儲存乘積  \n→ Decision: num1 = \"0\" 或 num2 = \"0\"? // 判斷是否有零  \n Yes → Step 4: return \"0\" // 直接回傳  \n No  →  \n→ Step 5: for i from len1-1 down to 0 // 從 num1 最低位開始  \n → Step 6: digit1 ← num1[i] - '0' // 轉為數字  \n → Step 7: for j from len2-1 down to 0 // 從 num2 最低位開始  \n  → Step 8: digit2 ← num2[j] - '0' // 轉為數字  \n  → Step 9: product ← digit1 * digit2 + result[i+j+1] // 乘法加已有值  \n  → Step 10: result[i+j+1] ← product mod 10 // 存低位  \n  → Step 11: result[i+j] ← result[i+j] + product div 10 // 加進位  \n  → End for // num2 內層結束  \n → End for // num1 外層結束  \n→ Step 12: startIdx ← 0 // 預設起始索引  \n→ Decision: result[0] == 0? // 檢查是否首位為 0  \n Yes → startIdx ← 1 // 跳過首位零  \n No  →  \n→ Step 13: resStr ← \"\" // 初始化結果字串  \n→ Step 14: for k from startIdx to len1+len2-1 // 將數字轉為字元  \n  → Step 15: resStr ← resStr + digitToChar(result[k]) // 拼接字元  \n  → End for // 完成拼接  \n→ Step 16: return resStr // 回傳乘積字串  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 如果任一為零，直接回傳 \"0\"\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # 用於存儲乘積，長度為 m + n\n        pos = [0] * (m + n)\n\n        # 從最低位開始逐位相乘\n        for i in range(m - 1, -1, -1):\n            d1 = ord(num1[i]) - 48  # 字元轉數字\n            for j in range(n - 1, -1, -1):\n                d2 = ord(num2[j]) - 48\n                mul = d1 * d2\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n                pos[p1] += sum_ // 10     # 進位\n                pos[p2] = sum_ % 10        # 存低位\n\n        # 轉成字串並去除前導 0\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result if result else \"0\"\n\n\ndef main():\n    data = sys.stdin.read()\n    # 先搜尋單引號中的數字\n    nums = re.findall(r\"'(\\d+)'\", data)\n    if len(nums) < 2:\n        # 若沒有單引號，搜尋所有連續的數字\n        nums = re.findall(r\"(\\d+)\", data)\n\n    if len(nums) < 2:\n        # 仍不足兩個數字，嘗試以空白分割\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            return  # 無法取得數字，直接結束\n    else:\n        num1, num2 = nums[0], nums[1]\n\n    solution = Solution()\n    print(solution.multiply(num1, num2))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "success": true,
          "output": "56088"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode539.json",
    "problem_index_in_file": 0,
    "title": "Minimum Time Difference",
    "description_snippet": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference b...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We need to handle list of times in HH:MM. Find min difference in minutes between any two times. Approach: Convert each time to minutes since midnight. Sort list. Compute differences between consecutive times and also wrap-around between last and first (24*60). Keep min. Return min.\n\nWe need to produce step-by-step with arrow lines and comments. Include Start and End. Use Decision.\n\nLet's structure: Start. Input list. Convert to minutes. Sort list. Initialize minDiff large. Iterate i from 0 to n-2: diff = sorted[i+1] - sorted[i]; if diff<minDiff set. After loop compute wrapDiff = sorted[0] + 1440 - sorted[-1]; if wrapDiff<minDiff set. Output minDiff. End.\n\nInclude explanation after each line.\n\nMake sure to use arrow for steps. For loops maybe \"Loop i = 0 to n-2:\". For Decision, if. Use Yes, No. Use proper indentation. Use 虛擬碼步驟 and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收輸入時間點清單 times // 取得使用者提供的 HH:MM 字串陣列\n→ Step 2: 將每個時間點轉換為自午夜以來的分鐘數 minutesList // 例如 \"23:45\" → 1425\n→ Step 3: 對 minutesList 進行排序 sortedMinutes // 方便計算相鄰差值\n→ Decision: 是否至少有兩個時間點? // 必須至少兩個才能計算差距\n    Yes → Step 4: 設定 minDiff 為無限大 // 用於尋找最小差值\n    No  → Step 5: 回傳 0 // 兩個時間點不足，差值視為 0\n→ Loop i = 0 to length(sortedMinutes) - 2: // 遍歷相鄰時間點\n    → Step 6: 計算 diff = sortedMinutes[i+1] - sortedMinutes[i] // 相鄰差值\n    → Decision: diff < minDiff? // 檢查是否為新的最小差值\n        Yes → Step 7: 設定 minDiff = diff // 更新最小差值\n        No  → // 不做任何改動\n→ Step 8: 計算 wrapDiff = sortedMinutes[0] + 1440 - sortedMinutes[last] // 從最後一點到第一點的跨午夜差值\n→ Decision: wrapDiff < minDiff? // 檢查跨午夜差值是否更小\n    Yes → Step 9: 設定 minDiff = wrapDiff // 更新最小差值\n    No  → // 不做任何改動\n→ Step 10: 回傳 minDiff // 將最小分鐘差返回\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findMinDifference(self, timePoints):\n        # 將每個時間轉成自午夜以來的分鐘數\n        minutes = []\n        for t in timePoints:\n            h, m = map(int, t.split(':'))\n            minutes.append(h * 60 + m)\n        # 先排序，方便計算相鄰差距\n        minutes.sort()\n        # 初始最小差距設為無限大\n        min_diff = float('inf')\n        # 計算相鄰時間點之差距\n        for i in range(1, len(minutes)):\n            diff = minutes[i] - minutes[i - 1]\n            if diff < min_diff:\n                min_diff = diff\n        # 計算跨午夜的差距\n        wrap_diff = 1440 - (minutes[-1] - minutes[0])\n        if wrap_diff < min_diff:\n            min_diff = wrap_diff\n        return min_diff\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個輸入，並解析為時間點清單\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        # 若無輸入則直接結束\n        sys.exit()\n    # 使用 json.loads 解析形如 '[\"23:59\",\"00:00\"]' 的字串\n    time_points = json.loads(input_data)\n    # 產生解答並輸出\n    result = Solution().findMinDifference(time_points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"23:59\",\"00:00\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[\"00:00\",\"23:59\",\"00:00\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode665.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Array",
    "description_snippet": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for checking if an array can become non-decreasing by modifying at most one element. We need to output line by line with \"虛擬碼步驟\" plus comment. Use Start, End, Decision: with arrow. The pseudocode must reflect algorithm. For such problem, typical approach: iterate and count violations; if >1 return false. If violation at index i, check if modifying nums[i] or nums[i+1] can fix. But simpler: If we find i such that nums[i] > nums[i+1], then if it's first violation, check if either i-1 < nums[i+1] or nums[i] < nums[i+2]. If not, return false. Continue. End true. Let's produce steps.\n\nAlso include array input reading, loop, conditions.\n\nWe'll produce each line as \"虛擬碼步驟 // 解釋\". Use arrow like \"→\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入整數陣列 nums // 從使用者處取得整數陣列\n→ Step 2: 變數 n ← 長度(nums) // 記錄陣列長度\n→ Step 3: 變數 count ← 0 // 記錄發現的降序對數\n→ Step 4: 變數 index ← -1 // 記錄第一次違規的位置\n→ Decision: 是否 n < 2? // 若陣列長度不足，直接非遞增\n    Yes → Step 5: 輸出 true // 兩個元素以下皆可視為可調整\n    No  → \n→ Step 6: 從 i = 0 到 n-2 進行迴圈 // 檢查相鄰元素\n    → Decision: nums[i] > nums[i+1]? // 發現降序對\n        Yes → \n            → Step 7: count ← count + 1 // 違規數量加一\n            → Decision: count > 1? // 超過一次則直接失敗\n                Yes → Step 8: 輸出 false // 需要調整超過一次\n                No  → \n                    → Decision: index == -1? // 第一次違規\n                        Yes → Step 9: index ← i // 記錄位置\n                        No  → \n        No → \n→ Decision: count == 0? // 沒有任何違規\n    Yes → Step 10: 輸出 true // 原陣列已非遞增\n    No  → \n        → Decision: (index == 0 or nums[index-1] <= nums[index+1]) 或 (index == n-2 or nums[index] <= nums[index+2])? // 可透過調整其中一個元素修正\n            Yes → Step 11: 輸出 true // 只需改一次即可\n            No  → Step 12: 輸出 false // 任何一次調整都無法修正\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def checkPossibility(self, nums):\n        count = 0\n        n = len(nums)\n        for i in range(1, n):\n            if nums[i] < nums[i - 1]:\n                count += 1\n                if count > 1:\n                    return False\n                # Decide which element to modify\n                if i == 1 or nums[i] >= nums[i - 2]:\n                    nums[i - 1] = nums[i]  # adjust previous element\n                else:\n                    nums[i] = nums[i - 1]  # adjust current element\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract all integers from the input string\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    solution = Solution()\n    result = solution.checkPossibility(nums)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,2,3]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode446.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices II - Subsequence",
    "description_snippet": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n\nA sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for solving the problem: count number of arithmetic subsequences (length>=3) in an integer array nums. Classic Leetcode 446. Approach: use DP with hashmaps: dp[i] is map diff->count of subsequences ending at i with that diff. For each j<i, diff = nums[i]-nums[j], count_j = dp[j][diff], then dp[i][diff] += count_j + 1. Accumulate answer += count_j. At end return answer.\n\nWe produce virtual code with arrows, decisions. Let's craft stepwise. Need Start, End. Use Decision where needed. Provide explanation per line. Use 虛擬碼步驟 syntax. Use arrow for next step.\n\nLet's produce. Use comments in Chinese.\n\nLet's ensure each line includes the arrow after step if there's more steps. Provide indentation? It's okay.\n\nWe might show loops: For i from 0 to n-1 etc.\n\nOk. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length of nums // 取得陣列長度  \n→ Decision: 如果 n < 3? // 若元素不足三個，無法形成長度≥3的算術子序列  \n  Yes → Step 2: Return 0 // 直接回傳 0  \n  No  → Step 3: Initialize answer ← 0 // 用於累加所有算術子序列的個數  \n      → Step 4: Initialize dp[0…n-1] as empty maps // dp[i] 存儲以 nums[i] 結尾且以差值 diff 為鍵的子序列個數  \n→ Step 5: For i from 0 to n-1 // 逐一考慮每個索引作為子序列的結尾  \n    → Step 6: For j from 0 to i-1 // 對所有前面的索引進行配對  \n      → Step 7: diff ← nums[i] - nums[j] // 計算差值  \n      → Step 8: count_j ← dp[j][diff] if exists else 0 // 取得以 nums[j] 結尾且差值為 diff 的子序列個數  \n      → Step 9: answer ← answer + count_j // 每個以 j 結尾的子序列都能擴充成長度≥3的算術子序列  \n      → Step 10: dp[i][diff] ← dp[i][diff] + count_j + 1 // 將差值 diff 的子序列數量更新，+1 為新建的兩元素序列 (i,j)  \n→ Step 11: Return answer // 回傳總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        dp = [defaultdict(int) for _ in range(n)]\n        total = 0\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                count = dp[j][diff]\n                dp[i][diff] += count + 1\n                total += count\n        return total\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入中的「nums =」字串去除，保留列表字面量\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        list_str = data[start:end+1]\n    except ValueError:\n        list_str = data\n    nums = ast.literal_eval(list_str)\n    solution = Solution()\n    result = solution.numberOfArithmeticSlices(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,4,6,8,10]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [7,7,7,7,7]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode309.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: maximum profit with cooldown. Typical DP: hold, sold, rest states. We'll present pseudocode line by line with explanations. Must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows. Let's craft.\n\nOutline:\n\nStart\n→ Initialize variables: n, maxProfit, hold, rest, sold\n→ For each day i from 0 to n-1:\n    → Update hold: max(prevHold, prevRest - price[i]) // keep holding or buy today\n    → Update sold: prevHold + price[i] // sell today\n    → Update rest: max(prevRest, prevSold) // rest day after cooldown or staying rest\n→ After loop: return max(rest, sold) // max profit at end\nEnd\n\nNeed to use decision? Not many decision but can include. Use arrows. Provide lines sequential.\n\nLet's produce.\n\nMake sure each line ends with comment after //.\n\nLet's produce the pseudocode.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize: n ← length(prices) // 取得天數  \n→ Initialize: hold ← -∞ // 第一天持有股票的最大利潤（尚未買入）  \n→ Initialize: rest ← 0 // 未持有股票且沒有進行交易的最大利潤  \n→ Initialize: sold ← -∞ // 今天賣出的最大利潤（需經過冷卻）  \n\n→ For i from 0 to n-1: // 遍歷每一天  \n  Decision: 是否進行交易? // 判斷是否買入或賣出  \n   Yes → Step: newHold ← max(hold, rest - prices[i]) // 保持持股或今天買入  \n   Yes → Step: newSold ← hold + prices[i] // 今天賣出  \n   Yes → Step: newRest ← max(rest, sold) // 休息或冷卻日  \n   No  → // 不做任何變動  \n      // 保持上一日的狀態  \n      newHold ← hold  \n      newSold ← sold  \n      newRest ← rest  \n   // 更新狀態為今天結束時的值  \n   hold ← newHold  \n   sold ← newSold  \n   rest ← newRest  \n\n→ Decision: 最後是否持有? // 取最大利潤  \n  Yes → Step: result ← max(rest, sold) // 可能在賣出或休息結束  \n  No  → Step: result ← rest // 若未持股則仍為 rest  \n\n→ Output result // 回傳最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef max_profit_with_cooldown(prices):\n    \"\"\"\n    動態規劃求解帶冷卻期的股票最大利潤。\n    - hold: 目前持有股票的最大利潤（可買或已持有）\n    - sold: 今天賣出的最大利潤（必須經過冷卻）\n    - rest: 今天休息或冷卻結束後的最大利潤\n    \"\"\"\n    if not prices:\n        return 0\n\n    # 初始狀態\n    hold = -prices[0]  # 第一天買進\n    sold = 0           # 尚未賣出\n    rest = 0           # 未持股且未冷卻\n\n    # 從第二天開始迭代\n    for price in prices[1:]:\n        prev_sold = sold\n        # 1. 今日賣出：必須從之前持有的狀態轉換\n        sold = hold + price\n        # 2. 今日持有：要么保持持有，要么在休息後買進\n        hold = max(hold, rest - price)\n        # 3. 今日休息：要么繼續休息，要么從剛賣出的狀態冷卻\n        rest = max(rest, prev_sold)\n\n    # 最終結果：可以是賣出後或休息後的最大利潤\n    return max(sold, rest)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，支援形如 'prices = [1,2,3,0,2]' 或直接給出列表字面量。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    if '=' in data:\n        # 取等號右邊的部分\n        data = data.split('=', 1)[1].strip()\n    # 使用 eval 解析為 Python 物件，假設輸入安全\n    try:\n        return eval(data, {}, {})\n    except Exception:\n        # 若解析失敗，回傳空列表\n        return []\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    prices = parse_input(input_data)\n    result = max_profit_with_cooldown(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,2,3,0,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "prices = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode275.json",
    "problem_index_in_file": 0,
    "title": "H-Index II",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation after //. Must use virtual code arrow syntax Start, End, Decision:, Yes →, No → etc. Must not output actual code. Must reflect algorithm that runs in log time: binary search over sorted array to find smallest index where citations[i] >= n-i. The h-index is min(citations[i], n-i). Usually we find largest h such that citations[n-h] >= h. We can implement binary search on index i. But need steps: Start, input array, compute n, low=0, high=n-1, answer=0. While low <= high: mid=(low+high)//2. If citations[mid] >= n-mid: answer = n-mid; low = mid+1 else high = mid-1. After loop End, output answer. Provide explanation each step. Use virtual code: \"Start\" etc. Also maybe include \"While low <= high:\" step? Provide lines accordingly. Ensure each line has virtual code step and explanation comment. Use arrow syntax for decisions. For while loop, we can use Decision: while condition? But maybe we just treat as a loop: \"While low <= high:\" then inside steps. Use \"→\" for each step inside loop. Use \"Decision:\" for the while condition. Might need nested decision for if. Use \"Decision:\" for binary condition. Provide explanation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Input citations array, n = length(citations) // 取得論文數量\n→ low = 0, high = n - 1, hIndex = 0 // 初始化搜尋範圍與答案\n→ Decision: low <= high? // 判斷是否還有範圍可搜尋\n    Yes → mid = (low + high) // 2 // 取中間索引\n    → Decision: citations[mid] >= n - mid? // 檢查中點是否符合 h-index 條件\n        Yes → hIndex = n - mid // 更新 h-index 為可行最大值\n        → low = mid + 1 // 向右搜尋更大 h-index\n        No  → high = mid - 1 // 向左搜尋更小範圍\n    No  → End // 搜尋結束\n→ Output hIndex // 回傳計算得到的 h-index\n\nNeed to maintain arrow formatting: Use \"→\" before each step. Decision lines: \"Decision: ...\" with indent. Use Yes →, No → etc.\n\nMake sure each line includes \"虛擬碼步驟\" then space then \"// 解釋\". Let's format accordingly.\n\nExample line: \"Start // 程式開始執行\". Good.\n\nFor decision lines, e.g., \"Decision: low <= high? // 判斷是否還有範圍可搜尋\".\n\nThen indented lines: maybe add spaces before \"Yes →\" etc. Use tab or spaces? In example, they used indentation. We'll follow similar. So inside Decision, we indent with spaces. Provide \"Yes →\" lines accordingly.\n\nMake sure each line ends with // ... comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input citations array, n = length(citations) // 取得論文數量  \n→ low = 0, high = n - 1, hIndex = 0 // 初始化搜尋範圍與答案  \n→ Decision: low <= high? // 判斷搜尋範圍是否還有可用  \n    Yes → mid = (low + high) // 2 // 取中間索引  \n    → Decision: citations[mid] >= n - mid? // 檢查中點是否符合 h‑index 條件  \n        Yes → hIndex = n - mid // 更新為目前可行的最大 h-index  \n        → low = mid + 1 // 向右搜尋可能更大的 h-index  \n        No  → high = mid - 1 // 向左搜尋更小範圍  \n    No  → End // 搜尋結束  \n→ Output hIndex // 回傳計算得到的 h-index",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef h_index(citations):\n    n = len(citations)\n    left, right = 0, n - 1\n    h = 0\n    while left <= right:\n        mid = (left + right) // 2\n        if citations[mid] >= n - mid:\n            h = max(h, n - mid)\n            left = mid + 1\n        else:\n            right = mid - 1\n    return h\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract a list of integers from input such as:\n        'citations = [0,1,3,5,6]'\n    or simply\n        '[0,1,3,5,6]'\n    \"\"\"\n    match = re.search(r'\\[.*?\\]', data, re.DOTALL)\n    if not match:\n        return []\n    list_str = match.group(0)\n    try:\n        return ast.literal_eval(list_str)\n    except Exception:\n        return []\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    citations = parse_input(data)\n    if not isinstance(citations, list):\n        return\n    result = h_index(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode403.json",
    "problem_index_in_file": 0,
    "title": "Frog Jump",
    "description_snippet": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: Frog Crossing River. We need step by step logic: input stones array, initial position index 0, initial lastJump 0? Actually first jump must be 1. We need to determine if possible to reach last stone. It's a classic LeetCode problem 403. Approach: DFS with memo or DP with set of reachable jumps at each index. We'll produce algorithm: Use a map from stone index to set of jump lengths that can reach it. Start: index 0 has jump set {0}. For each stone, for each jump in its set, consider next jumps = k-1,k,k+1 if >0, if target stone exists. We can use a set for stones to quick lookup. At the end, if last stone index's set non-empty, success.\n\nWe produce virtual code steps: Start, Input stones list, Build set, Initialize map, For loop over stones, For loop over jumps, compute next, check if stone exists, add to map. After loops, check if last stone reachable.\n\nWe need to produce each line with arrow and explanation. We must not output actual code. Just virtual steps.\n\nLet's produce something like:\n\nStart\n→ Step 1: Read array stones // 获得石头位置列表\n→ Step 2: Set stoneSet = stones as hash set // 方便查找目标石头\n→ Step 3: Initialize map indexToJumps = {} // 每个石头索引对应可到达的跳跃长度集合\n→ Step 4: For i from 0 to stones.length-1:\n    → Decision: 是否是起点？ // 第一个石头开始\n        Yes → Set indexToJumps[i] = {0} // 起点可视为前一次跳跃为0，方便计算\n        No → // 之后由前面石头的跳跃决定\n→ Step 5: For each stone index i in ascending order:\n    → For each jump k in indexToJumps[i]:\n        → For nextJump in [k-1, k, k+1]:\n            → Decision: nextJump > 0? // 必须正跳\n                Yes → target = stones[i] + nextJump\n                    → Decision: target in stoneSet? // 目标石头存在\n                        Yes → idx = index of target // 通过查表获取索引\n                            → Add nextJump to indexToJumps[idx] // 记录可达跳跃\n                        No → // 跳不到石头，忽略\n                No → // 跳跃为非正，忽略\n→ Step 6: lastIndex = stones.length-1\n→ Step 7: Decision: indexToJumps[lastIndex] not empty? // 是否有跳跃可达最后石头\n    Yes → Output \"True\" // 可跨河\n    No  → Output \"False\" // 不可跨河\nEnd\n\nBut we must align with the format: each line \"虛擬碼步驟\" + \" // 解釋/說明\". Use arrows and Decision.\n\nWe need to produce each step line by line. For loops maybe multi-level indent? The example shows indentation: Indentation using spaces.\n\nWe should maintain structure: Start, → Step..., Decision lines with indentation. Use \"→ Decision:\" lines with Yes/No branch arrows.\n\nWe cannot output code, only virtual steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 stones 陣列 // 取得所有石頭的位置，已升序排列  \n→ Step 2: 建立 stoneSet = {stones[i]}  // 用 hash 集合方便 O(1) 查找  \n→ Step 3: 初始化 indexToJumps 為空映射 // 每個石頭索引對應可到達的跳距集合  \n→ Step 4: For i 從 0 到 stones.length-1  \n    → Decision: i 為起點？ // 第一顆石頭  \n        Yes → indexToJumps[i] = {0} // 起點視為前一次跳距為 0，方便後續計算  \n        No → // 之後的石頭不直接設定，等待前面石頭推算  \n→ Step 5: For i 從 0 到 stones.length-1  \n    → For each k 在 indexToJumps[i]  \n        → For nextJump 在 {k-1, k, k+1}  \n            → Decision: nextJump > 0? // 跳距必須為正  \n                Yes → target = stones[i] + nextJump  \n                    → Decision: target 存在於 stoneSet? // 有石頭可以落腳  \n                        Yes → idx = index of target in stones  \n                            → Add nextJump 至 indexToJumps[idx] // 記錄可到達跳距  \n                        No → // 目標不是石頭，跳不進去，忽略  \n                No → // 跳距非正，直接忽略  \n→ Step 6: lastIndex = stones.length - 1  \n→ Decision: indexToJumps[lastIndex] 非空？ // 是否有任何跳距能抵達最後石頭  \n    Yes → Step 7: 輸出 True // 能跨河  \n    No  → Step 7: 輸出 False // 無法跨河  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def canCross(self, stones):\n        stone_set = set(stones)\n        jumps = {stone: set() for stone in stones}\n        jumps[0].add(0)  # 起點前一次跳距視為 0\n\n        for stone in stones:\n            for k in jumps[stone]:\n                for step in (k - 1, k, k + 1):\n                    if step > 0 and stone + step in stone_set:\n                        jumps[stone + step].add(step)\n\n        return bool(jumps[stones[-1]])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入：預期格式為 \"stones = [0,1,3,5,6,8,12,17]\"\n    if \"stones\" in data:\n        try:\n            _, list_part = data.split(\"=\", 1)\n            stones = eval(list_part.strip())\n        except Exception:\n            # 若解析失敗，嘗試直接 eval 整個輸入\n            stones = eval(data)\n    else:\n        # 若輸入直接是列表字面值\n        stones = eval(data)\n\n    sol = Solution()\n    result = sol.canCross(stones)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stones = [0,1,3,5,6,8,12,17]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "stones = [0,1,2,3,4,8,9,11]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  }
]