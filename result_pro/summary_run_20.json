{
  "run_index": 20,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 386,
  "generation_or_validation_failure_count": 53,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    content = sys.stdin.read()\n    lines = content.splitlines()\n    print(f'檔案共有 {len(lines)} 行')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with steps line by line, each line includes \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow →, Decision, Start, End. We need to reflect requirement: open data.txt, read lines, count, output number of lines; if file not found, show \"找不到檔案！\". Use with and try/except.\n\nWe need to present structure of steps. Example:\n\nStart\n→ Step 1: try // start try block\n→ Decision: 檔案是否存在? // try to open file, but actual check is try open. But we can say try open.\n\nActually typical structure:\n\nStart\n→ Step 1: try // 嘗試開啟檔案\n    → Step 2: with open('data.txt', 'r') as f: // 使用 with 來開啟檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: print('總行數:', count) // 輸出行數\n    → Decision: 是否有任何例外? // 但 in except block\nexcept FileNotFoundError: // 如果檔案不存在\n    → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut need to use Decision arrow for if? maybe use Decision: 檔案是否存在? but we can't check directly. But we can use Decision: 檔案開啟成功? Yes or No. For simplicity, use Decision: 檔案開啟成功? (Yes → count, No → print error). But using try/except is better.\n\nBut requirement: Use with + try/except. So we can structure:\n\nStart\n→ Decision: 試著以 with open('data.txt', 'r')? // 這裡用 try block\n    Yes → Step: with open('data.txt', 'r') as f: // 開啟檔案\n        → Step: lines = f.readlines()\n        → Step: count = len(lines)\n        → Step: print('總行數:', count)\n    No → Step: print('找不到檔案！')\nEnd\n\nBut need to use try/except. Use Step: try // start try block. Then with. And except FileNotFoundError.\n\nBetter:\n\nStart\n→ Step 1: try // 嘗試執行以下程式碼\n    → Step 2: with open('data.txt', 'r') as f: // 用 with 開啟檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: print('總行數:', count) // 輸出行數\n    → Decision: 是否發生例外? // 判斷是否有例外\n        Yes → Step 6: print('找不到檔案！') // 處理檔案不存在的例外\n        No  → // 無例外，程式正常結束\nEnd\n\nBut we need to specify except block.\n\nBetter use typical structure:\n\nStart\n→ Step 1: try // 開始 try 區塊\n    → Step 2: with open('data.txt', 'r') as f: // 使用 with 開啟檔案\n        → Step 3: lines = f.readlines() // 讀取檔案所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: print('總行數:', count) // 輸出總行數\n→ Decision: 是否拋出 FileNotFoundError? // 這裡判斷例外\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n    No  → // 正常結束\nEnd\n\nBut we cannot have Decision after try block; we need except. However for virtual code, we can simulate Decision: if exception? It's fine.\n\nBut we need to use arrows: →.\n\nThus final output:\n\nStart // 程式開始執行\n→ Step 1: try // 開始 try 區塊\n    → Step 2: with open('data.txt', 'r') as f: // 用 with 開啟檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: print('總行數:', count) // 輸出行數\n→ Decision: 是否拋出 FileNotFoundError? // 檢查是否發生檔案不存在例外\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n    No  → // 正常結束，無需額外操作\nEnd // 程式執行結束\n\nBut we need to keep consistent indentation? The example shows indentation by spaces but we can use indent. Use arrow only once per step.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: try // 嘗試執行以下程式碼\n    → Step 2: with open('data.txt', 'r') as f: // 使用 with 開啟檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: print('總行數:', count) // 輸出行數\n→ Decision: 是否發生 FileNotFoundError? // 判斷是否拋出例外\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n    No  → // 程式正常結束\nEnd // 程式執行結束\n\nThis is okay.\n\nBut the requirement: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\" The example uses indentation of \"Decision:\" with nested steps inside. We should adhere to that.\n\nThus output lines exactly:\n\nStart // 程式開始執行\n→ Step 1: try // 嘗試執行以下程式碼\n    → Step 2: with open('data.txt', 'r') as f: // 用 with 開啟檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: print('總行數:', count) // 輸出行數\n→ Decision: 是否拋出 FileNotFoundError? // 檢查是否發生檔案不存在例外\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n    No  → // 正常結束，無需額外操作\nEnd // 程式執行結束\n\nYes.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: try // 嘗試執行以下程式碼  \n → Step 2: with open('data.txt', 'r') as f: // 用 with 開啟檔案  \n  → Step 3: lines = f.readlines() // 讀取所有行  \n  → Step 4: count = len(lines) // 計算行數  \n  → Step 5: print('總行數:', count) // 輸出行數  \n→ Decision: 是否拋出 FileNotFoundError? // 檢查是否發生檔案不存在例外  \n Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息  \n No  → // 正常結束，無需額外操作  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,5,6,2,2]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 5, 6, 2, 2]'"
        }
      ],
      "generated_code": "import random\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳結果列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 讀取整個標準輸入\n    code = sys.stdin.read()\n\n    # 執行輸入的程式碼，確保 roll_dice 可用\n    exec_globals = {\"roll_dice\": roll_dice, \"__builtins__\": __builtins__}\n    exec(code, exec_globals)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Follow format: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. The user wants a function roll_dice(n) using random module, simulate rolling n times 6-sided die, return list of results. So produce steps: Start, define function, initialize list, loop n times, generate random integer 1-6, append to list, after loop return list, End. Include random import. Use virtual steps. We must not output actual code, just virtual code. Use arrow for each step. For loops: maybe Decision: Loop until count < n? Use While. Provide explanation. Let's produce.\n\nWe need to output line by line. Let's produce:\n\nStart\n→ Step: Import random module // 引入 random 模組\n→ Step: 定義函數 roll_dice(n) // 建立 roll_dice 函數，參數 n\n    → Step: 初始化結果清單 results = [] // 用來儲存每次擲骰結果\n    → Step: 初始化計數器 i = 0 // 計算已擲幾次\n    → Decision: i < n? // 檢查是否已擲完所有 n 次\n        Yes → Step: 產生隨機數 die = random.randint(1,6) // 擲一顆六面骰\n        → Step: 將 die 加入 results // 把結果存進清單\n        → Step: i = i + 1 // 增加計數器\n        → Decision: i < n? // 重複檢查\n            ... (but need to use loop). Might instead use While loop: Decision: i < n? Yes → ... No → ...\n    → Step: 回傳 results // 返回所有結果清單\nEnd\n\nBut we need to be clear: use loop. Use Decision and Yes/No arrows. Let's structure:\n\nStart\n→ Step: Import random module // 引入 random\n→ Step: 定義函數 roll_dice(n) // 定義\n    → Step: 初始化空清單 results // []\n    → Step: 初始化 i = 0 // 計數\n    → Decision: i < n? // 判斷是否還要擲\n        Yes → Step: die = random.randint(1,6) // 擲骰\n        → Step: results.append(die) // 存入清單\n        → Step: i = i + 1 // 迴圈計數\n        → Decision: i < n? // 重複\n            Yes → (loop back to step above)\n            No  → Step: return results // 回傳\nEnd\n\nBut we need arrow back. Might use \"→\" for loops. But we can show loop by decision with Yes leading back. But we need to indicate the loop. Maybe better:\n\nStart\n→ Step: Import random // 引入模組\n→ Step: 定義函數 roll_dice(n) // 建立函式\n    → Step: 初始化 results = [] // 清單\n    → Step: 初始化 i = 0 // 計數\n    → Decision: i < n? // 判斷是否完成\n        Yes → Step: die = random.randint(1,6) // 擲骰\n        → Step: results.append(die) // 存入\n        → Step: i = i + 1 // 計數增加\n        → Decision: i < n? // 重複\n            Yes → [回到 \"Yes\" 之上] // 繼續循環\n            No  → Step: return results // 回傳\nEnd\n\nWe can use \"→\" for arrows; but need to keep each line separate. We'll just list each step.\n\nLet's write the lines:\n\nStart // 程式開始執行\n→ Step 1: Import random // 引入 random 模組\n→ Step 2: 定義函數 roll_dice(n) // 建立 roll_dice 函式\n    → Step 3: 初始化 results = [] // 用於儲存擲骰結果\n    → Step 4: 初始化 i = 0 // 追蹤已擲次數\n    → Decision: i < n? // 檢查是否還有未擲的骰子\n        Yes → Step 5: die = random.randint(1, 6) // 擲一顆六面骰\n        → Step 6: results.append(die) // 將結果加入清單\n        → Step 7: i = i + 1 // 計數器加一\n        → Decision: i < n? // 再次檢查是否完成\n            Yes → (回到 Step 5) // 重複擲骰\n            No  → Step 8: return results // 回傳所有結果\nEnd // 程式執行結束\n\nBut we need each line separate. The indentation may be optional. But we need to show arrow and explanation. Each line is a separate line, including those inside function. But we can use indentation to show structure. We need to ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nThus produce lines exactly:\n\nStart // 程式開始執行\n→ Step 1: Import random // 引入 random 模組\n→ Step 2: 定義函數 roll_dice(n) // 建立 roll_dice 函式\n    → Step 3: 初始化 results = [] // 用於儲存擲骰結果\n    → Step 4: 初始化 i = 0 // 追蹤已擲次數\n    → Decision: i < n? // 檢查是否還有未擲的骰子\n        Yes → Step 5: die = random.randint(1, 6) // 擲一顆六面骰\n        → Step 6: results.append(die) // 將結果加入清單\n        → Step 7: i = i + 1 // 計數器加一\n        → Decision: i < n? // 再次檢查是否完成\n            Yes → (回到 Step 5) // 重複擲骰\n            No  → Step 8: return results // 回傳所有結果\nEnd // 程式執行結束\n\nBut the line \"Yes → (回到 Step 5)\" may not be needed as separate line, but it's a decision branch. Might just keep as \"Yes → 回到 Step 5\" as part of the decision.\n\nBut the instructions say \"逐行地產生虛擬碼\" and each line must contain \"虛擬碼步驟\" and explanation. So the line \"Yes → (回到 Step 5)\" can be considered a step. But it might be confusing. Instead we can restructure:\n\nDecision: i < n? // 檢查是否還有未擲的骰子\n    Yes → Step 5: die = random.randint(1, 6) // 擲一顆六面骰\n    → Step 6: results.append(die) // 將結果加入清單\n    → Step 7: i = i + 1 // 計數器加一\n    → Decision: i < n? // 再次檢查是否完成\n        Yes → (循環回到 \"Yes\" 分支) // 重新擲骰\n        No  → Step 8: return results // 回傳所有結果\n\nBut each line must have step or decision. Let's do as:\n\nDecision: i < n? // 檢查是否還有未擲的骰子\n    Yes → Step 5: die = random.randint(1, 6) // 擲一顆六面骰\n    → Step 6: results.append(die) // 將結果加入清單\n    → Step 7: i = i + 1 // 計數器加一\n    → Decision: i < n? // 再次檢查是否完成\n        Yes → (回到 \"Yes\" 分支) // 重複擲骰\n        No  → Step 8: return results // 回傳所有結果\n\nBut we need each line separated. The \"Yes → (回到 ...)\" is a step; we can just say \"Yes → 回到 Step 5\" and explanation. That may be fine.\n\nThus final output:\n\nStart // 程式開始執行\n→ Step 1: Import random // 引入 random 模組\n→ Step 2: 定義函數 roll_dice(n) // 建立 roll_dice 函式\n    → Step 3: 初始化 results = [] // 用於儲存擲骰結果\n    → Step 4: 初始化 i = 0 // 追蹤已擲次數\n    → Decision: i < n? // 檢查是否還有未擲的骰子\n        Yes → Step 5: die = random.randint(1, 6) // 擲一顆六面骰\n        → Step 6: results.append(die) // 將結果加入清單\n        → Step 7: i = i + 1 // 計數器加一\n        → Decision: i < n? // 再次檢查是否完成\n            Yes → Step 5 // 重複擲骰\n            No  → Step 8: return results // 回傳所有結果\nEnd // 程式執行結束\n\nBut the step \"Step 5\" repeated may be confusing. Maybe better use \"Yes → (循環回到 Step 5)\" but we can't produce actual code. But it's okay.\n\nAlternatively, we can use a While loop: Decision: i < n? Yes → Step 5... No → Step 8. That covers loop.\n\nI'll output accordingly. Ensure formatting: each line with \"虛擬碼步驟\" and \"// 解釋\". No actual code. Let's deliver.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random // 引入 random 模組  \n→ Step 2: 定義函數 roll_dice(n) // 建立 roll_dice 函式  \n&nbsp;&nbsp;&nbsp;→ Step 3: 初始化 results = [] // 用於儲存擲骰結果  \n&nbsp;&nbsp;&nbsp;→ Step 4: 初始化 i = 0 // 追蹤已擲次數  \n&nbsp;&nbsp;&nbsp;→ Decision: i < n? // 檢查是否還有未擲的骰子  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: die = random.randint(1, 6) // 擲一顆六面骰  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: results.append(die) // 將結果加入清單  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: i = i + 1 // 計數器加一  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: i < n? // 再次檢查是否完成  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5 // 重複擲骰  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 8: return results // 回傳所有結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量函式執行時間，回傳四捨五入到小數點 3 位的秒數。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼，並在當前全域命名空間執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with \"虛擬碼步驟\" and then \"// 解釋\". Use arrow \"→\" etc. Should start with Start. For measuring time, import time, define function measure_time, start timer, call func(*args), end timer, compute elapsed, round to 3 decimals, return result. Also may return value of func? The requirement: measure_time(func, *args) returns time taken in seconds rounded to 3 decimal places. Probably also returns result? The requirement says \"回傳結果 (四捨五入到小數點 3 位)\" - \"result\" might mean the elapsed time. So return elapsed. Could also return the result of func? Not specified, but likely just return elapsed. We can also return both maybe. Let's assume just elapsed. Provide virtual code lines. Use Decision? Not needed. Just straightforward.\n\nLet's craft steps:\n\nStart\n→ Step 1: Import time module // 引入時間模組\n→ Step 2: Define function measure_time(func, *args) // 定義測時函式\n→ Step 3: Record start_time = time.time() // 記錄開始時間\n→ Step 4: Execute result = func(*args) // 執行目標函式並取得結果\n→ Step 5: Record end_time = time.time() // 記錄結束時間\n→ Step 6: Compute elapsed = end_time - start_time // 計算耗時\n→ Step 7: Round elapsed to 3 decimal places: rounded_time = round(elapsed, 3) // 四捨五入\n→ Step 8: Return rounded_time // 回傳時間\nEnd\n\nWe might also mention returning result? but not necessary. Use virtual code arrow. Provide each line. Also may need comment \"Start\" and \"End\". Use \"Start\" and \"End\" lines.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 定義測時函式  \n→ Step 3: Record start_time = time.time() // 記錄開始時間  \n→ Step 4: Execute result = func(*args) // 執行目標函式並取得結果  \n→ Step 5: Record end_time = time.time() // 記錄結束時間  \n→ Step 6: Compute elapsed = end_time - start_time // 計算執行耗時  \n→ Step 7: Round elapsed to 3 decimal places: rounded_time = round(elapsed, 3) // 四捨五入至小數點三位  \n→ Step 8: Return rounded_time // 回傳四捨五入後的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"orange\",\"melon\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'orange', 'melon', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略輸入（保證程式可通用於任何合法輸入）\n    _ = sys.stdin.read()\n\n    # 初始集合\n    fruits = {'apple', 'banana'}\n\n    # 新增 'orange'\n    fruits.add('orange')\n\n    # 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 移除 'banana'\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的 'pineapple'（不會拋錯）\n    fruits.discard('pineapple')\n\n    # 輸出結果\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Each line: \"虛擬碼步驟 // 解釋\" with arrow etc. Must follow format with Start, End, Decision, Yes/No? But here just operations.\n\nWe can just list steps:\n\nStart\n→ Step 1: 初始化集合 fruits = {'apple', 'banana'} // 建立初始集合\n→ Step 2: fruits.add('orange') // 加入 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增兩個元素\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: print(fruits) // 輸出結果\nEnd\n\nBut ensure each line has arrow and explanation after space. Also use correct formatting: \"虛擬碼步驟 // 解釋\". Example: \"Start // 程式開始執行\". So use \"Start // 程式開始執行\". Next lines with arrow \"→\". Ensure there is no extra content. Let's produce.\n\nCheck: \"虛擬碼步驟\" could be \"Step 1: ...\" but arrow preceding. Example: \"→ Step 1: Initialize set\" etc. Good.\n\nWe also need to show that update uses list. The explanation must be short. Use Chinese. Use \"→ Step 2: fruits.add('orange') // 加入橘子\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化集合 fruits = {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'（不會錯誤）  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.76TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.76 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate() -> str:\n    \"\"\"\n    向匯率 API 取得美元兌台幣匯率，並回傳格式化字串。\n    若發生錯誤則回傳錯誤訊息。\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        data = resp.json()\n        rate = data['rates']['TWD']\n        return f'目前美元匯率：約 {rate:.2f} TWD'\n    except Exception:\n        return '更新失敗，請檢查網路連線'\n\ndef start_gui() -> None:\n    \"\"\"\n    建立 tkinter GUI，包含顯示匯率的 Label 與更新按鈕。\n    \"\"\"\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label():\n        \"\"\"從 API 取得匯率並更新 label 文字。\"\"\"\n        result = fetch_rate()\n        label.config(text=result)\n\n    tk.Button(win, text='更新匯率', command=update_label).pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    # 先讀取所有標準輸入，若有輸入則視為測試場景\n    input_text = sys.stdin.read()\n    if input_text.strip():\n        # 若輸入中包含「更新匯率」，執行 API 取得並列印結果\n        if '更新匯率' in input_text:\n            print(fetch_rate())\n        # 其他輸入可視需求自行處理\n    else:\n        # 若沒有輸入，啟動 GUI\n        start_gui()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with comments. Use Start, End, Decision. Provide steps for importing modules, creating tkinter window, defining function to fetch API, update label, button, loop. Provide comments. Use arrows. No actual code. Just virtual steps. Ensure each line ends with comment.\n\nLet's craft.\n\nFormat:\n\nStart // 程式開始執行\n→ Step 1: 匯入 requests 模組 // 需要發送 HTTP 請求\n→ Step 2: 匯入 tkinter 模組 // 用於建立 GUI\n→ Step 3: 建立主視窗 window = Tk() // 建立 tkinter 視窗\n→ Step 4: 設定視窗標題 \"美元兌台幣匯率\" // 提供使用者訊息\n→ Step 5: 建立 Label 顯示匯率 label = Label(window, text=\"匯率資訊\") // 預設文字\n→ Step 6: 放置 Label 在窗口中 label.pack() // 顯示\n→ Step 7: 定義函式 fetch_rate() // 用來向 API 取得匯率\n    → Step 8: 發送 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率\n    → Decision: 如果回應成功?\n        Yes → Step 9: 解析 JSON 取得 'rates' → 'TWD' // 取得台幣匯率\n        Yes → Step 10: 建立顯示文字 f\"USD/TWD = {rate}\" // 準備顯示\n        Yes → Step 11: 更新 Label 文字 label.config(text=display_text) // 更新 GUI\n        No  → Step 12: 設定 Label 文字 \"請求失敗\" // 顯示錯誤訊息\n→ Step 13: 建立 Button 按鈕 button = Button(window, text=\"更新匯率\", command=fetch_rate) // 按鈕觸發函式\n→ Step 14: 放置 Button 在窗口 button.pack() // 顯示按鈕\n→ Step 15: 啟動主循環 window.mainloop() // 進入 GUI 事件循環\nEnd // 程式結束\n\nMake sure each line has arrow and comment. Use \"→\" or \"Yes →\" etc. Ensure lines after Decision show indentation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 匯入 requests 模組 // 需要發送 HTTP 請求\n→ Step 2: 匯入 tkinter 模組 // 用於建立 GUI\n→ Step 3: 建立主視窗 window = Tk() // 建立 tkinter 視窗\n→ Step 4: 設定視窗標題 \"美元兌台幣匯率\" // 提供使用者訊息\n→ Step 5: 建立 Label 顯示匯率 label = Label(window, text=\"匯率資訊\") // 預設文字\n→ Step 6: 放置 Label 在窗口中 label.pack() // 顯示\n→ Step 7: 定義函式 fetch_rate() // 用來向 API 取得匯率\n    → Step 8: 發送 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率\n    → Decision: 回應成功? // 檢查 HTTP 狀態碼\n        Yes → Step 9: 解析 JSON 取得 'rates' → 'TWD' // 取得台幣匯率\n        Yes → Step 10: 建立顯示文字 f\"USD/TWD = {rate}\" // 準備顯示\n        Yes → Step 11: 更新 Label 文字 label.config(text=display_text) // 更新 GUI\n        No  → Step 12: 設定 Label 文字 \"請求失敗\" // 顯示錯誤訊息\n→ Step 13: 建立 Button 按鈕 button = Button(window, text=\"更新匯率\", command=fetch_rate) // 按鈕觸發函式\n→ Step 14: 放置 Button 在窗口 button.pack() // 顯示按鈕\n→ Step 15: 啟動主循環 window.mainloop() // 進入 GUI 事件循環\nEnd // 程式結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqukzze5i.py\", line 80, in <module>\n    main()\n  File \"/tmp/tmpqukzze5i.py\", line 47, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [1], [2], [2], [], [1], [2], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # map value -> index in the list\n        self.val_to_index = {}\n        # list of values\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        \"\"\"Insert val into the set if not present.\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"Remove val from the set if present.\"\"\"\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # Swap the value to remove with the last value\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # Remove last element\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"Return a random element from the set.\"\"\"\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two lists (operations and arguments)\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'          # close the first list\n    args_str = '[' + parts[1].lstrip()  # add opening bracket for second list\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            result.append(None)  # represent null\n        elif op == \"insert\":\n            res = obj.insert(arg[0])\n            result.append(res)\n        elif op == \"remove\":\n            res = obj.remove(arg[0])\n            result.append(res)\n        elif op == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n        else:\n            # Unknown operation; skip or raise error\n            result.append(None)\n\n    # Format output: null, true, false, numbers\n    formatted = []\n    for val in result:\n        if val is None:\n            formatted.append(\"null\")\n        elif isinstance(val, bool):\n            formatted.append(\"true\" if val else \"false\")\n        else:\n            formatted.append(str(val))\n    print(\"[\" + \", \".join(formatted) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code, step-by-step, for RandomizedSet class implementation. Each line should be \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. We need to describe the class structure and methods. The algorithm uses vector for values and unordered_map from val to index. insert: check if exists, if not push back, update map. remove: check if exists, if yes swap with last element, update map, pop back, delete map entry. getRandom: return vector[random index]. Each operation average O(1). We need to present in stepwise pseudo code, with decisions. Let's produce:\n\nStart // 初始化 RandomizedSet\n→ Step 1: 建立空 vector values // 用於存儲元素\n→ Step 2: 建立空 hash map indices // key: val, value: index in values\nEnd // 準備完成\n\nThen each method: Insert, Remove, getRandom. For Insert:\n\nStart // insert(val)\n→ Decision: 如果 val 在 indices 中? // 檢查是否已存在\n    Yes → Step: 返回 false // 已存在，插入失敗\n    No  → Step: push_back val 到 values // 加入新元素\n        → Step: 設定 indices[val] = values.size() - 1 // 存儲索引\n        → Step: 返回 true // 插入成功\nEnd // insert 結束\n\nRemove similar:\n\nStart // remove(val)\n→ Decision: 如果 val 在 indices 中? // 檢查是否存在\n    Yes → Step: 找到 index = indices[val] // 獲取索引\n        → Step: lastVal = values.back() // 取得最後一個元素\n        → Decision: 如果 index != values.size()-1? // 是否不是最後一個\n            Yes → Step: values[index] = lastVal // 交換\n                → Step: indices[lastVal] = index // 更新 lastVal 的索引\n                → Step: values.pop_back() // 刪除最後一個\n                → Step: 刪除 indices[val] // 移除被刪除元素的映射\n                → Step: 返回 true // 成功\n            No  → Step: values.pop_back() // 直接刪除\n                → Step: 刪除 indices[val]\n                → Step: 返回 true\n    No  → Step: 返回 false // 沒有該元素\nEnd\n\ngetRandom:\n\nStart // getRandom()\n→ Step: idx = random_integer(0, values.size()-1) // 隨機索引\n→ Step: 返回 values[idx] // 返回隨機元素\nEnd\n\nAlso mention that random_integer uses built-in. Provide explanation. Ensure each line ends with // explanation. Use proper virtual arrows. Use \"Yes →\" and \"No →\" for decisions. For nested decisions, indent? The sample had indentation. We'll indent nested lines with spaces.\n\nLet's output accordingly.\n...done thinking.\n\nStart // RandomizedSet 初始化\n→ Step 1: 建立空 vector values // 存儲所有元素\n→ Step 2: 建立空 hash map indices // key: 值, value: 在 values 中的索引\nEnd // 準備完成\n\nStart // insert(val) // 插入元素\n→ Decision: 如果 val 在 indices 中? // 判斷元素是否已存在\n    Yes → Step: 返回 false // 已存在，插入失敗\n    No  → Step: push_back val 到 values // 加入新元素\n        → Step: indices[val] = values.size() - 1 // 記錄索引\n        → Step: 返回 true // 插入成功\nEnd // insert 結束\n\nStart // remove(val) // 刪除元素\n→ Decision: 如果 val 在 indices 中? // 判斷元素是否存在\n    Yes → Step: idx = indices[val] // 取得索引\n        → Step: lastVal = values.back() // 取得最後一個元素\n        → Decision: 如果 idx != values.size() - 1? // 是否不是最後一個\n            Yes → Step: values[idx] = lastVal // 交換位置\n                → Step: indices[lastVal] = idx // 更新 lastVal 的索引\n                → Step: values.pop_back() // 刪除最後一個\n                → Step: 删除 indices[val] // 移除被刪除元素的映射\n                → Step: 返回 true // 成功刪除\n            No  → Step: values.pop_back() // 直接刪除\n                → Step: 删除 indices[val]\n                → Step: 返回 true // 成功刪除\n    No  → Step: 返回 false // 元素不存在，刪除失敗\nEnd // remove 結束\n\nStart // getRandom() // 取得隨機元素\n→ Step: idx = random_integer(0, values.size() - 1) // 隨機索引\n→ Step: 返回 values[idx] // 回傳隨機選取的元素\nEnd // getRandom 結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.rows = m\n        self.cols = n\n        self.total = m * n\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    # Remove possible empty lines\n    data = [line for line in data if line.strip() != \"\"]\n    if len(data) < 2:\n        # If the two JSON arrays are on the same line separated by comma\n        combined = \" \".join(data)\n        parts = combined.split(\"],\", 1)\n        ops = json.loads(parts[0] + \"]\")\n        args = json.loads(parts[1].strip())\n    else:\n        ops = json.loads(data[0])\n        args = json.loads(data[1])\n\n    result = []\n    instance = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            instance = Solution(*arg)\n            result.append(None)\n        elif op == \"flip\":\n            result.append(instance.flip())\n        elif op == \"reset\":\n            instance.reset()\n            result.append(None)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output pseudo code line by line with explanation. It's a typical solution: maintain list of available indices, use reservoir or random index. Approach: flatten indices 0..m*n-1, maintain a map from selected index to last available index. Each flip: pick random k from [0, remaining-1]; map k to actual index via mapping or default k; then replace mapping of k with mapping of remaining-1; decrement remaining. Reset: clear mapping, remaining=m*n. That uses O(1) time per flip, O(m*n) space worst-case for map but average small? Actually map size up to remaining? We'll use hash map.\n\nWe produce virtual code: Start, initialize m,n, size, remaining, map. Then flip method: random index selection, map resolution, update map, decrement remaining, compute i,j, return. Reset: clear map, reset remaining. We must write pseudocode line by line with arrow.\n\nWe need to adhere to format: \"虛擬碼步驟 // 解釋\". Use arrows. We'll start with class definition? We might start with Start? For each method, use Start/End. Probably like:\n\nStart // 程式開始\n→ Step: 初始化 Solution(m,n) // 建構子\n    → Step: size ← m*n\n    → Step: remaining ← size\n    → Step: map ← empty\n→ End // 完成建構\n...\n\nBut we need to output step by step for each method. Possibly we present each method separately with its own Start/End. Let's produce:\n\nStart // 程式開始\n→ Step: Class Solution { // 定義 Solution 類別\n    → Step: Constructor(m, n) { // 建構子\n        → Step: this.m ← m\n        → Step: this.n ← n\n        → Step: this.size ← m * n\n        → Step: this.remaining ← this.size\n        → Step: this.map ← empty map\n    }\n    → Step: flip() { // 隨機翻轉\n        → Step: randIdx ← RandomInt(0, this.remaining - 1) // 隨機選取剩餘可翻轉位置\n        → Decision: 是否 map 含 randIdx? // 判斷映射表中是否已有對應\n            Yes → realIdx ← this.map[randIdx]\n            No  → realIdx ← randIdx\n        → Decision: 是否 map 含 this.remaining - 1? // 取得最後一個可翻轉位置的映射\n            Yes → lastIdx ← this.map[this.remaining - 1]\n            No  → lastIdx ← this.remaining - 1\n        → Step: this.map[randIdx] ← lastIdx // 更新映射\n        → Step: this.remaining ← this.remaining - 1 // 已翻轉一個位置\n        → Step: i ← realIdx / this.n\n        → Step: j ← realIdx % this.n\n        → Step: return [i, j] // 回傳翻轉後的位置\n    }\n    → Step: reset() { // 重置矩陣\n        → Step: this.remaining ← this.size\n        → Step: this.map ← empty map // 清空映射表\n    }\n}\nEnd // 程式結束\n\nBut each line must be a separate virtual code line. Use arrow for steps. Use decision blocks with Yes/No. Each step has explanation. Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Class Solution { // 定義 Solution 類別  \n→     Step: Constructor(m, n) { // 建構子，初始化矩陣尺寸  \n→         Step: this.m ← m // 記錄列數  \n→         Step: this.n ← n // 記錄列數  \n→         Step: this.size ← m * n // 總格子數  \n→         Step: this.remaining ← this.size // 尚未翻轉的格子數  \n→         Step: this.map ← empty map // 用於映射已選格子  \n→     } // 結束建構子  \n→     Step: flip() { // 隨機選取一個尚未翻轉的格子並翻轉  \n→         Step: randIdx ← RandomInt(0, this.remaining - 1) // 隨機索引  \n→         Decision: this.map contains randIdx? // 檢查映射表是否已存儲該索引  \n→             Yes → realIdx ← this.map[randIdx] // 取映射值作為實際索引  \n→             No  → realIdx ← randIdx // 若未映射，直接使用 randIdx  \n→         Decision: this.map contains this.remaining - 1? // 取得最後一個可用格子的映射  \n→             Yes → lastIdx ← this.map[this.remaining - 1] // 取映射值  \n→             No  → lastIdx ← this.remaining - 1 // 若未映射，直接使用  \n→         Step: this.map[randIdx] ← lastIdx // 更新映射表以「移除」已選格子  \n→         Step: this.remaining ← this.remaining - 1 // 已翻轉一格，減少剩餘數  \n→         Step: i ← realIdx / this.n // 計算行號  \n→         Step: j ← realIdx % this.n // 計算列號  \n→         Step: return [i, j] // 回傳已翻轉格子的座標  \n→     } // 結束 flip  \n→     Step: reset() { // 將所有格子重置為 0  \n→         Step: this.remaining ← this.size // 恢復剩餘格子數為全量  \n→         Step: this.map ← empty map // 清空映射表  \n→     } // 結束 reset  \n→ } // 結束類別定義  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Repeating Character Replacement",
      "source_file": "Leetcode/leetcode424.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn7js3uzo.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmpn7js3uzo.py\", line 39, in main\n    k = int(parts[1])\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'ABAB'"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuu7gzxsk.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmpuu7gzxsk.py\", line 39, in main\n    k = int(parts[1])\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'AABABBA'"
        }
      ],
      "generated_code": "import sys\n\ndef character_replacement(s: str, k: int) -> int:\n    \"\"\"回傳經過最多 k 次字元替換後，可得到的相同字元子串最大長度。\"\"\"\n    count = [0] * 26          # 26 個大寫英文字母的頻率\n    max_count = 0             # 當前窗口內最頻出字元的個數\n    left = 0                  # 左指標\n    res = 0                   # 最長長度\n\n    for right, ch in enumerate(s):\n        idx = ord(ch) - ord('A')\n        count[idx] += 1\n        max_count = max(max_count, count[idx])\n\n        # 若需要替換的字元超過 k，則收縮左側窗口\n        while (right - left + 1) - max_count > k:\n            left_idx = ord(s[left]) - ord('A')\n            count[left_idx] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n\n    return res\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 允許多種輸入格式，例如：\n    # 1) s = \"ABAB\", k = 2\n    # 2) ABAB 2\n    # 3) ABAB\\n2\n    cleaned = data.replace(',', ' ').replace('=', ' ').replace('\"', '').replace(\"'\", \"\")\n    parts = cleaned.split()\n\n    if len(parts) >= 2:\n        s = parts[0]\n        k = int(parts[1])\n    else:\n        lines = data.splitlines()\n        s = lines[0].strip()\n        k = int(lines[1].strip()) if len(lines) > 1 else 0\n\n    print(character_replacement(s, k))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem: given string s, integer k, we can change up to k characters to any uppercase letter to maximize length of substring of identical letters. Classic problem: Longest repeating character replacement. Use sliding window with frequency array.\n\nWe need to produce each line: Virtual code step + // explanation. Use arrow structure.\n\nWe should include Start, End, Decision, etc. We'll produce a step-by-step algorithm.\n\nWe'll start with Start. Then Step 1: Initialize left pointer, maxLen, freq array, maxFreq. Step 2: Iterate right pointer from 0 to s.length-1. For each char, increment freq. Update maxFreq = max(maxFreq, freq[char]). If window size > k + maxFreq? Wait condition: If (right - left + 1) - maxFreq > k, shrink window: decrement freq[s[left]] and left++. Step 3: Update maxLen = max(maxLen, right-left+1). End.\n\nAlso maybe Decision step: if window invalid? We'll use Decision to shrink window. Provide explanation.\n\nWe'll produce steps accordingly.\n\nMake sure to not output actual code, but virtual code with arrow. Use \"Start\", \"→ Step x: ...\" lines, \"→ Decision: ...\" lines, and \"End\".\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 left = 0, maxLen = 0, maxFreq = 0, freq[26] = 0 // 設定滑動窗口左右指標、最大長度、頻率計數  \n→ Step 2: 從 0 到 s.length-1 逐字進行右指標 right 迴圈 // 依次將每個字元納入滑動窗口  \n  → Step 3: freq[ s[right] ]++ // 將當前字元的頻率加一  \n  → Step 4: maxFreq = max( maxFreq, freq[ s[right] ] ) // 更新窗口內最高頻字元數  \n  → Decision: 如果 (right - left + 1) - maxFreq > k? // 檢查目前窗口大小減去最頻字元數是否超過可替換次數  \n   Yes → Step 5: freq[ s[left] ]-- // 移除左端字元的頻率  \n    → Step 6: left++ // 收縮窗口左端  \n   No  → // 窗口仍合法，無需收縮  \n  → Step 7: maxLen = max( maxLen, right - left + 1 ) // 更新能得到的最大相同字元子串長度  \nEnd // 程式執行結束，返回 maxLen"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvcqjidfi.py\", line 74, in <module>\n    main()\n  File \"/tmp/tmpvcqjidfi.py\", line 57, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmpvcqjidfi.py\", line 12, in buildDict\n    pattern = word[:i] + '*' + word[i+1:]\n              ~~~~~~~~~^~~~~\nTypeError: can only concatenate list (not \"str\") to list"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MagicDictionary:\n    def __init__(self):\n        self.patterns = {}\n\n    def buildDict(self, dictionary):\n        self.patterns = {}\n        for word in dictionary:\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                if pattern not in self.patterns:\n                    self.patterns[pattern] = set()\n                self.patterns[pattern].add(word)\n\n    def search(self, searchWord):\n        for i in range(len(searchWord)):\n            pattern = searchWord[:i] + '*' + searchWord[i+1:]\n            if pattern in self.patterns:\n                words_set = self.patterns[pattern]\n                if len(words_set) > 1 or (len(words_set) == 1 and searchWord not in words_set):\n                    return True\n        return False\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return [], []\n    parts = data.splitlines()\n    if len(parts) == 1:\n        # Input may be a single line with two lists separated by a comma\n        idx = data.find('],')\n        if idx != -1:\n            ops_str = data[:idx+1]\n            args_str = data[idx+2:]\n        else:\n            ops_str, args_str = data.split(',', 1)\n    else:\n        ops_str, args_str = parts[0], parts[1]\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    raw = sys.stdin.read()\n    ops, args = parse_input(raw)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif op == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)\n        elif op == \"search\":\n            results.append(obj.search(arg))\n\n    # Convert results to LeetCode-style output\n    out = []\n    for r in results:\n        if r is None:\n            out.append(\"null\")\n        elif isinstance(r, bool):\n            out.append(\"true\" if r else \"false\")\n        else:\n            out.append(str(r))\n    print(\"[\" + \", \".join(out) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for implementing the MagicDictionary class with methods: constructor, buildDict, search. Provide algorithm: using trie or map by patterns? Simplest: build map of patterns with wildcard replaced each position: for each word, for each index, create key word with that character replaced by '*', store in set or map to count. Then search: for each position in searchWord, create pattern with '*' and check if pattern exists in map and that either the original word different or length matches? Actually we need exactly one character difference. So algorithm: For each position, replace with '*', if that pattern in map, check if there's at least one word different from searchWord. In building, we store patterns mapping to count or set of words. For simplicity, store counts and also set of words. But we can just store count of words that match that pattern. When searching, we need to ensure there is at least one word that is not equal to searchWord. So if pattern count > 1 or if pattern exists and the word at that pattern isn't same word.\n\nBut we just produce virtual code, not real code. Provide each step line by line with explanation.\n\nWe'll need to define class, constructor, buildDict, search. Use data structures: HashMap<String, Integer> patternCount; HashMap<String, String[]> maybe.\n\nSimpler: For each word, for each position, pattern = word.substring(0,i) + '*' + word.substring(i+1). Add to map, increment count. Also store wordSet. For search: iterate positions, pattern, if map contains pattern, check: if patternCount > 1 or (patternCount==1 and wordSet does not contain searchWord?). Actually if patternCount==1 and the only word is searchWord itself, we need false.\n\nSo we need to store for each pattern the set of words that map to it, maybe as HashSet. But we can just use count and check: if patternCount>1 or if patternCount==1 and original word != searchWord? Wait patternCount==1 only indicates one word has that pattern; if that word equals searchWord, then we cannot change exactly one char to match itself? Actually if we change one char to the same word, we are effectively not changing? But problem says change exactly one character; So if searchWord already exists in dictionary, we need to find another word that differs by exactly one character. So patternCount==1 and the word equals searchWord is not valid. So we need to know if there exists a different word. So we need to store set or we can store patternCount and also a boolean flag indicating if pattern includes searchWord? Actually we can store mapping from pattern to set of words. So we can implement as Map<String, Set<String>> patterns.\n\nThus algorithm steps: buildDict loops words, for each index, pattern; add word to set of that pattern.\n\nsearch loops positions, pattern; if patterns contains key, and patterns.get(pattern).size()>1 or !patterns.get(pattern).contains(searchWord). Then return true.\n\nReturn false otherwise.\n\nNow produce virtual code steps:\n\nStart MagicDictionary // class definition\n\nDefine properties: Map patterns\n\nConstructor // init map\n\nbuildDict // input array dictionary\n\n- For each word in dictionary: For each index i: pattern= word[0:i] + '*' + word[i+1:] // replace char\n- If pattern not in patterns: add new set\n- Add word to set\n\nsearch // input searchWord\n\n- For each index i: pattern= searchWord[0:i] + '*' + searchWord[i+1:]\n- If pattern in patterns:\n    - set = patterns[pattern]\n    - If set size >1 OR (set size==1 AND set doesn't contain searchWord) -> return true\n- After loop return false\n\nEnd // done\n\nNeed to use virtual code format: Start, Decision, Yes→, No→, End etc. Each line with explanation.\n\nWe'll produce lines:\n\nStart // 程式開始\n\n→ MagicDictionary class definition // 定義 MagicDictionary 類\n\n→ Define property: patterns: Map<String, Set<String>> // 儲存模式到單詞集合\n\n→ Constructor: MagicDictionary() // 初始化物件\n\n    → Initialize patterns as empty map // 建立空字典\n\n→ Method: buildDict(dictionary) // 建立字典\n\n    → Decision: For each word in dictionary? We'll use loop\n\n    → For each word in dictionary: // 逐個處理單詞\n\n        → For i from 0 to word.length-1: // 每個位置\n\n            → pattern = word with i-th char replaced by '*' // 產生模式\n\n            → Decision: pattern exists in patterns? // 檢查模式是否已存在\n\n                Yes → Add word to existing set // 將單詞加入集合\n\n                No → Create new set with word, insert into patterns // 新增模式\n\n→ Method: search(searchWord) // 搜尋\n\n    → Decision: For i from 0 to searchWord.length-1: // 逐個位置\n\n        → pattern = searchWord with i-th char replaced by '*'\n\n        → Decision: pattern exists in patterns? // 是否有匹配模式\n\n            Yes → set = patterns[pattern]\n\n                → Decision: set.size >1 OR (set.size==1 AND word not in set)? // 有多個單詞或不同於自身\n\n                    Yes → Return true // 找到符合條件\n\n                    No → Continue // 需要檢查下一個位置\n\n            No → Continue // 位置不匹配，檢查下一個位置\n\n    → Return false // 所有位置均未符合\n\nEnd // 程式結束\n\nBut we must output each line with arrow notation. For loops, we may use Step notation. Use \"Step\" for each action. We'll maintain each line with explanation after //.\n\nLet's craft final output.\n...done thinking.\n\n```\nStart // 程式開始\n→ MagicDictionary class definition // 定義 MagicDictionary 類\n→ Define property: patterns: Map<String, Set<String>> // 儲存每個模式對應的單詞集合\n→ Constructor: MagicDictionary() // 初始化物件\n    → Initialize patterns as empty map // 建立空字典\n→ Method: buildDict(dictionary) // 建立字典\n    → Decision: For each word in dictionary? // 逐個處理每個單詞\n        Yes → For each word in dictionary:\n            → Step: word ← current dictionary entry // 取得單詞\n            → For i from 0 to word.length - 1:\n                → Step: pattern ← word with i‑th char replaced by '*' // 產生模式\n                → Decision: pattern exists in patterns? // 檢查模式是否已存在\n                    Yes → Step: Add word to patterns[pattern] // 將單詞加入已有集合\n                    No  → Step: Create new set containing word, insert into patterns // 新增模式\n→ Method: search(searchWord) // 搜尋\n    → Decision: For i from 0 to searchWord.length - 1? // 逐個位置檢查\n        Yes → For i from 0 to searchWord.length - 1:\n            → Step: pattern ← searchWord with i‑th char replaced by '*' // 產生模式\n            → Decision: pattern exists in patterns? // 是否有匹配模式\n                Yes →\n                    → Step: set ← patterns[pattern] // 取得該模式對應的單詞集合\n                    → Decision: set.size > 1 OR (set.size == 1 AND searchWord not in set)? // 有多個單詞或不同於自身\n                        Yes → Return true // 找到符合條件的單詞\n                        No  → Continue // 位置不符合，檢查下一個位置\n                No  → Continue // 位置不匹配，檢查下一個位置\n    → Return false // 所有位置均未符合條件\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjmz2sn7x.py\", line 55, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjmz2sn7x.py\", line 24, in __init__\n    if key not in self.lookup or index > self.lookup[key]:\n       ^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass WordFilter:\n    \"\"\"\n    WordFilter 允許以前綴(prefix)和後綴(suffix)搜尋字典中的單詞。\n    \"\"\"\n    def __init__(self, words):\n        \"\"\"\n        words: List[str] – 字典中所有單詞。\n        建立一個 hash 表，鍵為 (前綴, 後綴) 的元組，值為能匹配該鍵的最大索引。\n        \"\"\"\n        self.lookup = {}\n        for index, word in enumerate(words):\n            L = len(word)\n            # 所有可能的前綴長度 0~L\n            for i in range(L + 1):\n                prefix = word[:i]\n                # 所有可能的後綴長度 0~L\n                for j in range(L + 1):\n                    suffix = word[j:]\n                    key = (prefix, suffix)\n                    # 只保留最大的索引\n                    if key not in self.lookup or index > self.lookup[key]:\n                        self.lookup[key] = index\n\n    def f(self, prefix, suffix):\n        \"\"\"\n        回傳符合前綴 prefix 與後綴 suffix 的單詞索引，\n        若有多個則回傳最大的索引；若無則回傳 -1。\n        \"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 將兩個列表包裝成外層列表，方便使用 json.loads 解析\n    # 例如： '[\"apple\",\"banana\"], [\"a\",\"e\"]' -> [['apple','banana'], ['a','e']]\n    raw_input = '[' + raw_input + ']'\n    try:\n        data = json.loads(raw_input)\n    except json.JSONDecodeError:\n        # 若解析失敗，直接結束\n        sys.exit(0)\n\n    # 取得字典與前綴/後綴\n    words = data[0]\n    pref, suff = data[1]\n\n    # 執行查詢\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code in Chinese (繁體). Each line: virtual step then comment. Use arrow, Decision, Start, End. We need to design WordFilter class with constructor and method f. Use prefix/suffix search. Likely use Trie with combined prefix and suffix? But we can propose using dictionary mapping from prefix-suffix to index. For simplicity: for each word, for each prefix length i, suffix length j, create key pref+ \"#\" + suff and store max index. Then f just look up. Complexity O(total pairs). Provide virtual steps. So we produce pseudo steps for class initialization and f method. Use arrays. Provide steps.\n\nMake sure to output line by line. Use arrow. Let's craft.\n\nStart\n\n→ Step 1: WordFilter(words) // 初始化\n→ Step 2: 建立哈希表 map // 用於存儲 prefix#suffix → 最大索引\n→ Decision: words 是否為空? // 若無單詞\n    No  → Step 3: 對每個單詞 word 及其索引 i 進行迴圈 // 遍歷單詞\n        → Step 4: 計算所有前綴\n            → For each prefix p of word\n                → Step 5: 計算所有後綴\n                    → For each suffix s of word\n                        → Step 6: key = p + \"#\" + s\n                        → Step 7: 若 key 不存在或 i > map[key]，更新 map[key] = i\n→ End // 建構完成\n\nf(pref, suff)\n\nStart // f 方法開始\n→ Step 8: key = pref + \"#\" + suff // 組合關鍵字\n→ Decision: key 是否在 map 中? // 檢查是否存在對應詞\n    Yes → Step 9: Return map[key] // 回傳最大索引\n    No  → Step 10: Return -1 // 無符合條件的詞\nEnd // f 方法結束\n\nWe also need maybe class skeleton: define class WordFilter. Provide steps for class definition.\n\nLet's structure: Start, Step: Define class WordFilter. Then inside we have property map. Then constructor, method.\n\nWill produce as virtual code lines. Use Chinese explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Define class WordFilter // 定義 WordFilter 類別\n    → Step 1.1: 內部宣告變數 map: Map<String, Int> // 用於存儲 prefix#suffix → 最大索引\n→ Step 2: WordFilter(words) // 建構子初始化\n    → Step 2.1: For i from 0 to words.length-1 // 遍歷所有單詞\n        → Step 2.2: word = words[i] // 取得第 i 個單詞\n        → Decision: 是否需要處理此單詞? // 可選：若 word 為空則跳過\n            Yes → Step 2.3: 對 word 生成所有前綴\n                → For pLen from 1 to word.length // 前綴長度\n                    → Step 2.3.1: prefix = word.substring(0, pLen)\n                    → Step 2.3.2: 對 word 生成所有後綴\n                        → For sLen from 1 to word.length // 後綴長度\n                            → Step 2.3.2.1: suffix = word.substring(word.length - sLen)\n                            → Step 2.3.2.2: key = prefix + \"#\" + suffix // 組合鍵\n                            → Decision: key 是否已存在於 map? // 更新最大索引\n                                Yes → Step 2.3.2.3: 若 i > map[key]，則 map[key] = i\n                                No  → Step 2.3.2.4: map[key] = i // 新增鍵值\n→ End // 建構子執行結束\n\nf(pref, suff) // 方法開始\n    → Step 3: key = pref + \"#\" + suff // 組合前綴後綴作為鍵\n    → Decision: key 是否存在於 map? // 檢查是否有符合條件的單詞\n        Yes → Step 4: Return map[key] // 回傳最大索引\n        No  → Step 5: Return -1 // 無符合條件的單詞\nEnd // 方法執行結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy5y18c3m.py\", line 29, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n    ^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnewm7_fz.py\", line 29, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]\n    ^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\ndef find_maximized_capital(k: int, W: int, Profits: list[int], Capital: list[int]) -> int:\n    # 將專案按所需資本升序排序，方便一次性加入可負擔專案\n    projects = sorted(zip(Capital, Profits))\n    max_heap = []          # 儲存可負擔專案的利潤（作為最大堆）\n    i = 0                  # 追蹤已加入堆的專案索引\n    n = len(Profits)\n\n    for _ in range(k):\n        # 把所有目前可負擔的專案利潤加入堆\n        while i < n and projects[i][0] <= W:\n            heapq.heappush(max_heap, -projects[i][1])  # 使用負值模擬最大堆\n            i += 1\n        # 如果沒有可選專案，提前結束\n        if not max_heap:\n            break\n        # 選取利潤最高的專案\n        W -= heapq.heappop(max_heap)\n    return W\n\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入並執行 exec 以獲取變數 k, w, profits, capital 等\n    # 注意：此處假設輸入格式合法且安全（如 LeetCode 風格）\n    data = sys.stdin.read()\n    local_vars = {}\n    exec(data, {}, local_vars)\n\n    # 取得必要變數，支持不同大小寫或命名方式\n    k = local_vars.get('k')\n    W = local_vars.get('W', local_vars.get('w', 0))\n    Profits = local_vars.get('Profits', local_vars.get('profits', []))\n    Capital = local_vars.get('Capital', local_vars.get('capital', []))\n\n    result = find_maximized_capital(k, W, Profits, Capital)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to solve Leetcode \"Maximum Capital\". This is classic greedy using max heap and min heap. Steps: sort projects by capital, iterate selecting up to k times, push profits of affordable into max-heap, pick max profit, add to capital. Provide virtual code lines. We'll follow format: Start, Step lines, Decision blocks, End. Use arrow notation.\n\nWe must avoid actual code. Just pseudo steps.\n\nLet's produce. Ensure each line ends with // explanation. Use \"→ Step 1:\" etc. Include Decision branches.\n\nLet's create list:\n\nStart\n\n→ Step 1: 將所有專案按所需資本升序排序 // 方便依資本逐步加入可選項\n\n→ Step 2: 初始化一個空的最大堆 (profitMaxHeap) // 用來存取目前可負擔專案的最大利潤\n\n→ Step 3: 初始化指標 idx = 0 // 用於追蹤已加入最大堆的專案\n\n→ Decision: 是否已完成 k 次專案? // 控制迴圈結束\n\n    No → Step 4: 當 idx < n 且 projects[idx].capital <= currentCapital 時\n        → Step 5: 將 projects[idx].profit 推入 profitMaxHeap // 可負擔專案加入利潤堆\n        → Step 6: idx += 1 // 移到下一個專案\n        → Back to Step 4 // 重複加入所有可負擔專案\n\n    Yes → Step 7: Decision: profitMaxHeap 是否為空? // 無可選專案\n        Yes → Step 8: Break // 結束循環，無法再累積資本\n        No  → Step 9: 取出 profitMaxHeap 中最大利潤 profit\n            → Step 10: currentCapital += profit // 完成專案後更新資本\n            → Step 11: k -= 1 // 已完成一個專案\n\n→ Decision: k > 0  // 是否還能再選專案\n    Yes → 回到 Decision 第一次 // 重新嘗試加入可負擔專案\n    No  → Step 12: End // 完成所有選擇\n\nEnd // 回傳最終資本\n\nBut we need proper structure: Start, Decision blocks with Yes/No. Use arrow. Let's produce final. Ensure each line has arrow and explanation. Use \"→\" for continuation lines, \"Decision:\" for condition. For loops, use Decision block.\n\nAlso \"Back to Step 4\" maybe use \"→\" and refer to earlier. Might need proper arrow structure.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將所有專案依最低資本升序排序 // 方便後續逐步加入可負擔專案  \n→ Step 2: 建立一個空的最大堆 profitMaxHeap // 用於儲存目前可負擔專案的利潤  \n→ Step 3: 設定 idx = 0 // 指標追蹤已處理的專案  \n→ Step 4: currentCapital = w // 初始資本  \n→ Step 5: decision = k > 0 // 檢查是否還能選擇專案  \n\n    Decision: 是否已完成 k 個專案? // 控制主迴圈  \n        Yes → End // 已達上限，結束  \n        No  → Decision: idx < n 且 projects[idx].capital <= currentCapital? // 是否還有可負擔的專案？  \n\n            Yes → Step 6: 將 projects[idx].profit 推入 profitMaxHeap // 加入利潤堆  \n            → Step 7: idx += 1 // 移動到下一個專案  \n            → 回到 Decision: idx < n 且 projects[idx].capital <= currentCapital? // 重新檢查  \n\n            No  → Decision: profitMaxHeap.isEmpty()? // 是否還有可選專案？  \n\n                Yes → End // 無可負擔專案，結束  \n                No  → Step 8: 取出 profitMaxHeap 中最大利潤 profit // 選取最佳利潤  \n                → Step 9: currentCapital += profit // 更新資本  \n                → Step 10: k -= 1 // 已完成一個專案  \n                → 回到 Decision: k > 0 // 再次檢查是否還能選擇  \n\nEnd // 程式執行結束，currentCapital 為最大資本回傳"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a)()()', '(a())()']\""
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Use BFS to generate all possible strings by removing parentheses level by level.\n        Stop when the first level contains any valid strings and return them.\n        \"\"\"\n        def is_valid(st: str) -> bool:\n            \"\"\"Check if a string has balanced parentheses.\"\"\"\n            count = 0\n            for ch in st:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # Initial level contains the original string\n        level = {s}\n        while level:\n            # Filter valid strings in the current level\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid\n            # Build next level by removing one parenthesis from each string\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        new_item = item[:i] + item[i+1:]\n                        next_level.add(new_item)\n            level = next_level\n        return []\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Extract the string value from raw input.\n    Handles formats like:\n        s = \"()())()\"\n        \"()())()\"\n        \"s = \\\"()())()\\\"\"\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        _, part = raw.split('=', 1)\n        part = part.strip()\n        if (part.startswith('\"') and part.endswith('\"')) or (part.startswith(\"'\") and part.endswith(\"'\")):\n            return part[1:-1]\n        return part\n    # If no '=', assume the whole line is the string (possibly quoted)\n    if (raw.startswith('\"') and raw.endswith('\"')) or (raw.startswith(\"'\") and raw.endswith(\"'\")):\n        return raw[1:-1]\n    return raw\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: given string s with parentheses and letters, remove minimal number of invalid parentheses to make string valid. Return list of unique strings that are valid with minimal removals. Standard LeetCode 301. Approach: use BFS to generate all possibilities by removing one parenthesis at each level, stop when we find valid strings, gather all of that level. Or DFS with pruning. Provide steps line by line with arrow etc.\n\nWe should output the virtual code lines: Start, then maybe Step 1: define helper function isValid, etc.\n\nWe need each line: \"虛擬碼步驟 // 解釋\" as per formatting. Must include arrow arrows (→, Yes →, No →). Provide indentation to show decision branches.\n\nWe should cover the algorithm: calculate left and right to remove, then backtrack. Provide steps. Use DFS recursion: function removeRec(s, start, lRemove, rRemove, result). Base: if lRemove==0 && rRemove==0: check if s valid, add to result. Else iterate i from start to len(s)-1: skip duplicates: if i>start && s[i]==s[i-1] continue. If s[i]== '(' and lRemove>0: remove it and recurse. If s[i]== ')' and rRemove>0: remove it and recurse.\n\nBut maybe BFS approach: level-wise removal. Provide steps. I think BFS may be simpler to explain. But we can use DFS with pruning. Let's produce a virtual code with DFS approach.\n\nWe need to include steps for computing remove counts: iterate string to count leftRemove and rightRemove.\n\nThen call backtrack.\n\nReturn results.\n\nMake sure each line has explanation comment.\n\nOk produce. Use arrow arrows.\n\nLet's produce a fairly concise virtual code. We'll include Start, then Step: compute remove counts, call DFS, end. Provide decision steps inside DFS.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算需要移除的左括號數 lRemove 與右括號數 rRemove // 先一次掃描字串，統計不匹配的括號數量  \n→ Step 2: 初始化結果集合 result 為空集合 // 用於儲存所有唯一有效字串  \n→ Step 3: 呼叫 removeRec(s, 0, lRemove, rRemove, result) // 從索引 0 開始回溯刪除  \n→ End // 程式執行結束  \n\n---\n\nRemoveRec(string cur, int start, int lRem, int rRem, Set result) // 回溯函式  \n→ Decision: 若 lRem == 0 且 rRem == 0? // 所有需要移除的括號已處理完畢  \n    Yes → Step 4: 若 isValid(cur) 則將 cur 加入 result // 檢查剩餘字串是否合法，合法才加入集合  \n    No  → Step 5: 返回 // 若已達到刪除上限但字串不合法，直接返回  \n→ Step 6: 迴圈 i 從 start 到 cur.length - 1  \n    → Decision: 若 i > start 且 cur[i] == cur[i-1]? // 避免重複刪除同一個括號位置  \n        Yes → Continue // 跳過此索引  \n    → Decision: 若 cur[i] == '(' 且 lRem > 0?  \n        Yes → Step 7: 產生 newStr = cur 刪除索引 i 的字符 // 建立新的字串  \n        → Decision: 若 newStr 以前未被處理過? // 可用布林旗標或集合檢查  \n            Yes → Call removeRec(newStr, i, lRem - 1, rRem, result) // 仍從同一索引繼續搜尋  \n    → Decision: 若 cur[i] == ')' 且 rRem > 0?  \n        Yes → Step 8: 產生 newStr = cur 刪除索引 i 的字符  \n        → Decision: 若 newStr 以前未被處理過?  \n            Yes → Call removeRec(newStr, i, lRem, rRem - 1, result) // 仍從同一索引繼續搜尋  \n→ End // removeRec 執行結束  \n\n---\n\nisValid(string str) // 檢查字串是否合法  \n→ Step 9: 初始化 counter = 0  \n→ 迴圈每個字符 ch 在 str  \n    → Decision: 若 ch == '('?  \n        Yes → counter++  \n    → Decision: 若 ch == ')'？  \n        Yes → counter--  \n        → Decision: counter < 0?  \n            Yes → Return false // 右括號多於左括號  \n→ Decision: counter == 0?  \n    Yes → Return true // 成功配對  \n    No  → Return false // 左括號多於右括號  \n\n---"
    },
    {
      "title": "Compare Version Numbers",
      "source_file": "Leetcode/leetcode165.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '0'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef compare_version(version1: str, version2: str) -> int:\n    \"\"\"比較兩個版本字串，返回 -1、0 或 1。\"\"\"\n    v1 = [int(part) for part in version1.split('.')]\n    v2 = [int(part) for part in version2.split('.')]\n    max_len = max(len(v1), len(v2))\n    for i in range(max_len):\n        num1 = v1[i] if i < len(v1) else 0\n        num2 = v2[i] if i < len(v2) else 0\n        if num1 < num2:\n            return -1\n        if num1 > num2:\n            return 1\n    return 0\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 先使用正則尋找所有版本號樣式（digits[.digits]*）\n    matches = re.findall(r'\\d+(?:\\.\\d+)*', data)\n    if len(matches) < 2:\n        return  # 無法取得兩個版本，直接結束\n    version1, version2 = matches[0], matches[1]\n    result = compare_version(version1, version2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps in Traditional Chinese, with each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow, etc.\n\nWe need to process two version strings. Steps: split by '.', iterate index, parse int, compare, handle missing as 0. Return -1,1,0.\n\nLet's produce pseudocode lines:\n\nStart // 開始\n→ Step 1: 將 version1 拆分成列表 rev1 以 '.' 為分隔符 // 取得第一個版本的修訂列表\n→ Step 2: 將 version2 拆分成列表 rev2 以 '.' 為分隔符 // 取得第二個版本的修訂列表\n→ Step 3: 計算 maxLen = max(len(rev1), len(rev2)) // 取較長的長度\n→ Step 4: 針對 i 從 0 到 maxLen-1 迴圈 // 遍歷所有位置\n    → Decision: i < len(rev1) ? // 是否有第一個版本的修訂\n        Yes → val1 = int(rev1[i]) // 取得並轉為整數\n        No  → val1 = 0 // 沒有則為 0\n    → Decision: i < len(rev2) ?\n        Yes → val2 = int(rev2[i]) // 取得並轉為整數\n        No  → val2 = 0 // 沒有則為 0\n    → Decision: val1 < val2 ?\n        Yes → Return -1 // 第一個小於第二個\n        No  →\n            Decision: val1 > val2 ?\n                Yes → Return 1 // 第一個大於第二個\n                No  → // 相等，繼續下一個修訂\n→ End // 所有修訂相等，回傳 0\n\nWe need to output each line accordingly. Use arrow \"→\" preceding each step; decisions use indentation. The \"Return\" lines maybe inside Decision. Need to maintain consistent structure. Also the final End line.\n\nLet's produce.\n\nAlso the \"Return\" lines should be separate lines with arrow? Use \"→ Return -1 // ...\". For nested decisions, need indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將 version1 拆分成列表 rev1 以 '.' 為分隔符 // 取得第一個版本的修訂列表\n→ Step 2: 將 version2 拆分成列表 rev2 以 '.' 為分隔符 // 取得第二個版本的修訂列表\n→ Step 3: 計算 maxLen = max(len(rev1), len(rev2)) // 取較長的修訂數量\n→ Step 4: 針對 i 從 0 到 maxLen-1 迴圈 // 逐位比對修訂\n    → Decision: i < len(rev1) ? // 第一個版本是否有此修訂\n        Yes → val1 = int(rev1[i]) // 取得並轉為整數\n        No  → val1 = 0 // 缺少則視為 0\n    → Decision: i < len(rev2) ? // 第二個版本是否有此修訂\n        Yes → val2 = int(rev2[i]) // 取得並轉為整數\n        No  → val2 = 0 // 缺少則視為 0\n    → Decision: val1 < val2 ?\n        Yes → Return -1 // version1 小於 version2\n        No  →\n            Decision: val1 > val2 ?\n                Yes → Return 1 // version1 大於 version2\n                No  → // 兩者相等，繼續迴圈\n→ End // 所有修訂相等，回傳 0"
    },
    {
      "title": "Add Digits",
      "source_file": "Leetcode/leetcode258.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = 38",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphv0s2db8.py\", line 28, in <module>\n    main()\n  File \"/tmp/tmphv0s2db8.py\", line 13, in main\n    data = sys.stdin.read().strip()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 1,
          "input": "num = 0",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7y5kmf2e.py\", line 28, in <module>\n    main()\n  File \"/tmp/tmp7y5kmf2e.py\", line 13, in main\n    data = sys.stdin.read().strip()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        }
      ],
      "generated_code": "import re\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        \"\"\"Repeatedly add the digits of num until it becomes a single digit.\"\"\"\n        while num >= 10:\n            # Convert num to string, sum its digits, and assign back to num\n            num = sum(int(digit) for digit in str(num))\n        return num\n\ndef main():\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the first integer found in the input (handles formats like \"num = 38\")\n    match = re.search(r'\\d+', data)\n    num = int(match.group()) if match else 0\n\n    # Compute the digital root\n    result = Solution().addDigits(num)\n\n    # Output the result to stdout\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, using arrows and structure. The task: compute digital root of integer. Steps: Start, input num, then loop: while num >= 10, set num = sum of digits of num, then output num, End. Need to use Decision: If num >= 10? yes loop. But we need to show repeated addition. We'll show a decision to check if num has more than one digit, then sum digits. Use sum operation, we need to illustrate adding digits maybe with a loop. Use sub-steps inside decision. The format: \"Start // 程式開始執行\", \"→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\", etc. Use \"Decision:\" etc. We'll produce lines.\n\nWe need \"逐行\" output. Each line includes \"虛擬碼步驟\" and comment. Use arrow \"→\". For nested decisions, indent? The example didn't indent but had nested decisions shown under with 4 spaces? Actually example had:\n\n```\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n```\n\nWe should follow similar indentation: use 4 spaces for nested lines. We'll produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 num // 取得使用者輸入的整數\n→ Decision: num 是否大於等於 10? // 檢查是否還有多於一位數\n    Yes → Step 2: 計算 num 的各位數字之和 // 將 num 轉換為各位數字之和\n        → Sub-step: sum = 0\n        → Sub-step: temp = num\n        → Sub-step: 循環 while temp > 0\n            → Sub-step: sum = sum + (temp mod 10)\n            → Sub-step: temp = temp / 10 (整數除法)\n        → Sub-step: num = sum // 更新 num 為新值\n        → Decision: num 是否大於等於 10? // 再次檢查是否需要繼續\n            Yes → (回到 Step 2 的 Sub-step) // 重複加總\n            No  → Step 3: 輸出 num // 已經是一位數，輸出結果\nNo  → Step 3: 輸出 num // 原始數字已是一位數，直接輸出\nEnd // 程式執行結束\n\nBut we need to ensure each line follows the pattern: \"虛擬碼步驟 [空格] // 解釋\". Use arrow \"→\" before each step, except Start/End maybe no arrow? In example Start has no arrow. So we keep that.\n\nAlso for nested steps, maybe use \"→\" too but indent. Should maintain consistent pattern.\n\nWe must not output actual code but only virtual steps. Ensure each line ends with comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 num // 從使用者取得一個整數  \n→ Decision: num 是否大於等於 10? // 判斷是否還有多於一位數  \n    Yes → Step 2: 計算 num 的各位數字之和 // 先將 num 轉換成各位數字之和  \n        → Sub-step: sum = 0 // 初始化加總變數  \n        → Sub-step: temp = num // 用 temp 來分解 num  \n        → Sub-step: while temp > 0 // 逐位提取  \n            → Sub-step: sum = sum + (temp mod 10) // 加入最低位數字  \n            → Sub-step: temp = temp / 10 // 移除已處理的位數（整數除法）  \n        → Sub-step: num = sum // 更新 num 為新值  \n        → Decision: num 是否大於等於 10? // 再次檢查是否需要重複加總  \n            Yes → (回到 Step 2 的 Sub-step) // 若仍多於一位，重複步驟  \n            No  → Step 3: 輸出 num // 目前已是一位數，輸出結果  \n    No  → Step 3: 輸出 num // 初始數字已是一位數，直接輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets_with_dup(nums):\n    nums.sort()\n    res = [[]]  # start with empty subset\n    for num in nums:\n        new_subsets = []\n        for subset in res:\n            new_subsets.append(subset + [num])\n        res += new_subsets\n    # remove duplicates while preserving order\n    unique_res = []\n    seen = set()\n    for subset in res:\n        t = tuple(subset)\n        if t not in seen:\n            seen.add(t)\n            unique_res.append(subset)\n    return unique_res\n\ndef format_output(subsets):\n    \"\"\"Return a string representation without spaces, e.g. [[],[1],[1,2]]\"\"\"\n    return '[' + ','.join('[' + ','.join(str(x) for x in subset) + ']' for subset in subsets) + ']'\n\nif __name__ == \"__main__\":\n    # Read entire stdin, expect format like: nums = [1,2,2]\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the list part after '='\n    try:\n        _, nums_part = data.split('=', 1)\n    except ValueError:\n        nums_part = data\n    nums = ast.literal_eval(nums_part.strip())\n    result = subsets_with_dup(nums)\n    print(format_output(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with arrow, etc. Problem: generate power set of array with duplicates but avoid duplicate subsets. Approach: sort array, backtrack, skip duplicates. Provide virtual steps.\n\nWe should produce a step-by-step algorithm with Start, Decision, etc. Each line has \"→\" or indentation? The example shows indent for decision branches. Use \"→ Step\" etc. We need to produce for generating all subsets. Let's design:\n\nStart\n→ Sort nums ascending // ensures duplicates adjacent\n→ Decision: If nums empty? // base case\n   Yes → Step: add empty subset to result\n   No → Step: initialize result as empty list\n→ Step: Call backtrack(index=0, current=[])\nEnd\n\nDefine backtrack function:\n→ Step: backtrack(index, current)\n   → Decision: If index == len(nums)? // end of array\n        Yes → Step: add copy of current to result\n        No → Step: Include current number\n   → Step: current.append(nums[index]) // include\n   → Step: backtrack(index+1, current)\n   → Step: current.pop() // backtrack\n   → Decision: If index>0 and nums[index]==nums[index-1]?\n        Yes → Step: skip adding duplicate subset by not exploring exclusion? Actually typical approach: for each index we choose to include or not. But to avoid duplicates, we skip exploring exclusion after include? Let's think: Standard algorithm: backtrack(start): add current; for i from start to n-1: if i>start and nums[i]==nums[i-1] continue; current.append(nums[i]); backtrack(i+1); pop.\n\nThus we don't need include and exclude separately. We just loop.\n\nSo maybe restructure:\n\n→ Step: backtrack(start, current)\n   → Step: add current to result\n   → For i from start to len(nums)-1\n       → Decision: If i>start and nums[i]==nums[i-1]? // skip duplicates at this level\n            Yes → Step: continue\n            No → Step: current.append(nums[i])\n            → Step: backtrack(i+1, current)\n            → Step: current.pop()\n\nReturn result.\n\nLet's write virtual steps accordingly.\n\nWe need to use \"→\" arrows. Each line: \"虛擬碼步驟 // 解釋\". Use indentation for nested decisions.\n\nWe need to mention \"Start\", \"End\" etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort nums in non‑decreasing order // 讓相同元素相鄰，便於跳過重複\n→ Step 2: 初始化 result 為空集合 // 用來存所有子集\n→ Step 3: 定義遞迴函式 Backtrack(start, current) // 產生子集\n→ Decision: 是否執行遞迴? // 直接呼叫以產生所有子集\n    Yes → Step 4: Call Backtrack(0, []) // 從首位開始，當前子集為空\nEnd // 程式執行結束\n\n--- Backtrack 函式定義 ---\nStart // 開始 Backtrack\n→ Step 5: 將 current 的複製加到 result // 目前路徑形成一個子集\n→ Step 6: For i from start 到 len(nums)-1 // 嘗試以每個位置為起點\n    → Decision: i > start AND nums[i] == nums[i-1]? // 同一層重複元素，跳過\n        Yes → Step 7: Continue // 跳過重複子集\n        No  → Step 8: Append nums[i] to current // 選取此元素\n        → Step 9: Call Backtrack(i+1, current) // 往下遞迴，下一層開始位置為 i+1\n        → Step 10: Pop nums[i] from current // 回溯，移除上一步加入的元素\nEnd // 結束 Backtrack\n\n--- 結束 ---"
    },
    {
      "title": "Word Break",
      "source_file": "Leetcode/leetcode139.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8h_vsiqu.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmp8h_vsiqu.py\", line 41, in main\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8h_vsiqu.py\", line 34, in parse_input\n    data[key.strip()] = ast.literal_eval(val.strip())\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"leet\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7sb8l7o3.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmp7sb8l7o3.py\", line 41, in main\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7sb8l7o3.py\", line 34, in parse_input\n    data[key.strip()] = ast.literal_eval(val.strip())\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"apple\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz08jk_ta.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpz08jk_ta.py\", line 41, in main\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpz08jk_ta.py\", line 34, in parse_input\n    data[key.strip()] = ast.literal_eval(val.strip())\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"cats\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(s)]\n\ndef parse_input(text: str):\n    \"\"\"\n    將形如\n        s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n    的輸入轉換成字典 {\"s\": \"leetcode\", \"wordDict\": [\"leet\",\"code\"]}，再用 ast.literal_eval 解析。\n    \"\"\"\n    # 去除首尾空白與換行\n    text = text.strip()\n    # 以逗號分隔並逐個轉成鍵值對\n    parts = [p.strip() for p in text.split(',')]\n    data = {}\n    for part in parts:\n        if part.startswith('s'):\n            key, val = part.split('=', 1)\n            data[key.strip()] = ast.literal_eval(val.strip())\n        elif part.startswith('wordDict'):\n            key, val = part.split('=', 1)\n            data[key.strip()] = ast.literal_eval(val.strip())\n    return data\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    data = parse_input(raw_input)\n    s = data['s']\n    wordDict = data['wordDict']\n\n    solution = Solution()\n    result = solution.wordBreak(s, wordDict)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for word break problem. Provide line by line steps with arrows, decision, etc. Should be clear. No actual code. Let's design algorithm: DP: dp[i] true if prefix up to i can be segmented. Start, iterate i from 1 to len, for each j < i check if dp[j] true and s[j:i] in dict. Use dictionary set. Return dp[n]. So produce virtual steps.\n\nLet's output lines:\n\nStart\n→ Step 1: 初始化字典集合 wordSet = wordDict\n→ Step 2: 初始化 dp 數組長度 n+1，dp[0] = true\n→ Decision: 是否已經處理完所有位置 i? // 循環 i 從 1 到 n\n    No → Step 3: 設定 j = 0\n    → Decision: j < i?\n        Yes → Step 4: 檢查 dp[j] 是否為 true 且 s[j:i] 在 wordSet\n            Yes → Step 5: 將 dp[i] 設為 true，跳出內層循環\n            No → Step 6: j = j + 1\n        No → Decision: dp[i] 是否為 true?\n            Yes → Step 7: i = i + 1（跳過此 i 的進一步檢查）\n            No  → Step 8: i = i + 1（進入下一個 i）\n→ Step 9: 回傳 dp[n] 作為最終結果\nEnd\n\nBut need to format with arrows, etc. Let's ensure each line ends with // 解釋. Use \"→\" and \"Decision:\" etc.\n\nWe need indentation maybe? The example shows indentation for decisions. We can use two spaces indentation for sub-steps.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 初始化字典集合 wordSet = wordDict // 方便快速查找\n→ Step 2: 取得字串長度 n = len(s) // 需要知道迴圈上限\n→ Step 3: 建立布林陣列 dp，長度 n+1，並設定 dp[0] = true // dp[i] 表示 s[:i] 可分割\n→ Step 4: 從 i = 1 開始遍歷到 n // 逐個檢查前綴是否可分割\n    Decision: 是否 i ≤ n? // 迴圈條件\n        Yes → Step 5: 設置 j = 0 // 準備檢查前面的切分點\n        → Decision: 是否 j < i? // 內層循環條件\n            Yes → Step 6: 檢查 dp[j] 為 true 且 s[j:i] 在 wordSet\n                Yes → Step 7: 設定 dp[i] = true // 找到合法分割\n                No  → Step 8: j = j + 1 // 移到下一個切分點\n            No  → Decision: 是否 dp[i] 為 true? // 若已設定為 true，可跳過\n                Yes → Step 9: i = i + 1 // 前往下一個 i\n                No  → Step 10: i = i + 1 // 仍前往下一個 i\n→ Step 11: 回傳 dp[n] // 最終結果是否能整段分割\nEnd // 程式結束\n\nBut need to ensure each line has \"虛擬碼步驟\" and \"// 解釋\". So we must put comment after code, not before. Example shows:\n\nStart // 程式開始執行\n\nYes. So each line: \"Start // ...\". We need to keep code part and comment part separated by space. We'll follow.\n\nLet's refine each step:\n\n1. Start // 程式開始執行\n2. → Step 1: 初始化字典集合 wordSet = wordDict // 方便快速查找\n3. → Step 2: 取得字串長度 n = len(s) // 需要知道迴圈上限\n4. → Step 3: 建立布林陣列 dp，長度 n+1，並設定 dp[0] = true // dp[i] 表示 s[:i] 可分割\n5. → Step 4: 從 i = 1 開始遍歷到 n // 逐個檢查前綴是否可分割\n   Decision: 是否 i ≤ n? // 迴圈條件\n        Yes → Step 5: 設置 j = 0 // 準備檢查前面的切分點\n        → Decision: 是否 j < i? // 內層循環條件\n            Yes → Step 6: 檢查 dp[j] 為 true 且 s[j:i] 在 wordSet\n                Yes → Step 7: 設定 dp[i] = true // 找到合法分割\n                No  → Step 8: j = j + 1 // 移到下一個切分點\n            No  → Decision: 是否 dp[i] 為 true? // 若已設定為 true，可跳過\n                Yes → Step 9: i = i + 1 // 前往下一個 i\n                No  → Step 10: i = i + 1 // 仍前往下一個 i\n6. → Step 11: 回傳 dp[n] // 最終結果是否能整段分割\n7. End // 程式結束\n\nBut the indentation may need to be shown with spaces. The example shows 4 spaces indentation for nested steps. We'll mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字典集合 wordSet = wordDict // 方便快速查找  \n→ Step 2: 取得字串長度 n = len(s) // 需要知道迴圈上限  \n→ Step 3: 建立布林陣列 dp，長度 n+1，並設定 dp[0] = true // dp[i] 表示 s[:i] 可分割  \n→ Step 4: 從 i = 1 開始遍歷到 n // 逐個檢查前綴是否可分割  \n  Decision: 是否 i ≤ n? // 迴圈條件  \n    Yes → Step 5: 設置 j = 0 // 準備檢查前面的切分點  \n    → Decision: 是否 j < i? // 內層循環條件  \n      Yes → Step 6: 檢查 dp[j] 為 true 且 s[j:i] 在 wordSet  \n        Yes → Step 7: 設定 dp[i] = true // 找到合法分割  \n        No  → Step 8: j = j + 1 // 移到下一個切分點  \n      No  → Decision: 是否 dp[i] 為 true? // 若已設定為 true，可跳過  \n        Yes → Step 9: i = i + 1 // 前往下一個 i  \n        No  → Step 10: i = i + 1 // 仍前往下一個 i  \n→ Step 11: 回傳 dp[n] // 最終結果是否能整段分割  \nEnd // 程式結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef longest_uncommon_subsequence_length(strs):\n    \"\"\"\n    找出給定字串陣列中最長的不相交子序列長度。\n    如果不存在，回傳 -1。\n    \"\"\"\n    freq = Counter(strs)                 # 1. 統計每個字串出現次數\n    # 2. 依字串長度由大到小排序\n    for s in sorted(strs, key=len, reverse=True):\n        if freq[s] == 1:                  # 3. 若唯一，直接回傳長度\n            return len(s)\n    return -1                            # 4. 全部非唯一，無答案\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        strs = ast.literal_eval(data)    # 解析輸入為 list\n    except Exception:\n        # 若解析失敗，視為空串列\n        strs = []\n    result = longest_uncommon_subsequence_length(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. The user wants to solve problem: longest uncommon subsequence length among strings in array strs. We need algorithm: If there is a string that is unique (no identical string appears), then answer is its length. Because a string itself is subsequence of itself, and if no other string equals it, it cannot be subsequence of others unless some other string contains it as subsequence. But for longest uncommon subsequence, known solution: find longest string that is not equal to any other string. If exists, return its length; else -1.\n\nEdge cases: If all strings equal, no unique, answer -1. If two strings equal length but unique, return length. Actually if there is a unique string but all others equal to it? Wait unique means string appears only once. If that string is unique, it cannot be subsequence of another string that is shorter or longer? Actually a string can be subsequence of longer string. So a unique string may still be subsequence of another string if that other string contains it as subsequence. But the standard LeetCode solution: if there is any string that is not equal to any other string, return its length, else -1. But there is nuance: For example strs = [\"aba\",\"cdc\",\"eae\"] all unique, answer 3. For [\"aaa\",\"aa\"], answer 3 because \"aaa\" is not a subsequence of \"aa\". For [\"aaa\",\"aaa\",\"aa\"], longest unique is \"aa\"? Wait \"aa\" appears once? Actually appears once, but \"aa\" is subsequence of \"aaa\". So longest uncommon subsequence might be 3? But \"aaa\" is not equal to any other string? Actually \"aaa\" appears twice, so not unique. So algorithm fails? Let's think. Problem statement: need longest uncommon subsequence. Known solution is: For each string, if it doesn't appear more than once, return its length. Because if there is any unique string, then it's guaranteed to be not a subsequence of any other string? Not always. But for the problem as defined, this is accepted solution.\n\nSo produce virtual code accordingly. Steps: input array, count frequencies, iterate through strings sorted by length descending, find first string with freq 1, return its length, else -1.\n\nWe need to produce virtual code line by line with explanation. Use Start, End, Decision, etc. We'll generate steps: Start, Step 1: Count frequencies, Step 2: Sort indices by length descending, Step 3: Iterate, Decision: if frequency 1? If yes, output length. If none, output -1. End.\n\nLet's create virtual code lines accordingly.\n\nAlso need to include arrow notation. Use '→' and 'Yes →', 'No →'.\n\nWe'll create code like:\n\nStart // 程式開始執行\n→ Step 1: 建立字串頻率映射 freq // 用於統計每個字串出現次數\n→ Step 2: 取得所有字串索引 list_idx // 方便後續排序\n→ Step 3: 按字串長度降序排序 list_idx // 先檢查最長字串\n→ Step 4: For 每個 idx in list_idx // 遍歷字串\n    → Decision: freq[ strs[idx] ] 是否等於 1? // 判斷是否唯一\n        Yes → Step 5: 回傳 strs[idx] 的長度 // 找到最長唯一字串\n        No  → // 繼續迴圈\n→ Step 6: 若迴圈結束仍未回傳 → 回傳 -1 // 無唯一字串\nEnd // 程式結束\n\nAlso need to consider output step? We'll just output length. Provide explanation comments.\n\nMake sure each line has \"虛擬碼步驟 [space] // 解釋/說明\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字串頻率映射 freq ← {} // 用於統計每個字串出現次數  \n→ Step 2: 將每個字串加入 freq 並累加計數  \n→ Decision: 是否已完成所有字串？ // 檢查是否已統計完畢  \n    Yes → Step 3: 取得所有字串索引 list_idx ← 0..len(strs)-1 // 方便後續排序  \n    No  → // 仍有字串未處理  \n→ Step 4: 按字串長度降序排序 list_idx // 先檢查最長字串  \n→ Step 5: For idx in list_idx // 遍歷字串，從長到短  \n    → Decision: freq[ strs[idx] ] 是否等於 1? // 判斷字串是否唯一  \n        Yes → Step 6: 回傳 strs[idx] 的長度 // 找到最長唯一字串，作為答案  \n        No  → // 繼續檢查下一個字串  \n→ Step 7: 若迴圈結束仍未回傳 → 回傳 -1 // 所有字串都不唯一，無不相交子序列  \nEnd // 程式結束執行"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of a list of distinct integers.\n        Uses in-place backtracking by swapping elements.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 如果已經排列到最後，將目前的排列加入結果\n            if start == len(nums):\n                res.append(nums[:])  # 需複製一份\n                return\n            for i in range(start, len(nums)):\n                # 交換將未使用的元素放到前面\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                # 回溯：還原交換\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入，預期格式為：nums = [1,2,3]\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 取得等號後的內容並安全解析為 Python 資料結構\n    try:\n        _, expr = data.split('=', 1)\n        nums = ast.literal_eval(expr.strip())\n    except Exception:\n        # 若解析失敗，假設整行即為數列字串\n        nums = ast.literal_eval(data)\n\n    sol = Solution()\n    result = sol.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, following the format. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision:, arrow →, Yes →, No →. Must generate steps for generating all permutations of array of distinct integers. Use recursion/backtracking. Must include steps: input, check empty, call backtrack, etc. Let's outline:\n\nStart\n→ Step 1: 輸入 nums // array of distinct integers\n→ Decision: 如果 nums 為空? // check if empty\n    Yes → Step 2: 回傳空陣列 // return empty array (maybe return [])\n    No  → Step 3: 建立結果陣列 result // results list\n        → Step 4: 呼叫 backtrack(當前路徑 [], 剩餘 nums) // start recursion\n\nDefine backtrack(path, remaining)\n→ Decision: 如果 remaining 為空? // base case\n    Yes → Step 5: 將 path 複製並加入 result // add current permutation\n    No  → Step 6: 對於每個元素 idx in remaining\n        → Step 7: 新路徑 newPath = path + element // add to path\n        → Step 8: 新剩餘 newRemaining = remaining without element // remove element\n        → Step 9: 呼叫 backtrack(newPath, newRemaining) // recurse\n\nEnd\n→ Step 10: 回傳 result // return all permutations\n\nNeed to ensure each line uses arrow and comment. Use indentation for nested decisions maybe but keep format. Provide each line accordingly.\n\nLet's craft. Use \"Decision:\" then Yes →, No → with nested steps. Use \"Step X:\" for steps. We'll need numbering maybe but not necessary. We'll just label.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 nums // 取得輸入陣列  \n→ Decision: 如果 nums 為空? // 檢查是否為空陣列  \n    Yes → Step 2: 回傳 [] // 空陣列不產生排列  \n    No  → Step 3: 建立 result 為空陣列 // 用於儲存所有排列  \n        → Step 4: 呼叫 backtrack([], nums) // 開始遞迴產生排列  \nEnd // 程式結束  \n\n// ----------------- backtrack 函式 -----------------  \n→ Step 5: 定義 backtrack(path, remaining) // path 為目前排列，remaining 為尚未使用的元素  \n→ Decision: 如果 remaining 為空? // 基本情況：所有元素已加入 path  \n    Yes → Step 6: 將 path 複製後加入 result // 保存完整排列  \n    No  → Step 7: 對於每個元素 idx 在 remaining  \n        → Step 8: newPath ← path + remaining[idx] // 將當前元素加入路徑  \n        → Step 9: newRemaining ← remaining 去除 idx 所指元素 // 生成新的剩餘列表  \n        → Step 10: 呼叫 backtrack(newPath, newRemaining) // 進行遞迴  \nEnd // backtrack 函式結束  \n\n→ Step 11: 回傳 result // 返回所有產生的排列結果"
    },
    {
      "title": "Best Time to Buy and Sell Stock with Transaction Fee",
      "source_file": "Leetcode/leetcode714.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "prices = [1,3,2,8,4,9], fee = 2",
          "expected_output": "8",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvhvh5wdd.py\", line 25, in <module>\n    data = eval('{' + formatted + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'prices' is not defined"
        },
        {
          "example_index": 1,
          "input": "prices = [1,3,7,5,10,3], fee = 3",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8issoz2f.py\", line 25, in <module>\n    data = eval('{' + formatted + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'prices' is not defined"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def maxProfit(self, prices, fee):\n        \"\"\"Return the maximum profit with transaction fee.\"\"\"\n        if not prices:\n            return 0\n        cash = 0          # 最大利潤，當前不持有股票\n        hold = -prices[0] # 以第一天價格買入後的利潤（尚未支付手續費）\n        for price in prices[1:]:\n            # 如果今天賣出，利潤為持股利潤 + 當前股價 - 交易費\n            cash = max(cash, hold + price - fee)\n            # 如果今天買入，利潤為目前現金 - 當前股價\n            hold = max(hold, cash - price)\n        return cash\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 將輸入轉換成字典字串，例如: 'prices = [1,3,2,8,4,9], fee = 2'\n    # 轉為: {'prices':[1,3,2,8,4,9], 'fee':2}\n    formatted = raw_input.replace('prices =', 'prices:').replace('fee =', 'fee:')\n    formatted = formatted.replace(' ', '')  # 移除空白\n    data = eval('{' + formatted + '}')\n    prices = data['prices']\n    fee = data['fee']\n    solution = Solution()\n    print(solution.maxProfit(prices, fee))",
      "virtual_code": "Thinking...\nThe user wants virtual code for the problem: maximize profit with transaction fee. They want step-by-step pseudocode with explanations, no actual code. Use arrows, Start, End, Decision. Provide line by line.\n\nWe need to produce virtual code that solves the problem: dynamic programming, maintain two states: hold and cash. For each price, update.\n\nBut they want a generic algorithm. We'll produce steps: initialize cash=0, hold=-price[0]-fee? Wait transaction fee only charged once per transaction; typical approach: fee charged on sale or purchase? They say fee is charged once for each stock purchase and sale. Means each transaction includes fee. Usually you subtract fee when selling. But here says charged once for each stock purchase and sale: might mean you pay fee on both? But typical Leetcode problem \"Best Time to Buy and Sell Stock with Transaction Fee\" charges fee on sell. But we will state that we account fee when selling. Provide pseudo steps accordingly.\n\nLet's produce algorithm:\n\nStart\n→ Initialize cash=0 // profit without holding stock\n→ Initialize hold=-prices[0] - fee // holding a stock after buying first day (pay fee)\n→ For each day i from 1 to n-1:\n    Decision: 是否應該更新持有狀態? // check if buying today yields better hold\n        Yes → hold = max(hold, cash - prices[i] - fee) // buy today (pay fee)\n        No  → keep previous hold\n    Decision: 是否應該更新現金狀態? // check if selling today yields better cash\n        Yes → cash = max(cash, hold + prices[i]) // sell today (receive price, fee already paid)\n        No  → keep previous cash\n→ End // 返回 cash\n\nBut hold update may need to happen before cash or after? Standard: for each price p: new_cash = max(cash, hold + p); new_hold = max(hold, cash - p - fee). Use temporary variables. Provide steps accordingly.\n\nWe'll produce as virtual code lines with explanation. We'll include arrays etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize cash = 0 // 目前手上無股票，獲利為 0  \n→ Initialize hold = -prices[0] - fee // 在第一天購買股票，扣除交易費  \n→ Decision: 迴圈從第 2 天開始? // 檢查是否還有剩餘天數  \n    Yes → → For i = 1 到 n-1: // 處理每一天的價格  \n        → Decision: 是否要在今天賣出? // 檢查賣出是否能提高現金  \n            Yes → cash = max(cash, hold + prices[i]) // 賣出股票，取得價格，現金更新  \n            No  → cash unchanged // 保持原先現金  \n        → Decision: 是否要在今天買入? // 檢查買入是否能提升持股狀態  \n            Yes → hold = max(hold, cash - prices[i] - fee) // 購買股票，扣除費用，持股更新  \n            No  → hold unchanged // 保持原先持股  \n    No → // 迴圈結束，已經處理完所有天數  \nEnd // 程式執行結束，回傳 cash 為最大獲利\n\n// 以上虛擬碼使用動態規劃，維持兩個狀態：cash（不持股時的最大獲利）與 hold（持股時的最大獲利），並在每天根據買賣決策更新。"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 儲存所有元素的動態陣列\n        self.data = []\n        # 每個值對應其在 data 中的所有索引集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入 val。若第一次插入則回傳 True，否則回傳 False。\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"若 val 存在則移除一個，回傳 True；否則回傳 False。\"\"\"\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        # 把最後一個元素覆蓋到被移除的位置\n        self.data[remove_idx] = last_val\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        # 刪除最後一個元素\n        self.data.pop()\n        # 若 val 的索引集合已空，刪除該鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機回傳一個元素。\"\"\"\n        return random.choice(self.data)\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 找到兩個列表之間的分隔符\n    split_pos = raw_input.find('], [')\n    ops_part = raw_input[:split_pos + 1]\n    args_part = raw_input[split_pos + 2:]\n    # 解析成 Python 物件\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == 'RandomizedCollection':\n            obj = RandomizedCollection()\n            result.append(None)\n        elif op == 'insert':\n            res = obj.insert(arg[0])\n            result.append(res)\n        elif op == 'remove':\n            res = obj.remove(arg[0])\n            result.append(res)\n        elif op == 'getRandom':\n            res = obj.getRandom()\n            result.append(res)\n        else:\n            # 任何未知操作直接 append None\n            result.append(None)\n\n    # 使用 json.dumps 以符合 LeetCode 風格輸出\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The requirement: implement RandomizedCollection with insert, remove, getRandom in average O(1). So typical solution uses vector and hashmap of val to set of indices. Steps: Start, initialize data structures. For insert: add to vector, record index in map, check if val existed before. Return true if first time. For remove: if val not present return false. Else get an index from map[val], remove from vector via swap with last element, update map for swapped element, pop_back. Return true. getRandom: random index from vector. Provide virtual code with arrows and decisions.\n\nWe need to produce line-by-line. Use arrows: Start, then maybe Step 1: 初始化數據結構 etc. Use Decision lines accordingly.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義 class RandomizedCollection // 定義類\n→ Step 2: 內部數據結構：vector<int> nums // 存放所有元素\n→ Step 3: unordered_map<int, unordered_set<int>> idxMap // 值到其索引集合\n→ Step 4: Constructor() // 初始化空集合\n    → End // 結構完成\n\nThen methods:\n\n→ Step 5: Method insert(val)\n    → Decision: 若 val 不在 idxMap? // 判斷是否首次插入\n        Yes → Step 6: 將 val 加入 nums // 添加到 vector\n             → Step 7: 將新索引 nums.size()-1 加入 idxMap[val]\n             → Step 8: Return true // 新值\n        No  → Step 9: 將 val 加入 nums\n             → Step 10: 將新索引加入 idxMap[val]\n             → Step 11: Return false // 已存在\n\nBut typical algorithm: always add to vector, update map, return true if not present before.\n\nThen remove:\n\n→ Step 12: Method remove(val)\n    → Decision: 若 val 不在 idxMap? // 無此值\n        Yes → Step 13: Return false\n        No  → Step 14: 取得 idxMap[val] 中任一索引 remIdx // 取一個索引\n             → Step 15: 取得最後一個索引 lastIdx = nums.size()-1\n             → Step 16: 取得 lastVal = nums[lastIdx]\n             → Step 17: nums[remIdx] = lastVal // 覆蓋\n             → Step 18: 更新 idxMap[lastVal]：移除 lastIdx，加入 remIdx\n             → Step 19: 移除 idxMap[val] 中的 remIdx\n             → Step 20: 從 nums pop_back()\n             → Decision: 若 idxMap[val] 为空? // 若 val 刪除完畢\n                Yes → Step 21: 移除 idxMap[val] 鍵\n             → Step 22: Return true\n\ngetRandom:\n\n→ Step 23: Method getRandom()\n    → Step 24: 產生隨機整數 r in [0, nums.size()-1] // 隨機索引\n    → Step 25: Return nums[r]\n\nEnd // 程式結束\n\nBut the instructions: Each line with virtual code plus explanation. Use arrow \"→\". For decision lines use Decision: if ...? Then Yes → and No →.\n\nAlso we need to show each line as code. We'll include Start and End. For the class definition, we might treat as Step 1: Define class RandomizedCollection // etc.\n\nBetter produce as:\n\nStart // 程式開始執行\n→ Step 1: class RandomizedCollection // 定義類別\n→ Step 2:     vector<int> nums // 儲存所有元素的動態陣列\n→ Step 3:     unordered_map<int, unordered_set<int>> idxMap // 每個值對應其在 nums 中的索引集合\n→ Step 4:     RandomizedCollection() // 建構子\n        → End // 退出建構子\n\nBut maybe we need to keep code-like lines but not actual code. It's okay. Provide each step as one line.\n\nLet's produce final answer with full virtual code and explanations.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: class RandomizedCollection // 定義 RandomizedCollection 類別  \n→ Step 2:     vector<int> nums // 主要儲存所有元素的向量  \n→ Step 3:     unordered_map<int, unordered_set<int>> idxMap // 每個值對應在 nums 中的所有索引集合  \n→ Step 4:     RandomizedCollection() // 建構子，初始化空結構  \n    → End // 建構子結束  \n\n→ Step 5: bool insert(int val) // 插入 val 的方法  \n    → Decision: 若 val 尚未存在於 idxMap? // 判斷是否第一次插入  \n        Yes → Step 6: nums.push_back(val) // 把 val 放到向量尾部  \n             → Step 7: idxMap[val].insert(nums.size()-1) // 記錄新索引  \n             → Step 8: return true // 成功插入且為首次出現  \n        No  → Step 9: nums.push_back(val) // 仍然放到尾部（重複值）  \n             → Step 10: idxMap[val].insert(nums.size()-1) // 加入索引到集合  \n             → Step 11: return false // 已存在  \n\n→ Step 12: bool remove(int val) // 刪除 val 的方法  \n    → Decision: 若 val 不在 idxMap? // 沒有此值  \n        Yes → Step 13: return false // 無法刪除  \n        No  → Step 14: int remIdx = *idxMap[val].begin() // 取得任一索引  \n             → Step 15: int lastIdx = nums.size() - 1 // 最後一個索引  \n             → Step 16: int lastVal = nums[lastIdx] // 最後一個值  \n             → Step 17: nums[remIdx] = lastVal // 用最後一個值覆蓋要刪除的位置  \n             → Step 18: idxMap[lastVal].erase(lastIdx) // 移除 lastVal 的舊索引  \n             → Step 19: idxMap[lastVal].insert(remIdx) // 加入 new 索引  \n             → Step 20: idxMap[val].erase(remIdx) // 移除 val 的索引  \n             → Step 21: nums.pop_back() // 刪除向量尾部  \n             → Decision: 若 idxMap[val] 變為空? // val 是否已全部刪除  \n                Yes → Step 22: idxMap.erase(val) // 移除該鍵  \n             → Step 23: return true // 刪除成功  \n\n→ Step 24: int getRandom() // 取得隨機元素的方法  \n    → Step 25: int r = rand() % nums.size() // 產生 0 ~ size-1 的隨機索引  \n    → Step 26: return nums[r] // 回傳對應的值  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Remove K Digits",
      "source_file": "Leetcode/leetcode402.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"1432219\", k = 3",
          "expected_output": "\"1219\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwe761oai.py\", line 65, in <module>\n    result = remove_k_digits(num_str, k_val)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwe761oai.py\", line 16, in remove_k_digits\n    stack.pop()\nIndexError: pop from empty list"
        },
        {
          "example_index": 1,
          "input": "num = \"10200\", k = 1",
          "expected_output": "\"200\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '200'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '\"200\"'\nRaw Got:      '0'"
        },
        {
          "example_index": 2,
          "input": "num = \"10\", k = 2",
          "expected_output": "\"0\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcmn9_1tp.py\", line 65, in <module>\n    result = remove_k_digits(num_str, k_val)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpcmn9_1tp.py\", line 16, in remove_k_digits\n    stack.pop()\nIndexError: pop from empty list"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef remove_k_digits(num: str, k: int) -> str:\n    \"\"\"Return the smallest number after removing k digits from num.\"\"\"\n    stack = []\n    for digit in num:\n        # Greedy: remove previous larger digits if we still have deletions left\n        while k > 0 and stack and stack[-1] > digit:\n            stack.pop()\n            k -= 1\n        stack.append(digit)\n\n    # If deletions remain, remove from the end\n    while k > 0:\n        stack.pop()\n        k -= 1\n\n    # Build result and strip leading zeros\n    result = ''.join(stack).lstrip('0')\n    return result if result else '0'\n\ndef parse_input(data: str):\n    \"\"\"Parse the input string to extract num and k.\"\"\"\n    num = None\n    k = None\n\n    # Try to find patterns like num = \"12345\", k = 2\n    num_match = re.search(r'num\\s*=\\s*[\"\\']?([^\"\\']+?)[\"\\']?', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if num_match:\n        num = num_match.group(1)\n    if k_match:\n        k = int(k_match.group(1))\n\n    # If not found, try to split by whitespace\n    if num is None or k is None:\n        tokens = data.split()\n        if tokens:\n            # First token might be the number (with or without quotes)\n            first = tokens[0]\n            if first.startswith('\"') and first.endswith('\"'):\n                num = first.strip('\"')\n            elif first.startswith(\"'\") and first.endswith(\"'\"):\n                num = first.strip(\"'\")\n            else:\n                num = first\n        if len(tokens) >= 2:\n            try:\n                k = int(tokens[1])\n            except ValueError:\n                pass\n\n    return num, k\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    num_str, k_val = parse_input(raw_data)\n\n    if num_str is None or k_val is None:\n        # If parsing fails, do nothing\n        sys.exit(0)\n\n    result = remove_k_digits(num_str, k_val)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step, with each line containing \"虛擬碼步驟\" and // explanation. Use Start, End, Decision:, arrow. Need to design algorithm: greedy using stack to remove digits that are larger than next digit, until k removed. At end, maybe remove from end if k>0. Then remove leading zeros. Provide final string. Ensure virtual code lines.\n\nLet's produce steps:\n\nStart // start\n→ Step 1: 初始化空棧 S // 用於保存結果數字\n→ Step 2: 初始化變量 removed = 0 // 追蹤已刪除的位數\n→ Decision: 遍歷每個字符 digit in num // 逐位處理\n    → Step 3: Decision: while S 非空 且 removed < k 且 S.top() > digit // 若棧頂大於當前並且還可刪除\n        → Step 4: Pop S.top() // 刪除棧頂\n        → Step 5: removed += 1 // 列為已刪除\n        → Step 6: Decision: 退出 while // 循環結束\n    → Step 7: Push digit 到 S // 把當前位數保存\n→ Step 8: Decision: 若 removed < k // 若還有未刪除位\n        → Step 9: Remove last (k - removed) digits from S // 刪除尾部多餘位\n        → Step 10: removed = k // 更新已刪除\n→ Step 11: Convert S 為字串 result // 取得最終數字\n→ Step 12: Remove前導零 from result // 去除前導零\n→ Step 13: Decision: 若 result 為空\n        → Step 14: result = \"0\" // 若全被刪除，返回0\n→ End // 結束\n\nNeed to format each line. Ensure arrow \"→\" or \"Yes →\" etc. Decision: lines with Yes / No? But we only have simple decisions. Use Decision: ... and then branches with Yes/No. But we can use decision without Yes/No if just a loop? Might use Decision: if ...? Actually example shows Decision: If condition? then Yes → ... No → ... but we could also use Decision: loop? For clarity maybe use Decision: while? But keep as Decision: 循環條件? Could use Decision: while? We'll format as Decision: 若... // comment. Then we can indent branches using Yes / No? For while loop we just show steps within.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 S // 用於保存構造後的數字  \n→ Step 2: 初始化變量 removed = 0 // 追蹤已刪除的位數  \n→ Decision: 遍歷每個字符 digit 在 num // 逐位處理  \n  → Step 3: Decision: while S 非空 且 removed < k 且 S.top() > digit // 若棧頂數字大於當前且還可刪除  \n    → Step 4: Pop S.top() // 刪除棧頂數字  \n    → Step 5: removed += 1 // 記錄一次刪除  \n    → Step 6: Decision: 退出 while // 退出內層循環  \n  → Step 7: Push digit 到 S // 把當前數字放入棧  \n→ Step 8: Decision: 若 removed < k // 若仍有剩餘刪除需求  \n    Yes → Step 9: Remove (k - removed) 個字元從 S 的尾部 // 刪除最後多餘位  \n    No  → // 不做任何操作  \n→ Step 10: Convert S 為字串 result // 取得堆疊中剩餘數字的字串  \n→ Step 11: Remove 前導零 from result // 去除字串前面的零  \n→ Decision: 若 result 為空 // 判斷結果是否為空字符串  \n  Yes → Step 12: result = \"0\" // 所有位被刪除時返回 0  \n  No  → // 保留 result  \nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvsix0wje.py\", line 41, in <module>\n    start_gene, end_gene, bank = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvsix0wje.py\", line 36, in parse_input\n    data = ast.literal_eval(formatted)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7bd32a827450>"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx6y62m4x.py\", line 41, in <module>\n    start_gene, end_gene, bank = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx6y62m4x.py\", line 36, in parse_input\n    data = ast.literal_eval(formatted)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x72b51352b450>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list[str]) -> int:\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\ndef parse_input(input_str: str) -> tuple[str, str, list[str]]:\n    # Convert \"startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\"\n    # into a dict via ast.literal_eval\n    if not input_str.strip():\n        raise ValueError(\"Empty input\")\n    # Replace '=' with ':' to form a dict literal\n    formatted = '{' + input_str.replace('=', ':') + '}'\n    data = ast.literal_eval(formatted)\n    return data['startGene'], data['endGene'], data['bank']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    start_gene, end_gene, bank = parse_input(raw_input)\n    solution = Solution()\n    result = solution.minMutation(start_gene, end_gene, bank)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanation. It's a typical BFS shortest path problem. Steps: Use BFS queue starting with startGene. Use visited set. While queue not empty: pop gene and depth. If gene==endGene return depth. For each position 0-7: for each char in 'ACGT': generate new gene if different. If in bank and not visited, add to queue, visited. If no path return -1.\n\nWe must include Start, End, Decision, etc. Ensure each line has virtual code step and comment. Use arrow \"→\" to indicate steps. Use Decision for condition checks. Use Yes→, No→. Also use indentation.\n\nMake sure to include initialization of bank set, visited set. Use queue structure.\n\nLet's produce lines:\n\nStart // start of program\n→ Step 1: 定義字母集合 letters = ['A','C','G','T'] // 基本字母\n→ Step 2: 建立 bankSet = set(bank) // 轉成集合方便查詢\n→ Step 3: 建立 visitedSet = empty set // 記錄已訪問基因\n→ Step 4: 建立 queue = [(startGene,0)] // 起始基因和距離\n→ Step 5: 將 startGene 加入 visitedSet // 標記已訪問\n→ Decision: queue 是否為空? // 判斷是否還有基因可處理\n    Yes → End // queue 空，無路徑，返回 -1\n    No  → \n        → Step 6: 從 queue 取出 gene, dist // 取下一個基因\n        → Decision: gene == endGene? // 是否達到目標\n            Yes → End // 直接返回 dist\n            No  →\n                → Step 7: 針對每個位置 i 在 0..7\n                    → Step 8: 針對每個字母 ch 在 letters\n                        → Decision: ch != gene[i]? // 必須改變\n                            Yes →\n                                → Step 9: 產生 newGene = gene 前 i + ch + gene 後 i+1 // 新基因\n                                → Decision: newGene 在 bankSet 且 newGene 未在 visitedSet? // 有效且未訪問\n                                    Yes →\n                                        → Step 10: 加入 visitedSet, newGene\n                                        → Step 11: 將 (newGene, dist+1) 加入 queue\n                                    No  → // 其它情況忽略\n                // 轉回 Decision: queue 是否為空? // 重複迴圈\n        // End While loop after queue empty\n→ End // 返回 -1\n\nWe need to add return -1 at end.\n\nWe can add Step 12: return -1\n\nLet's produce lines with proper arrow and indent. Ensure each line has // explanation. Use proper indentation for nested Decision.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 letters = ['A','C','G','T'] // 基本可用字母集合  \n→ Step 2: 建立 bankSet = set(bank) // 將基因庫轉為集合以加速查詢  \n→ Step 3: 建立 visitedSet = empty set // 追蹤已訪問的基因  \n→ Step 4: 建立 queue = [(startGene, 0)] // 起始基因與距離  \n→ Step 5: 將 startGene 加入 visitedSet // 標記起點已被處理  \n→ Decision: queue 是否為空? // 判斷是否還有基因要處理  \n Yes → End // queue 为空，表示不存在路徑，返回 -1  \n No  →  \n  → Step 6: 從 queue 取出 gene, dist // 取下一個待處理基因  \n  → Decision: gene == endGene? // 是否已達到目標基因  \n   Yes → End // 找到目標，返回當前距離  \n   No  →  \n    → Step 7: 針對每個位置 i 在 0..7  \n     → Step 8: 針對每個字母 ch 在 letters  \n      → Decision: ch != gene[i]? // 必須改變字元  \n       Yes →  \n        → Step 9: 產生 newGene = gene[:i] + ch + gene[i+1:] // 新基因  \n        → Decision: newGene 在 bankSet 且 newGene 未在 visitedSet? // 有效且未訪問  \n         Yes →  \n          → Step 10: 將 newGene 加入 visitedSet // 標記已訪問  \n          → Step 11: 將 (newGene, dist+1) 加入 queue // 下一步距離加一  \n          No  → // 其它情況忽略  \n       No  → // 其它情況忽略  \n     // 重複 Step 7 至 Step 11  \n   // 迴圈結束後回到 Decision: queue 是否為空?  \n   // 這一步會被外層 Decision 自動處理  \n  → Step 12: return -1 // 若 queue 为空且未返回，表示無法達成目標  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆（最大堆的反向）用來儲存較小一半的數字\n        self.small = []  # 儲存負值，實際上是最大堆\n        # 大根堆（最小堆）用來儲存較大一半的數字\n        self.large = []  # 儲存正值，最小堆\n\n    def addNum(self, num: int) -> None:\n        # 先把新數字加入小堆（最大堆）\n        heapq.heappush(self.small, -num)\n        # 若小堆最大值大於大堆最小值，交換兩個堆頂\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 重新平衡：兩堆大小差距不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入轉成兩個列表：commands 與 args\n    wrapped = '[' + data + ']'\n    commands, args = ast.literal_eval(wrapped)\n    obj = None\n    output = []\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            output.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            output.append(None)\n        elif cmd == \"findMedian\":\n            median = obj.findMedian()\n            output.append(median)\n    # 用 json.dumps 讓 None 轉成 null，符合 LeetCode 輸出格式\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for a class MedianFinder. The typical solution: two heaps: max-heap for lower half, min-heap for upper half. Insert number: if lower empty or num <= max of lower, add to lower; else add to upper. Rebalance: sizes differ >1: move one. findMedian: if sizes equal: average top of each; else top of larger heap. We'll produce step-by-step pseudo-code with arrows, start, end, decisions, etc. Ensure each line has \"虛擬碼步驟 // 解釋\". Use Chinese. Use \"Start\", \"End\", \"Decision:\". Provide steps for class definition, constructor, addNum, findMedian. Provide the algorithm steps within functions. Use indentation perhaps but arrow lines.\n\nLet's produce.\n\nNeed to be careful to use arrow \"→\". Also for decisions: \"Decision: ...\". Provide each line.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MedianFinder 類 // 建立類別\n→ Step 2: 在類別內宣告 maxHeap: 優先級佇列 (最大堆) // 儲存較小一半\n→ Step 3: 在類別內宣告 minHeap: 優先級佇列 (最小堆) // 儲存較大一半\n→ Step 4: 定義構造函式 MedianFinder() // 初始化構造\n    → Step 5: maxHeap ← 新的空最大堆 // 初始化空堆\n    → Step 6: minHeap ← 新的空最小堆 // 初始化空堆\n→ Step 7: 定義方法 addNum(num) // 新增數字\n    → Decision: 如果 maxHeap 为空 或 num ≤ maxHeap.top()? // 判斷放在哪一堆\n        Yes → maxHeap.push(num) // 加入較小堆\n        No  → minHeap.push(num) // 加入較大堆\n    → Step 8: Decision: maxHeap.size() > minHeap.size() + 1? // 檢查左堆過大\n        Yes → minHeap.push(maxHeap.top()); maxHeap.pop() // 平衡，搬移一個\n        No → Decision: minHeap.size() > maxHeap.size() + 1? // 檢查右堆過大\n            Yes → maxHeap.push(minHeap.top()); minHeap.pop() // 平衡，搬移一個\n            No  → // 已平衡\n→ Step 9: 定義方法 findMedian() // 計算中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 兩堆大小相等\n        Yes → return (maxHeap.top() + minHeap.top()) / 2.0 // 取平均\n        No → Decision: maxHeap.size() > minHeap.size()? // 左堆較大\n            Yes → return maxHeap.top() // 取左堆頂\n            No  → return minHeap.top() // 取右堆頂\nEnd // 程式結束\n\nNeed to ensure each line has \"虛擬碼步驟 // 解釋\". The \"Decision:\" lines also include explanation after //. Provide indentation with arrow maybe not necessary but we can show. Ensure each line unique. Provide pseudo-code step with arrow at start of line.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MedianFinder 類 // 建立類別\n→ Step 2: 在類別內宣告 maxHeap: 優先級佇列（最大堆） // 儲存較小一半\n→ Step 3: 在類別內宣告 minHeap: 優先級佇列（最小堆） // 儲存較大一半\n→ Step 4: 定義構造函式 MedianFinder() // 初始化構造\n    → Step 5: maxHeap ← 新的空最大堆 // 初始化空堆\n    → Step 6: minHeap ← 新的空最小堆 // 初始化空堆\n→ Step 7: 定義方法 addNum(num) // 新增數字\n    → Decision: 如果 maxHeap 为空 或 num ≤ maxHeap.top()? // 判斷放在哪一堆\n        Yes → maxHeap.push(num) // 加入較小堆\n        No  → minHeap.push(num) // 加入較大堆\n    → Step 8: Decision: maxHeap.size() > minHeap.size() + 1? // 檢查左堆過大\n        Yes → minHeap.push(maxHeap.top()); maxHeap.pop() // 平衡，搬移一個\n        No  → Decision: minHeap.size() > maxHeap.size() + 1? // 檢查右堆過大\n            Yes → maxHeap.push(minHeap.top()); minHeap.pop() // 平衡，搬移一個\n            No  → // 已平衡\n→ Step 9: 定義方法 findMedian() // 計算中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 兩堆大小相等\n        Yes → return (maxHeap.top() + minHeap.top()) / 2.0 // 取平均\n        No → Decision: maxHeap.size() > minHeap.size()? // 左堆較大\n            Yes → return maxHeap.top() // 取左堆頂\n            No  → return minHeap.top() // 取右堆頂\nEnd // 程式結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp12caf9rd.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmp12caf9rd.py\", line 50, in main\n    intervals = ast.literal_eval(interval_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpblcz6dgt.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpblcz6dgt.py\", line 50, in main\n    intervals = ast.literal_eval(interval_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport json\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals,\n        merging any that overlap.\n        \"\"\"\n        result = []          # 最終結果\n        i = 0\n        n = len(intervals)\n\n        # 1. 將所有不重疊且在 newInterval 之前的區間直接加入\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 2. 合併所有與 newInterval 有重疊的區間\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        result.append(newInterval)\n\n        # 3. 將剩餘不重疊且在 newInterval 之後的區間加入\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n\n    # 取得 intervals 與 newInterval 的字串\n    interval_pat = r'intervals\\s*=\\s*(\\[.*?\\])'\n    newint_pat = r'newInterval\\s*=\\s*(\\[.*?\\])'\n    interval_match = re.search(interval_pat, data, re.S)\n    newint_match = re.search(newint_pat, data, re.S)\n\n    if not interval_match or not newint_match:\n        print(\"[]\")\n        return\n\n    # 解析為 Python 物件\n    intervals = ast.literal_eval(interval_match.group(1))\n    newInterval = ast.literal_eval(newint_match.group(1))\n\n    # 執行解法\n    sol = Solution()\n    merged = sol.insert(intervals, newInterval)\n\n    # 輸出 JSON 形式，避免多餘空格\n    print(json.dumps(merged))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line with comments. Problem: insert interval into sorted non-overlapping intervals, merging as needed. Provide algorithm: iterate, add intervals before new, merge overlaps, add after.\n\nWe need virtual code with Start, End, Decision. Steps include: initialize result array, for each interval: if interval.end < new.start: add to result. Else if interval.start > new.end: add newInterval if not added yet, then add remaining intervals. Else: overlapping -> merge: new.start = min(new.start, interval.start), new.end = max(new.end, interval.end). After loop, if new not added: add. Return result.\n\nWe'll output line by line.\n\nMake sure to use arrows and decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用來存儲最終的區間集合  \n→ Step 2: 設定 flag added = False // 標記 newInterval 是否已經加入 result  \n→ Step 3: 從 intervals 中遍歷每個 interval // 處理所有已排序且不重疊的區間  \n&nbsp;&nbsp;→ Decision: 如果 interval.end < newInterval.start? // 檢查此區間是否完全在 newInterval 之前  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: 將 interval 加入 result // 区间不重疊，直接保存  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 如果 interval.start > newInterval.end? // 檢查此區間是否完全在 newInterval 之後  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: 如果 not added? // 是否還沒把 newInterval 加入  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: 將 newInterval 加入 result // 把新區間放到正確位置  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: 直接跳過 // newInterval 已經加入，不再重複  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set added = True  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: 合併區間  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newInterval.start = min(newInterval.start, interval.start) // 取更小的起點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newInterval.end = max(newInterval.end, interval.end) // 取更大的終點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 8: 將 interval 加入 result // 若與 newInterval 不重疊且在之後  \n&nbsp;&nbsp;→ Step 9: 循環結束後，判斷是否還未加入 newInterval  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 如果 not added?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 10: 將 newInterval 加入 result // 若最後仍未加入，現在加入  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 11: 何無操作  \n→ Step 12: 返回 result // 回傳插入並合併後的區間集合  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Parentheses",
      "source_file": "Leetcode/leetcode20.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 1,
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 3,
          "input": "s = \"([])\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        Check if the string s consisting of brackets is valid.\n        \"\"\"\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n\n        for char in s:\n            if char in mapping:            # it's a closing bracket\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:                           # it's an opening bracket\n                stack.append(char)\n        return not stack\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # Read the entire input\n    raw_input = sys.stdin.read().strip()\n\n    # Try to extract the string inside quotes (e.g., s = \"()\")\n    start = raw_input.find(\"'\")\n    end = raw_input.rfind(\"'\")\n    if start != -1 and end != -1 and end > start:\n        s = raw_input[start + 1:end]\n    else:\n        # Fallback: use the whole input if no quotes are found\n        s = raw_input\n\n    solution = Solution()\n    result = solution.isValid(s)\n\n    # Output in lowercase as required\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to output pseudocode step by step. No actual code. Use the specified format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End, Decision. We need to describe algorithm: push open brackets onto stack; for each char, if open push; if close check stack top matches; else invalid. At end stack must be empty. Provide step by step.\n\nWe need to include decisions: if char is open or close, etc.\n\nWe must output each line separately. Let's produce:\n\nStart // 程式開始\n→ Step 1: 初始化一個空棧 // 用於存放未匹配的開括號\n→ Step 2: 遍歷字符串 s 的每個字符 // 逐一檢查每個符號\n    → Decision: 當前字符是 '(' 或 '[' 或 '{' ?\n        Yes → Step 3: 將該開括號推入棧 // 等待後續匹配\n        No → Decision: 當前字符是 ')' 或 ']' 或 '}' ?\n            Yes → Step 4: 如果棧為空？\n                Yes → Step 5: 返回 False // 沒有可匹配的開括號\n                No  → Step 6: pop 類型為棧頂的開括號 // 取出已匹配的開括號\n                    → Decision: pop 的開括號與當前閉括號是否匹配？\n                        Yes → Step 7: 繼續遍歷下一個字符 // 匹配成功\n                        No  → Step 8: 返回 False // 匹配失敗\n            No  → Step 9: 返回 False // 遇到未知字符\n→ Decision: 遍歷完畢後棧是否為空？\n    Yes → Step 10: 返回 True // 所有括號匹配\n    No  → Step 11: 返回 False // 還有未匹配的開括號\nEnd // 程式結束\n\nMake sure each line includes comment. Provide arrow as required.\n\nLet's ensure proper indentation? In sample, they used indentation for decisions. We'll mimic.\n\nAlso include \"Start\" \"End\" lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空棧 // 用來存放尚未匹配的開括號  \n→ Step 2: 遍歷字符串 s 的每個字符 // 逐個檢查每個符號  \n    → Decision: 當前字符是 '(' 或 '[' 或 '{'？ // 判斷是否為開括號  \n        Yes → Step 3: 將該開括號推入棧 // 等待之後匹配  \n        No → Decision: 當前字符是 ')' 或 ']' 或 '}'？ // 判斷是否為閉括號  \n            Yes → Step 4: 如果棧為空？ // 無可匹配的開括號  \n                Yes → Step 5: 返回 False // 括號不合法  \n                No → Step 6: pop 棧頂開括號 // 取出最近的開括號  \n                    → Decision: pop 的開括號與當前閉括號是否匹配？  \n                        Yes → Step 7: 繼續遍歷下一個字符 // 匹配成功  \n                        No → Step 8: 返回 False // 匹配失敗  \n            No → Step 9: 返回 False // 遇到未知字符  \n→ Decision: 遍歷完畢後棧是否為空？ // 檢查是否有未匹配的開括號  \n    Yes → Step 10: 返回 True // 所有括號合法且正確匹配  \n    No → Step 11: 返回 False // 仍有未匹配的開括號  \nEnd // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsheaxgud.py\", line 44, in <module>\n    args_list = ast.literal_eval(args_str)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # move to most recently used\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # evict least recently used\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Try to parse two lists from the input\n    match = re.match(r'\\s*(\\[[^\\]]*\\])\\s*,\\s*(\\[[^\\]]*\\])\\s*', data)\n    if match:\n        cmds_str, args_str = match.group(1), match.group(2)\n    else:\n        # Fallback: input may be split across lines\n        parts = data.splitlines()\n        if len(parts) >= 2:\n            cmds_str, args_str = parts[0].strip(), parts[1].strip()\n        else:\n            raise ValueError(\"Invalid input format\")\n\n    commands = ast.literal_eval(cmds_str)\n    args_list = ast.literal_eval(args_str)\n\n    cache = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"LRUCache\":\n            cache = LRUCache(args[0])\n            results.append(None)          # constructor returns null\n        elif cmd == \"get\":\n            results.append(cache.get(args[0]))\n        elif cmd == \"put\":\n            cache.put(args[0], args[1])\n            results.append(None)          # put returns null\n        else:\n            # Unknown command; ignore or raise error as needed\n            pass\n\n    # Output results in JSON format so that None becomes null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code outline for LRU cache. Each line: \"虛擬碼步驟 // 解釋\". Use arrow →, decisions, Start End. Must produce step-by-step pseudocode. Not actual code. Provide structure. Should cover initialization, get, put, eviction. Use hashmap and doubly linked list concept. Provide O(1). Each line with explanation. Let's produce.\n\nNeed to keep format exactly: \"虛擬碼步驟 // 解釋\". Use arrow. Eg: \"Start // 程式開始執行\".\n\nLet's produce a sequence: Start -> initialize capacity and data structures -> define Node -> define hashmap -> define head/tail sentinel nodes -> functions. Should be step by step. Provide decisions inside get and put. Use \"Decision:\" lines. Use \"Yes →\" \"No →\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 結構 // 每個節點包含 key、value、prev、next  \n→ Step 2: 初始化空的 hashmap key_to_node // 用於 O(1) 取得節點  \n→ Step 3: 建立兩個 sentinel 節點 head 與 tail，並將 head.next 指向 tail，tail.prev 指向 head // 代表雙向鏈表的兩端  \n→ Step 4: 設定容量 capacity，並維持 current_size 為 0 // 用來追蹤目前儲存的鍵數  \n\n// ---------- get(key) ----------  \n→ Function get(key) // 定義取得功能  \n    → Decision: key 是否存在於 hashmap?  \n        Yes → Step 5: 取得 node = key_to_node[key] // O(1) 取得節點  \n            → Step 6: 移除 node 從其目前位置 // O(1)  \n            → Step 7: 插入 node 至 head 的後面 // O(1)，表示最近使用  \n            → Step 8: 回傳 node.value // 取得對應值  \n        No  → Step 9: 回傳 -1 // key 不存在  \n\n// ---------- put(key, value) ----------  \n→ Function put(key, value) // 定義插入/更新功能  \n    → Decision: key 是否已存在於 hashmap?  \n        Yes → Step 10: 取得 node = key_to_node[key] // 已存在  \n            → Step 11: 更新 node.value = value // 更新值  \n            → Step 12: 移除 node 從其目前位置 // O(1)  \n            → Step 13: 插入 node 至 head 的後面 // O(1)  \n        No  → Step 14: 建立新節點 new_node(key, value) // 新建節點  \n            → Step 15: 插入 new_node 至 head 後面 // O(1)  \n            → Step 16: key_to_node[key] = new_node // 在 hashmap 中註冊  \n            → Step 17: current_size += 1 // 數量增加  \n            → Decision: current_size 是否 > capacity?  \n                Yes → Step 18: 找到 lru_node = tail.prev // 最舊節點  \n                    → Step 19: 移除 lru_node 從鏈表 // O(1)  \n                    → Step 20: 刪除 key_to_node[lru_node.key] // hashmap 移除  \n                    → Step 21: current_size -= 1 // 數量減少  \n                No → No action  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    lines = data.splitlines()\n    results = []\n    obj = None\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        if line.startswith(\"RangeModule\"):\n            obj = RangeModule()\n            results.append(\"null\")\n        elif line.startswith(\"rangeModule.addRange\"):\n            m = re.search(r'addRange\\((\\d+),\\s*(\\d+)\\)', line)\n            if m:\n                left, right = int(m.group(1)), int(m.group(2))\n                obj.addRange(left, right)\n                results.append(\"null\")\n        elif line.startswith(\"rangeModule.removeRange\"):\n            m = re.search(r'removeRange\\((\\d+),\\s*(\\d+)\\)', line)\n            if m:\n                left, right = int(m.group(1)), int(m.group(2))\n                obj.removeRange(left, right)\n                results.append(\"null\")\n        elif line.startswith(\"rangeModule.queryRange\"):\n            m = re.search(r'queryRange\\((\\d+),\\s*(\\d+)\\)', line)\n            if m:\n                left, right = int(m.group(1)), int(m.group(2))\n                res = obj.queryRange(left, right)\n                results.append(str(res).lower())\n    output = \"[\" + \", \".join(results) + \"]\"\n    print(output)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for RangeModule. Should describe design: likely using ordered list of non-overlapping intervals. Implement addRange, queryRange, removeRange. We need to produce step-by-step pseudo-code.\n\nMake sure each line follows format: \"虛擬碼步驟 // 解釋\".\n\nUse arrow \"→\" to indicate sequence. Use Decision.\n\nWe must produce a stepwise algorithm description. Provide start, etc. Provide maybe high-level skeleton of methods. Not actual code, but steps.\n\nLet's outline:\n\nStart\n→ Initialize RangeModule with empty interval list // list to store intervals\n\nImplement addRange:\n→ Find first interval with end >= left (using binary search) // locate insertion point\n→ Merge overlapping intervals\n→ Insert new merged interval\n\nImplement queryRange:\n→ Find interval with start <= left and end >= right? // check covering\n\nImplement removeRange:\n→ Find overlapping intervals\n→ Adjust or split intervals accordingly\n→ Remove fully covered intervals\n\nWe need to provide step-by-step. Each line separate. Use arrows. Provide decision points. Let's produce full pseudo steps.\n\nWe should maybe define helper: find position index. But keep simple.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義 RangeModule 類別 // 建立資料結構的類別\n\n→ Step 2: 初始化內部變數 intervals 為空列表 // 用來儲存已追蹤的半開區間\n\n→ Step 3: 建立 addRange 方法 // 用來加入新區間\n\n    → Step 4: 在 intervals 中找到第一個區間，其 end ≥ left （可使用二分搜尋） // 找到可能重疊的起始位置\n    → Decision: 如果不存在此區間？ // 若無重疊區間\n        No → Step 5: 直接將 [left, right) 插入 intervals 且保持排序 // 新增獨立區間\n        Yes → Step 6: 設定 mergeLeft ← min(left, current.start) // 確定合併的左端\n            → Step 7: 設定 mergeRight ← right // 初始合併右端\n            → Step 8: 從找到的區間開始向後遍歷，直到遇到區間 start > right\n                → Decision: 如果區間 start ≤ right？ // 判斷是否重疊\n                    Yes → Step 9: mergeRight ← max(mergeRight, interval.end) // 擴大合併右端\n                    No  → Step 10: 停止遍歷 // 往後區間不再重疊\n            → Step 11: 移除所有已被合併的區間（從 Step 4 找到的開始到 Step 10 停止位置）\n            → Step 12: 插入新區間 [mergeLeft, mergeRight) 並保持排序 // 完成合併後的插入\n\n→ Step 13: 建立 queryRange 方法 // 用來查詢區間是否完全被追蹤\n\n    → Step 14: 在 intervals 中找到第一個區間，其 end > left （可使用二分搜尋） // 可能覆蓋左端的區間\n    → Decision: 如果此區間不存在？ // 沒有區間覆蓋左端\n        No → Step 15: 回傳 false // 不能覆蓋整個查詢區間\n        Yes → Step 16: 判斷此區間的 start ≤ left 且 end ≥ right\n            → Decision: 如果條件為真？ // 整個查詢區間被此區間覆蓋\n                Yes → Step 17: 回傳 true\n                No  → Step 18: 回傳 false // 只覆蓋一部分\n\n→ Step 19: 建立 removeRange 方法 // 用來移除指定區間\n\n    → Step 20: 在 intervals 中找到第一個區間，其 end > left （可使用二分搜尋） // 可能被刪除的區間\n    → Step 21: 從 Step 20 開始遍歷所有區間，直到區間 start ≥ right\n        → Decision: 如果區間 end ≤ left？ // 不在刪除範圍內\n            Yes → Step 22: 跳過此區間 // 仍保持不變\n            No  → Decision: 如果區間 start < left && end > right？\n                Yes → Step 23: 將此區間拆分為兩個區間 [start, left) 和 [right, end) // 刪除中間部分\n                No  → Decision: 如果區間 start < left < end ≤ right？\n                    Yes → Step 24: 將區間的 end 設為 left // 刪除右半部\n                    No  → Decision: 如果 left ≤ start < right < end？\n                        Yes → Step 25: 將區間的 start 設為 right // 刪除左半部\n                        No  → Step 26: 直接移除此區間 // 完全被刪除\n    → Step 27: 完成所有被移除或調整的區間\n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpko0fhgff.py\", line 88, in <module>\n    main()\n  File \"/tmp/tmpko0fhgff.py\", line 61, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n    result = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args)\n            result.append(None)\n        elif op == \"insertFront\":\n            result.append(obj.insertFront(*args))\n        elif op == \"insertLast\":\n            result.append(obj.insertLast(*args))\n        elif op == \"deleteFront\":\n            result.append(obj.deleteFront(*args))\n        elif op == \"deleteLast\":\n            result.append(obj.deleteLast(*args))\n        elif op == \"getFront\":\n            result.append(obj.getFront(*args))\n        elif op == \"getRear\":\n            result.append(obj.getRear(*args))\n        elif op == \"isEmpty\":\n            result.append(obj.isEmpty(*args))\n        elif op == \"isFull\":\n            result.append(obj.isFull(*args))\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a line-by-line pseudo-code with comments. The pseudo-code must use arrows and structure. It should cover the design of a circular double-ended queue.\n\nWe need to include initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. We must not output actual code, just pseudo-code lines with arrow or decision.\n\nWe need to be clear.\n\nWe can represent the deque with an array of size k, and two pointers front and rear, perhaps. For circular behavior, we can use modulo. We should handle empty and full conditions.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\".\n\nWe need to show step by step.\n\nWe may structure as:\n\nStart\n\n→ Step: 定義 MyCircularDeque 類 // define class\n\n→ Step: MyCircularDeque(int k) // constructor\n\n→ Step: Initialize array arr of size k // store items\n\n→ Step: Set front = -1, rear = -1 // pointers\n\n→ Step: Set capacity = k\n\n→ Step: End constructor\n\nThen operations: insertFront, insertLast etc. We can show each operation as steps.\n\nWe can maybe group each operation as a block.\n\nWe can use Decision lines to check empty or full.\n\nBetter to structure like:\n\n→ Step: boolean insertFront(val) // method\n\n→ Decision: if isFull()? // check full\n\n→   Yes → Step: return false // cannot insert\n\n→   No  → Step: if isEmpty()? // check empty\n\n→       Yes → Step: front = 0; rear = 0; arr[front] = val // set first element\n\n→       No  → Step: front = (front - 1 + capacity) % capacity; arr[front] = val // insert at front\n\n→ Step: return true\n\nSimilarly for insertLast.\n\nWe need to show getFront etc.\n\nWe can show isEmpty, isFull.\n\nAlright, produce each line accordingly.\n\nWe need to ensure every line includes \"虛擬碼步驟 // 解釋\". Also arrow usage.\n\nWe must start with Start and End.\n\nWe also need to handle the entire design. We can use comments like \"MyCircularDeque 類定義\" etc.\n\nWe must not output actual code but pseudocode.\n\nLet's write the output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類 // 建立類別  \n→ Step 2: MyCircularDeque(int k) // 建構子，接收容量  \n→ Step 3: Set capacity = k // 儲存最大容量  \n→ Step 4: 建立陣列 arr[capacity] // 用來儲存元素  \n→ Step 5: Set front = -1 // 初始化前指標  \n→ Step 6: Set rear = -1 // 初始化後指標  \n→ Step 7: End MyCircularDeque 建構子 // 結束建構  \n→  \n→ Step 8: boolean insertFront(val) // 前插入方法  \n→   Decision: 是否已滿? (isFull())  \n→     Yes → Step 9: Return false // 不能插入，已滿  \n→     No  → Decision: 是否為空? (isEmpty())  \n→         Yes → Step 10: front = 0; rear = 0; arr[front] = val // 第一個元素  \n→         No  → Step 11: front = (front - 1 + capacity) % capacity; arr[front] = val // 往前插入  \n→   Step 12: Return true // 成功插入  \n→ End insertFront  \n→  \n→ Step 13: boolean insertLast(val) // 後插入方法  \n→   Decision: 是否已滿? (isFull())  \n→     Yes → Step 14: Return false // 不能插入，已滿  \n→     No  → Decision: 是否為空? (isEmpty())  \n→         Yes → Step 15: front = 0; rear = 0; arr[rear] = val // 第一個元素  \n→         No  → Step 16: rear = (rear + 1) % capacity; arr[rear] = val // 往後插入  \n→   Step 17: Return true // 成功插入  \n→ End insertLast  \n→  \n→ Step 18: boolean deleteFront() // 前刪除方法  \n→   Decision: 是否為空? (isEmpty())  \n→     Yes → Step 19: Return false // 不能刪除，空  \n→     No  → Decision: 前後指標相同? (front == rear)  \n→         Yes → Step 20: front = -1; rear = -1 // 清空整個佇列  \n→         No  → Step 21: front = (front + 1) % capacity // 移動前指標  \n→   Step 22: Return true // 成功刪除  \n→ End deleteFront  \n→  \n→ Step 23: boolean deleteLast() // 後刪除方法  \n→   Decision: 是否為空? (isEmpty())  \n→     Yes → Step 24: Return false // 不能刪除，空  \n→     No  → Decision: 前後指標相同? (front == rear)  \n→         Yes → Step 25: front = -1; rear = -1 // 清空整個佇列  \n→         No  → Step 26: rear = (rear - 1 + capacity) % capacity // 移動後指標  \n→   Step 27: Return true // 成功刪除  \n→ End deleteLast  \n→  \n→ Step 28: int getFront() // 取得前項  \n→   Decision: 是否為空? (isEmpty())  \n→     Yes → Step 29: Return -1 // 空佇列  \n→     No  → Step 30: Return arr[front] // 回傳前項  \n→ End getFront  \n→  \n→ Step 31: int getRear() // 取得後項  \n→   Decision: 是否為空? (isEmpty())  \n→     Yes → Step 32: Return -1 // 空佇列  \n→     No  → Step 33: Return arr[rear] // 回傳後項  \n→ End getRear  \n→  \n→ Step 34: boolean isEmpty() // 檢查是否為空  \n→   Step 35: Return front == -1 // 若前指標為 -1，佇列空  \n→ End isEmpty  \n→  \n→ Step 36: boolean isFull() // 檢查是否已滿  \n→   Step 37: Return (front == (rear + 1) % capacity) // 前後相鄰時為滿  \n→ End isFull  \n→  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"找出所有重複檔案的群組\"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]                     # 目錄路徑\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]          # 去掉結尾的 ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # 只保留重複的群組\n        return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 轉成列表，如果輸入形式為 'paths = [...]'\n    if raw_input.startswith('paths'):\n        _, _, list_str = raw_input.partition('=')\n        paths_list = ast.literal_eval(list_str.strip())\n    else:\n        # 若直接給列表字串\n        paths_list = ast.literal_eval(raw_input)\n\n    solution = Solution()\n    result = solution.findDuplicate(paths_list)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanations. The requirement: no actual code, just virtual steps with arrows. Format: Each line: virtual step + space + // explanation. Use arrows and structure. For decisions: Decision: etc. Use Start and End.\n\nWe need to design algorithm: iterate over directory info strings, parse each: split by space to get path and file entries. For each file entry, extract filename and content. Build map from content to list of full paths. After processing all, filter map entries with list size>=2, collect into result list. Return result.\n\nWe need to present step by step. Provide decision steps. Use Start, End.\n\nWe need to include parsing details: e.g., split path string by spaces, etc.\n\nMake sure each line ends with // explanation. Use arrow arrow. Use indentation for nested steps? Format not specified but sample shows indentation for nested decisions. We'll use indent with spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 contentMap：content → list of file paths // 用來儲存每種內容對應的檔案路徑  \n→ Step 2: 對於輸入列表 paths 中的每一個 directoryInfo // 逐一處理每個目錄資訊  \n  → Step 2.1: 以空格分隔 directoryInfo 為 parts // 第一個部分是目錄路徑，剩下的是檔案資訊  \n   → Step 2.2: 設定 dirPath = parts[0] // 取得目錄路徑  \n   → Decision: parts 長度 > 1? // 判斷是否有檔案資訊  \n    Yes → Step 2.3: 對於 parts[1:] 中的每一個 fileEntry // 逐一處理檔案資訊  \n      → Step 2.3.1: 以 '(' 分割 fileEntry 成 namePart 與 contentPart // 分離檔名與內容  \n      → Step 2.3.2: 取得 fileName = namePart // 檔名  \n      → Step 2.3.3: 取得 fileContent = contentPart 去掉最後的 ')' // 檔案內容  \n      → Step 2.3.4: 建立 fullPath = dirPath + '/' + fileName // 完整路徑  \n      → Step 2.3.5: 若 contentMap 中不存在 fileContent, 則新增空列表  \n      → Step 2.3.6: 將 fullPath 加入 contentMap[fileContent] 的列表  \n      → Step 2.3.7: // 完成單個檔案的處理  \n      // 完成該檔案資訊的處理  \n      // 返回 Step 2.2  \n      // 回到 Step 2.2 的迴圈  \n      // 完成所有檔案資訊的處理  \n      // 回到 Step 2.2  \n      // 完成該 directoryInfo 的處理  \n      // 返回 Step 2  \n      // 回到 Step 2 的迴圈  \n    No → Step 2.4: // 這個 directoryInfo 只有目錄本身，無檔案，直接跳過  \n    // 完成 Step 2 的處理  \n→ Step 3: 建立 result 列表 // 用來儲存重複檔案的群組  \n→ Step 4: 對於 contentMap 中的每一個 entry (content, pathsList) // 遍歷內容對應的路徑列表  \n  → Decision: pathsList 長度 >= 2? // 判斷是否為重複檔案群組  \n   Yes → Step 4.1: 將 pathsList 加入 result // 加入重複檔案群組  \n   No → Step 4.2: // 跳過單一檔案的內容  \n→ Step 5: 回傳 result // 程式結束，輸出重複檔案群組  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0r8b_k1f.py\", line 71, in <module>\n    main()\n  File \"/tmp/tmp0r8b_k1f.py\", line 46, in main\n    cmds = ast.literal_eval(parts[0].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ['Trie'\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split into two lists: commands and arguments\n    # Expected format: \"['cmd1', 'cmd2', ...], [['arg1'], ['arg2'], ...]\"\n    # We use ast.literal_eval for safe evaluation\n    parts = data.split(',', 1)\n    cmds = ast.literal_eval(parts[0].strip())\n    args_list = ast.literal_eval(parts[1].strip())\n\n    results = []\n    trie = None\n\n    for cmd, args in zip(cmds, args_list):\n        if cmd == 'Trie':\n            trie = Trie()\n            results.append(None)\n        elif cmd == 'insert':\n            trie.insert(args[0])\n            results.append(None)\n        elif cmd == 'search':\n            results.append(trie.search(args[0]))\n        elif cmd == 'startsWith':\n            results.append(trie.startsWith(args[0]))\n        else:\n            # Unsupported command; skip or raise error\n            results.append(None)\n\n    # Output results in JSON format (null, true, false)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Must not output actual code. We need to design a Trie class with operations. Provide step-by-step pseudocode with explanations. Use Start, End, Decision: and arrows. Should be line by line. Each line: \"虛擬碼步驟 // 解釋\". We need to include class definition, initialization, insert, search, startsWith. Use a Node structure perhaps. We'll produce a high-level algorithm. Each step maybe: Start, Initialize root node, define Node structure with children map and isEnd flag, Insert: for each character, if not exist, create node, move to child, after loop mark isEnd. Search: similar, but return false if missing, after loop return isEnd. startsWith: traverse and return true if all chars found. Provide decisions for missing node.\n\nMake sure to include arrows. Use indentation. Use decision blocks. Provide explanation after each line.\n\nLet's generate.\n\nWe need to keep structure. Probably use:\n\nStart // 開始\n→ Define Node // 定義節點結構\n    → Node: children map, isEnd flag\n→ Define Trie // 定義 Trie 類別\n    → Trie: root node\n→ Method: insert(word)\n    → Step: current = root\n    → For each char in word\n        → If char not in current.children\n            → Create new node, add to children\n        → current = current.children[char]\n    → After loop: current.isEnd = true\n→ Method: search(word)\n    → Step: current = root\n    → For each char in word\n        → If char not in current.children → return false\n        → current = current.children[char]\n    → After loop: return current.isEnd\n→ Method: startsWith(prefix)\n    → Step: current = root\n    → For each char in prefix\n        → If char not in current.children → return false\n        → current = current.children[char]\n    → After loop: return true\nEnd // 結束\n\nWe need to include decisions. Use Decision: for missing child. Eg.\n\n→ Decision: if char not in current.children? // 檢查字符是否已存在\n   Yes → Step: create node // 新增節點\n   No  → Step: move to child // 直接往下\n\nLet's produce accordingly.\n\nAlso for search and startsWith decisions.\n\nLet's output with each line in that format. Use arrow \"→\" at beginning of each line, but decisions will be indented. Use \"Decision:\" lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Node // 定義節點結構  \n→   Node: children map, isEnd flag // children 用於存放子節點，isEnd 標記單詞結束  \n→ Define Trie // 定義 Trie 類別  \n→   Trie: root node // 根節點不代表任何字元，所有單詞皆從此節點開始  \n→ Method: insert(word) // 插入單詞的流程  \n→   Step: current ← root // 以根節點為起點  \n→   For each char in word // 逐字處理  \n→     Decision: if char not in current.children? // 檢查當前節點是否已有此字元的子節點  \n→       Yes → Step: create new Node for char, add to current.children // 新增子節點  \n→       No  → // 已存在，直接使用  \n→     Step: current ← current.children[char] // 移動到該子節點  \n→   After loop: current.isEnd ← true // 標記單詞結束位置  \n→ Method: search(word) // 搜尋單詞是否已存在  \n→   Step: current ← root // 以根節點為起點  \n→   For each char in word // 逐字處理  \n→     Decision: if char not in current.children? // 若缺失則單詞不存在  \n→       Yes → Step: return false // 結束搜尋，單詞不存在  \n→       No  → // 存在，繼續  \n→     Step: current ← current.children[char] // 移動到該子節點  \n→   After loop: Step: return current.isEnd // 若到達終點且 isEnd 為 true，單詞存在  \n→ Method: startsWith(prefix) // 判斷是否有任何單詞以 prefix 為前綴  \n→   Step: current ← root // 以根節點為起點  \n→   For each char in prefix // 逐字處理  \n→     Decision: if char not in current.children? // 若缺失則不存在前綴  \n→       Yes → Step: return false // 結束搜尋，前綴不存在  \n→       No  → // 存在，繼續  \n→     Step: current ← current.children[char] // 移動到該子節點  \n→   After loop: Step: return true // 所有字元皆匹配，存在前綴  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[1]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[1]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[2,9]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[2, 9]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[4,8,9]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[4, 8, 9]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\n# API: returns a uniform random integer in [1, 7]\ndef rand7() -> int:\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        Generates a uniform random integer in the range [1, 10]\n        using only the rand7() API.\n        \"\"\"\n        while True:\n            # First attempt: generate a value in [1, 49]\n            first = rand7()\n            second = rand7()\n            num = (first - 1) * 7 + second  # 1..49\n\n            # Accept if num is in [1, 40]\n            if num <= 40:\n                return 1 + (num - 1) % 10  # maps 1..40 -> 1..10\n\n            # Rejection: num in [41, 49]\n            rem = num - 40  # 1..9\n            third = rand7()\n            num2 = (rem - 1) * 7 + third  # 1..63\n\n            # Accept if num2 in [1, 60]\n            if num2 <= 60:\n                return 1 + (num2 - 1) % 10  # maps 1..60 -> 1..10\n            # Else reject and repeat\n\ndef main() -> None:\n    \"\"\"\n    Reads input from stdin, where the input is of the form:\n        n = <integer>\n    Generates n calls to rand10() and prints the result list.\n    \"\"\"\n    input_data = sys.stdin.read().strip()\n    # Parse the integer value of n\n    if '=' in input_data:\n        n_str = input_data.split('=')[-1].strip()\n    else:\n        n_str = input_data\n    try:\n        n = int(n_str)\n    except ValueError:\n        # If parsing fails, treat input as 0\n        n = 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating rand10() from rand7().\n\nWe must produce step-by-step algorithm: typical approach: use two rand7() calls to generate 49 values, use rejection sampling to map 1-40 to 1-10, and use leftover 41-49 to produce more values via recursion or additional calls. Classic solution: call rand7() twice to get 7x7=49 possibilities. Use number = (first-1)*7 + second, which gives 1-49. If number <= 40, return ((number-1) mod 10)+1. Else use leftover numbers 41-49 (9 values). We can generate another rand7() to transform these 9 values into 1-10 range by repeating same process: use rand7() twice again to get 49 values; use mapping from 1-10 from numbers 1-40 again; if number>40, discard and repeat. However we need to ensure no infinite loops.\n\nBetter: Use method: Use rand7() twice to produce 49 values. If value <= 40, map to 1-10. If >40, we need to map 41-49 to new range. We can use value-40 to get 1-9. Then we can produce a new 7x7 result: we can use that 1-9 plus another rand7() to produce 1-63 maybe? Wait: Another classic method: Use rand7() twice to produce 49, reject >40. Then for leftover 41-49 (9 values), we can map them into 1-10 by generating another rand7() and using the 9 leftover as base. For example: use rand7() again to generate 1-7. Then we can produce 9*7 = 63 values: (value-1)*7 + nextRand. That gives 63 possibilities. If <= 60, map to 1-10; else reject. This ensures eventually we get a value.\n\nAlternatively simpler: use recursion: If number>40, recursively call rand10() again using rand7() as needed. But that may cause many calls but still works. But typical solution uses two-stage rejection.\n\nWe'll output pseudocode with Start, Decision, etc.\n\nWe must provide \"逐行\" lines, each line: virtual code step, space, comment.\n\nLet's produce algorithm steps:\n\nStart\n→ Step 1: Generate a1 = rand7()\n→ Step 2: Generate a2 = rand7()\n→ Step 3: Compute v = (a1-1)*7 + a2 // value in 1..49\n→ Decision: if v ≤ 40? // 40 good for 1..10 mapping\n    Yes → Step 4: Return ((v-1) mod 10)+1 // uniform 1..10\n    No  → Step 5: Generate b1 = rand7()\n    → Decision: if v ≤ 49? (always true) but we need to map 41-49\nBut we need to use v' = (v-41)*7 + b1 to get 1..63? Wait.\n\nBetter: In the No branch, we want to re-use the 9 leftover values (41-49). Let's compute rem = v-40 // 1..9\n\nThen we generate b1 = rand7(), compute v2 = (rem-1)*7 + b1 // 1..63\n\nThen if v2 ≤ 60, return ((v2-1) mod 10)+1 else reject and loop again.\n\nWe can implement as loop.\n\nSo steps:\n\nStart\n→ Step 1: LoopStart // repeat until return\n→ Step 2: a1 = rand7()\n→ Step 3: a2 = rand7()\n→ Step 4: v = (a1-1)*7 + a2 // 1..49\n→ Decision: if v ≤ 40?\n    Yes → Step 5: return ((v-1) mod 10)+1\n    No  → Step 6: rem = v-40 // 1..9\n    → Step 7: b1 = rand7()\n    → Step 8: v2 = (rem-1)*7 + b1 // 1..63\n    → Decision: if v2 ≤ 60?\n        Yes → Step 9: return ((v2-1) mod 10)+1\n        No  → Step 10: goto LoopStart // discard and retry\nEnd\n\nWe need to label loop. Use Step 1: LoopStart.\n\nMake sure we don't use any other API.\n\nNow produce final virtual code lines with comments. Each line: \"虛擬碼步驟\" space \"// 解釋\".\n\nWe need arrow → for each step after Start. Also indent for nested decisions? Use sample indentation.\n\nWe'll use:\n\nStart // 程式開始執行\n→ LoopStart // 進入重試迴圈\n    → Step 1: a1 = rand7() // 產生第一個 1~7 隨機數\n    → Step 2: a2 = rand7() // 產生第二個 1~7 隨機數\n    → Step 3: v = (a1-1)*7 + a2 // 組合成 1~49 整數\n    → Decision: 如果 v ≤ 40? // 檢查是否在可直接映射區間\n        Yes → Step 4: return ((v-1) mod 10)+1 // 直接映射到 1~10\n        No  → Step 5: rem = v-40 // 取得餘下 1~9 的值\n            → Step 6: b1 = rand7() // 再次產生 1~7\n            → Step 7: v2 = (rem-1)*7 + b1 // 組合成 1~63\n            → Decision: 如果 v2 ≤ 60? // 允許的 1~60\n                Yes → Step 8: return ((v2-1) mod 10)+1 // 映射到 1~10\n                No  → Step 9: goto LoopStart // 拒絕重試\nEnd // 程式執行結束\n\nWe need to follow the format: each line start with arrow if after Start. Indentation can be represented as spaces before arrow.\n\nBut sample used indentation with spaces then arrow. Use same.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ LoopStart // 進入重試迴圈  \n    → Step 1: a1 = rand7() // 產生第一個 1~7 隨機數  \n    → Step 2: a2 = rand7() // 產生第二個 1~7 隨機數  \n    → Step 3: v = (a1-1)*7 + a2 // 組合成 1~49 整數  \n    → Decision: 如果 v ≤ 40? // 檢查是否在可直接映射區間  \n        Yes → Step 4: return ((v-1) mod 10)+1 // 直接映射到 1~10  \n        No  → Step 5: rem = v-40 // 取得餘下 1~9 的值  \n            → Step 6: b1 = rand7() // 再次產生 1~7  \n            → Step 7: v2 = (rem-1)*7 + b1 // 組合成 1~63  \n            → Decision: 如果 v2 ≤ 60? // 允許的 1~60  \n                Yes → Step 8: return ((v2-1) mod 10)+1 // 映射到 1~10  \n                No  → Step 9: goto LoopStart // 拒絕重試  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) != 8:\n        print(\"false\")\n        sys.exit(0)\n\n    p1 = [nums[0], nums[1]]\n    p2 = [nums[2], nums[3]]\n    p3 = [nums[4], nums[5]]\n    p4 = [nums[6], nums[7]]\n\n    solution = Solution()\n    result = solution.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: given 4 points in 2D, determine if they form a square. Input not sorted. Output boolean.\n\nWe need to use virtual code with arrow, decisions etc. Provide explanation each line.\n\nWe need to produce algorithm: compute all pairwise distances squared (to avoid sqrt). There are 6 distances. In a square, we should have 4 equal smaller distances (sides) and 2 equal larger distances (diagonals). Also side length > 0.\n\nThus steps: read points. Create list of distances squared. Sort. Check first 4 equal, last 2 equal, side > 0, and side*2 == diagonal? Actually in a square, diagonal^2 = 2 * side^2. So check that last distance equals 2*first distance. Could also check that 4 smallest are equal and 2 largest are equal, and largest = 2*smallest. That's standard.\n\nAlso need to ensure points distinct? Not necessary because if distances zero then side length zero -> invalid.\n\nWe need to produce pseudo-code with decisions. Let's produce step-by-step.\n\nWe'll also incorporate steps: compute distances. Then sort. Then Decision: if any side <=0? etc. Provide explanation.\n\nWe'll not output actual code. So just pseudo-code steps with arrows. Provide explanation.\n\nMake sure each line includes virtual code step and comment after //.\n\nLet's produce.\n\nPotential steps:\n\nStart\n→ Step 1: Input points p1,p2,p3,p4 // obtain four 2D points\n→ Step 2: Initialize empty list dist // to store squared distances\n→ Step 3: For each pair (i,j) with i<j, compute squared distance d = (xi - xj)^2 + (yi - yj)^2 // pairwise distances\n→ Step 4: Append d to dist\n→ Step 5: Sort dist ascending // smallest to largest\n→ Decision: 如果 dist[0] == 0? // side length zero invalid\n    Yes → Step 6: Return False // not a square\n    No  →\n→ Decision: 如果 dist[0] == dist[1] == dist[2] == dist[3]? // four equal smallest\n    Yes →\n    No  → Step 7: Return False // sides unequal\n→ Decision: 如果 dist[4] == dist[5]? // two largest equal\n    Yes →\n    No  → Step 8: Return False // diagonals unequal\n→ Decision: 如果 dist[4] == 2 * dist[0]? // diagonal^2 = 2 * side^2\n    Yes →\n    No  → Step 9: Return False // not a square\n→ Step 10: Return True // all conditions satisfied, points form a square\nEnd\n\nBut the virtual code syntax: Use arrow, e.g., \"→ Step 1: ...\" \"Decision:\" lines. Use \"Yes →\" and \"No →\".\n\nWe must include explanations after // each line.\n\nMake sure each line is separate line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取四點 p1, p2, p3, p4 // 從輸入取得四個座標  \n→ Step 2: 初始化空列表 dist // 用於存放所有點對的距離平方值  \n→ Step 3: 針對所有 i<j 的點對，計算 d = (xi - xj)^2 + (yi - yj)^2  \n  → Step 3a: 將 d 加入 dist // 收集 6 個距離平方  \n→ Step 4: 將 dist 依升序排序 // 最小距離放前面  \n→ Decision: 如果 dist[0] == 0? // 任何邊長為 0 表示重複點  \n  Yes → Step 5: 回傳 False // 不是正方形  \n  No  →  \n→ Decision: 如果 dist[0] == dist[1] == dist[2] == dist[3]? // 四條邊相等  \n  Yes →  \n  No  → Step 6: 回傳 False // 邊長不等，非正方形  \n→ Decision: 如果 dist[4] == dist[5]? // 兩條對角線相等  \n  Yes →  \n  No  → Step 7: 回傳 False // 對角線不等，非正方形  \n→ Decision: 如果 dist[4] == 2 * dist[0]? // 對角線平方 = 2 * 邊長平方  \n  Yes →  \n  No  → Step 8: 回傳 False // 不滿足 90 度角條件  \n→ Step 9: 回傳 True // 所有條件滿足，四點構成正方形  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgxkwxqe3.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpgxkwxqe3.py\", line 38, in main\n    special = ast.literal_eval(lists[1])\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxhxm2xag.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpxhxm2xag.py\", line 38, in main\n    special = ast.literal_eval(lists[1])\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # 先假設不使用任何優惠，直接按單價買\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得所有 [] 包起來的字串（含巢狀）\n    lists = re.findall(r'\\[.*?\\]', data, flags=re.DOTALL)\n    if len(lists) < 3:\n        raise ValueError(\"輸入格式不正確，缺少 price/special/needs。\")\n    price = ast.literal_eval(lists[0])\n    special = ast.literal_eval(lists[1])\n    needs = ast.literal_eval(lists[2])\n\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo code for computing minimal price using DP/backtracking with offers. Provide step by step virtual code lines with explanation.\n\nWe must produce each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nGoal: produce algorithm: use DFS with memoization (backtracking) or DP with recursion. Steps: define function dfs(remaining). Base case: if all zeros -> 0. Try each offer if applicable. Compute price: offer price + dfs(remaining - offer). Also compute normal price: sum of remaining * price. Use memo to cache.\n\nWe need to output virtual code lines, not actual code. Use Start, End, Decision, etc.\n\nWe'll produce lines: Start, define function, etc.\n\nLet's produce around 20-30 lines.\n\nWe need to ensure use of arrow syntax: \"→\" and \"Decision:\" with Yes →, No →.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義輸入變數 price, needs, special // 取得商品價格、需求與優惠資訊\n→ Step 2: 建立 memo = {} // 用於記錄已計算狀態的最低價格\n→ Step 3: 定義函式 dfs(remaining) // 依照剩餘需求遞迴尋找最低價格\n    → Decision: 如果 remaining 全為 0? // 檢查是否已購買完所有需求\n        Yes → Return 0 // 無需再付費\n        No  → // 進一步計算\n            → Step 4: 計算 normal = Σ remaining[i] * price[i] // 若不使用任何優惠的價格\n            → Step 5: best = normal // 初始最佳價格為不使用優惠\n            → Step 6: 循環每個優惠 offer in special\n                → Step 7: 可否使用 offer? // 判斷每個商品剩餘是否足以扣除優惠中的數量\n                    → Decision: 所有 remaining[i] >= offer[i] for i in 0..n-1? \n                        Yes →\n                            → Step 8: next_remaining = remaining - offer[i] for each i // 更新剩餘需求\n                            → Step 9: offer_price = offer[n] // 取優惠價格\n                            → Step 10: total = offer_price + dfs(next_remaining) // 遞迴計算其餘部分\n                            → Step 11: best = min(best, total) // 更新最佳價格\n                        No → // 無法使用此優惠，跳過\n            → Step 12: memo[remaining] = best // 記錄此剩餘狀態的最佳價格\n            → Step 13: Return best // 回傳計算出的最低價格\n→ Step 14: 呼叫 result = dfs(needs) // 從原始需求開始遞迴\n→ Step 15: Output result // 顯示最低花費\nEnd // 程式執行結束"
    },
    {
      "title": "ZigZag Conversion",
      "source_file": "Leetcode/leetcode6.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu5ir73jt.py\", line 36, in <module>\n    main()\n  File \"/tmp/tmpu5ir73jt.py\", line 25, in main\n    s_match = re.search(r\"(?<=s\\s*=\\s*)'([^']*)'\", data)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 177, in search\n    return _compile(pattern, flags).search(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 307, in _compile\n    p = _compiler.compile(pattern, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 749, in compile\n    code = _code(p, flags)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 582, in _code\n    _compile(code, p.data, flags)\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 155, in _compile\n    raise error(\"look-behind requires fixed-width pattern\")\nre.error: look-behind requires fixed-width pattern"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        # 如果行數為 1 或不小於字串長度，直接回傳原字串\n        if numRows == 1 or numRows >= len(s):\n            return s\n        # 建立每一行的儲存字串\n        rows = [''] * numRows\n        index, step = 0, 1\n        for c in s:\n            rows[index] += c\n            # 到達頂部或底部時反轉方向\n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n        return ''.join(rows)\n\ndef main():\n    data = sys.stdin.read()\n    # 解析輸入格式：s = '字串', numRows = 整數\n    s_match = re.search(r\"(?<=s\\s*=\\s*)'([^']*)'\", data)\n    n_match = re.search(r\"(?<=numRows\\s*=\\s*)\\d+\", data)\n    if not s_match or not n_match:\n        # 如果解析失敗，直接結束\n        return\n    s = s_match.group(1)\n    numRows = int(n_match.group(0))\n    result = Solution().convert(s, numRows)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for converting a string to zigzag pattern and read line by line. This is similar to Leetcode \"ZigZag Conversion\". We need to generate virtual code line by line with explanations. Use virtual arrows and decisions.\n\nWe need to follow format: each line: `虛擬碼步驟 // 解釋`. Use Start, Decision, etc.\n\nWe should produce algorithm: Input string s, numRows. If numRows <=1 or numRows >= length: return s. Initialize array of strings for rows. Iterate over characters, maintain current row and direction. Append char to current row. If reach top or bottom change direction. After loop, concatenate rows. Return result.\n\nLet's produce line by line with decisions.\n\nWe need to ensure each line has the format: \"Start // 程式開始執行\" etc.\n\nWe'll produce steps:\n\nStart\n→ Input s, numRows // get input string and number of rows\n→ Decision: 如果 numRows <= 1 或 numRows >= s.length() ? // check trivial cases\n    Yes → Output s // return original string // 因為不需要轉換\n    No  → Decision: 初始化 rows 為 numRows 個空字串 // prepare rows array\n        Yes -> (initialize)\n← Actually we can't have nested Decision inside Yes. We'll just do normal steps: Initialize rows array, set currentRow=0, direction=1\n→ Loop: 對於每個字符 c in s\n    → Append c 到 rows[currentRow] // add char to current row\n    → Decision: 如果 currentRow==0 或 currentRow==numRows-1 ?\n        Yes → direction = -direction // change direction\n        No  →\n    → currentRow += direction // move to next row\n→ After loop, concatenate all rows into result\n→ Output result\nEnd\n\nAdd arrow for Decision branches. We need proper indentation and arrow.\n\nLet's craft.\n\nWe must use \"→ Decision:\" lines with Yes → and No →. Each line must be one virtual code step plus comment.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s, numRows // 取得輸入字串與行數  \n→ Decision: 如果 numRows <= 1 或 numRows >= s.length()? // 判斷是否需要轉換  \n    Yes → Output s // 直接回傳原始字串，無需轉換  \n    No  →  \n        → Initialize rows[numRows] 為空字串 // 為每一行建立空字串  \n        → Set currentRow = 0 // 目前所在行號  \n        → Set direction = 1 // 初始方向向下  \n        → Loop: 對於每個字符 c in s // 遍歷字串  \n            → Append c 到 rows[currentRow] // 把字符放到目前行  \n            → Decision: 如果 currentRow == 0 或 currentRow == numRows - 1? // 判斷是否到達頂/底  \n                Yes → Set direction = -direction // 反轉方向  \n                No  →  \n            → Set currentRow = currentRow + direction // 移動到下一行  \n        → End Loop // 迴圈結束  \n        → Concatenate all rows into result // 把各行連接起來  \n        → Output result // 回傳最終結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Parenthesis String",
      "source_file": "Leetcode/leetcode678.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(*)\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "s = \"(*))\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def checkValidString(self, s: str) -> bool:\n        \"\"\"檢查字符串是否有效。\"\"\"\n        low, high = 0, 0          # 分別表示最小和最大未匹配的 '(' 數量\n        for ch in s:\n            if ch == '(':\n                low += 1\n                high += 1\n            elif ch == ')':\n                low -= 1\n                high -= 1\n            else:  # '*'\n                low -= 1\n                high += 1\n            if high < 0:          # 最大未匹配數為負，無法匹配\n                return False\n        return low == 0           # 最小未匹配數為0則可匹配\n\ndef parse_input(data: str) -> str:\n    \"\"\"從輸入資料中抽取字符串，支援 's = \"...\"' 或直接給出字符串。\"\"\"\n    # 先嘗試尋找雙引號或單引號包圍的內容\n    match = re.search(r'[\"\\'](.*)[\"\\']', data)\n    if match:\n        return match.group(1)\n    # 若找不到引號，直接返回去除空白的整個輸入\n    return data.strip()\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    result = Solution().checkValidString(s)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for validating string with * as wildcard. Classic algorithm: keep lower and upper bound of possible open parentheses count. Iterate. For each char: if '(', increment lower and upper. If ')', decrement lower and upper. If '*', lower-- (treat as ')'), upper++ (treat as '('). Ensure upper never negative. After loop, if lower <= 0 return true else false.\n\nWe need to produce step-by-step with arrows. Should be clear. Let's write pseudocode lines.\n\nStart // 程式開始\n\n→ Step 1: 初始化 lower = 0, upper = 0 // open count bounds\n\n→ Step 2: 遍歷字符串 s 的每個字符 c // 逐字符處理\n\n→ Decision: 如果 c == '('? // 判斷左括號\n\n  Yes → Step 3a: lower += 1, upper += 1 // 左括號增加\n\n  No → Decision: 如果 c == ')'?\n\n   Yes → Step 3b: lower -= 1, upper -= 1 // 右括號減少\n\n   No → Decision: 如果 c == '*'?\n\n    Yes → Step 3c: lower -= 1, upper += 1 // '*' 可視為 ')' 或 '('\n\n    No → Step 3d: // 無其他字符，忽略\n\n→ Decision: upper < 0? // 若 upper 為負\n\n  Yes → Step 4: return False // 不可能匹配\n\n  No → Step 5: // 继续\n\n→ Step 6: 在循环结束后，adjust lower: if lower < 0 then lower = 0 // 负数视为0\n\n→ Decision: lower == 0? // 若最小可能开放数为0\n\n  Yes → Step 7: return True // 有匹配方案\n\n  No → Step 8: return False // 无匹配\n\nEnd // 程式結束\n\nBut need each line with virtual code and comment. Ensure format: each line: virtual code step [space] // explanation.\n\nUse arrow → for steps and decisions. Also Use indentation for decisions.\n\nMake sure to include Start and End.\n\nAlso need to mention Step numbering maybe. Provide step names. Should be fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: lower = 0, upper = 0 // 初始化最小與最大開啟括號數  \n→ Step 2: for each character c in s // 逐字符遍歷  \n  Decision: c == '('? // 判斷是否為左括號  \n   Yes → Step 3a: lower += 1, upper += 1 // 左括號同時增加兩個界限  \n   No → Decision: c == ')'? // 判斷是否為右括號  \n    Yes → Step 3b: lower -= 1, upper -= 1 // 右括號同時減少兩個界限  \n    No → Decision: c == '*'? // 判斷是否為星號  \n     Yes → Step 3c: lower -= 1, upper += 1 // 星號同時視作 ')'（-1）與 '('（+1）  \n     No → Step 3d: // 其它字符（若有）忽略  \n  Decision: upper < 0? // 若最大開啟數變為負，無法匹配  \n   Yes → Step 4: return False // 立即返回偽  \n   No → Step 5: // 繼續下一字符  \n→ Step 6: if lower < 0 then lower = 0 // 任何負值視為 0（星號可留空）  \n→ Decision: lower == 0? // 最終最小開啟數為 0 表示可匹配  \n  Yes → Step 7: return True // 有合法匹配  \n  No → Step 8: return False // 無合法匹配  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1,5,1,6,1,4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1,3,2,3,1,2]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef wiggle_sort(nums):\n    \"\"\"Reorder nums into wiggle sequence: nums[0] < nums[1] > nums[2] < nums[3] …\"\"\"\n    n = len(nums)\n    for i in range(n - 1):\n        if i % 2 == 0:\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            if nums[i] < nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums\n\ndef main():\n    data = sys.stdin.read()\n    # Extract the list part from input like \"nums = [1,5,1,1,6,4]\"\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        print(\"[]\")\n        return\n    nums = ast.literal_eval(match.group())\n    wiggle_sort(nums)\n    # Output without spaces to match sample format\n    print('[' + ','.join(map(str, nums)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for wiggle sort, typical solution: iterate through array, for each index i, if (i%2==0 && nums[i] > nums[i+1]) swap, else if (i%2==1 && nums[i] < nums[i+1]) swap. Provide steps line by line with comments. Use arrow syntax and decision. Need to start with Start. Include steps like Step 1: for i in 0..n-2: etc. Provide decision inside loop. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算陣列長度 n ← nums.length // 取得輸入陣列長度  \n→ Step 2: 從 i = 0 到 n-2 進行迴圈 // 逐個檢查相鄰兩個元素  \n  Decision: i 為偶數? // 判斷目前索引為偶數或奇數  \n   Yes → Decision: nums[i] > nums[i+1]? // 偶數位應為小於，若大於則需交換  \n    Yes → Step 3: 交換 nums[i] 與 nums[i+1] // 交換以滿足 nums[i] < nums[i+1]  \n    No  → No → // 兩個元素已符合條件，保持不變  \n   No  → Decision: nums[i] < nums[i+1]? // 奇數位應為大於，若小於則需交換  \n    Yes → Step 4: 交換 nums[i] 與 nums[i+1] // 交換以滿足 nums[i] > nums[i+1]  \n    No  → No → // 兩個元素已符合條件，保持不變  \nEnd // 程式執行結束，陣列已重新排序為波浪式排列"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"Last-in-first-out stack implemented with two queues.\"\"\"\n\n    def __init__(self):\n        self.q1 = deque()  # 主隊列，存放堆疊元素，頂部在前端\n        self.q2 = deque()  # 臨時隊列，用於調整順序\n\n    def push(self, x: int) -> None:\n        \"\"\"Push element x onto the stack.\"\"\"\n        self.q2.append(x)                # 把新元素先放入臨時隊列\n        while self.q1:                   # 把舊元素搬移到臨時隊列\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1  # 交換兩個隊列\n\n    def pop(self) -> int:\n        \"\"\"Remove and return the top element.\"\"\"\n        return self.q1.popleft()          # 前端即為堆疊頂部\n\n    def top(self) -> int:\n        \"\"\"Return the top element without removing it.\"\"\"\n        return self.q1[0]                 # 前端即為堆疊頂部\n\n    def empty(self) -> bool:\n        \"\"\"Return True if the stack is empty.\"\"\"\n        return not self.q1\n\ndef serialize(result):\n    \"\"\"Convert Python objects to the required string format.\"\"\"\n    parts = []\n    for v in result:\n        if v is None:\n            parts.append(\"null\")\n        elif isinstance(v, bool):\n            parts.append(\"true\" if v else \"false\")\n        else:\n            parts.append(str(v))\n    return \"[\" + \", \".join(parts) + \"]\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入拆成兩個列表：方法名稱與對應參數\n    try:\n        left, right = data.split(\"],\", 1)\n        left = left + \"]\"\n        right = \"[\" + right\n        ops = ast.literal_eval(left)\n        args = ast.literal_eval(right)\n    except Exception:\n        # 若格式不符合，直接退出\n        sys.exit()\n\n    stack = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            stack = MyStack()\n            outputs.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            outputs.append(None)\n        elif op == \"pop\":\n            outputs.append(stack.pop())\n        elif op == \"top\":\n            outputs.append(stack.top())\n        elif op == \"empty\":\n            outputs.append(stack.empty())\n        else:\n            # 忽略未知操作\n            outputs.append(None)\n\n    print(serialize(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with arrow and comments. Need to design LIFO stack using two queues. We will produce a design: Use queue1 as main storage; push operation will enqueue to q1, then move all elements from q2 to q1? Wait typical solution: Use two queues; push: enqueue to q2; then dequeue all from q1 to q2; swap names. So q1 always has stack order. Or alternative: pop operation can be expensive: use q1 for stack order, pop: dequeue all but last and enqueue back. But we can choose either. Provide virtual code accordingly.\n\nDefine MyStack class with two queues: q1, q2. Methods: push, pop, top, empty.\n\nImplement:\n\nStart: MyStack constructor: initialize q1, q2 empty.\n\npush(x):\n    → Step: Enqueue x into q2\n    → Step: While q1 not empty: Dequeue from q1 and enqueue to q2\n    → Step: Swap q1 and q2 // now q1 holds all elements in correct order\n\npop():\n    → Step: If q1 empty: return error? But we assume not called\n    → Step: Dequeue front from q1 and return it // this is top\n\ntop():\n    → Step: If q1 empty: return error\n    → Step: Peek front of q1 and return it\n\nempty():\n    → Step: Return whether q1 is empty\n\nBut need to show only standard queue ops: push to back (enqueue), pop front, peek front, size, isEmpty.\n\nSo we can use queue's operations: q1.enqueue, q1.dequeue, q1.peek, q1.isEmpty.\n\nWe need to output each line: `虛擬碼步驟 // 解釋`. Use arrow and indent.\n\nWe'll produce like:\n\nStart // 程式開始執行\n\n→ Step 1: 建立 MyStack // 初始化兩個 queue\n\nBut we need to show entire class, but we will just produce conceptual steps for methods.\n\nBetter to produce a flowchart style. For each method, show steps.\n\nSo we produce:\n\nStart // 程式開始\n\n→ Step 1: MyStack() // 建立空的兩個 queue q1, q2\n\n→ Step 2: push(x) // 將元素 x 放入堆疊\n    → 2.1: Enqueue x into q2 // 把新元素先放進臨時 queue\n    → 2.2: While q1 not empty: dequeue from q1 and enqueue into q2 // 把舊元素搬到臨時 queue，保證順序\n    → 2.3: Swap references of q1 and q2 // 讓 q1 成為新的主 queue，q2 變成空\n    → 2.4: End // push 完成\n\n→ Step 3: pop() // 移除並返回堆疊頂部\n    → 3.1: If q1 is empty: return error // 保證不非法 pop\n    → 3.2: Dequeue front from q1 and return it // 前端即為頂部元素\n    → 3.3: End\n\n→ Step 4: top() // 取得堆疊頂部而不移除\n    → 4.1: If q1 is empty: return error\n    → 4.2: Peek front of q1 and return it // 前端即為頂部元素\n    → 4.3: End\n\n→ Step 5: empty() // 判斷堆疊是否為空\n    → 5.1: Return q1.isEmpty() // 直接檢查主 queue 是否空\n    → 5.2: End\n\nEnd // 程式結束\n\nBut we need to use arrow notation: `→ Step`. We should indent decisions.\n\nWe might include decisions like `Decision: if q1 empty?`.\n\nWe'll produce final answer accordingly.\n\nLet's write it line by line.\n\nAlso need to maintain order: Start, then each step. Use arrow and decisions.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: MyStack() // 建立 MyStack，初始化兩個空 queue q1 與 q2  \n→ Step 2: push(x) // 將元素 x 放入堆疊  \n  → 2.1: Enqueue x into q2 // 把新元素先放入臨時 queue q2  \n  → 2.2: While q1 not empty? // 判斷主 queue 是否仍有舊元素  \n    Yes → 2.2.1: Dequeue front from q1 and enqueue into q2 // 依序搬移舊元素，保持順序  \n    No  → 2.2.2: End // q1 已空，搬移結束  \n  → 2.3: Swap q1 and q2 // 令 q1 成為新的主 queue，q2 重新變成空  \n  → 2.4: End // push 完成  \n→ Step 3: pop() // 移除並返回堆疊頂部元素  \n  → 3.1: If q1 is empty? // 檢查是否非法 pop  \n    Yes → 3.1.1: Return error // 或拋出例外  \n    No  → 3.1.2: End  \n  → 3.2: Dequeue front from q1 and return it // 前端即為堆疊頂部  \n  → 3.3: End // pop 完成  \n→ Step 4: top() // 取得堆疊頂部元素但不移除  \n  → 4.1: If q1 is empty? // 檢查是否非法 top  \n    Yes → 4.1.1: Return error  \n    No  → 4.1.2: End  \n  → 4.2: Peek front of q1 and return it // 前端即為頂部  \n  → 4.3: End // top 完成  \n→ Step 5: empty() // 判斷堆疊是否為空  \n  → 5.1: Return q1.isEmpty() // 直接檢查主 queue 是否空  \n  → 5.2: End // empty 完成  \nEnd // 程式結束執行"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz2u_i5wj.py\", line 41, in <module>\n    data = eval(raw_input, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'numCourses' is not defined"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj77y5o01.py\", line 41, in <module>\n    data = eval(raw_input, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'numCourses' is not defined"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy1webj7k.py\", line 41, in <module>\n    data = eval(raw_input, {}, {})\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'numCourses' is not defined"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"使用 Kahn 演算法做拓撲排序。\"\"\"\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 建立圖與入度計算\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 將所有入度為 0 的節點加入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 演算法\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若有環，order 長度會小於 numCourses\n        return order if len(order) == numCourses else []\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，去除換行與多餘空格\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將「=」改成「:」並包裝成字典字面量再 eval\n    # 這樣可以安全地解析「numCourses = 2, prerequisites = [[1,0]]」等字串\n    raw_input = raw_input.replace('=', ':')\n    raw_input = ' {' + raw_input + ' }'\n    data = eval(raw_input, {}, {})\n\n    numCourses = data['numCourses']\n    prerequisites = data['prerequisites']\n\n    sol = Solution()\n    result = sol.findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving course schedule problem. Provide steps: topological sort via Kahn or DFS. Use BFS Kahn. We'll produce steps accordingly.\n\nMake sure each line: 虛擬碼步驟 + space + // explanation.\n\nUse arrows →, Decision: etc.\n\nLet's produce lines: Start, initialize adjacency list, indegree array, queue, etc.\n\nAlso handle cycle detection. End.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 adjacency list 與 indegree 陣列，長度為 numCourses // 為每門課建立鄰接清單及入度計數  \n→ Step 2: 對每對 [a, b] 在 prerequisites 裡  \n  → Step 2.1: adjacency[b].append(a) // b 必須先修，將 a 加到 b 的鄰接列表  \n  → Step 2.2: indegree[a] += 1 // a 的入度加 1  \n→ Step 3: 建立空 Queue，並將所有 indegree 為 0 的課程加入 Queue // 這些課程沒有前置課，先可修  \n→ Step 4: 初始化 result 為空陣列 // 用來存儲修課順序  \n→ Decision: Queue 是否非空? // 檢查是否還有可修的課程  \n  Yes → Step 5: 從 Queue 取出一門課 current  \n    → Step 5.1: result.append(current) // 加入修課順序  \n    → Step 5.2: 對於 adjacency[current] 裡的每門課 neighbour  \n      → Step 5.2.1: indegree[neighbour] -= 1 // 完成 current 後，neighbour 的入度減 1  \n      → Step 5.2.2: 如果 indegree[neighbour] == 0  \n        → Step 5.2.3: Queue.append(neighbour) // 現在 neighbour 可以修  \n    → Step 5.3: 回到 Decision: Queue 是否非空? // 迴圈直到 Queue 空  \n  No  → End // 無更多課程可修，結束循環  \n→ Decision: result 的長度等於 numCourses? // 判斷是否成功修完所有課程  \n  Yes → Return result // 有效順序已經完成  \n  No  → Return 空陣列 // 形成環，無法完成所有課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "source_file": "Leetcode/leetcode4.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2.00000'\nGot (Norm):      '3.00000'\n--- (Raw) ---\nRaw Expected: '2.00000'\nRaw Got:      '3.00000'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        # Handle cases where one array is empty\n        if not nums1:\n            n = len(nums2)\n            if n % 2 == 1:\n                return float(nums2[n // 2])\n            return (nums2[n // 2 - 1] + nums2[n // 2]) / 2.0\n        if not nums2:\n            m = len(nums1)\n            if m % 2 == 1:\n                return float(nums1[m // 2])\n            return (nums1[m // 2 - 1] + nums1[m // 2]) / 2.0\n\n        # Ensure nums1 is the shorter array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        total = m + n\n        half = (total + 1) // 2\n\n        low, high = 0, m\n        while low <= high:\n            mid1 = (low + high) // 2\n            mid2 = half - mid1\n\n            Aleft = nums1[mid1 - 1] if mid1 > 0 else float('-inf')\n            Aright = nums1[mid1] if mid1 < m else float('inf')\n            Bleft = nums2[mid2 - 1] if mid2 > 0 else float('-inf')\n            Bright = nums2[mid2] if mid2 < n else float('inf')\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2 == 1:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0\n            elif Aleft > Bright:\n                high = mid1 - 1\n            else:\n                low = mid1 + 1\n\ndef parse_input(text):\n    # Extract the two list expressions\n    lists = re.findall(r'\\[([^\\]]*)\\]', text)\n    if len(lists) != 2:\n        return [], []\n\n    def to_int_list(s):\n        s = s.strip()\n        if not s:\n            return []\n        return list(map(int, s.split(',')))\n\n    nums1 = to_int_list(lists[0])\n    nums2 = to_int_list(lists[1])\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. We must design algorithm for median of two sorted arrays in O(log(m+n)). Classic solution: binary search partition. We'll produce high-level pseudo steps. Let's output step-by-step with decision structure. Include Start, End. Each line: Virtual code step [space] // explanation.\n\nWe need to output line-by-line steps. Use arrows.\n\nLet's design:\n\nStart\n→ Determine total length tot = m + n\n→ Determine half = (tot + 1) / 2\n→ Ensure nums1 is the shorter array\n→ Binary search low=0, high=m\nLoop:\n    → Decision: low <= high?\n        Yes → mid1 = (low + high) / 2\n        → mid2 = half - mid1\n        → Decision: mid1 < m and nums2[mid2-1] > nums1[mid1]?\n            Yes → low = mid1 + 1 // shift right\n            No → Decision: mid1 > 0 and nums1[mid1-1] > nums2[mid2]?\n                Yes → high = mid1 - 1 // shift left\n                No → Partition correct found\n                    → Determine maxLeft:\n                        Decision: mid1 == 0? nums2[mid2-1]\n                        else if mid2 == 0? nums1[mid1-1]\n                        else max(nums1[mid1-1], nums2[mid2-1])\n                    → Decision: tot % 2 == 1?\n                        Yes → Return maxLeft\n                        No → Determine minRight:\n                            Decision: mid1 == m? nums2[mid2]\n                            else if mid2 == n? nums1[mid1]\n                            else min(nums1[mid1], nums2[mid2])\n                        → Return (maxLeft + minRight)/2.0\n        No → End loop (should not happen)\nEnd\n\nNeed to format each line with arrow. Let's produce lines exactly.\n\nImportant: each line includes virtual code and explanation. Use `→` for steps inside start. Indent decisions maybe with spaces? The example uses indentation. We'll replicate.\n\nEnsure no real code. Use placeholders like `Step X`. We must use `[空格]` after each virtual code. Use `//` comments. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 確定總長度 tot ← m + n // 計算兩個陣列總元素數  \n→ Step 2: 計算分割點 half ← (tot + 1) / 2 // 半數，用於二分搜尋  \n→ Step 3: 若 m > n，交換 nums1、nums2 與 m、n // 保證 nums1 為較短陣列  \n→ Step 4: 初始化 low ← 0, high ← m // 設定二分搜尋範圍  \n→ Decision: low ≤ high? // 判斷是否還有搜尋空間  \n    Yes → Step 5: mid1 ← (low + high) / 2 // nums1 的分割索引  \n    → Step 6: mid2 ← half - mid1 // 使兩邊分割數量相等  \n    → Decision: mid1 < m 且 nums2[mid2-1] > nums1[mid1]? // 需要向右移動分割點  \n        Yes → Step 7: low ← mid1 + 1 // 右移搜尋範圍  \n        No → Decision: mid1 > 0 且 nums1[mid1-1] > nums2[mid2]? // 需要向左移動分割點  \n            Yes → Step 8: high ← mid1 - 1 // 左移搜尋範圍  \n            No → Step 9: // 找到正確分割點  \n                → Step 10: maxLeft ←  \n                    Decision: mid1 == 0? nums2[mid2-1]  \n                        Yes → nums2[mid2-1] // nums1 沒有左邊元素  \n                        No → Decision: mid2 == 0? nums1[mid1-1]  \n                            Yes → nums1[mid1-1] // nums2 沒有左邊元素  \n                            No → max(nums1[mid1-1], nums2[mid2-1]) // 取兩邊左側最大值  \n                → Decision: tot % 2 == 1? // 總長度奇數  \n                    Yes → Step 11: Return maxLeft // 中位數即左側最大值  \n                    No → Step 12: minRight ←  \n                        Decision: mid1 == m? nums2[mid2]  \n                            Yes → nums2[mid2] // nums1 沒有右邊元素  \n                            No → Decision: mid2 == n? nums1[mid1]  \n                                Yes → nums1[mid1] // nums2 沒有右邊元素  \n                                No → min(nums1[mid1], nums2[mid2]) // 取兩邊右側最小值  \n                        → Step 13: Return (maxLeft + minRight) / 2.0 // 總長度偶數時平均兩邊中值  \n    No → End // 雖不會發生，結束搜尋  \nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        \"\"\"\n        Merge accounts that share at least one common email.\n        Uses a Union‑Find structure to connect all emails belonging to the same person.\n        \"\"\"\n        parent = {}  # email -> parent email\n\n        def find(x):\n            \"\"\"Path‑compressed find.\"\"\"\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}  # email -> owner's name\n\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            # Initialize the parent for first email if not seen\n            parent.setdefault(first_email, first_email)\n            email_to_name[first_email] = name\n\n            for email in acc[2:]:\n                parent.setdefault(email, email)\n                email_to_name[email] = name\n                # Union first_email and email\n                root1 = find(first_email)\n                root2 = find(email)\n                if root1 != root2:\n                    parent[root2] = root1\n\n        # Group emails by their root parent\n        root_to_emails = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            root_to_emails[root].append(email)\n\n        # Build result list\n        merged_accounts = []\n        for root, emails in root_to_emails.items():\n            merged_accounts.append([email_to_name[root]] + sorted(emails))\n        return merged_accounts\n\ndef main():\n    \"\"\"\n    Read the input from stdin, parse it into a list of accounts,\n    perform the merge, and print the result to stdout.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Remove possible leading variable assignment\n    if '=' in data:\n        _, data = data.split('=', 1)\n        data = data.strip()\n\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        return\n\n    solution = Solution()\n    result = solution.accountsMerge(accounts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. For merging accounts with emails. Steps: build email to name mapping, graph union-find or adjacency. We'll use union-find. Steps: iterate accounts, for each email connect to first email of account. Union operation. After processing, group emails by root. Then produce output list sorted emails and prepend name.\n\nLet's craft virtual code lines accordingly.\n\nWe need arrow formatting: Use \"Start\", \"End\", \"Decision:\" etc.\n\nWe'll include loops, union operations. Provide explanations.\n\nLet's produce step-by-step.\n\nWe'll define functions: UnionFind initialization with parent dict. Methods: find, union.\n\nAlso maintain email_to_name dict.\n\nProcess accounts.\n\nAfter grouping, produce output.\n\nOk produce lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 UnionFind 結構 // 建立父層關係儲存每個 email\n→ Step 2: 初始化 email_to_name 映射 // 將每個 email 與對應姓名關聯\n→ Step 3: 遍歷 accounts，為每個帳號處理\n    → Decision: 是否為第一個帳號? // 取出名稱並對第一封信建立映射\n        Yes → Step 4: name = accounts[i][0] // 取得帳號擁有者姓名\n        No  → // 其餘帳號已在 Step 4 處理\n    → Step 5: 取得 first_email = accounts[i][1] // 取帳號第一封信\n    → Step 6: 將 first_email 設為 root（如果尚未存在）\n    → Step 7: 遍歷 accounts[i] 從第 2 封信開始\n        → Step 8: 對每封信 email 進行\n            → Step 9: 將 email 設為 root（如果尚未存在）\n            → Step 10: union(first_email, email) // 將此帳號內所有信件歸為同一組\n→ Step 11: 建立 root_to_emails 的映射\n    → Step 12: 對於每個 email in email_to_name\n        → Step 13: 找到 root = find(email)\n        → Step 14: 如果 root 不在 root_to_emails，則新增空列表\n        → Step 15: append email 到 root_to_emails[root]\n→ Step 16: 建立結果列表 results\n    → Step 17: 對於每個 root in root_to_emails\n        → Step 18: 取得 emails = root_to_emails[root] 並排序\n        → Step 19: 取得 name = email_to_name[root] // 取任一 email 的姓名\n        → Step 20: 建立 account = [name] + emails\n        → Step 21: append account 到 results\n→ End // 程式執行結束（返回 results）"
    },
    {
      "title": "Search in Rotated Sorted Array II",
      "source_file": "Leetcode/leetcode81.json",
      "problem_index_in_file": 0,
      "generation_error": "Failed to extract code from model response.",
      "failed_validation_details": [
        {
          "example_index": -1,
          "input": null,
          "expected_output": null,
          "actual_output_or_error": "We need to output python code that solves problem. The first part: \"請根據上述需求生成包含 main 區塊且能通過上述範例測試的完整程式碼.\" The earlier part with \"You must output a python code block only, no explanation.\" So final output: only python code inside triple backticks. We must parse input from stdin: format like 'nums = [2,5,6,0,0,1,2], target = 0'. We need to parse into nums list and target int. We'll read entire stdin string; we can use eval? The input string may be like 'nums = [2,5,6,0,0,1,2], target = 0'. We'll parse by splitting on ',' maybe. Approach: read line from sys.stdin.read().strip(); then use regex to extract list and target. Eg pattern r'nums\\s*=\\s*(\\[.*\\]),?\\s*target\\s*=\\s*(-?\\d+)' . Use re to find. Evaluate list via ast.literal_eval.\n\nReturn 'true' or 'false' lowercase.\n\nImplement class Solution with method search same as reference.\n\nIn main: read from sys.stdin.read() or input(); we could use sys.stdin.read() because there may be newline. We'll parse accordingly.\n\nEdge cases: If input may include newlines? We'll robustly use re.\n\nLet's produce code."
        }
      ],
      "generated_code": null,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for searching in rotated sorted array with duplicates. Use binary search with handling duplicates. Provide step by step with comments. Each line with virtual code + comment.\n\nLet's outline algorithm:\n\nStart\n→ Input nums, target\n→ l = 0, r = len(nums)-1\n→ While l <= r\n   mid = (l+r)//2\n   If nums[mid] == target → return true\n   // If left side is sorted\n   If nums[l] < nums[mid]\n      // target in left sorted part?\n      If nums[l] <= target < nums[mid] → r = mid-1 else l = mid+1\n   Else if nums[l] > nums[mid]\n      // right side sorted\n      If nums[mid] < target <= nums[r] → l = mid+1 else r = mid-1\n   Else // nums[l] == nums[mid], duplicate, skip\n      l += 1\nEnd → return false\n\nAlso need to consider cases where l==mid etc. Provide virtual code lines.\n\nWe produce each line. Use \"Step X\" maybe. Use arrow.\n\nLet's format.\n\nStart\n→ Input: nums, target\n→ l ← 0\n→ r ← len(nums)-1\n→ Decision: l <= r? // Loop condition\n    Yes →\n        → mid ← (l + r) // 2\n        → Decision: nums[mid] == target? // Check if found\n            Yes → Step: return true\n            No →\n                → Decision: nums[l] < nums[mid]? // left sorted\n                    Yes →\n                        → Decision: nums[l] <= target < nums[mid]? // target in left part\n                            Yes → r ← mid - 1\n                            No  → l ← mid + 1\n                    No →\n                        → Decision: nums[l] > nums[mid]? // right sorted\n                            Yes →\n                                → Decision: nums[mid] < target <= nums[r]? // target in right part\n                                    Yes → l ← mid + 1\n                                    No  → r ← mid - 1\n                            No →\n                                → Step: l ← l + 1 // nums[l]==nums[mid], skip duplicate\n                → Loop back to Decision: l <= r?\n    No → End // exit loop\n→ Step: return false\n\nWe need to use \"Decision:\" and \"Yes →\", \"No →\". Provide comments.\n\nLet's output lines exactly as requested. Ensure each line has virtual code + comment separated by space. Use arrow '→'.\n\nAlso ensure \"Start\" and \"End\". Provide comments.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums, target // 接收旋轉後的陣列與目標值  \n→ l ← 0 // 左指標初始化  \n→ r ← len(nums)-1 // 右指標初始化  \n→ Decision: l <= r? // 判斷是否仍有搜尋範圍  \n Yes →  \n  → mid ← (l + r) // 2 // 計算中間索引  \n  → Decision: nums[mid] == target? // 檢查中間值是否為目標  \n   Yes → return true // 找到目標，立即返回  \n   No →  \n    → Decision: nums[l] < nums[mid]? // 左半段是否為升序排列  \n     Yes →  \n      → Decision: nums[l] <= target < nums[mid]? // 目標是否位於左升序段  \n       Yes → r ← mid - 1 // 調整右指標至左段  \n       No  → l ← mid + 1 // 調整左指標至右段  \n         // 這樣能保持搜尋在正確的區間  \n      No →  \n       → Decision: nums[l] > nums[mid]? // 右半段是否為升序排列  \n        Yes →  \n         → Decision: nums[mid] < target <= nums[r]? // 目標是否位於右升序段  \n          Yes → l ← mid + 1 // 調整左指標至右段  \n          No  → r ← mid - 1 // 調整右指標至左段  \n            // 這樣能保持搜尋在正確的區間  \n        No →  \n         → l ← l + 1 // nums[l] == nums[mid]，跳過重複元素  \n         // 避免因重複導致無法判斷哪段升序  \n         // 移動左指標以縮小搜尋範圍  \n         // 迴圈會自動回到條件判斷  \n         // 直到 l > r 或找到目標  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n         //  \n          Barbie."
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,4,1,4,1,0,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 4, 1, 4, 1, 0, 0]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        \"\"\"\n        建構子：將黑名單映射到可用白名單，並記錄有效區間長度。\n        \"\"\"\n        self.size = n - len(blacklist)          # 可用數字個數\n        black = set(blacklist)                  # 快速查詢黑名單\n        last = n - 1\n        self.mapping = {}                       # 黑名單 < size 時的映射\n\n        for b in blacklist:\n            if b < self.size:                  # 只需處理小於 size 的黑名單\n                while last in black:           # 找到最後一個不在黑名單的數字\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        \"\"\"\n        隨機抽取一個不在黑名單的數字。\n        \"\"\"\n        idx = random.randint(0, self.size - 1)   # 隨機取索引\n        return self.mapping.get(idx, idx)        # 若有映射則使用映射值，否則直接返回索引\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取兩行資料\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        sys.exit()\n\n    # 解析命令與對應參數\n    commands = json.loads(lines[0])\n    args_list = json.loads(lines[1])\n\n    result = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 建構子，args 為 [n, blacklist]\n            n, blacklist = args\n            obj = Solution(n, blacklist)\n            result.append(None)                # 產生 null\n        else:\n            # 目前只有 pick 方法\n            if cmd == \"pick\":\n                res = obj.pick()\n                result.append(res)\n            else:\n                # 如有其他方法可使用 getattr\n                method = getattr(obj, cmd)\n                res = method(*args)\n                result.append(res)\n\n    # 輸出結果，使用 json.dumps 以得到 null 而非 None\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need produce virtual code algorithm: classic white-list mapping using hash map from blacklisted indices in [0, m-1] to valid values in [n-m, n-1] that are not blacklisted. Steps: init: compute m=blacklist length, create set of blacklisted in [0, n-m-1], also compute set of available white values in [n-m, n-1] that are not blacklisted. Map each blacklisted in [0, n-m-1] to next available white. pick: generate random k in [0, n-m-1], if k in map, return map[k] else k.\n\nNeed produce virtual code line by line with explanation. Include Start, End, Decision, etc. Use arrows. No actual code. Provide step by step.\n\nLet's craft.\n\nStart\n→ Step 1: Input n, blacklist // 初始化 n 與黑名單\n→ Step 2: Set m = size(blacklist) // 黑名單長度\n→ Step 3: Define whiteRangeEnd = n - m // 白名單起始點\n→ Step 4: Initialize empty set blackSet // 用於快速判斷黑名單\n    → Decision: 若需要可選擇將所有 blacklist 加入 blackSet? Actually we need blackSet for values >= whiteRangeEnd. But easier: create blackSet for all blacklist values\n        Yes → For each x in blacklist: add x to blackSet\n→ Step 5: Initialize empty queue freeWhite // 存放可用白名單\n    → Decision: 檢查白名單區間 [whiteRangeEnd, n-1] 中哪些不在黑名單\n        Yes → For i from whiteRangeEnd to n-1:\n                If i not in blackSet: enqueue freeWhite\n→ Step 6: Initialize empty map remap // 將黑名單前半段映射到白名單\n    → Decision: For each b in blacklist:\n                If b < whiteRangeEnd:\n                    val = dequeue freeWhite\n                    remap[b] = val\n→ Step 7: Store m, whiteRangeEnd, remap // 以備 pick 使用\nEnd // 初始化完成\n\nThen pick:\n\nStart // pick 執行\n→ Step 1: Generate randIndex = randomInt(0, whiteRangeEnd-1) // 隨機選取 [0, n-m-1]\n→ Step 2: If randIndex in remap:\n        Yes → Return remap[randIndex] // 替換為白名單對應值\n        No  → Return randIndex // 直接返回\nEnd // pick 結束\n\nWe need virtual code lines. Let's produce more compact but still step by step.\n\nWe should include arrows and indentation.\n\nUse format:\n\nStart // 程式開始\n→ Step 1: Input n, blacklist // ...\n… etc.\n\nWe must include decisions and Yes/No branches.\n\nLet's write.\n\nWe may include loops as steps. Since loops are part of steps.\n\nOk produce final answer.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: Input n, blacklist // 接收整數 n 與黑名單陣列\n→ Step 2: Set m = size(blacklist) // 黑名單長度\n→ Step 3: Set whiteRangeEnd = n - m // 白名單區間的起始點 (白名單長度)\n→ Step 4: Initialize empty set blackSet // 用來快速判斷哪些數是黑名單\n    → Decision: 將所有 blacklist 加入 blackSet\n        Yes → For each x in blacklist: add x to blackSet\n→ Step 5: Initialize empty queue freeWhite // 儲存可用白名單值\n    → Decision: Scan區間 [whiteRangeEnd, n-1]\n        Yes → For i from whiteRangeEnd to n-1:\n                If i not in blackSet: enqueue freeWhite\n→ Step 6: Initialize empty map remap // 將前半段黑名單映射到白名單\n    → Decision: 對每個 b in blacklist\n        Yes → If b < whiteRangeEnd:\n                val = dequeue freeWhite\n                remap[b] = val\n→ Step 7: Store m, whiteRangeEnd, remap // 以備 pick 使用\nEnd // 初始化完成\n\n// ----------------- pick() -----------------\nStart // pick 執行\n→ Step 1: Generate randIndex = randomInt(0, whiteRangeEnd-1) // 隨機選取 [0, n-m-1]\n→ Step 2: Decision: 是否在 remap 中?\n    Yes → Return remap[randIndex] // 替換為白名單對應值\n    No  → Return randIndex // 直接返回\nEnd // pick 結束\n```"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0y8j_h3g.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmp0y8j_h3g.py\", line 40, in main\n    args_list = ast.literal_eval(lines[1])\n                                 ~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass TrieNode:\n    __slots__ = ('children', 'sum')\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.mapping = {}\n\n    def insert(self, key: str, val: int) -> None:\n        old = self.mapping.get(key, 0)\n        delta = val - old\n        self.mapping[key] = val\n        node = self.root\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main() -> None:\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not lines:\n        return\n    ops = ast.literal_eval(lines[0])\n    args_list = ast.literal_eval(lines[1])\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == 'MapSum':\n            obj = MapSum()\n            results.append(None)\n        elif op == 'insert':\n            obj.insert(*args)\n            results.append(None)\n        elif op == 'sum':\n            results.append(obj.sum(*args))\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. The user requests design a map that allows operations: map string key to value, return sum of values with keys with given prefix. Implement MapSum class with methods insert and sum. Provide virtual code, not actual code, just steps. Each line: virtual code step + space + // explanation. Use arrow notation: Start, Decision, etc. Provide structure.\n\nWe should provide algorithm: use Trie with sum at nodes. Or store dictionary of key to value and recompute sums. But efficient is Trie.\n\nWe need to produce steps: initialize root, maintain key-value map for updates, update sums along path when inserting or updating.\n\nVirtual code might be:\n\nStart\n→ Initialize MapSum // create root node, map for key-values\n→ Method insert(key,val) // etc\n\nBut must be line-by-line and include decisions.\n\nLet's produce a generic flow of operations: start class initialization, insert function steps, sum function steps.\n\nWe also need to cover decision: if key exists? override and adjust sums difference.\n\nWe can include internal procedure: update sums along trie path.\n\nSo we can produce something like:\n\nStart // 程式開始執行\n→ Create MapSum instance // 初始化 MapSum 物件\n    → Step: root ← new TrieNode() // 建立 Trie 根節點\n    → Step: dict ← empty map // 儲存 key → val 的映射\nEnd\n\nBut we need to show methods.\n\nBetter structure:\n\nDefine class MapSum\n    → Start // 程式開始\n    → Step: root ← TrieNode() // 初始化 Trie 根節點\n    → Step: map ← {} // key 到 val 的映射\n\nMethod insert(key,val)\n    → Decision: key exists in map?\n        Yes → old ← map[key] // 取得舊值\n        No → old ← 0\n    → delta ← val - old // 需要更新的差值\n    → Step: map[key] ← val // 更新映射\n    → Node ← root\n    → Loop each character c in key\n        → Decision: Node.children has c?\n            Yes → Node ← Node.children[c]\n            No → Node.children[c] ← new TrieNode()\n                → Node ← Node.children[c]\n        → Node.sum ← Node.sum + delta // 更新每個節點的總和\n\nMethod sum(prefix)\n    → Node ← root\n    → Loop each character c in prefix\n        → Decision: Node.children has c?\n            Yes → Node ← Node.children[c]\n            No → Return 0 // 前綴不存在\n    → Return Node.sum // 返回前綴對應的總和\n\nEnd\n\nWe need to format each line with arrow and explanation.\n\nWe must include \"→\" for next step, \"Decision:\" for decisions, \"Start\" and \"End\". Provide each step line.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Class MapSum: // 定義 MapSum 類別\n    → Start // MapSum 初始化\n    → Step: root ← TrieNode() // 建立 Trie 根節點\n    → Step: map ← {} // 建立 key→value 的映射表\n    → End // MapSum 初始化完成\n→ Method insert(key, val): // 插入或覆蓋 key 的值\n    → Decision: key exists in map? // 判斷 key 是否已存在\n        Yes → old ← map[key] // 取得舊值\n        No  → old ← 0 // 沒有舊值則為 0\n    → delta ← val - old // 計算需要加到每個節點的差值\n    → Step: map[key] ← val // 更新映射表\n    → Step: node ← root // 從根節點開始\n    → For each character c in key:\n        → Decision: node.children has c? // 判斷子節點是否存在\n            Yes → node ← node.children[c] // 移動到子節點\n            No  → node.children[c] ← new TrieNode() // 建立新節點\n                → node ← node.children[c] // 移動到新節點\n        → Step: node.sum ← node.sum + delta // 更新節點的總和\n    → End // insert 完成\n→ Method sum(prefix): // 取得前綴總和\n    → Step: node ← root // 從根節點開始\n    → For each character c in prefix:\n        → Decision: node.children has c? // 判斷子節點是否存在\n            Yes → node ← node.children[c] // 移動到子節點\n            No  → Return 0 // 前綴不存在，總和為 0\n    → Return node.sum // 返回前綴對應節點的總和\n→ End // MapSum 類別結束\n\nBut need to follow the arrow formatting exactly: `→` arrow and `Decision:` lines etc. Use spaces after each step. Should each step be separate line. Indentation may not be required, but can include for readability. However spec says each line must contain: `虛擬碼步驟` + space + `// 解釋/說明`. So each line should start with a step string; we can indent but it might break? Not sure but it's fine.\n\nBetter to remove indentation for clarity: each line starts with the step.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MapSum: // 定義 MapSum 類別  \n→ Start // MapSum 初始化  \n→ Step: root ← TrieNode() // 建立 Trie 根節點  \n→ Step: map ← {} // 建立 key→value 的映射表  \n→ End // MapSum 初始化完成  \n\n→ Method insert(key, val): // 插入或覆蓋 key 的值  \n→ Decision: key exists in map? // 判斷 key 是否已存在  \n  Yes → old ← map[key] // 取得舊值  \n  No  → old ← 0 // 沒有舊值則為 0  \n→ Step: delta ← val - old // 計算需要加到每個節點的差值  \n→ Step: map[key] ← val // 更新映射表  \n→ Step: node ← root // 從根節點開始  \n→ For each character c in key: // 逐字處理 key  \n  Decision: node.children has c? // 判斷子節點是否存在  \n   Yes → node ← node.children[c] // 移動到子節點  \n   No  → node.children[c] ← new TrieNode() // 建立新節點  \n    → node ← node.children[c] // 移動到新節點  \n  Step: node.sum ← node.sum + delta // 更新節點的總和  \n→ End // insert 完成  \n\n→ Method sum(prefix): // 取得前綴總和  \n→ Step: node ← root // 從根節點開始  \n→ For each character c in prefix: // 逐字處理前綴  \n  Decision: node.children has c? // 判斷子節點是否存在  \n   Yes → node ← node.children[c] // 移動到子節點  \n   No  → Return 0 // 前綴不存在，總和為 0  \n→ Return node.sum // 返回前綴對應節點的總和  \n→ End // MapSum 類別結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[None,[-0.3037421387514557,-0.5995203273034382],[-0.8406044099489014,-0.1312471741093314],[0.020038793976505896,-0.3452914608057318]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[None, [-0.3037421387514557, -0.5995203273034382], [-0.8406044099489014, -0.1312471741093314], [0.020038793976505896, -0.3452914608057318]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    # 讀取兩行輸入\n    line1 = sys.stdin.readline()\n    line2 = sys.stdin.readline()\n    # 解析 JSON 格式\n    commands = json.loads(line1.strip())\n    args_list = json.loads(line2.strip())\n\n    res = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            res.append(None)\n        elif cmd == \"randPoint\":\n            point = obj.randPoint()\n            res.append(point)\n        else:\n            res.append(None)  # 若有未知命令\n\n    print(res)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for class Solution with constructor and randPoint method. Steps include generating random polar coordinates, ensuring uniform distribution inside circle. Use radius and center. Steps: generate random r from sqrt(rand()) * radius, theta uniform [0,2π). Then compute x = center_x + r*cos(theta), y = center_y + r*sin(theta). Output array. We'll produce each line with \"虛擬碼步驟 // 解釋\". Use Start/End etc. Include class structure and method. Let's do:\n\nStart\n→ Define class Solution\n    → Step 1: Constructor with radius, x_center, y_center // store attributes\n    → Step 2: randPoint method\n        → Step 2.1: Generate random u1 in [0,1) // uniform\n        → Step 2.2: Generate random u2 in [0,1) // uniform\n        → Step 2.3: Compute r = sqrt(u1) * radius // radial distance\n        → Step 2.4: Compute theta = u2 * 2π // angle\n        → Step 2.5: Compute x = x_center + r * cos(theta) // point coordinates\n        → Step 2.6: Compute y = y_center + r * sin(theta)\n        → Step 2.7: Return [x, y] // point inside circle\nEnd\n\nAlso we need to show decision? maybe not. Provide step names. Let's format. Ensure each line has virtual code and comment. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class Solution // 定義 Solution 類別  \n    → Step 1: Constructor(radius, x_center, y_center) // 初始化圓半徑與中心座標  \n        → Store radius as self.radius // 以供後續使用  \n        → Store x_center as self.cx // 以備產生隨機點時使用  \n        → Store y_center as self.cy // 同上  \n    → Step 2: Method randPoint() // 產生均勻隨機點  \n        → Step 2.1: Generate u1 = random() in [0,1) // 第一個隨機數，後續用於計算半徑  \n        → Step 2.2: Generate u2 = random() in [0,1) // 第二個隨機數，後續用於計算角度  \n        → Step 2.3: Compute r = sqrt(u1) * self.radius // 半徑，利用 sqrt 保證均勻分布  \n        → Step 2.4: Compute theta = u2 * 2π // 角度，均勻分佈於 [0, 2π)  \n        → Step 2.5: Compute x = self.cx + r * cos(theta) // 轉換為座標 x  \n        → Step 2.6: Compute y = self.cy + r * sin(theta) // 轉換為座標 y  \n        → Step 2.7: Return [x, y] // 回傳隨機點  \nEnd // 程式執行結束"
    },
    {
      "title": "Guess Number Higher or Lower",
      "source_file": "Leetcode/leetcode374.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 10, pick = 6",
          "expected_output": "6",
          "actual_output_or_error": "File \"/tmp/tmpzfithjb3.py\", line 39\n    n, global pick_value = nums[0], nums[1]  # 取得 n 與 pick\n       ^^^^^^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "n = 1, pick = 1",
          "expected_output": "1",
          "actual_output_or_error": "File \"/tmp/tmpm7x1ecju.py\", line 39\n    n, global pick_value = nums[0], nums[1]  # 取得 n 與 pick\n       ^^^^^^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "n = 2, pick = 1",
          "expected_output": "1",
          "actual_output_or_error": "File \"/tmp/tmpjdx7qd90.py\", line 39\n    n, global pick_value = nums[0], nums[1]  # 取得 n 與 pick\n       ^^^^^^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 先把全域變數 pick 定義為 None，稍後再賦值\npick = None\n\ndef guess(num: int) -> int:\n    \"\"\"模擬猜數字 API，根據全域變數 pick 回傳結果。\"\"\"\n    global pick\n    if num > pick:\n        return -1  # 猜的數字太大\n    elif num < pick:\n        return 1   # 猜的數字太小\n    else:\n        return 0   # 猜對了\n\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        \"\"\"使用二分搜尋找出 pick。\"\"\"\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res < 0:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1  # 理論上不會到這裡\n\ndef main() -> None:\n    \"\"\"主程式：讀取輸入、執行演算法、輸出結果。\"\"\"\n    data = sys.stdin.read()\n    # 從輸入字串中擷取所有整數\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, global pick_value = nums[0], nums[1]  # 取得 n 與 pick\n\n    # 把 pick 設為全域變數供 guess() 使用\n    global pick\n    pick = pick_value\n\n    sol = Solution()\n    result = sol.guessNumber(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the \"Guess Number Higher or Lower\" problem. It's binary search. We output each line with explanation. Must not output actual code, just pseudocode with arrow notation. Use virtual code steps: Start, Decision, Step, End. Each line includes explanation after //.\n\nWe must not output real code. We'll produce lines like:\n\nStart // start\n→ Step 1: 初始化 low = 1, high = n // set bounds\n→ Decision: while low <= high? // loop condition\n    Yes → Step 2: mid = low + (high - low) / 2 // middle guess\n        → Step 3: result = guess(mid) // call API\n        → Decision: result == 0? // correct\n            Yes → Step 4: return mid // found\n            No  → Decision: result < 0? // too high\n                Yes → Step 5: high = mid - 1 // adjust high\n                No  → Step 6: low = mid + 1 // adjust low\n    No  → End // done\n\nBut must ensure correct arrow formatting: \"→\" for steps, \"Decision:\" for decisions. Each line with explanation.\n\nAlso we need \"Start\" and \"End\" lines. The line \"Decision:\" with nested lines indent? The format example shows indentation with spaces. We'll mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 low = 1, high = n // 設定搜尋區間的上下限\n→ Decision: low <= high? // 判斷搜尋區間是否還有可能存在答案\n    Yes → Step 2: mid = low + (high - low) / 2 // 計算區間中點作為猜測\n        → Step 3: result = guess(mid) // 呼叫 API 取得回覆\n        → Decision: result == 0? // 判斷是否猜對\n            Yes → Step 4: return mid // 成功，回傳答案\n            No  → Decision: result < 0? // 判斷猜的數字是否太大\n                Yes → Step 5: high = mid - 1 // 重新設定上限，排除 mid 及其以上數字\n                No  → Step 6: low = mid + 1 // 重新設定下限，排除 mid 及其以下數字\n    No  → End // 搜尋結束，無需繼續執行\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 原始陣列的複本\n        self.nums = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return self.nums\n\n    def shuffle(self):\n        # Fisher–Yates 洗牌\n        shuffled = list(self.nums)\n        n = len(shuffled)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先把輸入拆成兩個 JSON 陣列\n    first_part, second_part = data.split('],', 1)\n    first_part += ']'\n    if not second_part.strip().startswith('['):\n        second_part = '[' + second_part.strip()\n    methods = json.loads(first_part)\n    args_list = json.loads(second_part)\n\n    results = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(args[0])   # constructor 只傳第一個參數\n            results.append(None)\n        else:\n            res = getattr(obj, method)(*args)\n            results.append(res)\n\n    # 用 JSON 輸出，None 會轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations in Traditional Chinese. Virtual code should use arrow →, Yes →, No → etc. Steps: Start, End, Decision.\n\nDefine class Solution with constructor, reset, shuffle. Use array copy, Fisher-Yates shuffle. Let's craft pseudo-code line by line.\n\nNeed to keep each line separate. Use indentation for decision branches maybe using spaces. Provide brief explanation.\n\nLet's produce lines:\n\nStart\n→ Step 1: 定義類別 Solution // 定義解決方案類別\n→ Step 2: 宣告成員變數 originalArray, currentArray // 保存原始和目前陣列\n→ Step 3: Constructor Solution(nums) // 初始化物件\n    → Step 3.1: originalArray ← Copy(nums) // 複製輸入陣列作為原始\n    → Step 3.2: currentArray ← Copy(originalArray) // 初始化目前陣列為原始\n→ Step 4: Method reset() // 重置方法\n    → Step 4.1: currentArray ← Copy(originalArray) // 把目前陣列設為原始\n    → Step 4.2: Return currentArray // 回傳目前陣列\n→ Step 5: Method shuffle() // 隨機洗牌方法\n    → Step 5.1: n ← Length(currentArray) // 取得陣列長度\n    → Decision: n > 1? // 判斷陣列是否可洗牌\n        Yes → For i從 n-1 到 1 步驟-1\n            → Step 5.1.1: j ← RandomInt(0, i) // 隨機索引\n            → Step 5.1.2: Swap(currentArray[i], currentArray[j]) // 交換\n        No → // 何不做任何\n    → Step 5.2: Return currentArray // 回傳洗牌後陣列\nEnd\n\nBut we need each line separate with arrow and explanation. Use spaces indentation to show nested. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 宣告成員變數 originalArray, currentArray // 儲存原始與目前陣列  \n→ Step 3: Constructor Solution(nums) // 建構子，接收輸入陣列  \n  → Step 3.1: originalArray ← Copy(nums) // 取輸入陣列的複本作為原始  \n  → Step 3.2: currentArray ← Copy(originalArray) // 初始化目前陣列為原始複本  \n→ Step 4: Method reset() // 重置方法  \n  → Step 4.1: currentArray ← Copy(originalArray) // 重新把目前陣列設為原始  \n  → Step 4.2: Return currentArray // 回傳目前陣列  \n→ Step 5: Method shuffle() // 洗牌方法  \n  → Step 5.1: n ← Length(currentArray) // 取得陣列長度  \n  → Decision: n > 1? // 判斷陣列是否有足夠元素可洗牌  \n    Yes → For i從 n-1 到 1 步驟-1  \n     → Step 5.1.1: j ← RandomInt(0, i) // 隨機產生 0~i 的整數  \n     → Step 5.1.2: Swap(currentArray[i], currentArray[j]) // 交換元素  \n    No  → // 何不做任何操作  \n  → Step 5.2: Return currentArray // 回傳洗牌後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"\n        Generate all subsets (power set) of a list of unique integers.\n        Uses backtracking: at each step decide to include or exclude the current element.\n        \"\"\"\n        res = []\n\n        def backtrack(start, path):\n            # Append a copy of the current subset to the result\n            res.append(path[:])\n            # Explore further elements\n            for i in range(start, len(nums)):\n                path.append(nums[i])          # Include nums[i]\n                backtrack(i + 1, path)        # Recurse with next index\n                path.pop()                    # Backtrack: remove nums[i]\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    \"\"\"\n    Read input from stdin, parse the list of numbers, compute all subsets,\n    and print the result without spaces between elements.\n    Expected input format: 'nums = [1,2,3]'\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part after '='\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n\n    # Safely parse the list using ast.literal_eval\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        print(\"[]\")\n        return\n\n    sol = Solution()\n    subsets = sol.subsets(nums)\n\n    # Format output without spaces, e.g., [[],[1],[2],[1,2]]\n    subset_strings = []\n    for subset in subsets:\n        subset_str = '[' + ','.join(map(str, subset)) + ']'\n        subset_strings.append(subset_str)\n    output = '[' + ','.join(subset_strings) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for generating all subsets of unique elements array. Use typical backtracking or iterative approach. Provide each line with comment. Use Start, End, Decision, arrow. Provide steps. We'll produce algorithm: Start → input array nums → decide length → call recursive function buildSubset(index, currentSet) → if index==len → add currentSet copy to result → else → include nums[index] → call with index+1, currentSet + [nums[index]] → exclude → call with index+1, currentSet. Finally output result. Let's write steps. Use indentation for decision branches. Ensure each line has // explanation. Provide code lines. Use \"Start\" and \"End\". Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 nums // 取得由唯一整數組成的陣列  \n→ Step 2: 初始化結果集合 result 為空集合 // 用於儲存所有子集  \n→ Step 3: 定義遞迴函式 BuildSubset(index, current)  \n&nbsp;&nbsp;→ Decision: 若 index 等於 nums 的長度? // 判斷是否已處理完所有元素  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: 將 current 的複製加入 result // 把完整子集加入結果  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: 包含 nums[index] 吗? // 是否選擇將當前元素加入子集  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: 呼叫 BuildSubset(index + 1, current + [nums[index]]) // 包含元素後繼續遞迴  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: 呼叫 BuildSubset(index + 1, current) // 不包含元素後繼續遞迴  \n→ Step 7: 呼叫 BuildSubset(0, []) // 從第一個元素開始生成子集  \n→ Step 8: 輸出 result // 返回所有子集的集合  \nEnd // 程式執行結束"
    },
    {
      "title": "Shortest Unsorted Continuous Subarray",
      "source_file": "Leetcode/leetcode581.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '-3'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '-3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef find_unsorted_subarray(nums):\n    n = len(nums)\n    if n <= 1:\n        return 0\n\n    # 找到從左邊開始的第一個不符合有序的索引\n    max_left = nums[0]\n    left = n\n    for i in range(n):\n        max_left = max(max_left, nums[i])\n        if nums[i] < max_left:\n            left = i\n\n    # 找到從右邊開始的第一個不符合有序的索引\n    min_right = nums[-1]\n    right = -1\n    for i in range(n - 1, -1, -1):\n        min_right = min(min_right, nums[i])\n        if nums[i] > min_right:\n            right = i\n\n    if right == -1:\n        return 0\n    return right - left + 1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 找出方括號中包含的列表文字\n    start = data.find('[')\n    end = data.rfind(']')\n    list_str = data[start:end + 1]\n\n    # 解析為 Python list\n    nums = ast.literal_eval(list_str)\n\n    # 計算並輸出結果\n    result = find_unsorted_subarray(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm: Find minimal subarray that when sorted, whole array sorted. Standard solution: find left and right boundaries. Approach: find max seen from left, min seen from right. Determine leftmost index where current < max so unsorted; similarly for right.\n\nReturn length = max(0, right-left+1). Provide pseudocode line by line.\n\nMake sure use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 取得整個陣列\n→ Step 2: n = length(nums) // 陣列長度\n→ Step 3: max_left = -∞ // 初始化左側最大值\n→ Step 4: left = n // 左邊界預設為 n（未找到）\n→ Decision: 如果 n <= 1? // 檢查是否只有一個或零個元素\n    Yes → Step 5: Return 0 // 已經排好順序\n    No  → // 繼續\n→ Step 6: For i from 0 to n-1: // 從左到右掃描\n        max_left = max(max_left, nums[i]) // 更新左側最大\n        If nums[i] < max_left: left = i // 找到左邊界\n→ Step 7: min_right = ∞ // 初始化右側最小值\n→ Step 8: right = -1 // 右邊界預設為 -1（未找到）\n→ Step 9: For i from n-1 down to 0: // 從右到左掃描\n        min_right = min(min_right, nums[i]) // 更新右側最小\n        If nums[i] > min_right: right = i // 找到右邊界\n→ Decision: 如果 right == -1? // 判斷是否已經有序\n    Yes → Step 10: Return 0 // 已經排好順序\n    No  → // 計算長度\n→ Step 11: length = right - left + 1 // 子陣列長度\n→ Step 12: Return length // 回傳結果\nEnd // 程式執行結束\n\nWe need arrow for each step; include Decision branches with Yes → and No →.\n\nMake sure each line includes \"虛擬碼步驟\" + space + \"// 解釋\". Use Chinese.\n\nLet's format.\n\nWe need to include \"→\" before each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 取得整個陣列  \n→ Step 2: n = length(nums) // 取得陣列長度  \n→ Step 3: max_left = -∞ // 初始化左側最大值  \n→ Step 4: left = n // 左邊界預設為 n（未找到）  \n→ Decision: 如果 n <= 1? // 檢查是否只有一個或零個元素  \n  Yes → Step 5: Return 0 // 已經排好順序  \n  No  → // 繼續進行判斷  \n→ Step 6: For i from 0 to n-1: // 從左到右掃描陣列  \n  max_left = max(max_left, nums[i]) // 更新左側最大值  \n  If nums[i] < max_left: left = i // 找到左邊界  \n→ Step 7: min_right = ∞ // 初始化右側最小值  \n→ Step 8: right = -1 // 右邊界預設為 -1（未找到）  \n→ Step 9: For i from n-1 down to 0: // 從右到左掃描陣列  \n  min_right = min(min_right, nums[i]) // 更新右側最小值  \n  If nums[i] > min_right: right = i // 找到右邊界  \n→ Decision: 如果 right == -1? // 判斷是否已經是完全有序  \n  Yes → Step 10: Return 0 // 已經排好順序  \n  No  → // 需要計算子陣列長度  \n→ Step 11: length = right - left + 1 // 計算需要排序的子陣列長度  \n→ Step 12: Return length // 回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxje5upcu.py\", line 77, in <module>\n    main()\n  File \"/tmp/tmpxje5upcu.py\", line 54, in main\n    commands, args = json.loads(data)\n                     ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 83 (char 82)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}           # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys (preserves LRU order)\n\n    def _update(self, key: int) -> None:\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current freq list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to higher freq list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and freq\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        # Evict if necessary\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict the LRU key among the lowest freq\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key with freq 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    commands, args = json.loads(data)\n\n    outputs = []\n    cache = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            outputs.append(None)\n        elif cmd == \"put\":\n            cache.put(arg[0], arg[1])\n            outputs.append(None)\n        elif cmd == \"get\":\n            res = cache.get(arg[0])\n            outputs.append(res)\n        else:\n            # Ignore unknown commands\n            outputs.append(None)\n\n    # Convert None to 'null' for output formatting\n    formatted = \"[\" + \", \".join(\"null\" if x is None else str(x) for x in outputs) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines step-by-step for implementing LFUCache with O(1). We need to use virtual code arrows and structure. Provide explanations. So we need to design data structures: hashmap key->Node (value, freq). freq->DLL of nodes; maintain minFreq. Steps for get: if not exist return -1; else increase freq: remove node from current freq list, add to freq+1 list, update node freq, if old freq list empty and minFreq==oldFreq, minFreq++ ; return value. For put: if capacity 0 return. If key exists, update value, then treat as get to increase freq. Else if size==capacity, evict: find minFreq list, remove LRU node (tail) ; remove from hashmap. Insert new node with freq=1, add to freq=1 list, set minFreq=1. Use doubly linked list for each freq. Provide pseudocode line by line. Use Start, End. Use Decision: and arrows.\n\nWe'll produce a single linear list of steps? But need to show structure for operations. Use function definitions: Start → LFUCache constructor, get, put.\n\nWe can break into multiple parts: Initialization, get, put, helper removeFromList, addToList. But as per requirement, we output virtual code line by line with explanation. Might need to include nested decisions and loops.\n\nLet's produce:\n\nStart // Program start\n→ Step 1: Define Node struct with key, value, freq, prev, next // Node for doubly linked list\n→ Step 2: Define DLinkedList class with head, tail, size, methods addNode, removeNode, removeTail // Doubly linked list for each frequency\n→ Step 3: Define LFUCache class with capacity, size, minFreq, keyMap, freqMap // Hashmaps\n→ Step 4: Constructor: set capacity, size=0, minFreq=0 // init\n→ Decision: If capacity==0? // If no capacity, skip init\n    Yes → End // No cache\n    No  → End // proceed\n\nNow operations:\n\n// get\n→ Step: get(key)\n→ Decision: If key not in keyMap? // check existence\n    Yes → Step: return -1 // not found\n    No  → Step: node = keyMap[key] // fetch node\n    → Step: updateFrequency(node) // helper to bump freq\n    → Step: return node.value\n\n// updateFrequency\n→ Step: remove node from freqMap[node.freq] list // remove\n→ Decision: If freqMap[node.freq].size==0? // list empty\n    Yes → Step: delete freqMap[node.freq] // remove list\n    No  → Step: // nothing\n→ Step: node.freq++ // increment\n→ Decision: If freqMap[node.freq] exists? // check list\n    Yes → Step: // use existing list\n    No  → Step: freqMap[node.freq] = new DLinkedList() // create new list\n→ Step: add node to freqMap[node.freq] // add to front\n→ Decision: If node.freq-1 == minFreq AND old list empty? // update minFreq\n    Yes → Step: minFreq = node.freq\n    No  → Step: // nothing\n\n// put\n→ Step: put(key, value)\n→ Decision: If capacity==0? // no capacity\n    Yes → Step: return // nothing\n    No  → Step: // proceed\n→ Decision: If key in keyMap? // update\n    Yes → Step: node = keyMap[key]\n    → Step: node.value = value\n    → Step: updateFrequency(node)\n    → End\n    No  → Decision: If size == capacity? // need eviction\n        Yes → Step: list = freqMap[minFreq] // get min freq list\n        → Step: evictNode = list.removeTail() // remove LRU\n        → Step: delete keyMap[evictNode.key] // remove from map\n        → Step: size-- // decrement size\n        → End\n        No  → Step: // nothing\n    → Step: create newNode with key, value, freq=1\n    → Step: keyMap[key] = newNode\n    → Step: If freqMap[1] exists? // list for freq 1\n        Yes → Step: // use it\n        No  → Step: freqMap[1] = new DLinkedList() // create\n    → Step: add newNode to freqMap[1]\n    → Step: minFreq = 1 // reset minFreq\n    → Step: size++ // increment\n\nEnd\n\nWe also need to include DLinkedList methods:\n\n// DLinkedList methods\n→ Step: addNode(node) // add to head\n→ Step: removeNode(node) // detach\n→ Step: removeTail() // remove tail node and return\n\nBut we can keep as high-level.\n\nLet's format each line with arrow and explanation. Use indentation for decisions.\n\nWe'll produce each step line by line. Ensure each line ends with comment. Use Chinese explanations.\n\nLet's craft.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n\n→ Step 1: 定義 Node 結構，包含 key, value, freq, prev, next // 為 LFUCache 建立節點資料型別\n→ Step 2: 定義 DLinkedList 類別，內部有 head, tail, size，並提供 addNode(node), removeNode(node), removeTail() 方法 // 每個頻率對應的雙向鏈表\n→ Step 3: 定義 LFUCache 類別，屬性有 capacity, size, minFreq, keyMap, freqMap // keyMap: key → Node，freqMap: freq → DLinkedList\n→ Step 4: LFUCache constructor(capacity)  \n    → 設定 this.capacity = capacity, this.size = 0, this.minFreq = 0 // 初始化\n    → Decision: 若 capacity == 0? // 無法存放任何項目\n        Yes → End // 直接結束構造\n        No  → End // 其餘部分繼續\n\n// ---------- get(key) ----------\n→ Step: get(key)  \n    → Decision: 若 key 不在 keyMap?  \n        Yes → Step: return -1 // 找不到即回傳 -1\n        No  → Step: node = keyMap[key] // 取得節點\n        → Step: updateFrequency(node) // 更新頻率並移到對應鏈表\n        → Step: return node.value // 回傳對應值\n\n// ---------- updateFrequency(node) ----------\n→ Step: updateFrequency(node)  \n    → Step: oldFreq = node.freq  \n    → Step: freqMap[oldFreq].removeNode(node) // 從舊頻率鏈表移除\n    → Decision: 若 freqMap[oldFreq].size == 0?  \n        Yes → Step: delete freqMap[oldFreq] // 若鏈表空則移除該頻率層\n        No  → Step: // 其餘保持不變\n    → Step: node.freq++ // 頻率加 1\n    → Decision: 若 freqMap[node.freq] 不存在?  \n        Yes → Step: freqMap[node.freq] = new DLinkedList() // 新增頻率層\n        No  → Step: // 其餘保持不變\n    → Step: freqMap[node.freq].addNode(node) // 加到新頻率層頭部\n    → Decision: 若 oldFreq == minFreq AND freqMap[oldFreq] 已空?  \n        Yes → Step: minFreq = node.freq // 最小頻率升 1\n        No  → Step: // 其餘保持不變\n\n// ---------- put(key, value) ----------\n→ Step: put(key, value)  \n    → Decision: 若 capacity == 0?  \n        Yes → Step: return // 無法儲存任何項目\n        No  → Step: // 其餘部分繼續\n    → Decision: 若 key 已在 keyMap?  \n        Yes → Step: node = keyMap[key]  \n            → Step: node.value = value // 更新值  \n            → Step: updateFrequency(node) // 更新頻率  \n            → End // 結束 put\n        No  → // 新增項目  \n            → Decision: 若 size == capacity?  \n                Yes → Step: list = freqMap[minFreq] // 取得最小頻率層  \n                    → Step: evictNode = list.removeTail() // 移除最舊的節點  \n                    → Step: delete keyMap[evictNode.key] // 從 keyMap 刪除  \n                    → Step: size-- // 減少目前項目數  \n                No  → Step: // 無需 evict  \n            → Step: newNode = new Node(key, value, freq=1) // 建立新節點  \n            → Step: keyMap[key] = newNode // 加入 keyMap  \n            → Decision: 若 freqMap[1] 不存在?  \n                Yes → Step: freqMap[1] = new DLinkedList() // 建立頻率 1 層  \n                No  → Step: // 其餘保持不變  \n            → Step: freqMap[1].addNode(newNode) // 加到頻率 1 層頭部  \n            → Step: minFreq = 1 // 重置最小頻率為 1  \n            → Step: size++ // 目前項目數加 1  \n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Basic Calculator",
      "source_file": "Leetcode/leetcode224.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\n\ndef precedence(op: str) -> int:\n    \"\"\"Return the precedence of the operator.\"\"\"\n    if op in ('+', '-'):\n        return 1\n    if op in ('*', '/'):\n        return 2\n    return 0  # '(' has lowest precedence in our logic\n\n\ndef apply_op(nums: list, ops: list):\n    \"\"\"Apply the top operator on the top two numbers.\"\"\"\n    op = ops.pop()\n    right = nums.pop()\n    left = nums.pop()\n    if op == '+':\n        nums.append(left + right)\n    elif op == '-':\n        nums.append(left - right)\n    elif op == '*':\n        nums.append(left * right)\n    elif op == '/':\n        # Python's // rounds toward negative infinity, use int() for truncation toward zero\n        nums.append(int(left / right))\n\n\ndef calculate(s: str) -> int:\n    \"\"\"Evaluate a basic arithmetic expression containing + - * / and parentheses.\"\"\"\n    nums = []\n    ops = []\n    i = 0\n    n = len(s)\n    while i < n:\n        ch = s[i]\n        if ch.isspace():\n            i += 1\n            continue\n\n        if ch.isdigit():\n            # Parse multi-digit number\n            num = 0\n            while i < n and s[i].isdigit():\n                num = num * 10 + int(s[i])\n                i += 1\n            nums.append(num)\n            continue\n\n        if ch == '(':\n            ops.append(ch)\n            i += 1\n            continue\n\n        if ch == ')':\n            # Resolve until matching '('\n            while ops and ops[-1] != '(':\n                apply_op(nums, ops)\n            ops.pop()  # remove '('\n            i += 1\n            continue\n\n        # Operator handling (+ - * /)\n        # Handle unary minus: treat as 0 - number\n        if ch in '+-':\n            # Check if unary: start of expression or after '(' or another operator\n            if (i == 0 or s[i-1] in ' (*/+-'):\n                if ch == '-':\n                    nums.append(0)\n                # unary + is ignored\n                i += 1\n                continue\n\n        # For binary operators\n        while ops and precedence(ops[-1]) >= precedence(ch):\n            apply_op(nums, ops)\n        ops.append(ch)\n        i += 1\n\n    # Apply remaining operators\n    while ops:\n        apply_op(nums, ops)\n\n    return nums[0] if nums else 0\n\n\ndef main():\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    # Extract the expression string between quotes\n    expr = None\n    if '\"' in data:\n        start = data.find('\"')\n        end = data.rfind('\"')\n        expr = data[start + 1:end]\n    elif \"'\" in data:\n        start = data.find(\"'\")\n        end = data.rfind(\"'\")\n        expr = data[start + 1:end]\n    else:\n        expr = data  # fallback if no quotes\n\n    result = calculate(expr)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for evaluating a basic calculator: given string s with + - * / and parentheses? It says valid expression, basic calculator. Might include parentheses? Typically LeetCode Basic Calculator II no parentheses, only + - * /. Basic Calculator I includes parentheses. We'll design generic approach: using stack, handling parentheses. But due to limited requirement, we can design a simple algorithm: use two stacks: values and operators. Handle precedence.\n\nWe'll produce virtual code lines with arrow arrows. Each line: \"Start // ...\" etc. Provide step-by-step explanation.\n\nWe need to be careful: each line includes \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe use \"→\" arrow.\n\nWe need to produce step-by-step for evaluating expression. Provide decision points.\n\nOk.\n\nLet's craft: Start // start program.\n\nThen Step: Initialize index, stack for numbers, stack for operators.\n\nLoop over string until index < length:\n\n- If char is space: skip.\n\n- If char is digit: parse full number, push to numbers stack.\n\n- If char is '(': push to operators stack.\n\n- If char is ')': while top of operators not '(', evaluate top operator, pop number operands, push result; then pop '('.\n\n- If char is operator + - * /: while operators stack not empty and precedence of top >= current precedence, evaluate; then push current operator.\n\nAfter loop, evaluate remaining operators.\n\nResult is top of numbers stack.\n\nReturn result.\n\nLet's produce virtual code with each step as line. We should include decision blocks.\n\nMake each line a single action.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化索引 i ← 0 // 設定遍歷字串的起點  \n→ Step 2: 建立空堆疊 numStack // 存放數字  \n→ Step 3: 建立空堆疊 opStack // 存放運算子  \n\n→ Decision: 是否還有字元待處理？ i < len(s)? // 判斷是否已遍歷完字串  \n    Yes → Step 4: 讀取字元 ch ← s[i] // 取得目前索引的字元  \n    → Decision: ch 是空白字元？ // 處理空白  \n        Yes → Step 5: i ← i + 1 // 跳過空白並繼續  \n        No  → Decision: ch 是數字？  \n            Yes → Step 6: 讀取完整數字 num ← 0  \n                → While ch 是數字  \n                    → Step 7: num ← num * 10 + int(ch) // 解析多位數  \n                    → i ← i + 1  \n                    → 更新 ch ← s[i]（若還有字元）  \n                → Step 8: 推入 numStack ← num // 把解析出的數字存入堆疊  \n                → Decision: i < len(s)? // 繼續處理  \n                    Yes → GOTO Step 4  \n                    No  → GOTO Step 15 // 過完字串後進行最後計算  \n            No  → Decision: ch 是 '('？  \n                Yes → Step 9: 推入 opStack ← '(' // 儲存左括號  \n                → Step 10: i ← i + 1  \n                → Decision: i < len(s)?  \n                    Yes → GOTO Step 4  \n                    No  → GOTO Step 15  \n            No  → Decision: ch 是 ')'？  \n                Yes → Step 11: While opStack.top() != '('  \n                    → Step 12: operator ← opStack.pop()  \n                    → Step 13: right ← numStack.pop()  \n                    → Step 14: left ← numStack.pop()  \n                    → Step 15: result ← evaluate(left, operator, right)  \n                    → Step 16: 推入 numStack ← result  \n                → Step 17: pop '(' from opStack  \n                → Step 18: i ← i + 1  \n                → Decision: i < len(s)?  \n                    Yes → GOTO Step 4  \n                    No  → GOTO Step 15  \n            No  → // ch 是運算子 (+, -, *, /)  \n                → Step 19: currentOp ← ch  \n                → While opStack not empty AND precedence(opStack.top()) >= precedence(currentOp)  \n                    → Step 20: operator ← opStack.pop()  \n                    → Step 21: right ← numStack.pop()  \n                    → Step 22: left ← numStack.pop()  \n                    → Step 23: result ← evaluate(left, operator, right)  \n                    → Step 24: 推入 numStack ← result  \n                → Step 25: 推入 opStack ← currentOp  \n                → Step 26: i ← i + 1  \n                → Decision: i < len(s)?  \n                    Yes → GOTO Step 4  \n                    No  → GOTO Step 15  \n\n→ Step 27: While opStack not empty  \n    → Step 28: operator ← opStack.pop()  \n    → Step 29: right ← numStack.pop()  \n    → Step 30: left ← numStack.pop()  \n    → Step 31: result ← evaluate(left, operator, right)  \n    → Step 32: 推入 numStack ← result  \n\n→ Step 33: result ← numStack.top() // 最終結果  \n→ End // 程式執行結束  \n\n// evaluate(a, op, b) 函式：根據 op 執行對應運算並返回結果  \n// precedence(op)：返回運算子的優先等級（* / > + -）  \n// 以上流程實現不使用 eval 的基本算術表達式計算器。"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport bisect\n\ndef contains_nearby_almost_duplicate(nums, index_diff, value_diff):\n    \"\"\"\n    檢查是否存在兩個索引 i, j 滿足:\n    - i != j\n    - abs(i - j) <= index_diff\n    - abs(nums[i] - nums[j]) <= value_diff\n    \"\"\"\n    if index_diff <= 0 or value_diff < 0:\n        return False\n\n    window = []  # 以排序的方式保存滑動窗口內的元素\n\n    for i, num in enumerate(nums):\n        # 1. 在窗口中尋找最接近 num 的元素\n        #   以 num - value_diff 為左邊界\n        pos = bisect.bisect_left(window, num - value_diff)\n        if pos < len(window) and abs(window[pos] - num) <= value_diff:\n            return True\n\n        # 2. 將目前元素加入窗口\n        bisect.insort(window, num)\n\n        # 3. 保持窗口大小 <= index_diff\n        if len(window) > index_diff:\n            # 要移除的是 nums[i - index_diff]，在窗口中找到其位置\n            old_val = nums[i - index_diff]\n            idx = bisect.bisect_left(window, old_val)\n            # 確保找到的索引真的對應到 old_val\n            # 若相同值有多個，刪除其中一個即可\n            if idx < len(window) and window[idx] == old_val:\n                window.pop(idx)\n\n    return False\n\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 轉換成字典格式供 literal_eval 解析\n    # 先把關鍵字後的 '=' 改成 ':'，再加上大括號\n    data = data.replace('nums =', 'nums:').replace('indexDiff =', 'indexDiff:').replace('valueDiff =', 'valueDiff:')\n    data = data.strip()\n    if not data.startswith('{'):\n        data = '{' + data\n    if not data.endswith('}'):\n        data = data + '}'\n\n    try:\n        params = ast.literal_eval(data)\n    except Exception as e:\n        # 若解析失敗，直接輸出 false\n        print('false')\n        return\n\n    nums = params.get('nums', [])\n    index_diff = params.get('indexDiff', 0)\n    value_diff = params.get('valueDiff', 0)\n\n    result = contains_nearby_almost_duplicate(nums, index_diff, value_diff)\n    print('true' if result else 'false')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm to check near duplicates. Standard solution: sliding window with set. We'll produce line-by-line steps.\n\nWe must not output actual code, only virtual steps with explanation. Use Start, Decision, etc.\n\nLet's craft. Lines:\n\nStart\n→ Step 1: 初始化空集合 window // 用於存儲當前窗口中的元素\n→ Step 2: 循環遍歷 nums，索引 i 從 0 到 len(nums)-1\n    → Step 2.1: 如果窗口大小 > indexDiff, 则移除最旧元素 nums[i - indexDiff - 1] // 確保距離限制\n    → Decision: 是否存在窗口中與 nums[i] 差值 <= valueDiff？\n        Yes → Step 3: 返回 True // 找到符合條件的對\n        No  → Step 4: 將 nums[i] 加入窗口 // 為下一個元素做準備\n→ End // 無任何對符合條件，返回 False\n\nBut we need each line with virtual code and explanation. Use arrow indentation properly. Provide Step numbers. Provide Decision branches. Provide \"Yes →\" and \"No →\". Also mention return statements.\n\nLet's craft each line:\n\nStart // 程式開始執行\n\n→ Step 1: Set window = empty set // 用於保存滑動窗口內的元素\n\n→ Step 2: For i from 0 to length(nums)-1 // 逐個遍歷陣列\n\n    → Step 2.1: If i > indexDiff, Remove nums[i - indexDiff - 1] from window // 保持距離限制\n\n    → Decision: 是否存在元素 x 在 window 使 |x - nums[i]| <= valueDiff？\n\n        Yes → Step 3: Return True // 找到符合條件的對\n\n        No  → Step 4: Add nums[i] to window // 把當前元素加入窗口\n\n→ End // 無符合條件，返回 False\n\nWe must include return false at end. Step 5: Return False.\n\nAdd Step 5 after End? Actually End line is final; we can just put Step 5 before End. Let's do:\n\n→ Step 5: Return False // 所有索引都檢查完畢，未找到符合條件\n\nEnd // 程式執行結束\n\nWe need to keep each line separate. Also ensure the Decision branches are properly indented.\n\nMake sure each line includes virtual code + explanation. Provide arrows etc.\n\nLet's produce final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Set window = empty set // 用於保存滑動窗口內的元素\n→ Step 2: For i from 0 to length(nums)-1 // 逐個遍歷陣列\n    → Step 2.1: If i > indexDiff, Remove nums[i - indexDiff - 1] from window // 保持距離限制\n    → Decision: 是否存在元素 x 在 window 使 |x - nums[i]| <= valueDiff？\n        Yes → Step 3: Return True // 找到符合條件的對\n        No  → Step 4: Add nums[i] to window // 把當前元素加入窗口\n→ Step 5: Return False // 所有索引都檢查完畢，未找到符合條件\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpaq40nom4.py\", line 27, in <module>\n    commands, args_list = json.loads(data)\n                          ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 25 (char 24)"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpw2o4s3t5.py\", line 27, in <module>\n    commands, args_list = json.loads(data)\n                          ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"建立前綴和，方便隨機選擇索引\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機挑選一個索引，機率與權重成正比\"\"\"\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，格式為 [\"cmd1\",\"cmd2\",...], [[arg1],[arg2],...]\n    commands, args_list = json.loads(data)\n\n    result = []\n    instance = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 建構物件\n            instance = Solution(*args)\n            result.append(None)  # 按照題目要求，返回 null\n        else:\n            # 呼叫方法\n            method = getattr(instance, cmd)\n            res = method(*args) if args else method()\n            result.append(res)\n\n    # 輸出結果，使用 json.dumps 以產生符合題目格式的輸出\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementing pickIndex with weighted random selection. We need to follow format: each line: virtual code step + space + // explanation. Use arrows and decision structures. The code: Start, preprocess cumulative weights, store array, use random number. Steps: Build prefix sums, total sum. pickIndex: generate random number between 1 and total, binary search for first prefix >= random. Return index. Also handle initialization in constructor. Provide virtual code lines.\n\nWe need to not output actual code. So use steps like \"Initialize cumulative array\" etc.\n\nEnsure each line ends with // explanation.\n\nWe need to include Start and End. Provide arrows. For binary search, we can have Decision: binary search loop.\n\nWe also need to indicate the array storage.\n\nLet's produce steps:\n\nStart\n→ Step 1: 接收權重數組 w // 存入內部變數\n→ Step 2: 建立前綴和陣列 prefix // 前綴和用於權重查找\n    → Decision: 是否需要初始化 prefix? // 只要 w 不為空\n        Yes → Loop i from 0 to w.length-1\n            → Step 3: prefix[i] = (i == 0 ? w[i] : prefix[i-1] + w[i]) // 計算前綴和\n        No → Step 4: prefix = [] // 空陣列\n→ Step 5: 計算總權重 total = prefix[w.length-1] // 最後一個前綴和即總和\n→ Step 6: 定義 pickIndex 函式 // 將會根據權重隨機選擇索引\n    → Step 7: 產生隨機整數 r 在 [1, total] 之間 // 隨機數對應權重區間\n    → Decision: r 是否小於等於 prefix[0]? // 判斷是否在第一個區間\n        Yes → Step 8: return 0 // 第一個索引\n        No  → Decision: r 是否小於等於 prefix[1]? // 以此類推\n            Yes → Step 9: return 1\n            No  → ...\n    → Step 10: 迭代 binary search 以找出 r 所在區間 // 更有效率\n        → Decision: low < high? // binary search 迴圈條件\n            Yes → Step 11: mid = (low + high) // 2 // 計算中點\n                → Decision: r <= prefix[mid]? // 判斷 r 與前綴和\n                    Yes → Step 12: high = mid // 移動高指標\n                    No  → Step 13: low = mid + 1 // 移動低指標\n            No → Step 14: return low // 找到索引\n→ End\n\nWe need to ensure each line formatted. Use arrow \"→\" before each step, and decisions indented.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收權重數組 w // 將傳入的權重陣列存入內部變數  \n→ Step 2: 建立前綴和陣列 prefix // 用於快速查找權重區間  \n  Decision: w 是否為空? // 只有 w 非空時才需要建立前綴和  \n   Yes → Loop i 從 0 到 w.length-1  \n    → Step 3: prefix[i] = (i == 0 ? w[i] : prefix[i-1] + w[i]) // 計算前綴和  \n    // 這樣 prefix[i] 就是從 0 到 i 的總權重  \n   No  → Step 4: prefix = [] // 空陣列，表示無權重  \n→ Step 5: 計算總權重 total = (prefix.length == 0 ? 0 : prefix[prefix.length-1]) // 最後一個前綴和即總和  \n→ Step 6: 定義函式 pickIndex() // 用於根據權重隨機選擇索引  \n  → Step 7: 產生隨機整數 r 在 [1, total] 之間 // 隨機數對應到權重區間  \n  → Decision: r 是否小於等於 prefix[0]? // 判斷是否落在第一個區間  \n   Yes → Step 8: return 0 // 第一個索引  \n   No  → Decision: r 是否小於等於 prefix[1]? // 以此類推  \n    Yes → Step 9: return 1 // 第二個索引  \n    No  → … // 連續判斷直到找到對應區間  \n    // 以上為簡化示例，實際可用二分搜尋更有效率  \n  → Step 10: 執行二分搜尋找出 r 所在區間 // 快速定位索引  \n   → Decision: low < high? // 二分搜尋的迴圈條件  \n    Yes → Step 11: mid = (low + high) // 2 // 計算中點  \n      Decision: r <= prefix[mid]? // 判斷 r 與前綴和的關係  \n       Yes → Step 12: high = mid // r 在左半邊  \n       No  → Step 13: low = mid + 1 // r 在右半邊  \n    No  → Step 14: return low // low 為對應索引  \nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps12ngo0w.py\", line 53, in <module>\n    mat, k = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps12ngo0w.py\", line 30, in parse_input\n    mat = ast.literal_eval(mat_match.group(1))\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,0,0]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2h1gvu78.py\", line 53, in <module>\n    mat, k = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2h1gvu78.py\", line 30, in parse_input\n    mat = ast.literal_eval(mat_match.group(1))\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,0,0,0]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef count_soldiers(row):\n    \"\"\"使用二分搜尋統計 row 中 1 的數量。\"\"\"\n    left, right = 0, len(row)\n    while left < right:\n        mid = (left + right) // 2\n        if row[mid] == 1:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef k_weakest_rows(mat, k):\n    \"\"\"回傳最弱的 k 行的索引。\"\"\"\n    soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n    soldiers.sort()                 # 先按士兵數，再按行號\n    return [i for _, i in soldiers[:k]]\n\ndef parse_input(data):\n    \"\"\"從 stdin 讀取 mat 與 k，支援多種輸入格式。\"\"\"\n    mat = None\n    k = None\n\n    # 1. 解析「mat = ...」和「k = ...」的寫法\n    mat_match = re.search(r'mat\\s*=\\s*(\\[.*?\\])', data, re.S)\n    if mat_match:\n        mat = ast.literal_eval(mat_match.group(1))\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if k_match:\n        k = int(k_match.group(1))\n\n    # 2. 若無上述匹配，嘗試逐行解析\n    if mat is None or k is None:\n        lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            mat = ast.literal_eval(lines[0])\n            k = int(lines[1])\n        elif len(lines) == 1:\n            # 可能是「[[...],...], 3」的寫法\n            parts = lines[0].rsplit(',', 1)\n            mat = ast.literal_eval(parts[0].strip())\n            k = int(parts[1].strip())\n        else:\n            raise ValueError(\"無法解析輸入。\")\n\n    return mat, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    mat, k = parse_input(raw_input)\n    result = k_weakest_rows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nThe user wants pseudo code in Chinese (Traditional). Provide step-by-step virtual code with explanations. No real code. Use arrow format. Should handle input: matrix mat, ints m,n, k. Determine number of soldiers per row. Use decision logic. Output indices of k weakest. Probably need to sort rows by strength then indices. We produce algorithm: compute counts via binary search or scanning until first 0. Then create list of pairs (count, index). Sort by count ascending, then index ascending. Then take first k indices. Provide pseudocode. Use decision: maybe for each row, count soldiers: loop until 0. Or use binary search because sorted. We'll produce pseudocode using binary search for efficiency.\n\nLet's produce virtual code. Use Start, End, Decision.\n\nLine example: \"Start // 開始執行\" etc.\n\nWe must be careful to include arrows and indentation.\n\nLet's produce about 25-30 lines. Each line include explanation after //.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入矩陣 mat, 整數 k // 取得輸入資料  \n→ Step 2: 初始化空列表 rowsInfo // 用來儲存每一列的(士兵數, 行號)  \n→ Decision: 若 mat 為空?  \n    Yes → Step 3: 回傳空列表 // 無資料直接結束  \n    No → Step 4: 取得行數 m = mat 的行數 // 取得矩陣長度  \n→ Step 5: 迭代 i 從 0 到 m-1 // 遍歷每一行  \n    → Step 6: 呼叫 BinarySearch(mat[i]) 取得該行的士兵數 // 使用二分搜尋取得 1 的數量  \n    → Step 7: 加入 rowsInfo 以元組 (soldiers, i) // 儲存行資訊  \n→ Step 8: 進行排序 rowsInfo 根據第一個元素升序，再以第二個元素升序 // 先按士兵數，士兵數相同則按行號  \n→ Step 9: 初始化空列表 result // 儲存弱行的行號  \n→ Decision: 若 k > rowsInfo 的長度?  \n    Yes → Step 10: k = rowsInfo 的長度 // 保證不超過行數  \n    No → No  \n→ Step 11: 迭代 j 從 0 到 k-1  \n    → Step 12: 將 rowsInfo[j].行號 加入 result // 取前 k 個弱行  \n→ End // 程式執行結束  \n\n// BinarySearch 步驟（假設每行 1 的區間連續）  \nStart // BinarySearch 開始  \n→ Step 1: 設定 left = 0, right = len(row) - 1, count = 0 // 左右指標，初始士兵數  \n→ Decision: 是否存在 1?  \n    Yes → Step 2: 若 row[left] == 0 → count = 0 // 若最左邊已是 0，則士兵數為 0  \n    No → Step 3: 計算右端點位置  \n    → Decision: left > right?  \n        Yes → Step 4: count = right + 1 // 右端點即士兵數  \n        No → Step 5: 計算 mid = (left + right) // 2  \n        → Decision: row[mid] == 1?  \n            Yes → Step 6: left = mid + 1 // 往右搜尋  \n            No → Step 7: right = mid - 1 // 往左搜尋  \n→ End // BinarySearch 結束，返回 count"
    }
  ]
}