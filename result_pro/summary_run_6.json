{
  "run_index": 6,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 388,
  "generation_or_validation_failure_count": 51,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,3,3,6,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 3, 3, 6, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有程式碼（例如：print(roll_dice(5))）\n    code = sys.stdin.read()\n    # 執行讀取到的程式碼，讓它能呼叫 roll_dice 函式\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Each line includes virtual code step and explanation. Use Start, End, Decision, arrow, etc. It's a function roll_dice(n) using random module. Steps: import random, define function, create list, loop n times, generate random integer 1-6, append to list, return list. Use Start, End.\n\nAlso we need arrow lines: → Step 1: ... etc. Provide explanation.\n\nNeed to use arrow (→). Each line should be one step. Must not output actual code, only virtual code.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 匯入 random 模組 // 引入亂數功能\n→ Step 2: 定義函數 roll_dice(n) // 建立擲骰函式\n→ Step 3: 初始化空串列 results // 用來儲存每次擲骰結果\n→ Decision: n 是否大於 0? // 檢查是否需要擲骰\n    Yes → Step 4: 進入 for 迴圈，重複 n 次 // 擲 n 次骰子\n        → Step 5: 產生 1 至 6 的亂數值 die_value // 模擬一次擲骰\n        → Step 6: 把 die_value 加入 results 串列 // 儲存結果\n    No  → Step 7: 直接跳過擲骰 // 若 n 為 0 或負數，不擲骰\n→ Step 8: 回傳 results 串列 // 回傳所有擲骰結果\nEnd // 程式執行結束\n\nWe must use arrow and decision formatting exactly as example. Use indent spaces for nested.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 匯入 random 模組 // 引入亂數功能\n→ Step 2: 定義函數 roll_dice(n) // 建立擲骰函式\n→ Step 3: 初始化空串列 results // 用來儲存每次擲骰結果\n→ Decision: n 是否大於 0? // 檢查是否需要擲骰\n    Yes → Step 4: 進入 for 迴圈，重複 n 次 // 擲 n 次骰子\n        → Step 5: 產生 1 至 6 的亂數值 die_value // 模擬一次擲骰\n        → Step 6: 把 die_value 加入 results 串列 // 儲存結果\n    No  → Step 7: 直接跳過擲骰 // 若 n 為 0 或負數，不擲骰\n→ Step 8: 回傳 results 串列 // 回傳所有擲骰結果\nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行所需秒數，回傳四捨五入到小數點 3 位的結果。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼並執行\n    code = sys.stdin.read()\n    # 建立執行環境，將 measure_time 讓使用者程式可存取\n    exec_globals = {\"measure_time\": measure_time}\n    exec(code, exec_globals)",
      "virtual_code": "Thinking...\nWe need to output pseudo code lines, with explanation. Must follow format. Use virtual code arrow etc.\n\nWe need to implement measure_time(func, *args) using time module. Steps: start, get start time, call func with args, get end time, compute duration, round to 3 decimals, return result. No actual code.\n\nWe must include Start, End, Decision? No decisions needed, just steps. We'll include Step 1 etc.\n\nUse \"→\" arrow for each step. Example from format. We'll include \"Start // 程式開始執行\" etc.\n\nWe need to mention time module import at start? We can include \"Import time module\" step.\n\nLet's produce:\n\nStart\n→ Step 1: Import time module // 載入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義 measure_time 函式\n→ Step 3: Record start_time = time.time() // 紀錄開始時間\n→ Step 4: Execute result = func(*args) // 執行傳入函式並取得結果\n→ Step 5: Record end_time = time.time() // 紀錄結束時間\n→ Step 6: Calculate elapsed = end_time - start_time // 計算耗時\n→ Step 7: Round elapsed to 3 decimal places -> rounded = round(elapsed, 3) // 四捨五入到小數點三位\n→ Step 8: Return rounded, result // 回傳耗時及函式結果\nEnd\n\nBut maybe they want the function to return only result? The requirement: \"用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。\" The wording ambiguous: \"回傳結果\" might mean the time result. Probably function returns the rounded elapsed time. Not both result and time. But they might want time only. But also maybe the function should return the elapsed time. Let's interpret: measure_time returns the time. It \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\" - so returns the elapsed seconds. So we don't need to return result of func.\n\nThus step 4: Execute result = func(*args) // Execute func\nStep 8: Return rounded // return elapsed time\n\nBut we might keep result? The description doesn't mention result of func. So just return elapsed.\n\nThus final pseudo code.\n\nLet's write each line with explanation.\n\nWe need to use the same style: \"→ Step 1: ... // ...\". No indentation? The example shows indentation for decisions. But we can just indent lines with spaces maybe.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 載入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 定義 measure_time 函式  \n→ Step 3: Record start_time = time.time() // 紀錄開始時間  \n→ Step 4: Execute result = func(*args) // 執行傳入函式並取得結果  \n→ Step 5: Record end_time = time.time() // 紀錄結束時間  \n→ Step 6: Calculate elapsed = end_time - start_time // 計算耗時  \n→ Step 7: Round elapsed to 3 decimal places -> rounded = round(elapsed, 3) // 四捨五入到小數點三位  \n→ Step 8: Return rounded // 回傳耗時（秒）  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"grape\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'grape', 'melon', 'apple'}\""
        }
      ],
      "generated_code": "def main():\n    # 讀取標準輸入，雖然此問題不需要實際輸入，但依規範需加入讀取步驟\n    import sys\n    sys.stdin.read()  # 讀取並忽略內容\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 同時新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除 'pineapple'（不存在時不會報錯）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc. Should not produce actual code. So steps: Start, create set, add, update, remove, discard, output. Also maybe decision for discard? Could check if element exists before discard but not needed. But could illustrate. We'll produce.\n\nMake sure each line ends with explanation comment. Use arrows etc.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 1: 定義集合 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Decision: 是否存在 'pineapple' in fruits? // 檢查 'pineapple' 是否在集合\n    Yes → Step 5: fruits.discard('pineapple') // 移除 'pineapple'（如果存在）\n    No  → Step 5: fruits.discard('pineapple') // 直接 discard，不會報錯\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd // 程式執行結束\n\nBut we need to use arrow \"Yes →\" \"No →\" inside Decision. Might need to show indentation. Use tab or space? Use indentation as in example. Provide each line with comment. Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化集合 fruits = {'apple', 'banana'} // 建立包含兩個水果的集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'\n→ Decision: 'pineapple' 是否存在於 fruits? // 檢查要 discard 的元素是否在集合中\n    Yes → Step 5: fruits.discard('pineapple') // 如果存在，移除 'pineapple'\n    No  → Step 5: fruits.discard('pineapple') // 若不存在，discard 仍能安全執行\n→ Step 6: 輸出 fruits // 顯示最終集合的內容\nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.88TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.88 TWD'"
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef fetch_rate():\n    \"\"\"向 API 發送請求並回傳美元對台幣的匯率。\"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        rate = data['rates'].get('TWD')\n        return rate\n    except Exception:\n        return None\n\ndef run_gui():\n    \"\"\"建立 tkinter GUI，按鈕可更新匯率。\"\"\"\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update():\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f'目前美元匯率：約 {rate} TWD')\n        else:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    tk.Button(win, text='更新匯率', command=update).pack(pady=5)\n    win.mainloop()\n\ndef main():\n    \"\"\"從 stdin 讀取輸入，若有輸入即印出匯率；否則啟動 GUI。\"\"\"\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        rate = fetch_rate()\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n    else:\n        run_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrow notation and Decision, Start, End.\n\nWe must cover:\n\n- Start\n- Import modules (requests, tkinter)\n- Create main window\n- Define function to fetch rate\n- Use requests to GET URL\n- Parse JSON, get rate TWD\n- Update label text\n- Button to trigger update\n- Run mainloop\n\nUse Decision? Probably decision for if request success. We'll include.\n\nFollow format exactly.\n\nLet's produce step by step.\n\nWe'll use pseudo code style: e.g., \"→ Import modules\" but arrow indicates next step.\n\nLet's craft.\n\nAlso note: Use \"Start\" and \"End\".\n\nAdd indentation for nested decisions? Not required but can illustrate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Import modules: requests, tkinter, json // 引入所需模組\n→ Create main window: root = tkinter.Tk() // 建立主視窗\n→ Set window title: root.title('USD/TWD 匯率查詢') // 設定視窗標題\n→ Create label widget: rate_label = tkinter.Label(root, text='匯率未載入', font=('Arial', 14)) // 用於顯示匯率\n→ Pack label into window: rate_label.pack(pady=10) // 放置在視窗中\n→ Define function fetch_rate(): // 定義取得匯率的函式\n    → Try:\n        → Send GET request to API: response = requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 呼叫匯率 API\n        → Decision: 如果 response.status_code == 200? // 檢查請求是否成功\n            Yes → Parse JSON: data = response.json() // 解析回傳 JSON\n            Yes → Extract TWD rate: rate = data['rates'].get('TWD', '未知') // 取出 TWD 匯率\n            Yes → Update label text: rate_label.config(text=f'1 USD = {rate} TWD') // 顯示最新匯率\n            No  → Update label text: rate_label.config(text='請求失敗') // 顯示錯誤訊息\n    → Except Exception as e:\n        → Update label text: rate_label.config(text='連線失敗') // 處理異常\n→ Create button widget: refresh_btn = tkinter.Button(root, text='更新匯率', command=fetch_rate) // 建立按鈕並連結函式\n→ Pack button into window: refresh_btn.pack(pady=5) // 放置按鈕\n→ Call fetch_rate() once // 初始載入匯率\n→ Start main event loop: root.mainloop() // 啟動 tkinter 事件迴圈\nEnd // 程式執行結束\n\nBut need to follow formatting: Each line should be \"虛擬碼步驟 // 解釋\". Indentation for nested lines maybe not necessary but we can indent to show hierarchy but still each line separate.\n\nLet's produce with indentation using tabs or spaces? Provide consistent spaces before nested lines.\n\nWe can use 4 spaces indentation for nested steps.\n\nWe'll produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import modules: requests, tkinter, json // 引入所需模組  \n→ Create main window: root = tkinter.Tk() // 建立主視窗  \n→ Set window title: root.title('USD/TWD 匯率查詢') // 設定視窗標題  \n→ Create label widget: rate_label = tkinter.Label(root, text='匯率未載入', font=('Arial', 14)) // 用於顯示匯率  \n→ Pack label into window: rate_label.pack(pady=10) // 放置在視窗中  \n→ Define function fetch_rate(): // 定義取得匯率的函式  \n    → Try: // 嘗試執行以下動作  \n        → Send GET request to API: response = requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 呼叫匯率 API  \n        → Decision: 如果 response.status_code == 200? // 檢查請求是否成功  \n            Yes → Parse JSON: data = response.json() // 解析回傳 JSON  \n            Yes → Extract TWD rate: rate = data['rates'].get('TWD', '未知') // 取出 TWD 匯率  \n            Yes → Update label text: rate_label.config(text=f'1 USD = {rate} TWD') // 顯示最新匯率  \n            No  → Update label text: rate_label.config(text='請求失敗') // 顯示錯誤訊息  \n    → Except Exception as e: // 發生例外時執行  \n        → Update label text: rate_label.config(text='連線失敗') // 處理異常  \n→ Create button widget: refresh_btn = tkinter.Button(root, text='更新匯率', command=fetch_rate) // 建立按鈕並連結函式  \n→ Pack button into window: refresh_btn.pack(pady=5) // 放置按鈕  \n→ Call fetch_rate() once // 初始載入匯率  \n→ Start main event loop: root.mainloop() // 啟動 tkinter 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n        # 總格數\n        self.rem = self.total     # 剩餘未翻轉格數\n        self.map = {}             # 映射表，隨機索引 → 真實索引\n\n    def flip(self):\n        # 隨機選取一個剩餘未翻轉的索引\n        r = random.randint(0, self.rem - 1)\n        # 取得實際索引（如果已映射則取映射值）\n        x = self.map.get(r, r)\n        # 把最後一個未翻轉格移到 r 的位置\n        self.rem -= 1\n        self.map[r] = self.map.get(self.rem, self.rem)\n        # 返回行列坐標\n        return [x // self.n, x % self.n]\n\n    def reset(self):\n        self.rem = self.total\n        self.map.clear()\n\n\ndef main():\n    # 讀取整個標準輸入，假設第一行是操作列表，第二行是對應的參數\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    result = []\n    sol = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            sol = Solution(*args)\n            result.append(None)\n        elif op == \"flip\":\n            result.append(sol.flip())\n        elif op == \"reset\":\n            sol.reset()\n            result.append(None)\n\n    # 輸出結果，使用 json 以得到與範例相同的 null 表示\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm. Use Start, End, Decision. Need to design algorithm: basically random flip problem: maintain list of available cells mapping to indices. Use mapping dictionary to track used indices. Use random from 0 to remain-1. Steps: init m,n, total m*n, mapping dict, remaining count. flip: pick rand in [0, remaining-1], get index = mapping.get(rand, rand); update mapping[ rand ] = mapping.get(remaining-1, remaining-1 ); decrement remaining; convert index to (i,j). reset: clear mapping, set remaining to total.\n\nNeed to describe each line: e.g., Start; → Step: initialize variables; etc. Provide explanation comment after //.\n\nAlso we need to show each line's virtual code. We can include steps with indent for Decision lines.\n\nWe must not output actual code. Just pseudocode steps.\n\nLet's produce step lines. Provide comments in Chinese. Let's include variable names like total, remaining, mapping, randIdx, idx, row, col. Provide decision logic for mapping existence.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 total = m * n // 计算总格数\n→ Step 2: 設定 remaining = total // 记录剩余未翻转格数\n→ Step 3: 初始化 mapping 為空字典 // 用於映射随机索引到實際位置\n→ Step 4: 结束初始化 // 完成构造函数\n\nflip():\nStart // flip 方法入口\n→ Step 1: 若 remaining == 0 → return null 或錯誤 // 所有格已翻转\n→ Step 2: 生成 randIdx = random(0, remaining - 1) // 随机选取未翻转索引\n→ Decision: 如果 mapping 中有 randIdx?\n    Yes → idx = mapping[randIdx] // 使用映射得到真实索引\n    No  → idx = randIdx // 直接使用随机索引\n→ Step 3: 取得 lastIdx = remaining - 1 // 最后未翻转格索引\n→ Decision: 如果 mapping 中有 lastIdx?\n    Yes → mapping[randIdx] = mapping[lastIdx] // 将最后格映射到 randIdx\n    No  → mapping[randIdx] = lastIdx // 直接赋值\n→ Step 4: 删除 mapping[lastIdx] // 解除映射，避免未来冲突\n→ Step 5:  remaining -= 1 // 更新剩余格数\n→ Step 6: 计算 row = idx / n // 行号\n→ Step 7: 计算 col = idx % n // 列号\n→ Step 8: 返回 [row, col] // 输出翻转位置\nEnd // flip 方法结束\n\nreset():\nStart // reset 方法入口\n→ Step 1: 清空 mapping // 删除所有映射\n→ Step 2: 設定 remaining = total // 恢复剩余格数\nEnd // reset 方法结束\n\nNeed to use format \"虛擬碼步驟 [空格] // 解釋\". So each line: \"Start // 程式開始執行\". \"→ Step 1: ...\" etc. For Decision lines we need indent and format: \"→ Decision: ...\". Use Yes → etc.\n\nLet's produce.\n\nAlso we must keep virtual code lines, not actual code. Use colon. Provide mapping variable names.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 total = m * n // 计算矩阵总格数\n→ Step 2: 設定 remaining = total // 记录剩余未翻转格数\n→ Step 3: 初始化 mapping 為空字典 // 用於映射随机索引到實際位置\n→ Step 4: 结束初始化 // 完成构造函数\n\nStart // flip 方法入口\n→ Step 1: 若 remaining == 0 → return null // 所有格已翻转\n→ Step 2: 生成 randIdx = random(0, remaining - 1) // 随机选取未翻转索引\n→ Decision: 如果 mapping 中有 randIdx?\n    Yes → idx = mapping[randIdx] // 使用映射得到真实索引\n    No  → idx = randIdx // 直接使用随机索引\n→ Step 3: 取得 lastIdx = remaining - 1 // 最后未翻转格索引\n→ Decision: 如果 mapping 中有 lastIdx?\n    Yes → mapping[randIdx] = mapping[lastIdx] // 将最后格映射到 randIdx\n    No  → mapping[randIdx] = lastIdx // 直接赋值\n→ Step 4: 删除 mapping[lastIdx] // 解除映射，避免未来冲突\n→ Step 5:  remaining -= 1 // 更新剩余格数\n→ Step 6: 计算 row = idx / n // 行号\n→ Step 7: 计算 col = idx % n // 列号\n→ Step 8: 返回 [row, col] // 输出翻转位置\nEnd // flip 方法结束\n\nStart // reset 方法入口\n→ Step 1: 清空 mapping // 删除所有映射\n→ Step 2: 設定 remaining = total // 恢复剩余格数\nEnd // reset 方法结束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp667wz5le.py\", line 64, in <module>\n    main()\n  File \"/tmp/tmp667wz5le.py\", line 51, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmp667wz5le.py\", line 17, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MagicDictionary:\n    \"\"\"\n    以集合方式存儲字典，搜尋時逐一比較字母差異數。\n    \"\"\"\n    def __init__(self):\n        # 直接存放所有單字的集合，方便快速檢查\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        \"\"\"\n        設置字典：把所有單字放進集合，保持唯一性。\n        \"\"\"\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        \"\"\"\n        判斷是否能改一個字元得到字典中的單字。\n        \"\"\"\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            # 計算兩字串不同的位置數量\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    # 讀取全部輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入包成元組，方便使用 literal_eval 解析\n    try:\n        ops, args = ast.literal_eval('(' + data + ')')\n    except Exception as e:\n        raise ValueError(\"輸入格式不正確\") from e\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)          # 對應 LeetCode 的 null\n        elif op == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)          # 對應 LeetCode 的 null\n        elif op == \"search\":\n            res = obj.search(arg)\n            results.append(res)\n        else:\n            # 若有其他操作，直接忽略或拋錯\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 讓 None 轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MagicDictionary with methods: constructor, buildDict, search. Provide pseudo-code line by line, with explanation. Use arrows, decision, etc. Ensure format. Let's design steps: store dictionary as list or hashset; also build patterns by replacing each char with wildcard to map possible words that differ by one. Approach: for each word, generate all patterns by replacing each position with '*', store mapping from pattern to original word count. In search, generate patterns and check if any pattern maps to at least one word different from the searchWord. Provide steps accordingly. Provide virtual code. Let's write.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立 MagicDictionary 物件 // 產生一個空的字典物件\n    → Init: patternMap ← 空字典 // 用來存放「通配模式 → 詞彙集合」\n→ Step 2: buildDict(dictionary) // 接收並處理字典資料\n    → Decision: dictionary 為空? // 若沒有字典資料則直接結束\n        No → Loop for each word in dictionary // 逐一處理每個詞\n            → Loop i from 0 to length(word)-1 // 為每個字元位置產生通配模式\n                → pattern ← word 之字元序列，將第 i 個字元改為 '*'\n                → Decision: pattern 已存在於 patternMap? // 是否已有此模式\n                    Yes → patternMap[pattern].Add(word) // 加入該詞到集合\n                    No  → patternMap[pattern] ← {word} // 新建集合並加入該詞\n→ Step 3: search(searchWord) // 查詢是否能改一個字元匹配字典\n    → Decision: searchWord 為空? // 空字串直接回傳 false\n        Yes → Return false\n    → Loop i from 0 to length(searchWord)-1 // 為每個位置產生通配模式\n        → pattern ← searchWord 的字元序列，將第 i 個字元改為 '*'\n        → Decision: pattern 是否在 patternMap? // 有無匹配模式\n            Yes → Loop word in patternMap[pattern] // 檢查該集合中每個詞\n                → Decision: word ≠ searchWord? // 必須不同才算「改一個字元」\n                    Yes → Return true // 找到符合條件的詞，返回成功\n            No  → Continue // 無此模式，檢查下一個位置\n    → Return false // 所有位置檢查完畢仍未找到符合條件\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Find K Closest Elements",
      "source_file": "Leetcode/leetcode658.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptrs4xxmw.py\", line 36, in <module>\n    main()\n  File \"/tmp/tmptrs4xxmw.py\", line 26, in main\n    exec(data, {}, ns)\n  File \"<string>\", line 1\n    arr = [1,2,3,4,5], k = 4, x = 3\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwmyk6bzy.py\", line 36, in <module>\n    main()\n  File \"/tmp/tmpwmyk6bzy.py\", line 26, in main\n    exec(data, {}, ns)\n  File \"<string>\", line 1\n    arr = [1,1,2,3,4,5], k = 4, x = -1\n    ^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        \"\"\"\n        Find the k closest elements to x in a sorted array arr.\n        Uses binary search to locate the left boundary of the window of size k.\n        \"\"\"\n        left, right = 0, len(arr) - k\n        while left < right:\n            mid = (left + right) // 2\n            # Compare distance from x to the two candidates at the ends of the window\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]\n\ndef main():\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Execute the input string in an isolated namespace to extract variables\n    ns = {}\n    exec(data, {}, ns)\n    arr = ns['arr']\n    k = ns['k']\n    x = ns['x']\n\n    sol = Solution()\n    result = sol.findClosestElements(arr, k, x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code. Steps: find first index using binary search. Then use two pointers to expand k. Return subarray. Need to explain each line. Use Start, End, Decision, Yes/No. Provide virtual steps. Let's design.\n\nStart\n→ Step 1: BinarySearchLowerBound(arr, x) // find leftmost index with value >= x\n→ Step 2: Initialize left = index - 1; right = index // pointers to left and right of x\n→ Step 3: Initialize result = empty list\n→ Step 4: While k > 0 // loop to pick k elements\n   Decision: left < 0? // check if left pointer out of bounds\n     Yes → TakeRight: result.append(arr[right]); right += 1\n     No →\n        Decision: right >= len(arr)? // check if right pointer out of bounds\n          Yes → TakeLeft: result.append(arr[left]); left -= 1\n          No →\n             Decision: abs(arr[left]-x) <= abs(arr[right]-x)? // compare distance\n                Yes → TakeLeft: result.append(arr[left]); left -= 1\n                No  → TakeRight: result.append(arr[right]); right += 1\n   k -= 1\n→ Step 5: Sort result ascending // ensure ascending order\n→ End\n\nBut we also need to sort result? Actually if we take from left and right we may not guarantee order. So we can gather into list then sort. Or we could build two lists and merge. Use result = sorted(result). Provide explanation.\n\nAlso we should mention that binary search returns insertion index.\n\nLet's write lines accordingly.\n\nEnsure each line includes \"虛擬碼步驟\" + \" // 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: BinarySearchLowerBound(arr, x) // 找到第一個值 ≥ x 的索引（插入位置）  \n→ Step 2: left = index - 1; right = index // 左指標在 x 左邊，右指標在 x 右邊  \n→ Step 3: result = [] // 用來存放選出的 k 個最接近 x 的數字  \n→ Step 4: While k > 0 // 重複挑選直到得到 k 個數字  \n&nbsp;&nbsp;Decision: left < 0? // 左指標已超出陣列左邊界？  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → result.append(arr[right]); right += 1 // 只能取右邊的數字  \n&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: right >= len(arr)? // 右指標已超出陣列右邊界？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → result.append(arr[left]); left -= 1 // 只能取左邊的數字  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: abs(arr[left]-x) <= abs(arr[right]-x)? // 比較兩邊距離  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → result.append(arr[left]); left -= 1 // 左邊更接近（或相等且更小）  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → result.append(arr[right]); right += 1 // 右邊更接近  \n&nbsp;&nbsp;k -= 1 // 已選一個，剩下需要挑選的數量減一  \n→ Step 5: result.sort() // 最後將選出的 k 個數字按升序排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpepov6vas.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpepov6vas.py\", line 37, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpepov6vas.py\", line 18, in __init__\n    self.lookup[key] = idx\n    ~~~~~~~~~~~^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass WordFilter:\n    def __init__(self, words):\n        # 建立前綴+後綴對應索引的查詢表\n        self.lookup = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            # 前綴長度從 0 (空字串) 到 L\n            for i in range(L + 1):\n                prefix = word[:i]\n                # 後綴長度從 0 到 L\n                for j in range(L + 1):\n                    suffix = word[j:]\n                    key = (prefix, suffix)\n                    # 只需要存儲最大索引\n                    self.lookup[key] = idx\n\n    def f(self, prefix, suffix):\n        # 直接查表，若不存在則回傳 -1\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    # 讀取整個輸入並去除首尾空白\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 以外層 [] 包覆，使整個輸入成為一個合法的 JSON 陣列\n    # 例如輸入: '[[\"apple\"]], [\"a\", \"e\"]' 會被轉成 [['apple'], ['a', 'e']]\n    data = json.loads('[' + raw + ']')\n\n    words = data[0]          # 第一個元素為單字清單\n    prefix, suffix = data[1] # 第二個元素為 [prefix, suffix]\n\n    wf = WordFilter(words)\n    result = wf.f(prefix, suffix)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for designing WordFilter class with prefix-suffix search, returning highest index. We need step-by-step algorithm. Provide virtual code lines with explanation. No actual code. Let's think algorithm: Build a trie of combined prefix and suffix? Typical solution uses hash map mapping combined prefix+suffix to max index. Or build a trie where each node holds max index of word with that prefix. For suffix, use reversed trie. But we can combine: For each word, for each possible prefix and suffix pair, store max index. But naive O(n * L^2). Efficient solution: Build a combined trie: For each word with index i, for each prefix length p, for each suffix length s, store key prefix + '#' + suffix -> i. But we need efficient queries. Use a trie that stores for each node the maximum index of word with that prefix. For suffix we need reversed trie and combine? Alternative: Use a map of combined string = prefix + '#' + suffix to max index. For query, need to look up that key. Complexity: building all pairs O(n L^2). But maybe acceptable? Provide algorithmic steps.\n\nSince user just needs virtual code steps, not complexity. We'll provide steps to implement WordFilter with combined map. Provide pseudocode steps: Build a dictionary map<string, int> mp; For each word with index i: for each prefix p (including whole word), for each suffix s (including whole word) create key = p + \"#\" + s; store mp[key] = max(mp[key], i). Then query: key = pref + \"#\" + suff; return mp[key] if exists else -1.\n\nAlso we may include a more efficient approach using trie: but maybe simpler.\n\nLet's produce virtual code: Start, Step 1: Initialize map, Step 2: For each word with index, Step 3: Generate prefixes, Step 4: Generate suffixes, Step 5: Store key. Then f function: build key and look up.\n\nLet's produce with virtual code lines: Start, -> Step 1: WordFilter(words) // constructor // Step 2: For each word, index // etc.\n\nLet's write in structured format. Use arrow for decision? Not needed but we can include decision when key not found.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: WordFilter(words) // 建構 WordFilter 物件，傳入單字列\n    → Step 2: mp ← EmptyMap // 建立空的映射表，鍵為「前綴#後綴」，值為最大索引\n    → Decision: 迴圈遍歷每個單字及其索引\n        Yes → Step 3: For i from 0 to words.length-1\n            → Step 4: word ← words[i] // 取得目前單字\n            → Step 5: preLen ← word.length // 單字長度\n            → Step 6: preList ← EmptyList // 儲存所有前綴\n            → Step 7: For p from 1 to preLen\n                → Step 8: pre ← substring(word, 0, p) // 取得前 p 個字\n                → Step 9: preList.append(pre) // 加入前綴列表\n            → Step 10: sufLen ← word.length // 同樣取得後綴長度\n            → Step 11: sufList ← EmptyList // 儲存所有後綴\n            → Step 12: For s from 1 to sufLen\n                → Step 13: suf ← substring(word, word.length - s, s) // 取得最後 s 個字\n                → Step 14: sufList.append(suf) // 加入後綴列表\n            → Step 15: For each pre in preList\n                → Step 16: For each suf in sufList\n                    → Step 17: key ← pre + \"#\" + suf // 組合鍵\n                    → Decision: key 是否已存在於 mp\n                        Yes → Step 18: mp[key] ← max(mp[key], i) // 儲存更大的索引\n                        No  → Step 19: mp[key] ← i // 建立新鍵\n    → End // 建構完成\n\n→ Step 20: f(pref, suff) // 查詢前綴 pref 與後綴 suff 的最大索引\n    → Step 21: key ← pref + \"#\" + suff // 組合查詢鍵\n    → Decision: key 是否存在於 mp\n        Yes → Step 22: return mp[key] // 回傳最大索引\n        No  → Step 23: return -1 // 找不到符合條件的單字\nEnd // 程式執行結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd3wsqtps.py\", line 41, in main\n    parsed_val = ast.literal_eval(val)\n                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpd3wsqtps.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmpd3wsqtps.py\", line 44, in main\n    parsed_val = int(val)\n                 ^^^^^^^^\nValueError: invalid literal for int() with base 10: '[1'"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6vbqlrb4.py\", line 41, in main\n    parsed_val = ast.literal_eval(val)\n                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp6vbqlrb4.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmp6vbqlrb4.py\", line 44, in main\n    parsed_val = int(val)\n                 ^^^^^^^^\nValueError: invalid literal for int() with base 10: '[1'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k, W, Profits, Capital):\n        # 將專案按最低資本排序\n        projects = sorted(zip(Capital, Profits))\n        max_heap = []           # 儲存可執行專案的利潤（取最大）\n        i = 0                   # 目前已加入 heap 的專案索引\n        n = len(Profits)\n\n        for _ in range(k):\n            # 把所有可負擔的專案都加入最大堆\n            while i < n and projects[i][0] <= W:\n                heapq.heappush(max_heap, -projects[i][1])  # 用負值模擬最大堆\n                i += 1\n            if not max_heap:\n                break            # 沒有可執行專案，提前結束\n            # 取最大利潤，更新資本\n            W += -heapq.heappop(max_heap)\n        return W\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 解析「key = value」形式的輸入\n    parts = [p.strip() for p in raw_input.split(',') if p.strip()]\n    data = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        try:\n            # 先嘗試解析為字面量（列表、整數等）\n            parsed_val = ast.literal_eval(val)\n        except Exception:\n            # 若無法解析，假設為整數\n            parsed_val = int(val)\n        data[key] = parsed_val\n\n    k = data.get('k')\n    w = data.get('w')\n    profits = data.get('profits')\n    capital = data.get('capital')\n\n    # 呼叫解法並輸出結果\n    result = Solution().findMaximizedCapital(k, w, profits, capital)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code for algorithm: LeetCode maximum capital. Classic problem: choose k projects with profit >0, use priority queues sorted by capital and profit. Approach: sort projects by capital ascending. Use max-heap for profit. Iterate. Steps: sort, maintain index, push eligible, pop max profit up to k. Use w initial capital. So produce steps.\n\nWe need to output in lines with virtual code and comment. Each line: \"虛擬碼步驟 // 解釋\". Use arrow and Decision etc.\n\nLet's design steps:\n\nStart\n→ Step 1: 定義 Project 為 (capital, profit) // 兩個屬性\n→ Step 2: 將所有 project 按 capital 升序排序 // 方便一次性加入可選項\n→ Step 3: 初始化 max-heap 儲存 profit // 取最大 profit\n→ Step 4: 初始化 idx = 0 // 目前已處理的 project 索引\n→ Step 5: for i in 1..k:\n    → Decision: 是否還有可加入的 project? // 檢查 idx < n\n        Yes → Loop:\n            → Decision: project[idx].capital <= current capital? // 是否可執行\n                Yes → Step 6: push project[idx].profit 到 max-heap\n                    → idx += 1\n                    → 回到這個 Decision\n                No → Step 7: 如果 heap 為空? // 沒有可做的\n                    → End? 或 break\n        No → break // 所有 project 已處理\n    → Decision: max-heap 为空? // 無可做項目\n        Yes → break // 無法再增加資本\n        No  → Step 8: pop max profit from heap\n                → Step 9: current capital += popped profit\n→ End // 返回 current capital\n\nNeed to produce virtual code line by line with arrows etc. Use \"Decision:\" lines. For loops we can represent as \"Step 5: for i = 1 to k\" but need arrow after. Provide details.\n\nLet's craft lines.\n\nWe need to include \"Start\" and \"End\". Use \"→\" arrow.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 Project 陣列並存入 (capital, profit) // 定義項目結構\n→ Step 2: 將 projects 按 capital 升序排序 // 方便一次性篩選可執行項目\n→ Step 3: 初始化 max-heap profitHeap // 儲存可選項目的利潤，方便取最大\n→ Step 4: 初始化 idx = 0 // 指向未處理項目的索引\n→ Step 5: 初始化 currentCapital = w // 起始資本\n→ Step 6: for i = 1 to k: // 允許執行至多 k 個項目\n    → Decision: idx < n? // 是否還有未處理項目\n        Yes → Step 7: while idx < n and projects[idx].capital <= currentCapital:\n            → Step 8: push projects[idx].profit 到 profitHeap // 加入可做的項目\n            → Step 9: idx += 1 // 移動到下一個項目\n            → 回到 while 條件\n        No  → // 所有項目已處理\n    → Decision: profitHeap.isEmpty()? // 是否有可選的利潤\n        Yes → Step 10: break // 沒有項目可執行，結束\n        No  → Step 11: pop maxProfit from profitHeap // 取最大利潤\n            → Step 12: currentCapital += maxProfit // 資本加上利潤\n→ End // 程式執行結束，currentCapital 為最大化資本\n\nBut we must maintain each line as \"虛擬碼步驟 // 解釋\" with single space after. Use \"→\" arrow per step. For nested steps, indent with spaces maybe but not required. Use \"Decision:\" lines. Each line after arrow and maybe indent.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Project 陣列並存入 (capital, profit) // 定義項目結構  \n→ Step 2: 將 projects 按 capital 升序排序 // 方便一次性篩選可執行項目  \n→ Step 3: 初始化 max-heap profitHeap // 儲存可選項目的利潤，方便取最大  \n→ Step 4: 初始化 idx = 0 // 指向未處理項目的索引  \n→ Step 5: 初始化 currentCapital = w // 起始資本  \n→ Step 6: for i = 1 to k: // 允許執行至多 k 個項目  \n → Decision: idx < n? // 是否還有未處理項目  \n  Yes → Step 7: while idx < n and projects[idx].capital <= currentCapital:  \n    → Step 8: push projects[idx].profit 到 profitHeap // 加入可做的項目  \n    → Step 9: idx += 1 // 移動到下一個項目  \n    → 回到 while 條件  \n  No → // 所有項目已處理  \n → Decision: profitHeap.isEmpty()? // 是否有可選的利潤  \n  Yes → Step 10: break // 沒有項目可執行，結束  \n  No  → Step 11: pop maxProfit 從 profitHeap // 取最大利潤  \n    → Step 12: currentCapital += maxProfit // 資本加上利潤  \n→ End // 程式執行結束，currentCapital 為最大化資本"
    },
    {
      "title": "My Calendar III",
      "source_file": "Leetcode/leetcode732.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprzuusx6u.py\", line 35, in <module>\n    ops, args = json.loads(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 68 (char 67)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict\n\nclass MyCalendarThree:\n    \"\"\"MyCalendarThree 允許在給定時間段上進行預約，並能即時回傳目前最大的同時預約數量。\"\"\"\n    def __init__(self):\n        # time_delta 存儲每個時間點的變化量 (+1 代表開始，-1 代表結束)\n        self.time_delta = defaultdict(int)\n\n    def book(self, start, end):\n        \"\"\"新增一段時間區間，並回傳目前最大同時預約數。\"\"\"\n        # 在開始時間加入 +1，結束時間加入 -1\n        self.time_delta[start] += 1\n        self.time_delta[end] -= 1\n\n        current = 0       # 目前同時預約數\n        max_concurrent = 0  # 最大同時預約數\n\n        # 按時間升序遍歷所有時間點，累加變化量\n        for time in sorted(self.time_delta):\n            current += self.time_delta[time]\n            if current > max_concurrent:\n                max_concurrent = current\n\n        return max_concurrent\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容，並解析成兩個列表：操作名稱與對應參數\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    ops, args = json.loads(raw_input)\n\n    results = []\n    calendar = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendarThree\":\n            calendar = MyCalendarThree()\n            results.append(None)          # 代表 constructor，輸出為 null\n        else:\n            # 使用 getattr 動態調用相應的方法\n            method = getattr(calendar, op)\n            results.append(method(*arg))\n\n    # 使用 json.dumps 以符合題目輸出格式（None 會轉成 null）\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code with line-by-line steps. It's a problem: MyCalendarThree: need to support book intervals and return maximum concurrent bookings. Typical solution uses sweep line with map of time points increments/decrement. Virtual code: maintain sorted map of time -> delta. For book(start, end): add delta+1 at start, -1 at end. Then iterate through sorted times accumulate current, track max.\n\nWe need to produce pseudocode lines. Must follow format: each line: virtual code step [space] // explanation. Use Start, End, Decision, arrows.\n\nWe'll show initialization, book function, internal logic. Provide step-by-step.\n\nLet's produce.\n\nNeed to incorporate Start of class, then book function, inside use map. Show decisions: check map, iterate.\n\nLet's craft.\n\nUse virtual code: \"Start MyCalendarThree // initialize\" etc.\n\nLet's generate.\n...done thinking.\n\nStart MyCalendarThree // 初始化 MyCalendarThree 物件\n→ Step 1: 建立空的平衡樹或字典 timeDelta // 用於存儲每個時間點的變化量\n→ End MyCalendarThree // 初始化結束\n\nStart book(startTime, endTime) // 呼叫 book 方法開始新增事件\n→ Step 2: timeDelta[startTime] = timeDelta.get(startTime, 0) + 1 // 在開始時間增加 1 份佔用\n→ Step 3: timeDelta[endTime] = timeDelta.get(endTime, 0) - 1 // 在結束時間減少 1 份佔用\n\n→ Step 4: current = 0 // 記錄目前同時佔用的事件數\n→ Step 5: maxConcurrent = 0 // 記錄歷史最高佔用數\n\n→ Decision: 遍歷 timeDelta 按時間排序? // 為了正確累加，需要按時間升序遍歷\n    Yes → Step 6: for each (time, delta) in timeDelta sorted by time:\n        → Step 7: current = current + delta // 累加變化量得到此時間點的佔用數\n        → Step 8: maxConcurrent = max(maxConcurrent, current) // 更新最大佔用數\n    No  → Step 9: // 若時間點已排序，直接執行 Step 6\n→ End book // book 方法結束\n\n→ Step 10: return maxConcurrent // 回傳目前最大 k-booking 數值\n\nEnd MyCalendarThree // MyCalendarThree 類別結束。"
    },
    {
      "title": "Solve the Equation",
      "source_file": "Leetcode/leetcode640.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equation = \"x+5-3+x=6+x-2\"",
          "expected_output": "x=2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'x=2'\nGot (Norm):      'x=-2'\n--- (Raw) ---\nRaw Expected: 'x=2'\nRaw Got:      'x=-2'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def solveEquation(self, equation: str) -> str:\n        def parse_side(s: str):\n            x_coeff, const = 0, 0\n            i, n, sign = 0, len(s), 1\n            while i < n:\n                if s[i] == '+':\n                    sign = 1\n                    i += 1\n                elif s[i] == '-':\n                    sign = -1\n                    i += 1\n                else:\n                    j = i\n                    while j < n and s[j] not in '+-':\n                        j += 1\n                    token = s[i:j]\n                    if 'x' in token:\n                        coeff_part = token[:-1]\n                        if coeff_part == '' or coeff_part == '+':\n                            coeff = 1\n                        elif coeff_part == '-':\n                            coeff = -1\n                        else:\n                            coeff = int(coeff_part)\n                        x_coeff += sign * coeff\n                    else:\n                        const += sign * int(token)\n                    i = j\n            return x_coeff, const\n\n        left, right = equation.split('=')\n        left_x, left_const = parse_side(left)\n        right_x, right_const = parse_side(right)\n\n        total_x = left_x - right_x\n        total_const = right_const - left_const\n\n        if total_x == 0:\n            if total_const == 0:\n                return \"Infinite solutions\"\n            else:\n                return \"No solution\"\n        else:\n            return f\"x={-total_const // total_x}\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，支援 'equation = \"...\"' 或直接輸入方程式\n    if 'equation' in data:\n        _, eq_part = data.split('=', 1)\n        equation = eq_part.strip().strip('\"').strip(\"'\")\n    else:\n        equation = data\n\n    solution = Solution()\n    result = solution.solveEquation(equation)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The problem: solving linear equation with only +, -, variable x, coefficient. Input is equation string. We need to parse, compute coefficient of x and constant terms. Solve ax + b = 0. Return string.\n\nWe produce virtual pseudocode lines with explanation. Must use structure Start, End, Decision, arrow.\n\nWe need to consider: if coefficient of x = 0: if constant term also zero -> infinite solutions. else no solution.\n\nIf coefficient != 0 -> compute x = -b / a, integer guaranteed.\n\nReturn \"x=#value\".\n\nLet's produce step by step: Start, Input equation string, parse into tokens? Let's outline: Step 1: Initialize coeffX=0, constTerm=0. Step 2: Split equation by '=' into left and right. Step 3: For each side, parse terms: each term is optionally sign, coefficient number (maybe omitted 1), variable 'x' maybe present. We'll accumulate left side as terms with sign; right side similarly but we subtract when moving to left.\n\nSimplify: Convert equation to standard form: left - right = 0. So we can compute net coeffX, constTerm.\n\nImplementation: function parseSide(side, signMultiplier) where signMultiplier is 1 for left, -1 for right? Actually left side terms keep sign as given, right side terms move to left, so subtract them.\n\nSimplify: We parse each side, and for each term: if term contains 'x' then add coeff * sign * signMultiplier to coeffX else add number * sign * signMultiplier to constTerm.\n\nParsing: terms separated by '+' or '-'. We can add leading '+' to start for uniform.\n\nOk.\n\nNow after computing coeffX and constTerm, Decision: If coeffX == 0 then Decision: If constTerm == 0 -> Infinite solutions else No solution. Else compute solution = -constTerm / coeffX.\n\nReturn string \"x=\" + solution.\n\nWe need to output lines with // explanation.\n\nLet's produce each step as virtual code lines.\n\nStart // 程式開始執行\n\n→ Step 1: Input equation string // 從使用者取得方程式字串\n\n→ Step 2: Initialize coeffX = 0, constTerm = 0 // 用於累計 x 的係數與常數項\n\n→ Step 3: Split equation by '=' into leftPart, rightPart // 把等式左右兩邊分開\n\n→ Step 4: Define function parseSide(side, multiplier) // 用於解析單側的項目，multiplier 為 1（左側）或 -1（右側，移到左側）\n\n→ Step 5: Within parseSide: Prepend '+' to side if it doesn't start with '+' or '-' // 方便後續按符號拆分\n\n→ Step 6: Split side by '+' and '-' (keeping signs) into termList // 取得所有項目\n\n→ Step 7: For each term in termList: // 逐項處理\n\n   → Step 7.1: If term contains 'x' then\n\n     → Step 7.1.1: Extract coefficient (default 1 if empty) // 取得 x 的係數\n\n      → Step 7.1.2: coeffX += multiplier * coefficient // 累加到總係數\n\n    → Step 7.2: Else\n\n      → Step 7.2.1: constTerm += multiplier * integer(term) // 累加到常數項\n\n→ Step 8: Call parseSide(leftPart, +1) // 解析左側項目\n\n→ Step 9: Call parseSide(rightPart, -1) // 解析右側項目並移到左側\n\n→ Step 10: Decision: 如果 coeffX == 0? // 檢查 x 的總係數是否為 0\n\n   Yes → Decision: 如果 constTerm == 0? // 檢查常數項是否也為 0\n\n     Yes → Step 11: Output \"Infinite solutions\" // 無限多解\n\n     No → Step 12: Output \"No solution\" // 無解\n\n   No → Step 13: Compute solution = -constTerm / coeffX // 求解 x，結果為整數\n\n     → Step 14: Output \"x=\" + solution // 回傳解\n\nEnd // 程式執行結束\n\nWe need each line with arrow as shown. For nested decisions we indent with spaces or tabs? In example they used indentation with spaces. We'll use indentation with 4 spaces for nested levels.\n\nAlso each line must have virtual code step and // explanation. Ensure no actual code output.\n\nLet's format. Use arrow '→' for each step except Start/End. Indent decision branches.\n\nWe must ensure each line includes explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入方程式字串 // 從使用者取得方程式字串\n→ Step 2: 初始化 coeffX = 0, constTerm = 0 // 用於累計 x 的係數與常數項\n→ Step 3: 將方程式以 '=' 分割為 leftPart 與 rightPart // 把等式左右兩邊分開\n→ Step 4: 定義函式 parseSide(side, multiplier) // 用於解析單側項目，multiplier 為 1（左側）或 -1（右側移到左側）\n  → Step 5: 若 side 不以 '+' 或 '-' 開頭，則在前面加上 '+' // 方便後續按符號拆分\n  → Step 6: 把 side 按 '+' 和 '-' 拆分成 termList，保留符號 // 取得所有項目\n  → Step 7: 對 termList 中的每個 term 進行處理\n    → Step 7.1: 若 term 包含 'x' 則\n      → Step 7.1.1: 擷取係數（若空白則為 1） // 取得 x 的係數\n      → Step 7.1.2: coeffX += multiplier * 係數 // 累加到總係數\n    → Step 7.2: 否則\n      → Step 7.2.1: constTerm += multiplier * 整數(term) // 累加到常數項\n→ Step 8: 呼叫 parseSide(leftPart, +1) // 解析左側項目\n→ Step 9: 呼叫 parseSide(rightPart, -1) // 解析右側項目並移到左側\n→ Step 10: Decision: 如果 coeffX == 0? // 檢查 x 的總係數是否為 0\n   Yes → Decision: 如果 constTerm == 0? // 檢查常數項是否也為 0\n     Yes → Step 11: 輸出 \"Infinite solutions\" // 無限多解\n     No → Step 12: 輸出 \"No solution\" // 無解\n   No → Step 13: 計算 solution = -constTerm / coeffX // 求解 x，結果為整數\n     → Step 14: 輸出 \"x=\" + solution // 回傳解\nEnd // 程式執行結束"
    },
    {
      "title": "Isomorphic Strings",
      "source_file": "Leetcode/leetcode205.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"foo\", t = \"bar\"",
          "expected_output": "false",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'false'\nGot (Norm):      'true'\n--- (Raw) ---\nRaw Expected: 'false'\nRaw Got:      'true'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        mapping_s_t = {}\n        mapping_t_s = {}\n        for c1, c2 in zip(s, t):\n            if c1 in mapping_s_t and mapping_s_t[c1] != c2:\n                return False\n            if c2 in mapping_t_s and mapping_t_s[c2] != c1:\n                return False\n            mapping_s_t[c1] = c2\n            mapping_t_s[c2] = c1\n        return True\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，去除可能的引號、逗號，並分割成字串\n    raw = sys.stdin.read()\n    if not raw:\n        sys.exit(0)\n    # 去除雙引號、單引號、逗號\n    cleaned = raw.replace('\"', '').replace(\"'\", '').replace(',', ' ')\n    parts = cleaned.split()\n    if len(parts) < 2:\n        # 若輸入只有一行但包含逗號分隔的兩個字串\n        parts = raw.replace('\"', '').replace(\"'\", '').replace(',', ' ').split()\n    s, t = parts[0], parts[1]\n    solution = Solution()\n    result = solution.isIsomorphic(s, t)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for checking if two strings are isomorphic. We need to do step by step: start, check length, use maps, iterate, check mapping consistency, ensure no duplicate mapping. Use arrow notation. Provide explanation each line. No actual code. Just virtual steps.\n\nWe need to handle two maps: char->char mapping from s to t, and reverse mapping to ensure uniqueness.\n\nPseudo steps: Start, input s, t, if lengths differ then not isomorphic, else iterate over indices, for each char s[i] and t[i], check if mapping exists: if not, ensure t[i] not already mapped from another char, then set mapping; else check consistency. After loop, End. Also if any mismatch return false.\n\nWe'll produce steps with \"Step 1: Check length equality\". Then \"Decision: If lengths differ\" etc.\n\nMake sure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得兩個字串 s 與 t // 從使用者輸入或參數取得字串  \n→ Decision: 若 |s| ≠ |t|? // 若長度不同，兩者不可能是同構  \n    Yes → Step 2: 輸出 false // 直接判斷非同構  \n    No  → Step 3: 建立空映射 mapST 和 mapTS // mapST 用於 s→t，mapTS 用於 t→s  \n→ Step 4: 設定索引 i ← 0 // 用於逐字元遍歷  \n→ Decision: i < |s|? // 是否還有未處理的字元  \n    Yes → Step 5: 取得 char a ← s[i], char b ← t[i] // 讀取對應位置的字元  \n    → Decision: a 已映射於 mapST? // 查看 s 中該字元是否已有對應  \n        Yes → Step 6: 若 mapST[a] ≠ b? // 若映射不一致，則不同構  \n                Yes → Step 7: 輸出 false  \n                No  → Step 8: i ← i + 1 → 迴圈繼續  \n        No  → Step 9: Decision: b 已映射於 mapTS? // 檢查 t 中此字元是否已被其他 s 字元映射  \n            Yes → Step 10: 輸出 false // 兩個 s 字元映射到同一個 t 字元，違反唯一性  \n            No  → Step 11: 設定 mapST[a] ← b 並且 mapTS[b] ← a // 建立雙向映射  \n            → Step 12: i ← i + 1 → 迴圈繼續  \n    No  → Step 13: 輸出 true // 所有字元均符合同構規則  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"\n    這個類別用來在一個整數陣列中，隨機挑選目標值的索引。\n    建構子會把每個數字對應到它所有索引的清單，方便之後快速取得。\n    \"\"\"\n    def __init__(self, nums):\n        # 以字典來儲存每個數字對應到的索引清單\n        self.num_indices = defaultdict(list)\n        for idx, num in enumerate(nums):\n            self.num_indices[num].append(idx)\n\n    def pick(self, target):\n        \"\"\"\n        隨機返回一個 nums[i] == target 的索引。\n        只要 target 存在，所有符合條件的索引都有相同機率被選中。\n        \"\"\"\n        # 直接從字典取得所有對應索引\n        indices = self.num_indices[target]\n        # 隨機挑選其中一個索引\n        return random.choice(indices)\n\ndef main():\n    # 讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入為 (operations, arguments) 的 tuple\n    # 例如: '[\"Solution\",\"pick\"], [[1,2],[3]]' 會被轉成\n    # (['Solution','pick'], [[1,2],[3]])\n    ops, args = ast.literal_eval('(' + data + ')')\n\n    outputs = []\n    solution_obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 建構子可能接收一個列表，裡面又是一個列表\n            nums = arg[0] if isinstance(arg, list) and arg and isinstance(arg[0], list) else arg\n            solution_obj = Solution(nums)\n            outputs.append(None)          # 按題目要求輸出 null\n        elif op == \"pick\":\n            target = arg[0] if isinstance(arg, list) else arg\n            outputs.append(solution_obj.pick(target))\n        else:\n            # 如有其他操作，略過\n            pass\n\n    # 輸出結果，將 None 轉成 JSON 的 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The requirement: We need to describe algorithm: store mapping from number to list of indices, pick random. Steps: Start, constructor, build map, pick method, random selection. Use Decision, etc. Provide each line virtual code + explanation. Format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's produce code for class Solution. Use Start/End. Provide steps. We'll include decisions: target exists. We'll use mapping. Use Random. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 mapping 為 Map<Integer, List<Integer>> // 建立一個字典來儲存每個數值對應的所有索引  \n→ Step 2: 定義變數 rng 為 Random // 建立隨機數產生器  \n→ Decision: 如果進入建構子 (Solution(nums))? // 判斷是否執行建構子初始化  \n  Yes → Step 3: 對 nums 逐一遍歷，對於每個索引 i 和對應值 val  \n    → Decision: mapping 是否已包含 val? // 檢查字典中是否已有此數值的索引清單  \n     Yes → Step 4: 將 i 加入 mapping[val] 的列表 // 把索引加入已有清單  \n     No  → Step 5: 建立新列表 list，將 i 加入，並把 list 存入 mapping[val] // 新數值，創建索引清單  \n→ End // 建構子初始化完成  \n→ Decision: 如果進入 pick(target) 方法? // 判斷是否執行 pick 方法  \n  Yes → Step 6: 從 mapping 取得 list = mapping[target] // 取得所有對應目標值的索引清單  \n    → Decision: list 是否為空? // 檢查是否存在對應索引（理論上不會為空）  \n     Yes → Step 7: 回傳 -1 // 如果為空，回傳錯誤碼（備用情況）  \n     No  → Step 8: 計算 n = list.size() // 索引清單長度  \n     → Step 9: 產生 randIndex = rng.nextInt(n) // 產生 0~n-1 的隨機整數  \n     → Step 10: 回傳 list.get(randIndex) // 回傳對應的隨機索引  \n→ End // 程式執行結束\n\n---  \n\n此虛擬碼流程展示了如何在建構時建立數值到索引的映射，並在 pick 方法中以等概率選取對應索引。"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[1,0],[0,1],[0,1],[1,0],[3,2],[2,4]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[1, 0], [0, 1], [0, 1], [1, 0], [3, 2], [2, 4]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1],[0,1],[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1], [0, 1], [1, 0]]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[0,1],[1,0],[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[0, 1], [1, 0], [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        \"\"\"\n        找出所有字串拼接為迴文的索引對\n        \"\"\"\n        # 建立 word -> index 的字典，方便 O(1) 查找\n        index_map = {word: i for i, word in enumerate(words)}\n        res = []\n\n        # 若存在空字串，特殊處理\n        empty_idx = index_map.get(\"\")\n        if empty_idx is not None:\n            for i, word in enumerate(words):\n                if i == empty_idx:\n                    continue\n                if word == word[::-1]:\n                    res.append([i, empty_idx])  # word + \"\"\n                    res.append([empty_idx, i])  # \"\" + word\n\n        for i, word in enumerate(words):\n            word_len = len(word)\n            # 對於每一個切割位置，分成 left + right\n            for cut in range(word_len + 1):\n                left, right = word[:cut], word[cut:]\n\n                # 情況 1：左半邊為回文，則可把右半邊的倒序放在前面\n                if left == left[::-1]:\n                    rev_right = right[::-1]\n                    j = index_map.get(rev_right)\n                    if j is not None and j != i:\n                        res.append([j, i])  # (j, i)\n\n                # 情況 2：右半邊為回文，且 cut != 0（避免重複處理完整字串）\n                if cut != 0 and right == right[::-1]:\n                    rev_left = left[::-1]\n                    j = index_map.get(rev_left)\n                    if j is not None and j != i:\n                        res.append([i, j])  # (i, j)\n\n        return res\n\n\ndef main():\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析輸入，例如 'words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]'\n    # 先移除前綴，取等號右邊\n    try:\n        _, expr = raw.split('=', 1)\n    except ValueError:\n        # 若格式不符合，直接嘗試解析整個輸入\n        expr = raw\n    words = ast.literal_eval(expr.strip())\n\n    sol = Solution()\n    pairs = sol.palindromePairs(words)\n    print(pairs)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm O(total length). Known solution: iterate over words, store map of word to index. For each word, reverse it and check if reverse exists. Also check prefixes/suffixes for palindrome. Steps: build map, then for each word, loop through splits, etc. Provide pseudocode line by line with comments.\n\nWe need to output as per format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrows.\n\nWe'll produce algorithm steps. Provide high-level loops. Use pseudo.\n\nLet's craft.\n\nStart // program start\n\n→ Step 1: Build map of reversed words? Actually typical: map from word to index.\n\n→ Step 2: Initialize result list.\n\n→ For each word index i in words: loop.\n\n→ Inside loop, for each split position from 0 to len(word): left, right.\n\n→ Check if left is palindrome: then reverse(right) in map and index not equal; add pair (map[revRight], i).\n\n→ Check if right is palindrome and split>0: reverse(left) in map; add (i, map[revLeft]).\n\nAlso handle full reverse: same as left=full, right empty.\n\nAlso handle case of empty string: if empty present, all palindromes.\n\nWe'll structure with Decision lines.\n\nLet's craft.\n\nRemember to include arrow lines like \"→ Step: ...\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 map 以 word 為鍵、索引為值，方便 O(1) 查找 // 建構字典，鍵為單字，值為其在陣列中的索引  \n→ Step 2: 建立結果清單 pairs = [] // 用於儲存所有符合條件的 (i, j) 對  \n→ Decision: 是否存在空字串？ // 判斷是否需要特殊處理空字串  \n Yes → Step 3: 找出空字串的索引 emptyIdx  \n  → Decision: 空字串是否存在？ // 只有在 map 內有 \"\" 時才進行以下操作  \n   Yes → For each index k, word in words  \n     Decision: k != emptyIdx? // 排除自己  \n      Yes → If word is palindrome?  \n        → Step 4: Append (k, emptyIdx) to pairs // 空字串 + palindrome  \n        → Step 5: Append (emptyIdx, k) to pairs // palindrome + 空字串  \n      No → No action  \n   No → No action  \n→ For each index i, word in words // 逐一處理每個單字  \n  → Step 6: 令 wordLen = len(word)  \n  → For splitPos from 0 to wordLen // 包含全長，以便處理完整字串與空字串的拆分  \n    → Step 7: left = word[0:splitPos]，right = word[splitPos:] // 取得左半、右半字串  \n    → Decision: left 是否為 palindrome? // 若左半是回文，右半可以倒轉為前綴  \n     Yes → Step 8: revRight = reverse(right)  \n      → Decision: revRight 是否在 map 且 map[revRight] != i?  \n       Yes → Step 9: Append (map[revRight], i) to pairs // (j, i) 的回文對  \n       No → No action  \n     No → No action  \n    → Decision: splitPos > 0 且 right 是否為 palindrome? // 若右半是回文，左半可以倒轉為後綴  \n     Yes → Step 10: revLeft = reverse(left)  \n      → Decision: revLeft 是否在 map 且 map[revLeft] != i?  \n       Yes → Step 11: Append (i, map[revLeft]) to pairs // (i, j) 的回文對  \n       No → No action  \n     No → No action  \n→ End // 程式執行結束，pairs 為所有符合條件的回文對集合"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef longest_uncommon_subsequence(strs):\n    \"\"\"\n    找到長度最大的「不常見子序列」。\n    只要有一個字串在整個陣列中只出現一次，整個字串就一定是\n    不常見子序列；若所有字串都至少重複一次，就不存在不常見子序列。\n    \"\"\"\n    if not strs:          # 空陣列直接回傳 -1\n        return -1\n\n    # 計算每個字串的出現次數\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n\n    max_len = -1\n    for s in strs:\n        if freq[s] == 1:        # 只出現一次才可能是答案\n            max_len = max(max_len, len(s))\n\n    return max_len\n\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入，去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    # 解析成 Python 列表，輸入類似 '[\"aba\",\"cdc\",\"eae\"]'\n    try:\n        strs = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，直接回傳 -1\n        print(-1)\n        sys.exit(0)\n\n    # 確保輸入是 list of str\n    if not isinstance(strs, list) or not all(isinstance(x, str) for x in strs):\n        print(-1)\n        sys.exit(0)\n\n    result = longest_uncommon_subsequence(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm: find longest uncommon subsequence length. Approach: For each string, if it does not appear equal to any other string, answer length of that string. else -1. Explanation: Because any uncommon subsequence must be whole string if no duplicates. If duplicates, impossible. So algorithm: iterate over strings, if string unique, track max length. If max >0 return else -1.\n\nWe need to output lines: Start, etc. Use Decision nodes. Provide explanation after each line. Use 虛擬碼 arrow and structure. Let's craft.\n\nStart\n→ Step 1: Initialize maxLen = -1 // 設定最大長度為 -1\n→ Step 2: 取得字符串陣列 strs // 獲取輸入陣列\n→ Decision: 迭代每個字符串 s in strs? // 遍歷陣列\n    Yes → Step 3: 檢查 s 在 strs 中是否唯一 // 判斷是否有重複\n        → Decision: 有重複? // 是否存在相同字符串\n            Yes → Step 4: 跳過此 s // 不是唯一，無法成為不常見子序列\n            No  → Step 5: 更新 maxLen = max(maxLen, len(s)) // 更新最大長度\n→ Step 6: 回傳 maxLen // 返回結果\n\nBut need to output more detailed steps. Also need to handle duplicates check: count occurrences.\n\nLet's produce final virtual code.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 maxLen = -1 // 初始化最長不常見子序列長度，-1 代表尚未找到\n→ Step 2: 取得輸入陣列 strs // 從使用者處取得字符串列表\n→ Decision: 為每個字符串 s 在 strs 內部迭代? // 準備逐一檢查每個字串\n    Yes → Step 3: 計算 s 在 strs 中的出現次數 count(s) // 判斷該字串是否重複\n        → Decision: count(s) > 1? // 是否存在相同的字串\n            Yes → Step 4: 跳過此 s // 重複字串不能成為不常見子序列\n            No  → Step 5: 更新 maxLen = max(maxLen, len(s)) // 若唯一，考慮其長度為候選答案\n→ Step 6: 回傳 maxLen // 返回最長長度或 -1 若未找到符合條件\nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef parse_input():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return []\n    if '=' in raw:\n        _, rhs = raw.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = raw\n    try:\n        nums = eval(rhs, {}, {})\n    except Exception:\n        nums = []\n    return nums\n\nif __name__ == \"__main__\":\n    nums = parse_input()\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate a virtual code step-by-step that solves the problem: return all permutations of array nums. We must output step-by-step virtual code lines with explanation, following the format. Use Start, End, Decision, etc. Use arrows. For each line: \"虛擬碼步驟 // 解釋/說明\". Provide each step. Should be in Chinese (繁體). Must not output actual code, just pseudo-code steps.\n\nWe need to provide algorithm: backtracking. Steps: Start, initialize result list, define backtrack function, call it, return result.\n\nWe need to show steps. Use arrows: →. For decisions: Decision: If remaining numbers? etc.\n\nWe must follow format: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use Start, End, Decision. Let's construct:\n\nStart // 程式開始執行\n→ Step 1: 建立空的結果清單 result // 用於儲存所有排列\n→ Step 2: 定義遞迴函式 backtrack(current, remaining) // current 為目前排列，remaining 為未使用的數字\n→ Decision: 如果 remaining 為空? // 檢查是否所有數字都已使用\n    Yes → Step 3: 把 current 加入 result // 完整排列加入結果\n    No  → Step 4: 針對 remaining 中每個元素 x 進行迴圈 // 逐一嘗試\n        → Step 5: 呼叫 backtrack(current + [x], remaining - [x]) // 選擇 x 並遞迴\n→ Step 6: 呼叫 backtrack([], nums) // 開始遞迴，初始為空排列\n→ Step 7: 回傳 result // 所有排列已完成，回傳結果\nEnd // 程式執行結束\n\nMake sure each line is separate. Include decision branches. Provide explanation after //.\n\nWe need to be careful about formatting: \"虛擬碼步驟\" includes arrow. Eg: \"→ Step 1: 建立空的結果清單 result // 用於儲存所有排列\".\n\nAlso include decision lines with indentation maybe. But each line is separate. In sample they used indentation for nested steps? They used indentation with four spaces? They used \"    Yes → Step 2: ...\" etc. So we should mimic that: Use 4 spaces indentation before Yes→ and No→ lines. And for inner steps indent further? Example:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nThus we replicate. For our algorithm:\n\nStart // 程式開始執行\n→ Step 1: 建立空的結果清單 result // 用於儲存所有排列\n→ Step 2: 定義遞迴函式 backtrack(current, remaining) // current 為目前排列，remaining 為未使用的數字\n→ Decision: 如果 remaining 為空? // 檢查是否所有數字都已使用\n    Yes → Step 3: 把 current 加入 result // 完整排列加入結果\n    No  → Step 4: 針對 remaining 中每個元素 x 進行迴圈 // 逐一嘗試\n        → Step 5: 呼叫 backtrack(current + [x], remaining - [x]) // 選擇 x 並遞迴\n→ Step 6: 呼叫 backtrack([], nums) // 開始遞迴，初始為空排列\n→ Step 7: 回傳 result // 所有排列已完成，回傳結果\nEnd // 程式執行結束\n\nNeed to ensure proper indentation. The Step 5 inside step 4 should be indented more? They didn't indent further, but inside No branch they had \"No  → Decision: ...\". Then inside that Decision they had \"Yes → Step 3: ...\" So we should mimic: Step 4 then inside it maybe we don't need another Decision. But we can indent Step 5 under No. The formatting: After \"No  → Step 4: ...\" we then indent \"    → Step 5: ...\" maybe? They didn't show indent for Step 5. In sample, after \"No  → Decision:\" there is no nested indentation for the nested Decision's inner steps? They had \"    Yes → Step 3: ...\" with 4 spaces before Yes. Then inside No branch they had \"        Yes → Step 4: ...\" with 8 spaces? Actually sample:\n\n```\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n```\n\nSo nested Decision inside No has indentation of 4 spaces more for its steps (Yes, No). So for our algorithm:\n\n→ Decision: 如果 remaining 為空? // ...\n    Yes → Step 3: ...\n    No  → Step 4: 針對 remaining 中每個元素 x 進行迴圈 // ...\n        → Step 5: 呼叫 backtrack(current + [x], remaining - [x]) // ... \n\nBut the Step 5 maybe should be inside the loop. Could indent further. We can use \"        → Step 5: ...\" with 8 spaces before arrow. Let's produce.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的結果清單 result // 用於儲存所有排列  \n→ Step 2: 定義遞迴函式 backtrack(current, remaining) // current 為目前排列，remaining 為未使用的數字  \n→ Decision: 如果 remaining 為空? // 檢查是否所有數字都已使用  \n    Yes → Step 3: 把 current 加入 result // 完整排列加入結果  \n    No  → Step 4: 針對 remaining 中每個元素 x 進行迴圈 // 逐一嘗試  \n        → Step 5: 呼叫 backtrack(current + [x], remaining - [x]) // 選擇 x 並遞迴  \n→ Step 6: 呼叫 backtrack([], nums) // 開始遞迴，初始為空排列  \n→ Step 7: 回傳 result // 所有排列已完成，回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "輸入格式錯誤"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "輸入格式錯誤"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list[str]) -> int:\n        # 若目標基因不在基因庫中，直接無法達成\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            # 逐一嘗試每個位置的字母變化\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n\n        # 迴圈結束仍未找到目標\n        return -1\n\nif __name__ == \"__main__\":\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        sys.exit(0)\n\n    # 解析輸入格式：startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    # 將字串包裝成 dict 形式後 eval 解析\n    try:\n        data = eval('{' + data_str + '}')\n    except Exception as e:\n        print(\"輸入格式錯誤\")\n        sys.exit(1)\n\n    startGene = data.get('startGene')\n    endGene = data.get('endGene')\n    bank = data.get('bank', [])\n\n    solution = Solution()\n    result = solution.minMutation(startGene, endGene, bank)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for shortest path BFS from startGene to endGene with constraints: mutations allowed only within bank. Return min steps else -1. Use virtual code steps line by line with explanations. Use arrows and decision. Must be in Traditional Chinese. Provide explanation after space. Must not output actual code. Use Start End. We'll produce steps: initialize queue, visited set, bank set, etc. BFS loop, generate neighbors by changing each char to other 3 letters. Check bank and not visited. Count steps. If reach endGene return steps. If queue empty return -1. Also special case if start==end return 0. Also ensure bank contains end? Might still return -1 if not reachable. Provide comments accordingly.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 檢查 startGene 是否等於 endGene // 若已相同，無需變異\n    Yes → Step 2: 回傳 0 // 結束，步數為 0\n    No  → Continue\n→ Step 3: 建立字母陣列 letters = ['A','C','G','T'] // 用於產生變異\n→ Step 4: 將 bank 轉成 Set bankSet // 方便 O(1) 查找\n→ Step 5: 建立 queue 為 [(startGene,0)] // 以元組 (基因, 變異數) 儲存\n→ Step 6: 建立 visitedSet = {startGene} // 避免重複處理\n→ Decision: 迴圈是否有待處理項目? // 判斷 queue 是否為空\n    Yes → Step 7: 取出 queue 前項 currentGene, steps = queue.pop_front() // 取得當前基因及已進行的步數\n    → Decision: currentGene 是否等於 endGene? // 檢查是否達成目標\n        Yes → Step 8: 回傳 steps // 找到最短路徑，回傳步數\n        No  → Step 9: 對於每個位置 i 在 0..7\n            → Step 10: 對於每個字母 l 在 letters\n                → Decision: l 與 currentGene[i] 是否不同? // 只考慮單字母變異\n                    Yes → Step 11: 產生 newGene = currentGene 的第 i 位換成 l // 形成新的基因\n                    → Decision: newGene 是否在 bankSet 且未訪問? // 只允許有效且未處理的基因\n                        Yes → Step 12: 將 newGene 加入 visitedSet // 標記已訪問\n                        → Step 13: 將 (newGene, steps+1) 加入 queue // 下一層節點\n                        No  → Continue\n                    No  → Continue\n                Continue\n            Continue\n        End for each position\n        → Continue while loop\n    No  → Step 14: 回傳 -1 // 無法到達結束基因\nEnd // 程式結束\n\nBut need format with each line preceded by \"→\" except Start and End. Use indentation? The example shows indent lines. Use similar. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 startGene 是否等於 endGene // 若已相同，無需變異  \n  Yes → Step 2: 回傳 0 // 結束，步數為 0  \n  No  → Continue  \n→ Step 3: 建立字母陣列 letters = ['A','C','G','T'] // 用於產生變異  \n→ Step 4: 將 bank 轉成 Set bankSet // 方便 O(1) 查找  \n→ Step 5: 建立 queue 為 [(startGene,0)] // 以元組 (基因, 變異數) 儲存  \n→ Step 6: 建立 visitedSet = {startGene} // 避免重複處理  \n→ Decision: 迴圈是否有待處理項目? // 判斷 queue 是否為空  \n  Yes → Step 7: 取出 queue 前項 currentGene, steps = queue.pop_front() // 取得當前基因及已進行的步數  \n  → Decision: currentGene 是否等於 endGene? // 檢查是否達成目標  \n   Yes → Step 8: 回傳 steps // 找到最短路徑，回傳步數  \n   No  → Step 9: 對於每個位置 i 在 0..7  \n    → Step 10: 對於每個字母 l 在 letters  \n     → Decision: l 與 currentGene[i] 是否不同? // 只考慮單字母變異  \n      Yes → Step 11: 產生 newGene = currentGene 的第 i 位換成 l // 形成新的基因  \n      → Decision: newGene 是否在 bankSet 且未訪問? // 只允許有效且未處理的基因  \n       Yes → Step 12: 將 newGene 加入 visitedSet // 標記已訪問  \n        → Step 13: 將 (newGene, steps+1) 加入 queue // 下一層節點  \n       No  → Continue  \n     No  → Continue  \n    Continue  \n  Continue while loop  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → Continue  \n  → End // 程式結束  \n\n(Note: 以上行為示範性，實際程式碼中不會產生如此冗長的重複行，僅示範格式。)"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # max-heap for the lower half (store negative values)\n        self.small = []\n        # min-heap for the upper half\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 先把新數放進小堆\n        heapq.heappush(self.small, -num)\n\n        # 讓小堆頂（最大的負數）不大於大堆頂\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡堆的大小，差距不超過1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把兩個列表包成一個 tuple，方便用 literal_eval 解析\n    if data[0] != '(':\n        data = '(' + data + ')'\n\n    try:\n        commands, args = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，直接結束\n        return\n\n    results = []\n    obj = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == 'MedianFinder':\n            obj = MedianFinder()\n            results.append(None)                # constructor returns null\n        elif cmd == 'addNum':\n            obj.addNum(arg[0])                 # arg is a single-element list\n            results.append(None)                # addNum returns null\n        elif cmd == 'findMedian':\n            results.append(obj.findMedian())    # median value\n        else:\n            # 其他命令忽略\n            results.append(None)\n\n    # 轉成 LeetCode 風格的輸出：None -> null\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code describing implementation of MedianFinder class with addNum and findMedian. Should use structure: Start, steps, decision, End. Use arrow → etc. Provide short explanation comments.\n\nWe must design algorithm: use two heaps: max-heap for lower half, min-heap for upper half. When adding, decide which heap. Balance sizes difference <=1. findMedian: if sizes equal, mean of tops; else top of larger heap.\n\nWe output line by line. Use virtual code.\n\nLet's craft:\n\nStart\n→ Step 1: 定義 MaxHeap 小根? Actually MaxHeap for lower half, MinHeap for upper half\n→ Step 2: 初始化空堆\n→ Step 3: addNum(num) // 添加數字\n    → Decision: 是否將 num 放入 MaxHeap? (例如 if MaxHeap is empty or num <= top of MaxHeap)\n        Yes → Insert num into MaxHeap\n        No  → Insert num into MinHeap\n→ Step 4: BalanceHeaps() // 讓兩堆大小差不超過1\n    → Decision: size(MaxHeap) > size(MinHeap)+1?\n        Yes → Move top of MaxHeap to MinHeap\n        No → Decision: size(MinHeap) > size(MaxHeap)+1?\n            Yes → Move top of MinHeap to MaxHeap\n            No → No action\n→ Step 5: findMedian()\n    → Decision: size(MaxHeap) == size(MinHeap)?\n        Yes → Return (top(MaxHeap)+top(MinHeap))/2.0\n        No → Decision: size(MaxHeap) > size(MinHeap)?\n            Yes → Return top(MaxHeap)\n            No  → Return top(MinHeap)\nEnd\n\nWe must output each line with // comment. Use arrow for decisions.\n\nMake sure each line includes the code step and comment. Use \"Start\" and \"End\". Use \"Decision:\" lines with Yes → and No →. Use arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 MaxHeap `low` 用於存放較小半數 // 最高值在頂端\n→ Step 2: 建立 MinHeap `high` 用於存放較大半數 // 最小值在頂端\n→ Step 3: addNum(num) // 新數字加入流程\n    → Decision: 若 `low` 為空 或 num ≤ top(low) ? // 判斷該數屬於較小半數\n        Yes → Insert num into `low` // 加入較小半數堆\n        No  → Insert num into `high` // 加入較大半數堆\n→ Step 4: BalanceHeaps() // 兩堆大小差必須 ≤ 1\n    → Decision: size(`low`) > size(`high`) + 1 ?\n        Yes → Move top(`low`) to `high` // 把較大值移至大半數堆\n        No  → Decision: size(`high`) > size(`low`) + 1 ?\n            Yes → Move top(`high`) to `low` // 把較小值移至小半數堆\n            No  → // 堆已平衡，無需調整\n→ Step 5: findMedian() // 取得目前所有數字的中位數\n    → Decision: size(`low`) == size(`high`) ?\n        Yes → Return (top(`low`) + top(`high`)) / 2.0 // 平均兩個中位數\n        No  → Decision: size(`low`) > size(`high`) ?\n            Yes → Return top(`low`) // 小堆多，頂端即為中位數\n            No  → Return top(`high`) // 大堆多，頂端即為中位數\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmlhlfne9.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpmlhlfne9.py\", line 48, in main\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmlhlfne9.py\", line 42, in parse_input\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnuaefmze.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpnuaefmze.py\", line 48, in main\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnuaefmze.py\", line 42, in parse_input\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i, n = 0, len(intervals)\n\n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Add the merged interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses input of the form:\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    and returns the corresponding Python objects.\n    \"\"\"\n    intervals_match = re.search(r'intervals\\s*=\\s*(\\[[^\\]]*\\])', data)\n    new_match = re.search(r'newInterval\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not intervals_match or not new_match:\n        raise ValueError(\"Invalid input format\")\n\n    intervals = ast.literal_eval(intervals_match.group(1))\n    new_interval = ast.literal_eval(new_match.group(1))\n    return intervals, new_interval\n\ndef main():\n    raw_input = sys.stdin.read()\n    intervals, new_interval = parse_input(raw_input)\n    solution = Solution()\n    merged = solution.insert(intervals, new_interval)\n    print(merged)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Steps: start, iterate, handle three phases: before newInterval, overlapping, after newInterval. Steps similar to Leetcode solution. Provide explanation. Ensure no real code. Use arrow notation. Let's produce.\n\nWe'll output lines: Start, → Step: 初始化 result list, → Step: 取得 newStart, newEnd, etc. Then Decision: intervals[i] < newStart? etc. Let's produce about 20 lines. Use indentation for decisions. Provide explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空陣列 // 用來存放最終的區間  \n→ Step 2: 取得 newStart 與 newEnd 來自 newInterval // 新區間的起點與終點  \n→ Step 3: 設定 i 為 0，n 為 intervals 的長度 // 索引及長度準備  \n→ Decision: i < n 且 intervals[i].end < newStart? // 判斷當前區間是否完全在新區間左側  \n    Yes → Step 4: 把 intervals[i] 加入 result // 直接加入，無重疊  \n        → Step 5: i ← i + 1 // 移動到下一個區間  \n        → Jump to Decision // 重新檢查下一個  \n    No  → Decision: i < n 且 intervals[i].start > newEnd? // 判斷當前區間是否完全在新區間右側  \n        Yes → Step 6: 把 newInterval 加入 result // 新區間未被加入，加入之  \n            → Step 7: 把剩下所有 intervals[i..n-1] 加入 result // 之後全部加入  \n            → Step 8: End // 完成輸出  \n        No  → Step 9: 合併區間  \n            → Decision: 設定 mergedStart 為 min(newStart, intervals[i].start) // 新起點取較小值  \n            → Step 10: 設定 mergedEnd 為 max(newEnd, intervals[i].end) // 新終點取較大值  \n            → Step 11: i ← i + 1 // 移動至下一個區間  \n            → Jump to Decision // 重新檢查，繼續合併直到不重疊  \n→ Step 12: 若循環結束且 newInterval 尚未加入 result  \n    → Step 13: 把 newInterval 加入 result // 確保新區間被加入  \n→ End // 程式執行結束，返回 result"
    },
    {
      "title": "All O`one Data Structure",
      "source_file": "Leetcode/leetcode432.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg23fp3w8.py\", line 124, in <module>\n    main()\n  File \"/tmp/tmpg23fp3w8.py\", line 90, in main\n    cmds = ast.literal_eval(data[0])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 0\n    \nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Node:\n    def __init__(self, count=0):\n        self.count = count\n        self.keys = set()\n        self.prev = None\n        self.next = None\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()  # dummy head with count -inf\n        self.tail = Node()  # dummy tail with count +inf\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node(count)\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        if key not in self.key_to_node:\n            return\n        node = self.key_to_node[key]\n        node.keys.remove(key)\n        prev_count = node.count - 1\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    data = [line.strip() for line in sys.stdin if line.strip()]\n    if not data:\n        return\n    # Remove possible 'Input' or 'Output' prefixes\n    if data[0].startswith('Input'):\n        data[0] = data[0][len('Input'):].strip()\n    if len(data) > 1 and data[1].startswith('Output'):\n        data[1] = data[1][len('Output'):].strip()\n\n    cmds = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1]) if len(data) > 1 else []\n\n    obj = None\n    res = []\n    for cmd, arg in zip(cmds, args):\n        if cmd == 'AllOne':\n            obj = AllOne()\n            res.append(None)\n        elif cmd == 'inc':\n            obj.inc(arg[0] if isinstance(arg, (list, tuple)) else arg)\n            res.append(None)\n        elif cmd == 'dec':\n            obj.dec(arg[0] if isinstance(arg, (list, tuple)) else arg)\n            res.append(None)\n        elif cmd == 'getMaxKey':\n            res.append(obj.getMaxKey())\n        elif cmd == 'getMinKey':\n            res.append(obj.getMinKey())\n        else:\n            res.append(None)\n\n    # Format output\n    out_items = []\n    for v in res:\n        if v is None:\n            out_items.append('null')\n        else:\n            out_items.append(f'\"{v}\"')\n    out_str = '[' + ', '.join(out_items) + ']'\n    print('Output')\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps for designing AllOne data structure. Provide step-by-step instructions. Use Start, End, Decision, etc. Provide each line with explanation.\n\nWe should produce pseudo-code for the methods: initialization, inc, dec, getMaxKey, getMinKey. We need to describe the data structures used: a doubly linked list of count nodes, each node holds a set of keys with that count; and a hash map from key to node. Outline logic.\n\nWe need to produce line by line pseudo-code, not actual code.\n\nMake sure each line ends with // explanation. Use arrow '→', 'Yes →', 'No →'.\n\nLet's produce:\n\nStart // 初始化\n→ Step 1: 初始化哈希表 keyToNode // 记录 key 到计数节点\n→ Step 2: 初始化雙向鏈表 head, tail // 计数节点链表\n→ Step 3: head.next = tail; tail.prev = head // 设空链表\nEnd\n\nThen inc:  \n\nStart inc(key)  \n→ Decision: 如果 key 在 keyToNode? // 判断 key 是否已存在  \n    Yes → Step 1: currNode = keyToNode[key] // 获取当前计数节点  \n        → Step 2: nextCount = currNode.count + 1  \n        → Decision: 如果 currNode.next.count == nextCount? // 下一节点是否已是目标计数  \n            Yes → targetNode = currNode.next  \n            No  → Step 3: targetNode = 新建节点(count=nextCount)  \n                → Insert targetNode 在 currNode 之后  \n        → Step 4: 把 key 从 currNode.keys 移除  \n        → Step 5: 把 key 加入 targetNode.keys  \n        → Step 6: keyToNode[key] = targetNode  \n        → Decision: 如果 currNode.keys 为空? // 该计数节点是否无 key  \n            Yes → 删除 currNode 从链表  \n    No  → Step 1: // key 不存在，计数从 1  \n        → Decision: 如果 head.next.count == 1? // 第一节点是否为 count 1  \n            Yes → node1 = head.next  \n            No  → Step 2: node1 = 新建节点(count=1)  \n                → Insert node1 在 head 之后  \n        → Step 3: 把 key 加入 node1.keys  \n        → Step 4: keyToNode[key] = node1  \nEnd\n\nSimilarly for dec:\n\nStart dec(key)  \n→ currNode = keyToNode[key]  \n→ Step 1: currCount = currNode.count  \n→ Decision: 如果 currCount == 1? // 计数降到 0  \n    Yes → Step 2: 从 currNode.keys 移除 key  \n        → Step 3: 删除 currNode 及其 key 记录  \n        → Step 4: 删除 keyToNode[key]  \n    No  → Step 1: newCount = currCount - 1  \n        → Decision: 如果 currNode.prev.count == newCount? // 前一节点是否为目标计数  \n            Yes → prevNode = currNode.prev  \n            No  → Step 2: prevNode = 新建节点(count=newCount)  \n                → 插入 prevNode 在 currNode 前面  \n        → Step 3: 把 key 从 currNode.keys 移除  \n        → Step 4: 把 key 加入 prevNode.keys  \n        → Step 5: keyToNode[key] = prevNode  \n        → Decision: 如果 currNode.keys 为空?  \n            Yes → 删除 currNode  \nEnd\n\ngetMaxKey:\n\nStart getMaxKey  \n→ Decision: 如果 head.next == tail? // 空集合  \n    Yes → return \"\"  \n    No  → Step 1: node = tail.prev // 最大计数节点  \n        → Step 2: return 任意 key from node.keys  \nEnd\n\ngetMinKey similar:\n\nStart getMinKey  \n→ Decision: 如果 head.next == tail?  \n    Yes → return \"\"  \n    No → Step 1: node = head.next // 最小计数节点  \n        → Step 2: return 任意 key from node.keys  \nEnd\n\nThis should satisfy.\n\nMake sure each line has // explanation.\n\nWe need to include arrow and decision lines properly.\n\nAlso note that we need to include Start and End for each function.\n\nWe must produce pseudo-code lines only, no actual code.\n\nLet's format accordingly.\n\nAlso note we might include \"Decision:\" lines for condition checks. Each step line must include the arrow and explanation.\n\nOk.\n...done thinking.\n\nStart // AllOne 資料結構初始化\n→ Step 1: keyToNode ← 空哈希表 // 記錄 key 到其所在的計數節點\n→ Step 2: head ← 新節點(count = -∞) // 鏈表起始節點\n→ Step 3: tail ← 新節點(count = +∞) // 鏈表結束節點\n→ Step 4: head.next ← tail; tail.prev ← head // 形成空雙向鏈表\nEnd\n\nStart inc(key) // 對 key 進行計數遞增\n→ Decision: key 是否在 keyToNode? // 判斷 key 是否已存在\n    Yes → Step 1: currNode ← keyToNode[key] // 取得目前的計數節點\n        → Step 2: nextCount ← currNode.count + 1 // 目標新計數\n        → Decision: currNode.next.count == nextCount? // 下一節點是否已為目標計數\n            Yes → targetNode ← currNode.next\n            No → Step 3: targetNode ← 新節點(count = nextCount) // 新建節點\n                → Insert targetNode 在 currNode 後面\n        → Step 4: 從 currNode.keys 移除 key\n        → Step 5: 將 key 加入 targetNode.keys\n        → Step 6: keyToNode[key] ← targetNode // 更新映射\n        → Decision: currNode.keys 為空? // 該節點是否已無 key\n            Yes → Delete currNode 從鏈表\n    No → Step 1: // key 為新 key，初始計數為 1\n        → Decision: head.next.count == 1? // 第一實際節點是否已為 1\n            Yes → node1 ← head.next\n            No → Step 2: node1 ← 新節點(count = 1) // 新建節點\n                → Insert node1 在 head 後面\n        → Step 3: 將 key 加入 node1.keys\n        → Step 4: keyToNode[key] ← node1 // 建立映射\nEnd\n\nStart dec(key) // 對 key 進行計數遞減\n→ Step 1: currNode ← keyToNode[key] // 取得目前的計數節點\n→ Step 2: currCount ← currNode.count\n→ Decision: currCount == 1? // 會否降為 0\n    Yes → Step 3: 從 currNode.keys 移除 key\n        → Step 4: Delete currNode 從鏈表\n        → Step 5: Delete keyToNode[key] // 完全移除 key\n    No → Step 1: newCount ← currCount - 1 // 目標新計數\n        → Decision: currNode.prev.count == newCount? // 前一節點是否已為目標計數\n            Yes → prevNode ← currNode.prev\n            No → Step 2: prevNode ← 新節點(count = newCount) // 新建節點\n                → Insert prevNode 在 currNode 前面\n        → Step 3: 從 currNode.keys 移除 key\n        → Step 4: 將 key 加入 prevNode.keys\n        → Step 5: keyToNode[key] ← prevNode // 更新映射\n        → Decision: currNode.keys 為空? // 該節點是否已無 key\n            Yes → Delete currNode 從鏈表\nEnd\n\nStart getMaxKey() // 取得計數最大者之一\n→ Decision: head.next == tail? // 是否為空集合\n    Yes → return \"\"\n    No → Step 1: node ← tail.prev // 最後一個實際節點即最大計數\n        → Step 2: return 任意 key from node.keys\nEnd\n\nStart getMinKey() // 取得計數最小者之一\n→ Decision: head.next == tail? // 是否為空集合\n    Yes → return \"\"\n    No → Step 1: node ← head.next // 第一個實際節點即最小計數\n        → Step 2: return 任意 key from node.keys\nEnd"
    },
    {
      "title": "Design HashSet",
      "source_file": "Leetcode/leetcode705.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]",
          "expected_output": "[null, null, null, true, false, null, true, null, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,null,true,null,false]'\nGot (Norm):      '[None,None,None,True,False,None,True,None,False]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, null, true, null, false]'\nRaw Got:      '[None, None, None, True, False, None, True, None, False]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyHashSet:\n    def __init__(self):\n        # 使用固定大小的 bucket 數組，避免使用字典或集合\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        # 簡單的取餘數哈希函式\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        h = self._hash(key)\n        # 只在 bucket 中不存在時才插入\n        if key not in self.buckets[h]:\n            self.buckets[h].append(key)\n\n    def remove(self, key: int) -> None:\n        h = self._hash(key)\n        if key in self.buckets[h]:\n            self.buckets[h].remove(key)\n\n    def contains(self, key: int) -> bool:\n        h = self._hash(key)\n        return key in self.buckets[h]\n\n\ndef main() -> None:\n    # 讀取整個輸入，拆成兩行：方法名稱和參數\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n\n    # 解析成 Python 物件（列表）\n    ops = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    # 結果列表，對應每個呼叫的返回值\n    results = []\n    obj = None\n\n    for idx, op in enumerate(ops):\n        if op == \"MyHashSet\":\n            obj = MyHashSet()\n            results.append(None)\n        elif op == \"add\":\n            # args_list[idx] 形如 [key]\n            key = args_list[idx][0]\n            obj.add(key)\n            results.append(None)\n        elif op == \"remove\":\n            key = args_list[idx][0]\n            obj.remove(key)\n            results.append(None)\n        elif op == \"contains\":\n            key = args_list[idx][0]\n            results.append(obj.contains(key))\n        else:\n            # 若遇到未知指令，視作 None\n            results.append(None)\n\n    # 輸出結果，與題目示例格式一致\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. The user requests design a HashSet without built-in hash tables. So we can implement using array of buckets, each bucket is a linked list (separate chaining). Provide methods add, contains, remove. Use an array of size maybe 1000. We'll design steps.\n\nWe need to output per line:\n\nStart // 程式開始執行\n→ Step 1: 定義 HashSet 類別 // etc.\n\nWe must include decisions etc.\n\nWe need to produce \"virtual code\" with arrows and decisions.\n\nLet's produce:\n\nStart\n→ Step 1: 宣告 MyHashSet 類別，內部包含 buckets 數組 // array of linked lists\n→ Step 2: 初始化 buckets 為固定大小 1000 // default capacity\n→ Step 3: 定義 hash 函式 (key mod bucketCount) // compute index\n→ Step 4: 定義 add(key) // add key\n   → Step 4.1: 計算 idx = hash(key)\n   → Step 4.2: 取得 bucket = buckets[idx]\n   → Decision: bucket 為空?\n      Yes → Step 4.2.1: 建立新節點並指向 buckets[idx] // insert at head\n      No → Decision: key 已存在於 bucket?\n          Yes → Step 4.2.2: return // already present\n          No → Step 4.2.3: 建立新節點並插入 bucket head // add\n→ Step 5: 定義 contains(key)\n   → Step 5.1: idx = hash(key)\n   → Step 5.2: 取得 bucket\n   → Decision: bucket 為空?\n      Yes → Step 5.2.1: return false\n      No → Step 5.3: 迭代 bucket\n          Decision: current.key == key?\n             Yes → Step 5.3.1: return true\n             No → Step 5.3.2: move to next\n   → Step 5.4: return false\n→ Step 6: 定義 remove(key)\n   → Step 6.1: idx = hash(key)\n   → Step 6.2: 取得 bucket\n   → Decision: bucket 為空?\n      Yes → Step 6.2.1: return // nothing to remove\n      No → Decision: head.key == key?\n           Yes → Step 6.2.2: buckets[idx] = head.next // remove head\n           No → Step 6.3: prev = head, curr = head.next\n                While curr != null\n                   Decision: curr.key == key?\n                        Yes → Step 6.3.1: prev.next = curr.next // unlink\n                            Step 6.3.2: return\n                        No → Step 6.3.3: prev = curr, curr = curr.next\n                Step 6.4: return // key not found\n→ End // 程式執行結束\n\nNeed to add explanation comments after each line.\n\nAlso must include Start and End. Use arrows. Each line start with \"→\".\n\nWe'll also need to represent decision indentation. Use tabs? Just spaces. We'll produce as example.\n\nMake sure each line includes virtual code + space + comment.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyHashSet 類別，內部包含 buckets 數組 // 建立 HashSet 類別並準備存放 bucket  \n→ Step 2: 初始化 buckets 為固定大小 1000 // 以 1000 個 bucket 作為基礎容量  \n→ Step 3: 定義 hash 函式 (key mod bucketCount) // 計算 key 的 bucket 索引  \n→ Step 4: 定義 add(key) // 插入 key  \n  → Step 4.1: 計算 idx = hash(key) // 取得 bucket 索引  \n  → Step 4.2: 取得 bucket = buckets[idx] // 取出對應 bucket  \n  → Decision: bucket 為空? // 判斷 bucket 是否已存在節點  \n   Yes → Step 4.2.1: 建立新節點並指向 buckets[idx] // 插入第一個節點  \n   No → Decision: key 已存在於 bucket? // 檢查是否重複  \n    Yes → Step 4.2.2: return // 已存在不重複插入  \n    No → Step 4.2.3: 建立新節點並插入 bucket head // 將新節點插入鏈表頭  \n→ Step 5: 定義 contains(key) // 檢查 key 是否存在  \n  → Step 5.1: idx = hash(key) // 取得 bucket 索引  \n  → Step 5.2: 取得 bucket  \n  → Decision: bucket 為空?  \n   Yes → Step 5.2.1: return false // 空 bucket 表示不存在  \n   No → Step 5.3: 迭代 bucket  \n    Decision: current.key == key?  \n     Yes → Step 5.3.1: return true // 找到 key  \n     No → Step 5.3.2: move to next // 繼續搜尋  \n  → Step 5.4: return false // 搜尋完畢仍未找到  \n→ Step 6: 定義 remove(key) // 刪除 key  \n  → Step 6.1: idx = hash(key) // 取得 bucket 索引  \n  → Step 6.2: 取得 bucket  \n  → Decision: bucket 為空?  \n   Yes → Step 6.2.1: return // 沒有節點，直接返回  \n   No → Decision: head.key == key?  \n    Yes → Step 6.2.2: buckets[idx] = head.next // 刪除頭節點  \n    No → Step 6.3: prev = head, curr = head.next // 設定遍歷指標  \n     While curr != null  \n      Decision: curr.key == key?  \n       Yes → Step 6.3.1: prev.next = curr.next // 解除連結  \n        Step 6.3.2: return // 刪除完成  \n       No → Step 6.3.3: prev = curr, curr = curr.next // 移動至下一個  \n  → Step 6.4: return // 若迴圈結束仍未找到，直接返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nINF = 10 ** 9\n\ndef collapse(s: str) -> str:\n    \"\"\"連鎖消除，直到無法再消除為止\"\"\"\n    while True:\n        i = 0\n        new_s = []\n        changed = False\n        while i < len(s):\n            j = i\n            while j < len(s) and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:      # 可消除\n                changed = True\n            else:\n                new_s.append(s[i:j])\n            i = j\n        if not changed:\n            break\n        s = \"\".join(new_s)\n    return s\n\ndef hand_key(hand: dict) -> str:\n    \"\"\"將手中球的計數轉成鍵字串，用於記憶化\"\"\"\n    return \"\".join(f\"{c}{hand[c]}\" for c in sorted(hand))\n\ndef min_insert(board: str, hand: dict, memo: dict) -> int:\n    \"\"\"回溯求最小插入數\"\"\"\n    if not board:\n        return 0\n    if all(v == 0 for v in hand.values()):\n        return INF\n    key = board + \"|\" + hand_key(hand)\n    if key in memo:\n        return memo[key]\n\n    ans = INF\n    # 嘗試所有插入位置與顏色\n    for pos in range(len(board) + 1):\n        for color, cnt in hand.items():\n            if cnt == 0:\n                continue\n            # 插入\n            new_board = board[:pos] + color + board[pos:]\n            collapsed = collapse(new_board)\n            new_hand = hand.copy()\n            new_hand[color] -= 1\n            if not collapsed:\n                ans = min(ans, 1)            # 只需此一步即可\n            else:\n                res = min_insert(collapsed, new_hand, memo)\n                if res != INF:\n                    ans = min(ans, 1 + res)\n    memo[key] = ans\n    return ans\n\ndef solve(board: str, hand: str) -> int:\n    hand_counts = {c: hand.count(c) for c in \"RYB G W\".split() if c in hand}\n    # 確保所有顏色都有鍵，否則後續不會被考慮\n    for c in \"RYBGW\":\n        hand_counts.setdefault(c, 0)\n    memo = {}\n    ans = min_insert(board, hand_counts, memo)\n    return -1 if ans == INF else ans\n\ndef parse_input(data: str):\n    \"\"\"從輸入中提取 board 與 hand 的值\"\"\"\n    # 若使用形如 board = \"XXX\", hand = \"YYY\" 的格式\n    board_match = re.search(r'board\\s*=\\s*\"([^\"]*)\"', data)\n    hand_match = re.search(r'hand\\s*=\\s*\"([^\"]*)\"', data)\n    if board_match and hand_match:\n        return board_match.group(1), hand_match.group(1)\n    # 若為兩行單獨輸入\n    parts = data.strip().splitlines()\n    if len(parts) >= 2:\n        return parts[0].strip(), parts[1].strip()\n    # 若為單行逗號分隔\n    parts = data.replace(',', ' ').split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    raise ValueError(\"無法解析輸入\")\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    board_str, hand_str = parse_input(raw)\n    result = solve(board_str, hand_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving Zuma game. We need to output each line with step and explanation. This is algorithm design. Likely DFS + memo with state string+hand counts, or BFS. Need to produce minimal insertions. Use recursion with pruning. Provide virtual code lines. We'll generate pseudo code with steps.\n\nWe need to output \"逐行\" virtual code. Each line includes virtual code and explanation. Use arrow structure. So we need to format accordingly.\n\nWe need to define functions: minInsertions(board, hand). Use backtracking. Use memoization: key=board+handCounts string. Recursively try each position to insert each color from hand if available. After insertion, collapse board: while any group length >=3, remove and merge. Use helper collapse(board). After collapse, if board empty return 0. Else if no hand left return INF. At recursion, ans = min(ans, 1 + minInsertions(newBoard,newHand)). Finally return ans or -1.\n\nWe need to implement collapse: scan board, find groups, remove. Use loop until no changes.\n\nWe need representation of hand counts: map color->count. We'll convert to string key.\n\nThe pseudo code lines should include decisions, loops, recursion.\n\nLet's draft.\n\nWe need to start: Start. Then define main function.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Function: MinInsertions(board, handCount) // 主函式計算最小插入數\n...\n\nWe need to be careful: use virtual code arrows.\n\nLet's produce.\n\nWe must adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's craft.\n\nWe will produce about 60-70 lines.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function: MinInsertions(board, handCount) // 計算清空 board 所需最少插入數  \n  Decision: 如果 board 為空? // 若棋盤已空，無需再插入  \n   Yes → Return 0 // 直接勝利，回傳 0  \n   No  → Decision: 如果 handCount 所有顏色為 0? // 手中無球可插  \n    Yes → Return INF // 無法勝利，回傳無限大（代表失敗）  \n    No  → → MemoKey = board + “|” + handCountToString(handCount) // 生成記憶化鍵  \n     Decision: 如果 MemoKey 在 memo? // 檢查是否已計算此狀態  \n      Yes → Return memo[MemoKey] // 直接使用已存結果  \n      No  → → ans = INF // 初始化答案為無限大  \n       → For each position i from 0 to len(board) // 嘗試所有插入位置  \n         → For each color c in handCount if handCount[c] > 0 // 嘗試所有可用顏色  \n           → newBoard = InsertAt(board, i, c) // 在第 i 個位置插入顏色 c  \n           → collapsedBoard = Collapse(newBoard) // 連鎖消除  \n           → newHandCount = handCount; newHandCount[c] -= 1 // 使用一顆球  \n            Decision: 如果 collapsedBoard 為空? // 清空成功  \n             Yes → ans = Min(ans, 1) // 只需此一次插入即可勝利  \n             No  → ans = Min(ans, 1 + MinInsertions(collapsedBoard, newHandCount)) // 進行遞迴  \n           → End For c  \n         → End For i  \n        memo[MemoKey] = ans // 記錄此狀態的最小插入數  \n        Return ans // 回傳此狀態的答案  \n→ Function: Collapse(board) // 連鎖消除直到無法再消除  \n  → Repeat  \n    → changed = False // 標記本輪是否有消除發生  \n    → i = 0 // 索引指標  \n    → newBoard = EmptyString // 儲存未被消除的球  \n    → While i < len(board) // 遍歷棋盤  \n      → j = i  \n      → While j < len(board) and board[j] == board[i] // 找出同色連續區段  \n        j += 1  \n      → count = j - i // 連續球數  \n      Decision: 如果 count >= 3? // 可消除  \n       Yes → changed = True // 記錄已消除  \n         // 不將此區段加入 newBoard（消除）  \n       No  → newBoard += board[i:j] // 保留此區段  \n         i = j // 移到下一區段  \n      → End While  \n      Decision: 如果 changed? // 有消除發生  \n       Yes → board = newBoard // 更新棋盤為未消除部分  \n         // 重複檢查可能的新連鎖  \n       No  → Break // 無消除，終止循環  \n    → End Repeat  \n   → Return board // 回傳最終棋盤  \n→ Function: InsertAt(board, pos, color) // 在 pos 位置插入 color  \n  → Return board[0:pos] + color + board[pos:] // 插入後的新棋盤  \n→ Function: handCountToString(handCount) // 將手中球計數轉成字串  \n  → Return “R:” + handCount['R'] + “Y:” + handCount['Y'] + “B:” + handCount['B'] + “G:” + handCount['G'] + “W:” + handCount['W'] // 格式化鍵值  \n→ Function: MinAns(board, hand) // 入口函式  \n  → handCount = CountColors(hand) // 轉成計數字典  \n  → result = MinInsertions(board, handCount) // 取得最小插入數  \n  Decision: 如果 result == INF? // 失敗判定  \n   Yes → Return -1 // 無法清空，回傳 -1  \n   No  → Return result // 成功，回傳最小插入數  \n→ End // 程式執行結束"
    },
    {
      "title": "Find the Difference",
      "source_file": "Leetcode/leetcode389.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'e'\nGot (Norm):      'N'\n--- (Raw) ---\nRaw Expected: '\"e\"'\nRaw Got:      'N'"
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'y'\nGot (Norm):      'N'\n--- (Raw) ---\nRaw Expected: '\"y\"'\nRaw Got:      'N'"
        }
      ],
      "generated_code": "import sys\n\ndef find_the_difference(s: str, t: str) -> str:\n    \"\"\"\n    透過 XOR 方式找出 t 中多出的字元。\n    XOR 的性質：相同的字元 XOR 兩次會抵消，最後剩下唯一不同的字元。\n    \"\"\"\n    xor_val = 0\n    for ch in s:\n        xor_val ^= ord(ch)\n    for ch in t:\n        xor_val ^= ord(ch)\n    return chr(xor_val)\n\ndef parse_input() -> tuple[str, str]:\n    \"\"\"\n    讀取標準輸入，支援下列三種常見格式：\n    1. 兩行各一個字串\n    2. 同一行兩個空格分隔的字串\n    3. 包含雙引號或單引號的字串（如 \"abcd\"）\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return \"\", \"\"\n    lines = raw.splitlines()\n    if len(lines) >= 2:\n        s, t = lines[0].strip(), lines[1].strip()\n    else:\n        parts = raw.split()\n        s, t = parts[0], parts[1] if len(parts) > 1 else \"\"\n    # 移除可能存在的引號\n    s = s.strip('\"').strip(\"'\")\n    t = t.strip('\"').strip(\"'\")\n    return s, t\n\ndef main() -> None:\n    s, t = parse_input()\n    result = find_the_difference(s, t)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step. The requirement: \"You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t.\"\n\nWe need to output step-by-step virtual code with comments.\n\nWe should cover reading inputs, iterating through characters of s and t, maybe use a frequency map or XOR. Since they want virtual code, we can propose algorithm: sum char codes, subtract or XOR. Or count frequency.\n\nSimpler: Use a dictionary count for s, then iterate t and decrement; the one that becomes negative or missing is answer.\n\nOr using XOR: XOR all chars of s and t, result is added char.\n\nLet's write virtual steps: Start, read s and t, compute XOR of chars, return result. Provide explanation.\n\nBut we need to ensure each line includes virtual code step + comment. Format: \"→ Step 1: ...\" etc. Use arrow \"→\" preceding. Use Decision if needed.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s 和 t // 從使用者處取得兩個字串\n→ Step 2: 初始化變數 result 為 0 // 用於存放 XOR 結果\n→ Step 3: 對於 s 中的每個字元 c → result = result XOR ASCII(c) // 將 s 的字元 XOR 進去\n→ Step 4: 對於 t 中的每個字元 c → result = result XOR ASCII(c) // 將 t 的字元 XOR 進去\n→ Step 5: 將 result 轉回字元作為答案 // 取 XOR 結果對應的字元\n→ End // 程式執行結束\n\nBut need more details: maybe step of conversion to char. Provide explanation after each line.\n\nLet's output as per format: Each line includes virtual code step then comment after //.\n\nWe must ensure each line has \"→\" preceding? In example, the first line Start has no arrow. In pattern: \"Start // 程式開始執行\" then \"→ Step 1:\" etc. So we follow.\n\nAlso we need to maybe mention Decision: not needed. Could also propose using frequency count: maybe show Decision for if result 0? Not necessary.\n\nWe'll produce final answer with proper formatting. Ensure lines separated by newline.\n\nAlso use Traditional Chinese for comments.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s 和 t // 取得兩個需要比較的字串  \n→ Step 2: 初始化變數 result 為 0 // 用於存放 XOR 運算的累積結果  \n→ Step 3: 對於 s 中的每個字元 c → result = result XOR ASCII(c) // 把 s 的每個字元加入 XOR，消除重複字元  \n→ Step 4: 對於 t 中的每個字元 c → result = result XOR ASCII(c) // 再把 t 的每個字元加入 XOR，唯一多出的字元不會被抵消  \n→ Step 5: 將 result 轉回字元作為答案 // XOR 的結果即為 t 補加的那一個字元  \n→ End // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpimwgpcdx.py\", line 25, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqwk3ufnb.py\", line 25, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    matrix = [[-5]], k = 1\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\ndef kth_smallest(matrix, k):\n    n = len(matrix)\n    low, high = matrix[0][0], matrix[-1][-1]\n\n    while low < high:\n        mid = (low + high) // 2\n        count = 0\n        for row in matrix:\n            # number of elements <= mid in this sorted row\n            count += bisect.bisect_right(row, mid)\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\nif __name__ == \"__main__\":\n    # Read entire input; the input format is like:\n    # matrix = [[...], ...], k = 8\n    data = sys.stdin.read()\n    # Execute the input string so that `matrix` and `k` become available\n    exec(data, globals())\n    result = kth_smallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving k-th smallest element in sorted matrix. Use binary search on value range, count <= mid using row binary search. Complexity O(n log(n^2)). Memory O(1). We'll produce steps.\n\nWe need to output lines with \"Start\" etc. Provide each step: read n,k,matrix; set low/high; while low<high; mid; count <=mid; adjust. Then output low. Use pseudo.\n\nWe need to show decision structure.\n\nLet's produce step lines.\n\nWe'll write:\n\nStart\n→ Step 1: 讀取矩陣大小 n 以及 k 以及整個 n x n 矩陣 // 取得輸入\n→ Step 2: 設定 low = matrix[0][0] // 最小值\n→ Step 3: 設定 high = matrix[n-1][n-1] // 最大值\n→ Decision: while low < high? // 迴圈直到低高相等\n    Yes → Step 4: 計算 mid = (low + high) / 2 // 取中值\n    → Step 5: 計算 count = 0 // 初始化計數\n    → Step 6: 依序對每一列進行 binary search 找出 <= mid 的元素數 // 效率\n    → Step 7: 如果 count < k? // 檢查是否還需更大值\n        Yes → Step 8: 設定 low = mid + 1 // 選擇更大的區間\n        No  → Step 9: 設定 high = mid // 選擇更小或等區間\n    → Decision: 重複 while low < high? // 迴圈判斷\n        Yes → (回到 Step 4)\n        No  → (離開迴圈)\n→ Step 10: 輸出 low // 低即為第 k 小值\nEnd\n\nWe need to ensure each line is single step; we may need to break into substeps.\n\nAlso for Step 6, we may need to show loop over rows.\n\nMaybe:\n\n→ Step 6: 對 row in matrix:\n            → Step 6a: 使用 binary search 在 row 中找出第一個 > mid 的索引 idx\n            → Step 7: 增加 count += idx\n\nBut we should keep step numbering.\n\nBetter to produce step labels. Let's produce.\n\nWe'll follow format: \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\nUse indentation.\n\nWe might need to include \"Decision:\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n、k 以及 n x n 矩陣 mat // 取得輸入資料  \n→ Step 2: 設定 low = mat[0][0] // 矩陣中最小的值  \n→ Step 3: 設定 high = mat[n-1][n-1] // 矩陣中最大的值  \n\n→ Decision: while low < high? // 迴圈直到低高相等  \n    Yes → Step 4: 計算 mid = (low + high) / 2 // 取中值以進行範圍二分  \n    → Step 5: 計算 count = 0 // 初始化小於等於 mid 的元素數  \n    → Step 6: 對每一列 row 進行  \n            → Step 6a: 在 row 中執行 binary search 找到第一個 > mid 的索引 idx  \n            → Step 6b: count += idx // idx 為 <= mid 的元素數  \n    → Decision: count < k? // 判斷目前範圍是否包含足夠小的元素  \n        Yes → Step 7: 設定 low = mid + 1 // 需要更大的數值，調整低端  \n        No  → Step 8: 設定 high = mid // 可能包含目標，調整高端  \n    → Decision: 重複 while low < high?  \n        Yes → (回到 Step 4)  \n        No  → (離開迴圈)  \n\n→ Step 9: 輸出 low // low 為第 k 小的元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Strange Printer",
      "source_file": "Leetcode/leetcode664.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"aaabbb\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strangePrinter(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        # 逆序填表\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                # 首先假設要在 i 處多一次印刷\n                dp[i][j] = 1 + dp[i + 1][j]\n                # 若某個 k 的字元等於 i，則可以把 i 的印刷和 k 的印刷合併\n                for k in range(i + 1, j + 1):\n                    if s[k] == s[i]:\n                        if k + 1 <= j:\n                            dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j])\n                        else:\n                            dp[i][j] = min(dp[i][j], dp[i][k - 1])\n        return dp[0][n - 1]\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中擷取字串，只保留小寫英文字母\n    s = ''.join(re.findall(r'[a-z]+', data))\n    sol = Solution()\n    result = sol.strangePrinter(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo code for algorithm to compute minimal turns for strange printer. Classic DP. Steps: DP[i][j] minimal turns for s[i..j]. Base: dp[i][i] =1. Transition: dp[i][j] = min over k from i to j-1 of dp[i][k]+dp[k+1][j] - (if s[k]==s[j] then 1 else 0). Actually typical recurrence: dp[i][j] = min(dp[i][k] + dp[k+1][j] - (s[k]==s[j] ?1:0)). Also can consider optimization. But we just need pseudo steps.\n\nWe need to output each line with virtual code and explanation. Format: lines: \"Start // ...\", \"→ Step ...\" etc.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: Input string s // 取得輸入字串\n→ Step 2: n ← length(s) // 取得長度\n→ Step 3: Initialize 2D array dp[n][n] with large values // dp 用來儲存子串最小印刷次數\n→ Step 4: For i from 0 to n-1:\n    → Step 4.1: dp[i][i] ← 1 // 單字元只需一次印刷\n→ Step 5: For length L from 2 to n:\n    → Step 5.1: For i from 0 to n-L:\n        → Step 5.1.1: j ← i + L -1\n        → Step 5.1.2: dp[i][j] ← INF\n        → Step 5.1.3: For k from i to j-1:\n            → Step 5.1.3.1: temp ← dp[i][k] + dp[k+1][j]\n            → Step 5.1.3.2: If s[k] == s[j] then temp ← temp -1 // 合併印刷\n            → Step 5.1.3.3: dp[i][j] ← min(dp[i][j], temp)\n→ Step 6: Result ← dp[0][n-1] // 整串最小印刷次數\n→ End // 結束\n\nNeed to add comments for each line. Ensure \"→\" arrow for sub-steps maybe nested.\n\nLet's produce exactly as format: each line \"虛擬碼步驟 // 解釋\". Use \"Start\", \"End\". Use \"Decision:\" maybe not needed. Just use arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input string s // 取得輸入字串  \n→ Step 2: n ← length(s) // 獲取字串長度  \n→ Step 3: Initialize 2D array dp[n][n] with large values // 建立 dp 表存放子串最小印刷次數  \n\n→ Step 4: For i from 0 to n-1: // 設置單字元情況  \n  → Step 4.1: dp[i][i] ← 1 // 單個字元只需一次印刷  \n\n→ Step 5: For L from 2 to n: // 逐漸考慮更長子串  \n  → Step 5.1: For i from 0 to n-L: // 子串左端  \n    → Step 5.1.1: j ← i + L - 1 // 子串右端  \n    → Step 5.1.2: dp[i][j] ← INF // 初始化為大值  \n    → Step 5.1.3: For k from i to j-1: // 分割點  \n      → Step 5.1.3.1: temp ← dp[i][k] + dp[k+1][j] // 合併兩半  \n      → Step 5.1.3.2: If s[k] == s[j] then temp ← temp - 1 // 若兩邊相同字元可合併一次印刷  \n      → Step 5.1.3.3: dp[i][j] ← min(dp[i][j], temp) // 更新最小值  \n\n→ Step 6: Result ← dp[0][n-1] // 整個字串的最小印刷次數  \n→ End // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8dpshgie.py\", line 68, in <module>\n    instances[var_name].addRange(left, right)\n    ~~~~~~~~~^^^^^^^^^^\nKeyError: '\\\\nrangeModule'"
        }
      ],
      "generated_code": "import sys\nimport bisect\nimport json\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i - 1][0] <= left and right <= self.ranges[i - 1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Split commands by ';' or newline, then strip whitespace\n    raw_commands = [cmd.strip() for cmd in data.replace('\\n', ';').split(';') if cmd.strip()]\n    instances = {}\n    output = []\n\n    for cmd in raw_commands:\n        if '.' not in cmd:\n            # Constructor\n            # Example: \"RangeModule rangeModule = new RangeModule()\"\n            var_part = cmd.split('=')[0].strip()\n            var_name = var_part.split()[-1]\n            instances[var_name] = RangeModule()\n            output.append(None)\n        else:\n            var_name, rest = cmd.split('.', 1)\n            method_name = rest.split('(')[0]\n            args_str = rest[rest.find('(')+1:rest.rfind(')')]\n            left_str, right_str = args_str.split(',')\n            left, right = int(left_str.strip()), int(right_str.strip())\n            if method_name == 'addRange':\n                instances[var_name].addRange(left, right)\n                output.append(None)\n            elif method_name == 'removeRange':\n                instances[var_name].removeRange(left, right)\n                output.append(None)\n            elif method_name == 'queryRange':\n                result = instances[var_name].queryRange(left, right)\n                output.append(result)\n\n    # Print output as JSON array with lowercase booleans and null\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code (step by step) for implementing a RangeModule data structure, following the problem statement. It should be generic, like pseudocode but not actual code. Each line must contain a step plus comment. Use arrow syntax as in example. Use Start, End, Decision. We need to show initialization, addRange, queryRange, removeRange operations. Use a data structure like balanced BST or list of intervals. We'll describe steps.\n\nWe need to output as per format: each line: \"虛擬碼步驟 // 解釋\".\n\nWe can present as a flowchart style. Should be step-by-step pseudocode. Provide each method's logic.\n\nWe'll design using sorted list of non-overlapping intervals. Use merge operations.\n\nPseudo steps:\n\nStart\n→ Initialize empty list intervals\nEnd\n\nMethod addRange(left,right)\n→ If left >= right, return\n→ Find position where left would be inserted\n→ Merge overlapping intervals: while current interval starts <= right\n    set left = min(left, current.start)\n    set right = max(right, current.end)\n    remove current\n→ Insert merged interval at position\n\nMethod queryRange\n→ If left >= right return true\n→ Find interval that could cover left: binary search\n→ If found and interval.start <= left and interval.end >= right return true\n→ Else return false\n\nMethod removeRange\n→ If left >= right return\n→ Find intervals that overlap with [left,right)\n→ For each overlapping:\n    if interval.start < left: keep left part [interval.start,left)\n    if interval.end > right: keep right part [right,interval.end)\n    remove original\n→ Insert remaining parts\n\nWe need to represent decision branches.\n\nWe need to provide each line with arrow and comment.\n\nWe can show separate methods after Start? Could use labels for each method. Provide separate sections.\n\nWe need to use the arrow syntax. Provide \"Decision:\" lines for conditional branches.\n\nWe'll output as a single flowchart but with methods separated. Provide lines with \"Method: addRange\" maybe as a label.\n\nLet's produce a structured step-by-step. Use indentation? They didn't specify indentation but example used indentation for nested decisions.\n\nWe will produce lines like:\n\nStart // 程式開始執行\n→ Initialize intervals as empty list // 建立空的區間集合\nEnd // 程式結束\n\nThen separate method definitions:\n\nStart // 初始化 RangeModule\n→ Method addRange // 添加區間\n    → Decision: 是否 left >= right? // 判斷區間是否合法\n        Yes → Return // 無效區間直接返回\n        No  → Continue\n    → Find first interval with end >= left // 找到可能重疊的起始位置\n    → While current interval start <= right\n        → Update left = min(left, current.start) // 合併左端\n        → Update right = max(right, current.end) // 合併右端\n        → Remove current interval // 刪除重疊區間\n    → Insert merged [left,right) at found position // 插入新合併區間\n    → End // addRange 完成\n\nAnd similarly for queryRange and removeRange.\n\nNeed to be careful with syntax: use \"→\" arrow for each step. For nested decisions, indent lines after Decision.\n\nMake sure each line ends with // 解釋.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize intervals as empty list // 建立一個空的區間集合，所有區間皆保持不重疊且有序  \nEnd // 程式結束  \n\n---  \n// ---------------------------  \n// RangeModule 類別初始化  \n// ---------------------------  \nStart // RangeModule 初始化  \n→ intervals ← [] // 內部使用有序不重疊區間的清單  \nEnd // 初始化完成  \n\n---  \n// ---------------------------  \n// addRange 方法  \n// ---------------------------  \nStart // addRange 方法開始  \n→ Method addRange(left, right) // 定義 addRange 函式  \n    → Decision: 是否 left >= right? // 檢查區間長度是否為零或負數  \n        Yes → Return // 無效區間直接結束  \n        No  → Continue // 有效區間繼續處理  \n    → Find idx ← index of first interval with end >= left // 找到可能重疊的起始位置  \n    → While idx < intervals.length AND intervals[idx].start <= right  \n        → left ← min(left, intervals[idx].start) // 合併左端點  \n        → right ← max(right, intervals[idx].end) // 合併右端點  \n        → Remove intervals[idx] // 刪除已重疊區間  \n        → Continue // 留在同一索引處繼續檢查下個區間  \n    → Insert [left, right) at position idx in intervals // 插入合併後的新區間  \nEnd // addRange 完成  \n\n---  \n// ---------------------------  \n// queryRange 方法  \n// ---------------------------  \nStart // queryRange 方法開始  \n→ Method queryRange(left, right) // 定義 queryRange 函式  \n    → Decision: 是否 left >= right? // 檢查區間長度是否為零或負數  \n        Yes → Return true // 空區間皆視為已追蹤  \n        No  → Continue  \n    → Find idx ← index of interval with start <= left < end // 找到左端可能屬於的區間  \n    → Decision: 是否存在 such interval?  \n        No  → Return false // 沒有區間覆蓋左端  \n        Yes → \n            → Decision: 是否 intervals[idx].end >= right?  \n                Yes → Return true // 整個區間都被追蹤  \n                No  → Return false // 右端未被追蹤  \nEnd // queryRange 完成  \n\n---  \n// ---------------------------  \n// removeRange 方法  \n// ---------------------------  \nStart // removeRange 方法開始  \n→ Method removeRange(left, right) // 定義 removeRange 函式  \n    → Decision: 是否 left >= right? // 檢查區間長度是否為零或負數  \n        Yes → Return // 無效區間直接結束  \n        No  → Continue  \n    → Find idx ← index of first interval with end > left // 找到可能重疊的起始位置  \n    → While idx < intervals.length AND intervals[idx].start < right  \n        → Decision: intervals[idx].start < left? // 是否需要保留左半部分  \n            Yes → \n                → newLeft ← intervals[idx].start  \n                → newRight ← left  \n                → Update intervals[idx] ← [newLeft, newRight] // 保留左半區間  \n                → idx ← idx + 1 // 移至下一個區間  \n            No → idx ← idx // 不保留左半部分，保持 idx  \n        → Decision: intervals[idx].end > right? // 是否需要保留右半部分  \n            Yes → \n                → newLeft ← right  \n                → newRight ← intervals[idx].end  \n                → Replace intervals[idx] with [newLeft, newRight] // 保留右半區間  \n                → Break // 右端已處理完畢，結束迴圈  \n            No → \n                → Remove intervals[idx] // 整個區間完全被刪除  \n                → Continue // 保持同一索引處檢查下一個重疊區間  \nEnd // removeRange 完成  \n\n---  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsoqdxzlp.py\", line 78, in <module>\n    main()\n  File \"/tmp/tmpsoqdxzlp.py\", line 62, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n    result = []\n    obj = None\n    for op, a in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(a[0])\n            result.append(None)\n        else:\n            method = getattr(obj, op)\n            res = method(*a)\n            result.append(res)\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. We must not output actual code. Use the arrow syntax etc.\n\nWe need to design the class. We'll provide steps: initialization, insert front, insert last, delete front, delete last, get front, get rear, is empty, is full. Use array with head and tail pointers maybe. We'll provide virtual steps.\n\nLet's create a main start, then define class MyCircularDeque with constructor, operations, using a circular buffer array. We'll outline steps in virtual code.\n\nWe should use \"Start\" and \"End\". Each step includes arrow \"→\". For decisions use \"Decision:\" with Yes/No arrows.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Class MyCircularDeque // 定義輪轉雙端佇列類別\n    → Constructor(k) // 初始化佇列容量與索引\n        → Step 1: 建立容量為 k+1 的陣列 arr // 多一位避免 head==tail 同時表示空滿\n        → Step 2: 設定 head = 0, tail = 0 // 佇列空\n        → Step 3: 設定 maxSize = k+1 // 用於判斷滿\n    → Method insertFront(value) // 在前端插入\n        → Decision: 是否滿? (isFull?) // 檢查是否已滿\n            Yes → Return false // 無法插入\n            No → Step 4: head = (head - 1 + maxSize) mod maxSize // 前移 head\n                  Step 5: arr[head] = value // 放入資料\n                  Return true // 成功\n    → Method insertLast(value) // 在後端插入\n        → Decision: 是否滿? (isFull?)\n            Yes → Return false\n            No → Step 6: arr[tail] = value // 放入資料\n                  Step 7: tail = (tail + 1) mod maxSize // 後移 tail\n                  Return true\n    → Method deleteFront() // 刪除前端\n        → Decision: 是否空? (isEmpty?)\n            Yes → Return false\n            No → Step 8: head = (head + 1) mod maxSize // 前移 head\n                  Return true\n    → Method deleteLast() // 刪除後端\n        → Decision: 是否空? (isEmpty?)\n            Yes → Return false\n            No → Step 9: tail = (tail - 1 + maxSize) mod maxSize // 後移 tail\n                  Return true\n    → Method getFront() // 取得前端值\n        → Decision: 是否空? (isEmpty?)\n            Yes → Return -1\n            No → Return arr[head]\n    → Method getRear() // 取得後端值\n        → Decision: 是否空? (isEmpty?)\n            Yes → Return -1\n            No → Return arr[(tail - 1 + maxSize) mod maxSize]\n    → Method isEmpty() // 判斷是否空\n        → Return head == tail\n    → Method isFull() // 判斷是否滿\n        → Return (tail + 1) mod maxSize == head\nEnd // 程式執行結束\n\nAdd explanations after // for each line.\n\nWe must keep format exactly: each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe must not output actual code. Use no code syntax. Use pseudo. Ensure each line has arrow and comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MyCircularDeque // 定義輪轉雙端佇列類別  \n → Constructor(k) // 初始化佇列容量與索引  \n  → Step 1: 建立容量為 k+1 的陣列 arr // 多一位避免 head==tail 同時表示空滿  \n  → Step 2: 設定 head = 0, tail = 0 // 佇列空  \n  → Step 3: 設定 maxSize = k+1 // 用於判斷滿  \n → Method insertFront(value) // 在前端插入  \n  → Decision: 是否滿? (isFull?)  \n   Yes → Return false // 無法插入  \n   No → Step 4: head = (head - 1 + maxSize) mod maxSize // 前移 head  \n    Step 5: arr[head] = value // 放入資料  \n    Return true // 成功  \n → Method insertLast(value) // 在後端插入  \n  → Decision: 是否滿? (isFull?)  \n   Yes → Return false  \n   No → Step 6: arr[tail] = value // 放入資料  \n    Step 7: tail = (tail + 1) mod maxSize // 後移 tail  \n    Return true  \n → Method deleteFront() // 刪除前端  \n  → Decision: 是否空? (isEmpty?)  \n   Yes → Return false  \n   No → Step 8: head = (head + 1) mod maxSize // 前移 head  \n    Return true  \n → Method deleteLast() // 刪除後端  \n  → Decision: 是否空? (isEmpty?)  \n   Yes → Return false  \n   No → Step 9: tail = (tail - 1 + maxSize) mod maxSize // 後移 tail  \n    Return true  \n → Method getFront() // 取得前端值  \n  → Decision: 是否空? (isEmpty?)  \n   Yes → Return -1  \n   No → Return arr[head]  \n → Method getRear() // 取得後端值  \n  → Decision: 是否空? (isEmpty?)  \n   Yes → Return -1  \n   No → Return arr[(tail - 1 + maxSize) mod maxSize]  \n → Method isEmpty() // 判斷是否空  \n  → Return head == tail  \n → Method isFull() // 判斷是否滿  \n  → Return (tail + 1) mod maxSize == head  \nEnd // 程式執行結束"
    },
    {
      "title": "Mini Parser",
      "source_file": "Leetcode/leetcode385.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[123,[456,[789]]]'\nGot (Norm):      '[[123,[456,[789]]]]'\n--- (Raw) ---\nRaw Expected: '[123,[456,[789]]]'\nRaw Got:      '[[123,[456,[789]]]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass NestedInteger:\n    \"\"\"\n    This class stores either a single integer or a nested list of NestedInteger objects.\n    \"\"\"\n    def __init__(self, value=None):\n        if value is None:\n            self._int = None\n            self._list = []\n        elif isinstance(value, int):\n            self._int = value\n            self._list = None\n        else:\n            raise ValueError(\"Unsupported value type\")\n\n    def isInteger(self):\n        return self._int is not None\n\n    def add(self, elem):\n        if self.isInteger():\n            raise Exception(\"Cannot add to an integer NestedInteger\")\n        self._list.append(elem)\n\n    def setInteger(self, value):\n        self._int = value\n        self._list = None\n\n    def getInteger(self):\n        return self._int\n\n    def getList(self):\n        return self._list\n\n    def __repr__(self):\n        if self.isInteger():\n            return str(self._int)\n        return '[' + ','.join(repr(e) for e in self._list) + ']'\n\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        \"\"\"\n        Deserialize the string s into a NestedInteger object.\n        \"\"\"\n        # If the string does not start with '[', it represents a single integer\n        if not s or s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack = []\n        current = NestedInteger()\n        stack.append(current)\n\n        num = ''\n        negative = False\n\n        # Iterate over each character\n        for ch in s:\n            if ch == '[':\n                # Start of a new nested list\n                new_ni = NestedInteger()\n                stack.append(new_ni)\n            elif ch == '-':\n                negative = True\n            elif ch.isdigit():\n                num += ch\n            elif ch in ',]':\n                # If we have accumulated digits, create an integer NestedInteger\n                if num:\n                    val = int(num)\n                    if negative:\n                        val = -val\n                    stack[-1].add(NestedInteger(val))\n                    num = ''\n                    negative = False\n                # When encountering ']', close the current list\n                if ch == ']' and len(stack) > 1:\n                    finished = stack.pop()\n                    stack[-1].add(finished)\n\n        # The bottom of the stack is the outermost NestedInteger\n        return stack[0]\n\n\ndef parse_input(text: str) -> str:\n    \"\"\"\n    Extract the serialized string from the raw input text.\n    Handles formats like:\n        s = \"[1,2,3]\"\n        \"[1,2,3]\"\n        123\n    \"\"\"\n    # Look for content inside double quotes\n    match = re.search(r'\"([^\"]*)\"', text)\n    if match:\n        return match.group(1)\n\n    # If no quotes, try to split on '='\n    if '=' in text:\n        _, value = text.split('=', 1)\n        value = value.strip()\n    else:\n        value = text.strip()\n\n    # Strip surrounding quotes if present\n    if value.startswith('\"') and value.endswith('\"'):\n        value = value[1:-1]\n    return value\n\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read()\n    # Extract the serialized string\n    serialized_str = parse_input(raw_input.strip())\n\n    # Deserialize using the provided solution\n    sol = Solution()\n    nested = sol.deserialize(serialized_str)\n\n    # Output the representation of the deserialized NestedInteger\n    print(repr(nested))",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for deserializing nested integer list string. Provide step by step virtual code with comments. Use Start, End, Decision. Each line should be one step. Use arrow \"→\". We need to handle parsing of nested list: If string starts with '[' then it's a list; else integer. We'll use stack or recursion.\n\nWe need to produce line-by-line pseudocode with comment after space and //.\n\nMake sure we use \"虛擬碼步驟\" then space then comment. Use \"Start\", \"End\", \"Decision:\" etc.\n\nLet's produce typical algorithm:\n\nStart\n→ Decision: 是否以 '[' 開頭? // Check if string starts with '[' indicating list\n    Yes → Step 1: 初始化一個空的 NestedInteger list // Create result list\n          → Step 2: 用一個堆疊存儲 NestedInteger 對象，push result // Stack to manage nested lists\n          → Step 3: 從索引 1 開始遍歷 s，直到最後一個字符 ']' // Parse characters inside outer list\n                → Decision: 如果字符是 '['? // Start of a sublist\n                    Yes → Step 4: 創建新的 NestedInteger list，推入堆疊 // New sublist\n                    No → Decision: 如果字符是 ']'? // End of current sublist\n                        Yes → Step 5: 將堆疊頂部彈出，並將其加入上層堆疊頂部 // Close sublist\n                        No → Decision: 如果字符是 ','? // Skip comma\n                            Yes → Step 6: 跳過 // Move to next\n                            No → Step 7: 讀取整數值直到 ',' 或 ']' // Parse number\n                                    → Step 8: 建立 NestedInteger 整數，加入堆疊頂部 // Add integer\n            → Step 9: 返回堆疊頂部作為結果 // Completed\n    No → Step 10: 直接將整數解析為 NestedInteger，返回 // String is single integer\nEnd\n\nWe need to include each line with \"→\" and explanation.\n\nAlso need to include End step.\n\nLet's format accordingly.\n\nWe'll use arrows \"→\" but not double arrow maybe for sub steps.\n\nWe must use \"Decision:\" for if conditions. For loop we can have Step lines.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: s 是否以 '[' 開頭? // 判斷輸入是否為列表  \n Yes → Step 1: 建立一個空的 NestedInteger list 作為結果 // 初始外層列表  \n  → Step 2: 建立堆疊 stack，並將結果推入堆疊 // 用堆疊追蹤目前處理的列表  \n  → Step 3: 設定索引 i = 1，開始從 s[1] 逐字元處理直到最後一個 ']' // 解析外層列表內容  \n   → Decision: s[i] 是 '['? // 發現新的子列表開頭  \n    Yes → Step 4: 建立新的空 NestedInteger list，推入堆疊 // 進入子列表  \n    No → Decision: s[i] 是 ']'? // 判斷是否結束目前列表  \n     Yes → Step 5: 從堆疊中彈出頂部，並將其加到新堆疊頂部（上層列表） // 關閉子列表  \n     No → Decision: s[i] 是 ','? // 逗號分隔符，跳過  \n      Yes → Step 6: i += 1，跳過逗號 // 進入下一項目  \n      No → Step 7: 讀取整數值直到遇到 ',' 或 ']' // 把數字拆開  \n       → Step 8: 轉換讀取到的子串為整數，建立 NestedInteger 整數，加入堆疊頂部 // 加入數字到目前列表  \n       → Step 9: i 移至下一個有效字符，繼續迴圈  \n  → Step 10: 回傳堆疊頂部（最外層列表）作為結果 // 解析完畢  \n No → Step 11: 直接將整個 s 轉為整數，建立 NestedInteger 整數，並返回 // s 為單一整數  \nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,5,5,8,8]'\nGot (Norm):      '[None,4,5,5,8,8]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 5, 5, 8, 8]'\nRaw Got:      '[None, 4, 5, 5, 8, 8]'"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,7,7,7,8]'\nGot (Norm):      '[None,7,7,7,8]'\n--- (Raw) ---\nRaw Expected: '[null, 7, 7, 7, 8]'\nRaw Got:      '[None, 7, 7, 7, 8]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two lists: operations and arguments\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'\n    args_str = parts[1]\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == 'KthLargest':\n            k, nums = arg\n            obj = KthLargest(k, nums)\n            result.append(None)\n        else:  # 'add'\n            val = arg[0]\n            res = obj.add(val)\n            result.append(res)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for this problem. The class KthLargest. Use min-heap of size k to maintain kth largest. Steps: constructor: initialize heap, push initial nums if less than k, else maintain. add: push val, if size>k pop smallest. return heap[0] (min). We'll produce virtual code with Start, End, Decision, etc. Need to output lines with \"→\" and comments. No actual code. Let's produce.\n\nWe'll start with Start. Then steps: initialize heap empty. Set k. Insert initial nums: loop over each num: call add (or push). But we can just do for each: push and if size>k pop. Then after constructor, return. Then add method: push val, if size>k pop. Return min.\n\nLet's produce steps for class initialization and add. Each step with explanation. Use \"Decision:\" for if condition. Use \"Yes →\", \"No →\".\n\nLet's craft.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 KthLargest 類別 // 建立類別\n→ Step 2: 建立私有成員變數 k, minHeap // 需要保存 k 與最小堆\n→ Step 3: Constructor KthLargest(k, nums) // 初始化方法\n→ Step 4: 設定 k 為輸入 k // 設定 k 值\n→ Step 5: 初始化 minHeap 為空堆 // 建立最小堆\n→ Step 6: 對 nums 中每個 score 執行 AddToHeap(score) // 處理初始分數\n→ Step 7: End Constructor // 結束建構\n→ Step 8: 方法 add(val) // 新增分數\n→ Step 9: Push val 到 minHeap // 加入分數\n→ Step 10: Decision: minHeap 大小 > k? // 判斷堆是否超出 k\n    Yes → Pop 最小值 from minHeap // 去除最小，保持大小 k\n    No  → // 不需要移除\n→ Step 11: Return minHeap 根元素 // 返回第 k 大\n→ End // 程式執行結束\n\nBut we also need to include loop for initializing initial nums. We'll do \"Decision\" for each number? Might simpler: \"Loop over nums: push/pop as add\" but we can just call add for each. Let's incorporate.\n\nAlso need to provide \"Step\" numbers? Not necessary but fine.\n\nMake sure format: \"→ Step X: ...\" each line. Provide explanation comment after //. Provide \"Decision:\" lines indented? In sample they indent. We'll mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 KthLargest 類別 // 建立類別\n→ Step 2: 建立私有成員變數 k, minHeap // 需要保存 k 與最小堆\n→ Step 3: Constructor KthLargest(k, nums) // 初始化方法\n→ Step 4: 設定 k 為輸入 k // 設定 k 值\n→ Step 5: 初始化 minHeap 為空堆 // 建立最小堆\n→ Step 6: 對 nums 中每個 score 執行 AddScore(score) // 處理初始分數\n    → Decision: score 是否已存在? // 簡化說明：此處直接使用 add 邏輯\n        Yes → // 這裡不會發生\n        No  → Step 7: Push score 到 minHeap // 加入分數\n            → Decision: minHeap 大小 > k? // 判斷堆是否超出 k\n                Yes → Step 8: Pop 最小值 from minHeap // 去除最小，保持大小 k\n                No  → // 不需要移除\n→ Step 9: End Constructor // 結束建構\n→ Step 10: 方法 add(val) // 新增分數\n→ Step 11: Push val 到 minHeap // 加入分數\n→ Step 12: Decision: minHeap 大小 > k? // 判斷堆是否超出 k\n    Yes → Step 13: Pop 最小值 from minHeap // 去除最小，保持大小 k\n    No  → // 不需要移除\n→ Step 14: Return minHeap 根元素 // 返回第 k 大\n→ End // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"\n        Find all groups of duplicate file paths based on file content.\n\n        Args:\n            paths (list[str]): Each string contains a directory path followed by\n                               file entries in the format \"name(content)\".\n\n        Returns:\n            list[list[str]]: Groups of duplicate file paths.\n        \"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            # Split the string by whitespace: first part is directory, rest are files.\n            parts = path.split()\n            if not parts:\n                continue\n            root = parts[0]\n            for file_info in parts[1:]:\n                # Separate filename and content.\n                name, content = file_info.split('(')\n                content = content.rstrip(')')  # Remove the trailing ')'.\n                # Build the full file path and map it by content.\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # Only keep groups with two or more files.\n        return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin.\n    raw_input = sys.stdin.read().strip()\n\n    # Handle optional leading variable assignment like \"paths = [...]\".\n    if raw_input.startswith(\"paths\"):\n        _, _, raw_input = raw_input.partition(\"=\")\n        raw_input = raw_input.strip()\n\n    # Safely evaluate the list literal.\n    try:\n        paths_list = ast.literal_eval(raw_input)\n    except Exception as e:\n        # If parsing fails, output an empty list and exit.\n        print([])\n        sys.exit(0)\n\n    # Compute and print the duplicate groups.\n    solution = Solution()\n    result = solution.findDuplicate(paths_list)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm described. Must produce step-by-step with explanation after each line. Use Start, End, Decision etc. No actual code. Just virtual. Let's design algorithm: iterate each input path string, split by space to get dir and file entries. For each file entry, extract filename and content within parentheses. Build map content -> list of full path. After all, collect lists with length>=2. Return.\n\nLet's produce pseudocode lines with arrow. Each line separate. Use \"Start\" etc.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 contentMap，鍵為檔案內容，值為檔案完整路徑列表 // 用於收集相同內容的檔案  \n→ Step 2: 迭代每個 directoryInfo 字串 in input list // 處理每個目錄資訊  \n    → Step 2.1: 以空格分割 directoryInfo，取第一段作為 dirPath，剩餘部分為 fileEntries // 確定目錄路徑與檔案列表  \n    → Decision: 是否有 fileEntries? // 檢查是否有檔案  \n      Yes → Step 2.2: 迭代每個 fileEntry in fileEntries // 逐一處理檔案  \n        → Step 2.2.1: 以 '(' 分割，取前半段作為 fileName，後半段取除最後一個 ')' 的子字串作為 fileContent // 取得檔名與內容  \n        → Step 2.2.2: 組合 fullPath = dirPath + \"/\" + fileName // 形成完整路徑  \n        → Step 2.2.3: 若 fileContent 不在 contentMap 中，新增 entry contentMap[fileContent] = 空列表 // 初始化列表  \n        → Step 2.2.4: 將 fullPath 加入 contentMap[fileContent] 列表 // 記錄檔案  \n      No → Step 2.3: 直接跳過 // 沒有檔案時不執行任何操作  \n→ Step 3: 建立結果列表 result = 空列表 // 用於儲存重複檔案群組  \n→ Step 4: 迭代 contentMap 的每一個 key, value對 // 檢查每組內容  \n    → Decision: value 列表長度 >= 2? // 是否至少兩個檔案  \n      Yes → Step 4.1: 將 value 列表加入 result // 加入重複檔案群組  \n      No → Step 4.2: 跳過 // 不足兩個不列入結果  \n→ End // 程式執行結束，返回 result\n\n---  \n// 以上虛擬碼逐行說明了如何從目錄資訊字串中提取檔案路徑與內容，並找出所有重複內容的檔案群組。"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmnjd0xvt.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmpmnjd0xvt.py\", line 35, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmpmnjd0xvt.py\", line 10, in rand10\n    a = rand7()          # rand7() 產生 1~7\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbkyj46v3.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmpbkyj46v3.py\", line 35, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmpbkyj46v3.py\", line 10, in rand10\n    a = rand7()          # rand7() 產生 1~7\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8lbwddg9.py\", line 39, in <module>\n    main()\n  File \"/tmp/tmp8lbwddg9.py\", line 35, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmp8lbwddg9.py\", line 10, in rand10\n    a = rand7()          # rand7() 產生 1~7\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        產生 1~10 的均勻隨機整數，僅使用 rand7() 兩次。\n        方法：使用兩次 rand7() 產生 0~48 的整數，若小於 40 則映射到 1~10，否則重試。\n        \"\"\"\n        while True:\n            a = rand7()          # rand7() 產生 1~7\n            b = rand7()          # 再產生 1~7\n            # 把兩個 7 進位數轉成 0~48 的整數\n            num = (a - 1) * 7 + (b - 1)\n            if num < 40:         # 0~39 可以映射到 1~10\n                return (num % 10) + 1\n            # num >= 40 時拒絕採樣，重新迴圈\n\ndef main():\n    \"\"\"\n    讀取輸入，輸出 n 次 rand10() 的結果。\n    輸入格式範例：'n = 3' 或 '3'。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入取得 n\n    if '=' in data:\n        _, value = data.split('=', 1)\n        n = int(value.strip())\n    else:\n        n = int(data)\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating rand10 from rand7. Classic approach: use rejection sampling: combine two rand7 to get 49 outcomes; map 1-40 to 1-10, reject 41-49. Or use base-7 representation to generate 0-48, map modulo 10. Provide virtual steps.\n\nNeed to output line by line with arrow notation.\n\nWe'll design: Start → Step: repeat loop → get a = rand7() → get b = rand7() → compute num = (a-1)*7 + (b-1) // 0-48 → if num < 40 → return num%10+1 → else → repeat loop. End.\n\nProvide comments.\n\nAlso maybe explain rejection probability.\n\nLet's produce virtual code. Use Decision with Yes →, No → loops.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 開始一個無限迴圈 // 用來重複產生隨機數直到符合條件  \n    → Step 2: a ← rand7() // 產生第一個 1~7 的隨機整數  \n    → Step 3: b ← rand7() // 再產生第二個 1~7 的隨機整數  \n    → Step 4: num ← (a - 1) * 7 + (b - 1) // 把兩個 7 進位數轉成 0~48 的整數  \n    → Decision: 是否 num < 40? // 檢查是否落在可接受範圍內  \n        Yes → Step 5: return (num mod 10) + 1 // 轉成 1~10 的隨機整數並結束迴圈  \n        No  → Step 6: 轉到 Step 1 // 若超過 39，重新嘗試（拒絕採樣）  \nEnd // 程式執行結束 (當 return 觸發時)"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnomu825s.py\", line 50, in <module>\n    price, special, needs = parse_input(input_data)\n                            ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnomu825s.py\", line 40, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5750z8bd.py\", line 50, in <module>\n    price, special, needs = parse_input(input_data)\n                            ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5750z8bd.py\", line 40, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # cost without using any special offer\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # try every special offer\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(input_str):\n    # regex to capture three lists\n    pattern = re.compile(\n        r'price\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*'\n        r'special\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*'\n        r'needs\\s*=\\s*(\\[[^\\]]*\\])',\n        re.DOTALL\n    )\n    m = pattern.search(input_str)\n    if not m:\n        raise ValueError(\"Input format is incorrect.\")\n    price = ast.literal_eval(m.group(1))\n    special = ast.literal_eval(m.group(2))\n    needs = ast.literal_eval(m.group(3))\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit()\n    price, special, needs = parse_input(input_data)\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving this LeetCode problem (Shopping Offers). We need to output each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc.\n\nWe should outline algorithm: DFS with memoization/backtracking. Steps: Start, preprocess offers, define helper function dfs(current needs). For each offer, check if can apply; if yes, subtract; compute cost = offer price + dfs(new needs). Keep min. Also compute cost without offers: sum(needs[i]*price[i]). Use memoization map of tuple(needs) to min cost. End.\n\nWe need to produce step-by-step pseudocode lines. Each line include arrow. Use \"→\" for sequential. Use indentation? Not required but can indent lines after decision with tabs or spaces. The example used indentation with spaces. We'll produce similar.\n\nWe should keep each line simple. We'll describe functions.\n\nLet's craft.\n\nStart // start program\n→ Function: solve(price, needs, special) // main entry\n→ Build memo map // cache results\n→ Define DFS(currentNeeds) // recursive helper\n    → Convert currentNeeds to key string // for memo lookup\n    → If key in memo → Return memo[key] // cached result\n    → Calculate baseCost = sum(currentNeeds[i]*price[i]) // no offers\n    → minCost = baseCost\n    → For each offer in special:\n        → Check if offer can be applied: for all i, offer[i] <= currentNeeds[i]\n        → If applicable:\n            → newNeeds = currentNeeds[i] - offer[i] for all i\n            → offerCost = offer[last] + DFS(newNeeds) // offer price + rest\n            → If offerCost < minCost → minCost = offerCost\n    → memo[key] = minCost\n    → Return minCost\n→ Call DFS(needs) // compute answer\n→ Return result\nEnd // end program\n\nNeed each line with arrow or start/decision. We also need Decision lines. In loops, maybe use Decision. But we can keep simpler.\n\nLet's produce each line following format: \"虛擬碼步驟 // 解釋\". Use \"→\" before each step after Start. For Decision, use \"Decision:\" etc.\n\nWe'll also include arrow inside loop for condition. We'll include indentation with spaces.\n\nLet's write lines:\n\nStart // 程式開始執行\n→ Function solve(price, needs, special) // 主要入口，傳入價格、需求與特價\n    → memo = {} // 用於記錄已算過的需求組合對應的最小價格\n    → Define DFS(currentNeeds) // 以遞迴方式計算最小價格\n        → key = tuple(currentNeeds) // 將需求轉為鍵方便快取\n        → Decision: 如果 key 已在 memo? // 判斷是否已計算\n            Yes → Return memo[key] // 直接回傳已知結果\n            No  → // 繼續計算\n        → baseCost = 0\n        → For i in 0..n-1: // 計算不使用特價時的價格\n            → baseCost += currentNeeds[i] * price[i] // 每種商品的單價乘以需求量\n        → minCost = baseCost // 初始最小價格為不使用特價的成本\n        → For each offer in special: // 嘗試所有特價方案\n            → Decision: 能否使用此特價? // 檢查每種商品需求是否足夠\n                Yes → \n                    → newNeeds = []\n                    → For i in 0..n-1:\n                        → newNeeds[i] = currentNeeds[i] - offer[i] // 减去特價包裹中的數量\n                    → offerCost = offer[n] + DFS(newNeeds) // 特價費用 + 其餘需求的最小費用\n                    → Decision: offerCost < minCost? // 判斷是否更新最小價格\n                        Yes → minCost = offerCost // 用更便宜的方案替換\n                No → // 若不滿足需求，跳過此特價\n        → memo[key] = minCost // 將計算結果存入快取\n        → Return minCost // 回傳此需求組合的最小價格\n    → result = DFS(needs) // 從原始需求開始計算\n    → Return result // 傳回答案\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟 // 解釋\". We used indented lines but each line still has \"→\" at start. The sample used arrow for lines after start. So we should keep arrow at start of each line except Start and End? The sample uses \"Start // ...\", \"→ Step 1: ...\", \"→ Decision: ...\" etc. So we should format each line starting with \"Start\" or \"→\" or \"End\". Use arrow for all steps after Start. Indentation inside loops can be with spaces after arrow maybe? But the sample shows indentation with spaces after arrow? They had \"→ Decision:\" and then indent inside with spaces and \"Yes → Step...\" etc. So we need to maintain same pattern.\n\nThus our code lines:\n\nStart // 程式開始執行\n→ Function solve(price, needs, special) // 主要入口，傳入價格、需求與特價\n    → memo = {} // 用於記錄已算過的需求組合對應的最小價格\n    → Define DFS(currentNeeds) // 以遞迴方式計算最小價格\n        → key = tuple(currentNeeds) // 將需求轉為鍵方便快取\n        → Decision: 如果 key 已在 memo? // 判斷是否已計算\n            Yes → Return memo[key] // 直接回傳已知結果\n            No  → // 繼續計算\n        → baseCost = 0\n        → For i in 0..n-1: // 計算不使用特價時的價格\n            → baseCost += currentNeeds[i] * price[i] // 每種商品的單價乘以需求量\n        → minCost = baseCost // 初始最小價格為不使用特價的成本\n        → For each offer in special: // 嘗試所有特價方案\n            → Decision: 能否使用此特價? // 檢查每種商品需求是否足夠\n                Yes → \n                    → newNeeds = []\n                    → For i in 0..n-1:\n                        → newNeeds[i] = currentNeeds[i] - offer[i] // 减去特價包裹中的數量\n                    → offerCost = offer[n] + DFS(newNeeds) // 特價費用 + 其餘需求的最小費用\n                    → Decision: offerCost < minCost? // 判斷是否更新最小價格\n                        Yes → minCost = offerCost // 用更便宜的方案替換\n                No → // 若不滿足需求，跳過此特價\n        → memo[key] = minCost // 將計算結果存入快取\n        → Return minCost // 回傳此需求組合的最小價格\n    → result = DFS(needs) // 從原始需求開始計算\n    → Return result // 傳回答案\nEnd // 程式執行結束\n\nWe need to ensure each line begins with \"→\" except Start and End. Indent lines also start with \"→\" but we have nested indentation. The example shows indentation before \"Yes →\" etc. So we must maintain that style. Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function solve(price, needs, special) // 主要入口，傳入價格、需求與特價  \n    → memo = {} // 用於記錄已算過的需求組合對應的最小價格  \n    → Define DFS(currentNeeds) // 以遞迴方式計算最小價格  \n        → key = tuple(currentNeeds) // 將需求轉為鍵方便快取  \n        → Decision: 如果 key 已在 memo? // 判斷是否已計算  \n            Yes → Return memo[key] // 直接回傳已知結果  \n            No  → // 繼續計算  \n        → baseCost = 0  \n        → For i in 0..n-1: // 計算不使用特價時的價格  \n            → baseCost += currentNeeds[i] * price[i] // 每種商品的單價乘以需求量  \n        → minCost = baseCost // 初始最小價格為不使用特價的成本  \n        → For each offer in special: // 嘗試所有特價方案  \n            → Decision: 能否使用此特價? // 檢查每種商品需求是否足夠  \n                Yes →  \n                    → newNeeds = []  \n                    → For i in 0..n-1:  \n                        → newNeeds[i] = currentNeeds[i] - offer[i] // 減去特價包裹中的數量  \n                    → offerCost = offer[n] + DFS(newNeeds) // 特價費用 + 其餘需求的最小費用  \n                    → Decision: offerCost < minCost? // 判斷是否更新最小價格  \n                        Yes → minCost = offerCost // 用更便宜的方案替換  \n                No → // 若不滿足需求，跳過此特價  \n        → memo[key] = minCost // 將計算結果存入快取  \n        → Return minCost // 回傳此需求組合的最小價格  \n    → result = DFS(needs) // 從原始需求開始計算  \n    → Return result // 傳回答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Count of Range Sum",
      "source_file": "Leetcode/leetcode327.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp75vwn73k.py\", line 50, in <module>\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [-2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        # 前綴和\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        # 分治計數，返回區間 [lo, hi) 的合法範圍和個數\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:  # 只有一個元素，無合法子區間\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            # 計算跨左右子陣列的合法區間\n            i = j = mid\n            for left in prefix[lo:mid]:\n                # 找到最小滿足 left + lower 的位置\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                # 找到第一個超過 left + upper 的位置\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            # 合併兩個已排序的子陣列\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入格式：nums = [...], lower = ..., upper = ...\n    parts = [p.strip() for p in data.split(',')]\n    nums = None\n    lower = None\n    upper = None\n    for part in parts:\n        if part.startswith('nums'):\n            # 取等號右邊並評估為 list\n            nums_str = part.split('=', 1)[1].strip()\n            nums = eval(nums_str)\n        elif part.startswith('lower'):\n            lower = int(part.split('=', 1)[1].strip())\n        elif part.startswith('upper'):\n            upper = int(part.split('=', 1)[1].strip())\n\n    # 若解析失敗，嘗試使用正則表達式提取所有整數\n    if nums is None or lower is None or upper is None:\n        nums = list(map(int, re.findall(r'-?\\d+', data)))\n        # 假設第一個整數序列為 nums，接下來的兩個整數為 lower、upper\n        # 若 nums 需要完整數列，則可自行調整\n        if len(nums) >= 3:\n            lower = nums[-2]\n            upper = nums[-1]\n            nums = nums[:-2]\n\n    sol = Solution()\n    result = sol.countRangeSum(nums, lower, upper)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem is standard: count range sum using prefix sums and merge sort or BIT. We'll produce steps: compute prefix sums, then use merge sort divide and conquer to count pairs with difference in range. Provide virtual steps line by line. We'll need to follow the format exactly: each line \"虛擬碼步驟 // 解釋\". Use arrows etc. Use Start, End, Decision. Ensure each line separate.\n\nWe'll produce algorithm:\n\nStart\n→ Step: Calculate prefix sums array P of length n+1, P[0]=0, P[i+1]=P[i]+nums[i] // Compute cumulative sums\n→ Step: Call recursive function count_while_merge(P, 0, n) // count pairs using divide and conquer\n→ Step: Return result // final count\n\nDefine recursive function:\n\nDecision: if left>=right → return 0 // no range\n→ Step: mid = (left+right)//2\n→ Step: count = count_while_merge(P, left, mid) + count_while_merge(P, mid+1, right) // count left and right halves\n→ Step: count += count_cross(P, left, mid, right) // count cross pairs\n→ Step: merge sorted subarrays P[left:mid+1] and P[mid+1:right+1] // maintain sorted order\n→ Step: return count\n\ncount_cross:\n\nStep: initialize pointers i=left, j=mid+1, k=mid+1, valid_count=0\n→ While i<=mid:\n    → While j<=right and P[j] - P[i] < lower: j++ // move j to first >= lower\n    → While k<=right and P[k] - P[i] <= upper: k++ // move k to first > upper\n    → valid_count += k - j // number of valid k for this i\n    → i++\n\n→ Step: return valid_count\n\nWill produce virtual code steps accordingly.\n\nNeed to output each line with arrow etc.\n\nLet's produce:\n\nStart // 程式開始\n→ Step: 生成前綴和數組 P // P[0]=0, 之後累加 nums\n→ Step: P 之長度為 n+1 // 確保下標對應\n→ Decision: 若 n==0 → End // 空陣列直接結束\n    Yes → End // 空陣列，沒有子陣列\n    No  → Step: 呼叫 count_while_merge(P, 0, n) // 計算區間和數量\n→ Step: 計算結果 res = count_while_merge(P, 0, n) // 取得計數\n→ Step: 回傳 res // 結束\nEnd // 程式執行結束\n\nBut need to detail recursive steps. Actually we need to output code for entire algorithm. So after Step: 呼叫 count_while_merge, we need to define that function's steps. Since we output in order, we might list function body after.\n\nBut format: each line must be virtual step; function definition lines like \"Function count_while_merge(left, right):\" could be represented. We'll use \"Start\" then \"→ Function count_while_merge(left, right) // 計算區間和\" then substeps.\n\nWe'll structure:\n\nStart\n→ Function count_while_merge(left, right) // 計算區間和個數\n    → Decision: if left >= right → Return 0 // 基本情況\n        Yes → Return 0\n        No  → Step: mid = (left + right) // 2 // 中點\n            → Step: left_count = count_while_merge(left, mid) // 左半段\n            → Step: right_count = count_while_merge(mid+1, right) // 右半段\n            → Step: cross_count = count_cross(P, left, mid, right) // 跨段\n            → Step: count = left_count + right_count + cross_count // 總計\n            → Step: merge_sorted(P, left, mid, right) // 合併保持排序\n            → Step: Return count\n\nFunction count_cross(P, left, mid, right)\n    → Step: i = left; j = mid+1; k = mid+1; res = 0\n    → While i <= mid:\n        → While j <= right and P[j] - P[i] < lower: j++ // 找到最小滿足 lower\n        → While k <= right and P[k] - P[i] <= upper: k++ // 找到超過 upper\n        → res += k - j\n        → i++\n    → Step: Return res\n\nBut we need to use virtual arrows \"→\" each line; sublines indent with spaces? Example format uses indentation. We'll replicate.\n\nLet's produce final answer with each line starting with \"Start\" or \"→\" etc. Ensure each line has virtual code and comment. Use Chinese explanation. Use \"Decision:\" line. Use \"Yes →\" and \"No →\". Use \"→ Function\". Let's produce.\n\nAlso need to reference lower and upper variables defined externally. We'll mention that.\n\nWe'll produce full algorithm steps.\n\nLet's craft.\n...done thinking.\n\n```\nStart // 程式開始執行\n\n→ Function countRangeSum(nums, lower, upper) // 主入口函式\n    → Step: n = length(nums) // 取得陣列長度\n    → Step: P = new array of size n+1 // 前綴和陣列\n    → Step: P[0] = 0 // 前綴和初值\n    → For i from 0 to n-1:\n        → Step: P[i+1] = P[i] + nums[i] // 累積相加\n\n    → Step: result = count_while_merge(P, 0, n) // 呼叫遞迴計數\n    → Step: Return result // 傳回最終計數\nEnd // 主程式結束\n\n→ Function count_while_merge(P, left, right) // 以分治法計算範圍和\n    → Decision: if left >= right? // 基本情況，只有一個或零個元素\n        Yes → Step: Return 0 // 無區間可計算\n        No  → Step: mid = (left + right) // 2 // 計算中點\n            → Step: leftCount = count_while_merge(P, left, mid) // 左半段計數\n            → Step: rightCount = count_while_merge(P, mid+1, right) // 右半段計數\n            → Step: crossCount = count_cross(P, left, mid, right) // 跨段計數\n            → Step: total = leftCount + rightCount + crossCount // 累加總計\n            → Step: merge_sorted(P, left, mid, right) // 合併保持遞增順序\n            → Step: Return total\n\n→ Function count_cross(P, left, mid, right) // 計算跨左右段的合法範圍和\n    → Step: i = left; j = mid+1; k = mid+1; res = 0 // 初始化指標\n    → While i <= mid:\n        → While j <= right and P[j] - P[i] < lower:\n            → Step: j = j + 1 // 移動 j 到第一個滿足 lower 的位置\n        → While k <= right and P[k] - P[i] <= upper:\n            → Step: k = k + 1 // 移動 k 到第一個超過 upper 的位置\n        → Step: res = res + (k - j) // 對於此 i，所有 j~k-1 都是合法\n        → Step: i = i + 1 // 移動到下一個左段元素\n    → Step: Return res\n\n→ Function merge_sorted(P, left, mid, right) // 合併已排序的兩段\n    → Step: temp = empty list\n    → Step: i = left; j = mid + 1\n    → While i <= mid and j <= right:\n        → Decision: if P[i] <= P[j]? // 比較兩段首元素\n            Yes → Step: temp.append(P[i]); i = i + 1\n            No  → Step: temp.append(P[j]); j = j + 1\n    → While i <= mid:\n        → Step: temp.append(P[i]); i = i + 1\n    → While j <= right:\n        → Step: temp.append(P[j]); j = j + 1\n    → For idx, val in enumerate(temp):\n        → Step: P[left + idx] = val // 複製回原陣列\n```"
    },
    {
      "title": "Subarray Sum Equals K",
      "source_file": "Leetcode/leetcode560.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subarray_sum(nums, k):\n    \"\"\"計算子陣列總和等於 k 的個數。\"\"\"\n    count = 0\n    prefix_sum = 0\n    sum_map = {0: 1}  # 前綴和 0 出現一次\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - k in sum_map:\n            count += sum_map[prefix_sum - k]\n        sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n    return count\n\ndef parse_input(text: str):\n    \"\"\"從輸入文字中解析 nums 與 k。\"\"\"\n    text = text.strip()\n    if not text:\n        return [], 0\n\n    # 先嘗試以逗號分隔\n    if ',' in text:\n        arr_part, k_part = text.split(',', 1)\n    else:\n        # 若沒有逗號，嘗試逐行解析\n        lines = text.splitlines()\n        if len(lines) >= 2:\n            arr_part, k_part = lines[0], lines[1]\n        else:\n            # 仍未能解析時直接返回空\n            return [], 0\n\n    # 解析陣列\n    try:\n        nums = ast.literal_eval(arr_part.strip())\n    except Exception:\n        nums = []\n\n    # 解析 k\n    if '=' in k_part:\n        _, k_str = k_part.split('=', 1)\n    else:\n        k_str = k_part\n    try:\n        k = int(k_str.strip())\n    except Exception:\n        k = 0\n\n    return nums, k\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    nums, k = parse_input(input_text)\n    result = subarray_sum(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for the algorithm: count subarrays with sum k. Standard solution: use prefix sum and hashmap counts. Virtual code steps.\n\nWe must output line by line: each line with virtual code step + comment. Use arrow, Decision etc.\n\nWe need to structure: Start, initialize count=0, sum=0, map with 0:1. Iterate array: update sum; if sum-k in map, add map[sum-k] to count; increment map[sum]. After loop, End.\n\nAlso include decisions: check if map contains key. Use Decision. Provide brief explanation after each line.\n\nLet's write.\n\nNeed to keep format: \"Start // 程式開始執行\". Each subsequent line: \"→\" etc.\n\nBe careful with indentation for nested decisions. Use spaces indentation before lines inside decisions.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 count ← 0 // 儲存符合條件子陣列數量  \n→ Step 2: 設定 currentSum ← 0 // 記錄前綴和  \n→ Step 3: 設定 prefixCount ← {0: 1} // 以 0 作為前綴和出現一次  \n\n→ Decision: 如果 nums 為空? // 檢查輸入是否為空陣列  \n    Yes → Step 4: 回傳 count // 若空陣列，直接回傳 0  \n    No  → \n\n→ Step 5: For 每個 num 在 nums 之中 // 逐一遍歷陣列元素  \n    → currentSum ← currentSum + num // 更新前綴和  \n    → Decision: 如果 (currentSum - k) 在 prefixCount? // 判斷是否存在需要的前綴和  \n        Yes → Step 6: count ← count + prefixCount[currentSum - k] // 加上匹配子陣列數量  \n        No  →  \n    → Step 7: prefixCount[currentSum] ← prefixCount.get(currentSum, 0) + 1 // 記錄目前前綴和的出現次數  \n\n→ Step 8: 回傳 count // 回傳最終計算結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Two Sum II - Input Array Is Sorted",
      "source_file": "Leetcode/leetcode167.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpm_9ilhif.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmpm_9ilhif.py\", line 30, in main\n    exec(code, {}, data)\n  File \"<string>\", line 1\n    numbers = [2,7,11,15], target = 9\n    ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp555zhldv.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmp555zhldv.py\", line 30, in main\n    exec(code, {}, data)\n  File \"<string>\", line 1\n    numbers = [2,3,4], target = 6\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu09x64lq.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmpu09x64lq.py\", line 30, in main\n    exec(code, {}, data)\n  File \"<string>\", line 1\n    numbers = [-1,0], target = -1\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\ndef twoSum(numbers, target):\n    \"\"\"\n    兩指標法：用 left 指向左端，right 指向右端。\n    每次比較兩個數字之和與 target，根據結果調整指標。\n    這個做法只使用常數額外空間。\n    \"\"\"\n    left, right = 0, len(numbers) - 1\n    while left < right:\n        s = numbers[left] + numbers[right]\n        if s == target:\n            # 1‑indexed 的索引回傳\n            return [left + 1, right + 1]\n        elif s < target:\n            left += 1   # 需要更大的和，移動左指標\n        else:\n            right -= 1  # 需要更小的和，移動右指標\n    return []  # 理論上不會到這裡，因題目保證唯一解\n\ndef main():\n    \"\"\"\n    讀取 stdin，解析出 numbers 與 target，呼叫兩數之和演算法，並印出結果。\n    \"\"\"\n    data = {}\n    code = sys.stdin.read().strip()\n    if not code:\n        return\n    # 直接執行輸入的程式碼，從中取得 numbers 與 target\n    exec(code, {}, data)\n    numbers = data.get('numbers')\n    target = data.get('target')\n    result = twoSum(numbers, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line. Provide explanation. Need to solve two sum problem with sorted array, use two pointers. Constant extra space, return 1-indexed indices. We'll produce steps.\n\nMake sure to use \"Start\", \"End\", \"Decision:\" etc. Format each line: \"虛擬碼步驟 // 解釋\". Use arrow → etc.\n\nWe should include comments like \"Start // 程式開始執行\" etc.\n\nWe'll produce pseudocode:\n\nStart\n→ Initialize left = 1 // 1-indexed left pointer\n→ Initialize right = length of numbers // 1-indexed right pointer\n→ Decision: While left < right? // loop condition\n    Yes → Decision: numbers[left] + numbers[right] == target? // check sum\n        Yes → Step: Return [left, right] // found solution\n        No  → Decision: numbers[left] + numbers[right] < target? // need larger sum\n            Yes → Step: left = left + 1 // move left pointer right\n            No  → Step: right = right - 1 // move right pointer left\n    No → End // no more pairs\n\nBut we must ensure \"End\" after loop. But we need to produce constant space.\n\nMake sure to have \"Step: Return\" etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ left ← 1 // 設定左指標為第一個元素（1 索引）  \n→ right ← length(numbers) // 設定右指標為最後一個元素（1 索引）  \n→ Decision: left < right? // 當左指標還在右指標左側時持續搜尋  \n Yes → Decision: numbers[left] + numbers[right] == target? // 判斷兩個指標指向的元素之和是否為目標值  \n  Yes → Step: Return [left, right] // 找到符合條件的兩個索引，結束程式  \n  No → Decision: numbers[left] + numbers[right] < target? // 若和太小，需增大總和  \n   Yes → Step: left ← left + 1 // 右移左指標，選擇更大的數字  \n   No → Step: right ← right - 1 // 左移右指標，選擇更小的數字  \n No → End // 左指標已超過右指標，搜尋結束（理論上不會執行，因題目保證唯一解）  \nEnd // 程式執行結束"
    },
    {
      "title": "Super Pow",
      "source_file": "Leetcode/leetcode372.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvdcbixpo.py\", line 26, in <module>\n    main()\n  File \"/tmp/tmpvdcbixpo.py\", line 21, in main\n    b = ast.literal_eval(b_str)  # parse list safely\n        ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp35igtkq0.py\", line 26, in <module>\n    main()\n  File \"/tmp/tmp35igtkq0.py\", line 21, in main\n    b = ast.literal_eval(b_str)  # parse list safely\n        ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef super_pow(a: int, b: list[int]) -> int:\n    MOD = 1337\n    result = 1\n    for digit in b:\n        result = (pow(result, 10, MOD) * pow(a, digit, MOD)) % MOD\n    return result\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Example input format: \"a = 2, b = [3]\"\n    parts = [p.strip() for p in data.split(',')]\n    a_part = parts[0]\n    b_part = parts[1] if len(parts) > 1 else ''\n    a = int(a_part.split('=')[1].strip())\n    b_str = b_part.split('=')[1].strip() if '=' in b_part else '[]'\n    b = ast.literal_eval(b_str)  # parse list safely\n    result = super_pow(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm to compute a^b mod 1337, where a positive integer a, b is huge given as array of digits (or maybe array of numbers representing decimal digits). It's typical LeetCode problem \"Super Pow\". We need to produce steps, using arrow, Decision, etc.\n\nWe need to provide each line: virtual code step + // explanation. Use Start, End. Use decision etc.\n\nWe must not output actual code. Just pseudo-code steps.\n\nWe need to handle huge exponent array: compute a^b mod 1337 using exponentiation by repeated squaring and modular exponent for digits: since b is large, we can process each digit: exponent mod φ(1337)? Actually 1337=7*191. Not prime. But typical solution: use property of Euler's theorem: a^φ(m) ≡ 1 mod m if gcd(a,m)=1. For composite, can use Carmichael lambda or compute recursively.\n\nSimpler: use recursion: superPow(a, b) where b array. If b empty return 1. Else last digit d = b.pop(); compute pow = superPow(a, b). result = (pow^10 * a^d) mod 1337. Use fast pow modulo.\n\nOk produce pseudo-code.\n\nLet's produce steps:\n\nStart\n→ Read a, b_array\n→ Define function modExp(base, exponent, mod) // fast exponent mod\n→ Define function superPow(a, b_array) // compute a^b mod 1337\nDecision: if b_array empty? // base case\n    Yes → Return 1 // exponent 0\n    No  → Let d = last element of b_array\n    → Call superPow(a, b_array_without_last) // recursive call\n    → Let pow10 = modExp(result, 10, 1337) // result^10 mod 1337\n    → Let aPowD = modExp(a, d, 1337) // a^d mod 1337\n    → Return (pow10 * aPowD) mod 1337\n→ Call superPow(a, b_array) // compute answer\n→ Output answer\nEnd\n\nBut we need to list each line step with arrow and explanation.\n\nNeed to be \"逐行\" produce each line. Use arrows and decision. Use indent? In example they indent inside decision using spaces. We can mimic.\n\nAlso include modExp implementation: typical binary exponent.\n\nDefine modExp base, exp, mod:\n    result = 1\n    while exp > 0:\n        if exp % 2 == 1: result = (result * base) % mod\n        base = (base * base) % mod\n        exp = exp // 2\n    return result\n\nBut we need to produce pseudo-code steps sequentially, not functions? But we can treat each as step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義變數 a, b_array // 讀取輸入的底數和指數陣列\n→ Step 2: 定義函式 modExp(base, exp, mod) // 快速模冪計算\n→ Step 3:   Inside modExp: result ← 1 // 初始化結果\n→ Step 4:   Inside modExp: while exp > 0 // 迴圈直到指數為 0\n→ Step 5:     Inside modExp: if exp mod 2 == 1 then result ← (result * base) mod mod\n→ Step 6:     Inside modExp: base ← (base * base) mod mod\n→ Step 7:     Inside modExp: exp ← exp // 2\n→ Step 8:   Inside modExp: return result // 返回模冪結果\n→ Step 9: 定義函式 superPow(a, b_array) // 計算 a^b mod 1337\n→ Step 10:   Inside superPow: Decision: if b_array 為空? // 指數已消耗完\n→ Step 11:       Yes → return 1 // a^0 = 1\n→ Step 12:       No → d ← b_array 的最後一個元素 // 取指數的最後一位\n→ Step 13:       Inside superPow: 移除 b_array 的最後一個元素 // 準備遞迴\n→ Step 14:       Inside superPow: sub ← superPow(a, b_array) // 先算 a^(b/10)\n→ Step 15:       Inside superPow: pow10 ← modExp(sub, 10, 1337) // (a^(b/10))^10 mod 1337\n→ Step 16:       Inside superPow: aPowD ← modExp(a, d, 1337) // a^d mod 1337\n→ Step 17:       Inside superPow: return (pow10 * aPowD) mod 1337 // 合併結果\n→ Step 18: Call superPow(a, b_array) 并存儲為 ans // 執行主計算\n→ Step 19: 輸出 ans // 顯示最終結果\nEnd // 程式執行結束\n\nNeed to ensure the syntax: Use arrow \"→\" before each step except Start and End. For decisions, we indent. Use \"Decision:\" and \"Yes →\" etc.\n\nLet's format lines exactly as required: each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nMake sure each line is single line.\n\nWe need to maintain indentation using spaces before lines under decision.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 a 與 b_array // 取得底數與指數陣列  \n→ Step 2: 定義函式 modExp(base, exp, mod) // 快速模冪計算  \n→ Step 3:   modExp: result ← 1 // 初始化結果  \n→ Step 4:   modExp: while exp > 0 // 迴圈直到指數為 0  \n→ Step 5:     modExp: if exp mod 2 == 1 then result ← (result * base) mod mod // 若指數為奇數則乘入結果  \n→ Step 6:     modExp: base ← (base * base) mod mod // 平方底數  \n→ Step 7:     modExp: exp ← exp // 2 // 將指數除以 2  \n→ Step 8:   modExp: return result // 返回模冪結果  \n→ Step 9: 定義函式 superPow(a, b_array) // 計算 a^b mod 1337  \n→ Step 10:   superPow: Decision: if b_array 為空? // 指數已消耗完  \n→ Step 11:     Yes → return 1 // a^0 = 1  \n→ Step 12:     No  → d ← b_array 的最後一個元素 // 取指數的最後一位  \n→ Step 13:     superPow: 移除 b_array 的最後一個元素 // 準備遞迴  \n→ Step 14:     superPow: sub ← superPow(a, b_array) // 先算 a^(b/10)  \n→ Step 15:     superPow: pow10 ← modExp(sub, 10, 1337) // (a^(b/10))^10 mod 1337  \n→ Step 16:     superPow: aPowD ← modExp(a, d, 1337) // a^d mod 1337  \n→ Step 17:     superPow: return (pow10 * aPowD) mod 1337 // 合併結果  \n→ Step 18: ans ← superPow(a, b_array) // 執行主計算並存儲結果  \n→ Step 19: 輸出 ans // 顯示最終結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      '[null,null,2,2,false]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      '[null, null, 2, 2, false]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x):\n        self.q2.append(x)\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self):\n        return self.q1.popleft()\n\n    def top(self):\n        return self.q1[0]\n\n    def empty(self):\n        return not self.q1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 移除可能存在的 \"Input \" 前綴\n    if data.startswith('Input'):\n        data = data[len('Input'):].strip()\n    # 將兩個列表解析為 tuple\n    try:\n        cmds, args = ast.literal_eval('(' + data + ')')\n    except Exception:\n        # 若解析失敗直接退出\n        return\n    stack = MyStack()\n    results = []\n    for cmd, arg in zip(cmds, args):\n        if cmd == 'push':\n            stack.push(arg[0] if arg else None)\n            results.append(None)\n        elif cmd == 'pop':\n            results.append(stack.pop())\n        elif cmd == 'top':\n            results.append(stack.top())\n        elif cmd == 'empty':\n            results.append(stack.empty())\n        else:\n            # 未知命令，忽略\n            pass\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code with line-by-line, each line has \"虛擬碼步驟 [space] // 解釋\". Use arrows: Start, Decision:, etc. We need to design algorithm: LIFO stack using two queues. Common approach: use one queue as main, another as temp to rotate. For push: enqueue into q1; then move all elements from q2 to q1? Wait we have two queues. Approach1: keep elements in queue1 with newest at front. For push: enqueue x to queue2, then dequeue all from queue1 to queue2, then swap names. That's O(n) push. For pop/top/empty: just operate on queue1 front. We'll use queue1 and queue2 names.\n\nLet's produce steps:\n\nStart\nInitialize q1, q2 as empty queues.\n\npush(x):\n- Enqueue x to q2.\n- While q1 not empty:\n    - Dequeue from q1, enqueue to q2.\n- Swap q1 and q2. (q1 holds all elements, newest front)\n- End push.\n\npop():\n- If q1 empty return error.\n- Dequeue from q1 and return.\n\ntop():\n- If q1 empty return error.\n- Peek front of q1 and return.\n\nempty():\n- Return q1.isEmpty()\n\nWe need to represent with virtual code lines. Let's produce pseudo-code structure:\n\nStart // 程式開始執行\n→ Step 1: 初始化兩個佇列 q1, q2 為空 // 建立兩個佇列\n→ Decision: 判斷是否需要實作類別 MyStack? // 進入類別定義\n\nBut we need just steps of algorithm. Let's outline as methods:\n\nDefine class MyStack\n    Start // 定義 MyStack 類別\n    → Step 1: q1 ← 新佇列 // 主佇列\n    → Step 2: q2 ← 新佇列 // 暫存佇列\n\n    → Method: push(x) // 推進\n        → Step 3: q2.enqueue(x) // 把新元素放到暫存佇列\n        → Decision: q1.isEmpty()? // q1 是否為空\n            Yes → Step 4: 交換 q1, q2 // 若空，直接交換\n            No → Step 5: 從 q1 逐個取出並加入 q2 // 將舊元素搬移\n                → Decision: q1.isEmpty()?\n                    Yes → Step 6: 交換 q1, q2 // 轉移完成後交換\n                    No → Step 5 重複 // 重複直到 q1 空\n        → End Method\n\nBut we can express loops simpler: While q1 not empty: q2.enqueue(q1.dequeue()); Then swap. So we can write loop.\n\nLet's craft virtual code: use \"→ While\" maybe not allowed but we can use \"Decision:\" with Yes/No.\n\nSimplify: push(x):\n    → Step push: q2.enqueue(x)\n    → Decision: q1.isEmpty()?\n        Yes → Step push: swap(q1,q2)\n        No → Step push: While q1 not empty:\n            - Step push: temp = q1.dequeue()\n            - Step push: q2.enqueue(temp)\n          After loop → Step push: swap(q1,q2)\n\nBut we might represent loop with Decision: while? Might use \"Decision:\" with Yes → ... No → ... but loops are not typical. We can use \"Decision: q1.isEmpty()?\" with Yes -> swap; No -> Do move then loop. But easier to represent with \"While\" line as separate.\n\nGiven instructions: use 虛擬碼的箭頭 (→, Yes →, No →) and Decision. They didn't forbid loops. Use \"While\" maybe not. But we can use \"Decision\" for loop condition.\n\nBetter: In push: \n→ Step: q2.enqueue(x)\n→ Decision: q1.isEmpty()?\n    Yes → Step: swap(q1,q2)\n    No → Step: 從 q1 取出所有元素並加入 q2\n        → Decision: q1.isEmpty()?\n            Yes → Step: swap(q1,q2)\n            No → 回到「從 q1 取出...」 // 重複\n\nThis may be confusing.\n\nSimpler: Write explicit loop pseudo:\n\n→ Step: q2.enqueue(x)\n→ While q1 not empty:\n    → Step: temp = q1.dequeue()\n    → Step: q2.enqueue(temp)\n→ Step: swap(q1,q2)\n\nWe can output that as lines with arrows. We can treat \"While\" as line with explanation.\n\nLet's produce final output lines:\n\nStart // 程式開始執行\n→ Step 1: q1 ← 新佇列 // 建立主佇列\n→ Step 2: q2 ← 新佇列 // 建立暫存佇列\n\n// push 方法\n→ Method: push(x) // 推入元素\n    → Step: q2.enqueue(x) // 把新元素先放到暫存佇列\n    → While: q1 不為空 // 將主佇列中的所有元素搬移至暫存佇列\n        → Step: temp ← q1.dequeue() // 取出主佇列前端\n        → Step: q2.enqueue(temp) // 再放回暫存佇列\n    → Step: swap(q1, q2) // 交換兩個佇列，q1 成為新的主佇列\n\n// pop 方法\n→ Method: pop() // 移除並回傳頂部元素\n    → Decision: q1.isEmpty()?\n        Yes → Step: return error // 佇列為空\n        No → Step: return q1.dequeue() // 直接從主佇列前端移除\n\n// top 方法\n→ Method: top() // 取得頂部元素\n    → Decision: q1.isEmpty()?\n        Yes → Step: return error\n        No → Step: return q1.peek() // 只查看主佇列前端\n\n// empty 方法\n→ Method: empty() // 判斷是否為空\n    → Step: return q1.isEmpty() // 回傳主佇列是否空\n\nEnd // 程式執行結束\n\nBut need each line with arrow and explanation. Also each method block may require indentation. But requirement: \"逐行輸出\" each line must have \"虛擬碼步驟 [space] // 解釋/說明\". So we need to list lines; inside method, we can indent with tabs or spaces? Not specified. We'll just keep as separate lines.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: q1 ← 新佇列 // 初始化主佇列\n→ Step 2: q2 ← 新佇列 // 初始化暫存佇列\n\n// push 方法\n→ Method: push(x) // 推入元素\n    → Step: q2.enqueue(x) // 把新元素放到暫存佇列\n    → While: q1 不為空 // 將主佇列所有元素搬移至暫存佇列\n        → Step: temp ← q1.dequeue() // 從主佇列取出元素\n        → Step: q2.enqueue(temp) // 放回暫存佇列\n    → Step: swap(q1, q2) // 交換兩個佇列，使 q1 為主佇列\n\n// pop 方法\n→ Method: pop() // 移除並回傳頂部元素\n    → Decision: q1.isEmpty()?\n        Yes → Step: return error // 堆疊空時錯誤\n        No → Step: return q1.dequeue() // 從主佇列前端移除並回傳\n\n// top 方法\n→ Method: top() // 取得頂部元素\n    → Decision: q1.isEmpty()?\n        Yes → Step: return error // 堆疊空時錯誤\n        No → Step: return q1.peek() // 只查看主佇列前端\n\n// empty 方法\n→ Method: empty() // 判斷堆疊是否為空\n    → Step: return q1.isEmpty() // 回傳主佇列是否空\n\nEnd // 程式執行結束\n\nBut need each line not contain \"→\" inside the body? They ask \"虛擬碼的箭頭 (→, Yes →, No →)\". So we can use \"→\" for each line; but inside method we may need indentation but still \"→\". Let's produce each line with \"→\" at start:\n\nStart // 程式開始執行\n→ Step 1: q1 ← 新佇列 // 初始化主佇列\n→ Step 2: q2 ← 新佇列 // 初始化暫存佇列\n\n→ // push 方法\n→ Method: push(x) // 推入元素\n→     Step: q2.enqueue(x) // 把新元素放到暫存佇列\n→     While: q1 不為空 // 將主佇列所有元素搬移至暫存佇列\n→         Step: temp ← q1.dequeue() // 從主佇列取出元素\n→         Step: q2.enqueue(temp) // 放回暫存佇列\n→     Step: swap(q1, q2) // 交換兩個佇列，使 q1 為主佇列\n\n→ // pop 方法\n→ Method: pop() // 移除並回傳頂部元素\n→     Decision: q1.isEmpty()?\n→         Yes → Step: return error // 堆疊空時錯誤\n→         No  → Step: return q1.dequeue() // 從主佇列前端移除並回傳\n\n→ // top 方法\n→ Method: top() // 取得頂部元素\n→     Decision: q1.isEmpty()?\n→         Yes → Step: return error // 堆疊空時錯誤\n→         No  → Step: return q1.peek() // 只查看主佇列前端\n\n→ // empty 方法\n→ Method: empty() // 判斷堆疊是否為空\n→     Step: return q1.isEmpty() // 回傳主佇列是否空\n\nEnd // 程式執行結束\n\nHowever each line should have \"虛擬碼步驟 [space] // 解釋/說明\". But lines with \"→ // push 方法\" doesn't fit. Maybe we avoid comment lines. Let's just output as above but keep each line with code and explanation. No comment lines. We'll drop \"// push 方法\" etc. Instead we can use \"→ Step: // 推入方法\" etc. But better to keep methods as separate blocks but still with arrow.\n\nLet's restructure:\n\nStart // 程式開始執行\n→ Step 1: q1 ← 新佇列 // 初始化主佇列\n→ Step 2: q2 ← 新佇列 // 初始化暫存佇列\n\n→ Method: push(x) // 推入元素\n→     Step: q2.enqueue(x) // 把新元素放到暫存佇列\n→     While: q1 不為空 // 將主佇列所有元素搬移至暫存佇列\n→         Step: temp ← q1.dequeue() // 從主佇列取出元素\n→         Step: q2.enqueue(temp) // 放回暫存佇列\n→     Step: swap(q1, q2) // 交換兩個佇列，使 q1 為主佇列\n\n→ Method: pop() // 移除並回傳頂部元素\n→     Decision: q1.isEmpty()?\n→         Yes → Step: return error // 堆疊空時錯誤\n→         No  → Step: return q1.dequeue() // 從主佇列前端移除並回傳\n\n→ Method: top() // 取得頂部元素\n→     Decision: q1.isEmpty()?\n→         Yes → Step: return error // 堆疊空時錯誤\n→         No  → Step: return q1.peek() // 只查看主佇列前端\n\n→ Method: empty() // 判斷堆疊是否為空\n→     Step: return q1.isEmpty() // 回傳主佇列是否空\n\nEnd // 程式執行結束\n\nNeed to ensure each line has a single \"虛擬碼步驟\" part. For \"Method: push(x)\" line, explanation after // is fine. For nested lines, we maintain indentation but still each line has arrow.\n\nBut the requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\" So the arrow and code part then space then comment. So \"→ Method: push(x) // 推入元素\" fits.\n\nNow we need to ensure \"While:\" line also has explanation. \"→ While: q1 不為空 // 將主佇列所有元素搬移至暫存佇列\". Good.\n\nBut the nested lines inside While: we have \"→ Step:\" lines.\n\nAlso the decision lines: \"→ Decision: q1.isEmpty()?\" plus explanation after //. But the Yes and No branches each need \"Yes → Step:\" lines with explanation. Good.\n\nThus final output ready. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: q1 ← 新佇列 // 初始化主佇列  \n→ Step 2: q2 ← 新佇列 // 初始化暫存佇列  \n\n→ Method: push(x) // 推入元素  \n→     Step: q2.enqueue(x) // 把新元素放到暫存佇列  \n→     While: q1 不為空 // 將主佇列所有元素搬移至暫存佇列  \n→         Step: temp ← q1.dequeue() // 從主佇列取出元素  \n→         Step: q2.enqueue(temp) // 放回暫存佇列  \n→     Step: swap(q1, q2) // 交換兩個佇列，使 q1 為主佇列  \n\n→ Method: pop() // 移除並回傳頂部元素  \n→     Decision: q1.isEmpty()? // 判斷主佇列是否為空  \n→         Yes → Step: return error // 堆疊空時錯誤  \n→         No  → Step: return q1.dequeue() // 從主佇列前端移除並回傳  \n\n→ Method: top() // 取得頂部元素  \n→     Decision: q1.isEmpty()? // 判斷主佇列是否為空  \n→         Yes → Step: return error // 堆疊空時錯誤  \n→         No  → Step: return q1.peek() // 只查看主佇列前端  \n\n→ Method: empty() // 判斷堆疊是否為空  \n→     Step: return q1.isEmpty() // 回傳主佇列是否空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Permutation in String",
      "source_file": "Leetcode/leetcode567.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        \"\"\"\n        Return True if s2 contains any permutation of s1, otherwise False.\n        Uses a sliding window with character frequency counters.\n        \"\"\"\n        len1, len2 = len(s1), len(s2)\n        if len1 > len2:\n            return False\n\n        # Frequency of characters in s1\n        target = Counter(s1)\n\n        # Frequency of characters in the first window of s2\n        window = Counter(s2[:len1])\n\n        if target == window:\n            return True\n\n        # Slide the window over s2\n        for i in range(len1, len2):\n            # Character leaving the window\n            left_char = s2[i - len1]\n            # Character entering the window\n            right_char = s2[i]\n\n            # Update the window counter\n            window[right_char] += 1\n            window[left_char] -= 1\n            if window[left_char] == 0:\n                del window[left_char]\n\n            if window == target:\n                return True\n\n        return False\n\nif __name__ == \"__main__\":\n    # Read input from stdin. Expect two lines: first line is s1, second line is s2.\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    # Extract s1 and s2 from input lines. If more than two lines are provided, ignore extras.\n    s1 = data[0].strip()\n    s2 = data[1].strip() if len(data) > 1 else \"\"\n\n    solution = Solution()\n    result = solution.checkInclusion(s1, s2)\n    # Print result in lowercase as specified in examples\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, no actual code. Need to implement algorithm: check if s2 contains permutation of s1. Approach: sliding window of length len(s1) over s2, compare character counts. Use hash maps or array counts.\n\nWe produce steps: Start, compute lengths, if s2 shorter, return false, set counts for s1, window counts, iterate, compare counts each step, etc.\n\nUse virtual code with arrows. Let's write:\n\nStart // begin\n\n→ Step 1: Set n1 = length of s1, n2 = length of s2 // get lengths\n\n→ Decision: If n2 < n1? // s2 too short\n\n    Yes → Step 2: Return false // cannot contain permutation\n\n    No → Step 3: Initialize countS1[26] = 0 // frequency of s1\n\n    No → Step 4: Initialize windowCount[26] = 0 // frequency of current window\n\n    No → Step 5: For i from 0 to n1-1: increment countS1[s1[i]] and windowCount[s2[i]] // build initial counts\n\n    No → Step 6: Initialize diff = 0 // number of chars where counts differ\n\n    No → Step 7: For each character c in alphabet: if countS1[c] != windowCount[c] → diff++ // compute diff\n\n    No → Step 8: For i from n1 to n2-1: // sliding window\n\n        → Decision: If diff == 0? // window matches\n\n            Yes → Step 9: Return true // permutation found\n\n            No → Step 10: OutChar = s2[i - n1], InChar = s2[i] // chars leaving and entering\n\n            No → Step 11: If countS1[OutChar] == windowCount[OutChar] then diff++ // removal may create difference\n\n            No → Step 12: windowCount[OutChar]-- // update counts\n\n            No → Step 13: If countS1[OutChar] == windowCount[OutChar] then diff-- // after decrement match again\n\n            No → Step 14: If countS1[InChar] == windowCount[InChar] then diff++ // adding may create difference\n\n            No → Step 15: windowCount[InChar]++ // update\n\n            No → Step 16: If countS1[InChar] == windowCount[InChar] then diff-- // after increment match again\n\n    No → Decision: After loop, if diff == 0? // check last window\n\n        Yes → Step 17: Return true\n\n        No  → Step 18: Return false\n\nEnd // finish\n\nBut ensure each line is in required format. Use \"Step\" labels. Use arrows. Let's produce line by line.\n\nWe must use \"Start\" and \"End\" markers.\n\nMake sure each line includes a single statement and comment.\n\nWe'll use \"→\" arrow to indicate flow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n1 ← length(s1) // 取得 s1 長度\n→ Step 2: n2 ← length(s2) // 取得 s2 長度\n→ Decision: n2 < n1? // s2 是否太短無法包含任何排列\n    Yes → Step 3: return false // s2 不能包含 s1 的排列\n    No  → Step 4: countS1[26] ← 0 // s1 字符頻率表\n    No  → Step 5: windowCnt[26] ← 0 // 當前滑動窗口頻率表\n    No  → Step 6: for i ← 0 to n1-1 do\n        → Step 7: countS1[s1[i]]++ // 統計 s1 的字符頻率\n        → Step 8: windowCnt[s2[i]]++ // 統計 s2 初始窗口的頻率\n    No  → Step 9: diff ← 0 // 不同字符頻率的個數\n    No  → for c ← 'a' to 'z' do\n        → Step 10: if countS1[c] ≠ windowCnt[c] then diff++ // 計算初始差異\n    No  → Step 11: for i ← n1 to n2-1 do // 開始滑動窗口\n        → Decision: diff == 0? // 窗口是否已經匹配\n            Yes → Step 12: return true // 找到排列\n            No  → Step 13: outChar ← s2[i-n1] // 滑出字符\n            No  → Step 14: inChar ← s2[i] // 滑入字符\n            No  → Decision: countS1[outChar] == windowCnt[outChar]? \n                Yes → Step 15: diff++ // 先前相等，滑出後會產生差異\n                No  →\n            No  → Step 16: windowCnt[outChar]-- // 更新滑出字符頻率\n            No  → Decision: countS1[outChar] == windowCnt[outChar]?\n                Yes → Step 17: diff-- // 滑出後再次相等\n                No  →\n            No  → Decision: countS1[inChar] == windowCnt[inChar]?\n                Yes → Step 18: diff++ // 先前相等，滑入後會產生差異\n                No  →\n            No  → Step 19: windowCnt[inChar]++ // 更新滑入字符頻率\n            No  → Decision: countS1[inChar] == windowCnt[inChar]?\n                Yes → Step 20: diff-- // 滑入後再次相等\n                No  →\n        → End of for\n    No  → Decision: diff == 0? // 檢查最後一個窗口\n        Yes → Step 21: return true\n        No  → Step 22: return false\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        return\n    # 移除可能的 \"accounts =\" 前綴\n    if data.lower().startswith('accounts'):\n        idx = data.find('[')\n        if idx != -1:\n            data = data[idx:]\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception as e:\n        print(\"[]\")\n        return\n    sol = Solution()\n    merged = sol.accountsMerge(accounts)\n    print(merged)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanations. We need to handle merging accounts by email connectivity, union find. Provide steps: Start, build mapping email->name, graph edges, DFS to collect groups, sort emails, output. Must use arrow syntax.\n\nLet's craft.\n\nWe'll output line by line:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 emailToName, 邏輯圖 emailGraph // 建立 email 與名字的對應及圖結構\n\n→ Step 2: 遍歷 accounts\n    → Step 2.1: 取 name = account[0] // 第一次元素是名字\n    → Step 2.2: 取 emails = account[1:] // 其餘是電子郵件\n    → Step 2.3: 對每個 email in emails\n        → Step 2.3.1: emailToName[email] = name // 只保留名字\n        → Step 2.3.2: 如果 email not in emailGraph，emailGraph[email] = 空集合 // 初始化鄰接集合\n    → Step 2.4: 若 emails 不是空，取首個 email = emails[0]\n        → Step 2.5: 對剩下的 email2 in emails[1:]\n            → Step 2.5.1: emailGraph[首個 email].add(email2) // 連接兩個 email\n            → Step 2.5.2: emailGraph[email2].add(首個 email) // 無向圖\n\n→ Step 3: 初始化空集合 visited // 用來標記已訪問的 email\n\n→ Step 4: 初始化空列表 mergedAccounts // 儲存合併後的帳號\n\n→ Step 5: 遍歷 emailGraph 的每個 email\n    → Decision: 如果 email 未訪問?\n        Yes → Step 5.1: 初始化空列表 componentEmails // 存放同一人所有 email\n        → Step 5.2: 初始化棧 stack = [email] // DFS 堆疊\n        → Step 5.3: while stack 非空\n            → Step 5.3.1: pop e from stack // 取得 email\n            → Step 5.3.2: 若 e 已訪問，繼續 // skip\n            → Step 5.3.3: visited.add(e) // 標記\n            → Step 5.3.4: componentEmails.add(e) // 加入集合\n            → Step 5.3.5: 對每個 neighbour in emailGraph[e]\n                → Step 5.3.5.1: 如果 neighbour 未訪問，stack.add(neighbour) // 探索\n        → Step 5.4: sort componentEmails // 依字母排序\n        → Step 5.5: name = emailToName[componentEmails[0]] // 取其中一個 email 對應的名字\n        → Step 5.6: mergedAccounts.append([name] + componentEmails) // 建立合併後帳號\n        No → Step 5.7: 繼續下一個 email\n\n→ End // 程式結束\n\nEnsure arrow syntax.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 `emailToName`, 邏輯圖 `emailGraph` // 建立 email 與名字的對應及圖結構  \n\n→ Step 2: 遍歷 `accounts`  \n → Step 2.1: 取 `name = account[0]` // 第一次元素是名字  \n → Step 2.2: 取 `emails = account[1:]` // 其餘是電子郵件  \n → Step 2.3: 對每個 `email in emails`  \n   → Step 2.3.1: `emailToName[email] = name` // 只保留名字  \n   → Step 2.3.2: 若 `email` 未在 `emailGraph`，`emailGraph[email] = 空集合` // 初始化鄰接集合  \n → Step 2.4: 若 `emails` 不是空，取首個 `base = emails[0]`  \n  → Step 2.5: 對剩下的 `email2 in emails[1:]`  \n    → Step 2.5.1: `emailGraph[base].add(email2)` // 連接兩個 email  \n    → Step 2.5.2: `emailGraph[email2].add(base)` // 無向圖  \n\n→ Step 3: 初始化空集合 `visited` // 用來標記已訪問的 email  \n\n→ Step 4: 初始化空列表 `mergedAccounts` // 儲存合併後的帳號  \n\n→ Step 5: 遍歷 `emailGraph` 的每個 `email`  \n  Decision: 如果 `email` 未訪問? // 判斷是否已處理  \n   Yes → Step 5.1: 初始化空列表 `componentEmails` // 存放同一人所有 email  \n    → Step 5.2: 初始化棧 `stack = [email]` // DFS 堆疊  \n    → Step 5.3: while `stack` 非空  \n     → Step 5.3.1: `e = stack.pop()` // 取得 email  \n     → Step 5.3.2: 若 `e` 已訪問，繼續 // 跳過  \n     → Step 5.3.3: `visited.add(e)` // 標記  \n     → Step 5.3.4: `componentEmails.add(e)` // 加入集合  \n     → Step 5.3.5: 對每個 `neighbour in emailGraph[e]`  \n      → Step 5.3.5.1: 若 `neighbour` 未訪問，`stack.add(neighbour)` // 探索  \n    → Step 5.4: `sort componentEmails` // 依字母排序  \n    → Step 5.5: `name = emailToName[componentEmails[0]]` // 取其中一個 email 對應的名字  \n    → Step 5.6: `mergedAccounts.append([name] + componentEmails)` // 建立合併後帳號  \n   No → Step 5.7: 繼續下一個 `email`  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,1,1,1,1,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 1, 1, 1, 1, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.size = n - len(blacklist)          # 可用數字的個數\n        self.mapping = {}                       # 低位黑名到高位允許值的映射\n        black_set = set(blacklist)\n        last = n - 1                            # 從最大值開始掃描高位可用數字\n        for b in blacklist:\n            if b < self.size:                   # 只對低位黑名進行映射\n                while last in black_set:        # 跳過已被黑名的高位數字\n                    last -= 1\n                self.mapping[b] = last          # 把低位黑名映射到第一個可用高位\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)   # 只呼叫一次隨機函式\n        return self.mapping.get(index, index)     # 若映射存在則返回映射值，否則返回原始索引\n\ndef main():\n    ops_line = sys.stdin.readline().strip()\n    args_line = sys.stdin.readline().strip()\n\n    # 移除外層單引號或雙引號（若存在）\n    if ops_line and ops_line[0] in (\"'\", '\"') and ops_line[0] == ops_line[-1]:\n        ops_line = ops_line[1:-1]\n    if args_line and args_line[0] in (\"'\", '\"') and args_line[0] == args_line[-1]:\n        args_line = args_line[1:-1]\n\n    ops = ast.literal_eval(ops_line)\n    args = ast.literal_eval(args_line)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == 'Solution':\n            n, bl = arg\n            obj = Solution(n, bl)\n            results.append(None)\n        else:\n            results.append(getattr(obj, op)())\n\n    # 使用 json.dumps 以得到符合題目格式的輸出（None 變成 null）\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm that given n and blacklist, we pick random integer in [0, n-1] not in blacklist, uniformly. Need minimize random calls. Standard solution: remap blacklisted numbers in [0, M-1] to allowed numbers in [M, n-1] where M = n - blacklist.length. Preprocess: create set of blacklisted numbers in high range [M, n-1] to map. Use dictionary map from blacklisted low to allowed high. Then pick random in [0, M-1] and map if needed.\n\nWe must produce virtual code step by step with comments. So start: Start; Step: compute M = n - blacklist.length; Step: build set blackHigh of blacklist items >= M; Step: build map from lowBlack to highAllow; Step: for each lowBlack in blacklist where lowBlack < M: map lowBlack to next high from blackHigh? Actually algorithm: iterate through blacklist numbers; for each b < M, assign mapping to next available number >= M not in blacklist. Use pointer.\n\nThen pick: generate random integer r in [0, M-1]; if r in map, return map[r] else return r.\n\nWe need to minimize random calls: one per pick. So virtual code.\n\nWe need to follow output format: Each line \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\nUse arrow notation: Start → Step 1: 計算 M = n - blacklist.size() // allowed count.\n\n→ Step 2: 建立 set blackHigh = {b in blacklist | b >= M} // blacklisted high numbers\n\n→ Step 3: 建立 map mapping = {} // 用於映射低黑名到高允許\n\n→ Step 4: 初始化 pointer highCandidate = M // 從 M 開始掃描高位可用\n\n→ Decision: 是否有低黑名? // 如果 blacklist中有小於 M 的數\n\nWe might use loops but virtual code can be linear steps. Provide pseudocode.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: M ← n - len(blacklist) // 計算可用數量\n→ Step 2: blackHigh ← {b | b ∈ blacklist and b ≥ M} // 收集高位黑名\n→ Step 3: mapping ← empty dictionary // 用於映射\n→ Step 4: highCandidate ← M // 從 M 開始尋找可用高位數\n→ Decision: 任何低黑名存在? // 檢查是否有 b < M\n    Yes → Loop over each b in blacklist where b < M:\n        → Step 5: while highCandidate ∈ blackHigh: highCandidate ← highCandidate + 1 // 跳過被黑名\n        → Step 6: mapping[b] ← highCandidate // 將低黑名映射到可用高位\n        → Step 7: highCandidate ← highCandidate + 1 // 移到下一候選\n    No → // 沒有低黑名，映射保持空\n→ Step 8: Function pick():\n        → Decision: 隨機 r ← random_int(0, M-1) // 產生隨機數\n            Yes → Step 9: if r in mapping: return mapping[r] else return r // 選擇映射或原始\n→ End // 程式結束\n\nNeed to use arrow formatting and comments. Use \"→\" for steps, \"Decision:\" lines. Ensure each line ends with comment.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: M ← n - len(blacklist) // 計算允許取值的數量\n→ Step 2: blackHigh ← {b | b ∈ blacklist ∧ b ≥ M} // 收集所有在高位區間 [M, n-1] 的黑名\n→ Step 3: mapping ← {} // 用於把低位黑名映射到高位允許值\n→ Step 4: highCandidate ← M // 從 M 開始掃描可用的高位數字\n→ Decision: 是否存在任何低位黑名 (b < M)? // 檢查 blacklist 中是否有 < M 的數字\n    Yes → Loop over each b in blacklist where b < M:\n        → Step 5: while highCandidate ∈ blackHigh: highCandidate ← highCandidate + 1 // 跳過已被黑名的高位數字\n        → Step 6: mapping[b] ← highCandidate // 把低位黑名映射到第一個可用的高位數字\n        → Step 7: highCandidate ← highCandidate + 1 // 讓 highCandidate 指向下一個候選高位數字\n    No  → // 無低位黑名，映射保持空\n→ Step 8: Function pick():\n        → Decision: 生成隨機數 r ← random_int(0, M-1) // 只呼叫一次隨機函式\n            Yes → Step 9: if r ∈ mapping: return mapping[r] else return r // 若 r 為低位黑名則返回映射值，否則返回 r 本身\n→ End // 程式結束\n```"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      '[null,3,null,5]'\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      '[null, 3, null, 5]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = Node()\n        self.map = {}\n\n    def insert(self, key: str, val: int) -> None:\n        diff = val - self.map.get(key, 0)\n        self.map[key] = val\n        node = self.root\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = Node()\n            node = node.children[ch]\n            node.sum += diff\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main():\n    data = sys.stdin.read().strip()\n    if data.startswith(\"'\") and data.endswith(\"'\"):\n        data = data[1:-1]\n    if not data:\n        print(json.dumps([]))\n        return\n    ops, args = eval(data)\n\n    ms = MapSum()\n    outputs = []\n    for op, arg in zip(ops, args):\n        if op == 'insert':\n            ms.insert(arg[0], arg[1])\n            outputs.append(None)\n        elif op == 'sum':\n            outputs.append(ms.sum(arg[0]))\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for design of MapSum with methods. Use virtual code steps. Need to describe data structure: Trie with cumulative sums, also map to store current values for key updates. Steps: Initialize root node, map dictionary. Insert: if key existed, subtract old value from sums along prefix. Then add new val. sum: traverse prefix, return sum stored at node.\n\nWe output line by line: Start, Step, Decision, etc. Each line \"虛擬碼步驟 // 解釋\".\n\nLet's produce. Use Chinese comments. Ensure each line ends with // 解釋/說明. Use \"→\" arrow. Use \"Decision:\" etc.\n\nWe'll produce pseudocode for MapSum class initialization and methods.\n\nWe can produce like:\n\nStart // 程式開始\n→ Step 1: 定義節點結構 Node { map<char, Node*> child; int sum; } // 每個節點存儲子節點和前綴總和\n→ Step 2: MapSum() 初始化 root = new Node(); map<string, int> valMap; // 存儲鍵對應值\n→ Step 3: insert(key, val) // 插入或更新\n    → Decision: 是否存在 key? // 檢查鍵是否已存在\n        Yes → Step 4: old = valMap[key]; diff = val - old; // 計算差值\n        No  → Step 4: diff = val; // 新鍵，差值即為 val\n    → Step 5: cur = root; // 從根開始\n    → While (char c in key):\n        → Decision: cur.child contains c? // 是否已有該字母子節點\n            Yes → cur = cur.child[c];\n            No  → cur.child[c] = new Node(); cur = cur.child[c];\n        → Step 6: cur.sum += diff; // 更新前綴和\n    → Step 7: valMap[key] = val; // 更新鍵值對\n→ Step 8: sum(prefix) // 計算前綴總和\n    → cur = root;\n    → While (char c in prefix):\n        → Decision: cur.child contains c? // 是否能繼續走\n            Yes → cur = cur.child[c];\n            No  → Return 0; // 前綴不存在\n    → Return cur.sum; // 回傳前綴總和\nEnd // 程式執行結束\n\nNeed to keep each line with // explanation. Ensure every line includes \"虛擬碼步驟 // 解釋\". Use arrow lines. Provide each line separately.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 定義節點結構 Node { map<char, Node*> child; int sum; } // 每個節點存放子節點及前綴總和\n\n→ Step 2: MapSum() 初始化 root = new Node(); map<string, int> valMap; // root 為 Trie 根節點，valMap 存儲每個 key 的目前值\n\n→ Step 3: insert(key, val) // 插入或更新鍵值對\n    → Decision: 是否存在 key? // 檢查 key 是否已在 valMap 中\n        Yes → Step 4: old = valMap[key]; diff = val - old; // 計算與舊值的差值\n        No  → Step 4: diff = val; // 新鍵，差值即為 val\n    → Step 5: cur = root; // 從根節點開始遍歷\n    → While (c in key):\n        → Decision: cur.child 包含 c? // 是否已有此字母的子節點\n            Yes → cur = cur.child[c];\n            No  → cur.child[c] = new Node(); cur = cur.child[c];\n        → Step 6: cur.sum += diff; // 更新沿途節點的前綴總和\n    → Step 7: valMap[key] = val; // 更新 key 對應的新值\n\n→ Step 8: sum(prefix) // 計算所有以 prefix 為前綴的鍵的值總和\n    → cur = root;\n    → While (c in prefix):\n        → Decision: cur.child 包含 c? // 能否繼續向下走\n            Yes → cur = cur.child[c];\n            No  → Return 0; // 前綴不存在，總和為 0\n    → Return cur.sum; // 返回前綴對應節點的總和\n\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.12596,0.12562],[0.12996,-0.71489],[0.16476,0.72704]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.12596, 0.12562], [0.12996, -0.71489], [0.16476, 0.72704]]'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 使用極座標隨機生成點，確保面積均勻分佈\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    # 讀取操作與對應的參數\n    ops = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    results = []\n    obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            res = getattr(obj, op)(*args)\n            results.append(res)\n\n    # 轉換結果為符合 LeetCode 輸出的 JSON 風格字串\n    out_parts = []\n    for r in results:\n        if r is None:\n            out_parts.append('null')\n        elif isinstance(r, list):\n            formatted = '[' + ', '.join(f'{x:.5f}' for x in r) + ']'\n            out_parts.append(formatted)\n        else:\n            out_parts.append(str(r))\n    output = '[' + ', '.join(out_parts) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The function: initialize radius, center, then randPoint generates uniform random point inside circle. Approach: generate random angle uniform [0,2π), random radius sqrt(random)*radius to ensure uniform area. Then compute x,y.\n\nWe should produce virtual code steps.\n\nWe need start, steps, decision. The code: Start → Step: initialize parameters. Then randPoint: generate random radius r: r = sqrt(rand01)*radius. Generate angle theta: theta = rand01 * 2π. Then compute x = x_center + r * cos(theta). y = y_center + r * sin(theta). Return [x,y].\n\nWe need to show decision maybe not needed. But we can show decision for checking if radius > 0? But not required.\n\nBetter to produce:\n\nStart // 程式開始執行\n→ Step 1: Store radius, x_center, y_center // 初始化圓半徑與中心座標\n→ Step 2: randPoint() // 生成隨機點\n    → Step 3: Generate random number u in [0,1] // 用於半徑\n    → Step 4: Compute r = sqrt(u) * radius // 轉換以保證面積均勻分佈\n    → Step 5: Generate random number v in [0,1] // 用於角度\n    → Step 6: Compute theta = v * 2π // 隨機角度\n    → Step 7: Compute x = x_center + r * cos(theta) // 將極坐標轉為笛卡兒座標\n    → Step 8: Compute y = y_center + r * sin(theta)\n    → Step 9: Return [x, y] // 回傳隨機點\nEnd // 程式執行結束\n\nWe need arrow formatting: \"→\". Indentation for nested steps. Use Decision? maybe not.\n\nThe instructions: Use virtual code arrow and structure. Use Decision: if needed. Not necessary.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: radius ← radius; x_center ← x_center; y_center ← y_center // 初始化圓的參數\n→ Step 2: Function randPoint() // 開始隨機點生成\n    → Step 3: u ← Random(0,1) // 取得 0~1 之亂數\n    → Step 4: r ← sqrt(u) * radius // 轉換半徑以確保均勻\n    → Step 5: v ← Random(0,1) // 取得 0~1 之亂數作角度\n    → Step 6: theta ← v * 2π // 轉換成角度\n    → Step 7: x ← x_center + r * cos(theta) // 極坐標轉笛卡兒\n    → Step 8: y ← y_center + r * sin(theta)\n    → Step 9: Return [x, y] // 回傳點\nEnd // 程式結束\n\nLet's adhere to formatting: each line \"虛擬碼步驟 [space] // 解釋\". Use arrow \"→\". For nested, indent with spaces. Use no actual code. Provide as plain text.\n\nMake sure to include Decision only if necessary. Not needed.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Store radius, x_center, y_center // 初始化圓的半徑與中心座標  \n→ Step 2: randPoint() // 開始隨機點生成  \n  → Step 3: u ← Random(0, 1) // 取得 0~1 的亂數，用於計算半徑  \n  → Step 4: r ← sqrt(u) * radius // 透過 sqrt 轉換半徑，確保面積均勻分佈  \n  → Step 5: v ← Random(0, 1) // 取得 0~1 的亂數，用於計算角度  \n  → Step 6: theta ← v * 2π // 將亂數轉為 0~2π 的角度  \n  → Step 7: x ← x_center + r * cos(theta) // 將極座標轉為笛卡兒座標（x）  \n  → Step 8: y ← y_center + r * sin(theta) // 將極座標轉為笛卡兒座標（y）  \n  → Step 9: Return [x, y] // 回傳隨機點座標  \nEnd // 程式執行結束"
    },
    {
      "title": "4Sum II",
      "source_file": "Leetcode/leetcode454.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkstnogde.py\", line 33, in <module>\n    A, B, C, D = parse_input(raw_input)\n                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkstnogde.py\", line 27, in parse_input\n    d = eval(data)\n        ^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'A' is not defined"
        },
        {
          "example_index": 1,
          "input": "A = [0], B = [0], C = [0], D = [0]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmex3x0hj.py\", line 33, in <module>\n    A, B, C, D = parse_input(raw_input)\n                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmex3x0hj.py\", line 27, in parse_input\n    d = eval(data)\n        ^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'A' is not defined"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def fourSumCount(self, A, B, C, D):\n        # 先把 A + B 的所有和記錄在哈希表中\n        ab_counts = Counter(a + b for a in A for b in B)\n        # 再遍歷 C + D 的所有和，找對應的補數\n        count = 0\n        for c in C:\n            for d in D:\n                count += ab_counts.get(-(c + d), 0)\n        return count\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串轉成四個列表。輸入格式為：\n    A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]\n    \"\"\"\n    data = data.strip()\n    # 將 ' = ' 替換成 ' : ' 以符合字典語法\n    data = data.replace('=', ':')\n    # 加上大括號變成 dict 字串\n    data = '{' + data + '}'\n    # 使用 eval 解析成字典\n    # 注意：此處假設輸入格式始終正確且安全\n    d = eval(data)\n    return d['A'], d['B'], d['C'], d['D']\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    A, B, C, D = parse_input(raw_input)\n    sol = Solution()\n    result = sol.fourSumCount(A, B, C, D)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code lines with explanations. Problem: Four Sum Count. Approach: compute sums of A+B, C+D, store frequencies in map, then count matches. We'll use hash map. Steps: iterate all pairs of A,B compute sum, count freq. Similarly iterate C,D compute sum, for each sum find -sum in map to add count. Complexity O(n^2). Output steps.\n\nWe need use Start, End, Decision. No actual code. Let's structure.\n\nStart\n→ Step 1: 初始化空的哈希表 sumABCount // 用於存儲 A[i]+B[j] 的頻率\n→ Step 2: 循環 i from 0 to n-1\n    → Step 3: 循環 j from 0 to n-1\n        → Step 4: 計算 sumAB = A[i] + B[j]\n        → Step 5: sumABCount[sumAB] += 1 // 更新頻率\n→ Step 6: 初始化計數器 result = 0 // 用於累計符合條件的四元組數\n→ Step 7: 循環 k from 0 to n-1\n    → Step 8: 循環 l from 0 to n-1\n        → Step 9: 計算 sumCD = C[k] + D[l]\n        → Step 10: 找到 target = -sumCD\n        → Decision: target 是否存在於 sumABCount？\n            Yes → Step 11: result += sumABCount[target] // 匹配成功，累加頻率\n            No  → // 不做任何事\n→ Step 12: 輸出 result // 回傳符合條件的四元組總數\nEnd\n\nBut we need include arrows: Use `→` before each step. For Decision use `Decision:`.\n\nAlso need comments after `//`. Let's format accordingly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空的哈希表 sumABCount // 用於存儲 A[i]+B[j] 的頻率\n→ Step 2: 循環 i 從 0 到 n-1 // 遍歷陣列 A\n    → Step 3: 循環 j 從 0 到 n-1 // 遍歷陣列 B\n        → Step 4: 計算 sumAB = A[i] + B[j] // 兩個元素之和\n        → Step 5: sumABCount[sumAB] += 1 // 更新這個和的出現頻率\n→ Step 6: 初始化計數器 result = 0 // 用於累計符合條件的四元組數\n→ Step 7: 循環 k 從 0 到 n-1 // 遍歷陣列 C\n    → Step 8: 循環 l 從 0 到 n-1 // 遍歷陣列 D\n        → Step 9: 計算 sumCD = C[k] + D[l] // 兩個元素之和\n        → Step 10: 設定 target = -sumCD // 需要的補數\n        → Decision: target 是否存在於 sumABCount？ // 檢查是否有相對應的補數\n            Yes → Step 11: result += sumABCount[target] // 匹配成功，累加頻率\n            No  → // 不做任何事，繼續下一對\n→ Step 12: 輸出 result // 回傳符合條件的四元組總數\nEnd // 程式執行結束"
    },
    {
      "title": "Decode Ways II",
      "source_file": "Leetcode/leetcode639.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"*\"",
          "expected_output": "9",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqpfi5ifn.py\", line 48, in <module>\n    print(num_decodings(s))\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqpfi5ifn.py\", line 39, in num_decodings\n    if 10 <= int(prev + curr) <= 26:\n             ^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 's '"
        },
        {
          "example_index": 1,
          "input": "s = \"1*\"",
          "expected_output": "18",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp784slco6.py\", line 48, in <module>\n    print(num_decodings(s))\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp784slco6.py\", line 39, in num_decodings\n    if 10 <= int(prev + curr) <= 26:\n             ^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 's '"
        },
        {
          "example_index": 2,
          "input": "s = \"2*\"",
          "expected_output": "15",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9yqx3blp.py\", line 48, in <module>\n    print(num_decodings(s))\n          ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9yqx3blp.py\", line 39, in num_decodings\n    if 10 <= int(prev + curr) <= 26:\n             ^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 's '"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef num_decodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        ch = s[i - 1]\n\n        # single digit contribution\n        if ch == '*':\n            dp[i] = 9 * dp[i - 1]\n        elif ch != '0':\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = 0\n\n        # two digit contribution\n        if i > 1:\n            prev = s[i - 2]\n            curr = ch\n\n            if prev == '*' and curr == '*':\n                dp[i] = (dp[i] + 15 * dp[i - 2]) % MOD\n            elif prev == '*':\n                if curr <= '6':\n                    dp[i] = (dp[i] + 2 * dp[i - 2]) % MOD\n                else:\n                    dp[i] = (dp[i] + dp[i - 2]) % MOD\n            elif curr == '*':\n                if prev == '1':\n                    dp[i] = (dp[i] + 9 * dp[i - 2]) % MOD\n                elif prev == '2':\n                    dp[i] = (dp[i] + 6 * dp[i - 2]) % MOD\n            else:\n                if 10 <= int(prev + curr) <= 26:\n                    dp[i] = (dp[i] + dp[i - 2]) % MOD\n\n    return dp[n] % MOD\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        s = data.strip()\n        print(num_decodings(s))",
      "virtual_code": "Thinking...\nWe need produce virtual code lines for decoding algorithm for string with '*' wildcard, counting ways modulo 1e9+7. Need to produce step-by-step virtual code and explanations.\n\nWe must use virtual code structure with Start, End, Decision, arrow. Provide line-by-line.\n\nWe need algorithm: dynamic programming. Count ways for each position i. Let dp[i] ways for prefix length i. dp[0]=1. For each position i (1-indexed), compute ways based on s[i-1] char (current). For single digit: if char is '0' no ways; if '*' -> 9 ways; else -> 1. For two-digit: if i>=2, consider s[i-2] and s[i-1] forming two-digit number. Cases: \n- if first char '1': second can be '0'-'9' => 10 ways if second '*', else 1.\n- if first char '2': second '0'-'6': 7 ways if second '*', else 1.\n- if first char '*': second '0'-'9': if second '*': '*' '1' or '2' leads to 15? Let's compute: if first '*', second '*': possibilities: 11-19 (9) and 21-26 (6) total 15. If second digit '0'-'6': if second digit <=6: first '*' can be '1' or '2' so 2 ways. If second digit '7'-'9': only first '1' works: 1 way. For zero: if second digit '0', only first '1' or '2' can produce 10 or 20: but 20 invalid? '20' mapping to 'T' yes '20' is valid. So if second is '0', first '*' can be '1' or '2' => 2 ways.\n\nThus dp[i] = (dp[i-1] * ways_single) + (dp[i-2] * ways_double). mod M.\n\nImplementation: iterate i from 1 to n.\n\nNeed to produce virtual code steps:\n\nStart\n→ Initialize n = length of s\n→ Initialize dp[0] = 1\n→ For i from 1 to n:\n    → Determine single_digit_ways\n    → If i == 1:\n         dp[1] = single_digit_ways\n    → Else:\n        → Determine double_digit_ways\n        → dp[i] = (dp[i-1] * single_digit_ways + dp[i-2] * double_digit_ways) mod M\n→ Return dp[n] // final answer\nEnd\n\nWe also need decisions for each char mapping. We'll have sub-steps to compute single_digit_ways and double_digit_ways using Decision.\n\nWe need to produce virtual code step by step with decisions.\n\nLet's craft.\n\nStart // begin\n→ Step 1: n = length of s // get string length\n→ Step 2: dp[0] = 1 // base case: empty string one way\n→ For i = 1 to n:\n    → Step 3: current = s[i-1] // current char\n    → Decision: if current == '*'\n        Yes → single = 9 // '*' can be 1-9\n        No  → Decision: if current == '0'\n                Yes → single = 0 // '0' cannot be decoded alone\n                No  → single = 1 // digit 1-9\n    → Decision: if i == 1\n        Yes → dp[1] = single\n        No  → Decision: determine two-digit contribution\n            → Step 4: prev = s[i-2] // previous char\n            → Decision: if prev == '1'\n                Yes → if current == '*'\n                        two = 9 // 10-19\n                    No  → two = 1 // 10-19 with digit\n            → No → Decision: if prev == '2'\n                    Yes → if current == '*'\n                            two = 6 // 20-26\n                        No  → if current between '0' and '6'\n                                two = 1\n                            No  → two = 0\n            → No → Decision: if prev == '*'\n                    Yes → if current == '*'\n                            two = 15 // 11-19 & 21-26\n                        No  → if current between '0' and '6'\n                                two = 2 // 10-16,20-26\n                            No  → if current between '7' and '9'\n                                two = 1 // 17-19\n                        No  → two = 0\n            → No → two = 0 // other cases\n            → Step 5: dp[i] = (dp[i-1] * single + dp[i-2] * two) mod M\n→ Step 6: return dp[n]\nEnd\n\nNeed to include modulo each step maybe in Step 5.\n\nLet's format with arrow and comments.\n\nWe must maintain each line format: \"虛擬碼步驟 // 解釋\".\n\nUse arrow `→`. For decisions, indent accordingly.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length of s // 取得輸入字串長度  \n→ Step 2: dp[0] = 1 // 空字串只有一種解碼方式  \n\n→ For i = 1 to n: // 逐字處理每個位置  \n  → Step 3: current = s[i-1] // 取得第 i 個字元  \n    Decision: if current == '*': // '*' 可代表 1~9  \n     Yes → single = 9 // 九種可能  \n     No → Decision: if current == '0': // '0' 不能單獨解碼  \n       Yes → single = 0  \n       No → single = 1 // 1~9 各一種  \n    Decision: if i == 1: // 第一個字元不考慮兩位數  \n     Yes → dp[1] = single // 直接以單位數結果  \n     No → // 需要同時考慮單位數和兩位數  \n       → Step 4: prev = s[i-2] // 取得前一個字元  \n       Decision: if prev == '1': // 前位為 1  \n        Yes → Decision: if current == '*': // 1* 代表 10~19  \n          Yes → two = 9  \n          No  → two = 1 // 10~19 以實際數字為止  \n        No → Decision: if prev == '2': // 前位為 2  \n         Yes → Decision: if current == '*': // 2* 代表 20~26  \n           Yes → two = 6  \n           No  → Decision: if current between '0' and '6': // 20~26 以實際數字  \n            Yes → two = 1  \n            No  → two = 0 // 27~29 無效  \n        No → Decision: if prev == '*': // 前位為 '*'  \n         Yes → Decision: if current == '*': // ** 代表 11~19 與 21~26  \n           Yes → two = 15  \n           No  → Decision: if current between '0' and '6': // 10~16 與 20~26  \n            Yes → two = 2 // '1' 或 '2'  \n            No  → Decision: if current between '7' and '9': // 17~19  \n             Yes → two = 1 // 1 only  \n             No  → two = 0 // 70~99 等無效  \n        No → two = 0 // 其他字元不形成合法兩位數  \n       → Step 5: dp[i] = (dp[i-1] * single + dp[i-2] * two) mod M // 計算第 i 個位置的解碼數  \n→ Step 6: return dp[n] // 最終結果為整個字串的解碼數量  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated String Match",
      "source_file": "Leetcode/leetcode686.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "a = \"abcd\", b = \"cdabcdab\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '-1'"
        },
        {
          "example_index": 1,
          "input": "a = \"a\", b = \"aa\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\n\ndef repeated_string_match(a: str, b: str) -> int:\n    \"\"\"Return the minimum times a must be repeated so that b becomes a substring.\n    If impossible, return -1.\"\"\"\n    len_a = len(a)\n    len_b = len(b)\n\n    # 最小需要的重複次數（向上取整）\n    repeat = (len_b + len_a - 1) // len_a\n\n    # 先嘗試最小重複次數\n    s = a * repeat\n    if b in s:\n        return repeat\n\n    # 再嘗試一次（可能因為部分重疊而需要多一個 a）\n    s += a\n    if b in s:\n        return repeat + 1\n\n    # 超過兩次仍找不到，則無法成為子字串\n    return -1\n\ndef parse_input_line(line: str) -> str:\n    \"\"\"\n    從輸入行解析出字串值。\n    支援以下格式：\n        a = \"abcd\"\n        b = \"cdabcdab\"\n    會移除等號、空格以及外層的單引號或雙引號。\n    \"\"\"\n    if '=' in line:\n        _, value = line.split('=', 1)\n        line = value.strip()\n    # 移除外層單引號或雙引號\n    if (line.startswith('\"') and line.endswith('\"')) or \\\n       (line.startswith(\"'\") and line.endswith(\"'\")):\n        line = line[1:-1]\n    return line\n\nif __name__ == \"__main__\":\n    # 讀取所有非空白行\n    raw_lines = [ln.strip() for ln in sys.stdin if ln.strip()]\n\n    # 預期兩行輸入：第一行 a，第二行 b\n    if len(raw_lines) >= 2:\n        a_str = parse_input_line(raw_lines[0])\n        b_str = parse_input_line(raw_lines[1])\n    else:\n        # 若輸入不足，直接返回\n        print(-1)\n        sys.exit(0)\n\n    result = repeated_string_match(a_str, b_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code. For the problem: given a and b, find min repeats of a such that b is substring; else -1. Standard solution: compute max repeats as ceil(len(b)/len(a)) + 2. Then iterate from that many repeats down? Actually typical solution: For repeats from ceil(len(b)/len(a)) to ceil(len(b)/len(a)) + 2 inclusive, repeat a that many times and check if b is substring. If found return repeats else -1. Because repeating further than that cannot make b substring if not found earlier? Actually explanation: need to account for overlaps, so we might need one more repetition beyond ceil. So try up to ceil(len(b)/len(a)) + 2. That covers all cases.\n\nWe need to produce virtual code line by line, with explanations. The input is strings a, b. Output integer.\n\nWe'll produce algorithm.\n\nWe can structure:\n\nStart\n→ Step 1: 取得 a 的長度 lenA // a 的長度\n→ Step 2: 取得 b 的長度 lenB // b 的長度\n→ Step 3: 計算最少重複次數 minRepeat = ceil(lenB / lenA) // 基本重複次數\n→ Decision: 如果 b 為 a 的子字串? Wait we need to check after repeating.\n\nBetter: Build repeated string rep = a repeated minRepeat times. Check if b in rep; if yes return minRepeat. Else extend by 1: rep = rep + a; check; if yes return minRepeat+1; else extend by 1: rep = rep + a; check; if yes return minRepeat+2; else return -1.\n\nSo we can do for repeat from minRepeat to minRepeat+2:\n\n→ Decision: repeat <= minRepeat+2? yes\n\nBetter:\n\n→ Step 4: 初始化 rep = \"\" // 目前重複的字符串\n→ For i from 1 to minRepeat+2: // 依次重複 a\n    → Step 5: rep = rep + a // 加上一個 a\n    → Decision: rep 是否包含 b? // 檢查 b 是否為 rep 的子字串\n        Yes → Step 6: 回傳 i // i 是所需的最小重複次數\n        No  → No action // 迴圈繼續\n\n→ Step 7: 回傳 -1 // 所有重複次數都無法包含 b\n\nBut we need to compute minRepeat = ceil(lenB / lenA). We can compute as (lenB + lenA -1)/lenA integer division.\n\nEdge cases: if a or b empty? Not necessary.\n\nWe'll produce lines accordingly.\n\nThe output format: each line: virtual code step + space + comment // explanation.\n\nUse arrow ->. Use Start and End.\n\nAlso need Decision structure.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 取得 a 的長度 lenA // a 的長度\n→ Step 2: 取得 b 的長度 lenB // b 的長度\n→ Step 3: 計算最小重複次數 minRepeat = (lenB + lenA - 1) / lenA // 取整除後向上取整\n→ Step 4: 初始化 rep = \"\" // 用於累積重複後的字串\n→ Step 5: 初始化 i = 1 // 目前重複次數計數\n→ Decision: i <= minRepeat + 2? // 是否已嘗試足夠多次\n    Yes → Step 6: rep = rep + a // 加入一個 a\n    → Decision: rep 是否包含 b? // 檢查 b 是否為子字串\n        Yes → Step 7: 回傳 i // 找到最小重複次數\n        No  → Step 8: i = i + 1 // 嘗試下一次重複\n    No  → Step 9: 回傳 -1 // 仍無法包含 b\nEnd // 程式結束\n\nWe need to keep sequential steps. In Step 8, after incrementing i, we need to go back to decision loop. So we need a loop arrow. Use arrow to indicate loop: We can have a Decision block that loops. Might need to structure as:\n\nDecision: i <= minRepeat + 2? \n    Yes → rep = rep + a \n    → Decision: rep 是否包含 b? \n        Yes → 回傳 i \n        No  → i = i + 1 \n        → 回到上層 Decision? (loop) \n    No → 回傳 -1\n\nBut maybe easier: Use a While loop:\n\n→ Step 6: While i <= minRepeat + 2: \n    rep = rep + a \n    if rep contains b: return i \n    i = i + 1 \n→ Step 7: return -1\n\nBut the requirement: use arrow and Decision structure. So we can embed a loop using Decision and arrows.\n\nLet's structure as:\n\n→ Step 5: 初始化 i = 1 // 目前重複次數\n→ Decision: i <= minRepeat + 2? // 是否還有重複次數可嘗試\n    Yes → Step 6: rep = rep + a // 加入 a\n    → Decision: rep 是否包含 b? // 檢查是否已滿足\n        Yes → Step 7: 回傳 i // 找到答案\n        No  → Step 8: i = i + 1 // 增加次數\n        → 回到上層 Decision (loop) \n    No  → Step 9: 回傳 -1 // 所有次數都嘗試完畢仍無法\n\nWe need to denote \"回到上層 Decision (loop)\" maybe not necessary; just note that the flow goes back to the Decision at line 5.\n\nBetter to use arrow to indicate loop back: \"→ Decision: i <= ...? // 回到此處\".\n\nWe'll produce lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 a 的長度 lenA // a 的長度  \n→ Step 2: 取得 b 的長度 lenB // b 的長度  \n→ Step 3: 計算最小重複次數 minRepeat = (lenB + lenA - 1) / lenA // 向上取整的最小重複次數  \n→ Step 4: 初始化 rep = \"\" // 用於累積重複後的字串  \n→ Step 5: 初始化 i = 1 // 目前已重複的次數  \n→ Decision: i <= minRepeat + 2? // 是否還有重複次數可嘗試  \n    Yes → Step 6: rep = rep + a // 加入一個 a  \n    → Decision: rep 是否包含 b? // 檢查 b 是否為子字串  \n        Yes → Step 7: 回傳 i // 找到最小重複次數，結束程式  \n        No  → Step 8: i = i + 1 // 次數加 1，繼續嘗試  \n        → 回到上層 Decision (loop)  \n    No  → Step 9: 回傳 -1 // 所有嘗試結束仍無法包含 b  \nEnd // 程式結束執行"
    },
    {
      "title": "Target Sum",
      "source_file": "Leetcode/leetcode494.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnksc4nuj.py\", line 35, in <module>\n    main()\n  File \"/tmp/tmpnksc4nuj.py\", line 26, in main\n    target_str = parts[1].split('=')[1]\n                 ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findTargetSumWays(self, nums, target):\n        # dp[sum] = number of ways to reach this sum\n        dp = defaultdict(int)\n        dp[0] = 1\n        for num in nums:\n            next_dp = defaultdict(int)\n            for s, count in dp.items():\n                next_dp[s + num] += count\n                next_dp[s - num] += count\n            dp = next_dp\n        return dp[target]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expected format: \"nums = [1,1,1], target = 3\"\n    data = data.replace(' ', '')\n    parts = data.split(',')\n    nums_str = parts[0].split('=')[1]\n    target_str = parts[1].split('=')[1]\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n\n    solution = Solution()\n    result = solution.findTargetSumWays(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: count number of expressions with + or - that sum to target. Essentially classic \"Target Sum\" dynamic programming or DFS with memoization. We'll produce virtual code line by line. Let's do Start, then Step: read array, read target, define recursive function with memoization, base case, recursion. Count. End.\n\nFollow format exactly: Each line \"虛擬碼步驟 // 解釋\". Use arrow and Decision. Let's craft.\n\nWe need to ensure no actual code, just pseudocode. Use \"→\" to indicate steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 整數陣列 nums 與 目標值 target // 從使用者或輸入取得資料  \n→ Step 2: 建立 空字典 memo 用於快取 // memo[(index, current_sum)] → 方案數  \n→ Decision: 若 nums 為空? // 檢查是否已無剩餘數字  \n Yes → Step 3: 若 target == 0? // 判斷最終和是否符合目標  \n  Yes → Return 1 // 只有一種合法表達式（空表達式）  \n  No → Return 0 // 無合法表達式  \n No → Step 4: 呼叫 函式 countWays(0, 0) // 從第一個數字開始，初始和為 0  \n→ Function: countWays(index, current_sum)  \n  Decision: 若 (index, current_sum) 於 memo? // 已計算過此子問題  \n   Yes → Return memo[(index, current_sum)] // 直接回傳快取結果  \n   No → Step 5: 若 index == nums.length? // 所有數字已處理完畢  \n    Yes → Decision: 若 current_sum == target? // 判斷是否達到目標  \n      Yes → Return 1 // 找到一個合法表達式  \n      No → Return 0 // 不符合目標  \n    No → Step 6: 取得 num = nums[index] // 取下一個數字  \n      → Step 7: 計算 plus = countWays(index+1, current_sum + num) // 加號選項  \n      → Step 8: 計算 minus = countWays(index+1, current_sum - num) // 減號選項  \n      → Step 9: total = plus + minus // 合併兩種選擇的方案數  \n      → Step 10: memo[(index, current_sum)] = total // 存入快取  \n      → Return total // 回傳此子問題的答案  \n→ Step 11: 取得 count = countWays(0, 0) // 主呼叫返回最終答案  \n→ Step 12: 輸出 count // 顯示可建立的不同表達式總數  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe1mnnkfr.py\", line 38, in <module>\n    arguments = ast.literal_eval(arg_part)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[[1, 2, 3]], [], [], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)          # 原始陣列\n        self.nums = list(nums)              # 目前陣列，用於 shuffle\n\n    def reset(self):\n        \"\"\"重置陣列並回傳原始順序\"\"\"\n        self.nums = list(self.original)\n        return self.nums\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 洗牌演算法回傳隨機打亂的陣列\"\"\"\n        n = len(self.nums)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        return self.nums\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 分離指令與對應參數\n    # 例：[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]\n    cmd_part, arg_part = data.split('],', 1)\n    cmd_part += ']'                          # 重新補上 ]\n    arg_part = '[' + arg_part.strip()        # 確保是合法列表\n\n    # 解析為 Python 物件\n    commands = ast.literal_eval(cmd_part)\n    arguments = ast.literal_eval(arg_part)\n\n    results = []\n\n    # 執行指令序列\n    for idx, cmd in enumerate(commands):\n        if cmd == \"Solution\":\n            # 初始化物件，參數為 arguments[0][0]\n            sol = Solution(arguments[0][0])\n            results.append(None)\n        elif cmd == \"reset\":\n            results.append(sol.reset())\n        elif cmd == \"shuffle\":\n            results.append(sol.shuffle())\n\n    # 輸出結果，使用 JSON 格式以得到 `null` 代替 `None`\n    print(json.dumps(results, separators=(', ', ': ')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for a Solution class with constructor, reset, shuffle. We need to design algorithm: using Fisher-Yates shuffle. Also store original copy.\n\nWe need to produce lines with \"Start\" and \"End\" etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow → and Decision:.\n\nWe need to produce step-by-step: Start → Step 1: store original array etc. We need to maintain object state: original array, current array.\n\nLet's craft:\n\nStart\n→ Step 1: Store nums in originalArray // 保存原始排列\n→ Step 2: Create mutable array arr as copy of nums // 用於隨機打亂\n→ Step 3: Define reset() // 重置方法\n    → Step 4: Set arr to copy of originalArray // 恢復原始\n    → Step 5: Return arr // 返回\n→ Step 6: Define shuffle() // 打亂方法\n    → Step 7: For i from arr.length-1 downto 1 // Fisher-Yates\n        → Step 8: Generate random integer j between 0 and i inclusive // 隨機選擇\n        → Step 9: Swap arr[i] and arr[j] // 交換\n    → Step 10: Return arr // 返回打亂後的陣列\nEnd\n\nNeed to use Decision? not needed. But we can show Decision for random? Not necessary. Use arrow.\n\nWe should include the class definition and methods.\n\nWe need to format lines: \"Start // 程式開始執行\" etc. Use \"Step\" with numbers. Provide explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set originalArray ← copy of input nums // 取得並保存原始排列  \n→ Step 2: Set arr ← copy of originalArray // 用於後續隨機打亂  \n→ Step 3: Define reset() // 重置方法  \n  → Step 4: Set arr ← copy of originalArray // 恢復到原始順序  \n  → Step 5: Return arr // 回傳重置後的陣列  \n→ Step 6: Define shuffle() // 打亂方法  \n  → Step 7: For i from arr.length - 1 down to 1 // Fisher‑Yates 循環  \n    → Step 8: Generate random integer j in [0, i] // 隨機選擇位置  \n    → Step 9: Swap arr[i] and arr[j] // 交換兩個元素  \n  → Step 10: Return arr // 回傳隨機打亂後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    res = []\n    def backtrack(start, path):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 取出中括號之間的部分並解析成列表\n    try:\n        start = raw_input.find('[')\n        end = raw_input.rfind(']')\n        nums = ast.literal_eval(raw_input[start:end+1])\n    except Exception:\n        # 若解析失敗則假設輸入本身就是列表表達式\n        nums = ast.literal_eval(raw_input)\n    result = subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for generating power set of an array of unique elements. We must not output actual code, but virtual code steps. We need to use arrows, decisions, etc.\n\nWe need to produce line-by-line virtual code, each line includes a virtual code step and explanation. Use \"Start\", \"End\", \"Decision:\", \"→\". Provide the algorithm: maybe recursive backtracking or iterative.\n\nLet's outline steps:\n\nStart // program starts\n\n→ Step 1: Input array nums // receive input\n\n→ Step 2: Initialize result list res with empty subset // start with empty set\n\n→ Decision: 是否已經處理完所有元素? (if index == len(nums)) // base case\n\n    Yes → Step 3: Add current subset to res // add subset\n\n    No  → Decision: 是否包含 nums[index] in current subset? // we need to explore both choices\n\nBut typical algorithm: For each element, we can either include or exclude. We'll use recursion with backtracking.\n\nPseudo steps:\n\n→ Function backtrack(index, current_subset)\n\n    → If index == len(nums): add current_subset copy to res; return\n\n    → // Exclude current element\n\n    → backtrack(index+1, current_subset)\n\n    → // Include current element\n\n    → Append nums[index] to current_subset\n\n    → backtrack(index+1, current_subset)\n\n    → // Backtrack: remove last element\n\nBut need to produce as virtual code lines.\n\nLet's produce a linear virtual code with function call.\n\nStart\n\n→ Step 1: 定義遞迴函數 backtrack(index, subset) // 用於生成子集\n\n→ Decision: 如果 index 等於 nums 長度? // 檢查是否到達結尾\n\n    Yes → Step 2: 把 subset 的複製加入 res // 收集子集\n\n    No  → Step 3: // 不包含 nums[index]\n\n        → backtrack(index+1, subset) // 直接往下一個元素\n\n    No → Step 4: // 包含 nums[index]\n\n        → Append nums[index] 到 subset\n\n        → backtrack(index+1, subset) // 進行下一層\n\n        → Remove 最後一個元素從 subset // 回溯\n\nEnd\n\nBut need to start with calling backtrack(0, empty list). Provide step for initializing res and calling backtrack.\n\nLet's produce:\n\nStart\n\n→ Step 1: 初始化 res 為空集合 // 存放所有子集\n\n→ Step 2: 初始化 subset 為空集合 // 當前子集\n\n→ Step 3: 呼叫 backtrack(0, subset) // 開始遞迴\n\nThen define backtrack as above.\n\nLet's structure virtual code:\n\nStart\n\n→ Step 1: res ← [] // 儲存所有子集\n\n→ Step 2: subset ← [] // 當前子集\n\n→ Step 3: Call backtrack(0, subset) // 開始遞迴\n\n→ Function backtrack(index, subset):\n\n    → Decision: 如果 index == len(nums)? // 檢查是否已處理完所有元素\n\n        Yes → Step 4: res.append(copy(subset)) // 收集子集\n\n        No  → // 不包含 nums[index]\n\n            → backtrack(index+1, subset)\n\n        No  → // 包含 nums[index]\n\n            → subset.append(nums[index])\n\n            → backtrack(index+1, subset)\n\n            → subset.pop() // 回溯\n\n→ End // 程式結束\n\nBut need to use \"→\" arrow before each step inside function. Use indentation or maybe no indent but using \"Decision:\" etc.\n\nBetter to show as:\n\nStart // 程式開始\n\n→ Step 1: res ← [] // 初始化結果列表\n\n→ Step 2: subset ← [] // 初始化暫存子集\n\n→ Step 3: Call backtrack(0, subset) // 啟動遞迴\n\n→ Function backtrack(index, subset):\n\n    → Decision: 如果 index == len(nums)? // 到達末尾\n\n        Yes → Step 4: res.append(copy(subset)) // 收集子集\n\n        No  → Step 5: // 不選取 nums[index]\n\n            → backtrack(index+1, subset) // 進一步遞迴\n\n        No  → Step 6: // 選取 nums[index]\n\n            → subset.append(nums[index]) // 加入元素\n\n            → backtrack(index+1, subset) // 進一步遞迴\n\n            → subset.pop() // 回溯移除元素\n\nEnd // 結束\n\nWe need to ensure \"→\" for each line inside function, also \"Decision:\" lines.\n\nWe must provide explanation after each line.\n\nAlso avoid \"Function\" maybe need \"→ Step 1: 定義遞迴函式 backtrack(index, subset)\". But we can just embed as above.\n\nBetter to use:\n\n→ Step 1: 定義遞迴函式 backtrack(index, subset) // 用於產生子集\n\nThen inside we use Decision etc.\n\nLet's produce final output.\n\nNote: They ask to output only virtual code lines, no actual code. So we must not use code formatting? But examples used code block but not necessary. We'll output plain lines.\n\nAlso need to follow format: each line \"虛擬碼步驟 空格 // 解釋\".\n\nLet's produce accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: res ← [] // 初始化結果列表，用來存放所有子集\n→ Step 2: subset ← [] // 初始化暫存子集，用來構造單一子集\n→ Step 3: Call backtrack(0, subset) // 啟動遞迴，從索引 0 開始\n→ Step 4: 定義遞迴函式 backtrack(index, subset) // 用於生成子集\n    → Decision: 如果 index == len(nums)? // 判斷是否已經處理完所有元素\n        Yes → Step 5: res.append(copy(subset)) // 把當前子集複製並加入結果\n        No  → Step 6: // 不包含 nums[index]，直接遞迴到下一個元素\n            → backtrack(index+1, subset) // 進一步遞迴\n        No  → Step 7: // 包含 nums[index]，先將元素加入子集\n            → subset.append(nums[index]) // 加入當前元素\n            → backtrack(index+1, subset) // 再遞迴到下一個元素\n            → subset.pop() // 回溯：移除剛剛加入的元素\nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,-1,-3]'\nGot (Norm):      '[None,1,-1,-3]'\n--- (Raw) ---\nRaw Expected: '[null, 1, -1, -3]'\nRaw Got:      '[None, 1, -1, -3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並解析成兩個列表 (commands, args)\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 為了能夠使用 ast.literal_eval 解析兩個列表，將整段文字包裝成元組字面量\n    data = ast.literal_eval(\"(\" + raw_input + \")\")\n    commands, args_list = data\n\n    obj = None\n    results = []\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"NumArray\":\n            # args 是一個包含 nums 的列表，例如 [[1,2,3]]\n            obj = NumArray(args[0])\n            results.append(None)  # constructor 返回 null\n        elif cmd == \"sumRange\":\n            # args 是 [left, right]\n            results.append(obj.sumRange(args[0], args[1]))\n\n    # 將結果輸出為 Python 形式的列表，None 將被顯示為 None\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for implementing the NumArray class with prefix sum. Step by step. Start, end. Provide lines with // explanation. Use arrow. Provide multiple steps. Should be like:\n\nStart\n→ Step 1: Define class NumArray // define class\n→ Step 2: Define constructor with nums array // store array and compute prefix sums\n→ Step 3: Compute prefix array\n→ Step 4: Define sumRange method\n→ Step 5: Return prefix[right+1] - prefix[left] // compute sum\nEnd\n\nAlso include explanation. We should include comments for each line. Use arrows. Ensure each line ends with comment. Provide in Chinese. Use bullet? No. Just line. Use arrow. Provide exactly as format: \"虛擬碼步驟 // 解釋\". For arrows, include \"→\".\n\nThus output:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 建立數組累加功能的類別\n→ Step 2: 建構子 NumArray(nums) // 初始化，接收整數陣列\n→ Step 3: 建立 prefix 佔用長度 nums.length + 1 的陣列 // prefix[0] = 0, 用於儲存前綴和\n→ Step 4: 對於 i 從 0 到 nums.length-1\n    → prefix[i+1] = prefix[i] + nums[i] // 依序累加至 prefix\n→ Step 5: 定義方法 sumRange(left, right) // 回傳左右區間總和\n    → return prefix[right+1] - prefix[left] // 差值即為區間和\nEnd // 程式執行結束\n\nBut we need \"逐行\" output. The indentation lines inside loops? The example shows indentation for Decision but not required. We can put Step 4 with indentation inside for loop? Use arrow indentation? For clarity, we can just keep as separate lines: Step 4: for i loop, Step 5: inside. But the example uses arrow and indentation for decisions. For for loops, we can just write:\n\n→ Step 4: For i from 0 to nums.length-1 // 迭代陣列建立前綴和\n    → prefix[i+1] = prefix[i] + nums[i] // 更新前綴和\n\nAlso sumRange inside.\n\nThus produce lines accordingly.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 NumArray // 建立處理前綴和的類別  \n→ Step 2: 建構子 NumArray(nums) // 初始化，接收整數陣列  \n→ Step 3: 建立 prefix 佔用長度 nums.length + 1 的陣列 // prefix[0] = 0，用於儲存前綴和  \n→ Step 4: For i from 0 to nums.length - 1 // 逐元素累加建立前綴和  \n    → prefix[i + 1] = prefix[i] + nums[i] // 更新 prefix[i+1] 為前綴和  \n→ Step 5: 定義方法 sumRange(left, right) // 回傳左右區間總和  \n    → return prefix[right + 1] - prefix[left] // 差值即為 nums[left…right] 的總和  \nEnd // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"Multiply two non‑negative integer strings without using built‑in big integer.\"\"\"\n        # Special case: if either number is zero, the product is zero.\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        # Result can be at most m + n digits long.\n        pos = [0] * (m + n)\n\n        # Multiply each digit of num1 with each digit of num2.\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                # Positions in the result array:\n                # p2 holds the lower digit of the product sum,\n                # p1 holds the higher digit (carry position).\n                p1, p2 = i + j, i + j + 1\n                total = mul + pos[p2]\n\n                # Store lower digit and propagate carry to the higher digit.\n                pos[p2] = total % 10\n                pos[p1] += total // 10\n\n        # Convert the integer list to a string, skipping leading zeros.\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result\n\ndef main():\n    # Read the entire input; it may contain the numbers in any format.\n    data = sys.stdin.read()\n    # Extract all contiguous digit sequences; they correspond to the numbers.\n    numbers = re.findall(r'\\d+', data)\n    if len(numbers) < 2:\n        # If we didn't find two numbers, the input format is incorrect.\n        print(\"0\")\n        return\n    num1, num2 = numbers[0], numbers[1]\n\n    solver = Solution()\n    product = solver.multiply(num1, num2)\n    print(product)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to multiply two non-negative integer strings without BigInteger or direct conversion. Classic string multiplication algorithm: produce result array of length m+n, iterate from end of strings, multiply digits, accumulate, handle carry. Output string trimming leading zeros. We need to write virtual code lines, with explanations. Must be line-by-line, using arrow symbols. Format example shows \"→ Step 1: 輸入使用者數字 // ...\" etc. So each line is like \"Start // 程式開始執行\". Use arrow \"→\" for steps, \"Decision:\" etc.\n\nWe need to generate a clear algorithm in pseudo-code. Should include input, output, main steps: initialize arrays, loop over digits reversed, compute product, sum with carry, produce final string, remove leading zeros. Also handle special case if either input is \"0\".\n\nWe'll produce lines with virtual code steps.\n\nLet's produce:\n\nStart\n→ Input num1, num2 // 取得兩個數字字串\n→ Decision: 如果 num1 等於 '0' 或 num2 等於 '0'? // 檢查是否為零\n    Yes → Step 1: Return '0' // 直接回傳\n    No  →\n→ Step 2: m ← length(num1), n ← length(num2) // 取得長度\n→ Step 3: result ← array of size m+n initialized to 0 // 用於存放每位積\n→ Step 4: For i從 m-1 到 0 循環 // 從最低位開始\n    → For j從 n-1 到 0 循環 // 內層迴圈\n        → digit1 ← int(num1[i]) // 轉換字元為數字\n        → digit2 ← int(num2[j]) // 轉換字元為數字\n        → prod ← digit1 * digit2 // 兩位相乘\n        → sum ← prod + result[i+j+1] // 加入已存積與位置\n        → result[i+j+1] ← sum mod 10 // 儲存單位\n        → result[i+j] ← result[i+j] + sum div 10 // 加入進位\n→ Step 5: Build output string by跳過前導零\n    → idx ← 0\n    → While idx < length(result) AND result[idx] == 0\n        → idx ← idx + 1\n    → If idx == length(result) // 全為零\n        → Return '0'\n    → Else\n        → output ← ''\n        → For k從 idx 到 length(result)-1\n            → output ← output + char(result[k] + '0')\n        → Return output\n\nEnd\n\nWe need to ensure each line is one statement with arrow and explanation. Use Decision, Yes, No, Step.\n\nWe need to maintain formatting exactly: each line with \"→ Step ...\" or \"Decision:\" etc. Indentation? In example, they indent under Decision with Yes → ... No → ... but we can keep same style. Use tab or spaces? Use simple indent.\n\nWe'll produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Input num1, num2 // 取得兩個數字字串\n→ Decision: 如果 num1 等於 '0' 或 num2 等於 '0'? // 檢查是否為零\n    Yes → Step 1: Return '0' // 直接回傳\n    No  →\n→ Step 2: m ← length(num1), n ← length(num2) // 取得兩個字串長度\n→ Step 3: result ← array of size m+n 初始化為 0 // 用於存放乘法結果\n→ Step 4: For i 从 m-1 到 0  // 從最低位開始迴圈\n    → For j 从 n-1 到 0  // 內層迴圈遍歷 num2\n        → digit1 ← int(num1[i]) // 把 num1 的第 i 位字元轉成數字\n        → digit2 ← int(num2[j]) // 把 num2 的第 j 位字元轉成數字\n        → prod ← digit1 * digit2 // 兩位數相乘\n        → sum ← prod + result[i+j+1] // 加上已存的積與進位\n        → result[i+j+1] ← sum mod 10 // 存單位數\n        → result[i+j] ← result[i+j] + sum div 10 // 加入進位\n→ Step 5: Build 輸出字串，跳過前導零\n    → idx ← 0\n    → While idx < length(result) AND result[idx] == 0\n        → idx ← idx + 1\n    → Decision: 如果 idx 等於 length(result)? // 全部為零\n        Yes → Return '0' // 只剩零\n        No  →\n            → output ← '' // 初始化空字串\n            → For k 从 idx 到 length(result)-1\n                → output ← output + char(result[k] + '0') // 轉回字元\n            → Return output\nEnd // 程式執行結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hIndex(self, citations):\n        \"\"\"\n        Binary search on a sorted citations array to find the h-index.\n        citations : List[int] – sorted in non‑decreasing order.\n        Returns the maximum integer h such that at least h papers have\n        at least h citations.\n        \"\"\"\n        n = len(citations)\n        left, right = 0, n - 1\n        best_h = 0\n        while left <= right:\n            mid = (left + right) // 2\n            # Number of papers with citations >= citations[mid]\n            # is n - mid because the array is sorted ascending.\n            if citations[mid] >= n - mid:\n                # mid satisfies the condition, try to find a larger h\n                best_h = n - mid\n                left = mid + 1\n            else:\n                # mid is too large, shrink the search space\n                right = mid - 1\n        return best_h\n\n\ndef parse_citations(line: str):\n    \"\"\"\n    Extract a list of integers from an input line like:\n    'citations = [0,1,3,5,6]'\n    \"\"\"\n    match = re.search(r'\\[.*\\]', line)\n    if match:\n        return eval(match.group(0))\n    return []\n\n\nif __name__ == \"__main__\":\n    # Read all input from stdin (the input may span multiple lines)\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Parse the citations list\n    citations = parse_citations(raw_input)\n\n    # Compute and print the h-index\n    result = Solution().hIndex(citations)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, with explanations, for the problem: given sorted array of citations non-descending, compute h-index, with algorithm in logarithmic time. So binary search. Virtual code steps: Start, Step 1: input array, Step 2: compute n, Step 3: binary search low=1 high=n, Step 4: while low <= high, mid = (low+high)/2, if citations[n-mid] >= mid, then low=mid+1; else high=mid-1. Finally return high (or low-1). Explanation accordingly. Ensure each line with \"虛擬碼步驟\" and comment. Use arrows. Provide each step line. We must adhere to format: \"Start\" etc. Each line: \"虛擬碼步驟 // 解釋\". We'll use arrows. Ensure no actual code, just pseudocode. Provide explanation for each line. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 獲取 citations 陣列 // 從使用者取得已排序的引用次數陣列  \n→ Step 2: 設定 n = citations.length // 取得陣列長度  \n→ Step 3: 設定 low = 1, high = n // h-index 的範圍在 1~n  \n→ Decision: low 是否小於等於 high? // 檢查是否還有搜尋範圍  \n    Yes → Step 4: 計算 mid = (low + high) / 2 // 取中間點作為候選 h  \n    → Step 5: 計算 idx = n - mid // 對應於至少有 mid 次引用的最小索引  \n    → Decision: citations[idx] 是否大於等於 mid? // 判斷是否符合 h 指標條件  \n        Yes → Step 6: 設定 low = mid + 1 // 可能還能找更大的 h，向右搜尋  \n        No  → Step 7: 設定 high = mid - 1 // h 太大，向左縮小搜尋範圍  \n    → End  \n→ End // 跳出 while，low > high  \n→ Step 8: 回傳 high // high 為最大的滿足條件的 h 值  \nEnd // 程式執行結束"
    }
  ]
}