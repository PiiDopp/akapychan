{
  "run_index": 29,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 393,
  "generation_or_validation_failure_count": 46,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,1,1,1,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 1, 1, 1, 5]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取所有標準輸入，並直接執行（符合範例所示的輸入格式）\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation, step by step, following format. Use arrow, Start, End, Decision. The function roll_dice(n). Use random module. Steps: import random, define function, create list, loop n times, random.randint(1,6), append, return list. Provide lines with explanation. Also maybe include error checking? Not necessary. Just simple. Output each line. Use arrow for lines. Use Start, End.\n\nLet's produce lines like:\n\nStart // 程式開始\n→ Step 1: Import random module // 導入 random 模組\n→ Step 2: Define function roll_dice(n) // 定義擲骰子函式\n→ Step 3: Initialize empty list results = [] // 建立空結果列表\n→ Step 4: For i from 1 to n: // 開始擲 n 次\n    → Step 4.1: roll = random.randint(1,6) // 擲一次六面骰\n    → Step 4.2: Append roll to results // 加入結果\n→ Step 5: Return results // 回傳所有結果\nEnd // 程式結束\n\nBut we need arrow syntax: → Step 1: ... // explanation. For loop need indentation? Use arrow to indicate inside block? Could use spaces. Provide a Decision? No.\n\nBut we should use arrow for each line, maybe nested? Could use tab indentation with arrow. Example:\n\nStart // 程式開始執行\n→ Step 1: Import random module // 導入 random 模組\n→ Step 2: Define function roll_dice(n) // 定義函式\n→ Step 3: Initialize results = [] // 建立空列表\n→ Step 4: For i = 1 to n: // 進行擲骰迴圈\n    → Step 4.1: roll = random.randint(1,6) // 擲一次骰子\n    → Step 4.2: Append roll to results // 存入列表\n→ Step 5: Return results // 回傳結果\nEnd // 程式結束\n\nYes. Provide each line.\n\nWe must not output actual code, just virtual code. So \"Step 1: Import random module\" is virtual. Good.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 導入 random 模組  \n→ Step 2: Define function roll_dice(n) // 定義擲骰子函式  \n→ Step 3: Initialize results = [] // 建立空結果列表  \n→ Step 4: For i = 1 to n: // 進行擲 n 次的迴圈  \n  → Step 4.1: roll = random.randint(1,6) // 擲一次六面骰  \n  → Step 4.2: Append roll to results // 將擲出的數字加入列表  \n→ Step 5: Return results // 回傳所有擲出的結果  \nEnd // 程式結束執行"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '(8,2.0)'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '(8, 2.0)'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行所需秒數，回傳結果與四捨五入到小數點 3 位的時間。\"\"\"\n    start = time.perf_counter()          # 記錄開始時間\n    result = func(*args)                 # 執行目標函數並取得結果\n    end = time.perf_counter()            # 記錄結束時間\n    duration = round(end - start, 3)     # 四捨五入到小數點 3 位\n    return result, duration\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼並執行\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step with comments. Use Start, End, Decision, etc. The function measure_time that takes func, *args, measures time. Steps: import time? In virtual code maybe Step 1: Import time. Step 2: Define function measure_time(func, *args). Step 3: record start time. Step 4: execute func(*args) store result. Step 5: record end time. Step 6: compute duration. Step 7: round duration to 3 decimal places. Step 8: return result and duration? The requirement says \"回傳結果 (四捨五入到小數點 3 位)\" ambiguous: maybe return the result of func and the duration? Likely return a tuple: (result, duration). We'll design that.\n\nWe need to produce virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's create a structured pseudo code.\n\nStart\n→ Step 1: Import time module // 導入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義測時函數\n    → Step 3: start = time.perf_counter() // 記錄開始時間\n    → Step 4: result = func(*args) // 執行目標函數並取得結果\n    → Step 5: end = time.perf_counter() // 記錄結束時間\n    → Step 6: duration = end - start // 計算執行秒數\n    → Step 7: rounded_duration = round(duration, 3) // 四捨五入到三位小數\n    → Step 8: return result, rounded_duration // 回傳結果與執行時間\nEnd\n\nWe should use Decision? Not needed.\n\nWe output accordingly. Use the format. Ensure each line includes step, arrow, etc. Probably include indentation for nested steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 導入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 定義測時函數  \n  → Step 3: start = time.perf_counter() // 記錄開始時間  \n  → Step 4: result = func(*args) // 執行目標函數並取得結果  \n  → Step 5: end = time.perf_counter() // 記錄結束時間  \n  → Step 6: duration = end - start // 計算執行秒數  \n  → Step 7: rounded_duration = round(duration, 3) // 四捨五入到小數點 3 位  \n  → Step 8: return result, rounded_duration // 回傳函數結果與執行時間  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"orange\",\"apple\",\"melon\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'orange', 'apple', 'melon'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取任何提供的輸入，但此問題中不需要實際處理\n    _ = sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'（不會拋錯誤）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each line: \"虛擬碼步驟 // 解釋\". Use Start, → etc. We need steps for creating set, add, update, remove, discard, output. Use decision? No need decision. Just sequential. Also show operations. The final output statement: print or display.\n\nWe need to obey format: \"Start // 程式開始執行\". Then arrow \"→\". Each line. For collection operations, use \"Step 1:...\" etc. Provide explanation. Use the arrow arrow. Provide End.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增元素 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除元素 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: display fruits // 輸出最終集合\nEnd // 程式執行結束\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use arrow for steps. Use no actual code. Use \"←\" or \"←\"? The example uses \"Step 1:\" but uses \"→ Step 1:\". We'll use \"→ Step 1:\". Good.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'（不會拋錯誤）  \n→ Step 6: display fruits // 輸出最終集合 fruits  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef get_rate():\n    \"\"\"\n    呼叫匯率 API，回傳美元兌台幣的匯率。\n    若發生任何錯誤，拋出 Exception。\n    \"\"\"\n    url = 'https://api.exchangerate-api.com/v4/latest/USD'\n    r = requests.get(url, timeout=10)\n    r.raise_for_status()\n    data = r.json()\n    return data['rates']['TWD']\n\ndef main():\n    \"\"\"\n    1. 先從標準輸入讀取資料。\n    2. 若輸入文字中包含「更新匯率」或「按下」，就取得匯率並印出。\n    3. 接著開啟 tkinter GUI，提供手動更新匯率的按鈕。\n    \"\"\"\n    # 讀取全部輸入\n    input_data = sys.stdin.read()\n    if input_data:\n        # 若使用者輸入與「更新匯率」相關的字詞，直接印出匯率\n        if '更新匯率' in input_data or '按下' in input_data:\n            try:\n                rate = get_rate()\n                print(f'目前美元匯率：約 {rate} TWD')\n            except Exception:\n                print('更新失敗，請檢查網路連線')\n            # 結束後仍進入 GUI\n        # 若輸入不包含相關字詞，則不做任何輸出，直接進入 GUI\n\n    # 建立 tkinter 視窗\n    root = tk.Tk()\n    root.title('匯率查詢')\n\n    label = tk.Label(root, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label():\n        \"\"\"按鈕回呼，取得最新匯率並更新 label\"\"\"\n        try:\n            rate = get_rate()\n            label.config(text=f'目前美元匯率：約 {rate} TWD')\n        except Exception:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    update_button = tk.Button(root, text='更新匯率', command=update_label)\n    update_button.pack(pady=5)\n\n    # 初始取得一次匯率\n    try:\n        rate = get_rate()\n        label.config(text=f'目前美元匯率：約 {rate} TWD')\n    except Exception:\n        label.config(text='更新失敗，請檢查網路連線')\n\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with arrows and explanations. No actual code. Just steps.\n\nWe need steps for importing modules, creating Tkinter window, setting up button, function to fetch rate using requests, display, main loop.\n\nLet's structure.\n\nStart\n→ Import modules: requests, tkinter\n→ Create main window\n→ Set window title\n→ Create label for displaying rate\n→ Define function fetch_rate():\n    → Send GET request to API\n    → Parse JSON response\n    → Extract TWD rate\n    → Update label text\n→ Create button to trigger fetch_rate\n→ Pack widgets\n→ Call fetch_rate initially\n→ Start mainloop\nEnd\n\nWe need decision? Possibly handle errors? But requirement didn't mention error handling. We can include simple decision.\n\nAlso we should use virtual arrows: \"→\" for sequential steps, \"Decision:\" for condition. Not necessary here, but maybe for error.\n\nWe'll include decision for status code success.\n\nOk.\n\nLet's produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Import modules: requests, tkinter // 匯入網路請求與 GUI 套件\n→ Create main window (root) // 建立 Tkinter 視窗物件\n→ Set window title to 'USD/TWD 匯率顯示' // 給視窗一個標題\n→ Create label (rate_label) with initial text '匯率載入中...' // 用於顯示匯率資訊\n→ Define function fetch_rate(): // 開始定義抓取匯率的功能\n    → Send GET request to 'https://api.exchangerate-api.com/v4/latest/USD' // 呼叫匯率 API\n    → Decision: 如果回應 status code 為 200? // 檢查請求是否成功\n        Yes → Parse JSON response // 解析回傳的 JSON\n        → Extract TWD rate from 'rates' dictionary // 取得台幣匯率\n        → Update rate_label text to f'USD to TWD: {rate}' // 顯示最新匯率\n        No  → Update rate_label text to '請求失敗，請稍後重試' // 顯示錯誤訊息\n→ Create button (refresh_btn) labelled '更新匯率' and bind to fetch_rate // 建立按鈕並連結功能\n→ Pack rate_label, refresh_btn into root window // 將元件排版\n→ Call fetch_rate() once to initialise匯率顯示 // 先抓一次顯示初始匯率\n→ Start mainloop of root // 開始事件迴圈，等待使用者操作\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # 儲存值到其索引的映射\n        self.val_to_index = {}\n        # 儲存所有元素的列表\n        self.values = []\n\n    def insert(self, val):\n        \"\"\"插入元素，若不存在則加入並回傳 True，否則回傳 False\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        \"\"\"刪除元素，若存在則刪除並回傳 True，否則回傳 False\"\"\"\n        if val not in self.val_to_index:\n            return False\n        # 取得要刪除元素的索引\n        idx = self.val_to_index[val]\n        # 取得最後一個元素\n        last_val = self.values[-1]\n        # 用最後一個元素覆蓋要刪除的位置\n        self.values[idx] = last_val\n        # 更新覆蓋後元素的新索引\n        self.val_to_index[last_val] = idx\n        # 刪除最後一個元素\n        self.values.pop()\n        # 刪除映射\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        \"\"\"隨機返回一個元素\"\"\"\n        return random.choice(self.values)\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        sys.exit(0)\n\n    # 將輸入轉成兩個列表：操作序列與對應參數\n    # 例如：[\"RandomizedSet\", \"insert\"], [[], [1]]\n    data = ast.literal_eval('[' + data_str + ']')\n    ops, args = data\n\n    result = []\n    obj = None\n\n    for i, op in enumerate(ops):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            result.append(None)  # constructor 的返回值為 null\n        elif op == \"insert\":\n            val = args[i][0]\n            result.append(obj.insert(val))\n        elif op == \"remove\":\n            val = args[i][0]\n            result.append(obj.remove(val))\n        elif op == \"getRandom\":\n            result.append(obj.getRandom())\n\n    # 使用 json.dumps 以符合題目輸出格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing RandomizedSet with O(1) operations. We need to produce each step with arrow notation and comments.\n\nWe need to include Start, End, Decision, etc. It's a design explanation, not code. Each line: \"虛擬碼步驟 [space] // 解釋\".\n\nWe should outline initialization, insert, remove, getRandom. We need to use an array/list for values and a hashmap for val->index. Provide steps for each method.\n\nWe should keep \"Start\" at top, \"End\" at bottom. Also maybe \"Class Definition\" but it's virtual steps, maybe we include \"Start // 程式開始執行\" then \"→ Class RandomizedSet\" but maybe we just outline operations.\n\nBetter produce high-level steps:\n\nStart\n→ Initialize: Create empty list values and map indices // 資料結構初始化\n→ Method insert(val):\n    → Decision: val exists in map? // 檢查是否已存在\n        Yes → Return false // 已存在，插入失敗\n        No → Append val to list // 加入末尾\n             → Update map[val] = last_index // 記錄位置\n             → Return true // 插入成功\n→ Method remove(val):\n    → Decision: val exists in map? // 檢查是否存在\n        Yes → Get index of val\n             → Get last element in list\n             → Overwrite list[index] = last_element // 覆蓋\n             → Update map[last_element] = index // 更新位置\n             → Remove last element from list // 刪除尾部\n             → Delete map[val] // 移除映射\n             → Return true // 刪除成功\n        No → Return false // 不存在，刪除失敗\n→ Method getRandom():\n    → Generate random integer r between 0 and len(list)-1 // 隨機索引\n    → Return list[r] // 返回隨機元素\nEnd\n\nAlso we need each line with arrow maybe nested indentation.\n\nWe need to include \"Decision:\" lines with Yes → / No →.\n\nWe should also include comment after each line.\n\nWe must not output real code, only virtual steps.\n\nWe must output line by line.\n\nWe need to maintain proper indentation with arrows. Use `→` before each step. Use \"Decision:\" for condition. Use Yes→, No→.\n\nWe need to incorporate Start and End.\n\nWe also need to show that getRandom uses array indexing.\n\nLet's produce.\n\nAlso maybe include \"Return\" steps.\n\nWe must avoid real code, but still show logic. We should keep lines short but descriptive.\n\nLet's produce.\n\nWe'll use Chinese comments.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize values ← [] // 建立儲存元素的列表  \n→ Initialize indices ← {} // 建立元素值到索引的映射  \n\n→ Method insert(val): // 插入方法開始  \n    → Decision: val exists in indices? // 檢查元素是否已存在  \n        Yes → Return false // 失敗：元素已存在  \n        No  → Append val to values // 追加到列表末尾  \n             → Update indices[val] ← last_index // 記錄新位置  \n             → Return true // 成功：元素已插入  \n\n→ Method remove(val): // 刪除方法開始  \n    → Decision: val exists in indices? // 檢查元素是否存在  \n        Yes → Retrieve idx ← indices[val] // 取得元素索引  \n             → Retrieve last_val ← values[last_index] // 取得最後一個元素  \n             → Overwrite values[idx] ← last_val // 用最後元素覆蓋待刪元素  \n             → Update indices[last_val] ← idx // 更新被覆蓋元素的新位置  \n             → Remove last element from values // 刪除列表尾部  \n             → Delete indices[val] // 刪除映射  \n             → Return true // 成功：元素已刪除  \n        No  → Return false // 失敗：元素不存在  \n\n→ Method getRandom(): // 隨機取得方法開始  \n    → Generate random integer r ∈ [0, len(values)-1] // 隨機索引  \n    → Return values[r] // 回傳隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[0,0],[1,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [0, 0], [1, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, m_rows, n_cols):\n        self.m = m_rows\n        self.n = n_cols\n        self.total = m_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.n, x % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.flipped.clear()\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Wrap the input string into a tuple for safe parsing\n    data = ast.literal_eval(f\"({raw})\")\n    commands, args_list = data\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        elif cmd == \"flip\":\n            results.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            results.append(None)\n    # Output with JSON formatting to get `null` instead of `None`\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm. Likely to use reservoir/selection without storing full matrix. Approach: treat each cell as index in range m*n. Maintain map of available positions mapping to some. Use trick: randomly choose an index from [0, remaining-1], map to actual position via hashmap that tracks swapped values.\n\nPseudo: total=m*n, remaining=total. map=HashMap<Integer,Integer>.\n\nflip(): randIndex= random(0, remaining-1). val=map.getOrDefault(randIndex, randIndex). remaining--. map.put(randIndex, map.getOrDefault(remaining, remaining)). return [val / n, val % n].\n\nreset(): clear map, remaining=total.\n\nWe need to output virtual code line by line with explanations. Use Start, End, Decision, etc.\n\nLet's produce lines:\n\nStart\n→ Step: 初始化 m, n, total = m * n, remaining = total, map = 空哈希表 // 初始化矩阵尺寸与可选位置\n→ Step: 定义 flip() 方法 // 准备返回随机零位并翻转\n    → Step: 生成随机整数 r 在 [0, remaining-1] // 随机挑选可用位置\n    → Step: v = map.getOrDefault(r, r) // 实际位置，如果已交换则取映射\n    → Step: remaining = remaining - 1 // 减少可选位置计数\n    → Step: last = map.getOrDefault(remaining, remaining) // 取最末位置映射\n    → Step: map.put(r, last) // 把 r 位置映射到最末位置，以保持映射完整\n    → Step: i = v / n, j = v % n // 计算二维坐标\n    → Step: return [i, j] // 输出\n→ Step: 定义 reset() 方法 // 重置矩阵\n    → Step: map.clear() // 清空映射\n    → Step: remaining = total // 重新计数\nEnd\n\nAdd Decision? Not needed. But we can use Step with comments.\n\nWe should format each line with virtual code arrow. Use \"→\" for steps. No Decision needed. Let's output.\n\nAlso we need to show for each line: \"虛擬碼步驟 // 解釋\". Use Chinese.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m, n ← 設定矩陣尺寸; total ← m × n; remaining ← total; map ← 空哈希表 // 初始化資料結構  \n→ Step 2: 定義 flip() 方法 // 準備隨機翻轉 0 為 1  \n    → Step 3: r ← 隨機整數 [0, remaining−1] // 隨機挑選一個可用位置  \n    → Step 4: v ← map.getOrDefault(r, r) // 若 r 已被映射，取映射值，否則取 r 本身  \n    → Step 5: remaining ← remaining − 1 // 移除已選位置  \n    → Step 6: last ← map.getOrDefault(remaining, remaining) // 取得最後剩餘位置的映射值  \n    → Step 7: map.put(r, last) // 把 r 位置映射到最後剩餘位置，維持映射一致  \n    → Step 8: i ← v / n; j ← v mod n // 轉換成二維座標  \n    → Step 9: return [i, j] // 返回並已翻轉  \n→ Step 10: 定義 reset() 方法 // 重置矩陣  \n    → Step 11: map.clear() // 清空映射表  \n    → Step 12: remaining ← total // 重設可用位置數量  \nEnd // 程式執行結束"
    },
    {
      "title": "Search in Rotated Sorted Array",
      "source_file": "Leetcode/leetcode33.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzpf5ptnt.py\", line 32, in <module>\n    nums = ast.literal_eval(nums_part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxu4ti2vs.py\", line 32, in <module>\n    nums = ast.literal_eval(nums_part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:  # 左半段有序\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:  # 右半段有序\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入，例如 \"nums = [4,5,6,7,0,1,2], target = 0\"\n    parts = data.split(',', 1)\n    nums_part = parts[0].strip()\n    target_part = parts[1].strip() if len(parts) > 1 else ''\n    if '=' in nums_part:\n        nums = ast.literal_eval(nums_part.split('=', 1)[1].strip())\n    else:\n        nums = ast.literal_eval(nums_part)\n    if '=' in target_part:\n        target = ast.literal_eval(target_part.split('=', 1)[1].strip())\n    else:\n        target = ast.literal_eval(target_part)\n    solution = Solution()\n    result = solution.search(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for searching in rotated sorted array O(log n). So algorithm: binary search with pivot detection. Steps: Start, left=0 right=n-1. While left<=right: mid=(left+right)//2. If nums[mid]==target return mid. Else check if nums[left]<=nums[mid] meaning left part sorted. If target between nums[left] and nums[mid], adjust right=mid-1 else left=mid+1. Else right part sorted. If target between nums[mid] and nums[right], left=mid+1 else right=mid-1. After loop return -1. Also need initial check for empty array. Virtual code.\n\nWe must include arrow syntax.\n\nWe'll output each line with comment. Provide structure. Use \"Decision:\" for conditions.\n\nAlso need to start with Start, End.\n\nEnsure each line: virtual code step + space + // explanation.\n\nWe will not provide actual code, just virtual.\n\nLet's create lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 0, right = nums.length - 1 // 初始化搜尋範圍\n→ Decision: 如果 left > right? // 判斷是否為空陣列\n    Yes → Step 2: 回傳 -1 // 空陣列直接回傳 -1\n    No  → Loop: while left <= right // 進行二分搜尋\n        → Step 3: mid = (left + right) // 2 // 取中點索引\n        → Decision: 如果 nums[mid] == target? // 判斷是否找到目標\n            Yes → Step 4: 回傳 mid // 找到目標即返回索引\n            No  → Decision: 如果 nums[left] <= nums[mid]? // 判斷左半段是否有序\n                Yes → Decision: 如果 target >= nums[left] 且 target < nums[mid]? // 目標在左有序段\n                    Yes → Step 5: right = mid - 1 // 搜尋左半段\n                    No  → Step 6: left = mid + 1 // 目標在右半段\n                No  → Decision: 如果 target > nums[mid] 且 target <= nums[right]? // 目標在右有序段\n                    Yes → Step 7: left = mid + 1 // 搜尋右半段\n                    No  → Step 8: right = mid - 1 // 目標在左半段\nEnd // 程式執行結束\n\nNeed to also include final return -1 after loop? Should add after loop ends.\n\nAdd Step 9 after loop: 回傳 -1 // 未找到目標\n\nLet's produce final virtual code. Ensure each line ends with // explanation. Use proper indentation? They didn't ask for indentation but arrow lines. Use same as example.\n\nWe'll output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = nums.length - 1 // 初始化搜尋範圍  \n→ Decision: 如果 left > right? // 判斷是否為空陣列  \n Yes → Step 2: 回傳 -1 // 空陣列直接回傳 -1  \n No  → Loop: while left <= right // 進行二分搜尋  \n  → Step 3: mid = (left + right) // 2 // 取中點索引  \n  → Decision: 如果 nums[mid] == target? // 判斷是否找到目標  \n   Yes → Step 4: 回傳 mid // 找到目標即返回索引  \n   No  → Decision: 如果 nums[left] <= nums[mid]? // 判斷左半段是否有序  \n    Yes → Decision: 如果 target >= nums[left] 且 target < nums[mid]? // 目標在左有序段  \n     Yes → Step 5: right = mid - 1 // 搜尋左半段  \n     No  → Step 6: left = mid + 1 // 目標在右半段  \n    No  → Decision: 如果 target > nums[mid] 且 target <= nums[right]? // 目標在右有序段  \n     Yes → Step 7: left = mid + 1 // 搜尋右半段  \n     No  → Step 8: right = mid - 1 // 目標在左半段  \n→ Step 9: 回傳 -1 // 未找到目標，搜尋結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmw9hnu88.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpmw9hnu88.py\", line 37, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmpmw9hnu88.py\", line 10, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap the input in parentheses so it becomes a tuple of two lists\n    parsed = ast.literal_eval('(' + data + ')')\n    methods, args = parsed[0], parsed[1]\n\n    obj = None\n    output = []\n\n    for method, arg in zip(methods, args):\n        if method == \"MagicDictionary\":\n            obj = MagicDictionary()\n            output.append(None)\n        elif method == \"buildDict\":\n            obj.buildDict(arg)\n            output.append(None)\n        elif method == \"search\":\n            result = obj.search(arg)\n            output.append(result)\n        else:\n            # Unexpected method name; skip or handle as needed\n            output.append(None)\n\n    # Convert output to LeetCode-style string\n    result_str = '[' + ', '.join(json.dumps(item) for item in output) + ']'\n    print(result_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. This is a design of MagicDictionary with build and search. Need to output pseudo steps, not code. Use Start, End, Decision, etc. So maybe design:\n\n- Start\n- Step: 初始化資料結構: 建立字典儲存每個字串\n- Step: BuildDict: For each word add to set\n- Search: For each position, try all 26 letters; if any changed word in set, return true.\n- End\n\nNeed to represent decision: For each word, for each char, for each letter not same, newWord, check set.\n\nBut need to express pseudo code: Use loops? We can express loops with \"Loop\" arrows. Let's produce:\n\nStart\n→ Step 1: 建立空集合 dict // 存放所有單詞\n→ Decision: buildDict called? // 如果有呼叫 buildDict\n    Yes → Step 2: For each word in dictionary // 加入字典\n          → Step 3: dict.add(word) // 存入集合\n→ End // 建構完成\n...\n\nBut buildDict should be separate. The MagicDictionary class has buildDict method.\n\nWe can produce:\n\nStart\n→ Step 1: 定義 MagicDictionary 物件 // 包含集合 dict\n→ Step 2: buildDict(dictionary)\n    → For each word in dictionary\n        → dict.add(word)\n→ Step 3: search(searchWord)\n    → For i from 0 to length-1\n        → For ch from 'a' to 'z'\n            → If ch != searchWord[i]\n                → newWord = searchWord with i replaced by ch\n                → If dict.contains(newWord)\n                    → Return true\n    → Return false\nEnd\n\nWe need to use virtual code arrows, decisions, etc. Let's structure:\n\nStart\n→ Step: 定義 MagicDictionary 類別\n    → Step: 建構函式: 初始化空集合 dict\n→ Step: buildDict(dictionary)\n    → Step: 對每個 word in dictionary\n        → dict.add(word)\n→ Step: search(searchWord)\n    → Step: For i in [0, len(searchWord)-1]\n        → Step: For ch in 'a'..'z'\n            → Decision: ch == searchWord[i]?\n                No → newWord = searchWord[0:i] + ch + searchWord[i+1:]\n                    → Decision: dict.contains(newWord)?\n                        Yes → Return true\n    → Return false\nEnd\n\nWe can write each line with comment.\n\nMake sure each line uses arrow or decision.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: 定義 MagicDictionary 類別 // 宣告類別並初始化\n    → Step: 建構函式：dict ← 空集合 // 用來儲存所有單字\n→ Step: buildDict(dictionary) // 建構字典\n    → Step: 對每個 word ∈ dictionary\n        → Step: dict.add(word) // 將單字加入集合\n→ Step: search(searchWord) // 搜尋是否能改一個字元匹配字典\n    → Step: For i ← 0 to length(searchWord)-1\n        → Step: For ch ← 'a' to 'z'\n            → Decision: ch == searchWord[i]？ // 是否與原字元相同\n                No → Step: newWord ← 替換 searchWord[i] 為 ch\n                    → Decision: dict.contains(newWord)？ // 新字是否在字典中\n                        Yes → Return true // 找到符合條件的單字\n    → Return false // 無任何可行改法\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Bulb Switcher II",
      "source_file": "Leetcode/leetcode672.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, presses = 1",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def flipLights(self, n: int, presses: int) -> int:\n        if presses == 0:\n            return 1\n        if n == 1:\n            return 2\n        if n == 2:\n            if presses == 1:\n                return 3\n            else:\n                return 4\n        # n >= 3\n        if presses == 1:\n            return 4\n        if presses == 2:\n            return 7\n        return 8\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\\\d+', data)))\n    if len(nums) < 2:\n        print(0)\n    else:\n        n, presses = nums[0], nums[1]\n        solution = Solution()\n        result = solution.flipLights(n, presses)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: we have n bulbs, initial all ON. Four buttons that flip subsets. Presses times. Count distinct final statuses.\n\nWe need to output a step-by-step virtual code, explaining each step. It's not about writing algorithmic details, but produce steps that solve the problem.\n\nWe need to think: For given n and presses, compute number of distinct possible statuses. Known problem: It's from Leetcode: bulbs switch? The result depends on presses and n, with known outcomes: If presses==0 =>1; If presses==1 =>2; If presses==2 =>4; If presses>=3 => depends on n: if n==1 =>2; if n==2 =>4; else =>8.\n\nBut we need to generate virtual code for that logic. Provide steps accordingly.\n\nWe must use Start, End, Decision, etc.\n\nWe need to produce lines like:\n\nStart // 程式開始\n→ Step 1: Input n, presses // 取得 n 和 presses\n→ Step 2: If presses == 0? // 檢查按鈕次數為0\n    Yes → Step 3: Output 1 // 只有一種狀態\n    No → Step 4: If presses == 1? // ...\n        Yes → Step 5: Output 2 // ...\n        No → Step 6: If presses == 2? // ...\n            Yes → Step 7: Output 4\n            No → Step 8: If n == 1? // ...\n                Yes → Step 9: Output 2\n                No → Step 10: If n == 2? // ...\n                    Yes → Step 11: Output 4\n                    No → Step 12: Output 8\nEnd // 程式結束\n\nThat's the typical solution. Provide comments.\n\nWe need to be careful: For presses>=3, we have 8 possible statuses unless n==1 or 2. So we can implement.\n\nWe should also handle n<1? but it's typical.\n\nSo produce virtual code lines accordingly.\n\nAlso, note to mention we don't need to consider flips logic; we just use known combinatorial results.\n\nWe should produce each line with arrow and explanation.\n\nLet's craft.\n\nWe need to ensure each line ends with // 解釋. Use arrows as specified. Use Decision blocks with Yes/No lines.\n\nLet's produce.\n\nWe'll produce like:\n\nStart // 程式開始\n→ Step 1: 讀取 n, presses // 取得燈泡數與按鈕次數\n→ Decision: presses 是否等於 0? // 判斷是否有按鈕按\n    Yes → Step 2: 回傳 1 // 只可能有一種狀態\n    No  → Decision: presses 是否等於 1? // ...\n        Yes → Step 3: 回傳 2 // 兩種可能\n        No  → Decision: presses 是否等於 2? // ...\n            Yes → Step 4: 回傳 4 // 四種可能\n            No  → Decision: n 是否等於 1? // ...\n                Yes → Step 5: 回傳 2 // n=1 時只有兩種\n                No  → Decision: n 是否等於 2? // ...\n                    Yes → Step 6: 回傳 4 // n=2 時四種\n                    No  → Step 7: 回傳 8 // 其他 n 時八種\nEnd // 程式結束\n\nBut we should include the steps for each decision; the arrow after each yes no lines should point to next step.\n\nNeed to ensure formatting:\n\nStart // 程式開始\n→ Step 1: 讀取 n, presses // 取得燈泡數與按鈕次數\n→ Decision: presses 等於 0? // 判斷是否有按鈕按\n    Yes → Step 2: 回傳 1 // 只可能有一種狀態\n    No  → Decision: presses 等於 1? // ...\n        Yes → Step 3: 回傳 2 // 兩種可能\n        No  → Decision: presses 等於 2? // ...\n            Yes → Step 4: 回傳 4 // 四種可能\n            No  → Decision: n 等於 1? // ...\n                Yes → Step 5: 回傳 2 // n=1 時只有兩種\n                No  → Decision: n 等於 2? // ...\n                    Yes → Step 6: 回傳 4 // n=2 時四種\n                    No  → Step 7: 回傳 8 // 其他 n 時八種\nEnd // 程式結束\n\nThat should satisfy. Let's output accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 讀取 n, presses // 取得燈泡數與按鈕次數\n→ Decision: presses 等於 0? // 判斷是否有按鈕按\n    Yes → Step 2: 回傳 1 // 只可能有一種狀態\n    No  → Decision: presses 等於 1? // 檢查按鈕次數是否為 1\n        Yes → Step 3: 回傳 2 // 兩種可能的最終狀態\n        No  → Decision: presses 等於 2? // 檢查按鈕次數是否為 2\n            Yes → Step 4: 回傳 4 // 四種可能的最終狀態\n            No  → Decision: n 等於 1? // n 只有一盞燈時的特殊情況\n                Yes → Step 5: 回傳 2 // 兩種可能\n                No  → Decision: n 等於 2? // n 只有兩盞燈時的特殊情況\n                    Yes → Step 6: 回傳 4 // 四種可能\n                    No  → Step 7: 回傳 8 // n≥3 時可達到八種可能\nEnd // 程式結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8qa0b7cl.py\", line 34, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8qa0b7cl.py\", line 13, in __init__\n    self.lookup[(word[:i], word[j:])] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        # 建立從 (前綴, 後綴) 到最大索引的映射\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):          # 前綴長度\n                for j in range(L + 1):      # 後綴長度\n                    self.lookup[(word[:i], word[j:])] = weight\n\n    def f(self, prefix, suffix):\n        # 直接查表，若不存在回傳 -1\n        return self.lookup.get((prefix, suffix), -1)\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # 用正則表達式抓取兩個括號列表\n    pattern = r'\\s*(\\[.*\\])\\s*,\\s*(\\[.*\\])\\s*'\n    m = re.match(pattern, raw)\n    if not m:\n        raise ValueError(\"輸入格式不符合要求\")\n\n    words_str, query_str = m.group(1), m.group(2)\n    words = ast.literal_eval(words_str)\n    pref, suff = ast.literal_eval(query_str)\n\n    wf = WordFilter(words)\n    print(wf.f(pref, suff))",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line explaining steps for design. Need to describe algorithm, data structures, initialization, and query. No real code, just pseudocode with arrows and decisions.\n\nWe need to design WordFilter class that supports prefix-suffix search efficiently. Likely use Trie for prefixes and suffixes, or hash map mapping (prefix, suffix) to index. But can also use combined key: combine pref and suff with '#' and build trie of reversed words.\n\nSimpler: store words, for each word create all prefixes and suffixes? Might be heavy. Better: use a trie with nodes storing indices list. For each word at index i, insert word into trie where keys are pref#suff combinations. But standard solution: create a trie for all words with added '#' and reversed words. Implementation: For each word, for i from 0 to len(word), for j from 0 to len(word), build key word[i:] + '#' + word[:j]. But we can use a trie storing reversed prefixes.\n\nBut for virtual code, we just outline approach.\n\nWe should produce lines:\n\nStart\n→ Initialize WordFilter class with words array\n→ For each word with index i\n    → For each prefix length p from 0 to len(word)\n        → For each suffix length s from 0 to len(word)\n            → Build key = prefix + '#' + suffix\n            → Store in map key → i (overwrites previous smaller index)\n→ End initialization\n\nQuery f(pref, suff)\n→ key = pref + '#' + suff\n→ Return map.get(key, -1)\n\nWe can mention complexity: O(N * L^2) precompute, O(1) query.\n\nBut also note that we can use trie to reduce memory.\n\nBut for virtual code, we just need steps. Let's craft pseudocode:\n\nStart\n→ Step 1: Define WordFilter class with constructor and method f\n→ Constructor: Receive words array\n→ Step 2: Initialize dictionary map: Map<string, int>\n→ Step 3: For each word index i in words:\n    → Compute len = word.length\n    → For prefix_len from 0 to len:\n        → prefix = word.substring(0, prefix_len)\n        → For suffix_len from 0 to len:\n            → suffix = word.substring(len - suffix_len)\n            → key = prefix + '#' + suffix\n            → Map[key] = i // store latest index\n→ End constructor\n→ Method f(pref, suff):\n    → key = pref + '#' + suff\n    → If key in map: return map[key] else return -1\n→ End method\n→ End class\n\nWe need to include arrow formatting. Also show decisions? Not many decisions. But maybe decision: If key found? Yes/No.\n\nLet's produce each line with explanation.\n\nWe'll format as:\n\nStart // 程式開始執行\n→ Step 1: Define WordFilter class with constructor and f method // 建立類別\n...\n\nWe must be careful to maintain arrow after each step.\n\nUse 'Decision:' lines for key existence.\n\nLet's write it.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 WordFilter 類別，包含建構子 WordFilter(string[] words) 與方法 f(string pref, string suff) // 準備類別結構  \n→ Step 2: 在建構子內部初始化空的哈希表 map<string, int> // 用於存放「前綴#後綴」對應的最大索引  \n→ Step 3: 對 words 中每個字串 word 以及其索引 i 進行迭代 // 準備逐字處理  \n→     SubStep 3.1: 計算 word 的長度 len = word.length // 取得字長  \n→     SubStep 3.2: 從 prefix_len = 0 到 len 逐步增加  \n→         SubSubStep 3.2.1: 取 prefix = word.substring(0, prefix_len) // 取得當前前綴  \n→         SubStep 3.3: 從 suffix_len = 0 到 len 逐步增加  \n→             SubSubStep 3.3.1: 取 suffix = word.substring(len - suffix_len) // 取得當前後綴  \n→             SubSubStep 3.3.2: 組合 key = prefix + \"#\" + suffix // 建立唯一鍵  \n→             SubSubStep 3.3.3: map[key] = i // 覆蓋舊值，保留最大的索引  \n→ End 建構子 // 建構完畢  \n→ Method f(pref, suff) // 查詢方法  \n→     SubStep 4.1: 產生 key = pref + \"#\" + suff // 建立查詢鍵  \n→     Decision: key 是否存在於 map? // 檢查是否有符合條件的單詞  \n→         Yes → Return map[key] // 回傳最大的索引  \n→         No  → Return -1 // 沒有符合條件的單詞  \nEnd // 程式結束執行"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpr6z1j_ka.py\", line 39, in <module>\n    profits = list(map(int, re.search(r'profits\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '['"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6vc8gtp8.py\", line 39, in <module>\n    profits = list(map(int, re.search(r'profits\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '['"
        }
      ],
      "generated_code": "import sys\nimport re\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k, W, profits, capital):\n        \"\"\"\n        利用先將專案按資本需求排序，接著用最大堆挑選可負擔的專案利潤。\n        每次挑選一次最優利潤，將其加入現有資本，重複最多 k 次。\n        \"\"\"\n        # 將 (資本需求, 利潤) 兩列打包並依資本需求升序排序\n        projects = sorted(zip(capital, profits))\n        max_heap = []  # 儲存可負擔專案的利潤，使用負值作為最大堆\n        idx = 0        # 追蹤已考慮的專案指標\n        n = len(profits)\n\n        for _ in range(k):\n            # 把所有目前可負擔的專案利潤加入堆\n            while idx < n and projects[idx][0] <= W:\n                heapq.heappush(max_heap, -projects[idx][1])\n                idx += 1\n            # 若無可負擔專案則結束\n            if not max_heap:\n                break\n            # 選取利潤最高的專案並加入資本\n            W += -heapq.heappop(max_heap)\n\n        return W\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit()\n\n    # 使用正則表達式提取 k、w、profits、capital\n    k = int(re.search(r'k\\s*=\\s*(-?\\d+)', data).group(1))\n    w = int(re.search(r'w\\s*=\\s*(-?\\d+)', data).group(1))\n    profits = list(map(int, re.search(r'profits\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)))\n    capital = list(map(int, re.search(r'capital\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)))\n\n    # 執行演算法並輸出結果\n    solution = Solution()\n    result = solution.findMaximizedCapital(k, w, profits, capital)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudo code steps for Leetcode IPO problem: pick up to k projects maximizing capital, each project has profit and required capital. Approach: sort projects by capital ascending. Use max-heap for profits of affordable projects. For up to k times: while next project's capital <= current capital, push profit to heap; if heap empty break; pop max profit, add to capital. Return capital.\n\nWe need step by step virtual code lines, each line with explanation. Use Start, End, Decision, etc. Provide arrows. Format: each line \"虛擬碼步驟 // 解釋\". We should include steps like Build array of pairs, sort, initialize heap, iterate k times, etc.\n\nLet's produce pseudo code accordingly. Ensure Chinese explanation. Use 虛擬碼: \"Start\", \"→\", \"Decision:\", \"Yes →\", \"No →\", \"End\". For loops maybe \"Loop\" or \"Repeat\". We'll produce explicit lines. Let's start.\n\nAlso include step for pairing projects. Use \"Array projects ← [ (capital[i], profits[i]) for i in 0..n-1 ]\". Then sort.\n\nThen pointer idx = 0. Heap = empty max-heap.\n\nThen for i from 1 to k: while idx < n and projects[idx].capital <= currentCapital: push projects[idx].profit; idx++.\n\nThen if heap empty break.\n\nThen currentCapital += heap.popMax().\n\nFinally return currentCapital.\n\nWrap with Start/End.\n\nLet's produce each line. Ensure each line has // explanation. Use appropriate arrows.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 projects 陣列 ← [ (capital[i], profits[i]) for i in 0..n-1 ] // 將資本需求與利潤配對\n→ Step 2: 依資本需求升冪排序 projects // 方便逐步加入可負擔專案\n→ Step 3: 初始化 idx ← 0 // 指標追蹤已考慮專案\n→ Step 4: 初始化 maxHeap ← 空最大堆 // 存放已可負擔專案的利潤\n→ Step 5: 初始化 currentCapital ← w // 現有資本\n→ Loop: i 從 1 到 k 逐步執行 // 最多執行 k 次專案\n    → Decision: 目前可負擔專案數量 > 0? // 判斷是否還有利潤可加入\n        Yes → While idx < n 且 projects[idx].capital ≤ currentCapital\n            → Step 6: maxHeap.insert(projects[idx].profit) // 將可負擔專案的利潤加入堆\n            → Step 7: idx ← idx + 1 // 移至下一個專案\n        No  → Step 8: Break 循環 // 無可負擔專案，結束迴圈\n    → Decision: maxHeap 非空? // 判斷是否有利潤可選擇\n        Yes → Step 9: bestProfit ← maxHeap.extractMax() // 取最大利潤\n        No  → Step 10: Break 循環 // 無可選擇專案，結束迴圈\n    → Step 11: currentCapital ← currentCapital + bestProfit // 完成專案後更新資本\nEnd // 程式執行結束\n→ Return currentCapital // 回傳最終最大資本值"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      \"['()()()', '(())()']\""
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List, Set\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        \"\"\"\n        Return all possible strings after removing the minimum number of\n        invalid parentheses to make the input string valid.\n        \"\"\"\n        # Helper to check if a string is valid\n        def is_valid(string: str) -> bool:\n            count = 0\n            for c in string:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # BFS: level represents all strings at current removal depth\n        level: Set[str] = {s}\n        while True:\n            # Find all valid strings in the current level\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid\n\n            # Generate next level by removing one parenthesis at every position\n            next_level: Set[str] = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        next_item = item[:i] + item[i+1:]\n                        next_level.add(next_item)\n\n            level = next_level\n\ndef extract_input(text: str) -> str:\n    \"\"\"\n    Extract the string value from the input text. The input may be in the form\n    of s = \"...\" or just a quoted string.\n    \"\"\"\n    # Search for a quoted substring\n    m = re.search(r'[\"\\'](.*?)[\"\\']', text)\n    if m:\n        return m.group(1)\n    # Fallback: use whatever comes after '='\n    if '=' in text:\n        return text.split('=', 1)[1].strip()\n    return text.strip()\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read()\n    s = extract_input(raw_input)\n\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n\n    # Print the list of results (Python list representation)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: remove minimum invalid parentheses, return all unique valid strings. This is LeetCode 301.\n\nWe need to generate pseudo code step by step, with explanation after each line. Use Start, Decision, etc. Provide line by line. Not actual code.\n\nWe'll produce algorithm: BFS or DFS with pruning, track min removals. Approach: compute leftRem and rightRem by scanning string. Then DFS recursion removing one parenthesis at each step with pruning, skip duplicates. Use set to store results. Ensure unique.\n\nLet's produce pseudo steps:\n\nStart\n→ Step: 計算需要刪除的左括號數量 leftRem 和右括號數量 rightRem // 先掃描一次\n→ Decision: 若左括號>0? // determine if any removal needed\n    // not necessary in pseudocode; just compute both\n→ Step: 定義遞迴函式 dfs(index, leftCount, rightCount, leftRem, rightRem, path, result) // 主要邏輯\n→ Decision: 如果 index == len(s) // 到末尾\n    Yes → Decision: 如果 leftRem==0 and rightRem==0 // 沒有剩餘刪除\n        Yes → Step: 把 path 加入 result 集合 // 成功組合\n        No  → Step: 返回 // 不符合條件\n→ Decision: 如果 s[index] == '(' // 左括號\n    Yes → Decision: if leftRem > 0 // 可以刪除\n        Yes → Step: dfs(index+1, leftCount, rightCount, leftRem-1, rightRem, path, result) // 刪除本括號\n    Yes → Step: dfs(index+1, leftCount+1, rightCount, leftRem, rightRem, path+'(', result) // 保留\n→ Decision: if s[index] == ')' // 右括號\n    Yes → Decision: if rightRem > 0 // 可以刪除\n        Yes → Step: dfs(index+1, leftCount, rightCount, leftRem, rightRem-1, path, result) // 刪除\n    Yes → Decision: if leftCount > rightCount // 有未匹配左括號\n        Yes → Step: dfs(index+1, leftCount, rightCount+1, leftRem, rightRem, path+')', result) // 保留\n→ Decision: else // 字母\n    Yes → Step: dfs(index+1, leftCount, rightCount, leftRem, rightRem, path+char, result) // 直接加入\nEnd // 返回結果\n\nBut need to include pruning: skip duplicates by if index>0 and s[index]==s[index-1] and we removed this char earlier. In pseudo we can note skipping.\n\nAlso ensure to use Set for results.\n\nWe'll produce steps accordingly. Ensure each line uses arrow. Provide explanation after //.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step: s_len ← length(s) // 取得字串長度\n→ Step: leftRem ← 0, rightRem ← 0 // 初始化左右括號需要刪除的數量\n→ Decision: 從左到右掃描 s // 先計算需要刪除的數量\n    // inside loop not separate lines but we can mention\n→ Step: for i in 0..s_len-1: \n    → Decision: 如果 s[i] == '(' → leftRem ← leftRem + 1 // 遇到左括號就遞增\n    → Decision: 否則如果 s[i] == ')' \n        → Decision: if leftRem > 0 → leftRem ← leftRem - 1 // 匹配成功，減少左括號計數\n        → No  → rightRem ← rightRem + 1 // 無匹配左括號，右括號需要刪除\n// 完成掃描得到 leftRem、rightRem\n→ Step: results ← empty set // 用於存儲唯一有效字串\n→ Step: call dfs(0, 0, 0, leftRem, rightRem, empty string, results) // 開始遞迴\n→ Step: return results as list // 將集合轉為列表返回\n// 以下為遞迴函式定義\n→ Step: 定義函式 dfs(idx, openCount, closeCount, leftRem, rightRem, path, results)\n→ Decision: 如果 idx == s_len // 到達字串末尾\n    Yes → Decision: 如果 leftRem == 0 且 rightRem == 0\n        Yes → Step: results.add(path) // 加入合法字串\n        No  → Step: return // 不符合刪除數量\n    No  → Step: return // 超出長度安全返回\n→ Step: c ← s[idx] // 取得目前字符\n→ Decision: 如果 c == '(' // 左括號\n    Yes → Decision: if leftRem > 0 \n        Yes → Step: dfs(idx+1, openCount, closeCount, leftRem-1, rightRem, path, results) // 刪除此左括號\n    Yes → Step: dfs(idx+1, openCount+1, closeCount, leftRem, rightRem, path + '(', results) // 保留並增加左括號計數\n→ Decision: 否則如果 c == ')' // 右括號\n    Yes → Decision: if rightRem > 0 \n        Yes → Step: dfs(idx+1, openCount, closeCount, leftRem, rightRem-1, path, results) // 刪除此右括號\n    Yes → Decision: if openCount > closeCount // 有未匹配左括號\n        Yes → Step: dfs(idx+1, openCount, closeCount+1, leftRem, rightRem, path + ')', results) // 保留並增加右括號計數\n→ Decision: 否則 // 為字母\n    Yes → Step: dfs(idx+1, openCount, closeCount, leftRem, rightRem, path + c, results) // 直接加入\n// 以上為完整遞迴邏輯\nEnd // 程式執行結束\n\nNeed to ensure format lines with arrow arrow: \"→\" before Step or Decision. Also each line after arrow includes explanation after //. Should not output actual code. We also need to ensure we used \"Yes →\" etc.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: s_len ← length(s) // 取得字串長度  \n→ Step: leftRem ← 0, rightRem ← 0 // 初始化左右括號需要刪除的數量  \n→ Decision: 從左到右掃描 s // 先計算需要刪除的數量  \n  → Step: for i in 0..s_len-1  \n    → Decision: 如果 s[i] == '(' → leftRem ← leftRem + 1 // 遇到左括號就遞增  \n    → Decision: 否則如果 s[i] == ')'  \n      → Decision: if leftRem > 0 → leftRem ← leftRem - 1 // 匹配成功，減少左括號計數  \n      → No → rightRem ← rightRem + 1 // 無匹配左括號，右括號需要刪除  \n// 完成掃描得到 leftRem、rightRem  \n→ Step: results ← empty set // 用於存儲唯一有效字串  \n→ Step: call dfs(0, 0, 0, leftRem, rightRem, empty string, results) // 開始遞迴  \n→ Step: return results as list // 將集合轉為列表返回  \n\n// 以下為遞迴函式定義  \n→ Step: 定義函式 dfs(idx, openCount, closeCount, leftRem, rightRem, path, results)  \n  → Decision: 如果 idx == s_len // 到達字串末尾  \n    Yes → Decision: 如果 leftRem == 0 且 rightRem == 0  \n      Yes → Step: results.add(path) // 加入合法字串  \n      No  → Step: return // 不符合刪除數量  \n    No  → Step: return // 超出長度安全返回  \n  → Step: c ← s[idx] // 取得目前字符  \n  → Decision: 如果 c == '(' // 左括號  \n    Yes → Decision: if leftRem > 0  \n      Yes → Step: dfs(idx+1, openCount, closeCount, leftRem-1, rightRem, path, results) // 刪除此左括號  \n    Yes → Step: dfs(idx+1, openCount+1, closeCount, leftRem, rightRem, path + '(', results) // 保留並增加左括號計數  \n  → Decision: 否則如果 c == ')' // 右括號  \n    Yes → Decision: if rightRem > 0  \n      Yes → Step: dfs(idx+1, openCount, closeCount, leftRem, rightRem-1, path, results) // 刪除此右括號  \n    Yes → Decision: if openCount > closeCount // 有未匹配左括號  \n      Yes → Step: dfs(idx+1, openCount, closeCount+1, leftRem, rightRem, path + ')', results) // 保留並增加右括號計數  \n  → Decision: 否則 // 為字母  \n    Yes → Step: dfs(idx+1, openCount, closeCount, leftRem, rightRem, path + c, results) // 直接加入  \nEnd // 程式執行結束"
    },
    {
      "title": "Find K Pairs with Smallest Sums",
      "source_file": "Leetcode/leetcode373.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpf3jz_khg.py\", line 44, in <module>\n    nums1, nums2, k = parse_input(input_data)\n                      ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpf3jz_khg.py\", line 33, in parse_input\n    nums1 = ast.literal_eval(part.split('=', 1)[1].strip())\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp83c9q794.py\", line 44, in <module>\n    nums1, nums2, k = parse_input(input_data)\n                      ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp83c9q794.py\", line 33, in parse_input\n    nums1 = ast.literal_eval(part.split('=', 1)[1].strip())\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n    heap = []\n    res = []\n    # 初始將 nums1 的前 min(k, len(nums1)) 個元素與 nums2[0] 配對放入堆\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    # 依次取出最小和，直到得到 k 個結果或堆空\n    while heap and len(res) < k:\n        sum_val, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n\ndef parse_input(s):\n    \"\"\"\n    從形如\n        nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n    的字串中解析出兩個列表和整數 k。\n    \"\"\"\n    parts = s.split(',')\n    nums1 = nums2 = None\n    k = None\n    for part in parts:\n        part = part.strip()\n        if part.startswith('nums1'):\n            nums1 = ast.literal_eval(part.split('=', 1)[1].strip())\n        elif part.startswith('nums2'):\n            nums2 = ast.literal_eval(part.split('=', 1)[1].strip())\n        elif part.startswith('k'):\n            k = int(part.split('=', 1)[1].strip())\n    return nums1, nums2, k\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit()\n    nums1, nums2, k = parse_input(input_data)\n    result = k_smallest_pairs(nums1, nums2, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find k pairs with smallest sums from two sorted arrays. Classic problem: use min-heap of size k. We'll produce pseudocode lines with explanation. Must be structured with Start, Decision, etc. We'll list steps. No actual code, only virtual steps. Use arrows. Include each line. Ensure explanation in Chinese. Use indentation for nested decisions. Probably we want algorithm:\n\nStart\n→ Step 1: Initialize min-heap\n→ Step 2: For each i from 0 to min(k-1, len(nums1)-1): push (nums1[i]+nums2[0], i, 0)\n→ Step 3: Initialize result list\n→ Decision: If result size < k and heap not empty\n    Yes → Step 4: Pop smallest sum from heap → (sum, i, j)\n        → Step 5: Append (nums1[i], nums2[j]) to result\n        → Decision: If j+1 < len(nums2)\n            Yes → Step 6: Push (nums1[i]+nums2[j+1], i, j+1) to heap\n            No  → Step 7: Do nothing\n        → Step 8: Repeat Decision\n    No → End\nEnd\n\nBut we need to use structure. Provide step numbers? Not required but we can. Each line must have virtual code step + space + comment. Use \"→\" for steps, \"Decision:\" for decisions. Provide comments in Chinese.\n\nLet's output. Use Start, End. Use Decision: and Yes →, No →.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化最小堆 Heap ← 空堆 // 用於存放可能的最小和  \n→ Step 2: 初始化結果列表 Result ← 空列表 // 存放 k 個最小和對  \n→ Step 3: 迭代 i ← 0 到 min(k-1, len(nums1)-1)  \n    → Step 3.1: 推入 Heap (nums1[i] + nums2[0], i, 0) // 每個 nums1 的首元素與 nums2 的首元素組合  \n→ Step 4: Decision: Result長度 < k 且 Heap非空? // 判斷是否還需要再取對  \n    Yes → Step 5: Pop Heap 取得最小和 (sum, i, j) // 取出和最小的三元組  \n    → Step 6: Append (nums1[i], nums2[j]) 到 Result // 將對加入結果  \n    → Decision: j + 1 < len(nums2)? // 是否還有下一個 nums2 元素可配對  \n        Yes → Step 7: 推入 Heap (nums1[i] + nums2[j+1], i, j+1) // 將下一個可能的和加入堆  \n        No  → Step 8: 什麼也不做 // 已經到達 nums2 結尾  \n    → Step 9: 轉回 Step 4 進行下一輪判斷  \n    No → End // 已得到 k 個最小對或堆已空  \nEnd // 程式執行結束"
    },
    {
      "title": "Merge Sorted Array",
      "source_file": "Leetcode/leetcode88.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_q1cauri.py\", line 40, in <module>\n    params = parse_input(input_text)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_q1cauri.py\", line 33, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"Merge nums2 into nums1 in-place.\"\"\"\n        i = m - 1          # last valid element in nums1\n        j = n - 1          # last element in nums2\n        k = m + n - 1      # last position in nums1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\ndef parse_input(line: str):\n    \"\"\"Parse a line like 'nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3'.\"\"\"\n    parts = [p.strip() for p in line.split(',')]\n    data = {}\n    for part in parts:\n        if '=' in part:\n            key, val = part.split('=', 1)\n            key = key.strip()\n            val = val.strip()\n            # Use literal_eval to safely parse lists and integers\n            data[key] = ast.literal_eval(val)\n    return data\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        sys.exit(0)\n    params = parse_input(input_text)\n    nums1 = params.get('nums1')\n    m = params.get('m')\n    nums2 = params.get('nums2')\n    n = params.get('n')\n    Solution().merge(nums1, m, nums2, n)\n    # Output without spaces as in the examples\n    print('[' + ','.join(map(str, nums1)) + ']')",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrow, start/end, decisions, etc. No actual code. Just steps. We need to merge sorted arrays into nums1. Classic algorithm: use three pointers from end: i=m-1, j=n-1, k=m+n-1, while i>=0 and j>=0 compare nums1[i] and nums2[j], place larger at nums1[k], decrement pointers. Then if j>=0 remaining elements, copy nums2[j] into nums1[k]. No need to copy i part because already there. Provide virtual code steps with explanations.\n\nWe need to produce lines with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow \"→\". For decisions use Decision: if condition? Yes → Step ... No → Step ... End. Start / End markers.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize i = m - 1 // 指向 nums1 最後有效元素\n→ Step 2: Initialize j = n - 1 // 指向 nums2 最後元素\n→ Step 3: Initialize k = m + n - 1 // 指向 nums1 最後位置\n→ Decision: 是否還有元素待合併? i >= 0 和 j >= 0? // 檢查兩個陣列是否都有未處理元素\n    Yes → Decision: nums1[i] > nums2[j]? // 決定較大者放在末尾\n        Yes → Step 4: nums1[k] = nums1[i] // 把 nums1[i] 放到最終位置\n            → Step 5: i = i - 1 // 移動 nums1 指標\n            → Step 6: k = k - 1 // 移動最終位置指標\n        No  → Step 7: nums1[k] = nums2[j] // 把 nums2[j] 放到最終位置\n            → Step 8: j = j - 1 // 移動 nums2 指標\n            → Step 9: k = k - 1 // 移動最終位置指標\n    No  → Decision: 是否還有 nums2 的元素剩餘? j >= 0? // 若 nums1 已處理完，剩餘 nums2 必須複製\n        Yes → Step 10: nums1[k] = nums2[j] // 將剩餘 nums2 元素複製到 nums1\n            → Step 11: j = j - 1\n            → Step 12: k = k - 1\n        No  → Step 13:  // 所有元素已合併，無需進一步操作\nEnd\n\nBut the decision loop structure needs to repeat. We can use a while loop: Decision: i >= 0 and j >= 0? Yes→..., No→ ... and after handling j? Actually algorithm: while i>=0 and j>=0 ... then after loop, while j>=0 copy. But we can represent as nested decisions.\n\nBut the guidelines require use of \"Decision:\" and \"Yes →\", \"No →\" but no while loops? We can simulate with Decision repeated. But easier: use Decision: i >=0 and j >=0? Yes → step, No → Step X: Decision: j >=0? Yes → step, No → End. And after the Yes branch we loop back to start of Decision. But need to specify loop arrow. But the template might allow repeating arrow to same line? Might be complex.\n\nAlternatively, we can use a loop symbol: \"→ Decision: i >= 0 and j >= 0? ...\", and after the branch we could jump back to the same Decision line (loop). But maybe not needed to be explicit.\n\nSimpler: Use a \"Loop\" concept: \"→ Loop: while i >=0 and j >=0\" but not in guidelines. We can use \"Decision\" to check condition at each iteration, with \"Yes →\" to perform merging and then go back to Decision. \"No →\" exit to next phase.\n\nWe can represent by labeling \"Start Merging\" etc.\n\nLet's produce final virtual code accordingly. Ensure each line has explanation after \"//\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = m - 1 // 設定指向 nums1 的最後一個有效元素  \n→ Step 2: j = n - 1 // 設定指向 nums2 的最後一個元素  \n→ Step 3: k = m + n - 1 // 設定指向 nums1 的最終位置  \n\n→ Decision: i >= 0 and j >= 0? // 判斷兩陣列是否還有未合併的元素  \n    Yes → Decision: nums1[i] > nums2[j]? // 決定較大者放在最後位置  \n        Yes → Step 4: nums1[k] = nums1[i] // 把 nums1[i] 放到 nums1 的最後位置  \n            → Step 5: i = i - 1 // 移動 nums1 指標  \n            → Step 6: k = k - 1 // 移動最終位置指標  \n            → Step 7: Goto Decision // 回到條件判斷繼續合併  \n        No  → Step 8: nums1[k] = nums2[j] // 把 nums2[j] 放到 nums1 的最後位置  \n            → Step 9: j = j - 1 // 移動 nums2 指標  \n            → Step 10: k = k - 1 // 移動最終位置指標  \n            → Step 11: Goto Decision // 回到條件判斷繼續合併  \n    No  → Decision: j >= 0? // 如果 nums1 已處理完，檢查 nums2 是否還有剩餘元素  \n        Yes → Step 12: nums1[k] = nums2[j] // 將剩餘的 nums2 元素複製到 nums1  \n            → Step 13: j = j - 1 // 移動 nums2 指標  \n            → Step 14: k = k - 1 // 移動最終位置指標  \n            → Step 15: Goto Decision // 再次檢查是否還有剩餘元素  \n        No  → Step 16: // 所有元素已合併完成，無需進一步操作  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Unique Substrings in Wraparound String",
      "source_file": "Leetcode/leetcode467.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '7'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findSubstringInWraproundString(self, p: str) -> int:\n        \"\"\"\n        計算字串 p 中所有唯一非空子串，且在無限循環字母表\n        'abcdefghijklmnopqrstuvwxyz' 中能連續出現的個數。\n        \"\"\"\n        # dp[i] 代表以字母 chr(i + ord('a')) 為結尾的最大連續合法子串長度\n        dp = [0] * 26\n        cur_len = 0  # 當前連續合法子串長度\n\n        for i in range(len(p)):\n            # 判斷是否為前一個字母的後繼（含 wraparound）\n            if i > 0 and (ord(p[i]) - ord(p[i - 1])) % 26 == 1:\n                cur_len += 1\n            else:\n                cur_len = 1\n\n            idx = ord(p[i]) - ord('a')\n            if cur_len > dp[idx]:\n                dp[idx] = cur_len\n\n        return sum(dp)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，提取所有小寫字母作為字串 s\n    data = sys.stdin.read()\n    s = ''.join(re.findall(r'[a-z]', data))\n\n    # 創建 Solution 物件並計算答案\n    solution = Solution()\n    result = solution.findSubstringInWraproundString(s)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: Count number of unique non-empty substrings of s that appear in infinite wraparound string base (i.e., all substrings that are contiguous sequences of letters where each next letter follows previous alphabetically, with wrap from z to a). Classic Leetcode 467. Approach: track longest continuous wrap substring ending at each letter; use array of size 26, for each char track max length of valid substring ending with that char. Then answer sum of all entries.\n\nNeed to produce step-by-step virtual code with explanation. Use Start, End, Decision etc.\n\nLet's produce steps: Start, initialize array len[26]=0, prevLen=0, iterate over s with index i. For each char c, if i>0 and (s[i-1]+1)%26 == s[i] else prevLen=0. Update curLen=prevLen+1. idx = c-'a'. If curLen > len[idx] then len[idx] = curLen. Set prevLen=curLen. After loop sum len. Return sum.\n\nWrap-around check: ascii difference or use modulo.\n\nWe need to include decision steps for wrap detection.\n\nAlso, we must not output real code; just virtual steps.\n\nWe can use arrow notation.\n\nLet's craft.\n\nWe might structure:\n\nStart\n→ Initialize array len[26] all 0 // track max length for each ending char\n→ Initialize prevLen = 0 // length of current valid substring\n→ For each index i from 0 to length(s)-1 // iterate string\n    → Let currentChar = s[i] // current character\n    → Decision: if i>0 and currentChar follows previous char in alphabet wraparound? // check consecutive\n        Yes → prevLen = prevLen + 1 // extend current length\n        No  → prevLen = 1 // start new length\n    → idx = currentChar - 'a' // map to 0-25\n    → Decision: if prevLen > len[idx]? // longer ending at this char\n        Yes → len[idx] = prevLen // update max length\n        No → No action\n→ After loop: sum = 0 // initialize sum\n→ For each value in len array\n    → sum = sum + value // accumulate\n→ Return sum // number of unique substrings\nEnd\n\nWe should ensure that we handle modulo properly: if (currentChar - prevChar + 26) % 26 == 1.\n\nDecision: if (i>0 && ((currentChar - prevChar + 26) % 26 == 1))\n\nAlso, prevLen resets to 1 when not consecutive? In algorithm we use prevLen=1 when not consecutive. But we must set prevLen = 1 if not consecutive, else prevLen+1.\n\nLet's produce with this logic.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化陣列 len[26] 全部為 0 // 用來記錄每個字母結尾的最大有效子串長度  \n→ 初始化 prevLen = 0 // 當前連續合法子串的長度  \n→ 循環遍歷 s 的每個字符，索引為 i // 處理整個輸入字串  \n&nbsp;&nbsp;→ 設 currentChar = s[i] // 取得目前的字母  \n&nbsp;&nbsp;→ Decision: 如果 i>0 且 currentChar 為前一字母的後繼（含 wraparound）? // 判斷是否連續  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → prevLen = prevLen + 1 // 連續，長度加 1  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → prevLen = 1 // 非連續，重新開始長度為 1  \n&nbsp;&nbsp;→ idx = currentChar - 'a' // 把字母映射到 0~25  \n&nbsp;&nbsp;→ Decision: 如果 prevLen > len[idx]? // 若此字母結尾的子串更長  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → len[idx] = prevLen // 更新最大長度  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → 什麼都不做  \n→ 迴圈結束後 // 所有字母的最大長度已記錄  \n→ 初始化 sum = 0 // 用來累加所有可能的子串數量  \n→ 循環遍歷 len[26] 的每個值 v  \n&nbsp;&nbsp;→ sum = sum + v // 把長度相加得到總數  \n→ 回傳 sum // 結果即為唯一非空子串的個數  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"Store indices of each number for quick random access.\"\"\"\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"Return a random index where nums[index] == target.\"\"\"\n        return random.choice(self.num_indices[target])\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 將兩個外層列表以最外層逗號分開\n    depth = 0\n    split_pos = None\n    for i, ch in enumerate(raw_input):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_pos = i\n            break\n    if split_pos is None:\n        raise ValueError(\"輸入格式錯誤，無法找到分隔點\")\n\n    cmds_str = raw_input[:split_pos].strip()\n    args_str = raw_input[split_pos + 1 :].strip()\n\n    # 解析兩個列表\n    commands = ast.literal_eval(cmds_str)\n    arguments = ast.literal_eval(args_str)\n\n    results = []\n    obj = None\n\n    for idx, cmd in enumerate(commands):\n        if cmd == \"Solution\":\n            # 建構子，參數為 [[nums]]\n            obj = Solution(*arguments[idx])\n            results.append(None)  # 建構子不返回值，輸出為 null\n        else:\n            # 其他方法，參數可能是 [arg1, arg2, ...]\n            args = arguments[idx]\n            if isinstance(args, list):\n                res = getattr(obj, cmd)(*args)\n            else:\n                res = getattr(obj, cmd)(args)\n            results.append(res)\n\n    # 輸出結果，使用 JSON 以確保 None 變為 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step, line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols. Provide steps: Start, class constructor, method pick, etc. Should explain logic. We need to include Decision nodes.\n\nWe should produce pseudo-code with structure: Start, Step1: store nums array, Step2: create map target->list indices, Step3: pick method: get list, random index, return. Ensure equal probability.\n\nWe need to follow format: \"虛擬碼步驟 [space] // 解釋\".\n\nWe should include arrows and decision constructs. Also include \"End\". Let's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 宣告 Solution 類別\n→ Step 2: Solution(int[] nums) // 建構子，接收整數陣列\n    → Step 3: 建立空字典 targetIndexMap // 存儲目標值到索引列表\n    → Decision: 迭代 nums 以填充 targetIndexMap // 為每個值收集索引\n        Yes → Step 4: 把索引加入對應目標的列表 // 若 key 存在，追加索引\n        No  → Step 5: 建立新列表並加入索引 // 若 key 不存在，創建列表\n→ Step 6: 定義 int pick(int target) // pick 方法\n    → Step 7: 從 targetIndexMap 取得索引列表 list // 取得所有匹配索引\n    → Decision: list 為空？ // 理論上不會，但做安全檢查\n        Yes → Step 8: 回傳 -1 // 目標不存在時回傳 -1\n        No  → Step 9: 生成隨機整數 r 在 [0, list.size() - 1] 之間 // 隨機選取\n            → Step 10: 回傳 list[r] // 回傳隨機索引\nEnd // 程式執行結束\n\nBut we need arrow and decision style. Ensure each line has a comment. Use \"→\" arrow, \"Yes →\", \"No →\" indent.\n\nLet's produce more formal.\n\nAlso need to mention that random selection ensures equal probability because each index equally likely.\n\nWe need to include \"Decision:\" lines with \"Yes →\" and \"No →\".\n\nLet's write.\n\nAlso may include \"Start\" and \"End\".\n\nMake sure each line ends with \" // 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 宣告 Solution 類別  \n→ Step 2: Solution(int[] nums) // 建構子，接收整數陣列  \n    → Step 3: 建立空字典 targetIndexMap // 存儲目標值到索引列表  \n    → Decision: 迭代 nums 以填充 targetIndexMap? // 為每個值收集索引  \n        Yes → Step 4: 把索引 i 加入對應目標 nums[i] 的列表 // 若 key 存在，追加索引  \n        No  → Step 5: 建立新列表並加入索引 i，存入 targetIndexMap[nums[i]] // 若 key 不存在，創建列表  \n→ Step 6: 定義 int pick(int target) // pick 方法  \n    → Step 7: 從 targetIndexMap 取得索引列表 list = targetIndexMap[target] // 取得所有匹配索引  \n    → Decision: list 是否為空? // 理論上不會，但做安全檢查  \n        Yes → Step 8: 回傳 -1 // 目標不存在時回傳 -1（保險）  \n        No  → Step 9: 生成隨機整數 r 在 [0, list.size() - 1] 之間 // 隨機選取索引位置  \n            → Step 10: 回傳 list[r] // 回傳隨機索引，確保各索引等概率  \nEnd // 程式執行結束"
    },
    {
      "title": "Best Time to Buy and Sell Stock IV",
      "source_file": "Leetcode/leetcode188.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpf1ne361q.py\", line 35, in <module>\n    prices = ast.literal_eval(prices_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbcke17eh.py\", line 35, in <module>\n    prices = ast.literal_eval(prices_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, k, prices):\n        n = len(prices)\n        if n == 0:\n            return 0\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        dp = [[0] * n for _ in range(k + 1)]\n        for t in range(1, k + 1):\n            max_diff = -prices[0]\n            for d in range(1, n):\n                dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff)\n                max_diff = max(max_diff, dp[t - 1][d] - prices[d])\n        return dp[k][n - 1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Expect input like: k = 2, prices = [2,4,1]\n    parts = data.split(',')\n    k_part = parts[0].strip()\n    prices_part = parts[1].strip()\n\n    k = int(k_part.split('=')[1].strip())\n    prices_str = prices_part.split('=')[1].strip()\n    prices = ast.literal_eval(prices_str)\n\n    solution = Solution()\n    result = solution.maxProfit(k, prices)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for maximum profit with at most k transactions. Classic DP: dp[trans][day] or 2D array. Since we want pseudocode, we should step through: Input prices array and k. If k >= n/2, do unlimited transactions. Else dp. Use virtual code steps.\n\nWe need to produce line by line with arrow \"→\" and explanation. Also need Start, End, Decision.\n\nWe should produce a simple algorithm: Initialize n = length(prices). If k >= n/2, return sum of all positive differences. Else create dp array of size (k+1) x n. For t from 1 to k: set maxDiff = -prices[0]; for i from 1 to n-1: dp[t][i] = max(dp[t][i-1], prices[i] + maxDiff); maxDiff = max(maxDiff, dp[t-1][i] - prices[i]); Finally answer dp[k][n-1].\n\nLet's write pseudocode lines. Use steps:\n\nStart\n→ Read k, prices\n→ Set n = length(prices)\n→ Decision: if k >= n/2?\n    Yes → Step: compute unlimited profit\n        → Step: profit = 0\n        → Step: for i=1 to n-1: if prices[i] > prices[i-1] then profit += prices[i]-prices[i-1]\n        → Step: output profit\n        → End\n    No → Step: create dp array of (k+1) x n with zeros\n    → Step: for t=1 to k:\n        → Step: set maxDiff = -prices[0]\n        → Step: for i=1 to n-1:\n            → Step: dp[t][i] = max(dp[t][i-1], prices[i] + maxDiff)\n            → Step: maxDiff = max(maxDiff, dp[t-1][i] - prices[i])\n    → Step: output dp[k][n-1]\nEnd\n\nBut we need to follow the format: Each line \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nNeed to use arrows \"→\" and \"Decision:\" etc. Each line is a step. Indentation for nested lines? Use spaces. The example shows indentation inside Decision. Use 4 spaces indent. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 k 與陣列 prices // 取得交易限制及每日股價\n→ Step 2: 設定 n = length(prices) // 股價天數\n→ Decision: k 是否大於等於 n/2? // 判斷是否可視為無限交易\n    Yes → Step 3: 計算無限交易最大利潤\n        → Step 4: profit = 0\n        → Step 5: for i = 1 to n-1:\n            → Step 6: if prices[i] > prices[i-1] then profit += prices[i]-prices[i-1]\n        → Step 7: 輸出 profit\n        → End // 程式結束\n    No → Step 8: 初始化 dp 為 (k+1)×n 的 2D 陣列 // 動態規劃表\n→ Step 9: for t = 1 to k:\n    → Step 10: maxDiff = -prices[0] // 交易前的最大差值\n    → Step 11: for i = 1 to n-1:\n        → Step 12: dp[t][i] = max(dp[t][i-1], prices[i] + maxDiff) // 選擇不交易或賣出\n        → Step 13: maxDiff = max(maxDiff, dp[t-1][i] - prices[i]) // 更新最大差值\n→ Step 14: 輸出 dp[k][n-1] // 最終最大利潤\nEnd // 程式結束\n\nCheck format: Each line starts with \"→\" except Start and End. We need \"虛擬碼步驟\" is the step. Use arrow for indentation. Good.\n\nNeed to ensure that nested indentation uses 4 spaces? Example uses 4 spaces for sub-lines after Decision. We'll use 4 spaces for indentation after Decision: but keep arrow before each line. Example shows: \"    Yes → Step 2:\" etc. So we can mimic.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 k 與陣列 prices // 取得交易限制及每日股價  \n→ Step 2: 設定 n = length(prices) // 股價天數  \n→ Decision: k 是否大於等於 n/2? // 判斷是否可視為無限交易  \n    Yes → Step 3: 計算無限交易最大利潤  \n        → Step 4: profit = 0  \n        → Step 5: for i = 1 to n-1:  \n            → Step 6: if prices[i] > prices[i-1] then profit += prices[i]-prices[i-1]  \n        → Step 7: 輸出 profit  \n        → End // 程式結束  \n    No → Step 8: 初始化 dp 為 (k+1)×n 的 2D 陣列 // 動態規劃表  \n→ Step 9: for t = 1 to k:  \n    → Step 10: maxDiff = -prices[0] // 交易前的最大差值  \n    → Step 11: for i = 1 to n-1:  \n        → Step 12: dp[t][i] = max(dp[t][i-1], prices[i] + maxDiff) // 選擇不交易或賣出  \n        → Step 13: maxDiff = max(maxDiff, dp[t-1][i] - prices[i]) // 更新最大差值  \n→ Step 14: 輸出 dp[k][n-1] // 最終最大利潤  \nEnd // 程式結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出陣列 strs 中，長度最大的「不常見子序列」長度。\n        若不存在，回傳 -1。\n        \"\"\"\n        # 統計每個字串出現次數\n        freq = Counter(strs)\n\n        # 若有唯一字串，長度即為答案\n        for s in strs:\n            if freq[s] == 1:\n                return len(s)\n\n        # 無唯一字串，無法得到不常見子序列\n        return -1\n\ndef main():\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析類似 [\"aba\",\"cdc\",\"eae\"] 的字串為 list\n    try:\n        strs = ast.literal_eval(data)\n    except Exception:\n        # 如果解析失敗，直接終止\n        return\n\n    # 只保留字串類型的元素\n    strs = [s for s in strs if isinstance(s, str)]\n\n    solution = Solution()\n    result = solution.findLUSlength(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving problem: longest uncommon subsequence length between strings array.\n\nKnown solution: if any string is unique (not equal to any other), answer = its length, else -1.\n\nSo algorithm: count frequency of each string. For each string, if freq==1, return its length. If none unique, return -1.\n\nWe need to output virtual code lines with explanations.\n\nLet's produce steps:\n\nStart\n→ Step: Build frequency map of strings\n→ For each string in strs:\n    If freq[s]==1 → return length of s\nAfter loop → return -1\nEnd\n\nBut we need to include decisions and arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立字串頻率表 freq // 用於統計每個字串出現次數\n→ For 每個字串 s in strs:\n    → Decision: 如果 freq[s] == 1? // 檢查字串是否唯一\n        Yes → Step 2: 回傳 s 的長度 // 唯一字串即為最長的不常見子序列長度\n        No  → Step 3: 繼續迴圈 // 不是唯一字串，檢查下一個\n→ Step 4: 回傳 -1 // 沒有唯一字串，最長不常見子序列不存在\nEnd // 程式執行結束\n\nBut need to adhere to arrow style: \"Decision:\" lines with Yes → and No →.\n\nLet's produce as per format.\n\nAlso include \"→\" before steps.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字串頻率表 freq // 用於統計每個字串出現次數  \n→ For 每個字串 s in strs:  \n  → Decision: 如果 freq[s] == 1? // 檢查字串是否唯一  \n   Yes → Step 2: 回傳 s 的長度 // 唯一字串即為最長的不常見子序列長度  \n   No  → Step 3: 繼續迴圈 // 不是唯一字串，檢查下一個  \n→ Step 4: 回傳 -1 // 沒有唯一字串，最長不常見子序列不存在  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"Return all 10-letter-long substrings that occur more than once.\"\"\"\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"從 stdin 讀取的字串解析出 DNA 序列 s。\"\"\"\n    raw = raw.strip()\n    if raw.lower().startswith('s'):\n        # 可能是形如 s = 'DNA' 的輸入\n        _, _, value = raw.partition('=')\n        value = value.strip()\n        if (value.startswith(\"'\") and value.endswith(\"'\")) or \\\n           (value.startswith('\"') and value.endswith('\"')):\n            value = value[1:-1]\n        return value\n    return raw\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(s)\n    # 輸出為 JSON 格式的字串，方便測試\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for this problem: find all 10-letter-long substrings that occur more than once in a given string s (DNA sequence). Standard solution: sliding window, hash map counting, then output substrings with count>1. Complexity O(n). Virtual code steps. Need to use Start, End, Decision etc. Each line: virtual code step + space + // explanation.\n\nWe should also include the data structures: dictionary map substring->count.\n\nPseudo code: Start. Step 1: Read string s. Step 2: Initialize empty map freq. Step 3: For i from 0 to len(s)-10: substring = s[i:i+10]; increment freq[substring]. Step 4: Initialize empty list result. Step 5: For each entry in freq: if count>1, add to result. Step 6: Output result. End.\n\nAdd decisions: check length at least 10? We can add a Decision: if len(s) <10 then result empty. Then end.\n\nNeed to reflect decision nodes: \"Decision: 是否 s 长度 <10?\" Yes → End // no repeated 10-letter sequences. No → Proceed.\n\nAlso decisions for count >1.\n\nAlso use arrow notation: \"→\" for steps, \"Decision:\".\n\nWe'll produce each line. Let's produce. Ensure to follow format: Start // ... etc.\n\nLet's produce code.\n\nPotential nuance: we must show each step. Provide explanation after //.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 DNA 字串 s // 從輸入取得整個 DNA 序列  \n→ Decision: s 的長度 < 10? // 檢查是否足夠長以形成 10 字符子序列  \n Yes → End // 序列太短，無法產生任何 10 字符子序列，程式結束  \n No  → Step 2: 建立空字典 freq 以記錄每個 10 字符子序列的出現次數 // 用於統計頻率  \n→ Step 3: 對 i 從 0 到 len(s)-10 執行  \n  → Substring ← s[i:i+10] // 取出從 i 開始的 10 字符子序列  \n  → freq[Substring] ← freq.get(Substring, 0) + 1 // 更新頻率計數  \n→ Step 4: 建立空清單 result 用於儲存重複出現的子序列 // 結果集合  \n→ Step 5: 對於每個 (substr, cnt) 在 freq.items() 執行  \n  → Decision: cnt > 1? // 判斷此子序列是否出現多於一次  \n   Yes → result.append(substr) // 若重複，加入結果集合  \n   No  →  // 不重複則不執行任何操作  \n→ Step 6: 輸出 result // 回傳所有重複出現的 10 字符子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef permute(nums):\n    res = []\n\n    def backtrack(start):\n        if start == len(nums):\n            res.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    backtrack(0)\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找到第一個 '[' 並取到最後一個 ']'\n    left = data.find('[')\n    right = data.rfind(']')\n    if left == -1 or right == -1 or left > right:\n        nums = []\n    else:\n        nums = ast.literal_eval(data[left:right+1])\n    result = permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all permutations of distinct integers array. The algorithm: backtracking DFS, using visited array or swapping in-place. Each step to generate permutations. Provide line by line steps with explanations. Use Start, End, Decision: etc.\n\nLet's produce a structured algorithm:\n\nStart\n→ Step 1: Receive nums array\n→ Step 2: Initialize result list\n→ Step 3: Define backtrack(index) function\n    → Decision: If index == len(nums)\n        → Step 4: Append copy of nums to result\n        → Step 5: Return\n    → Step 6: For i from index to len(nums)-1\n        → Decision: If i != index? but swap ensures no duplicate; can just swap\n            → Step 7: Swap nums[index] with nums[i]\n            → Step 8: Call backtrack(index+1)\n            → Step 9: Swap nums[index] with nums[i] back (backtrack)\n→ Step 10: Call backtrack(0)\n→ Step 11: Return result\n\nWe need to output virtual code lines with explanation. Each line of virtual code with arrow and explanation after //.\n\nMake sure each line has '→' for normal step, 'Decision:' for if.\n\nAlso need to include the function definition line as a step. Possibly separate lines.\n\nLet's produce. We'll treat function backtrack as step maybe 'Define backtrack(index)' with comment.\n\nWill produce each line separately. Use indentation to show nested.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Receive nums array // 取得輸入的整數陣列  \n→ Step 2: Initialize result list // 建立空列表以儲存所有排列  \n→ Step 3: Define backtrack(index) function // 定義遞迴回朔輔助函式  \n  → Decision: index == len(nums) ? // 檢查是否已排列完所有位置  \n   Yes → Step 4: Append copy of nums to result // 把完整排列加入結果  \n   No  → Step 5: For i from index to len(nums)-1 // 循環嘗試所有可置換位置  \n    → Step 6: Swap nums[index] with nums[i] // 交換元素以建立新排列  \n    → Step 7: Call backtrack(index+1) // 進入下一層遞迴  \n    → Step 8: Swap nums[index] with nums[i] back // 交換回原位置，回朔  \n→ Step 9: Call backtrack(0) // 從第一個位置開始遞迴  \n→ Step 10: Return result // 回傳所有可能的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max heap (invert values)\n        self.large = []  # min heap\n\n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Convert the input into a tuple of (commands, arguments)\n    # Input format: [\"cmd1\", \"cmd2\", ...], [arg1, arg2, ...]\n    # Wrap with parentheses so that ast.literal_eval treats it as a tuple\n    data = '(' + data + ')'\n    try:\n        commands, arguments = ast.literal_eval(data)\n    except Exception:\n        print(\"[]\")\n        return\n\n    result = []\n    mf = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MedianFinder\":\n            mf = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            mf.addNum(arg[0])  # arg is a list containing the number\n            result.append(None)\n        elif cmd == \"findMedian\":\n            result.append(mf.findMedian())\n\n    # Output in JSON format to match the expected \"null\" representation\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for MedianFinder class with methods. Use virtual steps. We need to use Start, End, Decision. Provide line by line with explanations. No actual code. We'll design algorithm: Use two heaps: max heap for lower half, min heap for upper half. For addNum: push to one heap then balance. findMedian: if heaps equal size, average; else top of larger. Provide pseudo steps. Each step separate line. Include class initialization. Let's craft.\n\nWe need to use arrow syntax \"→\". Use indent for decisions. Provide lines like \"Start // 程式開始\". Then \"→ Step 1: 定義類別 MedianFinder // 建立類別\". Actually we should produce virtual code for the class definition? We can create steps inside class: constructor, addNum, findMedian. Use arrow to indicate method entry. Use decisions inside methods. Provide each line explanation.\n\nLet's produce:\n\nStart\n→ Step 1: 定義類別 MedianFinder // 建立 MedianFinder 類別\n→ Step 2: 宣告最大堆 maxHeap, 最小堆 minHeap // 用於儲存前一半和後一半數字\n→ Step 3: Constructor: 初始化 maxHeap, minHeap // 構造函式\n→ Step 4: Method addNum(num) // 新增數字\n    → Decision: 如果 maxHeap 为空? // 初始情況\n        Yes → maxHeap.add(num) // 先放入最大堆\n        No  → Decision: num ≤ maxHeap.peek()? // 比較大小\n            Yes → maxHeap.add(num) // 放入最大堆\n            No  → minHeap.add(num) // 放入最小堆\n    → Decision: maxHeap.size > minHeap.size + 1? // 最大堆多一個\n        Yes → minHeap.add(maxHeap.pop()) // 移動最大堆根到最小堆\n        No  → Decision: minHeap.size > maxHeap.size + 1? // 最小堆多一個\n            Yes → maxHeap.add(minHeap.pop()) // 移動最小堆根到最大堆\n            No  → // 已平衡\n→ Step 5: Method findMedian() // 計算中位數\n    → Decision: maxHeap.size == minHeap.size? // 堆大小相等\n        Yes → median = (maxHeap.peek() + minHeap.peek()) / 2.0 // 取兩堆頂平均\n        No  → Decision: maxHeap.size > minHeap.size? // 最大堆多\n            Yes → median = maxHeap.peek() // 最大堆頂即中位數\n            No  → median = minHeap.peek() // 最小堆頂即中位數\n    → Step 6: Return median // 回傳中位數\nEnd\n\nBut need each line with \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow \"→\" for steps and decisions. Indentation can use spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MedianFinder // 建立 MedianFinder 類別  \n→ Step 2: 宣告兩個堆 maxHeap（最大堆）與 minHeap（最小堆） // 用於儲存前半與後半數值  \n→ Step 3: Constructor: 初始化 maxHeap, minHeap // 建構函式，堆皆空  \n\n→ Step 4: Method addNum(num) // 新增數字到資料結構  \n  → Decision: 如果 maxHeap 為空? // 初始時堆尚未有數字  \n   Yes → maxHeap.add(num) // 把 num 放進最大堆  \n   No → Decision: num ≤ maxHeap.peek()? // 與最大堆頂比較  \n    Yes → maxHeap.add(num) // 若小於等於，放入最大堆  \n    No → minHeap.add(num) // 否則放入最小堆  \n  → Decision: maxHeap.size > minHeap.size + 1? // 最大堆多一個元素  \n   Yes → minHeap.add(maxHeap.pop()) // 把最大堆頂移到最小堆，平衡堆大小  \n   No → Decision: minHeap.size > maxHeap.size + 1? // 最小堆多一個元素  \n    Yes → maxHeap.add(minHeap.pop()) // 把最小堆頂移到最大堆，平衡堆大小  \n    No → // 堆已平衡，無需調整  \n\n→ Step 5: Method findMedian() // 計算目前所有數字的中位數  \n  → Decision: maxHeap.size == minHeap.size? // 堆大小相等  \n   Yes → median = (maxHeap.peek() + minHeap.peek()) / 2.0 // 兩堆頂平均為中位數  \n   No → Decision: maxHeap.size > minHeap.size? // 最大堆多  \n    Yes → median = maxHeap.peek() // 最大堆頂即為中位數  \n    No → median = minHeap.peek() // 最小堆頂即為中位數  \n  → Step 6: Return median // 回傳計算得到的中位數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvqxcae8g.py\", line 49, in <module>\n    intervals, new_interval = parse_input(raw_data)\n                              ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvqxcae8g.py\", line 42, in parse_input\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb0o5tq2s.py\", line 49, in <module>\n    intervals, new_interval = parse_input(raw_data)\n                              ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpb0o5tq2s.py\", line 42, in parse_input\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, new_interval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < new_interval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all intervals that overlap with the new interval\n        while i < n and intervals[i][0] <= new_interval[1]:\n            new_interval[0] = min(new_interval[0], intervals[i][0])\n            new_interval[1] = max(new_interval[1], intervals[i][1])\n            i += 1\n\n        # Add the merged interval\n        result.append(new_interval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(data):\n    \"\"\"\n    解析形如\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    的字串，回傳兩個 Python list。\n    \"\"\"\n    intervals_match = re.search(r'intervals\\s*=\\s*(\\[.*?\\])', data, re.S)\n    new_match = re.search(r'newInterval\\s*=\\s*(\\[.*?\\])', data, re.S)\n    if not intervals_match or not new_match:\n        raise ValueError(\"輸入格式錯誤\")\n    intervals = ast.literal_eval(intervals_match.group(1))\n    new_interval = ast.literal_eval(new_match.group(1))\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_data = sys.stdin.read()\n    intervals, new_interval = parse_input(raw_data)\n\n    # 執行插入與合併\n    solution = Solution()\n    merged = solution.insert(intervals, new_interval)\n\n    # 輸出結果\n    print(merged)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode with each line. The requirement: no actual code, just virtual steps. Should cover the algorithm: merging new interval into sorted non-overlapping list.\n\nLet's design steps:\n\nStart\n→ Step 1: Initialize empty result list res\n→ Step 2: Iterate through intervals with index i from 0 to len-1\n→ Decision: Is intervals[i].end < newInterval.start? // interval ends before new starts, no overlap\n    Yes → Append intervals[i] to res\n    No  → Decision: Is intervals[i].start > newInterval.end? // interval starts after new ends\n        Yes → Append newInterval to res; set newInterval = intervals[i]; // treat this interval as new\n        No  → // overlap\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n→ After loop ends\n→ Append remaining newInterval to res\n→ End\n\nNeed to explain each line. Use arrows. Provide explanation after //.\n\nLet's produce with each step. Need to include arrows with Yes/No decisions properly indent. Let's generate.\n\nAlso need to start with \"Start // 程式開始執行\". Then steps. Use \"→\" for normal step. For Decision: \"Decision: ...\" with Yes →, No →.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的結果陣列 res // 用來存放插入後的區間  \n→ Step 2: 針對每一個 intervals[i] 從頭到尾遍歷  \n→ Decision: 是否 intervals[i].end < newInterval.start? // 此區間完全在新區間左側，無重疊  \n  Yes → Step 3: 把 intervals[i] 加到 res // 保留原本不重疊的區間  \n  No → Decision: 是否 intervals[i].start > newInterval.end? // 此區間完全在新區間右側，無重疊  \n   Yes → Step 4: 把 newInterval 加到 res // 將新區間先加入  \n    → Step 5: 把 intervals[i] 當作新的 newInterval，重新進行合併處理  \n   No → Step 6: 合併 intervals[i] 與 newInterval // 兩區間有重疊，更新 newInterval 為合併結果  \n     → Step 6a: newInterval.start = min(newInterval.start, intervals[i].start)  \n     → Step 6b: newInterval.end = max(newInterval.end, intervals[i].end)  \n→ Step 7: 循環結束後，將剩餘的 newInterval 加到 res // 將最後合併的區間加入  \nEnd // 程式執行結束，返回 res"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport re\nfrom functools import lru_cache\n\ndef chain_remove(s: str) -> str:\n    \"\"\"消除連鎖，返回消除後的棋盤字串\"\"\"\n    while True:\n        n = len(s)\n        i = 0\n        removed = False\n        new_s = []\n        while i < n:\n            j = i + 1\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:  # 可以消除\n                removed = True\n                # 跳過這段\n            else:\n                new_s.append(s[i:j])\n            i = j\n        if not removed:\n            break\n        s = ''.join(new_s)\n    return s\n\ndef min_insertions(board: str, hand: str) -> int:\n    \"\"\"回溯+備忘錄，返回最小插入數；無法清空時返回 -1\"\"\"\n    hand_count = {}\n    for c in hand:\n        hand_count[c] = hand_count.get(c, 0) + 1\n\n    @lru_cache(maxsize=None)\n    def dfs(b: str, h: tuple) -> int:\n        if not b:\n            return 0\n        hand_dict = dict(zip('RYBGRW', h))\n        best = float('inf')\n        n = len(b)\n        # 嘗試每個插入位置\n        i = 0\n        while i <= n:\n            # 找到同色區段\n            if i < n and b[i] == b[i-1] if i>0 else False:\n                # 已在同色區段內，跳過\n                i += 1\n                continue\n            j = i\n            while j < n and b[j] == b[i] if i < n else False:\n                j += 1\n            color = b[i] if i < n else None\n            run_len = j - i\n            need = 3 - run_len\n            if need <= 0:\n                # 直接消除\n                new_board = chain_remove(b)\n                res = dfs(new_board, h)\n                if res != float('inf'):\n                    best = min(best, res)\n                i = j\n                continue\n            if color and hand_dict.get(color, 0) >= need:\n                # 用手牌插入\n                new_hand_dict = hand_dict.copy()\n                new_hand_dict[color] -= need\n                new_h = tuple(new_hand_dict[c] for c in 'RYBGRW')\n                new_board = chain_remove(b[:i] + color * need + b[i:])\n                res = dfs(new_board, new_h)\n                if res != float('inf'):\n                    best = min(best, res + need)\n            i = j\n        return best\n\n    init_hand = tuple(hand_count.get(c, 0) for c in 'RYBGRW')\n    ans = dfs(board, init_hand)\n    return ans if ans != float('inf') else -1\n\ndef parse_input(data: str):\n    \"\"\"解析輸入，提取 board 和 hand\"\"\"\n    # 尋找兩個引號內的字串\n    strs = re.findall(r'\"([A-Z]+)\"', data)\n    if len(strs) >= 2:\n        return strs[0], strs[1]\n    # 否則嘗試按行讀取\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n    raise ValueError(\"無法解析輸入\")\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    board, hand = parse_input(data)\n    result = min_insertions(board, hand)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo code for algorithm to solve Zuma variation. Likely use BFS or DFS with state representation board string + hand counts. Min insertions. Standard solution: DFS with memoization (state: board string, hand string counts) returning min steps or INF. Recursively try inserting balls at each position where adjacent colors same or not. Use removal logic.\n\nWe need to output line-by-line pseudo code with explanations. Use Start, Decision, etc. The pseudo code should outline algorithmic steps. Use arrow etc.\n\nLet's produce a step-by-step pseudo code.\n\nWe will have functions: solve(board, handCounts) -> min steps.\n\nAlgorithm: Use recursion with memoization map<state, result>.\n\nIn recursion: If board empty return 0. For each position i from 0 to board.length: find run of same color around i. Compute needed balls to make 3: need = 3 - runLen. If handCounts[color] >= need: newBoard = remove after inserting need balls. Recursively compute result+need. Keep min.\n\nReturn min else INF.\n\nReturn -1 if INF.\n\nWe'll include functions: removeConsecutive(board) returning board after chain reaction.\n\nImplement removal: iterate over string, collapse consecutive of same color, if len >=3 remove and restart.\n\nPseudo.\n\nNeed to produce lines.\n\nLet's write:\n\nStart // main entry\n\n→ Step 1: 初始化手牌顏色計數表 // Count balls in hand by color\n\n→ Step 2: 呼叫 DFS(board, handCounts) // Find min insertions\n\n→ Decision: 若返回值為 INF? // If impossible\n\n    Yes → Step 3: 回傳 -1 // 返回失敗\n\n    No  → Step 4: 回傳 結果 // 成功\n\nEnd\n\nDefine DFS:\n\n→ Step 5: 若 board 為空則回傳 0 // 已清空\n\n→ Step 6: 若 (board, handCounts) 已在 memo 則回傳 memo值 // 記錄\n\n→ Step 7: 設 minSteps 為 INF\n\n→ Step 8: 迭代位置 i 從 0 到 board.length\n\n    → Decision: 確定同色區段起始與終止 // 找同色連續區段\n\n        Yes → Step 9: 取得顏色 color, 長度 runLen\n\n        → Step 10: 計算需要 balls = 3 - runLen\n\n        → Decision: 是否需要 balls >0? // 需要插入\n\n            Yes → Decision: handCounts[color] >= balls? // 有足夠手牌\n\n                Yes → Step 11: 新手牌計數 newHand = handCounts，扣減 balls\n\n                → Step 12: 新 board after插入：將balls顏色插入區段\n\n                → Step 13: newBoard = chainRemove(newBoard)\n\n                → Step 14: result = DFS(newBoard, newHand)\n\n                → Decision: result ≠ INF? // 可解\n\n                    Yes → Step 15: 更新 minSteps = min(minSteps, result + balls)\n\n            No → Step 16: 直接考慮不插入此位置 // 這種情況不需要插入\n\n→ Step 17: 記錄 memo[(board, handCounts)] = minSteps\n\n→ Step 18: 回傳 minSteps\n\nDefine chainRemove:\n\n→ Step 19: 重複\n\n    → Step 20: 用指標掃描 board，找同色連續段\n\n    → Step 21: 若段長度 ≥3，移除該段\n\n    → Step 22: 重新組合剩餘字串\n\n    → Step 23: 若有移除則回到 Step 20，否則結束\n\n→ Step 24: 回傳清理後的 board\n\nThat's the gist.\n\nWe must format each line as: \"虛擬碼步驟 // 解釋\". Use arrow '→', 'Yes →', 'No →', 'Decision:'. We'll produce each line accordingly.\n\nNeed to include indent for decisions, but keep simple.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 取得手牌顏色計數表 handCounts // 將 hand 轉為每顏色球數\n\n→ Step 2: 以 DFS(board, handCounts) 取得最小插入數 // 進行深度優先搜尋\n\n→ Decision: DFS 回傳 INF? // 判斷是否無法清除\n\n    Yes → Step 3: 回傳 -1 // 無法完成遊戲，輸出失敗\n\n    No  → Step 4: 回傳 0 或具體最小插入數 // 成功完成，輸出結果\n\nEnd // 程式執行結束\n\n▼ DFS 函式定義\n\n→ Step 5: If board 為空則回傳 0 // 牌已全清\n\n→ Step 6: 若 (board, handCounts) 已在 memo 則回傳 memo 值 // 重複狀態節省計算\n\n→ Step 7: 設 minSteps 為 INF // 初始最小步數\n\n→ Step 8: 針對 board 的每個插入位置 i 從 0 到 board.length 執行\n\n    → Decision: 找出 i 位置左右同色連續區段 start ~ end // 確定同色區段\n\n        Yes → Step 9: color ← board[start] // 區段顏色\n\n        → Step 10: runLen ← end - start + 1 // 同色球數\n\n        → Step 11: 需要插入的球數 balls ← 3 - runLen // 使組合至少3個\n\n        → Decision: balls > 0? // 需要插入才能消除\n\n            Yes → Decision: handCounts[color] ≥ balls? // 手牌足夠\n\n                Yes → Step 12: newHand ← handCounts，newHand[color] -= balls // 扣除手牌\n\n                → Step 13: newBoard ← board，將 balls 個 color 插入 start 位置 // 模擬插入\n\n                → Step 14: newBoard ← chainRemove(newBoard) // 連鎖消除\n\n                → Step 15: result ← DFS(newBoard, newHand) // 進一步遞迴\n\n                → Decision: result ≠ INF? // 可成功清除\n\n                    Yes → Step 16: minSteps ← min(minSteps, result + balls) // 更新最小步數\n\n            No → Step 17: // 手牌不足，跳過此位置\n\n        No → Step 18: // 連續區段已 ≥3，直接消除再遞迴\n\n            → Step 19: newBoard ← board；newBoard ← chainRemove(newBoard) // 消除\n\n            → Step 20: result ← DFS(newBoard, handCounts) // 進一步遞迴\n\n            → Decision: result ≠ INF? // 可成功清除\n\n                Yes → Step 21: minSteps ← min(minSteps, result) // 更新最小步數\n\n→ Step 22: memo[(board, handCounts)] ← minSteps // 記錄結果\n\n→ Step 23: 回傳 minSteps // 給呼叫者\n\n▼ chainRemove 函式定義\n\n→ Step 24: repeat\n\n    → Step 25: 用指標掃描 newBoard，找同色連續段 [l, r] // 找連續區段\n\n    → Decision: r - l + 1 ≥ 3? // 是否可消除\n\n        Yes → Step 26: 把區段 [l, r] 從 newBoard 刪除 // 消除球\n\n        → Step 27: 將剩餘子字串連接成 newBoard // 更新\n\n        → Step 28: 從頭重新掃描 // 連鎖消除可能再次發生\n\n        No → Step 29: // 沒有可消除區段\n\n            → Step 30: 跳出迴圈\n\n→ Step 31: 回傳 newBoard // 消除完成後的板面\n\nEnd // 程式結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        \"\"\"Add the half‑open interval [left, right).\"\"\"\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # intervals overlap\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        \"\"\"Return True iff every real number in [left, right) is tracked.\"\"\"\n        i = 0\n        # find first interval that might cover left\n        for idx, (l, r) in enumerate(self.ranges):\n            if l <= left < r:\n                i = idx\n                break\n        else:\n            return False\n        return self.ranges[i][0] <= left and right <= self.ranges[i][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        \"\"\"Stop tracking numbers in the half‑open interval [left, right).\"\"\"\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                # no overlap\n                new_ranges.append([l, r])\n            else:\n                # overlap exists\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\ndef main() -> None:\n    input_data = sys.stdin.read()\n    lines = [line.strip() for line in input_data.splitlines() if line.strip()]\n    objects = {}\n    outputs = []\n\n    ctor_pattern = re.compile(r'^RangeModule\\s+(\\w+)\\s*=\\s*new\\s+RangeModule\\(\\);$')\n    call_pattern = re.compile(r'^(\\w+)\\.(\\w+)\\((.*)\\);$')\n\n    for line in lines:\n        # constructor\n        m = ctor_pattern.match(line)\n        if m:\n            var_name = m.group(1)\n            objects[var_name] = RangeModule()\n            outputs.append(None)\n            continue\n\n        # method calls\n        m = call_pattern.match(line)\n        if m:\n            var, method, args_str = m.groups()\n            args = [int(a.strip()) for a in args_str.split(',') if a.strip()]\n            obj = objects.get(var)\n            if obj is None:\n                continue  # ignore invalid calls\n            if method == 'addRange':\n                obj.addRange(*args)\n                outputs.append(None)\n            elif method == 'removeRange':\n                obj.removeRange(*args)\n                outputs.append(None)\n            elif method == 'queryRange':\n                result = obj.queryRange(*args)\n                outputs.append(result)\n            continue\n\n        # ignore any other line\n        continue\n\n    # format outputs: null, true, false\n    formatted = []\n    for val in outputs:\n        if val is None:\n            formatted.append('null')\n        elif val is True:\n            formatted.append('true')\n        elif val is False:\n            formatted.append('false')\n        else:\n            formatted.append(str(val))\n    print(f\"[{', '.join(formatted)}]\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for design of RangeModule data structure with addRange, queryRange, removeRange. Use start, decision etc. Provide each line: 虛擬碼步驟 [space] // explanation. Should be step-by-step algorithm design. Let's produce conceptual algorithm using interval merging via sorted list or tree. We'll outline:\n\nStart\n→ Initialize sorted list of intervals\n\nAddRange:\n→ Find position to insert\n→ Merge overlapping intervals\n\nQueryRange:\n→ Find first interval that could cover left\n→ Check if interval covers [left,right)\n\nRemoveRange:\n→ Find overlapping intervals\n→ Split or adjust intervals\n\nWe need to produce lines with virtual code steps and explanations. Use arrow and decisions. Let's craft.\n\nAlso we might include a main algorithm to maintain intervals as sorted non-overlapping list.\n\nWill produce step-by-step algorithm, not actual code.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ DataStructure: Intervals ← Empty Sorted List of [l,r) // 初始化一個空的排序列表，用於存放不重疊的半開區間  \n\n**addRange(left, right)**  \n→ FindInsertIndex ← BinarySearch(Intervals, left) // 使用二分搜尋找出左端點可能插入的位置  \n→ NewLeft ← left; NewRight ← right // 初始化新增區間  \n→ i ← FindInsertIndex  \n→ Decision: i > 0 AND Intervals[i-1].right >= left? // 判斷前一個區間是否與新區間重疊  \n    Yes → NewLeft ← min(NewLeft, Intervals[i-1].left)  \n        NewRight ← max(NewRight, Intervals[i-1].right)  \n        Remove Intervals[i-1]  \n        i ← i - 1  \n    No → // 前一個區間不重疊  \n→ Decision: i < length(Intervals) AND Intervals[i].left <= right? // 判斷後續區間是否與新區間重疊  \n    Yes → NewLeft ← min(NewLeft, Intervals[i].left)  \n        NewRight ← max(NewRight, Intervals[i].right)  \n        Remove Intervals[i]  \n        // 不改變 i，因為已刪除，後面區間已向前移動  \n    No → // 後續區間不重疊，停止迴圈  \n→ Insert [NewLeft, NewRight) at position i in Intervals // 插入合併後的新區間  \n\n**queryRange(left, right)**  \n→ i ← BinarySearch(Intervals, left) // 找到左端點可能所在的位置  \n→ Decision: i > 0 AND Intervals[i-1].right > left? // 前一個區間是否覆蓋 left  \n    Yes → i ← i - 1 // 調整到實際覆蓋 left 的區間  \n→ Decision: i >= length(Intervals)? // 沒有任何區間可覆蓋 left  \n    Yes → Return False  \n→ Decision: Intervals[i].left <= left AND Intervals[i].right >= right? // 該區間是否完整覆蓋 [left,right)  \n    Yes → Return True  \n    No  → Return False  \n\n**removeRange(left, right)**  \n→ i ← BinarySearch(Intervals, left) // 找到左端點可能所在的位置  \n→ Decision: i > 0 AND Intervals[i-1].right > left? // 前一個區間是否跨越左端點  \n    Yes → // 需要將其分割  \n        Old ← Intervals[i-1]  \n        Remove Intervals[i-1]  \n        // 只保留左邊不被移除的部分  \n        If Old.left < left: Insert [Old.left, left) at position i-1  \n        // 右邊部分會在後續處理  \n→ While i < length(Intervals) AND Intervals[i].left < right? // 處理所有與 [left,right) 重疊的區間  \n    Decision: Intervals[i].right <= right? // 整個區間在移除範圍內  \n        Yes → Remove Intervals[i] // 刪除整個區間  \n        // i 不變，因為已刪除  \n    No  → // 只需修剪左側，保留右側  \n        NewLeft ← max(Intervals[i].left, right)  \n        Intervals[i].left ← NewLeft // 更新為移除後的起點  \n        Break // 右側已不再重疊，結束迴圈  \n→ End // 結束 removeRange 函式  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0f0dbu5v.py\", line 103, in <module>\n    main()\n  File \"/tmp/tmp0f0dbu5v.py\", line 72, in main\n    commands = json.loads(data[0])   # 讀取操作指令列表\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        # 初始化循環佇列，長度為 k\n        self.k = k\n        self.buf = [0] * k      # 儲存元素的陣列\n        self.head = 0           # 指向前端元素的索引\n        self.count = 0          # 當前佇列中的元素數量\n\n    def insertFront(self, value: int) -> bool:\n        # 前端插入元素\n        if self.count == self.k:     # 佇列已滿\n            return False\n        self.head = (self.head - 1) % self.k  # 循環向前移動 head\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        # 後端插入元素\n        if self.count == self.k:     # 佇列已滿\n            return False\n        idx = (self.head + self.count) % self.k  # 後端實際位置\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        # 刪除前端元素\n        if self.count == 0:          # 佇列為空\n            return False\n        self.head = (self.head + 1) % self.k  # 循環向後移動 head\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        # 刪除後端元素\n        if self.count == 0:          # 佇列為空\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        # 取得前端元素\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        # 取得後端元素\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        # 判斷佇列是否為空\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        # 判斷佇列是否已滿\n        return self.count == self.k\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    commands = json.loads(data[0])   # 讀取操作指令列表\n    args = json.loads(data[1])       # 讀取對應的參數列表\n\n    outputs = []\n    deque_obj = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MyCircularDeque\":\n            deque_obj = MyCircularDeque(arg[0])\n            outputs.append(None)     # 建構子返回 null\n        elif cmd == \"insertFront\":\n            outputs.append(deque_obj.insertFront(arg[0]))\n        elif cmd == \"insertLast\":\n            outputs.append(deque_obj.insertLast(arg[0]))\n        elif cmd == \"deleteFront\":\n            outputs.append(deque_obj.deleteFront())\n        elif cmd == \"deleteLast\":\n            outputs.append(deque_obj.deleteLast())\n        elif cmd == \"getFront\":\n            outputs.append(deque_obj.getFront())\n        elif cmd == \"getRear\":\n            outputs.append(deque_obj.getRear())\n        elif cmd == \"isEmpty\":\n            outputs.append(deque_obj.isEmpty())\n        elif cmd == \"isFull\":\n            outputs.append(deque_obj.isFull())\n\n    # 輸出結果為 JSON 格式，符合 LeetCode 的輸出風格\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for the design of MyCircularDeque class. Each line: virtual code step + space + // explanation. Use arrows and structure. No actual code. Should cover initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. We need to describe algorithm logic. Use Start, End. Let's output as lines.\n\nWe should include Decision blocks for capacity checks etc. Use \"→\" arrow for flow.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 MyCircularDeque(k) // 建立大小為 k 的循環雙端佇列  \n  → 設定陣列 buffer 為長度 k  \n  → head ← 0 // 指向佇列頭部索引  \n  → tail ← 0 // 指向佇列尾部索引  \n  → size ← 0 // 現有元素數量  \n\n→ Step 2: insertFront(value) // 在前端插入元素  \n  → Decision: 如果 isFull()? // 檢查是否已滿  \n    Yes → Return false // 無法插入  \n    No → head ← (head - 1 + k) % k // 前移 head 指標  \n      buffer[head] ← value // 存放新值  \n      size ← size + 1  \n      Return true  \n\n→ Step 3: insertLast(value) // 在後端插入元素  \n  → Decision: 如果 isFull()? // 檢查是否已滿  \n    Yes → Return false // 無法插入  \n    No → buffer[tail] ← value // 存放新值  \n      tail ← (tail + 1) % k // 後移 tail 指標  \n      size ← size + 1  \n      Return true  \n\n→ Step 4: deleteFront() // 刪除前端元素  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return false // 無法刪除  \n    No → head ← (head + 1) % k // 前移 head 指標  \n      size ← size - 1  \n      Return true  \n\n→ Step 5: deleteLast() // 刪除後端元素  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return false // 無法刪除  \n    No → tail ← (tail - 1 + k) % k // 後移 tail 指標  \n      size ← size - 1  \n      Return true  \n\n→ Step 6: getFront() // 取得前端元素  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return -1 // 空佇列無元素  \n    No → Return buffer[head] // 返回 head 所指元素  \n\n→ Step 7: getRear() // 取得後端元素  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return -1 // 空佇列無元素  \n    No → rearIndex ← (tail - 1 + k) % k // 計算實際尾部索引  \n      Return buffer[rearIndex] // 返回 tail 前一個元素  \n\n→ Step 8: isEmpty() // 判斷佇列是否為空  \n  → Return size == 0 // 若大小為 0，則為空  \n\n→ Step 9: isFull() // 判斷佇列是否已滿  \n  → Return size == k // 若大小等於容量，則已滿  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Count of Smaller Numbers After Self",
      "source_file": "Leetcode/leetcode315.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [5,2,6,1]",
          "expected_output": "[2,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,1,1,0]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[2,1,1,0]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "nums = [-1]",
          "expected_output": "[0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-1]",
          "expected_output": "[0,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,0]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,0]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass BIT:\n    \"\"\"Binary Indexed Tree (Fenwick Tree) for prefix sums.\"\"\"\n    def __init__(self, size: int):\n        self.size = size\n        self.tree = [0] * (size + 1)\n\n    def update(self, index: int, delta: int) -> None:\n        \"\"\"Add delta at position index.\"\"\"\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index: int) -> int:\n        \"\"\"Return sum of values in range [1, index].\"\"\"\n        result = 0\n        while index > 0:\n            result += self.tree[index]\n            index -= index & -index\n        return result\n\nclass Solution:\n    def countSmaller(self, nums):\n        \"\"\"Return counts of smaller numbers after each element.\"\"\"\n        # Coordinate compression: map each unique number to a rank starting from 1\n        sorted_unique = sorted(set(nums))\n        rank = {num: i + 1 for i, num in enumerate(sorted_unique)}\n\n        bit = BIT(len(rank))\n        res = []\n\n        # Process numbers from right to left\n        for num in reversed(nums):\n            r = rank[num]\n            # Count numbers already inserted that are smaller than current\n            res.append(bit.query(r - 1))\n            # Insert current number into BIT\n            bit.update(r, 1)\n\n        # Reverse to match original order\n        return res[::-1]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input string which may look like:\n        nums = [5,2,6,1]\n    or simply:\n        [5,2,6,1]\n    Returns the list of integers.\n    \"\"\"\n    data = data.strip()\n    # Find the first '[' and the last ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        return []\n    inner = data[start + 1:end]\n    # Use eval safely on the extracted part\n    try:\n        nums = eval(inner, {\"__builtins__\": None}, {})\n    except Exception:\n        nums = []\n    # Ensure we return a list of ints\n    if isinstance(nums, list):\n        return nums\n    return []\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.countSmaller(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting smaller elements to right, typical problem: count of smaller numbers after self. Approach: using Binary Indexed Tree or Balanced BST. We'll output steps line by line with virtual code syntax.\n\nWe need to use arrows and Decision structure.\n\nLet's produce algorithm: iterate from right to left, maintain sorted list, or BIT. We'll use BIT.\n\nSteps: build coordinate compression, initialize BIT size = unique count. For each element from end to start: query BIT for count of numbers less than current value, store in result[i], then update BIT at index of current value +1.\n\nLet's write virtual steps accordingly.\n\nAlso need Start and End. Provide explanation per line. Use \"Step 1: ...\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 nums 的座標壓縮映射 // 將所有數值映射到 1..m 範圍，方便使用 BIT  \n→ Step 2: 初始化 Binary Indexed Tree (BIT) 以大小 m // BIT 用於快速查詢前綴和  \n→ Step 3: 建立結果陣列 counts，長度與 nums 相同，預設為 0 // 用於存放每個位置右側更小的數量  \n→ Step 4: 逐位從 nums 末端往前遍歷 i ← n-1 downto 0 // 逆序遍歷可確保已處理的元素為右側元素  \n      → Decision: i 為最後一個元素? // 判斷是否為第一輪  \n        Yes → Step 5: counts[i] ← 0 // 最右邊沒有右側元素  \n        No  → Step 6: queriesIndex ← index of nums[i] in compressed mapping  \n           → Step 7: counts[i] ← BIT.query(queriesIndex - 1) // 取得比 nums[i] 小的已插入元素數量  \n           → Step 8: BIT.update(queriesIndex, 1) // 將 nums[i] 加入 BIT，供未來計算使用  \n→ Step 9: 完成遍歷後，返回 counts // 將結果輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphe2odkf5.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmphe2odkf5.py\", line 49, in main\n    result = multiply_complex(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmphe2odkf5.py\", line 23, in multiply_complex\n    a_real, a_imag = parse_complex(a_str)\n                     ^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmphe2odkf5.py\", line 17, in parse_complex\n    real = int(s[:op_pos])\n           ^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '1+'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef parse_complex(s: str):\n    \"\"\"將複數字串轉為 (real, imag) 整數對。\"\"\"\n    s = s.strip()\n    if s.endswith('i'):\n        s = s[:-1]  # 去掉結尾的 'i'\n    # 找出實部與虛部之間的最後一個 '+' 或 '-'\n    op_pos = max(\n        (i for i, ch in enumerate(s[1:], start=1) if ch in '+-'),\n        default=-1\n    )\n    if op_pos == -1:\n        # 只有實部\n        return int(s), 0\n    real = int(s[:op_pos])\n    imag = int(s[op_pos:])\n    return real, imag\n\ndef multiply_complex(a_str: str, b_str: str) -> str:\n    \"\"\"計算兩個複數字串的乘積，並回傳格式 'real+imagi'。\"\"\"\n    a_real, a_imag = parse_complex(a_str)\n    b_real, b_imag = parse_complex(b_str)\n\n    real_part = a_real * b_real - a_imag * b_imag\n    imag_part = a_real * b_imag + a_imag * b_real\n\n    return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 先嘗試從輸入中擷取被雙引號包住的字串\n    quoted = re.findall(r'\"([^\"]+)\"', data)\n    if len(quoted) >= 2:\n        num1, num2 = quoted[0], quoted[1]\n    else:\n        # 若沒有引號，直接以逗號或空白分隔\n        parts = re.split(r',|\\s+', data.strip())\n        parts = [p for p in parts if p]  # 去除空項\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            return  # 輸入格式不符\n\n    result = multiply_complex(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to compute multiplication of two complex numbers represented as strings \"a+bi\". We need step by step: parse, multiply, format. Should be in plain text, each line: virtual code step + space + comment. Use arrows, Start, End, Decision. Need to handle sign, negative numbers. So parse string: find '+', split. But imaginary part may have negative sign? Actually representation \"a+bi\" maybe \"a+bi\" with plus or minus? For example \"1+-1i\"? But typical representation uses \"1+1i\" or \"1-1i\"? But given spec, imaginary part integer range [-100,100]. So the string can be \"a+bi\" or \"a-bi\". Let's assume always contains '+', and imaginary part may start with '-' sign if negative? Actually \"a-bi\" is a+(-b)i. But string \"a-bi\" has '-' sign before b. So easier: find last 'i', then substring up to 'i', then parse real and imaginary. We can find the index of '+' or '-' after real part. But easier: split on '+'? But negative may cause second minus. We can parse using regex? But we need pseudocode.\n\nLet's produce simple logic: Find position of 'i' (last char). Remove it. Then find the last occurrence of '+' or '-' before the imaginary part. Use index of '+' or '-' after first character? Because real part may be negative too. So we need to find the operator between real and imaginary: the last '+' or '-' in the string (excluding first char). Then split accordingly. Then convert to integers. Multiply: (a+bi)(c+di) = (ac - bd) + (ad + bc)i. Format: resultReal + resultImag + 'i'. Imag part may be negative, so we will format accordingly: e.g., if imag >=0 use '+' sign before value. Actually representation likely \"real+imagi\" always with '+' sign between. But spec says string form \"real+imaginaryi\". So if imaginary negative, we would have \"real+-3i\"? Possibly. We'll just format as real + (imag) + \"i\" with plus sign for positive or negative.\n\nLet's produce pseudocode lines.\n\nStart\n→ Step 1: Read input strings num1 and num2 //取得兩個複數字串\n→ Step 2: Parse num1 into (a, b) //拆解實部與虛部\n    → Step 2a: Remove trailing 'i' from num1\n    → Step 2b: Find the position of the last '+' or '-' (excluding first char)\n    → Step 2c: real1 = integer substring before that position\n    → Step 2d: imag1 = integer substring after that position\n→ Step 3: Parse num2 into (c, d) //同上\n→ Step 4: Compute real part of product: realProd = a * c - b * d //計算實部\n→ Step 5: Compute imag part of product: imagProd = a * d + b * c //計算虛部\n→ Step 6: Convert realProd to string realStr\n→ Step 7: Convert imagProd to string imagStr\n→ Step 8: Concatenate result = realStr + imagStr + \"i\" //組成結果字串\n→ End //輸出結果\n\nBut we need to use virtual code with arrows and decisions maybe for parsing. Provide Decision for find operator. But we can keep simple.\n\nLet's produce more granular steps.\n\nAlso include Decision for find operator: find plus or minus.\n\nWe can also include a Decision: if char at position is '-' after first char.\n\nBut we can simply find position of last '+' or '-' in string after first char. Use Step: findOperatorIndex = lastIndexOf '+' or '-' after position 1.\n\nBut to keep simple, we can use Decision: If there is '+' after first char? Then use it else '-'.\n\nBut there may be both, but the last one is correct. We'll implement decision: if string contains '+' after first char? Yes use that index; No use '-'.\n\nBut we need to be careful for negative imaginary: e.g., \"1-1i\" has '-' after '1', but also 'i'. So there is '-' sign. So we can parse.\n\nSimplify: Step 2b: operatorIndex = last index of '+' or '-' in string excluding first char.\n\nWe can implement Decision: If '+' exists after index 1? Yes use that index else use '-'.\n\nBut we can avoid complexity: we can parse using split with regex? But in virtual code, just illustrate.\n\nLet's produce the pseudocode accordingly.\n\nNow output format: each line as \"虛擬碼步驟 // 解釋\". Use arrows and structure.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取兩個複數字串 num1, num2 // 取得輸入  \n→ Step 2: 解析 num1 為 (a, b)  \n  → Step 2a: 移除 num1 最後的 'i' // 刪除虛部符號  \n  → Step 2b: 決定分隔符號  \n   Decision: num1 是否包含 '+' 從第二個字元開始?  \n   Yes → operatorIndex = 最後一個 '+' 的位置 // 正實部+正虛部  \n  No  → operatorIndex = 最後一個 '-' 的位置 // 實部或虛部為負  \n  → Step 2c: real1 = 整數化 num1[0 : operatorIndex] // 取得實部  \n  → Step 2d: imag1 = 整數化 num1[operatorIndex :] // 取得虛部  \n→ Step 3: 解析 num2 為 (c, d) // 同 2 步  \n  → Step 3a: 移除 num2 最後的 'i'  \n  → Step 3b: 決定分隔符號  \n   Decision: num2 是否包含 '+' 從第二個字元開始?  \n   Yes → operatorIndex = 最後一個 '+' 的位置  \n  No  → operatorIndex = 最後一個 '-' 的位置  \n  → Step 3c: real2 = 整數化 num2[0 : operatorIndex]  \n  → Step 3d: imag2 = 整數化 num2[operatorIndex :]  \n→ Step 4: 計算乘積實部 realProd = a * c - b * d // (ac - bd)  \n→ Step 5: 計算乘積虛部 imagProd = a * d + b * c // (ad + bc)  \n→ Step 6: 將 realProd 轉成字串 realStr  \n→ Step 7: 將 imagProd 轉成字串 imagStr  \n→ Step 8: 組合結果 result = realStr + imagStr + \"i\" // \"real+imagi\" 形式  \n→ End // 輸出結果並結束程式"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    \"\"\"找出所有重複檔案的完整路徑。\"\"\"\n    content_map = defaultdict(list)\n\n    for path in paths:\n        parts = path.split()\n        root = parts[0]\n        for file_info in parts[1:]:\n            name, content = file_info.split('(')\n            content = content.rstrip(')')\n            content_map[content].append(f\"{root}/{name}\")\n\n    # 只保留至少兩個檔案的群組\n    return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 允許輸入形式為 \"paths = [...]\"\n    if raw_input.startswith(\"paths\"):\n        # 去除 \"paths =\" 或 \"paths =\"\n        prefix_len = raw_input.find('=') + 1\n        raw_input = raw_input[prefix_len:].strip()\n\n    # 解析成 Python list\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception:\n        print(\"Invalid input format\")\n        return\n\n    # 計算重複檔案並輸出\n    result = find_duplicate(paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for algorithm that given list of directory info strings returns groups of duplicate file paths. We must output line-by-line virtual code steps with explanation after '//'. Use Start, End, Decision. So we produce steps like:\n\nStart\n→ Step 1: Initialize dictionary content_to_paths // map content to list of file paths\n→ For each dir_info in paths // iterate over input list\n   → Parse dir_info into dir_path and file_entries // split by space, first part is path, rest are file entries\n   → For each file_entry in file_entries\n        → Parse file_entry into file_name and file_content // split by '(' and ')'\n        → full_path = dir_path + \"/\" + file_name // construct full path\n        → Add full_path to content_to_paths[file_content] // store\n→ Step 2: Initialize result = [] // list to hold duplicate groups\n→ For each content, path_list in content_to_paths\n     → If length of path_list > 1\n          → Add path_list to result // duplicate group\n→ End // return result\n\nBut they want step-by-step with Decision and arrows. Use Decision for >1. Use loops as Step 1, Step 2 etc. So we need to produce a pseudocode outline. Let's produce lines:\n\nStart\n→ Step 1: content_map ← {} // dictionary mapping file content to list of paths\n→ Decision: 迴圈遍歷每個 directory info? // iterate input list\n    Yes → Step 2: dir_info ← current directory info string // fetch current\n    → Step 3: parts ← dir_info split by space // split into dir path and file entries\n    → dir_path ← parts[0] // first part is directory path\n    → file_entries ← parts[1..] // rest are file entries\n    → Decision: 迴圈遍歷每個 file_entry // iterate files\n        Yes → Step 4: file_entry ← current file entry\n        → Step 5: file_name ← substring before '(' // extract name\n        → Step 6: file_content ← substring inside parentheses // extract content\n        → Step 7: full_path ← dir_path + \"/\" + file_name // build full path\n        → Step 8: If content_map contains file_content\n              Yes → Append full_path to content_map[file_content] // add to existing\n              No  → content_map[file_content] ← [full_path] // new list\n        No  → // end file loop\n    No  → // end dir_info loop\n→ Step 9: result ← [] // initialize result list\n→ Decision: 迴圈遍歷 content_map 的 key/value pairs\n    Yes → current_paths ← value list\n    → Decision: if length of current_paths > 1? // only duplicate groups\n        Yes → Append current_paths to result // add group\n        No  → // skip\n    No  → // end loop\n→ End // return result\n\nMake sure each line has \"→\" arrow for steps inside decisions or loops. But in example, they use indentation inside decision: Yes → etc. We'll replicate.\n\nWe need to produce each line with arrow and explanation. Use Chinese. We'll provide.\n\nLet's output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: content_map ← {} // 建立字典，鍵為檔案內容，值為對應的檔案全路徑列表\n→ Decision: 迴圈遍歷每個 directory info ？ // 處理輸入清單中的每一條資料\n    Yes → Step 2: dir_info ← current directory info string // 取目前的 directory info\n    → Step 3: parts ← dir_info split by space // 用空格分割，得到路徑與檔案資訊\n    → dir_path ← parts[0] // 第一段是目錄路徑\n    → file_entries ← parts[1..] // 其餘為檔案項目\n    → Decision: 迴圈遍歷每個 file_entry ？ // 處理目錄下所有檔案\n        Yes → Step 4: file_entry ← current file entry // 取目前的檔案項目\n        → Step 5: file_name ← substring before '(' // 取得檔名\n        → Step 6: file_content ← substring inside '(' and ')' // 取得檔案內容\n        → Step 7: full_path ← dir_path + \"/\" + file_name // 組成完整路徑\n        → Decision: content_map 是否已包含 file_content ？ // 判斷內容是否已登錄\n            Yes → Append full_path to content_map[file_content] // 已存在，加入路徑\n            No  → content_map[file_content] ← [full_path] // 新建列表並加入路徑\n        No  → // 結束檔案迴圈\n    No  → // 結束 directory info 迴圈\n→ Step 8: result ← [] // 初始化結果列表\n→ Decision: 迴圈遍歷 content_map 的 key/value 對？ // 檢查每一種內容\n    Yes → current_paths ← value list // 取對應的路徑列表\n    → Decision: if length of current_paths > 1 ？ // 只保留重複的檔案\n        Yes → Append current_paths to result // 加入重複組\n        No  → // 跳過單一檔案\n    No  → // 結束字典迴圈\n→ End // 程式執行結束，返回 result\n```"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[5]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[5]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[7,10]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[7, 10]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[5,1,2]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[5, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport random  # 只在缺少外部 rand7() 時作為備援\n\n# 假設外部會提供 rand7()，此處提供一個備援實作\ndef rand7():\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        while True:\n            # 兩次 rand7 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取，例如 'n = 1'\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        sys.exit()\n    n = int(nums[0])\n\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for constructing rand10() using rand7(). Standard solution: use two calls to rand7() to produce 49 outcomes; accept 1-40; map to 1-10 by modulo. If outside, repeat. Provide step-by-step pseudo-code. Use decision branches.\n\nWe need to output lines with virtual code and comments. Use Start, End. Each step line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 function rand10() // 建立 rand10 函式\n→ Decision: Inside rand10 迴圈?\n    Yes → Step 2: Call rand7() 並存於 a // 產生 1~7\n    No  → Step 2: Call rand7() 並存於 b // 產生 1~7\n→ Step 3: 計算 index = (a-1)*7 + b // 生成 1~49\n→ Decision: index ≤ 40? // 可用於映射 1~10\n    Yes → Step 4: return (index-1) mod 10 + 1 // 轉為 1~10\n    No  → Step 5: 進入迴圈重試 // 重新呼叫 rand7()\nEnd // 程式執行結束\n\nNeed to include while loop. Use Decision: 是否完成? etc.\n\nLet's structure:\n\nStart\n→ Step 1: function rand10()\n→ Step 2: loop\n    → Step 3: a ← rand7()\n    → Step 4: b ← rand7()\n    → Step 5: idx ← (a-1)*7 + b\n    → Decision: idx ≤ 40?\n        Yes → Step 6: return (idx-1) mod 10 + 1\n        No  → Step 7: continue loop\n\nWe need to indicate loop with decision or loop structure.\n\nWe can do:\n\n→ Decision: 需要產生有效值? // 迴圈條件\n    Yes → … etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: function rand10() // 建立 rand10 函式\n→ Decision: 需要產生有效值? // 進入重試迴圈\n    Yes → Step 2: a ← rand7() // 產生第一個隨機數 (1~7)\n    → Step 3: b ← rand7() // 產生第二個隨機數 (1~7)\n    → Step 4: idx ← (a-1)*7 + b // 產生 1~49 的組合編號\n    → Decision: idx ≤ 40? // 能否映射到 1~10\n        Yes → Step 5: return (idx-1) mod 10 + 1 // 轉換為 1~10 並返回\n        No  → Step 6: 進入迴圈重試 // idx>40 時重新開始\nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxRotateFunction(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = sum(nums)\n        current = sum(i * num for i, num in enumerate(nums))\n        max_val = current\n        for i in range(1, n):\n            current = current + total - n * nums[i - 1]\n            if current > max_val:\n                max_val = current\n        return max_val\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中提取整數列表。\n    支援類似 'nums = [4,3,2,6]' 或 '[4,3,2,6]' 的格式。\n    \"\"\"\n    match = re.search(r'\\[(.*?)\\]', data)\n    if not match:\n        return []\n    nums_str = match.group(1)\n    if not nums_str.strip():\n        return []\n    return [int(x.strip()) for x in nums_str.split(',')]\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    nums = parse_input(raw)\n    sol = Solution()\n    result = sol.maxRotateFunction(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo steps) for solving problem: find maximum rotation function F(k) for array rotated by k positions clockwise.\n\nWe need to produce line by line, with \"虛擬碼步驟 // 解釋\". Use arrows. Start, End, Decision.\n\nWe must output in Traditional Chinese.\n\nWe need to propose algorithm: known solution: compute sum of array, and first F(0). Then iterate k=1..n-1, update F(k) = F(k-1) + sum - n * arr[k-1]. So compute max.\n\nSo produce steps: Input n, array, compute sum, compute currentF. Set maxF = currentF. For i from 1 to n-1: update currentF += sum - n*arr[i-1]; if currentF>maxF then maxF=currentF. End loop. Output maxF.\n\nWe also may include steps for reading input, computing.\n\nUse virtual code.\n\nLet's format.\n\nStart // Start program\n→ Step 1: 讀取整數 n // 取得陣列長度\n→ Step 2: 讀取整數陣列 nums[0…n-1] // 取得原始數字\n→ Step 3: 計算 sum = Σ nums[i] // 計算所有元素總和\n→ Step 4: 計算 currentF = Σ i * nums[i] // F(0) 的值\n→ Step 5: 設定 maxF = currentF // 初始化最大值\n→ Step 6: For i從1到n-1 // 逐步旋轉\n    → Decision: i <= n-1? // 迴圈條件\n        Yes → Step 7: currentF = currentF + sum - n * nums[i-1] // 依公式更新 F(i)\n        Yes → Decision: currentF > maxF? // 檢查是否更新最大值\n            Yes → Step 8: maxF = currentF // 更新最大值\n            No  → // 不更新\n        Yes → // 迴圈結束條件\n        No  → // 跳出迴圈\n→ Step 9: 輸出 maxF // 回傳答案\nEnd // 程式結束\n\nBut need arrows and indentation.\n\nLet's produce. Use indentation for nested steps. Format:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得陣列長度\n→ Step 2: 讀取整數陣列 nums[0…n-1] // 取得原始數字\n→ Step 3: 計算 sum = Σ nums[i] // 計算所有元素總和\n→ Step 4: 計算 currentF = Σ i * nums[i] // F(0) 的值\n→ Step 5: 設定 maxF = currentF // 初始化最大值\n→ Step 6: For i從1到n-1 // 逐步旋轉\n    → Decision: i <= n-1? // 迴圈條件\n        Yes → Step 7: currentF = currentF + sum - n * nums[i-1] // 更新 F(i)\n        Yes → Decision: currentF > maxF? // 檢查是否更新最大值\n            Yes → Step 8: maxF = currentF // 更新最大值\n            No  → // 不更新\n        Yes → // 迴圈結束條件\n        No  → // 跳出迴圈\n→ Step 9: 輸出 maxF // 回傳答案\nEnd // 程式結束\n\nBut need proper arrow: Use '→' for steps and decision arrows: 'Yes →', 'No →'.\n\nLet's format more elegantly: each line.\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得陣列長度\n→ Step 2: 讀取整數陣列 nums[0…n-1] // 取得原始數字\n→ Step 3: 計算 sum = Σ nums[i] // 計算所有元素總和\n→ Step 4: 計算 currentF = Σ i * nums[i] // F(0) 的值\n→ Step 5: 設定 maxF = currentF // 初始化最大值\n→ Step 6: For i從1到n-1 // 逐步旋轉\n    → Decision: i <= n-1? // 迴圈條件\n        Yes → Step 7: currentF = currentF + sum - n * nums[i-1] // 依公式更新 F(i)\n        Yes → Decision: currentF > maxF? // 檢查是否更新最大值\n            Yes → Step 8: maxF = currentF // 更新最大值\n            No  → // 不更新\n        Yes → // 迴圈結束條件\n        No  → // 跳出迴圈\n→ Step 9: 輸出 maxF // 回傳答案\nEnd // 程式結束\n\nWe can also show 'No →' arrow for loop end? But we don't need.\n\nBut ensure each line has step code and comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得陣列長度  \n→ Step 2: 讀取整數陣列 nums[0…n-1] // 取得原始數字  \n→ Step 3: 計算 sum = Σ nums[i] // 計算所有元素總和  \n→ Step 4: 計算 currentF = Σ i * nums[i] // F(0) 的值  \n→ Step 5: 設定 maxF = currentF // 初始化最大值  \n→ Step 6: For i從1到n-1 // 逐步旋轉  \n  → Decision: i <= n-1? // 迴圈條件  \n   Yes → Step 7: currentF = currentF + sum - n * nums[i-1] // 依公式更新 F(i)  \n   Yes → Decision: currentF > maxF? // 檢查是否更新最大值  \n    Yes → Step 8: maxF = currentF // 更新最大值  \n    No  → // 不更新  \n   Yes → // 迴圈結束條件  \n   No  → // 跳出迴圈  \n→ Step 9: 輸出 maxF // 回傳答案  \nEnd // 程式結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4l6y_o3w.py\", line 55, in <module>\n    ops = json.loads(ops_part.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 12 (char 11)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    \"\"\"\n    實作支持更新與區間求和的數組。\n    這裡採用 Binary Indexed Tree（Fenwick Tree）做為底層資料結構，時間複雜度均為 O(log n)。\n    \"\"\"\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]           # 保留原始陣列以便計算差值\n        self.tree = [0] * (self.n + 1)\n        for i, v in enumerate(nums):\n            self._add(i + 1, v)       # BIT 的索引從 1 開始\n\n    def _add(self, i, delta):\n        \"\"\"將 delta 加到 BIT 的第 i 個位置。\"\"\"\n        while i <= self.n:\n            self.tree[i] += delta\n            i += i & -i\n\n    def update(self, index, val):\n        \"\"\"更新 nums[index] 為 val。\"\"\"\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._add(index + 1, diff)\n\n    def sumRange(self, left, right):\n        \"\"\"回傳區間 [left, right] 的總和。\"\"\"\n        return self._prefix_sum(right + 1) - self._prefix_sum(left)\n\n    def _prefix_sum(self, i):\n        \"\"\"計算 BIT 前 i 個元素的累積和。\"\"\"\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，去除首尾空白\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 由於 LeetCode 的輸入格式為「operations, arguments」兩部分，\n    # 這裡先以第一個逗號做分隔，確保只分成兩段。\n    try:\n        ops_part, args_part = raw.split(',', 1)\n    except ValueError:\n        # 若輸入格式不符，直接結束\n        sys.exit()\n\n    # 解析 JSON\n    ops = json.loads(ops_part.strip())\n    args = json.loads(args_part.strip())\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])  # arg 是一個長度為 1 的列表\n            res.append(None)        # 這類呼叫回傳 null\n        elif op == \"update\":\n            obj.update(arg[0], arg[1])\n            res.append(None)\n        elif op == \"sumRange\":\n            res.append(obj.sumRange(arg[0], arg[1]))\n        else:\n            # 不支援的操作，直接放 None\n            res.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到 null 的正確表示\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a NumArray class that supports update and sumRange queries. We need to think of data structure: segment tree or BIT. We'll choose Segment Tree. Provide steps: Build tree, update, query. Provide steps for class methods.\n\nNeed to use format: \"虛擬碼步驟 [space] // 解釋\". Use arrows, Decision, etc. Each line a step. Provide sequential steps for class initialization, update, query. Probably include Start/End.\n\nWe will produce like:\n\nStart // 程式開始\n→ Step 1: 定義 NumArray 類別 // 定義主類別\n→ Step 2: 在構造函式中接收 nums // 接收初始陣列\n→ Step 3: 建立 segTree 陣列長度 4*nums.length // 準備節點儲存\n→ Step 4: 呼叫 build(1,0, n-1) // 建立段樹\n...\n\nAnd similar for update and sumRange.\n\nUse Decision: if left==right? etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 定義 NumArray 類別 // 主類別入口\n→ Step 2: 在構造函式中接收 nums // 接收初始陣列\n→ Step 3: 計算 n ← nums.length // 取得陣列長度\n→ Step 4: 建立 segTree 陣列長度 4 * n // 準備節點儲存\n→ Step 5: 呼叫 build(1, 0, n-1) // 建立段樹\n\n→ Step 6: 定義 build(node, l, r) // 構建段樹遞迴函式\n    → Decision: 如果 l == r? // 判斷是否為葉節點\n        Yes → segTree[node] ← nums[l] // 把陣列值存進葉節點\n        No  → Step 7: 計算 mid ← (l + r) / 2 // 找中點\n            → Step 8: 呼叫 build(node*2, l, mid) // 建立左子樹\n            → Step 9: 呼叫 build(node*2+1, mid+1, r) // 建立右子樹\n            → Step 10: segTree[node] ← segTree[node*2] + segTree[node*2+1] // 合併子節點值\n\n→ Step 11: 定義 update(index, val) // 更新元素\n    → Step 12: 呼叫 updateRec(1, 0, n-1, index, val) // 遞迴更新\n\n→ Step 13: 定義 updateRec(node, l, r, idx, v) // 遞迴更新函式\n    → Decision: 如果 l == r? // 到達對應葉節點\n        Yes → segTree[node] ← v // 更新葉節點值\n        No  → Step 14: 計算 mid ← (l + r) / 2\n            → Decision: 如果 idx <= mid? // 判斷要更新哪一側\n                Yes → 呼叫 updateRec(node*2, l, mid, idx, v) // 更新左子樹\n                No  → 呼叫 updateRec(node*2+1, mid+1, r, idx, v) // 更新右子樹\n            → Step 15: segTree[node] ← segTree[node*2] + segTree[node*2+1] // 重新合併子節點值\n\n→ Step 16: 定義 sumRange(left, right) // 查詢區間和\n    → Step 17: 返回 query(1, 0, n-1, left, right) // 遞迴查詢\n\n→ Step 18: 定義 query(node, l, r, L, R) // 遞迴查詢函式\n    → Decision: 如果 L <= l 且 r <= R? // 節點完全覆蓋查詢區間\n        Yes → 返回 segTree[node] // 直接回傳節點值\n        No  → Step 19: 計算 mid ← (l + r) / 2 // 找中點\n            → Step 20: 若 R <= mid? // 整個查詢在左半\n                Yes → 返回 query(node*2, l, mid, L, R) // 只查左子樹\n                No  → 若 L > mid? // 整個查詢在右半\n                    Yes → 返回 query(node*2+1, mid+1, r, L, R) // 只查右子樹\n                    No  → // 查詢跨兩側\n                        → Step 21: leftSum ← query(node*2, l, mid, L, mid) // 左半區間和\n                        → Step 22: rightSum ← query(node*2+1, mid+1, r, mid+1, R) // 右半區間和\n                        → Step 23: 返回 leftSum + rightSum // 合併兩邊和\n\nEnd // 程式執行結束"
    },
    {
      "title": "Super Pow",
      "source_file": "Leetcode/leetcode372.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6_5bb7v_.py\", line 25, in <module>\n    a, b = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6_5bb7v_.py\", line 19, in parse_input\n    b = ast.literal_eval(b_part.split('=')[1].strip())\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpilzvyd02.py\", line 25, in <module>\n    a, b = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpilzvyd02.py\", line 19, in parse_input\n    b = ast.literal_eval(b_part.split('=')[1].strip())\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nMOD = 1337\n\ndef super_pow(a: int, b: list[int]) -> int:\n    \"\"\"計算 a^b mod 1337，其中 b 是以數字陣列表示的整數.\"\"\"\n    result = 1\n    for digit in b:\n        result = pow(result, 10, MOD) * pow(a, digit, MOD) % MOD\n    return result\n\ndef parse_input(text: str):\n    \"\"\"從 'a = 2, b = [3]' 這類文字輸入中提取 a 與 b.\"\"\"\n    parts = text.split(',')\n    a_part = parts[0].strip()           # 'a = 2'\n    b_part = parts[1].strip()           # 'b = [3]'\n    a = int(a_part.split('=')[1].strip())\n    b = ast.literal_eval(b_part.split('=')[1].strip())\n    return a, b\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if raw:\n        a, b = parse_input(raw)\n        print(super_pow(a, b))",
      "virtual_code": "Thinking...\nWe need to produce pseudo code for calculating a^b mod 1337, with a positive integer a and b huge integer represented as array. We should produce step-by-step algorithm, likely using modular exponentiation with exponent as array. Approach: compute exponent b as base 10 digits array, compute a^b mod 1337 via repeated exponentiation by squaring? But b is huge, cannot convert to integer. Standard method: use algorithm that processes digits: For each digit d in b array (most significant first), we maintain result=1. For each digit, compute result = (result^10 mod M) * (a^d mod M) mod M. Because exponentiation: a^b = a^{(prev*10 + d)} = (a^{prev})^10 * a^d. So maintain cur result of a^{prev}. Compute pow_mod(a, d) precomputed maybe. For each step, we compute result = pow_mod(result, 10) * pow_mod(a, d) mod M.\n\nAlso we need pow_mod for exponent 10 and d. For exponent 10, we can compute via pow_mod function.\n\nNeed to process array digits, maybe array of ints representing decimal digits. Provide pseudo code.\n\nLet's write pseudo code steps.\n\nWe should use Start, End, Decision, and arrows. Provide each line with explanation.\n\nWe need to include steps: read a, read array bDigits.\n\nCompute M=1337.\n\nPrecompute a_mod = a mod M.\n\nDefine function pow_mod(base, exp): // fast exponentiation modulo M. but we can inline.\n\nPseudo code:\n\nStart\n→ Step 1: Input a, input bDigits // receive a and array of digits\n→ Step 2: M ← 1337\n→ Step 3: a_mod ← a mod M\n→ Step 4: result ← 1\n→ Step 5: For each digit d in bDigits (from left to right) // process exponent digits\n    → Step 5.1: temp ← pow_mod(result, 10, M) // raise current result to power 10 modulo M\n    → Step 5.2: pow_d ← pow_mod(a_mod, d, M) // compute a_mod^d modulo M\n    → Step 5.3: result ← (temp * pow_d) mod M\n→ Step 6: Output result // final answer\nEnd\n\nNeed to define pow_mod function using loop: while exp>0: if exp%2==1 result= (result*base)%M; base=(base*base)%M; exp//=2.\n\nAdd pseudo code for pow_mod.\n\nMaybe use separate function: define function pow_mod(base, exp):\n    res ← 1\n    While exp > 0\n        If exp % 2 == 1: res ← (res * base) mod M\n        base ← (base * base) mod M\n        exp ← exp // 2\n    Return res\n\nWe need to show each line with explanation.\n\nAlso need to use arrow notation with decisions? We can use Decision for while loop maybe.\n\nLet's produce lines.\n\nWe need to maintain structure.\n\nAlso note that pow_mod function will be used twice per digit: for exponent 10 and exponent d.\n\nWe can also precompute a_pow[0..9] maybe but not necessary.\n\nBut produce straightforward algorithm.\n\nLet's produce each line as \"Start //\", then \"→ Step 1: ...\" etc. Use \"Decision:\" for while loops.\n\nWe need to include decision lines.\n\nE.g.:\n\nDecision: exp > 0? // while exp > 0\n   Yes → ... // body\n   No  → ... // exit loop\n\nBut typical pseudo code may not need explicit loops, but we can include.\n\nBut output format requires that each line contain \"虛擬碼步驟\" and explanation. Use arrow.\n\nLet's produce.\n\nWe also need to include step for function definition maybe at top.\n\nWe can start with Start, then define function.\n\nBut maybe we can define function separately before main. But pseudo code might be in same block.\n\nWe can use \"Function pow_mod(base, exp):\" then lines inside.\n\nLet's create:\n\nStart // 程式開始\n→ Function pow_mod(base, exp): // 定義快速冪模函式\n    → Step 1: res ← 1 // 初始化結果\n    → Decision: exp > 0? // 只要指數大於 0\n        Yes → Step 2: If exp mod 2 == 1 Then res ← (res * base) mod M // 指數奇數時更新結果\n        Yes → Step 3: base ← (base * base) mod M // 平方基底\n        Yes → Step 4: exp ← exp // 2 // 指數除以 2\n        No  → End // 指數為 0 時結束\n    → Return res // 回傳計算結果\n\nThen main:\n\n→ Step 1: Input a // 取得基底\n→ Step 2: Input bDigits // 取得指數的十進位數字陣列\n→ Step 3: M ← 1337 // 取模數\n→ Step 4: a_mod ← a mod M // 先把基底模 M\n→ Step 5: result ← 1 // 初始化結果\n→ Step 6: For each digit d in bDigits (left to right) // 逐位處理指數\n    → Decision: no? Actually loop\nBut we can write:\n\n→ Decision: 有更多數字? // 逐位迴圈\n    Yes → Step 6.1: temp ← pow_mod(result, 10, M) // 將已計算的指數提升 10 次方\n    Yes → Step 6.2: pow_d ← pow_mod(a_mod, d, M) // 計算 a_mod 的 d 次方\n    Yes → Step 6.3: result ← (temp * pow_d) mod M // 更新結果\n    No  → End // 所有位數處理完畢\n\n→ Step 7: Output result // 顯示最終答案\nEnd // 程式結束\n\nBut we need to include explanation after each line.\n\nMake sure to follow arrow notation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function pow_mod(base, exp): // 定義快速冪模函式  \n → Step 1: res ← 1 // 初始化結果為 1  \n → Decision: exp > 0? // 若指數還未歸零  \n  Yes → Step 2: If exp mod 2 == 1 Then res ← (res * base) mod M // 指數奇數時更新結果  \n  Yes → Step 3: base ← (base * base) mod M // 基底平方  \n  Yes → Step 4: exp ← exp // 2 // 指數除以 2  \n  No  → End // 指數為 0 時結束迴圈  \n → Return res // 回傳計算結果  \n\n→ Step 1: Input a // 讀取正整數 a  \n→ Step 2: Input bDigits // 讀取表示 b 的十進位數字陣列  \n→ Step 3: M ← 1337 // 取模數  \n→ Step 4: a_mod ← a mod M // 把基底先做模運算  \n→ Step 5: result ← 1 // 初始化累積結果  \n→ Step 6: For each digit d in bDigits (from most‑significant to least) // 逐位處理指數  \n  → Step 6.1: temp ← pow_mod(result, 10, M) // 把已計算的 a^{prev} 提升到 10 次方  \n  → Step 6.2: pow_d ← pow_mod(a_mod, d, M) // 計算 a_mod 的 d 次方  \n  → Step 6.3: result ← (temp * pow_d) mod M // 更新累積結果為 a^{prev*10+d}  \n→ Step 7: Output result // 輸出最終答案 a^b mod 1337  \nEnd // 程式結束執行"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        n = len(nums)\n        for i in range(n - 1):\n            if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]):\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the list part from the input string\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group()\n        nums = ast.literal_eval(nums_str)\n    else:\n        nums = []\n\n    sol = Solution()\n    sol.wiggleSort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that reorder array to wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3] etc. The standard solution is to sort or to iterate and swap when condition fails. We should produce a virtual code outline line by line, using Start, End, Decision, arrows.\n\nWe need each line: virtual step + \" // explanation\".\n\nLet's produce steps:\n\nStart // start program\n→ Step 1: Let n = length of nums // get array length\n→ Step 2: For i from 0 to n-2 do // iterate through indices\n    → Decision: If i is even and nums[i] > nums[i+1]? // check condition for even index\n        Yes → Step 3: Swap nums[i] and nums[i+1] // swap to make nums[i] < nums[i+1]\n        No  → Decision: If i is odd and nums[i] < nums[i+1]? // check condition for odd index\n            Yes → Step 4: No action // condition already satisfied\n            No  → Step 5: Swap nums[i] and nums[i+1] // swap to make nums[i] > nums[i+1]\nEnd // finished reordering\n\nBut we need each line separate. Use arrow formatting. We can use indentation.\n\nAlso each line: \"虛擬碼步驟 // 解釋\"\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: for i from 0 to n-2 do // 逐一檢查相鄰元素\n    → Decision: i even and nums[i] > nums[i+1]? // 需要調整的情況\n        Yes → Step 3: swap(nums[i], nums[i+1]) // 交換以使 nums[i] < nums[i+1]\n        No  → Decision: i odd and nums[i] < nums[i+1]? // 需要調整的情況\n            Yes → Step 4: // 無需調整，條件已滿足\n            No  → Step 5: swap(nums[i], nums[i+1]) // 交換以使 nums[i] > nums[i+1]\nEnd // 程式執行結束\n\nNeed to ensure each line separate. Also we need to use arrow for nested steps.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: for i from 0 to n-2 do // 逐一檢查相鄰元素  \n  → Decision: i even and nums[i] > nums[i+1]? // 需要調整的情況  \n    Yes → Step 3: swap(nums[i], nums[i+1]) // 交換以使 nums[i] < nums[i+1]  \n    No  → Decision: i odd and nums[i] < nums[i+1]? // 需要調整的情況  \n      Yes → Step 4: // 無需調整，條件已滿足  \n      No  → Step 5: swap(nums[i], nums[i+1]) // 交換以使 nums[i] > nums[i+1]  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7ntrw8o0.py\", line 76, in <module>\n    main()\n  File \"/tmp/tmp7ntrw8o0.py\", line 53, in main\n    args = ast.literal_eval(lists[1])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        # 將新元素加入主隊列\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        if not self.q1:\n            return None\n        # 將除最後一個元素外的所有元素移到輔助隊列\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 最後一個元素即為棧頂\n        res = self.q1.popleft()\n        # 交換兩個隊列，讓 q1 成為新的主隊列\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -> int:\n        if not self.q1:\n            return None\n        # 移動除最後一個元素外的所有元素\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 取得棧頂元素\n        res = self.q1.popleft()\n        # 把棧頂元素保留，放回輔助隊列\n        self.q2.append(res)\n        # 交換兩個隊列\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -> bool:\n        return not self.q1\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 取得兩個列表\n    import re\n    lists = re.findall(r'\\[.*?\\]', data, re.S)\n    if len(lists) < 2:\n        return\n    ops = ast.literal_eval(lists[0])\n    args = ast.literal_eval(lists[1])\n\n    stack = MyStack()\n    results = []\n    for op, a in zip(ops, args):\n        if op == \"push\":\n            stack.push(a[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n        else:\n            # 未定義的操作\n            results.append(None)\n\n    # 將結果轉成 JSON 格式輸出\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step. For each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows.\n\nWe need to design a stack using two queues. Provide algorithm. Use two queues q1, q2.\n\nOperations:\npush(x): enqueue to q1.\n\npop(): move all elements from q1 to q2 except last, then dequeue last from q1 (or from q2). Let's design: pop: while size(q1) > 1: dequeue from q1 and enqueue to q2. Then the last element is front of q1, dequeue it and store result. Swap q1 and q2. Return result.\n\ntop(): similar but after retrieving last, push it to q2 as well, then swap.\n\nempty(): check size of q1.\n\nNeed to output virtual code.\n\nWe'll produce pseudo-steps. Ensure each line includes comment. Use arrow. Example:\n\nStart // 程式開始執行\n→ Step 1: 定義兩個空隊列 Q1, Q2 // 建立兩個隊列\n→ Step 2: push(x) → Enqueue x 到 Q1 // 將新元素加入 Q1\n→ Step 3: pop() → 如果 Q1 為空? // 檢查是否有元素\n    Yes → Step 4: Return null/錯誤 // 空棧\n    No  → Decision: Q1 大於 1? // 判斷是否多於一個元素\n        Yes → Step 5: while size(Q1) > 1: Dequeue from Q1, Enqueue to Q2 // 移動元素\n        No  → Step 6: Dequeue from Q1,  // 取得最後元素\n    Step 7: 交換 Q1, Q2 // 重置主隊列\n    Step 8: Return 取出的元素 // 回傳\n\nBut need to be consistent with pseudo-code style.\n\nLet's outline main algorithm steps.\n\nWe'll produce a sequence of lines.\n\nWe can treat push, pop, top, empty as methods defined.\n\nBetter: Represent as separate blocks.\n\nBut we should produce sequential lines; each step refers to operations inside methods.\n\nProbably we can produce a pseudo algorithm for class.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 初始化空隊列 Q1, Q2 // 用兩個隊列存儲資料\n\nDefine push(x):\n→ Step 2: Enqueue x 到 Q1 // 新元素加入 Q1\n\nDefine pop():\n→ Step 3: Decision: 如果 Q1 為空? // 檢查棧是否為空\n    Yes → Step 4: Return null // 空棧無法彈出\n    No  → Step 5: while size(Q1) > 1: // 移動除最後一個元素外的所有元素\n            → Step 6: Dequeue front from Q1, Enqueue 到 Q2 // 移動至 Q2\n        Step 7: Dequeue front from Q1, store為 result // 最後元素即為棧頂\n        Step 8: Swap Q1, Q2 // Q1 現成下一輪操作的主隊列\n        Step 9: Return result // 返回彈出的元素\n\nDefine top():\n→ Step 10: Decision: 如果 Q1 為空? // 檢查棧是否為空\n     Yes → Step 11: Return null // 空棧無棧頂\n     No  → Step 12: while size(Q1) > 1:\n            → Step 13: Dequeue front from Q1, Enqueue 到 Q2 // 移動\n        Step 14: Dequeue front from Q1, store為 topValue // 最後元素\n        Step 15: Enqueue topValue 到 Q2 // 把棧頂元素保留\n        Step 16: Swap Q1, Q2 // 重置\n        Step 17: Return topValue // 回傳棧頂\n\nDefine empty():\n→ Step 18: Decision: Q1 為空? // 判斷是否有元素\n    Yes → Step 19: Return True\n    No  → Step 20: Return False\n\nEnd // 程式結束\n\nBut each line should include comment after //. Use \"虛擬碼步驟\". For example \"→ Step 1: 初始化空隊列 Q1, Q2 // 用兩個隊列存儲資料\". Good.\n\nWe need arrow indentation for decisions.\n\nWe must adhere to example: \"→ Decision: 如果數字大於 0? // 檢查數值是否為正\". Use same format.\n\nWe may need to indicate \"Yes →\" and \"No →\" lines.\n\nLet's produce final answer accordingly. Ensure each line ends with comment. Use \"Start\", \"End\". Use \"Decision:\" for if.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化兩個空隊列 Q1, Q2 // 用於模擬堆疊\n\n// push 操作\n→ Step 2: push(x) → Enqueue x 到 Q1 // 把新元素放入主隊列\n\n// pop 操作\n→ Step 3: pop() → Decision: 如果 Q1 為空? // 檢查堆疊是否為空\n    Yes → Step 4: Return null // 空堆疊無法彈出\n    No  → Step 5: while size(Q1) > 1: // 移動除最後一個元素外的所有元素\n            → Step 6: Dequeue front from Q1, Enqueue 到 Q2 // 將元素搬移到輔助隊列\n        Step 7: Dequeue front from Q1, store 為 result // 最後元素即為堆疊頂端\n        Step 8: Swap Q1, Q2 // 重新把輔助隊列設為主隊列\n        Step 9: Return result // 回傳彈出的元素\n\n// top 操作\n→ Step 10: top() → Decision: 如果 Q1 為空? // 檢查堆疊是否為空\n     Yes → Step 11: Return null // 空堆疊無頂端\n     No  → Step 12: while size(Q1) > 1: // 移動除最後一個元素外的所有元素\n            → Step 13: Dequeue front from Q1, Enqueue 到 Q2 // 搬移到輔助隊列\n        Step 14: Dequeue front from Q1, store 為 topValue // 抓取頂端元素\n        Step 15: Enqueue topValue 到 Q2 // 把頂端元素保留\n        Step 16: Swap Q1, Q2 // 重置主隊列\n        Step 17: Return topValue // 回傳堆疊頂端\n\n// empty 操作\n→ Step 18: empty() → Decision: Q1 為空? // 判斷堆疊是否為空\n    Yes → Step 19: Return True // 堆疊空\n    No  → Step 20: Return False // 堆疊非空\n\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "expected_output": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpte1uk2kp.py\", line 59, in <module>\n    data = ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\n             ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpur7ni5ex.py\", line 59, in <module>\n    data = ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\n             ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass DSU:\n    def __init__(self):\n        self.parent = {}\n\n    def find(self, x):\n        # 初始化父指標\n        if x not in self.parent:\n            self.parent[x] = x\n        # 路徑壓縮\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        # 將兩個節點合併\n        self.parent[self.find(x)] = self.find(y)\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        dsu = DSU()\n        email_to_name = {}\n\n        # 先把所有 email 依據共同出現的帳號合併\n        for acc in accounts:\n            name = acc[0]\n            emails = acc[1:]\n            if not emails:\n                continue\n            first = emails[0]\n            for e in emails:\n                dsu.union(first, e)\n                email_to_name[e] = name\n\n        # 根據並查集的根收集所有 email\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = dsu.find(email)\n            merged[root].append(email)\n\n        # 產生最終結果，email 先排序再加上姓名\n        result = []\n        for root, ems in merged.items():\n            name = email_to_name[root]\n            result.append([name] + sorted(ems))\n\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入，並解析成 Python 物件\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    # 可能的輸入形態為像 'accounts = [[\"John\", ...]]'\n    # 使用 ast.literal_eval 以避免 exec 的安全風險\n    data = ast.literal_eval(raw_input)\n    # 若輸入中有變數名，取得其值\n    if isinstance(data, tuple) and len(data) == 2 and isinstance(data[0], str):\n        # 假設格式為 ('accounts', [['John', ...], ...])\n        accounts = data[1]\n    else:\n        accounts = data\n\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for merging accounts based on common emails, DSU. Output each step with comment. Use arrow. Provide step-by-step. No actual code.\n\nWe'll produce:\n\nStart\n→ Initialize map emailToIndex\n→ Initialize DSU arrays parent, rank\n→ For each account i\n   → For each email e in account i starting from 1\n        // map email to index\n        If email not in map, set map[e] = i\n        Else union(i, map[e]) // union by email\n→ After building DSU, build map root -> name, emails\n→ For each email, find root, add email to root's email set\n→ For each root, sort emails, prepend name, output account\nEnd\n\nWe need each line as \"虛擬碼步驟 // 解釋\". Use arrow. Use Decision? not necessary except maybe when email not in map.\n\nWe'll use arrows with indentation.\n\nOk produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立 emailToIndex 映射與 DSU 結構 // 建立 email 到帳號索引的對應表以及並查集\n→ Step 2: For each account i in accounts // 逐一處理每一筆帳號資料\n    → Step 2.1: name ← accounts[i][0] // 取得帳號名稱\n    → Step 2.2: For each email e in accounts[i][1:] // 逐一處理帳號中的每個 Email\n        → Decision: e 是否已存在於 emailToIndex? // 判斷 Email 是否已被映射\n            Yes → Step 2.2.1: union(i, emailToIndex[e]) // 已存在則合併兩個帳號\n            No  → Step 2.2.2: emailToIndex[e] ← i // 不存在則建立映射\n→ Step 3: 建立 rootToEmails 映射 // 根據並查集根節點收集所有 Email\n→ Step 4: For each email e in emailToIndex\n    → root ← find(emailToIndex[e]) // 找到 Email 所屬帳號的根節點\n    → Step 4.1: If root 不是在 rootToEmails 中，建立空集合 // 初始化集合\n    → Step 4.2: rootToEmails[root].add(e) // 將 Email 加入對應根節點的集合\n→ Step 5: 組合最終結果\n    → For each root in rootToEmails\n        → emails ← rootToEmails[root] // 取得此帳號所有 Email\n        → emailsSorted ← sort(emails) // 將 Email 排序\n        → name ← accounts[root][0] // 取得此帳號的名稱\n        → resultAccount ← [name] + emailsSorted // 組成帳號資料\n        → Output resultAccount // 將結果加入輸出清單\nEnd // 程式執行結束\n```"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0rsclw05.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp0rsclw05.py\", line 32, in main\n    arguments = ast.literal_eval(second)\n                ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[], [10, 20], [15, 25], [20, 30]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCalendar:\n    \"\"\"日曆類別，儲存已預約的區間，避免重疊。\"\"\"\n    def __init__(self):\n        self.bookings = []  # 以 (start, end) 的元組儲存\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"嘗試新增事件，若有重疊則拒絕。\"\"\"\n        for s, e in self.bookings:\n            # 若 start < e 且 end > s，表示兩區間有交集\n            if start < e and end > s:\n                return False\n        self.bookings.append((start, end))\n        return True\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 讀入兩個列表：指令與對應參數\n    parts = data.split('],', 1)\n    if len(parts) != 2:\n        return\n    first = parts[0] + ']'\n    second = '[' + parts[1]\n    commands = ast.literal_eval(first)\n    arguments = ast.literal_eval(second)\n\n    outputs = []\n    calendar = None\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MyCalendar\":\n            calendar = MyCalendar()\n            outputs.append(None)          # 代表 null\n        elif cmd == \"book\":\n            result = calendar.book(arg[0], arg[1])\n            outputs.append(result)        # 真/假\n\n    print(json.dumps(outputs))  # 以 JSON 格式輸出，None -> null，True/False -> true/false\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the MyCalendar class with book method, handling double booking using maybe interval tree or list. Let's do simple list sorted, check overlapping. Virtual code: Start, initialization, book method. Use Decision, loops.\n\nLet's write steps: Start, Step 1: Initialize event list. Step 2: book method: iterate events, check overlap. If overlap, return false. Else add to list sorted. Use Decision for overlap check: if start < existing_end and end > existing_start. Provide explanation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCalendar 類別 // 建立日曆物件\n    → Step 2: 初始化 events 為空列表 // 用於儲存已預約事件 (start, end)\n→ Step 3: 定義 book(start, end) 方法 // 嘗試新增事件\n    → Decision: events 是否為空？ // 若無任何事件，直接加入\n        Yes → Step 4: events 加入 (start, end) // 新增事件\n            → Step 5: 返回 true // 成功預約\n        No  → Step 6: 進入迴圈 遍歷每個 (s, e) in events // 檢查重疊\n            → Decision: start < e 且 end > s？ // 判斷是否有交集\n                Yes → Step 7: 返回 false // 發現重疊，拒絕預約\n                No  → Step 8: 繼續下一個事件 // 無重疊，檢查下去\n        → Decision: 已檢查完所有事件且無重疊？ // 若沒有任何重疊\n            Yes → Step 9: events 加入 (start, end) // 添加新事件\n                → Step 10: 返回 true // 成功預約\n→ End // 程式執行結束"
    },
    {
      "title": "First Bad Version",
      "source_file": "Leetcode/leetcode278.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "actual_output_or_error": "File \"/tmp/tmp2diiu72y.py\", line 31\n    global bad_version\n    ^^^^^^^^^^^^^^^^^^\nSyntaxError: name 'bad_version' is assigned to before global declaration"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "actual_output_or_error": "File \"/tmp/tmpk5nearqf.py\", line 31\n    global bad_version\n    ^^^^^^^^^^^^^^^^^^\nSyntaxError: name 'bad_version' is assigned to before global declaration"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 模擬 API：只有從 bad_version 開始，後續版本均為壞\nbad_version = None\ndef isBadVersion(version: int) -> bool:\n    return version >= bad_version\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整行輸入，例如: \"n = 5, bad = 4\"\n    data = sys.stdin.read().strip()\n    # 取出 n 與 bad 的數值\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        n, bad = nums[0], nums[1]\n    else:\n        raise ValueError(\"Input must contain n and bad values.\")\n    \n    # 設定全域變數以供 isBadVersion 使用\n    global bad_version\n    bad_version = bad\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    first_bad = solution.firstBadVersion(n)\n    print(first_bad)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step with explanation. Problem: find first bad version via binary search to minimize calls. Use low, high. While low < high: mid = low + (high - low)/2. If isBadVersion(mid) -> high = mid else low = mid +1. Return low. Need to use virtual code arrows, Start, End, Decision. Provide each line as \"虛擬碼步驟 // 解釋\". Ensure no actual code but pseudocode. Use Chinese explanation. Provide each line with step name maybe Step 1, Step 2 etc. Use arrows and decisions. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 low = 1, high = n // 設定搜尋區間為所有版本  \n→ Decision: low 是否小於 high? // 判斷是否還有未搜尋的版本  \n Yes → Step 2: 計算 mid = low + (high - low) / 2 // 找到中間版本，避免溢位  \n  → Decision: isBadVersion(mid) 是否為真? // 檢查中間版本是否為壞版本  \n   Yes → Step 3: high = mid // 若 mid 為壞版本，則第一壞版本必定在左半區間  \n   No  → Step 4: low = mid + 1 // 若 mid 為好版本，則第一壞版本必定在右半區間  \n  → 回到 Decision: low 是否小於 high? // 重新判斷是否還有區間可搜尋  \n No  → Step 5: 返回 low // low 即為第一個壞版本  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,1,4,4,4,6,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 1, 4, 4, 4, 6, 0]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        self.mapping = {}\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit(0)\n    commands = ast.literal_eval(data[0])\n    arguments = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)\n        elif cmd == \"pick\":\n            results.append(obj.pick())\n    # Use json.dumps to get the correct 'null' representation for None\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code with explanation per line. The algorithm: typical mapping method. Steps: compute M = n - blacklist.length. Map blacklisted numbers >= M to allowed numbers. In constructor: create set for blacklist. Build mapping dict for each b in blacklist where b < M. For each allowed number i from M to n-1, if not in blacklist, map b to i. Then pick: generate random k in [0,M-1]; if k in map, return map[k]; else return k.\n\nWe need to produce virtual code with arrows. Each line: \"Start\", \"→ Step 1: ...\" etc.\n\nWe need to show initialization and pick method. Use decisions? Might use loops.\n\nWe must ensure each line has the virtual code plus comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 變數 M ← n - blacklist.length // 只剩下的可用數字總數\n→ Step 2: 建立空集合 B // 用於快速判斷黑名單\n    For 每個 b in blacklist:\n        → Step 2.1: B.add(b) // 將黑名單項目加入集合\n→ Step 3: 建立空映射 map // 將小於 M 的黑名單映射到大於等於 M 的合法數字\n    For 每個 b in blacklist:\n        → Decision: 如果 b < M? // 只需要處理小於 M 的黑名單項目\n            Yes → Step 3.1: 尋找合法數字 i 從 M 開始遞增\n                While i in B: // 跳過仍在黑名單的數字\n                    → Step 3.1.1: i ← i + 1\n                → Step 3.1.2: map.put(b, i) // 將黑名單數字映射到合法數字\n            No  → Skip // 大於等於 M 的黑名單不需要映射\n→ End // 初始化結束\n\nStart // pick() 方法開始\n→ Step 4: 產生隨機整數 k ← random(0, M-1) // 取範圍內隨機值\n→ Decision: 如果 k 在 map? // 判斷是否為被映射的黑名單數字\n    Yes → Step 5: 返回 map[k] // 回傳映射後的合法數字\n    No  → Step 5: 返回 k // 直接回傳隨機數\nEnd // pick() 方法結束\n\nStart // 程式結束執行\nEnd // 程式執行結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg_je39rk.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpg_je39rk.py\", line 44, in main\n    res = obj.sum(prefix)\n          ^^^^^^^^^^^^^^^\n  File \"/tmp/tmpg_je39rk.py\", line 16, in sum\n    return sum(v for k, v in self.dic.items() if k.startswith(prefix))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpg_je39rk.py\", line 16, in <genexpr>\n    return sum(v for k, v in self.dic.items() if k.startswith(prefix))\n                                                 ^^^^^^^^^^^^^^^^^^^^\nTypeError: startswith first arg must be str or a tuple of str, not list"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MapSum:\n    def __init__(self):\n        # 用字典儲存 key -> value 的對應\n        self.dic = {}\n\n    def insert(self, key, val):\n        # 直接覆蓋舊值\n        self.dic[key] = val\n\n    def sum(self, prefix):\n        # 回傳所有以 prefix 為前綴的 key 的 value 的總和\n        return sum(v for k, v in self.dic.items() if k.startswith(prefix))\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包裝成一個 JSON 陣列，方便解析\n    # 例如: '[\"MapSum\",\"insert\"],[[],[\"apple\",3]]' 變成\n    # [['MapSum','insert'],[[],['apple',3]]]\n    try:\n        ops, args = json.loads('[' + data + ']')\n    except Exception as e:\n        # 如果 JSON 解析失敗，嘗試使用 ast.literal_eval\n        ops, args = ast.literal_eval('(' + data + ')')\n\n    obj = None\n    result = []\n\n    for i, op in enumerate(ops):\n        if op == \"MapSum\":\n            obj = MapSum()\n            result.append(None)\n        elif op == \"insert\":\n            key, val = args[i]\n            obj.insert(key, val)\n            result.append(None)\n        elif op == \"sum\":\n            prefix = args[i]\n            res = obj.sum(prefix)\n            result.append(res)\n        else:\n            # 若出現未知指令，視為 None\n            result.append(None)\n\n    # 將 None 轉成 JSON 的 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with comments. Use arrows and decisions. The problem: design a MapSum class. The virtual code: Steps to initialize map, insert, sum. Use data structure: maybe trie with sums. Or hashmap to track key->value, and maintain prefix sums. For virtual code we can show high-level algorithm.\n\nWe need to produce virtual code, not actual code. For each line, we provide explanation.\n\nWe should structure: Start → Step: Initialize mapSum class, create data structures (hashmap and trie). Then for insert: update hashmap, update trie prefix sums. For sum: traverse trie.\n\nLet's output:\n\nStart // 程式開始執行\n\n→ Step 1: Create MapSum object // 初始化 MapSum\n\n→ Decision: 是否已初始化? // 確保一次初始化\n\nBut we might just show steps for each method.\n\nBetter: Start; → Step 1: 定義 MapSum 類別 // 包含 trie 根節點、key→value 映射\n\n→ Step 2: 在 MapSum 建構子中建立空 trie 根節點 // 根節點不存儲字符\n\n→ Step 3: 在 MapSum 建構子中建立空 hashmap // 用於儲存 key 的最新值\n\nNow for insert:\n\n→ Step 4: Method insert(key, val) // 插入或更新 key 值\n\n→ Decision: key 是否存在於 hashmap? // 判斷是否為更新\n\n    Yes → Step 5: oldVal ← hashmap[key] // 取得舊值\n    No  → Step 5: oldVal ← 0 // 舊值為 0\n\n→ Step 6: delta ← val - oldVal // 計算差值\n\n→ Step 7: hashmap[key] ← val // 更新 key 的值\n\n→ Step 8: node ← trieRoot // 從根節點開始\n\n→ Step 9: For each character c in key // 遍歷 key 的每個字符\n\n        → Step 10: If node.children[c] does not exist, create new child node // 建立新節點\n        → Step 11: node ← node.children[c] // 進入子節點\n        → Step 12: node.sum ← node.sum + delta // 更新節點的累加值\n\n→ End // insert 完成\n\nFor sum:\n\n→ Step 13: Method sum(prefix) // 回傳前綴值總和\n\n→ Step 14: node ← trieRoot // 從根節點開始\n\n→ Decision: prefix 是否為空? // 空前綴表示總和\n\n    Yes → Step 15: return 0 // 若空前綴，返回 0（或可選擇根節點 sum）\n\n    No  →\n\n→ Step 15: For each character c in prefix\n\n        → Step 16: If node.children[c] does not exist, return 0 // 前綴不存在\n        → Step 17: node ← node.children[c] // 進入子節點\n\n→ Step 18: return node.sum // 返回累加值\n\n→ End // sum 完成\n\nWe need to include Start and End.\n\nMake sure to follow format: each line \"虛擬碼步驟 // 解釋\".\n\nUse arrows: → Step, Decision:, Yes →, No →. Start and End.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MapSum 類別，內部包含 trie 根節點與 key→value hashmap // 準備資料結構  \n→ Step 2: 在 MapSum 建構子中建立空 trie 根節點 // 根節點不存儲字符，僅作為起點  \n→ Step 3: 在 MapSum 建構子中建立空 hashmap // 用於儲存每個 key 的最新值  \n\n→ Step 4: 方法 insert(key, val) // 插入或更新 key 的值  \n    → Decision: key 是否已存在於 hashmap? // 判斷是否為更新  \n        Yes → Step 5: oldVal ← hashmap[key] // 取得舊值  \n        No  → Step 5: oldVal ← 0 // 舊值為 0，表示全新插入  \n→ Step 6: delta ← val - oldVal // 計算值變化量  \n→ Step 7: hashmap[key] ← val // 更新 key 的值  \n→ Step 8: node ← trieRoot // 從 trie 根節點開始  \n→ Step 9: For 每個字符 c 在 key 中  \n        → Step 10: 如果 node.children[c] 為空，則建立新子節點 // 先確保節點存在  \n        → Step 11: node ← node.children[c] // 進入子節點  \n        → Step 12: node.sum ← node.sum + delta // 更新從此節點起始的前綴累加值  \n\n→ End // insert 完成  \n\n→ Step 13: 方法 sum(prefix) // 回傳以 prefix 為前綴的所有 key 值總和  \n    → Step 14: node ← trieRoot // 從根節點開始  \n    → Decision: prefix 是否為空? // 空前綴代表全體累加  \n        Yes → Step 15: return 0 // 此處可選擇返回 0 或 trieRoot.sum  \n        No → Step 15: For 每個字符 c 在 prefix 中  \n            → Step 16: 如果 node.children[c] 為空，返回 0 // 前綴不存在  \n            → Step 17: node ← node.children[c] // 進入子節點  \n→ Step 18: return node.sum // 回傳從該節點起始的累加值  \n\n→ End // sum 完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.14315482715683764,0.785906257221433],[0.3838014928088993,-0.7928955703264581],[-0.36295399418301794,-0.4903992789111321]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.14315482715683764, 0.785906257221433], [0.3838014928088993, -0.7928955703264581], [-0.36295399418301794, -0.4903992789111321]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    \"\"\"生成均勻分布於圓內的隨機點。\"\"\"\n\n    def __init__(self, radius, x_center, y_center):\n        # 儲存半徑與圓心座標\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機生成半徑與角度，保證均勻分布\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉回直角座標系\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit(0)\n\n    # 第一行: 操作列表\n    ops = json.loads(data[0])\n    # 第二行: 對應的參數列表\n    args_list = json.loads(data[1])\n\n    results = []\n    instance = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            # 建構子呼叫\n            instance = Solution(*args)\n            results.append(None)           # LeetCode 期望 null\n        elif op == \"randPoint\":\n            # 呼叫方法並紀錄回傳值\n            if instance is not None:\n                results.append(instance.randPoint())\n            else:\n                results.append(None)\n        else:\n            # 若有其他未知操作，直接回傳 None\n            results.append(None)\n\n    # 輸出符合 LeetCode JSON 格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations in Traditional Chinese, line by line. The task: implement Solution class with constructor and randPoint method generating uniform random point inside circle. We'll produce steps like:\n\nStart\n→ Define class Solution // class definition\n→ Step: constructor with radius, x_center, y_center\n→ Step: store radius, x_center, y_center\n→ Step: define randPoint method\n→ Inside randPoint: generate random radius sqrt(rnd1) * radius // to maintain uniform density\n→ Generate random angle uniform 0-2π\n→ Compute x = x_center + r * cos(angle)\n→ Compute y = y_center + r * sin(angle)\n→ Return [x, y]\nEnd\n\nNeed to include \"Decision:\" maybe not needed. But could include if loop or not.\n\nUse arrow '→'. Provide comment after space: // explanation in Chinese.\n\nEnsure each line contains virtual code step then space then comment. Use Chinese.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class Solution // 定義 Solution 類別  \n→ Step: 初始化參數 (radius, x_center, y_center) // 建構子：接受半徑與圓心座標  \n→ Step: 將 radius, x_center, y_center 存入物件屬性 // 方便之後使用  \n→ Step: 定義方法 randPoint() // 用來產生隨機點  \n→ Decision: 在 randPoint 內部執行隨機生成流程? // 進入生成邏輯  \n  → Step: 產生 uniform 隨機數 u1 ∈ [0,1] // 用於計算半徑  \n  → Step: 產生 uniform 隨機數 u2 ∈ [0,1] // 用於計算角度  \n  → Step: 計算 r = radius * sqrt(u1) // 保持面積均勻分布  \n  → Step: 計算 θ = 2π * u2 // 角度在 0 到 2π 之間均勻  \n  → Step: 計算 x = x_center + r * cos(θ) // 計算隨機點 x 座標  \n  → Step: 計算 y = y_center + r * sin(θ) // 計算隨機點 y 座標  \n  → Step: Return [x, y] // 回傳隨機點座標  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated String Match",
      "source_file": "Leetcode/leetcode686.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "a = \"abcd\", b = \"cdabcdab\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '-1'"
        },
        {
          "example_index": 1,
          "input": "a = \"a\", b = \"aa\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def repeatedStringMatch(self, A: str, B: str) -> int:\n        # 計算至少需要重複 A 的次數，至少能覆蓋 B 的長度\n        repeat = (len(B) + len(A) - 1) // len(A)\n        s = A * repeat\n        # 先檢查一次重複後是否已包含 B\n        if B in s:\n            return repeat\n        # 再追加一次 A，再檢查一次\n        s += A\n        if B in s:\n            return repeat + 1\n        # 兩次都不行，表示不可能\n        return -1\n\ndef parse_input(raw: str):\n    \"\"\"\n    從標準輸入讀取資料，支援以下兩種常見格式：\n    1. 兩行分別為 a 與 b\n    2. 單行例如：a = \"abcd\", b = \"cdabcdab\"\n    解析後返回 (a, b) 的字串。\n    \"\"\"\n    # 移除換行、逗號、等號與引號，並以空格分隔\n    cleaned = raw.replace('\\n', ' ').replace(',', ' ').replace('=', ' ').replace('\"', ' ')\n    tokens = cleaned.split()\n    # 取前兩個非空字串作為 a, b\n    if len(tokens) < 2:\n        raise ValueError(\"輸入格式不正確，無法解析 a 與 b。\")\n    return tokens[0], tokens[1]\n\ndef main():\n    raw_input = sys.stdin.read()\n    a, b = parse_input(raw_input)\n    result = Solution().repeatedStringMatch(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The task: given two strings a and b, find minimum repeats of a so that b is substring. Classic LeetCode problem. Algorithm: repeat a until length >= len(b)+len(a). Actually minimal repeats n = ceil(len(b)/len(a)). Check if b in a*n; if not, try n+1; if still not, return -1.\n\nVirtual code lines: Start, Step: compute repeat count, Step: build repeated string, Decision: contains? If yes, return n; else, repeat n+1, check, return n+1 if contains; else -1. End.\n\nWe need to use arrow syntax and decision blocks. Provide explanation after each line.\n\nLet's craft. Use variable names: lenA, lenB, repeats, repeatedA.\n\nMake sure each line ends with // explanation.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Step 1: lenA ← length of a; lenB ← length of b // 取得兩個字串長度\n→ Step 2: repeats ← ceil(lenB / lenA) // 計算至少需要重複幾次才能覆蓋 b 的長度\n→ Step 3: repeatedA ← a repeated repeats times // 建立重複後的字串\n→ Decision: 是否 b 為 repeatedA 的子字串? // 檢查是否已經包含\n    Yes → Step 4: 回傳 repeats // 若包含，最小重複數為 repeats\n    No  → Step 5: repeatedA ← repeatedA concatenated with a // 追加一次再檢查\n           Decision: 是否 b 為 repeatedA 的子字串? // 再次檢查\n               Yes → Step 6: 回傳 repeats + 1 // 若包含，最小重複數為 repeats+1\n               No  → Step 7: 回傳 -1 // 兩次皆未包含，無法達成\nEnd // 程式執行結束\n\nCheck formatting: each line has virtual code, then space, then // explanation. Use arrow and indent? Indent the nested decisions. Provide \"Yes →\" and \"No →\" lines. Ok.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: lenA ← length of a; lenB ← length of b // 取得兩個字串長度  \n→ Step 2: repeats ← ceil(lenB / lenA) // 計算至少需要重複幾次才能覆蓋 b 的長度  \n→ Step 3: repeatedA ← a repeated repeats times // 建立重複後的字串  \n→ Decision: 是否 b 為 repeatedA 的子字串? // 檢查是否已經包含  \n    Yes → Step 4: 回傳 repeats // 若包含，最小重複數為 repeats  \n    No  → Step 5: repeatedA ← repeatedA concatenated with a // 追加一次再檢查  \n           Decision: 是否 b 為 repeatedA 的子字串? // 再次檢查  \n               Yes → Step 6: 回傳 repeats + 1 // 若包含，最小重複數為 repeats+1  \n               No  → Step 7: 回傳 -1 // 兩次皆未包含，無法達成  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[1,2,3],[1,2,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [1, 2, 3], [1, 2, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"初始化，存儲原始陣列的副本。\"\"\"\n        self.original = list(nums)\n\n    def reset(self):\n        \"\"\"將陣列恢復到原始順序並返回。\"\"\"\n        return list(self.original)\n\n    def shuffle(self):\n        \"\"\"\n        使用 Fisher‑Yates 洗牌演算法打亂陣列。\n        產生的排列均等可能。\n        \"\"\"\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        return\n\n    # 解析輸入：將兩個列表包裝成一個外層列表，方便 json.loads\n    try:\n        methods, args = json.loads('[' + data + ']')\n    except json.JSONDecodeError:\n        # 若輸入已經是完整的 JSON，直接解析\n        methods, args = json.loads(data)\n\n    result = []\n    obj = None\n\n    for method, arg in zip(methods, args):\n        if method == \"Solution\":\n            # arg 是形如 [[1,2,3]] 的列表，取其中的 nums\n            obj = Solution(arg[0])\n            result.append(None)\n        elif method == \"reset\":\n            result.append(obj.reset())\n        elif method == \"shuffle\":\n            result.append(obj.shuffle())\n        else:\n            # 未知方法，按需處理；此處簡單忽略\n            result.append(None)\n\n    # 將 None 轉成 JSON 的 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step for design of a class Solution that supports constructor, reset, shuffle. They ask for virtual code, no actual code. We produce steps: Start, Step for constructor, Step for reset, Step for shuffle, End. Also need to handle shuffle algorithm: Fisher-Yates. Provide explanation.\n\nWe should produce something like:\n\nStart\n→ Step 1: 存儲原始陣列的複製 // 保存原始順序\n→ Step 2: 初始化隨機數生成器 // 用於後續 shuffle\n→ Step 3: reset() // 返回原始陣列\n    → Return a copy of stored original // 確保不改變原始\n→ Step 4: shuffle() // 返回隨機排列\n    → Step 4.1: 創建陣列 copy 為當前陣列 // 需要複製\n    → Step 4.2: 對 i 從 last 到 1 迭代\n        → Step 4.2.1: 隨機選擇 j 0..i\n        → Step 4.2.2: 交換 copy[i] 與 copy[j] // Fisher-Yates\n    → Return copy\nEnd\n\nAlso need to maintain state: maybe store original array and a copy for current? But we can just always return copy of original.\n\nBetter to implement: constructor: store original array and create current copy as original. shuffle: operate on copy.\n\nWe need to include decision nodes? Not necessary, but we can show if else? Might not.\n\nThey ask to use arrows and structure. Should show Start, End. For each step.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums // 取得建構函式傳入的整數陣列  \n→ Step 2: 建立 original = nums 的複製 // 保存原始順序以供 reset 使用  \n→ Step 3: 建立 current = original 的複製 // current 代表目前的陣列狀態  \n→ Step 4: 初始化隨機數生成器 RNG // 用於 shuffle 時產生隨機索引  \n→ Step 5: 定義方法 reset() // 重置陣列到原始配置  \n    → Step 5.1: 設定 current = original 的複製 // 重新複製原始陣列  \n    → Step 5.2: 回傳 current // 返回重置後的陣列  \n→ Step 6: 定義方法 shuffle() // 產生等可能的隨機排列  \n    → Step 6.1: 對 i 從 current.length-1 迭代到 1  \n        → Step 6.1.1: RNG 產生 j ∈ [0, i] // 隨機選擇交換索引  \n        → Step 6.1.2: 交換 current[i] 與 current[j] // Fisher‑Yates 交換  \n    → Step 6.2: 回傳 current // 返回已打亂的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    \"\"\"\n    回溯法生成所有子集。\n    :param nums: int list, 互不相同的元素\n    :return: list of lists，所有子集\n    \"\"\"\n    res = []\n\n    def backtrack(start, path):\n        # 把目前的子集加入結果\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            # 包含 nums[i] 的情況\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()  # 回溯\n\n    backtrack(0, [])\n    return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入：假設格式為 \"nums = [1,2,3]\" 或僅為 \"[1,2,3]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        nums = ast.literal_eval(expr.strip())\n    else:\n        nums = ast.literal_eval(data)\n\n    # 取得子集並輸出\n    result = subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for generating power set of unique array. Provide each step. Use Start, Decision, etc. Use Chinese comments. We'll produce lines:\n\nStart\n→ Step 1: Sort nums? Not needed. But typical recursion.\n\nWe'll use backtracking. Steps: define result list. Define recursive function backtrack(index, currentSubset). At each call, add currentSubset to result. If index==len(nums) return. Else: include nums[index], backtrack(index+1, currentSubset+[nums[index]]). Then exclude, backtrack(index+1, currentSubset). That covers all subsets.\n\nLet's produce virtual code lines with explanations.\n\nNeed to show each step. Use indentation for decisions? Use arrow lines.\n\nWe can use:\n\nStart // 程式開始執行\n→ Step 1: 宣告 result 為空集合 // 用於儲存所有子集\n→ Step 2: 定義遞迴函式 Backtrack(idx, subset) // idx: 當前索引，subset: 已選子集\n→     Decision: 如果 idx 等於 len(nums)? // 檢查是否已遍歷完所有元素\n            Yes → Step 3: 將 subset 複製並加入 result // 收集當前子集\n            No  → Step 4: 執行包含 nums[idx] 的遞迴 // 選擇當前元素\n                     → Step 5: Backtrack(idx+1, subset ∪ {nums[idx]}) // 加入元素後遞迴\n                     → Step 6: 執行不包含 nums[idx] 的遞迴 // 放棄當前元素\n                     → Step 7: Backtrack(idx+1, subset) // 直接遞迴\n→ Step 8: 呼叫 Backtrack(0, 空集合) // 開始回溯\n→ Step 9: 回傳 result // 返回所有子集\nEnd\n\nNeed to ensure each line is \"虛擬碼步驟\" + \" // 解釋\". Use the arrow. For indentation we might use tab or spaces, but keep same format.\n\nWill add arrow arrows before each line? Use \"→\" before each step. For Decision lines, show \"Decision: ...\" etc.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告 result 為空集合 // 用於儲存所有子集  \n→ Step 2: 定義遞迴函式 Backtrack(idx, subset) // idx: 當前索引，subset: 已選子集  \n→     Decision: 如果 idx 等於 len(nums)? // 檢查是否已遍歷完所有元素  \n→         Yes → Step 3: 將 subset 複製並加入 result // 收集當前子集  \n→         No  → Step 4: 執行包含 nums[idx] 的遞迴 // 選擇當前元素  \n→             → Step 5: Backtrack(idx+1, subset ∪ {nums[idx]}) // 加入元素後遞迴  \n→             → Step 6: 執行不包含 nums[idx] 的遞迴 // 放棄當前元素  \n→             → Step 7: Backtrack(idx+1, subset) // 直接遞迴  \n→ Step 8: 呼叫 Backtrack(0, 空集合) // 開始回溯  \n→ Step 9: 回傳 result // 返回所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Shortest Unsorted Continuous Subarray",
      "source_file": "Leetcode/leetcode581.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '-3'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '-3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findUnsortedSubarray(self, nums):\n        n = len(nums)\n        # 如果長度小於等於1，已經有序\n        if n <= 1:\n            return 0\n\n        # 找左邊界：第一次發現小於目前最大值的位置\n        left = n\n        max_val = nums[0]\n        for i in range(1, n):\n            if nums[i] < max_val:\n                left = i\n            max_val = max(max_val, nums[i])\n\n        # 找右邊界：第一次發現大於目前最小值的位置\n        right = -1\n        min_val = nums[-1]\n        for i in range(n - 2, -1, -1):\n            if nums[i] > min_val:\n                right = i\n            min_val = min(min_val, nums[i])\n\n        # 如果沒有發現不整齊的區段，left 仍為 n，right 為 -1\n        if left == n and right == -1:\n            return 0\n\n        return right - left + 1\n\ndef parse_input(input_str: str):\n    \"\"\"將類似 'nums = [2,6,4,8,10,9,15]' 的字串轉成 list\"\"\"\n    # 去除空白與換行\n    input_str = input_str.strip()\n    if '=' in input_str:\n        _, value = input_str.split('=', 1)\n        value = value.strip()\n    else:\n        value = input_str\n    # 使用 ast.literal_eval 以安全方式解析字面量\n    return ast.literal_eval(value)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.findUnsortedSubarray(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code. Steps: find left boundary: iterate from left to right, track max, find first index where arr[i] < max. Find right boundary: iterate from right to left, track min, find first index where arr[i] > min. If no such subarray, length 0. Else length = right-left+1. Virtual code lines with explanations.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 讀入 整數陣列 nums // 取得輸入\n→ Step 2: 初始化 n = length(nums) // 獲取陣列長度\n→ Decision: 如果 n < 2? // 檢查陣列長度\n    Yes → Step 3: 輸出 0 // 只一個或零個元素已排序\n    No  → Decision: 找左邊界 // 開始尋找左邊界\n        → Step 4: left = n // 設定左邊界初始值\n        → Step 5: max_val = nums[0] // 記錄目前最大值\n        → Step 6: 從 i = 1 到 n-1 逐步:\n            → Decision: 如果 nums[i] < max_val? // 判斷是否破壞排序\n                Yes → left = i // 更新左邊界為破壞位置\n                No  → No\n            → Decision: 更新 max_val = max(max_val, nums[i]) // 保持最大值\n        → Step 7: 再次確認 left == n? // 是否整個陣列已排序\n            Yes → Step 8: 輸出 0 // 已排序\n            No  → Decision: 找右邊界 // 開始尋找右邊界\n                → Step 9: right = -1 // 設定右邊界初始值\n                → Step 10: min_val = nums[n-1] // 記錄目前最小值\n                → Step 11: 從 i = n-2 到 0 逐步:\n                    → Decision: 如果 nums[i] > min_val? // 判斷是否破壞排序\n                        Yes → right = i // 更新右邊界\n                        No  → No\n                    → Decision: 更新 min_val = min(min_val, nums[i]) // 保持最小值\n                → Step 12: 計算長度 = right - left + 1 // 取子陣列長度\n                → Step 13: 輸出 長度 // 返回結果\nEnd // 程式執行結束\n\nWe need to keep format exactly: \"→ Step X: ... // 解釋\". Use Decision lines with Yes→ and No→.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入 整數陣列 nums // 取得輸入  \n→ Step 2: 初始化 n = length(nums) // 獲取陣列長度  \n→ Decision: 如果 n < 2? // 檢查陣列長度  \n Yes → Step 3: 輸出 0 // 只一個或零個元素已排序  \n No → Decision: 找左邊界 // 開始尋找左邊界  \n  → Step 4: left = n // 設定左邊界初始值  \n  → Step 5: max_val = nums[0] // 記錄目前最大值  \n  → Step 6: 從 i = 1 到 n-1 逐步: // 遍歷陣列  \n    → Decision: 如果 nums[i] < max_val? // 判斷是否破壞排序  \n     Yes → left = i // 更新左邊界為破壞位置  \n     No → No  \n    → Decision: 更新 max_val = max(max_val, nums[i]) // 保持最大值  \n  → Step 7: 再次確認 left == n? // 是否整個陣列已排序  \n    Yes → Step 8: 輸出 0 // 已排序  \n    No → Decision: 找右邊界 // 開始尋找右邊界  \n     → Step 9: right = -1 // 設定右邊界初始值  \n     → Step 10: min_val = nums[n-1] // 記錄目前最小值  \n     → Step 11: 從 i = n-2 到 0 逐步: // 反向遍歷陣列  \n       → Decision: 如果 nums[i] > min_val? // 判斷是否破壞排序  \n        Yes → right = i // 更新右邊界  \n        No → No  \n       → Decision: 更新 min_val = min(min_val, nums[i]) // 保持最小值  \n     → Step 12: 計算長度 = right - left + 1 // 取子陣列長度  \n     → Step 13: 輸出 長度 // 返回結果  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,3,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, 3, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> keys in LRU order\n\n    def _update(self, key: int):\n        \"\"\"Increment frequency of a key and move it to the new freq list.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # Remove from old freq list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add to new freq list\n        new_freq = freq + 1\n        self.freq_to_keys[new_freq][key] = None\n        self.key_to_val_freq[key] = (value, new_freq)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        # Evict if at capacity\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict the LRU key from the min_freq list\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Wrap input in brackets to make it a list of two elements\n    methods_and_args = json.loads('[' + data + ']')\n    methods, args = methods_and_args\n\n    output = []\n    cache = None\n    for method, arg in zip(methods, args):\n        if method == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            output.append(None)\n        elif method == \"put\":\n            cache.put(*arg)\n            output.append(None)\n        elif method == \"get\":\n            res = cache.get(*arg)\n            output.append(res)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps, line by line, with explanation after //, following the format. Must not output actual code. Provide steps for LFU cache design and implementation, including data structures: hash maps, doubly linked lists, frequency lists, etc. Steps: initialize capacity, minFreq, global map key->node, freq map freq->list of nodes. Node contains key, value, freq. Methods: get, put. For get: if key not exist return -1; else increment frequency: remove from old list, add to new freq list, update minFreq if needed. Return value. For put: if capacity zero return; if key exists: update value, then similar increment freq; else if capacity reached: evict LRU from minFreq list: remove first node; delete from key map; then insert new node with freq=1; add to freq list 1; set minFreq=1; add to key map.\n\nNeed to output stepwise, with virtual arrows and decisions.\n\nMake sure to use virtual code format with → etc. Provide each line: e.g., \"Start // 程式開始執行\". Then subsequent steps: \"→ Step 1: 初始化 LFUCache(capacity) // 設定容量並初始化資料結構\".\n\nWill need to break into logical sub-steps: initialization, get, put, helper function incrementFreq, evictIfNeeded, etc. Also include decision points: key exists? capacity full? freq list empty? etc.\n\nProvide O(1) operations: Use HashMap for key->Node, HashMap freq->LinkedHashSet or doubly linked list.\n\nWe will just provide pseudo steps.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: 取 `capacity` 並存於 `this.capacity` // 設定快取容量  \n→ Step 2: 建立 `this.minFreq ← 0` // 追蹤目前最小頻率  \n→ Step 3: 初始化 `this.keyToNode ← new Map()` // key → Node (key, value, freq)  \n→ Step 4: 初始化 `this.freqToNodes ← new Map()` // freq → DoublyLinkedList of Nodes  \n\nEnd // 快取結構初始化完成  \n\n---\n\n### 取得 (get)  \n→ Step 5: Decision: `if key not in keyToNode?` // 檢查 key 是否存在  \n  No → Step 6: `return -1` // 不存在，直接回傳  \n  Yes → Step 7: 取得 `node ← keyToNode[key]` // 取得對應節點  \n  → Step 8: Call `incrementFreq(node)` // 進行頻率遞增  \n  → Step 9: `return node.value` // 回傳值  \n\n---\n\n### 放置 (put)  \n→ Step 10: Decision: `if capacity == 0?`  \n  Yes → Step 11: `return` // 容量為 0，直接結束  \n  No → Step 12: Decision: `if key in keyToNode?`  \n    Yes → Step 13: 取得 `node ← keyToNode[key]`  \n     → Step 14: `node.value ← value` // 更新值  \n     → Step 15: Call `incrementFreq(node)` // 進行頻率遞增  \n    No → Step 16: Decision: `if keyToNode.size == capacity?`  \n      Yes → Step 17: Call `evictLFU()` // 逐出最少頻率/最舊元素  \n      No → Step 18: // 無需逐出，直接插入  \n       → Step 19: 創建 `newNode ← {key, value, freq:1}`  \n       → Step 20: `keyToNode[key] ← newNode` // 記錄 key ↦ node  \n       → Step 21: `addNodeToFreqList(newNode, 1)` // 加入 freq 1 列表  \n       → Step 22: `minFreq ← 1` // 最小頻率更新為 1  \n\n---\n\n### 增加頻率 (incrementFreq)  \n→ Step 23: `oldFreq ← node.freq`  \n→ Step 24: `node.freq ← oldFreq + 1` // 更新節點頻率  \n→ Step 25: `removeNodeFromFreqList(node, oldFreq)` // 從舊頻率列表移除  \n→ Step 26: Decision: `if freqToNodes[oldFreq] is empty?`  \n  Yes → Step 27: `delete freqToNodes[oldFreq]` // 清除空列表  \n    Decision: `if minFreq == oldFreq?`  \n      Yes → Step 28: `minFreq ← node.freq` // 更新最小頻率  \n      No → // 不變  \n  No → // 不變  \n→ Step 29: `addNodeToFreqList(node, node.freq)` // 加入新頻率列表  \n\n---\n\n### 逐出最少頻率元素 (evictLFU)  \n→ Step 30: `list ← freqToNodes[minFreq]` // 取得最小頻率列表  \n→ Step 31: `nodeToRemove ← list.head` // 最舊（LRU）節點  \n→ Step 32: `removeNodeFromFreqList(nodeToRemove, minFreq)` // 從列表移除  \n→ Step 33: `delete keyToNode[nodeToRemove.key]` // 刪除 key ↦ node 映射  \n→ Step 34: Decision: `if list is empty?`  \n  Yes → Step 35: `delete freqToNodes[minFreq]` // 清空空列表  \n    Decision: `if keyToNode.size == 0?`  \n      Yes → Step 36: `minFreq ← 0` // 沒有元素，重設  \n      No → // 不變  \n  No → // 不變  \n\n---\n\n### 連結操作  \n→ Step 37: `addNodeToFreqList(node, freq)`  \n  → Step 38: `if freq not in freqToNodes?`  \n    Yes → Step 39: `freqToNodes[freq] ← new DoublyLinkedList()` // 新建列表  \n    No → // 列表已存在  \n  → Step 40: `freqToNodes[freq].addToTail(node)` // 加入尾端  \n\n→ Step 41: `removeNodeFromFreqList(node, freq)`  \n  → Step 42: `freqToNodes[freq].remove(node)` // O(1) 移除  \n  → Step 43: `if freqToNodes[freq].isEmpty()?`  \n    Yes → Step 44: `delete freqToNodes[freq]` // 列表空，刪除  \n\nEnd // LFUCache 虛擬碼結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\nimport ast\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"建立前綴和，總重量用於後續隨機選擇\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機選取索引，概率與權重成正比\"\"\"\n        target = random.randint(1, self.total)  # 1 ~ total\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個字串\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析類似 ('[\"Solution\",\"pickIndex\"], [[[1]],[]]') 這樣的字串\n    # ast.literal_eval 能正確解析成 (['Solution', 'pickIndex'], [[[1]], []])\n    try:\n        methods, args_list = ast.literal_eval(data)\n    except Exception as e:\n        raise ValueError(\"輸入格式不正確\") from e\n\n    outputs = []\n    instance = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # args 可能是 [[1]]，取第一個元素作為 w\n            instance = Solution(args[0])\n            outputs.append(None)  # 對應 LeetCode 的 null\n        elif method == \"pickIndex\":\n            if instance is None:\n                raise RuntimeError(\"Solution 未初始化\")\n            outputs.append(instance.pickIndex())\n        else:\n            raise ValueError(f\"未知方法 {method}\")\n\n    # 輸出結果，將 None 轉為 null\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for a class that initializes with array w, builds prefix sums, and pickIndex uses random between 1 and sum, binary search. Use virtual code steps. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrows, Decision, Start, End. Provide step-by-step.\n\nLet's outline:\n\nStart\n→ Step 1: Receive w array // store w\n→ Step 2: Compute prefix sums array prefix // cumulative weights\n→ Step 3: Compute total weight total = prefix[-1] // sum of all weights\n→ Step 4: Define function pickIndex()\n    → Step 5: Generate random integer r between 1 and total inclusive // random target\n    → Decision: Search for smallest index i where prefix[i] >= r\n        → Binary Search Loop:\n            → Step 6: low=0, high=prefix.length-1 // initial bounds\n            → Step 7: While low < high:\n                → Step 8: mid = floor((low+high)/2) // middle index\n                → Decision: If prefix[mid] < r?\n                    → Yes → low = mid + 1 // target is to the right\n                    → No  → high = mid // target is at mid or left\n            → Step 9: Return low // found index\nEnd\n\nBut we need to represent each line with arrow, decision etc. We need to label function definition maybe as \"Function: pickIndex\" but still maintain virtual code.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Store input array w // 接收 w\n→ Step 2: Initialize prefix array of same length // 用於累積權重\n→ Step 3: For i from 0 to w.length-1:\n    → Step 4: If i == 0 then prefix[i] = w[i] else prefix[i] = prefix[i-1] + w[i] // 計算前綴和\n→ Step 5: total = prefix[w.length-1] // 總權重\n→ Function pickIndex // 定義 pickIndex 函式\n    → Step 6: r = RandomInt(1, total) // 隨機數，範圍 1~total\n    → Decision: 找到首個 prefix[i] >= r\n        → Step 7: low = 0 // 搜索下界\n        → Step 8: high = prefix.length-1 // 搜索上界\n        → Step 9: While low < high:\n            → Step 10: mid = floor((low + high)/2) // 取中點\n            → Decision: prefix[mid] < r ?\n                → Yes → low = mid + 1 // r 在右側\n                → No  → high = mid // r 在左側或等於 mid\n        → Step 11: Return low // 找到對應索引\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use arrow and indent. Let's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Store input array w // 接收 w  \n→ Step 2: Initialize prefix array of same length // 用於累積權重  \n→ Step 3: For i from 0 to w.length-1:  \n  → Step 4: If i == 0 then prefix[i] = w[i] else prefix[i] = prefix[i-1] + w[i] // 計算前綴和  \n→ Step 5: total = prefix[w.length-1] // 總權重  \n→ Function pickIndex // 定義 pickIndex 函式  \n  → Step 6: r = RandomInt(1, total) // 隨機數，範圍 1~total  \n  → Decision: 找到首個 prefix[i] >= r  \n    → Step 7: low = 0 // 搜索下界  \n    → Step 8: high = prefix.length-1 // 搜索上界  \n    → Step 9: While low < high:  \n      → Step 10: mid = floor((low + high)/2) // 取中點  \n      → Decision: prefix[mid] < r ?  \n         → Yes → low = mid + 1 // r 在右側  \n         → No → high = mid // r 在左側或等於 mid  \n    → Step 11: Return low // 找到對應索引  \nEnd // 程式結束"
    }
  ]
}