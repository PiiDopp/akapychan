[
  {
    "source_file": "900.json",
    "problem_index_in_file": 0,
    "title": "安全除法",
    "description_snippet": "請寫一個程式，讓使用者輸入兩個整數 a 與 b，輸出 a / b 的結果。若輸入的資料非整數或除數為 0，請顯示錯誤提示『輸入錯誤或除數為 0』。程式必須使用 try / except 結構。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The requirement: \"Use virtual code, no actual code.\" Format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow →, Decision, Start, End. Must include try/except structure. Steps: start, prompt input a, prompt input b, try parse ints, if not integer error, try division, catch ZeroDivisionError, output result else error. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入文字 a // 取得使用者輸入的第一個數值（尚未轉型）  \n→ Step 2: 輸入文字 b // 取得使用者輸入的第二個數值（尚未轉型）  \n→ Step 3: try // 嘗試執行以下區塊  \n  → Step 4: 轉型 a 為整數 // 轉換輸入為整數，若失敗會觸發 ValueError  \n  → Step 5: 轉型 b 為整數 // 轉換輸入為整數，若失敗會觸發 ValueError  \n  → Step 6: 轉型結果為 result = a / b // 執行除法，若除數為 0 會觸發 ZeroDivisionError  \n  → Step 7: 輸出 result // 顯示除法結果  \n  → Step 8: except ValueError // 捕捉任何轉型錯誤  \n   → Step 9: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息  \n  → Step 10: except ZeroDivisionError // 捕捉除數為 0 的錯誤  \n   → Step 11: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    try:\n        # 讀取一行輸入，並將兩個數字轉為整數\n        a, b = map(int, input().split())\n        # 執行除法並印出結果\n        print(a / b)\n    except (ValueError, ZeroDivisionError):\n        # 若轉型失敗或除數為 0，印出錯誤訊息\n        print('輸入錯誤或除數為 0')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "10 0",
          "expected_output": "輸入錯誤或除數為 0",
          "success": true,
          "output": "輸入錯誤或除數為 0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "900.json",
    "problem_index_in_file": 1,
    "title": "統計文字行數",
    "description_snippet": "請寫一個程式，開啟名為 data.txt 的檔案，讀取內容並輸出總共有幾行文字。若檔案不存在，請顯示『找不到檔案！』。請使用 with 語法搭配 try / except。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanations. Each line: \"虛擬碼步驟 // 解釋\". Must include arrows and structure: Start, End, Decision. Use \"→\" arrow. We need to open file data.txt with try/except; use with syntax. We need to count lines. So steps: Start, Decision: File exists? But we use try/except. So maybe Step: Try open file with with. Step: Read lines, count. Step: Output count. Except FileNotFoundError: output \"找不到檔案！\". End.\n\nWe must adhere to format: each line as per example. Let's produce lines:\n\nStart // 程式開始執行\n→ Decision: 是否準備開啟檔案? // 開始嘗試讀取檔案\n    Yes → Step 1: 執行 try → 開啟 data.txt with with 語法 // 使用 with 打開檔案\n        → Step 2: 讀取所有行並計算行數 // 計算檔案的行數\n        → Step 3: 輸出 '共 X 行' // 顯示行數\n    No  → Step 4: 輸出 '找不到檔案！' // 檔案不存在時的錯誤訊息\nEnd // 程式執行結束\n\nBut we need to reflect try/except logic. We can use Decision: try open? But try is not a decision. Maybe we use \"Decision: 嘗試開啟檔案?\" but actually try block will handle.\n\nSimplify: Start, Step 1: Try block. Step 2: open file with with. Step 3: read lines, count. Step 4: output. Except block: output not found. End.\n\nLet's follow style: Use Decision for the try? Or use \"Decision: 是否出現 FileNotFoundError?\" after try? Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 嘗試執行下列區塊 (try) // 開始錯誤捕捉流程\n→ Step 2: 開啟 'data.txt' 並以 with 語法讀取檔案 // 確保檔案會被正確關閉\n→ Step 3: 讀取所有行並計算行數 // 使用 lines = file.readlines()\n→ Step 4: 輸出 '共 {count} 行' // 顯示行數結果\n→ Decision: 是否捕捉到 FileNotFoundError? // 檢查是否發生檔案不存在錯誤\n    Yes → Step 5: 輸出 '找不到檔案！' // 顯示錯誤訊息\n    No  → // 什麼都不做，流程已結束\nEnd // 程式執行結束\n\nBut we need to reflect try/except semantics. Let's produce:\n\nStart // 程式開始執行\n→ Decision: 準備執行 try? // 進入 try 區塊\n    Yes → Step 1: 開啟 'data.txt' 並使用 with 語法讀取檔案 // 打開檔案並確保自動關閉\n        → Step 2: 讀取所有行並計算行數 // 用 readlines() 或迭代\n        → Step 3: 輸出 '共 {count} 行' // 顯示行數\n    No  → Decision: 是否捕捉到 FileNotFoundError? // 處理例外\n        Yes → Step 4: 輸出 '找不到檔案！' // 顯示錯誤訊息\n        No  → // 其他例外或正常結束\nEnd // 程式執行結束\n\nBut we might use \"Decision: 檔案存在?\" earlier. Simpler: Start; Decision: 嘗試開啟檔案? (Yes -> read; No -> error). Use try/except mapping.\n\nHowever spec: Use with syntax and try/except. So maybe:\n\nStart\n→ Step 1: 嘗試執行 try 區塊 // 進入錯誤處理流程\n→ Step 2: 開啟 'data.txt' 並使用 with 語法讀取檔案 // 檔案操作\n→ Step 3: 讀取所有行並計算行數 // 計算行數\n→ Step 4: 輸出 '共 {count} 行' // 顯示結果\n→ Decision: 是否有 FileNotFoundError? // 檢查是否發生例外\n    Yes → Step 5: 輸出 '找不到檔案！' // 顯示錯誤\n    No → // 例外已處理或無錯誤\nEnd\n\nBut step 4 would only run if no exception. We need a separation: In try block, lines 2-4. In except block, line 5. So maybe better:\n\nStart // 程式開始執行\n→ Step 1: 進入 try 區塊 // 開始錯誤捕捉\n→ Step 2: 使用 with 語法開啟 'data.txt' // 讀取檔案\n→ Step 3: 讀取所有行並計算行數 // 取得行數\n→ Step 4: 輸出 '共 {count} 行' // 顯示行數\n→ Decision: 是否拋出 FileNotFoundError? // 若檔案不存在\n    Yes → Step 5: 輸出 '找不到檔案！' // 顯示錯誤訊息\n    No  → // 沒有錯誤，正常結束\nEnd // 程式結束\n\nBut the \"Decision\" line after step 4 maybe not correct. Could use \"Decision: 該檔案是否存在?\" before try. But the spec wants to use try/except. It's fine to use decision after try? The example uses Decision earlier for conditional logic. Here we can use Decision: \"是否發生 FileNotFoundError?\" But that is after except block.\n\nAlternatively, we can use:\n\nStart\n→ Decision: 準備嘗試開啟檔案? // 進入 try\n    Yes → Step 1: 使用 try 語句\n        → Step 2: 開啟 'data.txt' 並使用 with 語法讀取檔案\n        → Step 3: 讀取所有行並計算行數\n        → Step 4: 輸出 '共 {count} 行'\n    No → Decision: 是否捕捉到 FileNotFoundError? // 例外處理\n        Yes → Step 5: 輸出 '找不到檔案！'\n        No → // 其他例外\n\nBut we cannot nest Step inside Decision like that.\n\nBetter to keep simple:\n\nStart // 程式開始執行\n→ Step 1: 進入 try 區塊 // 開始錯誤捕捉\n→ Step 2: 開啟 'data.txt' 並使用 with 語法讀取檔案 // 讀取檔案\n→ Step 3: 讀取所有行並計算行數 // 計算行數\n→ Step 4: 輸出 '共 {count} 行' // 顯示行數\n→ Decision: 是否拋出 FileNotFoundError? // 檢查是否發生檔案不存在錯誤\n    Yes → Step 5: 輸出 '找不到檔案！' // 顯示錯誤訊息\n    No  → // 正常結束\nEnd // 程式結束\n\nBut the step 4 is executed only if no exception. So Decision after step 4 seems odd. Instead we could have:\n\nStart // 程式開始執行\n→ Step 1: 進入 try 區塊 // 開始錯誤捕捉\n→ Step 2: 使用 with 語法開啟 'data.txt' // 讀取檔案\n→ Step 3: 讀取所有行並計算行數 // 計算行數\n→ Step 4: 輸出 '共 {count} 行' // 顯示行數\n→ Step 5: 結束 try 區塊 // 正常完成\n→ Decision: 是否發生 FileNotFoundError? // 檢查是否有例外\n    Yes → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息\n    No  → // 沒有錯誤，流程已結束\nEnd // 程式結束\n\nBut we need to reflect try/except. Step 5: 結束 try? It's implicit.\n\nLet's produce final output with each line following format. Ensure each line ends with comment. Use `→` arrow. Provide correct indent for decisions: show Yes →, No → lines.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 進入 try 區塊 // 開始錯誤捕捉  \n→ Step 2: 使用 with 語法開啟 'data.txt' // 確保檔案開啟且自動關閉  \n→ Step 3: 讀取所有行並計算行數 // 用 readlines() 或迭代求行數  \n→ Step 4: 輸出 '共 {count} 行' // 顯示計算得到的行數  \n→ Decision: 是否捕捉到 FileNotFoundError? // 檢查是否發生檔案不存在錯誤  \n    Yes → Step 5: 輸出 '找不到檔案！' // 顯示錯誤訊息  \n    No  → // 沒有錯誤，正常結束流程  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有標準輸入資料（即使本題不使用它，也要符合要求）\n    sys.stdin.read()\n\n    try:\n        # 用 with 語法安全開啟檔案，確保檔案關閉\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            # 輸出行數，符合題目示例格式\n            print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        # 檔案不存在時輸出錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 1 行",
          "success": true,
          "output": "檔案共有 1 行"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 0,
    "title": "表達式計算",
    "description_snippet": "請寫一個程式，輸入三個整數 a、b、c，計算並輸出結果：a + b * c 和 (a + b) * c。請觀察兩者的不同。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with step lines and explanation. Format: each line with \"虛擬碼步驟 // 解釋\". Use arrows. Steps: Start, input a, b, c, compute a+b*c, compute (a+b)*c, output both, End. Use Decision? Not needed. Just straight steps. But we can add Decision for computing? Not necessary.\n\nMake sure lines use arrow: \"→ Step 1: 輸入 a\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 整數 a // 從使用者取得第一個整數  \n→ Step 2: 輸入 整數 b // 從使用者取得第二個整數  \n→ Step 3: 輸入 整數 c // 從使用者取得第三個整數  \n→ Step 4: 計算 a_plus_b_times_c = a + (b * c) // 先乘再加，符合運算優先順序  \n→ Step 5: 計算 a_plus_b_times_c_parentheses = (a + b) * c // 先加再乘，使用括號改變優先順序  \n→ Step 6: 輸出 a_plus_b_times_c // 顯示 a + b * c 的結果  \n→ Step 7: 輸出 a_plus_b_times_c_parentheses // 顯示 (a + b) * c 的結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    \"\"\"\n    讀取三個整數 a、b、c，計算兩個表達式的值並輸出。\n    \"\"\"\n    # 從標準輸入一次讀取所有數字，並轉換為整數\n    data = sys.stdin.read().strip().split()\n    if len(data) != 3:\n        # 如果輸入不符合預期，則不做任何處理\n        return\n    a, b, c = map(int, data)\n\n    # 先計算 a + b * c\n    expr1 = a + b * c\n    # 再計算 (a + b) * c\n    expr2 = (a + b) * c\n\n    # 將結果輸出，格式與範例相同\n    print(f\"a + b * c = {expr1}\")\n    print(f\"(a + b) * c = {expr2}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2 3 4",
          "expected_output": "a + b * c = 14\n(a + b) * c = 20",
          "success": true,
          "output": "a + b * c = 14\n(a + b) * c = 20"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 1,
    "title": "平均分配",
    "description_snippet": "小明有 n 顆糖果，要平均分給 m 個小朋友。請輸入 n 和 m，輸出每個小朋友分到幾顆糖果，剩下幾顆糖果沒有分完。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step, line by line, with format: each line: \"虛擬碼步驟 // 解釋\". Use arrow, Decision. So we start with Start. Then read input n and m. Then compute quotient and remainder: candies_per_child = n / m (integer division), leftover = n % m. Then output both. End.\n\nWe need to produce \"虛擬碼步驟\" lines like \"→ Step 1: 讀取 n\" etc.\n\nMake sure to use Chinese comments in // for explanation.\n\nWe must not output actual code. Just pseudo steps. Use \"Start\" and \"End\". Also need to include decisions? Actually we don't need decisions. But we can include decision to check if m > 0 maybe. But not required. But we can include error handling: if m == 0 -> output error. Let's include a decision.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 取得糖果總數\n→ Step 2: 讀取 m // 取得小朋友人數\n→ Decision: 如果 m = 0? // 檢查是否除數為零\n    Yes → Step 3: 輸出 '錯誤：小朋友人數不能為 0' // 顯示錯誤訊息\n    No → Step 4: 計算 每人糖果 = n / m // 完全除法\n    → Step 5: 計算 剩餘糖果 = n % m // 取餘數\n    → Step 6: 輸出 每人糖果 // 顯示每人分到的糖果\n    → Step 7: 輸出 剩餘糖果 // 顯示剩下的糖果\nEnd // 程式執行結束\n\nBut format: each line separated. Ensure each line ends with comment. Use arrow for each step. Use \"Decision:\" line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n // 取得糖果總數  \n→ Step 2: 讀取 m // 取得小朋友人數  \n→ Decision: m 等於 0? // 檢查除數是否為零  \n    Yes → Step 3: 輸出 '錯誤：小朋友人數不能為 0' // 顯示錯誤訊息  \n    No  → Step 4: 計算 每人糖果 = n / m // 計算每位小朋友能分到的糖果數  \n    → Step 5: 計算 剩餘糖果 = n % m // 計算無法平均分配的剩餘糖果  \n    → Step 6: 輸出 每人糖果 // 顯示每人分到的糖果數  \n    → Step 7: 輸出 剩餘糖果 // 顯示剩餘糖果數  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n\n    # 從標準輸入讀取所有數據，並以空白分隔\n    data = sys.stdin.read().strip().split()\n    if not data:  # 若沒有輸入，直接返回\n        return\n\n    # 解析 n 與 m\n    n, m = map(int, data[:2])\n\n    # 若 m 為 0，避免除零錯誤，輸出錯誤訊息\n    if m == 0:\n        print(\"錯誤：小朋友人數不能為 0\")\n        return\n\n    # 計算每人分到的糖果數與剩餘糖果數\n    per = n // m\n    left = n % m\n\n    # 按照題目格式輸出結果\n    print(f\"每人={per} 剩下={left}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "20 6",
          "expected_output": "每人=3 剩下=2",
          "success": true,
          "output": "每人=3 剩下=2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 0,
    "title": "模擬擲骰子遊戲",
    "description_snippet": "請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese, step by step with arrow and explanation. Use random module. The function roll_dice(n) simulating n rolls, returns list of results. Steps: import random, define function, initialize list, loop n times, append random.randint(1,6), return list. End.\n\nUse format: Start // Start. Use arrow. Use Decision maybe not needed. Provide line by line with explanation. We'll produce:\n\nStart // 程式開始執行\n→ Step 1: 導入 random 模組 // 需要使用 random 產生隨機數\n→ Step 2: 定義函式 roll_dice(n) // 接收擲骰次數\n→ Step 3: 初始化空列表 results // 用於儲存每次擲骰結果\n→ Step 4: 循環 i 於 1 到 n // 執行 n 次擲骰\n    → Step 4a: 在 results 中追加 random.randint(1, 6) // 擲出 1-6 隨機整數\n→ Step 5: 回傳 results // 返回所有結果的列表\nEnd // 程式執行結束\n\nNeed to include arrows: For loop maybe use → for each. Might need indentation. Use arrow and decision? Not necessary. Provide each line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 導入 random 模組 // 需要使用 random 產生隨機數  \n→ Step 2: 定義函式 roll_dice(n) // 接收擲骰次數  \n→ Step 3: 初始化空列表 results // 用於儲存每次擲骰結果  \n→ Step 4: 循環 i 於 1 到 n  \n    → Step 4a: 在 results 中追加 random.randint(1, 6) // 擲出 1-6 隨機整數  \n→ Step 5: 回傳 results // 返回所有結果的列表  \nEnd // 程式執行結束",
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    模擬擲 n 次六面骰，回傳所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼，並在本模組的全域環境中執行\n    input_code = sys.stdin.read()\n    exec(input_code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,3,3,5,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 3, 3, 5, 4]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 1,
    "title": "計算程式執行時間",
    "description_snippet": "請使用 time 模組，寫一個函數 measure_time(func, *args)，用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with arrow syntax. The requirement: use time module, write function measure_time(func, *args) to measure execution time in seconds, return rounded to 3 decimals. So steps: Start, import time, define function, record start, call func(*args), record end, compute elapsed, round to 3 decimal places, return elapsed, End.\n\nNeed to follow format: \"虛擬碼步驟 // 解釋\". Include arrows and decision? Not needed as no branching. Just linear steps. Should start with Start // 程式開始執行. Use \"→ Step X: ...\". Provide explanation after each.\n\nMake sure to include imports. Also note the function signature: measure_time(func, *args). Might include comment. Provide pseudo steps. No actual code. So produce lines:\n\nStart\n→ Step 1: Import time module // 引入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: Record start_time ← time.time() // 取得開始時間\n→ Step 4: Call result ← func(*args) // 執行傳入的函式並取得結果\n→ Step 5: Record end_time ← time.time() // 取得結束時間\n→ Step 6: Calculate elapsed ← end_time - start_time // 計算耗時\n→ Step 7: Round elapsed_seconds ← round(elapsed, 3) // 四捨五入到小數點3位\n→ Step 8: Return elapsed_seconds // 回傳測量時間\nEnd\n\nBut we must also return the result? Problem statement says return the result (rounded). It says \"並回傳結果 (四捨五入到小數點 3 位)\". It's ambiguous whether to return the elapsed seconds or the function result. Likely return elapsed time. Provide step: Return elapsed_seconds.\n\nOk.\n\nNow produce virtual code accordingly. Ensure each line ends with comment.\n\nLet's craft output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import time module // 引入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: Record start_time ← time.time() // 取得開始時間\n→ Step 4: Call result ← func(*args) // 執行傳入的函式並取得結果\n→ Step 5: Record end_time ← time.time() // 取得結束時間\n→ Step 6: Calculate elapsed ← end_time - start_time // 計算耗時\n→ Step 7: Round elapsed_seconds ← round(elapsed, 3) // 四捨五入到小數點 3 位\n→ Step 8: Return elapsed_seconds // 回傳測量時間\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 執行所需的秒數，並回傳四捨五入到小數點 3 位的結果。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取標準輸入中的程式碼，並以包含 measure_time 及 time 的命名空間執行。\n    \"\"\"\n    # 讀取全部輸入 (可能是一段完整的 Python 程式碼)\n    code = sys.stdin.read()\n\n    # 建立一個包含 measure_time 與 time 的執行環境\n    exec_namespace = {\n        'measure_time': measure_time,\n        'time': time\n    }\n\n    # 執行輸入的程式碼，輸出將直接寫入標準輸出\n    exec(code, exec_namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 0,
    "title": "BMI 計算器\n",
    "description_snippet": "請撰寫一個程式，依序讀入使用者的姓名、身高（公分，float）、體重（公斤，float），計算 BMI = 體重(kg) / (身高(m))^2，並印出「<姓名> 的 BMI 為 <數值>」。數值四捨...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines with arrow etc.\n\nNeed steps: Start, Input name, height, weight, convert height to meters, compute BMI, round to 1 decimal, output string, End.\n\nAlso decision? None needed.\n\nLet's produce lines.\n\nUse arrow symbol \"→\". Use Decision if needed but none.\n\nWe'll produce:\n\nStart\n→ Step 1: 輸入 姓名 // 從使用者取得姓名\n→ Step 2: 輸入 身高_cm // 取得身高 (公分)\n→ Step 3: 輸入 體重_kg // 取得體重 (公斤)\n→ Step 4: 轉換 身高_m = 身高_cm / 100 // 把公分轉成公尺\n→ Step 5: 計算 BMI = 體重_kg / (身高_m)^2 // 根據公式計算 BMI\n→ Step 6: 四捨五入 BMI_rounded = round( BMI , 1 ) // 四捨五入到小數點 1 位\n→ Step 7: 輸出 \"<姓名> 的 BMI 為 <BMI_rounded>\" // 顯示結果\nEnd\n\nMake sure each line with virtual code + comment. Also arrow for Step. Use consistent formatting.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 姓名 // 從使用者取得姓名\n→ Step 2: 輸入 身高_cm // 取得身高（公分）\n→ Step 3: 輸入 體重_kg // 取得體重（公斤）\n→ Step 4: 轉換 身高_m = 身高_cm / 100 // 把公分轉成公尺\n→ Step 5: 計算 BMI = 體重_kg / (身高_m)^2 // 根據公式計算 BMI\n→ Step 6: 四捨五入 BMI_rounded = round( BMI , 1 ) // 四捨五入到小數點 1 位\n→ Step 7: 輸出 \"<姓名> 的 BMI 為 <BMI_rounded>\" // 顯示結果\nEnd // 程式執行結束",
      "generated_code": "def main() -> None:\n    \"\"\"\n    主程序：\n    1. 從標準輸入讀取姓名、身高（公分）以及體重（公斤）。\n    2. 計算 BMI（體重 / (身高/100)^2）。\n    3. 四捨五入至小數點後 1 位並輸出。\n    \"\"\"\n    # 讀取姓名\n    name = input().strip()\n    # 讀取身高（公分）\n    height_cm = float(input().strip())\n    # 讀取體重（公斤）\n    weight = float(input().strip())\n\n    # 將身高從公分轉換為公尺\n    height_m = height_cm / 100\n\n    # 計算 BMI\n    bmi = weight / (height_m ** 2)\n\n    # 印出結果，四捨五入到小數點後 1 位\n    print(f\"{name} 的 BMI 為 {bmi:.1f}\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Alice\n160\n50\n",
          "expected_output": "Alice 的 BMI 為 19.5\n",
          "success": true,
          "output": "Alice 的 BMI 為 19.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 1,
    "title": "兩數計算小工具\n",
    "description_snippet": "請撰寫一個程式，讀入一行包含兩個以空白分隔的整數，將其轉為 int 後，計算並輸出四個結果：和、差（第一個減第二個）、積、平均（保留到小數點後 1 位）。輸出格式固定為：\n和:<和> 差:<差> 積:...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The requirement: read a line with two integers separated by space, convert to int, compute sum, difference (first minus second), product, average to one decimal place. Output format: \"和:<和> 差:<差> 積:<積> 平均:<平均>\" exactly.\n\nWe need to output step by step. Use Start, End, Decision? Might not need decisions.\n\nSteps:\n\nStart\n→ Step 1: Read input line // read a line from input\n→ Step 2: Split input by space // split into tokens\n→ Step 3: Convert first token to int // parse int\n→ Step 4: Convert second token to int // parse int\n→ Step 5: Calculate sum = a + b // compute sum\n→ Step 6: Calculate difference = a - b // compute diff\n→ Step 7: Calculate product = a * b // compute product\n→ Step 8: Calculate average = (a + b) / 2.0 // compute average as float\n→ Step 9: Format average to one decimal // round/format\n→ Step 10: Construct output string = \"和:\" + sum + \" 差:\" + difference + \" 積:\" + product + \" 平均:\" + formattedAverage // build string\n→ Step 11: Print output // output result\nEnd\n\nWe might include steps for converting to int. Also we need to format average to one decimal. So step 9 uses format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入行 // 從標準輸入讀入一整行文字  \n→ Step 2: 將輸入行以空白分割 // 取得兩個字串元件  \n→ Step 3: 將第一個字串轉為 int // 解析第一個整數 a  \n→ Step 4: 將第二個字串轉為 int // 解析第二個整數 b  \n→ Step 5: 計算和 = a + b // 取得兩數之和  \n→ Step 6: 計算差 = a - b // 取得第一個減第二個的結果  \n→ Step 7: 計算積 = a * b // 取得兩數之積  \n→ Step 8: 計算平均 = (a + b) / 2.0 // 以浮點數計算平均值  \n→ Step 9: 將平均值格式化為一位小數 // 例如使用格式化字串 \"%.1f\"  \n→ Step 10: 組合輸出字串 = \"和:\" + 和 + \" 差:\" + 差 + \" 積:\" + 積 + \" 平均:\" + 格式化平均 // 建立符合要求的輸出格式  \n→ Step 11: 輸出結果字串 // 將結果寫入標準輸出  \nEnd // 程式執行結束",
      "generated_code": "#!/usr/bin/env python3\nimport sys\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取兩個整數，計算並輸出和、差、積與平均值。\n    \"\"\"\n    # 讀取一行輸入並移除前後空白\n    line = sys.stdin.readline().strip()\n    if not line:\n        # 若輸入為空，直接結束\n        return\n\n    # 以空白分割，取得兩個字串\n    a_str, b_str = line.split()\n\n    # 將字串轉成整數\n    a = int(a_str)\n    b = int(b_str)\n\n    # 進行各項計算\n    sum_val = a + b          # 和\n    diff_val = a - b         # 差（第一個減第二個）\n    prod_val = a * b         # 積\n    avg_val = (a + b) / 2.0  # 平均值，使用浮點數\n\n    # 輸出符合指定格式的結果，平均值保留到小數點後一位\n    print(f\"和:{sum_val} 差:{diff_val} 積:{prod_val} 平均:{avg_val:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 3\n",
          "expected_output": "和:15 差:9 積:36 平均:7.5\n",
          "success": true,
          "output": "和:15 差:9 積:36 平均:7.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 0,
    "title": "學生資料類別設計",
    "description_snippet": "請定義一個 Student 類別，具有屬性 name（姓名）與 score（分數）。\n1. 於 __init__() 建構子中初始化這兩個屬性。\n2. 定義方法 show_info()，輸出『XXX ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. No actual code, just virtual code steps. Use the format. Need to define class Student with __init__ and show_info. Then create two objects and call show_info. Must use Start, End, Decision. But not necessarily decisions here. Just flow. Provide steps. Use arrows.\n\nWe'll output each line:\n\nStart // 程式開始\n\n→ Step 1: Define class Student // 定義 Student 類別\n\n→ Step 2: Within Student, define __init__(self, name, score) // 建構子\n\n→ Step 3: Initialize self.name = name // 設定姓名\n\n→ Step 4: Initialize self.score = score // 設定分數\n\n→ Step 5: Define method show_info(self) // 定義顯示資訊方法\n\n→ Step 6: Inside show_info, print '{self.name} 的分數是 {self.score}' // 輸出資訊\n\n→ Step 7: Create student1 = Student('Alice', 85) // 建立第一個 Student 物件\n\n→ Step 8: Create student2 = Student('Bob', 92) // 建立第二個 Student 物件\n\n→ Step 9: Call student1.show_info() // 呼叫第一個物件的 show_info\n\n→ Step 10: Call student2.show_info() // 呼叫第二個物件的 show_info\n\nEnd // 程式執行結束\n\nMake sure each line ends with comment after // explanation. Use arrow symbols. We'll follow the sample formatting: each line begins with \"→\" maybe except Start and End. Provide exactly.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Define class Student // 定義 Student 類別\n→ Step 2: Within Student, define __init__(self, name, score) // 建構子，接收姓名與分數\n→ Step 3: Initialize self.name = name // 儲存姓名為實例屬性\n→ Step 4: Initialize self.score = score // 儲存分數為實例屬性\n→ Step 5: Define method show_info(self) // 定義顯示資訊的方法\n→ Step 6: Inside show_info, print '{self.name} 的分數是 {self.score}' // 輸出「姓名 的分數是 分數」的字串\n→ Step 7: Create student1 = Student('Alice', 85) // 建立第一個 Student 物件\n→ Step 8: Create student2 = Student('Bob', 92) // 建立第二個 Student 物件\n→ Step 9: Call student1.show_info() // 呼叫第一個物件的 show_info 方法\n→ Step 10: Call student2.show_info() // 呼叫第二個物件的 show_info 方法\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Student:\n    def __init__(self, name, score):\n        self.name = name      # 存儲姓名\n        self.score = score    # 存儲分數\n\n    def show_info(self):\n        # 輸出「姓名 的分數是 分數」的字串\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    # 讀取 stdin，無論輸入為何都先消費完畢\n    sys.stdin.read()\n\n    # 依照題目需求建立兩個 Student 物件\n    s1 = Student('Alice', 90)\n    s2 = Student('Bob', 80)\n\n    # 呼叫 show_info() 並將結果輸出\n    s1.show_info()\n    s2.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "success": true,
          "output": "Alice 的分數是 90\nBob 的分數是 80"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 1,
    "title": "動物類別繼承",
    "description_snippet": "請設計一個父類別 Animal，包含方法 make_sound()，印出『動物發出聲音』。\n建立子類別 Dog 與 Cat：\n1. Dog 覆寫 make_sound()，輸出『汪汪！』。\n2. Ca...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Must follow format: \"虛擬碼步驟 // 解釋/說明\". Use arrow →, Yes →, No →. The flow: Start, define Animal, define make_sound, define Dog subclass overriding, define Cat subclass overriding, instantiate, call methods, End.\n\nLet's produce step-by-step. Use Start. Then \"→ Define Class Animal // 定義父類別\" etc. Provide each line. Use arrow for definitions? Might not need Decision. But maybe show overriding decision? We can just sequential steps.\n\nUse \"→\" for each step. Provide short explanation after //. End.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Class Animal // 定義父類別  \n→   → Define Method make_sound() // 在父類別中宣告聲音方法  \n→   →   → Print '動物發出聲音' // 讓父類別輸出預設訊息  \n→ End // 完成父類別定義  \n\n→ Define Class Dog inherits Animal // 建立 Dog 子類別，繼承 Animal  \n→   → Override Method make_sound() // 覆寫父類別的聲音方法  \n→   →   → Print '汪汪！' // Dog 物件發出汪汪聲  \n→ End // 完成 Dog 子類別定義  \n\n→ Define Class Cat inherits Animal // 建立 Cat 子類別，繼承 Animal  \n→   → Override Method make_sound() // 覆寫父類別的聲音方法  \n→   →   → Print '喵～' // Cat 物件發出喵聲  \n→ End // 完成 Cat 子類別定義  \n\n→ Instantiate dog = Dog() // 建立 Dog 物件  \n→   → Call dog.make_sound() // 呼叫 Dog 的聲音方法  \n→ Instantiate cat = Cat() // 建立 Cat 物件  \n→   → Call cat.make_sound() // 呼叫 Cat 的聲音方法  \n\nEnd // 程式執行結束",
      "generated_code": "class Animal:\n    def make_sound(self):\n        print('動物發出聲音')\n\nclass Dog(Animal):\n    def make_sound(self):\n        print('汪汪！')\n\nclass Cat(Animal):\n    def make_sound(self):\n        print('喵～')\n\ndef main():\n    import sys\n    # 讀取並忽略所有輸入；程式不依賴於輸入內容\n    _ = sys.stdin.read()\n    \n    dog = Dog()\n    cat = Cat()\n    dog.make_sound()\n    cat.make_sound()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "汪汪！\n喵～",
          "success": true,
          "output": "汪汪！\n喵～"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 0,
    "title": "溫度判斷",
    "description_snippet": "請寫一個程式，輸入一個整數代表氣溫，並依下列規則輸出：\n- 小於 0：『冰點以下』\n- 0~29：『正常範圍』\n- 30~39：『炎熱』\n- 大於等於 40：『極端高溫』...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code with explanations per line. Use Start, Decision, arrow syntax. Must not output real code. Use the specified format. Provide steps: Start, input temperature, decision chain with thresholds. Use \"Yes →\" and \"No →\" appropriately. End. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Provide in Traditional Chinese. Use the arrow and indentation. We'll structure like:\n\nStart\n→ Step 1: 輸入氣溫整數 // 取得使用者輸入的氣溫\n→ Decision: 氣溫 < 0? // 判斷是否低於冰點\n    Yes → Step 2: 輸出 '冰點以下' // 低於冰點時輸出訊息\n    No  → Decision: 氣溫 <= 29? // 0~29 範圍判斷\n        Yes → Step 3: 輸出 '正常範圍' // 正常範圍輸出\n        No  → Decision: 氣溫 <= 39? // 30~39 判斷\n            Yes → Step 4: 輸出 '炎熱' // 炎熱輸出\n            No  → Step 5: 輸出 '極端高溫' // 大於等於40輸出\nEnd\n\nMake sure each line ends with // 解釋. Provide \"虛擬碼步驟\". For the Decision lines, we should include // explanation. For No → we need to align. Use indentation with spaces. Provide arrow with spaces. Let's create lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入氣溫整數 // 從使用者取得氣溫輸入\n→ Decision: 氣溫 < 0? // 判斷氣溫是否低於冰點\n    Yes → Step 2: 輸出 '冰點以下' // 輸出冰點以下訊息\n    No  → Decision: 氣溫 <= 29? // 判斷是否在正常範圍內\n        Yes → Step 3: 輸出 '正常範圍' // 輸出正常範圍訊息\n        No  → Decision: 氣溫 <= 39? // 判斷是否為炎熱區間\n            Yes → Step 4: 輸出 '炎熱' // 輸出炎熱訊息\n            No  → Step 5: 輸出 '極端高溫' // 輸出極端高溫訊息\nEnd // 程式執行結束\n\nWe need to ensure each line includes \"虛擬碼步驟\". The example uses no labels for each step. The user said: each line must contain: \"虛擬碼步驟\" + space + \"// 解釋\". So we must prepend \"虛擬碼步驟\" before each line? Wait the example didn't have \"虛擬碼步驟\" text. They wrote lines like \"Start // 程式開始執行\". So I think they mean \"虛擬碼步驟\" as a placeholder to denote the step, not literally writing \"虛擬碼步驟\". So just write the step like \"Start\", \"→ Step 1: ...\", etc. That's what the example shows. So we will output as above. Ensure proper indentation and arrow. Use spaces for alignment of Yes/No branches.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入氣溫整數 // 從使用者取得氣溫輸入  \n→ Decision: 氣溫 < 0? // 判斷氣溫是否低於冰點  \n  Yes → Step 2: 輸出 '冰點以下' // 輸出冰點以下訊息  \n  No → Decision: 氣溫 <= 29? // 判斷是否在正常範圍內  \n    Yes → Step 3: 輸出 '正常範圍' // 輸出正常範圍訊息  \n    No → Decision: 氣溫 <= 39? // 判斷是否為炎熱區間  \n      Yes → Step 4: 輸出 '炎熱' // 輸出炎熱訊息  \n      No → Step 5: 輸出 '極端高溫' // 輸出極端高溫訊息  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    try:\n        temp_line = sys.stdin.readline()\n        if not temp_line:\n            return\n        temp = int(temp_line.strip())\n    except Exception:\n        return\n    if temp < 0:\n        print(\"冰點以下\")\n    elif temp < 30:\n        print(\"正常範圍\")\n    elif temp < 40:\n        print(\"炎熱\")\n    else:\n        print(\"極端高溫\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "35",
          "expected_output": "炎熱",
          "success": true,
          "output": "炎熱"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 1,
    "title": "三數最大值",
    "description_snippet": "請寫一個程式，輸入三個整數，輸出其中最大的數字。不得使用 Python 內建 max()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate step-by-step pseudocode with arrows. Use Start, Decision, Yes→, No→. Provide explanation in Chinese. We cannot use max. Should compare. Steps: input a,b,c. Set max=a. Compare b>max → set max=b. Compare c>max → set max=c. Output max. End.\n\nLet's craft line-by-line with each line being a step or decision. Provide arrow. Explanation after //.\n\nExample format: \nStart // 程式開始執行\n→ Step 1: 輸入 a, b, c // 取得三個整數\n→ Step 2: 設定 max = a // 初始最大值為 a\n→ Decision: b > max? // 檢查 b 是否比目前最大大\n    Yes → Step 3: 設定 max = b // 若 b 更大，更新最大值\n    No  → // 保持 max\n→ Decision: c > max? // 檢查 c 是否比目前最大大\n    Yes → Step 4: 設定 max = c // 若 c 更大，更新最大值\n    No  → // 保持 max\n→ Step 5: 輸出 max // 顯示最大的數字\nEnd // 程式結束\n\nWe must use \"Yes →\" \"No →\". For No branch can just indicate comment.\n\nEnsure each line includes \"→\" or \"Yes →\" etc.\n\nAlso maybe Step 3 and Step 4 are under Yes branch; need to indent? In format, indentation maybe indicated by spaces. Provide each line separately.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 a, b, c // 取得三個整數  \n→ Step 2: 設定 max = a // 初始最大值設為 a  \n→ Decision: b > max? // 檢查 b 是否大於目前最大值  \n    Yes → Step 3: 設定 max = b // 若 b 更大，更新最大值  \n    No  → // 直接跳過，保持 max  \n→ Decision: c > max? // 檢查 c 是否大於目前最大值  \n    Yes → Step 4: 設定 max = c // 若 c 更大，更新最大值  \n    No  → // 直接跳過，保持 max  \n→ Step 5: 輸出 max // 顯示最大的數字  \nEnd // 程式結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有輸入，並以空白分隔為單詞\n    tokens = sys.stdin.read().strip().split()\n    if not tokens:               # 若沒有輸入則直接結束\n        return\n\n    # 只取前三個整數\n    a, b, c = map(int, tokens[:3])\n\n    # 先假設 a 為最大值\n    maximum = a\n\n    # 比較 b\n    if b > maximum:\n        maximum = b\n\n    # 比較 c\n    if c > maximum:\n        maximum = c\n\n    # 輸出最大的數字\n    print(maximum)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 25 7",
          "expected_output": "25",
          "success": true,
          "output": "25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 0,
    "title": "倍數輸出",
    "description_snippet": "請寫一個程式，輸入一個正整數 n，使用 for 迴圈搭配 range()，輸出 1~50 之間所有能被 n 整除的數字。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a structured step-by-step pseudo-code with explanations, as per the format. Use \"Start\", \"End\", \"Decision:\", \"→\". Each line includes code step plus explanation comment. The requirement: \"輸入一個正整數 n，使用 for 迴圈搭配 range()，輸出 1~50 之間所有能被 n 整除的數字。\" So steps: start, input n, for i in range(1,51): if i % n == 0: output i. Then end. Use virtual code syntax.\n\nMake sure each line has \"虛擬碼步驟\" plus \" // 解釋/說明\".\n\nSo produce something like:\n\nStart // 程式開始執行\n→ Input: n // 取得正整數 n\n→ For i in range(1, 51): // 迭代 1 到 50\n    → Decision: 如果 i mod n == 0? // 檢查 i 是否能被 n 整除\n        Yes → Output i // 輸出符合條件的數字\n        No  → (do nothing) // 不符合不輸出\nEnd // 程式結束\n\nNeed to be explicit \"→\" for each line. For nested lines maybe indent with tabs. Also each line's comment after //.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: n // 取得使用者輸入的正整數 n  \n→ For i in range(1, 51): // 迭代 1 到 50  \n  → Decision: 如果 i mod n == 0? // 檢查 i 是否能被 n 整除  \n   Yes → Output i // 輸出符合條件的數字  \n   No  → (無操作) // 不符合條件則不輸出  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    # 讀取使用者輸入的正整數 n\n    n = int(input().strip())\n    \n    # 收集 1~50 之間能被 n 整除的數字\n    divisible = [str(i) for i in range(1, 51) if i % n == 0]\n    \n    # 輸出結果，數字之間以空白分隔\n    print(' '.join(divisible))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "7",
          "expected_output": "7 14 21 28 35 42 49",
          "success": true,
          "output": "7 14 21 28 35 42 49"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 1,
    "title": "密碼檢查",
    "description_snippet": "請寫一個程式，讓使用者重複輸入密碼，直到輸入正確的密碼 'python123' 為止。每次輸入錯誤都提示『密碼錯誤，請再試一次』，輸入正確時輸出『登入成功』。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code for a program that repeatedly prompts the user to enter a password until the correct one 'python123' is entered. Each time wrong, prints \"密碼錯誤，請再試一次\". When correct, prints \"登入成功\". Use the specified format: Start, →, Decision, Yes →, No →, End. Provide each line with virtual code step and explanation after //. Must not output actual code. Just structured steps. Each line includes virtual code step and explanation. Use arrow arrows. Also, we need to include loops? We can use a while loop. Virtual code: Start, → Step 1: Initialize correct password 'python123' // define correct password, or we can just compare directly. But we can just keep looping. Use Decision: If input equals correct? Yes → Step 2: Output success End. No → Step 3: Output error, loop back.\n\nWe need to represent loop: perhaps using a while loop or a decision that loops back. Let's structure:\n\nStart\n→ Step 1: Prompt user to enter password // obtain input\n→ Decision: 密碼是否等於 'python123'? // check\n    Yes → Step 2: 輸出 '登入成功' // success\n    No → Step 3: 輸出 '密碼錯誤，請再試一次' // error\n    → Step 1 // loop back\n\nBut we need to use the arrow for loop: After No, we go back to Step 1. Use arrow: No → Step 1. But that may conflict with Step 1 being repeated. But okay.\n\nWe must label each line. Use Step 1, Step 2, Step 3. And End.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Prompt user for password // 取得使用者輸入的密碼  \n→ Decision: 密碼是否等於 'python123'? // 檢查輸入是否正確  \n    Yes → Step 2: Output '登入成功' // 成功訊息，結束程式  \n    No → Step 3: Output '密碼錯誤，請再試一次' // 錯誤提示  \n    No → Step 1 // 重新提示輸入，回到 Step 1  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    correct_password = 'python123'\n    while True:\n        try:\n            password = input()\n        except EOFError:\n            break\n        if password == correct_password:\n            print('登入成功')\n            break\n        else:\n            print('密碼錯誤，請再試一次')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "abc\n1234\npython123",
          "expected_output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功",
          "success": true,
          "output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 0,
    "title": "串列操作練習",
    "description_snippet": "請建立一個串列，內容包含整數 1 到 5，接著完成以下操作：\n1. 新增一個元素 6 到串列尾端。\n2. 刪除串列中的第 2 個元素（索引 1 的位置）。\n3. 輸出最後的串列結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce line-by-line virtual code with comments. The user says \"請建立一個串列，內容包含整數 1 到 5，接著完成以下操作：\n1. 新增一個元素 6 到串列尾端。\n2. 刪除串列中的第 2 個元素（索引 1 的位置）。\n3. 輸出最後的串列結果。\"\n\nWe output step by step with virtual code arrow syntax, no actual code. Just \"虛擬碼步驟\". Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. For this simple sequence no decisions.\n\nWe need to follow format: Each line: \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe must use arrow \"→\". For example:\nStart // 程式開始執行\n→ Step 1: 建立空串列 // 初始化空列表\n→ Step 2: 為索引 0-4 依序加入 1-5 // 填充初始元素\n... etc.\n\nBut we need to include \"虛擬碼步驟\" content. We can phrase: \"Start\" or \"Step 1\". Let's produce.\n\nWe need to ensure no actual code. Use pseudo-language.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化串列 List // 建立一個空列表\n→ Step 2: 從 1 到 5 依序加入 List // 填入 1,2,3,4,5\n→ Step 3: List.Append 6 // 將 6 加到尾端\n→ Step 4: List.RemoveAt 1 // 刪除索引 1 的元素 (第二個)\n→ Step 5: Output List // 顯示最後的列表內容\nEnd // 程式結束\n\nBut each line must have comment after \"//\". Use correct formatting. Provide them line by line. Ensure each line has \"虛擬碼步驟\" then a space then comment. Use arrow for each step: \"→ Step X\". The first line \"Start\". Last line \"End\". That meets.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 List // 建立一個空串列  \n→ Step 2: 從 1 到 5 依序加入 List // 填入 1、2、3、4、5  \n→ Step 3: List.Append 6 // 將 6 加到尾端  \n→ Step 4: List.RemoveAt 1 // 刪除索引 1（第二個元素）  \n→ Step 5: Output List // 輸出最後的串列結果  \nEnd // 程式結束執行",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取所有標準輸入，雖然此題不需要外部資料，但符合「必須從 stdin 讀取」的要求\n    _ = sys.stdin.read()\n\n    # 建立初始串列 [1, 2, 3, 4, 5]\n    nums = [1, 2, 3, 4, 5]\n\n    # 新增 6 到串列尾端\n    nums.append(6)\n\n    # 刪除索引 1 的元素（即第二個元素）\n    del nums[1]\n\n    # 輸出最終串列\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[1, 3, 4, 5, 6]",
          "success": true,
          "output": "[1, 3, 4, 5, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 1,
    "title": "集合函數練習",
    "description_snippet": "請建立一個集合 fruits = {'apple', 'banana'}，並完成以下操作：\n1. 使用 add() 新增 'orange'。\n2. 使用 update() 一次新增 'grape' 與...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, following format. Each line: virtual code step + space + comment // explanation. Use Start, End, Decision, arrows. For operations: initialize set, add, update, remove, discard, print. Provide step numbers? Not required. Just steps. Use arrow →. For decision maybe not needed. But we can include simple steps. Provide step names. Let's create:\n\nStart // 程式開始執行\n→ Step 1: Set fruits = {'apple', 'banana'} // 建立集合\n→ Step 2: Call fruits.add('orange') // 新增橘子\n→ Step 3: Call fruits.update(['grape', 'melon']) // 同時新增葡萄與哈密瓜\n→ Step 4: Call fruits.remove('banana') // 移除香蕉\n→ Step 5: Call fruits.discard('pineapple') // 嘗試移除不存在的菠蘿\n→ Step 6: Output fruits // 顯示最終集合\nEnd // 程式結束\n\nWe need to match format: Use virtual code step e.g. \"Start\". Use arrow \"→\". Provide comment after //. Ensure each line ends with comment. Provide line numbers? Not needed. Provide \"Decision:\" maybe not necessary. But we can keep simple steps.\n\nLet's format exactly. Ensure each line ends with comment. Use the exact syntax: `→ Step 1: ... // ...`.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set fruits = {'apple', 'banana'} // 建立初始集合 fruits  \n→ Step 2: Call fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: Call fruits.update(['grape', 'melon']) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: Call fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: Call fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'（不會拋錯）  \n→ Step 6: Output fruits // 輸出最終集合 fruits  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取輸入（即使此題不需要實際輸入，也保持通用性）\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 新增橘子\n    fruits.add('orange')\n\n    # 同時新增葡萄與哈密瓜\n    fruits.update(['grape', 'melon'])\n\n    # 移除香蕉\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的菠蘿（不會拋錯）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"apple\",\"grape\",\"melon\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'apple', 'grape', 'melon'}\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 0,
    "title": "質數判斷函數",
    "description_snippet": "請寫一個函數 is_prime(n)，判斷一個整數是否為質數。如果是質數回傳 True，否則回傳 False。\n\n質數定義：大於 1，且除了 1 和自己本身外，沒有其他因數。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations for is_prime(n). Each line: \"虛擬碼步驟 // 解釋\". Use arrow characters and decision structures. No actual code. Steps:\n\nStart\n→ Step 1: 判斷 n 是否小於等於 1 // 小於等於1非質數\nDecision: n <= 1?\nYes → Return False // 直接返回\nNo → Decision: n 等於 2 或 3? // 2,3 為質數\n    Yes → Return True\n    No → Decision: n 以 2 或 3 結尾? // 如果 n % 2 == 0 或 n % 3 == 0\n        Yes → Return False\n        No → Step 2: 設定 i = 5 // 從5開始\n→ Step 3: Decision: i * i <= n? // 只需檢查到 sqrt(n)\n    Yes → Decision: n % i == 0 或 n % (i+2) == 0? // 檢查 i 和 i+2\n        Yes → Return False\n        No → Step 4: i = i + 6 // 下一組候選因數\n        → Jump back to Step 3\n    No → Return True // 無因數找到，即質數\nEnd\n\nMake sure each line with // explanation.\n\nLet's craft. Use \"→\" arrow each line, but decisions should use \"Decision:\" lines.\n\nWe need to include \"Start\" and \"End\".\n\nMake sure arrow preceding lines.\n\nWe'll produce as:\n\nStart // 程式開始執行\n→ Step 1: 檢查 n 是否小於等於 1 // 小於等於1不是質數\n→ Decision: n <= 1? // 判斷是否非質數\n    Yes → Return False // 非質數直接返回\n    No → Decision: n 等於 2 或 3? // 2、3 是質數\n        Yes → Return True // 回傳質數\n        No → Decision: n 可被 2 或 3 整除? // 排除偶數和 3 的倍數\n            Yes → Return False // 不是質數\n            No → Step 2: 設定 i = 5 // 從 5 開始檢查\n→ Step 3: Decision: i * i <= n? // 只需檢查到 sqrt(n)\n    Yes → Decision: n % i == 0 或 n % (i + 2) == 0? // 檢查 i 與 i+2\n        Yes → Return False // 找到因數，非質數\n        No → Step 4: i = i + 6 // 移動到下一組候選因數\n        → Jump back to Step 3 // 重新檢查\n    No → Return True // 無因數，為質數\nEnd // 程式結束\n\nNeed to keep each line as \"虛擬碼步驟 // 解釋\". The \"→\" arrows used per line. For jumps maybe use \"→\" again.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 檢查 n 是否小於等於 1 // 小於等於1不是質數\n→ Decision: n <= 1? // 判斷是否為非質數\n    Yes → Return False // 非質數直接返回\n    No → Decision: n 等於 2 或 3? // 2、3 是質數\n        Yes → Return True // 回傳質數\n        No → Decision: n 可被 2 或 3 整除? // 排除偶數與 3 的倍數\n            Yes → Return False // 不是質數\n            No → Step 2: 設定 i = 5 // 從 5 開始檢查\n→ Step 3: Decision: i * i <= n? // 只需檢查到 sqrt(n)\n    Yes → Decision: n % i == 0 或 n % (i + 2) == 0? // 檢查 i 與 i+2\n        Yes → Return False // 找到因數，非質數\n        No → Step 4: i = i + 6 // 移動到下一組候選因數\n        → Jump back to Step 3 // 重新檢查\n    No → Return True // 無因數，為質數\nEnd // 程式結束",
      "generated_code": "import sys\n\ndef is_prime(n):\n    \"\"\"判斷 n 是否為質數，返回布林值。\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼並執行\n    user_code = sys.stdin.read()\n    exec(user_code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(is_prime(7))\nprint(is_prime(12))",
          "expected_output": "True\nFalse",
          "success": true,
          "output": "True\nFalse"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 1,
    "title": "計算平均分數",
    "description_snippet": "請寫一個函數 calc_avg(*scores)，接收多個分數作為參數，並回傳平均值 (四捨五入到小數點後 2 位)。\n\n限制：不可使用內建函數 sum()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, following format. Use arrow, Start, End. Use Decision steps? Might need loop to sum. No sum(). Use loop to accumulate. Also count length. Then compute avg = total / count. Then round to 2 decimals: use round? Round is built-in; maybe allowed? Not restricted. But we can compute manual? Use round(avg,2). Let's just use round. So implement.\n\nStructure: Start, Step: define function calc_avg, with variable total=0, count=0. For each score in scores: add to total, increment count. After loop, avg = total / count. rounded_avg = round(avg,2). Return rounded_avg. End.\n\nNeed virtual code steps: Start // ...\n→ Step: 定義函數 calc_avg(*scores) // 定義變數\n→ Step: total ← 0 // 初始化總分\n→ Step: count ← 0 // 初始化個數\n→ Step: for 每個 score in scores: // 遍歷所有分數\n    → Step: total ← total + score // 累加分數\n    → Step: count ← count + 1 // 計數增加\n→ Step: avg ← total / count // 計算平均值\n→ Step: rounded_avg ← round(avg, 2) // 四捨五入到小數點後 2 位\n→ Step: return rounded_avg // 回傳結果\nEnd // 程式結束\n\nBut each line must be `虛擬碼步驟 [空格] // 解釋/說明`. So we need to put the arrow `→` before step. So:\n\nStart // 程式開始執行\n→ Step: 定義函數 calc_avg(*scores) // 定義函數及參數\n→ Step: total ← 0 // 初始化總分\n→ Step: count ← 0 // 初始化個數\n→ Step: for score in scores: // 遍歷所有分數\n    → Step: total ← total + score // 累加分數\n    → Step: count ← count + 1 // 計數增加\n→ Step: avg ← total / count // 計算平均值\n→ Step: rounded_avg ← round(avg, 2) // 四捨五入到小數點後 2 位\n→ Step: return rounded_avg // 回傳結果\nEnd // 程式結束\n\nNeed to ensure no indentation? They used indentation in example but it's optional? They used arrow indent for nested steps. For for loop body we should indent with arrow? They used arrow within indentation? They wrote:\n\n```\n→ Step 2: ...\n    Yes → Step ...\n```\n\nSo for for loop body, we can indent with spaces. Use \"    → Step\" inside for.\n\nThus produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義函數 calc_avg(*scores) // 定義函數並接受不定長度的分數參數  \n→ Step: total ← 0 // 初始化總分為 0  \n→ Step: count ← 0 // 初始化分數個數為 0  \n→ Step: for score in scores: // 遍歷所有傳入的分數  \n    → Step: total ← total + score // 將當前分數累加到總分  \n    → Step: count ← count + 1 // 分數個數累加 1  \n→ Step: avg ← total / count // 計算平均值  \n→ Step: rounded_avg ← round(avg, 2) // 將平均值四捨五入到小數點後 2 位  \n→ Step: return rounded_avg // 回傳計算後的平均值  \nEnd // 程式執行結束",
      "generated_code": "def calc_avg(*scores):\n    \"\"\"計算傳入分數的平均值，並四捨五入到小數點後兩位。\"\"\"\n    total = 0          # 總分初始化為 0\n    count = 0          # 分數個數初始化為 0\n    for s in scores:   # 遍歷所有傳入的分數\n        total += s     # 累加分數\n        count += 1     # 個數累加 1\n    return round(total / count, 2)  # 計算平均值並四捨五入到 2 位小數\n\n\ndef main():\n    \"\"\"主函式：從 stdin 讀取程式碼並執行，輸出結果至 stdout。\"\"\"\n    import sys\n    code = sys.stdin.read()   # 讀取整個輸入\n    if code:\n        # 執行讀入的程式碼，讓 calc_avg 能在執行環境中被呼叫\n        exec(code, globals())\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(calc_avg(80, 90, 100))\nprint(calc_avg(70, 75, 85, 95))",
          "expected_output": "90.0\n81.25",
          "success": true,
          "output": "90.0\n81.25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 0,
    "title": "列表與條件生成式練習",
    "description_snippet": "請寫一個程式，建立一個包含 1 到 20 的整數列表，接著使用列表生成式（List Comprehension）產生一個新列表，只保留偶數並將它們平方後輸出結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanation. The user request: program that creates list 1 to 20, then list comprehension to keep evens and square them, output result. We output virtual code line by line, with arrow arrows. Use Start, End, Decision etc? For list creation and comprehension, we can use steps. They didn't mention loops. But we can do simple steps. Let's produce:\n\nStart\n→ Step 1: 建立數字列表1到20 // Create list [1..20]\n→ Step 2: 使用列表生成式篩選偶數並平方 // Create new list\n→ Step 3: 輸出新列表 // Output result\nEnd\n\nAlso we can illustrate that Step 2 uses comprehension: new_list = [x*x for x in numbers if x%2==0] but virtual code is generic. Also we might illustrate assignment. Provide arrow syntax. Provide explanation. They want arrow after each step. Use the arrow arrow. The format: 虛擬碼步驟 + space + // 解釋. The arrow symbol '→' before each step. For decisions, not needed. So produce lines.\n\nEnsure using繁體中文.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立整數列表 1~20 // 創建一個包含 1 到 20 的整數列表  \n→ Step 2: 使用列表生成式：new_list ← [x*x for x in numbers if x % 2 == 0] // 只保留偶數並將它們平方，產生新列表  \n→ Step 3: 輸出 new_list // 將結果輸出顯示給使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取標準輸入（如果有任何輸入可被忽略）\n    sys.stdin.read()\n\n    # 建立 1~20 的整數列表\n    nums = list(range(1, 21))\n\n    # 使用列表生成式篩選偶數並平方\n    result = [n * n for n in nums if n % 2 == 0]\n\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]",
          "success": true,
          "output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 1,
    "title": "map() / filter() / lambda 綜合練習",
    "description_snippet": "請寫一個程式，建立一個列表 numbers = [3, 7, 10, 15, 20]。\n1. 使用 filter() 搭配 lambda 篩選出可被 5 整除的數。\n2. 使用 map() 將這些數字...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step, following format:\n\nEach line: \"虛擬碼步驟 // 解釋\"\n\nWe need to use Start, End, Decision: etc. But here it's straightforward: create list, filter, map, output.\n\nWe can structure as:\n\nStart\n→ Step 1: 初始化 numbers list\n→ Step 2: 使用 filter with lambda to get divisible by 5\n→ Step 3: 使用 map with lambda to multiply by 10\n→ Step 4: 輸出結果\nEnd\n\nInclude explanation after each.\n\nWe need arrow notation: \"→\" at start of each line after Start? Format: \"Start // 程式開始執行\". Next lines: \"→ Step X: ...\" Each line ends with // explanation.\n\nSo produce.\n\nLet's produce lines.\n\nAlso we can include Decision? Not necessary but could include decision if we want to check if any divisible by 5. But not required.\n\nWe just follow simple.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 numbers = [3, 7, 10, 15, 20] // 初始化數字列表\n→ Step 2: filtered = filter(lambda x: x % 5 == 0, numbers) // 用 filter 和 lambda 篩選能被 5 整除的數\n→ Step 3: multiplied = map(lambda y: y * 10, filtered) // 用 map 和 lambda 將篩選後的數字乘以 10\n→ Step 4: result = list(multiplied) // 轉成列表以便輸出\n→ Step 5: 輸出 result // 顯示最終結果列表\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（若有輸入，則忽略，因為本題不需要任何外部資料）\n    _ = sys.stdin.read()\n    \n    # 建立固定的數字列表\n    numbers = [3, 7, 10, 15, 20]\n    \n    # 篩選出可被 5 整除的數字\n    filtered = filter(lambda x: x % 5 == 0, numbers)\n    \n    # 將篩選後的數字乘以 10\n    result = list(map(lambda x: x * 10, filtered))\n    \n    # 輸出最終結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[100, 150, 200]",
          "success": true,
          "output": "[100, 150, 200]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 0,
    "title": "JSON 檔案儲存與讀取練習",
    "description_snippet": "請寫一個程式，建立一個字典 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}。\n1. 使用 json.dump() 將其寫入 data.jso...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation in Chinese. Each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision. For this simple script: define dictionary, import json, open file for write, json.dump, close. Then open file for read, json.load, get name and city, print. No decisions needed. Provide line by line. Let's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import json // 導入 json 模組，提供序列化與反序列化功能  \n→ Step 2: data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立包含姓名、年齡、城市的字典  \n→ Step 3: with open('data.json', 'w', encoding='utf-8') as f: // 以寫入模式開啟 data.json 檔案，使用 UTF-8 編碼  \n  → Step 4: json.dump(data, f, indent=4) // 將 data 以 JSON 格式寫入檔案，並使用縮排方便閱讀  \n→ Step 5: with open('data.json', 'r', encoding='utf-8') as f: // 以讀取模式開啟已寫入的 data.json 檔案  \n  → Step 6: loaded_data = json.load(f) // 讀取 JSON 資料並解析回 Python 字典  \n→ Step 7: name = loaded_data['name'] // 從載入的資料中提取姓名  \n→ Step 8: city = loaded_data['city'] // 從載入的資料中提取城市  \n→ Step 9: print(f\"Name: {name}, City: {city}\") // 輸出姓名與城市資訊  \nEnd // 程式執行結束",
      "generated_code": "import json\nimport sys\n\ndef main() -> None:\n    # 讀取 stdin（此題無需實際輸入，僅遵循要求）\n    sys.stdin.read()\n\n    # 建立字典\n    data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}\n\n    # 將字典寫入 JSON 檔\n    with open('data.json', 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=4)\n\n    # 讀取 JSON 檔並取得資料\n    with open('data.json', 'r', encoding='utf-8') as f:\n        result = json.load(f)\n\n    # 輸出姓名與城市\n    print(f\"姓名： {result['name']}\")\n    print(f\"城市： {result['city']}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "姓名： Alice\n城市： Taipei",
          "success": true,
          "output": "姓名： Alice\n城市： Taipei"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 1,
    "title": "即時匯率查詢小工具",
    "description_snippet": "請使用 requests 模組串接匯率 API（https://api.exchangerate-api.com/v4/latest/USD），取得當前美元兌換台幣（TWD）的匯率。\n將結果顯示在 t...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line steps, using the arrow syntax, and comments. No actual code. The user wants to connect to exchangerate-api, get USD to TWD, display in tkinter window, update with button. We'll produce virtual steps:\n\nStart\n→ Import modules: requests, tkinter\n→ Create main window\n→ Create label to display rate\n→ Create button \"Refresh\"\n→ Define function refresh_rate: send GET request to API, parse JSON, get rates['TWD'], update label text\n→ Bind button to refresh_rate\n→ Call refresh_rate initially to display first rate\n→ Start mainloop\nEnd\n\nNeed to use Decision? Probably not needed. But we can add error handling decisions.\n\nMake sure each line has virtual code step + comment.\n\nAlso note use of arrows, maybe indentation for decision branches. But simple steps.\n\nLet's write:\n\nStart // 程式開始執行\n→ Import requests, tkinter // 載入需要的模組\n→ Create main window Tk() // 建立 tkinter 主視窗\n→ Create label variable rate_var = StringVar() // 用於顯示匯率的變數\n→ Create label with textvariable rate_var // 建立顯示匯率的標籤\n→ Pack or grid the label // 將標籤加入視窗\n→ Create button \"Refresh\" // 建立更新按鈕\n→ Pack the button // 將按鈕加入視窗\n→ Define function refresh_rate(): // 定義更新匯率的函式\n    → Send GET request to https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料\n    → Decision: 如果請求成功? // 檢查 HTTP 狀態碼\n        Yes → Parse JSON response // 解析回傳的 JSON\n        → Extract rates['TWD'] // 取出台幣匯率\n        → Update rate_var with \"1 USD = X TWD\" // 更新顯示文字\n        No → Update rate_var with \"取得匯率失敗\" // 顯示失敗訊息\n→ Bind button click to refresh_rate // 把按鈕事件連到函式\n→ Call refresh_rate() // 初始取得並顯示匯率\n→ Start mainloop() // 啟動 tkinter 事件循環\nEnd // 程式執行結束\n\nNeed to ensure the format: Each line separate. For nested lines we can indent but still show arrow. Probably easier to maintain single lines. For function, we can use indentation but each line still \"→\".\n\nThe decision lines: \"Decision:\" maybe inside function. But we can show as separate lines. Let's produce.\n\nLet's output as requested.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import requests, tkinter // 載入需要的模組  \n→ Create main window Tk() // 建立 tkinter 主視窗  \n→ Create StringVar rate_var // 用於顯示匯率的變數  \n→ Create label with textvariable=rate_var // 建立顯示匯率的標籤  \n→ Pack the label // 將標籤加入視窗  \n→ Create button \"Refresh\" // 建立更新按鈕  \n→ Pack the button // 將按鈕加入視窗  \n→ Define function refresh_rate(): // 定義更新匯率的函式  \n→ Send GET request to https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料  \n→ Decision: 如果請求成功? // 檢查 HTTP 狀態碼  \n  Yes → Parse JSON response // 解析回傳的 JSON  \n   → Extract rates['TWD'] // 取出台幣匯率  \n   → Update rate_var with \"1 USD = X TWD\" // 更新顯示文字  \n  No  → Update rate_var with \"取得匯率失敗\" // 顯示失敗訊息  \n→ Bind button click to refresh_rate // 把按鈕事件連到函式  \n→ Call refresh_rate() // 初始取得並顯示匯率  \n→ Start mainloop() // 啟動 tkinter 事件循環  \nEnd // 程式執行結束",
      "generated_code": "import requests\nimport sys\n\ndef fetch_rate():\n    \"\"\"\n    從 exchangerate-api 取得 USD 對 TWD 的匯率。\n    若發生例外，回傳 None。\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取指令，若為「按下「更新匯率」按鈕」則取得並輸出匯率。\n    \"\"\"\n    # 讀取全部輸入\n    user_input = sys.stdin.read().strip()\n    # 檢查輸入指令\n    if user_input == '按下「更新匯率」按鈕':\n        rate = fetch_rate()\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n    else:\n        # 若輸入不是預期指令，直接不輸出任何結果\n        pass\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.76TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.76 TWD'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode306.json",
    "problem_index_in_file": 0,
    "title": "Additive Number",
    "description_snippet": "An additive number is a string whose digits can form an additive sequence.\n\nA valid additive sequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: determine if string is additive number. We need to output each line with explanation. So produce pseudocode with structure: Start, loops for first two numbers, recursion, etc. Use Decision arrows. Let's craft step-by-step algorithm:\n\n- Start\n- Input string s\n- For i from 1 to len-2: first number length\n   - If s[0]=='0' and i>1 skip\n   - num1=substr\n   - For j from 1 to len-i-1:\n        - If s[i]=='0' and j>1 skip\n        - num2=substr\n        - Call recursive check from position i+j\n   - If any recursive true return true\n- Return false\n\nRecursive function:\n- Input index, prev1, prev2\n- If index==len: return true\n- sum=prev1+prev2 as string\n- If s starting at index has sum as prefix: call recursively with new prev2=sum\n- else return false\n\nAdd decision steps.\n\nLet's produce lines accordingly.\n\nUse `→` arrow and indentation. Include Start and End.\n\nMake sure each line has \"虛擬碼步驟\" + space + `// 解釋/說明`.\n\nLet's generate.\n\nUse Start. Then Step 1: initialize length. Then loops. We'll structure.\n\nImportant: Provide each step line.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 len = s 的長度 // 取得輸入字串長度  \n→ Decision: 如果 len < 3? // Additive sequence 至少需三個數字  \n  Yes → Step 2: 回傳 False // 長度不足以成為有效序列  \n  No  → Step 3: 進入第一個數字的長度迴圈 // 從第二個數字開始嘗試各種長度  \n→ For i = 1 到 len - 2: // i 為第一個數字的長度  \n  Decision: 如果 s[0] 為 '0' 且 i > 1? // 檢查首數字是否有前導零  \n   Yes → Continue // 跳過無效長度  \n   No → Step 4: 取得 first = s 的前 i 個字元並轉為整數 // 第一個數字  \n    → Step 5: 進入第二個數字的長度迴圈  \n    → For j = 1 到 len - i - 1: // j 為第二個數字長度  \n      Decision: 如果 s[i] 為 '0' 且 j > 1? // 檢查第二個數字是否有前導零  \n       Yes → Continue // 跳過無效長度  \n       No → Step 6: 取得 second = s 的第 i 到 i+j 個字元並轉為整數 // 第二個數字  \n        → Step 7: 呼叫 RecursivelyCheck(i + j, first, second)  \n         Decision: 如果 RecursivelyCheck 回傳 True? // 確認後續序列有效  \n          Yes → Step 8: 回傳 True // 成功找到合法序列  \n          No → Continue // 試下一個第二個數字長度  \n→ Step 9: 回傳 False // 所有組合皆失敗  \n→ End // 程式結束  \n\n// RecursivelyCheck 函式定義  \nStart // RecursivelyCheck 開始  \n→ Step 10: 如果 index == len? // 已遍歷完整字串  \n  Yes → Step 11: 回傳 True // 成功構成完整序列  \n  No  → Step 12: 計算 sumStr = (prev1 + prev2) 的字串表示 // 下一個預期數字  \n    → Decision: 如果 s 從 index 開頭的子字串是否以 sumStr 為前綴?  \n     Yes → Step 13: 呼叫 RecursivelyCheck(index + sumStr.length, prev2, sumStr 的整數值) // 進一步驗證  \n       Decision: 如果 RecursivelyCheck 回傳 True?  \n        Yes → Step 14: 回傳 True // 整個遞迴成功  \n        No → Step 15: 回傳 False // 失敗  \n     No  → Step 16: 回傳 False // 無法符合下一個預期數字  \n→ End // RecursivelyCheck 結束  \n\n// 說明：上面虛擬碼通過兩層迴圈遍歷可能的首兩個數字長度，並使用遞迴驗證其餘數字是否符合加法規則，避免前導零並確保至少三個數字。若任何路徑成功，最終返回 True；否則返回 False。",
      "generated_code": "import sys\n\ndef is_additive_number(num: str) -> bool:\n    n = len(num)\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            first, second = num[:i], num[i:j]\n            # 前導零檢查\n            if (len(first) > 1 and first[0] == '0') or (len(second) > 1 and second[0] == '0'):\n                continue\n            k = j\n            while k < n:\n                sum_str = str(int(first) + int(second))\n                if not num.startswith(sum_str, k):\n                    break\n                k += len(sum_str)\n                first, second = second, sum_str\n            if k == n:\n                return True\n    return False\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n    s = data.strip()\n    # 若輸入含雙引號或單引號則移除\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n    result = is_additive_number(s)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"112358\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"199100199\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode739.json",
    "problem_index_in_file": 0,
    "title": "Daily Temperatures",
    "description_snippet": "Given an array of integers temperatures represents the daily temperatures, return an array answer su...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the daily temperatures problem. Use a stack approach. Provide step-by-step virtual code lines with explanations. Must use structure Start, End, Decision, etc. Let's write:\n\nStart\n→ Step 1: 初始化堆疊S為空 // 存儲未匹配的日子索引\n→ Step 2: 建立答案陣列answer長度n，初始值0 // 預設無暖天\n→ Step 3: 從第0日到第n-1日遍歷每日溫度T[i]\n    → Decision: 是否有未匹配的日子在堆疊上? // 檢查堆疊是否為空\n        Yes → Step 4: 設置currentIndex為堆疊頂\n            → Decision: T[i] > T[currentIndex]? // 新溫度是否比堆疊頂高\n                Yes → Step 5: answer[currentIndex] = i - currentIndex // 計算等待天數\n                    → Step 6: pop堆疊頂 // 已解決\n                    → Step 7: 回到 Decision: 是否有未匹配的日子? // 可能還有多個舊日子\n                No  → Step 8: 跳出迴圈 // 仍未解決，停止\n        No  → Step 9: push i到堆疊 // 新日子進入堆疊\n→ Step 10: 完成遍歷\nEnd\n\nBut need to show each line with \"虛擬碼步驟\" and explanation after //. Use arrows for decisions.\n\nLet's write with indentations. Use proper line breaks.\n\nNeed to adhere to format: Each line: \"虛擬碼步驟 // 解釋\". Use \"→\" before each step.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化堆疊S為空 // 用來儲存尚未找到暖日的日子索引  \n→ Step 2: 建立答案陣列answer，長度為n，全部設定為0 // 預設所有日子都找不到暖日  \n→ Step 3: 從 i = 0 到 n-1 遍歷每天的溫度 T[i] // 逐日處理  \n  → Decision: S 是否為空？ // 判斷堆疊中是否還有未解決的日子  \n   Yes → Step 4: currentIndex ← S.top() // 取堆疊頂端的日子索引  \n    → Decision: T[i] > T[currentIndex]？ // 新溫度是否比堆疊頂高  \n     Yes → Step 5: answer[currentIndex] ← i - currentIndex // 計算等待天數  \n      → Step 6: S.pop() // 已經找到暖日，從堆疊中移除  \n      → Step 7: 回到 Decision: S 是否為空？ // 可能還有多個舊日子需要檢查  \n       (No 迴圈結束，繼續外層遍歷)  \n    No → Step 8: 跳出內層 Decision // 仍未找到暖日，暫停檢查  \n   No → Step 9: S.push(i) // 把今天的索引加入堆疊，等待未來暖日  \n→ Step 10: 完成遍歷 // 所有日子已處理完畢  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def dailyTemperatures(self, temperatures):\n        n = len(temperatures)\n        res = [0] * n\n        stack = []  # 儲存尚未找到暖日的日子索引\n        for i, temp in enumerate(temperatures):\n            # 找到比當前天更暖的日子\n            while stack and temp > temperatures[stack[-1]]:\n                idx = stack.pop()\n                res[idx] = i - idx\n            stack.append(i)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    temperatures = ast.literal_eval(data)  # 解析輸入的列表\n    result = Solution().dailyTemperatures(temperatures)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[73,74,75,71,69,72,76,73]",
          "expected_output": "[1,1,4,2,1,1,0,0]",
          "success": true,
          "output": "[1, 1, 4, 2, 1, 1, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "[30,40,50,60]",
          "expected_output": "[1,1,1,0]",
          "success": true,
          "output": "[1, 1, 1, 0]"
        },
        {
          "example_index": 2,
          "input": "[30,60,90]",
          "expected_output": "[1,1,0]",
          "success": true,
          "output": "[1, 1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode71.json",
    "problem_index_in_file": 0,
    "title": "Simplify Path",
    "description_snippet": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Y...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step for simplifying Unix path. We need each line: virtual step and comment. Use arrows etc. We'll structure algorithm: Start → split by '/', process each component with stack, ignore empty and '.'; if '..' pop; else push component. At end, build result by joining stack with '/' prefixed. If stack empty, result '/'. Provide explanation. Let's produce.\n\nUse indentation for decisions: Yes → / No →. Provide start and end. Ensure each line ends with // explanation. Provide arrow '→' before each step. For decisions: \"Decision:\" lines. Use 'Yes →', 'No →'. Ok. We'll output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入的絕對路徑 // 取得待簡化的 Unix 路徑字串  \n→ Step 2: 初始化空棧 Stack // 用來儲存有效的目錄名稱  \n→ Step 3: 將路徑按 '/' 分割成元件列表 parts // 例如 \"/a//b/c\" 會得到 [\"\", \"a\", \"\", \"b\", \"c\"]  \n→ Decision: parts 是否為空? // 檢查是否真的有分割結果  \n    Yes → Step 4: 設定 result 為 '/' // 空路徑直接回傳根目錄  \n    No  → Step 5: 循環處理每個 component in parts // 逐一檢查並更新棧  \n→     Decision: component 是否為空字串? // 代表連續斜線  \n        Yes → Continue // 跳過此項目，避免重複斜線  \n        No  → Decision: component 為 \".\"? // 代表當前目錄  \n            Yes → Continue // 直接跳過  \n            No  → Decision: component 為 \"..\"? // 代表返回上層  \n                Yes → Decision: Stack 是否非空?  \n                    Yes → Step 6: 從 Stack 彈出最後一個目錄 // 移除上一層目錄  \n                    No  → Continue // 若已在根目錄則不做任何事  \n                No  → Step 7: 把 component 推入 Stack // 合法目錄或檔名，加入棧  \n→ Step 8: 若 Stack 為空則 result 為 '/' // 所有目錄已被移除，回到根  \n→ Decision: Stack 是否非空?  \n    Yes → Step 9: 將 Stack 以 '/' 連接，並在前面加 '/' 形成 result // 重新組合簡化路徑  \n    No  → Step 10: result 已在 Step 8 設定為 '/' // 路徑已處理完畢  \nEnd // 程式執行結束，result 為簡化後的 canonical path",
      "generated_code": "import sys\nimport re\n\ndef simplify_path(path: str) -> str:\n    \"\"\"\n    Simplify an absolute Unix-style path to its canonical form.\n    \"\"\"\n    stack = []\n    parts = path.split('/')\n\n    for part in parts:\n        if part == '' or part == '.':\n            continue            # ignore empty or current dir\n        elif part == '..':\n            if stack:\n                stack.pop()   # move to parent directory\n        else:\n            stack.append(part)  # valid directory name\n\n    return '/' + '/'.join(stack)\n\nif __name__ == \"__main__\":\n    # Read entire input, strip surrounding whitespace\n    raw_input = sys.stdin.read().strip()\n\n    # Extract the path string enclosed in double quotes\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        path_str = match.group(1)\n    else:\n        # If no quotes, assume the whole input is the path\n        path_str = raw_input.strip('\"')\n\n    # Compute simplified canonical path\n    result = simplify_path(path_str)\n\n    # Print the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "path = \"/home/\"",
          "expected_output": "\"/home\"",
          "success": true,
          "output": "/home"
        },
        {
          "example_index": 1,
          "input": "path = \"/home//foo/\"",
          "expected_output": "\"/home/foo\"",
          "success": true,
          "output": "/home/foo"
        },
        {
          "example_index": 2,
          "input": "path = \"/home/user/Documents/../Pictures\"",
          "expected_output": "\"/home/user/Pictures\"",
          "success": true,
          "output": "/home/user/Pictures"
        },
        {
          "example_index": 3,
          "input": "path = \"/../\"",
          "expected_output": "\"/\"",
          "success": true,
          "output": "/"
        },
        {
          "example_index": 4,
          "input": "path = \"/.../a/../b/c/../d/./\"",
          "expected_output": "\"/.../b/d\"",
          "success": true,
          "output": "/.../b/d"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode347.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Elements",
    "description_snippet": "Given an integer array nums and an integer k, return the k most frequent elements. You may return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving \"Top K frequent elements\" problem. We must provide step-by-step pseudocode lines with comments after each line. Format: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. We must produce line-by-line. Let's design.\n\nWe need to outline algorithm: Count frequencies using hash map. Build list of (num, freq). Use a heap or sort by freq. For k most frequent: can use min-heap of size k, or sort entire list. Use whichever. We'll produce generic pseudocode using min-heap. Steps: start, count frequencies, create min-heap, iterate over freq map: if heap size < k push, else if current freq > heap.min push/pop. After building heap, extract elements to result list. Return.\n\nWe'll produce pseudocode. Each line maybe like \"Start // 程式開始執行\". Then \"→ Step 1: 建立空頻率表 freqMap ← {} // 用於存儲每個數字的出現頻率\". Then \"→ Step 2: 對 nums 中每個數字 num 進行遍歷 // 遞增計數\". Then \"→ Decision: 若 num 已存在於 freqMap? // 判斷鍵是否已存在\". \"    Yes → freqMap[num] ← freqMap[num] + 1 // 已存在則加 1\". \"    No  → freqMap[num] ← 1 // 否則初始計數為 1\". Then after loop \"→ Step 3: 建立最小堆 minHeap ← empty // 用於維持前 k 個頻率最高的元素\". Then \"→ Step 4: 對 freqMap 中每個 (num, count) 進行遍歷\". \"→ Decision: 若 minHeap.size < k? // 堆還未滿 k\". \"    Yes → minHeap.push((count, num)) // 直接加入\". \"    No  → Decision: 若 count > minHeap.min.count? // 新元素頻率更高\". \"        Yes → minHeap.pop() // 移除最小頻率\". \"            → minHeap.push((count, num)) // 加入新元素\". \"        No  → No operation // 保持堆\". Then after building heap \"→ Step 5: 建立結果列表 result ← []\". \"→ Step 6: 從 minHeap 中提取所有元素並加入 result\". \"→ Decision: 若 minHeap 非空?\". \"    Yes → result.append(minHeap.pop().num) // 把數字加入結果\". \"    No  → End\". But we need to produce iterative extraction until empty.\n\nWe should express extraction loop: \"→ Decision: minHeap 非空? // 若還有元素\". \"    Yes → result.append(minHeap.pop().num)\". \"        → Decision: minHeap 非空? // 重複\". \"        ...\". But we can simplify: \"→ Step 7: 循環直到 minHeap 為空, 將每個 pop 的 num 加入 result\". Then \"→ End\".\n\nOk, produce lines. Use arrow \"→\". Let's produce.\n\nMake sure to use `Decision:` for conditions. Use `Yes →`, `No →` inside. Keep lines minimal but clear.\n\nLet's craft.\n\nAlso include \"Start // 程式開始執行\". Then steps. At the end \"End // 程式執行結束\". Ensure each line ends with `//` comment.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空頻率表 freqMap ← {} // 用於存儲每個數字的出現頻率  \n→ Step 2: 對 nums 中的每個數字 num 進行遍歷 // 逐一處理輸入陣列  \n  Decision: 若 num 已存在於 freqMap? // 判斷該數字是否已計數  \n   Yes → freqMap[num] ← freqMap[num] + 1 // 已存在則累加 1  \n   No  → freqMap[num] ← 1 // 否則初始化為 1  \n→ Step 3: 建立最小堆 minHeap ← empty // 用於保持前 k 個最高頻率元素  \n→ Step 4: 對 freqMap 中的每個 (num, count) 進行遍歷 // 處理所有頻率對  \n  Decision: 若 minHeap.size < k? // 堆還未滿 k  \n   Yes → minHeap.push((count, num)) // 直接加入堆中  \n   No  → Decision: 若 count > minHeap.min.count? // 新元素頻率更高  \n     Yes → minHeap.pop() // 移除最小頻率的元素  \n      → minHeap.push((count, num)) // 加入新元素  \n     No  → No operation // 保持堆不變  \n→ Step 5: 建立結果列表 result ← [] // 存放最終的 k 個頻率最高元素  \n→ Step 6: 循環從 minHeap 提取所有元素並加入 result // 取出所有堆中的元素  \n  Decision: minHeap 非空?  \n   Yes → result.append(minHeap.pop().num) // 把數字加入結果  \n    → Decision: minHeap 非空? // 重複提取直到堆空  \n     Yes → … // 同上  \n     No  → End // 提取完畢  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        \"\"\"Return the k most frequent elements in nums.\"\"\"\n        freq = Counter(nums)  # Count frequency of each number\n        # Retrieve the k largest items based on frequency\n        return [item for item, _ in heapq.nlargest(k, freq.items(), key=lambda x: x[1])]\n\ndef parse_input(data: str):\n    \"\"\"Extract nums list and integer k from input string.\"\"\"\n    # Find the first '[' and the last ']' to capture the list representation\n    start = data.find('[')\n    end = data.rfind(']')\n    nums = ast.literal_eval(data[start:end+1])  # safely parse list\n\n    # Search for the integer value of k\n    m = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    k = int(m.group(1)) if m else 0\n    return nums, k\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    nums, k = parse_input(raw)\n    solution = Solution()\n    result = solution.topKFrequent(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode752.json",
    "problem_index_in_file": 0,
    "title": "Open the Lock",
    "description_snippet": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3',...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to solve lock problem (like Leetcode 752). Use BFS, maintain visited, deadends set, queue, etc. Provide step-by-step. We'll output lines with \"Start\", \"→\" arrow etc.\n\nNeed to be careful with formatting. Provide each line: virtual code step + space + comment. Use arrow '→'. For decisions: \"Decision:\" lines. Use indent for nested branches maybe indent spaces. Example earlier used indentation.\n\nWe need to include Start, End. Provide steps:\n\n- Initialize deadend set.\n- Check if start in deadend: return -1.\n- If target is '0000': return 0.\n- Initialize queue with start and depth 0.\n- Mark visited start.\n- While queue not empty:\n  - pop current, depth.\n  - For each of 4 wheels:\n    - Generate next by rotating +1 and -1.\n    - If next == target: return depth+1.\n    - If next not in deadends and not visited: add to queue, mark visited.\n\n- After loop: return -1.\n\nWe should produce pseudo-code lines accordingly. Use arrow and Decision lines.\n\nWe need to format as requested. Each line: \"虛擬碼步驟\" then space then comment. Example earlier used \"Start // 程式開始執行\". We'll produce Chinese comments.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: deadSet ← set(deadends) // 建立死結點集合\n→ Step 2: start ← '0000' // 初始鎖狀態\n→ Decision: 如果 start 在 deadSet? // 檢查起始碼是否為死結點\n    Yes → End ← -1 // 起始即為死結點，無法開鎖\n    No  →\n→ Decision: 如果 target 為 '0000'? // 目標即為起始狀態\n    Yes → End ← 0 // 已開鎖\n    No  →\n→ Step 3: queue ← [(start, 0)] // BFS 隊列，存 (狀態, 步驟數)\n→ Step 4: visited ← {start} // 記錄已訪問的狀態\n→ Decision: queue 是否為空? // 檢查 BFS 是否結束\n    No →\n        → Step 5: current, steps ← queue.pop_front() // 取出首個狀態\n        → Step 6: for i in [0,1,2,3] // 遍歷四個輪\n            → Step 7: nextPlus ← rotate(current, i, +1) // 轉一格向上\n            → Step 8: if nextPlus == target? // 檢查是否達到目標\n                Yes → End ← steps + 1 // 找到最短路徑\n                No  →\n                    → Decision: nextPlus 在 deadSet 或 visited? // 檢查有效性\n                        Yes → // 跳過\n                        No  →\n                            → Step 9: queue.append((nextPlus, steps+1)) // 加入隊列\n                            → Step 10: visited.add(nextPlus) // 標記已訪問\n            → Step 11: nextMinus ← rotate(current, i, -1) // 轉一格向下\n            → Step 12: if nextMinus == target? // 檢查是否達到目標\n                Yes → End ← steps + 1\n                No  →\n                    → Decision: nextMinus 在 deadSet 或 visited?\n                        Yes → \n                        No  →\n                            → Step 13: queue.append((nextMinus, steps+1))\n                            → Step 14: visited.add(nextMinus)\n        → Decision: queue 是否為空? // 迴圈結束條件\n            Yes → End ← -1 // 所有可能已探索完仍未到目標\n            No  →\n→ End // 程式結束\n\nNeed to maintain proper indentation: Use spaces for nested decisions. In sample, they used indent of 4 spaces for nested lines. We'll replicate.\n\nAlso use arrow for steps: \"→ Step ...\". For decision we use \"→ Decision:\" lines.\n\nWe need to ensure we don't include actual code, just pseudo steps. Provide comment.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: deadSet ← set(deadends) // 建立死結點集合  \n→ Step 2: start ← '0000' // 初始鎖狀態  \n→ Decision: 如果 start 在 deadSet? // 檢查起始碼是否為死結點  \n Yes → End ← -1 // 起始即為死結點，無法開鎖  \n No →  \n→ Decision: 如果 target 為 '0000'? // 目標即為起始狀態  \n Yes → End ← 0 // 已開鎖  \n No →  \n→ Step 3: queue ← [(start, 0)] // BFS 隊列，存 (狀態, 步驟數)  \n→ Step 4: visited ← {start} // 記錄已訪問的狀態  \n→ Decision: queue 是否為空? // 檢查 BFS 是否結束  \n No →  \n  → Step 5: current, steps ← queue.pop_front() // 取出首個狀態  \n  → Step 6: for i in [0,1,2,3] // 遍歷四個輪  \n   → Step 7: nextPlus ← rotate(current, i, +1) // 轉一格向上  \n   → Step 8: if nextPlus == target? // 檢查是否達到目標  \n    Yes → End ← steps + 1 // 找到最短路徑  \n    No →  \n     → Decision: nextPlus 在 deadSet 或 visited? // 檢查有效性  \n      Yes → // 跳過  \n      No →  \n       → Step 9: queue.append((nextPlus, steps+1)) // 加入隊列  \n       → Step 10: visited.add(nextPlus) // 標記已訪問  \n    → Step 11: nextMinus ← rotate(current, i, -1) // 轉一格向下  \n    → Step 12: if nextMinus == target? // 檢查是否達到目標  \n     Yes → End ← steps + 1  \n     No →  \n      → Decision: nextMinus 在 deadSet 或 visited?  \n       Yes →  \n       No →  \n        → Step 13: queue.append((nextMinus, steps+1))  \n        → Step 14: visited.add(nextMinus)  \n  → Decision: queue 是否為空? // 迴圈結束條件  \n   Yes → End ← -1 // 所有可能已探索完仍未到目標  \n   No →  \nEnd // 程式結束",
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def openLock(self, deadends, target):\n        dead = set(deadends)\n        if '0000' in dead:\n            return -1\n        queue = deque([('0000', 0)])\n        visited = {'0000'}\n        while queue:\n            state, steps = queue.popleft()\n            if state == target:\n                return steps\n            for i in range(4):\n                digit = int(state[i])\n                for move in (-1, 1):\n                    new_digit = (digit + move) % 10\n                    new_state = state[:i] + str(new_digit) + state[i+1:]\n                    if new_state not in dead and new_state not in visited:\n                        visited.add(new_state)\n                        queue.append((new_state, steps + 1))\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Execute the input line to define deadends and target\n    exec(data, globals())\n    solution = Solution()\n    result = solution.openLock(deadends, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"",
          "expected_output": "6",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmphoalu60x.py\", line 28, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "deadends = [\"8888\"], target = \"0009\"",
          "expected_output": "1",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpd4n4vekb.py\", line 28, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    deadends = [\"8888\"], target = \"0009\"\n    ^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"",
          "expected_output": "-1",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpa09orahj.py\", line 28, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode380.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1)",
    "description_snippet": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool inser...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for RandomizedSet. Use Start, Decision, etc. Provide step-by-step logic. Need to include insert, remove, getRandom, with average O(1). Data structures: array/list to store values; hashmap from val to index in array. For insert: check map, if exists return false; else push to array, set map[val]=size-1, return true. Remove: check map; if not exists return false; else get index; swap with last element; update map of last element to index; pop last; delete map entry; return true. getRandom: generate random index from 0 to size-1, return array[index].\n\nWe need to output virtual code line by line, with explanations. Let's produce code structure: Start; Step: Initialize data structures. For methods: Insert, Remove, GetRandom. Use decision arrows. Each line has comment. Ensure no actual code. Use virtual steps. Use \"←\" arrow or \"→\". We'll use \"→\" to indicate next step.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 0: 建立空陣列 elements 和空哈希表 idxMap // 用於儲存元素和其索引\n\nThen methods:\n\nInsert:\n→ Decision: val 已存在於 idxMap? // 檢查是否已存在\n    Yes → Step 1: return false // 已存在，插入失敗\n    No  → Step 2: 把 val 加入 elements // 將值加入陣列\n    → Step 3: idxMap[val] = elements.size - 1 // 記錄索引\n    → Step 4: return true // 插入成功\n\nRemove:\n→ Decision: val 存在於 idxMap? // 檢查是否存在\n    Yes → Step 1: index = idxMap[val] // 取得索引\n    → Step 2: lastVal = elements.last // 取得最後一個值\n    → Step 3: elements[index] = lastVal // 交換位置\n    → Step 4: idxMap[lastVal] = index // 更新最後一個值索引\n    → Step 5: elements.pop() // 移除最後一個元素\n    → Step 6: delete idxMap[val] // 刪除映射\n    → Step 7: return true // 刪除成功\n    No  → Step 8: return false // 元素不存在，刪除失敗\n\nGetRandom:\n→ Step 0: randIdx = random(0, elements.size-1) // 隨機產生索引\n→ Step 1: return elements[randIdx] // 返回隨機元素\n\nEnd // 程式結束\n\nBut we need to produce virtual code lines with explanation after each. Provide one line per step. Use arrows for transitions. For decision, include Yes and No branches.\n\nLet's structure: Use indentation? They didn't require indentation, but can show with spaces.\n\nWe'll output as per example: each line \"虛擬碼步驟 // 解釋\". So we produce lines like:\n\nStart // 程式開始執行\n→ Step 0: 建立空陣列 elements 和空哈希表 idxMap // 用於儲存元素和其索引\n\nThen decision etc.\n\nLet's craft.\n\nAlso ensure each line has \"→\" before step? In example they had \"→ Step 1:\" lines. Use same.\n\nFor decision: \"→ Decision: ...\" and then sub-lines with indentation. But we can still produce each line as separate lines: decision line, then branch lines with indent? We can represent indentation with spaces before \"Yes →\" etc. Example from specification: they show indented lines:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // ...\n    No  → Decision: ...\n\nThus we can produce similar.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 建立空陣列 elements 和空哈希表 idxMap // 用於儲存元素及其索引  \n\n// ---------- insert ----------\n→ Decision: val 已存在於 idxMap? // 檢查元素是否已在集合  \n    Yes → Step 1: return false // 已存在，插入失敗  \n    No  → Step 2: elements.append(val) // 將新值加入陣列  \n        → Step 3: idxMap[val] = elements.size - 1 // 記錄新值的索引  \n        → Step 4: return true // 插入成功  \n\n// ---------- remove ----------\n→ Decision: val 存在於 idxMap? // 檢查元素是否在集合  \n    Yes → Step 1: index = idxMap[val] // 取得要移除值的索引  \n        → Step 2: lastVal = elements.last // 取得陣列最後一個值  \n        → Step 3: elements[index] = lastVal // 用最後一個值覆蓋要移除的位置  \n        → Step 4: idxMap[lastVal] = index // 更新最後一個值的新索引  \n        → Step 5: elements.pop() // 移除陣列最後一個元素  \n        → Step 6: idxMap.delete(val) // 刪除該值的映射  \n        → Step 7: return true // 移除成功  \n    No  → Step 8: return false // 元素不存在，移除失敗  \n\n// ---------- getRandom ----------\n→ Step 0: randIdx = random(0, elements.size - 1) // 隨機產生有效索引  \n→ Step 1: return elements[randIdx] // 返回隨機選中的元素  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # 1. 存放元素的列表\n        self.values = []\n        # 2. 元素到索引的映射\n        self.val_to_index = {}\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：兩個列表，中間以 '], ' 分隔\n    close_bracket = data.find(']')\n    ops_str = data[:close_bracket + 1]\n    params_str = data[close_bracket + 2:]\n\n    ops = ast.literal_eval(ops_str)\n    params = ast.literal_eval(params_str)\n\n    res = []\n    obj = None\n\n    for op, param in zip(ops, params):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(obj.insert(param[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(param[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n        else:\n            # 若有其他操作，可在此處處理\n            res.append(None)\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[None,True,False,True,2,True,False,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[None, True, False, True, 2, True, False, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode519.json",
    "problem_index_in_file": 0,
    "title": "Random Flip Matrix",
    "description_snippet": "There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to ran...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output pseudocode lines. Use Start, End, Decision. Provide line by line pseudocode with explanation after //.\n\nGoal: design algorithm for random flip without bias, minimizing random calls.\n\nStandard solution: use reservoir mapping from index to remaining indices. Map 0..m*n-1 to themselves initially. On flip: pick random r from [0, remaining-1]; swap mapping[r] with mapping[remaining-1] (or mapping[remaining-1] is 0). Return index mapping[r] as (i,j). Decrease remaining. Reset: clear map and set remaining=m*n.\n\nAlso use hashmap for mapping.\n\nWe must output virtual code line by line.\n\nWe'll produce a pseudocode structure: Start -> initialize variables: total, remaining, map. flip() pseudocode with random calls minimal. Use decision if map contains r etc. Provide explanation.\n\nWe'll produce code lines like:\n\nStart\n→ Step 1: Initialize total ← m × n // Total cells\n→ Step 2: Initialize remaining ← total // Cells still 0\n→ Step 3: Initialize map ← empty hashmap // Mapping from random index to actual index\n\nBut we need to structure into a class with constructor, flip, reset. Use blocks.\n\nWe need to use arrow lines with indentation? The example uses indentation for nested decisions. We'll follow.\n\nLet's design:\n\nStart // 程式開始執行\n→ Class Solution // 定義解決方案類別\n    → Constructor(m, n) // 初始化\n        → total ← m × n // 總格數\n        → remaining ← total // 仍為 0 的格數\n        → mapping ← empty hashmap // 將 0~total-1 映射\n    → Method flip() // 隨機翻轉\n        → idx ← random(0, remaining-1) // 取剩餘區間的隨機索引\n        → If idx in mapping? // 判斷是否已映射\n            Yes → val ← mapping[idx] // 若已映射，取得映射值\n            No  → val ← idx // 若未映射，使用自身\n        → last ← remaining-1 // 最後一個未翻轉的索引\n        → If last in mapping? // 取 last 的映射\n            Yes → lastVal ← mapping[last]\n            No  → lastVal ← last\n        → mapping[idx] ← lastVal // 把 idx 指向 last 的值\n        → Remove mapping[last] if exists // 清除 last 的映射\n        → remaining ← remaining - 1 // 減少剩餘\n        → Return [val / n, val % n] // 將一維索引轉為二維\n    → Method reset() // 重置\n        → remaining ← total // 重新設為全部\n        → mapping ← empty hashmap // 清空映射\nEnd // 程式結束\n\nAdd explanations after // for each line.\n\nWe need to follow format: each line: 虛擬碼步驟 [space] // 解釋.\n\nMake sure to use arrows properly. Indentation maybe not necessary but we can use indentation with spaces for readability.\n\nWe'll include Decision: lines for if conditions.\n\nLet's format:\n\nStart // 程式開始執行\n→ Class Solution // 定義解決方案類別\n    → Constructor(m, n) // 初始化\n        → total ← m × n // 總格數\n        → remaining ← total // 仍為 0 的格數\n        → mapping ← empty hashmap // 用於映射未翻轉的索引\n    → Method flip() // 隨機翻轉\n        → idx ← random(0, remaining-1) // 在剩餘格數中隨機選取\n        → Decision: idx 在 mapping 中? // 判斷 idx 是否已映射\n            Yes → val ← mapping[idx] // 若已映射，取得映射值\n            No  → val ← idx // 若未映射，使用自身\n        → last ← remaining-1 // 最後一個可用索引\n        → Decision: last 在 mapping 中? // 判斷 last 是否已映射\n            Yes → lastVal ← mapping[last] // 若已映射，取得映射值\n            No  → lastVal ← last // 若未映射，使用自身\n        → mapping[idx] ← lastVal // 把 idx 映射到 last 的值\n        → Decision: last 在 mapping 中? // 如 last 已映射，需要刪除\n            Yes → Remove mapping[last] // 刪除映射\n            No  → // 不需要刪除\n        → remaining ← remaining - 1 // 減少剩餘格數\n        → Return [val / n, val % n] // 轉換為行列索引\n    → Method reset() // 重置\n        → remaining ← total // 重新設為全部\n        → mapping ← empty hashmap // 清空映射\nEnd // 程式執行結束\n\nCheck format: We must put a space after each line before //. Also we must use arrow '→' after Start. For decisions we used \"Decision:\" lines and indentation.\n\nLet's ensure each line has exactly: virtual code step + space + // explanation.\n\nWe'll keep indentation for clarity but it's part of the virtual code step; the indentation should be part of the step text. The arrow '→' at beginning of line.\n\nMake sure to include arrow for inner lines? The example shows arrow only at start of each step, even within nested decisions. So we should prefix each line with '→' even for nested lines? The example: they used indent but same arrow. We'll replicate.\n\nThus lines like \"→ Decision: ...\". Then nested lines also have '→' and indentation? In example, they have:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: ...\n\nThey indent 'Yes →' etc but also arrow. So we should mimic that.\n\nThus for nested decision branches, we should indent and prefix with Yes → etc.\n\nLet's craft accordingly.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Class Solution // 定義解決方案類別\n    → Constructor(m, n) // 初始化\n        → total ← m × n // 總格數\n        → remaining ← total // 仍為 0 的格數\n        → mapping ← empty hashmap // 用於映射未翻轉的索引\n    → Method flip() // 隨機翻轉\n        → idx ← random(0, remaining-1) // 在剩餘格數中隨機選取\n        → Decision: idx 在 mapping 中? // 判斷 idx 是否已映射\n            Yes → val ← mapping[idx] // 若已映射，取得映射值\n            No  → val ← idx // 若未映射，使用自身\n        → last ← remaining-1 // 最後一個可用索引\n        → Decision: last 在 mapping 中? // 判斷 last 是否已映射\n            Yes → lastVal ← mapping[last] // 若已映射，取得映射值\n            No  → lastVal ← last // 若未映射，使用自身\n        → mapping[idx] ← lastVal // 把 idx 映射到 last 的值\n        → Decision: last 在 mapping 中? // 如 last 已映射，需要刪除\n            Yes → Remove mapping[last] // 刪除映射\n            No  → // 不需要刪除\n        → remaining ← remaining - 1 // 減少剩餘格數\n        → Return [val / n, val % n] // 轉換為行列索引\n    → Method reset() // 重置\n        → remaining ← total // 重新設為全部\n        → mapping ← empty hashmap // 清空映射\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n            # 仍為 0 的格數\n        self.mapping = {}             # 只對已被映射的索引存儲對應值\n\n    def flip(self):\n        # 在剩餘區間 [0, total-1] 隨機選取一個索引\n        r = random.randint(0, self.total - 1)\n\n        # 若 r 已映射，取其對應值；否則直接使用 r\n        val = self.mapping.get(r, r)\n\n        # 把最終未被翻轉的索引放到 r 位置\n        last = self.total - 1\n        last_val = self.mapping.get(last, last)\n        self.mapping[r] = last_val\n\n        # 若 last 位置曾被映射，需要把它從映射表中移除\n        if last in self.mapping:\n            del self.mapping[last]\n\n        self.total -= 1              # 失去一個 0 的格\n        return [val // self.n, val % self.n]  # 轉換回 (i, j)\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.mapping.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入拆分為兩個列表：方法名和對應參數\n    split_pos = data.find('],')\n    calls_part = data[:split_pos + 1]\n    args_part = data[split_pos + 2:].strip()\n\n    calls = json.loads(calls_part)\n    args_list = json.loads(args_part)\n\n    result = []\n    obj = None\n\n    for call, args in zip(calls, args_list):\n        if call == \"Solution\":\n            obj = Solution(args[0], args[1])\n            result.append(None)\n        elif call == \"flip\":\n            result.append(obj.flip())\n        elif call == \"reset\":\n            obj.reset()\n            result.append(None)\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [1, 0], [2, 0], null, [2, 0]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode735.json",
    "problem_index_in_file": 0,
    "title": "Asteroid Collision",
    "description_snippet": "We are given an array asteroids of integers representing asteroids in a row. The indices of the aste...",
    "examples_loaded": 4,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (not real code) for solving asteroid collision problem (LeetCode 735). We need to produce step-by-step virtual code with arrows and decisions, each line with explanation comment. Should be in Chinese Traditional. Each line like \"→ Step 1: ...\" etc. Use Start and End. We should incorporate stack logic. Steps:\n\nStart\n→ Initialize stack to empty\n→ Iterate over each asteroid in asteroids array\n    → If asteroid > 0:\n        → Push onto stack\n    → Else (asteroid < 0):\n        → While stack not empty and top > 0 and top < abs(asteroid):\n            → Pop stack\n        → If stack empty or top < 0:\n            → Push asteroid\n        → Else if top == abs(asteroid):\n            → Pop stack\n            → // both explode, do nothing else\n        → Else // top > abs(asteroid):\n            → // current asteroid explodes, do nothing\nEnd\n→ Return stack as list\n\nNeed to include each decision. Use \"Decision:\" lines.\n\nLet's produce lines accordingly. Use Chinese comments. Use arrows. Use \"Yes →\", \"No →\" for decisions. Ensure each line has \" // explanation\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空堆疊 stack // 用來儲存仍存活的彈星  \n→ Step 2: 迴圈遍歷陣列 asteroids，變數 asteroid 為目前彈星 // 逐一處理每顆彈星  \n\n    → Decision: 如果 asteroid > 0? // 正數表示向右移動  \n        Yes → Step 3: 將 asteroid 推入 stack // 右移彈星不會立刻碰撞  \n        No  → Decision: 如果 asteroid < 0? // 負數表示向左移動  \n\n            Yes → Step 4: 開始 while 迴圈  \n                    → Decision: 如果 stack 不是空且 stack.top > 0 且 stack.top < abs(asteroid)? // 右移彈星比左移彈星小  \n                        Yes → Step 5: 從 stack 彈出 top // 右移彈星被消滅  \n                        No  → // 不進入 while，跳出迴圈  \n\n            → Decision: 如果 stack 为空 或 stack.top < 0? // 沒有右移彈星或右移彈星已消滅  \n                Yes → Step 6: 將 asteroid 推入 stack // 左移彈星能存活  \n                No  → Decision: 如果 stack.top == abs(asteroid)? // 相等大小  \n                    Yes → Step 7: 從 stack 彈出 top // 兩顆都消滅  \n                    No  → // stack.top > abs(asteroid)  \n                        Step 8: // 目前左移彈星被消滅，直接跳過，保持 stack 不變  \n\nEnd // 程式執行結束  \n→ Step 9: 將 stack 轉成列表回傳 // 取得最終存活的彈星狀態",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def asteroidCollision(self, asteroids):\n        \"\"\"\n        使用堆疊模擬彈星碰撞。\n        堆疊頂部存放還未被消滅的彈星。\n        \"\"\"\n        stack = []\n        for a in asteroids:\n            # 如果是向左移動的彈星，可能會與堆疊中的右移彈星相撞\n            if a < 0:\n                # 只要堆疊頂部是右移彈星，且右移彈星比左移彈星小，則右移彈星先消滅\n                while stack and stack[-1] > 0 and stack[-1] < -a:\n                    stack.pop()\n                # 堆疊頂部是右移彈星且大小相同，兩者都消滅\n                if stack and stack[-1] > 0 and stack[-1] == -a:\n                    stack.pop()\n                    continue  # 目前左移彈星也消滅，跳過推入\n                # 堆疊頂部是右移彈星且更大，左移彈星消滅\n                if stack and stack[-1] > 0:\n                    continue\n            # 否則（向右移動或左移彈星在上面沒有右移彈星），直接推入堆疊\n            stack.append(a)\n        return stack\n\ndef parse_input(raw: str):\n    \"\"\"\n    從 'asteroids = [5,10,-5]' 這樣的字串中解析出列表。\n    \"\"\"\n    if '=' in raw:\n        raw = raw.split('=', 1)[1]\n    return ast.literal_eval(raw.strip())\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    asteroids = parse_input(raw_input)\n    result = Solution().asteroidCollision(asteroids)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "asteroids = [5,10,-5]",
          "expected_output": "[5,10]",
          "success": true,
          "output": "[5, 10]"
        },
        {
          "example_index": 1,
          "input": "asteroids = [8,-8]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "asteroids = [10,2,-5]",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        },
        {
          "example_index": 3,
          "input": "asteroids = [3,5,-6,2,-1,4]",
          "expected_output": "[-6,2,4]",
          "success": true,
          "output": "[-6, 2, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode45.json",
    "problem_index_in_file": 0,
    "title": "Jump Game II",
    "description_snippet": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at index ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code (pseudo) with step-by-step lines and explanation, per requirement. Use Start, Decision, End etc. Must not output actual code, only steps. Should explain algorithm: Greedy approach: maintain current max reach, steps, etc. The task: minimal jumps to reach end. We'll produce pseudo-code: start, set jumps=0, currentEnd=0, farthest=0, iterate i from 0 to n-2: update farthest, if i==currentEnd: jumps++, currentEnd=farthest. End. Provide explanation per line.\n\nWe need \"逐行輸出\" each line includes the virtual code step and // explanation. Use arrow \"→\". Each line must have the step then space then // explanation. Use indentation maybe for decisions? Example in sample uses indentation. Let's replicate that.\n\nWe need \"虛擬碼步驟\" then space then explanation. For loops, we can denote \"Loop: i from 0 to n-2\". For Decision we can indent. Provide arrow and maybe Yes/No lines.\n\nWe can't produce actual code. We need to use \"→\" arrow. Let's produce:\n\nStart // 程式開始\n\n→ Step 1: 初始化變數 jumps = 0, currentEnd = 0, farthest = 0 // 設定跳躍次數、目前可達最遠位置、未來最遠位置\n\n→ Loop i from 0 to n-2 // 只需遍歷到倒數第二個位置\n\n    → Update farthest = max(farthest, i + nums[i]) // 找出從 i 可以跳到的最遠位置\n\n    → Decision: i == currentEnd? // 目前已到達的最遠位置是否已被訪問\n\n        Yes → jumps++ // 需要一次跳躍才能繼續前進\n\n        Yes → currentEnd = farthest // 更新可達最遠位置\n\nEnd // 回傳 jumps\n\nBut we need to show return.\n\nLet's format.\n\nAlso may need \"Decision\" indentation. Provide \"→ Decision:\" then indent lines Yes/No.\n\nUse \"Yes →\". Provide \"No\" maybe none because decision just used to trigger update.\n\nBetter to express:\n\n→ Decision: i == currentEnd? // 已到達當前可達最遠點\n\n    Yes → jumps++ // 增加跳躍次數\n\n    Yes → currentEnd = farthest // 更新可達最遠點\n\nNo:  // nothing\n\nBut maybe we skip No.\n\nLet's produce final.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化變數 jumps = 0, currentEnd = 0, farthest = 0 // 設定跳躍次數、目前可達最遠索引、未來可達最遠索引\n→ Loop i from 0 to n-2 // 只需遍歷到倒數第二個位置\n    → Update farthest = max(farthest, i + nums[i]) // 找出從 i 可以跳到的最遠位置\n    → Decision: i == currentEnd? // 是否已到達目前已知的最遠可達點\n        Yes → jumps++ // 需要一次跳躍才能繼續前進\n        Yes → currentEnd = farthest // 更新目前可達最遠點\nEnd // 程式執行結束，回傳 jumps\n\n[備註] 這段虛擬碼使用貪心演算法，在一次遍歷中就能得到最小跳躍次數。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        jumps = 0          # 目前已經跳躍的次數\n        current_end = 0    # 目前已知可達到的最遠索引\n        farthest = 0       # 從已遍歷的索引能跳到的最遠位置\n\n        for i in range(n - 1):\n            farthest = max(farthest, i + nums[i])  # 更新未來最遠可達位置\n            if i == current_end:                  # 到達目前已知最遠點，需要再跳一次\n                jumps += 1\n                current_end = farthest            # 更新可達最遠點\n\n        return jumps\n\n\ndef parse_nums(input_str):\n    \"\"\"\n    從輸入字串中提取整數列表。預期格式類似：\n    'nums = [2,3,1,1,4]'\n    \"\"\"\n    match = re.search(r'\\[(.*?)\\]', input_str)\n    if not match:\n        # 如果沒有找到方括號，嘗試把整行視為逗號或空格分隔的數字\n        nums_str = re.findall(r'-?\\d+', input_str)\n    else:\n        nums_str = match.group(1).split(',')\n\n    # 把抓到的字串轉成整數\n    nums = [int(x.strip()) for x in nums_str if x.strip()]\n    return nums\n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 解析出 nums 列表\n    nums = parse_nums(raw_input)\n    # 計算最小跳躍次數\n    result = Solution().jump(nums)\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,3,0,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode495.json",
    "problem_index_in_file": 0,
    "title": "Teemo Attacking",
    "description_snippet": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets po...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. We should answer in Traditional Chinese. Each line: 虛擬碼步驟 + space + // 解釋. Use arrow and decision. Provide algorithm: iterate array, accumulate total poison seconds. For each attack, if timeSeries[i] <= previous_end + 1? Actually inclusive intervals [t, t+duration-1]. For overlapping attacks, overlapping seconds counted once. So logic: maintain prev_end = 0. total=0. For each attack t: if t > prev_end, no overlap: total += duration, prev_end = t+duration-1. else overlap: add t+duration-1 - prev_end, prev_end = t+duration-1. But careful: we add only non-overlap part. So algorithm: iterate i. If i==0: total = duration; prev_end = t+duration-1. Else: if t > prev_end: total += duration; else total += t+duration-1 - prev_end; prev_end = t+duration-1. That's solution.\n\nBut we need virtual code line-by-line, using arrows and decisions.\n\nAlso need to handle case array empty? Not specified; probably length >0. Could include Decision: if timeSeries empty? For completeness.\n\nWe produce virtual code: Start, Check empty, etc.\n\nLet's write.\n\nWe produce lines:\n\nStart // 程式開始\n\n→ Decision: 若 timeSeries 為空? // 判斷是否有攻擊\n\n    Yes → Return 0 // 沒有攻擊則毒素時間為 0\n\n    No → ...\n\nThen Initialize variables: total = 0; prev_end = -∞? Actually we can set prev_end = -1 to handle first attack.\n\nBut algorithm: For each attack i in timeSeries:\n\n→ Step: For each attack time t in timeSeries // 迭代攻擊時間\n\n→ Decision: t > prev_end? // 判斷是否與前一次毒效重疊\n\n    Yes → total += duration // 沒重疊，增加整個持續時間\n\n    No  → total += t + duration - 1 - prev_end // 重疊，只增加新部分\n\n→ Update: prev_end = t + duration - 1 // 更新毒劑結束時間\n\nAfter loop: Return total\n\nLet's produce line by line.\n\nAlso need to handle previous end initial value: set prev_end = -1 to ensure first attack always > prev_end.\n\nWe will include Step 1: Initialize total = 0, prev_end = -1.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 是否有攻擊時間？ // 檢查 timeSeries 是否為空  \n    Yes → Return 0 // 無攻擊，Ashe 不會被毒，直接結束  \n    No  →  \n\n→ Step: 初始化變數  \n    total = 0 // 總毒效秒數  \n    prev_end = -1 // 上一次毒效結束時間，初始為 -1  \n\n→ Step: 遍歷 timeSeries  \n    for 每個 t in timeSeries // 逐一處理 Teemo 的攻擊時間  \n\n→ Decision: t > prev_end? // 判斷此攻擊是否在前一次毒效結束之後  \n    Yes → total += duration // 不重疊，整個持續時間皆為毒  \n    No  → total += t + duration - 1 - prev_end // 重疊，只加上新延伸的秒數  \n\n→ Step: 更新 prev_end = t + duration - 1 // 設定本次攻擊後的毒效結束時間  \n\nEnd of loop  \n\n→ Step: Return total // 回傳 Ashe 受毒的總秒數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef find_poisoned_duration(timeSeries, duration):\n    \"\"\"\n    計算 Ashe 被毒的總秒數。\n    timeSeries：攻擊時刻的非遞減序列\n    duration：每次攻擊持續的毒效秒數\n    \"\"\"\n    if not timeSeries:\n        return 0\n\n    total = 0\n    prev_end = -1  # 上一次毒效結束時間（初始為 -1，保證第一個攻擊一定不重疊）\n\n    for t in timeSeries:\n        if t > prev_end:                     # 舊毒效已結束，新增完整 duration\n            total += duration\n        else:                                # 舊毒效仍在，僅新增未被覆蓋的時間\n            total += t + duration - 1 - prev_end\n        prev_end = t + duration - 1          # 更新毒效結束時間\n\n    return total\n\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 timeSeries 列表和 duration 整數。\n    支援類似 'timeSeries = [1,4], duration = 2' 的格式。\n    \"\"\"\n    pattern = r'timeSeries\\s*=\\s*(\\[.*?\\]),\\s*duration\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if match:\n        ts = ast.literal_eval(match.group(1))\n        dur = int(match.group(2))\n    else:\n        # 若正則表達式失敗，嘗試簡易拆分\n        try:\n            parts = data.split(',')\n            ts_part = parts[0].split('=')[1].strip()\n            dur_part = parts[1].split('=')[1].strip()\n            ts = ast.literal_eval(ts_part)\n            dur = int(dur_part)\n        except Exception:\n            ts, dur = [], 0\n    return ts, dur\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    timeSeries, duration = parse_input(data)\n    result = find_poisoned_duration(timeSeries, duration)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode424.json",
    "problem_index_in_file": 0,
    "title": "Longest Repeating Character Replacement",
    "description_snippet": "You are given a string s and an integer k. You can choose any character of the string and change it ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the described problem. We must produce step-by-step algorithm using sliding window probably. Provide lines of virtual code with explanation. Each line should be like \"Start // 程式開始執行\". We'll include steps: initialize variables, iterate over string with window, maintain count of most frequent char, shrink window when length - mostFreq > k, update answer. Finally output answer.\n\nWe need to ensure to use \"虛擬碼步驟\" and explanation after space. Use arrows for decisions.\n\nLet's craft:\n\nStart // begin\n\n→ Step 1: 定義 n = length(s) // string length\n→ Step 2: 初始化 left = 0, maxLen = 0, freq[26] = 0 // window start, answer, char frequencies\n→ Decision: 迭代 right from 0 到 n-1 // iterate over string\n    → Step 3: 增加 freq[s[right]]++ // add char to window\n    → Step 4: 更新 currentMax = max(currentMax, freq[s[right]]) // most frequent char count\n    → Decision: (right - left + 1) - currentMax > k? // window too large after changes\n        Yes → Step 5: 減少 freq[s[left]]-- // shrink window from left\n        Yes → Step 6: left++ // move left pointer\n        Yes → Step 7: 重複檢查直到條件滿足 // loop shrink\n    → Step 8: 更新 maxLen = max(maxLen, right - left + 1) // record best\nEnd // return maxLen\n\nBut we need \"虛擬碼步驟\" each line. Use \"→\" arrows. For Decision block, indent maybe with spaces. Each line should have explanation after //.\n\nWe should avoid \"return\" in virtual code? We can include \"Step 9: Return maxLen // 結果\" before End.\n\nLet's produce final output with lines as required.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 n = length(s) // 取得字串長度  \n→ Step 2: 初始化 left = 0, maxLen = 0, freq[26] = 0, currentMax = 0 // 設定滑動窗口與統計資料  \n→ Decision: 循環 right 於 0 至 n-1? // 逐個遍歷字串  \n&nbsp;&nbsp;&nbsp;Yes → Step 3: freq[s[right]]++ // 將右端字元加入頻率統計  \n&nbsp;&nbsp;&nbsp;Yes → Step 4: currentMax = max(currentMax, freq[s[right]]) // 更新窗口內最多字元數  \n&nbsp;&nbsp;&nbsp;Yes → Decision: (right - left + 1) - currentMax > k? // 判斷是否需收縮窗口  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: freq[s[left]]-- // 從左端移除字元頻率  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: left++ // 移動左端指標  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: 重複檢查 (回到 Decision) // 直到窗口合法  \n&nbsp;&nbsp;&nbsp;Yes → Step 8: maxLen = max(maxLen, right - left + 1) // 更新最長合法子字串長度  \n→ Step 9: Return maxLen // 輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = [0] * 26          # frequency of each letter in the current window\n        max_count = 0             # max frequency of a single letter in the window\n        left = 0                  # left boundary of the sliding window\n        res = 0                   # best answer found so far\n\n        for right, ch in enumerate(s):\n            idx = ord(ch) - ord('A')\n            count[idx] += 1\n            if count[idx] > max_count:\n                max_count = count[idx]\n\n            # If we need to replace more than k letters to make all same,\n            # shrink window from the left\n            while (right - left + 1) - max_count > k:\n                count[ord(s[left]) - ord('A')] -= 1\n                left += 1\n\n            # Update the best result\n            res = max(res, right - left + 1)\n\n        return res\n\ndef main() -> None:\n    data = sys.stdin.read()\n\n    # Extract the string s and integer k from the input text\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n\n    if not s_match or not k_match:\n        return\n\n    s = s_match.group(1)\n    k = int(k_match.group(1))\n\n    sol = Solution()\n    print(sol.characterReplacement(s, k))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode58.json",
    "problem_index_in_file": 0,
    "title": "Length of Last Word",
    "description_snippet": "Given a string s consisting of words and spaces, return the length of the last word in the string.\n\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Need to respond in Traditional Chinese. Provide virtual code. Must follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe need algorithm: find last word length in string s.\n\nSimplest: trim trailing spaces, find last space index, length = len(s)-1 - lastSpace.\n\nWe produce steps:\n\nStart\n→ Step 1: Trim trailing spaces from s // remove spaces at end\n→ Step 2: Find last space index in s // locate space before last word\n→ Decision: 如果沒有空格? // no space means entire string is one word\n    Yes → Step 3: length = length of s // 全字串即為最後一個單詞長度\n    No  → Step 4: length = len(s) - lastSpaceIndex - 1 // 距離最後空格的距離\n→ Step 5: 返回 length // 結果\n\nWe need to produce virtual code with \"Start\" and \"End\".\n\nLet's produce each line with arrow.\n\nMake sure to include decision indentation with Yes/No arrows.\n\nAlso note that \"虛擬碼步驟\" includes arrow and step description.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Trim trailing spaces from s // 移除字串末端的空白字元  \n→ Step 2: Find last space index in s // 找出最後一個空格的位置  \n→ Decision: 是否存在空格? // 判斷字串中是否還有空格  \n  Yes → Step 3: length = length of s // 沒有空格，整個字串即為最後一個單詞  \n  No  → Step 4: length = len(s) - lastSpaceIndex - 1 // 有空格，計算最後一個單詞的長度  \n→ Step 5: Return length // 回傳最後一個單詞的長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        \"\"\"\n        計算字串 s 中最後一個單詞的長度。\n        先移除首尾空白，若字串為空則回傳 0，否則以空白切割並取最後一個元素長度。\n        \"\"\"\n        s = s.strip()\n        if not s:\n            return 0\n        words = s.split()\n        return len(words[-1]) if words else 0\n\ndef extract_string_from_input(raw_input: str) -> str:\n    \"\"\"\n    從輸入字串中擷取第一個雙引號內的內容。\n    例如輸入 's = \"Hello World\"' 會回傳 'Hello World'。\n    \"\"\"\n    match = re.search(r'\"(.*?)\"', raw_input)\n    return match.group(1) if match else \"\"\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入的所有資料\n    raw_input = sys.stdin.read()\n    # 擷取其中的字串值\n    s = extract_string_from_input(raw_input)\n    # 計算並輸出最後一個單詞的長度\n    result = Solution().lengthOfLastWord(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello World\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"   fly me   to   the moon  \"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"luffy is still joyboy\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode33.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array",
    "description_snippet": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being pas...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for searching target in rotated sorted array. Use binary search with condition. We'll produce lines with \"Start\", \"→\" etc. We'll provide explanation after each line. Should be in Traditional Chinese. Let's craft the steps. We'll include decision branches. Use arrows and indentation. Provide clear steps: set left, right; while left <= right; mid; if nums[mid]==target; return mid; else check which side is sorted; decide search side. Use \"Decision:\" lines. We'll produce pseudocode lines. Use \"→\" arrow lines. Let's produce maybe around 15-20 lines. Ensure each line has explanation comment. We'll use Chinese explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 變數 left ← 0 // 設定左指標為陣列最左端  \n→ Step 2: 變數 right ← nums.length - 1 // 設定右指標為陣列最右端  \n→ Decision: 當 left ≤ right? // 判斷是否還有搜尋區間  \n    Yes → Step 3: 變數 mid ← left + (right - left) / 2 // 計算中點索引  \n    → Decision: nums[mid] = target? // 檢查中點是否為目標  \n        Yes → Step 4: 回傳 mid // 找到目標，結束搜尋  \n        No → Decision: nums[left] ≤ nums[mid]? // 判斷左半段是否為升序  \n            Yes → Decision: nums[left] ≤ target < nums[mid]? // 目標是否在左半段  \n                Yes → Step 5: right ← mid - 1 // 搜尋左半段  \n                No  → Step 6: left ← mid + 1 // 搜尋右半段  \n            No  → Decision: nums[mid] < target ≤ nums[right]? // 目標是否在右半段  \n                Yes → Step 7: left ← mid + 1 // 搜尋右半段  \n                No  → Step 8: right ← mid - 1 // 搜尋左半段  \n    No  → End // left > right 時，目標不存在  \nEnd // 程式執行結束，若未回傳則回傳 -1（可在外部處理）",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"\n        在可能被旋轉的升序整數陣列中搜尋 target。\n        使用二分搜尋，確保 O(log n) 時間複雜度。\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n\n            # 左半段有序\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # 右半段有序\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中擷取 nums 與 target\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*([-]?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        # 若格式不符合，嘗試直接 eval 兩個變數\n        try:\n            # 先把可能的逗號分隔符替換成空格\n            cleaned = data.replace(',', ' ')\n            parts = cleaned.split()\n            nums = ast.literal_eval(parts[0])\n            target = int(parts[1])\n        except Exception:\n            print(-1)\n            return\n    else:\n        nums_str, target_str = match.groups()\n        nums = ast.literal_eval(nums_str)\n        target = int(target_str)\n\n    solution = Solution()\n    result = solution.search(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [1], target = 0",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode676.json",
    "problem_index_in_file": 0,
    "title": "Implement Magic Dictionary",
    "description_snippet": "Design a data structure that is initialized with a list of different words. Provided a string, you s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrow arrows and decision, no actual code, just steps.\n\nWe need to design data structure that can support search with one edit difference. Approach: build dictionary of words, and for each word, generate all possible patterns with a wildcard for each position, mapping to count or list. Search: for each position, replace with wildcard and check if any dictionary word matches that pattern and not same word.\n\nSimpler: Build map from pattern to list of words. For search, iterate positions, replace char with '*' and look up pattern, check if any word in list is not same.\n\nImplement MagicDictionary class with methods.\n\nWe need virtual steps: Start, Step for constructor, Step for buildDict, Step for search. Inside search we iterate positions. We'll show decision whether pattern matches.\n\nWe must output virtual code only, no actual code. Provide explanation per line. Use arrow and indentation.\n\nLet's produce something like:\n\nStart\n→ Step 1: 初始化魔法字典 // 建立空的字典映射\n→ Step 2: 讀取單字陣列 // 接收不同的單字\n→ Decision: 如果字典為空? // 若無字可處理\n    Yes → End // 直接結束\n    No → For each word in dictionary // 逐字處理\n        → Step 3: 為單字生成所有「一位置為通配符」的模式 // 取代每個字元為 '*'\n        → Step 4: 將模式與單字關聯存入映射 // map[pattern] = list of words\nEnd\n\nSimilarly search.\n\nLet's produce more detailed.\n\nNeed to show arrow arrows and decisions. Use Start, End.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空的模式映射 Map<string, List<string>> patternMap // 用於存放所有「一個位置為通配符」的模式\n→ Step 2: 建立空的字典集合 Set<string> wordSet // 用於快速判斷完整字是否存在\n→ Step 3: 建構子 MagicDictionary() // 初始化時只建立兩個空資料結構\n    // 這一步完成後即完成建構子\n\n→ Step 4: 進入 buildDict(String[] dictionary) 方法 // 接收一組不同的單字\n    → Decision: dictionary 為空? // 若沒有單字可處理\n        Yes → End // 建構完成，結束建構過程\n        No  → For each word in dictionary // 逐字處理每個單字\n            → Step 5: 把 word 加入 wordSet // 以便後續直接判斷完整相符\n            → Step 6: 取字長 L = word.length\n            → For i from 0 to L-1 // 為每個位置產生模式\n                → Step 7: 建立 pattern = word[0..i-1] + '*' + word[i+1..L-1] // 以 '*' 取代第 i 個字元\n                → Step 8: patternMap[pattern] ← patternMap[pattern] ∪ {word} // 將單字加入對應模式的清單\n    → End // buildDict 完成\n\n→ Step 9: 進入 search(String searchWord) 方法 // 接收欲搜尋的字串\n    → Decision: searchWord 為空? // 若字串長度為 0\n        Yes → Return false // 無法改變一個字元得到任何單字\n        No  → For each index i in searchWord\n            → Step 10: 取字長 L = searchWord.length\n            → Step 11: 建立 pattern = searchWord[0..i-1] + '*' + searchWord[i+1..L-1] // 以 '*' 取代第 i 個字元\n            → Step 12: 取得 patternList = patternMap[pattern] // 所有在這個模式下的字\n            → Decision: patternList 是否為空? // 若無匹配模式\n                Yes → Continue // 試下個位置\n                No  → For each candidateWord in patternList\n                    → Decision: candidateWord ≠ searchWord? // 確保改變字元後字串不等於原本字串\n                        Yes → Return true // 找到符合條件的字，搜尋成功\n                        No  → Continue // 跳過與原字相同的字\n    → Return false // 所有位置都未找到符合條件的字，搜尋失敗\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        # 以單字長度作為索引，避免不必要的長度比對\n        self.words_by_len = {}\n\n    def buildDict(self, dictionary):\n        # 重新組織資料，確保每個長度只有一次初始化\n        self.words_by_len = {}\n        for word in dictionary:\n            self.words_by_len.setdefault(len(word), set()).add(word)\n\n    def search(self, searchWord):\n        l = len(searchWord)\n        # 若此長度不存在，直接返回 False\n        if l not in self.words_by_len:\n            return False\n        candidates = self.words_by_len[l]\n        for word in candidates:\n            diff = 0\n            # 逐字比對，早停優化\n            for a, b in zip(word, searchWord):\n                if a != b:\n                    diff += 1\n                    if diff > 1:\n                        break\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    # 讀取整個輸入並拆分成兩個列表\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 兩個列表之間以 '],' 分隔，保持原始格式\n    parts = raw.split('],', 1)\n    commands_str = parts[0].strip() + ']'\n    args_str = parts[1].strip()\n\n    commands = json.loads(commands_str)\n    args_list = json.loads(args_str)\n\n    results = []\n    magic_dict = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MagicDictionary\":\n            magic_dict = MagicDictionary()\n            results.append(None)  # constructor returns null\n        elif cmd == \"buildDict\":\n            magic_dict.buildDict(args)\n            results.append(None)  # method returns null\n        elif cmd == \"search\":\n            res = magic_dict.search(args)\n            results.append(res)\n        else:\n            # 不應該出現的命令，安全處理\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 可自動轉為 null、true、false\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpdhppgn4m.py\", line 67, in <module>\n    main()\n  File \"/tmp/tmpdhppgn4m.py\", line 54, in main\n    magic_dict.buildDict(args)\n  File \"/tmp/tmpdhppgn4m.py\", line 13, in buildDict\n    self.words_by_len.setdefault(len(word), set()).add(word)\nTypeError: unhashable type: 'list'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode672.json",
    "problem_index_in_file": 0,
    "title": "Bulb Switcher II",
    "description_snippet": "There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode steps. Steps: start, input n, presses. compute all possible statuses after exactly presses presses. We can think state space 2^n huge, but we can use linear algebra over GF(2). Each button corresponds to a vector; pressing combination results vector sum mod2. Number of distinct outcomes equals number of distinct sums of length presses from 4 vectors with repetition allowed. Since pressing order irrelevant, we can think number of distinct vectors achievable by using any multiset of size presses from 4 types. Equivalent to number of distinct linear combinations where coefficients are nonnegative integers summing to presses, modulo 2. So we need to count distinct sums of vectors v1..v4. We can model as 4x n matrix mod2. The set of achievable vectors is linear combinations of rows with coefficients c_i where c_i = parity of number of times button i pressed? Wait, pressing button twice cancels? Since flipping twice returns original. So only parity of presses of each button matters. But we also have constraint that total presses count is exactly presses, not just parity. So we need to count number of distinct vectors among all 4^presses sequences? Actually order doesn't matter for final state; only multiset counts mod2 matter for resulting vector. For each button i, let a_i = number of times pressed. Then final vector = a1*v1 + a2*v2 + a3*v3 + a4*v4 (mod 2). a_i are nonnegative integers summing to presses. But only parity of a_i matters for final vector; however constraint on sum imposes parity constraints. The set of achievable vectors equals { sum a_i*v_i | a_i≥0, Σ a_i=presses}. We can consider parity vector p_i = a_i mod 2. Then Σ a_i = presses => Σ (p_i + 2k_i)=presses => Σ p_i ≡ presses (mod 2). So parity vector p must have same parity as presses. For each such parity vector, we need to check if there exist nonnegative integers a_i with that parity and sum presses. That is possible if Σ p_i ≤ presses and presses-Σ p_i is even (since we can add 2 to any a_i). Also need a_i >=0. So condition: Σ p_i <= presses and presses ≡ Σ p_i (mod 2). That's it. For each parity vector satisfying that, the final vector is p1*v1 + p2*v2 + p3*v3 + p4*v4 (mod2). So number of distinct resulting vectors equals number of distinct linear combinations of the 4 vectors with parity vectors satisfying those constraints. Since there are at most 2^4=16 parity vectors, we can enumerate them. For each, if constraints satisfied, compute combination vector. Use set to deduplicate. Finally output set size.\n\nThus pseudocode steps: start, input n, presses. compute v1..v4 as bitstrings or boolean arrays length n. Then create empty set S. For p1 in {0,1} ... p4 in {0,1}: if (p1+p2+p3+p4)<=presses && (presses%2)==((p1+p2+p3+p4)%2): compute vector res = p1*v1 XOR p2*v2 XOR p3*v3 XOR p4*v4. add res to set. After loop, return size of set. Complexity O(16*n). Works.\n\nNow produce virtual code line by line. We need arrow lines. Provide explanation after each line. Use Start, End. Use Decision lines for conditions. Use nested loops. Provide bitset representation maybe as arrays. Provide set using e.g., HashSet.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: n, presses // 取得燈泡數量與按鈕總次數  \n→ Array v1[n] ← all 1s // Button 1: flip all bulbs  \n→ Array v2[n] ← [i%2==0 ? 1 : 0] // Button 2: flip even-indexed bulbs (2,4,…)  \n→ Array v3[n] ← [i%2==1 ? 1 : 0] // Button 3: flip odd-indexed bulbs (1,3,…)  \n→ Array v4[n] ← [ (i-1)%3==0 ? 1 : 0 ] // Button 4: flip bulbs where j = 3k+1  \n→ Set S ← empty // 用來儲存不同的燈泡狀態  \n→ For p1 in {0,1} // p1 表示 Button 1 的按壓奇偶性  \n    → For p2 in {0,1} // p2 表示 Button 2 的按壓奇偶性  \n        → For p3 in {0,1} // p3 表示 Button 3 的按壓奇偶性  \n            → For p4 in {0,1} // p4 表示 Button 4 的按壓奇偶性  \n                → Let sumP ← p1 + p2 + p3 + p4 // 目前奇偶總和  \n                → Decision: 是否可達成此奇偶組合? // 檢查總按壓數與奇偶限制  \n                    Yes → Condition: sumP ≤ presses && (presses % 2) == (sumP % 2)  \n                    Yes → Compute res ← XOR of v1,v2,v3,v4 weighted by p1..p4  \n                    Yes → Add res to set S // 若合法，加入結果集  \n                    No  → Skip // 不符合按壓次數/奇偶條件，忽略  \n→ Return |S| // 回傳不同可能的燈泡狀態數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_statuses(n: int, presses: int) -> int:\n    # Button 1: flip all bulbs\n    v1 = [1] * n\n    # Button 2: flip even-labelled bulbs (2,4,...)\n    v2 = [1 if (i + 1) % 2 == 0 else 0 for i in range(n)]\n    # Button 3: flip odd-labelled bulbs (1,3,...)\n    v3 = [1 if (i + 1) % 2 == 1 else 0 for i in range(n)]\n    # Button 4: flip bulbs j = 3k + 1\n    v4 = [1 if i % 3 == 0 else 0 for i in range(n)]\n\n    results = set()\n\n    # Enumerate all possible parity vectors (p1, p2, p3, p4)\n    for p1 in (0, 1):\n        for p2 in (0, 1):\n            for p3 in (0, 1):\n                for p4 in (0, 1):\n                    parity_sum = p1 + p2 + p3 + p4\n                    # Condition: parity sum <= presses and same parity as presses\n                    if parity_sum <= presses and (presses % 2) == (parity_sum % 2):\n                        # Compute resulting bulb state by XORing selected button vectors\n                        state = tuple(\n                            (p1 * v1[i] ^ p2 * v2[i] ^ p3 * v3[i] ^ p4 * v4[i])\n                            for i in range(n)\n                        )\n                        results.add(state)\n    return len(results)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) < 2:\n        return\n    n, presses = numbers[0], numbers[1]\n    ans = count_statuses(n, presses)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, presses = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode60.json",
    "problem_index_in_file": 0,
    "title": "Permutation Sequence",
    "description_snippet": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\n\nBy listing and labeling all o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode to find kth permutation sequence. We must produce each line with virtual code step plus comment. Use arrows, Decision etc. Format: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce a solution for generating kth permutation. Standard algorithm: factorial number system. Steps: compute factorials, build list of numbers 1..n, for i from 1..n: index = (k-1)/fact[n-i], pick numbers[index], append to result, remove from list, k = (k-1)%fact[n-i] +1.\n\nWe need to produce pseudocode lines. Let's write:\n\nStart\n→ Step 1: Initialize list numbers = [1..n] // numbers available\n→ Step 2: Compute factorial array fact[0..n] // fact[i] = i!\n→ Step 3: Adjust k = k - 1 // zero-based index\n→ Step 4: Initialize result = empty string // to build permutation\n→ Step 5: For i from 1 to n\n→     Decision: If i <= n? // loop condition\n→         Yes → Step 5.1: idx = k / fact[n - i] // index of chosen number\n→         Yes → Step 5.2: Append numbers[idx] to result // add chosen digit\n→         Yes → Step 5.3: Remove numbers[idx] from list // update list\n→         Yes → Step 5.4: k = k % fact[n - i] // update k for next iteration\n→         No → End of loop\nEnd // return result\n\nBut we need each line with arrow etc. Might need to show indentation. Use \"Decision:\" then Yes → Step etc. Use \"No → End\" etc.\n\nWe must produce as per format: Each line: \"虛擬碼步驟 // 解釋\". So for decision, we need a line \"Decision: ...\" then indentation.\n\nWe must include all lines; no real code. Use plain text.\n\nLet's craft.\n\nWe can include lines like:\n\nStart // 程式開始執行\n→ Step 1: Initialize list numbers = [1, 2, ..., n] // 建立 1~n 的數字列表\n→ Step 2: Compute factorial array fact[0..n] where fact[0] = 1, fact[i] = fact[i-1]*i // 先算階乘表\n→ Step 3: k = k - 1 // 轉換為 0 起始索引\n→ Step 4: result = \"\" // 用於累積結果\n→ Decision: i = 1 to n? // 開始迴圈\n    Yes → Step 5: idx = k / fact[n - i] // 計算目前位置的索引\n    Yes → Step 6: result += numbers[idx] // 把該數字加入結果\n    Yes → Step 7: Remove numbers[idx] from numbers // 移除已選數字\n    Yes → Step 8: k = k % fact[n - i] // 更新 k 為剩餘部分\n    No → End // 迴圈結束\nEnd // 回傳 result\n\nBut we might need to include more explicit steps. We can include \"i = i + 1\" line.\n\nLet's produce.\n\nAlso, the Decision: i <= n? But if we use for loop we might not need explicit decision. But the format demands Decision lines.\n\nWe can do:\n\nDecision: i <= n? // 是否還有位數未處理\nYes → Step 5: ...\n...\nNo → End\n\nWe also need to keep track of i. We'll include Step 4: i = 1 // 初始 i\n\nStep 5: idx = ... ; Step 6: result += ; Step 7: Remove ; Step 8: k = ... ; Step 9: i = i + 1\n\nThen Decision again.\n\nOk.\n\nLet's write final.\n\nWe must output only virtual code lines, no explanation beyond comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 list numbers = [1, 2, …, n] // 建立 1 到 n 的數字列表  \n→ Step 2: 初始化 factorial array fact[0] = 1; for i = 1 to n: fact[i] = fact[i-1] * i // 計算 0~n 的階乘  \n→ Step 3: k = k - 1 // 轉成 0 起始的索引  \n→ Step 4: result = \"\" // 用來累積最終排列  \n→ Step 5: i = 1 // 設定目前處理的位數  \n→ Decision: i <= n? // 判斷是否還有位數未處理  \n  Yes → Step 6: idx = k / fact[n - i] // 取得本位的索引  \n  Yes → Step 7: result += numbers[idx] // 將選中的數字加入結果  \n  Yes → Step 8: 移除 numbers[idx] from numbers // 更新可用數字列表  \n  Yes → Step 9: k = k % fact[n - i] // 更新 k 為剩餘部分  \n  Yes → Step 10: i = i + 1 // 前往下一位  \n  No → End // 所有位數已處理  \nEnd // 程式執行結束，返回 result",
      "generated_code": "import sys\nimport re\nimport math\n\ndef get_permutation(n: int, k: int) -> str:\n    \"\"\"\n    Return the k-th permutation of numbers 1..n in lexicographical order.\n    \"\"\"\n    numbers = list(range(1, n + 1))   # 可用數字列表\n    k -= 1                            # 轉成 0 起始的索引\n    result = []\n\n    for i in range(n, 0, -1):\n        fact = math.factorial(i - 1)          # (i-1)!\n        index = k // fact                     # 本位的索引\n        result.append(str(numbers.pop(index)))  # 加入結果並移除\n        k %= fact                             # 更新 k\n\n    return ''.join(result)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取所有文字\n    raw_input = sys.stdin.read()\n    # 用正則抓取所有整數，假設輸入至少包含兩個整數\n    numbers = list(map(int, re.findall(r'\\d+', raw_input)))\n    if len(numbers) < 2:\n        sys.exit(0)\n    n, k = numbers[0], numbers[1]\n    # 計算並輸出結果\n    print(get_permutation(n, k))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 3",
          "expected_output": "\"213\"",
          "success": true,
          "output": "213"
        },
        {
          "example_index": 1,
          "input": "n = 4, k = 9",
          "expected_output": "\"2314\"",
          "success": true,
          "output": "2314"
        },
        {
          "example_index": 2,
          "input": "n = 3, k = 1",
          "expected_output": "\"123\"",
          "success": true,
          "output": "123"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode744.json",
    "problem_index_in_file": 0,
    "title": "Find Smallest Letter Greater Than Target",
    "description_snippet": "You are given an array of characters letters that is sorted in non-decreasing order, and a character...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for this problem, in traditional Chinese explanation. Provide line-by-line with arrow and decision. Use Start, End, Decision. The code should not be actual code but pseudocode steps.\n\nWe need to handle the array letters sorted non-decreasing. target char. There are at least two different characters.\n\nReturn smallest character > target; if none, return first char. That is typical problem: Next Greater Letter with wrap-around.\n\nWe can do binary search: find first index > target. If found, return letters[i]; else return letters[0].\n\nSo pseudocode: Start, read letters array and target, maybe input; then Step: Use binary search boundaries low=0 high=len-1; While low <= high: mid = (low+high)//2; If letters[mid] > target: result = letters[mid]; high = mid-1; Else low = mid+1. After loop, if result found return it else return letters[0].\n\nAlternatively simpler: For each char in letters: if char > target: return char; after loop return letters[0]. That is linear but simpler.\n\nWe need to produce virtual code step-by-step. We must include arrow '→', Decision, Yes/No. Use Start, End.\n\nWe need each line: \"Step\" or \"Decision\" etc. Provide explanation after comment. Use Chinese.\n\nLet's produce a linear algorithm. We'll do:\n\nStart\n→ Step 1: 初始化指標 i = 0 // 設定循環索引\n→ Step 2: 取得 letters[0] 作為回傳預設值 // 若無符合，回傳首字元\n→ Decision: i < length of letters? // 循環是否還未到結尾\n    Yes → Decision: letters[i] > target? // 該字元是否大於目標\n        Yes → Step 3: 回傳 letters[i] // 找到第一個大於 target 的字元\n        No  → Step 4: i = i + 1 // 進一步索引\n    No  → Step 5: 回傳 letters[0] // 未找到，回傳首字元\nEnd\n\nBut the description says at least two different characters, but algorithm fine.\n\nNeed to include arrows and indentation maybe but they just use the example. Use arrow '→' before each step. The decision lines also use '→ Decision: ...'.\n\nLet's format.\n\nWe can also show binary search version:\n\nStart\n→ Step 1: low = 0, high = len(letters)-1, result = null // 初始化指標\n→ Decision: low <= high? // 進行二分搜尋\n    Yes → Step 2: mid = (low + high) // 2 // 計算中點\n          Decision: letters[mid] > target? // 比較中點字元與目標\n              Yes → Step 3: result = letters[mid]; high = mid - 1 // 更新結果並向左搜尋\n              No  → Step 4: low = mid + 1 // 向右搜尋\n    No  → Decision: result != null? // 搜尋結束，檢查是否找到\n        Yes → Step 5: 回傳 result // 回傳找到的字元\n        No  → Step 6: 回傳 letters[0] // 未找到，回傳首字元\nEnd\n\nWe need each line as single step. We need to include explanation after comment.\n\nLet's create final output. Ensure each line ends with comment after //.\n\nAlso we need to include the decision indent lines like the example: Yes → Step ... etc. They show \"Yes → Step 2: ...\" and \"No → Step 4: ...\".\n\nMake sure to use the arrow after \"Decision:\" lines. So structure:\n\nDecision: condition? // comment\n    Yes → Step ...\n    No  → Step ...\n\nWe must include the arrow inside the same line as Step, not separate line. For example:\n\nDecision: letters[mid] > target? // 比較中點字元與目標\n    Yes → Step 3: result = letters[mid]; high = mid - 1 // 更新結果並向左搜尋\n    No  → Step 4: low = mid + 1 // 向右搜尋\n\nOk.\n\nWe also need to use Start and End.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: low = 0, high = len(letters) - 1, result = null // 初始化二分搜尋指標與結果\n→ Decision: low <= high? // 判斷搜尋區間是否仍有效\n    Yes → Step 2: mid = (low + high) // 2 // 計算中點索引\n          Decision: letters[mid] > target? // 判斷中點字元是否大於目標字元\n              Yes → Step 3: result = letters[mid]; high = mid - 1 // 記錄可能的答案，繼續搜尋左半邊\n              No  → Step 4: low = mid + 1 // 繼續搜尋右半邊\n    No  → Decision: result != null? // 搜尋結束，判斷是否已找到符合條件的字元\n        Yes → Step 5: 回傳 result // 回傳第一個大於 target 的字元\n        No  → Step 6: 回傳 letters[0] // 未找到，回傳字母表最前面的字元\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nextGreatestLetter(self, letters, target):\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if letters[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return letters[left % len(letters)]\n\ndef parse_input(data):\n    # 提取 letters 列表\n    letters_match = re.search(r'letters\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not letters_match:\n        raise ValueError(\"Cannot find letters list in input\")\n    letters_str = letters_match.group(1)\n    letters = eval(letters_str)  # 只解析列表，安全假設輸入受控\n\n    # 提取 target 字符\n    target_match = re.search(r'target\\s*=\\s*\"(.+?)\"', data)\n    if not target_match:\n        raise ValueError(\"Cannot find target in input\")\n    target = target_match.group(1)\n\n    return letters, target\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    letters, target = parse_input(input_data)\n    result = Solution().nextGreatestLetter(letters, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"a\"",
          "expected_output": "\"c\"",
          "success": true,
          "output": "c"
        },
        {
          "example_index": 1,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"c\"",
          "expected_output": "\"f\"",
          "success": true,
          "output": "f"
        },
        {
          "example_index": 2,
          "input": "letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"",
          "expected_output": "\"x\"",
          "success": true,
          "output": "x"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode496.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element I",
    "description_snippet": "The next greater element of some element x in an array is the first greater element that is to the r...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code in pseudo steps. The problem: \"Next Greater Element I\" from Leetcode. We need to output step-by-step pseudocode with explanations. Use Start, End, Decision:, Yes →, No → arrows. Need to handle arrays. We need to find next greater element for each element in nums1. Approach: use stack to precompute next greater for all elements in nums2. Then for each element in nums1 get answer. Virtual code: start, build map from element to next greater value. Use stack for decreasing elements. Then answer array.\n\nWe'll produce steps:\n\nStart\n→ Step 1: 初始化空棧 stack // 用來追蹤未找到下一個更大元素的元素\n→ Step 2: 初始化空映射 nextMap // 存放每個 nums2 元素對應的下一個更大元素\n\nWe need to iterate nums2 from left to right? Usually right-to-left using stack. We can do right-to-left: for each element in reverse order:\n→ Decision: 是否需要遍歷 nums2 從右往左? // 以便在 stack 中存儲未處理元素\n\nWe'll produce a for loop: for i from nums2.length-1 downto 0\nInside:\n→ Step: while stack not empty and stack.top <= nums2[i] pop // 移除所有不大於當前元素\n→ Decision: 是否 stack 為空? // 如果空，則沒有更大元素\n    Yes → Step: nextMap[nums2[i]] = -1\n    No  → Step: nextMap[nums2[i]] = stack.top // stack.top 是下一個更大\n→ Step: push nums2[i] onto stack // 將當前元素加入棧\nAfter loop\n→ Step: 初始化答案陣列 ans 為 nums1.length\n→ For each idx in 0..nums1.length-1\n    → Step: ans[idx] = nextMap[nums1[idx]] // 取映射\n→ End\n\nWe also need to include Start, End.\n\nWe need each line with \"虛擬碼步驟\" + space + \"// 解釋\".\n\nLet's generate each line. Use arrow formatting like \"→\". Provide step labels.\n\nWill produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化空棧 stack // 用來追蹤未找到下一個更大元素的元素\n→ Step 2: 初始化空映射 nextMap // 存放每個 nums2 元素對應的下一個更大元素\n\nThen decision for reverse iteration. Use a for loop. Since we need step by step, we can express as Decision: 迴圈從最後一個元素到第一個? Yes. But better:\n\n→ Decision: 是否從 nums2 的最後一個元素開始? // 為了能使用棧找到右側更大元素\n\nWe can just do:\n\n→ For i from nums2.length-1 downto 0: // 逆向遍歷 nums2\n\nWithin:\n\n→ Step: while stack not empty and stack.top <= nums2[i] pop // 移除不大於當前元素的棧頂\n\n→ Decision: stack 為空? // 判斷是否還有更大元素可供\n\n    Yes → Step: nextMap[nums2[i]] = -1 // 沒有更大元素\n\n    No  → Step: nextMap[nums2[i]] = stack.top // 下一個更大元素\n\n→ Step: push nums2[i] onto stack // 將當前元素入棧，供左側元素使用\n\nAfter loop:\n\n→ Step 3: 初始化答案陣列 ans 為 nums1.length // 為結果準備空陣列\n\n→ For idx from 0 to nums1.length-1: // 逐個處理 nums1\n\n    → Step: ans[idx] = nextMap[nums1[idx]] // 直接查表取得答案\n\n→ End // 程式執行結束\n\nMake sure each line uses \"→\". Also include \"Decision:\" lines with Yes → No → arrows.\n\nWe need to be careful: The \"For i from ... \" line may not be a decision. It's a loop. We can just label it as \"Step\". But format requires \"→ Step:\".\n\nAlso the decision lines: \"Decision: stack 為空?\" then Yes → Next greater else No → etc.\n\nWe need to maintain indentation? Not necessary but we can indent to show structure.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空棧 stack // 用來追蹤未找到下一個更大元素的元素\n→ Step 2: 初始化空映射 nextMap // 存放每個 nums2 元素對應的下一個更大元素\n\n→ Decision: 迴圈從 nums2 的最後一個元素開始? // 這樣可以在棧中保留右側未處理元素\n    Yes → Step 3: 逆向遍歷 nums2（從 index nums2.length-1 到 0）\n        → Step 4: while stack 不是空且 stack.top <= nums2[i] 時 pop // 移除所有不大於當前元素的棧頂\n        → Decision: stack 為空? // 判斷是否還有更大元素可用\n            Yes → Step 5: nextMap[nums2[i]] = -1 // 沒有更大元素，設定為 -1\n            No  → Step 6: nextMap[nums2[i]] = stack.top // stack.top 為下一個更大元素\n        → Step 7: push nums2[i] 到 stack // 將當前元素入棧，供左側元素使用\n\n→ Step 8: 初始化答案陣列 ans 為 nums1.length // 為結果準備空陣列\n→ For idx 從 0 到 nums1.length-1\n    → Step 9: ans[idx] = nextMap[nums1[idx]] // 直接查表取得對應的下一個更大元素\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef next_greater_element(nums1, nums2):\n    stack = []\n    next_greater = {}\n    for num in nums2:\n        while stack and num > stack[-1]:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n    return [next_greater.get(x, -1) for x in nums1]\n\ndef parse_input(text):\n    nums1_match = re.search(r'nums1\\s*=\\s*\\[([^\\]]*)\\]', text)\n    nums2_match = re.search(r'nums2\\s*=\\s*\\[([^\\]]*)\\]', text)\n    nums1 = []\n    nums2 = []\n    if nums1_match:\n        nums1 = [int(x.strip()) for x in nums1_match.group(1).split(',') if x.strip()]\n    if nums2_match:\n        nums2 = [int(x.strip()) for x in nums2_match.group(1).split(',') if x.strip()]\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    result = next_greater_element(nums1, nums2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "success": true,
          "output": "[-1, 3, -1]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "success": true,
          "output": "[3, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode658.json",
    "problem_index_in_file": 0,
    "title": "Find K Closest Elements",
    "description_snippet": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the ar...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code, but pseudocode with arrows. We need to implement algorithm: Given sorted array arr, find k closest to x. Approach: binary search to find insertion point, then use two pointers. We'll produce steps: Start, Input, binary search to find left index of x. Then set left = idx-1, right=idx. Then loop k times: choose closer between arr[left] and arr[right], handle boundaries. After loop, sort result ascending (since may be unsorted due to selection). End.\n\nWe need each line with virtual code step plus // explanation. Use Start, Decision, etc.\n\nLet's craft:\n\nStart\n→ Step 1: 輸入 arr, k, x // 取得輸入資料\n→ Step 2: BinarySearchInsertIndex = binarySearch(arr, x) // 找到 x 的插入位置\n→ Decision: 若 BinarySearchInsertIndex == 0? // 檢查左邊界\n    Yes → left = 0\n    No  → left = BinarySearchInsertIndex - 1\n→ Decision: 若 BinarySearchInsertIndex == len(arr)? // 檢查右邊界\n    Yes → right = len(arr) - 1\n    No  → right = BinarySearchInsertIndex\n→ Step 3: result = [] // 初始化結果集合\n→ Decision: k > 0? // 是否還需要選取元素\n    Yes → loop until k == 0:\n        → Decision: left < 0? // 沒左邊可選\n            Yes → result.add(arr[right]); right += 1; k -= 1\n            No  → Decision: right >= len(arr)? // 沒右邊可選\n                Yes → result.add(arr[left]); left -= 1; k -= 1\n                No  → Decision: |arr[left] - x| <= |arr[right] - x]? // 比較距離\n                    Yes → result.add(arr[left]); left -= 1; k -= 1\n                    No  → result.add(arr[right]); right += 1; k -= 1\n    No  → // nothing\n→ Step 4: result.sortAscending() // 排序結果\n→ End\n\nBut we need to format with arrows and indentation. Use `→` and `Decision:`. Indent sub-steps with spaces. Ensure each line ends with // 解釋.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 arr, k, x // 取得輸入資料  \n→ Step 2: BinarySearchInsertIndex = binarySearch(arr, x) // 找到 x 的插入位置（可用二分搜尋）  \n\n→ Decision: BinarySearchInsertIndex == 0? // 檢查左邊界是否為第一個位置  \n Yes → left = 0 // 若插入位置在最前面，左指標設為 0  \n No  → left = BinarySearchInsertIndex - 1 // 否則左指標設為插入位置前一個  \n\n→ Decision: BinarySearchInsertIndex == len(arr)? // 檢查右邊界是否已越界  \n Yes → right = len(arr) - 1 // 若已越界，右指標設為最後一個位置  \n No  → right = BinarySearchInsertIndex // 否則右指標設為插入位置  \n\n→ Step 3: result = [] // 初始化結果集合  \n\n→ Decision: k > 0? // 判斷是否還有元素需要挑選  \n Yes →  \n  Loop 循環直到 k == 0:  \n   → Decision: left < 0? // 左指標已越界  \n    Yes → result.add(arr[right]); right += 1; k -= 1 // 只能取右邊元素  \n    No →  \n     → Decision: right >= len(arr)? // 右指標已越界  \n      Yes → result.add(arr[left]); left -= 1; k -= 1 // 只能取左邊元素  \n      No →  \n       → Decision: |arr[left] - x| <= |arr[right] - x|? // 比較距離與等距時取較小的值  \n        Yes → result.add(arr[left]); left -= 1; k -= 1 // 取左邊較近或較小的數值  \n       No → result.add(arr[right]); right += 1; k -= 1 // 取右邊較近的數值",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef find_closest_elements(arr, k, x):\n    \"\"\"\n    找到距離 x 最近的 k 個元素（已排序的 arr）\n    使用滑動窗口二分搜尋（時間 O(log n)）\n    \"\"\"\n    left, right = 0, len(arr) - k          # window 的左端指標\n    while left < right:\n        mid = (left + right) // 2\n        # 若左邊的第 mid 個元素離 x 太遠，右移窗口\n        if x - arr[mid] > arr[mid + k] - x:\n            left = mid + 1\n        else:\n            right = mid\n    return arr[left:left + k]\n\ndef parse_input(data):\n    \"\"\"\n    從形如 'arr = [1,2,3], k = 4, x = 3' 的字串中解析出 arr、k、x\n    \"\"\"\n    # 取得列表字串\n    list_match = re.search(r'\\[.*?\\]', data)\n    if not list_match:\n        raise ValueError(\"無法找到陣列表示\")\n    arr = ast.literal_eval(list_match.group())\n\n    # 取得 k\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not k_match:\n        raise ValueError(\"無法找到 k 的值\")\n    k = int(k_match.group(1))\n\n    # 取得 x\n    x_match = re.search(r'x\\s*=\\s*(-?\\d+)', data)\n    if not x_match:\n        raise ValueError(\"無法找到 x 的值\")\n    x = int(x_match.group(1))\n\n    return arr, k, x\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    arr, k, x = parse_input(data)\n    result = find_closest_elements(arr, k, x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "success": true,
          "output": "[1, 2, 3, 4]"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "success": true,
          "output": "[1, 1, 2, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode93.json",
    "problem_index_in_file": 0,
    "title": "Restore IP Addresses",
    "description_snippet": "A valid IP address consists of exactly four integers separated by single dots. Each integer is betwe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: generate all valid IP addresses from a string of digits by inserting dots. We produce step-by-step pseudo-code with explanation after each line. No actual code. Use Start, Decision, etc. Provide algorithm maybe backtracking. We'll produce steps: Start, define result list, call backtrack with parameters (path, start). Inside backtrack: if length of path==4: check if start==len(s), add joined string to result. Else if start>=len(s) return. Loop i from 1 to 3: if start+i > len(s): break; take substring s[start:start+i]; if leading zero and len>1 skip; if int(substring)>255 skip; else call backtrack with path+ [segment], start+i. After recursion, return result. Provide explanation lines.\n\nWe must not output actual code, but virtual steps. Use arrow formatting. Each line: \"虛擬碼步驟 // 解釋\". Provide structured steps.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 定義結果列表 result = [] // 用於儲存所有有效 IP\n→ Step 2: 呼叫 Backtrack( path=[], index=0 ) // 開始遞迴搜尋\n...\nDefine Backtrack function: etc.\n\nWe should include decisions: if len(path)==4, if index==len(s) add. else return. Also loops.\n\nLet's produce each line carefully.\n\nWe need to use \"→\" arrow and \"Decision:\" where appropriate. Provide comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義結果列表 result = [] // 用來收集所有合法的 IP  \n→ Step 2: 呼叫 Backtrack( path = [], index = 0 ) // 從字串開始搜尋  \n\n→ Step 3: 定義 Backtrack( path, index ) // 進行遞迴搜尋  \n→ Decision: 是否已放置四段? // 檢查是否已形成四個段落  \n    Yes → Decision: 是否已使用完所有字元? // 檢查是否已到字串末尾  \n        Yes → Step 4: 將 path 組合成 IP 並加入 result // 成功的 IP，加入結果  \n        No  → Step 5: 返回 // 四段已滿但未到末尾，無效路徑  \n    No  → Decision: index 是否已達字串長度? // 檢查是否還有字元可用  \n        Yes → Step 6: 返回 // 仍未形成四段但字串已用完，無效路徑  \n        No  → Step 7: for len_seg in 1 to 3 // 試圖取 1 到 3 個數字作為下一段  \n\n→ Step 8: 計算 end = index + len_seg  \n→ Decision: end 是否超過字串長度? // 防止越界  \n    Yes → Break // 不能再取更長的段，結束迴圈  \n\n→ Step 9: segment = s[index : end] // 取得目前段  \n→ Decision: segment 是否以 '0' 開頭且長度>1? // 檢查前導零  \n    Yes → Continue // 這個段無效，嘗試下一長度  \n    No  → Step 10: value = int(segment) // 轉為整數  \n→ Decision: value 是否 > 255? // 檢查範圍  \n    Yes → Continue // 段值太大，嘗試下一長度  \n    No  → Step 11: 呼叫 Backtrack( path + [segment], end ) // 深入遞迴  \n\nEnd // 程式執行結束，result 已包含所有合法 IP  \n→ Step 12: 回傳 result // 給呼叫者所有可行的 IP 地址",
      "generated_code": "import sys\nimport json\n\ndef restore_ip_addresses(s: str):\n    \"\"\"\n    Return all possible valid IP addresses that can be formed by inserting dots into the given string s.\n    \"\"\"\n    res = []\n\n    def backtrack(start, path):\n        # If we have 4 parts and used all characters, add to result\n        if start == len(s) and len(path) == 4:\n            res.append('.'.join(path))\n            return\n        # If parts already 4 but not all characters used, dead end\n        if len(path) >= 4:\n            return\n\n        # Try segments of length 1 to 3\n        for length in range(1, 4):\n            end = start + length\n            if end > len(s):\n                break\n            part = s[start:end]\n            # Leading zero check\n            if part.startswith('0') and len(part) > 1:\n                continue\n            # Value range check\n            if int(part) > 255:\n                continue\n            backtrack(end, path + [part])\n\n    backtrack(0, [])\n    return res\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Parse the input string to extract the digit string s.\n    Handles formats like:\n        s = \"25525511135\"\n        25525511135\n        \"25525511135\"\n    \"\"\"\n    # Remove newlines and excess spaces\n    line = data.replace('\\n', ' ').strip()\n    # If an '=' is present, take the part after it\n    if '=' in line:\n        _, value = line.split('=', 1)\n        line = value.strip()\n    # Strip surrounding quotes if any\n    if (line.startswith('\"') and line.endswith('\"')) or (line.startswith(\"'\") and line.endswith(\"'\")):\n        line = line[1:-1]\n    return line\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n    s = parse_input(raw_input)\n    result = restore_ip_addresses(s)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"25525511135\"",
          "expected_output": "[\"255.255.11.135\",\"255.255.111.35\"]",
          "success": true,
          "output": "[\"255.255.11.135\", \"255.255.111.35\"]"
        },
        {
          "example_index": 1,
          "input": "s = \"0000\"",
          "expected_output": "[\"0.0.0.0\"]",
          "success": true,
          "output": "[\"0.0.0.0\"]"
        },
        {
          "example_index": 2,
          "input": "s = \"101023\"",
          "expected_output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
          "success": true,
          "output": "[\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode393.json",
    "problem_index_in_file": 0,
    "title": "UTF-8 Validation",
    "description_snippet": "Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line with explanations, for validating UTF-8 encoding given array of integers representing bytes. Use arrows, decisions, Start, End. Provide each line as \"虛擬碼步驟 // 解釋\". Should not output actual code. Should be step by step. Let's plan algorithm:\n\n- Input array data\n- Initialize index i=0\n- While i < length:\n    - Determine number of bytes for first byte:\n        - If first byte starts with 0: length=1\n        - Else if starts with 110: length=2\n        - Else if starts with 1110: length=3\n        - Else if starts with 11110: length=4\n        - Else invalid\n    - Check that remaining bytes exist: if i+length-1 >= n: invalid\n    - For each following byte j from 1 to length-1:\n        - Check that byte starts with 10\n    - Move i += length\n- If loop completes, return true\n- Else false\n\nWe'll produce virtual code steps.\n\nNeed to handle bit checking: To check leading bits, we can count number of leading 1s before first 0. Use helper: count leading ones.\n\nWe need to produce steps with decisions: e.g., Decision: Determine number of bytes.\n\nLet's outline lines:\n\nStart\n→ Step 1: Set i = 0 // 初始化索引\n→ Decision: 是否已到資料末尾? // 檢查是否完成\n    Yes → End // 全部驗證完畢，返回 true\n    No  → Step 2: 取得 current = data[i] & 0xFF // 取得當前字節\n→ Step 3: Count leading ones in current -> count // 判斷字節長度\n→ Decision: count == 0? // 1-byte\n    Yes → Step 4: i = i + 1 // 單字節，移動\n    No  → Decision: count == 2? // 2-byte\n        Yes → Step 5: len = 2\n        No  → Decision: count == 3? // 3-byte\n            Yes → Step 6: len = 3\n            No  → Decision: count == 4? // 4-byte\n                Yes → Step 7: len = 4\n                No  → Step 8: return false // 無效開頭\n→ Decision: i + len - 1 >= n? // 檢查剩餘字節數\n    Yes → Step 9: return false\n    No  → Step 10: j = 1 // 從第二個字節開始檢查\n→ Decision: j < len? // 需要檢查更多字節\n    Yes → Step 11: next = data[i + j] & 0xFF\n→ Decision: next >> 6 == 0b10? // 是否以 10 開頭\n        Yes → Step 12: j = j + 1 // 檢查下一個\n        No  → Step 13: return false // 後續字節格式錯誤\n    No  → Step 14: i = i + len // 完成一個字符，移動到下個\n    No  → Back to Decision: 是否已到資料末尾?\n\nWe need loops represented by decisions. Provide line numbers? Not required.\n\nLet's produce lines sequentially. Use arrow \"→\" at each step.\n\nBe careful with indentation. Use spaces and no actual code.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0 // 初始化索引指向資料第一個字節  \n→ Decision: i ≥ length of data? // 檢查是否已經檢查完所有字節  \n Yes → End // 所有字節合法，返回 true  \n No → Step 2: current ← data[i] & 0xFF // 取得目前字節的 8 位有效資料  \n→ Step 3: count ← countLeadingOnes(current) // 計算前導 1 的個數以判斷字節長度  \n→ Decision: count == 0? // 第一位為 0，表示 1 字節字符  \n Yes → Step 4: i ← i + 1 // 移動到下一個字節  \n No → Decision: count == 2? // 110xxxxx 表示 2 字節字符  \n  Yes → Step 5: len ← 2 // 設定此字符總長度  \n  No → Decision: count == 3? // 1110xxxx 表示 3 字節字符  \n   Yes → Step 6: len ← 3  \n   No → Decision: count == 4? // 11110xxx 表示 4 字節字符  \n    Yes → Step 7: len ← 4  \n    No → Step 8: return false // 開頭不符合任何 UTF‑8 規則，無效  \n→ Decision: i + len - 1 ≥ length of data? // 確認剩餘字節足夠  \n Yes → Step 9: return false // 字節不足，無效  \n No → Step 10: j ← 1 // 從第二個字節開始檢查每個後續字節  \n→ Decision: j < len? // 是否還有後續字節需要驗證  \n Yes → Step 11: next ← data[i + j] & 0xFF // 取得第 j 個後續字節  \n  Decision: (next >> 6) == 0b10? // 判斷是否以 10 開頭  \n   Yes → Step 12: j ← j + 1 // 檢查下一個字節  \n   No → Step 13: return false // 後續字節格式錯誤，無效  \n No → Step 14: i ← i + len // 一個字符檢查完畢，移動到下一個字符的起始位置  \n  → 回到 Decision: i ≥ length of data? // 重新檢查是否已處理完所有字節  \nEnd // 程式執行結束，若未在任何步驟返回 false，則為合法 UTF‑8 編碼。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def validUtf8(self, data):\n        n_bytes = 0  # number of continuation bytes expected\n        for num in data:\n            # 確保每個數字在 0-255 之間，否則不是有效字節\n            if not (0 <= num <= 255):\n                return False\n            if n_bytes == 0:\n                # 計算首位 1 的個數，判斷字符長度\n                mask = 0x80\n                count = 0\n                while mask & num:\n                    count += 1\n                    mask >>= 1\n                if count == 0:\n                    continue  # 單字節字符，直接跳到下一個\n                if count == 1 or count > 4:\n                    return False  # 無效的首字節模式\n                n_bytes = count - 1  # 需要的連續字節數\n            else:\n                # 連續字節必須以 10 開頭\n                if (num & 0xC0) != 0x80:\n                    return False\n                n_bytes -= 1\n        return n_bytes == 0  # 若還剩預期字節，則不完整\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入，可接受 \"data = [ ... ]\" 或直接 \"[ ... ]\"\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n    else:\n        expr = raw_input\n    expr = expr.strip()\n    try:\n        data = ast.literal_eval(expr)\n    except Exception:\n        # 失敗時使用 eval，雖不推薦但保留兼容性\n        data = eval(expr)\n\n    result = Solution().validUtf8(data)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "data = [197,130,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "data = [235,140,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode475.json",
    "problem_index_in_file": 0,
    "title": "Heaters",
    "description_snippet": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed war...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm to compute minimum radius for heaters covering houses. Provide step-by-step virtual code with explanations.\n\nWe need to output in Traditional Chinese, each line: virtual code step, space, comment. Use Start, Decision, etc.\n\nSo design algorithm: sort houses and heaters. For each house, find nearest heater using binary search or two-pointer. Compute distance to nearest heater. The maximum of these distances is minimum required radius. So steps: sort arrays. For each house: find nearest heater. Use binary search to find insertion point. Compute distance to left and right heaters. Keep max.\n\nSo produce virtual code. Ensure no actual code, just pseudo steps. Use arrow \"→\". Use Decision.\n\nLet's craft. Provide comments in Chinese. Ensure each line includes step and comment.\n\nLet's start:\n\nStart\n→ Step 1: 接收並排序房屋位置陣列 // 先將所有房屋位置升序\n→ Step 2: 接收並排序暖氣位置陣列 // 先將所有暖氣位置升序\n→ Step 3: 設定變數 maxRadius = 0 // 用於儲存最大最小距離\n→ Decision: 迴圈開始? // 從第一個房屋開始遍歷\n    Yes → Step 4: 對於每個房屋 pos 在 houses // 逐一處理每個房屋\n        → Decision: 使用二分搜尋找到暖氣插入點 idx? // 找到第一個位置 >= pos 的暖氣索引\n            Yes → Step 5: 計算距離 leftDist = pos - heaters[idx-1] (若 idx>0) // 左邊暖氣距離\n            No  → Step 5: leftDist = Infinity // 沒左邊暖氣\n            Yes → Step 6: 計算距離 rightDist = heaters[idx] - pos (若 idx<heaters.length) // 右邊暖氣距離\n            No  → Step 6: rightDist = Infinity // 沒右邊暖氣\n            → Step 7: minDist = 最小值(leftDist, rightDist) // 取最近暖氣距離\n            → Step 8: maxRadius = max(maxRadius, minDist) // 更新全局最大距離\n        → Decision: 下一個房屋? // 是否有剩餘房屋\n            Yes → 循環回 Step 4\n            No  → End // 所有房屋處理完畢\nEnd // 回傳 maxRadius 作為最小暖氣半徑\n\nBut need more explicit arrow for loops. Might incorporate loops as Decision.\n\nAlso ensure each line includes explanation after //.\n\nAlso we should include \"→ Decision: 迴圈開始?\" and maybe \"Yes → Step 4\" etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收並排序房屋位置陣列 // 先將所有房屋位置升序  \n→ Step 2: 接收並排序暖氣位置陣列 // 先將所有暖氣位置升序  \n→ Step 3: 設定變數 maxRadius = 0 // 用於儲存所有房屋所需的最大最小距離  \n→ Decision: 迴圈開始? // 從第一個房屋開始遍歷  \n  Yes → Step 4: 對於每個房屋 pos 在 houses // 逐一處理每個房屋  \n   → Decision: 使用二分搜尋找到插入點 idx? // 找到第一個位置 >= pos 的暖氣索引  \n    Yes → Step 5: 計算左邊距離 leftDist = pos - heaters[idx-1]（若 idx>0） // 左邊暖氣距離  \n    No  → Step 5: leftDist = Infinity // 無左邊暖氣，距離視為無限大  \n    Yes → Step 6: 計算右邊距離 rightDist = heaters[idx] - pos（若 idx<heaters.length） // 右邊暖氣距離  \n    No  → Step 6: rightDist = Infinity // 無右邊暖氣，距離視為無限大  \n    → Step 7: minDist = min(leftDist, rightDist) // 取最近暖氣距離  \n    → Step 8: maxRadius = max(maxRadius, minDist) // 更新全局最大距離  \n   → Decision: 有剩餘房屋? // 是否還有未處理的房屋  \n    Yes → 循環回 Step 4  \n    No  → End // 所有房屋處理完畢  \nEnd // 回傳 maxRadius 作為最小暖氣半徑",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findRadius(self, houses, heaters):\n        houses.sort()\n        heaters.sort()\n        radius = 0\n        i = 0  # 指向目前最近的右側暖氣\n\n        for house in houses:\n            # 移動暖氣指標，找到離 house 最近的右側暖氣\n            while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n                i += 1\n            # 以當前暖氣為參考，更新需要的半徑\n            radius = max(radius, abs(heaters[i] - house))\n        return radius\n\ndef parse_input(input_str: str):\n    \"\"\"\n    從形如 'houses = [1,2,3], heaters = [2]' 的字串中提取兩個整數列表。\n    \"\"\"\n    # 先提取所有方括號中的內容\n    lists = re.findall(r'\\[([^\\]]*)\\]', input_str)\n    if len(lists) < 2:\n        return [], []\n\n    # 將提取到的字串轉為整數列表\n    houses = [int(x.strip()) for x in lists[0].split(',') if x.strip()]\n    heaters = [int(x.strip()) for x in lists[1].split(',') if x.strip()]\n    return houses, heaters\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    houses, heaters = parse_input(data)\n\n    # 若列表為空，直接輸出 0\n    if not houses or not heaters:\n        print(0)\n        return\n\n    sol = Solution()\n    radius = sol.findRadius(houses, heaters)\n    print(radius)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode591.json",
    "problem_index_in_file": 0,
    "title": "Tag Validator",
    "description_snippet": "Given a string representing a code snippet, implement a tag validator to parse the code and return w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanation, for tag validator logic. Should follow format: \"虛擬碼步驟 // 解釋\". Use arrow and structure. Should produce algorithm pseudocode. Need to ensure each step explained. Provide Start, End, Decision blocks.\n\nLet's design steps: Input string, index pointer, stack. Validate wrapper. We'll parse recursively or iteratively. Use stack for open tags. When encountering <, check if starts CDATA or end tag or start tag. Validate tag name. For CDATA, skip to end of CDATA. For start tag, push onto stack; after content, when encountering end tag, pop and validate. Also ensure whole string is enclosed by one valid closed tag: first char must be '<', and overall content ends with matching end tag. So we need to check entire string.\n\nWe can implement a function isValidTagName(name) etc.\n\nWill output steps accordingly. Use \"→\" arrows for progression.\n\nLet's craft steps:\n\nStart\n→ Read input string S\n→ If S does not start with '<' or no matching outer tag: return False\n→ Call parseContent(0, len(S)) that returns bool\nInside parseContent:\n- while index < end:\n   - if S[index] == '<':\n        - if starts with \"<![CDATA[\":\n             parse CDATA skip to \"]]>\"\n        - else if starts with \"</\":\n             parse end tag: read tag name until '>'\n             check if stack top equals name; if not, invalid\n             pop stack; return true\n        - else: parse start tag: read tag name until '>'\n             validate tag name; push onto stack\n        - continue\n   - else: index++ // any other char\nAfter loop, if stack not empty: invalid\n\nBut need outer wrapper: We can parse entire string expecting first start tag and matching end tag.\n\nSimplify: Use stack, parse char by char, but maintain outer validation: start of string must be start tag, at end of string stack must be empty and outer tag matched.\n\nLet's produce steps:\n\nStart\n→ Initialize index=0, stack empty, outerTag=null\n→ If S does not start with '<': return False\n→ Parse first tag as start tag, set outerTag, push onto stack\n→ While index < len(S):\n   (Decision: Is next char '<'? etc.)\n   parse accordingly\n→ After loop, if stack empty and outerTag matched: return True else False\nEnd\n\nWill produce step by step with Decision.\n\nNeed to include functions like parseTagName, isValidTagName, skipCDATA.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Read input string S // 取得要驗證的程式碼片段\n→ Step 2: If S does not start with '<' → Return False // 必須以起始標籤開始\n→ Step 3: Initialize index = 0, stack = empty, outerTag = null // 用於追蹤開啟的標籤\n→ Decision: 是否能解析出第一個起始標籤? // 從開頭解析起始標籤\n    Yes → Step 4: ParseStartTag() → 得到 tagName, 將 tagName 推入 stack，並將 outerTag 設為 tagName // 取得外層標籤名稱\n    No  → Step 5: Return False // 若第一個 '<' 之後無效標籤，整段無效\n→ Decision: 是否已經到達字串結尾? // 迴圈開始\n    No  → Step 6: If S[index] == '<' then // 遇到 '<' 需要判斷是什麼種類\n        → Decision: 是否為 CDATA? // <![CDATA[\n            Yes → Step 7: SkipCDATA() // 跳過 CDATA 範圍\n            No  → Decision: 是否為結束標籤? // </TAG\n                Yes → Step 8: ParseEndTag() → 取得 endTagName\n                → Decision: stack.top() == endTagName? // 標籤是否匹配\n                    Yes → Step 9: Pop stack // 匹配成功，移除最上層標籤\n                    No  → Step 10: Return False // 結束標籤不匹配，無效\n                No  → Step 11: ParseStartTag() → 取得 startTagName\n                → Decision: isValidTagName(startTagName)? // 標籤名稱是否合法\n                    Yes → Step 12: Push startTagName to stack // 合法標籤推入堆疊\n                    No  → Step 13: Return False // 標籤名稱不合法，無效\n        No  → Step 14: index++ // 非 '<' 字元視為普通內容，直接跳過\n    Yes → Step 15: Break // 完成全部字串掃描\n→ Step 16: If stack is empty and outerTag matched? // 結束時堆疊應空且外層標籤已正確關閉\n    Yes → Step 17: Return True // 程式碼片段有效\n    No  → Step 18: Return False // 標籤未完全關閉或遺漏\nEnd // 程式執行結束\n\n// --------------------- 子程序說明 ---------------------\n// Step 4: ParseStartTag()\n//    讀取從 index 開始的 '<' 到下一個 '>' 的子字串，取得 tagName，更新 index 指向 '>' 之後\n// Step 7: SkipCDATA()\n//    讀取從 index 開始的 \"<![CDATA[\"，跳到第一個出現的 \"]]>\"，並將 index 移到 \"]]>\" 之後\n// Step 8: ParseEndTag()\n//    讀取從 index 開始的 \"</\" 到下一個 '>' 的子字串，取得 endTagName，更新 index\n// isValidTagName(name)\n//    檢查 name 只包含大寫英文字母且長度 1~9，否則返回 False\n// --------------------- end ---------------------",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isValid(self, code: str) -> bool:\n        stack = []\n        i = 0\n        n = len(code)\n\n        while i < n:\n            # Any characters before the first tag are invalid\n            if i > 0 and not stack:\n                return False\n\n            # CDATA section\n            if code.startswith(\"<![CDATA[\", i):\n                j = i + 9\n                k = code.find(\"]]>\", j)\n                if k == -1:\n                    return False\n                i = k + 3\n                continue\n\n            # End tag\n            if code.startswith(\"</\", i):\n                j = i + 2\n                k = code.find(\">\", j)\n                if k == -1:\n                    return False\n                tag_name = code[j:k]\n                if not stack or stack[-1] != tag_name:\n                    return False\n                stack.pop()\n                i = k + 1\n                continue\n\n            # Start tag\n            if code[i] == \"<\":\n                j = i + 1\n                k = code.find(\">\", j)\n                if k == -1 or j == k or (k - j) > 9:\n                    return False\n                tag_name = code[j:k]\n                if not all('A' <= ch <= 'Z' for ch in tag_name):\n                    return False\n                stack.append(tag_name)\n                i = k + 1\n                continue\n\n            # Regular character\n            i += 1\n\n        # After parsing, stack must be empty and outer tag must be closed\n        return not stack and code.startswith(\"<\") and code.endswith(\">\")\n\ndef extract_code_from_input(raw: str) -> str:\n    \"\"\"\n    Extracts the string value assigned to the variable `code` in the input.\n    Handles formats like: code = \"<DIV>...</DIV>\"\n    \"\"\"\n    # Find the part after the first '='\n    parts = raw.split('=', 1)\n    if len(parts) == 2:\n        expr = parts[1].strip()\n    else:\n        expr = raw.strip()\n\n    # Remove surrounding quotes if present\n    if (expr.startswith('\"') and expr.endswith('\"')) or \\\n       (expr.startswith(\"'\") and expr.endswith(\"'\")):\n        expr = expr[1:-1]\n    # Remove any leading/trailing whitespace\n    return expr.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    code_str = extract_code_from_input(raw_input)\n    sol = Solution()\n    result = sol.isValid(code_str)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "code = \"<A>  <B> </A>   </B>\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode679.json",
    "problem_index_in_file": 0,
    "title": "24 Game",
    "description_snippet": "You are given an integer array cards of length 4. You have four cards, each containing a number in t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code algorithm to determine if 24 can be formed from 4 numbers with +,-,*,/. Classic 24 game. Provide steps: generate all permutations of numbers, all operator combinations (4^3), all parenthesizations (5 possibilities). Evaluate using float with tolerance. Return true/false. Use recursion or nested loops. Provide pseudocode lines with explanations. Let's produce line by line: Start, define function canReach24(cards). Convert to list. Use epsilon. For each permutation. For each op combo. For each pattern. Evaluate expression using helper evalPattern. If result close to 24, return true. End loop. Return false. Provide pseudo loops. Use Decision etc.\n\nLet's output each line. Ensure arrow syntax. Include comments after space. Use indentation implied by arrow lines? Example: Start, then arrow to Step. We'll indent using spaces? Use \"→\" before each line. We'll produce like sample.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define function `canReach24(cards)` // 建立檢查 24 的主要函式  \n→   Convert `cards` to list of float numbers // 以浮點數處理真除法  \n→   Set `target = 24.0` // 目標值  \n→   Set `epsilon = 1e-6` // 允許的誤差範圍  \n\n→   Generate all permutations of `cards` // 依序嘗試所有數字順序  \n    → For each `perm` in permutations(cards) // perm 是一個長度為 4 的排列  \n→       Generate all combinations of 3 operators (each from ['+','-','*','/'])  \n        → For each `ops` in operatorCombinations() // ops 是長度為 3 的列表  \n→           Evaluate all 5 binary tree patterns  \n                → For pattern 1: ((a op1 b) op2 c) op3 d  \n                →   If evaluatePattern(perm, ops, pattern1) ≈ target → Return True  \n                → For pattern 2: (a op1 (b op2 c)) op3 d  \n                →   If evaluatePattern(perm, ops, pattern2) ≈ target → Return True  \n                → For pattern 3: a op1 ((b op2 c) op3 d)  \n                →   If evaluatePattern(perm, ops, pattern3) ≈ target → Return True  \n                → For pattern 4: a op1 (b op2 (c op3 d))  \n                →   If evaluatePattern(perm, ops, pattern4) ≈ target → Return True  \n                → For pattern 5: (a op1 b) op2 (c op3 d)  \n                →   If evaluatePattern(perm, ops, pattern5) ≈ target → Return True  \n\n→ End of loops // 若所有排列、操作、模式皆未命中  \n\n→ Return False // 無法達成 24  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport operator\nfrom itertools import permutations\n\ndef judge_point_24(nums):\n    target = 24.0\n    eps = 1e-6\n    ops = [operator.add, operator.sub, operator.mul, operator.truediv]\n\n    def dfs(values):\n        if len(values) == 1:\n            return abs(values[0] - target) < eps\n        n = len(values)\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                # 創造剩餘數字列表\n                remaining = [values[k] for k in range(n) if k != i and k != j]\n                for op in ops:\n                    # 防止除以零\n                    if op is operator.truediv and abs(values[j]) < eps:\n                        continue\n                    # 進行一次二元運算，將結果加入\n                    remaining.append(op(values[i], values[j]))\n                    if dfs(remaining):\n                        return True\n                    # 回溯\n                    remaining.pop()\n        return False\n\n    # 嘗試所有數字排列\n    for perm in permutations(nums):\n        if dfs(list(perm)):\n            return True\n    return False\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 透過正則抓取所有整數\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if not numbers or len(numbers) != 4:\n        print(\"false\")\n        return\n    result = judge_point_24(numbers)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "cards = [4,1,8,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "cards = [1,2,1,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode557.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String III",
    "description_snippet": "Given a string s, reverse the order of characters in each word within a sentence while still preserv...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for reversing each word's characters, preserving whitespace and word order. Use Start, End, Decision, Steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrow → for steps, Decision: for condition.\n\nWe need to split by whitespace, preserve. Approach: iterate through string, build result: accumulate characters until space encountered, then reverse current word and append to result, keep space. Also handle trailing word.\n\nSteps: Start, Step1: Initialize variables: result string, currentWord string. → Step2: Iterate each character c in s: if c is not whitespace, append to currentWord. Else whitespace: reverse currentWord, append to result, append space, reset currentWord. → After loop, if currentWord not empty, reverse and append. → End.\n\nAlternatively decision: if c is whitespace? etc. Use Decision.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: Set result = \"\" // 初始化結果字串\n\n→ Step 2: Set currentWord = \"\" // 初始化當前單詞\n\n→ Step 3: For each character c in s // 遍歷輸入字串\n\n    Decision: 如果 c 是空白? // 判斷是否為空格\n\n        Yes → Step 4: Append reverse(currentWord) to result // 將反轉後的單詞加入結果\n\n        Yes → Step 5: Append c to result // 保留空白\n\n        Yes → Step 6: currentWord = \"\" // 清空單詞緩存\n\n        No  → Step 7: Append c to currentWord // 收集單詞字符\n\n→ Step 8: Decision: currentWord 不為空? // 迴圈結束後檢查剩餘單詞\n\n    Yes → Step 9: Append reverse(currentWord) to result // 將最後單詞反轉後加入\n\n    No  → // 無操作\n\n→ End // 程式執行結束\n\nBut the format uses arrow \"→\" before each step. For Decision lines, use \"Decision:\" and then indent Yes/No lines.\n\nWe must ensure correct indentation and formatting. Use \"Yes →\" \"No →\". Also inside Decision, maybe no arrow at Decision line? In example: \"Decision: 如果數字大於 0?\" with indentation. Then \"Yes → Step 2: ...\". We'll mimic that.\n\nThus:\n\nStart // 程式開始執行\n\n→ Step 1: result = \"\" // 初始化結果字串\n\n→ Step 2: currentWord = \"\" // 初始化當前單詞\n\n→ Step 3: For each character c in s // 遍歷輸入字串\n\n    Decision: c 是空白嗎? // 判斷是否為空白\n\n        Yes → Step 4: result += reverse(currentWord) // 將反轉後的單詞加入結果\n\n        Yes → Step 5: result += c // 保留空白字符\n\n        Yes → Step 6: currentWord = \"\" // 清空單詞緩存\n\n        No  → Step 7: currentWord += c // 收集單詞字符\n\n→ Step 8: Decision: currentWord 不為空? // 迴圈結束後檢查剩餘單詞\n\n    Yes → Step 9: result += reverse(currentWord) // 將最後單詞反轉後加入\n\n    No  → // 無操作\n\n→ End // 程式執行結束\n\nWe need to include the \"→\" arrow before each step line. For Decision lines, indentation is two spaces? Example shows indentation maybe 4 spaces? We can indent by 4 spaces for sub-steps. Use same as example.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = \"\" // 初始化結果字串  \n→ Step 2: currentWord = \"\" // 初始化當前單詞  \n→ Step 3: For each character c in s // 遍歷輸入字串  \n    Decision: c 是空白嗎? // 判斷是否為空白  \n        Yes → Step 4: result += reverse(currentWord) // 將反轉後的單詞加入結果  \n        Yes → Step 5: result += c // 保留空白字符  \n        Yes → Step 6: currentWord = \"\" // 清空單詞緩存  \n        No  → Step 7: currentWord += c // 收集單詞字符  \n→ Step 8: Decision: currentWord 不為空? // 迴圈結束後檢查剩餘單詞  \n    Yes → Step 9: result += reverse(currentWord) // 將最後單詞反轉後加入  \n    No  → // 無操作  \n→ End // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        result = []\n        current = []\n        for c in s:\n            if c.isspace():\n                if current:\n                    result.append(''.join(reversed(current)))\n                    current = []\n                result.append(c)\n            else:\n                current.append(c)\n        if current:\n            result.append(''.join(reversed(current)))\n        return ''.join(result)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 尝试解析形如 's = \"...\"' 的输入\n    s = None\n    if data.startswith('s ='):\n        idx = data.find('=')\n        if idx != -1:\n            s_part = data[idx+1:].strip()\n            if (s_part.startswith('\"') and s_part.endswith('\"')) or \\\n               (s_part.startswith(\"'\") and s_part.endswith(\"'\")):\n                s = s_part[1:-1]\n            else:\n                s = s_part\n\n    # 若未解析成功，则直接使用输入或去掉外层引号\n    if s is None:\n        if (data.startswith('\"') and data.endswith('\"')) or \\\n           (data.startswith(\"'\") and data.endswith(\"'\")):\n            s = data[1:-1]\n        else:\n            s = data\n\n    sol = Solution()\n    result = sol.reverseWords(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Let's take LeetCode contest\"",
          "expected_output": "\"s'teL ekat edoCteeL tsetnoc\"",
          "success": true,
          "output": "s'teL ekat edoCteeL tsetnoc"
        },
        {
          "example_index": 1,
          "input": "s = \"Mr Ding\"",
          "expected_output": "\"rM gniD\"",
          "success": true,
          "output": "rM gniD"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode491.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Subsequences",
    "description_snippet": "Given an integer array nums, return all the different possible non-decreasing subsequences of the gi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all distinct non-decreasing subsequences of length >= 2 from an integer array nums. The format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows. Must not output actual code.\n\nWe need to produce step-by-step algorithm.\n\nPseudo: Use backtracking to generate subsequences, maintain current list. Use set to store results to avoid duplicates. At each index, decide to include current number if >= last included. Then recursing. Also skip duplicates? But set handles.\n\nWe'll produce high-level virtual steps.\n\nNeed to show Start, Decision, Step, Yes/No.\n\nWe can outline:\n\nStart\n→ Step 1: 初始化結果集合 res // 用來存唯一子序列\n→ Step 2: 定義遞迴函式 DFS(index, path) // index: 當前處理的元素位置，path: 當前子序列\n→ Decision: index 是否已超過 nums 長度? // 判斷是否到結束\n    Yes → Decision: path 長度是否 >= 2? // 只收集長度 >=2\n        Yes → Step: 將 path 轉成列表並加入 res // 存入結果\n        No  → No operation // 不滿足長度要求\n    No  → Step: For each j from index 到 len(nums)-1\n        → Decision: path 是否為空 OR nums[j] >= path 最後一個？ // 非遞減判斷\n            Yes → Step: Append nums[j] 至 path\n            → Call DFS(j+1, path)\n            → Step: 從 path 移除最後一個元素 // 回溯\n            No  → No operation // 跳過不合法\nEnd\n\nBut we also need to avoid duplicate subsequences due to repeated numbers. Could use set of tuple, but that's handled by res set. But for backtracking duplicates we could skip same numbers at same depth to avoid exploring same state; optional but not necessary.\n\nSimplify.\n\nNow produce virtual code lines, each line with explanation.\n\nWe need to use arrows: \"→ Step X: ...\" and \"Decision:\" etc.\n\nWe need to indent to show hierarchy.\n\nLet's craft.\n\nWe'll start:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化結果集合 res 為空集合 // 用來儲存唯一子序列\n\n→ Step 2: 定義遞迴函式 DFS(index, path) // index: 當前考慮的起始位置，path: 目前已選擇的子序列\n\n→ Decision: index 是否已超過 nums 長度? // 判斷是否已遍歷完整陣列\n    Yes → Decision: path 長度是否 >= 2? // 只收集至少兩個元素的子序列\n        Yes → Step: 將 path 轉成列表並加入 res // 存入結果集合\n        No  → Step: No operation // 子序列長度不足，直接回傳\n    No  → Step: For each j 從 index 到 nums.length-1\n        → Decision: path 為空 OR nums[j] >= path 最後一個元素? // 確認新增元素不破壞非遞減性\n            Yes → Step: Append nums[j] 至 path // 將元素加入子序列\n            → Call DFS(j+1, path) // 進一步遞迴\n            → Step: 從 path 移除最後一個元素 // 回溯，恢復原狀\n            No  → Step: No operation // 跳過不合法的選擇\n→ Step 3: 呼叫 DFS(0, 空列表) // 從陣列起始位置開始搜尋\n→ Step 4: 回傳 res // 將所有不同的子序列輸出\n\nEnd // 程式執行結束\n\nBut we need to show each step line with arrow at start or no arrow? In example they used \"→ Step 1:\" etc. For the decision block, they used \"Decision:\" with indent. For \"Yes →\" etc.\n\nWe need to maintain that formatting.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化結果集合 res 為空集合 // 用來儲存唯一子序列\n→ Step 2: 定義遞迴函式 DFS(index, path) // index: 當前考慮的起始位置，path: 目前已選擇的子序列\n    → Decision: index 是否已超過 nums 長度? // 判斷是否已遍歷完整陣列\n        Yes → Decision: path 長度是否 >= 2? // 只收集至少兩個元素的子序列\n            Yes → Step: 將 path 轉成列表並加入 res // 存入結果集合\n            No  → Step: No operation // 子序列長度不足，直接回傳\n        No  → Step: For each j 從 index 到 nums.length-1\n            → Decision: path 為空 OR nums[j] >= path 最後一個元素? // 確認新增元素不破壞非遞減性\n                Yes → Step: Append nums[j] 至 path // 將元素加入子序列\n                → Call DFS(j+1, path) // 進一步遞迴\n                → Step: 從 path 移除最後一個元素 // 回溯，恢復原狀\n                No  → Step: No operation // 跳過不合法的選擇\n→ Step 3: 呼叫 DFS(0, 空列表) // 從陣列起始位置開始搜尋\n→ Step 4: 回傳 res // 將所有不同的子序列輸出\nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def findSubsequences(self, nums: List[int]) -> List[List[int]]:\n        res: List[List[int]] = []\n\n        def backtrack(start: int, path: List[int]) -> None:\n            if len(path) > 1:\n                res.append(path[:])  # 存入一個完整的子序列\n            used = set()  # 避免在同一層重複選取相同數值\n            for i in range(start, len(nums)):\n                if (not path or nums[i] >= path[-1]) and nums[i] not in used:\n                    used.add(nums[i])\n                    path.append(nums[i])\n                    backtrack(i + 1, path)\n                    path.pop()  # 回溯\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        nums = []\n    else:\n        # 假設輸入格式為 'nums = [1, 2, 3]'\n        try:\n            nums = eval(data.split('=', 1)[1].strip())\n        except Exception:\n            # 如果輸入僅為列表字面，直接 eval\n            nums = eval(data)\n    solution = Solution()\n    result = solution.findSubsequences(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,6,7,7]",
          "expected_output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
          "success": true,
          "output": "[[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]"
        },
        {
          "example_index": 1,
          "input": "nums = [4,4,3,2,1]",
          "expected_output": "[[4,4]]",
          "success": true,
          "output": "[[4, 4]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode535.json",
    "problem_index_in_file": 0,
    "title": "Encode and Decode TinyURL",
    "description_snippet": "Note: This is a companion problem to the System Design problem: Design TinyURL.\nTinyURL is a URL sho...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. The problem: design tinyURL class with encode/decode. Provide algorithm. Virtual code: use hash map from short->long and long->short, generate short id using incremental counter or random string. We'll produce pseudocode. The format: \"Start // 程式開始執行\" then lines with arrows.\n\nWe need to use the arrow notation: \"→ Step 1: ...\" etc. Indent decisions. Provide explanations in Chinese. Use virtual code.\n\nWe must not output actual code. Provide virtual code with explanatory comments.\n\nLet's craft.\n\nWe'll design a Solution class with fields: counter, mapShortToLong, mapLongToShort. Use base62 encoding. For encode: if longUrl in mapLongToShort return existing short. Else generate id = counter; counter++; encode id to base62 string; build shortUrl = \"http://tinyurl.com/\" + code; store mapping; return shortUrl. For decode: parse code from shortUrl; look up mapShortToLong and return longUrl.\n\nImplement base62 conversion.\n\nNeed to show step-by-step pseudocode.\n\nLet's output accordingly.\n\nWe'll include decisions: if longUrl exists etc. We'll use Decision: if longUrl exists? Yes -> return existing. No -> generate new.\n\nFor decode: Decision: if shortUrl exists? Yes -> return mapping; else error.\n\nProvide all steps.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 counter ← 0，建立空字典 mapLongToShort、mapShortToLong // 準備編碼表與計數器\n→ Decision: 進入 Encode 或 Decode 取決於呼叫方法 // 判斷使用者要執行哪個動作\n\n    // ---------- Encode ----------\n    → Step 2: 若長網址 longUrl 在 mapLongToShort 中？ // 檢查是否已有縮網址\n        Yes → Step 3: 回傳已存在的短網址 mapLongToShort[longUrl] // 直接使用已生成的縮網址\n        No  → Step 4: counter ← counter + 1 // 為新網址產生唯一 id\n            → Step 5: code ← Base62Encode(counter) // 把 id 轉成 62 字元編碼\n            → Step 6: shortUrl ← \"http://tinyurl.com/\" + code // 組合成完整縮網址\n            → Step 7: mapLongToShort[longUrl] ← shortUrl // 儲存長網址到短網址對應\n            → Step 8: mapShortToLong[shortUrl] ← longUrl // 儲存短網址到長網址對應\n            → Step 9: 回傳 shortUrl // 結束 Encode\n\n    // ---------- Decode ----------\n    → Step 10: 從 shortUrl 擷取 code（移除前綴 http://tinyurl.com/） // 取得編碼字串\n        → Step 11: 若 code 在 mapShortToLong 中？ // 檢查是否已經存在映射\n            Yes → Step 12: longUrl ← mapShortToLong[shortUrl] // 找回原始長網址\n            No  → Step 13: 長網址未知，拋出錯誤或返回空 // 保證此路徑在本物件內不會出現\n        → Step 14: 回傳 longUrl // 結束 Decode\n\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport string\n\nclass Solution:\n    \"\"\"\n    TinyURL 的簡易實作，使用遞增整數 + Base62 編碼產生短網址，\n    並使用兩張字典做對應，確保編碼與解碼對應正確。\n    \"\"\"\n    def __init__(self):\n        self.counter = 0\n        self.base_url = \"http://tinyurl.com/\"\n        self.long_to_short = {}  # longUrl -> shortUrl\n        self.short_to_long = {}  # shortUrl -> longUrl\n        self.chars = string.ascii_letters + string.digits  # 62 個字元\n\n    def _encode_base62(self, num: int) -> str:\n        \"\"\"把整數編碼成 Base62 字串\"\"\"\n        if num == 0:\n            return self.chars[0]\n        arr = []\n        base = len(self.chars)\n        while num > 0:\n            num, rem = divmod(num, base)\n            arr.append(self.chars[rem])\n        arr.reverse()\n        return \"\".join(arr)\n\n    def encode(self, longUrl: str) -> str:\n        \"\"\"\n        將長網址轉成短網址。\n        若已經編碼過，直接回傳已存在的短網址。\n        \"\"\"\n        if longUrl in self.long_to_short:\n            return self.long_to_short[longUrl]\n        self.counter += 1\n        code = self._encode_base62(self.counter)\n        shortUrl = self.base_url + code\n        self.long_to_short[longUrl] = shortUrl\n        self.short_to_long[shortUrl] = longUrl\n        return shortUrl\n\n    def decode(self, shortUrl: str) -> str:\n        \"\"\"\n        從短網址回復原始長網址。\n        若 shortUrl 未在映射中，回傳空字串。\n        \"\"\"\n        return self.short_to_long.get(shortUrl, \"\")\n\ndef main():\n    # 讀取整個 stdin，並去除可能的首尾空白與引號\n    raw_input = sys.stdin.read().strip()\n    long_url = raw_input.strip('\"\\'')  # 兼容被引號包圍的輸入\n\n    # 建立 TinyURL 物件，進行編碼再解碼\n    tiny = Solution()\n    short = tiny.encode(long_url)\n    original = tiny.decode(short)\n\n    # 輸出解碼結果（即原始長網址）\n    print(original)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"https://leetcode.com/problems/design-tinyurl\"",
          "expected_output": "\"https://leetcode.com/problems/design-tinyurl\"",
          "success": true,
          "output": "https://leetcode.com/problems/design-tinyurl"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode745.json",
    "problem_index_in_file": 0,
    "title": "Prefix and Suffix Search",
    "description_snippet": "Design a special dictionary that searches the words in it by a prefix and a suffix.\n\nImplement the W...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for designing a WordFilter class with constructor and method f. We need to handle prefix and suffix search, returning highest index.\n\nWe should propose approach: build trie for prefixes, and suffix trie for reversed words, then intersection? But we can also build a hash map from prefix+suffix to max index? That's too big.\n\nBetter approach: use a combined trie where each node holds list of indices? There's known solution: use a trie where keys are pref+\"#\"+suff? Wait for problem: \"Word Filter\" from LeetCode 745. Approach: use trie of all possible suffixes and prefixes? Official solution: for each word, for each prefix length i, for each suffix length j, insert into map key=prefix+\"#\"+suffix with value index. But that's O(n * L^2). Instead efficient solution: build a trie with reversed words as keys, where each node stores a list of indices sorted. Then f queries with pref, suff: traverse reversed suffix in suffix trie to get list of indices, then find highest index that also has prefix? But we can store prefix in each node of reversed trie? There's approach: build trie of all words with reversed words, each node stores indices. Then f(pref, suff): we traverse suff reversed in trie to get list of indices; for each index in that list, check if word at index starts with pref; we need efficient: store set of indices for each prefix in a map? Might be simpler: use map of pref+suffix to max index. But for brevity we can propose building dictionary with key=prefix+\"#\"+suffix mapping to max index. Implementation: for each word at index i, for all possible prefixes and suffixes, compute key. But we just produce pseudo-code, not actual complexity concerns.\n\nLet's produce pseudo-code with steps:\n\nStart, WordFilter constructor: iterate words, for each index, compute all prefixes and suffixes, update map.\n\nMethod f: compute key=prefix+\"#\"+suffix, look up map, return value else -1.\n\nWe must provide line by line pseudo-code.\n\nOk.\n\nLet's produce lines: Start, etc.\n\nUse arrows. Use indentation for decisions.\n\nLet's start.\n\nWe'll produce:\n\nStart\n→ Initialize WordFilter // constructor\n    → Input words array // list of strings\n    → Initialize map PrefSuffMap // dictionary from string to int\n    → For each index i, word w in words\n        → For each prefix length p from 1 to len(w)\n            → prefix = w[0:p]\n            → For each suffix length s from 1 to len(w)\n                → suffix = w[len(w)-s:]\n                → key = prefix + \"#\" + suffix\n                → If key not in map or i > map[key] → map[key] = i\n    → End For\n\n→ End // constructor\n\n→ Function f(prefix, suffix)\n    → key = prefix + \"#\" + suffix\n    → If key in map → return map[key]\n    → Else return -1\n→ End\n\nBut we need pseudo-code with arrows, decision etc. We can express loops.\n\nLet's format:\n\nStart\n→ WordFilter(words) // Constructor\n    → PrefSuffMap = {} // 初始化映射\n    → For i in 0 .. words.length-1 // 遍歷每個單詞\n        → w = words[i]\n        → For pLen in 1 .. w.length // 前綴長度\n            → prefix = w[0:pLen]\n            → For sLen in 1 .. w.length // 後綴長度\n                → suffix = w[w.length - sLen :] // 後綴\n                → key = prefix + \"#\" + suffix\n                → If key not in PrefSuffMap OR i > PrefSuffMap[key] // 更新最大索引\n                    → PrefSuffMap[key] = i\n        → End For\n    → End For\n→ End // 結束建構\n→ Function f(pref, suff)\n    → key = pref + \"#\" + suff\n    → If key in PrefSuffMap // 有符合條件\n        → Return PrefSuffMap[key]\n    → Else\n        → Return -1\n→ End // 結束查詢\n\nWe need to use arrow syntax: \"→\" before each line, and \"Decision:\" for conditional.\n\nUse indenting for decision branch.\n\nOk.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ WordFilter(words) // 建構子：接收單詞陣列  \n    → PrefSuffMap = {} // 初始化前綴+後綴 → 最大索引 的映射  \n    → For i in 0 .. words.length-1 // 逐一處理每個單詞  \n        → w = words[i] // 取得第 i 個單詞  \n        → For pLen in 1 .. w.length // 遍歷所有前綴長度  \n            → prefix = w[0:pLen] // 取得前綴  \n            → For sLen in 1 .. w.length // 遍歷所有後綴長度  \n                → suffix = w[w.length - sLen :] // 取得後綴  \n                → key = prefix + \"#\" + suffix // 組合鍵  \n                → Decision: key 於 PrefSuffMap?  \n                    → Yes → If i > PrefSuffMap[key] // 只保留最大索引  \n                        → PrefSuffMap[key] = i // 更新為更大的索引  \n                    → No  → PrefSuffMap[key] = i // 新鍵，直接存入  \n            → End For  \n        → End For  \n    → End For  \n→ End // 建構完成  \n→ Function f(pref, suff) // 查詢方法  \n    → key = pref + \"#\" + suff // 組合查詢鍵  \n    → Decision: key 於 PrefSuffMap?  \n        → Yes → Return PrefSuffMap[key] // 取得最大符合索引  \n        → No  → Return -1 // 沒有符合的單詞  \n→ End // 查詢結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):\n                for j in range(L + 1):\n                    self.lookup[(word[:i], word[j:])] = weight\n\n    def f(self, prefix, suffix):\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the input into words part and query part\n    # Expected format: [[...]], [\"prefix\", \"suffix\"]\n    parts = data.split('], [', 1)\n    words_part = parts[0] + ']'  # close the words list\n    query_part = '[' + parts[1]  # add opening bracket for the query list\n\n    words_list = ast.literal_eval(words_part)\n    # If the words list is wrapped in an extra list, flatten it\n    if isinstance(words_list, list) and all(isinstance(x, list) for x in words_list):\n        words = words_list[0]\n    else:\n        words = words_list\n\n    query = ast.literal_eval(query_part)\n    pref, suff = query[0], query[1]\n\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode409.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindrome",
    "description_snippet": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: length of longest palindrome from letters, case-sensitive. Approach: count frequencies, sum even counts fully, odd counts contribute count-1, and if any odd present, add 1 at end. So pseudo steps: Start, Input string s, Count letters, For each char, count freq, Then calculate result: length = 0; For each freq, length += (freq // 2)*2; if length < len(s): length +=1; Return length. End.\n\nWe produce virtual code lines: each step, arrow etc. Use Start, Decision etc. Provide explanation. No actual code. Use arrow for flow. Provide each line. We might have loops: Decision: For each char? Use Decision for frequency? Simpler: Use step \"Count frequencies\" and \"Compute length\". We'll keep decision for odd? For each freq: if freq is odd? But we can compute directly. We'll structure: Start, Input, Step: Count frequencies, Step: Initialize length=0, Decision: If freq is even? etc.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Input: 讀取字串 s // 取得輸入字串\n→ Step 1: 建立字母頻率表 freq // 用來統計每個字母出現次數\n→ Decision: 對於 s 中每個字母 c // 逐字遍歷字串\n    Yes → Step 2: freq[c] +=1 // 計數累加\n    No  → (無動作) // 迴圈結束\n→ Step 3: 初始化長度 longest = 0 // 用於累積可組成的回文長度\n→ Decision: 對於 freq 中每個字母計數 count // 逐項處理頻率\n    Yes → Step 4: longest += (count // 2) * 2 // 加入能形成偶數對的字母數\n    No  → (無動作) // 迴圈結束\n→ Decision: 是否存在奇數頻率的字母？ // 檢查是否有可放置於中心的字母\n    Yes → Step 5: longest += 1 // 在回文中心放入一個字母\n    No  → (無動作) // 若全為偶數則不改變\n→ Output: 回傳 longest // 結果輸出\nEnd // 程式執行結束\n\nBut we need to use arrow and maybe nested decisions. Use \"Yes →\" \"No →\". Provide explanation. Each line must be one step. Also the decision lines for loops are tricky. The example shows loops by \"Decision:\" with nested Yes/No. We can emulate.\n\nBetter: We can have \"Decision: 對於 s 中每個字母?\" Yes → \"Step\" etc. But we need to show iterative structure.\n\nSimplify: Provide pseudo:\n\nStart\n→ Input: 讀取字串 s\n→ Step: 建立空字典 freq\n→ Decision: 迴圈遍歷 s 中的每個字母 c\n    Yes → Step: freq[c] = freq.get(c,0)+1\n    No  → (結束迴圈)\n→ Step: 初始化 longest = 0\n→ Decision: 迴圈遍歷 freq 中的每個 count\n    Yes → Step: longest += (count // 2) * 2\n    No  → (結束迴圈)\n→ Decision: 有無 oddCount? // 變量 oddCount = any(count%2==1)\n    Yes → Step: longest +=1\n    No  → (無動作)\n→ Output: longest\nEnd\n\nWe can also compute oddCount by a decision inside loop. But keep it simple.\n\nNeed each line of virtual code with explanation. So produce each line accordingly. Ensure to have \"→\" preceding steps. Use indentation maybe not required but for clarity. We'll keep indentation with 4 spaces for nested. Provide explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: 讀取字串 s // 從使用者取得原始字串  \n→ Step 1: 建立空字典 freq // 用來統計每個字母出現的次數  \n→ Decision: 迴圈遍歷 s 中的每個字母 c // 對字串進行逐字處理  \n    Yes → Step 2: freq[c] = freq.get(c,0)+1 // 將字母計數累加  \n    No  → (結束迴圈) // 已遍歷完所有字母  \n→ Step 3: 初始化 longest = 0 // 用於累積可組成的回文長度  \n→ Decision: 迴圈遍歷 freq 中的每個計數 count // 逐項處理字母頻率  \n    Yes → Step 4: longest += (count // 2) * 2 // 加入能形成偶數對的字母數  \n    No  → (結束迴圈) // 已處理完所有頻率  \n→ Decision: 是否存在奇數頻率的字母？ // 檢查是否可以放一個字母在中心  \n    Yes → Step 5: longest += 1 // 在回文中心放入一個字母  \n    No  → (無動作) // 若全為偶數則不改變  \n→ Output: 回傳 longest // 將結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        \"\"\"\n        計算可由字串 s 產生的最長回文長度。\n        方式：統計每個字母的頻率，偶數個字母全部使用，奇數個字母使用其最大偶數部分\n        若至少存在一個奇數頻率，則可以在中心放置一個字母。\n        \"\"\"\n        count = Counter(s)\n        length = 0\n        odd_found = False\n        for val in count.values():\n            if val % 2 == 0:\n                length += val\n            else:\n                length += val - 1\n                odd_found = True\n        if odd_found:\n            length += 1\n        return length\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，並只保留字母，忽略其他字符（如 `s = \"...\"`）\n    raw_input = sys.stdin.read()\n    s = ''.join(ch for ch in raw_input if ch.isalpha())\n    result = Solution().longestPalindrome(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abccccdd\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode502.json",
    "problem_index_in_file": 0,
    "title": "IPO",
    "description_snippet": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Cap...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for LeetCode problem: maximize capital selecting at most k projects. Classic solution: use min-heap for capital requirements, max-heap for profits. Steps: sort projects by capital; push into min-heap of capital. For i from 1..k: while projects with capital <= current capital: push profit into max-heap. If max-heap empty break. pop max profit, add to capital. Return capital.\n\nWe need to produce virtual code lines: Start, Step, Decision, etc. Provide explanation after //.\n\nWe need to produce steps line by line. We need to show sorting, adding to heap, loops, etc.\n\nLet's craft:\n\nStart // 程式開始\n\n→ Step 1: 將 projects 依 capital 排序 // 先按啟動資本由小到大排序\n\n→ Step 2: 初始化 minCapHeap 與 maxProfitHeap // 用來分別存取可啟動項目的資本與可選項目的利潤\n\n→ Step 3: 設定 idx = 0 // 追蹤已放入 minCapHeap 的項目索引\n\n→ Decision: 是否已選項目數小於 k? // 控制最多選 k 個\n\n    Yes → Step 4: 當 idx < n 且 projects[idx].capital <= currentCapital 時 → Step 4a: 把 projects[idx].profit 推入 maxProfitHeap; idx++ // 把可啟動的項目利潤加入最大堆\n\n    No → Decision: maxProfitHeap 是否非空? // 看是否還有可選利潤\n\n        Yes → Step 5: currentCapital += maxProfitHeap.pop() // 取最大的利潤加入資本\n\n        No  → Step 6: break // 沒有可啟動項目，結束循環\n\nEnd // 回傳 currentCapital\n\nBut need to incorporate while loop. Let's refine: Use a loop to push projects until capital requirement not satisfied. Use nested loop inside the main k loop.\n\nWe can structure:\n\n→ Step 4: While idx < n 且 projects[idx].capital <= currentCapital → Step 4a: maxProfitHeap.push(projects[idx].profit); idx++ // 將符合資本的利潤放入最大堆\n\n→ Decision: maxProfitHeap 內是否有元素? // 檢查是否有可選擇的項目\n\n    Yes → Step 5: currentCapital += maxProfitHeap.pop() // 從最大堆取最大利潤並加到資本\n\n    No  → Step 6: break // 無可選擇項目，結束\n\n→ Decision: 是否已選項目數 < k? // 迴圈判斷\n\nBut need to count selected projects. We can use a counter selected = 0. Each time we pop we increment selected. And loop until selected == k or no more profit.\n\nLet's produce full steps:\n\nStart\n→ Step 1: 將 n 個專案按 capital 升序排序\n→ Step 2: 初始化 minCapHeap = 空; maxProfitHeap = 空\n→ Step 3: idx = 0\n→ Step 4: selected = 0\n→ Decision: selected < k? // 是否還可以再選項目\n    Yes →\n        → Step 5: While idx < n 且 projects[idx].capital <= currentCapital\n            → Step 5a: maxProfitHeap.push(projects[idx].profit)\n            → Step 5b: idx += 1\n        → Decision: maxProfitHeap 非空?\n            Yes →\n                → Step 6: currentCapital += maxProfitHeap.pop()\n                → Step 7: selected += 1\n                → Go back to Decision: selected < k?\n            No →\n                → Step 8: break // 沒有可用利潤\n    No →\n        → Step 9: break // 已選 k 個\nEnd // 回傳 currentCapital\n\nWe need each line as virtual code with arrow and comment.\n\nLet's craft final output accordingly.\n\nMake sure each line uses \"→\" preceding the step unless it's decision. Use \"Decision:\" lines.\n\nAlso, we need to include start and end. Use \"Start // 程式開始執行\" etc.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 將所有專案依 capital 由小到大排序 // 方便後續只考慮可啟動的專案\n→ Step 2: 初始化 maxProfitHeap 為空 // 儲存已經可啟動專案的利潤，並能快速取得最大利潤\n→ Step 3: idx ← 0 // 追蹤已經放入最大堆的專案索引\n→ Step 4: selected ← 0 // 計算已選擇的專案數量\n→ Decision: selected < k? // 是否還能再選一個專案\n    Yes →\n        → Step 5: While idx < n 且 projects[idx].capital ≤ currentCapital\n            → Step 5a: maxProfitHeap.push(projects[idx].profit) // 把可啟動專案的利潤加入最大堆\n            → Step 5b: idx ← idx + 1\n        → Decision: maxProfitHeap 非空?\n            Yes →\n                → Step 6: currentCapital ← currentCapital + maxProfitHeap.pop() // 取最大利潤，更新資本\n                → Step 7: selected ← selected + 1 // 已選一個專案\n                → Go back to Decision: selected < k? // 進行下一輪選擇\n            No →\n                → Step 8: break // 沒有可選擇的專案，結束循環\n    No →\n        → Step 9: break // 已選 k 個專案，結束循環\nEnd // 回傳 currentCapital，完成最大化資本計算\n```",
      "generated_code": "import sys\nimport re\nimport heapq\n\ndef find_maximized_capital(k, w, profits, capital):\n    # 將專案按所需資本升序排序\n    projects = sorted(zip(capital, profits))\n    max_heap = []          # 儲存可啟動專案的利潤，使用負值做最大堆\n    i = 0                  # 追蹤已加入最大堆的專案\n    n = len(profits)\n\n    for _ in range(k):\n        # 把所有可啟動的專案利潤推進最大堆\n        while i < n and projects[i][0] <= w:\n            heapq.heappush(max_heap, -projects[i][1])\n            i += 1\n        # 若沒有可選擇的專案則結束\n        if not max_heap:\n            break\n        # 取最大的利潤並加入資本\n        w += -heapq.heappop(max_heap)\n    return w\n\ndef solve() -> None:\n    data = sys.stdin.read()\n    # 取出所有整數，順序為 k, w, profits..., capital...\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    k, w = nums[0], nums[1]\n    rest = nums[2:]\n    # 兩個列表長度相等，將剩餘數字平均分為 profits 和 capital\n    n = len(rest) // 2\n    profits = rest[:n]\n    capital = rest[n:]\n    result = find_maximized_capital(k, w, profits, capital)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode242.json",
    "problem_index_in_file": 0,
    "title": "Valid Anagram",
    "description_snippet": "Given two strings s and t, return true if t is an anagram of s, and false otherwise....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code lines: Start, input strings, maybe compute frequency, compare, return result, End. We should use arrows. Use decision: if lengths equal, then maybe count, compare. Or just use frequency array. Let's produce.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrow: \"→ Step 1: ...\". We'll start with Start. Then input strings. Then Decision if lengths equal. If not, return false. If equal, proceed to count frequencies. We can do: array[26] zeros. Then iterate over s and t. Update counts. Then Decision: if all zero, return true else false. Or compare arrays.\n\nLet's produce.\n\nAlso we must use \"Decision:\" structure.\n\nLet's produce:\n\nStart\n→ Step 1: 獲取輸入字符串 s 和 t // 取得兩個待比對的字串\n→ Decision: 若 s 與 t 長度不相等? // anagram 必須長度相同\n    No → Step 2: 創建 26 個元素的整數陣列 freq，初始化為 0 // 用於記錄字母出現次數\n    → Step 3: 對 s 的每個字符 c 進行 freq[c - 'a']++ // s 中每個字母次數加一\n    → Step 4: 對 t 的每個字符 c 進行 freq[c - 'a']-- // t 中每個字母次數減一\n    → Decision: 所有 freq 值是否均為 0? // 若相等，則字母統計相同\n        Yes → Step 5: 回傳 true // t 是 s 的字母異位詞\n        No  → Step 6: 回傳 false // t 不是 s 的字母異位詞\n    End\n    Yes → Step 7: 回傳 false // 長度不同，直接判定非異位詞\nEnd\n\nWe should add explanation after each line. Use arrow: \"→\" before each step. Decision lines start with \"Decision:\".\n\nEnsure each line ends with \"// 解釋\". The Decision lines also include explanation after. The nested steps inside decision? We need indentation? The example didn't indent but had indent. We'll use indent with 4 spaces for nested. Keep consistent. For arrow lines indent 4 spaces.\n\nLet's write final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 獲取輸入字符串 s 和 t // 取得兩個待比對的字串\n→ Decision: 若 s 與 t 長度不相等? // anagram 必須長度相同\n    Yes → Step 7: 回傳 false // 長度不同，直接判定非異位詞\n    No  → Step 2: 創建 26 個元素的整數陣列 freq，初始化為 0 // 用於記錄字母出現次數\n        → Step 3: 對 s 的每個字符 c 進行 freq[c - 'a']++ // s 中每個字母次數加一\n        → Step 4: 對 t 的每個字符 c 進行 freq[c - 'a']-- // t 中每個字母次數減一\n        → Decision: 所有 freq 值是否均為 0? // 若相等，則字母統計相同\n            Yes → Step 5: 回傳 true // t 是 s 的字母異位詞\n            No  → Step 6: 回傳 false // t 不是 s 的字母異位詞\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \"\"\"Return True if t is an anagram of s, False otherwise.\"\"\"\n        if len(s) != len(t):\n            return False\n        freq = [0] * 26\n        for c in s:\n            freq[ord(c) - 97] += 1\n        for c in t:\n            freq[ord(c) - 97] -= 1\n        return all(f == 0 for f in freq)\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read()\n\n    # Try to extract quoted strings, e.g. s = \"anagram\", t = \"nagaram\"\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        s, t = matches[0], matches[1]\n    else:\n        # Fallback: split by whitespace\n        tokens = data.split()\n        if len(tokens) >= 2:\n            s, t = tokens[0], tokens[1]\n        else:\n            s = tokens[0] if tokens else ''\n            t = ''\n\n    result = Solution().isAnagram(s, t)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"anagram\", t = \"nagaram\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"rat\", t = \"car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode301.json",
    "problem_index_in_file": 0,
    "title": "Remove Invalid Parentheses",
    "description_snippet": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parenth...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for algorithm to remove invalid parentheses to produce all unique valid strings with minimal removals. Standard solution: BFS or DFS with pruning, or count removals needed left and right. Use DFS with backtracking, skip duplicates. Provide algorithm steps: compute left/right removals needed. Then recursive function to generate. Need to output as virtual code lines with explanations. Format: lines like \"Start // ...\", \"→ Step 1: ...\". Should use decision arrows.\n\nWe'll produce steps: start, compute removals, define DFS, iterate over characters, if '(' increase left count else if ')' and right count >0 skip etc. Provide steps to build string, use set for results. End.\n\nWe need to keep virtual code lines for each logical step. Since not actual code, but pseudo steps. Provide as lines. Use decision arrows.\n\nLet's craft:\n\nStart // Program starts\n\n→ Step 1: Input string s // receive the string\n\n→ Step 2: Initialize left=0, right=0 // counts for removals\n\n→ Decision: For each char c in s? // iterate\n\n    → If c=='(' // increment left\n\n    → Else if c==')' // if left==0 then right++ else left--\n\nAfter loop, left/right hold minimal removals needed.\n\n→ Step 3: Define ResultSet = empty set // store unique results\n\n→ Step 4: Call DFS(startIndex=0, leftRem=left, rightRem=right, curString=\"\") // recursive build\n\n→ Inside DFS:\n\n    Decision: If startIndex==len(s) // reached end\n\n        → If leftRem==0 and rightRem==0 // valid string\n\n            → Add curString to ResultSet\n\n        → Return\n\n    → Let c = s[startIndex]\n\n    Decision: If c is '(' or ')' // potential removal\n\n        → If c=='(' and leftRem>0\n\n            → DFS(startIndex+1, leftRem-1, rightRem, curString) // skip '('\n\n        → If c==')' and rightRem>0\n\n            → DFS(startIndex+1, leftRem, rightRem-1, curString) // skip ')'\n\n    → Decision: If c=='(' // need to keep\n\n        → DFS(startIndex+1, leftRem, rightRem, curString+'(')\n\n    → Decision: If c==')' // need to keep only if leftRem==0\n\n        → If leftRem==0\n\n            → DFS(startIndex+1, leftRem, rightRem, curString+')')\n\n    → Else // c is letter\n\n        → DFS(startIndex+1, leftRem, rightRem, curString+c)\n\nEnd // finish\n\nReturn list(ResultSet)\n\nWe need to format each line with arrow or decision.\n\nBetter to format: \"→ Decision: ...\"\n\nLet's write each step.\n\nWe'll produce maybe 30-40 lines.\n\nRemember: every line must be \"虛擬碼步驟 [space] // 解釋\". Use arrows: \"→\", \"Decision:\".\n\nLet's produce.\n\nWe need to start with Start line.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得待處理的原始字串  \n→ Step 2: 初始化 left = 0, right = 0 // 用於計算需要刪除的左右括號數量  \n\n→ Decision: 對每個字元 c 在 s 進行迴圈  \n  → If c == '(' // 遇到左括號  \n    → left++ // 需要更多右括號來配對  \n    → Decision: 如果左括號已經足夠?  \n      No → 執行下個字元  \n      Yes → 右括號數量減一，左括號數量減一  \n        // 這裡表示已配對，減少需要刪除的右括號  \n        左括號減一，右括號減一  \n        // 但在計算階段通常不需要這一步，直接計算 left/right  \n        // 這行僅為說明  \n    → Decision: 如果右括號多於左括號?  \n      No → 執行下個字元  \n      Yes → right++ // 右括號沒有左括號配對，記錄需要刪除  \n    → 執行下個字元  \n  → If c == ')' // 遇到右括號  \n    → Decision: 如果 left == 0?  \n      Yes → right++ // 無左括號可配對，右括號需要刪除  \n      No → left-- // 有左括號可配對，減少左括號需求  \n  → 執行下個字元  \n  → Else // 字母  \n    → 執行下個字元  \nEnd // 完成左右括號需求計算  \n\n→ Step 3: 建立空集合 ResultSet = {} // 用於儲存唯一合法字串  \n\n→ Step 4: 呼叫 DFS(0, left, right, \"\") // 從索引 0 開始遞迴搜尋  \n  → DFS(index, leftRem, rightRem, current)  \n   → Decision: 如果 index == len(s) // 已處理完所有字元  \n      → Decision: 如果 leftRem == 0 AND rightRem == 0?  \n        Yes → ResultSet.add(current) // 目前字串合法且已刪除最少括號  \n        No → 返回 // 不合法，忽略  \n      → 返回  \n   → Decision: 取 s[index] 為 c  \n   → Decision: 是否為可刪除字元?（'(' 或 ')'）  \n      → Decision: c == '(' 且 leftRem > 0?  \n        Yes → DFS(index+1, leftRem-1, rightRem, current) // 刪除 '('  \n        No → 無操作  \n      → Decision: c == ')' 且 rightRem > 0?  \n        Yes → DFS(index+1, leftRem, rightRem-1, current) // 刪除 ')'  \n        No → 無操作  \n   → Decision: 是否保留 c?  \n      → Decision: c == '('?  \n        Yes → DFS(index+1, leftRem, rightRem, current + '(') // 保留 '('  \n        No → 無操作  \n      → Decision: c == ')' 且 leftRem == 0?  \n        Yes → DFS(index+1, leftRem, rightRem, current + ')') // 只在有足夠左括號時保留 ')'  \n        No → 無操作  \n      → Decision: c 是字母?  \n        Yes → DFS(index+1, leftRem, rightRem, current + c) // 直接保留字母  \n        No → 無操作  \n\n→ Step 5: 回傳 ResultSet 轉成列表 // 輸出所有唯一合法字串  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        # 計算需要刪除的左括號和右括號數量\n        left, right = 0, 0\n        for ch in s:\n            if ch == '(':\n                left += 1\n            elif ch == ')':\n                if left == 0:\n                    right += 1\n                else:\n                    left -= 1\n\n        res = set()\n\n        def dfs(index: int, left_rem: int, right_rem: int, path: str, balance: int):\n            \"\"\"\n            index      : 當前處理的字元位置\n            left_rem   : 仍須刪除的左括號數\n            right_rem  : 仍須刪除的右括號數\n            path       : 已經構造好的字串\n            balance    : 當前 '(' 的個數減去 ')' 的個數\n            \"\"\"\n            if index == len(s):\n                if left_rem == 0 and right_rem == 0 and balance == 0:\n                    res.add(path)\n                return\n\n            ch = s[index]\n\n            # 1. 嘗試刪除當前括號（如果是括號且有剩餘可刪除）\n            if ch == '(' and left_rem > 0:\n                dfs(index + 1, left_rem - 1, right_rem, path, balance)\n            if ch == ')' and right_rem > 0:\n                dfs(index + 1, left_rem, right_rem - 1, path, balance)\n\n            # 2. 保留當前字元\n            if ch == '(':\n                dfs(index + 1, left_rem, right_rem, path + ch, balance + 1)\n            elif ch == ')':\n                if balance > 0:\n                    dfs(index + 1, left_rem, right_rem, path + ch, balance - 1)\n            else:  # 字母\n                dfs(index + 1, left_rem, right_rem, path + ch, balance)\n\n        dfs(0, left, right, \"\", 0)\n        return list(res)\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從輸入字串中抽取要處理的字串 s。\n    支援兩種形式：\n    1. s = \"...\"\n    2. 直接給字串\n    \"\"\"\n    raw = raw.strip()\n    if raw.lower().startswith(\"s\"):\n        # 可能是 \"s = \\\"...\\\"\" 或 \"s = '...'\"\n        _, _, value = raw.partition(\"=\")\n        value = value.strip()\n        if (value.startswith('\"') and value.endswith('\"')) or (value.startswith(\"'\") and value.endswith(\"'\")):\n            value = value[1:-1]\n        return value\n    return raw\n\n\ndef main():\n    data = sys.stdin.read()\n    s = parse_input(data)\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    # 輸出為 JSON 格式，保持原始字串的順序不重要\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "success": true,
          "output": "[\"(a())()\", \"(a)()()\"]"
        },
        {
          "example_index": 2,
          "input": "s = \")(\"",
          "expected_output": "[\"\"]",
          "success": true,
          "output": "[\"\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode482.json",
    "problem_index_in_file": 0,
    "title": "License Key Formatting",
    "description_snippet": "You are given a license key represented as a string s that consists of only alphanumeric characters ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for reformat license key. Steps: remove dashes, uppercase, compute groups, handle first group length mod k. Build result. End. Provide each line with arrow etc.\n\nWe need to output lines: Start, then steps. Use \"→\" arrow each step. Use Decision for conditions. Provide explanation comments. Not actual code.\n\nLet's design:\n\nStart\n→ Step 1: Remove all dashes from s // Clean string\n→ Step 2: Convert cleaned string to uppercase // Uppercase letters\n→ Decision: If length of cleaned string ≤ k? // If short\n    Yes → Step 3: Return cleaned string // Only one group\n    No → Step 4: Calculate remainder = length % k // Determine first group length\n→ Decision: If remainder == 0? // If exact division\n    Yes → Step 5: Split cleaned string into groups of k starting from index 0 // Normal groups\n    No → Step 6: FirstGroupLength = remainder // Determine first group size\n        → Step 7: Build result string with first group of length FirstGroupLength\n        → Step 8: For remaining characters, append dash and next group of k characters // Remaining groups\n→ Step 9: Return result string // Output reformatted key\nEnd\n\nBut we need each line with \"→\" for steps, \"Decision:\" for decisions. Also indentation. Use \"Yes →\" \"No →\".\n\nAlso need to compute groups, maybe using loop.\n\nWe should be careful: Step 5: Use loop to slice every k characters and join with dash. Step 7 and 8 details.\n\nLet's craft the output with lines. Include indentation. Provide explanation comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: CleanedString ← Remove all dashes from s // 先把字串裡所有 '-' 去掉\n→ Step 2: UpperString ← Convert CleanedString to uppercase // 把所有小寫字母轉成大寫\n→ Decision: 如果 UpperString 長度 ≤ k? // 檢查字串是否已經可以成為單一群組\n    Yes → Step 3: Return UpperString // 只需要回傳這一組\n    No  → Step 4: Length ← Length of UpperString // 計算字串總長\n→ Decision: 如果 Length mod k == 0? // 是否可以均分為 k 位長的群組\n    Yes → Step 5: Groups ← Split UpperString into substrings of size k starting at index 0 // 正常切分\n        → Step 6: Result ← Join Groups with '-' as separator // 用 '-' 連接所有群組\n        → Step 7: Return Result // 回傳重新格式化的字串\n    No  → Step 8: FirstGroupSize ← Length mod k // 第一群組長度\n        → Step 9: Result ← Substring of UpperString from 0 to FirstGroupSize // 取第一群組\n        → Step 10: Index ← FirstGroupSize // 設定起始位置為第一群組結束處\n        → Decision: 是否還有剩餘字元? // 檢查是否還有未處理的字元\n            Yes → Step 11: While Index < Length\n                → Step 12: Result ← Result + '-' + Substring of UpperString from Index to Index+k // 加上下一群組\n                → Step 13: Index ← Index + k // 移動到下一群組起點\n            No  → // 無剩餘字元\n        → Step 14: Return Result // 回傳重新格式化的字串\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        \"\"\"\n        1. 去除字串中的 '-'，並轉成大寫。\n        2. 先算出第一組的長度：若總長除以 K 之餘數為 0，則第一組長度為 K，否則為餘數。\n        3. 依照第一組長度切分字串，剩下的每組長度都為 K。\n        4. 以 '-' 連接各組字串。\n        \"\"\"\n        cleaned = S.replace('-', '').upper()\n        n = len(cleaned)\n        if n == 0:\n            return ''\n\n        first_len = n % K or K\n        groups = [cleaned[:first_len]]\n        for i in range(first_len, n, K):\n            groups.append(cleaned[i:i+K])\n        return '-'.join(groups)\n\ndef parse_input(lines):\n    \"\"\"\n    解析輸入資料。支援兩種常見格式：\n    1. 兩行，第一行為字串，第二行為整數。\n    2. 兩行，格式如 \"s = \\\"...\\\", k = ...\".\n    \"\"\"\n    # 取第一行非空\n    s_line = ''\n    k_line = ''\n    for line in lines:\n        if line.strip():\n            if not s_line:\n                s_line = line.strip()\n            elif not k_line:\n                k_line = line.strip()\n    # 去除可能的變數名和引號\n    if s_line.lower().startswith('s'):\n        # 取冒號或等號後面部分\n        s_val = s_line.split('=')[-1].strip()\n        s_val = s_val.strip('\"').strip(\"'\")\n    else:\n        s_val = s_line.strip('\"').strip(\"'\")\n    if k_line.lower().startswith('k'):\n        k_val = k_line.split('=')[-1].strip()\n        k_val = k_val.strip('\"').strip(\"'\")\n    else:\n        k_val = k_line\n    try:\n        k_int = int(k_val)\n    except ValueError:\n        k_int = int(k_val.split()[-1])\n    return s_val, k_int\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    s, k = parse_input(data)\n    sol = Solution()\n    result = sol.licenseKeyFormatting(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp6_nz401p.py\", line 50, in parse_input\n    k_int = int(k_val)\n            ^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp6_nz401p.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmp6_nz401p.py\", line 57, in main\n    s, k = parse_input(data)\n           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6_nz401p.py\", line 52, in parse_input\n    k_int = int(k_val.split()[-1])\n                ~~~~~~~~~~~~~^^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpk_h0xxgh.py\", line 50, in parse_input\n    k_int = int(k_val)\n            ^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpk_h0xxgh.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpk_h0xxgh.py\", line 57, in main\n    s, k = parse_input(data)\n           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk_h0xxgh.py\", line 52, in parse_input\n    k_int = int(k_val.split()[-1])\n                ~~~~~~~~~~~~~^^^^\nIndexError: list index out of range"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode373.json",
    "problem_index_in_file": 0,
    "title": "Find K Pairs with Smallest Sums",
    "description_snippet": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nD...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for algorithm: find k smallest sum pairs from two sorted arrays. Use min-heap approach. Steps: initialize heap with first element pair (nums1[0]+nums2[0], 0,0). While result size < k and heap not empty: pop smallest, add to result, push next pair if not visited: (i+1,j) and (i,j+1) maybe duplicates. We need to track visited set.\n\nWe output lines starting with Start, etc. Use arrow → for steps. Provide explanation comments.\n\nWe need to adhere to format exactly: each line \"虛擬碼步驟 // 解釋\".\n\nWe need to produce lines of virtual code. Use Start, End, Decision. Steps: initialize result list, heap, visited. Insert first pair. While condition.\n\nWe need to use arrow → after Start. Indentation: maybe indentation via spaces.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result=[], heap=[], visited=set() // 建立結果、堆、訪問集合\n→ Step 2: 如果 nums1 或 nums2 為空，End // 若任一陣列空則無結果\n→ Step 3: 堆加入 (nums1[0]+nums2[0], 0,0) // 將第一個可能的最小和加入堆\n→ Step 4: visited 加入 (0,0) // 標記已加入的索引\n→ Decision: result長度 < k AND 堆非空? // 判斷是否還需要繼續\n    Yes → Step 5: pop (sum,i,j) from heap // 取最小和\n    → Step 6: 加入 (nums1[i],nums2[j]) 到 result // 將對加入答案\n    → Decision: i+1 < len(nums1) AND (i+1,j) 未訪問? // 是否可以進一步向下\n        Yes → Step 7: 推進堆 (nums1[i+1]+nums2[j], i+1,j) // 推入下一個 i\n        → Step 8: visited 加入 (i+1,j)\n        No → // skip\n    → Decision: j+1 < len(nums2) AND (i,j+1) 未訪問? // 是否向右\n        Yes → Step 9: 推進堆 (nums1[i]+nums2[j+1], i,j+1) // 推入下一個 j\n        → Step 10: visited 加入 (i,j+1)\n        No → // skip\n    → Decision: result長度 < k AND heap非空? // 迴圈判斷\n        Yes → 回到 Step 5\n        No → End // 結束\nEnd // 程式執行結束\n\nBut we must maintain arrow after each step line. Also decision branches with indentation.\n\nWe need to ensure we use \"Decision:\" lines. Use Yes → etc.\n\nWe must adhere to pattern: each line \"虛擬碼步驟 // 解釋\" and no actual code. We can use \"Start\", \"End\", \"Decision:\" and arrow syntax.\n\nWe need to include arrows for step lines: \"→ Step X:\" etc.\n\nEnsure formatting. Let's produce.\n\nUse indentation for nested decisions. Let's output lines.\n\nCheck each line: start with \"Start\" line. Next lines start with arrow.\n\nI think we can include \"Decision:\" lines.\n\nWe need to ensure each line contains code and comment separated by space. Provide Chinese comments.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result=[], heap=[], visited=set() // 建立結果列表、最小堆及已訪問索引集合  \n→ Step 2: 如果 nums1 或 nums2 為空，則 End // 若任一陣列為空則無需進一步處理  \n→ Step 3: heap 推進 (nums1[0]+nums2[0], 0, 0) // 將最初可能的最小和加入堆  \n→ Step 4: visited 加入 (0, 0) // 標記索引 (0,0) 已加入堆  \n→ Decision: result長度 < k 且 heap 非空? // 判斷是否還需要尋找更多最小和  \n    Yes → Step 5: pop (sum, i, j) 從 heap // 取出當前最小和及其索引  \n    → Step 6: 將 (nums1[i], nums2[j]) 加入 result // 把該對加入答案  \n    → Decision: i+1 < len(nums1) 且 (i+1, j) 未訪問? // 是否可往 nums1 方向進一步  \n        Yes → Step 7: heap 推進 (nums1[i+1]+nums2[j], i+1, j) // 推入下一個 i 索引的對  \n        → Step 8: visited 加入 (i+1, j) // 標記為已訪問  \n        No → // 跳過  \n    → Decision: j+1 < len(nums2) 且 (i, j+1) 未訪問? // 是否可往 nums2 方向進一步  \n        Yes → Step 9: heap 推進 (nums1[i]+nums2[j+1], i, j+1) // 推入下一個 j 索引的對  \n        → Step 10: visited 加入 (i, j+1) // 標記為已訪問  \n        No → // 跳過  \n    → Decision: result長度 < k 且 heap 非空? // 再次判斷是否繼續循環  \n        Yes → 回到 Step 5  \n        No → End // 繼續結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\nimport heapq\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        if not nums1 or not nums2 or k <= 0:\n            return []\n        heap = []\n        res = []\n        # 將第一個 nums1 的前 min(k, len(nums1)) 個元素與 nums2[0] 形成初始堆\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n        # 依次取最小和，並把下一個 j+1 的組合入堆\n        while heap and len(res) < k:\n            sum_val, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 從輸入中提取 nums1、nums2 和 k\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    nums1 = eval(nums1_match.group(1)) if nums1_match else []\n    nums2 = eval(nums2_match.group(1)) if nums2_match else []\n    k = int(k_match.group(1)) if k_match else 0\n\n    solution = Solution()\n    result = solution.kSmallestPairs(nums1, nums2, k)\n    # 輸出不帶空格的 JSON 格式，以符合範例輸出\n    print(json.dumps(result, separators=(',', ':')))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "success": true,
          "output": "[[1,2],[1,4],[1,6]]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "success": true,
          "output": "[[1,1],[1,1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode732.json",
    "problem_index_in_file": 0,
    "title": "My Calendar III",
    "description_snippet": "A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for MyCalendarThree class with book method that returns max overlap. Likely use difference array or segment tree or sweep line. Let's produce simple sweep line using sorted map of time points increments. Steps: maintain map<time, delta>. On book: add +1 at start, -1 at end. Then iterate through sorted times accumulating current, update max. Return max. Complexity O(n log n). Provide virtual code line by line.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCalendarThree 類別 // 建立日曆物件\n→ Step 2: 在類別中新增資料成員：Map<時間, 數量> timePoints // 用於記錄時間點增減\n→ Step 3: MyCalendarThree() 初始化 timePoints 為空 map // 建構子\n→ Decision: book(start, end) 被呼叫? // 判斷是否有新增事件\n    Yes → Step 4: 在 timePoints 中 timePoints[start] += 1 // 事件開始時數量+1\n    Yes → Step 5: 在 timePoints 中 timePoints[end] -= 1 // 事件結束時數量-1\n    Yes → Step 6: 初始化 maxOverlap = 0 // 儲存目前最大重疊數\n    Yes → Step 7: 初始化 current = 0 // 當前重疊數\n    Yes → Step 8: 遍歷 timePoints 按時間升序\n        → Step 8.1: current += delta // 根據時間點增減更新當前重疊\n        → Step 8.2: 若 current > maxOverlap 則 maxOverlap = current // 更新最大值\n    Yes → Step 9: 回傳 maxOverlap // 結果為最大的 k-booking\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyCalendarThree:\n    \"\"\"\n    使用差分映射（差分陣列）來維護每個時間點的活動變化，\n    於 book 時重新計算目前最大的重疊數量。\n    \"\"\"\n    def __init__(self):\n        # key: 時間點，value: 這個時間點的活動數量變化\n        self.timeline = {}\n\n    def book(self, start: int, end: int) -> int:\n        # 事件開始時活動數量 +1\n        self.timeline[start] = self.timeline.get(start, 0) + 1\n        # 事件結束時活動數量 -1\n        self.timeline[end] = self.timeline.get(end, 0) - 1\n\n        # 計算目前最大重疊數\n        curr = 0\n        max_overlap = 0\n        for time in sorted(self.timeline):\n            curr += self.timeline[time]\n            if curr > max_overlap:\n                max_overlap = curr\n        return max_overlap\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 解析指令和參數\n    commands = json.loads(data[0])\n    arguments = json.loads(data[1]) if len(data) > 1 else []\n\n    results = []\n    calendar = None\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"MyCalendarThree\":\n            calendar = MyCalendarThree()\n            results.append(None)  # LeetCode 需要返回 null\n        elif cmd == \"book\":\n            res = calendar.book(*args)\n            results.append(res)\n        else:\n            # 若有其他指令，直接忽略或可根據需求處理\n            results.append(None)\n\n    # 將 None 轉成 null 以符合 LeetCode 輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpcqdw5t48.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpcqdw5t48.py\", line 33, in main\n    commands = json.loads(data[0])\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 68 (char 67)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode162.json",
    "problem_index_in_file": 0,
    "title": "Find Peak Element",
    "description_snippet": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for peak element problem using binary search. Provide each line with arrow and comment.\n\nMake sure lines include Start, End, Decision: etc. Use \"→\" arrow after Start maybe \"Start\". Provide each step as described. Must use 0-indexed array.\n\nPseudo steps:\n\nStart\n→ Step: Set low=0, high=length-1 // 初始化搜索区间\n→ Decision: low <= high? // 检查区间是否为空\n    Yes → Step: mid=(low+high)//2 // 计算中点\n    Yes → Decision: nums[mid] > nums[mid+1]? // 与右侧比较\n        Yes → Decision: nums[mid] > nums[mid-1]? // 与左侧比较\n            Yes → Step: Return mid // mid 是峰值\n            No  → Step: high=mid-1 // 峰在左侧\n        No  → Step: low=mid+1 // 峰在右侧\n    No  → End // 结束\nEnd\n\nBut we need O(log n). Also need to handle boundaries: if mid==0 or mid==n-1, we can treat neighbor as -∞. We'll just check conditions accordingly.\n\nWe can incorporate boundary conditions in decisions.\n\nProvide explanation after each line.\n\nLet's produce virtual code lines. Use arrow \"→\" for each step. Use indentation for decisions.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step: low ← 0, high ← length(nums)-1 // 初始化搜索區間\n→ Decision: low <= high? // 檢查是否還有元素可搜尋\n    Yes → Step: mid ← (low + high) // 2 // 取中點\n    Yes → Decision: nums[mid] > nums[mid+1]? // 比較與右鄰\n        Yes → Decision: mid==0 OR nums[mid] > nums[mid-1]? // 還要確保比左鄰大\n            Yes → Step: return mid // 找到峰值\n            No  → Step: high ← mid-1 // 峰值在左側\n        No  → Step: low ← mid+1 // 峰值在右側\n    No  → End // 搜尋結束\n\nBut we might need to handle boundary for mid==length-1 when accessing nums[mid+1]. Use condition \"mid < high\" else treat as -∞. For simplicity, we can just check mid < high before comparing to nums[mid+1], else treat as true. Similarly left neighbor.\n\nAlternatively, we can handle in decision: if mid == high or nums[mid] > nums[mid+1], treat as right side condition satisfied.\n\nLet's produce step with this logic.\n\nAlso need final End line.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: low ← 0, high ← length(nums)-1 // 初始化搜尋區間  \n→ Decision: low ≤ high? // 檢查是否還有元素可搜尋  \n  Yes → Step: mid ← (low + high) // 2 // 取得中點  \n  Yes → Decision: mid = high OR nums[mid] > nums[mid+1]? // 與右鄰比較，若右邊不存在則視為 -∞  \n    Yes → Decision: mid = 0 OR nums[mid] > nums[mid-1]? // 與左鄰比較，若左邊不存在則視為 -∞  \n     Yes → Step: return mid // mid 為峰值  \n     No  → Step: high ← mid-1 // 峰值在左側  \n    No  → Step: low ← mid+1 // 峰值在右側  \n  No  → End // 搜尋結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    \"\"\"\n    Find a peak element in an array using binary search.\n    A peak element is strictly greater than its neighbors.\n    \"\"\"\n    def findPeakElement(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[mid + 1]:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(input_str):\n    \"\"\"\n    Extract integer list from input string.\n    Supports formats like:\n        nums = [1,2,3,1]\n    \"\"\"\n    numbers = list(map(int, re.findall(r'-?\\d+', input_str)))\n    return numbers\n\ndef main():\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    if not nums:\n        # If the list is empty, nothing to do (problem constraints assume non-empty)\n        return\n    solution = Solution()\n    peak_index = solution.findPeakElement(nums)\n    print(peak_index)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,3,5,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode736.json",
    "problem_index_in_file": 0,
    "title": "Parse Lisp Expression",
    "description_snippet": "You are given a string expression representing a Lisp-like expression to return the integer value of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for evaluating such expression. Provide a step-by-step algorithm: parse, evaluate recursively with environment stack. Provide virtual code line by line. Let's outline:\n\nStart\n→ Step 1: Parse expression string into tokens // Tokenize\n→ Step 2: Call Evaluate(tokens, envStack) // Recursively evaluate\n→ In Evaluate:\n   Decision: If token is '(' then\n      -> Read operator\n      -> If operator is 'let'\n           - create new scope env\n           - for each pair until last expr\n               * evaluate expression e\n               * assign to variable in current scope\n           - evaluate final expr in envStack\n           - pop scope\n      -> If operator is 'add' or 'mult'\n           - evaluate first operand\n           - evaluate second operand\n           - compute\n      -> else error\n   Decision: Else if token is integer // parse int\n   Decision: Else token is variable\n           - lookup variable in envStack from innermost to outermost\n→ Step 3: Return result\nEnd\n\nWe need to include arrow and decision steps.\n\nLet's produce virtual code lines. Each line should include a brief explanation comment.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: Tokenize the input expression string into a list of tokens // 將輸入字串拆分成單獨的標記\n→ Step 2: Create an empty environment stack // 建立空的環境堆疊用於變量作用域\n→ Step 3: Call Evaluate(tokens, envStack) and store result // 進行遞歸評估，得到整數結果\n→ Step 4: Output result // 將最終整數輸出\nEnd // 程式執行結束\n\nNow define Evaluate procedure as subroutine; but we need to produce virtual code for Evaluate logic line by line. We can use a subroutine block.\n\nWe can write:\n\n→ Sub Evaluate(tokens, envStack) // 評估一個表達式，返回整數\n\nInside, we need to read next token; but we can treat tokens list pointer. We'll use pseudo variable idx.\n\nBetter to treat tokens as queue.\n\nLet's write:\n\n→ Decision: If next token is '(' // 判斷是否為複合表達式\n    Yes →\n        → Consume '(' // 移除左括號\n        → Read operator token // 讀取操作符\n        → Decision: If operator == 'let'\n            Yes →\n                → Push new empty scope onto envStack // 新建一個局部作用域\n                → Loop while there are more than two tokens left before ')'\n                    → Read variable name // 變量名\n                    → Evaluate next expression recursively // 計算其值\n                    → Assign value to variable in current scope // 存入環境\n                → Evaluate final expression inside let // 最後一個表達式\n                → Pop scope from envStack // 退出局部作用域\n                → Return result // 返還 let 表達式值\n            No →\n                → Decision: If operator == 'add' or 'mult'\n                    Yes →\n                        → Evaluate first operand recursively // 先計算第一個子表達式\n                        → Evaluate second operand recursively // 再計算第二個子表達式\n                        → Decision: If operator == 'add'\n                            Yes → Return sum of operands // add 的結果\n                            No  → Return product of operands // mult 的結果\n                    No → Error // 非法操作符\n        → Consume ')' // 移除右括號\n    No →\n        → Decision: If token is an integer // 直接整數\n            Yes → Convert token to integer and return // 轉成整數回傳\n            No  → // token 是變量名\n                → Lookup variable value from envStack (innermost first)\n                → Return the found value // 取得並回傳變量值\n\nBut we need to produce lines accordingly.\n\nWe need to be careful: We cannot produce nested subroutines lines? It's okay.\n\nWe can include subroutine start and end.\n\nLet's produce lines:\n\n→ Sub Evaluate(tokens, envStack) // 評估一個表達式，返回整數\n→ Decision: If tokens.peek() == '(' // 檢查是否為複合表達式\n    Yes →\n        → tokens.consume('(') // 移除左括號\n        → op = tokens.consume() // 讀取操作符\n        → Decision: If op == 'let'\n            Yes →\n                → envStack.push({}) // 新建局部作用域\n                → While tokens.peek() != ')'\n                    → varName = tokens.consume() // 讀取變量名\n                    → value = Evaluate(tokens, envStack) // 計算對應表達式\n                    → envStack.top()[varName] = value // 設定變量\n                → result = Evaluate(tokens, envStack) // 計算 let 的最後表達式\n                → envStack.pop() // 退出局部作用域\n                → Return result // 回傳 let 結果\n            No →\n                → Decision: If op == 'add' or op == 'mult'\n                    Yes →\n                        → left = Evaluate(tokens, envStack) // 先計算左邊\n                        → right = Evaluate(tokens, envStack) // 再計算右邊\n                        → Decision: If op == 'add'\n                            Yes → Return left + right // 加法\n                            No  → Return left * right // 乘法\n                    No → Error // 非法操作符\n        → tokens.consume(')') // 移除右括號\n    No →\n        → token = tokens.consume() // 取得單個標記\n        → Decision: If token is integer\n            Yes → Return int(token) // 轉成整數回傳\n            No  → // 變量名\n                → For scope in reverse(envStack) // 從內層到外層搜尋\n                    → If varName in scope\n                        Yes → Return scope[varName] // 回傳找到的值\n                        No  → Continue\n                → Error // 未定義變量\n→ End Sub // 評估子程式結束\n\nBut we need each line with virtual code step + comment. We'll list them sequentially.\n\nLet's craft final output accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Tokenize the input expression string into a list of tokens // 將輸入字串拆分成單獨的標記  \n→ Step 2: Create an empty environment stack // 建立空的環境堆疊用於變量作用域  \n→ Step 3: Call Evaluate(tokens, envStack) and store result // 進行遞歸評估，得到整數結果  \n→ Step 4: Output result // 將最終整數輸出  \nEnd // 程式執行結束  \n\n→ Sub Evaluate(tokens, envStack) // 評估一個表達式，返回整數  \n→ Decision: If tokens.peek() == '(' // 檢查是否為複合表達式  \n Yes →  \n  → tokens.consume('(') // 移除左括號  \n  → op = tokens.consume() // 讀取操作符  \n  → Decision: If op == 'let' // 判斷是否為 let 表達式  \n   Yes →  \n    → envStack.push({}) // 新建局部作用域  \n    → While tokens.peek() != ')'  \n     → varName = tokens.consume() // 讀取變量名  \n     → value = Evaluate(tokens, envStack) // 計算對應表達式  \n     → envStack.top()[varName] = value // 設定變量  \n    → result = Evaluate(tokens, envStack) // 計算 let 的最後表達式  \n    → envStack.pop() // 退出局部作用域  \n    → Return result // 回傳 let 結果  \n   No →  \n    → Decision: If op == 'add' or op == 'mult' // 判斷是加法或乘法  \n     Yes →  \n      → left = Evaluate(tokens, envStack) // 計算第一個子表達式  \n      → right = Evaluate(tokens, envStack) // 計算第二個子表達式  \n      → Decision: If op == 'add'  \n       Yes → Return left + right // 加法  \n       No  → Return left * right // 乘法  \n     No → Error // 非法操作符  \n  → tokens.consume(')') // 移除右括號  \n No →  \n  → token = tokens.consume() // 取得單個標記  \n  → Decision: If token is integer // 直接整數  \n   Yes → Return int(token) // 轉成整數回傳  \n   No  → // token 為變量名  \n    → For scope in reverse(envStack) // 從內層到外層搜尋  \n     If varName in scope  \n      Return scope[varName] // 回傳找到的值  \n     Else Continue  \n    → Error // 未定義變量  \n→ End Sub // 評估子程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"\n        Evaluate a Lisp-like expression and return its integer value.\n        \"\"\"\n        # 1. Tokenize the expression\n        def tokenize(s: str):\n            tokens = []\n            i = 0\n            while i < len(s):\n                if s[i] in '()':\n                    tokens.append(s[i])\n                    i += 1\n                elif s[i] == ' ':\n                    i += 1\n                else:\n                    j = i\n                    while j < len(s) and s[j] not in ' ()':\n                        j += 1\n                    tokens.append(s[i:j])\n                    i = j\n            return tokens\n\n        # 2. Recursive evaluation using an index pointer\n        def eval_tokens(tokens, idx, env):\n            # If current token is a number or variable\n            if tokens[idx] != '(':\n                token = tokens[idx]\n                if token[0].isalpha():          # variable\n                    return env[token], idx + 1\n                else:                            # integer literal\n                    return int(token), idx + 1\n\n            # Skip '('\n            idx += 1\n            op = tokens[idx]\n            idx += 1\n\n            # Handle add / mult\n            if op == 'add' or op == 'mult':\n                left, idx = eval_tokens(tokens, idx, env)\n                right, idx = eval_tokens(tokens, idx, env)\n                assert tokens[idx] == ')'\n                idx += 1\n                return (left + right if op == 'add' else left * right), idx\n\n            # Handle let\n            if op == 'let':\n                # Create a new scope copying the current environment\n                new_env = env.copy()\n                # Process variable/value pairs until the final expression\n                while idx <= len(tokens) - 2:   # at least two tokens left before ')'\n                    # If the current token is the final expression\n                    if idx == len(tokens) - 2:\n                        break\n                    var = tokens[idx]\n                    idx += 1\n                    val, idx = eval_tokens(tokens, idx, new_env)\n                    new_env[var] = val\n                # Evaluate the final expression\n                val, idx = eval_tokens(tokens, idx, new_env)\n                assert tokens[idx] == ')'\n                idx += 1\n                return val, idx\n\n            # Should never reach here for valid input\n            raise ValueError(f\"Unknown operator: {op}\")\n\n        tokens = tokenize(expression)\n        result, _ = eval_tokens(tokens, 0, {})\n        return result\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    # Extract the expression string between the first pair of double quotes\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        # Fallback: remove leading \"expression = \" if present\n        expr = data.replace(\"expression = \", \"\").strip()\n    sol = Solution()\n    print(sol.evaluate(expr))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpw8tiohtl.py\", line 87, in <module>\n    print(sol.evaluate(expr))\n          ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpw8tiohtl.py\", line 73, in evaluate\n    result, _ = eval_tokens(tokens, 0, {})\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpw8tiohtl.py\", line 61, in eval_tokens\n    val, idx = eval_tokens(tokens, idx, new_env)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpw8tiohtl.py\", line 33, in eval_tokens\n    return env[token], idx + 1\n           ~~~^^^^^^^\nKeyError: 'mult'"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp4ou9bt4r.py\", line 87, in <module>\n    print(sol.evaluate(expr))\n          ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4ou9bt4r.py\", line 73, in evaluate\n    result, _ = eval_tokens(tokens, 0, {})\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4ou9bt4r.py\", line 61, in eval_tokens\n    val, idx = eval_tokens(tokens, idx, new_env)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4ou9bt4r.py\", line 33, in eval_tokens\n    return env[token], idx + 1\n           ~~~^^^^^^^\nKeyError: 'add'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode87.json",
    "problem_index_in_file": 0,
    "title": "Scramble String",
    "description_snippet": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the st...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to check if s2 is scrambled string of s1. Classic problem: recursion, memoization. We'll produce pseudo-code with Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow. We'll include recursion. Use map for memo.\n\nWe output step lines. Each line \"Step ...\". Use arrows \"→\". Use Decision. Ensure start and end. Let's produce.\n\nPseudo steps:\nStart\n→ Step 1: Define function IsScramble(a, b) // main recursive\n→ Decision: If lengths differ? -> No => false\n→ Decision: If a equals b? -> Yes => true\n→ Decision: If sorted(a) != sorted(b)? -> No => false // pruning\n→ Step 2: Memo key = a+'#'+b; if memo contains key return memo[key]\n→ Step 3: For i from 1 to len-1: // split positions\n    → Decision: If IsScramble(a[0:i], b[0:i]) AND IsScramble(a[i:], b[i:])? -> Yes => memo[key]=true; return true\n    → Decision: If IsScramble(a[0:i], b[len-i:]) AND IsScramble(a[i:], b[0:len-i])? -> Yes => memo[key]=true; return true\n→ Step 4: Memo[key]=false; return false\n→ End of function\n→ Step 5: Call IsScramble(s1, s2) // entry\n→ End // program finish\n\nNeed to use arrows. We'll format each line accordingly.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 IsScramble(a, b) // 建立遞迴判斷兩字串是否為雜湊關係  \n→ Decision: 如果 len(a) ≠ len(b)? // 字串長度不符即不可能  \n  Yes → Return False // 回傳假  \n  No →  \n   Decision: 如果 a == b? // 完全相同即為雜湊  \n    Yes → Return True // 回傳真  \n    No →  \n     Decision: 如果 sorted(a) ≠ sorted(b)? // 字母多寡不同即不可能  \n      Yes → Return False  \n      No →  \n       Step 2: key = a + \"#\" + b // 建立記憶化鍵  \n       Decision: 如果 memo 已存 key?  \n        Yes → Return memo[key] // 直接取回結果  \n        No →  \n         Step 3: 對 i 從 1 到 len(a)-1 做分割  \n         → Decision: 如果 IsScramble(a[0:i], b[0:i]) AND IsScramble(a[i:], b[i:])? // 正序分割成功  \n           Yes → memo[key] = True; Return True  \n           No →  \n            Decision: 如果 IsScramble(a[0:i], b[len(b)-i:]) AND IsScramble(a[i:], b[0:len(b)-i])? // 交換分割成功  \n             Yes → memo[key] = True; Return True  \n             No →  \n             (迴圈結束後)  \n          → Step 4: memo[key] = False; Return False // 無分割方式可行  \n→ End of function // 斷定遞迴結束  \n→ Step 5: Result = IsScramble(s1, s2) // 呼叫入口函式  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        memo = {}\n\n        def dfs(x: str, y: str) -> bool:\n            if (x, y) in memo:\n                return memo[(x, y)]\n            if x == y:\n                memo[(x, y)] = True\n                return True\n            if sorted(x) != sorted(y):\n                memo[(x, y)] = False\n                return False\n\n            n = len(x)\n            for i in range(1, n):\n                # Without swapping\n                if dfs(x[:i], y[:i]) and dfs(x[i:], y[i:]):\n                    memo[(x, y)] = True\n                    return True\n                # With swapping\n                if dfs(x[:i], y[-i:]) and dfs(x[i:], y[:-i]):\n                    memo[(x, y)] = True\n                    return True\n\n            memo[(x, y)] = False\n            return False\n\n        return dfs(s1, s2)\n\ndef parse_input(data: str):\n    \"\"\"從輸入文字中提取兩個字串，若找不到，嘗試以空白分隔。\"\"\"\n    quotes = re.findall(r'\"([^\"]*)\"', data)\n    if len(quotes) >= 2:\n        return quotes[0], quotes[1]\n    # 若沒有引號，直接以空白拆分\n    parts = data.replace(',', ' ').split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    return \"\", \"\"\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    s1, s2 = parse_input(raw)\n    result = Solution().isScramble(s1, s2)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"great\", s2 = \"rgeat\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"abcde\", s2 = \"caebd\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s1 = \"a\", s2 = \"a\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode34.json",
    "problem_index_in_file": 0,
    "title": "Find First and Last Position of Element in Sorted Array",
    "description_snippet": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending positio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with explanation. It should implement binary search to find first and last positions. Should be O(log n). We'll output virtual steps.\n\nWe need to follow output format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. Start, End, Decision. No actual code.\n\nWe need to produce steps:\n\nStart\n→ Step 1: Define left = 0, right = length-1 // Initialize bounds\n→ Decision: if left > right? // check if array empty\n   Yes → Step 2: Return [-1,-1] // no target\n   No  → Proceed\n\nWe need to find leftmost index: use binary search variant.\n\n→ Step 3: While left < right: // find leftmost\n   Decision: if nums[mid] >= target? // mid index\n       Yes → right = mid // move right boundary\n       No  → left = mid + 1 // move left boundary\n\nAfter loop, left is candidate. Check if nums[left] == target. If not, return [-1,-1].\n\nIf found, set start = left.\n\nThen find rightmost: set right = len-1; left = start maybe.\n\nWe can reuse similar loop:\n\n→ Step 4: left = start, right = len-1\n→ While left < right: // find rightmost\n   Decision: if nums[mid] <= target?\n       Yes → left = mid + 1\n       No  → right = mid\n\nAfter loop, right is candidate; adjust: right = left-1 maybe. Or use other variant. Let's produce variant: after loop, right = left-1. Or we can use while left <= right variant.\n\nSimpler: use binary search to find upper bound: left = start; right = len-1; while left <= right: mid = (left+right)//2; if nums[mid] <= target: left = mid +1; else right = mid -1. Then right is last index.\n\nWe need to produce steps accordingly.\n\nLet's produce final steps:\n\nStart\n→ Step 1: left = 0, right = len(nums)-1 // 初始化左右指標\n→ Decision: if left > right? // 空陣列\n   Yes → Step 2: return [-1,-1] // 直接結束\n   No  → Continue\n\n→ Step 3: while left < right: // 搜尋左端位置\n   Decision: if nums[(left+right)//2] >= target?\n       Yes → right = (left+right)//2\n       No  → left = (left+right)//2 + 1\n→ Step 4: if nums[left] != target? // 未找到目標\n   Yes → return [-1,-1]\n   No  → start = left // 左端位置\n\n→ Step 5: right = len(nums)-1, left = start // 設定右端搜尋範圍\n→ While left <= right: // 搜尋右端位置\n   mid = (left+right)//2\n   Decision: if nums[mid] <= target?\n       Yes → left = mid + 1\n       No  → right = mid - 1\n→ Step 6: end = right // 最後一個 target 的索引\n\n→ Step 7: return [start, end] // 回傳區間\n\nEnd\n\nWe need each line: 虛擬碼步驟 // 解釋. Use arrow \"→\" before each step.\n\nMake sure we use \"Start\" and \"End\".\n\nLet's format exactly as required.\n\nAlso include decisions with indentation and arrow lines.\n\nUse \"Decision:\" lines.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = len(nums)-1 // 初始化左右指標  \n→ Decision: 如果 left > right? // 判斷陣列是否為空  \n  Yes → Step 2: return [-1,-1] // 空陣列直接回傳 -1  \n  No  → 進行下一步  \n\n→ Step 3: while left < right: // 搜尋左端（最小索引）  \n  Decision: 如果 nums[(left+right)//2] >= target? // 判斷中間值是否大於等於目標  \n   Yes → right = (left+right)//2 // 把右邊界移到中間  \n   No  → left = (left+right)//2 + 1 // 把左邊界移到中間+1  \n\n→ Decision: 如果 nums[left] != target? // 找不到目標  \n  Yes → return [-1,-1] // 回傳 -1  \n  No  → start = left // 左端索引已確定  \n\n→ Step 5: right = len(nums)-1, left = start // 設定搜尋右端的範圍  \n→ while left <= right: // 搜尋右端（最大索引）  \n  mid = (left+right)//2  \n  Decision: 如果 nums[mid] <= target? // 判斷中間值是否小於等於目標  \n   Yes → left = mid + 1 // 把左邊界移到中間+1  \n   No  → right = mid - 1 // 把右邊界移到中間-1  \n\n→ Step 6: end = right // right 為最後一個目標元素的索引  \n\n→ Step 7: return [start, end] // 回傳目標區間  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def searchRange(self, nums, target):\n        \"\"\"Return the starting and ending position of target in sorted nums using binary search.\"\"\"\n        # Find leftmost (first) index\n        left, right = 0, len(nums) - 1\n        left_index = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] >= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n            if nums[mid] == target:\n                left_index = mid\n\n        # If target not found, return [-1, -1]\n        if left_index == -1:\n            return [-1, -1]\n\n        # Find rightmost (last) index\n        left, right = left_index, len(nums) - 1\n        right_index = left_index\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n            if nums[mid] == target:\n                right_index = mid\n\n        return [left_index, right_index]\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract nums list\n    nums_match = re.search(r'nums\\s*=\\s*\\[(.*?)\\]', data)\n    if nums_match:\n        nums_str = nums_match.group(1).strip()\n        if nums_str:\n            nums = [int(x.strip()) for x in nums_str.split(',')]\n        else:\n            nums = []\n    else:\n        nums = []\n\n    # Extract target value\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    target = int(target_match.group(1)) if target_match else 0\n\n    # Solve and print result\n    sol = Solution()\n    res = sol.searchRange(nums, target)\n    print(f'[{res[0]},{res[1]}]')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,7,7,8,8,10], target = 8",
          "expected_output": "[3,4]",
          "success": true,
          "output": "[3,4]"
        },
        {
          "example_index": 1,
          "input": "nums = [5,7,7,8,8,10], target = 6",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1,-1]"
        },
        {
          "example_index": 2,
          "input": "nums = [], target = 0",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1,-1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode771.json",
    "problem_index_in_file": 0,
    "title": "Jewels and Stones",
    "description_snippet": "You're given strings jewels representing the types of stones that are jewels, and stones representin...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm steps, line by line, with comments after a space. The algorithm: Count stones that are in jewels string. Use set for jewels, iterate over stones and count.\n\nWe should produce steps: Start, Decision: maybe build set, iterate, etc. Use arrows and Decision. Let's write:\n\nStart\n→ Step 1: Convert jewels string to a set of characters // for O(1) lookups\n→ Step 2: Initialize counter to 0 // count jewels in stones\n→ Step 3: For each character c in stones // iterate through stones\n→ Decision: If c exists in jewel set? // check membership\n    Yes → Step 4: Increment counter // increase count\n    No  → (no action)\n→ Step 5: Output counter // result\nEnd\n\nNeed to maintain structure: maybe use nested loops. Use Decision block for membership. Provide explanation after each line. Use \"Step\" etc.\n\nMake sure each line ends with `// 解釋`. Use arrow `→` properly. We need arrow after Start? In example, they put \"Start //\". So maybe \"Start\" without arrow. Then arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將 jewels 字串轉成集合 jewelSet // 方便 O(1) 成員檢查\n→ Step 2: 初始化計數器 count 為 0 // 用來累計符合的石頭數\n→ Step 3: 逐個遍歷 stones 字串中的字元 c // 檢查每顆石頭是否為寶石\n→ Decision: c 是否存在於 jewelSet? // 判斷字元是否為寶石類型\n    Yes → Step 4: 將 count 加 1 // 成功匹配，計數加一\n    No  → (略) // 不匹配時不做任何操作\n→ Step 5: 輸出 count // 回傳總共有多少顆寶石石頭\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numJewelsInStones(self, J, S):\n        # 將珠寶字串轉成集合，方便 O(1) 成員檢查\n        jewels = set(J)\n        # 對石頭字串中的每個字元做 membership 檢查，累計符合的數量\n        return sum(s in jewels for s in S)\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read()\n    # 取出所有雙引號中的字串，預期順序為 jewels, stones\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        jewels_str, stones_str = parts[0], parts[1]\n    else:\n        # 若無雙引號，嘗試以空白分割取前兩個 token\n        tokens = data.strip().split()\n        if len(tokens) >= 2:\n            jewels_str, stones_str = tokens[0], tokens[1]\n        else:\n            jewels_str, stones_str = '', ''\n    solution = Solution()\n    result = solution.numJewelsInStones(jewels_str, stones_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "jewels = \"aA\", stones = \"aAAbbbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "jewels = \"z\", stones = \"ZZ\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode594.json",
    "problem_index_in_file": 0,
    "title": "Longest Harmonious Subsequence",
    "description_snippet": "We define a harmonious array as an array where the difference between its maximum value and its mini...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line with explanations. Task: find longest harmonious subsequence length. Approach: count frequencies, iterate over keys, if key+1 exists, candidate = freq[key]+freq[key+1], track max. Return max. Edge cases: no pairs => 0.\n\nWe need to produce pseudocode with Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nMake sure each line uses arrows: \"→\". We'll structure as:\n\nStart\n→ Build frequency map\n→ Set maxLen = 0\n→ For each number in freq keys:\n   → Decision: if num+1 in freq?\n       Yes → currentLen = freq[num]+freq[num+1]\n       → Decision: if currentLen > maxLen?\n            Yes → maxLen = currentLen\n            No  → skip\n       No  → skip\n→ Return maxLen\nEnd\n\nWe should include variable names clearly. We need to keep to format: each line: \"虛擬碼步驟 [space] // 解釋\". Use arrow '→' at line start or after indent. Use \"Decision:\" and \"Yes →\", \"No →\". Ensure correct indent with spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build frequency map of nums // 先統計每個數字出現的次數  \n→ Decision: if freq map is empty? // 若輸入為空陣列  \n    Yes → Return 0 // 無法形成和諧子序列，直接回傳 0  \n    No  → Continue  \n→ Set maxLen = 0 // 初始化最大和諧子序列長度  \n→ For each key in freq map: // 逐個檢查可能的最小值  \n    → Decision: if key + 1 exists in freq? // 判斷是否存在相差 1 的數字  \n        Yes → Set currentLen = freq[key] + freq[key + 1] // 計算兩個數字的總頻率  \n        → Decision: if currentLen > maxLen? // 比較是否為更長的子序列  \n            Yes → maxLen = currentLen // 更新最大長度  \n            No  → No action // 保持舊值  \n        No → No action // 無相差 1 的數字，跳過  \n→ Return maxLen // 回傳最長和諧子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findLHS(self, nums):\n        \"\"\"Return length of longest harmonious subsequence.\"\"\"\n        count = Counter(nums)          # Count frequency of each number\n        res = 0\n        for num in count:              # For each unique number\n            if num + 1 in count:       # If the number +1 also exists\n                res = max(res, count[num] + count[num + 1])  # Update max length\n        return res\n\ndef parse_nums(data: str):\n    \"\"\"\n    Parse input string to extract a list of integers.\n    Handles formats like 'nums = [1,2,3]' or just '[1,2,3]'.\n    \"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    list_str = data[start:end + 1]\n    try:\n        return ast.literal_eval(list_str)\n    except Exception:\n        return []\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums = parse_nums(raw_input)\n    sol = Solution()\n    result = sol.findLHS(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,2,5,2,3,7]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1.json",
    "problem_index_in_file": 0,
    "title": "Two Sum",
    "description_snippet": "Given an array of integers nums and an integer target, return indices of the two numbers such that t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for two-sum problem. Use hash map. Provide each line. Use Start, End, Decision. Provide explanation. Ensure no real code. Each line with virtual code and // explanation. Use arrow and decisions. Let's produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的雜湊表 map // 用來存儲數值與其索引  \n→ Step 2: 對於陣列 nums 的每個元素 (index i, value num) 逐一迭代  \n  Decision: 是否已在 map 中找到 target - num? // 檢查是否存在需要配對的數字  \n   Yes → Step 3: 回傳 [map[target - num], i] // 找到配對，返回兩個索引  \n   No  → Step 4: 把 num 與其索引 i 存入 map // 把目前的數字加入雜湊表  \nEnd // 程式執行結束，若無結果則無法找到符合條件的兩數對（理論上不會發生）",
      "generated_code": "import sys\n\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"返回兩個數字的索引，使得它們相加等於目標值。\"\"\"\n        hash_map = {}\n        for i, val in enumerate(nums):\n            complement = target - val\n            if complement in hash_map:\n                return [hash_map[complement], i]\n            hash_map[val] = i\n        # 按題目假設一定有解，這裡不需要處理無解情況\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式：'nums = [2,7,11,15], target = 9'\n    try:\n        nums_start = data.index('[') + 1\n        nums_end = data.index(']')\n        nums_str = data[nums_start:nums_end]\n        nums = [int(x) for x in nums_str.split(',') if x.strip() != '']\n    except ValueError:\n        nums = []\n\n    try:\n        target_str = data.split('target =', 1)[1].strip()\n        target = int(target_str)\n    except (IndexError, ValueError):\n        target = 0\n\n    solution = Solution()\n    result = solution.twoSum(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode354.json",
    "problem_index_in_file": 0,
    "title": "Russian Doll Envelopes",
    "description_snippet": "You are given a 2D array of integers envelopes where envelopes[i] = [w_i, h_i] represents the width ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code to solve Russian Doll Envelopes problem. Provide step-by-step pseudocode, not actual code, with explanations. Use structure: Start, steps, decision, etc. We should include sorting, then LIS on height. The algorithm: sort envelopes by width ascending, and if width equal, height descending to avoid counting equal widths incorrectly. Then extract heights and compute LIS. Pseudocode: Start, Input, Sort, Extract heights, Initialize dp list, For each height, binary search to find insertion point, etc. Then return dp length. Provide comments. Must use 虛擬碼步驟 →, Decision: etc. Use Chinese. Each line must be: 虛擬碼步驟 + space + // 解釋. Use Start, End. Use arrow for steps. Use decision. Also show algorithm flow. We'll produce lines. Use \"Step\" or \"處理\" etc. But the format example uses \"Step 1: 輸入\". We'll follow that. Each line must contain \"虛擬碼步驟\" and comment.\n\nLet's produce. We'll start:\n\nStart // 程式開始執行\n\n→ Step 1: 讀取 2D 數組 envelopes // 取得所有信封尺寸\n\n→ Step 2: 按寬度升序排序 envelopes；若寬度相同，按高度降序排序 // 方便後續 LIS，避免同寬高影響\n\n→ Step 3: 生成高度陣列 heights = [] // 用於計算 LIS\n\n→ Step 4: For each envelope in sorted envelopes: heights.append(envelope.height) // 提取高度順序\n\n→ Step 5: 初始化空列表 dp // 存儲 LIS 的最小尾值\n\n→ Decision: 是否有高度? // 判斷是否進行 LIS\n\n    Yes → Step 6: For each h in heights: // 遍歷高度\n\n        → Step 7: binarySearch(dp, h) to find insertion index // 找最小大於等於 h 的位置\n\n        → Decision: index < len(dp)? // 是否已存在\n\n            Yes → Step 8: dp[index] = h // 用更小高度覆蓋\n\n            No  → Step 9: dp.append(h) // 新增更長的 LIS\n\n    No  → Step 10: dp remains empty // 沒有信封，結果為 0\n\n→ Step 11: 取 dp.length 為答案 // LIS 長度即為最大可疊信封數\n\nEnd // 程式執行結束\n\nBut the format expects each line separate with // explanation. So we need to write each line accordingly.\n\nWe'll need to produce arrow \"→\" for step lines. Indent decisions. But must maintain \"Start\" and \"End\". Also each step line must start with \"→\" or \"Decision:\".\n\nWe also might need to show the binarySearch pseudocode. Could include a nested decision for binarySearch. But we can keep simple.\n\nWe can provide additional steps for binarySearch:\n\n→ Step 7a: 設定 left=0, right=len(dp)-1 // 初始化二分搜尋範圍\n\n→ Step 7b: while left <= right: // 迴圈搜尋\n\n    → Decision: dp[mid] < h? // 判斷中點\n\n        Yes → left = mid+1 // 搜尋右半\n\n        No  → right = mid-1 // 搜尋左半\n\n→ Step 7c: index = left // 二分結果\n\nBut to keep concise, we can just mention binarySearch. The requirement: step lines include explanation. It's fine to have nested steps.\n\nLet's output each line accordingly.\n\nUse Chinese. Ensure we use correct formatting.\n\nWe must also include decision indent.\n\nWe need to produce lines with \"Decision:\" lines indent? In example, Decision lines are indented with 4 spaces maybe. But we can just prefix with \"Decision:\" and then inside the block show Yes →, No →. That is acceptable.\n\nWe need to produce \"Start // 程式開始執行\" then lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取 2D 數組 envelopes // 取得所有信封尺寸\n→ Step 2: 按寬度升序排序 envelopes；若寬度相同，按高度降序排序 // 方便後續 LIS，避免同寬高影響\n→ Step 3: 初始化空列表 heights // 用於存放高度順序\n→ Step 4: For each envelope in envelopes: heights.append(envelope.height) // 提取高度\n→ Step 5: 初始化空列表 dp // 存儲 LIS 的最小尾值\n→ Decision: heights 是否為空? // 判斷是否進行 LIS\n    Yes → Step 6: 直接返回 0 // 沒有信封時答案為 0\n    No  → Step 7: For each h in heights: // 遍歷高度\n        → Step 7a: binarySearch(dp, h) 取得插入位置 index // 找最小大於等於 h 的位置\n        → Decision: index < len(dp)? // 是否已存在相同位置\n            Yes → Step 7b: dp[index] = h // 用更小高度覆蓋\n            No  → Step 7c: dp.append(h) // 新增更長的 LIS\n→ Step 8: 取 dp.length 為答案 // LIS 長度即為最大可疊信封數\nEnd // 程式執行結束\n\n（若需更詳細的 binarySearch 步驟，可在 Step 7a 內再拆分為多行）",
      "generated_code": "import sys\nimport ast\nimport bisect\n\nclass Solution:\n    def maxEnvelopes(self, envelopes):\n        if not envelopes:\n            return 0\n        # Sort by width ascending, then height descending for equal widths\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for _, h in envelopes:\n            idx = bisect.bisect_left(dp, h)\n            if idx == len(dp):\n                dp.append(h)\n            else:\n                dp[idx] = h\n        return len(dp)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 支援 \"envelopes = [[...]]\" 或僅給列表字面量\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    try:\n        envelopes = ast.literal_eval(expr)\n    except Exception as e:\n        # 如果解析失敗，輸出錯誤訊息並結束\n        print(f\"Invalid input: {e}\")\n        return\n    result = Solution().maxEnvelopes(envelopes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "envelopes = [[5,4],[6,4],[6,7],[2,3]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "envelopes = [[1,1],[1,1],[1,1]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode746.json",
    "problem_index_in_file": 0,
    "title": "Min Cost Climbing Stairs",
    "description_snippet": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for minimal cost climb stairs problem. We produce step by step algorithm: DP, compute min cost to reach top. Start from index 0 or 1, can take 1 or 2 steps. cost array length n. We want min cost to reach beyond last index (top). Usually dp[i] minimal cost to reach step i. base dp[0]=cost[0], dp[1]=cost[1]. For i>=2 dp[i]=cost[i]+min(dp[i-1],dp[i-2]). Answer min(dp[n-1],dp[n-2]). Because you can finish by stepping on top beyond last index: either from last step or second last step.\n\nWe need virtual code with arrows.\n\nWe'll produce:\n\nStart // start program\n→ Input: cost array // receive cost array\n→ Decision: cost array length == 0? // check if empty\n    Yes → Step: return 0 // no cost\n    No → \n→ Step: n = length of cost // get length\n→ Step: dp[0] = cost[0] // cost to reach step 0\n→ Step: dp[1] = cost[1] // cost to reach step 1\n→ Step: i = 2 // initialize loop counter\n→ Decision: i < n? // iterate through array\n    Yes → \n        → Step: dp[i] = cost[i] + min(dp[i-1], dp[i-2]) // compute minimal cost for step i\n        → Step: i = i + 1 // increment\n        → Decision: i < n? // loop back\n            Yes → (loop)\n            No →\n    No →\n→ Step: result = min(dp[n-1], dp[n-2]) // minimal cost to reach top\n→ Step: return result // output answer\nEnd // end program\n\nWe need to keep each line with \"虛擬碼步驟 // 解釋\". Each line: e.g., \"Start // 程式開始執行\".\n\nUse arrows. Provide indentation for decisions maybe using spaces.\n\nWe must not output actual code, only virtual code lines with explanations.\n\nLet's craft lines.\n\nUse Chinese explanations.\n\nMake sure to include \"→\" arrows where needed.\n\nBe careful: Decision lines need \"Decision:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: cost array // 取得步階成本陣列  \n→ Decision: cost array 長度 == 0? // 檢查是否為空陣列  \n    Yes → Step: 回傳 0 // 無步階，成本為 0  \n    No → // 繼續計算  \n→ Step: n = cost array 長度 // 取得步階總數  \n→ Step: dp[0] = cost[0] // 第 0 階的最低成本  \n→ Step: dp[1] = cost[1] // 第 1 階的最低成本  \n→ Step: i = 2 // 設定從第 2 階開始迴圈  \n→ Decision: i < n? // 仍有步階未處理？  \n    Yes →  \n        → Step: dp[i] = cost[i] + min(dp[i-1], dp[i-2]) // 計算第 i 階的最低成本  \n        → Step: i = i + 1 // 前往下一個步階  \n        → Decision: i < n? // 仍有步階未處理？  \n            Yes → // 回到前面  \n            No →  \n    No → // 迴圈結束  \n→ Step: result = min(dp[n-1], dp[n-2]) // 從最後兩個步階中選擇成本最低的到達頂部  \n→ Step: 回傳 result // 輸出最小成本  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef min_cost_climbing_stairs(cost):\n    n = len(cost)\n    if n == 0:\n        return 0\n    if n == 1:\n        return cost[0]\n    dp0, dp1 = cost[0], cost[1]\n    for i in range(2, n):\n        dpi = cost[i] + min(dp0, dp1)\n        dp0, dp1 = dp1, dpi\n    return min(dp0, dp1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        # 若輸入為空，視為空陣列\n        cost_list = []\n    else:\n        # 解析輸入字串為列表\n        cost_list = ast.literal_eval(data)\n    result = min_cost_climbing_stairs(cost_list)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[10,15,20]",
          "expected_output": "15",
          "success": true,
          "output": "15"
        },
        {
          "example_index": 1,
          "input": "[1,100,1,1,1,100,1,1,100,1]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode630.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule III",
    "description_snippet": "There are n different online courses numbered from 1 to n. You are given an array courses where cour...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to provide virtual code for algorithm to solve maximum number of courses that can be taken. It's classic problem: schedule courses with durations and deadlines maximizing count. Use greedy: sort by lastDay, iterate, keep max-heap of durations. For each course, add duration, sum, if sum > lastDay, pop largest duration. Return heap size.\n\nWe need to output line by line virtual code, each line with explanation comment.\n\nLet's produce steps: Start, sort courses by lastDay ascending. Initialize max-heap (priority queue). sum=0. For each course in sorted list: add duration to heap, sum+=duration. If sum>lastDay: pop max duration, sum-=popped. Continue. End: return heap size.\n\nWe need to use arrow notation: Start, →, Decision etc.\n\nLine by line:\n\nStart\n→ Step 1: Sort courses by lastDay ascending // 按結束日遞增排序\n→ Step 2: Initialize max-heap durationsHeap // 儲存已選課程的持續時間\n→ Step 3: Initialize totalDays = 0 // 累計已安排課程總時長\n→ For each course in courses: // 遍歷所有課程\n    → Add course.duration to durationsHeap // 把此課程加入堆\n    → totalDays += course.duration // 更新總時長\n    → Decision: 如果 totalDays > course.lastDay? // 檢查是否超過截止日\n        Yes → Step 4: removed = pop max from durationsHeap // 移除最長課程\n            → totalDays -= removed // 調整總時長\nEnd // 結束循環\n→ Step 5: Return size of durationsHeap // 回傳可修課程數\n\nBut need to format each line with arrow and comment. For For loop we might represent with Decision? Not needed. Use \"→ For each course in courses:\" line, then indent subsequent lines? Not necessary but we can show sublines with indentation or nested arrow? Format uses arrows, we can indent by spaces. We'll maintain consistency.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Sort courses by lastDay ascending // 先把課程按最晚結束日遞增排序\n→ Step 2: Initialize max-heap durationsHeap // 用來存放已選課程的持續時間，方便快速找出最長的課程\n→ Step 3: Initialize totalDays = 0 // 記錄目前已安排課程的總時長\n→ For each course in courses: // 逐一處理每個課程\n    → Add course.duration to durationsHeap // 把這個課程加入堆中\n    → totalDays += course.duration // 更新已安排的總時長\n    → Decision: 如果 totalDays > course.lastDay? // 檢查目前總時長是否超過此課程的最晚結束日\n        Yes → Step 4: removed = pop max from durationsHeap // 移除堆中最長的課程，以減少總時長\n            → totalDays -= removed // 調整總時長\nEnd // 迴圈結束\n→ Step 5: Return size of durationsHeap // 堆的大小即為可修課程的最大數量\n```",
      "generated_code": "import sys\nimport heapq\n\ndef max_courses(courses):\n    \"\"\"\n    依照 greedy + max-heap 的方法計算能修的課程最大數量。\n    \"\"\"\n    # 先依 lastDay 排序，確保先考慮最早截止的課程\n    courses.sort(key=lambda x: x[1])\n\n    total_time = 0          # 已排定課程的總耗時\n    max_heap = []           # 儲存已選課程的 duration（使用負值實作 max-heap）\n\n    for duration, last_day in courses:\n        # 若加入此課程仍不會超過截止日，直接加入\n        if total_time + duration <= last_day:\n            heapq.heappush(max_heap, -duration)\n            total_time += duration\n        # 否則嘗試用更短的課程替換最長的已選課程\n        elif max_heap and -max_heap[0] > duration:\n            longest = -heapq.heappop(max_heap)   # 移除最長課程\n            total_time = total_time - longest + duration\n            heapq.heappush(max_heap, -duration)\n\n    return len(max_heap)\n\ndef main():\n    \"\"\"\n    主程式：從 stdin 讀取輸入，解析 courses 清單，輸出可修課程數量。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 可能輸入為 'courses = [[1,2],[3,4]]' 或直接 '[ [1,2], [3,4] ]'\n    if data.lower().startswith(\"courses\"):\n        _, courses_part = data.split('=', 1)\n        courses_str = courses_part.strip()\n    else:\n        courses_str = data\n\n    # 使用 eval 解析列表字串（假設輸入格式正確且安全）\n    courses = eval(courses_str)\n\n    result = max_courses(courses)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "courses = [[1,2]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "courses = [[3,2],[4,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode233.json",
    "problem_index_in_file": 0,
    "title": "Number of Digit One",
    "description_snippet": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm counting digit 1 in numbers from 0 to n inclusive. Use typical positional counting algorithm. We should output step-by-step pseudo code with arrows and decision blocks. Each line must be: \"虛擬碼步驟 // 解釋\". We'll produce from Start to End. Let's design algorithm:\n\n- Input n.\n- Initialize count = 0.\n- For position factor = 1; factor <= n; factor *= 10:\n    - lower = n % factor\n    - current = (n / factor) % 10\n    - higher = n / (factor * 10)\n    - if current == 0: count += higher * factor\n    - else if current == 1: count += higher * factor + lower + 1\n    - else: count += (higher + 1) * factor\n- Output count.\n\nWe will produce virtual code lines:\n\nStart\n→ Input n // 讀取整數 n\n→ Set count = 0 // 初始化計數\n→ Set factor = 1 // 位數位移因子\n→ Decision: factor <= n? // 判斷是否還有位數\n    Yes →\n        → Step: lower = n % factor // 低位數\n        → Step: current = (n / factor) % 10 // 當前位數\n        → Step: higher = n / (factor * 10) // 高位數\n        → Decision: current == 0? // 判斷當前位\n            Yes →\n                → Step: count += higher * factor // 加高位*位數\n            No →\n                → Decision: current == 1? // 判斷為1\n                    Yes →\n                        → Step: count += higher * factor + lower + 1 // 加高位*位數 + 低位+1\n                    No →\n                        → Step: count += (higher + 1) * factor // 加 (高位+1)*位數\n        → Step: factor *= 10 // 進位到下一位\n        → Decision: factor <= n? // 再次判斷\n            ... loops\n→ Step: Output count // 輸出結果\nEnd\n\nWe need to express each line as \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nLet's write them with correct formatting.\n\nAlso we should indent inside Decision blocks. Each line must be separate line, no indentation needed in output? In example, they used indentation for inside decisions. We'll mimic.\n\nWe'll start with \"Start // 程式開始執行\". Then each line. Use \"→\" before each step. Decision lines use \"Decision:\".\n\nWe need to ensure each line ends with // 解釋. Provide concise explanation. Let's craft:\n\nStart // 程式開始執行\n→ Input n // 讀取整數 n\n→ Set count = 0 // 初始化計數變數\n→ Set factor = 1 // 位數位移因子，從最低位開始\n→ Decision: factor <= n? // 判斷是否還有位數需要處理\n    Yes →\n        → Step: lower = n % factor // 低位數，位於 factor 以下的數字\n        → Step: current = (n / factor) % 10 // 當前位數\n        → Step: higher = n / (factor * 10) // 高位數，factor 以上的數字\n        → Decision: current == 0? // 當前位為 0 時的處理\n            Yes →\n                → Step: count += higher * factor // 1 的個數等於高位 * factor\n            No →\n                → Decision: current == 1? // 當前位為 1 時的處理\n                    Yes →\n                        → Step: count += higher * factor + lower + 1 // 高位 * factor + 低位 + 1\n                    No →\n                        → Step: count += (higher + 1) * factor // 高位+1 * factor\n        → Step: factor *= 10 // 移到下一位\n        → Decision: factor <= n? // 再次檢查是否還有位數\n            ... // 重複循環\n→ Step: Output count // 輸出總數\nEnd // 程式執行結束\n\nBut we need to keep each line separate. Also the repeated Decision for factor <= n? we need to loop but we can just end after that. But to match example, we might produce a loop arrow: maybe \"→ Decision: factor <= n? ...\" with Yes leading to the block and No leading to End. But we also need to have an outer Decision and inner steps. Let's restructure:\n\nWe'll have outer loop:\n\n→ Decision: factor <= n? // 是否還有位數\n    Yes →\n        ... (processing steps)\n        → Step: factor *= 10 // next position\n        → Decision: factor <= n? // 重複\n            Yes →\n                ... (repeat)\n            No →\n                → Step: Output count // 輸出結果\n    No →\n        → Step: Output count // 輸出結果\n\nBut that's too many lines. To keep simple, we can write while loop using decision.\n\nWe'll produce:\n\n→ Decision: factor <= n? // 判斷是否還有位數\n    Yes →\n        → Step: lower = n % factor // ...\n        ...\n        → Step: factor *= 10 // ...\n        → Decision: factor <= n? // 重新檢查\n            Yes →\n                → Step: lower = n % factor // ...\n                ...\n                → Step: factor *= 10 // ...\n                → Decision: factor <= n? // 重新檢查\n                    ... etc\n\nBut this repeats. Instead we can just mention the loop conceptually: \"→ Step: Repeat until factor > n\" with explanation.\n\nHowever the example uses decision branches. Let's just implement a simple while loop using Decision:\n\n→ Decision: factor <= n? // 進入位數循環\n    Yes →\n        → Step: lower = n % factor\n        → Step: current = (n / factor) % 10\n        → Step: higher = n / (factor * 10)\n        → Decision: current == 0?\n            Yes →\n                → Step: count += higher * factor\n            No →\n                → Decision: current == 1?\n                    Yes →\n                        → Step: count += higher * factor + lower + 1\n                    No →\n                        → Step: count += (higher + 1) * factor\n        → Step: factor *= 10\n        → Decision: factor <= n? // 迴圈檢查\n            Yes →\n                → Step: lower = n % factor\n                ... // 這裡省略重複\n                → Step: factor *= 10\n                → Decision: factor <= n? ...\n            No →\n                → Step: Output count\n    No →\n        → Step: Output count\n\nBut the instruction says to generate virtual code line by line; we can't use ellipsis. Maybe we can use a comment \"Repeat the same steps for next factor\" as one line to avoid repetition. Let's craft:\n\n→ Decision: factor <= n? // 進入位數循環\n    Yes →\n        → Step: lower = n % factor // 低位數\n        → Step: current = (n / factor) % 10 // 當前位\n        → Step: higher = n / (factor * 10) // 高位數\n        → Decision: current == 0? // 判斷當前位為 0\n            Yes →\n                → Step: count += higher * factor // 加高位 * factor\n            No →\n                → Decision: current == 1? // 判斷當前位為 1\n                    Yes →\n                        → Step: count += higher * factor + lower + 1 // 加高位 * factor + 低位 + 1\n                    No →\n                        → Step: count += (higher + 1) * factor // 加 (高位+1) * factor\n        → Step: factor *= 10 // 移到下一位\n        → Decision: factor <= n? // 重複循環\n            Yes →\n                → Step: lower = n % factor\n                ... // 這裡重複上述步驟\n            No →\n                → Step: Output count // 輸出結果\n    No →\n        → Step: Output count // 輸出結果\n\nBut \"...\" might be considered not allowed. The instruction: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋。⚠️ 請勿輸出實際程式碼，只輸出結構化的步驟。\" So we cannot use ellipsis. We need to show loops explicitly, but we can use a decision block that leads back to Start of loop. Use a label.\n\nWe can use \"→ Decision: factor <= n? // 循環判斷\" and inside Yes block we go to steps and then \"→ Step: factor *= 10\" then \"→ Decision: factor <= n? // 循環判斷\" again but we can use \"Yes → ... back to loop\" but to keep simple, we can just have a label \"LoopStart\". But the example didn't use labels. We could use a structure:\n\nDecision: factor <= n? // 循環判斷\n    Yes →\n        … (processing)\n        → Step: factor *= 10\n        → Decision: factor <= n? // 重新判斷，回到 Yes分支\n            Yes → … (repeat same processing) ???\n\nThis leads to infinite nested. But we can use a simpler approach: after factor*=10, we just \"→ Decision: factor <= n? // 回到循環起點\" with Yes leading back to \"→ Step: lower = n % factor\" etc. That is basically same as repeating lines. It's messy.\n\nBetter approach: Use while loop conceptually: \"→ While factor <= n: // 循環處理每一位\" but we need to express with Decision. Maybe we can use \"Decision: factor <= n?\" and inside Yes we do processing, then \"→ Step: factor *= 10\" and \"→ Decision: factor <= n?\" again with Yes leading to the processing block again. So we need to define the processing block as a separate subroutine maybe called \"ProcessPosition\". But we can't name. But we can represent the loop with a recursion of decision and steps. The example used nested decisions for if else but not loops.\n\nMaybe we can simply write the algorithm with \"While factor <= n:\" as a step. It's not actual code but virtual code. We can use \"→ While factor <= n: // 循環到最高位\". But the requirement uses Decision and arrow only. However they didn't forbid \"While\". But they gave example with Decision only. But we can still use \"While\". But to stay safe, we can use Decision block with a self-loop indicated by \"→ Decision: factor <= n? // 進入循環\" inside Yes block we finish with \"→ Step: factor *= 10\" then \"→ Decision: factor <= n? // 進行下一輪\". That still uses recursion. It might produce many lines but we can show a repeating block.\n\nSimpler: We'll treat the loop as a single block labeled \"Loop\" with steps. Use \"→ Decision: factor <= n? // 進入循環\" and then the Yes branch includes all processing and at the end \"→ Step: factor *= 10\" and then \"→ Decision: factor <= n? // 再次判斷\" but we will not expand the recursion; it's implied to repeat.\n\nBut the instruction: \"逐行地產生對應的虛擬碼 (Virtual Code)\" So we need to show the loop logic step by step, but we can use a high-level loop representation. Eg:\n\n→ Decision: factor <= n? // 是否還有位數需要處理\n    Yes →\n        … (processing)\n        → Step: factor *= 10 // 下一位\n        → Decision: factor <= n? // 重複判斷\n            Yes →\n                … (repeat same block)\n            No →\n                → Step: Output count\n    No →\n        → Step: Output count\n\nBut this still repeats. But maybe acceptable if we keep the same block repeated? It's still \"逐行\". It's okay to write the same block again. But we might exceed length. But we can show only one iteration of the loop? No, we need to represent general logic. We can show the loop with a note \"Repeat the same steps for next factor\" as a comment line. That might be acceptable as long as each line has explanation. The ellipsis might be considered \"省略\" but not \"...\"? The instruction doesn't forbid explanatory comments. We can add a line: \"→ Step: Repeat the same steps for next factor // 迴圈至 factor > n\". That is acceptable.\n\nThus we can structure:\n\nStart\n→ Input n\n→ Set count = 0\n→ Set factor = 1\n→ Decision: factor <= n? // 判斷是否還有位數需要處理\n    Yes →\n        → Step: lower = n % factor // 低位數\n        → Step: current = (n / factor) % 10 // 當前位數\n        → Step: higher = n / (factor * 10) // 高位數\n        → Decision: current == 0? // 判斷當前位為 0\n            Yes →\n                → Step: count += higher * factor // 1 的個數等於高位 * factor\n            No →\n                → Decision: current == 1? // 判斷當前位為 1\n                    Yes →\n                        → Step: count += higher * factor + lower + 1 // 加高位 * factor + 低位 + 1\n                    No →\n                        → Step: count += (higher + 1) * factor // 加 (高位+1) * factor\n        → Step: factor *= 10 // 移到下一位\n        → Step: Repeat the same steps for next factor // 迴圈至 factor > n\n    No →\n        → Step: Output count // 輸出結果\nEnd\n\nBut \"Repeat the same steps for next factor\" might not be valid virtual code but explanation. It should be a step, but we can call it \"Loop\" step. We can use \"→ Step: Repeat loop\" with explanation. But we can keep it simple: \"→ Step: Repeat loop // 重複執行上一段直到 factor > n\".\n\nLet's produce final output accordingly. Ensure each line has virtual code + // explanation. Use Chinese characters. Use arrow as in example.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 讀取整數 n  \n→ Set count = 0 // 初始化計數變數  \n→ Set factor = 1 // 位數位移因子，從最低位開始  \n→ Decision: factor <= n? // 判斷是否還有位數需要處理  \n    Yes →  \n        → Step: lower = n % factor // 低位數：位於 factor 以下的數字  \n        → Step: current = (n / factor) % 10 // 當前位數：factor 位的數字  \n        → Step: higher = n / (factor * 10) // 高位數：位於 factor 以上的數字  \n        → Decision: current == 0? // 判斷當前位是否為 0  \n            Yes →  \n                → Step: count += higher * factor // 1 的個數等於高位 * factor  \n            No →  \n                → Decision: current == 1? // 判斷當前位是否為 1  \n                    Yes →  \n                        → Step: count += higher * factor + lower + 1 // 高位 * factor + 低位 + 1  \n                    No →  \n                        → Step: count += (higher + 1) * factor // (高位+1) * factor  \n        → Step: factor *= 10 // 移到下一位  \n        → Step: Repeat loop // 重複執行上一段直到 factor > n  \n    No →  \n        → Step: Output count // 輸出總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countDigitOne(self, n: int) -> int:\n        if n <= 0:\n            return 0\n        count = 0\n        i = 1  # current position (1, 10, 100, ...)\n        while i <= n:\n            divider = i * 10\n            count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n            i *= 10\n        return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r\"-?\\d+\", data)\n    n = int(match.group()) if match else 0\n    solution = Solution()\n    print(solution.countDigitOne(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode299.json",
    "problem_index_in_file": 0,
    "title": "Bulls and Cows",
    "description_snippet": "You are playing the Bulls and Cows game with your friend.\n\nYou write down a secret number and ask yo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line with explanations, in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrows: Start, →, Decision: If... Yes →, No →. Should not output actual code. Just steps. The requirement: \"逐行產生對應的虛擬碼\" for the Bulls and Cows problem. We should produce pseudo-code.\n\nWe need to cover: Input secret, guess. Count bulls. Count cows. We need to handle duplicates. Common approach: iterate, count bulls, for non-bulls count frequencies in arrays 10 digits. Then cows = sum over digits of min(countSecret[d], countGuess[d]). Provide output string: `${bulls}A${cows}B`.\n\nWe must produce each line with explanation. Let's format.\n\nStart // 程式開始執行\n→ Step 1: 取得 secret 與 guess 兩個字串 // 從輸入取得秘密數字和猜測\n→ Step 2: 初始化 bulls = 0, cows = 0 // 記錄老闆數\n→ Step 3: 初始化 secretCount[10] = 0, guessCount[10] = 0 // 用於記錄非牛數字的頻率\n→ Decision: 兩個字串長度是否相同? // 確認輸入合法\n    Yes → Continue\n    No → End // 若長度不等，直接結束\n→ Step 4: 迴圈 i 從 0 到 length-1\n    → Decision: secret[i] == guess[i]? // 檢查是否為牛\n        Yes → bulls += 1 // 位置相同，牛數+1\n        No  → secretCount[secret[i]-'0'] += 1 // 否則將秘密數字加入頻率表\n            → guessCount[guess[i]-'0'] += 1 // 同樣將猜測數字加入頻率表\n→ Step 5: 迴圈 d 從 0 到 9\n    → cows += min(secretCount[d], guessCount[d]) // 取兩頻率的較小值作為牛\n→ Step 6: 構造 hint 字串為 `${bulls}A${cows}B` // 生成提示字串\n→ Step 7: 輸出 hint // 將結果輸出\nEnd // 程式執行結束\n\nBut we need to maintain arrow syntax: \"→\" before each step, or use \"Start\", \"Decision:\" etc. We must include \"→ Decision: ...\" with Yes→, No→ lines.\n\nAlso \"Step 4\" includes loop, we can break into separate lines maybe. Let's produce with proper indent. Use \"→\" for each main step, \"→\" inside loops maybe.\n\nWe need to produce each line exactly one line, no indentation maybe? But we can use indentation to show structure. The format example had indentation. Let's replicate.\n\nWe'll write:\n\nStart // 程式開始執行\n→ Step 1: 讀取 secret 與 guess // 取得秘密數字和猜測\n→ Step 2: 初始化 bulls = 0, cows = 0 // 記錄牛和奶的數量\n→ Step 3: 初始化 secretCount[10] = 0, guessCount[10] = 0 // 用於記錄非牛數字的頻率\n→ Decision: secret.length == guess.length? // 確認兩字串長度相同\n    Yes → Continue\n    No  → End // 若長度不等則結束\n→ Step 4: 迴圈 i 0 to secret.length-1\n    → Decision: secret[i] == guess[i]? // 判斷是否為牛\n        Yes → bulls += 1 // 牛數加1\n        No  → secretCount[secret[i]-'0'] += 1 // 將秘密數字加入頻率表\n            → guessCount[guess[i]-'0'] += 1 // 將猜測數字加入頻率表\n→ Step 5: 迴圈 d 0 to 9\n    → cows += min(secretCount[d], guessCount[d]) // 加入兩數字的較小頻率作為奶\n→ Step 6: 建立 hint 為 `${bulls}A${cows}B` // 生成提示字串\n→ Step 7: 輸出 hint // 將提示輸出\nEnd // 程式結束\n\nNeed to ensure \"Step 4\" and \"Step 5\" loops properly. Use \"→\" for nested lines.\n\nOk produce that. Ensure each line has `虛擬碼步驟 // 解釋`.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 secret 與 guess // 取得秘密數字和猜測  \n→ Step 2: 初始化 bulls = 0, cows = 0 // 記錄牛與奶的數量  \n→ Step 3: 初始化 secretCount[10] = 0, guessCount[10] = 0 // 用於記錄非牛數字的頻率  \n→ Decision: secret.length == guess.length? // 確認兩字串長度相同  \n    Yes → Continue // 若長度相同則繼續  \n    No  → End // 若長度不等則結束程式  \n→ Step 4: 迴圈 i 0 to secret.length-1 // 逐位比對  \n    → Decision: secret[i] == guess[i]? // 判斷是否為牛  \n        Yes → bulls += 1 // 牛數加1  \n        No  → secretCount[secret[i]-'0'] += 1 // 將秘密數字加入頻率表  \n            → guessCount[guess[i]-'0'] += 1 // 將猜測數字加入頻率表  \n→ Step 5: 迴圈 d 0 to 9 // 計算奶數  \n    → cows += min(secretCount[d], guessCount[d]) // 加入兩數字頻率中較小值作為奶  \n→ Step 6: 建立 hint 為 `${bulls}A${cows}B` // 生成提示字串  \n→ Step 7: 輸出 hint // 將提示輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef get_hint(secret: str, guess: str) -> str:\n    \"\"\"計算 Bulls and Cows，回傳形如 'xAyB' 的字串。\"\"\"\n    bulls = 0\n    # 先統計非牛數字的頻率\n    secret_count = Counter()\n    guess_count = Counter()\n\n    for s, g in zip(secret, guess):\n        if s == g:\n            bulls += 1\n        else:\n            secret_count[s] += 1\n            guess_count[g] += 1\n\n    # cows 為兩個頻率表中共同數字的較小頻率之和\n    cows = sum(min(secret_count[d], guess_count[d]) for d in secret_count if d in guess_count)\n    return f\"{bulls}A{cows}B\"\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取 secret 與 guess。\n    支援兩種格式：\n    1. secret = \"1807\", guess = \"7810\"\n    2. 兩行分別為 secret 與 guess\n    \"\"\"\n    data = data.strip()\n    # 第一種格式：尋找兩個字串\n    m_secret = re.search(r'secret\\s*=\\s*\"([^\"]*)\"', data)\n    m_guess  = re.search(r'guess\\s*=\\s*\"([^\"]*)\"', data)\n    if m_secret and m_guess:\n        return m_secret.group(1), m_guess.group(1)\n\n    # 第二種格式：兩行\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n\n    # 第三種格式：空格或換行分隔\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    raise ValueError(\"無法解析輸入。\")\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    secret, guess = parse_input(raw_input)\n    hint = get_hint(secret, guess)\n    print(hint)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "success": true,
          "output": "1A3B"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "success": true,
          "output": "1A1B"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode486.json",
    "problem_index_in_file": 0,
    "title": "Predict the Winner",
    "description_snippet": "You are given an integer array nums. Two players are playing a game with this array: player 1 and pl...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solution: Determine if player1 can win or tie with optimal play. This is standard DP: compute difference or DP for subarray. The virtual steps: start, get input array, compute dp[i][j] as max score difference current player can achieve over opponent for subarray i..j. Recurrence: dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]). Finally if dp[0][n-1] >=0 return true else false.\n\nWe must output step by step with arrow and explanation. Use Start, End. Use Decision. We can show loops. Ensure each line contains virtual code step and explanation. We'll produce step-by-step pseudo.\n\nLet's draft:\n\nStart // program begins\n→ Step 1: Read array nums // get input\n→ Decision: If nums length == 0? // handle empty\n    Yes → Return true // no numbers, player1 wins by default\n    No  → Continue\n→ Step 2: n = nums.length // array size\n→ Step 3: Create 2D array dp[n][n] // DP table\n→ Step 4: For i from 0 to n-1: dp[i][i] = nums[i] // base case single element\n→ Step 5: For length from 2 to n: // subarray lengths\n        For i from 0 to n - length:\n            j = i + length - 1\n            → Step 6: chooseLeft = nums[i] - dp[i+1][j] // if pick left\n            → Step 7: chooseRight = nums[j] - dp[i][j-1] // if pick right\n            → Step 8: dp[i][j] = max(chooseLeft, chooseRight) // optimal difference\n→ Step 9: diff = dp[0][n-1] // final score difference\n→ Decision: If diff >= 0? // player1 score >= player2\n    Yes → Return true\n    No  → Return false\nEnd // program finished\n\nAdd explanation after each line.\n\nWe need to ensure each line: \"虛擬碼步驟 // 解釋\". Use arrows and indentation. Use Decision: with Yes → and No →. Provide short explanation after each.\n\nMake sure to include \"Start\" and \"End\". Use Chinese. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read array nums // 讀取輸入的整數陣列  \n→ Decision: If nums.length == 0? // 檢查陣列是否為空  \n  Yes → Return true // 沒有數字，玩家1自動勝利  \n  No  → Continue // 陣列不為空，進行後續計算  \n→ Step 2: n = nums.length // 取得陣列長度  \n→ Step 3: Create 2D array dp[n][n] // 初始化 DP 表，用於存儲子陣列的分數差  \n→ Step 4: For i = 0 to n-1: dp[i][i] = nums[i] // 單個元素子陣列，玩家1直接取走，差值即為該元素  \n→ Step 5: For length = 2 to n: // 從子陣列長度 2 開始逐步擴大  \n  For i = 0 to n - length:  \n   j = i + length - 1 // 子陣列右端索引  \n   → Step 6: chooseLeft = nums[i] - dp[i+1][j] // 若玩家1選左端，取得 nums[i]，其後子陣列差值為 dp[i+1][j]，整體差值為 nums[i] - dp[i+1][j]  \n   → Step 7: chooseRight = nums[j] - dp[i][j-1] // 若玩家1選右端，類似計算  \n   → Step 8: dp[i][j] = max(chooseLeft, chooseRight) // 玩家1會選擇使得自己對手最小化的方案，取較大差值  \n→ Step 9: diff = dp[0][n-1] // 整個陣列的最終分數差（玩家1 分數 - 玩家2 分數）  \n→ Decision: If diff >= 0? // 玩家1得分是否大於或等於玩家2  \n  Yes → Return true // 玩家1勝利或平手時視為勝利  \n  No  → Return false // 玩家1輸敗  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def predictTheWinner(self, nums):\n        n = len(nums)\n        # dp[i][j] 表示在子陣列 i..j 中，先手玩家可以比後手玩家多贏的分數差\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]  # 單個元素時先手直接取走\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                # 先手選左端或右端，並考慮後手最優回應\n                left = nums[i] - dp[i + 1][j]\n                right = nums[j] - dp[i][j - 1]\n                dp[i][j] = max(left, right)\n        return dp[0][n - 1] >= 0  # 差值 >= 0 表示玩家1至少不輸\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出整數陣列。\n    支援兩種格式：\n      1. 直接陣列，例如 '[1,5,2]'\n      2. 變數賦值，例如 'nums = [1,5,2]'\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    if '=' in data:\n        # 取等號右邊的內容\n        data = data.split('=', 1)[1].strip()\n    # 使用 ast.literal_eval 解析安全的 Python 字面量\n    try:\n        nums = ast.literal_eval(data)\n        if isinstance(nums, list):\n            return nums\n    except Exception:\n        pass\n    # 若解析失敗，回傳空列表\n    return []\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    if not nums:\n        # 若沒有有效輸入，直接輸出 false\n        print('false')\n        return\n    sol = Solution()\n    result = sol.predictTheWinner(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,233,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode338.json",
    "problem_index_in_file": 0,
    "title": "Counting Bits",
    "description_snippet": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The task: Given integer n, return array ans length n+1 where ans[i] = number of 1's in binary representation of i. This is typical DP: ans[0] = 0, ans[i] = ans[i >> 1] + (i & 1). We need to produce virtual code with arrows and decision. Steps: Start, Input n, Initialize array ans of length n+1 with 0, Loop i from 1 to n: compute ans[i] using ans[i >> 1] + (i & 1). After loop, return ans. Also need to handle i=0. Virtual code lines: Start, Input, Initialize, For loop start, For each i, compute, Next, End. Provide explanation. Ensure each line ends with // explanation. Use arrow '→' for steps. Use Decision? not needed maybe. But could use for loop arrow. Use indentation for loop.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Input n // 取得輸入整數 n\n→ Initialize ans[0..n] // 建立長度 n+1 的陣列並預設為 0\n→ For i = 1 to n // 遍歷 1 到 n\n    → ans[i] = ans[i >> 1] + (i & 1) // 使用已計算值計算 i 的 1 位數\n→ End // 完成所有計算，ans 已完成\n```\n\nBut need each line explicit arrow and explanation. For loop we may use `Decision:` but not necessary. But requirement: Use arrows `→`, `Yes →`, `No →` and structure `Start`, `End`, `Decision:`. For loops maybe just arrow.\n\nWe need \"逐行輸出\" with each line containing virtual code step plus explanation. We'll include for loop as two lines: `→ For i = 1 to n` and inside with indentation arrow.\n\nAlso need to output \"End // 程式執行結束\". But we need to return ans at the end: maybe \"→ Return ans\" line. But \"End\" should mark end of program. Provide return before end.\n\nLet's produce.\n\n```\nStart // 程式開始執行\n→ Input n // 取得輸入整數 n\n→ Initialize ans[0..n] with 0 // 建立長度 n+1 的陣列並將所有元素設為 0\n→ For i = 1 to n // 逐一處理 1 到 n 的數字\n    → ans[i] = ans[i >> 1] + (i & 1) // 計算 i 的二進制中 1 的個數\n→ Return ans // 回傳結果陣列\nEnd // 程式執行結束\n```\n\nWe must ensure each line contains virtual code and explanation separated by space. Provide `→` arrows. For return line we use `→ Return ans`? Actually return is a statement. Use `→ Output ans` maybe. But spec: use \"虛擬碼步驟\". We can use `→ Output ans` to indicate returning. But \"Return\" is fine.\n\nAlso we may include decision: not needed. But could include Decision: \"If n == 0?\".\n\nBetter: Add Decision for n==0 to skip loop. But not necessary.\n\nLet's craft final. Ensure formatting consistent.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得輸入整數 n  \n→ Initialize ans[0..n] with 0 // 建立長度 n+1 的陣列並將所有元素設為 0  \n→ For i = 1 to n // 逐一處理 1 到 n 的數字  \n    → ans[i] = ans[i >> 1] + (i & 1) // 計算 i 的二進制中 1 的個數  \n→ Output ans // 回傳結果陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countBits(self, n: int):\n        res = [0] * (n + 1)\n        for i in range(1, n + 1):\n            res[i] = res[i >> 1] + (i & 1)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n    n = int(numbers[0]) if numbers else 0\n    ans = Solution().countBits(n)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,1]",
          "success": true,
          "output": "[0, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[0,1,1,2,1,2]",
          "success": true,
          "output": "[0, 1, 1, 2, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode757.json",
    "problem_index_in_file": 0,
    "title": "Set Intersection Size At Least Two",
    "description_snippet": "You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step algorithm. Problem: minimal size of set such that each interval has at least two integers. Classic interval covering with two points per interval. Known solution: sort intervals by end; keep last two chosen points; iterate. For each interval [l,r], if last two are both >= l? Actually we maintain two largest selected numbers. Suppose we maintain x and y as the two largest selected numbers so far. For each interval, if x < l then need to add two new numbers: r-1, r. If y < l but x >= l? Wait typical algorithm: sort by end ascending. Keep two variables last1,last2. For each interval [l,r]: if last1 < l, then need to add two numbers r-1,r; set last1=r-1, last2=r. Else if last2 < l, need to add one number r; set last2=r. Else already covered. That yields minimal size.\n\nWe'll produce pseudocode lines accordingly.\n\nMake sure to follow output format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows and Decision etc.\n\nWe'll start with Start.\n\nWe need to show sorting, then iterate. Provide decisions for conditions.\n\nAlso need to maintain result size.\n\nEdge cases: intervals may be unsorted.\n\nWe'll produce lines like:\n\nStart // 程式開始\n\n→ Step 1: Sort intervals by end ascending // 先按結束點排序\n\n→ Step 2: Initialize last1 = -∞, last2 = -∞, count = 0 // 初始化兩個已選取的數字與計數\n\n→ Decision: 迭代每個 interval // 逐一處理每個區間\n\n   → For each interval [l,r]:\n\n   → Decision: if last1 < l? // 檢查最小選點是否落在區間外\n\n      Yes → Step 3: count += 2 // 需要兩個新點\n\n      Yes → Step 4: last1 = r-1; last2 = r // 選取兩個最大的點\n\n      No  → Decision: if last2 < l? // 檢查第二個點是否落在區間外\n\n         Yes → Step 5: count += 1 // 需要一個新點\n\n         Yes → Step 6: last2 = r // 更新第二個點\n\n         No  → // 已經有兩個點在區間內，無需新增\n\n→ End // 完成所有區間，返回 count\n\nBut need to format each line with arrow? Actually we should produce lines with \"虛擬碼步驟 // 解釋\". Use arrows within steps. But example uses arrow in lines like \"→ Step 1: ...\" So we follow that.\n\nWe need to incorporate Decision lines with indentation. Use indentation with tabs or spaces? Example uses 4 spaces before Yes/No.\n\nWe need to show all steps.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: Sort intervals by end ascending // 先根據結束點排序區間\n→ Step 2: Set last1 = -∞, last2 = -∞, count = 0 // 初始化兩個已選取的數字與計數\n→ Step 3: For each interval [l, r] in sorted intervals // 逐一處理區間\n    → Decision: if last1 < l? // 最小選點不在區間內\n        Yes → Step 4: count += 2 // 需要新增兩個數字\n        Yes → Step 5: last1 = r-1; last2 = r // 選取區間內最大的兩個數字\n        No  → Decision: if last2 < l? // 第二個選點不在區間內\n            Yes → Step 6: count += 1 // 需要新增一個數字\n            Yes → Step 7: last2 = r // 更新第二個選點為區間內最大的數字\n            No  → // 已有兩個數字覆蓋此區間，無需新增\n→ End // 返回 count 為最小包含集合大小\n\nBut we need to provide final output maybe \"Return count\" as step.\n\nAdd \"→ Step 8: Return count\" before End.\n\nLet's produce final lines.\n\nCheck formatting: \"Step 1:\" etc.\n\nEnsure each line has arrow and comment.\n\nWe need to avoid real code but pseudocode. Use \"→\" arrow.\n\nAlso ensure indentation for Decision branches; can use four spaces.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort intervals by end ascending // 先根據結束點排序區間  \n→ Step 2: Set last1 = -∞, last2 = -∞, count = 0 // 初始化兩個已選取的數字與計數  \n→ Step 3: For each interval [l, r] in sorted intervals // 逐一處理區間  \n  → Decision: if last1 < l? // 最小選點不在區間內  \n   Yes → Step 4: count += 2 // 需要新增兩個數字  \n   Yes → Step 5: last1 = r-1; last2 = r // 選取區間內最大的兩個數字  \n   No  → Decision: if last2 < l? // 第二個選點不在區間內  \n    Yes → Step 6: count += 1 // 需要新增一個數字  \n    Yes → Step 7: last2 = r // 更新第二個選點為區間內最大的數字  \n    No  → // 已有兩個數字覆蓋此區間，無需新增  \n→ Step 8: Return count // 回傳最小包含集合的大小  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def intersectionSizeTwo(self, intervals):\n        # Sort by end, and by start descending for ties\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        last = -1          # Largest selected number so far\n        second_last = -1   # Second largest selected number\n        res = 0            # Count of selected numbers\n\n        for start, end in intervals:\n            count = 0\n            if start <= second_last <= end:\n                count += 1\n            if start <= last <= end:\n                count += 1\n\n            if count >= 2:\n                # Already have two numbers in this interval\n                continue\n            elif count == 1:\n                # Need one more number; pick the largest possible (end)\n                res += 1\n                second_last, last = last, end\n            else:\n                # Need two numbers; pick end-1 and end\n                res += 2\n                second_last, last = end - 1, end\n\n        return res\n\nif __name__ == \"__main__\":\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n    # Remove any leading variable assignment\n    if raw_input.startswith(\"intervals\"):\n        _, _, raw_input = raw_input.partition(\"=\")\n        raw_input = raw_input.strip()\n    # Parse the list of intervals safely\n    intervals = ast.literal_eval(raw_input)\n    # Compute and print the result\n    solution = Solution()\n    print(solution.intersectionSizeTwo(intervals))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[3,7],[8,9]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,3],[1,4],[2,5],[3,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3],[2,4],[4,5]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode647.json",
    "problem_index_in_file": 0,
    "title": "Palindromic Substrings",
    "description_snippet": "Given a string s, return the number of palindromic substrings in it.\n\nA string is a palindrome when ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants pseudo-code lines explaining counting palindromic substrings in a string s. The pseudo-code should use arrows and Decision structure. Each line: \"虛擬碼步驟 [space] // 解釋\". Should not output actual code. Use Start, End, Decision etc. We'll provide algorithm: iterate center positions for odd and even palindromes. Count expansions.\n\nWe'll output line by line.\n\nMake sure format exactly: \"Start // ...\" etc. Use Chinese explanations. Use arrows (→). For Decision, we might need Yes →, No →. Provide proper indentation.\n\nWe need to follow output format: each line separate, each line has \"虛擬碼步驟\" then space then \"// 解釋\".\n\nWe can't output code but pseudo-code lines. Use \"→ Step: ...\". For decisions, \"Decision:\" etc.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: 設定 count = 0 // 初始化回文子字串計數\n\n→ Step 2: 取得 s 的長度 n // 方便索引\n\n→ Step 3: 建立迴圈 center 從 0 到 n-1 // 為每個字符作為奇數回文中心\n\n    → Decision: center 可以作為奇數回文中心? // 確認索引合法\n\n        Yes → Step 4: 以 center 為中心，左右同時擴張，計算奇數長度回文 // 具體擴張步驟\n\n        No  → Skip // 不可能的情況\n\n→ Step 5: 另一個迴圈 center 從 0 到 n-2 // 為每個相鄰字符對作為偶數回文中心\n\n    → Decision: center 與 center+1 可以作為偶數回文中心? // 確認索引合法\n\n        Yes → Step 6: 以 (center, center+1) 為中心，左右同時擴張，計算偶數長度回文\n\n        No  → Skip\n\n→ Step 7: 回傳 count // 最終回文子字串數量\n\nEnd // 程式結束\n\nBut we must be more detailed inside expansions: For each expansion, increase count while characters match and within bounds.\n\nWe need pseudo-code lines for expansion. Use nested loops? Let's add:\n\nStep 4: 初始化 left = center, right = center // 開始擴張\n\n→ Step 4.1: while left >= 0 and right < n and s[left] == s[right] do\n\n    → Step 4.1.1: count = count + 1 // 每次匹配即為一個回文子字串\n\n    → Step 4.1.2: left = left - 1 // 向左移動\n\n    → Step 4.1.3: right = right + 1 // 向右移動\n\nSimilarly for even:\n\nStep 6: 初始化 left = center, right = center+1\n\n→ Step 6.1: while left >= 0 and right < n and s[left] == s[right] do\n\n    → Step 6.1.1: count = count + 1\n\n    → Step 6.1.2: left = left - 1\n\n    → Step 6.1.3: right = right + 1\n\nWe need to keep each line separate.\n\nAlso we need to keep the arrows. For nested steps we may use indentation but it's okay. Use \"→\" before each step.\n\nThe \"Decision:\" lines might not be necessary but we can include them. For simplicity, use steps with while loops as decisions. We need to produce pseudo-code lines but not actual code. We can use \"Decision:\" for while conditions.\n\nWe need to adhere to format: Each line \"虛擬碼步驟 [space] // 解釋\". Ensure we include the arrow and indent accordingly.\n\nLet's create:\n\nStart // 程式開始\n\n→ Step 1: 設定 count = 0 // 初始化回文子字串計數\n\n→ Step 2: 取得 s 的長度 n // 方便索引\n\n→ Step 3: 迴圈 center 從 0 到 n-1 // 處理奇數長度回文\n\n    → Step 3.1: 設定 left = center, right = center // 初始化左右指標\n\n    → Decision: while left >= 0 and right < n and s[left] == s[right] // 判斷是否仍為回文\n\n        Yes → Step 3.1.1: count = count + 1 // 計數\n\n        Yes → Step 3.1.2: left = left - 1 // 左移\n\n        Yes → Step 3.1.3: right = right + 1 // 右移\n\n        No → Skip // 擴張結束\n\n→ Step 4: 迴圈 center 從 0 到 n-2 // 處理偶數長度回文\n\n    → Step 4.1: 設定 left = center, right = center + 1 // 初始化左右指標\n\n    → Decision: while left >= 0 and right < n and s[left] == s[right] // 判斷是否仍為回文\n\n        Yes → Step 4.1.1: count = count + 1 // 計數\n\n        Yes → Step 4.1.2: left = left - 1 // 左移\n\n        Yes → Step 4.1.3: right = right + 1 // 右移\n\n        No → Skip // 擴張結束\n\n→ Step 5: 回傳 count // 返回回文子字串總數\n\nEnd // 程式結束\n\nBut we need to ensure each line follows \"虛擬碼步驟 // 解釋\". For nested lines we may indent or use tabs but maintain the arrow. Eg:\n\n→ Step 3: 迴圈 center 從 0 到 n-1 // 處理奇數長度回文\n\n    → Step 3.1: 設定 left = center, right = center // 初始化左右指標\n\n    → Decision: while left >= 0 and right < n and s[left] == s[right] // 判斷是否仍為回文\n\n        Yes → Step 3.1.1: count = count + 1 // 計數\n\n        Yes → Step 3.1.2: left = left - 1 // 左移\n\n        Yes → Step 3.1.3: right = right + 1 // 右移\n\n        No → Skip // 擴張結束\n\nBut the format may not support multiple lines with indentation; but the user didn't forbid indentations. However, it's safer to keep each line separate with arrow. For nested decisions, we can create separate lines like \"→ Decision: while ...\" and then \"→ Yes → ...\" etc. We need to ensure each line still follows the format: \"虛擬碼步驟 // 解釋\".\n\nThus each line must have \"→\" at beginning. For nested lines, we can add indent or additional arrow. But the arrow is required at start of line. The user example shows nested indent: they had \"Yes → Step 2: ...\" etc. So we can replicate that pattern.\n\nLet's rewrite accordingly:\n\nStart // 程式開始\n\n→ Step 1: 設定 count = 0 // 初始化回文子字串計數\n\n→ Step 2: 取得 s 的長度 n // 方便索引\n\n→ Step 3: 迴圈 center 從 0 到 n-1 // 處理奇數長度回文\n\n    → Step 3.1: 設定 left = center, right = center // 初始化左右指標\n\n    → Decision: while left >= 0 and right < n and s[left] == s[right] // 判斷是否仍為回文\n\n        Yes → Step 3.1.1: count = count + 1 // 計數\n\n        Yes → Step 3.1.2: left = left - 1 // 左移\n\n        Yes → Step 3.1.3: right = right + 1 // 右移\n\n        No  → Skip // 擴張結束\n\n→ Step 4: 迴圈 center 從 0 到 n-2 // 處理偶數長度回文\n\n    → Step 4.1: 設定 left = center, right = center + 1 // 初始化左右指標\n\n    → Decision: while left >= 0 and right < n and s[left] == s[right] // 判斷是否仍為回文\n\n        Yes → Step 4.1.1: count = count + 1 // 計數\n\n        Yes → Step 4.1.2: left = left - 1 // 左移\n\n        Yes → Step 4.1.3: right = right + 1 // 右移\n\n        No  → Skip // 擴張結束\n\n→ Step 5: 回傳 count // 返回回文子字串總數\n\nEnd // 程式結束\n\nHowever, each line must have \"虛擬碼步驟\" then space then comment. For the lines inside Decision, we need to follow that: \"Yes → Step ... // ...\". So we need to include \"Yes →\" at beginning.\n\nThus the line \"Yes → Step 3.1.1: count = count + 1 // 計數\" is fine. But the line \"→ Decision: while ...\" has a leading arrow then Decision. That line should be \"→ Decision: while ... // 判斷是否仍為回文\". Good.\n\nBut we need to ensure that each line ends with \" // 解釋\". For the \"Skip\" line: \"No  → Skip // 擴張結束\" is fine.\n\nNow the user asked \"逐行產生虛擬碼\" with the format. So we will output the pseudo-code as lines.\n\nMake sure not to include any other text. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 設定 count = 0 // 初始化回文子字串計數  \n→ Step 2: 取得 s 的長度 n // 方便索引  \n→ Step 3: 迴圈 center 從 0 到 n-1 // 處理奇數長度回文  \n    → Step 3.1: 設定 left = center, right = center // 初始化左右指標  \n    → Decision: while left >= 0 and right < n and s[left] == s[right] // 判斷是否仍為回文  \n        Yes → Step 3.1.1: count = count + 1 // 計數  \n        Yes → Step 3.1.2: left = left - 1 // 左移  \n        Yes → Step 3.1.3: right = right + 1 // 右移  \n        No  → Skip // 擴張結束  \n→ Step 4: 迴圈 center 從 0 到 n-2 // 處理偶數長度回文  \n    → Step 4.1: 設定 left = center, right = center + 1 // 初始化左右指標  \n    → Decision: while left >= 0 and right < n and s[left] == s[right] // 判斷是否仍為回文  \n        Yes → Step 4.1.1: count = count + 1 // 計數  \n        Yes → Step 4.1.2: left = left - 1 // 左移  \n        Yes → Step 4.1.3: right = right + 1 // 右移  \n        No  → Skip // 擴張結束  \n→ Step 5: 回傳 count // 返回回文子字串總數  \nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        count = [0]  # 用列表避免 nonlocal\n\n        def expand(left: int, right: int) -> None:\n            while left >= 0 and right < n and s[left] == s[right]:\n                count[0] += 1\n                left -= 1\n                right += 1\n\n        for i in range(n):\n            expand(i, i)       # 奇數長度回文\n            expand(i, i + 1)   # 偶數長度回文\n\n        return count[0]\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入形如 's = \"abc\"'，先取等號右側\n    if '=' in data:\n        _, s_part = data.split('=', 1)\n        s = s_part.strip()\n    else:\n        s = data\n\n    # 移除可能的單引號或雙引號\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n\n    result = Solution().countSubstrings(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"aaa\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode846.json",
    "problem_index_in_file": 0,
    "title": "leetcode846_problem_1",
    "description_snippet": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. For this problem: determine if hand can be arranged into groups of size groupSize where each group contains consecutive values. Classic solution: sort hand, count frequencies, iterate smallest key, subtract groupSize times. Steps: sort array, count frequencies (hash map), iterate over sorted keys, if count>0 then for i=0..groupSize-1 subtract from freq[key+i]; if any count insufficient return false; finally true.\n\nWe need virtual code lines with arrow syntax. Provide each step with explanation comment.\n\nLet's produce something like:\n\nStart // begin\n→ Step 1: Sort hand ascending // arrange cards\n→ Step 2: Create frequency map freq // count each card\n→ Decision: groupSize <= 0? // invalid\n    Yes → End with false\n    No → Continue\n→ For each card value v in sorted hand:\n    If freq[v] == 0 → continue\n    For i from 0 to groupSize-1:\n        If freq[v+i] < freq[v] → return false\n        Decrease freq[v+i] by freq[v]\n→ End // return true\n\nBut need per line. Use Decision etc. Provide explanations.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: Sort hand in ascending order // 方便後續連續檢查\n→ Step 2: Initialize an empty map freq // 用於記錄每張卡的出現次數\n→ For each card value x in hand:\n    → freq[x] = freq.get(x, 0) + 1 // 產生頻率表\n→ Decision: If groupSize == 0 or hand.length % groupSize != 0?\n    Yes → Step 3: Return false // 無法組成完整組\n    No  → Continue\n→ Decision: For each unique card value v in ascending order:\n    If freq[v] == 0 → continue // 已被消耗完\n    For i from 0 to groupSize-1:\n        If freq.get(v + i, 0) < freq[v]:\n            → Step 4: Return false // 缺少足夠的連續卡片\n        Else:\n            freq[v + i] = freq.get(v + i) - freq[v] // 消耗\n→ Step 5: Return true // 所有卡片成功分組\n\nBut need line by line with arrows and comments.\n\nWe need to avoid actual code, only virtual steps. Use arrows for nested structure.\n\nLet's output as per format. Use \"Decision:\" then indentation. Use \"Yes →\" and \"No →\".\n\nMake sure each line has \"虛擬碼步驟\" and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort hand in ascending order // 先將所有卡片值由小到大排序，方便後續檢查連續序列  \n→ Step 2: Initialize an empty map freq // 用於記錄每個卡片值出現的次數  \n→ For each card value x in hand:  \n  → freq[x] = freq.get(x, 0) + 1 // 逐一累加每個值的頻率  \n→ Decision: 是否滿足基本條件 (groupSize > 0 且 hand.length % groupSize == 0)?  \n  Yes → End with result false // 若條件不符，直接回傳 false  \n  No  → Continue // 符合條件，繼續往下做分組檢查  \n→ For each unique card value v in ascending order of hand:  \n  Decision: freq[v] == 0?  \n   Yes → Continue // 已被前面的組消耗完畢，跳過  \n   No  →  \n    For i from 0 to groupSize-1:  \n     Decision: freq.get(v + i, 0) < freq[v]?  \n      Yes → End with result false // 缺少足夠的連續卡片，無法完成分組  \n      No  → freq[v + i] = freq.get(v + i) - freq[v] // 消耗這段連續的卡片  \n→ End // 所有卡片已成功分組，回傳 true",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        if len(hand) % groupSize != 0:\n            return False\n\n        count = Counter(hand)\n        for card in sorted(count):\n            freq = count[card]\n            if freq > 0:\n                for i in range(card, card + groupSize):\n                    if count[i] < freq:\n                        return False\n                    count[i] -= freq\n        return True\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 從輸入字串中提取 hand 與 groupSize\n    hand_match = re.search(r'hand\\s*=\\s*(\\[[^\\]]*\\])', data)\n    size_match = re.search(r'groupSize\\s*=\\s*(\\d+)', data)\n\n    if not hand_match or not size_match:\n        print(False)\n        sys.exit()\n\n    hand_str = hand_match.group(1)\n    group_size_str = size_match.group(1)\n\n    # 解析手牌清單與群組大小\n    hand = eval(hand_str)\n    groupSize = int(group_size_str)\n\n    # 執行判斷並輸出結果\n    sol = Solution()\n    result = sol.isNStraightHand(hand, groupSize)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode88.json",
    "problem_index_in_file": 0,
    "title": "Merge Sorted Array",
    "description_snippet": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format. Use Start, End, Decision, etc. Steps: merging from end. Provide explanation per line.\n\nWe need to produce virtual code steps, not actual code. Format: \"虛擬碼步驟 // 解釋/說明\".\n\nLet's craft:\n\nStart\n→ Step 1: 設定 i = m-1 // 指向 nums1 原始元素最後一個\n→ Step 2: 設定 j = n-1 // 指向 nums2 最後一個\n→ Step 3: 設定 k = m+n-1 // 指向 nums1 最後位置\n→ Decision: 如果 i < 0 and j >= 0? // 檢查 nums1 已耗盡\n    Yes → 循環 while j >= 0: \n        → Step 4: nums1[k] = nums2[j] // 把剩餘 nums2 放進 nums1\n        → Step 5: k-- // 移動 k\n        → Step 6: j-- // 移動 j\n    No → Decision: 如果 j < 0? // nums2 已耗盡\n        Yes → End // 無需做任何事，nums1 已正確\n        No → Decision: 如果 nums1[i] > nums2[j]? // 選擇較大放入\n            Yes → Step 7: nums1[k] = nums1[i] // 放 nums1 元素\n            → Step 8: i-- // 移動 i\n            No  → Step 9: nums1[k] = nums2[j] // 放 nums2 元素\n            → Step 10: j-- // 移動 j\n        → Step 11: k-- // 移動 k\n        → Step 12: 回到 Decision: ... // 重複\n\nBut we need to structure as loops; maybe use While loop: while j >= 0, while i >=0 and j>=0, etc.\n\nSimplify: Use a while loop.\n\nLet's create: while j >= 0:\n   if i >=0 and nums1[i] > nums2[j]:\n       nums1[k] = nums1[i]\n       i--\n   else:\n       nums1[k] = nums2[j]\n       j--\n   k--\n\nThis covers all.\n\nSo virtual code:\n\nStart\n→ Step 1: i = m - 1 // 指向 nums1 原始最後元素\n→ Step 2: j = n - 1 // 指向 nums2 最後元素\n→ Step 3: k = m + n - 1 // 指向 nums1 最後位置\n→ Decision: 是否還有 nums2 元素? j >= 0? // 循環合併\n    Yes → Step 4: Decision: i >= 0 且 nums1[i] > nums2[j]? // 決定放哪個\n        Yes → Step 5: nums1[k] = nums1[i] // 放較大者\n        → Step 6: i-- // 移動 i\n        No  → Step 7: nums1[k] = nums2[j] // 放 nums2 元素\n        → Step 8: j-- // 移動 j\n    → Step 9: k-- // 移動 k\n    → 返回 Decision: j >= 0? // 重複\nEnd\n\nWe also need to cover case when nums1 empty. This algorithm covers because i starts -1.\n\nWe must produce line-by-line with arrows.\n\nOk, produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = m - 1 // 設定指標 i 指向 nums1 原始元素的最後一個  \n→ Step 2: j = n - 1 // 設定指標 j 指向 nums2 最後一個  \n→ Step 3: k = m + n - 1 // 設定指標 k 指向 nums1 整體最後位置  \n→ Decision: j >= 0? // 檢查是否還有 nums2 的元素未放入  \n  Yes → Step 4: Decision: i >= 0 且 nums1[i] > nums2[j]? // 決定將較大者放入 k 位置  \n    Yes → Step 5: nums1[k] = nums1[i] // 把 nums1 的較大元素放入 nums1[k]  \n     → Step 6: i-- // 移動 i 指標至前一個元素  \n    No  → Step 7: nums1[k] = nums2[j] // 把 nums2 的元素放入 nums1[k]  \n     → Step 8: j-- // 移動 j 指標至前一個元素  \n    → Step 9: k-- // 移動 k 指標至前一個位置  \n    → 回到 Decision: j >= 0? // 重複合併過程  \n  No → End // 所有元素已合併完成，結束程式  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        i = m - 1\n        j = n - 1\n        k = m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如:\n    'nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3'\n    的字串，並回傳 (nums1, m, nums2, n)。\n    \"\"\"\n    pattern = re.compile(\n        r'nums1\\s*=\\s*(\\[.*?\\])\\s*,\\s*m\\s*=\\s*(\\d+)\\s*,\\s*nums2\\s*=\\s*(\\[.*?\\])\\s*,\\s*n\\s*=\\s*(\\d+)',\n        re.S\n    )\n    match = pattern.search(data)\n    if not match:\n        raise ValueError(\"輸入格式不符合要求\")\n    nums1 = ast.literal_eval(match.group(1))\n    m = int(match.group(2))\n    nums2 = ast.literal_eval(match.group(3))\n    n = int(match.group(4))\n    return nums1, m, nums2, n\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    nums1, m, nums2, n = parse_input(raw)\n    Solution().merge(nums1, m, nums2, n)\n    print(nums1)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "success": true,
          "output": "[1, 2, 2, 3, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1009.json",
    "problem_index_in_file": 0,
    "title": "Complement of Base 10 Integer",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for computing complement of integer. Should use Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Must be in Traditional Chinese. Provide virtual code that flips bits. Steps: start, convert n to binary string, iterate bits, flip, assemble result, output. Also handle n=0? Complement of 0? If n=0, binary \"0\" complement \"1\" => 1? Usually. Use logic: while n>0. Use bitwise XOR with mask of all 1's same length. Or simpler: compute bit_length and use mask = (1 << bit_length) - 1; result = n ^ mask. Provide steps. Use virtual code structure.\n\nLet's craft.\n\nStart // 開始\n→ Step 1: 輸入整數 n // 取得使用者輸入\n→ Decision: 若 n 等於 0? // 特殊情況\n    Yes → Step 2: 設定 result = 1 // 0 的補碼為 1\n    No → Step 3: 計算 bitLen = n 的二進位長度 // 確定需要的位數\n→ Step 4: 計算 mask = (1 << bitLen) - 1 // 所有位都是 1 的掩碼\n→ Step 5: 計算 result = n XOR mask // 反轉所有位\n→ Step 6: 輸出 result // 回傳補碼\nEnd // 程式結束\n\nNeed to ensure proper indentation for decision branches.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者處取得要處理的整數  \n→ Decision: 若 n 等於 0? // 先檢查特殊情況  \n  Yes → Step 2: 設定 result = 1 // 0 的二進位是 0，反轉後是 1  \n  No  → Step 3: 計算 bitLen = n 的二進位長度 // 確定要反轉的位數  \n→ Step 4: 計算 mask = (1 << bitLen) - 1 // 建立所有位都是 1 的掩碼  \n→ Step 5: 計算 result = n XOR mask // 用 XOR 反轉 n 的所有位  \n→ Step 6: 輸出 result // 將補碼回傳給使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef bitwise_complement(n: int) -> int:\n    \"\"\"返回 n 的二進位補碼。\"\"\"\n    if n == 0:\n        return 1\n    mask = (1 << n.bit_length()) - 1\n    return n ^ mask\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read()\n    # 取出第一個整數 (支援 \"n = 5\" 等格式)\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        sys.exit()\n    n = int(numbers[0])\n\n    # 計算補碼並輸出\n    print(bitwise_complement(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 10",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode712.json",
    "problem_index_in_file": 0,
    "title": "Minimum ASCII Delete Sum for Two Strings",
    "description_snippet": "Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code (algorithm steps) for the problem: \"Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.\" This is a known dynamic programming problem: minimum ASCII delete sum. We need to produce step-by-step pseudocode with explanations.\n\nWe need to output line by line, each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow symbols and structure: Start, End, Decision: etc.\n\nWe need to produce the algorithm. Steps: initialize DP table dp[i][j] for prefixes of s1 length i, s2 length j. dp[0][0] = 0. dp[i][0] = sum ASCII of first i chars of s1; dp[0][j] = sum ASCII of first j chars of s2. Then iterate over i, j: if s1[i-1]==s2[j-1], dp[i][j]=dp[i-1][j-1] else dp[i][j] = min(dp[i-1][j]+ASCII(s1[i-1]), dp[i][j-1]+ASCII(s2[j-1])). Finally answer dp[m][n].\n\nWe need to output in pseudocode with explanation. Also need to use arrows and decision structures. The problem might also need reading input but not necessary. Just algorithm steps.\n\nWe need to output using \"Start // 程式開始執行\", \"→\" arrows. Each line includes step description and explanation.\n\nWe might structure:\n\nStart\n→ Step 1: Let m = length of s1, n = length of s2 // 獲取兩個字串長度\n→ Step 2: 初始化 dp 表格大小 (m+1)×(n+1) // 用於儲存子問題答案\n→ Step 3: dp[0][0] = 0 // 兩個空字串相等，刪除字元成本為 0\n→ Decision: 是否需要初始化第一列? // 為了計算刪除 s1 前 i 個字元\n   Yes → 迴圈 i from 1 to m: dp[i][0] = dp[i-1][0] + ASCII(s1[i-1]) // 將 s1 的前 i 個字元全部刪除\n   No // ...\n→ Decision: 是否需要初始化第一行? // 為了計算刪除 s2 前 j 個字元\n   Yes → 迴圈 j from 1 to n: dp[0][j] = dp[0][j-1] + ASCII(s2[j-1]) // 將 s2 的前 j 個字元全部刪除\n   No\n→ 迴圈 i from 1 to m:\n   → 迴圈 j from 1 to n:\n       → Decision: s1[i-1] == s2[j-1]?\n           Yes → dp[i][j] = dp[i-1][j-1] // 字元相同，不需要刪除\n           No → dp[i][j] = min( dp[i-1][j] + ASCII(s1[i-1]), dp[i][j-1] + ASCII(s2[j-1]) ) // 刪除較低成本的字元\n→ Step final: Return dp[m][n] // 最低刪除字元 ASCII 和\n\nEnd\n\nWe need to follow format: each line includes arrow and explanation. For loops and decisions, we should include arrow lines inside loops. Use indentation? Not needed, but we can use spaces.\n\nNeed to ensure each line ends with \"// 解釋\". Use Chinese explanation. Use \"→\" before step lines, and \"Decision:\" lines with indent. Use \"Yes →\", \"No →\" within decisions.\n\nMake sure no actual code, just structure. Provide as final output.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得字串 s1 與 s2 的長度 m 與 n // 為後續 DP 表格尺寸做準備  \n→ Step 2: 初始化 dp 為 (m+1)×(n+1) 的表格，並填入 0 // 用於存放子問題答案  \n→ Step 3: 設定 dp[0][0] = 0 // 空字串相等時不需要刪除任何字元  \n→ Decision: 是否需要為第一列設定值？ // 第一列對應刪除 s1 的前 i 個字元  \n Yes → 迴圈 i 從 1 到 m:  \n  → dp[i][0] = dp[i-1][0] + ASCII(s1[i-1]) // 刪除 s1 的第 i 個字元  \n No → （無）  \n→ Decision: 是否需要為第一行設定值？ // 第一行對應刪除 s2 的前 j 個字元  \n Yes → 迴圈 j 從 1 到 n:  \n  → dp[0][j] = dp[0][j-1] + ASCII(s2[j-1]) // 刪除 s2 的第 j 個字元  \n No → （無）  \n→ 迴圈 i 從 1 到 m:  \n → 迴圈 j 從 1 到 n:  \n  → Decision: s1[i-1] == s2[j-1]? // 檢查兩字元是否相同  \n   Yes → dp[i][j] = dp[i-1][j-1] // 字元相同，無需刪除  \n   No → dp[i][j] = min( dp[i-1][j] + ASCII(s1[i-1]), dp[i][j-1] + ASCII(s2[j-1]) ) // 刪除成本較低的字元  \n→ Step final: 回傳 dp[m][n] // 這即為最小 ASCII 刪除總和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # 初始化第一列（刪除 s1 的前 i 個字元）\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n\n        # 初始化第一行（刪除 s2 的前 j 個字元）\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n\n        # DP 填表\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(\n                        dp[i - 1][j] + ord(s1[i - 1]),\n                        dp[i][j - 1] + ord(s2[j - 1]),\n                    )\n\n        return dp[m][n]\n\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中解析出 s1 與 s2。\n    支援兩種格式：\n      1. 形如 s1 = \"sea\", s2 = \"eat\"\n      2. 兩行分別為字串\n    \"\"\"\n    # 先嘗試正則匹配\n    pattern = r's1\\s*=\\s*\"([^\"]*)\"\\s*,\\s*s2\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, text)\n    if match:\n        return match.group(1), match.group(2)\n\n    # 若沒有找到，假設每行是一個字串\n    lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # 其他情況直接回傳空字串\n    return \"\", \"\"\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s1, s2 = parse_input(data)\n    solution = Solution()\n    result = solution.minimumDeleteSum(s1, s2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"sea\", s2 = \"eat\"",
          "expected_output": "231",
          "success": true,
          "output": "231"
        },
        {
          "example_index": 1,
          "input": "s1 = \"delete\", s2 = \"leet\"",
          "expected_output": "403",
          "success": true,
          "output": "403"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode640.json",
    "problem_index_in_file": 0,
    "title": "Solve the Equation",
    "description_snippet": "Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for solving linear equation with x. Steps: parse equation, split left and right, compute coefficients, etc. Use virtual steps. Ensure each line with arrow and comment. Let's produce a step-by-step algorithm. Use decisions for no solution, infinite, unique. Use structure. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 equation // 從使用者取得方程式  \n→ Step 2: 用 '=' 分割 equation 為 leftPart, rightPart // 拆分等式兩邊  \n→ Step 3: 解析 leftPart 得到係數 sumLeftX, sumLeftConst // 取 x 的係數與常數  \n→ Step 4: 解析 rightPart 得到係數 sumRightX, sumRightConst // 取 x 的係數與常數  \n→ Step 5: 計算 netX = sumLeftX - sumRightX // 整理後 x 的總係數  \n→ Step 6: 計算 netConst = sumRightConst - sumLeftConst // 整理後常數項  \n→ Decision: 是否 netX 為 0? // 檢查 x 係數是否為零  \n    Yes → Decision: 是否 netConst 為 0? // 若係數為零，判斷常數是否也為零  \n        Yes → Step 7: 輸出 'Infinite solutions' // 無限制多解  \n        No  → Step 8: 輸出 'No solution' // 無解  \n    No  → Step 9: 計算 x = netConst / netX // 計算唯一解，因為已知結果為整數  \n→ Step 10: 輸出 'x=' + x // 回傳 x 的值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def solveEquation(self, equation: str) -> str:\n        \"\"\"\n        Solves a linear equation with variable x that contains only '+' and '-' operations.\n        Returns the result as a string:\n        - \"x=#value\" for a unique integer solution\n        - \"No solution\" if the equation has no solution\n        - \"Infinite solutions\" if the equation has infinitely many solutions\n        \"\"\"\n        def parse_side(s: str):\n            \"\"\"Parse one side of the equation and return (x_coefficient, constant).\"\"\"\n            x_coeff, const = 0, 0\n            i, n, sign = 0, len(s), 1\n            while i < n:\n                if s[i] == '+':\n                    sign = 1\n                    i += 1\n                elif s[i] == '-':\n                    sign = -1\n                    i += 1\n                else:\n                    j = i\n                    while j < n and s[j] not in '+-':\n                        j += 1\n                    token = s[i:j]\n                    if 'x' in token:\n                        coeff_part = token[:-1]  # everything before 'x'\n                        if coeff_part == '' or coeff_part == '+':\n                            coeff = 1\n                        elif coeff_part == '-':\n                            coeff = -1\n                        else:\n                            coeff = int(coeff_part)\n                        x_coeff += sign * coeff\n                    else:\n                        const += sign * int(token)\n                    i = j\n            return x_coeff, const\n\n        left, right = equation.split('=')\n        left_x, left_const = parse_side(left)\n        right_x, right_const = parse_side(right)\n\n        total_x = left_x - right_x\n        total_const = right_const - left_const\n\n        if total_x == 0:\n            if total_const == 0:\n                return \"Infinite solutions\"\n            else:\n                return \"No solution\"\n        else:\n            return f\"x={total_const // total_x}\"\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the equation string: either quoted or plain\n    match = re.search(r'\"([^\"]+)\"', data)\n    if match:\n        equation = match.group(1)\n    else:\n        # assume the entire input is the equation string\n        equation = data.replace('equation =', '').strip().strip('\"')\n    solution = Solution().solveEquation(equation)\n    print(solution)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equation = \"x+5-3+x=6+x-2\"",
          "expected_output": "x=2",
          "success": true,
          "output": "x=2"
        },
        {
          "example_index": 1,
          "input": "equation = \"x=x\"",
          "expected_output": "Infinite solutions",
          "success": true,
          "output": "Infinite solutions"
        },
        {
          "example_index": 2,
          "input": "equation = \"2x=x\"",
          "expected_output": "x=0",
          "success": true,
          "output": "x=0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode128.json",
    "problem_index_in_file": 0,
    "title": "Longest Consecutive Sequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm that finds longest consecutive sequence in unsorted array, O(n). Standard approach: put numbers in hash set, then for each number, if it's start of sequence (num-1 not in set), then extend count while num+1 in set. Track max. Complexity O(n). Provide line-by-line virtual code with explanation. Should use Start, End, Decision, arrow syntax. Use \"Step\" lines. Provide explanation after each. Ensure each line has virtual code + space + comment.\n\nLet's craft steps:\n\nStart\n→ Step 1: Build hash set from nums // O(n) to store numbers\n→ Step 2: Initialize maxLen = 0 // variable to hold longest length\n→ Step 3: For each number num in hash set // iterate over unique numbers\n    → Decision: Is num-1 in hash set? // check if num is sequence start\n        No  → Step 4: current = 1 // current sequence length\n        → Step 5: nextNum = num + 1 // prepare to extend\n        → Decision: Is nextNum in hash set? // while loop\n            Yes → Step 6: current++ // increment length\n            → Step 7: nextNum++ // move to next\n            → Decision: nextNum in hash set? // continue\n                Yes → (loop back to step 6)\n                No  → Step 8: If current > maxLen Then maxLen = current // update max\n        Yes  → (if num-1 in set, skip to next number)\n→ Step 9: Return maxLen // output result\nEnd\n\nNeed to format decisions with arrows. Let's craft consistent indentation and arrows. Use \"Yes →\" \"No →\". For loops and decisions, we need proper syntax. Use pseudo structure: \"Decision:\" then indented Yes/No branches. For loops, we can show as \"→ Decision: ...\". For while, can use Decision inside.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 hash set S 來存放 nums 中的所有數字 // O(n) 時間，方便快速查詢\n→ Step 2: 設定 maxLen = 0 // 用來記錄目前為止最長連續序列長度\n→ Step 3: For 每個 num 於 S 中 // 遍歷所有唯一數字\n    → Decision: 若 num-1 存於 S? // 檢查 num 是否為連續序列的起點\n        No  → Step 4: current = 1 // 初始化此序列長度\n        → Step 5: next = num + 1 // 設定下一個可能的連續數字\n        → Decision: 若 next 存於 S? // 進入 while 迴圈尋找完整序列\n            Yes → Step 6: current += 1 // 序列長度加一\n            → Step 7: next += 1 // 進一步尋找下個數字\n            → Decision: 若 next 存於 S? // 繼續迴圈\n                Yes → (回到 Step 6) // 仍在同一個序列內\n                No  → Step 8: 若 current > maxLen 則 maxLen = current // 更新最大長度\n        Yes  → (若 num-1 存於 S，則 num 不是序列起點，直接跳至下一個 num)\n→ Step 9: Return maxLen // 回傳最長連續序列長度\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def longestConsecutive(self, nums):\n        \"\"\"\n        Find the length of the longest consecutive elements sequence.\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n\n        num_set = set(nums)\n        longest = 0\n\n        for num in num_set:\n            # Only start counting if num is the beginning of a sequence\n            if num - 1 not in num_set:\n                current_num = num\n                length = 1\n\n                # Extend the sequence while the next number exists\n                while current_num + 1 in num_set:\n                    current_num += 1\n                    length += 1\n\n                longest = max(longest, length)\n\n        return longest\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Find the first '[' and parse the list using ast.literal_eval for safety\n    start = raw_input.find('[')\n    end = raw_input.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # If no list is found, assume the whole input is a list representation\n        list_str = raw_input\n    else:\n        list_str = raw_input[start:end + 1]\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # If parsing fails, treat input as an empty list\n        nums = []\n\n    # Ensure the parsed object is a list of integers\n    if not isinstance(nums, list):\n        nums = []\n\n    solution = Solution()\n    result = solution.longestConsecutive(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [100,4,200,1,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "nums = [1,0,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode56.json",
    "problem_index_in_file": 0,
    "title": "Merge Intervals",
    "description_snippet": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for merging overlapping intervals. Provide each line with comment. Use Start, End, Decision, arrow etc. Must be in Traditional Chinese. Provide no actual code, just virtual steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows like →, Yes →, No →. So we produce algorithm steps: sort intervals by start, initialize merged list, iterate through sorted intervals, compare with last interval's end, merge or append. Finally return merged.\n\nWe need to output step-by-step virtual code. The format: each line with code like \"Start // 程式開始執行\" etc.\n\nLet's produce steps:\n\nStart\n→ Step 1: Sort intervals by start ascending // 對 intervals 按起始點排序\n→ Step 2: 初始化 merged 為空列表 // 用於存放合併後的區間\n→ Step 3: 取第一個區間並加入 merged // 將第一個區間作為初始合併區間\n→ Decision: 迴圈遍歷 intervals 的其餘區間 // 檢查是否還有未處理的區間\n    Yes → Step 4: 取當前區間 curr // 取得當前要處理的區間\n    → Decision: curr.start <= merged.last.end? // 判斷是否與已合併區間重疊\n        Yes → Step 5: merged.last.end = max(merged.last.end, curr.end) // 合併\n        No  → Step 6: merged.append(curr) // 不重疊，直接加入\n    → Step 7: 迴圈結束判斷 // 回到迴圈條件\n    No  → Step 8: End // 完成所有區間處理\n→ Step 9: 返回 merged // 回傳合併後的區間列表\n\nBut we need to incorporate Decision blocks and arrows with indent. Format must be strict: Start, End, Decision lines with arrow.\n\nExample given shows indent: \"    Yes → Step 2: 輸出 '正數'\". We'll replicate. Use spaces for indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort intervals by start ascending // 對所有區間依起始點排序\n→ Step 2: 初始化 merged 為空列表 // 用來儲存合併後的區間\n→ Step 3: 取第一個區間並加入 merged // 先把排序後的第一個區間放進 merged\n→ Decision: 迴圈遍歷 intervals 的其餘區間 // 檢查是否還有未處理的區間\n    Yes → Step 4: 取當前區間 curr // 取得當前要處理的區間\n    → Decision: curr.start <= merged.last.end? // 判斷 curr 是否與 merged 最後一個區間重疊\n        Yes → Step 5: merged.last.end = max(merged.last.end, curr.end) // 若重疊，更新結束點為較大的值\n        No  → Step 6: merged.append(curr) // 若不重疊，直接把 curr 加入 merged\n    → Step 7: 回到迴圈條件 // 檢查是否還有下一個區間\n    No  → Step 8: End // 所有區間已處理完畢\n→ Step 9: 返回 merged // 輸出合併後的區間列表",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def merge(self, intervals):\n        \"\"\"\n        合併重疊的區間，返回不重疊的區間列表。\n        \"\"\"\n        if not intervals:\n            return []\n\n        # 先按起始點排序\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n\n        # 從第二個區間開始與已合併的區間比較\n        for current in intervals[1:]:\n            prev = merged[-1]\n            if current[0] <= prev[1]:\n                # 重疊，更新結束點\n                prev[1] = max(prev[1], current[1])\n            else:\n                # 不重疊，直接加入\n                merged.append(current)\n\n        return merged\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 可能的輸入格式：intervals = [[1,3],[2,6],[8,10],[15,18]]\n    # 或者直接給出列表字面量\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # 轉換成 Python 物件（安全方式）\n    intervals = ast.literal_eval(expr)\n\n    # 執行合併邏輯\n    solution = Solution()\n    merged = solution.merge(intervals)\n\n    # 輸出結果\n    print(merged)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "expected_output": "[[1,6],[8,10],[15,18]]",
          "success": true,
          "output": "[[1, 6], [8, 10], [15, 18]]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,4],[4,5]]",
          "expected_output": "[[1,5]]",
          "success": true,
          "output": "[[1, 5]]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[4,7],[1,4]]",
          "expected_output": "[[1,7]]",
          "success": true,
          "output": "[[1, 7]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode395.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring with At Least K Repeating Characters",
    "description_snippet": "Given a string s and an integer k, return the length of the longest substring of s such that the fre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations, following the format. The task: longest substring where each char frequency >= k. This is classic problem: longest substring with at least k repeating each char. Approach: divide and conquer or sliding window. We'll produce virtual steps for divide and conquer recursion.\n\nWe output line by line, with arrows.\n\nLet's produce steps:\n\nStart\n→ Step: Define function longestSubstring(s, k)\n    // function entry point\n→ Decision: If s length < k? // early exit\n    Yes → Step: Return 0 // cannot satisfy\n    No  → Continue\n→ Step: Find character in s that occurs less than k times (invalid char)\n    // Build frequency map, find first invalid\n→ Decision: If no invalid char? // all chars freq>=k\n    Yes → Step: Return s length // entire string valid\n    No  → Step: Split s by invalid char into parts\n        // Recursively compute each part\n→ Step: For each part, call longestSubstring(part, k) and keep max\n→ Step: Return max\n\nEnd.\n\nWe need to produce each step as a line of virtual code plus comment. Use \"→\" for steps. Indentation for decisions.\n\nLet's produce lines.\n\nWe'll use \"Start // 程式開始執行\". Then \"→ Step: 定義 function longestSubstring(s, k) // 進入函式\". Then decision etc.\n\nEnsure each line ends with comment.\n\nWe need to include arrow for decisions: \"Decision: ...\". For Yes and No, \"Yes →\" and \"No →\".\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義函式 longestSubstring(s, k) // 進入主函式  \n→ Decision: s 的長度是否小於 k？ // 若字串太短則不可能符合條件  \n  Yes → Step: 回傳 0 // 無法找到符合的子字串  \n  No  → Step: 建立字元頻率表 freq // 先統計各字元出現次數  \n→ Decision: 是否存在任何字元的頻率 < k？ // 這些字元為分割點  \n  Yes → Step: 找出第一個頻率 < k 的字元 badChar // 選擇分割符號  \n    → Step: 用 badChar 將 s 分割成多個子字串 parts // 以 badChar 為界線切分  \n    → Step: maxLen ← 0 // 初始化最大長度  \n    → Step: 對於每個 part 在 parts 中  \n      → Step: tempLen ← longestSubstring(part, k) // 递归求解子字串  \n      → Decision: tempLen 是否大於 maxLen？  \n        Yes → Step: maxLen ← tempLen // 更新最大長度  \n        No  → Step: 無需更新  \n    → Step: 回傳 maxLen // 返回此分段的最大長度  \n  No  → Step: 回傳 s 的長度 // 所有字元頻率已 ≥ k，整串有效  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        # 如果字串長度小於 k，無法滿足要求\n        if len(s) < k:\n            return 0\n\n        # 統計字元頻率\n        count = Counter(s)\n        for char, freq in count.items():\n            # 找到頻率小於 k 的字元，將字串以它為分割點切分\n            if freq < k:\n                # 對每個子字串遞迴計算，並取最大值\n                return max(\n                    self.longestSubstring(sub, k)\n                    for sub in s.split(char)\n                )\n        # 所有字元頻率都 >= k，整串有效\n        return len(s)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入，支援兩種格式：\n    1. s = \"aaabb\", k = 3\n    2. 兩行或一行分別給出字串和整數\n    \"\"\"\n    # 先嘗試以正則表達式解析 s = \"...\" , k = ...\n    pattern = r's\\s*=\\s*[\"\\'](.+?)[\"\\']\\s*,\\s*k\\s*=\\s*(\\d+)'\n    m = re.search(pattern, data)\n    if m:\n        s, k = m.group(1), int(m.group(2))\n        return s, k\n\n    # 如果沒有符合上面格式，嘗試分行/空白分隔\n    parts = [p.strip() for p in data.replace('\\n', ' ').split() if p.strip()]\n    if len(parts) >= 2:\n        s = parts[0]\n        k = int(parts[1])\n        return s, k\n\n    # 其他不可解析情況拋出錯誤\n    raise ValueError(\"無法解析輸入\")\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit()\n    s, k = parse_input(data)\n    solution = Solution()\n    result = solution.longestSubstring(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabb\", k = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"ababbc\", k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode231.json",
    "problem_index_in_file": 0,
    "title": "Power of Two",
    "description_snippet": "Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nAn integer n is a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step explaining checking if n is power of two. Must follow format: each line \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc.\n\nWe need to produce logic: check if n <= 0 → false. Then while n%2==0, n/=2. After loop, if n==1 true else false. Or use bit trick n & (n-1)==0. But we can use loop.\n\nThus produce steps:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 從使用者取得整數\n→ Decision: 如果 n <= 0? // 檢查 n 是否為正數\n    Yes → Step 2: 回傳 false // 小於等於0不是 2 的冪\n    No  → Step 3: 初始化變數 temp = n // 用於除以 2\n→ Decision: 如果 temp == 1? // 如果已經是 1，則 n 是 2^0\n    Yes → Step 4: 回傳 true // n 為 2 的冪\n    No  → Step 5: 開始迴圈\n→ Step 5: 重複執行直到 temp % 2 != 0 或 temp == 1 // 將 temp 除以 2 直到不整除\n        → Decision: 如果 temp % 2 != 0? // 若不再整除 2\n            Yes → Step 6: 回傳 false // 不是 2 的冪\n            No  → Step 7: temp = temp / 2 // 继续除 2\n        → Loop back to Step 5\n→ Step 4 or 6: End // 程式結束\n\nBut need line by line with arrows. Let's create simple structure:\n\nStart\n→ Step 1: Get integer n\n→ Decision: n <= 0?\n    Yes → Step 2: Return false\n    No → Step 3: temp = n\n→ Decision: temp == 1?\n    Yes → Step 4: Return true\n    No → Step 5: While temp % 2 == 0: temp /= 2\n→ Decision: temp == 1?\n    Yes → Step 6: Return true\n    No  → Step 7: Return false\nEnd\n\nBetter to represent loop: Step 5 with loop condition.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得使用者輸入的數字\n→ Decision: n <= 0? // 檢查是否為正數\n    Yes → Step 2: 回傳 false // 非正數不能是 2 的冪\n    No  → Step 3: 設定 temp = n // 用 temp 進行除法\n→ Decision: temp == 1? // 直接是 1 時是 2^0\n    Yes → Step 4: 回傳 true // 是 2 的冪\n    No  → Step 5: 開始 while 循環\n→ Step 5: While temp % 2 == 0: temp = temp / 2 // 重複除以 2\n→ Decision: temp == 1? // 結束後是否為 1\n    Yes → Step 6: 回傳 true // 是 2 的冪\n    No  → Step 7: 回傳 false // 不是 2 的冪\nEnd // 程式結束\n\nMake sure to include arrow and step numbering? Not required but okay.\n\nWe'll output each line separately. Ensure each line ends with // 解釋. Use arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者取得輸入的數值  \n→ Decision: n <= 0? // 檢查 n 是否為正數  \n Yes → Step 2: 回傳 false // 小於等於 0 不是 2 的冪  \n No  → Step 3: temp = n // 用 temp 進行除法操作  \n→ Decision: temp == 1? // 若已是 1，即 2^0  \n Yes → Step 4: 回傳 true // 確定是 2 的冪  \n No  → Step 5: 開始 while 循環  \n→ Step 5: While temp % 2 == 0: temp = temp / 2 // 只要能被 2 整除就除以 2  \n→ Decision: temp == 1? // 循環結束後是否剩 1  \n Yes → Step 6: 回傳 true // 是 2 的冪  \n No  → Step 7: 回傳 false // 不是 2 的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        \"\"\"\n        Determine whether n is a power of two.\n        Uses the bit trick: a positive power of two has only one bit set,\n        so n & (n - 1) == 0 iff n is a power of two.\n        \"\"\"\n        if n <= 0:\n            return False\n        return (n & (n - 1)) == 0\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 從輸入中搜尋第一個整數（允許負號）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        # 若找不到整數，直接退出\n        sys.exit(0)\n    n = int(match.group())\n    # 判斷是否為 2 的冪\n    result = Solution().isPowerOfTwo(n)\n    # 輸出符合題目要求的字串\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode455.json",
    "problem_index_in_file": 0,
    "title": "Assign Cookies",
    "description_snippet": "Assume you are an awesome parent and want to give your children some cookies. But, you should give e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for problem: maximize content children given greed factors and cookie sizes, each child at most one cookie. Classic greedy: sort both arrays, two pointers. We'll produce pseudocode lines.\n\nWe must produce lines: Start, Step 1, Decision, etc.\n\nLet's craft steps:\n\nStart // program start\n\n→ Step 1: Read number of children n and cookies m\n\n→ Step 2: Read array g[1..n] // greed factors\n\n→ Step 3: Read array s[1..m] // cookie sizes\n\n→ Step 4: Sort g ascending // sort greed\n\n→ Step 5: Sort s ascending // sort cookie sizes\n\n→ Decision: If n == 0 or m == 0? // edge\n\n    Yes → Step 6: Output 0 // no children or no cookies\n\n    No  → Step 7: Initialize i = 0, j = 0, count = 0 // indices\n\n→ Decision: While i < n and j < m? // main loop\n\n    Yes → Decision: If s[j] >= g[i]? // cookie big enough\n\n        Yes → Step 8: count = count + 1 // content child\n\n        Yes → Step 9: i = i + 1 // move to next child\n\n        Yes → Step 10: j = j + 1 // move to next cookie\n\n        No  → Step 11: j = j + 1 // cookie too small, try larger one\n\n    No → Step 12: Output count // finished\n\nEnd // program end\n\nBut we need virtual code lines each with explanation. Use arrow '→' for steps. Use Decision: and Yes → etc.\n\nWe must ensure each line is separate. Let's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 讀取子女數 n 與餅乾數 m // 取得輸入資料\n\n→ Step 2: 讀取 greed array g[0..n-1] // 子女貪婪值\n\n→ Step 3: 讀取 cookie array s[0..m-1] // 餅乾大小\n\n→ Step 4: 將 g 陣列按升序排序 // 方便比對\n\n→ Step 5: 將 s 陣列按升序排序 // 方便比對\n\n→ Decision: 是否 n == 0 或 m == 0? // 判斷邊界\n\n    Yes → Step 6: 輸出 0 // 無子女或無餅乾\n\n    No  → Step 7: 設定 i = 0, j = 0, count = 0 // 初始化指標\n\n→ Decision: while i < n 且 j < m? // 主循環\n\n    Yes → Decision: 如果 s[j] >= g[i]? // 是否能滿足\n\n        Yes → Step 8: count = count + 1 // 兒童滿足\n\n        Yes → Step 9: i = i + 1 // 移至下一個子女\n\n        Yes → Step 10: j = j + 1 // 使用此餅乾\n\n        No  → Step 11: j = j + 1 // 餅乾太小，嘗試下一個\n\n    No → Step 12: 輸出 count // 所有餅乾或子女已處理完畢\n\nEnd // 程式執行結束\n\nBut note the formatting: each line has virtual code then space then comment. Need to ensure we use \"→\" before step lines. For decisions we use \"Decision:\" lines with indentation? In example, indent under Decision: lines.\n\nSo format:\n\nDecision: ...? // comment\n\n    Yes → Step ... // comment\n\n    No  → Step ... // comment\n\nSimilarly while loop as Decision.\n\nAlso we need End after output. That line should not be indented.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取子女數 n 與餅乾數 m // 取得輸入資料\n→ Step 2: 讀取 greed 陣列 g[0..n-1] // 子女貪婪值\n→ Step 3: 讀取 cookie 陣列 s[0..m-1] // 餅乾大小\n→ Step 4: 將 g 陣列按升序排序 // 方便比對\n→ Step 5: 將 s 陣列按升序排序 // 方便比對\n→ Decision: 是否 n == 0 或 m == 0? // 判斷邊界\n    Yes → Step 6: 輸出 0 // 無子女或無餅乾\n    No  → Step 7: 設定 i = 0, j = 0, count = 0 // 初始化指標\n→ Decision: while i < n 且 j < m? // 主循環\n    Yes → Decision: 如果 s[j] >= g[i]? // 是否能滿足\n        Yes → Step 8: count = count + 1 // 兒童滿足\n        Yes → Step 9: i = i + 1 // 移至下一個子女\n        Yes → Step 10: j = j + 1 // 使用此餅乾\n        No  → Step 11: j = j + 1 // 餅乾太小，嘗試下一個\n    No → Step 12: 輸出 count // 所有餅乾或子女已處理完畢\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef find_content_children(g, s):\n    \"\"\"Greedy algorithm: sort both lists and assign the smallest possible cookie.\"\"\"\n    g.sort()\n    s.sort()\n    i = j = 0\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1          # child i is satisfied\n        j += 1              # move to next cookie\n    return i                # number of satisfied children\n\ndef parse_input(text):\n    \"\"\"Parse input of the form 'g = [1,2,3], s = [1,1]'.\"\"\"\n    # Extract all bracketed lists\n    parts = re.findall(r'\\[([^\\]]*)\\]', text)\n    if len(parts) < 2:\n        return [], []  # fallback if format is unexpected\n    g = [int(x.strip()) for x in parts[0].split(',') if x.strip()]\n    s = [int(x.strip()) for x in parts[1].split(',') if x.strip()]\n    return g, s\n\ndef main():\n    data = sys.stdin.read().strip()\n    g, s = parse_input(data)\n    result = find_content_children(g, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "g = [1,2], s = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode155.json",
    "problem_index_in_file": 0,
    "title": "Min Stack",
    "description_snippet": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nI...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. No actual code. Use arrow and decision etc. The logic: implement MinStack using two stacks: main stack and min stack. Each operation O(1). Provide step-by-step algorithm. We'll produce steps like:\n\nStart\n→ Step 1: Initialize mainStack, minStack as empty stacks\n...\n\nWe need to cover each method: push, pop, top, getMin. Probably show how push updates minStack if val <= current min. Pop also pops from minStack if popped value equals current min.\n\nProvide pseudo-code: Each method has steps. Let's produce structure.\n\nWe need to output in Chinese traditional.\n\nLet's produce:\n\nStart\n→ Step 1: 創建兩個空棧 mainStack, minStack // 用來存儲數值和最小值\n→ Step 2: 定義 push(val) // 推入元素\n    → Step 2.1: mainStack.Push(val) // 將 val 推入主棧\n    → Decision: 若 minStack.Empty 或 val <= minStack.Peek() ?\n        Yes → Step 2.2: minStack.Push(val) // 若 val 為新最小值，推入 minStack\n        No  → Step 2.3: // 不需要推入 minStack\n→ Step 3: 定義 pop() // 移除頂部元素\n    → Step 3.1: 若 mainStack.Empty → Return // 为空則返回\n    → Step 3.2: val = mainStack.Pop() // 移除主棧頂元素\n    → Decision: 若 val == minStack.Peek() ?\n        Yes → Step 3.3: minStack.Pop() // 同時移除 minStack 的頂部\n        No  → Step 3.4: // 不做操作\n→ Step 4: 定義 top() // 取得頂部元素\n    → Step 4.1: 若 mainStack.Empty → Return error // 或 null\n    → Step 4.2: Return mainStack.Peek() // 返回主棧頂元素\n→ Step 5: 定義 getMin() // 取得最小值\n    → Step 5.1: 若 minStack.Empty → Return error\n    → Step 5.2: Return minStack.Peek() // 返回 minStack 的頂部，即最小值\nEnd\n\nBut we need to output each line with arrow and explanation. Use \"→\" arrow. We need to use \"Decision:\" lines for condition.\n\nLet's craft each line carefully.\n\nWe should avoid actual code but show steps.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 創建空棧 mainStack // 主棧儲存所有元素\n→ Step 2: 創建空棧 minStack // minStack 儲存目前最小值\n→ Step 3: 定義方法 push(val) // 將元素加入堆疊\n    → Step 3.1: mainStack.Push(val) // 把 val 推到主棧頂\n    → Decision: 若 minStack.Empty 或 val <= minStack.Peek() ?\n        Yes → Step 3.2: minStack.Push(val) // val 為新最小值，亦推入 minStack\n        No  → Step 3.3: // 無需更新 minStack\n→ Step 4: 定義方法 pop() // 移除堆疊頂部元素\n    → Step 4.1: 若 mainStack.Empty → Return // 空堆疊直接返回\n    → Step 4.2: val = mainStack.Pop() // 取出主棧頂元素\n    → Decision: 若 val == minStack.Peek() ?\n        Yes → Step 4.3: minStack.Pop() // 同時移除 minStack 的頂部\n        No  → Step 4.4: // 不做任何操作\n→ Step 5: 定義方法 top() // 取得堆疊頂部元素\n    → Step 5.1: 若 mainStack.Empty → Return error // 例外處理\n    → Step 5.2: Return mainStack.Peek() // 回傳主棧頂元素\n→ Step 6: 定義方法 getMin() // 取得目前最小值\n    → Step 6.1: 若 minStack.Empty → Return error // 例外處理\n    → Step 6.2: Return minStack.Peek() // 回傳 minStack 頂部，即最小值\nEnd // 程式結束\n\nBut we need each line to include \"虛擬碼步驟 [space] // 解釋\". Also include indentation for steps inside methods? Possibly we keep each line as separate step. But we must use arrows for nested lines. The example shows indentation for nested lines with arrow and Decision. So we can mimic.\n\nLet's produce final output with lines.\n\nWe need to ensure we use \"Decision:\" lines correctly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 創建空棧 mainStack // 主棧儲存所有進入的元素  \n→ Step 2: 創建空棧 minStack // minStack 儲存目前的最小值  \n\n→ Step 3: 定義方法 push(val) // 將元素加入堆疊  \n    → Step 3.1: mainStack.Push(val) // 把 val 推到主棧頂  \n    → Decision: 若 minStack.Empty 或 val <= minStack.Peek() ? // 檢查是否需要更新最小值  \n        Yes → Step 3.2: minStack.Push(val) // val 為新最小值，同時推入 minStack  \n        No  → Step 3.3: // 無需更新 minStack  \n\n→ Step 4: 定義方法 pop() // 移除堆疊頂部元素  \n    → Step 4.1: 若 mainStack.Empty → Return // 空堆疊直接返回，無操作  \n    → Step 4.2: val = mainStack.Pop() // 取出主棧頂元素  \n    → Decision: 若 val == minStack.Peek() ? // 若被彈出的元素是最小值  \n        Yes → Step 4.3: minStack.Pop() // 同時從 minStack 移除最小值  \n        No  → Step 4.4: // 不做任何操作  \n\n→ Step 5: 定義方法 top() // 取得堆疊頂部元素  \n    → Step 5.1: 若 mainStack.Empty → Return error // 當主棧為空時報錯或返回特殊值  \n    → Step 5.2: Return mainStack.Peek() // 回傳主棧頂元素  \n\n→ Step 6: 定義方法 getMin() // 取得目前最小值  \n    → Step 6.1: 若 minStack.Empty → Return error // 當 minStack 為空時報錯或返回特殊值  \n    → Step 6.2: Return minStack.Peek() // 回傳 minStack 頂部，即最小值  \n\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        if self.stack:\n            val = self.stack.pop()\n            if self.min_stack and val == self.min_stack[-1]:\n                self.min_stack.pop()\n\n    def top(self):\n        if self.stack:\n            return self.stack[-1]\n\n    def getMin(self):\n        if self.min_stack:\n            return self.min_stack[-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包裝成列表，方便使用 ast.literal_eval 解析\n    ops_args = ast.literal_eval(f'[{data}]')\n    ops, args = ops_args[0], ops_args[1]\n\n    stack = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack = MinStack()\n            outputs.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            outputs.append(None)\n        elif op == \"pop\":\n            stack.pop()\n            outputs.append(None)\n        elif op == \"top\":\n            outputs.append(stack.top())\n        elif op == \"getMin\":\n            outputs.append(stack.getMin())\n\n    # 將 None 轉成 'null'，其他值保持原樣\n    out_str = '[' + ','.join('null' if v is None else str(v) for v in outputs) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "success": true,
          "output": "[null,null,null,null,-3,null,0,-2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode12.json",
    "problem_index_in_file": 0,
    "title": "Integer to Roman",
    "description_snippet": "Seven different symbols represent Roman numerals with the following values:\n\nSymbol\tValue\nI\t1\nV\t5\nX\t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for converting integer to Roman numeral following the described rules. Provide step-by-step pseudo-code lines with explanation, using arrows and structure. Must use the format: each line: \"虛擬碼步驟 // 解釋/說明\". Must be line by line.\n\nWe need to create algorithm: input integer n. Prepare arrays of values and symbols: 1000 M, 900 CM, 500 D, 400 CD, 100 C, 90 XC, 50 L, 40 XL, 10 X, 9 IX, 5 V, 4 IV, 1 I. Loop through arrays, append symbol while n >= value, subtract value.\n\nBut the description emphasises decimal place conversion, subtractive forms. But standard algorithm uses value array. Provide steps accordingly.\n\nAlso mention special rules: only I, X, C, M can be repeated at most 3 times. But algorithm inherently ensures this.\n\nLet's produce virtual code lines.\n\nWe need Start and End.\n\nWe'll define: Input n // assume positive integer between 1 and 3999.\n\nDefine arrays:\n\nvalues = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\nsymbols = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\n\nInitialize result = \"\"\n\nFor i from 0 to length(values)-1:\n    While n >= values[i]:\n        result += symbols[i]\n        n -= values[i]\n\nReturn result.\n\nAdd explanation.\n\nAlso mention that the subtractive forms are included.\n\nLet's produce step lines.\n\nEnsure arrows: \"→\" preceding lines for actions.\n\nUse indentation for decisions. But we don't have explicit decisions? We can incorporate Decision: while loop condition.\n\nWe can use \"Decision: n >= values[i]?\" etc.\n\nOk, produce.\n\nLet's generate code lines:\n\nStart // program start\n\n→ Step 1: 輸入整數 n // 取得需要轉換的數字\n\n→ Step 2: 定義數值陣列 values = [1000,900,500,400,100,90,50,40,10,9,5,4,1] // 包含可用的數值對\n\n→ Step 3: 定義符號陣列 symbols = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"] // 對應數值的羅馬字\n\n→ Step 4: 初始化 result = \"\" // 用於累積羅馬字\n\n→ Step 5: 初始化 index = 0 // 迴圈索引\n\n→ Decision: index < values.length? // 判斷是否還有可用的數值\n\n    Yes → Step 6: Decision: n >= values[index]? // 判斷當前數值能否被用來減去\n\n        Yes → Step 7: result += symbols[index] // 加入符號到結果\n\n        Yes → Step 8: n -= values[index] // 從數字中減去對應的數值\n\n        Yes → Step 9: 回到 Step 6 // 重新檢查是否還能再次使用同一個符號\n\n        No → Step 10: index += 1 // 移到下一個較小的數值\n\n        No → Step 11: 回到 Step 5 // 重新檢查下一個數值\n\n    No → Step 12: End // 迴圈結束，所有數值已處理\n\n→ Step 13: 輸出 result // 最終羅馬數字\n\nEnd // 程式結束\n\nBut we must ensure lines have '→' arrow. For Step lines, we can just prefix '→'.\n\nFor Decision lines we use \"Decision:\".\n\nLet's format each line accordingly.\n\nWe might need indentation for nested decisions. Use spaces.\n\nLet's produce final output.\n\nEnsure each line ends with // explanation. Provide explanation in Chinese.\n\nWe need to keep the arrow characters '→' for steps. For decisions, we need 'Decision:' line with indentation.\n\nLet's produce.\n\nMake sure each line ends with comment.\n\nAlso 'Start' and 'End' lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得需要轉換的數字  \n→ Step 2: 定義數值陣列 values = [1000,900,500,400,100,90,50,40,10,9,5,4,1] // 可用的數值對  \n→ Step 3: 定義符號陣列 symbols = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"] // 對應數值的羅馬字  \n→ Step 4: 初始化 result = \"\" // 用於累積羅馬字  \n→ Step 5: 初始化 index = 0 // 迴圈索引  \n→ Decision: index < values.length? // 判斷是否還有可用的數值  \n  Yes → Step 6: Decision: n >= values[index]? // 判斷當前數值能否被用來減去  \n   Yes → Step 7: result += symbols[index] // 加入符號到結果  \n   Yes → Step 8: n -= values[index] // 從數字中減去對應的數值  \n   Yes → Step 9: 回到 Step 6 // 重新檢查是否還能再次使用同一個符號  \n   No → Step 10: index += 1 // 移到下一個較小的數值  \n   No → Step 11: 回到 Step 5 // 重新檢查下一個數值  \n  No → Step 12: End // 迴圈結束，所有數值已處理  \n→ Step 13: 輸出 result // 最終羅馬數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"\n        將整數轉換為羅馬數字。\n\n        先建立能直接對應的數值與符號對，然後逐一從大到小\n        對整數做除法，取得每一個符號要出現的次數，再累加到結果。\n        \"\"\"\n        val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        syms = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n        roman_parts = []\n\n        for v, s in zip(val, syms):\n            count, num = divmod(num, v)      # count 為符號 s 要重複的次數\n            if count:\n                roman_parts.append(s * count)\n\n        return ''.join(roman_parts)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，尋找第一個出現的整數\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        sys.exit(0)                     # 無數字則直接結束\n\n    num = int(match.group())\n    solver = Solution()\n    print(solver.intToRoman(num))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 3749",
          "expected_output": "\"MMMDCCXLIX\"",
          "success": true,
          "output": "MMMDCCXLIX"
        },
        {
          "example_index": 1,
          "input": "num = 58",
          "expected_output": "\"LVIII\"",
          "success": true,
          "output": "LVIII"
        },
        {
          "example_index": 2,
          "input": "num = 1994",
          "expected_output": "\"MCMXCIV\"",
          "success": true,
          "output": "MCMXCIV"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode165.json",
    "problem_index_in_file": 0,
    "title": "Compare Version Numbers",
    "description_snippet": "Given two version strings, version1 and version2, compare them. A version string consists of revisio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line with explanations. Use Start, End, Decision, arrows. No actual code. Provide steps: split strings, iterate, compare numeric conversions. Edge: different lengths. Use indices.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將 version1 用 '.' 分割成陣列 rev1 // 取得每個修訂版\n→ Step 2: 將 version2 用 '.' 分割成陣列 rev2 // 取得每個修訂版\n→ Step 3: 設定 maxLen 為 rev1.length 與 rev2.length 中較大者 // 確定比較範圍\n→ Step 4: 初始化 index = 0 // 設定迴圈起始索引\n→ Decision: index < maxLen? // 檢查是否還有修訂版需要比較\n    Yes → Step 5: 取得 rev1[index] 若不存在則用 '0' 作為預設值 // 取得版號或缺省0\n        → Step 6: 取得 rev2[index] 若不存在則用 '0' 作為預設值 // 同上\n        → Step 7: 將 rev1[index] 與 rev2[index] 轉為整數 val1, val2 // 解析為數值\n        → Decision: val1 < val2? // 比較兩個版號\n            Yes → Step 8: 回傳 -1 // version1 小於 version2\n            No  → Decision: val1 > val2? // 比較大小\n                Yes → Step 9: 回傳 1 // version1 大於 version2\n                No  → Step 10: index = index + 1 // 兩版號相等，繼續下一個\n    No  → Step 11: 回傳 0 // 所有版號已比較完且相等\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        \"\"\"比對兩個版本字串，回傳 -1 / 0 / 1。\"\"\"\n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        n, m = len(v1), len(v2)\n        for i in range(max(n, m)):\n            num1 = v1[i] if i < n else 0\n            num2 = v2[i] if i < m else 0\n            if num1 < num2:\n                return -1\n            elif num1 > num2:\n                return 1\n        return 0\n\ndef parse_input() -> tuple[str, str]:\n    \"\"\"從 stdin 解析出兩個版本字串。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return \"\", \"\"\n\n    # 先嘗試抓取所有雙引號內的內容\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n\n    lines = data.splitlines()\n    # 若輸入有兩行，直接取兩行\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n\n    # 其餘情況以空白分隔\n    parts = data.split()\n    return parts[0] if parts else \"\", parts[1] if len(parts) > 1 else \"\"\n\nif __name__ == \"__main__\":\n    v1, v2 = parse_input()\n    sol = Solution()\n    result = sol.compareVersion(v1, v2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "version1 = \"1.2\", version2 = \"1.10\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "version1 = \"1.0\", version2 = \"1.0.0.0\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode692.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Words",
    "description_snippet": "Given an array of strings words and an integer k, return the k most frequent strings.\n\nReturn the an...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the described algorithm. The problem: Given array words and integer k, return k most frequent strings sorted by frequency descending, ties lexicographical ascending. Virtual code step-by-step.\n\nWe output lines like:\n\nStart // ...\n\n→ Step 1: Count frequencies // create hashmap\n\n→ Step 2: Build list of word-frequency pairs\n\n→ Step 3: Sort pairs by freq desc, lex asc\n\n→ Step 4: Extract first k words\n\n→ Step 5: Return list\n\nEnd // done\n\nWe need to show decision steps? Not necessary. Use arrows. Provide explanation after each line.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nFollow example style.\n\nLet's produce lines.\n\nWe might include more detailed steps: e.g., Step 1: Initialize hash map freqMap // to count.\n\nStep 2: For each word in words: increment count // counting.\n\nStep 3: Convert freqMap entries to list of pairs // list of (word, freq)\n\nStep 4: Sort list with custom comparator // frequency descending, then word ascending\n\nStep 5: Initialize result list // to hold k words\n\nStep 6: For i from 0 to min(k, list size)-1: add list[i].word to result // picking top k\n\nStep 7: Return result\n\nEnd.\n\nAlso we could show the sorting logic with Decision arrow? But simple.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率雜湊表 freqMap // 用於儲存每個字串的出現次數  \n→ Step 2: 遍歷 words 並遞增 freqMap[word] // 統計各字串頻率  \n→ Step 3: 將 freqMap 轉換為列表 pairs 其中每項為 (word, freq) // 方便排序  \n→ Step 4: 排序 pairs，先依 freq 降序，若頻率相同則依 word 正序 // 確定最常見字串順序  \n→ Step 5: 建立結果列表 result // 用於儲存前 k 個字串  \n→ Step 6: 取 pairs 前 k 項並將 word 加入 result // 選出最頻繁的 k 個字串  \n→ Step 7: 回傳 result // 輸出最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nimport json\nfrom collections import Counter\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 用正則表達式提取 words 列表和 k 整數\n    match = re.search(r'words\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if not match:\n        return\n\n    words_str, k_str = match.group(1), match.group(2)\n    words = ast.literal_eval(words_str)   # 解析字串成 Python list\n    k = int(k_str)\n\n    # 統計頻率\n    counter = Counter(words)\n\n    # 先按頻率降序，再按字典序升序排序\n    sorted_items = sorted(counter.items(), key=lambda x: (-x[1], x[0]))\n\n    # 取前 k 個字串\n    result = [word for word, _ in sorted_items[:k]]\n\n    # 以 JSON 格式輸出，符合範例要求的雙引號\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "success": true,
          "output": "[\"i\", \"love\"]"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "success": true,
          "output": "[\"the\", \"is\", \"sunny\", \"day\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode728.json",
    "problem_index_in_file": 0,
    "title": "Self Dividing Numbers",
    "description_snippet": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. The problem: find self-dividing numbers between left and right inclusive. We produce algorithm: iterate number from left to right, check digits. If digit 0 -> skip. Else if number % digit !=0 -> skip. If all digits pass -> add to result. Return list.\n\nWe need to output as described. Use Start, End, Decision, Step, etc. So we produce pseudocode: Start, Step 1: initialize result list, Step 2: loop current from left to right, Step 3: check digits: maybe separate Decision: hasZero? Decision: not divisible? etc. We'll include decisions with Yes/No.\n\nLet's craft step lines.\n\nWe must not output actual code. Just virtual steps. Use arrows: → Step, Decision.\n\nLet's produce.\n\nProbably:\n\nStart // 程式開始執行\n→ Step 1: result ← [] // 初始化空清單\n→ Step 2: current ← left // 設定起始數字\n→ Decision: current > right? // 檢查是否已越過右端\n    Yes → End // 範圍內已無數字，結束\n    No  → Step 3: temp ← current // 复制当前数用于拆分\n→ Step 4: hasZero ← False // 标记是否包含0\n→ Step 5: isDivisible ← True // 标记是否能被所有数字整除\n→ Decision: temp == 0? // 处理数值为0的情况（不算自除数）\n    Yes → Step 6: current ← current + 1 // 跳过此数\n    No  → Decision: temp % 10 == 0? // 检查个位数字是否为0\n        Yes → Step 7: hasZero ← True // 标记包含0\n        No  → Step 8: digit ← temp % 10 // 取个位数字\n→ Decision: hasZero? // 若包含0，则不是自除数\n    Yes → Step 9: current ← current + 1 // 跳过\n    No  → Decision: current % digit == 0? // 检查能否被该位整除\n        Yes → Step 10: temp ← temp / 10 // 去掉已检查的位\n        No  → Step 11: isDivisible ← False // 标记不符合\n        No  → Step 12: current ← current + 1 // 跳过\n        Yes → Step 13: temp ≠ 0? // 继续检查剩余位\n            Yes → back to Step 8\n            No  → Step 14: isDivisible ← True // 所有位都能整除\n→ Decision: isDivisible? // 如果满足自除数条件\n    Yes → Step 15: result.append(current) // 加入结果\n    No  → // 不做操作\n→ Step 16: current ← current + 1 // 进入下一数\n→ Decision: current <= right? // 继续循环\n    Yes → go to Step 2\n    No  → End // 完成\n\nBut we need more compact, maybe restructure.\n\nBetter: For each number, set temp=current, loop while temp>0: digit=temp%10; if digit==0 or current%digit!=0 then flag false break; temp//=10. After loop if flag true add to result. Then increment current.\n\nLet's produce virtual steps accordingly.\n\nOk.\n\nNow produce final answer. Use arrows and explanations.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: result ← [] // 建立空的自除數清單\n→ Step 2: current ← left // 設定第一個要檢查的數字\n→ Decision: current > right? // 已超過右邊界\n    Yes → End // 無更多數字，結束程式\n    No  → Step 3: temp ← current // 以 temp 進行拆分與判斷\n→ Step 4: isSelf ← True // 初始假設為自除數\n→ Step 5: hasZero ← False // 標記是否包含 0\n→ Decision: temp == 0? // 數字為 0 時直接跳過\n    Yes → Step 6: current ← current + 1 // 進到下一個數字\n    No  → // 進入下一階段判斷\n→ Decision: temp % 10 == 0? // 第一位數是 0 時\n    Yes → hasZero ← True // 標記有 0\n    No  → // 進行除法判斷\n→ Decision: hasZero? // 若有 0，非自除數\n    Yes → Step 7: current ← current + 1 // 跳過此數\n    No  → // 進入除法循環\n→ Step 8: digit ← temp % 10 // 取得最低位數字\n→ Decision: current % digit == 0? // 檢查能否被此位整除\n    Yes → Step 9: temp ← temp / 10 // 去除已檢查的位\n    No  → isSelf ← False // 無法整除，非自除數\n        No  → // 結束除法循環\n→ Decision: temp > 0? // 還有剩餘位需要檢查\n    Yes → go back to Step 8 // 重新檢查下一位\n    No  → // 已檢查完所有位\n→ Decision: isSelf? // 判斷是否為自除數\n    Yes → Step 10: result.append(current) // 加入結果清單\n    No  → // 不做任何操作\n→ Step 11: current ← current + 1 // 移動到下一個數字\n→ Decision: current <= right? // 是否還有數字需要檢查\n    Yes → go back to Step 3 // 重新開始檢查下一個數\n    No  → End // 所有數字已檢查完畢，結束程式\nEnd // 程式執行結束，結果已存於 result\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> list[int]:\n        res = []\n        for num in range(left, right + 1):\n            temp = num\n            divisible = True\n            while temp > 0:\n                digit = temp % 10\n                if digit == 0 or num % digit != 0:\n                    divisible = False\n                    break\n                temp //= 10\n            if divisible:\n                res.append(num)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入並擷取數字\n    raw_input = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', raw_input)))\n    if len(numbers) >= 2:\n        left, right = numbers[0], numbers[1]\n        result = Solution().selfDividingNumbers(left, right)\n        print(result)\n    else:\n        # 若輸入格式不符，直接輸出空列表\n        print([])",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 1, right = 22",
          "expected_output": "[1,2,3,4,5,6,7,8,9,11,12,15,22]",
          "success": true,
          "output": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"
        },
        {
          "example_index": 1,
          "input": "left = 47, right = 85",
          "expected_output": "[48,55,66,77]",
          "success": true,
          "output": "[48, 55, 66, 77]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1296.json",
    "problem_index_in_file": 0,
    "title": "Divide Array in Sets of K Consecutive Numbers",
    "description_snippet": "Given an array of integers nums and a positive integer k, check whether it is possible to divide thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: given array nums and positive k, check if can divide into sets of k consecutive numbers. Classic LeetCode 846. Approach: count frequencies, sort keys, iterate over sorted keys, for each value v, if count[v] >0, we need to take count[v] groups starting at v covering v, v+1,... v+k-1. For each i from v to v+k-1, reduce count[i] by count[v], if any count negative, return false. At end return true.\n\nWe need to output line-by-line pseudocode with comments. Use Start, End, Decision, Yes →, No → etc.\n\nWe should handle input, count map, sort keys, loop. Use dictionary. Use variables. Use pseudocode language.\n\nLet's craft steps:\n\nStart\n→ Step 1: 初始化頻率表 count ← 空字典 // 用於計算每個數字出現次數\n→ Step 2: 對 nums 中每個 num: count[num] ← count.get(num,0)+1 // 進行計數\n→ Step 3: 將 count 的鍵排序得到 sorted_keys ← 排序(count.keys()) // 依序處理\n\n→ Decision: 如果 count 中任一鍵的值不等於 0? Actually we need loop over sorted_keys\nWe can structure as: For each key in sorted_keys do.\n\nSo:\n→ Step 4: 循環每個 num 在 sorted_keys 中\n    → Decision: 如果 count[num] == 0? // 已經被消耗，跳過\n        Yes → 继续 // Next key\n        No  → \n            → Step 5: 取 group_count ← count[num] // 需要的組數\n            → Step 6: 對 i 從 num 到 num+k-1 做\n                → Decision: 如果 count.get(i,0) < group_count? // 沒有足夠數量\n                    Yes → Step 7: 返回 false // 不可分組\n                    No  → \n                        → Step 8: count[i] ← count[i] - group_count // 消耗\n            // 結束內部循環\n→ End // 如果所有檢查通過，返回 true\n\nBut we need to use Yes →, No → arrows within decision. Use End at last.\n\nLet's produce line by line:\n\nStart // 程式開始執行\n→ Step 1: count ← {} // 建立頻率表\n→ Step 2: 對每個 num in nums: count[num] ← count.get(num, 0) + 1 // 計算每個數字出現次數\n→ Step 3: sorted_keys ← Sort(count.keys()) // 依升序排序所有鍵\n→ Step 4: 循環 num 在 sorted_keys 中\n    → Decision: 如果 count[num] == 0? // 若已被消耗，跳過\n        Yes → // 下一個 key\n        No  → \n            → Step 5: group_count ← count[num] // 需要的組數\n            → Step 6: 循環 i 在 [num, num+k-1] 內\n                → Decision: 如果 count.get(i, 0) < group_count? // 數量不足\n                    Yes → Step 7: 返回 false // 無法完成分組\n                    No  → \n                        → Step 8: count[i] ← count[i] - group_count // 消耗\n    // 結束 num 的循環\n→ End // 所有檢查通過，返回 true\n\nBut we need to include explicit return statements. At Step 7 we return false, at the end return true.\n\nLet's produce as lines.\n\nWe also may need to mention return true at the end.\n\nMake sure to use \"→\" at start of each step. Use indentation as shown in example.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: count ← {} // 初始化頻率表  \n→ Step 2: 對每個 num in nums: count[num] ← count.get(num, 0) + 1 // 統計每個數字的出現次數  \n→ Step 3: sorted_keys ← Sort(count.keys()) // 把所有鍵按升序排序  \n\n→ Step 4: 循環 num 在 sorted_keys 中  \n    → Decision: 如果 count[num] == 0? // 若已被消耗，直接跳過  \n        Yes → // 下一個鍵  \n        No  →  \n            → Step 5: group_count ← count[num] // 需要從 num 開始的組數  \n            → Step 6: 循環 i 在 [num, num + k - 1]  \n                → Decision: 如果 count.get(i, 0) < group_count? // 檢查是否足夠  \n                    Yes → Step 7: 返回 false // 無法完成分組，直接結束  \n                    No  →  \n                        → Step 8: count[i] ← count[i] - group_count // 消耗相應數量  \n\n→ End // 所有檢查都通過，返回 true",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef is_possible_divide(nums, k):\n    if len(nums) % k != 0:\n        return False\n    count = Counter(nums)\n    for num in sorted(count):\n        if count[num] > 0:\n            need = count[num]\n            for i in range(num, num + k):\n                if count.get(i, 0) < need:\n                    return False\n                count[i] -= need\n    return True\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，假設格式為 \"nums = [...], k = ...\"\n    parts = [p.strip() for p in data.split(',')]\n    nums = []\n    k = 0\n    for part in parts:\n        if part.startswith('nums'):\n            # 取得方括號中的列表字串\n            start = part.find('[')\n            end = part.rfind(']')\n            nums_str = part[start:end+1]\n            nums = ast.literal_eval(nums_str)\n        elif part.startswith('k'):\n            _, value = part.split('=', 1)\n            k = int(value.strip())\n\n    result = is_possible_divide(nums, k)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,3,4,4,5,6], k = 4",
          "expected_output": "true",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpk7ck7bwv.py\", line 34, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 0\n    \nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3",
          "expected_output": "true",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpkduzvl9u.py\", line 34, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 0\n    \nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpa6h6b7qr.py\", line 34, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 0\n    \nSyntaxError: invalid syntax"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode238.json",
    "problem_index_in_file": 0,
    "title": "Product of Array Except Self",
    "description_snippet": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm: given array nums, return array answer such that answer[i] = product of all elements except nums[i], O(n), no division. The typical algorithm: compute left products and right products.\n\nSteps:\n- Input: array nums length n.\n- Create answer array length n, fill with 1.\n- Compute left product: for i from 1 to n-1, answer[i] = answer[i-1] * nums[i-1].\n- Compute right product: right = 1; for i from n-1 downto 0, answer[i] = answer[i] * right; right = right * nums[i].\n- Return answer.\n\nWe need to output as virtual code with line-by-line steps and explanations. Format: each line has virtual code step + space + // explanation. Use arrow etc.\n\nLet's produce:\n\nStart\n→ Step 1: Input array nums // Get the input array\n→ Step 2: Let n = length of nums // Determine array length\n→ Step 3: Initialize answer array of size n, all 1s // Prepare output array\n→ Decision: Is n > 1? // Edge case check\n    Yes → Step 4: For i = 1 to n-1 do\n        → answer[i] = answer[i-1] * nums[i-1] // Left cumulative product\n    No  → (skip)\n→ Step 5: right = 1 // Right side accumulator\n→ Decision: For i = n-1 down to 0 do\n    Yes → \n        → answer[i] = answer[i] * right // Multiply by right product\n        → right = right * nums[i] // Update right product\n    No  → (end loop)\n→ End // Return answer\n\nWe need to adhere to format: lines with arrows etc. Use Start, End. Use Decision lines. Ensure each line has virtual code step and explanation.\n\nWe need to incorporate the two loops. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: Input array nums // 取得輸入陣列\n→ Step 2: n ← length(nums) // 計算陣列長度\n→ Step 3: answer ← array of size n, all 1s // 初始化答案陣列\n→ Decision: n > 1? // 判斷是否需要進行左乘計算\n    Yes → Step 4: for i = 1 to n-1 do\n        → answer[i] ← answer[i-1] * nums[i-1] // 以左邊累積乘積填充答案\n    No  → (無需執行左乘)\n→ Step 5: right ← 1 // 右邊累積乘積初始值\n→ Decision: for i = n-1 down to 0 do\n    Yes → \n        → answer[i] ← answer[i] * right // 乘以右邊累積乘積\n        → right ← right * nums[i] // 更新右邊累積乘積\n    No  → (結束循環)\n→ End // 程式執行結束\n\nWe must not use actual code, just virtual. Also use arrow arrows like → Step 1 etc.\n\nMake sure each line has the virtual code step and explanation separated by space then //.\n\nWe need to keep consistent arrow usage: \"→\" before each step. Decision lines with indentation. Provide no actual code. Use Chinese explanations.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 取得輸入陣列  \n→ Step 2: n ← length(nums) // 取得陣列長度  \n→ Step 3: answer ← array of size n, all 1s // 初始化答案陣列為 1  \n→ Decision: n > 1? // 判斷是否需要進行左乘計算  \n  Yes → Step 4: for i = 1 to n-1 do  \n    → answer[i] ← answer[i-1] * nums[i-1] // 左邊累積乘積填充答案  \n  No  → (無需執行左乘)  \n→ Step 5: right ← 1 // 右邊累積乘積初始值  \n→ Decision: for i = n-1 down to 0 do  \n  Yes →  \n    → answer[i] ← answer[i] * right // 乘以右邊累積乘積  \n    → right ← right * nums[i] // 更新右邊累積乘積  \n  No  → (結束循環)  \n→ End // 程式執行結束",
      "generated_code": "import sys, ast\n\ndef product_except_self(nums):\n    n = len(nums)\n    res = [1]*n\n    left = 1\n    for i in range(n):\n        res[i] = left\n        left *= nums[i]\n    right = 1\n    for i in range(n-1, -1, -1):\n        res[i] *= right\n        right *= nums[i]\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract list\n    if \"nums\" in data:\n        try:\n            _, expr = data.split('=', 1)\n            nums = ast.literal_eval(expr.strip())\n        except Exception:\n            nums = ast.literal_eval(data.strip())\n    else:\n        nums = ast.literal_eval(data.strip())\n    result = product_except_self(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "[24,12,8,6]",
          "success": true,
          "output": "[24, 12, 8, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,1,0,-3,3]",
          "expected_output": "[0,0,9,0,0]",
          "success": true,
          "output": "[0, 0, 9, 0, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode321.json",
    "problem_index_in_file": 0,
    "title": "Create Maximum Number",
    "description_snippet": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 re...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps to solve maximum number of length k from two arrays while preserving order relative within each array. Classic LeetCode 321. Steps: helper to select max subsequence of length l from one array using stack; merge two subseqs by comparing lexicographically; iterate over possible split of k: i from max(0,k-n) to min(k,m). For each i get subseq1 of length i from nums1, subseq2 of length k-i from nums2. Merge and keep best. Output best. Also tie-breaking lexicographically. Pseudocode with decisions, loops, stack. Let's produce step-by-step.\n\nWe must output each line with virtual code and comment. Use arrows. Ensure to use \"Start\", \"End\". Use loops. Use Decision. Provide concise explanation.\n\nLet's craft lines.\n\nWe'll write:\n\nStart // start\n→ Step 1: Define helper MaxSubsequence(array, subLen) → returns list // 1\nInside helper: use stack algorithm. Represent as substeps.\n\nBut we need line-by-line. We can break into multiple lines. Use indentation perhaps.\n\nWe can produce something like:\n\nStart // 程式開始執行\n→ Step 1: Define function MaxSubsequence(array, subLen) // 建立取得最大子序列的功能\n    → Step 1.1: Initialize empty stack // 用於保存選取的數字\n    → Step 1.2: remaining = array.length - subLen // 可丟棄的元素數\n    → Decision: For each num in array // 逐個遍歷\n        → Step 1.3: While stack not empty AND stack.last < num AND remaining > 0\n            → Step 1.4: Pop stack.last // 刪除較小數字以留位置\n            → Step 1.5: remaining -= 1\n        → Step 1.6: If stack.size < subLen\n            → Step 1.7: Push num onto stack // 選取此數字\n    → Step 1.8: Return stack // 最大子序列\n\nThen main:\n\n→ Step 2: best = empty array of length k // 儲存目前最佳結果\n→ Decision: For i from max(0, k - n) to min(k, m) // 嘗試各種分配\n    → Step 2.1: seq1 = MaxSubsequence(nums1, i) // 從 nums1 選 i 位\n    → Step 2.2: seq2 = MaxSubsequence(nums2, k - i) // 從 nums2 選剩餘位\n    → Step 2.3: candidate = Merge(seq1, seq2) // 合併兩個子序列\n    → Decision: If candidate > best // 比較兩組字串\n        → Step 2.4: best = candidate // 更新最佳\n→ Step 3: Return best // 回傳結果\n\nNeed Merge function:\n\n→ Step 3: Define function Merge(a, b) // 合併兩個序列\n    → Step 3.1: result = empty list\n    → Decision: While a not empty OR b not empty\n        → Decision: If a > b (lexicographically)\n            → Step 3.2: Append a[0] to result\n            → Step 3.3: Remove first element of a\n        → Else\n            → Step 3.4: Append b[0] to result\n            → Step 3.5: Remove first element of b\n    → Step 3.6: Return result\n\nBut we need to ensure merge compares subarrays correctly. Use lexicographic comparison function.\n\nWe'll also need a helper LexicographicCompare(a,b). But can be inline.\n\nWe can incorporate a helper function CompareSequences(seqA, seqB) that returns true if seqA is lexicographically greater than seqB.\n\nDefine CompareSequences:\n\n→ Step 4: Define function IsGreater(a, b) // 判斷 a 是否在字典序上大於 b\n    → Step 4.1: For idx from 0 to min(a.length,b.length)-1\n        → Decision: If a[idx] > b[idx]\n            → Step 4.2: Return true\n        → Decision: If a[idx] < b[idx]\n            → Step 4.3: Return false\n    → Step 4.4: Return a.length > b.length // 若前一部分相同，長度較長者較大\n\nNow merge uses IsGreater.\n\nBut we need to incorporate that into merge step lines.\n\nLet's produce final lines.\n\nWe need to keep each line with comment.\n\nWe'll output each line. Use arrows. Use indentation maybe but maintain line numbers.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 MaxSubsequence(array, subLen) → 取得長度為 subLen 的最大子序列 // 建立取得最大子序列的功能  \n  → Step 1.1: stack ← [] // 用於保存選取的數字  \n  → Step 1.2: remaining ← array.length - subLen // 可丟棄的元素數  \n  → Decision: 對 array 中每個 num 進行遍歷 // 逐個遍歷  \n    Yes → Step 1.3: 當 stack 非空且 stack.last < num 且 remaining > 0 時  \n      Yes → Step 1.4: pop stack.last // 刪除較小數字以留位置  \n      Yes → Step 1.5: remaining ← remaining - 1  \n    No → 進行下一步  \n    Yes → Step 1.6: 如果 stack.size < subLen  \n      Yes → Step 1.7: push num 到 stack // 選取此數字  \n  → Step 1.8: return stack // 返回最大子序列  \n\n→ Step 2: 定義函式 IsGreater(a, b) → 判斷 a 是否字典序大於 b // 用於序列比較  \n  → Step 2.1: n ← min(a.length, b.length)  \n  → Decision: 對 i 從 0 到 n-1 迭代  \n    Yes → If a[i] > b[i]  \n      Yes → return true  \n      No → If a[i] < b[i]  \n        Yes → return false  \n  → Step 2.2: return a.length > b.length // 前部分相同則長度較長者較大  \n\n→ Step 3: 定義函式 Merge(a, b) → 合併兩個序列為最大序列 // 使用字典序比較  \n  → Step 3.1: result ← []  \n  → Decision: 當 a 或 b 非空時  \n    Yes → Decision: 如果 IsGreater(a, b)  \n      Yes → Step 3.2: append a[0] 到 result  \n      Yes → Step 3.3: remove a[0]  \n      No → Step 3.4: append b[0] 到 result  \n      No → Step 3.5: remove b[0]  \n  → Step 3.6: return result // 返回合併後的序列  \n\n→ Step 4: best ← [] // 儲存目前最佳結果  \n→ Decision: 對 i 從 max(0, k - n) 到 min(k, m) 進行迭代 // 嘗試各種分配  \n  Yes → Step 4.1: seq1 ← MaxSubsequence(nums1, i) // 從 nums1 選 i 位  \n  Yes → Step 4.2: seq2 ← MaxSubsequence(nums2, k - i) // 從 nums2 選剩餘位  \n  Yes → Step 4.3: candidate ← Merge(seq1, seq2) // 合併兩個子序列  \n  Yes → Decision: 如果 IsGreater(candidate, best)  \n    Yes → Step 4.4: best ← candidate // 更新最佳  \n\n→ Step 5: return best // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxNumber(self, nums1, nums2, k):\n        # Helper to pick the maximum subsequence of length t from nums\n        def pick_max(nums, t):\n            drop = len(nums) - t\n            stack = []\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:t]\n\n        # Merge two subsequences into the maximum possible sequence\n        def merge(a, b):\n            res = []\n            while a or b:\n                if a > b:\n                    res.append(a.pop(0))\n                else:\n                    res.append(b.pop(0))\n            return res\n\n        best = []\n        # Iterate over possible split of k between nums1 and nums2\n        start = max(0, k - len(nums2))\n        end = min(k, len(nums1))\n        for i in range(start, end + 1):\n            a = pick_max(nums1, i)\n            b = pick_max(nums2, k - i)\n            candidate = merge(a[:], b[:])  # use copies to avoid modifying originals\n            if candidate > best:\n                best = candidate\n        return best\n\ndef main():\n    # Read the entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the two lists and the integer k using regular expressions\n    list_strings = re.findall(r'\\[([^\\]]*)\\]', data)\n    nums1 = [int(x.strip()) for x in list_strings[0].split(',')] if len(list_strings) > 0 else []\n    nums2 = [int(x.strip()) for x in list_strings[1].split(',')] if len(list_strings) > 1 else []\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    k = int(k_match.group(1)) if k_match else 0\n\n    solution = Solution()\n    result = solution.maxNumber(nums1, nums2, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5",
          "expected_output": "[9,8,6,5,3]",
          "success": true,
          "output": "[9, 8, 6, 5, 3]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [6,7], nums2 = [6,0,4], k = 5",
          "expected_output": "[6,7,6,0,4]",
          "success": true,
          "output": "[6, 7, 6, 0, 4]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [3,9], nums2 = [8,9], k = 3",
          "expected_output": "[9,8,9]",
          "success": true,
          "output": "[9, 8, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode343.json",
    "problem_index_in_file": 0,
    "title": "Integer Break",
    "description_snippet": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the pro...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: maximize product of splitting integer n into sum of k positive integers with k>=2. This is classic integer break problem: maximize product of at least two positive integers. Solution: break into 2s and 3s; greedy: use as many 3s as possible except when remainder is 1 then change one 3+1 to 2+2. For n<=4, special cases: return n-1. So produce virtual code line by line with explanations.\n\nWe need to follow format: Start, then arrow steps, decision nodes, etc.\n\nWe'll produce step lines with \"→ Step X:\" etc.\n\nWe'll include decision logic: if n<=4: return n-1.\n\nElse:\n\nproduct=1, count3= n/3. remainder= n%3.\n\nif remainder==0: product=3^count3\n\nif remainder==1: use one less 3: count3-1, product=3^(count3-1)*4\n\nif remainder==2: product=3^count3*2\n\nWe can use loops to compute product maybe using multiplication.\n\nVirtual code: Step 1: Input n // get integer\nDecision: if n <= 4? // handle small n\nYes → Step 2: Return n-1 // maximum product for small n\nNo → Step 3: Set count3 = n / 3 // integer division\n→ Step 4: Set remainder = n % 3 // remainder\n→ Decision: remainder == 0? // product all 3's\n    Yes → Step 5: product = 3^count3 // compute power\n    No → Decision: remainder == 1? // handle remainder 1\n        Yes → Step 6: count3 = count3 - 1 // reduce one 3\n            → Step 7: product = 3^count3 * 4 // replace 3+1 with 2+2\n        No  → Step 8: product = 3^count3 * 2 // remainder 2 multiply by 2\n→ Step 9: Return product // final answer\nEnd\n\nWe need to include explanatory comments. Also we may need to explain power calculation maybe loop.\n\nBut we can treat power as multiplication loop.\n\nWe need to be careful: each line must have virtual code step and comment. For decisions we must indent.\n\nUse format:\n\nStart // 程式開始執行\n→ Step 1: Input n // 從使用者處取得整數 n\n→ Decision: n <= 4? // 判斷是否為特例\n    Yes → Step 2: Return n-1 // 小數值直接回傳 n-1\n    No  → Step 3: Set count3 = n / 3 // 計算可使用的 3 的個數\n        → Step 4: Set remainder = n % 3 // 計算餘數\n        → Decision: remainder == 0? // 全部拆成 3\n            Yes → Step 5: product = 1\n                → For i=1 to count3: product = product * 3 // 乘以 3 count3 次\n                → Step 6: Return product\n            No → Decision: remainder == 1? // 餘數 1 的情況\n                Yes → Step 7: count3 = count3 - 1 // 取一個 3 來配合餘數\n                    → Step 8: product = 1\n                    → For i=1 to count3: product = product * 3\n                    → product = product * 4 // 3+1 變成 2+2\n                    → Step 9: Return product\n                No  → Step 10: product = 1\n                    → For i=1 to count3: product = product * 3\n                    → product = product * 2 // 餘數 2 直接乘 2\n                    → Step 11: Return product\nEnd // 程式執行結束\n\nBut we need each line with explanation after //.\n\nBetter to structure simpler: use a function to compute product via loop for power.\n\nWe need to keep each line separate.\n\nWe should avoid \"For i=1 to count3\" as a single line? We can treat loop as a step.\n\nBut the format requires each line to have a virtual code step; we can include loops as single steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Read n // 取得整數 n\n→ Decision: n <= 4? // 小數值的特殊處理\n    Yes → Step 2: Return n-1 // n=2,3,4 時最大積分別為 1,2,4\n    No  → Step 3: count3 = n / 3 // 取得能拆成 3 的數量\n        → Step 4: remainder = n % 3 // 取得剩餘值\n        → Decision: remainder == 0? // 全部以 3 分割\n            Yes → Step 5: product = 1\n                → For i = 1 to count3: product = product * 3 // 乘 3 count3 次\n                → Step 6: Return product // 回傳結果\n            No  → Decision: remainder == 1? // 殘餘 1 的情況\n                Yes → Step 7: count3 = count3 - 1 // 把一個 3 與 1 合併成 2+2\n                    → Step 8: product = 1\n                    → For i = 1 to count3: product = product * 3\n                    → product = product * 4 // 兩個 2 的乘積\n                    → Step 9: Return product\n                No  → Step 10: product = 1\n                    → For i = 1 to count3: product = product * 3\n                    → product = product * 2 // 直接乘 2\n                    → Step 11: Return product\nEnd // 程式執行結束\n\nWe should keep indentation. Also ensure each line includes comment.\n\nAlso maybe we need to use \"→\" arrow after decision? In example, decision lines have \"Decision:\" and then Yes → Step X: etc.\n\nWe can follow that.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Read n // 取得整數 n\n→ Decision: n <= 4? // 小數值的特殊處理\n    Yes → Step 2: Return n-1 // n=2,3,4 時最大積分別為 1,2,4\n    No  → Step 3: count3 = n / 3 // 取得能拆成 3 的數量\n        → Step 4: remainder = n % 3 // 取得剩餘值\n        → Decision: remainder == 0? // 全部以 3 分割\n            Yes → Step 5: product = 1\n                → For i = 1 to count3: product = product * 3 // 乘 3 count3 次\n                → Step 6: Return product // 回傳結果\n            No  → Decision: remainder == 1? // 殘餘 1 的情況\n                Yes → Step 7: count3 = count3 - 1 // 把一個 3 與 1 合併成 2+2\n                    → Step 8: product = 1\n                    → For i = 1 to count3: product = product * 3\n                    → product = product * 4 // 兩個 2 的乘積\n                    → Step 9: Return product\n                No  → Step 10: product = 1\n                    → For i = 1 to count3: product = product * 3\n                    → product = product * 2 // 直接乘 2\n                    → Step 11: Return product\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def integerBreak(self, n: int) -> int:\n        if n <= 4:\n            return n - 1\n        product = 1\n        while n > 4:\n            product *= 3\n            n -= 3\n        return product * n\n\ndef main() -> None:\n    data = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n    sol = Solution()\n    result = sol.integerBreak(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 10",
          "expected_output": "36",
          "success": true,
          "output": "36"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode438.json",
    "problem_index_in_file": 0,
    "title": "Find All Anagrams in a String",
    "description_snippet": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Approach: sliding window with frequency maps. Use arrays of size 26. Count differences. Steps: compute freq of p, initialize window count for first len(p)-1, then iterate i from 0 to len(s)-1, add s[i], check if window size equal len(p) then compare counts, if equal add start index i-len(p)+1. Then remove s[i-len(p)+1] after loop. Actually typical sliding window: maintain window [i-len(p)+1, i]. We'll keep start pointer. Steps: pre-calc pCount. For i from 0 to len(s)-1: add s[i] to windowCount; if i>=len(p)-1: compare counts; if equal, add i-len(p)+1 to result; remove s[i-len(p)+1] from windowCount. Then at end return result.\n\nLet's produce virtual code with lines. Use Decision etc. Should include loops.\n\nAlso include Start, End.\n\nLet's craft.\n\nPotential lines:\n\nStart\n→ Step 1: 初始化 pCount[26] = 0, windowCount[26] = 0, result = [] // 先建 26 元素陣列\n→ Step 2: 對 p 的每個字元，pCount[字元]++ // 計算 p 的頻率\n→ Step 3: 取得 s 的長度 n, p 的長度 m\n→ Step 4: 針對 i 從 0 到 n-1 進行迴圈 // 滑動窗口\n    → Step 5: windowCount[s[i]]++ // 加入新字元\n    → Decision: i >= m-1? // 窗口已達到 p 的長度\n        Yes →\n            → Step 6: Decision: windowCount 與 pCount 相等? // 比較兩個頻率表\n                Yes → Step 7: result.append(i-m+1) // 匹配成功，加入起始索引\n            No →\n            No →\n        No →\n    → Decision: i >= m-1? // 若已完成窗口長度，需移除最舊字元\n        Yes →\n            → Step 8: windowCount[s[i-m+1]]-- // 移除最舊字元\n        No →\n    → Step 9: 進行到下一個 i\n→ End // 回傳結果\n\nBut we need to ensure each line has one step and comments. The decision lines must show arrow. Also we need to show removal step only after checking equality, but typical sliding window removes before next iteration. We'll follow pattern: after checking equality, if i>=m-1, then decrement windowCount[s[i-m+1]]. That ensures window is ready for next i+1.\n\nAlso we need to return result at end. So final step: Step 10: return result.\n\nLet's produce.\n\nMake sure each line includes \"→\" at start, except maybe Start. Use \"→\" before each step except Start? In example, Start has no arrow. We'll mimic: Start, then each step with arrow. We'll use \"→\" before each step.\n\nAlso decisions with Yes→ etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 pCount[26] = 0, windowCount[26] = 0, result = [] // 建立 26 個元素的頻率表與結果陣列  \n→ Step 2: 對 p 的每個字元，pCount[字元]++ // 計算 p 的字元頻率  \n→ Step 3: 設定 n = len(s)，m = len(p) // 取得 s 與 p 的長度  \n→ Step 4: 進行 for i in 0..n-1 的迴圈 // 滑動窗口遍歷 s  \n  → Step 5: windowCount[s[i]]++ // 將當前字元加入窗口頻率表  \n  → Decision: i >= m-1? // 窗口已達到 p 的長度？  \n   Yes →  \n    → Decision: windowCount 與 pCount 相等? // 比較兩個頻率表是否相同  \n     Yes → Step 6: result.append(i-m+1) // 匹配成功，加入起始索引  \n     No →  // 不匹配，無需操作  \n    No →  // 仍在前 m-1 個字元，尚未形成完整窗口  \n  → Decision: i >= m-1? // 若已形成完整窗口，需移除最舊字元  \n   Yes → Step 7: windowCount[s[i-m+1]]-- // 從窗口中移除最舊字元  \n   No →  // 前 m-1 個字元，不需要移除  \n  → Step 8: 繼續到下一個 i // 完成本次迴圈的處理  \n→ Step 9: return result // 回傳所有找到的起始索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str):\n        ns, np = len(s), len(p)\n        if ns < np:\n            return []\n\n        # Frequency array for characters 'a' to 'z'\n        p_count = [0] * 26\n        window = [0] * 26\n        for ch in p:\n            p_count[ord(ch) - 97] += 1\n\n        result = []\n        for i in range(ns):\n            # Add new character to the window\n            window[ord(s[i]) - 97] += 1\n\n            # When window size reaches np, check for anagram\n            if i >= np - 1:\n                if window == p_count:\n                    result.append(i - np + 1)\n                # Remove the leftmost character from the window\n                window[ord(s[i - np + 1]) - 97] -= 1\n\n        return result\n\ndef parse_input(text: str):\n    \"\"\"\n    Parses input of the form: s = \"string\", p = \"string\"\n    Handles both double and single quotes.\n    \"\"\"\n    # Try double quotes first\n    pattern_double = r's\\s*=\\s*\"(?P<s>[^\"]*)\"\\s*,\\s*p\\s*=\\s*\"(?P<p>[^\"]*)\"'\n    match = re.search(pattern_double, text)\n    if match:\n        return match.group('s'), match.group('p')\n    # Try single quotes\n    pattern_single = r\"s\\s*=\\s*'(?P<s>[^']*)'\\s*,\\s*p\\s*=\\s*'(?P<p>[^']*)'\"\n    match = re.search(pattern_single, text)\n    if match:\n        return match.group('s'), match.group('p')\n    # Fallback: assume first word is s, second is p\n    parts = text.replace(',', ' ').split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, p = parse_input(raw_input)\n    sol = Solution()\n    ans = sol.findAnagrams(s, p)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"cbaebabacd\", p = \"abc\"",
          "expected_output": "[0,6]",
          "success": true,
          "output": "[0, 6]"
        },
        {
          "example_index": 1,
          "input": "s = \"abab\", p = \"ab\"",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode467.json",
    "problem_index_in_file": 0,
    "title": "Unique Substrings in Wraparound String",
    "description_snippet": "We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so b...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: count unique substrings of s that appear in infinite wraparound string base. Known problem: Leetcode 467. Approach: track longest continuous substring ending at each letter. For each char c in s, maintain current length of consecutive wraparound substring. For each character, update dp[c] = max(dp[c], currLen). Finally sum dp values. Explanation: base infinite string. Implementation details: wrap if prev char is previous alphabet cyclically.\n\nWe need step-by-step virtual code lines with explanations. Ensure use Start, End, Decision, Yes/No arrows. Use step numbers maybe but consistent. Provide each line: \"虛擬碼步驟 // 解釋\". Let's craft.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Initialize array dp[26] all zeros // 用於記錄每個字母結尾的最大連續長度\n\n→ Initialize prev = '' // 前一個字符\n\n→ Initialize curLen = 0 // 當前連續長度\n\n→ For each character ch in s: // 逐字符遍歷輸入字串\n\n    Decision: 是否為字母? // 若輸入非字母，直接跳過（但假設s只包含小寫字母）\n\n        Yes → // 繼續\n\n    Decision: 是否為 wraparound 連續? // 檢查 ch 是否是前一個字母的下一個（a after z也算）\n\n        Yes → curLen = curLen + 1 // 連續\n\n        No  → curLen = 1 // 重置為1\n\n    → Update index = ord(ch) - ord('a') // 將字母轉換為 0-25\n\n    → Update dp[index] = max(dp[index], curLen) // 更新最大長度\n\n    → prev = ch // 設定前一個字符\n\nEnd // 程式執行結束\n\n→ Compute result = sum(dp) // 總唯一子串數量\n\n→ Return result // 返回答案\n\nBut we need to output step by step in format: \"虛擬碼步驟 // 解釋\". Each line should start with maybe \"Start\" or \"→ Step\". We should produce arrow for steps. Use consistent format: \"Start // 程式開始執行\".\n\nThen \"→ 初始化dp[26]為0 // 用於存儲每個字母結尾的最大長度\". etc.\n\nWe must be careful with decision lines indentation: use \"Decision:\" and Yes/No arrows. Provide code lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 dp[26] 為 0 // 用於記錄每個字母結尾時可得到的最大連續長度  \n→ 初始化 prev 為空字元 // 用來比較前一個字符  \n→ 初始化 curLen 為 0 // 當前連續 wraparound 子串長度  \n→ 遍歷 s 中的每個字符 ch // 逐字符處理輸入字串  \n Decision: ch 是否為小寫字母? // 確保只處理有效字符  \n  Yes → // 繼續處理  \n Decision: ch 是否是 prev 的下個字母（包含 z→a）? // 判斷是否連續  \n  Yes → curLen = curLen + 1 // 連續，長度遞增  \n  No  → curLen = 1 // 非連續，重置長度為 1  \n → 索引 = ord(ch) - ord('a') // 把字母轉成 0-25  \n → dp[索引] = max(dp[索引], curLen) // 更新此字母結尾時的最大長度  \n → prev = ch // 更新前一個字符為當前字符  \nEnd // 程式遍歷結束  \n→ 計算 result = sum(dp) // 所有 dp 值之和即為唯一子串總數  \n→ 返回 result // 回傳最終答案",
      "generated_code": "import sys\nimport re\n\ndef find_substring_in_wrapround_string(s: str) -> int:\n    \"\"\"\n    計算字串 s 中所有唯一非空子串，並檢查它們是否在無限 wraparound 字串中出現。\n    只需考慮小寫字母，時間複雜度 O(n)，空間 O(1)。\n    \"\"\"\n    # dp[i] 代表字母 chr(i + ord('a')) 作為子串結尾時，能得到的最大連續長度\n    dp = [0] * 26\n    cur_len = 0  # 當前連續子串長度\n\n    for i, ch in enumerate(s):\n        if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n            cur_len += 1          # 與前一個字母連續\n        else:\n            cur_len = 1           # 重新開始\n        idx = ord(ch) - ord('a')\n        dp[idx] = max(dp[idx], cur_len)\n\n    return sum(dp)\n\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取資料，輸出結果。\n    輸入可能形如：s = \"abc\" 或僅為字串 abc。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 若輸入中包含引號，提取引號內的內容；否則直接使用整個輸入\n    match = re.search(r'\"([^\"]*)\"', data)\n    s = match.group(1) if match else data\n\n    result = find_substring_in_wrapround_string(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode219.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate II",
    "description_snippet": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for checking duplicates within k distance. Each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide step-by-step. Use arrow.\n\nLet's write:\n\nStart\n→ Step 1: 建立一個空字典 lastIndex // 用來儲存每個值最後出現的索引\n→ For i from 0 to length(nums)-1: // 遍歷陣列\n    → Step 2: value = nums[i] // 取得當前元素\n    → Decision: 是否在 lastIndex 中存在 value? // 檢查是否已見過此值\n        Yes → Step 3: prevIndex = lastIndex[value] // 取得先前索引\n        Yes → Decision: abs(i - prevIndex) <= k? // 判斷距離\n            Yes → Step 4: Return true // 找到符合條件的重複\n            No  → Step 5: Update lastIndex[value] = i // 更新索引\n        No  → Step 6: lastIndex[value] = i // 新值加入字典\n→ Step 7: Return false // 沒有符合條件的重複\nEnd\n\nNeed to format each line with \"虛擬碼步驟 // 解釋\". Ensure each step is one line. For loops and decisions, indentation maybe with tab or spaces? Format shows arrows. Let's replicate style. Use \"→\" for steps, \"Decision:\" for decision. Use \"Yes →\", \"No →\". Use Start, End. Provide comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空字典 lastIndex // 用來儲存每個值最後出現的索引  \n→ For i from 0 to length(nums)-1: // 從陣列頭到尾逐一檢查  \n  → Step 2: value = nums[i] // 取得目前索引 i 的元素  \n  → Decision: 是否在 lastIndex 中存在 value? // 判斷此值是否已經出現過  \n    Yes → Step 3: prevIndex = lastIndex[value] // 取得此值最後一次出現的索引  \n    Yes → Decision: abs(i - prevIndex) <= k? // 檢查距離是否在 k 內  \n      Yes → Step 4: Return true // 找到符合條件的重複，立即返回  \n      No  → Step 5: Update lastIndex[value] = i // 距離太大，更新索引為目前 i  \n    No  → Step 6: lastIndex[value] = i // 此值首次出現，記錄索引  \n→ Step 7: Return false // 完全遍歷後仍未找到符合條件的重複  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        Checks whether there exist two identical elements in `nums`\n        whose indices differ by at most `k`.\n\n        :param nums: List[int] – the integer array\n        :param k: int – the maximum allowed index distance\n        :return: bool – True if such a pair exists, False otherwise\n        \"\"\"\n        last_index = {}\n        for i, num in enumerate(nums):\n            if num in last_index and i - last_index[num] <= k:\n                return True\n            last_index[num] = i\n        return False\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses the input string to extract the integer list `nums` and the integer `k`.\n\n    Expected format (examples):\n        \"nums = [1,2,3,1], k = 3\"\n        \"nums=[1,0,1,1],k=1\"\n        \"nums = [1,2,3,1,2,3], k = 2\"\n\n    :param data: str – raw input from stdin\n    :return: tuple (List[int], int)\n    \"\"\"\n    # Find the list inside brackets\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not list_match:\n        raise ValueError(\"Cannot find the list of numbers in input.\")\n    list_str = list_match.group(1).strip()\n    nums = [int(x.strip()) for x in list_str.split(',') if x.strip()]\n\n    # Find the value of k\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not k_match:\n        raise ValueError(\"Cannot find the value of k in input.\")\n    k = int(k_match.group(1))\n\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    sol = Solution()\n    result = sol.containsNearbyDuplicate(nums, k)\n    # Print lowercase 'true' or 'false' to match expected output\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1], k = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode135.json",
    "problem_index_in_file": 0,
    "title": "Candy",
    "description_snippet": "There are n children standing in a line. Each child is assigned a rating value given in the integer ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the candy problem (Leetcode 135). Provide line by line pseudo-code with explanations. Use Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe should not output actual code. Provide steps: initialize candies array with 1, first pass left-to-right, second pass right-to-left, sum candies. Provide decision steps: if rating[i] > rating[i-1], candies[i] = candies[i-1]+1 etc.\n\nUse \"Start // 程式開始執行\" etc. Provide arrow arrows.\n\nMake sure to have line by line, each with explanation. Provide decision structure for rating comparisons. Use indentations maybe.\n\nWe need to keep steps in order. We can use comments like // for explanation. Use arrow \"→\". Let's craft.\n\nWe need to be careful: no actual code, just pseudo steps. Provide line-by-line.\n\nOk let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立長度為 n 的陣列 candies，並將每個元素初始化為 1 // 每個孩子至少得到一顆糖果  \n→ Step 2: 設定 i 為 1 // 開始從第二個孩子進行左至右掃描  \n→ Decision: i < n? // 檢查是否還有孩子未掃描  \n Yes → Step 3: 如果 ratings[i] > ratings[i-1]? // 檢查右側孩子的評分是否比左側高  \n  Yes → Step 4: candies[i] = candies[i-1] + 1 // 右側孩子得糖果比左側多  \n  No  → Step 5: candies[i] = candies[i] // 保持目前值（已在初始化時為 1）  \n → Step 6: i = i + 1 // 移至下一個孩子  \n → Step 7: 回到 Decision: i < n?  \n No  → Step 8: i = n - 2 // 從倒數第二個孩子開始右至左掃描  \n→ Decision: i >= 0? // 檢查是否還有孩子未掃描  \n Yes → Step 9: 如果 ratings[i] > ratings[i+1]? // 檢查左側孩子的評分是否比右側高  \n  Yes → Step 10: candies[i] = max(candies[i], candies[i+1] + 1) // 確保左側孩子糖果數量既符合右側孩子的要求又至少比右側多  \n  No  → Step 11: candies[i] = candies[i] // 保持目前值  \n → Step 12: i = i - 1 // 移至上一個孩子  \n → Step 13: 回到 Decision: i >= 0?  \n No  → Step 14: sum = 0 // 初始化總糖果數  \n→ Step 15: 從 0 到 n-1 迭代每個 candies[i]  \n → Step 16: sum = sum + candies[i] // 累加糖果數  \n→ Step 17: 回傳 sum // 最終回傳最少糖果總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef candy(ratings):\n    \"\"\"計算最少糖果數量，符合題目條件。\"\"\"\n    n = len(ratings)\n    candies = [1] * n                     # 每個孩子至少一顆糖果\n    # 左到右掃描：右側孩子評分比左側高則多一顆糖果\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n    # 右到左掃描：左側孩子評分比右側高則確保比右側多\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n    return sum(candies)\n\ndef main():\n    \"\"\"從標準輸入讀取資料，計算並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式，例如 'ratings = [1,0,2]'\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = data\n\n    try:\n        ratings = ast.literal_eval(rhs)\n    except Exception:\n        # 若解析失敗，僅提取整數並組成列表\n        import re\n        nums = re.findall(r'-?\\d+', rhs)\n        ratings = [int(x) for x in nums]\n\n    result = candy(ratings)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ratings = [1,0,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "ratings = [1,2,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode127.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the word ladder problem: compute length of shortest transformation sequence. Use BFS. Steps: check endWord in wordList, if not return 0. Use set for wordList. Use queue with (word, level). Use visited set. For each word, for each position, change letter a-z, if new word in list and not visited, add to queue, mark visited. If new word==endWord return level+1. If BFS ends return 0.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Start, End, Decision:. Provide step labels: Start, → Step 1: ... etc. Use indentation for nested. Use \"Decision:\" lines.\n\nLet's create step numbers. Use \"Step 1\", \"Step 2\" etc. Also \"Decision: endWord in wordList?\" etc. Use Yes → etc.\n\nWe need to be careful with format: each line: 虛擬碼步驟[space]//解釋.\n\nAlso we can show pseudo code.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 beginWord, endWord, wordList // 從輸入取得起點、終點與字典  \n→ Step 2: 若 endWord 不在 wordList → End // 沒有可達終點，直接返回 0  \n→ Decision: 若 endWord 在 wordList?  \n    Yes → Step 3: 初始化 queue 為 [(beginWord, 1)] // 起點與初始層級 1  \n    No  → End // 這行實際上不會執行，因為已在前面處理  \n→ Step 4: 建立 visited 集合並加入 beginWord // 標記已訪問過的字  \n→ Step 5: 建立 setDict 為 wordList 的集合 // 方便 O(1) 查詢  \n→ Step 6: 進入 BFS 迴圈  \n    → Decision: 若 queue 為空?  \n        Yes → Step 7: 回傳 0 // 所有可能已被探索完，無路徑  \n        No  → Step 8: 取出 queue 內首項 (currentWord, level)  \n→ Step 9: 若 currentWord == endWord → Step 10: 回傳 level // 找到最短路徑  \n→ Step 11: 對每個字元位置 i 在 currentWord  \n    → Step 12: 對每個小寫字母 c 從 'a' 到 'z'  \n        → Decision: 若 c == currentWord[i]?  \n            Yes → Skip // 不需要替換成同一字母  \n            No  → Step 13: 建立 nextWord = currentWord 先替換第 i 個字為 c  \n→ Step 14: Decision: 若 nextWord 在 setDict 且未在 visited?  \n        Yes → Step 15: 加入 visited nextWord  \n              → Step 16: queue 加入 (nextWord, level + 1) // 下一層級  \n        No  → Skip // 無效或已訪問  \n→ Step 17: 迴圈結束後返回 0 // BFS 完結仍未找到 endWord  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        使用 BFS 找到最短轉換序列的長度。\n        若 endWord 不在字典，直接回傳 0。\n        \"\"\"\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (目前單字, 目前路徑長度)\n\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            # 嘗試每個位置換成 a~z\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        wordSet.remove(new_word)       # 標記已訪問\n                        queue.append((new_word, length + 1))\n        return 0\n\ndef parse_input(data: str):\n    \"\"\"\n    將類似 'beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\"]' 的字串\n    轉成 dict。使用 ast.literal_eval 以避免 eval 的安全風險。\n    \"\"\"\n    # 先去除前後空白\n    data = data.strip()\n    if not data:\n        return {}\n    # 把 '=' 換成 ':'，並包上花括號形成字典字串\n    data = data.replace('=', ':')\n    data = '{' + data + '}'\n    try:\n        parsed = ast.literal_eval(data)\n    except Exception as e:\n        raise ValueError(f\"無法解析輸入：{data}\") from e\n    return parsed\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有資料\n    raw = sys.stdin.read()\n    params = parse_input(raw)\n\n    # 取得必要參數\n    beginWord = params.get(\"beginWord\", \"\")\n    endWord = params.get(\"endWord\", \"\")\n    wordList = params.get(\"wordList\", [])\n\n    # 只保留字串型別的元素，排除非字串或重複\n    wordList = [w for w in wordList if isinstance(w, str)]\n\n    sol = Solution()\n    result = sol.ladderLength(beginWord, endWord, wordList)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpainx9wgb.py\", line 45, in parse_input\n    parsed = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7801565fba50>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpainx9wgb.py\", line 53, in <module>\n    params = parse_input(raw)\n             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpainx9wgb.py\", line 47, in parse_input\n    raise ValueError(f\"無法解析輸入：{data}\") from e\nValueError: 無法解析輸入：{beginWord : \"hit\", endWord : \"cog\", wordList : [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]}"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp4lkmu2b_.py\", line 45, in parse_input\n    parsed = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7269866f7a10>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp4lkmu2b_.py\", line 53, in <module>\n    params = parse_input(raw)\n             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4lkmu2b_.py\", line 47, in parse_input\n    raise ValueError(f\"無法解析輸入：{data}\") from e\nValueError: 無法解析輸入：{beginWord : \"hit\", endWord : \"cog\", wordList : [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]}"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode76.json",
    "problem_index_in_file": 0,
    "title": "Minimum Window Substring",
    "description_snippet": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation comments. The problem: Minimum Window Substring. Provide pseudo-code with start, decision, etc.\n\nWe need to include steps: count target chars, sliding window with left and right pointers, maintain formed counter, etc. Unique answer. Should handle no window.\n\nSo produce pseudocode lines: Start, Step: initialize target count dictionary, Step: initialize window count, left=0, right=0, formed=0, required=unique chars count. Best window = (inf, None, None). While right<n: add char to window, if window char count matches target char count, increment formed. While left <= right and formed == required: update best window if smaller. Then try to shrink window: char at left, decrement count, if count < target count, formed--. left++.\n\nAfter loop, if best window length is inf, return \"\", else return s[best[1]:best[2]].\n\nWe need to use arrow notation: \"→ Step X:\" etc. Use Decision: for conditions. Use Yes/No branches.\n\nAlso use indentation with spaces? Provide step number maybe. We'll use \"Step 1:\" etc.\n\nLet's produce.\n\nWe must not output real code. Just virtual steps with explanations.\n\nLet's write.\n\nStart\n→ Step 1: Initialize targetCount map for characters in t // count each needed char\n→ Step 2: required = number of unique keys in targetCount // how many distinct chars need to be satisfied\n→ Step 3: left = 0, right = 0 // window pointers\n→ Step 4: formed = 0 // how many unique chars in current window meet required counts\n→ Step 5: windowCount = empty map // counts of chars inside current window\n→ Step 6: bestLen = ∞, bestStart = 0, bestEnd = 0 // best window info\n→ Decision: while right < length of s? // expand window\n    Yes → Step 7: char = s[right] // char entering window\n    → Step 8: increment windowCount[char] // update window counts\n    → Decision: if windowCount[char] == targetCount[char]? // char count just reached target\n        Yes → Step 9: formed++ // one more unique char satisfied\n        No  → Step 10: // nothing else\n    → Decision: while left <= right and formed == required? // try to contract window\n        Yes → Step 11: currentLen = right - left + 1\n        → Decision: if currentLen < bestLen? // found smaller window\n            Yes → Step 12: bestLen = currentLen\n                     bestStart = left\n                     bestEnd = right\n            No  → Step 13: // keep best as is\n        → Step 14: leftChar = s[left] // char leaving window\n        → Step 15: decrement windowCount[leftChar]\n        → Decision: if windowCount[leftChar] < targetCount[leftChar]? // left char no longer satisfies\n            Yes → Step 16: formed-- // unique char unsatisfied\n            No  → Step 17: // still satisfied\n        → Step 18: left++ // move left pointer\n    → Step 19: right++ // expand right pointer\n→ Step 20: Decision: if bestLen == ∞? // no valid window found\n    Yes → Step 21: return \"\" // no substring\n    No  → Step 22: return s[bestStart:bestEnd+1] // return minimal window substring\nEnd\n\nAdd comments after each line.\n\nMake sure formatting consistent: \"→ Step X:\" etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 targetCount 為 t 中每個字元的出現次數 // 建立目標字元統計表  \n→ Step 2: required = targetCount 的鍵數目 // 需要滿足的獨特字元數量  \n→ Step 3: left = 0, right = 0 // 滑動視窗左右指標  \n→ Step 4: formed = 0 // 視窗中已滿足目標次數的字元類別數  \n→ Step 5: windowCount = 空字典 // 視窗內字元統計表  \n→ Step 6: bestLen = ∞, bestStart = 0, bestEnd = 0 // 儲存最小窗口資訊  \n→ Decision: 當 right < s.length? // 擴展右指標  \n    Yes → Step 7: char = s[right] // 進入窗口的字元  \n    → Step 8: windowCount[char]++ // 更新窗口字元計數  \n    → Decision: 如果 windowCount[char] == targetCount[char]? // 是否剛好滿足此字元  \n        Yes → Step 9: formed++ // 多一個字元類別已滿足  \n        No  → Step 10: // 不做處理  \n    → Decision: 當 left ≤ right 且 formed == required? // 觀察是否可以縮小窗口  \n        Yes → Step 11: currentLen = right - left + 1 // 當前窗口長度  \n        → Decision: 如果 currentLen < bestLen? // 找到更小窗口  \n            Yes → Step 12: bestLen = currentLen  \n                     bestStart = left  \n                     bestEnd = right  \n            No  → Step 13: // 保持現有最佳窗口  \n        → Step 14: leftChar = s[left] // 退出窗口的字元  \n        → Step 15: windowCount[leftChar]-- // 更新窗口字元計數  \n        → Decision: 如果 windowCount[leftChar] < targetCount[leftChar]? // 失去滿足條件  \n            Yes → Step 16: formed-- // 減少已滿足類別數  \n            No  → Step 17: // 仍然滿足  \n        → Step 18: left++ // 收縮左指標  \n    → Step 19: right++ // 擴大右指標  \n→ Step 20: Decision: 如果 bestLen == ∞? // 未找到有效窗口  \n    Yes → Step 21: 返回 \"\" // 沒有符合條件的子字串  \n    No  → Step 22: 返回 s[bestStart:bestEnd+1] // 返回最小窗口子字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n        dict_t = Counter(t)\n        required = len(dict_t)\n        l = r = 0\n        formed = 0\n        window_counts = {}\n        ans = float(\"inf\"), None, None  # (window length, left, right)\n        while r < len(s):\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n            while l <= r and formed == required:\n                character = s[l]\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n                l += 1\n            r += 1\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2] + 1]\n\ndef parse_input(data: str):\n    # Try to extract s and t from patterns like s = \"...\" , t = \"...\"\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    t_match = re.search(r't\\s*=\\s*\"([^\"]*)\"', data)\n    if s_match and t_match:\n        return s_match.group(1), t_match.group(1)\n    # Fallback: assume each line is one value\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # If still not enough, return empty strings\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, t = parse_input(raw_input)\n    solution = Solution()\n    result = solution.minWindow(s, t)\n    # Print result surrounded by double quotes as shown in examples\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
          "expected_output": "\"BANC\"",
          "success": true,
          "output": "\"BANC\""
        },
        {
          "example_index": 1,
          "input": "s = \"a\", t = \"a\"",
          "expected_output": "\"a\"",
          "success": true,
          "output": "\"a\""
        },
        {
          "example_index": 2,
          "input": "s = \"a\", t = \"aa\"",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode420.json",
    "problem_index_in_file": 0,
    "title": "Strong Password Checker",
    "description_snippet": "A password is considered strong if the below conditions are all met:\n\nIt has at least 6 characters a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find min steps to make password strong. We must follow format: each line with \"虛擬碼步驟\" and comment after // explanation. Use arrows and decision structure.\n\nNeed to produce line-by-line pseudocode. Must not output actual code, only structure. Use \"Start\", \"End\", \"Decision:\", \"→\" etc.\n\nWe need to explain algorithm: count length, count missing types, find repeats of 3+. Determine deletions needed if >20, replacements needed for repeats. Use approach: steps = deletions + max(missingTypes, replacementsAfterDeletion). For length <6: steps = max(missingTypes, 6 - len).\n\nAlso need to handle length between 6 and 20: steps = max(missingTypes, repeats).\n\nAlso for >20: deletions = len-20; reduce repeats by deletions in specific way.\n\nWe need to produce virtual code lines: Start, read password, compute len, etc.\n\nWe should structure:\n\nStart\n→ Step 1: input password\n→ Step 2: set length = len(password)\n→ Step 3: initialize missingLower, missingUpper, missingDigit = 1 each\n→ Step 4: loop through characters to update missing flags and collect repeats\nWe need to track repeats: find sequences of same char length >=3; store length.\n\nAfter loop: missingTypes = missingLower + missingUpper + missingDigit\n\nIf length <6:\n→ Step: replacements = count of repeats (each group len//3)\n→ Step: inserts = 6 - length\n→ Steps = max(missingTypes, replacements, inserts) but actual known formula: max(missingTypes, max(replacements, inserts)). Actually need insert count to cover both missing types and repeats.\n\nBut for <6, you can insert to satisfy missing types and break repeats. Usually steps = max(missingTypes, 6 - length, replacements) but replacements will be handled by inserts.\n\nBut we can produce pseudocode that calculates.\n\nIf length between 6 and 20:\n→ Step: replacements = sum over repeats of len//3\n→ Steps = max(missingTypes, replacements)\n\nIf length >20:\n→ Step: deletions = length - 20\n→ Step: use deletions to reduce repeats: iterate over repeats prioritized by mod 3\n→ Step: after deletions, recompute replacements\n→ Steps = deletions + max(missingTypes, replacements)\n\nWe need to show loops and decisions.\n\nLet's craft pseudocode lines with arrows.\n\nMake sure each line has explanation after //.\n\nLet's produce about 30 lines.\n\nWe should include details of using arrays for repeat lengths. We'll keep simplified.\n\nImportant: Use \"Decision:\" for branching, \"Yes →\" and \"No →\".\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 password // 從使用者取得密碼字串\n→ Step 2: 設定 len = length(password) // 取得密碼長度\n→ Step 3: 設定 missingLower = 1, missingUpper = 1, missingDigit = 1 // 假設缺少三種字元類型\n→ Step 4: 建立 empty list repeats // 用來儲存連續重複字元序列長度\n→ Step 5: 設定 i = 0 // 初始化索引\n→ Decision: i < len? // 仍有字元未處理？\n    Yes → Step 6: 取得 char = password[i] // 取得目前字元\n    → Step 7: 若 char 為小寫字母則 missingLower = 0 // 已存在小寫\n    → Step 8: 若 char 為大寫字母則 missingUpper = 0 // 已存在大寫\n    → Step 9: 若 char 為數字則 missingDigit = 0 // 已存在數字\n    → Step 10: 設定 runLen = 1 // 連續重複字元長度計數器\n    → Step 11: 從 i+1 開始檢查同字元序列\n    → Step 12: 若 next char == char 且 (i+1) < len 则 runLen++，i++，重複第11步\n    → Step 13: 若 runLen >= 3 則將 runLen 加入 repeats // 記錄長度≥3的重複序列\n    → Step 14: i++ // 移至下一個字元\n    → Decision: i < len? // 仍有字元未處理？ 轉回 Step 5\n    No  → Step 15: 計算 missingTypes = missingLower + missingUpper + missingDigit // 缺少類型數\n    → Step 16: 計算 totalRepetitions = sum over repeats of floor(runLen / 3) // 需要替換的數量\n→ Decision: len < 6? // 密碼太短？\n    Yes → Step 17: 設定 insertions = 6 - len // 需要插入的字元數\n    → Step 18: Steps = max(missingTypes, insertions, totalRepetitions) // 最小步驟數\n    No → Decision: 6 <= len <= 20? // 長度正常範圍？\n        Yes → Step 19: Steps = max(missingTypes, totalRepetitions) // 最小步驟數\n        No  → Decision: len > 20? // 密碼過長？\n            Yes → Step 20: 設定 deletions = len - 20 // 必須刪除的字元數\n            → Step 21: 設定 rem = deletions // 剩餘可用於減少重複的刪除\n            → Step 22: 針對 repeats 按 (runLen % 3) 由小到大排序 // 先處理 mod 0、1、2\n            → Step 23: 為每個 runLen 在排序後進行刪除\n                → Decision: rem == 0? // 已完成所有刪除？\n                    Yes → 退出循環\n                    No  → 若 runLen % 3 == 0 且 rem > 0\n                            → runLen--, rem--, 更新 repeats\n                            → 若 runLen < 3 则移除此項\n                            → 重新計算 totalRepetitions = sum floor(runLen/3)\n                            → 轉回 Step 23\n                → Decision: runLen % 3 == 1 且 rem > 0\n                            → runLen -= 2, rem -= 2 // 每兩次刪除可減少一個替換\n                            → 若 runLen < 3 则移除此項\n                            → 重新計算 totalRepetitions\n                            → 轉回 Step 23\n                → Decision: runLen % 3 == 2 且 rem > 0\n                            → runLen -= 3, rem -= 3 // 每三次刪除可減少一個替換\n                            → 若 runLen < 3 则移除此項\n                            → 重新計算 totalRepetitions\n                            → 轉回 Step 23\n            → Step 24: Steps = deletions + max(missingTypes, totalRepetitions) // 最小步驟數\n            No  → Step 25: // 理論上不會進入此分支\n→ End // 程式執行結束。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strongPasswordChecker(self, s: str) -> int:\n        n = len(s)\n        # Check missing character types\n        has_lower = has_upper = has_digit = 0\n        for c in s:\n            if c.islower():\n                has_lower = 1\n            elif c.isupper():\n                has_upper = 1\n            elif c.isdigit():\n                has_digit = 1\n        missing_types = 3 - (has_lower + has_upper + has_digit)\n\n        # Count replacements needed for repeating sequences\n        replace = 0\n        one_mod = two_mod = 0  # counts of sequences where len%3==0 or 1\n        i = 2\n        while i < n:\n            if s[i] == s[i - 1] == s[i - 2]:\n                length = 2\n                while i < n and s[i] == s[i - 1]:\n                    length += 1\n                    i += 1\n                replace += length // 3\n                if length % 3 == 0:\n                    one_mod += 1\n                elif length % 3 == 1:\n                    two_mod += 1\n            else:\n                i += 1\n\n        if n < 6:\n            # Need to insert characters\n            return max(6 - n, missing_types)\n        elif n <= 20:\n            # Only replacements and missing types matter\n            return max(replace, missing_types)\n        else:\n            # Delete characters first\n            delete = n - 20\n            # Prioritize deleting from sequences where len%3==0\n            reduce = min(delete, one_mod)\n            replace -= reduce\n            delete -= reduce\n\n            # Then delete from sequences where len%3==1 (each two deletions reduce one replace)\n            reduce = min(delete // 2, two_mod)\n            replace -= reduce\n            delete -= reduce * 2\n\n            # Remaining deletions reduce replaces by 3 each\n            replace -= delete // 3\n            # Final answer: deletions + max(missing_types, remaining replaces)\n            return (n - 20) + max(missing_types, replace)\n\ndef main():\n    data = sys.stdin.read()\n    # Try to extract password from format like: password = \"a\"\n    match = re.search(r'password\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        password = match.group(1)\n    else:\n        # Fallback: take first non-empty line as password\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        password = lines[0] if lines else \"\"\n\n    sol = Solution()\n    result = sol.strongPasswordChecker(password)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "password = \"a\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "password = \"aA1\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "password = \"1337C0d3\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode643.json",
    "problem_index_in_file": 0,
    "title": "Maximum Average Subarray I",
    "description_snippet": "You are given an integer array nums consisting of n elements, and an integer k.\n\nFind a contiguous s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for sliding window max average subarray length k. We'll produce algorithm: maintain sum of first k, compute avg, slide window. Provide steps.\n\nWe must output in specified format: each line: virtual code step + space + // explanation. Use Start, End, Decision. Provide arrows →. We need \"逐行\" lines.\n\nLet's create:\n\nStart // start\n\n→ Step 1: If n < k, return 0 // handle edge\n\n→ Step 2: Compute initial sum of first k elements // sum = sum(nums[0:k])\n\n→ Step 3: Set maxSum = sum // initialize maximum\n\n→ Step 4: For i from k to n-1: // slide\n\n    → Step 4.1: sum += nums[i] - nums[i-k] // add new, remove old\n\n    → Step 4.2: If sum > maxSum → maxSum = sum // update\n\n→ Step 5: maxAvg = maxSum / k // compute average\n\n→ End // return\n\nBut we need to output \"virtual code\" lines. Use \"Step X:\" style. Use arrow \"→\". Also decision: we need decision for if sum > maxSum? We can use Decision: If sum > maxSum? Yes → Step etc.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: If n < k, return 0 // 若數列長度不足 k，直接回傳 0\n→ Step 2: Compute initial sum of first k elements // 計算前 k 個元素的總和\n→ Step 3: Set maxSum = sum // 初始化最大總和為目前總和\n→ Step 4: For i from k to n-1: // 逐步滑動子陣列\n    → Step 4.1: sum += nums[i] - nums[i-k] // 加入新元素並移除最舊元素\n    → Decision: If sum > maxSum? // 判斷是否為更大的總和\n        Yes → Step 4.2: maxSum = sum // 更新最大總和\n        No  → (無操作) // 總和不大於最大值，保持不變\n→ Step 5: maxAvg = maxSum / k // 取得最大平均值\n→ End // 程式執行結束，回傳 maxAvg",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMaxAverage(self, nums, k):\n        # 初始滑動視窗和最大和\n        window_sum = sum(nums[:k])\n        max_sum = window_sum\n        # 依次滑動視窗\n        for i in range(k, len(nums)):\n            window_sum += nums[i] - nums[i - k]\n            if window_sum > max_sum:\n                max_sum = window_sum\n        return max_sum / k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = None\n    k = None\n\n    # 先嘗試正則匹配「nums = [...]」和「k = n」的格式\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if nums_match:\n        nums = eval(nums_match.group(1))\n    if k_match:\n        k = int(k_match.group(1))\n\n    # 若上述匹配失敗，則假設第一行是陣列，第二行是 k\n    if nums is None or k is None:\n        lines = data.strip().splitlines()\n        if lines:\n            try:\n                nums = eval(lines[0].strip())\n            except:\n                pass\n        if len(lines) > 1:\n            try:\n                k = int(lines[1].strip())\n            except:\n                pass\n\n    # 如仍無法獲取，直接返回\n    if nums is None or k is None:\n        sys.exit(0)\n\n    solution = Solution()\n    avg = solution.findMaxAverage(nums, k)\n    print(f\"{avg:.5f}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,12,-5,-6,50,3], k = 4",
          "expected_output": "12.75000",
          "success": true,
          "output": "12.75000"
        },
        {
          "example_index": 1,
          "input": "nums = [5], k = 1",
          "expected_output": "5.00000",
          "success": true,
          "output": "5.00000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode258.json",
    "problem_index_in_file": 0,
    "title": "Add Digits",
    "description_snippet": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line. Use arrows, decisions. Provide explanation after each line.\n\nThe problem: given an integer num, repeatedly sum its digits until result has only one digit, return it. This is digital root. The algorithm: while num >= 10: sum digits -> assign to num. Finally return num.\n\nWe need virtual code steps.\n\nFormat: Start, → Step, → Decision, etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Set num ← input integer // 取得輸入整數\n→ Decision: num >= 10? // 檢查是否為多位數\n    Yes → Step 2: sum ← 0 // 初始化累加變數\n    → Step 3: for each digit d in string representation of num: sum ← sum + d // 計算各位數字之和\n    → Step 4: num ← sum // 更新 num 為新和值\n    → Decision: num >= 10? // 檢查新值是否仍為多位數\n        Yes → Go back to Step 2 // 重新計算\n        No → Step 5: return num // 結果為單一數字，返回\n    No → Step 6: return num // 原本已是單一數字，直接返回\nEnd // 程式執行結束\n\nBut need to ensure formatting: Use arrow for each step: \"→ Step X:\" etc. Decision lines with Yes/No arrows. We need to indent or not? Use indentation maybe. But we should keep consistent.\n\nLet's format as:\n\nStart // 程式開始執行\n→ Step 1: num ← input integer // 取得輸入整數\n→ Decision: num >= 10? // 檢查 num 是否為多位數\n    Yes → Step 2: sum ← 0 // 初始化累加變數\n    → Step 3: for each digit d in string(num): sum ← sum + d // 計算所有位數之和\n    → Step 4: num ← sum // 更新 num 為新值\n    → Decision: num >= 10? // 檢查新值是否仍為多位數\n        Yes → Step 2 // 重新進行求和\n        No → Step 5: return num // 取得單一數字，返回結果\n    No → Step 6: return num // 初始即為單一數字，直接返回\nEnd // 程式執行結束\n\nBut \"Step 2\" repeated: we need maybe \"Step 7\" or \"Loop\". But we can just use \"Go to Step 2\" or \"Repeat\". But arrow lines must include \"→\". Use \"→\" for each line. Use \"Decision:\" lines.\n\nWe should provide line by line with explanations.\n\nWe need to avoid actual code. So no actual syntax. Use virtual code.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: num ← input integer // 取得輸入整數  \n→ Decision: num ≥ 10? // 檢查 num 是否為多位數  \n  Yes → Step 2: sum ← 0 // 初始化累加變數  \n   → Step 3: for each digit d in string(num): sum ← sum + d // 計算所有位數之和  \n   → Step 4: num ← sum // 更新 num 為新值  \n   → Decision: num ≥ 10? // 檢查新值是否仍為多位數  \n     Yes → Step 2 // 重新進行求和  \n     No → Step 5: return num // 取得單一數字，返回結果  \n  No → Step 6: return num // 初始即為單一數字，直接返回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# 計算數字的「數字根」：不斷將各位數相加，直到結果只有一位數\ndef add_digits(num: int) -> int:\n    while num >= 10:                # 當 num 有兩位或以上時\n        num = sum(int(d) for d in str(num))  # 取每一位數字相加\n    return num                      # 只剩一位數時回傳\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    if not data:  # 如果沒有輸入直接結束\n        return\n\n    # 從輸入中提取第一個整數，支援「num = 38」或直接「38」的格式\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    num = int(numbers[0])\n\n    # 計算並輸出結果\n    result = add_digits(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 38",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode696.json",
    "problem_index_in_file": 0,
    "title": "Count Binary Substrings",
    "description_snippet": "Given a binary string s, return the number of non-empty substrings that have the same number of 0's ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm to count binary substrings with equal 0 and 1 and groups consecutive. Known solution: count consecutive groups, count min(prev, curr). We'll produce steps.\n\nWe must output line by line: \"虛擬碼步驟 // 解釋\". Use arrows. Include Start, End. Use Decision. No actual code.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize prevCount = 0, currCount = 0, result = 0 // 變數初始化\n→ Step 2: For each character ch in s: // 逐字符遍歷\n    → Decision: 是否為 '1'? // 判斷是否切換群組\n        Yes → currCount++ // 目前為1群組長度增加\n        No  → prevCount = currCount; currCount = 1 // 更新前一群組長度，開始新群組\n    → Decision: 是否已經進入新群組? // 檢查是否剛剛結束1群組並切換到0\n        Yes → result += min(prevCount, currCount) // 加上有效子串數\n        No  → // 不做任何事\n→ End // 結束循環\n→ Step 3: 回傳 result // 輸出最終計算結果\n\nBut need arrows for decisions. Format:\n\nStart // 程式開始執行\n→ Step 1: ... // ...\n→ Step 2: For each character ch in s: // ...\n    → Decision: ch == '1'? // 判斷\n        Yes → currCount++ // ...\n        No  → prevCount = currCount; currCount = 1 // ...\n    → Decision: ??? Actually after updating counts we need to compute result when encountering new group? Usually we add min(prev, curr) when we just finished a group. That happens when ch is '0' after a run of '1's? Implementation: if ch is '0', prevCount = currCount; currCount = 1; result += min(prev, curr). For ch '1', just currCount++.\n\nSo we can restructure: Use one loop; within loop, if ch == '1': currCount++ ; else: // ch == '0'\n    prevCount = currCount\n    currCount = 1\n    result += min(prevCount, currCount)\n\nSimpler.\n\nLet's produce steps accordingly.\n\nAlso need to include Decision for char equality.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Initialize prev = 0, curr = 0, ans = 0 // 初始化計數器\n→ Step 2: For each character c in s: // 逐字元處理\n    → Decision: c == '1'? // 判斷是否為1\n        Yes → curr++ // 連續1的數量加一\n        No  → prev = curr; curr = 1; ans += min(prev, curr) // 進入0群組，更新prev並累加可行子串\n→ End // 循環結束\n→ Step 3: Return ans // 回傳結果\n\nWe must adhere to format: Each line with \"虛擬碼步驟 [space] // 解釋\". Use arrow lines \"→\".\n\nInclude Start, End, Step numbers. For decisions: \"Decision: ...?\" with Yes and No branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize prev = 0, curr = 0, ans = 0 // 初始化三個計數器  \n→ Step 2: For each character c in s: // 逐字元處理  \n  → Decision: c == '1'? // 判斷是否為 '1'  \n   Yes → curr++ // 連續 1 的長度加 1  \n   No → prev = curr; curr = 1; ans += min(prev, curr) // 進入 0 群組，更新 prev、curr 並累加可行子串數  \nEnd // 所有字元已處理  \n→ Step 3: Return ans // 回傳符合條件的子字串數量",
      "generated_code": "import sys\n\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        groups = []\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                count += 1\n            else:\n                groups.append(count)\n                count = 1\n        groups.append(count)\n\n        result = 0\n        for i in range(1, len(groups)):\n            result += min(groups[i], groups[i-1])\n        return result\n\ndef parse_input(line: str) -> str:\n    # Remove surrounding spaces\n    line = line.strip()\n    # If the line contains quotes, extract the content inside them\n    if '\"' in line:\n        start = line.find('\"')\n        end = line.rfind('\"')\n        if start != -1 and end != -1 and end > start:\n            return line[start+1:end]\n    # If the line starts with 's =', strip that part\n    if line.lower().startswith('s ='):\n        parts = line.split('=', 1)\n        return parts[1].strip()\n    # Otherwise, assume the whole line is the binary string\n    return line\n\nif __name__ == \"__main__\":\n    # Read all lines from stdin and use the first non-empty line\n    input_lines = [ln for ln in sys.stdin.read().splitlines() if ln.strip()]\n    if not input_lines:\n        sys.exit(0)\n    raw_input = input_lines[0]\n    binary_string = parse_input(raw_input)\n    solution = Solution()\n    print(solution.countBinarySubstrings(binary_string))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"00110011\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "s = \"10101\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode205.json",
    "problem_index_in_file": 0,
    "title": "Isomorphic Strings",
    "description_snippet": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments in Chinese. The requirement: Each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow symbols. Start End Decision. Provide step-by-step. We should handle checking mapping from s to t and from t to s to ensure one-to-one mapping. Also need to handle null or empty strings. So algorithm: if lengths differ -> false. Create two maps: s->t, t->s. Iterate through each char index. For each char pair (c1, c2). If c1 in map_s: check map_s[c1]==c2; else map_s[c1]=c2. Similarly for map_t. If mismatch -> false. After loop true.\n\nWe produce virtual code:\n\nStart\n→ Step 1: 接收字符串 s, t // 取得輸入\n→ Decision: s 和 t 是否同長? // 先檢查長度\n    Yes → Step 2: 初始化兩個空字典 mapS, mapT // 用於存映射\n        → Step 3: 循環 i 從 0 到 len(s)-1\n            → Step 4: let c1 = s[i], c2 = t[i] // 取得對應字符\n            → Decision: c1 是否已在 mapS? // 檢查已有映射\n                Yes → Decision: mapS[c1] 是否等於 c2? // 確認映射正確\n                    Yes → Decision: c2 是否已在 mapT? // 反向檢查\n                        Yes → Decision: mapT[c2] 是否等於 c1? // 確認一對一\n                            Yes → Step 5: 迴圈結束下一位\n                            No  → Step 6: 返回 False // 反向映射不一致\n                        No  → Step 7:  mapT[c2] = c1 // 建立反向映射\n                No  → Step 8:  mapS[c1] = c2 // 建立映射\n                No  → Step 9:  mapT[c2] = c1 // 建立反向映射\n        → Step 10: 返回 True // 所有字符對應一致\n    No  → Step 11: 返回 False // 長度不符\nEnd\n\nNeed to add comments after each step. Ensure arrow formatting. Use \"→\" lines. Use indentation for decision branches maybe indent with tabs or spaces. The example uses tabs for indentation but we can use 4 spaces. Provide comments.\n\nLet's craft lines with appropriate spacing and comments.\n\nEnsure each line ends with `// 解釋/說明` in Chinese.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 s, t // 取得使用者提供的兩個字串  \n→ Decision: s 與 t 的長度是否相同? // 首先檢查長度，若不同即不是同構  \n Yes → Step 2: 初始化兩個空映射表 mapS 與 mapT // mapS 用於 s→t 的映射，mapT 用於 t→s 的映射  \n  → Step 3: 循環 i 從 0 到 len(s)-1  \n   → Step 4: 取出字符對 c1 = s[i] 與 c2 = t[i] // 逐位檢查對應字符  \n   → Decision: c1 是否已存在於 mapS? // 判斷 s 中字符是否已有映射  \n    Yes → Decision: mapS[c1] 是否等於 c2? // 檢查已存在映射是否與當前字符一致  \n     Yes → Decision: c2 是否已存在於 mapT? // 進一步檢查反向映射是否已存在  \n      Yes → Decision: mapT[c2] 是否等於 c1? // 確認一對一對應仍成立  \n       Yes → Step 5: 迴圈進行下一位 // 所有檢查通過，繼續下一個字符  \n       No → Step 6: 返回 False // 反向映射不一致，結束並回傳 false  \n     No → Step 7: mapT[c2] = c1 // 為 c2 建立新的反向映射  \n    No → Step 8: mapS[c1] = c2 // 為 c1 建立新的映射  \n     No → Step 9: mapT[c2] = c1 // 為 c2 建立新的反向映射  \n  → Step 10: 返回 True // 所有字符對應正確，結束並回傳 true  \n No → Step 11: 返回 False // 長度不同，直接回傳 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        \"\"\"判斷兩字串是否同構。\"\"\"\n        if len(s) != len(t):\n            return False\n        mapping_s_t = {}\n        mapping_t_s = {}\n        for c1, c2 in zip(s, t):\n            if c1 in mapping_s_t and mapping_s_t[c1] != c2:\n                return False\n            if c2 in mapping_t_s and mapping_t_s[c2] != c1:\n                return False\n            mapping_s_t[c1] = c2\n            mapping_t_s[c2] = c1\n        return True\n\ndef parse_input() -> tuple[str, str]:\n    \"\"\"從標準輸入取得兩個字串 s 與 t。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return \"\", \"\"\n\n    # 先嘗試從格式 's = \"...\" , t = \"...\"' 之中抓取兩個 quoted 字串\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n\n    # 若未抓到，假設每一行就是一個字串\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n\n    # 其餘情況只剩一個字串，直接返回\n    return data, \"\"\n\nif __name__ == \"__main__\":\n    s, t = parse_input()\n    sol = Solution()\n    result = sol.isIsomorphic(s, t)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"egg\", t = \"add\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"foo\", t = \"bar\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"paper\", t = \"title\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode412.json",
    "problem_index_in_file": 0,
    "title": "Fizz Buzz",
    "description_snippet": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Use Start, Decision, etc. The requirement: given integer n, produce array answer 1-indexed. Steps: initialize array of size n; loop i from 1 to n; for each i decide if divisible by 3 and 5, else 3, else 5, else string of i; assign to array[i]; end loop; return array. Provide lines with \"→\" etc. Each line includes a comment. Should use structure like \"Start\", \"→ Step: ...\", \"Decision: ...\", \"Yes →\", \"No →\". Need to be one line per step. Each line should be \"虛擬碼步驟 [space] // 解釋\". Use arrow for decisions.\n\nLet's write:\n\nStart // 程式開始\n→ Step 1: 初始化答案陣列 answer[1..n] // 建立大小為 n 的陣列\n→ Step 2: 針對 i 從 1 到 n 進行迴圈 // 開始索引 1 的迴圈\n    → Decision: i 能同時被 3 和 5 整除? // 檢查是否同時可被 3 和 5 整除\n        Yes → Step 3: answer[i] ← \"FizzBuzz\" // 設為 FizzBuzz\n        No  → Decision: i 能被 3 整除? // 檢查是否能被 3 整除\n            Yes → Step 4: answer[i] ← \"Fizz\" // 設為 Fizz\n            No  → Decision: i 能被 5 整除? // 檢查是否能被 5 整除\n                Yes → Step 5: answer[i] ← \"Buzz\" // 設為 Buzz\n                No  → Step 6: answer[i] ← string(i) // 轉為字串\n→ Step 7: 返回 answer // 回傳結果\nEnd // 程式結束\n\nWe need to make each line with arrow and comment. We need to use the format: \"虛擬碼步驟 // 解釋\". So each line we output as:\n\nStart // 程式開始執行\n→ Step 1: 初始化答案陣列 answer[1..n] // 建立大小為 n 的陣列\n→ Step 2: 針對 i 從 1 到 n 進行迴圈 // 開始索引 1 的迴圈\n    → Decision: i 能同時被 3 和 5 整除? // 檢查是否同時可被 3 和 5 整除\n        Yes → Step 3: answer[i] ← \"FizzBuzz\" // 設為 FizzBuzz\n        No  → Decision: i 能被 3 整除? // 檢查是否能被 3 整除\n            Yes → Step 4: answer[i] ← \"Fizz\" // 設為 Fizz\n            No  → Decision: i 能被 5 整除? // 檢查是否能被 5 整除\n                Yes → Step 5: answer[i] ← \"Buzz\" // 設為 Buzz\n                No  → Step 6: answer[i] ← string(i) // 轉為字串\n→ Step 7: 返回 answer // 回傳結果\nEnd // 程式執行結束\n\nMake sure indentations. Provide lines exactly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化答案陣列 answer[1..n] // 建立大小為 n 的陣列\n→ Step 2: 針對 i 從 1 到 n 進行迴圈 // 開始索引 1 的迴圈\n    → Decision: i 能同時被 3 和 5 整除? // 檢查是否同時可被 3 和 5 整除\n        Yes → Step 3: answer[i] ← \"FizzBuzz\" // 設為 FizzBuzz\n        No  → Decision: i 能被 3 整除? // 檢查是否能被 3 整除\n            Yes → Step 4: answer[i] ← \"Fizz\" // 設為 Fizz\n            No  → Decision: i 能被 5 整除? // 檢查是否能被 5 整除\n                Yes → Step 5: answer[i] ← \"Buzz\" // 設為 Buzz\n                No  → Step 6: answer[i] ← string(i) // 轉為字串\n→ Step 7: 返回 answer // 回傳結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def fizzBuzz(self, n: int):\n        res = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                res.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                res.append(\"Fizz\")\n            elif i % 5 == 0:\n                res.append(\"Buzz\")\n            else:\n                res.append(str(i))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        sys.exit()\n    n = int(match.group())\n    sol = Solution()\n    answer = sol.fizzBuzz(n)\n    print(json.dumps(answer))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"1\",\"2\",\"Fizz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\"]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode150.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Reverse Polish Notation",
    "description_snippet": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polis...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for evaluating RPN expression. We must follow format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. We'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化一個空堆疊 stack // 用於儲存操作數\n→ Step 2: 對 tokens 中的每個 token 進行遍歷 // 逐一處理\n\nBut we need to produce pseudo code step by step, with decisions for operator vs operand. Use Decision blocks. Also need to show division truncation toward zero. So we need to handle integer division with truncation toward zero, typical in languages like Python's int division? Actually truncation toward zero is same as C/C++ for integer division (when operands are ints, division truncates toward zero). In pseudocode, we might note that.\n\nWe need to produce virtual code only, no real code.\n\nUse Start, End, Decision. Use arrows. For each line, include space then // 解釋.\n\nLet's produce steps:\n\nStart\n→ Step 1: 建立空堆疊 stack // 用於存放操作數\n→ Step 2: 對每個 token 進行迭代 // 逐個處理\n    → Decision: token 是否為操作符? // 判斷是運算還是數值\n        Yes → Step 3: 取出 stack 兩個元素 op2, op1 // pop 兩個操作數\n        → Decision: token 為 '+'? // 判斷運算類型\n            Yes → Step 4: 計算 op1 + op2 // 加法\n            No → Decision: token 為 '-'? // 減法\n                Yes → Step 5: 計算 op1 - op2 // 減法\n                No → Decision: token 為 '*'? // 乘法\n                    Yes → Step 6: 計算 op1 * op2 // 乘法\n                    No → Decision: token 為 '/'? // 除法\n                        Yes → Step 7: 計算 trunc(op1 / op2) // 除法並截斷\n                        No → Step 8: 錯誤 // 不合法符號（理論上不會發生）\n        → Decision: token 為數字? // 如果不是操作符則為數值\n            Yes → Step 9: 將 token 轉為整數並 push 到 stack // 入棧\n→ Step 10: stack 中應剩一個元素 // 最終結果\n→ Step 11: 取出並返回該元素 // 結果\nEnd\n\nBut we need each line exactly: \"虛擬碼步驟 [space] // 解釋\". Use arrow lines with indentation maybe. We should follow sample format: \"→ Step 1: ...\" and indentation with spaces and indentation for decisions. For each decision block, indent lines within block.\n\nAlso note the indentation of arrow: we might indent with spaces to show hierarchy.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空堆疊 stack // 用於存放操作數  \n→ Step 2: 對 tokens 中的每個 token 進行遍歷 // 逐一處理  \n  → Decision: token 為運算符號? // 判斷是運算還是數值  \n   Yes → Step 3: 取出 stack 兩個元素 op2, op1 // 先 pop 出第二個與第一個操作數  \n    → Decision: token 為 '+'? // 判斷加法  \n     Yes → Step 4: 計算 op1 + op2 // 加法  \n     No → Decision: token 為 '-'? // 判斷減法  \n      Yes → Step 5: 計算 op1 - op2 // 減法  \n      No → Decision: token 為 '*'? // 判斷乘法  \n       Yes → Step 6: 計算 op1 * op2 // 乘法  \n       No → Decision: token 為 '/'? // 判斷除法  \n        Yes → Step 7: 計算 trunc(op1 / op2) // 除法並向零截斷  \n        No → Step 8: 錯誤 // 這裡不應發生，因為輸入有效  \n   No → Decision: token 為數字? // 非運算符即為操作數  \n    Yes → Step 9: 將 token 轉為整數並 push 到 stack // 入棧  \n→ Step 10: stack 中剩下唯一元素 // 最終計算結果  \n→ Step 11: 取出並返回該元素 // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                elif token == '/':\n                    # 向零取整\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取出列表部分並解析\n    try:\n        start = data.index('[')\n        tokens = ast.literal_eval(data[start:])\n    except Exception:\n        tokens = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.evalRPN(tokens)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "expected_output": "22",
          "success": true,
          "output": "22"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode90.json",
    "problem_index_in_file": 0,
    "title": "Subsets II",
    "description_snippet": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of an array that may contain duplicates, ensuring no duplicate subsets. Standard solution: sort array, backtrack, skip duplicates.\n\nWe need to output step-by-step virtual code lines, each line has \"→ Step X:\" etc, with explanation. Use Start, End, Decision. We need to describe algorithm steps line by line.\n\nWe must not output actual code, just virtual code.\n\nWe need to produce each line: virtual code step + // explanation.\n\nLet's design steps:\n\nStart\n→ Input nums array\n→ Sort nums to handle duplicates\n→ Initialize result list with empty subset\n→ Initialize current subset list empty\n→ Define backtrack function with index parameter\n→ Decision: if index equals length of nums? // end recursion\n    Yes → Add copy of current subset to result\n    No → // process current element\n    → Decision: if index > 0 and nums[index] == nums[index-1] and not used? // skip duplicates\n        Yes → Skip current element\n        No → \n            → Add nums[index] to current subset\n            → backtrack(index+1)\n            → Remove last element from current subset\n→ Call backtrack(0)\n→ Output result\nEnd\n\nBut need to maintain used flag for duplicates. Actually standard approach: when iterating over options, for i from start to len-1, if i>start and nums[i]==nums[i-1] skip.\n\nSince we need step-by-step, maybe simpler: recursion that builds subsets, each call loops over remaining indices.\n\nWe can do:\n\nDefine function dfs(start, path)\n→ Decision: Add path to result\n→ For i from start to n-1:\n    → Decision: if i > start and nums[i] == nums[i-1]? // skip duplicate starting positions\n        Yes → Continue\n    → Add nums[i] to path\n    → dfs(i+1, path)\n    → Remove last from path\n\nBut we need step-by-step lines. We can break into steps.\n\nLet's produce virtual code:\n\nStart // 開始\n→ Step 1: 輸入 nums 數組 // 取得輸入\n→ Step 2: 將 nums 進行升序排序 // 方便處理重複元素\n→ Step 3: 建立結果集合 result 為空列表 // 用於儲存所有子集\n→ Step 4: 定義遞迴函式 dfs(start, path) // 產生子集的核心\n    → Decision: 把當前 path 加入 result // 每一步都存一次子集\n        Yes → Step 5: result.append(copy_of(path)) // 將 path 複製後加入\n    → Decision: 如果 start 等於 nums.length? // 沒有剩餘元素可選\n        Yes → Step 6: return // 結束此遞迴分支\n        No  → Step 7: 循環 i 從 start 到 nums.length-1\n            → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 跳過重複起始元素\n                Yes → Step 8: continue // 不選取此元素\n                No  → Step 9: path.append(nums[i]) // 選取 nums[i]\n                    → Step 10: dfs(i+1, path) // 進一步遞迴\n                    → Step 11: path.pop() // 回溯移除最後一個\n→ Step 12: 呼叫 dfs(0, empty_path) // 開始遞迴\n→ Step 13: 輸出 result // 回傳所有子集\nEnd // 程式結束\n\nWe need to ensure each line is virtual code line with arrow or decision. Must follow format: \"Start\" and \"End\". Use arrow \"→\" for steps. Use \"Decision:\".\n\nWe need to include each step line.\n\nLet's format accordingly.\n\nWe should separate nested lines maybe indent? But format example didn't use indentation for nested steps; they used indent but not required. But we can keep each line starting with \"→\" or \"Decision:\".\n\nBetter to write like:\n\nStart // 程式開始執行\n→ Step 1: 輸入 nums 數組 // 取得輸入\n→ Step 2: 將 nums 進行升序排序 // 方便處理重複元素\n→ Step 3: 建立結果集合 result 為空列表 // 用於儲存所有子集\n→ Step 4: 定義遞迴函式 dfs(start, path) // 產生子集的核心\n→ Decision: 把當前 path 加入 result // 每一步都存一次子集\n    Yes → Step 5: result.append(copy_of(path)) // 將 path 複製後加入\n→ Decision: 如果 start 等於 nums.length? // 沒有剩餘元素可選\n    Yes → Step 6: return // 結束此遞迴分支\n    No  → Step 7: 循環 i 從 start 到 nums.length-1\n        → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 跳過重複起始元素\n            Yes → Step 8: continue // 不選取此元素\n            No  → Step 9: path.append(nums[i]) // 選取 nums[i]\n                → Step 10: dfs(i+1, path) // 進一步遞迴\n                → Step 11: path.pop() // 回溯移除最後一個\n→ Step 12: 呼叫 dfs(0, empty_path) // 開始遞迴\n→ Step 13: 輸出 result // 回傳所有子集\nEnd // 程式執行結束\n\nBut we need each line to be separate; nested lines may be considered separate lines. The example shows indent with lines. We can mimic.\n\nHowever, the requirement: each line must contain virtual code step and explanation separated by space. Use arrows etc. So each line is a single line.\n\nWe must not output actual code, just virtual steps.\n\nWe need to ensure each step line contains explanation. Also need to keep consistent pattern: \"Start\", \"→\", \"Decision:\".\n\nWe need to output all lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 nums 數組 // 取得輸入\n→ Step 2: 將 nums 進行升序排序 // 方便處理重複元素\n→ Step 3: 建立結果集合 result 為空列表 // 用於儲存所有子集\n→ Step 4: 定義遞迴函式 dfs(start, path) // 產生子集的核心\n→ Decision: 把當前 path 加入 result // 每一步都存一次子集\n    Yes → Step 5: result.append(copy_of(path)) // 將 path 複製後加入\n→ Decision: 如果 start 等於 nums.length? // 沒有剩餘元素可選\n    Yes → Step 6: return // 結束此遞迴分支\n    No  → Step 7: 循環 i 從 start 到 nums.length-1\n        → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 跳過重複起始元素\n            Yes → Step 8: continue // 不選取此元素\n            No  → Step 9: path.append(nums[i]) // 選取 nums[i]\n                → Step 10: dfs(i+1, path) // 進一步遞迴\n                → Step 11: path.pop() // 回溯移除最後一個\n→ Step 12: 呼叫 dfs(0, empty_path) // 開始遞迴\n→ Step 13: 輸出 result // 回傳所有子集\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nimport json\n\ndef subsets_with_dup(nums):\n    nums.sort()\n    res = []\n\n    def backtrack(start, path):\n        res.append(path.copy())\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(0, [])\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 移除可能的 \"nums =\" 前綴，並提取列表\n    if 'nums' in data:\n        match = re.search(r'\\[.*\\]', data)\n        list_str = match.group(0) if match else data\n    else:\n        list_str = data\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        nums = eval(list_str, {})\n\n    result = subsets_with_dup(nums)\n    # 直接輸出 JSON 格式，避免空格\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "success": true,
          "output": "[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode415.json",
    "problem_index_in_file": 0,
    "title": "Add Strings",
    "description_snippet": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for adding two large numbers represented as strings, without built-in big integer or direct conversion. Use manual addition with carry. Output steps as described.\n\nWe need to produce each line: virtual step + \"// explanation\". Use arrows. Format:\n\nStart // 程式開始執行\n→ Step 1: 初始化變數 i, j, carry, result //...\nWe need to consider strings, reverse iterate, or use indices. Use while loops. Decision points for carry and length.\n\nLet's produce typical algorithm: start from end of strings, iterate until both indices < 0 and carry==0, compute digit sum, add to result string (append char), then reverse at end.\n\nWe can produce virtual code:\n\nStart\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = \"\" // 初始化指標和累加器\n→ Step 2: while i >= 0 or j >= 0 or carry > 0: // 主迴圈\n    → Decision: i >= 0? // 判斷是否還有位數在 num1\n        Yes → digit1 = int(num1[i]) - int('0') // 取 num1 右邊位數\n        No  → digit1 = 0 // 無位數時視為 0\n    → Decision: j >= 0? // 判斷是否還有位數在 num2\n        Yes → digit2 = int(num2[j]) - int('0')\n        No  → digit2 = 0\n    → Step 3: sum = digit1 + digit2 + carry // 計算本位和\n    → Step 4: result = str(sum % 10) + result // 將本位結果加到前面\n    → Step 5: carry = sum // 10 // 更新進位\n    → Step 6: i = i - 1 // 移動到下一位\n    → Step 7: j = j - 1\nEnd // 返回結果\n\nBut need to keep each line as single line. Also use arrow for decisions and steps. For nested lines we can indent.\n\nBetter to produce each line with indentation and arrows. Use \"Decision:\" and \"Yes →\" etc. Let's write:\n\nStart // 程式開始執行\n→ Step 1: i ← len(num1) - 1 // num1 的最後一個索引\n→ Step 1: j ← len(num2) - 1 // num2 的最後一個索引\n→ Step 1: carry ← 0 // 初始化進位\n→ Step 1: result ← \"\" // 存放相加結果\n→ Step 2: while i ≥ 0 or j ≥ 0 or carry > 0: // 只要還有位數或進位，繼續\n    → Decision: i ≥ 0? // num1 還有未處理的位數\n        Yes → digit1 ← int(num1[i]) - int('0') // 取 num1 的位數\n        No  → digit1 ← 0 // 無位數時為 0\n    → Decision: j ≥ 0? // num2 還有未處理的位數\n        Yes → digit2 ← int(num2[j]) - int('0') // 取 num2 的位數\n        No  → digit2 ← 0 // 無位數時為 0\n    → Step 3: sum ← digit1 + digit2 + carry // 本位相加\n    → Step 4: result ← str(sum % 10) + result // 將本位結果加到前面\n    → Step 5: carry ← sum // 10 // 更新進位\n    → Step 6: i ← i - 1 // 移動到上一位\n    → Step 7: j ← j - 1 // 移動到上一位\nEnd // 程式執行結束\n\nBut we must maintain \"Step\" numbering consistent. We have Step 1 repeated multiple times. But that's okay.\n\nAlternatively we can combine Step 1 lines.\n\nBetter to output each line with consistent numbering. Let's write:\n\nStart // 程式開始執行\n→ Step 1: i ← len(num1) - 1 // 指向 num1 最右邊位\n→ Step 1: j ← len(num2) - 1 // 指向 num2 最右邊位\n→ Step 1: carry ← 0 // 初始化進位\n→ Step 1: result ← \"\" // 存儲相加後的字串\n→ Step 2: while i ≥ 0 or j ≥ 0 or carry > 0: // 有位數或進位則繼續\n    → Decision: i ≥ 0? // num1 還有位\n        Yes → digit1 ← int(num1[i]) - int('0') // 取得 num1 右位數\n        No  → digit1 ← 0 // 無位視為 0\n    → Decision: j ≥ 0? // num2 還有位\n        Yes → digit2 ← int(num2[j]) - int('0') // 取得 num2 右位數\n        No  → digit2 ← 0\n    → Step 3: sum ← digit1 + digit2 + carry // 本位和\n    → Step 4: result ← str(sum % 10) + result // 把本位結果加到前面\n    → Step 5: carry ← sum // 10 // 更新進位\n    → Step 6: i ← i - 1 // 移動至 num1 的上一位\n    → Step 7: j ← j - 1 // 移動至 num2 的上一位\nEnd // 程式結束，result 為相加結果\n\nBut we need to output each line as one line. For nested lines we indent them maybe with tabs? Format says \"逐行輸出\", each line must contain virtual code step and comment. For nested lines we can keep indentation but still separate lines.\n\nThus output will be:\n\nStart // 程式開始執行\n→ Step 1: i ← len(num1) - 1 // 指向 num1 最右邊位\n→ Step 1: j ← len(num2) - 1 // 指向 num2 最右邊位\n→ Step 1: carry ← 0 // 初始化進位\n→ Step 1: result ← \"\" // 存儲相加後的字串\n→ Step 2: while i ≥ 0 or j ≥ 0 or carry > 0: // 有位數或進位則繼續\n    → Decision: i ≥ 0? // num1 還有位\n        Yes → digit1 ← int(num1[i]) - int('0') // 取得 num1 右位數\n        No  → digit1 ← 0 // 無位視為 0\n    → Decision: j ≥ 0? // num2 還有位\n        Yes → digit2 ← int(num2[j]) - int('0') // 取得 num2 右位數\n        No  → digit2 ← 0\n    → Step 3: sum ← digit1 + digit2 + carry // 本位和\n    → Step 4: result ← str(sum % 10) + result // 把本位結果加到前面\n    → Step 5: carry ← sum // 10 // 更新進位\n    → Step 6: i ← i - 1 // 移動至 num1 的上一位\n    → Step 7: j ← j - 1 // 移動至 num2 的上一位\nEnd // 程式結束，result 為相加結果\n\nBut indentation with spaces: we must show arrow and Decision: etc. Indentation may be with tabs. But not required.\n\nHowever, each line may include arrow but inside nested lines we might include arrow again. For Decision lines, we need to show \"Decision: if i ≥ 0?\" and then \"Yes → ...\", \"No → ...\". Use indentation. Should we include \"Decision:\" as separate line? It's considered a line.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← len(num1) - 1 // 指向 num1 最右邊位  \n→ Step 1: j ← len(num2) - 1 // 指向 num2 最右邊位  \n→ Step 1: carry ← 0 // 初始化進位  \n→ Step 1: result ← \"\" // 存儲相加後的字串  \n→ Step 2: while i ≥ 0 or j ≥ 0 or carry > 0: // 有位數或進位則繼續  \n  Decision: i ≥ 0? // 判斷 num1 還有未處理的位數  \n   Yes → digit1 ← int(num1[i]) - int('0') // 取 num1 的右位數  \n   No  → digit1 ← 0 // 無位數時視為 0  \n  Decision: j ≥ 0? // 判斷 num2 還有未處理的位數  \n   Yes → digit2 ← int(num2[j]) - int('0') // 取 num2 的右位數  \n   No  → digit2 ← 0 // 無位數時視為 0  \n  Step 3: sum ← digit1 + digit2 + carry // 本位相加  \n  Step 4: result ← str(sum % 10) + result // 將本位結果加到前面  \n  Step 5: carry ← sum // 10 // 更新進位  \n  Step 6: i ← i - 1 // 移動至 num1 的上一位  \n  Step 7: j ← j - 1 // 移動至 num2 的上一位  \nEnd // 程式執行結束，result 為相加後的字串",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1, num2):\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(res[::-1])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Try to extract numbers from the format: num1 = \"...\" , num2 = \"...\"\n    match = re.search(r'num1\\s*=\\s*\"([^\"]+)\"\\s*,\\s*num2\\s*=\\s*\"([^\"]+)\"', data)\n    if match:\n        num1, num2 = match.group(1), match.group(2)\n    else:\n        # Fallback: split by whitespace or comma\n        tokens = re.split(r'[\\s,]+', data)\n        tokens = [t for t in tokens if t]  # remove empty strings\n        if len(tokens) >= 2:\n            num1, num2 = tokens[0], tokens[1]\n        else:\n            # If still not enough tokens, assume entire input is two numbers separated by space\n            parts = data.split()\n            if len(parts) == 2:\n                num1, num2 = parts[0], parts[1]\n            else:\n                # Unable to parse, exit gracefully\n                sys.exit()\n\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "success": true,
          "output": "\"134\""
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "success": true,
          "output": "\"533\""
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "\"0\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode440.json",
    "problem_index_in_file": 0,
    "title": "K-th Smallest in Lexicographical Order",
    "description_snippet": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n]....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm: given n and k, return kth lexicographically smallest integer in [1,n]. This is a known problem: find k-th smallest in lexicographical order. Approach: count steps between prefix and next prefix to skip entire subtrees. Use a while loop, compute next, steps, etc. We'll produce a pseudo-code.\n\nThe virtual code should be step by step, with Start, End, Decision, etc. Each line \"→\" arrow. We need to produce explanation after each line. Should not output actual code, just virtual code.\n\nLet's design algorithm:\n\nInput: n, k.\n\nLet current=1, k-- (since we start from 1). While k > 0: compute count = count of numbers between current and current+1 under n (the number of nodes in subtree). If count <= k: k -= count; current++ (move to next prefix); else: current *= 10; k-- (move to first child); (count as moving one step down). At the end, return current.\n\nWe need to compute count between prefix and next prefix: compute steps = 0; first = prefix; last = prefix + 1; while first <= n: steps += min(n+1, last) - first; first *= 10; last *= 10; return steps.\n\nWe'll produce virtual code accordingly.\n\nLet's produce lines:\n\nStart\n\n→ Input n, k // 取得 n 和 k\n\n→ Step 1: current = 1 // 初始化目前前綴為 1\n\n→ Step 2: k = k - 1 // 已經算進 1，剩餘步數\n\n→ Decision: k == 0? // 判斷是否已經是目標\n\n    Yes → End with return current // 若 k 為 0，返回 1\n\n    No  → Loop:  while k > 0\n\nWithin loop:\n\n    → Step 3: steps = count(current, n) // 計算以 current 為前綴的數字總數\n\n    → Decision: steps <= k? // 判斷是否能跳過整棵子樹\n\n        Yes → Step 4: k = k - steps // 跳過整棵子樹\n\n            → Step 5: current = current + 1 // 移至同層下個前綴\n\n        No  → Step 6: k = k - 1 // 走進子節點\n\n            → Step 7: current = current * 10 // 進入下一層子節點\n\nAfter loop ends:\n\n→ End // 返回 current\n\nWe also need to define count function, but as virtual code we can inline:\n\n→ Step 3a: Define count(prefix, n): // 計算前綴下所有數字個數\n\n    → Step 3b: first = prefix, last = prefix + 1\n\n    → Step 3c: steps = 0\n\n    → Loop: while first <= n\n\n        → Step 3d: steps = steps + min(n+1, last) - first\n\n        → Step 3e: first = first * 10\n\n        → Step 3f: last = last * 10\n\n    → Return steps\n\nWe can present that as separate sub-block.\n\nThe algorithm should be clear.\n\nLet's produce final output with lines, each line ends with // explanation.\n\nMake sure use arrow \"→\". Also use \"Decision:\" with Yes →, No →.\n\nWe need to include Start, End.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input n, k // 取得整數 n 與 k\n→ Step 2: current = 1 // 初始化目前前綴為 1\n→ Step 3: k = k - 1 // 已算進 1，剩餘需走的步數\n→ Decision: k == 0? // 是否已是目標數字\n    Yes → End // 若 k 為 0，直接回傳 current\n    No  → // 進入主迴圈尋找 k‑th 數字\n\n// ------------------------ 主迴圈 ------------------------\n→ Step 4: While k > 0 // 當仍有步數未走完\n    → Step 5: steps = count(current, n) // 計算以 current 為前綴的所有數字數量\n    → Decision: steps <= k? // 能否一次跳過整棵子樹？\n        Yes → // 跳過子樹\n            → Step 6: k = k - steps // 減去跳過的步數\n            → Step 7: current = current + 1 // 移至同層下一個前綴\n        No  → // 必須走進子節點\n            → Step 8: k = k - 1 // 走進子節點一層，減一步\n            → Step 9: current = current * 10 // 進入下一層子節點\n\nEnd // 程式執行結束，current 為第 k 個字典序數字\n\n// ------------------------ count 函式 ------------------------\n→ Step 10: Define count(prefix, n) // 計算前綴 prefix 下所有數字個數\n    → Step 11: first = prefix, last = prefix + 1\n    → Step 12: steps = 0\n    → Loop: while first <= n\n        → Step 13: steps = steps + min(n + 1, last) - first // 加上本層節點數量\n        → Step 14: first = first * 10 // 進入下一位\n        → Step 15: last = last * 10 // 對應下一位的範圍上界\n    → Return steps // 回傳計算出的數量\n\n// End of virtual code explanation",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        def count_prefix(prefix: int, limit: int) -> int:\n            cur, nxt = prefix, prefix + 1\n            cnt = 0\n            while cur <= limit:\n                cnt += min(limit + 1, nxt) - cur\n                cur *= 10\n                nxt *= 10\n            return cnt\n\n        curr = 1\n        k -= 1\n        while k > 0:\n            cnt = count_prefix(curr, n)\n            if k >= cnt:\n                k -= cnt\n                curr += 1\n            else:\n                k -= 1\n                curr *= 10\n        return curr\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n    else:\n        # 如果輸入格式是兩個整數以空格或換行分隔\n        parts = data.strip().split()\n        n, k = int(parts[0]), int(parts[1])\n    solution = Solution()\n    result = solution.findKthNumber(n, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode40.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum II",
    "description_snippet": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem is classic \"Combination Sum II\" where each candidate can be used once and combinations unique. So algorithm: sort candidates, backtrack with pruning, skip duplicates at same depth. We output virtual code line by line.\n\nWe need Start, End, Decision, etc. Use arrows.\n\nWe'll include steps: sort candidates, initialize result list, call backtrack with start index 0 and remaining target. Backtrack: if target == 0 add combination; if target < 0 return. Loop i from start to len(candidates)-1: if i>start and candidates[i]==candidates[i-1] skip (duplicate). Add candidate to current path, call backtrack(i+1, target - candidates[i]), then pop.\n\nWe'll output each line as \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\nWe must keep structure: Start, → Step, → Decision: etc.\n\nWe'll have nested decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 candidates 進行排序 // 方便後續去重  \n→ Step 2: 建立空的 result 列表 // 用來儲存所有合法組合  \n→ Step 3: 建立空的 path 列表 // 用來記錄目前遞迴階段的組合  \n→ Step 4: 呼叫 Backtrack(0, target) // 從索引 0 開始遞迴  \n\n// -------------------- Backtrack 函式 --------------------\n→ Decision: target == 0? // 檢查是否已達到目標和  \n    Yes → Step 5: 把 path 的複製加入 result // 成功組合加入結果  \n    No  → Decision: target < 0? // 若已超過目標和則回溯  \n        Yes → Step 6: Return // 超過目標和，結束此遞迴分支  \n        No  → Step 7: 初始化 i = start // 設定迴圈起始索引  \n\n→ Step 8: 循環 i 從 start 到 len(candidates)-1  \n    → Decision: i > start AND candidates[i] == candidates[i-1]? // 同層重複值檢查  \n        Yes → Step 9: Continue // 跳過重複的候選數，避免重複組合  \n        No  → Step 10: path.append(candidates[i]) // 加入目前候選數到組合  \n        → Step 11: Backtrack(i+1, target - candidates[i]) // 深入下一層遞迴  \n        → Step 12: path.pop() // 回溯，移除最後加入的候選數  \n\nEnd // 程式執行結束，result 中即為所有唯一組合\n\n(Note: 以上虛擬碼示例遵循逐行、解釋結構，並使用決策箭頭表示條件與流程分支。)",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        Find all unique combinations of candidates that sum to target.\n        Each candidate may be used at most once.\n        \"\"\"\n        candidates.sort()\n        res = []\n\n        def backtrack(start, path, total):\n            # If the current sum equals the target, store a copy of the path\n            if total == target:\n                res.append(list(path))\n                return\n            # If the sum exceeds the target, no need to proceed further\n            if total > target:\n                return\n            prev = None\n            for i in range(start, len(candidates)):\n                # Skip duplicates at the same depth\n                if prev is not None and candidates[i] == prev:\n                    continue\n                # Choose the current candidate and explore deeper\n                path.append(candidates[i])\n                backtrack(i + 1, path, total + candidates[i])\n                path.pop()\n                prev = candidates[i]\n\n        backtrack(0, [], 0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list of candidates and the target value\n    match = re.search(r'candidates\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)', data)\n    if not match:\n        print(\"[]\")\n        return\n\n    candidates_str = match.group(1)\n    target = int(match.group(2))\n\n    # Convert the string representation of the list into an actual list\n    candidates = eval(candidates_str)\n\n    solution = Solution()\n    result = solution.combinationSum2(candidates, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "success": true,
          "output": "[[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "success": true,
          "output": "[[1, 2, 2], [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode449.json",
    "problem_index_in_file": 0,
    "title": "Serialize and Deserialize BST",
    "description_snippet": "Serialization is converting a data structure or object into a sequence of bits so that it can be sto...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo code line by line, with each line: 虛擬碼步驟 + space + // 解釋. Use arrows, Start, End, Decision etc. Provide algorithm for serialization/deserialization of BST with compact string.\n\nWe can use preorder traversal with null markers omitted because BST property allows reconstruction. Use space-separated values. Or use delimiters. Provide serialization: pre-order list of values. Deserialization: use bounds to construct BST from preorder list. Provide pseudo code.\n\nWe need to output step by step. Let's craft lines. Use Start, End. Use Decision. Use arrow and indent.\n\nLet's produce lines:\n\nStart // 開始程序\n\n→ Step 1: 定義 TreeNode // 節點結構\n\n→ Step 2: 定義 serialize(root) // 序列化入口\n\n→ Decision: root 為空? // 判斷是否為空節點\n\n    Yes → Return 空字符串 // 空樹序列化為空字串\n\n    No  → Step 3: 初始化 list 為空陣列 // 用於存放節點值\n\n→ Step 4: 呼叫 preorder(root, list) // 進行前序遍歷\n\n→ Step 5: 將 list 以空格連接成字符串 str // 形成輸出串\n\n→ Step 6: Return str // 回傳序列化結果\n\n→ End // serialize 完成\n\nDefine preorder(node, list)\n\n→ Step 1: 如果 node 為空，回傳 // 前序遞迴結束\n\n→ Step 2: 將 node.val 加入 list // 記錄節點值\n\n→ Step 3: preorder(node.left, list) // 遞迴左子樹\n\n→ Step 4: preorder(node.right, list) // 遞迴右子樹\n\n→ End // preorder 完成\n\nDefine deserialize(data)\n\n→ Step 1: 如果 data 為空，回傳 null // 空字串代表空樹\n\n→ Step 2: 將 data 以空格拆分成陣列 values // 解析值\n\n→ Step 3: 將 values 轉為整數陣列 arr // 方便操作\n\n→ Step 4: 初始化 index 為 0 // 用於追蹤目前值位置\n\n→ Step 5: 呼叫 build(-∞, +∞) // 建立 BST\n\n→ Step 6: Return 生成的根節點\n\n→ End // deserialize 完成\n\nDefine build(lower, upper)\n\n→ Decision: index 等於 arr.length? // 是否已處理完所有值\n\n    Yes → Return null // 無更多節點\n\n    No  → Step 1: 值 val = arr[index] // 取得當前值\n\n→ Decision: val < lower 或 val > upper? // 檢查是否在允許範圍\n\n    Yes → Return null // 不屬於此子樹，退回\n\n    No  → Step 2: index += 1 // 移動到下一個值\n\n→ Step 3: 創建 node = new TreeNode(val) // 建立節點\n\n→ Step 4: node.left = build(lower, val) // 左子樹必小於 val\n\n→ Step 5: node.right = build(val, upper) // 右子樹必大於 val\n\n→ Step 6: Return node // 回傳節點\n\n→ End // build 完成\n\nWe must ensure each line ends with // explanation. Provide arrow lines and decisions.\n\nMake sure to follow format: \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow arrows with \"→\". Use indent? Not necessary. Provide proper indent for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TreeNode // 節點結構  \n→ Step 2: 定義 serialize(root) // 序列化入口  \n→ Decision: root 為空? // 判斷樹是否為空  \n  Yes → Return 空字符串 // 空樹序列化為空字串  \n  No  → Step 3: 初始化 list 為空陣列 // 用於存放節點值  \n→ Step 4: 呼叫 preorder(root, list) // 進行前序遍歷  \n→ Step 5: 將 list 以空格連接成字符串 str // 形成輸出串  \n→ Step 6: Return str // 回傳序列化結果  \n→ End // serialize 完成  \n\nDefine preorder(node, list) // 前序遞迴輔助函式  \n→ Step 1: 如果 node 為空，回傳 // 遞迴結束條件  \n→ Step 2: 將 node.val 加入 list // 記錄節點值  \n→ Step 3: preorder(node.left, list) // 遞迴左子樹  \n→ Step 4: preorder(node.right, list) // 遞迴右子樹  \n→ End // preorder 完成  \n\nDefine deserialize(data) // 反序列化入口  \n→ Step 1: 如果 data 為空，回傳 null // 空字串代表空樹  \n→ Step 2: 將 data 以空格拆分成陣列 values // 解析值  \n→ Step 3: 將 values 轉為整數陣列 arr // 方便後續操作  \n→ Step 4: 初始化 index 為 0 // 追蹤目前值位置  \n→ Step 5: 呼叫 build(-∞, +∞) // 建立 BST  \n→ Step 6: Return 生成的根節點 // 回傳樹根  \n→ End // deserialize 完成  \n\nDefine build(lower, upper) // 用範圍重建子樹  \n→ Decision: index 等於 arr.length? // 是否已處理完所有值  \n  Yes → Return null // 無更多節點  \n  No  → Step 1: 值 val = arr[index] // 取得當前值  \n→ Decision: val < lower 或 val > upper? // 檢查是否在允許範圍  \n  Yes → Return null // 此值不屬於本子樹，退回  \n  No  → Step 2: index += 1 // 移動到下一個值  \n→ Step 3: 創建 node = new TreeNode(val) // 建立節點  \n→ Step 4: node.left = build(lower, val) // 左子樹必小於 val  \n→ Step 5: node.right = build(val, upper) // 右子樹必大於 val  \n→ Step 6: Return node // 回傳節點  \n→ End // build 完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a BST to a single string using preorder traversal.\"\"\"\n        res = []\n        def preorder(node):\n            if not node:\n                return\n            res.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n        preorder(root)\n        return ','.join(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes the encoded string back to a BST.\"\"\"\n        if not data:\n            return None\n        preorder = list(map(int, data.split(',')))\n        def build(min_val, max_val):\n            if preorder and min_val < preorder[0] < max_val:\n                val = preorder.pop(0)\n                node = TreeNode(val)\n                node.left = build(min_val, val)\n                node.right = build(val, max_val)\n                return node\n            return None\n        return build(float('-inf'), float('inf'))\n\ndef insert_into_bst(root, val):\n    \"\"\"Helper to insert a value into a BST.\"\"\"\n    if root is None:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insert_into_bst(root.left, val)\n    else:\n        root.right = insert_into_bst(root.right, val)\n    return root\n\ndef build_bst_from_list(values):\n    \"\"\"Builds a BST by inserting values in the given order.\"\"\"\n    root = None\n    for v in values:\n        root = insert_into_bst(root, v)\n    return root\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print('[]')\n        return\n\n    # Extract the list part after '='\n    try:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n        values = ast.literal_eval(list_str)\n        if not isinstance(values, list):\n            raise ValueError\n    except Exception:\n        print('[]')\n        return\n\n    # Build BST from the input list\n    root = build_bst_from_list(values) if values else None\n\n    # Serialize and output\n    codec = Codec()\n    serialized = codec.serialize(root)\n    if serialized:\n        output = '[' + ','.join(serialized.split(',')) + ']'\n    else:\n        output = '[]'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "root = [2,1,3]",
          "expected_output": "[2,1,3]",
          "success": true,
          "output": "[2,1,3]"
        },
        {
          "example_index": 1,
          "input": "root = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode349.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanations. No actual code. Use Start, Decision, arrows. Provide line by line.\n\nWe need to include input arrays, intersection unique, any order. We can use hash set.\n\nSteps:\n\nStart\n→ Step 1: create setA from nums1 // unique elements from first array\n→ Step 2: create result set // to store intersection\n→ Step 3: iterate nums2\n→ Decision: element in setA? // check membership\n    Yes → add to result set // add unique\n    No → skip\n→ Step 4: convert result set to array // output\nEnd\n\nBut we need each line with explanation after //.\n\nLet's generate.\n\nRemember: arrow \"→\" at beginning of each step? Use \"→\" at start.\n\nAlso need Start, End.\n\nWe must output each line in order.\n\nLet's produce.\n\nAlso maybe mention convert to array.\n\nAlright.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 nums1 的每個元素加入 SetA // 取得 nums1 的唯一元素集合  \n→ Step 2: 初始化空 SetResult // 用於存放交集的唯一元素  \n→ Step 3: 遍歷 nums2 的每個元素 // 檢查 nums2 的每個值  \n→ Decision: 該元素是否存在於 SetA? // 判斷 nums2 的元素是否與 nums1 交集  \n  Yes → Step 4: 將該元素加入 SetResult // 把交集元素加入結果集合  \n  No  → Step 5: 跳過此元素 // 不是交集，直接忽略  \n→ Step 6: 將 SetResult 轉成陣列並返回 // 將唯一交集元素輸出為陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        # 將兩個陣列轉成集合後取交集，最後再轉成列表回傳\n        return list(set(nums1) & set(nums2))\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入字串，抓取 nums1 與 nums2 的列表文字\n    pattern = r'nums1\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*nums2\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, data)\n    if not match:\n        return\n\n    nums1_str, nums2_str = match.group(1), match.group(2)\n    # 使用 eval 將文字轉成實際的列表，輸入預期為合法的 Python 列表字面量\n    nums1 = eval(nums1_str)\n    nums2 = eval(nums2_str)\n\n    sol = Solution()\n    result = sol.intersection(nums1, nums2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "success": true,
          "output": "[9, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode416.json",
    "problem_index_in_file": 0,
    "title": "Partition Equal Subset Sum",
    "description_snippet": "Given an integer array nums, return true if you can partition the array into two subsets such that t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: subset sum partition. Use dynamic programming. Steps: start, compute total, if odd return false. target = total/2. DP boolean array of size target+1. dp[0] = true. For each num, iterate from target down to num: dp[j] = dp[j] || dp[j-num]. At end return dp[target]. Use virtual code lines with arrows.\n\nWe need to include \"Start\" line. Steps numbered? Use arrow notation. Provide explanation after //.\n\nWe should ensure each line has \"虛擬碼步驟\" followed by space then // explanation. \"虛擬碼步驟\" may be something like \"→ Step 1: ...\". Use the format as example. Include Decision for odd check.\n\nAlso, include End line.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: sum ← sum(nums) // 計算陣列所有元素的總和\n→ Decision: 如果 sum 為奇數? // 若總和為奇數則無法分割成相等子集\n    Yes → Step 2: 返回 false // 直接回傳 false\n    No  → Step 3: target ← sum / 2 // 計算每個子集的目標和\n→ Step 4: dp ← boolean array of size target+1 // 建立 DP 陣列\n→ Step 5: dp[0] ← true // 初始化 dp[0] 為 true\n→ Step 6: for each num in nums // 遍歷陣列中的每個數字\n    → Step 7: for j from target down to num // 從目標和回到 num\n        → Step 8: dp[j] ← dp[j] OR dp[j-num] // 更新 dp[j] 若能達成\n→ Step 9: return dp[target] // 回傳是否能達成目標和\nEnd // 程式執行結束\n\nBut need each line with arrow notation; use nested indentation for decisions.\n\nLet's format accordingly. Use \"Decision:\" with Yes→ and No→ lines. Also for loops, use arrow for each inner block.\n\nMake sure each line has \"→\" at start except Start and End? In example, Start and End lines have no arrow. Steps have \"→ Step ...\". Decisions have \"Decision:\" and then indent Yes→, No→.\n\nAlso loops are not explicitly required; we can use Step 6 and Step 7 lines with indentation to show nested loops.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sum ← sum(nums) // 計算陣列所有元素的總和  \n→ Decision: 如果 sum 為奇數? // 若總和為奇數則無法分割成相等子集  \n  Yes → Step 2: return false // 直接回傳 false  \n  No  → Step 3: target ← sum / 2 // 計算每個子集的目標和  \n→ Step 4: dp ← boolean array of size target+1 // 建立 DP 陣列  \n→ Step 5: dp[0] ← true // 初始化 dp[0] 為 true  \n→ Step 6: for each num in nums // 遍歷陣列中的每個數字  \n  → Step 7: for j from target down to num // 從目標和回到 num  \n    → Step 8: dp[j] ← dp[j] OR dp[j-num] // 更新 dp[j] 若能達成  \n→ Step 9: return dp[target] // 回傳是否能達成目標和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canPartition(self, nums):\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        target = total // 2\n\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n\n        return dp[target]\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到列表的起始和結束位置，並安全地解析為 Python 列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        raise ValueError(\"輸入格式錯誤，無法找到列表\")\n    nums = ast.literal_eval(data[start:end + 1])\n\n    result = Solution().canPartition(nums)\n    # 按照題目要求輸出 true / false\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,11,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,5]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode398.json",
    "problem_index_in_file": 0,
    "title": "Random Pick Index",
    "description_snippet": "Given an integer array nums with possible duplicates, randomly output the index of a given target nu...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step. The problem: given array nums with duplicates, pick random index of target. We need to implement Solution class with constructor storing nums, and pick method.\n\nIn virtual code, we need steps like Start, → Step: initialize, → Decision. We'll need to handle random picking. Approach: in constructor, store array. In pick, iterate and collect indices of target, then random choose one.\n\nAlternatively, use reservoir sampling to avoid storing indices. But for simplicity, we can just store indices list. But virtual code might show building list and picking random index.\n\nWe'll generate lines:\n\nStart\n→ Step 1: Initialize Solution with nums // store array\n→ End\n\nFor pick:\n\nStart\n→ Step 1: Initialize empty list indices // store positions\n→ Step 2: For each i in 0..len(nums)-1: // iterate array\n    → Decision: nums[i]==target? // check\n        Yes → Step 3: Append i to indices // collect\n        No  → Step 4: Continue // skip\n→ Step 5: Randomly select k from 0..len(indices)-1 // random index\n→ Step 6: Return indices[k] // return chosen index\nEnd\n\nBut we need to produce virtual code with arrows and decisions. Let's format accordingly.\n\nRemember to include // explanations after each line.\n\nWe should keep each line as \"虛擬碼步驟 [space] // 解釋\".\n\nAlso use arrows: \"→\" for step, \"Decision:\".\n\nWe can incorporate \"Yes →\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Store input array nums into member variable // 將傳入的陣列保存在物件屬性中  \nEnd // 建構子結束  \n\n---  \n\nStart // pick 方法執行  \n→ Step 1: 初始化空列表 indices // 用於保存所有目標值的位置  \n→ Step 2: 迭代遍歷 nums 中每個索引 i  \n    → Decision: nums[i] 是否等於 target? // 判斷目前元素是否為目標值  \n        Yes → Step 3: 將索引 i 加入 indices 列表 // 收集所有符合的索引  \n        No  → Step 4: 繼續迭代 // 忽略非目標值  \n→ Step 5: 計算 indices 的長度 n  \n→ Step 6: 生成隨機整數 k，範圍 0 ~ n-1 // 隨機選擇一個有效索引  \n→ Step 7: 返回 indices[k] // 回傳隨機挑選的目標索引  \nEnd // pick 方法結束",
      "generated_code": "import sys\nimport random\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"\n        把每個數字對應到它在陣列中的所有索引。\n        這樣就能在 pick 時直接取得所有可能的索引。\n        \"\"\"\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        隨機挑選 target 在陣列中的一個索引。\n        \"\"\"\n        return random.choice(self.indices[target])\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 把輸入分成兩部分：操作列表與參數列表\n    # 例如： '[\"Solution\",\"pick\",\"pick\"],[[[1,2,3]],[3],[2]]'\n    # 先找到第一個 '],' 位置，保證拆分在操作列表結束處\n    split_idx = data.find('],')\n    if split_idx == -1:\n        raise ValueError(\"Invalid input format\")\n    ops_str = data[:split_idx+1]      # 包含第一個列表\n    args_str = data[split_idx+2:].strip()  # 後續列表\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    # 執行操作\n    outputs = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])\n            outputs.append(None)  # 第一個輸出是 null\n        elif op == \"pick\":\n            res = obj.pick(arg[0])\n            outputs.append(res)\n\n    # 將結果格式化成 LeetCode 風格的輸出\n    formatted = []\n    for out in outputs:\n        if out is None:\n            formatted.append(\"null\")\n        else:\n            formatted.append(str(out))\n    print(\"[\" + \", \".join(formatted) + \"]\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,2,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 2, 0, 3]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode139.json",
    "problem_index_in_file": 0,
    "title": "Word Break",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a spac...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for word break problem using DP. Provide line-by-line steps with explanations. Use Start, End, Decision. Use → arrow. Should be in Traditional Chinese. Each line \"虛擬碼步驟\" then space then \"// 解釋/說明\".\n\nWe'll produce algorithm:\n\nStart\n→ Initialize dp array length s.length+1 with false // dp[i] indicates prefix up to i can be segmented\n→ Set dp[0] = true // empty string can be segmented\n→ Decision: 迴圈 i from 1 to n // iterate over string length\n    Yes → Decision: for each j from 0 to i-1 // check previous split\n        Yes → Decision: if dp[j] is true AND substring s[j:i] in wordDict\n            Yes → Step: set dp[i] = true // found valid split\n            Yes → Decision: if dp[i] == true // break inner loop\n                Yes → Step: Break inner loop // no need to check more j\n    No // after loops\n→ Decision: if dp[n] true? // check entire string\n    Yes → Step: Return true // can segment\n    No  → Step: Return false // cannot segment\nEnd\n\nAlso maybe we need to show dictionary set and substring extraction.\n\nWe'll produce step-by-step.\n\nNeed to use proper syntax: `Decision: 如果...` and use `Yes →`, `No →`.\n\nLet's craft.\n\nWe'll start:\n\nStart // 程式開始執行\n→ Step 1: 建立字典集合 wordSet = Set(wordDict) // 將字典轉成集合以便 O(1) 查找\n→ Step 2: 取得 s 長度 n = len(s) // 字串長度\n→ Step 3: 建立布林陣列 dp[n+1] 全為 false // dp[i] 代表前 i 個字是否可切分\n→ Step 4: 設定 dp[0] = true // 空字串可切分\n→ Decision: 迭代 i 從 1 到 n // 逐個判斷前 i 個字\n    Yes → Step 5: 初始化 j 從 0 到 i-1 // 依序嘗試切點\n        Yes → Decision: 如果 dp[j] 為 true 且 s[j:i] 存在於 wordSet\n            Yes → Step 6: 設定 dp[i] = true // 找到合法切分\n            Yes → Decision: 若 dp[i] 已為 true\n                Yes → Step 7: 跳出內層迴圈 // 不需再檢查其他 j\n    No // 內層迴圈結束\n→ Decision: 如果 dp[n] 為 true\n    Yes → Step 8: 回傳 true // s 可切分\n    No  → Step 9: 回傳 false // s 無法切分\nEnd // 程式結束\n\nNeed to ensure we use arrow formatting exactly: For decisions with Yes/No, indent lines accordingly. Use `→` before each step. Use `Decision:` lines. Provide explanation after `//`. Use Traditional Chinese.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典集合 wordSet = Set(wordDict) // 將字典轉成集合以便 O(1) 查找  \n→ Step 2: 取得 s 長度 n = len(s) // 字串長度  \n→ Step 3: 建立布林陣列 dp[n+1] 全為 false // dp[i] 代表前 i 個字是否可切分  \n→ Step 4: 設定 dp[0] = true // 空字串可切分  \n→ Decision: 迭代 i 從 1 到 n // 逐個判斷前 i 個字  \n    Yes → Step 5: 初始化 j 從 0 到 i-1 // 依序嘗試切點  \n        Yes → Decision: 如果 dp[j] 為 true 且 s[j:i] 存在於 wordSet  \n            Yes → Step 6: 設定 dp[i] = true // 找到合法切分  \n            Yes → Decision: 若 dp[i] 已為 true  \n                Yes → Step 7: 跳出內層迴圈 // 不需再檢查其他 j  \n    No // 內層迴圈結束  \n→ Decision: 如果 dp[n] 為 true  \n    Yes → Step 8: 回傳 true // s 可切分  \n    No  → Step 9: 回傳 false // s 無法切分  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(s)]\n\ndef parse_input(data: str):\n    # 提取 s 的值\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    s = s_match.group(1) if s_match else \"\"\n\n    # 提取 wordDict 的值\n    wd_match = re.search(r'wordDict\\s*=\\s*(\\[[^\\]]*\\])', data)\n    wd_str = wd_match.group(1) if wd_match else \"[]\"\n    word_dict = eval(wd_str)  # 轉換為列表\n    return s, word_dict\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s, word_dict = parse_input(raw)\n    result = Solution().wordBreak(s, word_dict)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode283.json",
    "problem_index_in_file": 0,
    "title": "Move Zeroes",
    "description_snippet": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for moving zeros to end in-place. Each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision, arrow etc. Ensure not produce actual code. Just steps. The steps will include variables: index_non_zero, i etc. Provide explanation.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化 index_non_zero = 0 // 用於指向下個非零元素應放置的位置\n→ For i from 0 to length(nums)-1: // 遍歷整個陣列\n    → Decision: 如果 nums[i] != 0? // 判斷當前元素是否為非零\n        Yes → Step 2: 將 nums[index_non_zero] = nums[i] // 將非零元素移到前面\n            → Step 3: index_non_zero = index_non_zero + 1 // 移動指標\n        No → Step 4: 跳過 // 零值不做處理\n→ Step 5: For j from index_non_zero to length(nums)-1: // 將剩餘位置填零\n    → Step 6: nums[j] = 0 // 填入零\nEnd\n\nNeed to format each line with arrow. Use arrow only at beginning of step lines: \"→\". For decisions: \"Decision:\" etc.\n\nLet's produce.\n\nAlso we need explanation comment after each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 index_non_zero = 0 // 用於指向下個非零元素應放置的位置  \n→ Decision: 循環 i 從 0 到 length(nums)-1? // 準備遍歷整個陣列  \n    Yes → Step 2: 如果 nums[i] != 0? // 判斷當前元素是否為非零  \n        Yes → Step 3: 將 nums[index_non_zero] = nums[i] // 把非零元素移到前面  \n        Yes → Step 4: index_non_zero = index_non_zero + 1 // 移動指標到下一個空位  \n        No  → Step 5: 跳過 // 零值不進行任何操作  \n    No  → End // 完成整個循環  \n→ Step 6: 循環 j 從 index_non_zero 到 length(nums)-1? // 將剩餘位置填零  \n    Yes → Step 7: nums[j] = 0 // 把空位設為零  \n    No  → End // 填零完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def moveZeroes(self, nums):\n        \"\"\"\n        Modify nums in-place to move all zeros to the end while preserving\n        the relative order of non-zero elements.\n        \"\"\"\n        zero_pos = 0  # Next position to place a non-zero element\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[zero_pos], nums[i] = nums[i], nums[zero_pos]\n                zero_pos += 1\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    # Expected input format: \"nums = [0,1,0,3,12]\"\n    try:\n        _, list_str = input_data.split('=', 1)\n    except ValueError:\n        # If the input does not contain '=', assume it is a raw list\n        list_str = input_data\n\n    # Safely evaluate the list string to a Python list\n    nums = ast.literal_eval(list_str.strip())\n\n    # Apply the algorithm\n    Solution().moveZeroes(nums)\n\n    # Output the modified list\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,0,3,12]",
          "expected_output": "[1,3,12,0,0]",
          "success": true,
          "output": "[1, 3, 12, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode650.json",
    "problem_index_in_file": 0,
    "title": "2 Keys Keyboard",
    "description_snippet": "There is only one character 'A' on the screen of a notepad. You can perform one of two operations on...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to compute minimal operations to get n A's. It's a known problem: minimal operations equal to sum of prime factors. The algorithm: while n > 1: find smallest factor i from 2 to sqrt(n); if none, n is prime -> add n to answer; break. else: answer += i; n /= i; repeat. Alternatively DP. But we need virtual code steps. Provide line by line with explanation.\n\nWe need to output each line with \"虛擬碼步驟 // 解釋\".\n\nUse Start, End, Decision.\n\nWe will create pseudo-code: Start -> Step: input n, set result=0. Then while n > 1: find factor. Decision: has factor? etc.\n\nLet's produce lines. Use arrow \"→\" for sequence.\n\nWe need no actual code, just steps.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 讀入整數 n // 取得目標 A 的數量\n→ Step 2: 初始化 result ← 0 // 用於累加操作數量\n→ Decision: n > 1? // 判斷是否還有需要處理的數字\n    Yes → Step 3: 找到 n 的最小質因子 factor // 尋找最小因子\n        → Decision: factor == n? // n 本身是否為質數\n            Yes → Step 4: result ← result + n // 直接加上 n\n            No  → Step 5: result ← result + factor // 加上找到的因子\n            No  → Step 6: n ← n / factor // 把 n 除以因子\n        → Decision: n > 1? // 仍然需要繼續分解\n            Yes → (跳回 Step 3)\n            No  → End // 完成\n    No → End // n 已經是 1，無需進一步操作\n\nBut need arrow and indentation.\n\nWe can do:\n\nStart // 程式開始執行\n→ Step 1: 讀入 n // 取得目標 A 數量\n→ Step 2: result ← 0 // 初始化操作總數\n→ Decision: n > 1? // 是否還有需要處理的數\n    Yes → Step 3: factor ← 2 // 初始因子\n        → Decision: factor * factor > n? // 檢查是否已超過 sqrt(n)\n            Yes → Step 4: factor ← n // n 是質數\n            No  → Decision: n mod factor == 0? // factor 是否為 n 的因子\n                Yes → Step 5: // 找到因子\n                    → Step 6: result ← result + factor // 加上因子\n                    → Step 7: n ← n / factor // 除以因子\n                No  → Step 8: factor ← factor + 1 // 迭代到下一個可能因子\n        → Decision: n > 1? // 仍需進一步分解\n            Yes → (回到 Step 3)\n            No  → End // 完成\n    No → End // n == 1 時結束\n\nBut that seems too detailed. We can compress.\n\nWe need to keep each line short but meaningful.\n\nAlso note use of arrows: \"→\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入整數 n // 取得目標 A 的數量  \n→ Step 2: result ← 0 // 初始化總操作數  \n→ Decision: n > 1? // 判斷是否仍有數字需處理  \n&nbsp;&nbsp;&nbsp;Yes → Step 3: factor ← 2 // 設定最小可能因子  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: factor * factor > n? // 檢查是否已超過 sqrt(n)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: factor ← n // n 本身為質數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: n mod factor == 0? // factor 是否為 n 的因子  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: result ← result + factor // 加上找到的因子  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 6: factor ← factor + 1 // 檢查下一個可能因子  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: n > 1? // 是否還需要繼續分解  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → (跳回 Step 3)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → End // 完成  \n&nbsp;&nbsp;&nbsp;No → End // n 已等於 1，無需進一步操作",
      "generated_code": "import sys\nimport re\n\ndef min_steps(n: int) -> int:\n    res = 0\n    d = 2\n    while n > 1:\n        while n % d == 0:\n            res += d\n            n //= d\n        d += 1\n    return res\n\ndef main():\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    result = min_steps(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode397.json",
    "problem_index_in_file": 0,
    "title": "Integer Replacement",
    "description_snippet": "Given a positive integer n, you can apply one of the following operations:\n\n1. If n is even, replace...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code, but step-by-step algorithm for minimal operations to reduce n to 1 using allowed operations: if even n → n/2; if odd → n±1. It's essentially the classic integer replacement problem. We need to produce virtual code describing algorithm (likely greedy/DP). Provide steps line by line. Use virtual code with arrows, decisions.\n\nWe must output in Chinese. Each line: virtual step + space + // explanation.\n\nStart // 程式開始執行\n→ Step: 定義變數 count = 0 // 初始化操作計數\n→ Step: 定義變數 current = n // 設定當前數值\n→ Decision: current 等於 1? // 檢查是否已達終點\n    Yes → End // 結束，操作數為 count\n    No  → \n        Decision: current 為偶數? // 判斷偶數\n            Yes → \n                → Step: current = current / 2 // 將偶數除以 2\n                → Step: count = count + 1 // 操作次數加 1\n            No  →\n                → Decision: current 等於 3 或 current 末位二進位為 1? // 特殊情況\n                    Yes →\n                        → Step: current = current - 1 // 取 -1\n                        → Step: count = count + 1\n                    No  →\n                        → Step: current = current + 1 // 取 +1\n                        → Step: count = count + 1\n        → Step: repeat loop // 重複判斷直到 current = 1\n\nBut we need to produce virtual code lines with Start/End. Use arrow for steps. Provide explanation for each line.\n\nBetter structure: Use a while loop? But virtual code: while current > 1: ... but we cannot show loops? But can show decision repeated.\n\nWe can show:\n\n→ Step: 直到 current = 1 為止\n    while current > 1:\n        if current even: current/=2\n        else: if current==3 or (current & 2) == 0: current-=1 else current+=1\n        count++\n\nBut use virtual code lines: We'll use Decision and loops.\n\nLet's design:\n\nStart // start\n→ Step: count = 0 // 初始化操作次數\n→ Step: current = n // 設定當前數值\n→ Decision: current == 1? // 檢查是否已達1\n    Yes → End // 結束\n    No  →\n        → Decision: current 為偶數? // 判斷是否為偶數\n            Yes →\n                → Step: current = current / 2 // 將偶數除以2\n                → Step: count += 1 // 計數加一\n                → Decision: current == 1? // 判斷是否結束\n                    Yes → End\n                    No  → ← 回到 Decision: current 為偶數? // 迴圈\n            No  →\n                → Decision: current == 3 或 (current & 2) == 0? // 根據位數決定加減\n                    Yes →\n                        → Step: current = current - 1 // 減1\n                        → Step: count += 1\n                    No  →\n                        → Step: current = current + 1 // 加1\n                        → Step: count += 1\n                → Decision: current == 1? // 判斷是否結束\n                    Yes → End\n                    No  → ← 回到 Decision: current 為偶數? // 迴圈\n\nBut need to produce \"逐行虛擬碼\" each line. Each line can contain nested decisions? Might be heavy.\n\nSimpler: Use while loop representation:\n\nStart // 程式開始執行\n→ Step: count = 0 // 初始化計數\n→ Step: current = n // 初始值\n→ Decision: current > 1? // 判斷是否已達 1\n    Yes →\n        → Step: current 為偶數? // 判斷偶數\n            Yes →\n                → Step: current = current / 2\n                → Step: count += 1\n            No  →\n                → Decision: current == 3 或 current 末位為 1? // 判斷加減\n                    Yes →\n                        → Step: current = current - 1\n                        → Step: count += 1\n                    No  →\n                        → Step: current = current + 1\n                        → Step: count += 1\n        → Step: 回到 Decision: current > 1? // 迴圈\n    No  →\n        → End // 結束\n\nBut still need to maintain the structure of loop.\n\nBetter to express with a \"While\" structure:\n\nStart\n→ Step: count = 0\n→ Step: current = n\n→ While current > 1:\n    → Decision: current 為偶數? \n        Yes → Step: current = current / 2; count += 1\n        No  → Decision: current == 3 或 (current & 2) == 0? \n                 Yes → Step: current -= 1; count += 1\n                 No  → Step: current += 1; count += 1\n→ End\n\nBut each line must have virtual code step + explanation. The \"While\" line can be considered a step. Then nested lines.\n\nWe need to ensure each line is separate, but we can indent. Use arrow for nested? We can use '→' for each line but nested lines can start with indent.\n\nOk final format:\n\nStart // 程式開始執行\n→ Step: count = 0 // 初始化操作次數\n→ Step: current = n // 將輸入值存入 current\n→ While current > 1: // 當 current 大於 1 時持續循環\n    → Decision: current 為偶數? // 判斷是否為偶數\n        Yes → Step: current = current / 2 // 偶數則除以 2\n              → Step: count += 1 // 操作次數加 1\n        No  → Decision: current == 3 或 (current & 2) == 0? // 特殊情況\n                Yes → Step: current -= 1 // 取 -1\n                     → Step: count += 1\n                No  → Step: current += 1 // 取 +1\n                     → Step: count += 1\n→ End // 當 current 變為 1 時結束，返回 count\n\nBut we need to include explanation after each line, separated by '//' . So for each line we need to write explanation. For nested lines we might include indentation. The example shows nested decisions with indent. So we can mimic.\n\nThus final answer: Provide virtual code lines with explanation.\n\nLet's produce final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: count = 0 // 初始化操作計數器\n→ Step: current = n // 將輸入的正整數存入 current\n→ While current > 1: // 當 current 大於 1 時持續循環\n    → Decision: current 為偶數? // 判斷 current 是否為偶數\n        Yes → Step: current = current / 2 // 偶數則除以 2\n              → Step: count += 1 // 操作次數加 1\n        No  → Decision: current == 3 或 (current & 2) == 0? // 選擇加 1 或減 1 的最佳方向\n                Yes → Step: current -= 1 // 取 -1\n                     → Step: count += 1\n                No  → Step: current += 1 // 取 +1\n                     → Step: count += 1\n→ End // current 變為 1，循環結束，返回 count 為最小操作數\n```",
      "generated_code": "import sys\nimport re\n\ndef integer_replacement(n: int) -> int:\n    \"\"\"Return the minimum number of operations to reduce n to 1.\"\"\"\n    count = 0\n    while n != 1:\n        if n % 2 == 0:          # n is even\n            n //= 2\n        else:                    # n is odd\n            # For odd numbers, choose +/- 1 to minimize future steps\n            if n == 3 or ((n >> 1) & 1) == 0:\n                n -= 1\n            else:\n                n += 1\n        count += 1\n    return count\n\ndef main() -> None:\n    \"\"\"Read integer from stdin, compute result, print to stdout.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the first integer found in the input\n    match = re.search(r'-?\\d+', data)\n    if match:\n        n = int(match.group())\n        print(integer_replacement(n))\n    else:\n        print(\"No integer found in input\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 8",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode387.json",
    "problem_index_in_file": 0,
    "title": "First Unique Character in a String",
    "description_snippet": "Given a string s, find the first non-repeating character in it and return its index. If it does not ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code lines. For problem: find first non-repeating char in string s and return its index or -1. Let's design algorithm: use map to count characters. First pass to count. Second pass to find first char with count 1, return index. If none return -1.\n\nUse Start, End, Decision, etc. Provide each line: \"Start // 程式開始執行\", \"→ Step 1: 初始化計數字典 freq // 用於存儲每個字符出現次數\", \"→ Step 2: for 每個字符 c in s with索引 i // 遍歷字符串並計數\", \"    → Step 3: freq[c] = freq.get(c,0)+1 // 更新計數\", etc. But we need arrow and decision maybe.\n\nLet's produce:\n\nStart\n→ Step 1: 定義空字典 freq // 用於存儲字符頻率\n→ Step 2: for 每個字符 c 在 s 之中 // 第一遍遍歷計算頻率\n    → Step 3: freq[c] = freq.get(c,0)+1 // 更新頻次\n→ Step 4: for 每個字符 c 以及其索引 i 在 s 之中 // 第二遍遍歷尋找第一個頻次為1的字符\n    → Decision: freq[c] == 1? // 檢查此字符是否只出現一次\n        Yes → Step 5: 返回 i // 找到第一個非重複字符的索引\n        No  → (繼續迴圈)\n→ Step 6: 返回 -1 // 若無非重複字符，返回 -1\nEnd\n\nBut we need to include arrows for decisions and steps. Provide explanation after each line. Ensure format: \"Start // ...\" etc.\n\nUse \"Yes →\" and \"No →\" for decisions. For step inside decision we can indent.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 freq // 用於儲存每個字符的出現次數  \n→ Step 2: 遍歷字符串 s 的每個字符 c 以及其索引 i // 第一遍遍歷以計算頻率  \n  → Step 3: freq[c] = freq.get(c, 0) + 1 // 更新字符 c 的頻率  \n→ Step 4: 再次遍歷字符串 s 的每個字符 c 以及其索引 i // 第二遍遍歷尋找第一個非重複字符  \n  → Decision: freq[c] == 1? // 判斷字符 c 是否只出現一次  \n   Yes → Step 5: 返回 i // 找到第一個非重複字符，返回其索引  \n   No  → (繼續迴圈) // 否則繼續檢查下一個字符  \n→ Step 6: 返回 -1 // 若整個字符串都沒有非重複字符，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport collections\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        \"\"\"\n        Return the index of the first non-repeating character in s.\n        If none exists, return -1.\n        \"\"\"\n        # Count frequency of each character\n        freq = collections.Counter(s)\n        # Find first character with frequency 1\n        for idx, ch in enumerate(s):\n            if freq[ch] == 1:\n                return idx\n        return -1\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Parse the raw input string to extract the actual string value.\n    Handles cases like:\n      - just the string: \"leetcode\"\n      - with a label and quotes: s = \"leetcode\"\n    \"\"\"\n    data = data.strip()\n    # If the string contains quotes, extract the part inside the first pair of quotes\n    if '\"' in data:\n        start = data.find('\"')\n        end = data.rfind('\"')\n        if start != -1 and end != -1 and end > start:\n            return data[start+1:end]\n    # Otherwise, return the trimmed data itself\n    return data\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    sol = Solution()\n    result = sol.firstUniqChar(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "s = \"loveleetcode\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"aabb\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode697.json",
    "problem_index_in_file": 0,
    "title": "Degree of an Array",
    "description_snippet": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the ma...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for solution: find degree and min length subarray with same degree. Use maps: freq, first index, last index. Compute degree = max freq. For each num with freq == degree, compute last - first +1; min length. Steps: input array, initialize maps, iterate, compute degree, compute minLen, output. Use Start, End, Decision. We'll output lines as per format. Let's produce.\n\nWe must produce \"虛擬碼步驟 // 解釋\". Each step line starts with something like \"Start\", \"→ Step 1: ...\", \"→ Decision: ...\" etc.\n\nOk. Let's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義空字典 freq, first, last // 初始化頻率與首尾索引儲存\n→ Step 2: degree ← 0 // 記錄全陣列最大頻率\n→ Step 3: minLen ← Infinity // 初始最短子陣列長度\n→ Step 4: for idx, val in enumerate(nums): // 遍歷陣列\n    → Step 5: freq[val] ← freq.get(val, 0) + 1 // 更新頻率\n    → Step 6: if val not in first: first[val] ← idx // 記錄首次出現位置\n    → Step 7: last[val] ← idx // 更新最後出現位置\n→ Step 8: if freq[val] > degree: degree ← freq[val] // 更新最大頻率\n→ Step 9: // 完成遍歷後，degree 為全陣列度\n→ Decision: 需要找同度子陣列嗎? // 檢查是否存在頻率等於 degree 的元素\n    Yes → Step 10: for val, cnt in freq.items(): // 遍歷所有元素\n        → Decision: cnt == degree? // 判斷是否是度元素\n            Yes → Step 11: length ← last[val] - first[val] + 1 // 計算此元素子陣列長度\n            → Step 12: if length < minLen: minLen ← length // 更新最短長度\n            No  → // 忽略非度元素\n→ Step 13: output minLen // 回傳最短子陣列長度\nEnd // 程式執行結束\n\nWe need to ensure proper indentation. Use indentation via spaces? Use arrow and indentation? The example used indentation: \"Decision:\" then \"Yes →\", \"No →\". For nested loops, we indent under previous step. Let's format with leading spaces. Use spaces to indent lines under loops/decision.\n\nWe'll produce as final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義空字典 freq, first, last // 初始化頻率與首尾索引儲存\n→ Step 2: degree ← 0 // 記錄全陣列最大頻率\n→ Step 3: minLen ← Infinity // 初始最短子陣列長度\n→ Step 4: for idx, val in enumerate(nums): // 遍歷陣列\n    → Step 5: freq[val] ← freq.get(val, 0) + 1 // 更新頻率\n    → Step 6: if val not in first: first[val] ← idx // 記錄首次出現位置\n    → Step 7: last[val] ← idx // 更新最後出現位置\n    → Step 8: if freq[val] > degree: degree ← freq[val] // 更新最大頻率\n→ Step 9: // 完成遍歷後，degree 為全陣列度\n→ Decision: 需要找同度子陣列嗎? // 判斷是否存在頻率等於 degree 的元素\n    Yes → Step 10: for val, cnt in freq.items(): // 遍歷所有元素\n        → Decision: cnt == degree? // 判斷是否是度元素\n            Yes → Step 11: length ← last[val] - first[val] + 1 // 計算此元素子陣列長度\n            → Step 12: if length < minLen: minLen ← length // 更新最短長度\n            No  → // 忽略非度元素\n→ Step 13: output minLen // 回傳最短子陣列長度\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def findShortestSubArray(self, nums):\n        \"\"\"\n        找到與整個陣列相同度數的最短連續子陣列長度。\n        \"\"\"\n        left, right, count = {}, {}, {}\n        for i, num in enumerate(nums):\n            if num not in left:\n                left[num] = i          # 記錄第一次出現的索引\n            right[num] = i             # 更新最後一次出現的索引\n            count[num] = count.get(num, 0) + 1\n\n        degree = max(count.values())  # 整個陣列的度數\n        min_length = float('inf')\n\n        for num in count:\n            if count[num] == degree:\n                length = right[num] - left[num] + 1\n                if length < min_length:\n                    min_length = length\n\n        return min_length\n\ndef parse_input(data: str):\n    \"\"\"\n    將標準輸入中的字串轉成 Python list。\n    支援 'nums = [1,2,3]' 以及直接 '[1,2,3]' 的格式。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # 如果包含 'nums' 文字，去除它\n    if 'nums' in data:\n        data = re.sub(r'^\\s*nums\\s*=\\s*', '', data)\n    try:\n        nums = eval(data, {\"__builtins__\": None}, {})\n    except Exception:\n        # 若 eval 失敗，返回空列表\n        nums = []\n    return nums\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    if not nums:\n        return\n    sol = Solution()\n    result = sol.findShortestSubArray(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,2,3,1,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode503.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element II",
    "description_snippet": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Should reflect algorithm: next greater element in circular array. Use stack to process. Steps: initialize result array, stack holds indices. Loop twice array length, process indices modulo n. For each index, while stack not empty and nums[i] > nums[stack.top], set result[stack.top]=nums[i], pop. Then push i onto stack. After loop, remaining indices have -1 already. Return result.\n\nWe'll produce virtual code lines accordingly.\n\nLet's produce: Start, Step 1: initialize variables, Step 2: iterate twice length, etc. Use Decision for while condition.\n\nBe careful: \"虛擬碼步驟\" should be line content. Use arrow for flow. Include \"Decision:\" for loops.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n = nums.length // 取得陣列長度  \n→ Step 2: 建立 result 陣列長度 n 並預設值為 -1 // 初始所有結果為 -1  \n→ Step 3: 建立空堆疊 stack // 用於儲存待解決元素的索引  \n→ Step 4: 迴圈 i 從 0 到 2*n-1 // 兩次遍歷以處理循環  \n  Decision: i < 2*n? // 是否仍在兩次遍歷範圍內  \n   Yes → Step 5: 計算 idx = i mod n // 取得真實陣列索引  \n    Decision: stack 不是空? // 堆疊是否有待處理元素  \n     Yes → Decision: nums[idx] > nums[stack.top]? // 新元素是否比堆疊頂大  \n       Yes → Step 6: 設定 result[stack.top] = nums[idx] // 找到下一個較大值  \n        → Step 7: pop stack // 從堆疊中移除已解決的索引  \n        → Decision: nums[idx] > nums[stack.top]? // 仍有較大值可解決  \n          Yes → repeat Step 6-7  \n          No → End of while  \n       No → End of while  \n       No → End of while  \n       → Step 8: push idx onto stack // 將目前索引加入堆疊等待解決  \n       → End of if-else  \n       → End of while  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \n       → End of if-else  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def nextGreaterElements(self, nums):\n        n = len(nums)\n        res = [-1] * n\n        stack = []\n        for i in range(2 * n):\n            while stack and nums[stack[-1]] < nums[i % n]:\n                res[stack.pop()] = nums[i % n]\n            if i < n:\n                stack.append(i)\n        return res\n\ndef parse_input(input_str):\n    \"\"\"從輸入字串中擷取列表，例如 'nums = [1,2,1]'\"\"\"\n    match = re.search(r'\\[.*\\]', input_str)\n    if not match:\n        raise ValueError(\"無法找到列表格式的輸入\")\n    return ast.literal_eval(match.group())\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.nextGreaterElements(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1]",
          "expected_output": "[2,-1,2]",
          "success": true,
          "output": "[2, -1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,3]",
          "expected_output": "[2,3,4,-1,4]",
          "success": true,
          "output": "[2, 3, 4, -1, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode120.json",
    "problem_index_in_file": 0,
    "title": "Triangle",
    "description_snippet": "Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation for algorithm: minimum path sum in triangle array. Use dynamic programming. Steps: Start, iterate rows from bottom to top, update array, final answer top[0]. Virtual code lines with arrows and decisions. Probably no decisions needed besides loop and final output. Provide explanation per line. We'll produce something like:\n\nStart // program start\n→ Step 1: Initialize variable triangle (given)\n→ Decision: Check triangle empty? // if empty return 0\n   Yes → Step 2: Output 0 // no triangle\n   No  → Step 3: Set n = number of rows\n→ Step 4: For i from n-2 down to 0 // start from second last row\n   → Step 5: For j from 0 to i\n      → Step 6: triangle[i][j] = triangle[i][j] + min(triangle[i+1][j], triangle[i+1][j+1]) // update with min path\n→ Step 7: Output triangle[0][0] // result\nEnd\n\nMake sure each line has arrow? Use → Step. For loop we might include arrow to step 5. We'll use indentation. Use arrows only for start, decision, steps, etc. Provide explanation after //.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得三角陣列 triangle // 讀入給定的三角形資料  \n→ Decision: triangle 是否為空? // 檢查是否沒有資料  \n    Yes → Step 2: 輸出 0 // 沒有三角形時結果為 0  \n    No  → Step 3: 設定 n = triangle 的行數 // 取得行數以作迴圈基準  \n→ Step 4: 從第 n-2 行往上迴圈至第 0 行 // 從倒數第二行開始向上累計最小路徑  \n    → Step 5: 針對每行 i 的每個索引 j（0 ≤ j ≤ i）  \n        → Step 6: triangle[i][j] = triangle[i][j] + min(triangle[i+1][j], triangle[i+1][j+1]) // 加上下一行相鄰兩個位置的最小累加值  \n→ Step 7: 輸出 triangle[0][0] // 最上方已經包含整個三角形的最小路徑總和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef minimum_total(triangle):\n    \"\"\"Return the minimum path sum from top to bottom of a triangle.\"\"\"\n    if not triangle:                # 空三角形直接回傳 0\n        return 0\n\n    n = len(triangle)\n    dp = triangle[-1][:]            # 先用最底層的數字做起點\n\n    # 從倒數第二層往上更新 dp，計算到目前層的最小路徑總和\n    for i in range(n - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n\n    return dp[0]                    # 最上層即為整體最小路徑總和\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將「triangle = [[...]]」之類的字串轉成真正的 list\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    triangle = ast.literal_eval(expr)\n\n    result = minimum_total(triangle)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        },
        {
          "example_index": 1,
          "input": "triangle = [[-10]]",
          "expected_output": "-10",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode506.json",
    "problem_index_in_file": 0,
    "title": "Relative Ranks",
    "description_snippet": "You are given an integer array score of size n, where score[i] is the score of the i_th athlete in a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with each line followed by comment, using Start, End, Decision, arrow. Provide steps to solve: get array, create pair of score with index, sort descending, iterate assign rank string: Gold/Silver/Bronze/number. Store in result array. Output.\n\nWe must not output actual code. Just virtual steps. Provide per line.\n\nLet's craft.\n\nStart\n\n→ Step 1: Create list of pairs (score, index) from input array // 取得分數與原始索引\n\n→ Decision: 是否需要排序? // 確認有足夠數據進行排名\n\n    Yes → Step 2: Sort pairs in descending order by score // 依分數從高到低排序\n\n→ Step 3: 初始化結果陣列 answer size n // 建立輸出儲存\n\n→ Step 4: For each pair in sorted list with position pos (starting 0)\n    // 遍歷排序後的順序，pos 是位置索引\n\n    → Decision: pos 是否為 0? // 判斷是否第一名\n\n        Yes → Step 5: answer[original_index] = \"Gold Medal\" // 第一名給金牌\n\n        No  → Decision: pos 是否為 1? // 判斷是否第二名\n\n            Yes → Step 6: answer[original_index] = \"Silver Medal\" // 第二名給銀牌\n\n            No  → Decision: pos 是否為 2? // 判斷是否第三名\n\n                Yes → Step 7: answer[original_index] = \"Bronze Medal\" // 第三名給銅牌\n\n                No  → Step 8: answer[original_index] = (pos+1).toString() // 其餘給排名數字\n\n→ End // 結束流程，返回 answer 陣列\n\nBut need to format each line: \"虛擬碼步驟 // 解釋\". Use \"Start\" line etc.\n\nLet's produce each step as separate line, with arrow for steps after Decision? The format example shows indentation for nested branches. Use \"→\" for step lines, \"Decision:\" lines with Yes→ and No→ inside. Let's structure.\n\nStart // 程式開始執行\n\n→ Step 1: 建立 (score, index) 列表 // 將每位選手的分數與其索引配對\n\n→ Decision: 是否要排序? // 檢查是否需要根據分數排序\n\n    Yes → Step 2: 按 score 降序排序 pairs // 依分數由高到低排序\n\n→ Step 3: 初始化 answer 陣列長度為 n // 用於存放每位選手的排名\n\n→ Step 4: 循環遍歷排序後的 pairs，pos 從 0 開始\n    // pos 表示名次位置，original_index 為原始索引\n\n    → Decision: pos == 0? // 判斷是否第一名\n        Yes → Step 5: answer[original_index] = \"Gold Medal\" // 第一名獲得金牌\n\n        No  → Decision: pos == 1? // 判斷是否第二名\n            Yes → Step 6: answer[original_index] = \"Silver Medal\" // 第二名獲得銀牌\n\n            No  → Decision: pos == 2? // 判斷是否第三名\n                Yes → Step 7: answer[original_index] = \"Bronze Medal\" // 第三名獲得銅牌\n\n                No  → Step 8: answer[original_index] = (pos+1).toString() // 其餘名次直接使用名次數字\n\n→ End // 程式執行結束，返回 answer\n\nBut each line must have the \"虛擬碼步驟\" and comment separated by space and //.\n\nWe need to include the indentation for nested lines.\n\nLet's output lines exactly.\n\nAlso for Decision lines, we should write \"Decision: ... ?\" as per format. Example: \"Decision: 如果數字大於 0?\".\n\nSo we can write: \"Decision: pos == 0?\" etc.\n\nMake sure each line ends with comment.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 (score, index) 列表 // 將每位選手的分數與其索引配對  \n→ Decision: 是否要排序? // 檢查是否需要根據分數排序  \n  Yes → Step 2: 按 score 降序排序 pairs // 依分數由高到低排序  \n→ Step 3: 初始化 answer 陣列長度為 n // 用於存放每位選手的排名  \n→ Step 4: 循環遍歷排序後的 pairs，pos 從 0 開始  \n  // pos 表示名次位置，original_index 為原始索引  \n  Decision: pos == 0? // 判斷是否第一名  \n   Yes → Step 5: answer[original_index] = \"Gold Medal\" // 第一名獲得金牌  \n   No → Decision: pos == 1? // 判斷是否第二名  \n    Yes → Step 6: answer[original_index] = \"Silver Medal\" // 第二名獲得銀牌  \n    No → Decision: pos == 2? // 判斷是否第三名  \n     Yes → Step 7: answer[original_index] = \"Bronze Medal\" // 第三名獲得銅牌  \n     No → Step 8: answer[original_index] = (pos+1).toString() // 其餘名次直接使用名次數字  \nEnd // 程式執行結束，返回 answer",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass Solution:\n    def findRelativeRanks(self, score):\n        if not score:\n            return []\n        sorted_scores = sorted(score, reverse=True)\n        rank_map = {}\n        for i, s in enumerate(sorted_scores):\n            if i == 0:\n                rank_map[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_map[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_map[s] = \"Bronze Medal\"\n            else:\n                rank_map[s] = str(i + 1)\n        return [rank_map[s] for s in score]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse the input list; supports formats like \"[5,4,3]\" or \"5 4 3\"\n    try:\n        score = ast.literal_eval(data)\n    except Exception:\n        # fallback: split by whitespace\n        score = list(map(int, data.split()))\n    sol = Solution()\n    answer = sol.findRelativeRanks(score)\n    # Use json.dumps to output with double quotes as in the examples\n    print(json.dumps(answer))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[5,4,3,2,1]",
          "expected_output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]",
          "success": true,
          "output": "[\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]"
        },
        {
          "example_index": 1,
          "input": "[10,3,8,9,4]",
          "expected_output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]",
          "success": true,
          "output": "[\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode451.json",
    "problem_index_in_file": 0,
    "title": "Sort Characters By Frequency",
    "description_snippet": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequenc...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Steps: start, input string, count frequencies (map), create list of pairs char freq, sort by freq descending, build result string by repeating char freq times. Output result. Use virtual code arrow syntax.\n\nWe must not output actual code. Just steps. Provide each line with explanation after //.\n\nNeed to ensure use \"Start\", \"End\", \"Decision:\" arrows like example. Use \"Step\" maybe. Use \"→\" arrows.\n\nWe must include \"→ Decision:\" if condition. Probably only need decisions for tie? Not needed. But maybe for sorting? Not needed.\n\nWe can still include decision step for checking if frequency map empty? Probably not.\n\nJust linear steps.\n\nLet's produce:\n\nStart\n→ Step 1: 取得輸入字串 s // 從使用者取得原始字串\n→ Step 2: 初始化頻率映射 freqMap // 用於計算各字元出現次數\n→ Step 3: 迭代字串 s，對每個字元 c 增加 freqMap[c]  // 統計頻率\n→ Step 4: 建立字元-頻率對列表 freqList 從 freqMap // 方便排序\n→ Step 5: 排序 freqList 按頻率降序 // 使高頻字元排前面\n→ Step 6: 初始化空結果字串 result // 用於組裝輸出\n→ Step 7: 迭代 freqList，每個 (c, f) 重複 c f 次加入 result // 重複字元以構成最終字串\n→ Step 8: 輸出 result // 回傳排序後的字串\nEnd\n\nMaybe use arrows for each step: \"→ Step ...\". But example uses \"→ Step 1: ...\" preceded by arrow. Also \"Start\" not arrow. We'll follow that.\n\nInclude comments after //.\n\nMake sure each line has no code syntax. Use plain text like \"Step 1:\". Fine.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 s // 從使用者取得原始字串\n→ Step 2: 初始化頻率映射 freqMap // 用於計算各字元出現次數\n→ Step 3: 迭代字串 s，對每個字元 c 增加 freqMap[c] // 統計頻率\n→ Step 4: 建立字元-頻率對列表 freqList 從 freqMap // 方便排序\n→ Step 5: 排序 freqList 按頻率降序 // 使高頻字元排前面\n→ Step 6: 初始化空結果字串 result // 用於組裝輸出\n→ Step 7: 迭代 freqList，每個 (c, f) 重複 c f 次加入 result // 重複字元以構成最終字串\n→ Step 8: 輸出 result // 回傳排序後的字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"Return a string sorted by decreasing character frequency.\"\"\"\n    freq = Counter(s)\n    # most_common() returns pairs sorted by frequency descending\n    return ''.join(char * count for char, count in freq.most_common())\n\nif __name__ == \"__main__\":\n    # Read the whole input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Extract the string inside the first pair of double quotes,\n    # if they exist; otherwise use the whole input as the string.\n    first_quote = raw_input.find('\"')\n    if first_quote != -1:\n        second_quote = raw_input.find('\"', first_quote + 1)\n        if second_quote != -1:\n            s = raw_input[first_quote + 1:second_quote]\n        else:\n            s = raw_input[first_quote + 1:]\n    else:\n        # No quotes found – assume the entire input is the string\n        s = raw_input\n\n    result = frequency_sort(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eetr\"",
          "success": true,
          "output": "eetr"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"cccaaa\"",
          "success": true,
          "output": "cccaaa"
        },
        {
          "example_index": 2,
          "input": "s = \"Aabb\"",
          "expected_output": "\"bbAa\"",
          "success": true,
          "output": "bbAa"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode336.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Pairs",
    "description_snippet": "You are given a 0-indexed array of unique strings words.\n\nA palindrome pair is a pair of integers (i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce pseudocode step by step, explaining. Should be O(total length). Approach: for each word, insert reversed word into map with index. For each word, iterate prefixes and suffixes: if prefix is palindrome, find reversed suffix; if suffix palindrome, find reversed prefix. Avoid same index. Complexity O(n * L^2?) But using precomputed suffix? But we can do O(total length). We'll produce generic pseudocode.\n\nNeed to output in lines, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrows. Provide each step.\n\nLet's craft:\n\nStart\n→ Build map reverse_word -> index for all words\n→ Initialize result list\n→ For each word with index i:\n    → For each split position k from 0 to len(word):\n        → prefix = word[0:k], suffix = word[k:]\n        → Decision: prefix is palindrome?\n            Yes → reversed_suffix = reverse(suffix)\n                 Decision: reversed_suffix in map and map[reversed_suffix] != i?\n                     Yes → Append [i, map[reversed_suffix]] to result\n        → Decision: suffix is palindrome and k != len(word)?\n            Yes → reversed_prefix = reverse(prefix)\n                 Decision: reversed_prefix in map and map[reversed_prefix] != i?\n                     Yes → Append [map[reversed_prefix], i] to result\n→ End\n\nExplain each step.\n\nNeed to ensure no duplicates: we can skip if i==j. Also skip duplicate pairs if needed. Provide explanation.\n\nOk. Let's craft lines.\n\nWe need to include arrows and decision statements.\n\nWe'll use \"→\" after step, then \"Decision:\" for if.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 為每個單字 words[i] 建立 reverse_word_map[reverse(words[i])] = i // 方便後續快速查找相反的字串  \n→ Step 2: 初始化空的 result_list // 用來儲存所有符合條件的 (i, j)  \n→ Decision: 是否還有單字要處理？ // 迴圈開始  \n    Yes → Step 3: 取出單字 word 及其索引 i // 進入主迴圈  \n        → Step 4: 對 word 進行所有可能的分割 (k = 0 .. len(word)) // 以檢查前後子字串  \n            → Decision: 前綴 prefix = word[0:k] 是否為回文？ // 檢查前綴是否能形成回文  \n                Yes → Step 5: 計算 suffix 的反轉 reversed_suffix = reverse(word[k:])  \n                    → Decision: reversed_suffix 是否存在於 reverse_word_map 且 map[reversed_suffix] ≠ i？ // 確認不同索引  \n                        Yes → Step 6: 將 (i, map[reversed_suffix]) 加入 result_list // 找到符合的 (i, j)  \n                No → (不做任何事)  \n            → Decision: 後綴 suffix = word[k:] 是否為回文？且 k ≠ len(word) // 避免重複把整個字串作為前綴  \n                Yes → Step 7: 計算 prefix 的反轉 reversed_prefix = reverse(word[0:k])  \n                    → Decision: reversed_prefix 是否存在於 reverse_word_map 且 map[reversed_prefix] ≠ i？  \n                        Yes → Step 8: 將 (map[reversed_prefix], i) 加入 result_list // 找到符合的 (j, i)  \n                No → (不做任何事)  \n        → (結束所有分割)  \n    → (回到 Decision: 是否還有單字要處理？)  \n→ End // 程式執行結束，result_list 為所有回文對的集合",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        \"\"\"\n        找出所有 (i, j) 使得 words[i] + words[j] 為回文。\n        時間複雜度 O(total_len)，使用哈希表和字串切分判斷。\n        \"\"\"\n        # 建立「單字的逆序 → 索引」映射\n        rev_index = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            length = len(word)\n            # 從 0 到 length 進行所有切分\n            for cut in range(length + 1):\n                prefix = word[:cut]\n                suffix = word[cut:]\n\n                # 1. 前綴是回文，查找 suffix 的逆序是否存在\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    j = rev_index.get(rev_suffix)\n                    if j is not None and j != i:\n                        res.append([i, j])\n\n                # 2. 後綴是回文，查找 prefix 的逆序是否存在\n                #   cut 必須不為 0，避免重複把整個字串作為後綴\n                if cut != 0 and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    j = rev_index.get(rev_prefix)\n                    if j is not None and j != i:\n                        res.append([j, i])\n\n        return res\n\ndef main():\n    # 從 stdin 讀取整個內容，並解析出 words 列表\n    data = sys.stdin.read().strip()\n    # 取出第一個 '[' 之後的內容作為字串列表\n    idx = data.find('[')\n    if idx == -1:\n        words = []\n    else:\n        try:\n            words = ast.literal_eval(data[idx:])\n        except Exception:\n            words = []\n\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[2,3]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[2, 3]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[0, 1]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode386.json",
    "problem_index_in_file": 0,
    "title": "Lexicographical Numbers",
    "description_snippet": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo code steps for algorithm that lists numbers 1..n in lexicographical order, using O(n) time and O(1) space. Classic algorithm is to simulate lexicographic DFS traversal of prefix tree of numbers, using iteration over prefixes, counting nodes. There's known algorithm: for current=1, while count<n: if current*10 <= n, current*=10; else if current%10 != 9 and current+1 <= n: current+=1; else: while (current/10)%10==9 or current+1 > n: current/=10; current+=1. That gives O(n) steps.\n\nWe need to produce pseudo-code line by line with explanations. Must not output actual code but pseudo code. Use Start, End, Decision, arrow, etc.\n\nLet's produce steps: Initialize current=1. Initialize count=0. Output list empty? But output as we go. Since O(1) space, cannot store all numbers in list? But we need to return all numbers; presumably output as stream, but algorithm uses O(1) extra besides output. So we can just output each number.\n\nPseudo code lines: Start; Step: set current=1; Step: while count < n; Step: output current; increment count; Decision: if current*10 <= n? Yes -> set current*=10; No -> Decision: if current%10 != 9 and current+1 <= n? Yes -> current+=1; No -> Decision: if current/10 %10 ==9 or current+1>n? But we need to find the ancestor where we can move to next sibling. We'll loop: while (current/10)%10 ==9 or current+1>n: current/=10; Then current+=1. That's standard.\n\nNeed to ensure each line with pseudo code arrow and comment.\n\nWe should include Decision blocks with Yes → etc.\n\nLet's craft lines. Use \"Step\" naming maybe not necessary but we can use \"Step\". Format: → Step 1: 設定 current=1 // 初始化起點為1\n\nBut we need arrow after Start. So:\n\nStart // 程式開始執行\n→ Step 1: current ← 1 // 設定起始數字為 1\n→ Step 2: count ← 0 // 追蹤已輸出的數字個數\n→ Decision: count < n? // 判斷是否已輸出 n 個數字\n    Yes → Step 3: 輸出 current // 輸出目前數字\n    Yes → Step 4: count ← count + 1 // 更新已輸出數字個數\n    Yes → Decision: current * 10 ≤ n? // 是否能往更深層級進一步\n        Yes → Step 5: current ← current * 10 // 進入下一層首個數字\n        No → Decision: current % 10 ≠ 9 ∧ current + 1 ≤ n? // 能否向右兄弟遞增\n            Yes → Step 6: current ← current + 1 // 移到右兄弟\n            No → Step 7: current ← current / 10 // 先退回到父節點\n            No → Step 8: current ← current + 1 // 再向右兄弟移動\n        No → Step 9: 循環 (current % 10 == 9 OR current + 1 > n) → current ← current / 10 // 退回到能移動的節點\n        No → Step 10: current ← current + 1 // 向右兄弟遞增\n    No → Step 11: // 無需執行，等待下一次迴圈判斷\n→ Decision: count < n? // 重複直到輸出 n 個數字\n    Yes → Goto Step 3\n    No  → End // 完成輸出\n\nBut need to format with arrow and decisions properly. Also keep consistent indentation.\n\nWe must keep each line a single line with arrow or decision. Avoid multi-line within same line.\n\nLet's write each line explicitly.\n\nImportant: The format: \"→ Step X: ... // ...\" or \"Decision: ...\" lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: current ← 1 // 設定起始數字為 1\n→ Step 2: count ← 0 // 追蹤已輸出的數字個數\n→ Decision: count < n? // 判斷是否已輸出 n 個數字\n    Yes → Step 3: 輸出 current // 輸出目前數字\n    Yes → Step 4: count ← count + 1 // 更新已輸出數字個數\n    Yes → Decision: current * 10 ≤ n? // 是否能進一步深層\n        Yes → Step 5: current ← current * 10 // 進入下一層的第一個數字\n        No  → Decision: current % 10 ≠ 9 ∧ current + 1 ≤ n? // 能否遞增到右兄弟\n            Yes → Step 6: current ← current + 1 // 移到右兄弟\n            No  → Step 7: current ← current / 10 // 退回到父節點\n            No  → Step 8: current ← current + 1 // 再遞增到右兄弟\n        No  → Step 9: 循環 (current % 10 == 9 ∨ current + 1 > n) → current ← current / 10 // 退回到可移動節點\n        No  → Step 10: current ← current + 1 // 移到右兄弟\n    No  → Step 11: // 此分支不會執行，保持迴圈\n→ Decision: count < n? // 重複判斷直到輸出完畢\n    Yes → Goto Step 3\n    No  → End // 程式執行結束\n\nBut we have some duplicate Decision. Actually after Step 4 we need to decide for next number. But we can combine.\n\nWe need each line exactly one step or decision. The above is messy. We should produce simpler representation:\n\nWe can produce a while loop pseudo-code:\n\n→ Step 3: while count < n do\n   → Step 3.1: 輸出 current\n   → Step 3.2: count ← count + 1\n   → Decision: current * 10 ≤ n? // 進入下一層\n       Yes → current ← current * 10\n       No → Decision: current % 10 ≠ 9 ∧ current + 1 ≤ n? // 右兄弟\n           Yes → current ← current + 1\n           No → current ← current / 10\n           No → current ← current + 1\n\nBut we need arrow formatting inside while. We could represent with indentation.\n\nLet's craft final answer carefully.\n\nWe need to ensure each line starts with either Start, End, Decision, or → Step. Use arrow for step lines.\n\nAlso must maintain consistent indentation of Decision branches.\n\nLet's produce final pseudo-code:\n\nStart // 程式開始執行\n→ Step 1: current ← 1 // 設定起始數字為 1\n→ Step 2: count ← 0 // 記錄已輸出數字個數\n→ Decision: count < n? // 判斷是否已輸出 n 個數字\n    Yes → Step 3: 輸出 current // 輸出目前數字\n    Yes → Step 4: count ← count + 1 // 更新已輸出數字個數\n    Yes → Decision: current * 10 ≤ n? // 是否可以進一步深層\n        Yes → Step 5: current ← current * 10 // 進入下一層第一個數字\n        No  → Decision: current % 10 ≠ 9 ∧ current + 1 ≤ n? // 能否向右兄弟遞增\n            Yes → Step 6: current ← current + 1 // 移到右兄弟\n            No  → Step 7: current ← current / 10 // 退回到父節點\n            No  → Step 8: current ← current + 1 // 再遞增到右兄弟\n        No  → Step 9: // 當無法進一步時，退回到能遞增的節點\n            → Step 9.1: 循環 (current % 10 == 9 ∨ current + 1 > n) → current ← current / 10 // 退回父節點直到可以遞增\n            → Step 9.2: current ← current + 1 // 移到右兄弟\n→ Decision: count < n? // 重新判斷是否已輸出完畢\n    Yes → Goto Step 3\n    No  → End // 程式執行結束\n\nBut we need each line with \"→ Step\" or \"Decision\". The Step 9.1, Step 9.2 lines use arrows inside. That's okay.\n\nBut we used \"Goto\" which might not be required. We can just loop by using outer Decision again. But the pattern is fine.\n\nLet's refine: We'll avoid \"Goto\" but keep the outer Decision that leads to Step 3 again. Actually Step 3 is part of loop; we can restructure as:\n\nDecision: count < n? \n    Yes → Step 3 ...\n    No  → End\n\nSo after Step 4 etc., we go back to Decision at bottom. That is okay.\n\nNeed to ensure we don't use \"Goto Step 3\" because we don't want external reference. Instead, just rely on Decision to continue loop.\n\nBut inside the Decision we had nested steps: Step 3.1, 3.2 etc. But we can't easily return to Decision after them. So we can restructure: The outer Decision is at top; we then have steps, then we go back to top by ending the block and evaluating Decision again. That is okay.\n\nThus we will produce code accordingly.\n\nHowever, the format may be considered ambiguous. But as per requirement, each line must include arrow or decision. Let's produce final answer with clear lines.\n\nWill produce:\n\nStart // 程式開始執行\n→ Step 1: current ← 1 // 設定起始數字為 1\n→ Step 2: count ← 0 // 記錄已輸出數字個數\n→ Decision: count < n? // 判斷是否已輸出 n 個數字\n    Yes → Step 3: 輸出 current // 輸出目前數字\n    Yes → Step 4: count ← count + 1 // 更新已輸出數字個數\n    Yes → Decision: current * 10 ≤ n? // 是否可以進一步深層\n        Yes → Step 5: current ← current * 10 // 進入下一層第一個數字\n        No  → Decision: current % 10 ≠ 9 ∧ current + 1 ≤ n? // 能否向右兄弟遞增\n            Yes → Step 6: current ← current + 1 // 移到右兄弟\n            No  → Step 7: current ← current / 10 // 退回到父節點\n            No  → Step 8: current ← current + 1 // 再遞增到右兄弟\n        No  → Step 9: // 無法進一步，退回並遞增\n            → Step 9.1: 循環 (current % 10 == 9 ∨ current + 1 > n) → current ← current / 10 // 退回到可遞增節點\n            → Step 9.2: current ← current + 1 // 移到右兄弟\n→ Decision: count < n? // 重新判斷是否已輸出完畢\n    Yes → Goto Step 3\n    No  → End // 程式執行結束\n\nBut we still have Goto. Let's change:\n\nAt bottom:\n\n→ Decision: count < n? // 重新判斷是否已輸出完畢\n    Yes → Step 3 // 回到輸出階段\n    No  → End\n\nBut Step 3 is already part of earlier block; but it's okay.\n\nLet's provide final answer.\n\nAlso need to mention that we use \"→\" for each step, \"Decision:\" lines. Ok.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: current ← 1 // 設定起始數字為 1  \n→ Step 2: count ← 0 // 記錄已輸出數字個數  \n\n→ Decision: count < n? // 判斷是否已輸出 n 個數字  \n    Yes → Step 3: 輸出 current // 輸出目前數字  \n    Yes → Step 4: count ← count + 1 // 更新已輸出數字個數  \n\n    Yes → Decision: current * 10 ≤ n? // 是否能進一步深層  \n        Yes → Step 5: current ← current * 10 // 進入下一層第一個數字  \n        No  → Decision: current % 10 ≠ 9 ∧ current + 1 ≤ n? // 能否遞增到右兄弟  \n            Yes → Step 6: current ← current + 1 // 移到右兄弟  \n            No  → Step 7: current ← current / 10 // 退回到父節點  \n            No  → Step 8: current ← current + 1 // 再遞增到右兄弟  \n\n        No  → Step 9: // 無法進一步，退回並遞增  \n            → Step 9.1: 循環 (current % 10 == 9 ∨ current + 1 > n) → current ← current / 10 // 退回到可遞增節點  \n            → Step 9.2: current ← current + 1 // 移到右兄弟  \n\n→ Decision: count < n? // 重新判斷是否已輸出完畢  \n    Yes → Step 3 // 回到輸出階段  \n    No  → End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def lexicalOrder(self, n: int):\n        result = []\n        current = 1\n        count = 0\n        while count < n:\n            result.append(current)\n            count += 1\n            if current * 10 <= n:\n                current *= 10\n            else:\n                if current % 10 != 9 and current + 1 <= n:\n                    current += 1\n                else:\n                    while current % 10 == 9 or current + 1 > n:\n                        current //= 10\n                    current += 1\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n    sol = Solution()\n    result = sol.lexicalOrder(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "success": true,
          "output": "[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode10.json",
    "problem_index_in_file": 0,
    "title": "Regular Expression Matching",
    "description_snippet": "Given an input string s and a pattern p, implement regular expression matching with support for '.' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code (step-by-step pseudocode) for regex matching with '.' and '*', covering entire string. Provide steps, using Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". Use arrow → for steps.\n\nWe need to generate algorithm, likely DP. Provide steps: initialize dp table, iterate. Should include conditions.\n\nWe should not output actual code. Just pseudocode steps. Provide line-by-line.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s 和正則表達式 p // 從使用者取得要比對的字串與模式  \n→ Step 2: 計算 n ← s 的長度，m ← p 的長度 // 取得兩個序列的長度  \n→ Step 3: 建立二維布林表 dp[n+1][m+1] // dp[i][j] 表示 s 的前 i 個字元能否與 p 的前 j 個字元完全匹配  \n→ Step 4: 設定 dp[0][0] ← True // 空字串與空模式匹配  \n→ Decision: 是否有 '*' 在模式中且可匹配空字串?  \n    Yes → 逐 j 從 1 到 m  \n        Decision: p[j-1] 為 '*'?  \n            Yes → dp[0][j] ← dp[0][j-2] // '*' 允許前項為 0 次，故檢查跳過兩個字符的子模式  \n            No  → dp[0][j] ← False // 其它情況空字串不匹配  \n    No  → 只執行一次 Step 4，dp[0][j] 全為 False (已預設)  \n→ Step 5: 逐 i 從 1 到 n  \n    逐 j 從 1 到 m  \n        Decision: p[j-1] 為 '.' 或 p[j-1] 等於 s[i-1]?  \n            Yes → dp[i][j] ← dp[i-1][j-1] // 前一個字符已匹配，則前 i 個與前 j 個匹配  \n            No  → Decision: p[j-1] 為 '*'?  \n                Yes → Decision: p[j-2] 為 '.' 或等於 s[i-1]?  \n                    Yes → dp[i][j] ← dp[i][j-2] 或 dp[i-1][j] // '*' 取 0 次或 1+ 次  \n                    No  → dp[i][j] ← dp[i][j-2] // '*' 只能取 0 次，前項不匹配  \n                No  → dp[i][j] ← False // 其它情況不匹配  \n→ Step 6: 回傳 dp[n][m] // 若最後一個位置為 True，整個字串與模式匹配  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"Return True if s matches the pattern p, otherwise False.\"\"\"\n        m, n = len(s), len(p)\n        # dp[i][j] == True  iff s[:i] matches p[:j]\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # patterns like a*, a*b*, etc. can match empty string\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '.' or p[j - 1] == s[i - 1]:\n                    # current characters match\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    # try zero occurrence of the element before '*'\n                    dp[i][j] = dp[i][j - 2]\n                    # try one or more occurrence if preceding element matches\n                    if p[j - 2] == '.' or p[j - 2] == s[i - 1]:\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n                # else dp[i][j] remains False\n\n        return dp[m][n]\n\n\ndef parse_input(text: str):\n    \"\"\"\n    Extracts the two quoted strings from an input of the form:\n        s = \"some string\", p = \"pattern\"\n    \"\"\"\n    parts = re.findall(r'\"([^\"]*)\"', text)\n    if len(parts) != 2:\n        raise ValueError(\"Input must contain two quoted strings for s and p.\")\n    return parts[0], parts[1]\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    try:\n        s, p = parse_input(raw_input)\n    except Exception as e:\n        print(\"false\")\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.isMatch(s, p)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"a*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\", p = \".*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode518.json",
    "problem_index_in_file": 0,
    "title": "Coin Change II",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode line by line, with virtual code steps and comment. Use structure: Start, End, Decision:, arrows. For coin change number of combinations: classic DP. We'll produce steps: Start, initialize DP array size amount+1 with zeros, set dp[0]=1, loop coin in coins, inner loop i from coin to amount, dp[i]+=dp[i-coin], after loops, return dp[amount]. So produce virtual code lines accordingly. Use arrow style. Each line: \"→ Step ... // explanation\". Use Decision maybe for checking if amount==0? Could add initial check. Provide structure.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 陣列長度 amount+1, 全部設為 0 // 建立動態規劃表\n→ Step 2: 設定 dp[0] = 1 // 金額為 0 只有一種組合（不取任何硬幣）\n→ Decision: 是否 coins 為空？ // 檢查是否有硬幣可用\n    Yes → Step 3: 回傳 0 // 沒有硬幣，無法組合任何金額\n    No  →\n→ Step 4: 循環每枚硬幣 coin in coins // 外層循環處理不同面額\n    → Step 5: 循環 i 從 coin 到 amount // 內層循環更新組合數\n        → Step 6: dp[i] = dp[i] + dp[i - coin] // 加入使用該硬幣的組合\n→ Step 7: 回傳 dp[amount] // 回傳總組合數\n\nEnd // 程式執行結束\n\nBut need arrow formatting: \"→\" before each step. For decisions, indent. Provide arrow and comment.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 陣列長度 amount+1, 全部設為 0 // 建立動態規劃表\n→ Step 2: 設定 dp[0] = 1 // 金額為 0 只有一種組合（不取任何硬幣）\n→ Decision: coins 是否為空？ // 檢查是否有硬幣可用\n    Yes → Step 3: 回傳 0 // 沒有硬幣，無法組合任何金額\n    No  →\n→ Step 4: 循環每枚硬幣 coin in coins // 外層循環處理不同面額\n    → Step 5: 循環 i 從 coin 到 amount // 內層循環更新組合數\n        → Step 6: dp[i] = dp[i] + dp[i - coin] // 加入使用該硬幣的組合\n→ Step 7: 回傳 dp[amount] // 回傳總組合數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def change(self, amount, coins):\n        \"\"\"Return number of combinations to make up the given amount using unlimited coins.\"\"\"\n        dp = [0] * (amount + 1)\n        dp[0] = 1  # One way to make amount 0: use no coins\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n        return dp[amount]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect format: amount, [coin1, coin2, ...]\n    try:\n        amount_str, coins_str = data.split(',', 1)\n    except ValueError:\n        # If input does not contain a comma, treat the whole input as amount with no coins\n        amount_str, coins_str = data, '[]'\n    amount = int(amount_str.strip())\n    coins = ast.literal_eval(coins_str.strip())\n    solution = Solution()\n    result = solution.change(amount, coins)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "5, [1,2,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "3, [2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "10, [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode434.json",
    "problem_index_in_file": 0,
    "title": "Number of Segments in a String",
    "description_snippet": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contigu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanation. It's a simple algorithm: count segments in a string: iterate over characters, count transitions from space to non-space. We'll include Start, Decision, etc.\n\nMake sure to use virtual code steps with arrows. Use \"Decision:\" with Yes/No arrows. Include variables: s, count, i, inSegment flag, or previous char logic. Provide explanation in Chinese. Each line ends with // 解釋.\n\nMake sure to include End. Use \"→\" arrow. Provide each step on new line. Format: line like \"Start // 程式開始執行\".\n\nNeed to produce for given problem: \"Given a string s, return the number of segments in the string. A segment is defined to be a contiguous sequence of non-space characters.\" So steps:\n\n1. Start\n2. Input s (string)\n3. Initialize count=0\n4. Initialize inSegment=false\n5. For each character ch in s:\n   Decision: if ch is space? (if yes, set inSegment=false; if no, check inSegment)\n   If ch not space:\n     Decision: if inSegment==false? \n        Yes -> count++; inSegment=true\n        No -> do nothing\n   (If ch is space: set inSegment=false)\n6. End, return count\n\nNeed to use Decision blocks for each decision.\n\nAlso maybe using pointer index i: for i from 0 to length-1. So decision: i < len? etc. But simpler: iterate for each char.\n\nWe'll represent loop with \"→ Step: for ch in s\" and decision inside.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Input: s // 取得輸入字串\n→ Step 1: count ← 0 // 初始化段數計數\n→ Step 2: inSegment ← False // 初始化是否處於段內標誌\n→ Step 3: for ch in s // 遍歷字串中的每個字符\n    → Decision: ch 為空格? // 判斷字符是否為空白\n        Yes → inSegment ← False // 空白字符結束任何段\n        No  → Decision: inSegment 為 False? // 檢查是否剛開始新段\n            Yes → count ← count + 1 // 新段開始，計數加一\n            No  → No operation // 已在段內，保持不變\n→ End // 程式執行結束\n→ Output: count // 返回段數\n\nBut we need each line separate. Need to indent for nested decisions? Format maybe each line separate, but with indentation to show structure. Use indentation spaces before nested lines.\n\nMake sure each line ends with // 解釋.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input s // 取得輸入字串\n→ Step 1: count ← 0 // 初始化段數計數為 0\n→ Step 2: inSegment ← False // 初始化段內標誌為 False\n→ Step 3: for ch in s // 遍歷字串中的每個字符\n    → Decision: ch 為空格? // 判斷字符是否為空白字符\n        Yes → inSegment ← False // 空白結束任何正在進行的段\n        No  → Decision: inSegment 為 False? // 判斷是否剛開始新段\n            Yes → count ← count + 1 // 新段開始，段數加一\n            No  → No operation // 已在段內，保持不變\n→ End // 程式執行結束\n→ Output count // 回傳段數\n\nWe need to keep the indentation. Also each line must have virtual code step + space + // explanation. Provide correct Chinese explanation. Ensure \"Decision:\" lines have Yes →, No → arrows.\n\nAlso for \"No operation\" we could leave blank or comment. We might write \"No operation // 保持不變\".\n\nLet's format with proper indent spaces for nested steps. Each nested line starts with some spaces. We need to preserve that. For simplicity, we can use two spaces per indent. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Input s // 取得輸入字串\n→ Step 1: count ← 0 // 初始化段數計數為 0\n→ Step 2: inSegment ← False // 初始化段內標誌為 False\n→ Step 3: for ch in s // 遍歷字串中的每個字符\n  → Decision: ch 為空格? // 判斷字符是否為空白字符\n    Yes → inSegment ← False // 空白結束任何正在進行的段\n    No  → Decision: inSegment 為 False? // 判斷是否剛開始新段\n      Yes → count ← count + 1 // 新段開始，段數加一\n      No  → No operation // 已在段內，保持不變\n→ End // 程式執行結束\n→ Output count // 回傳段數",
      "generated_code": "import sys\n\ndef count_segments(s: str) -> int:\n    \"\"\"\n    Count contiguous sequences of non-space characters in the string.\n    \"\"\"\n    # Using str.split() with default separator splits on any whitespace\n    # and discards empty strings automatically.\n    return len(s.split())\n\ndef main() -> None:\n    # Read the entire input from stdin.\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the string after the first '=' if present,\n    # otherwise treat the whole input as the string.\n    if '=' in data:\n        _, after_eq = data.split('=', 1)\n        raw = after_eq.strip()\n    else:\n        raw = data.strip()\n\n    # Remove surrounding quotes if present.\n    raw = raw.strip('\\'\"')\n\n    # Compute the number of segments and print the result.\n    result = count_segments(raw)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello, my name is John\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"Hello\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode483.json",
    "problem_index_in_file": 0,
    "title": "Smallest Good Base",
    "description_snippet": "Given an integer n represented as a string, return the smallest good base of n.\n\nWe call k >= 2 a go...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for problem: find smallest good base of n represented as string. Classic LeetCode problem. Need to compute smallest k such that n in base k consists only of digits 1. Equivalent to n = (k^m - 1)/(k - 1) for some m >= 2. We can brute over m from floor(log2(n)) down to 2. For each m compute integer k = round(n^(1/(m-1)))? Actually formula: n = (k^m - 1)/(k - 1). Solve for k using binary search for each m. Return minimal k. If no base found, answer n-1 (k = n-1 gives representation \"11\" in base n-1). Provide pseudo-code.\n\nWe need to produce step-by-step virtual code with arrows and explanation.\n\nWe need to treat big integer represented as string, need big integer operations. We can use big integer arithmetic or string to int conversion if within limit? But we can use BigInteger. Steps: parse n as BigInteger.\n\nPseudo steps:\n\nStart\n→ Parse n string to BigInteger N\n→ Compute max_m = floor(log2(N)) // because base at least 2\n→ Initialize best_k = N - 1 // default\n→ For m from max_m down to 2:\n    → Binary search k in [2, N^(1/(m-1)) + 1] to find k satisfying sum_{i=0}^{m-1} k^i = N\n        Decision: compute powerSum(k, m) // using loop with BigInteger\n        If sum == N:\n            → Update best_k = k\n            → Break outer loop (since we iterate decreasing m gives smallest k? Actually smallest k corresponds to largest m? Wait need smallest base, which is minimal k. For fixed m, higher k yields smaller m? Let's think: For m fixed, k decreases with m? Actually n fixed, as m increases, k decreases because expression is sum of geometric series. We need smallest base => minimal k. For m from 2 to max_m, we should find k. For each m, compute k. Among all valid k, choose min. Since m larger gives smaller k? Let's check: For n=15, m=4 gives k=2 (1111 base2). m=2 gives k=14 (11 base14). So smallest k is 2. m large gives smaller k. So we should iterate m from max_m down to 2 to find smallest k first. Actually as m decreases, k increases. So iterate decreasing m to find smallest k earlier, and break. So yes.\n\n→ After loop, return best_k as string.\n\nNeed functions: powerSum(k,m) to compute sum of powers with overflow check. Use BigInteger.\n\nPseudo-code with Decision nodes.\n\nLet's produce steps with arrow lines.\n\nWe need to ensure \"虛擬碼步驟\" each line. Use arrows.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 n // 讀取 n\n→ Step 2: 轉成 BigInteger N = BigInteger(n) // 轉換為大數\n→ Step 3: 計算 max_m = floor(log2(N)) // 最大可能的 m\n→ Step 4: best_k = N - 1 // 預設答案為 n-1（代表 '11'）\n→ Decision: For m from max_m down to 2? Use loop\nBut pseudo-code line by line: We can represent loop using Decision? maybe use Step: For m = max_m downto 2\nWe can use \"Step 5: For m in [max_m, ..., 2]\" as loop.\n\nInside loop:\n→ Step 6: low = 2\n→ Step 7: high = N^(1/(m-1)) + 1 // approximate upper bound\n→ Step 8: BinarySearch while low <= high:\n   → Decision: mid = (low + high) / 2\n   → Step 9: sum = powerSum(mid, m)\n   → Decision: if sum == N? // found\n        Yes → best_k = mid\n            → Break (outer loops)\n        No: if sum < N? // need larger k? Actually sum increases with k. So if sum < N, low = mid + 1; else high = mid - 1\n\nAfter loops, output best_k.\n\nWe need to include explanation comments.\n\nWe need to use \"Decision:\" with arrows.\n\nWe need to include \"End\" line.\n\nAlso need function definitions:\n\n→ Function powerSum(base, m):\n    → sum = 0\n    → pow = 1\n    → For i=0 to m-1:\n        sum += pow\n        pow *= base\n    → return sum\n\nBut we can inline.\n\nWe should ensure no actual code.\n\nLet's produce final pseudo-code with lines, each line with comment.\n\nUse \"Step\" or \"Action\" naming.\n\nWe need to maintain arrow style: \"→\" after previous line? Actually example: \"→ Step 1: ...\". We need to show indentation maybe but not necessary.\n\nWe'll output lines in order.\n\nLet's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 n // 讀取使用者輸入的數字字串\n→ Step 2: 轉成 BigInteger N = BigInteger(n) // 以大數形式存儲 n，避免溢位\n→ Step 3: 計算 max_m = floor(log2(N)) // 最高可能的指數，因為 k≥2\n→ Step 4: best_k = N - 1 // 預設答案為 n-1，對應「11」的表示\n→ Decision: for m從max_m 到 2 逐步遞減 // 由大到小檢查 m，較大的 m 可能得到更小的 k\n    → Step 5: low = 2\n    → Step 6: high = floor( N^(1/(m-1)) ) + 1 // k 的上界，確保不漏掉可能的解\n    → Decision: while low <= high // 二分搜尋 k\n        → Step 7: mid = (low + high) // 2 // 取中值作為候選基數\n        → Step 8: sum = 0; pow = 1\n        → Step 9: for i = 0 to m-1 // 計算 (k^m-1)/(k-1) 的和\n            → sum += pow\n            → pow *= mid\n        → Decision: if sum == N\n            → Yes → best_k = mid // 找到合法的 k\n                → Yes → Exit all loops // 已得到最小 k，結束搜尋\n            → No\n                → Decision: if sum < N\n                    → Yes → low = mid + 1 // 和太小，增大 k\n                    → No  → high = mid - 1 // 和太大，減小 k\n→ Step 10: 輸出 best_k // 顯示找到的最小好基數\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef smallest_good_base(n_str: str) -> str:\n    n = int(n_str)\n    # Special case: n == 2 → base 1 (not valid, but follows the definition)\n    if n == 2:\n        return \"1\"\n\n    # The maximum possible exponent m satisfies 2^(m-1) <= n < 2^m\n    max_m = n.bit_length()          # equivalent to floor(log2(n)) + 1\n\n    # Iterate over possible lengths m from large to small.\n    # Larger m → smaller base k.\n    for m in range(max_m, 1, -1):\n        left, right = 2, n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            # Calculate the sum 1 + mid + mid^2 + ... + mid^(m-1)\n            # using the closed‑form formula.\n            s = (pow(mid, m) - 1) // (mid - 1)\n            if s == n:\n                return str(mid)\n            elif s < n:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    # If no better base is found, n-1 is always a valid answer ('11' in base n-1).\n    return str(n - 1)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract the first integer sequence from the input.\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n_str = match.group(0)\n    print(smallest_good_base(n_str))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"13\"",
          "expected_output": "\"3\"",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = \"4681\"",
          "expected_output": "\"8\"",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 2,
          "input": "n = \"1000000000000000000\"",
          "expected_output": "\"999999999999999999\"",
          "success": true,
          "output": "999999999999999999"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode326.json",
    "problem_index_in_file": 0,
    "title": "Power of Three",
    "description_snippet": "Given an integer n, return true if it is a power of three. Otherwise, return false.\n\nAn integer n is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the algorithm: check if n is power of 3. Approach: loop dividing by 3 while divisible. Or check if n>0 and 3^k equals. Since no actual code, we produce steps. Use Start, End, Decision. Provide each step. Use arrow notation. Provide explanation after //.\n\nLet's design algorithm:\n\nStart\n→ Step 1: Check if n <= 0 // If non-positive, not power of 3\n    Yes → Step 2: Return false\n    No  → Step 3: Loop: while n % 3 == 0\n           → Step 3a: n = n / 3\n           → Step 3b: Check if n == 1\n                Yes → Step 3c: Return true\n                No  → Continue loop\n    End of loop\n→ Step 4: Return false // if loop ends and n !=1\n\nBut need to structure. Provide Decision inside loop? Use Decision: if n % 3 == 0? Yes loop else exit.\n\nWe can produce like:\n\nStart\n→ Decision: n <= 0? // 若非正數則非三的冪\n    Yes → Step 1: Return false\n    No  → Decision: n == 1? // 若等於1則是三的冪\n        Yes → Step 2: Return true\n        No  → Step 3: Set temp = n\n→ Decision: temp % 3 == 0? // 迴圈判斷是否能被3整除\n    Yes → temp = temp / 3\n        → Decision: temp == 1? // 若化簡為1則成功\n            Yes → Step 4: Return true\n            No  → Go back to Decision: temp % 3 == 0?\n        No  → Step 5: Return false\nEnd\n\nBut need to structure loops; use Decision and arrow.\n\nWe can create:\n\nStart\n→ Decision: n <= 0? // 若非正數直接否\n    Yes → Step 1: Return false\n    No  → Decision: n == 1? // 1是3^0\n        Yes → Step 2: Return true\n        No  → Step 3: temp = n // 初始化临时变量\n→ Decision: temp % 3 == 0? // 检查是否能被3整除\n    Yes → temp = temp / 3\n        → Decision: temp == 1? // 若变成1即为3的幂\n            Yes → Step 4: Return true\n            No  → Go back to Decision: temp % 3 == 0? // 继续循环\n    No  → Step 5: Return false\nEnd\n\nNeed to show \"Go back\" maybe using arrow pointing back to previous decision? Use \"→\" to go to earlier? Provide explanation: \"Loop back\".\n\nBut the instruction: Use arrows (→, Yes →, No →) and structure Start, End, Decision. So we can express loops by using decisions and arrows to previous decision.\n\nLet's write:\n\nStart // 程式開始執行\n→ Decision: n <= 0? // 檢查是否為非正數\n    Yes → Step 1: Return false // 非正數不是三的冪\n    No  → Decision: n == 1? // 1是3的冪（3^0）\n        Yes → Step 2: Return true // n 是三的冪\n        No  → Step 3: temp = n // 設定臨時變數\n→ Decision: temp % 3 == 0? // 檢查 temp 是否能被3整除\n    Yes → temp = temp / 3 // 除以3\n        → Decision: temp == 1? // 檢查是否已化簡為1\n            Yes → Step 4: Return true // 找到三的冪\n            No  → Go back to Decision: temp % 3 == 0? // 進一步迴圈\n    No  → Step 5: Return false // 不能被3整除，非三的冪\nEnd // 程式執行結束\n\nBut we used \"Go back to Decision: temp % 3 == 0?\" maybe not standard. But it's okay.\n\nAlternatively, use explicit loop:\n\nStart\n→ Decision: n <= 0?\n    Yes → Step 1: Return false\n    No  → Step 2: temp = n\n→ Loop Start\n    → Decision: temp % 3 == 0?\n        Yes → temp = temp / 3\n            → Decision: temp == 1?\n                Yes → Step 3: Return true\n                No  → Go back to Loop Start\n        No  → Step 4: Return false\nEnd\n\nBut we need to output each line. So we break into each step.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: n <= 0? // 檢查是否為非正數  \n Yes → Step 1: Return false // 非正數不是三的冪  \n No  → Decision: n == 1? // 1 是 3 的冪（3^0）  \n  Yes → Step 2: Return true // n 為三的冪  \n  No  → Step 3: temp = n // 設定臨時變數  \n\n→ Decision: temp % 3 == 0? // 檢查 temp 是否能被 3 整除  \n Yes → temp = temp / 3 // 除以 3  \n  → Decision: temp == 1? // 檢查是否已化簡為 1  \n   Yes → Step 4: Return true // 找到三的冪  \n   No  → Go back to Decision: temp % 3 == 0? // 繼續迴圈  \n No  → Step 5: Return false // 不能被 3 整除，非三的冪  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        \"\"\"Return True if n is a power of three, otherwise False.\"\"\"\n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n //= 3\n        return n == 1\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 尋找第一個整數（允許負號）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        # 若找不到數字，直接結束\n        return\n    n = int(match.group())\n    result = Solution().isPowerOfThree(n)\n    # 按題目要求輸出小寫 'true' 或 'false'\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 27",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = -1",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode179.json",
    "problem_index_in_file": 0,
    "title": "Largest Number",
    "description_snippet": "Given a list of non-negative integers nums, arrange them such that they form the largest number and ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for arranging numbers to form largest number. Must output as virtual code lines with explanation. Use Start, Decision, etc. The algorithm: sort numbers as strings with custom comparator comparing a+b vs b+a. Then concatenate, remove leading zeros. Return string. Let's produce step-by-step. Use Start, → lines. Should include decision for empty list, sorting, concatenation, leading zeros, return. Provide explanation. Also need to handle large result as string.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: Convert nums to list of strings // 轉成字串以便字串比較\n→ Step 2: If list empty, return \"0\" // 空列表處理\n→ Step 3: Sort list with custom comparator // 排序以產生最大數\n    → Comparator: compare a+b vs b+a // 先拼接兩種順序\n→ Step 4: Concatenate sorted strings into result // 組合為最終字串\n→ Step 5: If result[0] == '0', return \"0\" // 只為零時\n→ Step 6: Return result // 結束\n\nBut need virtual code style with arrows and decision blocks.\n\nWe can use Decision: if empty list? Yes → return \"0\" No → continue.\n\nAlso Decision: if result[0]=='0'? Yes → return \"0\" No → return result.\n\nAlso need sorting step: maybe we show \"Sort using custom comparator\" as a step.\n\nLet's produce as lines:\n\nStart // 程式開始執行\n→ Step 1: nums_str ← map(str, nums) // 將整數轉成字串\n→ Decision: If nums_str is empty? // 檢查輸入是否為空\n    Yes → Return \"0\" // 空輸入直接回傳 0\n    No  → // 繼續處理\n→ Step 2: Define comparator cmp(a,b) // 定義比較函式\n    → cmp(a,b) ← If a+b > b+a then -1 else 1 // 降序排列\n→ Step 3: sorted_nums ← sort(nums_str, key=cmp) // 根據 cmp 排序\n→ Step 4: result ← concatenate(sorted_nums) // 合併所有字串\n→ Decision: If result starts with '0'? // 檢查全為零的情況\n    Yes → Return \"0\" // 只包含 0 的情況回傳單一 0\n    No  → Return result // 否則回傳組合結果\nEnd // 程式結束\n\nMake sure each line includes \"虛擬碼步驟\" + \" // 解釋\".\n\nWe need to maintain arrow formatting like `→`. Use `Decision:` lines for branching. Also include `Start` and `End`. Provide explanation.\n\nLet's produce final output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: nums_str ← map(str, nums) // 把每個整數轉成字串，方便後續字串比較\n→ Decision: If nums_str is empty? // 檢查輸入是否為空列表\n    Yes → Return \"0\" // 空輸入直接回傳「0」表示最大數\n    No  → // 繼續後續步驟\n→ Step 2: Define comparator cmp(a,b) // 定義自訂比較函式\n    → cmp(a,b) ← If a+b > b+a then -1 else 1 // 比較拼接「a+b」與「b+a」的大小，決定排序順序\n→ Step 3: sorted_nums ← sort(nums_str, key=cmp) // 按照 cmp 排序，得到能組成最大數的字串順序\n→ Step 4: result ← concatenate(sorted_nums) // 把排序後的字串連接成最終結果\n→ Decision: If result starts with '0'? // 檢查結果是否全為零\n    Yes → Return \"0\" // 如全為零，直接回傳單一「0」\n    No  → Return result // 否則回傳組合後的最大數字串\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nfrom functools import cmp_to_key\n\nclass Solution:\n    def largestNumber(self, nums):\n        # Convert all numbers to strings for easy concatenation\n        nums_str = list(map(str, nums))\n\n        # Custom comparator: decide order by comparing concatenations\n        def compare(x, y):\n            if x + y > y + x:\n                return -1          # x should come before y\n            elif x + y < y + x:\n                return 1           # y should come before x\n            else:\n                return 0\n\n        # Sort using the comparator\n        nums_str.sort(key=cmp_to_key(compare))\n\n        # Join into the final string\n        result = ''.join(nums_str)\n\n        # If the result starts with '0', the entire number is 0\n        return '0' if result[0] == '0' else result\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Expect input like \"nums = [10,2]\" or just \"[10,2]\"\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n\n    # Safely evaluate the list of numbers\n    try:\n        nums = eval(list_part.strip())\n    except Exception:\n        # If evaluation fails, treat as empty list\n        nums = []\n\n    solution = Solution()\n    print(solution.largestNumber(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,2]",
          "expected_output": "\"210\"",
          "success": true,
          "output": "210"
        },
        {
          "example_index": 1,
          "input": "nums = [3,30,34,5,9]",
          "expected_output": "\"9534330\"",
          "success": true,
          "output": "9534330"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode232.json",
    "problem_index_in_file": 0,
    "title": "Implement Queue using Stacks",
    "description_snippet": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should supp...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a virtual code implementation of a queue using two stacks, following the specified format. Each line should be a step with virtual code arrow and comment. Use \"Start\", \"End\", \"Decision:\" etc. The user wants to implement MyQueue class with push, pop, peek, empty. We need to produce a step-by-step algorithm for the whole class or each method? Likely for each method. But the instruction: \"逐行產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋。請根據輸出格式要求產生虛擬碼和逐行解釋.\" So we need to produce the entire class's operations algorithm.\n\nWe need to include the structure: Start, Steps, Decision, End. Use arrows.\n\nThe algorithm: Use two stacks: stack_in (for pushes) and stack_out (for pops/peeks). push(x): stack_in.push(x). pop(): if stack_out empty, transfer all from stack_in to stack_out, then pop from stack_out. peek(): same but just peek top of stack_out after transfer if needed. empty(): return stack_in empty and stack_out empty.\n\nWe need to produce each step line by line, including decisions.\n\nWe need to show the algorithm for the entire class, not necessarily code lines but conceptual steps.\n\nWe can produce something like:\n\nStart\n→ Declare stack_in and stack_out as empty stacks // 初始化兩個空堆疊\n→ Method: push(x)\n    → stack_in.push(x) // 將元素推入輸入堆疊\n→ Method: pop()\n    → Decision: if stack_out is empty? // 檢查輸出堆疊是否為空\n        Yes → Step: while stack_in not empty: stack_out.push(stack_in.pop()) // 將所有元素倒轉至輸出堆疊\n        No → // 跳過\n    → result ← stack_out.pop() // 從輸出堆疊彈出前端元素\n    → return result // 返回彈出的元素\n→ Method: peek()\n    → Decision: if stack_out is empty? // 檢查輸出堆疊是否為空\n        Yes → Step: while stack_in not empty: stack_out.push(stack_in.pop()) // 倒轉\n        No → // 跳過\n    → result ← stack_out.peek() // 取得輸出堆疊頂部元素\n    → return result\n→ Method: empty()\n    → Decision: if stack_in empty AND stack_out empty? // 判斷兩堆疊皆為空\n        Yes → return true\n        No  → return false\nEnd\n\nBut we need to format each line with \"虛擬碼步驟\" + space + \"// 解釋\". We need to use arrow arrows for steps. Let's create consistent format:\n\nStart // 程式開始執行\n→ Declare stack_in and stack_out as empty stacks // 初始化兩個空堆疊\n\nMethod push(x):\n→ push x onto stack_in // 將元素推入輸入堆疊\n\nMethod pop():\n→ Decision: stack_out empty? // 檢查輸出堆疊是否為空\n    Yes → while stack_in not empty: stack_out.push(stack_in.pop()) // 倒轉輸入堆疊到輸出堆疊\n    No → // 不做任何事\n→ result ← stack_out.pop() // 從輸出堆疊彈出元素\n→ return result // 返回彈出的元素\n\nMethod peek():\n→ Decision: stack_out empty? // 檢查輸出堆疊是否為空\n    Yes → while stack_in not empty: stack_out.push(stack_in.pop()) // 倒轉\n    No → // 不做任何事\n→ result ← stack_out.peek() // 取得輸出堆疊頂部元素\n→ return result // 返回前端元素\n\nMethod empty():\n→ Decision: stack_in empty AND stack_out empty? // 判斷兩堆疊皆為空\n    Yes → return true // 若空，返回真\n    No  → return false // 否則返回假\n\nEnd // 程式結束\n\nWe need to ensure each line is a separate line. Use \"→\" and indent for decisions.\n\nLet's produce lines. Also ensure \"Yes →\" and \"No →\" arrows for decisions. For the while loops, maybe we treat as steps too.\n\nWe should include \"Decision:\" lines with indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Declare stack_in and stack_out as empty stacks // 初始化兩個空堆疊  \n\nMethod: push(x) // 處理 push 操作  \n→ stack_in.push(x) // 將元素推入輸入堆疊  \n\nMethod: pop() // 處理 pop 操作  \n→ Decision: stack_out is empty? // 檢查輸出堆疊是否為空  \n    Yes → While stack_in not empty:  \n        → stack_out.push(stack_in.pop()) // 將所有輸入堆疊元素倒轉到輸出堆疊  \n    No → // 若輸出堆疊非空，直接跳過  \n→ result ← stack_out.pop() // 從輸出堆疊彈出前端元素  \n→ return result // 返回彈出的元素  \n\nMethod: peek() // 處理 peek 操作  \n→ Decision: stack_out is empty? // 檢查輸出堆疊是否為空  \n    Yes → While stack_in not empty:  \n        → stack_out.push(stack_in.pop()) // 將所有輸入堆疊元素倒轉到輸出堆疊  \n    No → // 若輸出堆疊非空，直接跳過  \n→ result ← stack_out.peek() // 取得輸出堆疊頂部元素  \n→ return result // 返回前端元素  \n\nMethod: empty() // 處理 empty 操作  \n→ Decision: stack_in is empty AND stack_out is empty? // 判斷兩堆疊皆為空  \n    Yes → return true // 若兩堆疊皆空，回傳 true  \n    No  → return false // 否則回傳 false  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    # 如果輸入中包含 \"Input\" 之類的標記，則忽略\n    lines = [line for line in data if line.strip() and line.strip() != 'Input']\n    if len(lines) < 2:\n        sys.exit(0)\n\n    # 解析指令與參數\n    try:\n        commands = ast.literal_eval(lines[0])\n        args_list = ast.literal_eval(lines[1])\n    except Exception:\n        commands = json.loads(lines[0])\n        args_list = json.loads(lines[1])\n\n    res = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyQueue\":\n            obj = MyQueue()\n            res.append(None)  # constructor returns null\n        elif cmd == \"push\":\n            obj.push(args[0])\n            res.append(None)\n        elif cmd == \"pop\":\n            res.append(obj.pop())\n        elif cmd == \"peek\":\n            res.append(obj.peek())\n        elif cmd == \"empty\":\n            res.append(obj.empty())\n        else:\n            # 忽略未知指令\n            res.append(None)\n\n    # 將結果輸出成 JSON 格式\n    print(json.dumps(res, separators=(', ', ': ')))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "success": true,
          "output": "[null, null, null, 1, 1, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode718.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Repeated Subarray",
    "description_snippet": "Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in bo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for finding maximum length of common subarray between two integer arrays nums1 and nums2. We need to output line by line with \"→\" etc. This is a classic problem: Longest Common Subarray (maximum length of contiguous subarray). Usually DP or binary search with hashing. Let's choose DP approach: 2D DP table of size (m+1)x(n+1) where dp[i][j] is length of longest common suffix ending at nums1[i-1] and nums2[j-1]. We track max. Also we can optimize to O(min(m,n)) memory by using two rows.\n\nWe need to produce virtual code steps, not actual code. So we can produce steps:\n\nStart // start program\n→ Step 1: 設定 m = len(nums1), n = len(nums2) // get lengths\n→ Step 2: 建立兩行 dpRow0, dpRow1 為長度 n+1 // two rows for DP\n→ Step 3: 初始化 maxLen = 0 // 记录最大长度\n→ Decision: 若 m == 0 or n == 0? // check empty arrays\n    Yes → Step 4: 回傳 0 // 若任一为空，结果为 0\n    No  → ...\nThen loop i from 1 to m:\n    → Step: iLoopStart\n        → Step: 交換 dpRow0, dpRow1 // 使用两行循环\n        → Step: 設 dpRow1[0] = 0 // reset first column\n        → Decision: j from 1 to n\n            → Step: jLoopStart\n                → Decision: nums1[i-1] == nums2[j-1]?\n                    Yes → Step: dpRow1[j] = dpRow0[j-1] + 1 // extend\n                    No  → Step: dpRow1[j] = 0 // reset\n                → Step: 若 dpRow1[j] > maxLen: 更新 maxLen\n        → Step: iLoopEnd\nAfter loops, Step: 回傳 maxLen // return result\n\nMake sure to format each line: \"→ Step ... // explanation\". Use decision blocks appropriately. Use arrows for Yes →, No →. Provide Start and End.\n\nWe need to keep each line separate, with no code. Use arrows like \"→ Step 1: ...\" etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 m = nums1 的長度, n = nums2 的長度 // 取得兩個陣列的長度  \n→ Step 2: 建立兩個長度為 n+1 的陣列 dpRow0 與 dpRow1，並全部初始化為 0 // 用於 DP 計算  \n→ Step 3: 設定 maxLen = 0 // 用於儲存目前找到的最大子陣列長度  \n→ Decision: 如果 m == 0 或 n == 0? // 判斷是否有空陣列  \n  Yes → Step 4: 回傳 0 // 若任一陣列為空，最長公共子陣列長度為 0  \n  No  → // 進入主迴圈  \n→ Step 5: 從 i = 1 到 m 做迴圈 // 遍歷 nums1 的每個元素  \n  → Step 6: 交換 dpRow0 與 dpRow1 的參考 // 只保留兩行，進行空間優化  \n  → Step 7: 將 dpRow1[0] 設為 0 // 第一欄為 0，因為不存在前綴  \n  → Step 8: 從 j = 1 到 n 做迴圈 // 遍歷 nums2 的每個元素  \n    → Decision: 如果 nums1[i-1] == nums2[j-1]? // 檢查兩個位置的元素是否相等  \n      Yes → Step 9: dpRow1[j] = dpRow0[j-1] + 1 // 以前一個位置的結果為基礎，延長長度  \n      No  → Step 10: dpRow1[j] = 0 // 不相等，重置長度為 0  \n    → Step 11: 如果 dpRow1[j] > maxLen? // 檢查是否找到更長的子陣列  \n      Yes → Step 12: maxLen = dpRow1[j] // 更新最大長度  \n  → Step 13: // 迴圈結束，繼續下一個 i  \n→ Step 14: 回傳 maxLen // 將結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findLength(self, nums1, nums2):\n        \"\"\"找出兩個陣列中最長的公共子陣列長度。\"\"\"\n        m, n = len(nums1), len(nums2)\n        # 只用兩行來做 DP，降低空間複雜度\n        prev = [0] * (n + 1)\n        cur = [0] * (n + 1)\n        max_len = 0\n        for i in range(1, m + 1):\n            # 每次從前一行拷貝，或直接交換\n            prev, cur = cur, prev\n            for j in range(1, n + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    cur[j] = prev[j - 1] + 1\n                    if cur[j] > max_len:\n                        max_len = cur[j]\n                else:\n                    cur[j] = 0\n        return max_len\n\ndef parse_input(text):\n    \"\"\"\n    從 stdin 讀取的文字中，找出兩個方括號內的內容，並轉成整數列表。\n    支援「nums1 = [1,2,3]」與「nums2 = [4,5]」等格式。\n    \"\"\"\n    # 取出所有 [] 內的字串\n    parts = re.findall(r'\\[([^\\]]*)\\]', text)\n    # 若只找到一個，假設第一個是 nums1，第二個是 nums2\n    if len(parts) >= 2:\n        raw1, raw2 = parts[0], parts[1]\n    elif len(parts) == 1:\n        raw1, raw2 = parts[0], ''\n    else:\n        raw1, raw2 = '', ''\n    def to_list(raw):\n        raw = raw.strip()\n        if not raw:\n            return []\n        return [int(x.strip()) for x in raw.split(',') if x.strip()]\n    return to_list(raw1), to_list(raw2)\n\ndef main():\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    sol = Solution()\n    result = sol.findLength(nums1, nums2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode493.json",
    "problem_index_in_file": 0,
    "title": "Reverse Pairs",
    "description_snippet": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for counting reverse pairs in array. Use algorithm: merge sort based counting O(n log n). Steps: sort while counting. Provide pseudo code lines: Start, Step: copy array, Step: define function count_and_merge(l,r). etc. Need decision: if l>=r return 0. Count left, right, cross. For cross, use two pointers to count >2*arr[j] condition. Then merge. Return sum. Finally call function, output result. Provide comments. Ensure each line has virtual code and comment. Use arrows. Provide structure.\n\nLet's craft lines:\n\nStart\n→ Step 1: 設定 nums 為輸入陣列 // 開始\n→ Step 2: 定義函式 count_and_merge(start, end) // 遞迴計算\n→ Decision: 如果 start >= end? // 單元素不需處理\n    Yes → Step 3: 返回 0 // 無逆序對\n    No  → Step 4: mid = (start + end) // 取得中點 // 助於分治\n    → Step 5: leftCount = count_and_merge(start, mid) // 計算左半段\n    → Step 6: rightCount = count_and_merge(mid+1, end) // 計算右半段\n    → Step 7: crossCount = 0 // 初始化跨段逆序對計數\n    → Step 8: i = start, j = mid+1 // 設定兩指標\n    → Decision: i <= mid? // 仍有左半段元素\n        Yes → Decision: j <= end AND nums[i] > 2*nums[j]? // 檢查逆序條件\n            Yes → Step 9: crossCount += (mid - i + 1) // 所有剩餘左元素皆符合\n                  → Step 10: j++ // 移動右指標\n            No  → Step 11: i++ // 左指標往後\n        No  → Step 12: // 兩指標遍歷結束\n    → Step 13: Merge nums[start..mid] 與 nums[mid+1..end] // 合併保持升序\n    → Step 14: 返回 leftCount + rightCount + crossCount // 合計逆序對\n→ Step 15: total = count_and_merge(0, nums.length-1) // 主函式呼叫\n→ Step 16: 輸出 total // 結果\nEnd\n\nNeed ensure decision indentation and arrows. Provide each line with // comment.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 nums 為輸入陣列 // 取得待分析的數列  \n→ Step 2: 定義函式 count_and_merge(start, end) // 遞迴計算逆序對數  \n→ Decision: 如果 start >= end? // 單一元素不會產生逆序對  \n  Yes → Step 3: 返回 0 // 無逆序對  \n  No  → Step 4: mid = (start + end) // 取得子陣列中點，分成左、右兩段  \n  → Step 5: leftCount = count_and_merge(start, mid) // 計算左半段的逆序對  \n  → Step 6: rightCount = count_and_merge(mid+1, end) // 計算右半段的逆序對  \n  → Step 7: crossCount = 0 // 初始化跨段逆序對計數  \n  → Step 8: i = start, j = mid+1 // 指標 i 指向左半段，j 指向右半段  \n  → Decision: i <= mid? // 左半段仍有未檢查元素  \n    Yes → Decision: j <= end AND nums[i] > 2*nums[j]? // 檢查是否為逆序對  \n      Yes → Step 9: crossCount += (mid - i + 1) // 右指標 j 的數字對後面所有左半段數字皆符合逆序條件  \n       → Step 10: j++ // 移動右指標，檢查下一個右側數字  \n      No  → Step 11: i++ // 左指標往後，檢查下一個左側數字  \n    No  → Step 12: // i 已越過 mid，指標循環結束  \n  → Step 13: Merge nums[start..mid] 與 nums[mid+1..end] // 合併兩段為升序，為後續計算做準備  \n  → Step 14: 返回 leftCount + rightCount + crossCount // 將三部分計數合併返回  \n→ Step 15: total = count_and_merge(0, nums.length-1) // 主呼叫，處理整個陣列  \n→ Step 16: 輸出 total // 顯示逆序對總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reversePairs(self, nums):\n        # Merge‑sort based counting of reverse pairs\n        def merge_sort(start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\n\n            # Count cross pairs where nums[i] > 2 * nums[j]\n            j = mid + 1\n            for i in range(start, mid + 1):\n                while j <= end and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n\n            # Merge the two sorted halves\n            temp = []\n            left, right = start, mid + 1\n            while left <= mid and right <= end:\n                if nums[left] <= nums[right]:\n                    temp.append(nums[left])\n                    left += 1\n                else:\n                    temp.append(nums[right])\n                    right += 1\n            while left <= mid:\n                temp.append(nums[left])\n                left += 1\n            while right <= end:\n                temp.append(nums[right])\n                right += 1\n\n            nums[start:end + 1] = temp\n            return count\n\n        return merge_sort(0, len(nums) - 1)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit(0)\n\n    # Extract the list of numbers from the input\n    # Accept inputs like 'nums = [1,2,3]' or just '[1,2,3]'\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group(0)\n    else:\n        nums_str = '[]'  # default empty list if no list found\n\n    try:\n        nums = eval(nums_str)\n        if not isinstance(nums, list):\n            nums = []\n    except Exception:\n        nums = []\n\n    solution = Solution()\n    result = solution.reversePairs(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,4,3,5,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode443.json",
    "problem_index_in_file": 0,
    "title": "String Compression",
    "description_snippet": "Given an array of characters chars, compress it using the following algorithm:\n\nBegin with an empty ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, no actual code, just steps. Must include Start, End, Decision etc. Also must show constants. Provide algorithm for in-place compression of char array. Use two pointers: write index and read index. Steps: initialize write=0; i=0; while i < n: char=chars[i]; count=0; while i < n and chars[i]==char: count++; i++; // count group. write chars[write++] = char; if count>1: convert count to digits string; for each digit: write chars[write++] = digit; end loops. After loop return write as new length. Must mention constant space: only few integers and temporary string for count digits? But converting count to string uses O(log count) temp, but that's constant relative to input? It's still extra space maybe not allowed but algorithm typically uses O(1) aside from digits buffer. But we can compute digits into array of length up to 5? We'll produce step: convert count to array of digits. That's constant because digits length <= number of digits of max count (10^9?). It's constant relative to input length? Actually digits can be up to length of n, but worst-case count could be n; but if n large, digits length ~ log n; but still could be O(log n). But typical solution uses O(1) space excluding output. We can accept that.\n\nLet's produce virtual code lines accordingly.\n\nMake sure each line ends with // explanation.\n\nOk produce lines:\n\nStart // start program\n→ Step 1: n ← length of chars // get array length\n→ Step 2: write ← 0 // write pointer for compressed result\n→ Step 3: i ← 0 // read pointer for traversal\n→ Decision: i < n? // start scanning groups\n    Yes → Step 4: char ← chars[i] // current group character\n    → Step 5: count ← 0 // counter for current group\n    → While i < n and chars[i] == char: // count group\n        → count ← count + 1\n        → i ← i + 1\n    → Step 6: chars[write] ← char // write the character\n    → write ← write + 1\n    → Decision: count == 1? // group size 1\n        No → Step 7: numStr ← string representation of count // convert count to string\n        → Step 8: for each digit d in numStr: // write each digit\n            → chars[write] ← d\n            → write ← write + 1\n    → Decision: i < n? // more groups to process\n        Yes → (loop back to Step 4)\n        No  → (exit loop)\n→ Step 9: return write // new length of compressed array\nEnd // program end\n\nBut we need to follow required format: each line: virtual code step + space + // explanation. Use arrow for decisions. Let's craft carefully.\n\nWe also need to include arrow for loop. Maybe we use → and arrows.\n\nWe'll produce as lines:\n\nStart // 程式開始執行\n\n→ Step 1: n ← len(chars) // 取得陣列長度\n\n→ Step 2: write ← 0 // 用於寫入壓縮結果的位置指標\n\n→ Step 3: i ← 0 // 用於遍歷原始字元的位置指標\n\n→ Decision: i < n? // 進入主循環，檢查是否還有字元可處理\n    Yes → Step 4: current ← chars[i] // 讀取目前群組的字元\n    → Step 5: count ← 0 // 初始化此群組的重複次數計數\n    → While i < n and chars[i] == current: // 計算連續相同字元的數量\n        → count ← count + 1\n        → i ← i + 1\n    → Step 6: chars[write] ← current // 將字元寫入結果\n    → write ← write + 1\n    → Decision: count == 1? // 判斷群組大小\n        No → Step 7: numStr ← str(count) // 把計數轉成字串\n        → Step 8: for digit in numStr: // 逐位寫入計數\n            → chars[write] ← digit\n            → write ← write + 1\n    → Decision: i < n? // 是否還有剩餘字元\n        Yes → (回到 Decision i < n?) // 重複主循環\n        No  → (跳出循環)\n→ Step 9: return write // 回傳新的陣列長度\n\nEnd // 程式執行結束\n\nNeed to ensure each line is separate. Also use arrow for \"→\". For the 'for digit in numStr:' line we use arrow. Let's produce final output accordingly.\n\nBut note: we can't include comments inside loops like // loop back. We need to produce line by line. We need to include the arrow for decision lines as 'Decision: ...?'. For loop, we could use 'While ...:' style. Let's produce.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← len(chars) // 取得字元陣列長度  \n→ Step 2: write ← 0 // 用於寫入壓縮後結果的指標  \n→ Step 3: i ← 0 // 用於遍歷原始陣列的指標  \n\n→ Decision: i < n? // 檢查是否還有字元可處理  \n    Yes → Step 4: current ← chars[i] // 讀取目前連續群組的字元  \n    → Step 5: count ← 0 // 初始化此群組的重複次數  \n    → While i < n and chars[i] == current: // 計算連續相同字元的數量  \n        → count ← count + 1  \n        → i ← i + 1  \n    → Step 6: chars[write] ← current // 將字元寫入結果  \n    → write ← write + 1  \n    → Decision: count == 1? // 判斷群組大小是否為 1  \n        No → Step 7: numStr ← str(count) // 將計數轉成字串  \n        → Step 8: for digit in numStr: // 逐位寫入計數字元  \n            → chars[write] ← digit  \n            → write ← write + 1  \n    → Decision: i < n? // 是否還有剩餘字元需要處理  \n        Yes → (回到 Decision i < n?) // 重複主循環  \n        No  → (跳出循環)  \n\n→ Step 9: return write // 回傳壓縮後的新長度  \n\nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def compress(self, chars):\n        \"\"\"\n        In‑place compresses the list of characters `chars` and returns the new length.\n        The algorithm uses two pointers: `write` to write the compressed data and `left`\n        to scan groups of consecutive identical characters.\n        \"\"\"\n        write = 0           # write index for the compressed result\n        left = 0            # read index for the current group\n        n = len(chars)\n\n        while left < n:\n            # Find the end of the current group\n            right = left\n            while right < n and chars[right] == chars[left]:\n                right += 1\n\n            # Write the character\n            chars[write] = chars[left]\n            write += 1\n\n            # Write the count if > 1\n            count = right - left\n            if count > 1:\n                for digit in str(count):\n                    chars[write] = digit\n                    write += 1\n\n            # Move to the next group\n            left = right\n\n        return write\n\n\nif __name__ == \"__main__\":\n    import sys\n    import ast\n\n    # Read the entire input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Extract the list of characters from the input string.\n    # Input is expected to be in the form: chars = [\"a\",\"a\",\"b\",...]\n    try:\n        _, right_side = raw_input.split('=', 1)\n    except ValueError:\n        # If there's no '=', assume the whole input is the list\n        right_side = raw_input\n\n    # Safely evaluate the list expression\n    chars = ast.literal_eval(right_side.strip())\n\n    # Perform compression and output the new length\n    solution = Solution()\n    new_length = solution.compress(chars)\n    print(new_length)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "chars = [\"a\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode674.json",
    "problem_index_in_file": 0,
    "title": "Longest Continuous Increasing Subsequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest continuous increasing sub...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for algorithm to find longest continuous increasing subarray. Steps: Initialize maxLen=1, currentLen=1. Iterate i from 1 to n-1: if nums[i]>nums[i-1] currentLen++ else currentLen=1. maxLen = max(maxLen, currentLen). Finally return maxLen.\n\nWe need to output step by step with virtual code and explanation. Use Start, End, Decision. Provide lines like \"Start // 程式開始執行\". Next \"→ Step 1: 定義 maxLen, currentLen\" etc.\n\nWe should incorporate array length check maybe if array empty return 0? But requirement: given unsorted array return length of longest continuous increasing subsequence. If empty array maybe 0. We'll handle.\n\nThus pseudocode steps:\n\nStart\n→ Step 1: 如果 nums 長度為 0，返回 0 // handle empty array\n→ Step 2: 初始化 maxLen = 1, currentLen = 1 // 至少一個元素\n→ Step 3: 循環 i 從 1 到 nums.length-1 // 遍歷陣列\n    → Decision: 如果 nums[i] > nums[i-1] ?\n        Yes → currentLen = currentLen + 1 // 延伸升序\n        No  → currentLen = 1 // 重置\n    → maxLen = max(maxLen, currentLen) // 更新最大長度\n→ Step 4: 返回 maxLen // 結果\nEnd\n\nBut we need to include virtual code arrow syntax. Use \"→\" before steps. Use \"Decision:\" for if. Use \"Yes →\" and \"No →\" for branches.\n\nAdd explanation after each line.\n\nLet's produce output lines accordingly. Ensure no actual code.\n\nAlso might need to mention reading input array.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 判斷 nums 是否為空陣列 // 若陣列為空，長度為 0  \n→ Decision: 如果 nums.length == 0? // 檢查陣列長度  \n  Yes → Step 2: 回傳 0 // 空陣列無子序列  \n  No  → Step 3: 初始化 maxLen = 1, currentLen = 1 // 至少有一個元素  \n→ Step 4: 從索引 1 開始遍歷 nums // 以檢查相鄰元素  \n  → Decision: 如果 nums[i] > nums[i-1]? // 判斷是否持續升序  \n    Yes → currentLen = currentLen + 1 // 連續升序，長度遞增  \n    No  → currentLen = 1 // 不升序，重置長度  \n  → maxLen = max(maxLen, currentLen) // 更新最大子序列長度  \n→ Step 5: 回傳 maxLen // 將結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLengthOfLCIS(self, nums):\n        \"\"\"返回 nums 的最长连续严格递增子数组长度。\"\"\"\n        if not nums:\n            return 0\n        max_len = 1\n        cur_len = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                cur_len += 1\n                if cur_len > max_len:\n                    max_len = cur_len\n            else:\n                cur_len = 1\n        return max_len\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'nums = [1, 2, 3]' 的字符串，返回列表。\n    \"\"\"\n    # 尋找等號後的部分\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n    # 使用 ast.literal_eval 解析列表\n    try:\n        return ast.literal_eval(list_part)\n    except Exception:\n        return []\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    nums = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findLengthOfLCIS(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode541.json",
    "problem_index_in_file": 0,
    "title": "Reverse String II",
    "description_snippet": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. For the given problem. We must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows, decisions etc. Provide step-by-step algorithm.\n\nWe should start with Start. Use pointer i=0, length n. While i < n. Determine remaining = n - i. If remaining >= 2k: reverse substring s[i:i+k], leave next k as is. i += 2k. Else if remaining >= k: reverse substring s[i:i+k], leave rest. i += remaining. Else (remaining < k): reverse s[i:n]. i += remaining. End.\n\nWe need to produce virtual code lines: Start, Step: initialize variables, Step: while loop, Decision: etc. Use arrow indentation. Let's produce lines.\n\nBe careful: Use \"→\" arrow before each step line. Indentation maybe with spaces? In example, they had indentation spaces and arrows for steps inside decision. Use \"Decision:\" lines with indent.\n\nLet's produce:\n\nStart\n→ Step 1: 設定 n = s.length // 字串長度\n→ Step 2: 設定 i = 0 // 從頭開始索引\n→ Decision: i < n? // 是否還有未處理字元\n    Yes → Step 3: 計算 remaining = n - i // 剩餘字元數\n    → Decision: remaining >= 2k? // 能否完整處理兩段\n        Yes → Step 4: reverse s[i:i+k] // 反轉第一段 k 字元\n        → Step 5: keep s[i+k:i+2k] // 保持後續 k 字元不變\n        → Step 6: i = i + 2k // 移動到下一個 2k 區段\n        No  → Decision: remaining >= k? // 只剩下 1~2k 字元\n            Yes → Step 7: reverse s[i:i+k] // 反轉第一段 k 字元\n            → Step 8: keep s[i+k:n] // 保持剩餘字元不變\n            → Step 9: i = n // 所有字元已處理\n            No  → Step 10: reverse s[i:n] // 反轉剩餘少於 k 的字元\n            → Step 11: i = n // 完成\n    → End While\nEnd\n\nBut we need to ensure arrow and indentation. Use spaces for indentation under Decision. In example they had:\n\n    Yes → Step 2: 輸出 '正數' // If positive\n\nWe should mimic that. For nested decisions we indent.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n = s.length // 取得字串長度  \n→ Step 2: 設定 i = 0 // 從字串起始位置開始  \n→ Decision: i < n? // 是否還有未處理的字元  \n    Yes → Step 3: 計算 remaining = n - i // 剩餘字元數  \n    → Decision: remaining >= 2k? // 是否能完整處理兩段 2k  \n        Yes → Step 4: reverse s[i : i + k] // 反轉前 k 個字元  \n        → Step 5: 保持 s[i + k : i + 2k] // 後 k 個字元保持原順序  \n        → Step 6: i = i + 2k // 移動到下一個 2k 區段  \n        No  → Decision: remaining >= k? // 只剩下 k ~ 2k 個字元  \n            Yes → Step 7: reverse s[i : i + k] // 反轉前 k 個字元  \n            → Step 8: 保持 s[i + k : n] // 其餘字元保持原順序  \n            → Step 9: i = n // 所有字元已處理  \n            No  → Step 10: reverse s[i : n] // 反轉剩餘少於 k 個字元  \n            → Step 11: i = n // 完成處理  \n    → End While  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseStr(self, s: str, k: int) -> str:\n        \"\"\"Reverse every first k characters in each 2k block of the string.\"\"\"\n        s_list = list(s)\n        n = len(s_list)\n        for i in range(0, n, 2 * k):\n            # reverse the first k characters in the current 2k block\n            s_list[i:i + k] = reversed(s_list[i:i + k])\n        return \"\".join(s_list)\n\ndef parse_input(line: str):\n    \"\"\"Parse input in the form: \"<string>\", k  or <string> k.\"\"\"\n    line = line.strip()\n    if not line:\n        return None, None\n    if ',' in line:\n        s_part, k_part = line.split(',', 1)\n    else:\n        parts = line.split()\n        s_part, k_part = parts[0], parts[1] if len(parts) > 1 else '0'\n    s_part = s_part.strip()\n    k_part = k_part.strip()\n    # Remove surrounding quotes if present\n    if (s_part.startswith('\"') and s_part.endswith('\"')) or (s_part.startswith(\"'\") and s_part.endswith(\"'\")):\n        s = s_part[1:-1]\n    else:\n        s = s_part\n    k = int(k_part)\n    return s, k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s, k = parse_input(data)\n    if s is not None:\n        solution = Solution()\n        result = solution.reverseStr(s, k)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abcdefg\", 2",
          "expected_output": "\"bacdfeg\"",
          "success": true,
          "output": "bacdfeg"
        },
        {
          "example_index": 1,
          "input": "\"abcd\", 2",
          "expected_output": "\"bacd\"",
          "success": true,
          "output": "bacd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode188.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock IV",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: maximum profit with at most k transactions. Classic DP. We need to write virtual code: Start, steps: input, initialization of DP arrays, loops, decisions.\n\nWe need to adhere to the output format: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow \"→\" and \"Decision:\" and \"Yes →\", \"No →\".\n\nWe need to produce steps, not actual code, but algorithmic steps.\n\nWe'll produce steps:\n\nStart\n→ Input array prices, integer k // get inputs\n→ Decision: if k >= prices.length/2? // if unlimited transactions\n    Yes → Step: set totalProfit = 0; for each day add positive difference // accumulate\n    No → Step: initialize two arrays dpBuy and dpSell size k+1 // store best profit after i buys/sells\n→ For each day from 0 to n-1\n    → For each transaction count t from 1 to k\n        → Decision: profitIfBuy = dpSell[t-1] - prices[day] // profit after buying\n            Yes → Update dpBuy[t] = max(dpBuy[t], profitIfBuy) // maintain max\n        → Decision: profitIfSell = dpBuy[t] + prices[day] // profit after selling\n            Yes → Update dpSell[t] = max(dpSell[t], profitIfSell) // maintain max\n→ Result: dpSell[k] // maximum profit\nEnd\n\nWe need to use arrow formatting: \"→ Step ...\" and \"Decision:\" etc. Each line separate.\n\nAlso include loops: \"→ For each day ...\". Inside, we need nested loops.\n\nLet's produce step lines.\n\nWe must include \"Start // 程式開始執行\".\n\nWe must use \"End // 程式執行結束\".\n\nWe'll also use \"Decision:\" lines.\n\nWe need to explain each line. Provide short intuitive explanation.\n\nMake sure each line starts with \"→\" or \"Decision:\" etc. Also \"Yes →\" and \"No →\" lines under decisions. For loop we can do \"→ For i = 0 to n-1 // 遍歷每天\" etc.\n\nWe need to be consistent with the arrow style: Use \"→\" before step. For decision: \"Decision: ... // ...\". Then \"Yes →\" etc.\n\nWe need to include the final profit output step.\n\nLet's craft.\n\nWe will also include \"Step: ...\".\n\nWe need to ensure not actual code.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 讀取整數陣列 prices 以及整數 k // 取得輸入  \n→ Decision: 是否 k 大於等於 prices.length / 2? // 檢查是否可以視為無限交易  \n    Yes → Step: 計算無限交易最大利潤  \n        → For i = 1 to prices.length-1 // 遍歷相鄰天數  \n            → Decision: 若 prices[i] > prices[i-1]? // 當天價格比前一天高  \n                Yes → Step: totalProfit += prices[i] - prices[i-1] // 累加利潤  \n    No  → Step: 初始化兩個陣列 dpBuy[0..k] 與 dpSell[0..k]  \n        → Step: dpBuy[*] = -∞, dpSell[*] = 0 // 先設為負無限和 0  \n→ For day = 0 to prices.length-1 // 遍歷每一天  \n    → For t = 1 to k // 每一筆交易次數  \n        → Decision: 先買入：profitIfBuy = dpSell[t-1] - prices[day]  \n            Yes → Step: dpBuy[t] = max(dpBuy[t], profitIfBuy) // 更新最優買入利潤  \n        → Decision: 再賣出：profitIfSell = dpBuy[t] + prices[day]  \n            Yes → Step: dpSell[t] = max(dpSell[t], profitIfSell) // 更新最優賣出利潤  \n→ Step: 計算最終利潤 = dpSell[k] // 最多 k 次交易的最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, k, prices):\n        n = len(prices)\n        if n == 0:\n            return 0\n        # If k is large enough, treat as unlimited transactions\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        # DP approach: dpBuy[t] is max profit after buying t-th stock,\n        # dpSell[t] is max profit after selling t-th stock\n        dpBuy = [-float('inf')] * (k + 1)\n        dpSell = [0] * (k + 1)\n        for day in range(n):\n            for t in range(1, k + 1):\n                # Update the best profit after buying t-th stock\n                dpBuy[t] = max(dpBuy[t], dpSell[t - 1] - prices[day])\n                # Update the best profit after selling t-th stock\n                dpSell[t] = max(dpSell[t], dpBuy[t] + prices[day])\n        return dpSell[k]\n\ndef main():\n    data = sys.stdin.read()\n    # Extract all integers from input\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        return\n    k = nums[0]\n    prices = nums[1:]\n    result = Solution().maxProfit(k, prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode522.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence II",
    "description_snippet": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to solve problem. Steps: iterate unique strings, check if not subsequence of any other. Use subsequence check function. Return length of longest such string, else -1. Provide virtual code lines. Use structure Start, Decision, Yes/No arrows.\n\nLet's draft.\n\nStart\n→ Step 1: Sort strings by length descending // helps find longest first\n→ Step 2: For each string s in sorted list\n    → Decision: Is there any other string t such that s is subsequence of t? // if yes skip\n        Yes → Continue // move to next string\n        No  → Return length of s // found uncommon subsequence\n→ Step 3: Return -1 // no uncommon subsequence\n\nWe need subsequence check. Define helper.\n\nAdd Step 0: Define function IsSubsequence(a,b) // check if a subsequence of b\n\nBut we can include inside decision.\n\nLet's produce lines. Use indentation.\n\nNeed to adhere to format: each line `虛擬碼步驟 [space] // 解釋`.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 0: 定義函式 IsSubsequence(a, b) // 檢查 a 是否為 b 的子序列\n    → Step 0.1: 初始化指標 i = 0, j = 0 // i 遍歷 a, j 遍歷 b\n    → Decision: i < len(a)? // 尚未遍歷完 a\n        Yes → Decision: j < len(b)? // j 仍在 b 的範圍內\n            Yes → Decision: a[i] == b[j]? // 字符相等\n                Yes → i = i + 1 // 移動 a 的指標\n                No  → // 不相等\n            No  → // j 超出範圍，a 不是子序列\n        No → // i 已達到 len(a)\n    → Decision: i == len(a)? // 是否已遍歷完 a\n        Yes → Return True // a 為 b 的子序列\n        No  → Return False // a 不是子序列\n→ Step 1: 將輸入字串陣列 strs 依長度遞減排序 // 先檢查最長字串\n→ Step 2: For each string s in strs // 逐一檢查\n    → Decision: 是否存在其他字串 t 使得 IsSubsequence(s, t) 為真? // s 在 t 中是子序列\n        Yes → // s 不是不常見子序列，繼續下一個\n        No  → Return len(s) // 找到最長的不常見子序列，返回長度\n→ Step 3: Return -1 // 未找到任何不常見子序列\nEnd // 程式執行結束\n\nNeed to format decision arrows properly. Provide each decision line with Yes →, No →. For nested, use indentation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 定義函式 IsSubsequence(a, b) // 檢查 a 是否為 b 的子序列  \n  → Step 0.1: 初始化 i = 0, j = 0 // i 遍歷 a，j 遍歷 b  \n  → Decision: i < len(a)? // 尚未遍歷完 a  \n   Yes → Decision: j < len(b)? // j 仍在 b 的範圍內  \n    Yes → Decision: a[i] == b[j]? // 字符相等  \n     Yes → i = i + 1 // 移動 a 的指標  \n     No  → // 字符不相等，跳過 j  \n   No  → // j 超出範圍，a 不是子序列，直接回傳 False  \n  → Decision: i == len(a)? // 是否已遍歷完 a  \n   Yes → Return True // a 為 b 的子序列  \n   No  → Return False // a 不是子序列  \n→ Step 1: 將輸入字串陣列 strs 依長度遞減排序 // 先檢查最長字串  \n→ Step 2: For each string s in strs // 逐一檢查  \n  → Decision: 是否存在其他字串 t 使得 IsSubsequence(s, t) 為真? // s 在 t 中是子序列  \n   Yes → // s 不是不常見子序列，繼續下一個  \n   No  → Return len(s) // 找到最長的不常見子序列，返回長度  \n→ Step 3: Return -1 // 未找到任何不常見子序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLUSlength(self, strs):\n        # 先按長度遞減排序，方便一次找到最長的不常見子序列\n        strs.sort(key=lambda x: -len(x))\n        for i, s in enumerate(strs):\n            # 若 s 不是任何其他字串的子序列，即為不常見子序列\n            if all(not self.is_subsequence(s, t) for j, t in enumerate(strs) if i != j):\n                return len(s)\n        return -1\n\n    def is_subsequence(self, s, t):\n        # 使用 iterator 進行子序列判斷\n        it = iter(t)\n        return all(c in it for c in s)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容，轉換為字串列表\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        print(-1)\n        sys.exit(0)\n    # 解析為 Python list，安全地使用 literal_eval\n    try:\n        strs = ast.literal_eval(input_data)\n    except Exception:\n        print(-1)\n        sys.exit(0)\n    # 確保輸入是一個字串列表\n    if not isinstance(strs, list) or not all(isinstance(x, str) for x in strs):\n        print(-1)\n        sys.exit(0)\n    sol = Solution()\n    result = sol.findLUSlength(strs)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"aba\",\"cdc\",\"eae\"]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode413.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices",
    "description_snippet": "An integer array is called arithmetic if it consists of at least three elements and if the differenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Input: integer array nums. Output: number of arithmetic subarrays. Approach: iterate with diff tracking. Use DP counting consecutive arithmetic sequences. Classic solution: maintain count of arithmetic subarrays ending at index i. For i >= 2, if nums[i] - nums[i-1] == nums[i-1] - nums[i-2], then current length increases: currLen++ else currLen=2. Then add currLen-2 to answer. Virtual code steps accordingly.\n\nNeed each line with // explanation. Use Start, Decision etc. We'll produce pseudo code. Use arrows. Each step simple.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize ans = 0 // 存儲結果\n→ Step 2: If length of nums < 3 → End // 小於三個元素無子陣列\n→ Step 3: Initialize prevDiff = nums[1] - nums[0] // 前一次差值\n→ Step 4: Initialize currLen = 2 // 目前連續算術子陣列長度\n→ For i from 2 to len-1: // 遍歷陣列\n    → Step 5: diff = nums[i] - nums[i-1] // 計算當前差值\n    → Decision: diff == prevDiff? // 是否繼續算術子陣列\n        Yes → Step 6: currLen = currLen + 1 // 延長長度\n        No  → Step 7: currLen = 2 // 重置長度為 2\n    → Step 8: prevDiff = diff // 更新前一次差值\n    → Decision: currLen >= 3? // 是否至少三個元素形成算術子陣列\n        Yes → Step 9: ans = ans + (currLen - 2) // 追加新的子陣列數\n        No  → No action\n→ End\n\nBut need to use \"Decision:\" lines for yes/no. Ensure format: \"Decision: ...\" then indent Yes/No. Provide explanation after each line.\n\nAlso include Step numbers maybe. Provide explanation. Let's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: ans = 0 // 用來累計所有算術子陣列的個數\n→ Step 2: If nums.length < 3 → End // 小於三個元素不可能有算術子陣列，直接結束\n→ Step 3: prevDiff = nums[1] - nums[0] // 計算第一對相鄰元素的差值\n→ Step 4: currLen = 2 // 目前已經確認的連續算術子陣列長度，起始為兩個元素\n→ For i = 2 to nums.length - 1: // 從第三個元素開始檢查\n    → Step 5: diff = nums[i] - nums[i-1] // 取得當前相鄰元素的差值\n    → Decision: diff == prevDiff? // 判斷是否與前一個差值相同\n        Yes → Step 6: currLen = currLen + 1 // 差值相同，延長連續算術子陣列\n        No  → Step 7: currLen = 2 // 差值不同，重置連續長度為兩個元素\n    → Step 8: prevDiff = diff // 更新前一個差值為目前的差值\n    → Decision: currLen >= 3? // 檢查是否形成至少三個元素的算術子陣列\n        Yes → Step 9: ans = ans + (currLen - 2) // 每延長一個長度，會產生一個新的算術子陣列\n        No  → No action // 長度不足三個，無新子陣列\n→ End // 程式執行結束，ans即為答案\n```",
      "generated_code": "import sys\nimport ast\n\ndef number_of_arithmetic_slices(nums):\n    \"\"\"計算所有至少三個元素的等差子陣列個數。\"\"\"\n    n = len(nums)\n    if n < 3:\n        return 0\n\n    total = 0          # 統計所有等差子陣列的個數\n    curr = 0           # 以 nums[i] 為結尾的等差子陣列數量\n\n    for i in range(2, n):\n        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n            curr += 1          # 連續等差子陣列延長\n            total += curr      # 每延長一次都多出 curr 個新的子陣列\n        else:\n            curr = 0           # 差值不一致，重置\n\n    return total\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'nums = [1,2,3,4]' 的輸入。\n    只取等號右邊的列表字面量並安全地評估。\n    \"\"\"\n    if '=' in data:\n        _, right = data.split('=', 1)\n    else:\n        right = data\n    right = right.strip()\n    # 使用 ast.literal_eval 以防止 eval 的安全風險\n    return ast.literal_eval(right)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums = parse_input(data)\n    result = number_of_arithmetic_slices(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode345.json",
    "problem_index_in_file": 0,
    "title": "Reverse Vowels of a String",
    "description_snippet": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e',...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. Need to include steps: Start, input string s, find vowels positions, reverse vowels, build output. Use virtual code with arrows and decisions. Must not output actual code. Provide each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision etc.\n\nWe need to cover the algorithm: Two pointers left and right; while left < right: move left until vowel, move right until vowel, swap, left++, right--. Build result string or list. End.\n\nAlso maybe we need to use list conversion. Steps: Convert string to char list, identify vowels set.\n\nLet's produce a step-by-step. Ensure each line ends with comment. Use virtual arrow. Use \"Decision: ...\" with Yes/No. Let's include Start, End.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 定義可逆元音集合 vowels = {'a','e','i','o','u','A','E','I','O','U'} // 定義所有元音\n\n→ Step 2: 將輸入字串 s 轉成可變的字符列表 chars // 方便交換字符\n\n→ Step 3: 初始化兩個指標 left = 0, right = len(chars) - 1 // 指向兩端\n\n→ Decision: 是否還有左指標 < 右指標? // 判斷是否需要繼續\n\n    Yes → Step 4: Decision: chars[left] 是否屬於 vowels? // 找左端元音\n\n        Yes → Step 5: Decision: chars[right] 是否屬於 vowels? // 找右端元音\n\n            Yes → Step 6: Swap chars[left] 與 chars[right] // 交換兩個元音\n\n            No  → Step 7: right = right - 1 // 右指標往左移\n\n        No  → Step 8: left = left + 1 // 左指標往右移\n\n    No  → Step 9: Convert chars 為字串 result // 轉回字串\n\n→ End // 程式結束\n\nBut we need to reflect that Step 5's No branch moves right pointer; but after that we need to continue loop. So better structure:\n\nUse while loop: while left < right. Inside: if chars[left] not vowel, left++ else if chars[right] not vowel, right-- else swap and left++ right--.\n\nSimplify: Step 4: Decision: chars[left] is vowel? etc.\n\nLet's structure:\n\n→ Step 4: Decision: chars[left] 是元音? // 判斷左端字符是否為元音\n\n    Yes → Step 5: Decision: chars[right] 是元音? // 判斷右端字符是否為元音\n\n        Yes → Step 6: Swap chars[left] 與 chars[right] // 交換兩個元音\n\n               Step 7: left = left + 1; right = right - 1 // 移動兩個指標\n\n        No  → Step 8: right = right - 1 // 右指標往左移\n\n    No  → Step 9: left = left + 1 // 左指標往右移\n\nAfter step 9 or step 8, we loop back to Decision left < right.\n\nLet's produce final output accordingly. Ensure each line has comment after //.\n\nUse 虛擬碼步驟 as described: e.g., \"Start\", \"→ Step 1: ...\". Use \"Decision:\" lines. Provide arrow lines accordingly.\n\nMake sure each line includes \" // 解釋\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義元音集合 vowels = {'a','e','i','o','u','A','E','I','O','U'} // 定義所有可逆的元音  \n→ Step 2: 將輸入字串 s 轉成可變字符列表 chars = list(s) // 方便交換字符  \n→ Step 3: 初始化左指標 left = 0, 右指標 right = len(chars) - 1 // 指向字串兩端  \n→ Decision: 是否還有 left < right? // 判斷是否需要繼續處理  \n    Yes → Step 4: Decision: chars[left] 是元音? // 判斷左端字符是否為元音  \n        Yes → Step 5: Decision: chars[right] 是元音? // 判斷右端字符是否為元音  \n            Yes → Step 6: Swap chars[left] 與 chars[right] // 交換左右兩個元音  \n            No  → Step 7: right = right - 1 // 右指標往左移  \n        No  → Step 8: left = left + 1 // 左指標往右移  \n    No  → Step 9: result = ''.join(chars) // 轉回字串作為結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef reverse_vowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')\n    chars = list(s)\n    left, right = 0, len(chars) - 1\n    while left < right:\n        while left < right and chars[left] not in vowels:\n            left += 1\n        while left < right and chars[right] not in vowels:\n            right -= 1\n        if left < right:\n            chars[left], chars[right] = chars[right], chars[left]\n            left += 1\n            right -= 1\n    return ''.join(chars)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 抓取雙引號內的內容，如果有的話；否則直接使用整行字串\n    match = re.search(r'\"([^\"]*)\"', data)\n    s = match.group(1) if match else data\n    result = reverse_vowels(s)\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"IceCreAm\"",
          "expected_output": "\"AceCreIm\"",
          "success": true,
          "output": "\"AceCreIm\""
        },
        {
          "example_index": 1,
          "input": "s = \"leetcode\"",
          "expected_output": "\"leotcede\"",
          "success": true,
          "output": "\"leotcede\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode464.json",
    "problem_index_in_file": 0,
    "title": "Can I Win",
    "description_snippet": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The p...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the game with no reuse integers. We need to outline algorithm: use recursion with memoization on bitmask representing available numbers, and DP to determine if current player can force win.\n\nWe need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 canWin(availableMask, currentSum) // ...\n...\n\nWe need to cover base cases: if any chosen number >= remaining needed to reach desiredTotal, return true. If no numbers left, return false.\n\nUse memoization dictionary mapping mask to bool.\n\nImplement loop over all numbers not used: for i in 1..maxChoosableInteger: if mask bit i-1 is 0, then choose it: newMask = mask | (1<<(i-1)), if not canWin(newMask, currentSum + i) then current player can win.\n\nAlso consider early exit if currentSum + i >= desiredTotal.\n\nAlso handle impossible case: sum of all numbers < desiredTotal → return false.\n\nLet's craft virtual code.\n\nWe need to keep each line and explanation.\n\nLet's produce step-by-step:\n\nStart // 程式開始執行\n→ Step 1: If sum(1..maxChoosableInteger) < desiredTotal → return False // 整體總和不足以達到目標，第一玩家無法贏\n\nDefine memo = {} // 用於儲存已計算的子問題結果\n\nDefine function canWin(mask, currentSum):\n    // mask 代表已被選取的數字，1 表示已用，0 表示可用\n    // currentSum 為目前累計總和\n\nInside function:\n→ If (mask, currentSum) in memo → return memo[(mask,currentSum)] // 直接回傳已計算結果\n\n→ For i from 1 to maxChoosableInteger:\n        bit = 1 << (i-1)\n        If mask & bit == 0: // i 未被使用\n            If currentSum + i >= desiredTotal → memo[(mask,currentSum)] = True; return True // 直接贏\n            // 否則遞迴對方\n            nextMask = mask | bit\n            If not canWin(nextMask, currentSum + i): // 對手無法贏\n                memo[(mask,currentSum)] = True\n                return True\n\n→ After loop → memo[(mask,currentSum)] = False\n→ Return False // 無法贏\n\nFinally call canWin(0, 0) and return that value.\n\nWe need to include \"Decision:\" lines where branching occurs. Use arrow lines.\n\nAlso we need to include comments after each line.\n\nLet's produce step lines.\n\nWill we include variable declarations for maxChoosableInteger and desiredTotal? They are given as input; we can assume they are accessible.\n\nLet's produce.\n\nWe need to ensure to use \"Start\" and \"End\" markers.\n\nLet's craft.\n\nWe'll produce lines:\n\nStart // 程式開始\n\n→ Decision: 如果 sum(1..maxChoosableInteger) < desiredTotal? // 檢查整體總和是否足夠\n    Yes → End // 返回 False，因無法達成目標\n\n→ Step 1: 定義 memo = {} // 建立記憶化資料結構\n\n→ Function: canWin(mask, currentSum) // 以遞迴方式判斷是否能贏\n    // 內部結構：\n\n→ Decision: 如果 (mask, currentSum) 存在於 memo? // 已計算過\n        Yes → Return memo[(mask,currentSum)] // 直接回傳\n\n→ Step 2: 對 i 迭代從 1 到 maxChoosableInteger\n        // 逐一檢查未被使用的數字\n\n→ Decision: 如果 mask 中第 (i-1) 位為 0? // i 未被選\n            Yes → Step 3: 计算 newSum = currentSum + i\n            → Decision: 如果 newSum >= desiredTotal? // 直接達成目標\n                Yes → memo[(mask,currentSum)] = True\n                → End 函式 // 返回 True\n\n→ Step 4: 否則 // 遞迴判斷對手是否無法贏\n                → Step 5: newMask = mask | (1 << (i-1))\n                → Step 6: 如果 not canWin(newMask, newSum)? // 對手無法贏\n                    → memo[(mask,currentSum)] = True\n                    → End 函式 // 返回 True\n\n→ End for 循環\n\n→ Step 7: memo[(mask,currentSum)] = False\n→ End 函式 // 返回 False\n\n→ Step 8: Return canWin(0, 0) // 從空掩碼和總和0開始判斷\n\nEnd // 程式執行結束\n\nBut we must use syntax: arrows, Decision, Yes →, No →, etc.\n\nLet's refine into proper format. For loop we can use \"→ Step 2: For i in 1..maxChoosableInteger\" with indentation? The example didn't show loops but we can incorporate.\n\nWe'll maintain consistent style.\n\nWe need to produce each line exactly with \"→\" preceding step names. For loops, we may have nested decisions. The example uses \"Decision:\" and then sub-lines with Yes → and No →.\n\nWe'll mimic that style.\n\nLet's structure:\n\nStart // 程式開始執行\n\n→ Decision: sum(1..maxChoosableInteger) < desiredTotal? // 檢查整體總和是否足夠\n    Yes → End // 直接返回 False，無法達成目標\n    No  → // 繼續執行\n\n→ Step 1: 定義 memo = {} // 建立記憶化資料結構\n\n→ Function: canWin(mask, currentSum) // 以遞迴方式判斷是否能贏\n    // 內部結構:\n\n    → Decision: (mask, currentSum) 是否存在於 memo? // 已計算過\n        Yes → Return memo[(mask,currentSum)] // 直接回傳\n\n    → Step 2: 對 i 迭代從 1 到 maxChoosableInteger // 逐一檢查未被使用的數字\n        // 這裡使用箭頭和縮排表示\n\n        → Decision: mask & (1 << (i-1)) == 0? // i 未被選\n            Yes →\n                → Step 3: newSum = currentSum + i // 取得新總和\n                → Decision: newSum >= desiredTotal? // 是否直接贏\n                    Yes →\n                        → Step 4: memo[(mask,currentSum)] = True\n                        → End 函式 // 返回 True\n                    No  →\n                        → Step 5: newMask = mask | (1 << (i-1)) // 標記 i 已使用\n                        → Decision: not canWin(newMask, newSum)? // 對手是否無法贏\n                            Yes →\n                                → Step 6: memo[(mask,currentSum)] = True\n                                → End 函式 // 返回 True\n                            No  → // 這條路徑對手能贏，繼續迴圈\n\n    → Step 7: memo[(mask,currentSum)] = False // 所有選項都無法贏\n    → End 函式 // 返回 False\n\n→ Step 8: Return canWin(0, 0) // 從空掩碼和總和0開始判斷\n\nEnd // 程式執行結束\n\nNeed to ensure each line ends with `// 解釋/說明`. Use consistent.\n\nAlso need to keep arrow lines: each line starting with `→`. But first decision line not preceded by arrow? The example shows `Start` without arrow. Then `→ Step 1:` etc. So we should start with `Start`. Then next lines all with arrow. Decision lines are preceded by `Decision:` inside. The sub-lines inside decision are prefixed with `Yes →`, `No →`. So we need to format accordingly.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: sum(1..maxChoosableInteger) < desiredTotal? // 檢查整體可用數字總和是否足夠  \n  Yes → End // 直接返回 False，無法達成目標  \n  No  → // 繼續執行  \n→ Step 1: 定義 memo = {} // 建立記憶化資料結構  \n→ Function: canWin(mask, currentSum) // 以遞迴方式判斷目前玩家能否贏  \n  Decision: (mask, currentSum) 是否存在於 memo? // 已計算過  \n   Yes → Return memo[(mask,currentSum)] // 直接回傳已知結果  \n  Step 2: For i 1 to maxChoosableInteger // 逐一檢查未被使用的數字  \n   Decision: mask & (1 << (i-1)) == 0? // i 未被選  \n    Yes →  \n     Step 3: newSum = currentSum + i // 取得新總和  \n     Decision: newSum >= desiredTotal? // 是否能直接達成目標  \n      Yes →  \n       Step 4: memo[(mask,currentSum)] = True // 記錄能贏  \n       End 函式 // 返回 True  \n      No  →  \n       Step 5: newMask = mask | (1 << (i-1)) // 標記 i 已使用  \n       Decision: not canWin(newMask, newSum)? // 對手是否無法贏  \n        Yes →  \n         Step 6: memo[(mask,currentSum)] = True // 能贏  \n         End 函式 // 返回 True  \n       No  → // 這條路徑對手能贏，繼續迴圈  \n  Step 7: memo[(mask,currentSum)] = False // 所有選項都無法贏  \n  End 函式 // 返回 False  \n→ Step 8: Return canWin(0, 0) // 從空掩碼與總和 0 開始判斷  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        # If desiredTotal is 0 or less, the first player wins immediately\n        if desiredTotal <= 0:\n            return True\n        # If the sum of all available numbers is less than desiredTotal,\n        # it is impossible to reach the target\n        if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\n            return False\n\n        memo = {}\n\n        def can_win(used_mask: int, remaining: int) -> bool:\n            # Check memoized result\n            if used_mask in memo:\n                return memo[used_mask]\n\n            # Try every unused number\n            for i in range(maxChoosableInteger):\n                bit = 1 << i\n                if not (used_mask & bit):  # number i+1 is still available\n                    val = i + 1\n                    # If picking this number reaches or exceeds the target,\n                    # the current player wins immediately\n                    if val >= remaining:\n                        memo[used_mask] = True\n                        return True\n                    # Otherwise, simulate the opponent's turn\n                    if not can_win(used_mask | bit, remaining - val):\n                        memo[used_mask] = True\n                        return True\n\n            # No winning move found\n            memo[used_mask] = False\n            return False\n\n        return can_win(0, desiredTotal)\n\ndef main():\n    # Read entire stdin, extract integers\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return  # Not enough input data\n    maxChoosableInteger, desiredTotal = nums[0], nums[1]\n    solution = Solution()\n    result = solution.canIWin(maxChoosableInteger, desiredTotal)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "maxChoosableInteger = 10, desiredTotal = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "maxChoosableInteger = 10, desiredTotal = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "maxChoosableInteger = 10, desiredTotal = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode122.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock II",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem \"Best Time to Buy and Sell Stock II\" (allow multiple transactions, at most one share at any time). We need to produce pseudocode with arrows, decisions, etc. Provide explanation after each line. Should be line-by-line. No actual code. The user wants the virtual code and explanation. We'll produce steps: Start, initialize cash=0, hold= -prices[0] or 0? For at most one share, we can use DP: hold is max profit holding a stock, cash is max profit not holding. Initialize hold = -infinity (or -prices[0]?), cash = 0. Then iterate over prices: new_cash = max(cash, hold + price), new_hold = max(hold, cash - price). Finally return cash. Provide explanation. Use \"Start\", \"End\". Use decision? We can include decision to update each. But we might not need explicit decision nodes; but can include decision: if price > previous? But typical algorithm is iterative with max. We can represent decision as conditional updates. Let's produce each line:\n\nStart // 開始程式\n→ Step 1: 初始化 cash = 0 // 初始不持有股票的最大利潤\n→ Step 2: 初始化 hold = -∞ // 初始持有股票的最大利潤為負無窮\n→ Step 3: 循環遍歷 prices[0..n-1] // 逐天計算\n   → Step 3.1: 計算 new_cash = max(cash, hold + price) // 賣出股票或保持不動\n   → Step 3.2: 計算 new_hold = max(hold, cash - price) // 買入股票或保持不動\n   → Step 3.3: 更新 cash = new_cash\n   → Step 3.4: 更新 hold = new_hold\nEnd // 回傳 cash\n\nBut we need to include explanations after each line. Also we can include decision arrows: Decision: if price > hold + price? but that might be too detailed.\n\nMaybe produce: Step: new_cash ← max(cash, hold + price) // compute best profit when not holding\nNo further decisions. But the requirement is to use arrow and decisions structure. We can incorporate decisions: Decision: if hold + price > cash? -> new_cash = hold + price else cash. But we can use simplified pseudocode with max.\n\nBetter produce:\n\nStart // 程式開始\n→ Step 1: cash ← 0 // 不持有股票時的最大利潤為 0\n→ Step 2: hold ← -∞ // 沒有股票時持有狀態設為負無窮\n→ Step 3: for price in prices: // 遍歷每一天的股價\n    → Decision: 是否賣出? // 檢查賣出是否能提高利潤\n        Yes → new_cash ← hold + price // 賣出後利潤\n        No  → new_cash ← cash // 保持不變\n    → Decision: 是否買入? // 檢查買入是否能提升持股利潤\n        Yes → new_hold ← cash - price // 買入後持股利潤\n        No  → new_hold ← hold // 保持不變\n    → Step 4: cash ← new_cash // 更新不持有狀態\n    → Step 5: hold ← new_hold // 更新持有狀態\nEnd // 程式結束，回傳 cash\n\nBut this uses decisions. Provide explanations.\n\nLet's produce final answer accordingly. Use lines separated. Use arrow `→`. Use \"Start\" and \"End\". Provide explanation. Ensure each line has \"虛擬碼步驟\" and after a space \"// 解釋/說明\". Provide in Traditional Chinese. Use \"Step\" as label. Ensure lines. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: cash ← 0 // 初始化不持有股票時的最大利潤為 0  \n→ Step 2: hold ← -∞ // 初始化持有股票時的最大利潤為負無窮  \n→ Step 3: for price in prices: // 逐天處理股價  \n    → Decision: 是否賣出? // 判斷賣出是否能帶來更高利潤  \n        Yes → new_cash ← hold + price // 賣出股票後得到的利潤  \n        No  → new_cash ← cash // 不賣出，保持原有利潤  \n    → Decision: 是否買入? // 判斷買入是否能提升持股利潤  \n        Yes → new_hold ← cash - price // 買入股票後的持股利潤  \n        No  → new_hold ← hold // 不買入，保持原有持股利潤  \n    → Step 4: cash ← new_cash // 更新不持有狀態的最大利潤  \n    → Step 5: hold ← new_hold // 更新持有狀態的最大利潤  \nEnd // 程式執行結束，回傳 cash 為可取得的最大利潤",
      "generated_code": "import sys\nimport ast\n\ndef max_profit(prices):\n    \"\"\"Return the maximum profit achievable with unlimited transactions.\"\"\"\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            profit += prices[i] - prices[i - 1]\n    return profit\n\ndef main():\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 從可能的格式 \"prices = [1,2,3]\" 取得列表\n    try:\n        if '=' in raw_input:\n            _, expr = raw_input.split('=', 1)\n            expr = expr.strip()\n        else:\n            expr = raw_input.strip()\n        prices = ast.literal_eval(expr)\n    except Exception:\n        # 若解析失敗，直接嘗試 eval（僅作備援）\n        prices = eval(raw_input, {}, {})\n\n    # 確保得到的是列表\n    if not isinstance(prices, list):\n        prices = []\n\n    # 計算並輸出結果\n    print(max_profit(prices))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode214.json",
    "problem_index_in_file": 0,
    "title": "Shortest Palindrome",
    "description_snippet": "You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n\nRe...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo code for the algorithm: shortest palindrome by adding characters in front of string s. Classic solution: find longest prefix of s that is palindrome; or compute longest palindromic prefix. Approach: Use KMP on s + '#' + reverse(s). Actually for shortest palindrome, we need longest palindromic prefix, then add reverse of suffix to front. So pseudo:\n\nStart\n→ Input s\n→ Reverse s to rev_s\n→ Create combined = s + '#' + rev_s\n→ Compute lps array for combined (KMP partial match)\n→ palLen = lps[last]\n→ suffix = rev_s[0:len(s)-palLen] ??? Wait we want reverse of suffix that is not in palindrome. Actually suffix = s[palLen:]\n→ reverse suffix to rev_suffix\n→ Result = rev_suffix + s\n→ Output Result\nEnd\n\nExplain steps.\n\nNeed to format per line: Virtual code step + comment.\n\nUse arrow ->, Decision lines? Not necessary as algorithm straightforward.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Input: string s // 取得原始字串\n→ Compute rev_s ← Reverse(s) // 取得 s 的反轉\n→ Build combined ← s + '#' + rev_s // 建立用於 KMP 的串\n→ Compute lps array for combined // KMP 前置函式，計算部分匹配表\n→ palLen ← lps[last_index_of_combined] // 最長的回文前綴長度\n→ suffix ← s[palLen:] // 從原字串截取未包含在回文前綴的部分\n→ rev_suffix ← Reverse(suffix) // 反轉該剩餘部分\n→ result ← rev_suffix + s // 把反轉後的字串加到前面形成最短回文\n→ Output result // 回傳最短回文字串\nEnd // 程式結束\n\nWe can also add steps for computing lps: like iterate.\n\nBut just high level is fine.\n\nHowever instructions ask to use virtual code steps; could include Decision? Not needed. But could include a loop for lps. Provide pseudocode for lps computation.\n\nLet's include:\n\n→ Initialize lps array of length combined_len with zeros\n→ For i from 1 to combined_len-1:\n    → While j > 0 and combined[i] != combined[j] → j = lps[j-1]\n    → If combined[i] == combined[j] → j +=1; lps[i] = j\n\nWe need to maintain j variable.\n\nLet's incorporate into lines.\n\nThus final output lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Input: string s // 取得原始字串  \n→ rev_s ← Reverse(s) // 取得 s 的反轉  \n→ combined ← s + '#' + rev_s // 建立用於 KMP 的串  \n→ lps_len ← Length(combined) // 取得 combined 的長度  \n→ lps ← Array of zeros with size lps_len // 建立部分匹配表  \n→ j ← 0 // 初始化 KMP 的長度指標  \n→ For i from 1 to lps_len-1: // KMP 迴圈  \n    → While j > 0 and combined[i] ≠ combined[j]: // 若不匹配  \n        → j ← lps[j-1] // 回退指標  \n    → If combined[i] = combined[j]: // 匹配  \n        → j ← j + 1  \n        → lps[i] ← j  \n→ palLen ← lps[lps_len-1] // 最長的回文前綴長度  \n→ suffix ← s[palLen:] // 從原字串截取未包含在回文前綴的部分  \n→ rev_suffix ← Reverse(suffix) // 反轉該剩餘部分  \n→ result ← rev_suffix + s // 把反轉後的字串加到前面形成最短回文  \n→ Output result // 回傳最短回文字串  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        if not s:\n            return \"\"\n        # Build the string for KMP: s + '#' + reversed(s)\n        temp = s + '#' + s[::-1]\n        n = len(temp)\n        lps = [0] * n\n        for i in range(1, n):\n            length = lps[i - 1]\n            while length > 0 and temp[i] != temp[length]:\n                length = lps[length - 1]\n            if temp[i] == temp[length]:\n                length += 1\n            lps[i] = length\n        # Characters that need to be added in front\n        to_add = s[lps[-1]:][::-1]\n        return to_add + s\n\ndef extract_string(data: str) -> str:\n    \"\"\"\n    將輸入字串解析成純粹的字串值。\n    支援兩種輸入形式：\n    1. s = 'example'\n    2. example\n    \"\"\"\n    data = data.strip()\n    # 如果輸入包含 's ='\n    if data.lower().startswith(\"s =\"):\n        # 取得等號後面的內容\n        s = data.split('=', 1)[1].strip()\n        # 去除外層單/雙引號\n        if (s.startswith(\"'\") and s.endswith(\"'\")) or (s.startswith('\"') and s.endswith('\"')):\n            s = s[1:-1]\n        return s\n    else:\n        # 直接使用整行文字\n        return data\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    s = extract_string(input_data)\n    solution = Solution()\n    result = solution.shortestPalindrome(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'aacecaaa'",
          "expected_output": "'aaacecaaa'",
          "success": true,
          "output": "aaacecaaa"
        },
        {
          "example_index": 1,
          "input": "s = 'abcd'",
          "expected_output": "'dcbabcd'",
          "success": true,
          "output": "dcbabcd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode713.json",
    "problem_index_in_file": 0,
    "title": "Subarray Product Less Than K",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for sliding window counting subarrays with product < k. Provide line-by-line with explanations.\n\nWe need to include Start, End, Decision, etc. The output should be just pseudocode lines.\n\nEnsure each line includes virtual code step + space + // explanation.\n\nShould use arrows →.\n\nLet's design steps:\n\nStart\n\n→ Initialize count = 0 // number of valid subarrays\n\n→ Initialize product = 1 // product of current window\n\n→ Initialize left = 0 // left index of window\n\n→ For right from 0 to length-1 // iterate through array\n\n    → product *= nums[right] // include new element\n\n    → Decision: While product >= k and left <= right // shrink window\n\n        Yes → product /= nums[left] // remove leftmost element\n\n        Yes → left++ // move left pointer\n\n        (loop until product < k)\n\n    → Decision: If product < k\n\n        Yes → count += (right - left + 1) // add number of subarrays ending at right\n\nEnd // return count\n\nAlso need to handle k <= 1? maybe early exit. We could add decision: if k <= 1 then return 0.\n\nLet's add early decision after initialization:\n\n→ Decision: If k <= 1\n\n    Yes → Return 0 // no subarray product can be less than 1\n\nBut pseudocode may not include return; we can just set count=0 and skip loops.\n\nSimpler: Add decision before for loop.\n\nOk produce final lines.\n\nMake sure each line ends with // explanation.\n\nUse arrow syntax. For loops: use → For right in 0 to len(nums)-1: But pseudocode uses arrow and indentation.\n\nWe need to indent sub-steps after loops/decisions. Use indenting? They don't specify indent format, but can just put indentation with spaces.\n\nExample in prompt: they used tab-like indentation but no special formatting.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ If k <= 1 Then count = 0 // k <=1, no valid subarray\n\n→ Else // proceed with sliding window\n\n    → Initialize count = 0 // 統計符合條件的子陣列數\n\n    → Initialize product = 1 // 當前滑動窗口的積\n\n    → Initialize left = 0 // 窗口左端指標\n\n    → For right = 0 To length(nums)-1 // 逐個遍歷陣列元素\n\n        → product = product * nums[right] // 加入右端元素\n\n        → Decision: While product >= k And left <= right // 若積不符合，收縮窗口\n\n            Yes → product = product / nums[left] // 移除左端元素\n\n            Yes → left = left + 1 // 左端移動\n\n        → Decision: If product < k // 乘積已滿足條件\n\n            Yes → count = count + (right - left + 1) // 統計以 right 為結束的子陣列\n\nEnd // 程式執行結束\n\nWe need to follow output format: each line: virtual code step + space + // explanation.\n\nNeed to ensure that indentation lines still considered as separate lines. Use spaces before arrow maybe.\n\nI'll produce each line with leading arrow but indentation inside. Use consistent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ If k <= 1 Then count = 0 // k <= 1 時，無任何子陣列能滿足積 < k  \n→ Else // k 大於 1 時才進行計算  \n    → Initialize count = 0 // 用來統計符合條件的子陣列數量  \n    → Initialize product = 1 // 當前滑動窗口的積  \n    → Initialize left = 0 // 滑動窗口左端指標  \n    → For right = 0 To length(nums)-1 // 逐個遍歷陣列元素  \n        → product = product * nums[right] // 將右端元素加入積中  \n        → Decision: While product >= k And left <= right // 若積不符合條件，需縮小窗口  \n            Yes → product = product / nums[left] // 移除左端元素的影響  \n            Yes → left = left + 1 // 左端指標右移  \n        → Decision: If product < k // 乘積已符合 < k 的要求  \n            Yes → count = count + (right - left + 1) // 以 right 為結尾的子陣列共有 (right-left+1) 個  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums, k):\n        if k <= 1:\n            return 0\n        prod = 1\n        result = left = 0\n        for right, val in enumerate(nums):\n            prod *= val\n            while prod >= k and left <= right:\n                prod //= nums[left]\n                left += 1\n            result += right - left + 1\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支援多種格式：\n    1. 'nums = [10,5,2,6], k = 100'\n    2. 第一行為列表，第二行為整數\n    \"\"\"\n    nums = None\n    k = None\n\n    # 嘗試從字串中找出 nums 與 k\n    m_nums = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    m_k = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if m_nums and m_k:\n        try:\n            nums = ast.literal_eval(m_nums.group(1))\n            k = int(m_k.group(1))\n        except Exception:\n            pass\n\n    # 若未成功，嘗試分行讀取\n    if nums is None or k is None:\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            try:\n                nums = ast.literal_eval(lines[0])\n                k = int(lines[1])\n            except Exception:\n                pass\n\n    # 仍未成功則直接拋出錯誤\n    if nums is None or k is None:\n        raise ValueError(\"輸入格式不符合要求，無法解析 nums 與 k。\")\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    sol = Solution()\n    ans = sol.numSubarrayProductLessThanK(nums, k)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,5,2,6], k = 100",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3], k = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode187.json",
    "problem_index_in_file": 0,
    "title": "Repeated DNA Sequences",
    "description_snippet": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. For e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: find all 10-letter-long substrings that appear more than once in a given string s. Typical solution uses sliding window and set or hash map.\n\nWe must output step-by-step lines with arrow and comments.\n\nWe need to include Start, End, Decision lines, etc. Provide each step with explanation.\n\nMake sure to not output real code. Just virtual steps.\n\nLet's design:\n\nStart.\n\n→ Step 1: Input string s // get DNA sequence.\n\n→ Decision: If length of s < 10? // if too short.\n\n    Yes → Step 2: Return empty list // no substrings.\n\n    No → Step 3: Initialize seen set and repeated set // track substrings seen once and those repeated.\n\n→ Step 4: For i from 0 to length(s)-10: // sliding window.\n\n    → Substring = s[i:i+10] // get 10-length substring.\n\n    → Decision: If substring in seen? // already seen.\n\n        Yes → Step 5: Add substring to repeated // add to repeated set.\n\n        No → Step 6: Add substring to seen // record first time.\n\n→ Step 7: Convert repeated set to list // produce output.\n\n→ Step 8: Return list // result.\n\nEnd.\n\nAlso maybe consider storing counts via dictionary.\n\nBut okay.\n\nAdd comments after each step.\n\nInclude arrow lines: \"→\". For decision, indent children.\n\nLet's format.\n\nRemember: each line has `虛擬碼步驟` + space + `// 解釋`.\n\nWe'll keep arrow and indent properly.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得 DNA 序列  \n→ Decision: 如果 len(s) < 10? // 序列太短無法形成 10 字元子字串  \n  Yes → Step 2: 返回空清單 // 直接結束  \n  No  → Step 3: 初始化 seen 集合與 repeated 集合 // 追蹤已見與重複的子字串  \n→ Step 4: 循環 i 從 0 到 len(s)-10: // 滑動窗口遍歷所有可能的 10 字元子字串  \n  → Substring ← s[i : i+10] // 取出當前 10 字元子字串  \n  → Decision: 如果 Substring 在 seen? // 已經見過一次  \n    Yes → Step 5: 把 Substring 加入 repeated // 標記為重複子字串  \n    No  → Step 6: 把 Substring 加入 seen // 記錄第一次出現  \n→ Step 7: 把 repeated 集合轉成清單 // 準備輸出結果  \n→ Step 8: 返回清單 // 結束並回傳所有重複的 10 字元子字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> list[str]:\n        \"\"\"\n        Find all 10-letter-long substrings that occur more than once in s.\n        Uses a sliding window with two sets to track seen and repeated sequences.\n        \"\"\"\n        seen = set()\n        repeated = set()\n\n        # Only iterate if the string is long enough\n        for i in range(len(s) - 9):\n            seq = s[i:i + 10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n\n        return list(repeated)\n\n\ndef main() -> None:\n    \"\"\"\n    Reads the DNA sequence from standard input, processes it, and prints\n    a JSON-formatted list of repeated 10-letter sequences.\n    \"\"\"\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n\n    # Extract DNA string: support \"s = '...'\" or plain string\n    match = re.search(r\"'([^']*)'\", raw_input)\n    dna_seq = match.group(1) if match else raw_input\n\n    # Compute repeated sequences\n    solution = Solution()\n    repeated = solution.findRepeatedDnaSequences(dna_seq)\n\n    # Output as JSON array string\n    print(json.dumps(repeated))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        },
        {
          "example_index": 1,
          "input": "s = 'AAAAAAAAAAAAA'",
          "expected_output": "[\"AAAAAAAAAA\"]",
          "success": true,
          "output": "[\"AAAAAAAAAA\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode300.json",
    "problem_index_in_file": 0,
    "title": "Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the length of the longest strictly increasing subsequence....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: longest increasing subsequence length. Use typical DP O(n^2) or patience sorting O(n log n). We need simple pseudocode. Provide each line with explanation. Use arrows and decisions.\n\nWe need step by step: Start, Input array, initialize dp array length n with 1, loop i from 1 to n-1, loop j from 0 to i-1, if nums[i] > nums[j], dp[i] = max(dp[i], dp[j]+1). After loops, find max in dp, output. End.\n\nProvide each line with arrow and explanation. Include decisions. Use virtual code formatting. Let's produce lines:\n\nStart // start\n→ Input nums // get array\n→ Set n = length(nums) // number of elements\n→ Create dp array of size n, fill with 1 // each element at least subsequence of length 1\n→ For i from 1 to n-1 // iterate over array\n    → For j from 0 to i-1 // compare with previous elements\n        → Decision: if nums[i] > nums[j]? // check increasing\n            Yes → Update dp[i] = max(dp[i], dp[j] + 1) // extend subsequence\n            No → // nothing\n→ After loops, set maxLen = 0 // track longest\n→ For each val in dp // find maximum\n    → Update maxLen = max(maxLen, val) // keep longest\n→ Output maxLen // result\nEnd // finish\n\nNeed to format each line with \"→\" and comment. Need to indent decisions. Use arrow inside decision lines? The example used \"Yes → Step\" and \"No  →\". We'll follow that.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 從使用者或函式參數取得整數陣列  \n→ Set n = length(nums) // 取得陣列長度  \n→ Create dp array of size n, fill with 1 // 每個位置至少為長度 1 的遞增子序列  \n→ For i from 1 to n-1 // 逐一檢視每個元素  \n    → For j from 0 to i-1 // 與前面的元素比較  \n        → Decision: 如果 nums[i] > nums[j]? // 判斷是否可延伸遞增子序列  \n            Yes → Update dp[i] = max(dp[i], dp[j] + 1) // 取最大長度更新 dp[i]  \n            No → // 不符合遞增條件，保持原值  \n→ After loops, set maxLen = 0 // 初始化最大長度  \n→ For each val in dp // 遍歷 dp 取得最大值  \n    → Update maxLen = max(maxLen, val) // 更新最大長度  \n→ Output maxLen // 回傳最長遞增子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport bisect\n\ndef length_of_lis(nums):\n    \"\"\"返回最長遞增子序列的長度（O(n log n)）\"\"\"\n    tails = []\n    for num in nums:\n        # 找到 num 應插入 tails 的位置\n        idx = bisect.bisect_left(tails, num)\n        if idx == len(tails):\n            tails.append(num)      # 新增一個更長的子序列\n        else:\n            tails[idx] = num       # 用更小的尾端更新現有子序列\n    return len(tails)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入中擷取方括號內的內容\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        nums = []\n    else:\n        list_str = data[start:end+1]\n        nums = ast.literal_eval(list_str)\n    # 計算並輸出結果\n    print(length_of_lis(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,9,2,5,3,7,101,18]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,3,2,3]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [7,7,7,7,7,7,7]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode46.json",
    "problem_index_in_file": 0,
    "title": "Permutations",
    "description_snippet": "Given an array nums of distinct integers, return all the possible permutations. You can return the a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The problem: generate all permutations of an array of distinct integers. Standard backtracking algorithm.\n\nWe need to output line by line: each line is a \"virtual code step\" followed by comment. Use arrow, etc. No actual code.\n\nWe'll produce steps:\n\nStart\n→ Step 1: define function permute(nums) // main function\n→ Step 2: initialize result list // store permutations\n→ Step 3: initialize visited array of false // track used elements\n→ Step 4: call backtrack(currentPermutation) // start recursion\n\nDefine backtrack(current):\n→ Decision: if current.length == nums.length? // check if a full permutation built\n   Yes → Step: add copy of current to result // add to result\n   No → loop over i from 0 to nums.length-1\n         if not visited[i] // if element not used\n            Mark visited[i] = true // include element\n            Append nums[i] to current // add to permutation\n            → Step: backtrack(current) // recurse\n            → Step: remove last element from current // backtrack\n            → Step: visited[i] = false // unmark\n\nAfter backtracking complete, return result\n\nEnd\n\nWe need to ensure each line uses virtual code style.\n\nWe'll produce each line with a number? Not necessary. Use \"→\" for steps, \"Decision:\" for decisions, \"Yes →\", \"No →\" etc. Each line comment after //.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: function permute(nums) // 定義主函式，輸入為整數陣列\n→ Step 2: result ← [] // 建立儲存結果的空陣列\n→ Step 3: visited ← Array(nums.length).fill(false) // 建立布林標記陣列，追蹤元素是否已使用\n→ Step 4: backtrack([]) // 開始回溯，初始排列為空\n→ Step 5: return result // 回傳所有排列\nEnd // 程式結束\n\nDefine backtrack(current):\nStart // 回溯函式開始\n→ Decision: current.length == nums.length? // 檢查是否已生成完整排列\n    Yes → Step 6: result.push(current.slice()) // 將排列副本加入結果\n    No → for i ← 0 to nums.length-1 do // 逐一考慮每個元素\n          → Decision: not visited[i]? // 若元素未被使用\n              Yes →\n                  → Step 7: visited[i] = true // 標記元素已使用\n                  → Step 8: current.push(nums[i]) // 加入元素到當前排列\n                  → Step 9: backtrack(current) // 進行下一層遞迴\n                  → Step 10: current.pop() // 回溯，移除最後加入的元素\n                  → Step 11: visited[i] = false // 取消標記，恢復狀態\n              No → // 若已使用，直接跳過\nEnd // 回溯函式結束\n\nBut we need each line of virtual code. Must maintain structure.\n\nProbably best to write:\n\nStart // 程式開始執行\n→ Step 1: function permute(nums) // 定義主函式\n→ Step 2: result ← [] // 儲存所有排列\n→ Step 3: visited ← Array(nums.length).fill(false) // 標記陣列\n→ Step 4: backtrack([]) // 開始回溯\n→ Step 5: return result // 回傳結果\nEnd // 程式結束\n\nStart // 回溯函式開始\n→ Decision: current.length == nums.length? // 完整排列判斷\n    Yes → Step 6: result.push(current.slice()) // 加入結果\n    No → for i ← 0 to nums.length-1 do // 迭代所有元素\n          → Decision: not visited[i]? // 尚未使用\n              Yes →\n                  → Step 7: visited[i] = true // 標記使用\n                  → Step 8: current.push(nums[i]) // 加入元素\n                  → Step 9: backtrack(current) // 遞迴\n                  → Step 10: current.pop() // 回溯移除\n                  → Step 11: visited[i] = false // 取消標記\n              No → // 跳過已使用的元素\nEnd // 回溯函式結束\n\nWe must output each line as \"虛擬碼步驟 [space] // 解釋\". So each line begins with arrow or step label.\n\nEnsure no actual code. Use placeholders like ← etc. Avoid parentheses that indicate actual code.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: function permute(nums) // 定義主函式，輸入為整數陣列  \n→ Step 2: result ← [] // 建立儲存所有排列的空陣列  \n→ Step 3: visited ← Array(nums.length).fill(false) // 建立布林標記陣列，追蹤每個元素是否已使用  \n→ Step 4: backtrack([]) // 開始回溯，初始排列為空  \n→ Step 5: return result // 回傳所有產生的排列  \nEnd // 程式結束  \n\nStart // 回溯函式開始  \n→ Decision: current.length == nums.length? // 檢查是否已完成一個完整排列  \n  Yes → Step 6: result.push(current.slice()) // 把當前排列的副本加入結果  \n  No → for i ← 0 to nums.length-1 do // 逐一嘗試每個元素  \n    → Decision: not visited[i]? // 若元素未被使用  \n     Yes →  \n       → Step 7: visited[i] = true // 標記元素已使用  \n       → Step 8: current.push(nums[i]) // 加入元素到目前排列  \n       → Step 9: backtrack(current) // 進行下一層遞迴  \n       → Step 10: current.pop() // 回溯，移除最後加入的元素  \n       → Step 11: visited[i] = false // 取消標記，恢復狀態  \n     No → // 若已使用，直接跳過此元素  \nEnd // 回溯函式結束",
      "generated_code": "import sys\nimport ast\nimport re\nimport json\n\ndef solve() -> None:\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中擷取方括號內的部分，並安全評估為列表\n    match = re.search(r'\\[.*\\]', data)\n    nums = ast.literal_eval(match.group()) if match else []\n\n    res = []\n\n    def backtrack(start: int) -> None:\n        if start == len(nums):\n            res.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    backtrack(0)\n\n    # 用 json.dumps 並去除空格，符合範例輸出格式\n    print(json.dumps(res, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0,1],[1,0]]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode829.json",
    "problem_index_in_file": 0,
    "title": "Consecutive Numbers Sum",
    "description_snippet": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive int...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. We need to consider algorithm: count number of ways to represent n as sum of consecutive positive integers. Known fact: number of odd divisors of n >1? Actually number of ways equals number of odd divisors of n. For sum of k consecutive numbers starting at a: a+(a+1)+...+(a+k-1) = k*a + k(k-1)/2 = n => k*a = n - k(k-1)/2 => a = (n - k(k-1)/2)/k must be positive integer. So algorithm: iterate k from 1 to sqrt(2n) maybe until k(k+1)/2 <= n? Check if (n - k(k-1)/2) % k == 0 and resulting a>0. Count. Provide pseudocode. Also could use divisor method but simple iteration is fine. Provide steps. Let's generate virtual code. Use Start, End, Decision, Steps.\n\nLet's produce each line. Ensure each line has \"虛擬碼步驟\" then a space then comment. Use arrow -> or Decision. Ensure structure.\n\nLet's write:\n\nStart // program start\n→ Input n // get integer n\n→ Initialize count = 0 // counter for ways\n→ Initialize k = 1 // length of sequence\n→ Decision: while k*(k+1)/2 <= n? // ensures possible starting positive\n    Yes → Compute numerator = n - k*(k-1)/2 // numerator for a\n    → Decision: numerator % k == 0? // check divisibility\n        Yes → a = numerator / k // compute starting number\n            Decision: a > 0? // positive start\n                Yes → count = count + 1 // valid representation\n                No  → // ignore, but should not happen\n        No  → // not a valid k\n    → k = k + 1 // increment sequence length\n→ End While\n→ Output count // number of ways\nEnd // program ends\n\nNeed to ensure each line has the arrow or decision. The while loop we can express as Decision: while condition? but we need to structure. Use Decision: while k*(k+1)/2 <= n? Yes -> body else End While. We need to show body steps.\n\nLet's format:\n\nStart // 程式開始執行\n→ Input n // 取得輸入整數 n\n→ Initialize count = 0 // 用於統計合法表達方式數量\n→ Initialize k = 1 // 目前考慮的連續正整數個數\n→ Decision: k*(k+1)/2 <= n? // 檢查是否還可能存在起始為正的序列\n    Yes → Compute numerator = n - k*(k-1)/2 // 估算序列首項的分子\n    → Decision: numerator % k == 0? // 判斷分子能否被 k 整除\n        Yes → a = numerator / k // 計算序列的首項\n            Decision: a > 0? // 確保首項為正整數\n                Yes → count = count + 1 // 有效的表示方式，累加計數\n                No  → // 這種情況不應發生，忽略\n        No  → // 此 k 不是合法的序列長度，忽略\n    → k = k + 1 // 進入下一個序列長度\n    → // 返回 Decision 以再次檢查條件\n→ Decision: k*(k+1)/2 <= n? // 重複 while 條件判斷\n    Yes → … // 重複上面的流程\n    No  → // 條件不滿足，結束循環\n→ Output count // 顯示總的合法表示方式數量\nEnd // 程式執行結束\n\nBut need to avoid repetition. Instead we can use a while loop representation: Decision: while condition? Yes → body -> No → End. Let's produce.\n\nBetter: \nDecision: k*(k+1)/2 <= n? \n    Yes → ... body ...\n    No  → EndWhile\n\nBut we must maintain flow. We can show the while by Decision and after body go back to Decision.\n\nThus code lines:\n\nStart\n→ Input n\n→ Initialize count = 0\n→ Initialize k = 1\n→ Decision: k*(k+1)/2 <= n? \n    Yes → Compute numerator = n - k*(k-1)/2\n    → Decision: numerator % k == 0? \n        Yes → a = numerator / k \n            Decision: a > 0? \n                Yes → count = count + 1\n                No  → \n        No  → \n    → k = k + 1\n    → // 回到 Decision\n    // The arrow will implicitly loop\n    // But we need explicit loop: after k = k+1 go to Decision line\n    // We'll denote that with arrow back\n    // Use arrow: ← Decision: k*(k+1)/2 <= n?\n    // But we can use \"→ Decision:\" again\n    // Let's use \"←\" to indicate jump back.\n\nWe need to use arrow \"→\" for forward, \"←\" for backward? The spec says arrow (→, Yes →, No →). It doesn't mention backward arrow, but we can just use the same decision structure: after body we need to go back to Decision. We can represent by writing another Decision line after body, but we can just write \"→ Decision:\" again with indentation.\n\nBetter to represent while as:\n\nDecision: k*(k+1)/2 <= n? \n    Yes → body\n    No  → // exit loop\n\nWhere body includes steps and then at end we need to go back to Decision, but it's implicit.\n\nSo after body we don't need to add extra arrow. So just end the block.\n\nThus we should write:\n\nDecision: k*(k+1)/2 <= n? \n    Yes → ... (body)\n    No  → // end loop\n\nBut we need to increment k inside body and loop will re-evaluate condition.\n\nOk.\n\nLet's produce final virtual code.\n\nRemember to use Chinese comments.\n\nLet's produce each line accordingly.\n\nAlso we need to avoid repetition of lines. We can compress with indentation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Input n // 取得輸入整數 n\n→ Initialize count = 0 // 記錄合法表示方式數量\n→ Initialize k = 1 // 目前考慮的連續正整數個數\n→ Decision: k*(k+1)/2 <= n? // 檢查是否還能有正整數起始序列\n    Yes → Compute numerator = n - k*(k-1)/2 // 估算序列首項的分子\n    → Decision: numerator % k == 0? // 判斷分子能否被 k 整除\n        Yes → a = numerator / k // 計算序列首項\n            Decision: a > 0? // 確保首項為正\n                Yes → count = count + 1 // 有效表示方式，計數累加\n                No  → // 不可能發生，忽略\n        No  → // k 不是合法序列長度，忽略\n    → k = k + 1 // 進入下一個序列長度\n    → // 重新進入 Decision 以檢查條件\n    // Loop ends when condition false\n→ Decision: k*(k+1)/2 <= n? // 重複 while 條件判斷\n    Yes → … // 重複上面的流程\n    No  → // 條件不滿足，結束循環\n→ Output count // 顯示總的合法表示方式數量\nEnd // 程式執行結束\n\nBut that's repetitive. We can simplify: After body, we don't need another Decision. So we don't need the second Decision. The while loop will automatically re-evaluate.\n\nThus:\n\nDecision: k*(k+1)/2 <= n? \n    Yes → ... body ... → // loop back\n    No  → // exit loop\n\nBut we need to indicate that after body it goes back to Decision. We can simply end the block. So we just keep the Decision and body; no need to add second Decision.\n\nThus final code:\n\nStart // 程式開始執行\n→ Input n // 取得輸入整數 n\n→ Initialize count = 0 // 記錄合法表示方式數量\n→ Initialize k = 1 // 目前考慮的連續正整數個數\n→ Decision: k*(k+1)/2 <= n? // 檢查是否還能有正整數起始序列\n    Yes → Compute numerator = n - k*(k-1)/2 // 估算序列首項的分子\n    → Decision: numerator % k == 0? // 判斷分子能否被 k 整除\n        Yes → a = numerator / k // 計算序列首項\n            Decision: a > 0? // 確保首項為正\n                Yes → count = count + 1 // 有效表示方式，計數累加\n                No  → // 不可能發生，忽略\n        No  → // k 不是合法序列長度，忽略\n    → k = k + 1 // 進入下一個序列長度\n    // 循環回到 Decision\n→ Decision: k*(k+1)/2 <= n? // 這行表示循環結束判斷\n    Yes → // 重複上述流程\n    No  → // 結束循環\n→ Output count // 顯示總的合法表示方式數量\nEnd // 程式執行結束\n\nBut this still repeats Decision.\n\nWe can condense: Use a while loop representation:\n\nDecision: k*(k+1)/2 <= n? \n    Yes → body\n    No  → // exit\n\nWhere body ends with k = k + 1 and then automatically loop back.\n\nThus we don't need second Decision.\n\nThus final output lines:\n\nStart // 程式開始執行\n→ Input n // 取得輸入整數 n\n→ Initialize count = 0 // 記錄合法表示方式數量\n→ Initialize k = 1 // 目前考慮的連續正整數個數\n→ Decision: k*(k+1)/2 <= n? // 檢查是否還能有正整數起始序列\n    Yes → Compute numerator = n - k*(k-1)/2 // 估算序列首項的分子\n    → Decision: numerator % k == 0? // 判斷分子能否被 k 整除\n        Yes → a = numerator / k // 計算序列首項\n            Decision: a > 0? // 確保首項為正\n                Yes → count = count + 1 // 有效表示方式，計數累加\n                No  → // 不可能發生，忽略\n        No  → // k 不是合法序列長度，忽略\n    → k = k + 1 // 進入下一個序列長度\n    // 循環回到 Decision 以重新檢查條件\n→ Output count // 顯示總的合法表示方式數量\nEnd // 程式執行結束\n\nWe must keep each line separate. The Decision block lines indent but still separate. Let's list each line.\n\nBetter to list:\n\nStart // 程式開始執行\n→ Input n // 取得輸入整數 n\n→ Initialize count = 0 // 記錄合法表示方式數量\n→ Initialize k = 1 // 目前考慮的連續正整數個數\n→ Decision: k*(k+1)/2 <= n? // 檢查是否還能有正整數起始序列\n    Yes → Compute numerator = n - k*(k-1)/2 // 估算序列首項的分子\n    → Decision: numerator % k == 0? // 判斷分子能否被 k 整除\n        Yes → a = numerator / k // 計算序列首項\n            Decision: a > 0? // 確保首項為正\n                Yes → count = count + 1 // 有效表示方式，計數累加\n                No  → // 不可能發生，忽略\n        No  → // k 不是合法序列長度，忽略\n    → k = k + 1 // 進入下一個序列長度\n    // 循環回到 Decision 以重新檢查條件\n→ Output count // 顯示總的合法表示方式數量\nEnd // 程式執行結束\n\nBut note: after body we still need to go back to Decision automatically. The comment indicates that.\n\nThus final output. Let's output as required.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得輸入整數 n  \n→ Initialize count = 0 // 記錄合法表示方式數量  \n→ Initialize k = 1 // 目前考慮的連續正整數個數  \n→ Decision: k*(k+1)/2 <= n? // 檢查是否還能有正整數起始序列  \n Yes → Compute numerator = n - k*(k-1)/2 // 估算序列首項的分子  \n → Decision: numerator % k == 0? // 判斷分子能否被 k 整除  \n  Yes → a = numerator / k // 計算序列首項  \n   Decision: a > 0? // 確保首項為正  \n    Yes → count = count + 1 // 有效表示方式，計數累加  \n    No  → // 不可能發生，忽略  \n  No  → // k 不是合法序列長度，忽略  \n → k = k + 1 // 進入下一個序列長度  \n // 循環回到 Decision 以重新檢查條件  \n→ Output count // 顯示總的合法表示方式數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def consecutiveNumbersSum(self, n: int) -> int:\n        \"\"\"\n        Count the number of ways to express n as a sum of consecutive positive integers.\n        \"\"\"\n        count = 0\n        k = 1\n        # k is the length of the consecutive sequence\n        while k * (k - 1) // 2 < n:\n            if (n - k * (k - 1) // 2) % k == 0:\n                count += 1\n            k += 1\n        return count\n\ndef main() -> None:\n    # Read all input from stdin and extract the integer value\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    sol = Solution()\n    result = sol.consecutiveNumbersSum(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 9",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode202.json",
    "problem_index_in_file": 0,
    "title": "Happy Number",
    "description_snippet": "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode lines with comments. Should not output real code. Use arrow and decisions. Should produce steps to determine happy number. Use a set to detect loops. So algorithm: Start, initialize set seen. Loop: if n==1 -> return true. If n in seen -> return false. Add n to seen. Compute sum of squares of digits. Update n. Continue. End. Also maybe function signature.\n\nLet's produce lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Need to include Start, End. Use Decision.\n\nLet's produce.\n\nAlso maybe function definition: \"Start function IsHappy(n)\". We'll create. Provide steps.\n\nLet's write:\n\nStart // 開始執行\n\n→ Step 1: 初始化集合 Seen = 空集合 // 用來記錄已出現的數字\n\n→ Decision: 如果 n 等於 1? // 判斷是否已經是 1\n\n    Yes → Step 2: 返回 true // 直接返回，表示是快樂數\n\n    No  → Step 3: 進入主循環 // 若不是 1，開始迴圈\n\n→ Loop Start // 迴圈開始\n\n    → Decision: 如果 n 在 Seen? // 檢查是否已經出現過，表示循環\n\n        Yes → Step 4: 返回 false // 不是快樂數，終止\n\n        No  → Step 5: 將 n 加入 Seen // 記錄當前數字\n\n    → Step 6: 計算 digitSquaresSum(n) // 求各位數字平方和\n\n    → Step 7: n = digitSquaresSum(n) // 更新 n\n\n    → Decision: 如果 n 等於 1? // 再次檢查是否達到 1\n\n        Yes → Step 8: 返回 true // 成功，終止\n\n        No  → 回到 Loop Start // 繼續下一輪\n\nEnd // 結束\n\nNeed to include arrow before decisions. Use \"Decision:\" with indent lines. Use arrow after Yes and No. Format:\n\n→ Decision: ...?\n\n    Yes → Step...\n\n    No  → Step...\n\nMake sure each line ends with comment.\n\nAlso we need to mention the digitSquaresSum function: maybe Step 6 comment includes that.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化集合 Seen 為空集合 // 用來記錄已經出現的數字，檢測循環  \n→ Decision: 如果 n 等於 1? // 先檢查是否已經是快樂數  \n  Yes → Step 2: 返回 true // n 已是 1，直接判定為快樂數  \n  No  → Step 3: 進入主循環 // 否則開始迴圈判斷  \n→ Loop Start // 迴圈開始  \n  → Decision: n 是否已在 Seen? // 判斷是否出現過，表示進入循環  \n   Yes → Step 4: 返回 false // 出現循環，非快樂數  \n   No  → Step 5: 把 n 加入 Seen // 記錄當前數字  \n  → Step 6: 計算 digitSquaresSum(n) // 將 n 的每位數字平方相加  \n  → Step 7: 把結果賦值給 n // 更新 n 為新的數值  \n  → Decision: n 等於 1? // 檢查更新後的 n 是否已達 1  \n   Yes → Step 8: 返回 true // 成功，為快樂數  \n   No  → 回到 Loop Start // 繼續下一輪迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_happy(n: int) -> bool:\n    \"\"\"判斷 n 是否為快樂數.\"\"\"\n    def next_number(num: int) -> int:\n        \"\"\"計算數字每位平方和.\"\"\"\n        total = 0\n        while num > 0:\n            digit = num % 10\n            total += digit * digit\n            num //= 10\n        return total\n\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = next_number(n)\n    return n == 1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取第一個整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        # 若找不到數字，則直接輸出 false\n        print(\"false\")\n    else:\n        n = int(match.group())\n        result = is_happy(n)\n        print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 19",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode189.json",
    "problem_index_in_file": 0,
    "title": "Rotate Array",
    "description_snippet": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with arrow, explanation. Use Start, End, Decision. Task: rotate array to right by k steps. Should cover negative? k non-negative. Should handle k > n by mod. Implementation: use reverse method or temp array. Provide steps. Let's craft:\n\nStart\n→ Step 1: n ← length(nums) // get array length\n→ Decision: if k == 0 or n == 0? // trivial case\n    Yes → End // nothing to do\n    No  → Step 2: k ← k mod n // reduce steps\n→ Step 3: Reverse entire array // helper reverse subarray\n→ Step 4: Reverse first k elements // restore\n→ Step 5: Reverse remaining n-k elements // complete\nEnd\n\nAlso need to explain each. Provide pseudo code lines. Use arrow for each. Should include \"Decision:\" block indent maybe. We'll format as requested.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: 是否需要旋轉? (k == 0 或 n == 0?) // 判斷是否為空或不需動作  \n  Yes → End // 無需處理，直接結束  \n  No → Step 2: k ← k mod n // k 可能大於 n，先取模簡化步驟  \n→ Step 3: Reverse(nums, 0, n-1) // 先將整個陣列倒轉  \n→ Step 4: Reverse(nums, 0, k-1) // 再將前 k 個元素倒轉，得到右移 k 步的前 k 個元素  \n→ Step 5: Reverse(nums, k, n-1) // 最後倒轉剩下的 n‑k 個元素完成旋轉  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def rotate(self, nums, k):\n        n = len(nums)\n        if n == 0 or k % n == 0:\n            return\n        k %= n\n\n        # 逆轉子陣列的輔助函式\n        def reverse(arr, left, right):\n            while left < right:\n                arr[left], arr[right] = arr[right], arr[left]\n                left += 1\n                right -= 1\n\n        reverse(nums, 0, n - 1)      # 逆轉整個陣列\n        reverse(nums, 0, k - 1)      # 逆轉前 k 個元素\n        reverse(nums, k, n - 1)      # 逆轉剩下的 n-k 個元素\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串解析出 nums 與 k。\"\"\"\n    # 1. 嘗試「單行」格式：'nums = [1,2,3], k = 2'\n    list_match = re.search(r'\\[(.*?)\\]', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if list_match and k_match:\n        nums = ast.literal_eval('[' + list_match.group(1) + ']')\n        k = int(k_match.group(1))\n        return nums, k\n\n    # 2. 嘗試「多行」格式：第一行 nums，第二行 k\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        try:\n            nums = ast.literal_eval(lines[0].strip())\n            k = int(lines[1].strip())\n            return nums, k\n        except Exception:\n            pass\n\n    raise ValueError(\"無法解析輸入格式\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    Solution().rotate(nums, k)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "success": true,
          "output": "[5, 6, 7, 1, 2, 3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "success": true,
          "output": "[3, 99, -1, -100]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode492.json",
    "problem_index_in_file": 0,
    "title": "Construct the Rectangle",
    "description_snippet": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line with explanations. Task: Given area target A, find integers L, W such that L*W=A, L>=W, and L-W minimized. Return [L,W].\n\nAlgorithm: Start. Input area. Initialize bestDiff = INF, bestL=0,bestW=0. For w from 1 to sqrt(area): if area%w==0 then l=area/w. if l>=w and (l-w)<bestDiff: update. End loop. Return [bestL,bestW].\n\nVirtual code lines with arrows and explanation. Use decision steps.\n\nLet's produce steps: Start, Step 1: Input area, Step 2: Initialize bestDiff, bestL, bestW, Step 3: Compute limit = floor(sqrt(area)). Step 4: For w=1 to limit: Step 5: Decision if area mod w ==0? Yes -> l=area/w. Decision l>=w? Yes -> diff=l-w. Decision diff<bestDiff? Yes-> update. End loops. Step 6: Return [bestL,bestW]. End.\n\nAdd arrows appropriately. Use '→' for next. Indentation inside loops.\n\nLet's write lines:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入面積 A // 取得目標面積\n→ Step 2: 初始化 bestDiff = 無限大, bestL = 0, bestW = 0 // 用於儲存最佳尺寸\n→ Step 3: 計算 limit = floor(sqrt(A)) // 從 1 開始檢查到平方根\n→ Step 4: For w = 1 to limit: // 遍歷所有可能的寬度\n    → Decision: 若 A mod w = 0? // 判斷 w 是否為因數\n        Yes → Step 5: 設定 l = A / w // 對應長度\n        → Decision: 若 l >= w? // 確保長度不小於寬度\n            Yes → Step 6: 計算 diff = l - w // 長寬差距\n            → Decision: 若 diff < bestDiff? // 差距是否更小\n                Yes → Step 7: 更新 bestDiff = diff, bestL = l, bestW = w // 儲存更佳組合\n                No  → // 目前差距不佳，保持現有最佳\n            No  → // l < w，忽略此組合\n        No → // A mod w != 0，忽略此寬度\n→ Step 8: 回傳 [bestL, bestW] // 返回最優尺寸\nEnd // 程式執行結束\n\nEnsure each line follows format. Use proper indentation. Should be fine.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入面積 A // 取得目標面積  \n→ Step 2: 初始化 bestDiff = 無限大, bestL = 0, bestW = 0 // 用於儲存最佳尺寸  \n→ Step 3: 計算 limit = floor(sqrt(A)) // 從 1 開始檢查到平方根  \n→ Step 4: For w = 1 to limit: // 遍歷所有可能的寬度  \n&nbsp;&nbsp;&nbsp;→ Decision: 若 A mod w = 0? // 判斷 w 是否為因數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: 設定 l = A / w // 對應長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 若 l >= w? // 確保長度不小於寬度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: 計算 diff = l - w // 長寬差距  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 若 diff < bestDiff? // 差距是否更小  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: 更新 bestDiff = diff, bestL = l, bestW = w // 儲存更佳組合  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 目前差距不佳，保持現有最佳  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // l < w，忽略此組合  \n&nbsp;&nbsp;&nbsp;No → // A mod w != 0，忽略此寬度  \n→ Step 8: 回傳 [bestL, bestW] // 返回最優尺寸  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def constructRectangle(self, area: int):\n        # 從平方根開始往下尋找能整除 area 的因數\n        w = int(math.isqrt(area))\n        while area % w != 0:\n            w -= 1\n        l = area // w\n        return [l, w]\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，提取第一個整數作為面積\n    data = sys.stdin.read()\n    match = re.search(r\"-?\\d+\", data)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    area = int(match.group())\n\n    result = Solution().constructRectangle(area)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "area = 4",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "area = 37",
          "expected_output": "[37,1]",
          "success": true,
          "output": "[37, 1]"
        },
        {
          "example_index": 2,
          "input": "area = 122122",
          "expected_output": "[427,286]",
          "success": true,
          "output": "[427, 286]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode383.json",
    "problem_index_in_file": 0,
    "title": "Ransom Note",
    "description_snippet": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a virtual code with explanation per line, following format. For the given requirement: determine if ransomNote can be constructed from magazine. Standard solution: count frequency of letters in magazine, then subtract for each in ransomNote, if any count goes negative return false.\n\nWe'll produce steps: Start, input strings, maybe convert to arrays, count frequencies, iterate over ransomNote letters, check if available, decrement, if not available, return false, else after loop true, End.\n\nWe need arrow structure. Use `→` for each step, `Decision:` lines.\n\nLet's produce step-by-step.\n\nWe might need a data structure: dictionary freq.\n\nSteps:\n\nStart // Program start\n\n→ Step 1: Initialize empty frequency map freqMagazine // Create a map to store letter counts\n\n→ Step 2: For each char ch in magazine, increment freqMagazine[ch] // Count letters\n\n→ Decision: Is ransomNote empty? // If no letters to check, return true\n\n    Yes → Step 3: Return true // Nothing to construct\n\n    No  → Step 4: For each char ch in ransomNote, check freqMagazine[ch] > 0 // Validate each letter\n\n        → Decision: freqMagazine[ch] > 0? // Is letter available?\n\n            Yes → Step 5: Decrement freqMagazine[ch] // Use the letter\n\n            No  → Step 6: Return false // Letter missing, cannot construct\n\n→ Step 7: Return true // All letters satisfied\n\nEnd // Program ends\n\nBut need to keep arrow lines consistent. Also need to handle loops properly: \"For each char ch in magazine\" is a loop, not arrow? Might use → Step 2: For each ch in magazine, increment freqMagazine[ch] // Counting. But we need a loop arrow maybe: `→ Step 2: For each ch in magazine` then inside we can have an arrow to increment.\n\nLet's follow pattern from example: They use `→ Step 1: ...` for each line.\n\nWe can embed loops by having a decision inside.\n\nWe need to ensure each line has explanation after //.\n\nOk produce.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 freqMagazine // 用於存儲雜誌中每個字母的出現次數\n→ Step 2: 對雜誌中的每個字母 ch，執行以下動作 // 迭代雜誌字母\n    → Step 3: freqMagazine[ch] += 1 // 增加對應字母的計數\n→ Decision: 若 ransomNote 為空？ // 若無需構造字串，直接成功\n    Yes → Step 4: Return true // 直接回傳成功\n    No  → Step 5: 對 ransomNote 中的每個字母 ch，執行以下動作 // 逐字檢查\n        → Decision: freqMagazine[ch] > 0? // 該字母是否可用？\n            Yes → Step 6: freqMagazine[ch] -= 1 // 使用該字母\n            No  → Step 7: Return false // 無法構造，回傳失敗\n→ Step 8: Return true // 所有字母均可用，回傳成功\nEnd // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟\" + space + // explanation. The above uses indentation for loops; we need to keep each line starting with `→` or `Decision:`.\n\nIn example they used indentation for nested. Use same style.\n\nLet's output exactly like example with lines starting with \"Start\", \"→\", \"Decision:\", \"End\".\n\nMake sure each line has space after virtual code then explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freqMagazine // 用於存儲雜誌中每個字母的出現次數  \n→ Step 2: 對雜誌中的每個字母 ch，執行以下動作 // 迭代雜誌字母  \n → Step 3: freqMagazine[ch] += 1 // 增加對應字母的計數  \n→ Decision: 若 ransomNote 為空？ // 若無需構造字串，直接成功  \n Yes → Step 4: Return true // 直接回傳成功  \n No  → Step 5: 對 ransomNote 中的每個字母 ch，執行以下動作 // 逐字檢查  \n  → Decision: freqMagazine[ch] > 0? // 該字母是否可用？  \n   Yes → Step 6: freqMagazine[ch] -= 1 // 使用該字母  \n   No  → Step 7: Return false // 無法構造，回傳失敗  \n→ Step 8: Return true // 所有字母均可用，回傳成功  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        \"\"\"判斷 ransomNote 是否可以用 magazine 的字母組成，且每個字母只能使用一次。\"\"\"\n        # 建立兩個 Counter 分別統計 ransomNote 與 magazine 中各字母的出現次數\n        from collections import Counter\n        ransom_count = Counter(ransomNote)\n        magazine_count = Counter(magazine)\n\n        # 檢查每個 ransomNote 中的字母在 magazine 中是否足夠\n        for char, cnt in ransom_count.items():\n            if cnt > magazine_count.get(char, 0):\n                return False\n        return True\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取資料，計算並輸出結果。\"\"\"\n    data = sys.stdin.read()\n\n    # 透過正則表達式提取 ransomNote 與 magazine 的值\n    ransom_match = re.search(r'ransomNote\\s*=\\s*\"([^\"]*)\"', data)\n    magazine_match = re.search(r'magazine\\s*=\\s*\"([^\"]*)\"', data)\n\n    if not ransom_match or not magazine_match:\n        # 若輸入格式不符，直接輸出 false\n        print(\"false\")\n        return\n\n    ransom_note = ransom_match.group(1)\n    magazine_str = magazine_match.group(1)\n\n    # 呼叫解法\n    solution = Solution()\n    result = solution.canConstruct(ransom_note, magazine_str)\n\n    # 輸出符合範例的大小寫\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ransomNote = \"a\", magazine = \"b\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "ransomNote = \"aa\", magazine = \"ab\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode376.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Subsequence",
    "description_snippet": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a step-by-step virtual code for algorithm to find longest wiggle subsequence length. Classic DP: maintain up[i], down[i]. O(n). Or greedy: count peaks. We need to produce virtual code lines with explanations.\n\nLet's produce:\n\nStart\n→ Step 1: 若 nums 長度 ≤ 2, 返回長度 // handle trivial cases\n→ Step 2: 初始化 up = 1, down = 1 // length of wiggle ending with up/down\n→ Step 3: 從 i=1 到 n-1 迴圈\n    → Decision: 如果 nums[i] > nums[i-1]?\n        Yes → up = down + 1 // new wiggle ends with up\n        No →\n            Decision: 如果 nums[i] < nums[i-1]?\n                Yes → down = up + 1 // new wiggle ends with down\n                No → // equal, no change\n→ Step 4: 返回 max(up, down) // longest wiggle subsequence length\nEnd\n\nWe need to keep \"→\" per line, with explanation.\n\nAdd details like \"Loop over each element after first\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得 nums 的長度 n // 先知道陣列長度\n→ Decision: 如果 n ≤ 2? // 若只有一或兩個元素，自動是 wiggle\n    Yes → Return n // 回傳長度，程式結束\n    No  → 進入後續處理\n→ Step 2: 設定 up = 1, down = 1 // 上升/下降子序列的最長長度初始化為 1\n→ Step 3: 從 i = 1 到 n-1 迴圈 // 逐個檢查相鄰差值\n    → Decision: 如果 nums[i] > nums[i-1]? // 差值為正\n        Yes → up = down + 1 // 以升序結尾的新長度\n        No  → Decision: 如果 nums[i] < nums[i-1]? // 差值為負\n            Yes → down = up + 1 // 以降序結尾的新長度\n            No  → // nums[i] == nums[i-1]，不改變 up 或 down\n→ Step 4: Return max(up, down) // 兩種結尾中較長者即為答案\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleMaxLength(self, nums):\n        if not nums:\n            return 0\n        up = down = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                up = down + 1\n            elif nums[i] < nums[i - 1]:\n                down = up + 1\n        return max(up, down)\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取列表。\"\"\"\n    # 找到第一個 '['，並取得直到最後一個 ']' 的子字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    list_str = data[start:end+1]\n    # 使用 ast.literal_eval 解析成 Python 列表\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    sol = Solution()\n    result = sol.wiggleMaxLength(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,4,9,2,5]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,17,5,10,13,15,10,5,16,8]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4,5,6,7,8,9]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1249.json",
    "problem_index_in_file": 0,
    "title": "Minimum Remove to Make Valid Parentheses",
    "description_snippet": "Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code. We need to solve: remove minimum parentheses to make valid. Standard approach: count mismatches, then iterate to remove invalid left, then reverse to remove invalid right. Or stack. Provide steps.\n\nWe'll produce a step-by-step pseudocode with decision arrows.\n\nLet's structure:\n\nStart\n→ Step 1: Initialize empty stack and result list\n→ Step 2: Iterate characters of s\n    → Decision: If char is '('\n        → Push its index onto stack\n        → Append char to result\n    → Decision: If char is ')'\n        → If stack not empty\n            → Pop from stack\n            → Append char to result\n        → Else\n            → Mark this ')' for removal (skip)\n    → Decision: If char is lowercase\n        → Append char to result\n→ Step 3: After iteration, stack contains indices of unmatched '('\n→ Decision: If stack not empty\n    → Remove characters at those indices from result\n→ End // return result as string\n\nBut we need \"minimum number\" removal. This algorithm ensures. Alternatively, we can do two passes: first pass remove left mismatches, second pass reverse string to remove right mismatches. Provide steps.\n\nI'll craft pseudocode lines accordingly.\n\nMake sure each line ends with `// explanation`.\n\nNeed to use arrow notation.\n\nUse `Start` and `End`.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空列表 result，空棧 stack，並設定結果索引 idx ← 0 // 準備儲存合法字元和追蹤左括號  \n→ Step 2: 逐字元遍歷輸入字串 s  \n  → Decision: 若 char 是 '('  \n    Yes → Push idx 到 stack // 追蹤此左括號位置  \n     Append char 到 result  \n     idx ← idx + 1  \n     Continue  \n    No → (若不是左括號)  \n     → Decision: 若 char 是 ')'  \n      Yes → Decision: stack 是否為空?  \n        Yes → // 無配對左括號，跳過此右括號  \n        No → Pop stack // 配對成功  \n         Append char 到 result  \n         idx ← idx + 1  \n         Continue  \n       No → // char 為小寫字母  \n       Append char 到 result  \n       idx ← idx + 1  \n      Continue  \n→ Step 3: 若 stack 不為空  \n  → Decision: stack 仍有元素?  \n    Yes → // 這些左括號沒有配對，須刪除  \n     Delete result 位置對應 stack 的所有元素  \n     No → // 無需刪除  \n→ End // 程式結束，返回 result 轉成字串\n\n> **備註**  \n> - 步驟 2 中的 `idx` 用於追蹤 result 中每個字元的位置，以便在最後刪除未配對左括號。  \n> - 若想要完全符合「最少刪除」要求，此演算法只刪除必須刪除的括號，確保輸出合法且長度最大。",
      "generated_code": "import sys\n\nclass Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \"\"\"\n        Remove the minimum number of parentheses to make the string valid.\n        \"\"\"\n        s_list = list(s)          # convert to list for mutable operations\n        stack = []                # stack to hold indices of unmatched '('\n\n        for i, c in enumerate(s_list):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if stack:\n                    stack.pop()            # matched pair found\n                else:\n                    s_list[i] = ''          # unmatched ')', remove\n\n        # remove any remaining unmatched '('\n        for i in stack:\n            s_list[i] = ''\n\n        return ''.join(s_list)\n\ndef main():\n    # Read the entire input, strip surrounding whitespace\n    raw_input = sys.stdin.read().strip()\n\n    # Extract the string content:\n    # If the input contains quotes, take the part inside the first pair of quotes.\n    # Otherwise, treat the whole line as the string.\n    if '\"' in raw_input:\n        start = raw_input.find('\"')\n        end = raw_input.rfind('\"')\n        if start != -1 and end != -1 and start < end:\n            s = raw_input[start + 1:end]\n        else:\n            s = raw_input\n    else:\n        s = raw_input\n\n    solution = Solution()\n    result = solution.minRemoveToMakeValid(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"lee(t(c)o)de)\"",
          "expected_output": "\"lee(t(c)o)de\"",
          "success": true,
          "output": "lee(t(c)o)de"
        },
        {
          "example_index": 1,
          "input": "s = \"a)b(c)d\"",
          "expected_output": "\"ab(c)d\"",
          "success": true,
          "output": "ab(c)d"
        },
        {
          "example_index": 2,
          "input": "s = \"))((\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode239.json",
    "problem_index_in_file": 0,
    "title": "Sliding Window Maximum",
    "description_snippet": "You are given an array of integers nums, there is a sliding window of size k which is moving from th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for sliding window maximum. Use typical deque approach. Provide line-by-line. Use Start, End, Decision. We need to include arrows. Let's craft steps:\n\nStart\n→ Step 1: 初始化空雙端佇列 deque // 用於存儲索引\n→ Step 2: 迭代 i 從 0 到 nums.length - 1 // 遍歷數組\n    → Decision: 是否已到達窗口大小? // i >= k - 1\n        Yes → Step 3: 取 deque 前端索引即為最大值 // deque 內索引對應遞減值\n        No  → skip\n    → Decision: 是否需要移除離開窗口的索引? // deque.front <= i - k\n        Yes → Step 4: deque.popFront() // 移除\n        No  → skip\n    → Decision: deque 內元素值是否小於等於 nums[i]? // 循環\n        Yes → Step 5: deque.popBack() // 移除小值\n        No  → skip (loop)\n    → Step 6: deque.pushBack(i) // 將當前索引加入\n    → Step 7: 如果已到達窗口大小, 將 deque.front 值加入結果 // append\nEnd\n\nWe must include step numbers, but can use numbering.\n\nLet's output as required: each line \"虛擬碼步驟 [space] // 解釋\".\n\nNeed to include arrow characters. Use \"→\". Indent for decisions. Provide arrows for Yes → and No →. Must use \"Decision:\" prefix.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空雙端佇列 deque // 用於存儲滑動窗口內索引，保持元素值遞減  \n→ Step 2: 迭代 i 從 0 到 nums.length - 1 // 遍歷整個數組  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: i 已到達窗口大小? // 判斷是否可以取得最大值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: 取 deque.front 對應的 nums 值作為當前窗口最大值 // deque 前端索引對應最大值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → 省略  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: deque.front <= i - k ? // 判斷最舊索引是否已離開窗口  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: deque.popFront() // 移除離開窗口的索引  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → 省略  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: deque 內的索引對應值 <= nums[i] ? // 移除比當前值小或相等的元素，保持遞減  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: deque.popBack() // 刪除後繼續判斷  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → 省略（循環）  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 6: deque.pushBack(i) // 把當前索引加入佇列  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: i >= k - 1 ? // 判斷是否已形成完整窗口  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: 將 nums[deque.front] 加入結果陣列 // 收集最大值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → 省略  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\ndef max_sliding_window(nums, k):\n    \"\"\"返回滑動窗口大小為 k 的最大值列表。\"\"\"\n    if not nums or k == 0:\n        return []\n\n    deq = deque()          # 存儲索引，保持對應值遞減\n    res = []\n\n    for i in range(len(nums)):\n        # 移除已離開窗口的索引\n        while deq and deq[0] < i - k + 1:\n            deq.popleft()\n\n        # 移除比當前元素小的索引，因為它們不可能成為未來窗口的最大值\n        while deq and nums[deq[-1]] < nums[i]:\n            deq.pop()\n\n        deq.append(i)  # 將當前索引加入\n\n        # 當窗口已形成完整大小時，將最大值加入結果\n        if i >= k - 1:\n            res.append(nums[deq[0]])\n\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入格式：nums = [...], k = ...\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        print(\"Invalid input format\")\n        sys.exit()\n\n    nums_str, k_str = match.groups()\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n\n    result = max_sliding_window(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "success": true,
          "output": "[3, 3, 5, 5, 6, 7]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode628.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Three Numbers",
    "description_snippet": "Given an integer array nums, find three numbers whose product is maximum and return the maximum prod...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line-by-line with explanations. The problem: Given an integer array nums, find maximum product of any three numbers. Standard approach: sort array, consider max product from three largest numbers or two smallest negative numbers and the largest positive. Implementation: sort ascending, let n = len(nums). max1 = nums[n-1] * nums[n-2] * nums[n-3]; max2 = nums[0] * nums[1] * nums[n-1]; return max(max1, max2). Also handle negative? but algorithm covers.\n\nWe need to output in the format: Each line: \"虛擬碼步驟 // 解釋\". Using arrows. Start, Decision. Need to produce steps. Let's create:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Decision: 如果 n < 3? // 檢查是否至少有三個數字\n    Yes → Step 2: return error // 需要三個數字，若不足則返回錯誤\n    No  →\n→ Step 3: sort(nums) // 對陣列進行升序排序\n→ Step 4: prod1 ← nums[n-1] * nums[n-2] * nums[n-3] // 取三個最大值相乘\n→ Step 5: prod2 ← nums[0] * nums[1] * nums[n-1] // 取兩個最小值與最大值相乘\n→ Step 6: maxProd ← max(prod1, prod2) // 取兩種情況的較大值\n→ Step 7: return maxProd // 返回最大乘積\nEnd // 程式執行結束\n\nBut the format expects arrow with indentation. Use \"→ Decision:\" etc. The sample had indentation for substeps. For decision branches, indent lines with some spaces maybe. We'll replicate.\n\nMake sure each line has arrow at beginning: \"→ Step 1:\" etc. For decision branches, we need \"Decision:\" and then Yes →, No → lines. In the sample, they used \"Decision: 如果數字大於 0?\" and indent the Yes/No lines. We'll mimic.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Decision: 如果 n < 3? // 檢查是否至少有三個數字\n    Yes → Step 2: return error // 若不足三個，返回錯誤\n    No  → \n→ Step 3: sort(nums) // 對 nums 進行升序排序\n→ Step 4: prod1 ← nums[n-1] * nums[n-2] * nums[n-3] // 取三個最大值的乘積\n→ Step 5: prod2 ← nums[0] * nums[1] * nums[n-1] // 取兩個最小值和最大值的乘積\n→ Step 6: maxProd ← max(prod1, prod2) // 比較兩種乘積，取較大值\n→ Step 7: return maxProd // 回傳最終最大乘積\nEnd // 程式執行結束\n\nBut we need to include \"→\" before each step. For decision No branch we might need an arrow? In sample they had \"No → Decision:\" etc. We'll mimic: \"No →\". Then substeps. So after No we can continue to Step 3. Use arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: 如果 n < 3? // 檢查是否至少有三個數字  \n  Yes → Step 2: return error // 若不足三個，返回錯誤訊息  \n  No  →  \n→ Step 3: sort(nums) // 對 nums 進行升序排序  \n→ Step 4: prod1 ← nums[n-1] * nums[n-2] * nums[n-3] // 取三個最大值的乘積  \n→ Step 5: prod2 ← nums[0] * nums[1] * nums[n-1] // 取兩個最小值和最大值的乘積  \n→ Step 6: maxProd ← max(prod1, prod2) // 比較兩種乘積，取較大值  \n→ Step 7: return maxProd // 回傳最終最大乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef maximum_product(nums):\n    nums.sort()\n    # 取三個最大值相乘或兩個最小值與最大值相乘，取較大者\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入，支援 \"nums = [1,2,3]\" 或僅 \"[1,2,3]\"\n    if '=' in data:\n        _, nums_part = data.split('=', 1)\n        nums_str = nums_part.strip()\n    else:\n        nums_str = data\n    nums = ast.literal_eval(nums_str)\n    if len(nums) < 3:\n        print(0)\n    else:\n        print(maximum_product(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "24",
          "success": true,
          "output": "24"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-2,-3]",
          "expected_output": "-6",
          "success": true,
          "output": "-6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode68.json",
    "problem_index_in_file": 0,
    "title": "Text Justification",
    "description_snippet": "Given an array of strings words and a width maxWidth, format the text such that each line has exactl...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code, no actual code, following format. Must be in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to outline algorithm: Start, gather words into line, compute spaces, handle last line. Use decisions and loops. Provide arrow and indent decisions. We'll produce pseudocode lines. Use \"→\" arrow to next line.\n\nMake sure each line ends with comment.\n\nLet's craft:\n\nStart // 程式開始\n\n→ Initialize result list // 用來儲存排版後的每一行\n\n→ Set index = 0 // 追蹤目前已處理的單詞索引\n\n→ While index < words.length // 處理所有單詞\n\n    → Set lineStart = index // 記錄本行第一個單詞的位置\n\n    → Set lineLength = words[index].length // 本行已佔用字符長度\n\n    → Set index++ // 移動到下一個單詞\n\n    → While index < words.length AND lineLength + 1 + words[index].length <= maxWidth // 再加一個單詞不超過寬度\n\n        → lineLength += 1 + words[index].length // 加上空格和單詞長度\n\n        → index++ // 移動到下一個單詞\n\n    → Set lineEnd = index // 本行最後一個單詞索引\n\n    → Compute numberOfWords = lineEnd - lineStart // 本行單詞數\n\n    → Decision: 是否為最後一行? // 判斷是否已經到達字串結尾\n\n        Yes → Build left-justified line // 最後一行左對齊\n\n        No  → Decision: 只有一個單詞? // 需要特別處理\n\n            Yes → Build single-word line with padding // 只一個單詞時右側填滿空格\n\n            No  → Build fully-justified line // 其餘情況全對齊\n\n→ End // 程式結束\n\nBut need more detail on building lines: maybe separate steps.\n\nWe need to show building of spaces, distributing evenly, left-justified, etc.\n\nLet's produce each step with explanatory comment.\n\nAlso, include arrow for each sub-step within building line.\n\nLet's craft fully.\n\nWill include:\n\n- Step to calculate total spaces needed: maxWidth - sum word lengths.\n\n- For fully-justified: spacesBetweenWords = spacesNeeded / (numberOfWords-1) etc.\n\n- Extra spaces: remainder = spacesNeeded % (numberOfWords-1)\n\n- For left-justified: join words with single space, then pad end with spaces.\n\nWe can use pseudo-commands.\n\nLet's produce final output.\n\nRemember each line must be \"虛擬碼步驟 // 解釋\".\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ result ← empty list // 建立結果儲存容器  \n→ idx ← 0 // 設定目前單詞索引  \n→ wordsCount ← length(words) // 取得單詞總數  \n→ While idx < wordsCount // 逐行處理所有單詞  \n    → lineStart ← idx // 記錄本行第一個單詞的索引  \n    → lineLen ← length(words[idx]) // 本行已佔字符長度  \n    → idx ← idx + 1 // 移至下一個單詞  \n    → While idx < wordsCount AND lineLen + 1 + length(words[idx]) ≤ maxWidth // 若再加一個單詞不超過寬度  \n        → lineLen ← lineLen + 1 + length(words[idx]) // 加上空格與單詞長度  \n        → idx ← idx + 1 // 移至下一個單詞  \n    → lineEnd ← idx // 本行最後一個單詞索引（不包含）  \n    → numWords ← lineEnd - lineStart // 本行單詞數量  \n    → decision: idx == wordsCount ? // 判斷是否為最後一行  \n        Yes → // 最後一行左對齊  \n            → wordsInLine ← words[lineStart : lineEnd] // 取得本行所有單詞  \n            → line ← join(wordsInLine, \" \") // 以單個空格連接單詞  \n            → trailingSpaces ← maxWidth - length(line) // 需要填充的空格數  \n            → line ← line + repeat(\" \", trailingSpaces) // 右側填充空格  \n            → result.append(line) // 加入結果  \n        No  → // 不是最後一行  \n            → Decision: numWords == 1 ? // 只剩一個單詞時的特殊處理  \n                Yes → // 單字行，右側填充  \n                    → word ← words[lineStart]  \n                    → line ← word + repeat(\" \", maxWidth - length(word)) // 右側填空  \n                    → result.append(line)  \n                No  → // 多個單詞，需完全對齊  \n                    → totalWordLen ← 0  \n                    → For i from lineStart to lineEnd-1  \n                        → totalWordLen ← totalWordLen + length(words[i]) // 計算單詞總長  \n                    → spacesNeeded ← maxWidth - totalWordLen // 需要的空格總數  \n                    → gaps ← numWords - 1 // 單詞之間的空格數  \n                    → spacePerGap ← spacesNeeded // 除以 gaps 後取整數  \n                        = floor(spacesNeeded / gaps)  \n                    → extraSpaces ← spacesNeeded mod gaps // 余數，用於左側多餘空格  \n                    → line ← \"\"  \n                    → For i from lineStart to lineEnd-1  \n                        → line ← line + words[i] // 加入單詞  \n                        → If i < lineEnd-1 // 不是最後一個單詞  \n                            → baseSpace ← spacePerGap + 1 // 基本空格數（因為計算已包含單格）  \n                            → If extraSpaces > 0  \n                                → baseSpace ← baseSpace + 1 // 左側多餘空格  \n                                → extraSpaces ← extraSpaces - 1  \n                            → line ← line + repeat(\" \", baseSpace) // 加入空格  \n                    → result.append(line) // 加入結果  \n→ End // 程式結束執行",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # determine how many words can fit in the line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            # build the line\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(word) for word in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # left-justify for last line or single word\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                # fully justify\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k] + ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    words_match = re.search(r'words\\s*=\\s*(\\[[^\\]]*\\])', data)\n    maxwidth_match = re.search(r'maxWidth\\s*=\\s*(\\d+)', data)\n    if not words_match or not maxwidth_match:\n        return\n    words_list = ast.literal_eval(words_match.group(1))\n    maxWidth = int(maxwidth_match.group(1))\n    solution = Solution()\n    result = solution.fullJustify(words_list, maxWidth)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "success": true,
          "output": "['This    is    an', 'example  of text', 'justification.  ']"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "success": true,
          "output": "['What   must   be', 'acknowledgment  ', 'shall be        ']"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "success": true,
          "output": "['Science  is  what we', 'understand      well', 'enough to explain to', 'a  computer.  Art is', 'everything  else  we', 'do                  ']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode38.json",
    "problem_index_in_file": 0,
    "title": "Count and Say",
    "description_snippet": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code for generating nth element of count-and-say. No actual code, just virtual steps. Should be line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision, Start, End. Provide for generic algorithm: Start, set result=\"1\" for n=1, loop from 2 to n: compress previous string: iterate over characters, count consecutive identical, append count and char to new string. At end set result to new string. Finally output result. Provide explanation. Each line separate. Should include decisions for loops. Provide arrow structure. Let's produce.\n\nWe need to show iterative algorithm.\n\nWe can also show recursive approach but iterative is simpler.\n\nSo lines: Start, initialize n, initialize result, loop, inside loop: set current= result, new string empty, initialize count=1, iterate i from 1 to length-1: if current[i]==current[i-1], increment count else append count + char to new string, reset count=1. After loop, append last count+char. Set result=new string. Loop ends. End. Output result.\n\nAdd decision for n==1? Actually we can handle via loop starting at 1. Provide decision: if n==1? else loop.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 n // 從使用者取得要產生的第 n 個數列項  \n→ Decision: n 是否等於 1? // 若 n 為 1 則直接輸出初始值  \n    Yes → Step 2: 輸出 \"1\" // countAndSay(1) = \"1\"  \n    No  → Step 3: 設定 result = \"1\" // 初始化上一個數列項為 \"1\"  \n→ Step 4: 設定 counter = 2 // 從第 2 項開始計算  \n→ Decision: counter ≤ n? // 迴圈條件，直到計算到第 n 項  \n    Yes → Step 5: current = result // 取得上一個數列項  \n    → Step 6: newResult = \"\" // 用於儲存 RLE 壓縮後的新項  \n    → Step 7: count = 1 // 當前連續字元計數器  \n    → Step 8: i = 1 // 迭代索引，從第二個字元開始  \n    → Decision: i < length(current)? // 逐個字元遍歷 current  \n        Yes → Step 9: 如果 current[i] == current[i-1] 那麼  \n            → Step 10: count = count + 1 // 連續字元數加一  \n            → Step 11: i = i + 1 // 移動到下一個字元  \n            → Decision: i < length(current)? // 仍在範圍內？  \n                Yes → Step 12: 迴圈回到 Step 8  \n                No → Step 13: 新增 RLE 片段：newResult = newResult + count + current[i-1] // 將最後一段連續字元加入新結果  \n                    → Step 14: i = i + 1 // 確保離開迴圈  \n                    → Step 15: counter = counter + 1 // 進入下一項計算  \n                    → Step 16: result = newResult // 更新上一項為新結果  \n                    → Step 17: 回到 Step 4 迴圈條件  \n        No → Step 18: 新增 RLE 片段：newResult = newResult + count + current[i-1] // 目前字元與前一字元不同，加入已計數段  \n            → Step 19: count = 1 // 重置計數器  \n            → Step 20: i = i + 1 // 移動到下一個字元  \n            → Step 21: 回到 Step 8 迴圈  \n    No → Step 22: // i 不再小於 length(current)，表示已完成遍歷  \n        → Step 23: 新增 RLE 片段：newResult = newResult + count + current[length(current)-1] // 加入最後一段連續字元  \n        → Step 24: counter = counter + 1 // 進入下一項計算  \n        → Step 25: result = newResult // 更新上一項為新結果  \n        → Step 26: 回到 Step 4 迴圈條件  \n→ Decision: counter ≤ n? // 迴圈結束判斷  \n    Yes → 迴圈重複  \n    No → Step 27: 輸出 result // 得到第 n 個數列項  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        Return the nth term in the count-and-say sequence.\n        \"\"\"\n        # Base case: the first term is always \"1\".\n        if n == 1:\n            return \"1\"\n\n        # Iteratively build the sequence from the first term up to the nth term.\n        result = \"1\"\n        for _ in range(2, n + 1):\n            prev = result\n            new_result = []\n            count = 1\n            for i in range(1, len(prev)):\n                if prev[i] == prev[i - 1]:\n                    count += 1\n                else:\n                    new_result.append(str(count))\n                    new_result.append(prev[i - 1])\n                    count = 1\n            # Append the last run\n            new_result.append(str(count))\n            new_result.append(prev[-1])\n            result = \"\".join(new_result)\n        return result\n\ndef main() -> None:\n    \"\"\"\n    Reads an integer n from standard input, computes the nth count-and-say term,\n    and prints it surrounded by double quotes as required by the problem statement.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse input that may be in the form \"n = 4\" or just \"4\".\n    if '=' in data:\n        try:\n            n = int(data.split('=')[1].strip())\n        except ValueError:\n            n = int(data.replace('n', '').replace('=', '').strip())\n    else:\n        n = int(data)\n\n    solution = Solution()\n    result = solution.countAndSay(n)\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "\"1211\"",
          "success": true,
          "output": "\"1211\""
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "\"1\"",
          "success": true,
          "output": "\"1\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode287.json",
    "problem_index_in_file": 0,
    "title": "Find the Duplicate Number",
    "description_snippet": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving this problem: find duplicate number in array with n+1 numbers in 1..n, find duplicate without modifying array and constant space. Classic solution: Floyd's cycle detection (tortoise & hare). Steps: initialize slow=nums[0], fast=nums[0]; move slow=nums[slow], fast=nums[nums[fast]] until they meet; then find entrance: reset slow=nums[0]; while slow != fast: slow=nums[slow]; fast=nums[fast]; return slow.\n\nWe need to produce virtual code lines, each with explanation, using arrow syntax. Also use Decision: for loops? We can represent loops. Probably represent with Decision: and loop? But the example uses Decision for conditions. We can use loop structure by Decision with Yes/No leading to step. Let's outline:\n\nStart\n→ Step 1: Set slow = nums[0] // initialize tortoise\n→ Step 2: Set fast = nums[0] // initialize hare\n→ Decision: While slow != fast? // start loop to find intersection\n    Yes → Step 3: slow = nums[slow] // move tortoise one step\n    Yes → Step 4: fast = nums[nums[fast]] // move hare two steps\n    No  → (loop exit)\n→ Step 5: Set slow = nums[0] // reset tortoise to start\n→ Decision: While slow != fast? // find entrance\n    Yes → Step 6: slow = nums[slow] // move tortoise one\n    Yes → Step 7: fast = nums[fast] // move hare one\n    No  → (loop exit)\n→ Step 8: Return slow // duplicate number found\nEnd\n\nBut need to ensure each line has a virtual code step and explanation. Use arrow. For Decision we can write \"Decision: while slow != fast?\" then indent Yes branch. In example, they indent the Yes and No branches.\n\nLet's produce the output accordingly. Use Chinese comments. Use \"Start // 程式開始執行\". Also \"End // 程式執行結束\".\n\nWe need to ensure each line is separated by newline.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: slow = nums[0] // 初始化緩慢指標 tortoise\n→ Step 2: fast = nums[0] // 初始化快速指標 hare\n→ Decision: while slow != fast? // 進入找相交點的迴圈\n    Yes → Step 3: slow = nums[slow] // 慢速指標前進一步\n    Yes → Step 4: fast = nums[nums[fast]] // 快速指標前進兩步\n    No  → // 相交點找到，離開迴圈\n→ Step 5: slow = nums[0] // 把慢速指標重設到起點\n→ Decision: while slow != fast? // 找入場點（重複數）\n    Yes → Step 6: slow = nums[slow] // 慢速指標每次前進一步\n    Yes → Step 7: fast = nums[fast] // 快速指標每次前進一步\n    No  → // 相遇點即為重複數，離開迴圈\n→ Step 8: return slow // 回傳重複的數字\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare (Cycle Detection)\n        slow = fast = nums[0]\n        # Find intersection point of two runners.\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        # Find the entrance to the cycle (duplicate number).\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\ndef main():\n    # Read all input from stdin.\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list representation from the input string.\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        nums_str = data[start:end + 1]\n        nums = ast.literal_eval(nums_str)\n    except (ValueError, SyntaxError):\n        # Fallback: try to evaluate the whole input directly.\n        nums = ast.literal_eval(data)\n    # Compute and print the duplicate number.\n    result = Solution().findDuplicate(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,4,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3,3,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode714.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Transaction Fee",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: maximum profit with transaction fee, unlimited transactions. Classic DP: keep hold and cash states. We'll produce line-by-line pseudocode with explanation.\n\nStart, decision etc. Let's produce steps:\n\n- Input array prices, fee.\n- Initialize cash = 0, hold = -prices[0] - fee? Wait fee is paid on transaction, typical solution: hold = -prices[0] - fee? Actually fee is paid at sale, but can also treat at purchase or sale. Many solutions: hold = -prices[0] - fee (if fee at purchase). Let's pick hold = -prices[0] - fee. Then for each day i from 1 to n-1: cash = max(cash, hold + prices[i]); hold = max(hold, cash - prices[i] - fee). At end profit is cash. We'll produce steps.\n\nWe need to format as described. Each line: virtual code step + \" // explanation\". Use arrows and structure.\n\nLet's create:\n\nStart\n→ Step 1: Input prices array and fee // 取得價格陣列和手續費\n→ Decision: 檢查 prices 是否為空? // 若無資料則直接結束\n    Yes → End // 無股票無交易\n    No  →\n→ Step 2: 初始化 cash = 0, hold = -prices[0] - fee // 初始化現金與持股狀態\n→ Step 3: For i = 1 to length(prices)-1 // 逐日遍歷\n    → Step 4: cash = max(cash, hold + prices[i]) // 決定今日賣出或持有現金\n    → Step 5: hold = max(hold, cash - prices[i] - fee) // 決定今日買入或保持持股\n→ Step 6: Profit = cash // 最終最大利潤\nEnd\n\nBut need to include arrows for loops? Format: use Start, End, Decision. For loop maybe use Step: For i in... with indentation. Provide explanation. Let's craft.\n\nAlso note to include \"→\" preceding each step. The Decision block with Yes / No lines. The For loop: we might treat as Step 3: For i = 1 to n-1 // ... then inside indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 prices 陣列與 fee 整數 // 取得股票價格與手續費  \n→ Decision: 若 prices 為空陣列? // 檢查是否有資料可處理  \n    Yes → End // 無股票，直接結束  \n    No →  \n→ Step 2: cash ← 0, hold ← -prices[0] - fee // 初始現金為 0，持股時已扣除首日買入價格與手續費  \n→ Step 3: For i ← 1 to length(prices)-1 // 從第二天開始逐日遍歷  \n    → Step 4: cash ← max(cash, hold + prices[i]) // 今日若賣出則現金取最大值，否則保持現金  \n    → Step 5: hold ← max(hold, cash - prices[i] - fee) // 今日若買入則持股取最大值，否則保持持股  \n→ Step 6: profit ← cash // 最終最大利潤存於 profit  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices, fee):\n        n = len(prices)\n        if n == 0:\n            return 0\n        hold = -prices[0]\n        cash = 0\n        for price in prices[1:]:\n            cash = max(cash, hold + price - fee)\n            hold = max(hold, cash - price)\n        return cash\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list of prices and the fee using regex\n    match = re.search(r'prices\\s*=\\s*(\\[.*?\\])\\s*,\\s*fee\\s*=\\s*(\\d+)', data)\n    if not match:\n        # If the input format is not as expected, exit silently\n        return\n    prices_str, fee_str = match.group(1), match.group(2)\n    # Safely evaluate the list of prices\n    prices = ast.literal_eval(prices_str)\n    fee = int(fee_str)\n    # Compute the maximum profit\n    solution = Solution()\n    profit = solution.maxProfit(prices, fee)\n    print(profit)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,3,2,8,4,9], fee = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "prices = [1,3,7,5,10,3], fee = 3",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode406.json",
    "problem_index_in_file": 0,
    "title": "Queue Reconstruction by Height",
    "description_snippet": "You are given an array of people, people, which are the attributes of some people in a queue (not ne...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for reconstructing the queue given array people with height h_i and k_i. Standard solution: sort people by descending height, then insert at index k_i. Provide pseudocode steps line by line.\n\nLet's produce Start, Step 1: Sort people by height descending, if equal height ascending k maybe not needed but typical. Then create empty result array. Then for each person in sorted list: insert at index k_i. Then End.\n\nInclude Decision? Not needed. Use virtual arrows.\n\nMake sure each line has comment. Provide step numbers.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort people 由高到低排序，如果高度相同則按 k_i 升序 // 先把最高的人放在前面，確保插入時不會被後面更高的人影響  \n→ Step 2: 初始化 result 為空列表 // 用來存放最終排列好的隊列  \n→ Step 3: 對於 sorted_people 中的每一個 person  \n  → Decision: 取出當前 person 的 k_i // 需要知道目前此人前面有幾個更高或同高的人  \n   Yes → Step 4: 在 result 中插入 person，位置為 k_i // 插入的位置就是前面已經有 k_i 個更高/同高人的位置  \n   No → 省略 // 這裡實際上不會進入 No，因為每個人都必須插入  \n→ Step 5: 迴圈結束後，result 即為最終隊列 // 所有人已按照條件正確排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reconstructQueue(self, people):\n        \"\"\"\n        重建隊列。\n\n        步驟說明：\n        1. 先按高度遞減排序；若高度相同，按 k 升序。\n           這樣能保證高個子先被插入，後插入的低個子不會破壞已排好的高個子位置。\n        2. 用一個空列表 res 來保存結果。\n        3. 對於排序後的每個人 (h, k)：\n           直接在 res 中插入位置 k，因為已排好的前面恰好有 k 個高個子或同高個子。\n        4. 返回 res。\n        \"\"\"\n        # 步驟 1：按 (height descending, k ascending) 排序\n        people.sort(key=lambda x: (-x[0], x[1]))\n        # 步驟 2：建立空的結果列表\n        res = []\n        # 步驟 3：逐個插入\n        for person in people:\n            res.insert(person[1], person)\n        return res\n\ndef main():\n    \"\"\"\n    主函式：從標準輸入讀取資料、解析、呼叫解法並輸出結果。\n    輸入格式示例：\n        people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]\n    只需抽取列表部分並用 ast.literal_eval 解析即可。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找到第一個 '[' 和最後一個 ']'，抽取子串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # 無效輸入，直接退出\n        return\n    list_str = data[start:end+1]\n    try:\n        people = ast.literal_eval(list_str)\n    except Exception:\n        # 解析失敗時不做任何處理\n        return\n\n    # 呼叫解法\n    solution = Solution()\n    result = solution.reconstructQueue(people)\n\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
          "expected_output": "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]",
          "success": true,
          "output": "[[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]"
        },
        {
          "example_index": 1,
          "input": "people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]",
          "expected_output": "[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]",
          "success": true,
          "output": "[[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode381.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "description_snippet": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for the RandomizedCollection class, implementing insert, remove, getRandom in O(1). Should be pseudocode, no actual code. Use virtual code lines, each line has explanation.\n\nWe must describe initialization, data structures: vector for values, map from value to set of indices. And for removal, we swap with last element, update indices, etc.\n\nWe should produce steps for the whole algorithm: class definition, constructor, insert, remove, getRandom.\n\nEach line: \"虛擬碼步驟 // 解釋\"\n\nUse arrow notation. Let's produce:\n\nStart RandomizedCollection // start of constructor?\n\nBetter structure: Start class RandomizedCollection // class definition start.\n\nBut requirement: Use Start, End, Decision: etc. Might structure like:\n\nStart // 程式開始\n→ Step: 定義 class RandomizedCollection // 定義類別\n→ Step: 初始化 values list 和 indices map // 建立兩個資料結構\n...\n\nAlternatively break into methods.\n\nWe must show virtual code for insert, remove, getRandom.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step 1: 定義 RandomizedCollection 類別 // 建立類別\n\n→ Step 2: 建立空 vector values // 用於存放元素\n\n→ Step 3: 建立哈希表 indices mapping val -> set of indices // 追蹤每個值在 values 中的位置\n\n→ Step 4: 方法 insert(val)\n\n  → Decision: 若 indices[val] 為空? // 檢查 val 是否已存在\n\n    Yes → Step 5: 插入 val 到 values 並新增其索引到 indices[val] // 新增元素\n\n      → Step 6: 返回 true // 新元素\n\n    No  → Step 7: 插入 val 到 values 並新增索引到 indices[val] // 重複元素\n\n      → Step 8: 返回 false // 不是新元素\n\n→ Step 9: 方法 remove(val)\n\n  → Decision: 若 indices[val] 為空? // 是否存在該值\n\n    No → Step 10: 取得 indices[val] 的任意索引 idx_to_remove // 取一個要移除的索引\n\n      → Step 11: 取得 values 最後一個元素 last_val, last_index\n\n      → Decision: 若 idx_to_remove != last_index? // 是否不是最後一個\n\n        Yes → Step 12: 把 last_val 放到 idx_to_remove 的位置 // 替換\n\n          → Step 13: 更新 indices[last_val] 的索引集合：移除 last_index，新增 idx_to_remove\n\n        No → Step 14: // idx_to_remove 是最後一個，直接覆蓋\n\n      → Step 15: 從 values 刪除最後一個元素 // 移除\n\n      → Step 16: 在 indices[val] 刪除 idx_to_remove // 更新索引\n\n      → Decision: 若 indices[val] 空? // 是否還有該值\n\n        Yes → Step 17: 刪除 indices[val] 進行清理\n\n      → Step 18: 返回 true // 成功移除\n\n    Yes → Step 19: 返回 false // 沒有該元素\n\n→ Step 20: 方法 getRandom()\n\n  → Step 21: 隨機產生 0 到 values.size()-1 的索引 r // 隨機位置\n\n  → Step 22: 返回 values[r] // 返回隨機元素\n\nEnd // 程式結束\n\nWe should use \"Step\" or \"Step X:\" but format example uses \"Step 1:\" etc. So we will use \"Step 1:\" style.\n\nAlso use arrows: \"→\" before each step.\n\nWe'll include decisions with indentation.\n\nMake sure each line has \"// 解釋\".\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 定義 RandomizedCollection 類別 // 建立類別\n→ Step 2: 建立空 vector values // 用於儲存所有元素，允許快速存取最後一項\n→ Step 3: 建立哈希表 indices mapping val -> set of indices // 追蹤每個值在 values 中所有位置\n→ Step 4: 方法 insert(val) // 插入一個值\n    → Decision: 若 indices[val] 為空? // 判斷 val 是否首次出現\n        Yes → Step 5: 將 val 推入 values 並把其索引加入 indices[val] // 新增元素並記錄索引\n            → Step 6: 返回 true // 表示 val 原本不存在\n        No  → Step 7: 將 val 推入 values 並把其索引加入 indices[val] // 仍需記錄索引\n            → Step 8: 返回 false // 表示 val 已存在\n→ Step 9: 方法 remove(val) // 移除一個值\n    → Decision: 若 indices[val] 為空? // 判斷 val 是否存在\n        No → Step 10: 取 indices[val] 的任意一個索引 idx_to_remove // 選擇要移除的位置\n            → Step 11: 取 values 的最後一個元素 last_val 及其索引 last_index // 需要移動\n            → Decision: 若 idx_to_remove != last_index? // 需要交換\n                Yes → Step 12: 把 last_val 放到 idx_to_remove 的位置 // 交換位置\n                    → Step 13: 在 indices[last_val] 移除 last_index 並加入 idx_to_remove // 更新索引集合\n                No  → Step 14: // idx_to_remove 是最後一項，無需交換\n            → Step 15: 從 values 刪除最後一個元素 // 真正移除\n            → Step 16: 在 indices[val] 移除 idx_to_remove // 更新索引集合\n            → Decision: 若 indices[val] 空? // 是否還有該值剩餘\n                Yes → Step 17: 刪除 indices[val] 以釋放空間\n            → Step 18: 返回 true // 成功移除\n        Yes → Step 19: 返回 false // val 不存在\n→ Step 20: 方法 getRandom() // 取得隨機元素\n    → Step 21: 隨機產生索引 r 在 [0, values.size()-1] 之間 // 隨機位置\n    → Step 22: 返回 values[r] // 回傳隨機元素\nEnd // 程式結束",
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 用於存儲所有元素的列表\n        self.data = []\n        # 哈希表：值 -> 其在 data 中的所有索引集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        插入元素 val。\n        若 val 原本不存在於集合，返回 True；否則返回 False。\n        \"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此時索引集合大小為 1，表示 val 原本不存在\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        移除元素 val（若存在）。若成功移除，返回 True；否則返回 False。\n        \"\"\"\n        if not self.idx_map[val]:\n            return False\n        # 任取一個要移除的索引\n        remove_idx = self.idx_map[val].pop()\n        # 取最後一個元素的位置\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 若要移除的不是最後一個，將最後一個元素搬到要移除的位置\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            # 更新 last_val 的索引集合\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n        # 移除最後一個元素\n        self.data.pop()\n        # 若 val 的索引集合已空，刪除鍵以釋放空間\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        隨機返回一個元素。每個元素的返回機率與其出現次數成正比。\n        \"\"\"\n        return random.choice(self.data)\n\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    # 以換行分割，期望兩行：命令列表和參數列表\n    parts = raw_input.strip().splitlines()\n    if len(parts) < 2:\n        return\n    # 使用 eval 解析，因為輸入使用單引號而非 JSON\n    commands = eval(parts[0])\n    args_list = eval(parts[1])\n\n    result = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)\n        elif cmd == \"insert\":\n            res = obj.insert(args[0])\n            result.append(res)\n        elif cmd == \"remove\":\n            res = obj.remove(args[0])\n            result.append(res)\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n        else:\n            # 未知命令，輸出 None\n            result.append(None)\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 的格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      ''"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode132.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning II",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for minimum palindrome partitioning cuts. The output should be lines with \"虛擬碼步驟 // 解釋\". Must not output actual code. Use Start, End, Decision. Use arrows and maybe indentation.\n\nWe need algorithm: dynamic programming. For each i, compute min cuts up to i. Use palindrome table or expand around center. But pseudocode can illustrate high-level.\n\nLet's craft step by step:\n\nStart\n→ Initialize n = length of s\n→ Initialize array dp[n] // dp[i] min cuts for substring s[0..i]\n→ For i from 0 to n-1:\n    → For j from 0 to i:\n        → Decision: if s[j..i] is palindrome? // check\n            Yes → If j==0 then cuts=0 else cuts=dp[j-1]+1\n            → dp[i] = min(dp[i], cuts)\n→ Return dp[n-1] // min cuts for full string\nEnd\n\nWe also need to explain palindrome check. Could precompute palindrome table or use expansion each time. Let's include subroutine CheckPalindrome(start, end). Use DP.\n\nAlso explain complexity.\n\nBut just pseudocode lines. Use arrow '→'. Indent decisions and branches with indentation.\n\nNeed to maintain indentation maybe with spaces.\n\nLet's produce.\n\nWe also can add a step to precompute palindrome table:\n\n→ Initialize 2D bool pal[n][n] // true if substring i..j palindrome\n→ For i from 0 to n-1:\n    → pal[i][i] = true\n→ For length from 2 to n:\n    → For i from 0 to n-length:\n        → j = i+length-1\n        → Decision: if s[i]==s[j] and (length==2 or pal[i+1][j-1])? // palindrome\n            Yes → pal[i][j] = true\n            No  → pal[i][j] = false\n\nThen DP.\n\nLet's produce final output.\n\nRemember to include // explanation after each line.\n\nUse proper arrow formatting.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize n = length of s // 取得輸入字串長度  \n→ Initialize 2D bool array pal[n][n] = false // 兩維布林表用於判斷子字串是否為回文  \n\n// 建立回文表  \n→ For i from 0 to n-1:  \n  → pal[i][i] = true // 單個字元永遠是回文  \n→ For len from 2 to n:  \n  → For i from 0 to n-len:  \n    → j = i + len - 1  \n    → Decision: s[i] == s[j] AND (len == 2 OR pal[i+1][j-1])? // 判斷 i..j 是否回文  \n      Yes → pal[i][j] = true // 符合條件即為回文  \n      No  → pal[i][j] = false // 否則非回文  \n\n// DP 计算最小切割数  \n→ Initialize array dp[n] // dp[i] 表示子字串 s[0..i] 的最小切割数  \n→ For i from 0 to n-1:  \n  → dp[i] = i // 上限：把每个字符单独切割  \n  → For j from 0 to i:  \n    → Decision: pal[j][i]? // 子字串 s[j..i] 是否为回文  \n      Yes → Decision: j == 0? // 若从头开始则不需要切割  \n        Yes → cuts = 0 // 直接一块\n        No  → cuts = dp[j-1] + 1 // 在 j-1 处切一次再加上一块  \n        dp[i] = min(dp[i], cuts) // 更新最小切割数  \n      No  → // 子字串不是回文，跳过  \n→ Return dp[n-1] // 返回完整字符串的最小切割数  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        pal = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            min_cut = i  # worst case: cut before every character\n            for j in range(i + 1):\n                # check if s[j..i] is a palindrome\n                if s[j] == s[i] and (i - j <= 1 or pal[j + 1][i - 1]):\n                    pal[j][i] = True\n                    if j == 0:\n                        min_cut = 0\n                    else:\n                        min_cut = min(min_cut, dp[j - 1] + 1)\n            dp[i] = min_cut\n\n        return dp[-1]\n\ndef main():\n    data = sys.stdin.read()\n    # Extract the first string literal found in the input\n    match = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    if not match:\n        # If no quotes are found, treat the whole line as the string\n        s = data.strip()\n    else:\n        s = match.group(1)\n    solution = Solution()\n    result = solution.minCut(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode521.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence I",
    "description_snippet": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, using arrows, decisions. The task: given two strings a and b, return length of longest uncommon subsequence (LUS) between them. Standard Leetcode problem: if a==b return -1 else return max(len(a), len(b)). So algorithm is simple.\n\nWe need to generate virtual code with explanation lines. Should not output actual code. Use Start, Decision, Step, End. Provide each line with \"虛擬碼步驟 // 解釋\". So produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 讀取字串 a 和 b // 取得輸入\n\nBut must be more specific? Virtual code: Step 1: 接收輸入 a,b\n\nDecision: 如果 a == b? // 比較兩字串\n\nYes → Step 2: 回傳 -1 // 不存在不常見子序列\n\nNo  → Step 3: 計算長度 // 找出長度較大\n\n→ Step 4: 回傳 max(len(a), len(b)) // 回傳結果\n\nEnd\n\nAdd explanations. That is. Provide in Traditional Chinese.\n\nLet's produce.\n\nMake sure each line is one step with arrow as specified: \"→ Step X: ...\". Use \"Decision:\" lines. Use Yes →, No →. End.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 a 與 b // 取得兩個需要比較的字串  \n→ Decision: 如果 a 與 b 完全相同? // 檢查兩個字串是否相等  \n Yes → Step 2: 回傳 -1 // 相同時不存在「唯一」子序列，直接返回 -1  \n No  → Step 3: 取得字串長度 len_a 與 len_b // 分別計算兩個字串的長度  \n→ Step 4: 計算最大長度 max_len ← max(len_a, len_b) // 取兩個長度中較大的那個  \n→ Step 5: 回傳 max_len // 輸出最長的不常見子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        \"\"\"\n        返回兩個字串之間最長的不常見子序列長度。\n        如果兩個字串相同，則不存在不常見子序列，回傳 -1。\n        \"\"\"\n        if a == b:\n            return -1\n        return max(len(a), len(b))\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入，解析兩個字串，計算並輸出答案。\n    支援輸入格式：\n        - 兩個字串用逗號分隔並包在雙引號內，例如 \"aba\", \"cdc\"\n        - 兩個字串分別佔一行\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 首先嘗試尋找雙引號中的字串\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        a, b = quoted[0], quoted[1]\n    else:\n        # 若沒有雙引號，嘗試直接以逗號或空白分割\n        parts = re.split(r',|\\s+', data)\n        parts = [p for p in parts if p]  # 去除空字串\n        if len(parts) >= 2:\n            a, b = parts[0], parts[1]\n        else:\n            # 讀取不到兩個字串，直接結束\n            return\n\n    sol = Solution()\n    result = sol.findLUSlength(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"aba\", \"cdc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "\"aaa\", \"bbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "\"aaa\", \"aaa\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode322.json",
    "problem_index_in_file": 0,
    "title": "Coin Change",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for coin change problem minimal coins, infinite supply. Classic DP: dp[0]=0, dp[i]=min(dp[i-coin]+1). Return dp[amount] or -1.\n\nWe need to use the format: \"虛擬碼步驟 // 解釋\". Each line. Use Start, End, Decision, arrows. We need to include loops. Use Decision: if amount==0? etc.\n\nWe must produce steps: Start, initialize dp array, set dp[0]=0, dp others = Infinity. Loop over amounts 1..amount, inner loop over coins, update dp[i]. After loops, decision if dp[amount] == Infinity? return -1 else dp[amount].\n\nLet's produce steps with arrows. Eg:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 陣列長度 amount+1，所有值設為 Infinity // 建立 DP 表，初始值為無限大\n→ Step 2: 設定 dp[0] = 0 // 零金額不需要任何硬幣\n\n→ Decision: 是否需要計算所有金額? // 檢查是否有剩餘金額需要處理\n    Yes → Loop i from 1 to amount: // 循環計算每個金額的最小硬幣數\n        → Step 3: 將 dp[i] 設為 Infinity // 預設為無限大\n        → Loop over每個 coin in coins: // 遍歷所有硬幣面額\n            → Decision: 如果 i >= coin? // 檢查硬幣能否用於此金額\n                Yes → Step 4: 計算 newCount = dp[i-coin] + 1 // 使用該硬幣後的硬幣總數\n                → Decision: 如果 newCount < dp[i]? // 比較是否更少\n                    Yes → Step 5: 更新 dp[i] = newCount // 更新為更少的硬幣數\n                    No  → Step 6: 保持 dp[i] 不變 // 保留較大的數\n                No  → Step 7: 跳過此硬幣 // 不能用此硬幣\n            No → Step 8: 跳過此硬幣 // i 小於 coin\n        No → Step 9: 結束內層迴圈 // 完成此金額的所有硬幣檢查\n    No → Step 10: 無需計算 // amount 為 0 時已初始化\n\n→ Decision: 如果 dp[amount] 為 Infinity? // 檢查是否能組合成該金額\n    Yes → Step 11: 回傳 -1 // 無法得到該金額\n    No  → Step 12: 回傳 dp[amount] // 最小硬幣數\n\nEnd // 程式執行結束\n\nNeed to use arrow syntax with \"→\" and \"Decision:\" lines.\n\nEnsure each line ends with // 解釋.\n\nLet's craft. Also maybe use \"Start\" and \"End\".\n\nAlso the loops: we can use \"Loop\" step: \"Loop i from 1 to amount:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 陣列長度 amount+1，所有值設為 Infinity // 建立 DP 表，初始值為無限大  \n→ Step 2: 設定 dp[0] = 0 // 零金額不需要任何硬幣  \n\n→ Decision: 是否需要計算所有金額? // 檢查是否有剩餘金額需要處理  \n    Yes → Loop i from 1 to amount: // 循環計算每個金額的最小硬幣數  \n        → Step 3: 將 dp[i] 設為 Infinity // 預設為無限大  \n        → Loop over每個 coin in coins: // 遍歷所有硬幣面額  \n            → Decision: 如果 i >= coin? // 檢查硬幣能否用於此金額  \n                Yes → Step 4: 計算 newCount = dp[i-coin] + 1 // 使用該硬幣後的硬幣總數  \n                → Decision: 如果 newCount < dp[i]? // 比較是否更少  \n                    Yes → Step 5: 更新 dp[i] = newCount // 更新為更少的硬幣數  \n                    No  → Step 6: 保持 dp[i] 不變 // 保留較大的數  \n                No  → Step 7: 跳過此硬幣 // 不能用此硬幣  \n            No → Step 8: 跳過此硬幣 // i 小於 coin  \n        No → Step 9: 結束內層迴圈 // 完成此金額的所有硬幣檢查  \n    No → Step 10: 無需計算 // amount 為 0 時已初始化  \n\n→ Decision: 如果 dp[amount] 為 Infinity? // 檢查是否能組合成該金額  \n    Yes → Step 11: 回傳 -1 // 無法得到該金額  \n    No  → Step 12: 回傳 dp[amount] // 最小硬幣數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # dp[i] 表示湊成金額 i 所需最少硬幣數\n        dp = [math.inf] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n\n        return dp[amount] if dp[amount] != math.inf else -1\n\ndef parse_input(data: str):\n    \"\"\"\n    解析類似 'coins = [1,2,5], amount = 11' 的輸入字串。\n    \"\"\"\n    coins_match = re.search(r'coins\\s*=\\s*(\\[.*?\\])', data, re.S)\n    amount_match = re.search(r'amount\\s*=\\s*(-?\\d+)', data)\n\n    if not coins_match or not amount_match:\n        raise ValueError(\"輸入格式不正確\")\n\n    # 安全地解析列表\n    coins = eval(coins_match.group(1))\n    amount = int(amount_match.group(1))\n    return coins, amount\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    coins, amount = parse_input(raw_input)\n    solution = Solution()\n    result = solution.coinChange(coins, amount)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "coins = [1], amount = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode213.json",
    "problem_index_in_file": 0,
    "title": "House Robber II",
    "description_snippet": "You are a professional robber planning to rob houses along a street. Each house has a certain amount...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. The problem: House Robber II (circle). We need to compute max loot with no adjacent houses. Classic solution: consider two scenarios: rob houses 0..n-2 and 1..n-1. Use linear DP.\n\nWe need to output step by step virtual code lines with arrow and decisions. So something like:\n\nStart\n→ Step: if nums empty => return 0\n→ Step: if length==1 => return nums[0]\n→ Step: compute maxLinear(nums, 0, n-2)\n→ Step: compute maxLinear(nums, 1, n-1)\n→ Step: result = max(a, b)\n→ End\n\nInside maxLinear, we need DP: prev2, prev1.\n\nUse decision: for each i from start+1 to end:\n\nDecision: if nums[i] + prev2 > prev1? etc.\n\nWe'll show lines.\n\nLet's create Virtual Code steps:\n\nStart // Program start\n\n→ Step 1: Input array nums // receive input\n\n→ Decision: If nums is empty? // handle edge\n\nYes → Step 2: Return 0 // no houses\n\n→ Decision: If nums length == 1? // single house\n\nYes → Step 3: Return nums[0] // rob that house\n\n→ Step 4: Define helper function MaxLinear(start, end) // compute max for linear segment\n\n    → Step 4.1: Initialize prev2 = 0 // max till house before previous\n\n    → Step 4.2: Initialize prev1 = nums[start] // max till previous house\n\n    → Decision: If start == end? // single house in segment\n\n    Yes → Step 4.3: Return prev1 // only one house\n\n    → Step 4.4: For i from start+1 to end // iterate houses\n\n        → Decision: If nums[i] + prev2 > prev1? // choose rob or skip\n\n            Yes → Step 4.5: curr = nums[i] + prev2 // rob current\n\n            No  → Step 4.6: curr = prev1 // skip current\n\n        → Step 4.7: prev2 = prev1 // shift window\n\n        → Step 4.8: prev1 = curr // update\n\n    → Step 4.9: Return prev1 // final max\n\n→ Step 5: max1 = MaxLinear(0, n-2) // exclude last house\n\n→ Step 6: max2 = MaxLinear(1, n-1) // exclude first house\n\n→ Step 7: result = max(max1, max2) // pick better\n\n→ Step 8: Return result // output\n\nEnd\n\nWe need arrow formatting. Each line must contain arrow and comment. Indentation for nested steps. Let's produce with spaces or indentation? In example they used arrow \"→\" and indentation inside decisions. We'll replicate.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 取得要盜的房屋金額列表  \n\n→ Decision: 如果 nums 為空? // 先處理邊界情況  \n  Yes → Step 2: Return 0 // 沒有房屋，無法盜取  \n  No  → Decision: 如果 nums 長度為 1? // 只有一棟房屋  \n    Yes → Step 3: Return nums[0] // 直接盜取那棟房屋  \n    No  → Step 4: 定義函式 MaxLinear(start, end) // 計算線性區段的最大盜取金額  \n\n    → Step 4.1: 初始化 prev2 = 0 // 兩棟前的最大值  \n    → Step 4.2: 初始化 prev1 = nums[start] // 一棟前的最大值  \n\n    → Decision: 如果 start == end? // 只剩一棟房屋  \n      Yes → Step 4.3: Return prev1 // 直接回傳該房屋金額  \n      No  → Step 4.4: 從 start+1 迭代到 end // 遍歷剩餘房屋  \n\n      → Decision: 如果 nums[i] + prev2 > prev1? // 盜取當前房屋是否更划算  \n        Yes → Step 4.5: curr = nums[i] + prev2 // 盜取並加上兩棟前的最大值  \n        No  → Step 4.6: curr = prev1 // 跳過該房屋，保持前一棟的最大值  \n\n      → Step 4.7: prev2 = prev1 // 將 prev1 轉為 prev2  \n      → Step 4.8: prev1 = curr // 更新 prev1 為本輪最大值  \n\n    → Step 4.9: Return prev1 // 回傳整個區段的最大盜取金額  \n\n→ Step 5: max1 = MaxLinear(0, n-2) // 排除最後一棟房屋  \n→ Step 6: max2 = MaxLinear(1, n-1) // 排除第一棟房屋  \n→ Step 7: result = max(max1, max2) // 兩種情況取較大者  \n→ Step 8: Return result // 輸出最終答案  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    \"\"\"\n    House Robber II（圓形排列）解法\n    \"\"\"\n    def rob(self, nums):\n        # 空列表直接回傳 0\n        if not nums:\n            return 0\n        # 只有一棟房子時只能盜取那棟\n        if len(nums) == 1:\n            return nums[0]\n\n        # 直線排列的最優解\n        def rob_linear(houses):\n            prev, curr = 0, 0\n            for num in houses:\n                prev, curr = curr, max(curr, prev + num)\n            return curr\n\n        # 兩種情況：排除最後一棟或排除第一棟\n        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))\n\n\ndef main():\n    \"\"\"\n    主程式：讀取輸入、執行計算、輸出結果\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析「nums = [1,2,3]」或僅「[1,2,3]」的輸入\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n\n    # 使用 eval 取得 list（輸入符合 Python list 語法）\n    try:\n        nums = eval(list_part)\n    except Exception as e:\n        # 若解析失敗，直接退出\n        print(\"輸入格式錯誤\")\n        return\n\n    # 計算最大盜取金額\n    result = Solution().rob(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode402.json",
    "problem_index_in_file": 0,
    "title": "Remove K Digits",
    "description_snippet": "Given string num representing a non-negative integer num, and an integer k, return the smallest poss...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: \"Given a string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.\" Essentially Leetcode 402 Remove K Digits.\n\nWe need to produce step-by-step pseudocode lines with explanations. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and decision structure.\n\nWe should cover steps: start, input, if k >= length return \"0\", stack approach to remove k digits, handle leading zeros, final result, output, end.\n\nLet's produce lines with Start, input assignment, condition, loop, decisions, final adjustments, output.\n\nWe need to maintain arrow representation: \"→\" before each step, \"Decision:\" lines.\n\nLet's craft.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: 讀取 num 與 k // 取得輸入的數字字串與要刪除的位數\n→ Decision: 如果 k >= len(num)? // 檢查是否要刪除全部位數\n    Yes → Step 2: 回傳 \"0\" // 直接輸出 0，因為所有位數都被刪除\n    No  → Step 3: 初始化空棧 stack // 用於儲存最終結果的數位\n    → Step 4: 逐個字元 c 於 num 迭代 // 逐位檢查\n        → Decision: 如果 stack 不是空且 k > 0 且 stack.top > c? // 若前一位較大且還有刪除餘量\n            Yes → Step 5: pop stack.top; k ← k - 1 // 刪除前一位，減少刪除數\n            No  → Step 6: push c 到 stack // 保留當前位\n    → Step 7: 若 k > 0 則 stack.pop k 次 // 仍有剩餘刪除，從尾部刪除\n    → Step 8: 建立 result 字串，將 stack 的內容拼接起來 // 將棧中的位數組成字串\n    → Decision: 若 result 為空? // 檢查是否全部被刪除\n        Yes → Step 9: result ← \"0\" // 若空則回傳 0\n        No  → Step 10: 去除 result 前導 0 // 去除前導零\n    → Step 11: 回傳 result // 輸出最小數\nEnd // 程式執行結束\n\nNeed to format with arrow per line.\n\nAlso, we need to include \"Start\" and \"End\".\n\nAlso, the arrow for decision branches inside loops must be nested? Use indentation maybe not required but we can keep arrow.\n\nWe'll produce.\n\nLet's write the final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 num 與 k // 取得輸入的數字字串與要刪除的位數  \n→ Decision: 如果 k >= len(num)? // 檢查是否要刪除全部位數  \n Yes → Step 2: 回傳 \"0\" // 直接輸出 0，因為所有位數都被刪除  \n No → Step 3: 初始化空棧 stack // 用於儲存最終結果的數位  \n → Step 4: 逐個字元 c 於 num 迭代 // 逐位檢查  \n  → Decision: 如果 stack 不是空且 k > 0 且 stack.top > c? // 若前一位較大且還有刪除餘量  \n   Yes → Step 5: pop stack.top; k ← k - 1 // 刪除前一位，減少刪除數  \n   No  → Step 6: push c 到 stack // 保留當前位  \n → Step 7: 若 k > 0 則 stack.pop k 次 // 仍有剩餘刪除，從尾部刪除  \n→ Step 8: 建立 result 字串，將 stack 的內容拼接起來 // 將棧中的位數組成字串  \n→ Decision: 若 result 為空? // 檢查是否全部被刪除  \n Yes → Step 9: result ← \"0\" // 若空則回傳 0  \n No  → Step 10: 去除 result 前導 0 // 去除前導零  \n→ Step 11: 回傳 result // 輸出最小數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        \"\"\"Return the smallest number after removing k digits from num.\"\"\"\n        stack = []\n        for digit in num:\n            # Remove previous larger digits while we still have deletions left\n            while k > 0 and stack and stack[-1] > digit:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n\n        # If deletions remain, remove from the end\n        while k > 0:\n            stack.pop()\n            k -= 1\n\n        # Build result and strip leading zeros\n        result = ''.join(stack).lstrip('0')\n        return result if result else \"0\"\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that may come in two common formats:\n    1. Single line like: num = \"1432219\", k = 3\n    2. Two separate lines:\n        1432219\n        3\n    Returns (num, k) tuple.\n    \"\"\"\n    # Try regex format\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]*)\"', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if num_match and k_match:\n        return num_match.group(1), int(k_match.group(1))\n\n    # Fallback: split by lines\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], int(lines[1])\n    raise ValueError(\"Input format not recognized\")\n\ndef main():\n    raw_data = sys.stdin.read()\n    if not raw_data.strip():\n        return\n    num, k = parse_input(raw_data)\n    result = Solution().removeKdigits(num, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"1432219\", k = 3",
          "expected_output": "\"1219\"",
          "success": true,
          "output": "1219"
        },
        {
          "example_index": 1,
          "input": "num = \"10200\", k = 1",
          "expected_output": "\"200\"",
          "success": true,
          "output": "200"
        },
        {
          "example_index": 2,
          "input": "num = \"10\", k = 2",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode125.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome",
    "description_snippet": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and remov...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, each line with \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows and Decision. The code should reflect algorithm: iterate string, keep only alnum lowercase, then check palindrome. Virtual code might use two pointers or build cleaned string. Use decision steps.\n\nWe need to not output actual code. Provide structure. Provide virtual steps line by line. Probably use Start, End. Use Decision: if cleaned string length <=1 true. Use two pointers left right.\n\nLet's craft.\n\nLine 1: Start\n\nLine 2: → Step 1: Initialize cleanedString as empty // prepare storage\n\nLine 3: → Step 2: For each character c in s // iterate input\n\nLine 4:     → Decision: 如果 c 是字母或數字? // check alnum\n\nLine 5:         Yes → Step 3: Append lowercased(c) to cleanedString // keep only alnum lowercased\n\nLine 6:         No  → Step 4: Skip character // ignore others\n\nLine 7: → Decision: 如果 cleanedString 只含 0 或 1 個字符? // trivial palindrome\n\nLine 8:     Yes → Step 5: 返回 true // empty or single char is palindrome\n\nLine 9:     No  → Step 6: 初始化 left = 0, right = cleanedString.length - 1 // set pointers\n\nLine 10: → Decision: 循環 while left < right? // compare ends\n\nLine 11:     Yes → Step 7: Decision: 如果 cleanedString[left] != cleanedString[right]? // mismatch\n\nLine 12:         Yes → Step 8: 返回 false // not palindrome\n\nLine 13:         No  → Step 9: Increment left, decrement right // move inward\n\nLine 14:     No  → Step 10: 返回 true // all matched\n\nLine 15: End\n\nWe need to format each line as \"虛擬碼步驟 // 解釋\". Each step should be one line. Indent? Might use arrows with spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 cleanedString 為空字串 // 準備儲存純文字  \n→ Step 2: 對 s 中每個字元 c 進行迭代 // 遍歷輸入  \n → Decision: 如果 c 是字母或數字? // 判斷是否為有效字符  \n  Yes → Step 3: 將 lowercased(c) 加入 cleanedString // 轉小寫並保留  \n  No  → Step 4: 跳過此字元 // 忽略非字母數字  \n→ Decision: 如果 cleanedString 只含 0 或 1 個字符? // 基本情況  \n Yes → Step 5: 返回 true // 空或單一字符自動回文  \n No  → Step 6: 設定 left = 0, right = cleanedString.length - 1 // 指定左右指標  \n→ Decision: while left < right? // 開始比較  \n Yes → Step 7: Decision: 如果 cleanedString[left] != cleanedString[right]? // 檢查兩端是否相等  \n  Yes → Step 8: 返回 false // 不相等即非回文  \n  No  → Step 9: left++, right-- // 指標向中心移動  \n No  → Step 10: 返回 true // 所有對稱字元均相等  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    判斷字串 s 是否為回文。\n    只保留字母和數字，並轉成小寫，再檢查是否相同。\n    \"\"\"\n    filtered = []\n    for c in s:\n        if c.isalnum():\n            filtered.append(c.lower())\n    left, right = 0, len(filtered) - 1\n    while left < right:\n        if filtered[left] != filtered[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n\n    # 解析輸入字串\n    if not raw_input:\n        input_str = \"\"\n    else:\n        # 如果有 's =' 這樣的格式，先切割\n        if \"=\" in raw_input:\n            _, after_eq = raw_input.split(\"=\", 1)\n            raw_input = after_eq.strip()\n        # 去除可能的雙引號\n        if raw_input.startswith('\"') and raw_input.endswith('\"'):\n            input_str = raw_input[1:-1]\n        else:\n            input_str = raw_input\n\n    # 判斷是否為回文\n    result = is_palindrome(input_str)\n    # 按照題目要求輸出 'true' 或 'false'\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"race a car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \" \"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode169.json",
    "problem_index_in_file": 0,
    "title": "Majority Element",
    "description_snippet": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, in Traditional Chinese. The problem is to find majority element in array where always exists. Classic solution: Boyer-Moore Voting Algorithm. Virtual code steps: start, initialize candidate, count, loop through nums, if count==0 set candidate to current and count=1 else if nums[i]==candidate count++ else count--. After loop return candidate. Use decision arrows.\n\nWe need each line with virtual code and explanation. Use Start, End, Decision: with arrows.\n\nWe should not output actual code, just virtual steps. Let's craft.\n\nLine 1: Start // 程式開始\n\nLine 2: → Step 1: 初始化候選人 candidate 為 nums[0]，計數 count 為 1 // 設定初始值\n\nLine 3: → Step 2: 從索引 1 開始遍歷 nums // 循環遍歷陣列\n\nWe need loop structure. We can use Decision: index < n? Yes → ... No → End. But maybe simpler: For each element, decision inside.\n\nBetter: Use \"Step 2: 遍歷 nums 的每個元素 x\" then decision inside. But to keep structure with arrows.\n\nWe can write:\n\nStep 2: For each element x in nums[1: ] // 遍歷剩餘元素\n\nBut we need step by step. Let's use Decision inside loop: Decision: 如果 count == 0? Yes → set candidate = x, count=1 No → Decision: x == candidate? Yes → count++ No → count--.\n\nAfter loop, return candidate.\n\nLet's write virtual code accordingly.\n\nLine 3: → Decision: 迴圈索引 i < n? Yes → Step 2: 取得元素 nums[i] // 取得當前元素\nLine 4: → Decision: i == 0? No → Step 3: // 只處理從索引 1 開始\nLine 5:   Yes → i++ → Continue // 先處理索引 0 直接跳過\n\nThis seems messy. Maybe simpler: Use a generic \"Step 2: 對每個元素 x 執行以下判斷\". But we still need arrow.\n\nLet's do:\n\nStep 2: 依序處理 nums 的每個元素 x // 循環遍歷\n\nInside:\n\nDecision: 如果 count == 0? Yes → Step 3: 將 candidate 設為 x，count = 1 // 重置候選人\n           No → Decision: x == candidate? Yes → Step 4: count++ // 增加計數\n                                   No → Step 5: count-- // 減少計數\n\nAfter loop:\n\nStep 6: 返回 candidate // majority element\n\nEnd.\n\nWe need to express loop, but we can treat \"Step 2\" as loop body. Use \"→ Step 2: 遍歷 nums 的每個元素 x\" and then decisions inside. That's okay.\n\nLet's produce lines accordingly.\n\nAlso include arrows after each step: \"→\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 將 candidate 設為 nums[0]，count 設為 1 // 初始化候選人\n→ Step 2: 針對 nums 的每個元素 x（從索引 1 開始）執行以下判斷 // 進入迴圈\n    → Decision: 如果 count == 0? // 判斷計數是否為零\n        Yes → Step 3: 設定 candidate = x，count = 1 // 重置候選人\n        No  → Decision: x == candidate? // 判斷元素是否與候選人相同\n            Yes → Step 4: count++ // 相同則計數加一\n            No  → Step 5: count-- // 不同則計數減一\n→ Step 6: 返回 candidate // 最終 majority element\nEnd // 程式執行結束\n\nCheck formatting: each line must have virtual code step + space + // explanation. Indentation maybe not needed but can show nested decisions. Use arrow arrows with spaces. Use \"Decision:\" etc.\n\nAlso ensure each line separate. Should include Start and End.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 candidate 設為 nums[0]，count 設為 1 // 初始化候選人  \n→ Step 2: 針對 nums 的每個元素 x（從索引 1 開始）執行以下判斷 // 進入迴圈  \n&nbsp;&nbsp;→ Decision: 如果 count == 0? // 判斷計數是否為零  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: 設定 candidate = x，count = 1 // 重置候選人  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: x == candidate? // 判斷元素是否與候選人相同  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: count++ // 相同則計數加一  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5: count-- // 不同則計數減一  \n→ Step 6: 返回 candidate // 最終 majority element  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def majorityElement(self, nums):\n        \"\"\"\n        Boyer–Moore Voting Algorithm\n        \"\"\"\n        count = 0\n        candidate = None\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        return candidate\n\ndef main():\n    \"\"\"\n    讀取輸入，解析 nums，計算 majority element 並輸出。\n    輸入範例：nums = [3,2,3]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得方括號中的 list 字串\n    match = re.search(r'nums\\s*=\\s*(\\[.*\\])', data, re.S)\n    if not match:\n        # 如果格式不符合，嘗試直接評估整個輸入\n        try:\n            nums = ast.literal_eval(data)\n        except Exception:\n            raise ValueError(\"無法解析輸入，請使用 'nums = [..]' 格式\")\n    else:\n        list_str = match.group(1)\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            raise ValueError(\"list 解析失敗，請確認輸入格式正確\")\n\n    solution = Solution()\n    result = solution.majorityElement(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,1,1,1,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode468.json",
    "problem_index_in_file": 0,
    "title": "Validate IP Address",
    "description_snippet": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 ad...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with line by line steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision structure. Provide algorithm: check for IPv4 first: split by \".\", ensure 4 parts, each part numeric, no leading zeros unless single zero, between 0-255. Else check IPv6: split by \":\", ensure 8 parts, each part length 1-4, valid hex characters. If both fail, return \"Neither\".\n\nWe must output in Traditional Chinese. The virtual code steps, like Start, Step 1, Decision: If contains '.'? etc. Provide arrows.\n\nLet's construct. Each line: \"Start // 程式開始\" then arrow. We'll use \"→\" for continuation. Use \"Decision:\" lines. We'll need indentation for nested arrows: Use spaces. We'll use the example format.\n\nWe will include lines:\n\nStart // 程式開始\n\n→ Step 1: 判斷 queryIP 是否包含 '.' 以便可能為 IPv4 // 判斷 IP 是否以點分隔\n\n→ Decision: 若包含 '.'? // 判斷是否可能是 IPv4\n\n    Yes → Step 2: 以 '.' 分割為 parts // 將字串拆成四段\n\n    Yes → Decision: 若 parts 數目等於 4? // 確保四段\n\n        Yes → Step 3: 對每段進行驗證 // 驗證數值與格式\n\n        Yes → Decision: 所有段均合法? // 檢查整體合法性\n\n            Yes → Step 4: 回傳 'IPv4' // IP 為合法 IPv4\n\n            No  → Step 5: 轉至 IPv6 檢查 // 失敗則檢查 IPv6\n\n    No → Step 5: 轉至 IPv6 檢查 // 不是 IPv4\n\n→ Step 5: 判斷 queryIP 是否包含 ':' 以便可能為 IPv6 // 判斷 IP 是否以冒號分隔\n\n→ Decision: 若包含 ':'? // 判斷是否可能是 IPv6\n\n    Yes → Step 6: 以 ':' 分割為 parts // 拆成八段\n\n    Yes → Decision: 若 parts 數目等於 8? // 確保八段\n\n        Yes → Step 7: 對每段進行驗證 // 驗證長度與 hex\n\n        Yes → Decision: 所有段均合法? // 檢查整體合法性\n\n            Yes → Step 8: 回傳 'IPv6' // IP 為合法 IPv6\n\n            No  → Step 9: 回傳 'Neither' // 失敗\n\n    No → Step 9: 回傳 'Neither' // 不是 IPv6\n\nEnd // 程式結束\n\nWe must include comments after //.\n\nMake sure each line has \"虛擬碼步驟\" like \"Start\", \"→ Step 1: ...\". Use indentation spaces for nested lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 判斷 queryIP 是否包含 '.' 以便可能為 IPv4 // 判斷 IP 是否以點分隔\n→ Decision: 若包含 '.'? // 檢查是否為 IPv4 可能形式\n    Yes → Step 2: 以 '.' 分割為 parts // 把字串拆成四段\n    Yes → Decision: 若 parts 數目等於 4? // 確保恰好四段\n        Yes → Step 3: 對每段進行驗證 // 檢查數值範圍與格式\n        Yes → Decision: 所有段均合法? // 判斷整體是否合法\n            Yes → Step 4: 回傳 'IPv4' // IP 為合法 IPv4\n            No  → Step 5: 轉至 IPv6 檢查 // 失敗則檢查 IPv6\n    No  → Step 5: 轉至 IPv6 檢查 // 不是 IPv4\n→ Step 5: 判斷 queryIP 是否包含 ':' 以便可能為 IPv6 // 判斷 IP 是否以冒號分隔\n→ Decision: 若包含 ':'? // 檢查是否為 IPv6 可能形式\n    Yes → Step 6: 以 ':' 分割為 parts // 把字串拆成八段\n    Yes → Decision: 若 parts 數目等於 8? // 確保恰好八段\n        Yes → Step 7: 對每段進行驗證 // 檢查長度與十六進制字元\n        Yes → Decision: 所有段均合法? // 判斷整體是否合法\n            Yes → Step 8: 回傳 'IPv6' // IP 為合法 IPv6\n            No  → Step 9: 回傳 'Neither' // 失敗\n    No  → Step 9: 回傳 'Neither' // 不是 IPv6\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        # Helper to check IPv4\n        def isIPv4(s: str) -> bool:\n            parts = s.split('.')\n            if len(parts) != 4:\n                return False\n            for part in parts:\n                if not part.isdigit():\n                    return False\n                if not 0 <= int(part) <= 255:\n                    return False\n                if part[0] == '0' and len(part) != 1:\n                    return False\n            return True\n\n        # Helper to check IPv6\n        def isIPv6(s: str) -> bool:\n            parts = s.split(':')\n            if len(parts) != 8:\n                return False\n            hexdigits = set(\"0123456789abcdefABCDEF\")\n            for part in parts:\n                if not 1 <= len(part) <= 4:\n                    return False\n                if any(c not in hexdigits for c in part):\n                    return False\n            return True\n\n        if queryIP.count('.') == 3 and isIPv4(queryIP):\n            return \"IPv4\"\n        elif queryIP.count(':') == 7 and isIPv6(queryIP):\n            return \"IPv6\"\n        else:\n            return \"Neither\"\n\nif __name__ == \"__main__\":\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n    # Try to extract the IP string if input contains quotes\n    match = re.search(r'\\\"([^\"]+)\\\"', raw_input)\n    if match:\n        query_ip = match.group(1)\n    else:\n        query_ip = raw_input\n\n    sol = Solution()\n    result = sol.validIPAddress(query_ip)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "queryIP = \"172.16.254.1\"",
          "expected_output": "IPv4",
          "success": true,
          "output": "IPv4"
        },
        {
          "example_index": 1,
          "input": "queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"",
          "expected_output": "IPv6",
          "success": true,
          "output": "IPv6"
        },
        {
          "example_index": 2,
          "input": "queryIP = \"256.256.256.256\"",
          "expected_output": "Neither",
          "success": true,
          "output": "Neither"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode433.json",
    "problem_index_in_file": 0,
    "title": "Minimum Genetic Mutation",
    "description_snippet": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for BFS minimal mutation steps. Provide step-by-step with decision arrows. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide lines. Should include algorithm: convert bank to set, if endGene not in bank return -1. BFS queue. For each gene, for each position mutate each char, if in bank not visited then enqueue and visited, record steps. When reach endGene return steps. If queue empty return -1. We'll output steps with arrows. Ensure each line has //.\n\nLet's produce.\n\nWe need to represent variables: queue, visited, bankSet, steps.\n\nPseudo code:\n\nStart\n→ Initialize bankSet from bank // convert list to set\n→ Decision: endGene ∈ bankSet? // if not valid mutation\n    No → Return -1 // cannot reach\n    Yes →\n→ Initialize queue with (startGene, 0) // starting gene and steps 0\n→ Initialize visited set with startGene\n→ While queue not empty\n    → Pop gene, steps\n    → Decision: gene == endGene? // reached\n        Yes → Return steps\n        No →\n            → For each position i in 0..7\n                → For each nucleotide in ['A','C','G','T']\n                    → If nucleotide != gene[i]\n                        → mutated = replace char at i\n                        → Decision: mutated in bankSet AND not in visited?\n                            Yes → Add mutated to visited\n                                → Enqueue (mutated, steps+1)\n                            No → Continue\n→ Return -1 // no path found\nEnd\n\nWe need to follow the formatting.\n\nLet's produce each line accordingly.\n\nWe'll use indentation maybe with tabs or spaces? Not required. Just lines with arrow. Provide explanation after //.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize bankSet = Set(bank) // 把 gene bank 轉成集合方便快速查找\n→ Decision: endGene ∈ bankSet? // 檢查終點基因是否為合法基因\n    No  → Return -1 // 若終點不在 bank，無法完成突變\n    Yes →\n→ Initialize queue = [(startGene, 0)] // 佇列中存放 (基因, 已經突變步數)\n→ Initialize visited = {startGene} // 記錄已訪問過的基因，避免重複\n→ While queue is not empty // 從佇列中取出基因進行 BFS\n    → Pop (current, steps) from queue // 取出最先進入佇列的基因及其步數\n    → Decision: current == endGene? // 檢查是否已達到終點\n        Yes → Return steps // 若相等，直接回傳所需最少步數\n        No  →\n            → For i from 0 to 7 // 遍歷基因字串的每個位置\n                → For nucleotide in ['A', 'C', 'G', 'T'] // 可能的四種字母\n                    → If nucleotide != current[i] // 只考慮改變位置的情況\n                        → mutated = current with position i replaced by nucleotide\n                        → Decision: mutated ∈ bankSet AND mutated ∉ visited? // 檢查合法且未訪問\n                            Yes → Add mutated to visited // 標記為已訪問\n                                → Enqueue (mutated, steps + 1) // 將新基因加入佇列，步數+1\n                            No  → Continue // 無效或已訪問，忽略\n→ Return -1 // 佇列空了仍未找到終點，代表無法達成\nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank) -> int:\n        \"\"\"返回從 start 到 end 所需的最少突變步數，若無法達成則回傳 -1。\"\"\"\n        if start == end:\n            return 0\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n\n        queue = deque([(start, 0)])  # (目前基因, 已經突變的步數)\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutated = current[:i] + g + current[i + 1:]\n                    if mutated in bank_set and mutated not in visited:\n                        if mutated == end:\n                            return steps + 1\n                        visited.add(mutated)\n                        queue.append((mutated, steps + 1))\n        return -1\n\ndef main():\n    # 讀取輸入並執行 eval 以獲得 startGene、endGene、bank 變數\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    local_vars = {}\n    exec(data, {}, local_vars)\n\n    start_gene = local_vars.get('startGene')\n    end_gene = local_vars.get('endGene')\n    bank = local_vars.get('bank', [])\n\n    result = Solution().minMutation(start_gene, end_gene, bank)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp29crehz2.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp29crehz2.py\", line 38, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    ^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp99b0ew54.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp99b0ew54.py\", line 38, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\n    ^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode168.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Title",
    "description_snippet": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants pseudocode for converting a column number to Excel column title. We need to output step by step pseudocode with explanation. Use \"虛擬碼步驟\" and comment. Use arrows, decision. So something like:\n\nStart\n→ Step 1: Initialize result string as empty\n→ Step 2: While columnNumber > 0\n    → Step 2a: columnNumber--; // adjust to 0-based\n    → Step 2b: charCode = columnNumber % 26; // remainder\n    → Step 2c: char = 'A' + charCode; // letter\n    → Step 2d: Prepend char to result\n    → Step 2e: columnNumber = columnNumber / 26; // integer division\n→ Step 3: Return result\nEnd\n\nAdd comments after each line. Use \"→\" arrow.\n\nAlso can include a Decision for while condition.\n\nSo we produce output lines accordingly. Use format \"虛擬碼步驟 // 解釋\".\n\nWe need to adhere to format: each line has virtual code step then space then comment.\n\nWe need to use \"Start\", \"End\", \"Decision:\".\n\nLet's produce.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: result ← \"\" // 初始化結果字串為空\n→ Step 2: Decision: 是否 columnNumber > 0? // 判斷是否還有數字要轉換\n    Yes → Step 3: columnNumber ← columnNumber - 1 // 轉換為 0 為基底\n    Yes → Step 4: remainder ← columnNumber mod 26 // 取得餘數對應字母\n    Yes → Step 5: letter ← chr(ord('A') + remainder) // 將餘數轉為字母\n    Yes → Step 6: result ← letter + result // 把字母加到結果前面\n    Yes → Step 7: columnNumber ← columnNumber div 26 // 更新 columnNumber\n    Yes → Decision: 是否 columnNumber > 0? // 重新判斷是否還有位數\n        Yes → Jump back to Step 3 // 迴圈\n        No → // 結束迴圈\n→ Step 8: Return result // 回傳最終字串\nEnd // 程式執行結束\n\nWe might need to use proper arrow for while loop. Could just use \"Decision:\" inside a loop.\n\nAlternatively we can use a loop structure: \"→ While columnNumber > 0:\" but not exactly. But we should stick to structure: Decision: ... Yes→... No→.\n\nLet's produce. Ensure each line separate. Let's provide exactly as required.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← \"\" // 初始化結果字串為空  \n→ Decision: 是否 columnNumber > 0? // 判斷是否還有數字要轉換  \n Yes → Step 2: columnNumber ← columnNumber - 1 // 轉換為 0 為基底，方便計算  \n Yes → Step 3: remainder ← columnNumber mod 26 // 取得餘數對應字母編號  \n Yes → Step 4: letter ← chr(ord('A') + remainder) // 將餘數轉為對應大寫字母  \n Yes → Step 5: result ← letter + result // 把字母加到結果字串前面  \n Yes → Step 6: columnNumber ← columnNumber div 26 // 更新 columnNumber 進行下一輪迴圈  \n Yes → Decision: 是否 columnNumber > 0? // 重新判斷是否還有位數需要處理  \n  Yes → Jump back to Step 2 // 迴圈往前回到第 2 步繼續  \n  No → // 迴圈結束  \n→ Step 7: Return result // 回傳最終轉換完成的列標題  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        \"\"\"Convert a positive integer to its corresponding Excel column title.\"\"\"\n        result = ''\n        while columnNumber > 0:\n            columnNumber -= 1                     # 轉成 0‑基底\n            result = chr(columnNumber % 26 + ord('A')) + result\n            columnNumber //= 26\n        return result\n\ndef main():\n    # 從標準輸入讀取整個內容，並提取第一個整數\n    data = sys.stdin.read()\n    match = re.search(r'(-?\\d+)', data)\n    if not match:\n        return\n    column_number = int(match.group(1))\n\n    # 執行轉換\n    solution = Solution()\n    title = solution.convertToTitle(column_number)\n\n    # 將結果包在雙引號內輸出\n    print(f'\"{title}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnNumber = 1",
          "expected_output": "\"A\"",
          "success": true,
          "output": "\"A\""
        },
        {
          "example_index": 1,
          "input": "columnNumber = 28",
          "expected_output": "\"AB\"",
          "success": true,
          "output": "\"AB\""
        },
        {
          "example_index": 2,
          "input": "columnNumber = 701",
          "expected_output": "\"ZY\"",
          "success": true,
          "output": "\"ZY\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode23.json",
    "problem_index_in_file": 0,
    "title": "Merge k Sorted Lists",
    "description_snippet": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerg...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for merging k sorted linked lists into one sorted list. Should be step-by-step, with Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to output in Traditional Chinese. Must not output actual code. Provide steps in a typical algorithm: using min-heap or divide and conquer.\n\nWe can choose min-heap approach: insert heads into priority queue, repeatedly pop smallest, append to result, push next node from same list.\n\nBut we need to produce step-by-step pseudo-code: maybe high-level steps.\n\nWe need to produce lines: Start, then maybe \"Initialize a min-heap\", etc.\n\nWe'll include decisions: if list is empty, etc.\n\nWe'll use \"→\" arrow for next step, but each line is a step.\n\nWe can include nested decisions.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 建立一個最小堆 (min-heap) // 用於儲存各 linked-list 的目前最小節點\n\n→ Step 2: 對於每個 linked-list i, 若其頭節點不為空，將其節點加入 min-heap // 將所有非空頭節點放進堆\n\n→ Step 3: 建立一個 dummy 節點 dummy，並將指針 current 指向 dummy // 用於組裝結果鏈表\n\n→ Decision: 若 min-heap 為空? // 檢查是否還有節點可處理\n\n    No → Step 4: 從 min-heap 取出最小節點 node // 取出堆頂\n\n    → Step 5: 將 node 附加到 current.next // 將節點加入結果\n\n    → Step 6: 移動 current 到 node // 更新 current 指針\n\n    → Step 7: 若 node.next 不為空，將 node.next 插入 min-heap // 將下一個節點加入堆\n\n    → Jump to Step 3 // 重新檢查堆是否為空\n\n    Yes → Step 8: 返回 dummy.next // 堆空，結束，返回合併後的鏈表\n\nEnd // 程式執行結束\n\nWe must format each line: \"虛擬碼步驟 // 解釋\". Also include arrow in steps? The example uses \"→ Step 1:\" etc. We can keep same style.\n\nNeed to ensure each line is in one line.\n\nWe need \"Start\" and \"End\".\n\nWe need to ensure each line has the arrow? Example: \"Start // 程式開始執行\", \"→ Step 1: ...\".\n\nYes.\n\nLet's produce. Also include \"Decision:\" lines. Also \"Yes →\", \"No →\". The example shows nested indentation with indentation. We'll follow same.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個最小堆 (min-heap) // 用於儲存各 linked-list 的目前最小節點  \n→ Step 2: 對每個 linked-list 若其頭節點不為空，將該節點加入 min-heap // 將所有非空頭節點放進堆  \n→ Step 3: 建立一個 dummy 節點 dummy，並將 current 指向 dummy // 用於組裝結果鏈表  \n→ Decision: 若 min-heap 為空? // 檢查是否還有節點可處理  \n    No → Step 4: 從 min-heap 取出最小節點 node // 取出堆頂  \n    → Step 5: 將 node 附加到 current.next // 將節點加入結果  \n    → Step 6: 移動 current 到 node // 更新 current 指針  \n    → Step 7: 若 node.next 不為空，將 node.next 插入 min-heap // 將下一個節點加入堆  \n    → Jump to Step 3 // 重新檢查堆是否為空  \n    Yes → Step 8: 返回 dummy.next // 堆空，結束，返回合併後的鏈表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nfrom typing import List, Optional\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional['ListNode'] = None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        合併 k 個已排序的鏈表，返回合併後的單一鏈表。\n        使用最小堆（priority queue）在 O(N log k) 時間內完成。\n        \"\"\"\n        if not lists:\n            return None\n\n        # 初始化最小堆\n        min_heap = []\n        for idx, node in enumerate(lists):\n            if node:  # 若鏈表非空\n                heapq.heappush(min_heap, (node.val, idx, node))\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while min_heap:\n            val, idx, node = heapq.heappop(min_heap)\n            current.next = node\n            current = current.next\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, idx, node.next))\n\n        return dummy.next\n\ndef list_to_linked(nums: List[int]) -> Optional[ListNode]:\n    \"\"\"將數字列表轉換為單向鏈表。\"\"\"\n    dummy = ListNode()\n    curr = dummy\n    for num in nums:\n        curr.next = ListNode(num)\n        curr = curr.next\n    return dummy.next\n\ndef linked_to_list(node: Optional[ListNode]) -> List[int]:\n    \"\"\"將單向鏈表轉換回數字列表。\"\"\"\n    res = []\n    while node:\n        res.append(node.val)\n        node = node.next\n    return res\n\ndef parse_input(input_str: str) -> List[List[int]]:\n    \"\"\"\n    從輸入字串解析出列表 of 列表，例如:\n    'lists = [[1,4,5],[1,3,4],[2,6]]' -> [[1,4,5],[1,3,4],[2,6]]\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    # 找到 '=' 符號並取得其後的部分\n    if '=' in input_str:\n        _, part = input_str.split('=', 1)\n    else:\n        part = input_str\n    part = part.strip()\n    # 使用 literal_eval 以避免 eval 的安全風險\n    import ast\n    try:\n        parsed = ast.literal_eval(part)\n    except Exception:\n        parsed = []\n    # 轉換為列表 of 列表（若已經是）\n    if isinstance(parsed, list):\n        return [lst for lst in parsed if isinstance(lst, list)]\n    return []\n\ndef main() -> None:\n    data = sys.stdin.read()\n    raw_lists = parse_input(data)\n\n    # 將每個數字列表轉換為 LinkedList\n    linked_lists = [list_to_linked(nums) for nums in raw_lists]\n\n    sol = Solution()\n    merged_head = sol.mergeKLists(linked_lists)\n    result = linked_to_list(merged_head)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "success": true,
          "output": "[1, 1, 2, 3, 4, 4, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "lists = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "lists = [[]]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode295.json",
    "problem_index_in_file": 0,
    "title": "Find Median from Data Stream",
    "description_snippet": "The median is the middle value in an ordered integer list. If the size of the list is even, there is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. Provide algorithm for MedianFinder using two heaps. Let's design: initialize two heaps: maxHeap (lower half) and minHeap (upper half). addNum: if maxHeap empty or num <= maxHeap.peek, push to maxHeap else push to minHeap. Rebalance: if size difference >1, move top from larger heap to other. findMedian: if sizes equal, return (maxHeap.peek+minHeap.peek)/2.0 else return peek of larger. Provide virtual code.\n\nWe need to use arrow, Start End, Decision, etc. Provide step by step.\n\nLet's produce:\n\nStart // 初始化\n→ Step 1: 建立最大堆 low // 儲存較小的一半\n→ Step 2: 建立最小堆 high // 儲存較大的一半\n\nMethod: addNum(num)\n→ Step 3: Decision: if low empty or num <= low.peek? // 判斷放進哪個堆\n    Yes → Step 4: 插入 low (maxHeap) // 小於等於下界\n    No  → Step 5: 插入 high (minHeap) // 大於下界\n\n→ Step 6: Decision: |low.size - high.size| > 1? // 平衡堆\n    Yes → Decision: low.size > high.size? // 哪個堆太大\n        Yes → Step 7: 移動 low.peek() 到 high // 從大堆移到小堆\n        No  → Step 8: 移動 high.peek() 到 low // 從小堆移到大堆\n    No  → No operation\n\nMethod: findMedian()\n→ Step 9: Decision: low.size == high.size? // 是否相等\n    Yes → Step 10: 取 low.peek() + high.peek() / 2.0 // 平均\n    No  → Decision: low.size > high.size? // 低堆較大\n        Yes → Step 11: 取 low.peek() // 回傳低堆頂\n        No  → Step 12: 取 high.peek() // 回傳高堆頂\n\nEnd\n\nBut we need to put \"虛擬碼步驟\" with explanation.\n\nWe should use arrow \"→\" before steps. \"Decision:\" lines. For operations like \"Insert\" we use \"Insert num into low\". Provide explanation. Must follow format: each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立最大堆 low // 儲存較小的一半元素\n→ Step 2: 建立最小堆 high // 儲存較大的一半元素\n\n// addNum(num) 方法\n→ Step 3: Decision: 若 low 為空 或 num ≤ low.peek()？ // 判斷 num 應加入哪個堆\n    Yes → Step 4: Insert num into low // 把小於等於下界的數放入最大堆\n    No  → Step 5: Insert num into high // 把大於下界的數放入最小堆\n\n→ Step 6: Decision: |low.size - high.size| > 1？ // 檢查兩堆大小是否失衡\n    Yes → Decision: low.size > high.size？ // 判斷哪一堆太大\n        Yes → Step 7: Move low.peek() to high // 從最大堆移至最小堆\n        No  → Step 8: Move high.peek() to low // 從最小堆移至最大堆\n    No  → No  // 堆已平衡，無需操作\n\n// findMedian() 方法\n→ Step 9: Decision: low.size == high.size？ // 判斷兩堆大小是否相等\n    Yes → Step 10: Return (low.peek() + high.peek()) / 2.0 // 平均兩個中位數\n    No  → Decision: low.size > high.size？ // 判斷哪一堆多個元素\n        Yes → Step 11: Return low.peek() // 最大堆頂即為中位數\n        No  → Step 12: Return high.peek() // 最小堆頂即為中位數\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport ast\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        # max heap (store negatives)\n        self.small = []\n        # min heap\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # push into small (max heap)\n        heapq.heappush(self.small, -num)\n        # balance between heaps if necessary\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # The input is two lists separated by a comma.\n    # Wrap them into a tuple for literal_eval.\n    ops, args = ast.literal_eval(f\"({data})\")\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            result.append(median)\n        else:\n            result.append(None)\n    # Use json.dumps to get 'null' for None and correct formatting\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode352.json",
    "problem_index_in_file": 0,
    "title": "Data Stream as Disjoint Intervals",
    "description_snippet": "Given a data stream input of non-negative integers a_1, a_2, ..., a_n, summarize the numbers seen so...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps describing how SummaryRanges works. This is a classic LeetCode 352: Data Stream as Disjoint Intervals. We need to give virtual code, not actual code, but conceptual steps. We need to output line by line: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce the algorithm: maintain a sorted list of intervals. On addNum, find position to insert or merge.\n\nSimplify: use a balanced BST or sorted list. For virtual code, we can describe steps: maintain list intervals; on add, binary search to find insertion index; if value adjacent to left or right intervals, merge accordingly; else insert new interval.\n\ngetIntervals returns list.\n\nAlso include class initialization.\n\nWe'll produce virtual code: Start, SummaryRanges() etc.\n\nWe need to use arrows: → for steps, Decision: for branches, Yes →, No →.\n\nWe need to include all operations.\n\nLet's produce step-by-step:\n\nStart\n→ SummaryRanges() // initialize empty list of intervals\n→ addNum(value)\n    → Find leftmost interval with start > value using binary search (idx)\n    → Decision: if idx > 0 and intervals[idx-1].end + 1 >= value? // check left\n        Yes → leftMerge = true\n        No  → leftMerge = false\n    → Decision: if idx < len(intervals) and intervals[idx].start - 1 <= value? // check right\n        Yes → rightMerge = true\n        No  → rightMerge = false\n    → Decision: if leftMerge and rightMerge? // merge both\n        Yes → Merge intervals[idx-1] and intervals[idx] with value, set new end\n        No → Decision: if leftMerge? // merge with left\n            Yes → Extend intervals[idx-1].end to max(end, value)\n            No  → Decision: if rightMerge? // merge with right\n                Yes → Extend intervals[idx].start to min(start, value)\n                No  → // no merge, insert new interval\n                    Insert [value, value] at position idx\n→ getIntervals()\n    → Return copy of intervals\n\nWe need to use arrow formatting and comments.\n\nLet's write step by step.\n\nRemember to include End.\n\nWe also need to mention binary search.\n\nAdd appropriate indentation for decisions.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ SummaryRanges() // 初始化空的區間列表\n    → intervals ← [] // 用空列表存放已合併的 [start, end] 區間\n→ addNum(value) // 將新數字加入資料流\n    → idx ← binarySearchFirstStartGreaterThan(value, intervals) // 找出第一個 start 大於 value 的區間位置\n    → Decision: 是否與左側區間相鄰? // 判斷 value 是否能與左側區間合併\n        Yes → leftMerge ← true\n        No  → leftMerge ← false\n    → Decision: 是否與右側區間相鄰? // 判斷 value 是否能與右側區間合併\n        Yes → rightMerge ← true\n        No  → rightMerge ← false\n    → Decision: 左右兩側都可合併? // 同時與兩側區間相鄰，需要將三個區間合併\n        Yes →\n            → leftIdx ← idx - 1\n            → rightIdx ← idx\n            → newStart ← intervals[leftIdx].start\n            → newEnd ← intervals[rightIdx].end\n            → Remove intervals[rightIdx] // 刪除右側區間\n            → Remove intervals[leftIdx] // 刪除左側區間\n            → Insert [newStart, newEnd] at position leftIdx // 插入合併後的區間\n        No →\n            → Decision: 僅左側可合併?\n                Yes →\n                    → intervals[leftIdx].end ← max(intervals[leftIdx].end, value) // 延伸左側區間\n                No  →\n                    → Decision: 僅右側可合併?\n                        Yes →\n                            → intervals[rightIdx].start ← min(intervals[rightIdx].start, value) // 前縮右側區間\n                        No  →\n                            → Insert [value, value] at position idx // 新增獨立區間\n→ getIntervals() // 回傳目前所有區間\n    → Return copy of intervals // 以 [start, end] 的形式返回\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport json\n\nclass SummaryRanges:\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, val):\n        new_interval = [val, val]\n        res = []\n        placed = False\n        for start, end in self.intervals:\n            if end + 1 < val:\n                res.append([start, end])\n            elif val + 1 < start:\n                if not placed:\n                    res.append(new_interval)\n                    placed = True\n                res.append([start, end])\n            else:\n                # 合併區間\n                new_interval[0] = min(start, new_interval[0])\n                new_interval[1] = max(end, new_interval[1])\n        if not placed:\n            res.append(new_interval)\n        self.intervals = res\n\n    def getIntervals(self):\n        return self.intervals\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])   # e.g. [\"SummaryRanges\",\"addNum\",...]\n    args = json.loads(data[1])       # e.g. [[],[1],[],...]\n    obj = None\n    outputs = []\n    for cmd, arg in zip(commands, args):\n        if cmd == \"SummaryRanges\":\n            obj = SummaryRanges()\n            outputs.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            outputs.append(None)\n        elif cmd == \"getIntervals\":\n            outputs.append(obj.getIntervals())\n    # 輸出時使用 json.dumps，None 會被轉成 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "success": true,
          "output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode717.json",
    "problem_index_in_file": 0,
    "title": "1-bit and 2-bit Characters",
    "description_snippet": "We have two special characters:\\n- The first character can be represented by one bit 0.\\n- The secon...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrow syntax and explanation comments. The task: given binary array bits that ends with 0, return true if the last character must be a one-bit character. We need to produce a flowchart-like pseudo-code.\n\nWe need to generate steps: start, iterate through bits until before last index? We need to consider the rule: 0 is one-bit, 10 or 11 is two-bit. We need to determine if last 0 is one-bit char, meaning that all previous bits cannot form a 2-bit char that consumes the last 0.\n\nStandard solution: iterate i from 0 to len-2; if bits[i]==0 then i+=1; else i+=2. After loop, if i==len-1 return true else false.\n\nSo produce virtual code steps:\n\nStart\n→ Step 1: Set i=0 // 初始化指標\n→ Decision: i < len(bits)-1? // 只要還有足夠位可判斷\n    Yes → Decision: bits[i] == 0? // 檢查當前位\n        Yes → Step 2: i = i + 1 // 0 為一位字元，向右移一位\n        No  → Step 3: i = i + 2 // 10/11 為兩位字元，向右移兩位\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd\n\nBut we might need to include Step 4 and Step 5 outside of decisions. Actually after loop ends, we check i==len-1.\n\nAlternatively we can write:\n\nStart\n→ Step 1: Set i = 0\n→ While i < len(bits) - 1:\n    → Decision: bits[i] == 0 ?\n        Yes → i += 1\n        No  → i += 2\n→ Decision: i == len(bits) - 1 ?\n    Yes → Step 2: return true\n    No  → Step 3: return false\nEnd\n\nBut we need to include arrow syntax, \"→\" for steps and decisions, \"Decision:\" for conditions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標到陣列起點\n→ Decision: i < len(bits)-1? // 判斷是否還有足夠位數可處理\n    Yes → Decision: bits[i] == 0? // 判斷目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10 或 11 為兩位字元，指標右移兩位\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 最後一位必為一位字元\n        No  → Step 5: return false // 最後一位不是一位字元\nEnd // 程式結束\n\nBut we need to maintain the flow: the while loop continues until i >= len-1. The outer decision should loop. The pseudo-code structure: Start, Step1, Decision to check loop, inside loop we handle bits, after loop we decide return.\n\nSimplify: Use a while loop concept: \"Decision: i < len(bits)-1?\" with Yes -> Inside, No -> After loop.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 只要還有至少兩位可判斷\n    Yes → Decision: bits[i] == 0? // 檢查目前位\n        Yes → Step 2: i ← i + 1 // 0 是一位字元\n        No  → Step 3: i ← i + 2 // 10/11 是兩位字元\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續循環\n            Yes → (loop back to the previous Decision)\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut we need to avoid recursion loops in pseudo-code. We could indicate \"← Loop\" but simpler is to write \"While i < len(bits)-1:\" etc.\n\nBut we have to adhere to arrow format: \"→ Step\" and \"Decision:\".\n\nLet's design as:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 是否還有足夠位數可判斷\n    Yes → Decision: bits[i] == 0? // 判斷當前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10 或 11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續\n            Yes → (回到第一個 Decision) // 迴圈回到頂部\n            No  → // 迴圈結束\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut we need to express loops properly. Maybe simpler: use \"While\" concept:\n\nStart\n→ Step 1: i ← 0\n→ Decision: i < len(bits)-1? // 只要還有至少兩位可判斷\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1\n        No  → Step 3: i ← i + 2\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到上方 Decision) // 迴圈\n            No  → // 退出\n    No  → Decision: i == len(bits)-1? // 判斷最後一位\n        Yes → Step 4: return true\n        No  → Step 5: return false\nEnd\n\nBut arrow syntax \"←\" may be allowed? The requirement: Use arrows `→`, `Yes →`, `No →` and structure `Start`, `End`, `Decision:`. We can use `→ Step 1: i ← 0` but arrow is `→` to indicate step. That's okay.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10 或 11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續循環\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut the instruction: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\" and \"使用虛擬碼的箭頭 (→, Yes →, No →)\". So we need to use `Yes →` and `No →` after Decision? In example, they used `Yes → Step 2: ...` and `No  → Decision: ...` The \"Yes →\" and \"No →\" are placed after the line that is a decision. Actually in example:\n\nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nSo for each Decision, we indent two spaces? They use indentation for nested decisions. So we need to replicate.\n\nThus for our code: Each Decision line ends with `?`. Then we indent `Yes →` or `No →` lines under it.\n\nLet's produce final answer accordingly.\n\nBe careful: Each line after indent may contain \"Yes →\" or \"No  →\". Use two spaces before Yes or No? In example, they used two spaces before Yes and No. Use same. Also keep arrow symbol after Yes or No: `Yes →`.\n\nWe should output each line exactly. Ensure no trailing spaces after code.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標為陣列起點\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10 或 11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut the line \"→ Decision: i < len(bits)-1? // 重新判斷是否繼續\" maybe we need to indent under Step 2 and Step 3? In example, after Step 2, they didn't indent further. For our flow, we can simply treat the loop as separate: After Step 2 or Step 3, go back to outer Decision. Instead of nested Decision again, we can have a loop. But we need to stay within the arrow structure.\n\nSimplify: Represent loop by \"→ Decision: i < len(bits)-1?\" inside Yes branch, and the steps inside. After steps, we loop back automatically. But need to show \"Yes →\" back to the same decision. But we can avoid nested decisions by using \"Yes →\" line referencing the Decision again. But we cannot produce arrow referencing previous step. But we can simulate: After Step 2 and Step 3, we need to go back to the outer Decision. So we could just use \"Yes →\" on the outer Decision line again? Actually we can produce like:\n\nYes → (回到上一 Decision) // 迴圈\n\nBut maybe better: \"Yes → Decision: i < len(bits)-1?\" again. But the example used \"Yes → Step 2: 輸出 '正數'\". So we need to produce a step after Yes. So maybe \"Yes → Step 1: i ← i + 1\" etc. But we can't have infinite recursion. For clarity, we can structure loop as:\n\nStart\n→ Step 1: i ← 0\n→ Decision: i < len(bits)-1?\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1\n        No  → Step 3: i ← i + 2\n        → Decision: i < len(bits)-1? // loop check\n            Yes → (回到上方 Decision) // 迴圈\n            No  → // 退出\n    No  → Decision: i == len(bits)-1?\n        Yes → Step 4: return true\n        No  → Step 5: return false\nEnd\n\nBut the \"回到上方 Decision\" might be okay as a comment. However, the specification might expect only steps and decisions, not \"回到\" comments. But we can keep.\n\nMaybe we can structure as:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut the arrow after the nested Decision maybe wrong. Actually after Step 2 or Step 3, we should immediately check again. So we can treat the outer Decision as a loop. We can represent like:\n\nStart\n→ Step 1: i ← 0\n→ Decision: i < len(bits)-1?\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1\n        No  → Step 3: i ← i + 2\n        → Decision: i < len(bits)-1? // loop check\n            Yes → (回到上方 Decision) // 迴圈\n            No  → // 退出\n    No  → Decision: i == len(bits)-1?\n        Yes → Step 4: return true\n        No  → Step 5: return false\nEnd\n\nBut the structure is a bit weird. We can simplify to avoid nested decisions:\n\nWe can implement loop explicitly: Use \"While\" concept but keep arrow format:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 只要還有至少兩位可判斷\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1 // 0 為一位字元\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到第一個 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut we should keep consistent formatting: indentation of Yes/No lines under Decision. Use two spaces before Yes or No.\n\nBetter: Represent the loop as:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 只要還有至少兩位可判斷\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1 // 0 為一位字元\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut \"→ (回到上一 Decision)\" may be considered as a step? Might not be necessary. We can just omit the loop and rely on the outer decision as loop. Actually we can use the outer Decision to loop. Represent:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nMaybe we should restructure to avoid nested Decision inside Decision. Instead, we can treat the loop as:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 只要還有至少兩位可判斷\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1 // 0 為一位字元\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut this may not meet strict format. Let's try simpler: Use while loop concept but expressed:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續\n            Yes → (回到上方 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nI think this is okay.\n\nBut the requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So we must keep comment after //.\n\nThus each line ends with comment. For lines with \"→ (回到上一 Decision)\", we need comment too.\n\nBut we need to keep arrow symbol: \"→\" at the start of each step line. For decisions, we use \"Decision:\".\n\nLet's craft final output.\n\nOne possible final answer:\n\n```\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈回到判斷條件\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n```\n\nBut \"→ (回到上一 Decision)\" is not a step; we can just keep \"→ Decision: i < len(bits)-1? // 迴圈回到判斷\" again? Actually we can just have \"→ Decision: i < len(bits)-1? // 迴圈回到判斷\" but that duplicates. But it's fine.\n\nAlternatively, we can use a simpler representation:\n\nStart\n→ Step 1: i ← 0\n→ Decision: i < len(bits)-1?\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1\n        No  → Step 3: i ← i + 2\n        → Decision: i < len(bits)-1? // 迴圈\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出\n    No  → Decision: i == len(bits)-1?\n        Yes → Step 4: return true\n        No  → Step 5: return false\nEnd\n\nBut we must keep comments after each line.\n\nOk, I'll produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標為陣列起點\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10 或 11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈回到判斷條件\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n```",
      "generated_code": "import sys\n\nclass Solution:\n    def isOneBitCharacter(self, bits):\n        i = 0\n        n = len(bits)\n        while i < n - 1:\n            if bits[i] == 1:\n                i += 2\n            else:\n                i += 1\n        return i == n - 1\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 允許輸入格式為 \"bits = [1,0,0]\" 或僅為 \"[1,0,0]\"\n    if \"bits\" in data:\n        # 將 \"bits =\" 轉換為簡單的賦值形式\n        data = data.replace(\"bits =\", \"bits\")\n    try:\n        local_vars = {}\n        exec(data, {}, local_vars)\n        bits = local_vars.get(\"bits\", [])\n    except Exception:\n        # 若解析失敗，則視為空陣列\n        bits = []\n\n    solution = Solution()\n    result = solution.isOneBitCharacter(bits)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "bits = [1,0,0]",
          "expected_output": "true",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 1,
          "input": "bits = [1,1,1,0]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode47.json",
    "problem_index_in_file": 0,
    "title": "Permutations II",
    "description_snippet": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for generating all unique permutations of a list that may contain duplicates. Must output line by line pseudocode with explanation after //.\n\nWe need to use virtual code arrow and structure Start, Decision, etc.\n\nWe should design algorithm: backtracking with used array, sort nums to handle duplicates; at each step iterate over indices, skip if used or if duplicate and previous not used.\n\nPseudo:\n\nStart\n→ Sort nums\n→ Declare result list\n→ Declare backtrack function (path, used)\n→   If path length == nums length → add copy to result\n→   For i from 0 to len(nums)-1\n→     If used[i] → continue\n→     If i>0 and nums[i]==nums[i-1] and not used[i-1] → continue\n→     Mark used[i]=true\n→     Append nums[i] to path\n→     Call backtrack\n→     Remove last from path\n→     Mark used[i]=false\n→ Call backtrack([], [False]*len(nums))\n→ Return result\nEnd\n\nWe need each line with explanation. Use arrow \"→\" before each step. Use Decision: etc. But decisions may be included.\n\nWe need to produce virtual code lines. Let's create lines:\n\nStart // 程式開始執行\n→ Sort(nums) // 將數組排序，方便後續去重\n→ Declare result = [] // 用於儲存所有唯一排列\n→ Declare used = [False] * len(nums) // 標記每個元素是否已被使用\n→ Function backtrack(path) // 以 path 為當前排列進行遞歸\n    → Decision: if len(path) == len(nums)? // 判斷是否已完成一個排列\n        Yes → Append copy of path to result // 完成排列，加入結果\n        No  → For i in range(len(nums)) // 仍未完成，嘗試選擇下一個元素\n            → Decision: if used[i]? // 該元素已被使用\n                Yes → Continue // 跳過\n                No  → Decision: if i>0 and nums[i]==nums[i-1] and not used[i-1]? // 重複元素且前一個未使用\n                    Yes → Continue // 跳過以避免重複排列\n                    No  → used[i] = True // 標記使用\n                        → Append nums[i] to path // 加入當前元素\n                        → backtrack(path) // 進一步遞歸\n                        → Remove last element from path // 回溯\n                        → used[i] = False // 取消標記\n→ Call backtrack([]) // 開始遞歸，初始 path 為空\n→ Return result // 返回所有唯一排列\nEnd // 程式執行結束\n\nBut we need to use arrow lines \"→\" for each line, including nested lines maybe indent with spaces? We can keep indentation but must preserve format: each line start with arrow or \"→\" or \"Decision:\" lines. We need to include decision branches.\n\nWe should output exactly one line per step. We might need to include indentation for nested blocks but still each line start with arrow or \"Decision:\" etc.\n\nLet's structure with indentation to show nesting but each line begins with arrow or \"Decision:\".\n\nExample:\n\nStart // 程式開始執行\n→ Sort(nums) // 將數組排序，方便後續去重\n→ Declare result = [] // 用於儲存所有唯一排列\n→ Declare used = [False] * len(nums) // 標記每個元素是否已被使用\n→ Function backtrack(path) // 以 path 為當前排列進行遞歸\n    → Decision: if len(path) == len(nums)? // 判斷是否已完成一個排列\n        Yes → Append copy of path to result // 完成排列，加入結果\n        No  → For i in range(len(nums)) // 仍未完成，嘗試選擇下一個元素\n            → Decision: if used[i]? // 該元素已被使用\n                Yes → Continue // 跳過\n                No  → Decision: if i>0 and nums[i]==nums[i-1] and not used[i-1]? // 重複元素且前一個未使用\n                    Yes → Continue // 跳過以避免重複排列\n                    No  → used[i] = True // 標記使用\n                        → Append nums[i] to path // 加入當前元素\n                        → backtrack(path) // 進一步遞歸\n                        → Remove last element from path // 回溯\n                        → used[i] = False // 取消標記\n→ Call backtrack([]) // 開始遞歸，初始 path 為空\n→ Return result // 返回所有唯一排列\nEnd // 程式執行結束\n\nWe need to ensure every line includes a single comment after \"//\".\n\nYes.\n\nLet's output that.\n...done thinking.\n\nStart // 程式開始執行  \n→ Sort(nums) // 將數組排序，方便後續去重  \n→ Declare result = [] // 用於儲存所有唯一排列  \n→ Declare used = [False] * len(nums) // 標記每個元素是否已被使用  \n→ Function backtrack(path) // 以 path 為當前排列進行遞歸  \n  → Decision: if len(path) == len(nums)? // 判斷是否已完成一個排列  \n    Yes → Append copy of path to result // 完成排列，加入結果  \n    No → For i in range(len(nums)) // 仍未完成，嘗試選擇下一個元素  \n      → Decision: if used[i]? // 該元素已被使用  \n        Yes → Continue // 跳過  \n        No → Decision: if i>0 and nums[i]==nums[i-1] and not used[i-1]? // 重複元素且前一個未使用  \n         Yes → Continue // 跳過以避免重複排列  \n         No → used[i] = True // 標記使用  \n           → Append nums[i] to path // 加入當前元素  \n           → backtrack(path) // 進一步遞歸  \n           → Remove last element from path // 回溯  \n           → used[i] = False // 取消標記  \n→ Call backtrack([]) // 開始遞歸，初始 path 為空  \n→ Return result // 返回所有唯一排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n        nums.sort()  # 先排序方便去重\n        used = [False] * len(nums)\n\n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            for i in range(len(nums)):\n                if used[i]:\n                    continue\n                if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                    continue  # 避免重複排列\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n\n        backtrack([])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 從輸入中提取第一個方括號中的內容並解析為列表\n    m = re.search(r'\\[.*\\]', data, re.DOTALL)\n    if m:\n        nums_str = m.group(0)\n        try:\n            nums = eval(nums_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    result = Solution().permuteUnique(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "[[1,1,2],[1,2,1],[2,1,1]]",
          "success": true,
          "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": true,
          "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode719.json",
    "problem_index_in_file": 0,
    "title": "Find K-th Smallest Pair Distance",
    "description_snippet": "The distance of a pair of integers a and b is defined as the absolute difference between a and b.\\nG...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: find kth smallest pair distance in array. Classic problem: use binary search on distance with counting pairs <= mid. Or sort array and two pointers.\n\nWe produce step-by-step pseudocode. Must output each line with // explanation. Use Start, End, Decision, arrows.\n\nWe should present algorithm: sort array, binary search on distance low=0, high=nums[-1]-nums[0]. While low<high, mid=(low+high)//2, count pairs <= mid using two pointers. If count>=k, high=mid else low=mid+1. Return low.\n\nProvide steps line by line. We'll include sorting step, setting bounds, loop, counting logic.\n\nRemember to include arrows: \"→ Step X:\" etc. Use indentation for nested decisions. Let's produce:\n\nStart\n→ Step 1: Sort nums ascending\n→ Step 2: low ← 0\n→ Step 3: high ← nums[last] - nums[first]\n→ Decision: low < high? // While loop condition\n    Yes → Step 4: mid ← (low + high) / 2 // integer division\n    → Step 5: count ← 0 // initialize pair count\n    → Step 6: left ← 0 // start pointer\n    → Decision: left < n? // loop to count pairs\n        Yes → Step 7: While nums[right] - nums[left] > mid, right++? Actually we need right pointer. We'll use two-pointer approach: For each left, find furthest right where diff <= mid. Use right pointer that moves forward. Implementation: right = left+1 initially. Use inner loop. But pseudocode: \nWe can do: right ← left + 1\n        → Decision: right < n and nums[right] - nums[left] <= mid? \nBut typical algorithm: For left from 0 to n-1: while right < n and nums[right] - nums[left] <= mid: right++ ; count += right - left - 1\n\nWe'll express that.\n\nWe'll need to maintain right pointer across left increments. We'll show logic.\n\nLet's write:\n\n→ Step 8: right ← 1\n→ Decision: left < n? \n    Yes → Step 9: While right < n and nums[right] - nums[left] <= mid: right ← right + 1\n    → Step 10: count ← count + (right - left - 1)\n    → Step 11: left ← left + 1\n    No → Step 12: // finish counting\n\nAfter counting:\n\n→ Decision: count >= k? // adjust binary search\n    Yes → Step 13: high ← mid\n    No  → Step 14: low ← mid + 1\n\nThen loop.\n\nAfter loop finishes:\n\n→ Step 15: Return low\n\nEnd\n\nMake sure each line has explanation comment.\n\nLet's format carefully.\n\nAlso need to mention array length n.\n\nWe'll include step: n ← length(nums)\n\nOk. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先將陣列排序，方便雙指標計數  \n→ Step 2: n ← length(nums) // 取得陣列長度  \n→ Step 3: low ← 0 // 最小距離為 0  \n→ Step 4: high ← nums[n-1] - nums[0] // 最大距離為首尾差  \n→ Decision: low < high? // 進入二分搜尋迴圈  \n Yes → Step 5: mid ← (low + high) / 2 // 取中間距離（整數除法）  \n → Step 6: count ← 0 // 初始化可達距離小於等於 mid 的對數  \n → Step 7: right ← 1 // 初始化右指標（至少跟左指標相差 1）  \n → Step 8: left ← 0 // 左指標起始位置  \n  Decision: left < n? // 循環遍歷所有左指標  \n   Yes → Step 9: While right < n and nums[right] - nums[left] ≤ mid: right ← right + 1 // 向右擴展直到距離超過 mid  \n   → Step 10: count ← count + (right - left - 1) // 右指標左移前，所有 (right-1) - left 個元素與 left 形成距離 ≤ mid 的對  \n   → Step 11: left ← left + 1 // 移動左指標到下一個位置  \n   No → Step 12: // 左指標已遍歷完，結束計數  \n → Decision: count ≥ k? // 依據對數決定二分搜尋方向  \n  Yes → Step 13: high ← mid // 仍有足夠對，嘗試更小的距離  \n  No  → Step 14: low ← mid + 1 // 對數不足，距離太小，往右調整  \n → Decision: low < high? // 再次判斷是否需繼續二分搜尋  \n  Yes → 跳回 Step 5  \n  No  → Step 15: Return low // 找到第 k 小距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def smallestDistancePair(self, nums, k):\n        # 先排序，方便計數\n        nums.sort()\n        n = len(nums)\n\n        # 計算距離 <= mid 的對數\n        def count_pairs(mid: int) -> int:\n            count = 0\n            left = 0\n            for right in range(n):\n                # 移動左指標，保持距離不超過 mid\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            return count\n\n        # 二分搜尋最小距離\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            if count_pairs(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 透過正則表達式找出 nums 與 k\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    # 如果輸入格式不正確，直接終止\n    if not nums_match or not k_match:\n        sys.exit(0)\n\n    # 解析列表與整數\n    nums_str = nums_match.group(1)\n    k_str = k_match.group(1)\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.smallestDistancePair(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,1], k = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1], k = 2",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1,6,1], k = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode452.json",
    "problem_index_in_file": 0,
    "title": "Minimum Number of Arrows to Burst Balloons",
    "description_snippet": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce algorithm for min arrows to burst all intervals. Classic greedy: sort by end ascending, pick first arrow at end of first interval, count++, then iterate intervals: if interval start > current arrow position, need new arrow at its end. Provide virtual code lines with explanation. Use Start, End, Decision. Ensure step-by-step. Provide lines with virtual code arrow characters.\n\nLet's craft. Use arrow for control. Use indentation maybe. Provide each line. Use 10-20 lines. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得點陣列 points // 從輸入取得所有氣球區間  \n→ Decision: 如果 points 為空? // 檢查是否有氣球  \n  Yes → Step 2: 回傳 0 // 沒有氣球時箭數為 0  \n  No → Step 3: 設定 arrows = 0 // 初始化箭數計數  \n  No → Step 4: 設定 currentArrowPos = 無效值 // 目前箭射擊位置  \n→ Step 5: 排序 points 按照 x_end 升序 // 先按右邊界排序  \n→ Step 6: 循環遍歷每個 interval in points // 逐一檢查每個氣球  \n  Decision: 如果 interval.x_start <= currentArrowPos? // 已有箭能打通過  \n   Yes → 無操作 // 這個氣球已被現有箭擊中，繼續下一個  \n   No  → Step 7: arrows += 1 // 新箭需要射擊  \n   No  → Step 8: currentArrowPos = interval.x_end // 射擊點設在該氣球的右邊界  \n→ End // 迴圈結束，所有氣球已被考慮  \n→ Step 9: 回傳 arrows // 返回最小箭數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinArrowShots(self, points):\n        \"\"\"Return the minimum number of arrows required to burst all balloons.\"\"\"\n        if not points:          # 無氣球時不需要箭\n            return 0\n\n        # 先依右端點排序，這樣可以一次掃描決定箭數\n        points.sort(key=lambda x: x[1])\n        arrows = 1\n        current_end = points[0][1]\n\n        for start, end in points[1:]:\n            if start > current_end:   # 當前箭無法再打通此氣球\n                arrows += 1\n                current_end = end     # 新箭射向此氣球的右端點\n\n        return arrows\n\n\ndef parse_points(input_str: str):\n    \"\"\"\n    從像 'points = [[10,16],[2,8],[1,6],[7,12]]' 的字串中提取陣列。\n    使用 ast.literal_eval 以安全方式解析。\n    \"\"\"\n    input_str = input_str.strip()\n    if '=' in input_str:\n        _, rhs = input_str.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = input_str\n    return ast.literal_eval(rhs)\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    points = parse_points(raw_input)\n    solution = Solution()\n    result = solution.findMinArrowShots(points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode123.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock III",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\n\nFind t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, line by line, with arrow notation. The algorithm: max 2 transactions. Classic DP: track states: first buy, first sell, second buy, second sell. Or use max profit with two transactions using DP arrays. Simpler: iterate through days, maintain best profit if you have made 0,1,2 transactions, with states for buy/sell. Implementation: Use 4 variables: firstBuy, firstSell, secondBuy, secondSell. Initialize firstBuy = -∞ (meaning cost), firstSell=0, secondBuy=-∞, secondSell=0. For each price p: firstBuy = max(firstBuy, -p) (buy first), firstSell = max(firstSell, firstBuy + p) (sell first), secondBuy = max(secondBuy, firstSell - p) (buy second), secondSell = max(secondSell, secondBuy + p). At end, answer secondSell. So virtual steps.\n\nWe must output line by line. Use Start and End. Use arrow lines. Include decision? maybe not needed. We'll include variable initialization, loop, updates, final output. Each line has explanation after //. Use `→` arrows.\n\nLet's produce.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: 初始化 firstBuy, firstSell, secondBuy, secondSell // 設定交易狀態變數\n    firstBuy = -∞ // 第一次買入時機的最大負成本\n    firstSell = 0 // 第一次賣出時的最大利潤\n    secondBuy = -∞ // 第二次買入時機的最大負成本\n    secondSell = 0 // 第二次賣出時的最大利潤\n→ Step 2: 迭代遍歷 prices // 逐日處理股價\n    for each price in prices:\n        firstBuy = max(firstBuy, -price) // 可能在此日買入第一次\n        firstSell = max(firstSell, firstBuy + price) // 可能在此日賣出第一次\n        secondBuy = max(secondBuy, firstSell - price) // 可能在此日買入第二次\n        secondSell = max(secondSell, secondBuy + price) // 可能在此日賣出第二次\n→ Step 3: 輸出 secondSell // 最大利潤即為第二次賣出後的利潤\n    return secondSell\nEnd // 程式執行結束\n\nBut we need arrow per line. For each line: \"→ Step 1: ...\" maybe nested? We should indent. The example shows indent for nested steps. We'll follow that.\n\nUse arrow for Start and End? They used \"Start // 程式開始執行\" no arrow. They use \"→ Step\". So use that.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化交易狀態變數  \n  firstBuy = -∞ // 第一次買入的最大負成本（最小支出）  \n  firstSell = 0 // 第一次賣出的最大利潤（未交易時為 0）  \n  secondBuy = -∞ // 第二次買入的最大負成本  \n  secondSell = 0 // 第二次賣出的最大利潤（未完成任何交易時為 0）  \n→ Step 2: 逐日遍歷股價陣列 prices  \n  for each price in prices:  \n    firstBuy = max(firstBuy, -price) // 可能在此日買入第一次  \n    firstSell = max(firstSell, firstBuy + price) // 可能在此日賣出第一次  \n    secondBuy = max(secondBuy, firstSell - price) // 可能在此日買入第二次  \n    secondSell = max(secondSell, secondBuy + price) // 可能在此日賣出第二次  \n→ Step 3: 輸出最終最大利潤  \n  return secondSell // 兩筆交易完成後的最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_profit(prices):\n    \"\"\"Return the maximum profit with at most two transactions.\"\"\"\n    if not prices:\n        return 0\n    buy1 = float('-inf')\n    sell1 = 0\n    buy2 = float('-inf')\n    sell2 = 0\n    for price in prices:\n        buy1 = max(buy1, -price)\n        sell1 = max(sell1, buy1 + price)\n        buy2 = max(buy2, sell1 - price)\n        sell2 = max(sell2, buy2 + price)\n    return sell2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 尋找最外層的中括號，取出裡面的列表字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1:\n        list_str = data[start:end+1]\n        try:\n            prices = ast.literal_eval(list_str)\n        except Exception:\n            prices = []\n    else:\n        prices = []\n\n    result = max_profit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode57.json",
    "problem_index_in_file": 0,
    "title": "Insert Interval",
    "description_snippet": "You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for insertion of interval into sorted non-overlapping list. Provide line-by-line steps with explanations. Must use arrow syntax and decisions. Must not output actual code. Only virtual code. Provide each line with explanation. Let's think algorithm: input intervals list, newInterval. We'll create result list. Iterate over intervals. For each interval, if interval.end < newInterval.start: push interval to result. Else if interval.start > newInterval.end: push newInterval if not yet added, then push rest intervals. Else overlapping: merge newInterval.start = min(interval.start, newInterval.start), newInterval.end = max(interval.end, newInterval.end). Continue. After loop, if newInterval not added, push it. Output result.\n\nWe produce steps accordingly.\n\nUse structure: Start, → Step: declare result list, newAdded flag false. → For each interval in intervals: Decision: if interval.end < newInterval.start? Yes → add interval to result. No → Decision: if interval.start > newInterval.end? Yes → if not newAdded: add newInterval, set newAdded true; add interval. No → overlapping: merge newInterval: newInterval.start = min(newInterval.start, interval.start); newInterval.end = max(newInterval.end, interval.end). Continue loop. After loop: Decision: if not newAdded? Yes → add newInterval. End.\n\nWe need to adhere to format. Use 'Start', 'End', decisions with Yes→, No→. Provide arrow lines with explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果列表 result ← 空列表 // 用於儲存合併後的區間  \n→ Step 2: 初始化旗標 newAdded ← False // 追蹤 newInterval 是否已加入  \n→ For 每個 interval 在 intervals: // 逐一檢視已排序的區間  \n  Decision: interval.end < newInterval.start? // 此區間在 newInterval 之前且不重疊  \n   Yes → Step 3: result.add(interval) // 將前區間直接加入結果  \n   No  → Decision: interval.start > newInterval.end? // 此區間在 newInterval 之後且不重疊  \n    Yes → Decision: newAdded? // 確定是否已加入 newInterval  \n     No  → Step 4: result.add(newInterval) // 新區間先加入結果  \n     No  → Step 5: newAdded ← True // 標記已加入  \n     Yes → // 新區間已加入，直接處理剩餘區間  \n      Yes → Step 6: result.add(interval) // 加入此後的區間  \n      No  → Step 7: result.add(interval) // 加入此後的區間  \n      No → Step 8: result.add(interval) // 加入此後的區間  \n      No → // 若 newAdded 為 False，先加入 newInterval 再加入本區間  \n       Yes → Step 9: result.add(interval) // 加入本區間  \n       No  → Step 10: result.add(interval) // 加入本區間  \n      No  → // 兩區間重疊，需要合併  \n       Yes → Step 11: newInterval.start ← min(newInterval.start, interval.start) // 更新合併後的起點  \n       Yes → Step 12: newInterval.end   ← max(newInterval.end,   interval.end)   // 更新合併後的終點  \n       No  → Step 13: newInterval.start ← min(newInterval.start, interval.start) // 更新合併後的起點  \n       No  → Step 14: newInterval.end   ← max(newInterval.end,   interval.end)   // 更新合併後的終點  \n→ Decision: newAdded? // 迴圈結束後檢查 newInterval 是否已加入  \n  Yes → // 已加入，直接輸出結果  \n  No  → Step 15: result.add(newInterval) // 新區間尚未加入，現在加入  \nEnd // 程式執行結束，result 為插入並合併後的區間列表",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Add the merged newInterval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(text):\n    \"\"\"從輸入文字中解析 intervals 與 newInterval。\"\"\"\n    pattern = r'intervals\\s*=\\s*(\\[\\[.*?\\]\\])\\s*,\\s*newInterval\\s*=\\s*(\\[\\d+(?:,\\s*\\d+)*\\])'\n    match = re.search(pattern, text, re.DOTALL)\n    if not match:\n        raise ValueError(\"輸入格式錯誤\")\n    intervals_str, new_interval_str = match.groups()\n    intervals = ast.literal_eval(intervals_str)\n    new_interval = ast.literal_eval(new_interval_str)\n    return intervals, new_interval\n\ndef format_output(result):\n    \"\"\"將結果轉成沒有空格的字串格式。\"\"\"\n    return '[' + ','.join('[' + ','.join(str(x) for x in sub) + ']' for sub in result) + ']'\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    if not raw.strip():\n        sys.exit(0)\n    intervals, new_interval = parse_input(raw)\n    sol = Solution()\n    res = sol.insert(intervals, new_interval)\n    print(format_output(res))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "success": true,
          "output": "[[1,5],[6,9]]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "success": true,
          "output": "[[1,2],[3,10],[12,16]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode592.json",
    "problem_index_in_file": 0,
    "title": "Fraction Addition and Subtraction",
    "description_snippet": "Given a string expression representing an expression of fraction addition and subtraction, return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem: given string expression of fraction addition/subtraction, return irreducible fraction string. Need to parse expression, handle operations, keep fraction as numerator/denominator, reduce via gcd. Also if integer output, format as x/1. Steps: parse tokens, iterate through string, accumulate fraction result. Use function parseFraction to split \"a/b\". Use add or subtract fractions: (n1/d1)+(n2/d2) = (n1*d2 + n2*d1)/(d1*d2). After each op, reduce via gcd. At end, output string. Ensure start and end. Provide decision for operator. Provide steps for parsing. Virtual code must be line by line with explanation. Use arrows. Let's produce.\n\nWe'll start with Start. Step: initialize result numerator 0, denominator 1? Actually first fraction parse sets result. So we need to parse first fraction separately. So step: index=0. Step: parse first fraction → set result_num, result_den. Then while index < len: parse operator, parse next fraction, compute new result.\n\nEdge cases: plus or minus, may have unary? expression might start with negative? but problem might not include leading minus. We'll assume expression only contains + and - between fractions, maybe start with -? We can handle leading minus by checking if expression starts with '-'. But keep simple.\n\nPseudo steps:\n\nStart\n\n→ Step 1: Initialize index = 0, length = len(expression) // Set pointer\n\n→ Step 2: Parse first fraction using ParseFraction(index) // read numerator and denominator\n\n→ Step 3: Set result_num = first_num, result_den = first_den\n\n→ Step 4: While index < length:\n\n→ Decision: 下一個字元是 '+' 或 '-'? // check operator\n\n   Yes: store op = expression[index]; index++ // consume operator\n\n   No: // handle error\n\n→ Step 5: Parse next fraction using ParseFraction(index)\n\n→ Step 6: If op == '+': result_num = result_num * next_den + next_num * result_den; result_den = result_den * next_den\n\n→ Step 7: If op == '-': result_num = result_num * next_den - next_num * result_den; result_den = result_den * next_den\n\n→ Step 8: Reduce by gcd: g = GCD(|result_num|, result_den); result_num /= g; result_den /= g\n\n→ Step 9: Continue loop\n\nEnd loop\n\n→ Step 10: If result_den < 0: result_num = -result_num; result_den = -result_den // ensure denominator positive\n\n→ Step 11: Return string f\"{result_num}/{result_den}\" // format output\n\nAlso need functions: ParseFraction: read integer numerator until '/', then denominator until next operator or end. We'll produce steps inside.\n\nLet's produce virtual code.\n\nWe need to include each line with explanation. Use arrow \"→\". For decision use indentation.\n\nLet's create:\n\nStart // 程式開始執行\n\n→ Step 1: 設定指標 index = 0, length = len(expression) // 初始化位置與長度\n\n→ Step 2: 呼叫 ParseFraction(index) 取得 first_num, first_den // 解析第一個分數\n\n→ Step 3: result_num = first_num, result_den = first_den // 設定初始結果\n\n→ Step 4: 進入循環 while index < length\n\n    Decision: expression[index] 是否為 '+' 或 '-'? // 判斷是否還有運算符\n\n        Yes → Step 5: op = expression[index]; index += 1 // 取得運算符並移動指標\n\n        No → Decision: index 已到結尾? // 確認結束條件\n\n            Yes → Step 6: 跳出循環\n\n            No → Step 7: 報錯 // 無效字元\n\n    Step 8: 呼叫 ParseFraction(index) 取得 next_num, next_den // 解析下一個分數\n\n    Step 9: Decision: op == '+'? // 判斷是加還是減\n\n        Yes → Step 10: result_num = result_num * next_den + next_num * result_den; result_den = result_den * next_den // 加法合併分數\n\n        No → Step 11: result_num = result_num * next_den - next_num * result_den; result_den = result_den * next_den // 減法合併分數\n\n    Step 12: g = GCD(abs(result_num), result_den) // 取得最大公因數\n\n    Step 13: result_num = result_num / g; result_den = result_den / g // 約簡分數\n\n    Step 14: index = current position after fraction // 更新指標（ParseFraction 內部已更新）\n\nEnd while // 循環結束\n\n→ Step 15: Decision: result_den < 0? // 確保分母正號\n\n    Yes → Step 16: result_num = -result_num; result_den = -result_den // 取負號\n\n    No → // 不作變動\n\n→ Step 17: 輸出字串 f\"{result_num}/{result_den}\" // 回傳結果\n\nEnd // 程式結束\n\nBut we need to explicitly define ParseFraction and GCD functions. Could include as substeps or separate. Let's add function definitions earlier.\n\nWe can include at the top:\n\n→ Function ParseFraction(index): // 解析字串中的分數\n\n    Step: num_str = \"\"; while expression[index] is digit: num_str += expression[index]; index++\n\n    Step: expect '/'; index++ // 跳過斜線\n\n    Step: den_str = \"\"; while index < length and expression[index] is digit: den_str += expression[index]; index++\n\n    Step: return int(num_str), int(den_str), index // 回傳數字與更新指標\n\n→ Function GCD(a, b): // 計算最大公因數\n\n    Step: while b != 0: temp = b; b = a % b; a = temp\n\n    Step: return a\n\nBut virtual code lines must follow pattern. We can incorporate these as separate steps before main loop. Provide explanation.\n\nLet's produce final answer. Ensure each line includes virtual code and comment. Use Chinese explanation. Use arrow for each step. Indentation for decision. Use `→` at start of each step.\n\nWe'll output.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Function GCD(a, b): // 計算兩數的最大公因數\n    → Step 1: a = abs(a); b = abs(b) // 取絕對值以避免負號\n    → Step 2: while b != 0:\n        → Step 3: temp = b\n        → Step 4: b = a % b\n        → Step 5: a = temp\n    → Step 6: return a // 回傳 GCD\n→ Function ParseFraction(idx): // 從 idx 位置解析分數並返回 (num, den, new_idx)\n    → Step 1: num_str = \"\"\n    → Step 2: while idx < len(expression) and expression[idx] is digit:\n        → Step 3: num_str += expression[idx]\n        → Step 4: idx += 1\n    → Step 5: idx += 1 // 跳過 '/'\n    → Step 6: den_str = \"\"\n    → Step 7: while idx < len(expression) and expression[idx] is digit:\n        → Step 8: den_str += expression[idx]\n        → Step 9: idx += 1\n    → Step 10: return int(num_str), int(den_str), idx // 傳回數字、分母與更新後的索引\n→ Step 1: idx = 0; length = len(expression) // 初始化指標與長度\n→ Step 2: first_num, first_den, idx = ParseFraction(idx) // 解析第一個分數\n→ Step 3: result_num = first_num; result_den = first_den // 設定初始結果\n→ Step 4: while idx < length: // 處理後續運算符與分數\n    → Decision: expression[idx] 是否為 '+' 或 '-'? // 判斷是否還有運算符\n        Yes → Step 5: op = expression[idx]; idx += 1 // 取得運算符並移動指標\n        No  → Decision: idx 已到結尾? // 確認結束條件\n            Yes → Step 6: break // 跳出循環\n            No  → Step 7: raise Error(\"無效字元\") // 檢測到非法輸入\n    → Step 8: next_num, next_den, idx = ParseFraction(idx) // 解析下一個分數\n    → Decision: op == '+'? // 判斷是加還是減\n        Yes → Step 9: result_num = result_num * next_den + next_num * result_den\n                 result_den = result_den * next_den // 加法合併分數\n        No  → Step 10: result_num = result_num * next_den - next_num * result_den\n                  result_den = result_den * next_den // 減法合併分數\n    → Step 11: g = GCD(abs(result_num), result_den) // 取得最大公因數\n    → Step 12: result_num = result_num // g; result_den = result_den // g // 約簡分數\n→ Step 13: Decision: result_den < 0? // 確保分母為正\n    Yes → Step 14: result_num = -result_num; result_den = -result_den // 取負號\n    No  → // 不變動\n→ Step 15: return f\"{result_num}/{result_den}\" // 回傳結果字串\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom fractions import Fraction\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入中包含引號，則取引號內的內容作為表達式\n    match = re.search(r'\"(.*?)\"', data)\n    expr = match.group(1) if match else data\n\n    # 取出所有分數形式（可正可負）\n    fractions = re.findall(r'[+-]?\\d+/\\d+', expr)\n\n    # 計算總和並自動約簡\n    result = sum(Fraction(frac) for frac in fractions)\n\n    # 輸出結果\n    sys.stdout.write(f\"{result.numerator}/{result.denominator}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"-1/2+1/2\"",
          "expected_output": "0/1",
          "success": true,
          "output": "0/1"
        },
        {
          "example_index": 1,
          "input": "expression = \"-1/2+1/2+1/3\"",
          "expected_output": "1/3",
          "success": true,
          "output": "1/3"
        },
        {
          "example_index": 2,
          "input": "expression = \"1/3-1/2\"",
          "expected_output": "-1/6",
          "success": true,
          "output": "-1/6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode624.json",
    "problem_index_in_file": 0,
    "title": "Maximum Distance in Arrays",
    "description_snippet": "You are given m arrays, where each array is sorted in ascending order.\nYou can pick up two integers ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, step by step. Problem: given m arrays sorted ascending. We need to pick two integers from two different arrays (one from each array) and calculate distance |a-b|, find maximum possible distance.\n\nEssentially, we want maximum absolute difference between any element from array i and any element from array j, i!=j. Since arrays sorted, the maximum distance will be between the global minimum of all arrays and global maximum of all arrays, unless they come from same array. But we must choose two different arrays. So we need to consider min of each array and max of each array. Compute global min value along with the array index, and global max value along with index. If min and max come from different arrays, answer is global max - global min. If they come from same array, then we need next candidate: either second min or second max from that array? Actually we need maximize difference between elements from two different arrays. So we need consider for each array its min and max. Then we can consider all pairs of arrays: distance between min of array i and max of array j, or max of i and min of j. The maximum difference will be either max_j - min_i or max_i - min_j across all pairs. This simplifies to global max among all max values minus global min among all min values but ensuring arrays differ. If same array holds both extremes, we need alternative. The alternative is global max among all max values except the one from the array containing global min, minus global min among all min values except the one from the array containing global max. So we can compute two candidate distances:\n1) max_global (max among all arrays) minus min_other where min_other is the minimum value from any array other than the array of max_global. That gives distance where one side uses the max from its array, the other uses min from a different array.\n2) max_other minus min_global where max_other is the maximum value from any array other than array of min_global, minus min_global. This yields other orientation.\nTake max of these two.\n\nEdge cases: if m=1 then no pair of different arrays? Problem might guarantee m>=2. We'll assume.\n\nImplementation steps: \n- For each array, record min_i and max_i.\n- Find index of global min (min_global, idx_min). If multiple arrays have same min, pick any.\n- Find index of global max (max_global, idx_max). \n- Compute candidate1: max_global - min_of_other_arrays where other arrays exclude idx_max. We need min_other among arrays where index != idx_max. That is min value across all arrays except idx_max. But careful: we need min value, but from any array except idx_max. Actually we want min value from any array other than idx_max. That's simple: iterate all arrays, if idx != idx_max, take min_i; find min over them. \n- Candidate1 = max_global - min_other.\n- Candidate2: max_other - min_global where max_other is max among arrays with idx != idx_min. \n- Result = max(candidate1, candidate2). \nComplexity O(m). That is pseudo.\n\nNow produce virtual code lines with explanation. Use Start, Decision, etc. We can outline loops.\n\nWe need to adhere to formatting: each line \"虛擬碼步驟 // 解釋\".\n\nWe need arrows. We'll use indentation style as in example. Use \"→\" for steps. Also \"Decision:\" lines.\n\nWe need to output line by line. Each step must be a single line with arrow and comment. We'll use consistent formatting.\n\nLet's create steps:\n\nStart // 程式開始\n\n→ Initialize empty lists MinVals, MaxVals // 儲存每個陣列的最小值和最大值\n\n→ Decision: m == 0? // 檢查陣列數量\n    Yes → End // 若沒有陣列，結束\n    No → ...\n\nBut we can skip that; assume m>0. Just proceed.\n\nWe can write:\n\n→ For each array i in 0..m-1: // 迭代每個陣列\n    → Store min_i = array[0] // 取得最小值\n    → Store max_i = array[-1] // 取得最大值\n\nAfter loop:\n\n→ Find idx_min, min_global by scanning MinVals // 找出全局最小值與其陣列索引\n→ Find idx_max, max_global by scanning MaxVals // 找出全局最大值與其陣列索引\n\n→ Decision: idx_min == idx_max? // 判斷最小值和最大值來自同一陣列\n    Yes → // 必須計算替代值\n        → Compute min_other = min of MinVals where index != idx_max // 最小值來自不同陣列\n        → Compute max_other = max of MaxVals where index != idx_min // 最大值來自不同陣列\n        → Compute candidate1 = max_global - min_other // 距離1\n        → Compute candidate2 = max_other - min_global // 距離2\n        → Result = max(candidate1, candidate2) // 取最大\n    No → // 兩極值來自不同陣列\n        → Result = max_global - min_global // 最大距離\n\n→ End // 程式結束\n\nBut we need each step on its own line. The Decision branch contains sub-steps lines. For sub-steps we can indent with spaces and use arrow.\n\nLet's format accordingly:\n\nStart // 程式開始\n\n→ Step 1: 初始化 MinVals, MaxVals 為空列表 // 用於儲存每個陣列的最小值與最大值\n\n→ Step 2: 從每個陣列 i (0~m-1) 取得最小值與最大值\n    → Step 2.1: min_i ← array_i[0] // 最小值\n    → Step 2.2: max_i ← array_i[-1] // 最大值\n    → Step 2.3: Append min_i 到 MinVals // 儲存\n    → Step 2.4: Append max_i 到 MaxVals // 儲存\n\n→ Step 3: 在 MinVals 找到全局最小值 min_global 與其索引 idx_min // 全局最小\n\n→ Step 4: 在 MaxVals 找到全局最大值 max_global 與其索引 idx_max // 全局最大\n\n→ Decision: idx_min == idx_max? // 最小值和最大值來自同一陣列?\n    Yes → \n        → Step 5a: min_other ← 最小值中索引 ≠ idx_max 的最小值 // 不同陣列的最小值\n        → Step 5b: max_other ← 最大值中索引 ≠ idx_min 的最大值 // 不同陣列的最大值\n        → Step 5c: candidate1 ← max_global - min_other // 距離 1\n        → Step 5d: candidate2 ← max_other - min_global // 距離 2\n        → Step 5e: Result ← max(candidate1, candidate2) // 取最大\n    No → \n        → Step 6: Result ← max_global - min_global // 直接計算距離\n\n→ End // 程式結束\n\nBut the instructions: \"逐行輸出。每行必須包含：虛擬碼步驟 + 空格 + // 解釋/說明\". Also use arrow for structure. In example they used \"→ Step 1: ...\" lines, but also used \"Decision:\" line. Let's follow that style: Each line starts with \"→\" or \"Decision:\" etc. We'll need to produce each step line as one line. For decision branches, each branch's steps must be indented with spaces and \"→\". They used in example:\n\nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n\nSo each line in the branch starts with either \"Yes →\" or \"No  →\" (note two spaces after Yes). For nested Decision, we indent accordingly. We'll replicate.\n\nThus our pseudo-code:\n\nStart // 程式開始\n→ Step 1: 初始化 MinVals, MaxVals 為空列表 // 用於儲存每個陣列的最小值與最大值\n→ Step 2: 從每個陣列 i (0~m-1) 取得最小值與最大值 // 迭代每個陣列\n    → Step 2.1: min_i ← array_i[0] // 取得最小值\n    → Step 2.2: max_i ← array_i[-1] // 取得最大值\n    → Step 2.3: Append min_i 到 MinVals // 儲存\n    → Step 2.4: Append max_i 到 MaxVals // 儲存\n→ Step 3: 在 MinVals 找到全局最小值 min_global 與其索引 idx_min // 全局最小\n→ Step 4: 在 MaxVals 找到全局最大值 max_global 與其索引 idx_max // 全局最大\n→ Decision: idx_min == idx_max? // 最小值和最大值來自同一陣列?\n    Yes →\n        → Step 5a: min_other ← 最小值中索引 ≠ idx_max 的最小值 // 不同陣列的最小值\n        → Step 5b: max_other ← 最大值中索引 ≠ idx_min 的最大值 // 不同陣列的最大值\n        → Step 5c: candidate1 ← max_global - min_other // 距離 1\n        → Step 5d: candidate2 ← max_other - min_global // 距離 2\n        → Step 5e: Result ← max(candidate1, candidate2) // 取最大\n    No  →\n        → Step 6: Result ← max_global - min_global // 直接計算距離\nEnd // 程式結束\n\nBut the lines after \"Yes →\" and \"No →\" need indentation. In example, they used 4 spaces indentation for nested lines. We'll follow same.\n\nAlso need to maintain \"Decision:\" lines properly. We may need to indent the \"Decision:\" line for branch? In example, the \"Decision:\" line is at same level as previous line. That is fine.\n\nLet's produce final output with lines each on new line, each with virtual code step and comment.\n\nEnsure no actual code, just virtual steps.\n\nAlso ensure we use \"→\" at start for all steps except Decision. For sub-steps after Yes/No, start with \"→\".\n\nCheck formatting: Each line ends with comment after \"//\". The arrow \"→\" should be preceded by spaces? In example they didn't indent the top-level lines. So we start each line with \"Start\", \"→ Step 1:\" etc. We'll follow.\n\nBut we need to keep \"Yes →\" and \"No  →\" with correct spacing. In example, they had \"Yes → Step 2:\" with two spaces after Yes? Actually they wrote:\n\nYes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\nNo  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nThey had \"Yes →\" then space, then \"Step 2\". \"No  →\" had two spaces after No. So we need to mimic. We'll produce:\n\nYes →\n    → Step 5a: ...\nNo  →\n    → Step 6: ...\n\nBut we need to be consistent: after \"Yes →\" they had a space then \"Step\". Actually they wrote \"Yes → Step 2:\". So we can write \"Yes → Step 5a:\".\n\nBut for sub-steps under Yes, they used indentation.\n\nSo implement:\n\nYes →\n    → Step 5a: ...\n\nBut maybe easier: \"Yes → Step 5a:\" etc.\n\nLet's just replicate style: \"Yes → Step 5a:\".\n\nBut inside Yes branch, we need further steps. We'll use indentation and arrows. Eg:\n\nYes →\n    → Step 5a: ...\n    → Step 5b: ...\n\nBut we must maintain proper indentation with 4 spaces before \"→\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 初始化 MinVals, MaxVals 為空列表 // 用於儲存每個陣列的最小值與最大值\n→ Step 2: 從每個陣列 i (0~m-1) 取得最小值與最大值 // 迭代每個陣列\n    → Step 2.1: min_i ← array_i[0] // 取得最小值\n    → Step 2.2: max_i ← array_i[-1] // 取得最大值\n    → Step 2.3: Append min_i 到 MinVals // 儲存\n    → Step 2.4: Append max_i 到 MaxVals // 儲存\n→ Step 3: 在 MinVals 找到全局最小值 min_global 與其索引 idx_min // 全局最小\n→ Step 4: 在 MaxVals 找到全局最大值 max_global 與其索引 idx_max // 全局最大\n→ Decision: idx_min == idx_max? // 最小值和最大值來自同一陣列?\n    Yes →\n        → Step 5a: min_other ← 最小值中索引 ≠ idx_max 的最小值 // 不同陣列的最小值\n        → Step 5b: max_other ← 最大值中索引 ≠ idx_min 的最大值 // 不同陣列的最大值\n        → Step 5c: candidate1 ← max_global - min_other // 距離 1\n        → Step 5d: candidate2 ← max_other - min_global // 距離 2\n        → Step 5e: Result ← max(candidate1, candidate2) // 取最大\n    No  →\n        → Step 6: Result ← max_global - min_global // 直接計算距離\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxDistance(self, arrays):\n        if not arrays:\n            return 0\n        min_val = arrays[0][0]\n        max_val = arrays[0][-1]\n        res = 0\n        for arr in arrays[1:]:\n            res = max(res, abs(arr[-1] - min_val), abs(max_val - arr[0]))\n            min_val = min(min_val, arr[0])\n            max_val = max(max_val, arr[-1])\n        return res\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return []\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    try:\n        arrays = ast.literal_eval(expr)\n    except Exception:\n        arrays = []\n    return arrays\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    arrays = parse_input(raw_input)\n    solution = Solution()\n    result = solution.maxDistance(arrays)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arrays = [[1,2,3],[4,5],[1,2,3]]",
          "expected_output": " 4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": " arrays = [[1],[1]]",
          "expected_output": " 0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode20.json",
    "problem_index_in_file": 0,
    "title": "Valid Parentheses",
    "description_snippet": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the in...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for checking valid parentheses string. Use Start, Decision, etc. Use virtual code steps line by line. Provide explanation comments. Need to use arrow \"→\". Should include push/pop operations on stack. Let's produce steps.\n\nThe steps: Start. Read string s. Initialize empty stack. Iterate over characters. For each char, if it's opening bracket, push onto stack. If closing bracket, check if stack empty -> invalid. Else pop top and check match type. After loop, if stack empty -> valid else invalid. End. Also decision to handle each closing bracket.\n\nLet's produce virtual code. Use Decision: if char in opening brackets? etc. Provide lines.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得字串 s // 讀取輸入的字串  \n→ Step 2: 建立空堆疊 stack // 用來儲存未關閉的括號  \n→ Step 3: 對 s 之每個字元 c 進行迴圈 // 遍歷整個字串  \n  → Decision: c 是否為開括號? // 判斷字元類型  \n   Yes → Step 4: 將 c 推入 stack // 先把開括號記錄下來  \n   No  → Decision: c 是否為右括號? // 只處理合法的右括號  \n    Yes → Decision: stack 是否為空? // 先檢查是否還有可配對的開括號  \n     Yes → Step 5: 設定結果為無效並結束 // 沒有開括號可以配對  \n     No  → Step 6: 取出 stack 頂端元素 top // 取出最近的未配對開括號  \n      → Decision: top 與 c 是否匹配? // 比較括號型別  \n       Yes → Step 7: 繼續迴圈 // 配對成功，繼續處理下一個字元  \n       No  → Step 8: 設定結果為無效並結束 // 括號型別不符  \n    No  → Step 9: 跳過非括號字元 // 若字串可能包含其他字元，直接忽略  \n→ Decision: stack 是否為空? // 迴圈結束後確認是否還有未關閉的開括號  \n  Yes → Step 10: 設定結果為有效 // 所有括號都已正確配對  \n  No  → Step 11: 設定結果為無效 // 有剩餘未關閉的開括號  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"判斷括號是否有效\"\"\"\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n        for ch in s:\n            if ch in mapping:\n                # 若沒有對應的開括號，直接返回 False\n                if not stack or stack.pop() != mapping[ch]:\n                    return False\n            else:\n                # 只將開括號推進堆疊\n                stack.append(ch)\n        # 最後堆疊空代表所有括號都配對完成\n        return not stack\n\ndef parse_input() -> str:\n    \"\"\"從 stdin 解析輸入，支援 `s = \"()\"` 或純字串形式\"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return \"\"\n    # 若輸入中包含 '='，則取 '=' 右側作為字串\n    if '=' in raw:\n        _, part = raw.split('=', 1)\n        raw = part.strip()\n    # 移除可能存在的單/雙引號\n    if (raw.startswith('\"') and raw.endswith('\"')) or (raw.startswith(\"'\") and raw.endswith(\"'\")):\n        raw = raw[1:-1]\n    return raw\n\ndef main() -> None:\n    s = parse_input()\n    solution = Solution()\n    result = solution.isValid(s)\n    # 輸出符合題目格式的小寫字串\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 3,
          "input": "s = \"([])\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 4,
          "input": "s = \"([)]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode204.json",
    "problem_index_in_file": 0,
    "title": "Count Primes",
    "description_snippet": "Given an integer n, return the number of prime numbers that are strictly less than n....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for computing number of primes less than n. We need to use structure Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" before steps. Use Decision lines. Probably implement Sieve of Eratosthenes. Steps: input n, handle n<=2, create boolean array, iterate i from 2 to sqrt(n-1), mark composites, count primes. Let's produce step by step.\n\nWe'll output as lines: Start, → Step 1, etc. Use proper indentation maybe but not required. But need to keep consistent format. Provide comments after //.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得使用者輸入的整數\n→ Decision: n <= 2? // 若 n 小於等於 2，則沒有小於 n 的質數\n    Yes → Step 2: 回傳 0 // 回傳 0，結束\n    No  → Step 3: 建立布林陣列 isPrime[0 … n-1] 並將 0、1 設為 False，其他設為 True // 初始化素數判斷陣列\n→ Step 4: 設定 limit = ⌊sqrt(n-1)⌋ // 取上限，用於篩除\n→ Step 5: 從 i = 2 到 limit 逐一檢查\n    → Decision: isPrime[i]? // 判斷 i 是否仍為質數\n        Yes → Step 6: 針對 j = i*i; j < n; j += i 設 isPrime[j] = False // 把 i 的倍數標記為非質數\n        No  → Continue // 若不是質數，直接跳過\n→ Step 7: 計算 count = 0 // 初始化計數\n→ Step 8: 從 k = 2 到 n-1 逐一累加\n    → Decision: isPrime[k]? // 判斷 k 是否為質數\n        Yes → Step 9: count = count + 1 // 累加\n        No  → Continue // 跳過\n→ Step 10: 回傳 count // 回傳質數個數\nEnd // 程式執行結束\n\nNeed each line with arrow for step, but decision lines also. Let's format each line exactly as: \"→ Step X: ...\" or \"→ Decision: ...\". Also indent decisions maybe but keep same.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得使用者輸入的整數  \n→ Decision: n <= 2? // 若 n 小於等於 2，則沒有小於 n 的質數  \n Yes → Step 2: 回傳 0 // 回傳 0，結束  \n No  → Step 3: 建立布林陣列 isPrime[0 … n-1] 並將 0、1 設為 False，其他設為 True // 初始化素數判斷陣列  \n→ Step 4: 設定 limit = ⌊sqrt(n-1)⌋ // 取上限，用於篩除  \n→ Step 5: 從 i = 2 到 limit 逐一檢查  \n → Decision: isPrime[i]? // 判斷 i 是否仍為質數  \n  Yes → Step 6: 針對 j = i*i; j < n; j += i 設 isPrime[j] = False // 把 i 的倍數標記為非質數  \n  No  → Continue // 若不是質數，直接跳過  \n→ Step 7: 計算 count = 0 // 初始化計數  \n→ Step 8: 從 k = 2 到 n-1 逐一累加  \n → Decision: isPrime[k]? // 判斷 k 是否為質數  \n  Yes → Step 9: count = count + 1 // 累加  \n  No  → Continue // 跳過  \n→ Step 10: 回傳 count // 回傳質數個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_primes(n: int) -> int:\n    \"\"\"Return the number of prime numbers strictly less than n.\"\"\"\n    if n <= 2:\n        return 0\n    # 初始化布林陣列，預設所有數字為質數\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    limit = int(n ** 0.5) + 1\n    for i in range(2, limit):\n        if is_prime[i]:\n            # 把 i 的所有倍數標記為非質數\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    # 直接計算布林值為 True 的個數\n    return sum(is_prime)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並尋找第一個整數\n    data = sys.stdin.read()\n    match = re.search(r\"-?\\d+\", data)\n    if match:\n        n = int(match.group())\n        result = count_primes(n)\n        print(result)\n    else:\n        # 若沒有找到整數，則輸出 0\n        print(0)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode264.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number II",
    "description_snippet": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. \n\nGiven an inte...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm that finds nth ugly number. Classic DP using pointers i2,i3,i5. We output each line with explanation. Need to start with Start, end.\n\nUse decision? maybe use loop. Steps:\n\n1. Start\n2. Step 1: initialize ugly[1] = 1; i2=i3=i5=1; // base\n3. Step 2: For k from 2 to n:\n    - Step 3: next2 = ugly[i2] * 2; next3 = ugly[i3] * 3; next5 = ugly[i5] * 5; // compute candidates\n    - Decision: next ugly = min(next2,next3,next5); // choose smallest\n        - Step 4: ugly[k] = next ugly\n    - Decision: if next ugly == next2? i2++ ; // increment pointer\n        - etc.\n4. Step 5: Return ugly[n]\n\nNeed to output virtual code line by line with explanations. Use arrow \"→\". Use Decision with Yes/No? We could use Decision to choose pointer increments, but we can also show steps.\n\nSimplify: Use Decision for pointer increments.\n\nSo code lines:\n\nStart\n→ Step 1: Set ugly[1] = 1; i2 = i3 = i5 = 1; // initialise\n→ Step 2: For k = 2 to n: // iterate to compute nth ugly\n    → Step 3: Compute next2 = ugly[i2] * 2; next3 = ugly[i3] * 3; next5 = ugly[i5] * 5; // candidates\n    → Decision: next = min(next2,next3,next5); // pick smallest\n        Yes → Step 4: ugly[k] = next; // store\n    → Decision: if next == next2? // update pointer\n        Yes → i2 = i2 + 1; // move pointer\n        No → Decision: if next == next3?\n            Yes → i3 = i3 + 1;\n            No → i5 = i5 + 1;\n→ Step 5: Return ugly[n]; // final result\nEnd\n\nMake sure each line ends with // explanation.\n\nAlso need to ensure formatting: each line like \"Start // 程式開始執行\". Use arrow for indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set ugly[1] = 1; i2 = i3 = i5 = 1; // 初始化第一個丑數與三個指標  \n→ Step 2: For k = 2 to n: // 循環計算第 2 到第 n 個丑數  \n    → Step 3: Compute next2 = ugly[i2] * 2; next3 = ugly[i3] * 3; next5 = ugly[i5] * 5; // 計算三個候選數  \n    → Decision: next = min(next2, next3, next5); // 選擇最小的候選數作為下一個丑數  \n        Yes → Step 4: ugly[k] = next; // 存入丑數序列  \n    → Decision: if next == next2? // 判斷哪個指標需要前進  \n        Yes → i2 = i2 + 1; // 若是 2 的候選，指標 i2 前進  \n        No → Decision: if next == next3?  \n            Yes → i3 = i3 + 1; // 若是 3 的候選，指標 i3 前進  \n            No → i5 = i5 + 1; // 否則是 5 的候選，指標 i5 前進  \n→ Step 5: Return ugly[n]; // 回傳第 n 個丑數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef nthUglyNumber(n: int) -> int:\n    \"\"\"返回第 n 個丑數（質因數僅限 2、3、5）。\"\"\"\n    ugly = [1]          # 丑數序列\n    i2 = i3 = i5 = 0    # 三個指標，分別指向下一個乘 2、3、5 的位置\n\n    while len(ugly) < n:\n        next2 = ugly[i2] * 2\n        next3 = ugly[i3] * 3\n        next5 = ugly[i5] * 5\n        next_ugly = min(next2, next3, next5)\n\n        ugly.append(next_ugly)\n\n        if next_ugly == next2:\n            i2 += 1\n        if next_ugly == next3:\n            i3 += 1\n        if next_ugly == next5:\n            i5 += 1\n\n    return ugly[-1]\n\n\ndef main() -> None:\n    \"\"\"讀取輸入，計算並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中抽取第一個數字（符合範例格式 'n = 10' 或 'n=1'）\n    m = re.search(r'\\d+', data)\n    if not m:\n        return\n\n    n = int(m.group())\n    result = nthUglyNumber(n)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "12",
          "success": true,
          "output": "12"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode316.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicate Letters",
    "description_snippet": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm to remove duplicate letters to get the smallest lexicographical result. We need to output line by line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Should not output actual code. Just steps.\n\nWe need to describe algorithm: use stack, counts of remaining characters, visited flags. For each char: decrement count; if visited skip; while stack not empty and top > current and count[top] > 0, pop and mark visited false; push current, mark visited true. After loop, join stack. Output steps accordingly.\n\nWe need to produce a step-by-step virtual code with decisions.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use arrow →. Use Decision: lines. Should include Start and End.\n\nLet's produce about maybe 15-20 lines. Provide details.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字串 s 的長度 n, 建立頻率表 count[26] 計算每個字母剩餘出現次數 // 先統計每個字母總共出現的次數  \n→ Step 2: 建立布林陣列 visited[26] 初始化為 false，代表每個字母是否已放入結果中  \n→ Step 3: 建立空棧 stack 用於儲存最終結果的字母  \n→ Decision: 迴圈從 i = 0 到 i < n? // 遍歷每個字母  \n  Yes → Step 4: let c = s[i]，將對應字母的 count[c] 減 1 // 更新該字母剩餘次數  \n  Decision: visited[c] 為 true? // 是否已經在棧中？  \n   Yes → Step 5: 跳過此字母 // 已經放過，直接繼續下一個  \n   No → Decision: stack 不是空且 stack.top() > c 且 count[stack.top()] > 0? // 是否能彈出更大字母以保證最小字典序  \n    Yes → Step 6: 取出棧頂字母 t = stack.pop()，將 visited[t] 設為 false // 取出可替換字母  \n     → 重複判斷 Decision: stack 不是空且 stack.top() > c 且 count[stack.top()] > 0? // 可能還有更大字母可彈  \n      → Yes → Step 6 重複  \n       No → Step 7: 將 c 推入棧 stack.push(c)，並將 visited[c] 設為 true // 放入當前字母  \n    No → Step 7: 將 c 推入棧 stack.push(c)，並將 visited[c] 設為 true // 直接放入字母  \n    → Step 8: 迴圈結束，返回 Step 4  \n  Yes → Step 9: 跳出迴圈 // 所有字母已處理完  \n→ Step 10: 將棧中的字母按順序連接成結果字串 res // 把棧裡的字母組合成最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeDuplicateLetters(self, s: str) -> str:\n        \"\"\"\n        Use a stack to build the smallest lexicographical result.\n        \"\"\"\n        stack = []\n        seen = set()\n        # Record last occurrence of each character\n        last_occurrence = {c: i for i, c in enumerate(s)}\n\n        for i, c in enumerate(s):\n            if c not in seen:\n                # Remove larger characters that appear later\n                while stack and c < stack[-1] and i < last_occurrence[stack[-1]]:\n                    seen.discard(stack.pop())\n                stack.append(c)\n                seen.add(c)\n        return ''.join(stack)\n\ndef _extract_string(data: str) -> str:\n    \"\"\"\n    Extract the string value from input like:\n    s = \"bcabc\"\n    or just bcabc.\n    \"\"\"\n    data = data.strip()\n    # Look for the first and last double quote\n    quotes = [m.start() for m in re.finditer(r'\"', data)]\n    if len(quotes) >= 2:\n        return data[quotes[0] + 1:quotes[1]]\n    # If no quotes, return the trimmed data\n    return data\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    s = _extract_string(input_data)\n    result = Solution().removeDuplicateLetters(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bcabc\"",
          "expected_output": "\"abc\"",
          "success": true,
          "output": "abc"
        },
        {
          "example_index": 1,
          "input": "s = \"cbacdcbc\"",
          "expected_output": "\"acdb\"",
          "success": true,
          "output": "acdb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode432.json",
    "problem_index_in_file": 0,
    "title": "All O`one Data Structure",
    "description_snippet": "Design a data structure to store the strings' count with the ability to return the strings with mini...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Provide algorithm steps: Use Doubly linked list of count nodes, with hash map key->node, and each node has set of keys. Standard AllOne. Provide start, decisions, etc.\n\nWe should produce line-by-line pseudocode with arrows, explanation. No actual code.\n\nLet's craft:\n\nStart\n→ Initialize hashmap keyCountMap ← {} // store key to node\n→ Initialize headCountNode ← new Node(0) // dummy head with count 0\n→ Initialize tailCountNode ← new Node(0) // dummy tail with count 0\n→ Link headCountNode <-> tailCountNode // doubly linked list empty\n→ End // constructor finished\n\nThen inc method:\n→ inc(key) // public method\n    → Decision: key exists? // check keyCountMap\n        Yes → node ← keyCountMap[key]\n             → nextNode ← node.next\n             → Decision: nextNode.count == node.count + 1?\n                 Yes → // increment existing next node\n                     → Remove key from node.keySet\n                     → Add key to nextNode.keySet\n                     → keyCountMap[key] ← nextNode\n                     → Decision: node.keySet empty?\n                         Yes → Remove node from list\n                         No  → // keep node\n                 No → // need new node\n                     → newNode ← new Node(node.count + 1)\n                     → Insert newNode after node\n                     → Add key to newNode.keySet\n                     → keyCountMap[key] ← newNode\n                     → Remove key from node.keySet\n                     → Decision: node.keySet empty?\n                         Yes → Remove node\n                         No  → keep\n        No  → // new key\n             → Decision: headCountNode.next.count == 1?\n                 Yes → headCountNode.next.keySet add key\n                 No  → newNode ← new Node(1); insert after headCountNode; add key\n             → keyCountMap[key] ← node with count 1\nEnd inc\n\nSimilarly dec method. Provide logic.\n\nReturn max/min: just tail.prev and head.next.\n\nLet's produce concise steps with arrows. Each line comment.\n\nMake sure each line uses arrow. Use \"Decision:\" etc. Use indented lines with 4 spaces maybe? In example, indentation shown with spaces after Decision. We'll follow same.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ AllOne() // 建構 AllOne 物件  \n    → keyMap ← {} // key → 其所在的 count 節點  \n    → head ← new Node(0) // 偽頭，count = 0  \n    → tail ← new Node(0) // 偽尾，count = 0  \n    → head.next ← tail // 雙向鏈表初始化  \n    → tail.prev ← head  \nEnd // AllOne 建構完成  \n\n→ inc(key) // 增加 key 的計數  \n    → Decision: keyMap contains key? // key 是否已存在  \n        Yes → node ← keyMap[key] // 取得 key 所在節點  \n            → next ← node.next  \n            → Decision: next.count == node.count + 1? // 下一節點是否恰好 +1  \n                Yes → // 直接加入下一節點  \n                    → node.keySet.remove(key)  \n                    → next.keySet.add(key)  \n                    → keyMap[key] ← next  \n                    → Decision: node.keySet empty?  \n                        Yes → // 節點已無 key，移除節點  \n                            → remove(node)  \n                        No  → // 保留節點  \n                No  → // 需要新節點  \n                    → newNode ← new Node(node.count + 1)  \n                    → insertAfter(node, newNode)  \n                    → newNode.keySet.add(key)  \n                    → keyMap[key] ← newNode  \n                    → node.keySet.remove(key)  \n                    → Decision: node.keySet empty?  \n                        Yes → remove(node)  \n                        No  →  \n        No  → // 新 key，計數從 1 開始  \n            → Decision: head.next.count == 1? // 是否已有 count=1 節點  \n                Yes → head.next.keySet.add(key)  \n                No  → // 新增 count=1 節點  \n                    → node1 ← new Node(1)  \n                    → insertAfter(head, node1)  \n                    → node1.keySet.add(key)  \n            → keyMap[key] ← head.next  \n\n→ dec(key) // 減少 key 的計數  \n    → node ← keyMap[key] // 取得 key 所在節點  \n    → prev ← node.prev  \n    → Decision: node.count == 1? // 計數是否會降至 0  \n        Yes → // 刪除 key，移除節點  \n            → node.keySet.remove(key)  \n            → keyMap.remove(key)  \n            → Decision: node.keySet empty?  \n                Yes → remove(node)  \n                No  →  \n        No  → // 需要將 key 移至 prev 節點  \n            → Decision: prev.count == node.count - 1? // prev 是否恰好 -1  \n                Yes → // 直接加入 prev 節點  \n                    → node.keySet.remove(key)  \n                    → prev.keySet.add(key)  \n                    → keyMap[key] ← prev  \n                    → Decision: node.keySet empty?  \n                        Yes → remove(node)  \n                        No  →  \n                No  → // 新增 prev 節點  \n                    → newPrev ← new Node(node.count - 1)  \n                    → insertBefore(node, newPrev)  \n                    → newPrev.keySet.add(key)  \n                    → keyMap[key] ← newPrev  \n                    → node.keySet.remove(key)  \n                    → Decision: node.keySet empty?  \n                        Yes → remove(node)  \n                        No  →  \n\n→ getMaxKey() // 取得最大計數的 key  \n    → Decision: head.next == tail? // 是否有任何 key  \n        Yes → return \"\"  \n        No  → return any key in tail.prev.keySet  \n\n→ getMinKey() // 取得最小計數的 key  \n    → Decision: head.next == tail? // 是否有任何 key  \n        Yes → return \"\"  \n        No  → return any key in head.next.keySet  \n\n→ remove(node) // 將節點從鏈表中移除  \n    → node.prev.next ← node.next  \n    → node.next.prev ← node.prev  \n\n→ insertAfter(prev, newNode) // 在 prev 後插入 newNode  \n    → newNode.prev ← prev  \n    → newNode.next ← prev.next  \n    → prev.next.prev ← newNode  \n    → prev.next ← newNode  \n\n→ insertBefore(next, newNode) // 在 next 前插入 newNode  \n    → newNode.next ← next  \n    → newNode.prev ← next.prev  \n    → next.prev.next ← newNode  \n    → next.prev ← newNode  \n\nEnd // 所有方法已定義，資料結構可在 O(1) 時間內完成所有操作",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Node:\n    def __init__(self):\n        self.keys = set()\n        self.prev = None\n        self.next = None\n        self.count = 0\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node()\n        node.count = count\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        if key not in self.key_to_node:\n            return\n        node = self.key_to_node[key]\n        prev_count = node.count - 1\n        node.keys.remove(key)\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    # Remove potential 'Input' or 'Output' labels\n    if lines and lines[0].lower().startswith('input'):\n        lines = lines[1:]\n    if not lines:\n        return\n    commands = ast.literal_eval(lines[0])\n    args = ast.literal_eval(lines[1]) if len(lines) > 1 else []\n\n    obj = None\n    results = []\n    for cmd, arg in zip(commands, args):\n        if cmd == \"AllOne\":\n            obj = AllOne()\n            results.append(None)\n        elif cmd == \"inc\":\n            obj.inc(arg[0])\n            results.append(None)\n        elif cmd == \"dec\":\n            obj.dec(arg[0])\n            results.append(None)\n        elif cmd == \"getMaxKey\":\n            results.append(obj.getMaxKey())\n        elif cmd == \"getMinKey\":\n            results.append(obj.getMinKey())\n        else:\n            # Unknown command; append None\n            results.append(None)\n\n    print(\"Output\")\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "success": true,
          "output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode344.json",
    "problem_index_in_file": 0,
    "title": "Reverse String",
    "description_snippet": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with virtual code and explanation, for reversing a string represented as array of chars in place, O(1) memory. Provide step by step pseudocode with arrow, decisions, etc.\n\nNeed to start with Start, then steps: define left=0, right=len-1, while left<right swap s[left], s[right], left++, right--. End. Provide explanation each line. Use virtual code arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化指標 left ← 0 // 設定左邊指標指向陣列第一個元素  \n→ Step 2: 初始化指標 right ← s.length - 1 // 設定右邊指標指向陣列最後一個元素  \n→ Decision: 如果 left < right? // 判斷是否還有元素需要交換  \n  Yes → Step 3: 交換 s[left] 與 s[right] // 互換兩端字元  \n    → Step 4: left ← left + 1 // 左指標右移  \n    → Step 5: right ← right - 1 // 右指標左移  \n    → 回到 Decision: 如果 left < right? // 重新檢查條件  \n  No  → End // 所有字元已經被交換完成，結束程序  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def reverseString(self, s):\n        \"\"\"反轉字元陣列，原地完成，額外空間 O(1)\"\"\"\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]  # 交換兩端\n            left += 1\n            right -= 1\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到第一個 '['，取得列表字串\n    idx = data.find('[')\n    if idx != -1:\n        list_str = data[idx:]\n        try:\n            # 安全解析 Python 列表字面量\n            s = ast.literal_eval(list_str)\n        except Exception:\n            # 若解析失敗，使用 eval（較不安全，但作為備援）\n            s = eval(list_str)\n    else:\n        s = []\n\n    # 呼叫解法\n    sol = Solution()\n    sol.reverseString(s)\n\n    # 輸出結果，使用 JSON 以保留雙引號格式\n    print(json.dumps(s))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
          "expected_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
          "success": true,
          "output": "[\"o\", \"l\", \"l\", \"e\", \"h\"]"
        },
        {
          "example_index": 1,
          "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
          "expected_output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
          "success": true,
          "output": "[\"h\", \"a\", \"n\", \"n\", \"a\", \"H\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2220.json",
    "problem_index_in_file": 0,
    "title": "Minimum Bit Flips to Convert Number",
    "description_snippet": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from ei...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with explanation. Problem: minimal number of bit flips to convert start to goal. This is basically Hamming distance between binary representations of start and goal. Approach: compute XOR, count set bits. Steps: Start, compute XOR, count bits, output count, End. Each line with arrow etc.\n\nWe must produce line by line, using virtual code syntax: Start, → Step, Decision etc. Provide brief explanation after //. Should be structured.\n\nLet's produce:\n\nStart\n→ Step 1: Input start and goal // Get the two numbers\n→ Step 2: xor = start XOR goal // Find differing bits\n→ Decision: If xor == 0? // No bits differ\n    Yes → Step 3: result = 0 // Already same\n    No → Step 4: result = 0 // Initialize count\n    → Step 5: While xor > 0 // Count set bits\n        → Step 6: result = result + (xor & 1) // Add least significant bit if 1\n        → Step 7: xor = xor >> 1 // Shift right to process next bit\n→ Step 8: Output result // Return number of flips\nEnd\n\nNeed explanation after //. Provide concise.\n\nWe should maybe show loop with indentation? Use arrow and decisions. Provide \"Decision:\" etc.\n\nMake sure each line includes virtual code step and explanation.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input start and goal // 取得兩個整數  \n→ Step 2: xor = start XOR goal // 計算兩數不同位元的 XOR  \n→ Decision: 如果 xor 等於 0? // 檢查是否已相同  \n  Yes → Step 3: result = 0 // 無需翻轉，直接設定結果為 0  \n  No  → Step 4: result = 0 // 初始化翻轉計數  \n   → Step 5: While xor > 0 // 逐位計算 set bits  \n    → Step 6: result = result + (xor & 1) // 若 LSB 為 1，累加 1  \n    → Step 7: xor = xor >> 1 // 右移處理下一位  \n→ Step 8: Output result // 回傳最小翻轉數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_bit_flips(start: int, goal: int) -> int:\n    \"\"\"\n    1. 先把 start 與 goal 做 XOR，得到兩數不同的位元。\n    2. 再用位元運算逐個統計 XOR 中 1 的數量，即為所需翻轉數。\n    \"\"\"\n    xor = start ^ goal\n    flips = 0\n    while xor:\n        flips += xor & 1   # 若最低位是 1，累加 1\n        xor >>= 1          # 右移，處理下一位\n    return flips\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取字串，利用正規表達式擷取兩個整數\n    (順序為 start, goal)，計算最小翻轉數並輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)   # 找出所有整數字串\n    if len(nums) < 2:\n        return\n    start, goal = map(int, nums[:2])\n    result = min_bit_flips(start, goal)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "start = 10, goal = 7",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "start = 3, goal = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode767.json",
    "problem_index_in_file": 0,
    "title": "Reorganize String",
    "description_snippet": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode with lines: Start, steps, decisions. Must be for rearrange string so adjacent not same. Classic rearrange string using max heap. We can outline: count frequencies, check max freq <= (n+1)/2. Then use priority queue of (freq, char). Build result by picking top two, append, reduce counts, reinsert. Output result or empty.\n\nWe should produce step-by-step with explanations, using arrow → and decisions.\n\nLet's produce code lines:\n\nStart\n→ Step 1: Compute length n of s // Determine string length\n→ Step 2: Count frequency of each character in s // frequency map\n→ Decision: If any frequency > (n+1)/2? // feasibility check\n    Yes → Step 3: Return \"\" // impossible\n    No  → Step 4: Build max-heap of (freq, char) // priority queue\n→ Step 5: Initialize empty result string\n→ Step 6: While heap size > 1:\n    → Step 7: Pop top two items (freq1,char1),(freq2,char2)\n    → Step 8: Append char1 and char2 to result // ensures no adjacency\n    → Step 9: Decrease freq1, freq2 by 1\n    → Decision: If freq1-1 > 0? // remaining char1\n        Yes → Step 10: Push (freq1-1,char1) back\n    → Decision: If freq2-1 > 0? // remaining char2\n        Yes → Step 11: Push (freq2-1,char2) back\n→ Decision: If heap has one item left? // last char\n    Yes → Step 12: Pop last (freq,char)\n    → Decision: If freq > 1? // more than one left\n        Yes → Step 13: Return \"\" // cannot place without adjacency\n        No  → Step 14: Append char to result\n→ Step 15: Return result string // rearrangement complete\nEnd\n\nAdd comments after each line.\n\nMake sure formatting lines with arrow. Use \"Decision:\" lines for decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 s 的長度 n // 取得字串長度  \n→ Step 2: 計算每個字元的頻率 map // 生成字元頻率表  \n→ Decision: 有任何頻率 > (n+1)/2? // 檢查是否可行  \n  Yes → Step 3: 回傳 \"\" // 無法重新排列，直接結束  \n  No  → Step 4: 建立最大堆 heap，元素為 (頻率, 字元) // 準備排序  \n→ Step 5: 初始化空結果字串 result // 用於累積最終字串  \n→ Step 6: 當 heap 大小 > 1 時:  \n  → Step 7: 從 heap 中彈出最高頻率的兩個項目 (f1,c1), (f2,c2) // 取兩個最常見字元  \n  → Step 8: 將 c1, c2 依次加入 result // 兩個不同字元不會相鄰  \n  → Step 9: f1--, f2-- // 各自減少頻率  \n  → Decision: f1 > 0?  \n    Yes → Step 10: 把 (f1,c1) 放回 heap // 仍有剩餘  \n  → Decision: f2 > 0?  \n    Yes → Step 11: 把 (f2,c2) 放回 heap // 仍有剩餘  \n→ Decision: heap 中是否剩下一個項目?  \n  Yes → Step 12: 弹出最後一個 (f,c) // 只剩一個字元  \n    → Decision: f > 1?  \n     Yes → Step 13: 回傳 \"\" // 剩餘多於一個，會導致相鄰相同  \n     No  → Step 14: 將 c 加入 result // 單個字元可安全放置  \n→ Step 15: 回傳 result // 完成重新排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        n = len(s)\n        if n == 0:\n            return \"\"\n        freq = Counter(s)\n        # 若最常出現的字元數量超過 (n+1)//2，則無法重新排列\n        if max(freq.values()) > (n + 1) // 2:\n            return \"\"\n\n        # 建立最大堆（使用負頻率）\n        heap = [(-cnt, ch) for ch, cnt in freq.items()]\n        heapq.heapify(heap)\n\n        result = []\n        # 只要堆中有兩個以上元素，就一次取兩個字元，保證相鄰不同\n        while len(heap) > 1:\n            f1, c1 = heapq.heappop(heap)\n            f2, c2 = heapq.heappop(heap)\n            result.append(c1)\n            result.append(c2)\n\n            # 將剩餘的頻率再次加入堆\n            if f1 + 1 < 0:\n                heapq.heappush(heap, (f1 + 1, c1))\n            if f2 + 1 < 0:\n                heapq.heappush(heap, (f2 + 1, c2))\n\n        # 若堆中剩下最後一個字元，檢查其剩餘次數\n        if heap:\n            f, c = heapq.heappop(heap)\n            if f < -1:  # 剩餘次數大於 1，無法安排\n                return \"\"\n            result.append(c)\n\n        return ''.join(result)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 從輸入中提取第一個字串字面量（支持單引號或雙引號）\n    match = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    s = match.group(1) if match else data\n\n    solution = Solution()\n    rearranged = solution.reorganizeString(s)\n\n    # 依照範例輸出，將結果包裹在雙引號中\n    print(f'\"{rearranged}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "\"aba\"",
          "success": true,
          "output": "\"aba\""
        },
        {
          "example_index": 1,
          "input": "s = \"aaab\"",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode312.json",
    "problem_index_in_file": 0,
    "title": "Burst Balloons",
    "description_snippet": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it repre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm that solves maximum coins by bursting balloons, classic DP interval problem. Provide step by step pseudocode. Each line: \"虛擬碼步驟 // 解釋\". Use arrow for decisions. Use Start, End. Also use decision steps. We'll need to iterate over intervals, maybe use DP table dp[l][r] max coins for interval (l,r). Use 1-indexed padded array with ones at ends.\n\nLet's produce pseudocode with loops and recursion. Provide clear steps. Ensure each line contains one step.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入數列 nums // 取得所有氣球的數值  \n→ Step 2: 定義 m ← nums 的長度  \n→ Step 3: 建立新陣列 newNums，長度 m+2，並把 newNums[0] ← 1，newNums[m+1] ← 1 // 在兩端補 1  \n→ Step 4: 將 nums 的值依序塞入 newNums[1..m] // 形成完整的氣球序列  \n→ Step 5: 建立二維表 dp，大小 (m+2) × (m+2)，並初始化為 0 // dp[l][r] 代表在區間 (l,r) 內爆破所有氣球能獲得的最大硬幣  \n→ Decision: 是否有任何氣球需要處理？ // 檢查是否為空情況  \n    Yes → Step 6: 從 len ← 1 到 m 做迴圈 // len 代表子區間長度  \n        → Step 7: 對於每個起始點 l ← 1 到 m - len + 1 做迴圈  \n            → Step 8: 計算結束點 r ← l + len - 1 // 子區間為 (l, r)  \n            → Step 9: 設置 maxCoins ← 0 // 儲存此子區間的最佳結果  \n            → Decision: 對於每個最後爆破的位置 k ← l 到 r 做迴圈 // k 為最後爆破的氣球  \n                Yes → Step 10: 計算 coins ← dp[l][k-1] + dp[k+1][r] + newNums[l-1] * newNums[k] * newNums[r+1] // 之前已爆破區間的硬幣加上最後爆破 k 的硬幣  \n                → Step 11: 若 coins > maxCoins，則 maxCoins ← coins // 更新最佳值  \n                No  → // 迴圈結束  \n            → Step 12: 設定 dp[l][r] ← maxCoins // 保存此子區間的最大硬幣  \n        → Step 13: // l 迴圈結束  \n    → Step 14: // len 迴圈結束  \n    No  → // 空序列，直接跳至結束  \n→ Step 15: 回傳 dp[1][m] // 最終答案為完整區間 (1, m) 的最大硬幣  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxCoins(self, nums):\n        # 在前後加 1 方便計算\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        # 遍歷所有長度（子陣列長度從 2 開始，因為要包含左右邊界 1）\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                # i 為最後一個被戳破的氣球\n                for i in range(left + 1, right):\n                    dp[left][right] = max(\n                        dp[left][right],\n                        nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]\n                    )\n        return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 移除可能的換行並提取列表部分\n    data = data.replace(\"\\n\", \" \")\n    if \"nums\" in data:\n        # 取等號右邊的部分\n        _, nums_part = data.split(\"=\", 1)\n        nums_part = nums_part.strip()\n    else:\n        nums_part = data\n\n    # 使用安全的 literal_eval 解析列表\n    try:\n        nums = ast.literal_eval(nums_part)\n    except Exception:\n        nums = []\n\n    # 確保 nums 為列表\n    if not isinstance(nums, list):\n        nums = [nums]\n\n    # 計算並輸出結果\n    solution = Solution()\n    print(solution.maxCoins(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,1,5,8]",
          "expected_output": "167",
          "success": true,
          "output": "167"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode166.json",
    "problem_index_in_file": 0,
    "title": "Fraction to Recurring Decimal",
    "description_snippet": "Given two integers representing the numerator and denominator of a fraction, return the fraction in ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for converting fraction numerator/denominator to decimal string with repeating parentheses. Provide line-by-line pseudo steps with explanation after //. We need to follow arrow and Decision formatting. Provide Start and End.\n\nWe need to produce algorithmic steps: get sign, integer part, remainder, map remainders to position, etc.\n\nWe should not output actual code, just virtual steps. Use arrow '→', 'Yes →', 'No →', 'Decision:' etc. Provide each line with step and explanation. Must be in Traditional Chinese.\n\nLet's craft the steps:\n\nStart // 程式開始執行\n→ Step 1: 判斷輸入為零? // 如果分子為0則直接輸出\"0\"並結束\nDecision: 分子是否為0? // 檢查是否為零\n    Yes → Step 2: 輸出 \"0\" // 將結果輸出\n    No → Continue\n\nThen determine sign: negative if numerator and denominator signs differ.\n\n→ Step 3: 計算符號 // 判斷結果是否負數，若是則在結果前加 '-'\n→ Step 4: 取絕對值 // 取得分子、分母的絕對值\n→ Step 5: 取得整數部分 // 整數 = 分子 ÷ 分母\n→ Step 6: 取得餘數 // 餘數 = 分子 % 分母\n\nIf remainder 0: // no fractional part\n→ Decision: 餘數是否為0? // 判斷是否有小數部分\n    Yes → Step 7: 組合結果 = (符號) + 整數部分 // 完成輸出\n    No → Continue\n\nElse, process fractional part:\n→ Step 8: 建立空字串 fractional = \"\" // 用於儲存小數位\n→ Step 9: 建立字典 remainderIndex // 用於記錄餘數出現的位置\n→ Step 10: 循環 while 餘數 != 0\nDecision: 餘數是否為0? // 判斷是否結束\n    Yes → Break // 結束循環\n    No → Continue\n    No → Step 11: 乘 10 // 餘數 = 餘數 * 10\n    Step 12: 計算 digit = 餘數 ÷ 分母 // 得到下一位小數\n    Step 13: 更新餘數 = 餘數 % 分母 // 取得新餘數\n    Decision: 餘數是否已在 remainderIndex? // 判斷是否重複\n        Yes → Step 14: 重複開始位置 = remainderIndex[餘數] // 找到重複區間起點\n        No  → Step 15: 於 remainderIndex 內存入 餘數 → 当前 fractional 長度 // 記錄位置\n    Decision: 餘數是否已重複? // 判斷是否需要打入括號\n        Yes → Step 16: 將 fractional 切割為 nonRepeat = 前面至重複開始位置, repeat = 後面部分\n                 // 設定不重複與重複部分\n        No  → Step 17: 將 digit 加入 fractional // 追加小數位\n        // 循環結束後\n\nAfter loop:\n→ Decision: 餘數是否為0? // 若為0則結束\n    Yes → Step 18: 結果 = (符號)+整數部分 + \".\" + fractional // 組成完整結果\n    No → Step 19: 結果 = (符號)+整數部分 + \".\" + nonRepeat + \"(\" + repeat + \")\" // 加上括號\n\n→ Step 20: 輸出結果 // 顯示最終字符串\nEnd // 程式結束\n\nNeed to ensure correct formatting with arrows and indentation. Provide decisions with indentation maybe 4 spaces. Provide each line with virtual step and // explanation.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Decision: 分子是否為 0? // 檢查分子是否為零\n    Yes → Step 1: 輸出 \"0\" // 若為零，直接輸出結果並結束\n    No  → Continue // 否則進行下一步\n→ Step 2: 判斷符號 // 透過分子與分母符號判斷結果是否為負數\n→ Step 3: 取得絕對值 // 將分子與分母都轉成正整數以簡化後續運算\n→ Step 4: 計算整數部分 // 整數 = 分子 ÷ 分母\n→ Step 5: 計算餘數 // 餘數 = 分子 % 分母\n→ Decision: 餘數是否為 0? // 判斷是否存在小數部分\n    Yes → Step 6: 組合結果 = (符號) + 整數部分 // 結果為純整數，直接結合並輸出\n    No  → Continue // 否則進入小數部分處理\n→ Step 7: 初始化 fractional = \"\" // 用於存放小數位\n→ Step 8: 初始化 remainderIndex = {} // 用於記錄每個餘數首次出現的位置\n→ Decision: 餘數是否為 0? // 判斷是否需要進入循環\n    Yes → Break // 若餘數為 0，跳出循環\n    No  → Continue // 否則進行循環\n→ Step 9: 乘以 10 // 餘數 = 餘數 * 10，準備計算下一位小數\n→ Step 10: 計算 digit = 餘數 ÷ 分母 // 取得下一位小數\n→ Step 11: 更新餘數 = 餘數 % 分母 // 取得新的餘數\n→ Decision: 餘數是否已存在於 remainderIndex? // 判斷是否出現重複\n    Yes → Step 12: 重複起點 = remainderIndex[餘數] // 找到重複區間起點\n    No  → Step 13: remainderIndex[餘數] = length(fractional) // 記錄餘數首次出現的位置\n→ Decision: 餘數是否已重複? // 判斷是否需要插入括號\n    Yes → Step 14: nonRepeat = substring(fractional, 0, 重複起點) // 前部分\n           Step 15: repeat = substring(fractional, 重複起點) // 循環部分\n           Break // 結束循環\n    No  → Step 16: append digit to fractional // 將 digit 加入小數位\n    // 循環結束後再次判斷餘數是否為 0\n→ Decision: 餘數是否為 0? // 判斷是否已無循環\n    Yes → Step 17: 結果 = (符號) + 整數部分 + \".\" + fractional // 結合整數與完整小數\n    No  → Step 18: 結果 = (符號) + 整數部分 + \".\" + nonRepeat + \"(\" + repeat + \")\" // 加入括號表示重複\n→ Step 19: 輸出結果 // 顯示最終字串\nEnd // 程式結束執行\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return \"0\"\n        res = []\n        # 處理符號\n        if (numerator < 0) ^ (denominator < 0):\n            res.append(\"-\")\n        numerator, denominator = abs(numerator), abs(denominator)\n        # 整數部分\n        res.append(str(numerator // denominator))\n        remainder = numerator % denominator\n        if remainder == 0:\n            return \"\".join(res)\n        res.append(\".\")\n        seen = {}\n        # 小數部分\n        while remainder != 0:\n            if remainder in seen:\n                idx = seen[remainder]\n                res.insert(idx, \"(\")\n                res.append(\")\")\n                break\n            seen[remainder] = len(res)\n            remainder *= 10\n            res.append(str(remainder // denominator))\n            remainder %= denominator\n        return \"\".join(res)\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    numerator, denominator = nums[0], nums[1]\n    solution = Solution()\n    result = solution.fractionToDecimal(numerator, denominator)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numerator = 1, denominator = 2",
          "expected_output": "\"0.5\"",
          "success": true,
          "output": "0.5"
        },
        {
          "example_index": 1,
          "input": "numerator = 2, denominator = 1",
          "expected_output": "\"2\"",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "numerator = 4, denominator = 333",
          "expected_output": "\"0.(012)\"",
          "success": true,
          "output": "0.(012)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode30.json",
    "problem_index_in_file": 0,
    "title": "Substring with Concatenation of All Words",
    "description_snippet": "You are given a string s and an array of strings words. All the strings of words are of the same len...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: given string s and words array of same length. Find all starting indices of concatenated substrings formed by all words concatenated in any order.\n\nClassic LeetCode problem: Find All Substring Concatenation of All Words.\n\nWe need to produce virtual code steps line by line with explanation after //. Use Start, End, Decision, etc.\n\nWe need to outline algorithm: Let wordLen = length of each word; wordCount = words.length; totalLen = wordLen*wordCount. Build frequency map of words. For each offset from 0 to wordLen-1, use sliding window of size totalLen over s. Use hash map windowCount. For i from offset to s.length - wordLen step 1, extract word, update counts. Keep left pointer. If window size > wordCount, remove leftmost word. If counts match target, record left index. Complexity O(s.length * wordLen). Provide virtual code steps.\n\nWe produce each line as e.g.:\n\nStart // 程式開始執行\n→ Step 1: 計算 wordLen、wordCount、totalLen // 取得關鍵參數\n→ Step 2: 建立 wordsCount map // 記錄每個單詞出現次數\n→ Decision: s 長度是否小於 totalLen? // 無法匹配\n    Yes → End // 結束\n    No  → \n→ For offset in 0..wordLen-1: // 以不同起始位移遍歷\n    → 初始化 left = offset, count = 0, windowCount = 空\n    → For i from offset; i+wordLen <= s.length; i += 1: // 每次滑動一個字元\n        → Step 3: currentWord = s.substr(i, wordLen) // 取得滑動窗口內單詞\n        → If currentWord in wordsCount: // 有效單詞\n            → Increment windowCount[currentWord] // 進入窗口\n            → count += 1 // 進入窗口的單詞數\n        → Else: // 非單詞\n            → Reset windowCount = 空\n            → count = 0\n            → left = i + wordLen\n            → Continue\n        → While windowCount[currentWord] > wordsCount[currentWord]: // 超過目標次數\n            → leftWord = s.substr(left, wordLen)\n            → Decrement windowCount[leftWord]\n            → left += wordLen\n            → count -= 1\n        → If count == wordCount: // 窗口大小正好\n            → Record left // 存儲起始索引\n    → End For\n→ End For\nEnd // 程式結束\n\nNeed to follow exact format: each line '虛擬碼步驟' + space + '// 解釋/說明'. Use arrow. Use Start, End, Decision: . Ensure each line ends with explanation. Use indent? Not necessary.\n\nWe must be careful: use 虛擬碼步驟 like \"→ Step 1: ...\" as shown. Use Decision with indentation. The sample uses indentation with spaces. We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 計算 wordLen = words[0].length，wordCount = words.length，totalLen = wordLen * wordCount // 取得關鍵參數\n→ Step 2: 建立 wordsCount 目標頻率表 // 記錄每個單詞應出現的次數\n    ← For each word in words:\n        ← Increment wordsCount[word]\nDecision: 如果 s.length < totalLen? // 若 s 太短則無法匹配\n    Yes → End // 結束程式\n    No  →\n→ For offset = 0; offset < wordLen; offset++: // 以不同起始位移遍歷\n    → 初始化 left = offset，count = 0，windowCount 為空頻率表 // 左側指標與窗口統計\n    → For i = offset; i + wordLen <= s.length; i++: // 每個字符滑動一次\n        → currentWord = s.substr(i, wordLen) // 取得滑動窗口內的單詞\n        Decision: currentWord 是否在 wordsCount? // 判斷是否為合法單詞\n            Yes →\n                → Increment windowCount[currentWord] // 將單詞加入窗口\n                → count += 1 // 窗口中單詞總數加一\n            No →\n                → Reset windowCount 為空，count = 0 // 非合法單詞，重置窗口\n                → left = i + wordLen // 將左指標移到下一個位置\n                → Continue // 跳過後續判斷直接進入下一次迭代\n        → Decision: windowCount[currentWord] > wordsCount[currentWord]? // 檢查是否超出目標次數\n            Yes →\n                ← While windowCount[currentWord] > wordsCount[currentWord]:\n                    ← leftWord = s.substr(left, wordLen) // 取左側單詞\n                    ← Decrement windowCount[leftWord] // 從窗口中移除\n                    ← left += wordLen // 左指標右移一個單詞長度\n                    ← count -= 1 // 窗口中單詞總數減一\n            No →\n        → Decision: count == wordCount? // 窗口是否正好包含所有單詞\n            Yes →\n                → Record left // 將左指標加入答案列表\n            No →\n    → End For\n→ End For\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict, Counter\n\nclass Solution:\n    def findSubstring(self, s: str, words) -> list:\n        if not s or not words:\n            return []\n\n        word_len = len(words[0])\n        word_count = len(words)\n        total_len = word_len * word_count\n        if len(s) < total_len:\n            return []\n\n        freq = Counter(words)\n        result = []\n\n        for offset in range(word_len):\n            left = offset\n            right = offset\n            window_counts = defaultdict(int)\n            matched = 0\n\n            while right + word_len <= len(s):\n                word = s[right:right + word_len]\n                right += word_len\n\n                if word in freq:\n                    window_counts[word] += 1\n                    matched += 1\n\n                    while window_counts[word] > freq[word]:\n                        left_word = s[left:left + word_len]\n                        window_counts[left_word] -= 1\n                        matched -= 1\n                        left += word_len\n\n                    if matched == word_count:\n                        result.append(left)\n                else:\n                    # reset window\n                    window_counts.clear()\n                    matched = 0\n                    left = right\n\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    s = \"\"\n    words = []\n\n    if data:\n        # Extract the string s\n        m_s = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n        if m_s:\n            s = m_s.group(1)\n\n        # Extract the words list\n        m_w = re.search(r'words\\s*=\\s*\\[([^\\]]*)\\]', data)\n        if m_w:\n            words_part = m_w.group(1)\n            words = re.findall(r'\"([^\"]*)\"', words_part)\n\n    sol = Solution()\n    res = sol.findSubstring(s, words)\n    print(res)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "success": true,
          "output": "[0, 9]"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "success": true,
          "output": "[6, 9, 12]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode553.json",
    "problem_index_in_file": 0,
    "title": "Optimal Division",
    "description_snippet": "You are given an integer array nums. The adjacent integers in nums will perform the float division.\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving problem: given integer array nums, need to arrange parentheses to maximize value of nested division. Classic problem: maximize division by putting all numbers after first in denominator as a single division: i.e., expression: nums[0] / (nums[1] / nums[2] / ... / nums[n-1]) if n>2. For n=1 return nums[0], for n=2 return \"nums[0]/nums[1]\". Implementation: handle cases. We output virtual code lines with explanation. Steps: Start, Input, Determine length, if length 1: result=string(nums[0]), else if length 2: result=nums[0] + \"/\" + nums[1], else build string: start with nums[0] + \"/\", then open \"(\" + nums[1], then for each subsequent number from index 2 to end: add \"/\" + nums[i], then close \")\". Return result. No redundant parentheses: only parentheses around the denominator part. That is standard.\n\nWe need to output line by line with arrow. Use Start, End, Decision. Provide explanation after //.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收整數陣列 nums // 取得輸入資料  \n→ Decision: nums 長度是否等於 1? // 檢查特殊情況  \n    Yes → Step 2: 結果 = string(nums[0]) // 單一數字直接回傳  \n    No  → Decision: nums 長度是否等於 2? // 檢查兩個數字的情況  \n        Yes → Step 3: 結果 = string(nums[0]) + \"/\" + string(nums[1]) // 直接寫成除法  \n        No  → Step 4: 初始化結果 = string(nums[0]) + \"/\" + \"(\" + string(nums[1]) // 開始建構括號內的表達式，首項作除數  \n            → Loop i 從 2 到 nums.length-1  \n                Step 5: 結果 += \"/\" + string(nums[i]) // 加入後續數字的除法符號  \n            → Step 6: 結果 += \")\" // 關閉括號，完成分式  \n→ Step 7: 回傳結果 // 輸出最終表達式  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def optimalDivision(self, nums):\n        \"\"\"\n        Return the division expression with the maximum possible value.\n        For a single number, return it as a string.\n        For two numbers, return \"a/b\".\n        For three or more, wrap the denominator part in parentheses.\n        \"\"\"\n        n = len(nums)\n        if n == 1:\n            return str(nums[0])\n        if n == 2:\n            return f\"{nums[0]}/{nums[1]}\"\n        # For n >= 3, place all numbers after the first in one denominator\n        denom = \"/\".join(map(str, nums[1:]))\n        return f\"{nums[0]}/({denom})\"\n\nif __name__ == \"__main__\":\n    # Read the whole input from stdin and strip whitespace\n    data = sys.stdin.read().strip()\n    # Safely evaluate the input string as a Python literal (list of ints)\n    nums = ast.literal_eval(data)\n    # Create Solution instance and compute the optimal expression\n    result = Solution().optimalDivision(nums)\n    # Print the resulting string\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1000,100,10,2]",
          "expected_output": "\"1000/(100/10/2)\"",
          "success": true,
          "output": "1000/(100/10/2)"
        },
        {
          "example_index": 1,
          "input": "[2,3,4]",
          "expected_output": "\"2/(3/4)\"",
          "success": true,
          "output": "2/(3/4)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode368.json",
    "problem_index_in_file": 0,
    "title": "Largest Divisible Subset",
    "description_snippet": "Given a set of distinct positive integers nums, return the largest subset answer such that every pai...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps with explanations. The user wants solution for Largest Divisible Subset. So produce algorithm: sort nums, dp for largest divisible subset, reconstruct.\n\nNeed to produce step-by-step pseudocode lines, each with explanation. Use arrows. The format: Start, Step lines, Decision lines, Yes/No arrows, End. Should be per line. Provide code lines like \"Step 1: Sort nums ascending\". Explanation: \"將數字升序排列\" etc.\n\nLet's outline steps:\n\nStart\n→ Step 1: Sort nums ascending // Sorting\n→ Step 2: Initialize dp array length n with 1 // 每個位置至少包含自身\n→ Step 3: Initialize prev array length n with -1 // 用於回溯\n→ Decision: For i from 0 to n-1 // iterate\n    → Step 4: For j from 0 to i-1 // check earlier\n        → Decision: If nums[i] % nums[j] == 0 // divisibility\n            Yes → Step 5: If dp[j] + 1 > dp[i] // update longer\n                → Step 6: dp[i] = dp[j] + 1\n                → Step 7: prev[i] = j\n            No → (nothing)\n    → (end inner)\n→ Decision: Find index maxIdx where dp[maxIdx] is maximum // find longest subset\n    Yes → Step 8: Build result list by tracing prev from maxIdx\n        → Step 9: While idx != -1\n            → Step 10: Append nums[idx] to result\n            → Step 11: idx = prev[idx]\n        → Step 12: Reverse result // to maintain ascending order\n→ End\n\nNeed to add explanation after each line. Use arrow arrow formatting. The \"Decision:\" line should include arrow options. We need to show \"Yes →\" and \"No →\" branches.\n\nLet's produce lines accordingly. Use consistent formatting. Ensure each line includes explanation after space then //.\n\nWe should incorporate nested decisions correctly. Provide lines for inner loops. Provide \"Step\" numbering? Not necessary but helpful. Use \"Step\" labels.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先將數字按大小升序排列，方便後續判斷可被整除  \n→ Step 2: Initialize dp array length n with 1 // dp[i] 代表以 nums[i] 為結尾的最大可整除子集大小  \n→ Step 3: Initialize prev array length n with -1 // prev[i] 追蹤 dp[i] 的前驅索引，便於回溯子集  \n→ Decision: For i from 0 to n-1 // 遍歷每個元素作為子集結尾  \n    Yes → Step 4: For j from 0 to i-1 // 檢查之前的所有元素  \n        → Decision: If nums[i] % nums[j] == 0 // 判斷 nums[i] 是否能被 nums[j] 整除  \n            Yes → Step 5: If dp[j] + 1 > dp[i] // 若加入 nums[i] 可使子集更長  \n                → Step 6: dp[i] = dp[j] + 1 // 更新 dp[i]  \n                → Step 7: prev[i] = j // 記錄前驅索引  \n            No → (No action) // 不滿足可整除條件，忽略  \n        No → (No action) // j 的範圍結束  \n    → (內層循環結束)  \n→ Decision: Find index maxIdx where dp[maxIdx] is maximum // 找到最長子集的結尾索引  \n    Yes → Step 8: Initialize result list empty // 準備回溯子集  \n    Yes → Step 9: Set idx = maxIdx // 從最大索引開始回溯  \n    → Decision: While idx != -1 // 追蹤 prev 索引直到結束  \n        Yes → Step 10: Append nums[idx] to result // 加入當前元素  \n        Yes → Step 11: idx = prev[idx] // 移至前驅  \n        No → (循環結束)  \n    → (回溯結束)  \n→ Step 12: Reverse result // 反轉以得到遞增順序的子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def largestDivisibleSubset(self, nums):\n        if not nums:\n            return []\n        nums.sort()\n        n = len(nums)\n        dp = [1] * n\n        prev = [-1] * n\n        max_index = 0\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n            if dp[i] > dp[max_index]:\n                max_index = i\n\n        res = []\n        while max_index >= 0:\n            res.append(nums[max_index])\n            max_index = prev[max_index]\n\n        return res[::-1]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if raw_input.startswith(\"nums\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n    nums = ast.literal_eval(raw_input)\n    solution = Solution()\n    result = solution.largestDivisibleSubset(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,4,8]",
          "expected_output": "[1,2,4,8]",
          "success": true,
          "output": "[1, 2, 4, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode705.json",
    "problem_index_in_file": 0,
    "title": "Design HashSet",
    "description_snippet": "Design a HashSet without using any built-in hash table libraries.\n\nImplement MyHashSet class:\n\nvoid ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps, each line with explanation, using Start, End, Decision, etc. Provide a step-by-step algorithm for implementing a hash set without built-in hash table libraries. We can use array of buckets (e.g., array of linked lists). Use simple hash function mod number of buckets. Provide operations add, contains, remove.\n\nThe virtual code should be line by line, each line includes virtual code step and comment.\n\nWe need to cover initialization, add, contains, remove.\n\nWe'll produce pseudocode, not actual code. Use \"Step X:\" etc. Let's design:\n\nStart\n→ Step 1: Initialize bucket array of size N // create array of buckets\n→ Step 2: For each bucket, set to empty list // each bucket holds keys\n\nThen methods:\n\nStep 3: Define hash(key) = key mod N // simple hash function\n\nAdd:\n→ Step 4: Compute idx = hash(key) // get bucket index\n→ Step 5: Check if key exists in bucket[idx] // search linked list\n    Yes → Step 6: Return // key already present, do nothing\n    No  → Step 7: Append key to bucket[idx] // insert\n\nContains:\n→ Step 8: Compute idx = hash(key)\n→ Step 9: Search bucket[idx] for key\n    Yes → Step 10: Return true\n    No  → Step 11: Return false\n\nRemove:\n→ Step 12: Compute idx = hash(key)\n→ Step 13: Search bucket[idx] for key\n    Yes → Step 14: Remove key from bucket[idx] // delete from list\n    No  → Step 15: Return // key not present, do nothing\n\nWe may also discuss rehashing when load factor too high, but not necessary.\n\nLet's produce lines in required format:\n\nStart // 程式開始執行\n→ Step 1: Create array buckets[N] // 建立固定大小的桶陣列\n→ Step 2: For i in 0..N-1: buckets[i] ← empty list // 每個桶初始化為空鏈表\n→ Step 3: Define function hash(key) → key mod N // 計算鍵的哈希值\n→ Step 4: Method add(key):\n    → Step 4a: idx ← hash(key) // 找到對應桶\n    → Step 4b: If key in buckets[idx]: // 檢查是否已存在\n        Yes → Step 4c: Return // 已存在，無需插入\n        No  → Step 4d: Append key to buckets[idx] // 新增到桶\n→ Step 5: Method contains(key):\n    → Step 5a: idx ← hash(key) // 找到桶\n    → Step 5b: If key in buckets[idx]: // 搜尋\n        Yes → Step 5c: Return true // 找到，返回真\n        No  → Step 5d: Return false // 未找到，返回假\n→ Step 6: Method remove(key):\n    → Step 6a: idx ← hash(key) // 找到桶\n    → Step 6b: If key in buckets[idx]: // 確認存在\n        Yes → Step 6c: Remove key from buckets[idx] // 刪除\n        No  → Step 6d: Return // 不存在，無需操作\nEnd // 程式執行結束\n\nNeed to ensure format exactly: each line contains \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow arrows. For multi-step we can indent? Format shows indentation not required. We can use bullet steps with indent. Let's produce each line as separate line. For nested steps, we could still keep each line separate but with indentation maybe not needed. We can use numbering to indicate substeps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Create array buckets[N] // 建立固定大小的桶陣列  \n→ Step 2: For i in 0..N-1: buckets[i] ← empty list // 每個桶初始化為空鏈表  \n→ Step 3: Define function hash(key) → key mod N // 計算鍵的哈希值  \n→ Step 4: Method add(key): // 加入元素  \n    → Step 4a: idx ← hash(key) // 找到對應桶索引  \n    → Step 4b: If key in buckets[idx]: // 檢查是否已存在  \n        Yes → Step 4c: Return // 已存在，直接返回  \n        No  → Step 4d: Append key to buckets[idx] // 新增鍵到桶中  \n→ Step 5: Method contains(key): // 判斷是否存在  \n    → Step 5a: idx ← hash(key) // 找到對應桶索引  \n    → Step 5b: If key in buckets[idx]: // 搜尋鍵  \n        Yes → Step 5c: Return true // 找到，返回真  \n        No  → Step 5d: Return false // 未找到，返回假  \n→ Step 6: Method remove(key): // 刪除元素  \n    → Step 6a: idx ← hash(key) // 找到對應桶索引  \n    → Step 6b: If key in buckets[idx]: // 確認鍵存在  \n        Yes → Step 6c: Remove key from buckets[idx] // 從鏈表中刪除  \n        No  → Step 6d: Return // 不存在，無需操作  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyHashSet:\n    def __init__(self):\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        h = self._hash(key)\n        if key not in self.buckets[h]:\n            self.buckets[h].append(key)\n\n    def remove(self, key: int) -> None:\n        h = self._hash(key)\n        if key in self.buckets[h]:\n            self.buckets[h].remove(key)\n\n    def contains(self, key: int) -> bool:\n        h = self._hash(key)\n        return key in self.buckets[h]\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyHashSet\":\n            obj = MyHashSet()\n            result.append(None)\n        elif op == \"add\":\n            obj.add(arg[0])\n            result.append(None)\n        elif op == \"remove\":\n            obj.remove(arg[0])\n            result.append(None)\n        elif op == \"contains\":\n            res = obj.contains(arg[0])\n            result.append(res)\n        else:\n            # Unsupported operation\n            result.append(None)\n\n    # Convert Python None/True/False to JSON null/true/false\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]",
          "expected_output": "[null, null, null, true, false, null, true, null, false]",
          "success": true,
          "output": "[null, null, null, true, false, null, true, null, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode645.json",
    "problem_index_in_file": 0,
    "title": "Set Mismatch",
    "description_snippet": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. The algorithm: we can compute sum and sum of squares difference, or we can use hash set. Simpler: iterate, track seen, find duplicate; also find missing by computing expected sum. We'll produce virtual code steps. We'll mention arrays and variables. Output format lines. Let's do Start, Steps, etc.\n\nWe'll produce steps:\n\nStart\n→ Step 1: initialize duplicate = -1, missing = -1, seen = empty set // prepare\n→ Step 2: iterate over nums with index i // loop\n   → Decision: if nums[i] in seen? // check duplicate\n       Yes → duplicate = nums[i] // record duplicate\n   → Decision: else → add nums[i] to seen // add to set\n→ Step 3: compute expectedSum = n*(n+1)/2 // sum 1..n\n→ Step 4: compute actualSum = sum(nums) // sum array\n→ Step 5: missing = expectedSum - (actualSum - duplicate) // derived missing\n→ Step 6: return [duplicate, missing] // result\nEnd\n\nAdd explanation comments after each line. Provide arrow notation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 duplicate = -1, missing = -1, seen = 空集合 // 準備存儲重複值、缺失值與已見數字  \n→ Step 2: 對 nums 中每個數字 nums[i] 進行迴圈 // 遍歷整個陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: nums[i] 是否已在 seen 中? // 判斷是否為重複項  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → duplicate = nums[i] // 若已存在，記錄為重複數字  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → add nums[i] 到 seen // 否則加入已見集合  \n→ Step 3: 計算期望總和 expectedSum = n*(n+1)/2 // 1 到 n 的理論總和  \n→ Step 4: 計算實際總和 actualSum = sum(nums) // 取得錯誤後陣列的總和  \n→ Step 5: 計算缺失數 missing = expectedSum - (actualSum - duplicate) // 透過差值求得缺失數  \n→ Step 6: 回傳 [duplicate, missing] // 返回結果陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findErrorNums(self, nums):\n        \"\"\"\n        找出重複的數字和缺失的數字。\n\n        先利用集合去除重複，得到唯一元素的集合。\n        1. duplicate = sum(nums) - sum(unique_set)\n           這是所有元素之和減去唯一元素之和，得到重複的數字。\n        2. missing = n*(n+1)//2 - sum(unique_set)\n           n 是陣列長度，1~n 的理論總和減去唯一元素之和，即缺失的數字。\n        \"\"\"\n        n = len(nums)\n        unique_set = set(nums)\n        duplicate = sum(nums) - sum(unique_set)\n        missing = n * (n + 1) // 2 - sum(unique_set)\n        return [duplicate, missing]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取整數列表。\n    支援類似 'nums = [1,2,2,4]' 或僅有 '[1,2,2,4]' 的格式。\n    \"\"\"\n    # 找出第一個 '[' 到最後一個 ']' 的子字串\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group(0)\n    else:\n        # 若沒有找到，回傳空列表\n        nums_str = '[]'\n    # 用 literal_eval 安全解析列表\n    return ast.literal_eval(nums_str)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 解析出整數列表\n    nums = parse_input(raw_input)\n    # 呼叫解法並取得結果\n    solution = Solution()\n    result = solution.findErrorNums(nums)\n    # 將結果以列表形式輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,4]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode458.json",
    "problem_index_in_file": 0,
    "title": "Poor Pigs",
    "description_snippet": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out wh...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code with explanations line by line. The problem is \"determine number of pigs\" as known problem: Given buckets, minutesToDie, minutesToTest, we can perform tests in rounds. Number of rounds = floor(minutesToTest / minutesToDie) + 1? Actually standard problem: number of rounds = minutesToTest / minutesToDie (integer division). Each pig can represent base (rounds+1). We need to find smallest pigs such that (rounds+1)^pigs >= buckets. So pseudocode: compute rounds, then minimal pigs = ceil(log(buckets)/log(rounds+1)). Implementation steps: compute rounds = minutesToTest / minutesToDie; base = rounds+1; compute pigs by loop multiply until >= buckets. Or use math. Provide pseudo-code line by line. Use Start, End, Decision. Provide explanation comments. So output lines like:\n\nStart // 程式開始\n→ Step 1: 計算 可進行的測試輪次 // ... etc\n\nLet's craft.\n\nNeed to keep arrow notation. Use \"→\" before each step, indentation for decisions.\n\nPseudo-code steps:\n\nStart\n→ Step 1: 計算 rounds = minutesToTest / minutesToDie // 取得可進行的完整測試輪次\n→ Step 2: 設置 base = rounds + 1 // 每隻豬在每輪中可以代表的狀態數\n→ Decision: 如果 buckets <= 1? // 只需 0 或 1 隻豬\n    Yes → Step 3: 輸出 0 // 沒有毒桶或只有一個，無需豬\n    No → Step 4: 設置 pigs = 0 // 初始化豬數\n→ Step 5: 計算 result = 1 // 用於累乘計算可辨識的桶數\n→ Decision: result < buckets? // 需要更多豬？\n    Yes → Step 6: pigs = pigs + 1 // 增加一隻豬\n    → Step 7: result = result * base // 乘以基數\n    → Decision: result < buckets? // 仍需更多？\n        Yes → (loop back to Step 6)\n        No → Step 8: 輸出 pigs // 最終所需豬數\n→ End\n\nBut we need to use arrow style. Might use loop arrow.\n\nLet's produce in proper format.\n\nWe need to output step by step with \"→\" at each line. Use indent for Decision branches.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 rounds = minutesToTest ÷ minutesToDie // 取得可完整進行的測試輪數  \n→ Step 2: 設置 base = rounds + 1 // 每隻豬在所有輪次中可代表的不同狀態數  \n→ Decision: 如果 buckets <= 1? // 只有一個或沒有桶時不需要豬  \n  Yes → Step 3: 輸出 0 // 無需任何豬即可判斷  \n  No  → Step 4: 設置 pigs = 0 // 初始化所需豬數  \n→ Step 5: 設置 result = 1 // 用於累積可辨識的桶數  \n→ Decision: result < buckets? // 是否仍需更多豬？  \n  Yes → Step 6: pigs = pigs + 1 // 增加一隻豬  \n   → Step 7: result = result × base // 乘上基數更新可辨識桶數  \n   → Decision: result < buckets? // 再次判斷是否足夠  \n    Yes → (跳回 Step 6) // 仍需更多豬，重複循環  \n    No  → Step 8: 輸出 pigs // 已達足夠辨識數量，輸出所需豬數  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_pigs(buckets: int, minutes_to_die: int, minutes_to_test: int) -> int:\n    \"\"\"\n    計算在給定時間內辨識毒桶所需的最少豬數。\n    \"\"\"\n    rounds = minutes_to_test // minutes_to_die          # 可進行的完整測試輪次\n    base = rounds + 1                                  # 每隻豬能表示的不同狀態數\n    pigs = 0\n    while base ** pigs < buckets:                      # 直到可辨識的桶數 ≥ 所有桶\n        pigs += 1\n    return pigs\n\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取三個整數 (buckets, minutesToDie, minutesToTest)。\n    輸入格式可為任意文字加上數字，程式會自動擷取三個整數。\n    \"\"\"\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 3:\n        return  # 無法取得足夠資訊，直接結束\n    buckets, minutes_to_die, minutes_to_test = nums[:3]\n    result = min_pigs(buckets, minutes_to_die, minutes_to_test)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 15",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 30",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode49.json",
    "problem_index_in_file": 0,
    "title": "Group Anagrams",
    "description_snippet": "Given an array of strings strs, group the anagrams together. You can return the answer in any order....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for grouping anagrams. Use virtual code lines with comments. Let's outline algorithm: Use hash map with sorted string key. Iterate array, sort each string to key, push original string into list. Finally output values.\n\nLet's produce step by step. Use Start, End. Provide arrow lines. Use Decision for sorting maybe.\n\nLet's produce.\n\nWe'll write:\n\nStart\n\n→ Step 1: Initialize map key->list\n\n→ Step 2: For each string s in array\n\n   → Step 3: Sort characters of s to get key\n\n   → Step 4: If key not in map, create new list\n\n   → Step 5: Append s to map[key]\n\n→ Step 6: Collect all lists from map into result array\n\nEnd\n\nLet's add details.\n\nWe need to use arrow lines: \"→\". Provide explanation after //.\n\nAlso include Decision lines maybe for checking key presence. Use \"Decision:\".\n\nSo:\n\nStart // 程式開始執行\n\n→ Step 1: 建立空字典 groups // 用於儲存以排序字串為鍵的分組\n\n→ Step 2: 遍歷輸入陣列 strs 中的每個字串 s // 處理每個字串\n\n    → Step 3: 取字串 s 的字元，並按字母序排序得到 key // 排序後的字串作為鍵\n\n    → Decision: key 是否已在 groups 中？ // 判斷是否已有此鍵\n\n        Yes → Step 4a: 取得 groups[key] 並將 s 加入該列表 // 將字串加入已存在的分組\n\n        No  → Step 4b: 在 groups 中建立新鍵 key，並以 [s] 初始化列表 // 新鍵，先加入字串\n\n→ Step 5: 初始化結果陣列 result = [] // 用於儲存最終的分組\n\n→ Decision: groups 是否為空？ // 檢查是否有任何分組\n\n    Yes → Step 6a: result = [] // 若無分組，結果為空\n\n    No  → Step 6b: 循環遍歷 groups 中每個 key 的值，將列表 push 進 result // 將每個分組加入結果\n\nEnd // 程式執行結束\n\nBut maybe we don't need the Decision for empty. Simplify.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 groups // 用於儲存以排序字串為鍵的分組  \n→ Step 2: 遍歷輸入陣列 strs 中的每個字串 s // 處理每個字串  \n  → Step 3: 取得 s 的字元並按字母序排序得到 key // 排序後的字串作為鍵  \n  → Decision: key 是否已在 groups 中？ // 判斷是否已有此鍵  \n    Yes → Step 4a: 取得 groups[key] 並將 s 加入該列表 // 將字串加入已存在的分組  \n    No  → Step 4b: 在 groups 中建立新鍵 key，並以 [s] 初始化列表 // 新鍵，先加入字串  \n→ Step 5: 初始化結果陣列 result = [] // 用於儲存最終的分組  \n→ Step 6: 循環遍歷 groups 中的每個 key，將對應的列表 push 進 result // 將每個分組加入結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            # Use sorted string as key to group anagrams\n            key = tuple(sorted(s))\n            anagrams[key].append(s)\n        # Convert defaultdict values to a list of lists\n        return list(anagrams.values())\n\ndef parse_input(raw):\n    \"\"\"\n    Parse the raw input string from stdin.\n    Expected formats:\n        - 'strs = [\"eat\",\"tea\",\"tan\"]'\n        - '[\"eat\",\"tea\",\"tan\"]'\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return []\n    if '=' in raw:\n        # Split on the first '='\n        _, expr = raw.split('=', 1)\n        raw = expr.strip()\n    # Safely evaluate the list expression\n    return ast.literal_eval(raw)\n\ndef main():\n    raw_input = sys.stdin.read()\n    strs = parse_input(raw_input)\n\n    solution = Solution()\n    grouped = solution.groupAnagrams(strs)\n\n    # Use json.dumps to output double-quoted JSON format\n    print(json.dumps(grouped))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
          "success": true,
          "output": "[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]"
        },
        {
          "example_index": 1,
          "input": "strs = [\"\"]",
          "expected_output": "[[\"\"]]",
          "success": true,
          "output": "[[\"\"]]"
        },
        {
          "example_index": 2,
          "input": "strs = [\"a\"]",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[[\"a\"]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode546.json",
    "problem_index_in_file": 0,
    "title": "Remove Boxes",
    "description_snippet": "You are given several boxes with different colors represented by different positive numbers.\n\nYou ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for the problem \"remove boxes\" classic DP. We must output virtual code line by line, each line with explanation. Not actual code. Use Start, End, Decision. We'll produce algorithm outline: recursion with memoization DP(l,r,k). Steps: Start, input array, call solve(0,n-1,0). Decision: if l>r return 0. Step: merge same color at right? Standard. But we can produce high-level steps.\n\nWe need to produce step-by-step pseudo with explanation. Probably include recursive function definition, base case, merging identical color at end, loop to try splitting.\n\nWe'll keep lines: Start, → Step: Define function DP(l,r,k). etc.\n\nEnsure each line ends with comment // explanation.\n\nLet's draft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 讀取盒子顏色陣列 boxes[0..n-1] // 取得所有盒子顏色資訊  \n→ Step: 呼叫 DP(0, n-1, 0) 並輸出結果 // 計算從整個陣列開始的最大分數  \n\n// 定義遞迴函式 DP(l, r, k)：l~r 為目前考慮的子陣列，k 為右側連續與 boxes[r] 同色盒子數  \n→ Function: DP(l, r, k)  \n  → Decision: 如果 l > r? // 子陣列為空  \n    Yes → Return 0 // 無盒子可移除，得分為 0  \n    No → 繼續  \n  → Step: 先將右端相同顏色的盒子合併進 k  \n    While r > l AND boxes[r] == boxes[r-1]  \n      k ← k + 1  \n      r ← r - 1  \n      // 把右側相同顏色的盒子算進一次移除的 k  \n  → Step: 將當前子陣列剩餘盒子右端的同色盒子全部移除  \n    Score1 ← DP(l, r-1, 0) + (k+1)*(k+1)  \n    // 先把右端的 (k+1) 個同色盒子一次性移除，再處理左側  \n  → Decision: 是否嘗試把某個中間同色盒子與右端合併？ // 以尋找更高分  \n    Yes → For i = l to r-1  \n      If boxes[i] == boxes[r]  \n        Score2 ← DP(l, i, k+1) + DP(i+1, r-1, 0)  \n        // 把 i 位置的盒子與右端的 (k+1) 個同色盒子合併，先處理左側再右側  \n        Result ← max(Result, Score2)  \n      End For  \n    No → Result ← Score1 // 不合併，直接使用 Score1  \n  → Return Result // 傳回此子問題的最大分數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\n# Increase recursion depth for deep recursion in DP\nsys.setrecursionlimit(10000)\n\nclass Solution:\n    def removeBoxes(self, boxes):\n        memo = {}\n        n = len(boxes)\n\n        def dp(l, r, k):\n            if l > r:\n                return 0\n            if (l, r, k) in memo:\n                return memo[(l, r, k)]\n\n            # 合併右端相同顏色的盒子\n            while r > l and boxes[r] == boxes[r - 1]:\n                r -= 1\n                k += 1\n\n            # 直接把右端（k+1）個同色盒子一次移除\n            res = dp(l, r - 1, 0) + (k + 1) ** 2\n\n            # 嘗試將左側相同顏色的盒子與右端合併，尋找更高分\n            for i in range(l, r):\n                if boxes[i] == boxes[r]:\n                    res = max(res, dp(l, i, k + 1) + dp(i + 1, r - 1, 0))\n\n            memo[(l, r, k)] = res\n            return res\n\n        return dp(0, n - 1, 0)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入：允許格式如 \"boxes = [1,2,3]\" 或直接 \"[1,2,3]\"\n    if \"=\" in raw_input:\n        _, arr_str = raw_input.split(\"=\", 1)\n    else:\n        arr_str = raw_input\n\n    # 使用安全的字面解析\n    try:\n        boxes = ast.literal_eval(arr_str.strip())\n    except Exception as e:\n        print(\"Invalid input format\", file=sys.stderr)\n        sys.exit(1)\n\n    # 計算並輸出最大分數\n    solution = Solution()\n    result = solution.removeBoxes(boxes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "boxes = [1,3,2,2,2,3,4,3,1]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        },
        {
          "example_index": 1,
          "input": "boxes = [1,1,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "boxes = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode488.json",
    "problem_index_in_file": 0,
    "title": "Zuma Game",
    "description_snippet": "You are playing a variation of the game Zuma. \nIn this variation of Zuma, there is a single row of c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate pseudocode step by step. It's a variation of Zuma. Problem: given board string and hand string, find minimal insertions to clear board or -1. Classic Leetcode 488 Zuma Game. Approach: DFS with state memoization; using backtracking; for each color count in hand; try inserting into board at each position; simulate removal chain; compute result.\n\nWe need to produce pseudocode lines. Use Start, End, Decision etc. Each line with comment.\n\nWe need to produce pseudocode but not actual code. Just virtual steps.\n\nWe need to cover algorithm: Build hand count map; define DFS(board, handCount). Base: if board empty return 0. If all hand empty return INF. If state in memo return value. For each index in board, find group start and end; color. For each possible color insertion that has at least 1 ball in hand: if color matches group color, need to compute needed = 3 - groupLen; if needed <= count then we can insert needed; else skip. For each insertion, compute new board after removal: simulate collapse: remove group then merge adjacent same color and repeat until no group >=3. Then recursively call DFS on new board with updated handCount. Keep min.\n\nReturn min or INF.\n\nEdge: if min==INF return -1.\n\nWe need to produce pseudocode lines with steps, decisions etc. Also we need to include comments. Let's produce pseudocode in a linear fashion. Use \"→\" for next step. Use Decision lines.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". So each line must include comment.\n\nWe'll start with Start, then steps: preprocess hand counts, define DFS, etc.\n\nWe can structure:\n\nStart // program entry\n→ Initialize handCount map // count balls by color\n→ Define DFS(board, handCount) // recursive function\n    ... (inside)\n→ Call DFS(board, handCount) // get result\n→ If result INF -> output -1 else output result\nEnd // finished\n\nInside DFS: many steps. We can use nested lines? The pseudocode format requires each line separate. We can indent? Example format uses indentation like \"    Yes → ...\". We can use that style.\n\nSo produce:\n\n→ Decision: if board empty? Yes → Return 0 // no balls left\n                No → ...\n\n→ Decision: if hand empty? Yes → Return INF // cannot clear\n\n→ Check memo: if (board, handCount) in memo? Yes → Return memo value\n\n→ Initialize minSteps = INF // track minimum\n\n→ For each position i from 0 to len(board) - 1:\n    → Find j = i; while j < len(board) and board[j] == board[i]: j++ // group end\n    → groupColor = board[i]\n    → groupLen = j - i\n    → For each color c in handCount with count>0:\n        → Decision: if c != groupColor? No -> continue // skip colors not needed\n        → needed = 3 - groupLen\n        → Decision: if needed <= handCount[c]? Yes → ...\n            ... else skip\n\nBut we can just simplify: For each color available, we consider insertion if needed <= count.\n\nWe need to create new board: newBoard = board[0:i] + c * needed + board[i:]; then collapse.\n\nSimulate collapse: while True: find any group of length>=3 in newBoard; if none break; else remove those groups, update newBoard, repeat.\n\nAfter collapse, newHandCount = handCount; newHandCount[c] -= needed\n\nThen recursive steps: result = DFS(newBoard, newHandCount); if result != INF: minSteps = min(minSteps, 1 + result)\n\nAfter loop: memo[board, handCount] = minSteps; return minSteps\n\nAfter DFS: If result == INF -> return -1 else result.\n\nWe need to produce each line as per requirement. Might need to be careful with decision branches.\n\nLet's craft pseudocode accordingly.\n\nAlso, for simulation of collapse, we may use a helper function collapse(board). We can treat it as a step.\n\nWe can include that as separate step: collapse(newBoard) // collapse chain removal\n\nWe'll produce code.\n\nLet's produce the output now.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize handCount map from hand string // 取得手牌中各顏色球的數量  \n→ Define DFS(board, handCount) // 以遞迴方式搜尋最小插入數  \n    → Decision: 如果 board 為空?  \n        Yes → Return 0 // 盤面已被清空，成功  \n        No →  \n    → Decision: 如果手牌已空且 board 非空?  \n        Yes → Return INF // 無法再進行插入，返回無限大  \n        No →  \n    → Decision: 若 (board, handCount) 在 memo 中?  \n        Yes → Return memo[board, handCount] // 回傳已計算結果  \n        No →  \n    → Set minSteps = INF // 追蹤最小步數  \n    → For i from 0 to length(board)-1: // 逐個位置嘗試插入  \n        → Set j = i  \n        → While j < length(board) and board[j] == board[i]: j++ // 找到同色區塊結束  \n        → groupColor = board[i]  \n        → groupLen = j - i  \n        → For each color c in handCount with count>0: // 逐顏色嘗試  \n            → Decision: 若 c != groupColor?  \n                Yes → Continue // 僅插入同色以形成 3 個以上  \n                No →  \n            → needed = 3 - groupLen // 需要插入幾個球才能消除區塊  \n            → Decision: needed <= handCount[c]?  \n                Yes →  \n                    → newBoard = board[0:i] + c * needed + board[i:] // 插入球  \n                    → newBoard = collapse(newBoard) // 連鎖消除  \n                    → newHandCount = handCount; newHandCount[c] -= needed // 更新手牌  \n                    → result = DFS(newBoard, newHandCount) // 進一步遞迴  \n                    → Decision: result != INF?  \n                        Yes → minSteps = min(minSteps, 1 + result) // 更新最小步數  \n                        No →  \n                No → Continue // 這顏色不足以插入  \n    → memo[board, handCount] = minSteps // 記錄結果  \n    → Return minSteps // 回傳此狀態的最小插入數  \n→ Call DFS(initialBoard, handCount) // 啟動遞迴搜尋  \n→ Set answer = result from DFS  \n→ Decision: answer == INF?  \n    Yes → Output -1 // 無法清空盤面  \n    No → Output answer // 最小插入數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\n# Colors in fixed order for consistent indexing\nCOLORS = ['R', 'Y', 'B', 'G', 'W']\nINF = 10 ** 9\n\ndef collapse(s: str) -> str:\n    \"\"\"\n    Repeatedly remove any group of 3 or more consecutive same-colored balls.\n    \"\"\"\n    while True:\n        n = len(s)\n        i = 0\n        removed = False\n        new_s_parts = []\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:\n                # Skip this group -> it's removed\n                removed = True\n            else:\n                new_s_parts.append(s[i:j])\n            i = j\n        if not removed:\n            break\n        s = ''.join(new_s_parts)\n    return s\n\ndef find_min_steps(board: str, hand: str) -> int:\n    \"\"\"\n    Return the minimal number of insertions needed to clear the board,\n    or -1 if impossible.\n    \"\"\"\n    # Count balls in hand\n    hand_count = [hand.count(c) for c in COLORS]\n    memo = {}\n\n    def dfs(cur_board: str, cnt: tuple) -> int:\n        # Base cases\n        if not cur_board:\n            return 0\n        if all(c == 0 for c in cnt):\n            return INF\n\n        key = (cur_board, cnt)\n        if key in memo:\n            return memo[key]\n\n        min_steps = INF\n        n = len(cur_board)\n\n        # Iterate over each group in the board\n        i = 0\n        while i < n:\n            j = i\n            while j < n and cur_board[j] == cur_board[i]:\n                j += 1\n            color = cur_board[i]\n            group_len = j - i\n            color_idx = COLORS.index(color)\n            # Try inserting the same color to form a group of 3\n            needed = 3 - group_len\n            if needed <= cnt[color_idx]:\n                # Insert needed balls at position i\n                new_board = cur_board[:i] + color * needed + cur_board[i:]\n                new_board = collapse(new_board)\n                new_cnt = list(cnt)\n                new_cnt[color_idx] -= needed\n                steps = dfs(new_board, tuple(new_cnt))\n                if steps != INF:\n                    min_steps = min(min_steps, 1 + steps)\n            i = j\n\n        memo[key] = min_steps\n        return min_steps\n\n    result = dfs(board, tuple(hand_count))\n    return -1 if result == INF else result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract strings inside double quotes\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        board_input, hand_input = matches[0], matches[1]\n    else:\n        # Fallback: split by commas if quotes not present\n        parts = data.split(',')\n        board_input = parts[0].split('=')[1].strip().strip('\"').strip(\"'\")\n        hand_input = parts[1].split('=')[1].strip().strip('\"').strip(\"'\")\n\n    answer = find_min_steps(board_input, hand_input)\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode564.json",
    "problem_index_in_file": 0,
    "title": "Find the Closest Palindrome",
    "description_snippet": "Given a string n representing an integer, return the closest integer (not including itself), which i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo) for the problem: find nearest palindrome to n, excluding n itself. Input string n representing integer. Output nearest integer as string maybe. If tie choose smaller.\n\nWe need to generate step-by-step pseudo-code lines with explanation after //.\n\nWe need to not output real code, but \"virtual\" lines: \"Step 1: ...\".\n\nWe can structure: Start, parse input string to integer maybe keep string.\n\nWe need to generate candidate palindromes: For numbers close to n. Approach: Generate palindromes by manipulating prefix, produce palindrome by mirroring. Generate candidates: left, right around the prefix. Also handle all 9's case, 100...001 etc. Then compute distance.\n\nWe will produce pseudo code.\n\nLet's outline steps:\n\nStart\n→ Parse input string n to integer num\n→ Determine length len\n→ Build candidate palindromes list\n    → Construct palindrome from prefix of n (excluding last digit if odd) by mirroring\n    → For offset in [-1, 0, +1]:\n         → Adjust prefix (as int) by offset\n         → Construct palindrome and add\n    → Add edge cases: 10^len-1 +1 etc? For all 9's or 1000 etc\n→ Remove the original number from candidate list if present\n→ Initialize bestDiff = INF, bestCandidate = null\n→ For each candidate in list:\n      → diff = abs(candidate - num)\n      → If diff < bestDiff or (diff == bestDiff and candidate < bestCandidate):\n            → update bestDiff, bestCandidate\n→ Output bestCandidate as string\nEnd\n\nNeed to include \"Decision\" lines maybe.\n\nLet's produce step-by-step with each line \"→ Step X:\" or \"Decision:\".\n\nWe need to keep each line with // explanation. Provide arrow at start? Format: \"→ Step 1: ...\" but for decisions \"Decision:\".\n\nLet's produce.\n\nWe must ensure not to output actual code but virtual lines.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 n // 取得原始數字字串\n→ Step 2: 轉換 n 為整數 num // 方便計算距離\n→ Step 3: 取得字串長度 len // 用於後續構造對稱數\n→ Step 4: 建立候選數字列表 candidates // 用來存放所有可能的回文數\n→ Decision: 是否將原始字串作為基準產生回文? // 用於生成主要候選\n    Yes → Step 5: 取得前半段 prefixStr // 取前 ⌊len/2⌋ 位\n    Yes → Step 6: 產生 basePalindrome by 把 prefixStr 反轉後接在前後 // 生成同長度的對稱數\n    Yes → Step 7: 加入 basePalindrome 到 candidates // 加入初始候選\n    No  → // 若不需要則略過\n→ Step 8: 對 offset 在 [-1,0,1] 迭代 // 產生前後調整的候選\n    → Decision: 取 prefixInt = int(prefixStr) + offset // 取得調整後的前半\n        Yes → Step 9: 若 prefixInt 為負則跳過 // 不能產生負數\n        Yes → Step 10: 產生 palindromeByOffset = 轉換 prefixInt 為字串再反轉並拼接 // 產生對稱數\n        Yes → Step 11: 加入 palindromeByOffset 到 candidates // 加入候選\n→ Step 12: 加入特殊邊界候選： 10^(len-1)-1 和 10^len+1 // 如 99...9 和 100...001\n→ Step 13: 從 candidates 移除原始數字 num // 不能算自己\n→ Step 14: 初始化 bestDiff = 無限 大，bestCandidate = null // 用於追蹤最佳答案\n→ Step 15: 對每個 candidate in candidates 迭代 // 比較距離\n    → Step 16: 計算 diff = abs(candidate - num) // 取絕對差\n    → Decision: diff < bestDiff 或 (diff == bestDiff 且 candidate < bestCandidate)? // 判斷是否更新\n        Yes → Step 17: 更新 bestDiff = diff // 更新最小距離\n        Yes → Step 18: 更新 bestCandidate = candidate // 更新最接近的回文\n→ Step 19: 輸出 bestCandidate 作為字串 // 回傳結果\nEnd // 程式執行結束\n\nBut need to be careful with formatting: each line must have \"→\" or \"Decision:\" and comment. Also \"Start\" and \"End\".\n\nAlso arrow formatting: \"→ Step 1:\" etc.\n\nLet's produce final answer accordingly.\n\nAlso we need to avoid actual code but still mention steps.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 n // 取得原始數字字串  \n→ Step 2: 轉換 n 為整數 num // 方便後續距離計算  \n→ Step 3: 取得字串長度 len // 用於構造對稱數  \n→ Step 4: 建立候選數字列表 candidates // 存放所有可能的回文數  \n→ Decision: 是否以原始數字為基準產生回文?  \n    Yes → Step 5: 取得前半段 prefixStr = n 的前 ⌊len/2⌋ 位 // 準備對稱部分  \n    Yes → Step 6: 產生 basePalindrome = prefixStr + reverse(prefixStr)（若 len 為奇數，跳過中間位） // 生成同長度的對稱數  \n    Yes → Step 7: 加入 basePalindrome 到 candidates // 加入初始候選  \n    No  → // 若不需要則略過  \n→ Step 8: 對 offset 在 [-1, 0, 1] 迭代 // 產生前後調整的候選  \n    → Decision: prefixInt = int(prefixStr) + offset // 取得調整後的前半段數字  \n        Yes → Step 9: 若 prefixInt 為負則跳過 // 防止產生負數回文  \n        Yes → Step 10: 產生 palindromeByOffset = str(prefixInt) + reverse(str(prefixInt))（若 len 為奇數，處理中間位） // 產生對稱數  \n        Yes → Step 11: 加入 palindromeByOffset 到 candidates // 加入候選  \n→ Step 12: 加入特殊邊界候選： 10^(len-1)-1（如 99…9）和 10^len+1（如 100…001） // 處理全 9 與 1 前後空間  \n→ Step 13: 從 candidates 移除原始數字 num // 不能把自己算作答案  \n→ Step 14: 初始化 bestDiff = 無限大，bestCandidate = null // 用於追蹤最接近的回文  \n→ Step 15: 對每個 candidate in candidates 迭代 // 比較距離  \n    → Step 16: 計算 diff = abs(candidate - num) // 取絕對差  \n    → Decision: diff < bestDiff 或 (diff == bestDiff 且 candidate < bestCandidate)？  \n        Yes → Step 17: 更新 bestDiff = diff // 更新最小距離  \n        Yes → Step 18: 更新 bestCandidate = candidate // 更新目前最佳答案  \n→ Step 19: 輸出 bestCandidate 作為字串 // 回傳最接近的回文  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        length = len(n)\n        num = int(n)\n        candidates = set()\n\n        # 特殊情況\n        candidates.add(str(10 ** length + 1))\n        candidates.add(str(10 ** (length - 1) - 1))\n\n        prefix = int(n[:(length + 1) // 2])\n        for i in [-1, 0, 1]:\n            new_prefix = str(prefix + i)\n            if length % 2 == 0:\n                palin = new_prefix + new_prefix[::-1]\n            else:\n                palin = new_prefix + new_prefix[:-1][::-1]\n            candidates.add(palin)\n\n        candidates.discard(n)\n\n        res = None\n        for cand in candidates:\n            if res is None or abs(int(cand) - num) < abs(int(res) - num) or (\n                abs(int(cand) - num) == abs(int(res) - num) and int(cand) < int(res)\n            ):\n                res = cand\n\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = match.group()\n    solution = Solution()\n    result = solution.nearestPalindromic(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"123\"",
          "expected_output": "\"121\"",
          "success": true,
          "output": "121"
        },
        {
          "example_index": 1,
          "input": "n = \"1\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode442.json",
    "problem_index_in_file": 0,
    "title": "Find All Duplicates in an Array",
    "description_snippet": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode steps. Use virtual code arrows, decisions, Start, End. Must be O(n) time, constant auxiliary space (except output). Approach: iterate array, for each value v, treat index abs(v)-1; if nums[abs(v)-1] < 0, then record v; else set nums[abs(v)-1] = -nums[abs(v)-1] to mark seen once. After iteration, optionally revert signs? But not needed for output. Steps:\n\nStart\n→ Step: Initialize empty result list // to store duplicates\n→ For i from 0 to n-1: // iterate each element\n    → Step: let val = abs(nums[i]) // current value\n    → Decision: if nums[val-1] < 0? // already seen before\n        Yes → Step: append val to result // duplicate found\n        No → Step: nums[val-1] = -nums[val-1] // mark as seen\n→ End\n\nWe need to keep array modifications constant space. That's fine.\n\nBut also maybe we need to restore array? Not necessary for requirement.\n\nLet's produce lines accordingly. Use \"→\" arrow, \"Decision:\" etc.\n\nWe need to produce each line with // explanation.\n\nMake sure to include \"Start\" and \"End\".\n\nProbably include \"for\" loop as step: \"for i = 0 to n-1\" is a step; but we can break into steps: \"→ Step: Set i = 0 // 初始化索引\" but maybe simpler: use \"→ Step: for i in 0..n-1\" with explanation.\n\nBut they asked to produce virtual code line by line, with arrows.\n\nLet's propose:\n\nStart // 程式開始執行\n→ Step: Create empty list result // 儲存重複出現的數字\n→ Step: for i = 0 to n-1 // 遍歷陣列每個位置\n    → Step: val = abs(nums[i]) // 取目前元素的正值\n    → Decision: nums[val-1] < 0? // 先前是否已被標記\n        Yes → Step: result.append(val) // 這個數字已出現過，加入結果\n        No  → Step: nums[val-1] = -nums[val-1] // 標記為已出現一次\nEnd // 程式執行結束\n\nNeed to ensure each line includes \"虛擬碼步驟\" then space then // explanation. Provide as multiple lines. Use consistent arrow.\n\nWe may need to indent nested lines. Use indentation for clarity but still separate lines. Each line has arrow. For Decision lines, indent further. Provide \"Yes →\" and \"No →\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Create empty list result // 用來儲存所有重複出現的數字  \n→ Step: for i = 0 to n-1 // 逐一遍歷陣列中的每個索引  \n → Step: val = abs(nums[i]) // 取得目前元素的正值作為真正的數字  \n → Decision: nums[val-1] < 0? // 檢查對應索引位置是否已被負號標記  \n  Yes → Step: result.append(val) // 已出現過，將此數字加入結果  \n  No  → Step: nums[val-1] = -nums[val-1] // 未出現過，將對應位置設為負號標記  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef findDuplicates(nums):\n    \"\"\"找出所有重複出現的數字，O(n) 時間，O(1) 附加空間。\"\"\"\n    res = []\n    for num in nums:\n        idx = abs(num) - 1          # 對應索引\n        if nums[idx] < 0:           # 已被標記，表示第二次出現\n            res.append(abs(num))\n        else:\n            nums[idx] = -nums[idx]  # 標記為第一次出現\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入為 \"nums = [...]\"，去除前綴\n    if '=' in data:\n        _, data = data.split('=', 1)\n    data = data.strip()\n\n    # 解析成列表\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，嘗試自行處理逗號分隔的數字\n        nums = [int(x) for x in data.replace('[', '').replace(']', '').split(',') if x.strip()]\n\n    result = findDuplicates(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,2]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode146.json",
    "problem_index_in_file": 0,
    "title": "LRU Cache",
    "description_snippet": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplemen...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for LRUCache design in a structured way, with each line having \"虛擬碼步驟 // 解釋\" and using arrows. We need to write a step-by-step algorithm for LRUCache with O(1) get/put. Use a hashmap + doubly linked list. Provide pseudocode lines. Should be clear.\n\nWe need to output step-by-step, starting with Start, End. Use arrows →, Decision: if. For each step include description.\n\nLet's produce something like:\n\nStart\n→ Step 1: Initialize hash map `map` and doubly linked list `dll` with head/tail sentinel // set up data structures\n→ Step 2: Set capacity // store capacity\n...\nThen functions get, put.\n\nWe need to include decisions and loops. Use Decision: ...? Yes → ... No → ... structure.\n\nOk. Let's generate.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空 HashMap `nodeMap`，鍵為 key，值為節點指標 // 快速定位節點\n→ Step 2: 建立雙向鏈表，含頭尾偵測節點 `head` 與 `tail` // 用於維護使用順序\n→ Step 3: `head.next` 指向 `tail`，`tail.prev` 指向 `head` // 初始化鏈表結構\n→ Step 4: 設定 `capacity` 為傳入的容量值 // LRU 緩存容量\n→ Step 5: 初始化 `size` 為 0 // 現有項目數\n\nEnd // 初始化結束\n\nStart // LRUCache.get 方法開始執行\n→ Decision: 是否存在於 `nodeMap`? // 檢查 key 是否已被儲存\n    Yes → Step 1: 取得節點 `node` = `nodeMap[key]` // 取得對應節點\n    → Step 2: 移除節點 `node` 從其原位置 // 移除以重新放至前端\n    → Step 3: 將節點 `node` 插入 `head.next` 位置 // 變成最近使用\n    → Step 4: 回傳 `node.value` // 返回對應值\n    No  → Step 5: 回傳 -1 // key 不存在\nEnd // get 方法結束\n\nStart // LRUCache.put 方法開始執行\n→ Decision: 是否存在於 `nodeMap`? // 檢查 key 是否已存在\n    Yes → Step 1: 取得節點 `node` = `nodeMap[key]` // 取得對應節點\n    → Step 2: 更新 `node.value` 為新值 // 更新資料\n    → Step 3: 移除節點 `node` 從其原位置 // 重新插入以更新使用順序\n    → Step 4: 插入節點 `node` 到 `head.next` 位置 // 變成最近使用\n    No  → Decision: `size` 是否已達 `capacity`? // 檢查是否要淘汰\n        Yes → Step 1: 取得最舊節點 `lru` = `tail.prev` // 從尾端取得最舊\n        → Step 2: 刪除 `lru` 從 `nodeMap` // 從哈希表移除\n        → Step 3: 移除 `lru` 從鏈表 // 從雙向鏈表移除\n        → Step 4: 減少 `size` 1 // 更新大小\n        No  → // 不需要淘汰\n        No  → // 如果未超過容量則不處理\n        No  → // 結束決策分支\n    → Step 5: 創建新節點 `newNode`，設定 key/value // 建立新項目\n    → Step 6: 將 `newNode` 插入 `head.next` 位置 // 放置於最近使用\n    → Step 7: 將 `newNode` 放入 `nodeMap` // 更新哈希表\n    → Step 8: 增加 `size` 1 // 更新大小\nEnd // put 方法結束",
      "generated_code": "import sys\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"Least Recently Used (LRU) cache implementation.\"\"\"\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()  # key -> value\n\n    def get(self, key: int) -> int:\n        \"\"\"Return value if key exists, else -1. Move key to most recent.\"\"\"\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # re-insert to mark as most recent\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"Insert or update key with value. Evict LRU if capacity exceeded.\"\"\"\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # pop least recently used\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that may be in two forms:\n    1. Two separate lines: first line operations, second line arguments.\n    2. Single line with two JSON arrays separated by '],['.\n    \"\"\"\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        ops_str, args_str = lines[0], lines[1]\n    else:\n        # Remove all whitespace for easier parsing\n        no_ws = ''.join(data.split())\n        split_index = no_ws.find('],[')\n        ops_str = no_ws[:split_index + 1]          # up to and including first ']'\n        args_str = no_ws[split_index + 2:]         # after the ',['\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n    return ops, args\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    ops, args = parse_input(raw_input)\n\n    result = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            result.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            result.append(None)\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            result.append(val)\n    # Output as JSON array, None -> null\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "success": true,
          "output": "[null, null, null, 1, null, -1, null, -1, 3, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode9.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Number",
    "description_snippet": "Given an integer x, return true if x is a palindrome, and false otherwise....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for checking if integer x is palindrome. Steps: convert to string or use math reversal. Use simple approach: convert to string and compare. Virtual code lines.\n\nLet's produce:\n\nStart\n→ Step 1: 將 x 轉為字串 s // 取得數字的字串表示\n→ Step 2: 建立 s_rev 為 s 的逆序 // 逆轉字串\n→ Decision: s == s_rev? // 判斷原字串與逆字串是否相同\n    Yes → Step 3: 回傳 true // 若相同則為回文\n    No  → Step 4: 回傳 false // 否則非回文\nEnd\n\nInclude comments. Ensure arrow formatting. Provide explanation after space. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 轉換 x 為字串 s // 將整數轉為文字表示  \n→ Step 2: 產生 s_rev 為 s 的逆序字串 // 反轉字串以備比較  \n→ Decision: s 與 s_rev 是否相等? // 判斷字串是否為回文  \n  Yes → Step 3: 回傳 true // 若相同，x 為回文  \n  No  → Step 4: 回傳 false // 若不同，x 不是回文  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        判斷整數 x 是否為回文。\n        1. 負數直接返回 False，因為前面有負號。\n        2. 將數字轉成字串，判斷字串是否等於其逆序。\n        \"\"\"\n        if x < 0:\n            return False\n        s = str(x)\n        return s == s[::-1]\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read()\n    # 從輸入中尋找第一個整數（可帶負號）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return  # 若找不到數字則直接結束\n    x = int(match.group())\n    sol = Solution()\n    result = sol.isPalindrome(x)\n    # 按照題目要求輸出小寫 'true' / 'false'\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 121",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = -121",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 10",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode421.json",
    "problem_index_in_file": 0,
    "title": "Maximum XOR of Two Numbers in an Array",
    "description_snippet": "Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for max XOR pair in an array. Use trie approach. Provide step-by-step pseudo-code. Should follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow lines. Must include Start, End, Decision. Must use virtual arrow symbols. Let's produce lines.\n\nApproach: Build binary trie of bits from high to low (31 to 0). For each number, query best XOR with existing numbers in trie. Maintain max. Also insert number into trie.\n\nSimplify: Steps: Initialize trie root, maxXor=0. For each number in array: query best XOR: For bit from high to low: choose opposite bit if exists else same. accumulate XOR value. After query, update maxXor. Then insert number into trie: traverse bits, create nodes.\n\nWe produce pseudo-code lines with decisions on bit presence.\n\nLet's craft.\n\nStart\n→ Step 1: 初始化 Trie 根節點 // 創建 Trie 以儲存二進位位元\n→ Step 2: 初始化 maxXor 為 0 // 用於儲存目前最大的 XOR 結果\n→ Step 3: 遍歷陣列 nums 的每個數字 num // 主迴圈\n    → Step 3.1: 初始化 currentXor 為 0 // 本數字與已插入數字的 XOR\n    → Step 3.2: 初始化 node 為 Trie 根節點 // 用於搜尋最佳 XOR\n    → Decision: 最高位 31 到 0? // 循環遍歷每一位\n        Yes → Step 3.2.1: 取 bit = (num >> i) & 1 // 取得當前位元\n        → Decision: node 子節點是否存在 bit^1? // 嘗試選擇相反位元\n            Yes → Step 3.2.2: currentXor = currentXor | (1 << i) // 這一位能達到 1\n            → Step 3.2.3: node = node.child[bit^1] // 跳到相反位元子節點\n            No  → Step 3.2.4: node = node.child[bit] // 跳到相同位元子節點\n        No → // 位元處理完成\n    → Step 3.3: maxXor = max(maxXor, currentXor) // 更新最大 XOR\n    → Step 3.4: 初始化 node 為 Trie 根節點 // 開始插入本數字\n    → Decision: 最高位 31 到 0? // 插入每一位\n        Yes → Step 3.4.1: 取 bit = (num >> i) & 1\n        → Decision: node 子節點是否存在 bit? // 若不存在則建立\n            Yes → Step 3.4.2: node = node.child[bit]\n            No  → Step 3.4.3: 建立新節點 node.child[bit] = 新節點\n            → Step 3.4.4: node = node.child[bit]\n        No → // 位元處理完成\n→ End // 回傳 maxXor\n\nNeed to adjust to fit format: Use \"Step X:\" etc. Must use arrow \"→\" between lines. Provide decisions. The decision lines need to have Yes→ and No→ sub-lines. Provide explanation after each line. Ensure each line ends with \"//\". Use consistent style.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 Trie 根節點 // 建立一個空的位元 Trie 用於儲存數字的二進位表示  \n→ Step 2: 初始化 maxXor 為 0 // 用於記錄目前找到的最大 XOR 值  \n→ Step 3: 遍歷陣列 nums 的每個數字 num // 主迴圈，逐個處理陣列中的數字  \n    → Step 3.1: 初始化 currentXor 為 0 // 這個數字與已插入數字的 XOR 結果  \n    → Step 3.2: 初始化 node 為 Trie 根節點 // 用於在 Trie 中搜尋最佳 XOR  \n    → Decision: 從最高位 31 到最低位 0 迭代? // 逐位處理  \n        Yes → Step 3.2.1: 取 bit = (num >> i) & 1 // 取得第 i 位的二進位值  \n        → Decision: node.child[bit ^ 1] 是否存在? // 嘗試選擇相反位以得到 1  \n            Yes → Step 3.2.2: currentXor = currentXor | (1 << i) // 這一位能取得 1  \n            → Step 3.2.3: node = node.child[bit ^ 1] // 移動到相反位元子節點  \n            No  → Step 3.2.4: node = node.child[bit] // 沒有相反位，則使用相同位元  \n        No → // 所有位元已處理完畢  \n    → Step 3.3: maxXor = max(maxXor, currentXor) // 若本次 XOR 更大，更新最大值  \n    → Step 3.4: 初始化 node 為 Trie 根節點 // 準備將本數字插入 Trie  \n    → Decision: 從最高位 31 到最低位 0 迭代? // 插入每一位  \n        Yes → Step 3.4.1: 取 bit = (num >> i) & 1 // 取得第 i 位  \n        → Decision: node.child[bit] 是否存在? // 若不存在則建立新節點  \n            Yes → Step 3.4.2: node = node.child[bit] // 已有節點，直接移動  \n            No  → Step 3.4.3: 建立新節點 node.child[bit] = 新節點 // 創建節點  \n            → Step 3.4.4: node = node.child[bit] // 移動到剛建立或已存在的節點  \n        No → // 所有位元已插入完畢  \n→ End // 程式執行結束，maxXor 即為所求的最大 XOR 值",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaximumXOR(self, nums):\n        max_xor = 0\n        mask = 0\n        for i in range(31, -1, -1):\n            mask |= (1 << i)\n            prefixes = set(num & mask for num in nums)\n            temp = max_xor | (1 << i)\n            for p in prefixes:\n                if temp ^ p in prefixes:\n                    max_xor = temp\n                    break\n        return max_xor\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找到列表的起始與結束位置\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums = ast.literal_eval(data[start:end+1])\n    result = Solution().findMaximumXOR(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,10,5,25,2,8]",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 1,
          "input": "nums = [14,70,53,83,49,91,36,80,92,51,66,70]",
          "expected_output": "127",
          "success": true,
          "output": "127"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode524.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary through Deleting",
    "description_snippet": "Given a string s and a string array dictionary, return the longest string in the dictionary that can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line. The user request: \"Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\"\n\nWe need to produce virtual code with explanation. We should use the arrow structure. Let's think algorithm: We iterate over dictionary, filter words that are subsequences of s, keep track of best: longer length, if equal length lexicographically smaller.\n\nPseudo steps:\n\nStart\n→ Step 1: Define function isSubsequence(word, s) // check if word is subsequence of s\n→ Step 2: Initialize best = \"\" // best result\n→ Step 3: For each word in dictionary\n→ Decision: if isSubsequence(word, s)?\n    Yes → Decision: if len(word) > len(best) or (len(word) == len(best) and word < best)?\n        Yes → Step 4: best = word // update best\n        No  → (do nothing)\n    No  → (do nothing)\n→ Step 5: Return best\n\nNeed to explain each line. Also we might have to mention sorting dictionary to handle lexicographical order tie. But we can handle inside condition. The algorithm is fine.\n\nMake sure to use arrow and decisions.\n\nWe need to produce lines with \"虛擬碼步驟 // 解釋\".\n\nWe need to use Start and End markers.\n\nAlso mention the isSubsequence function: Use two pointers.\n\nWe can also break down that function into steps:\n\n→ Step A1: Function isSubsequence(word, s)\n→ Step A2: Initialize i=0, j=0\n→ Step A3: While i < len(word) and j < len(s):\n→ Decision: if word[i] == s[j]?\n    Yes → i += 1\n    No  → (do nothing)\n→ Step A4: j += 1\n→ Step A5: After loop, return i == len(word)\n\nBut we can integrate within main loop. However we want clarity.\n\nLet's produce Virtual Code lines sequentially.\n\nWe need to ensure each line contains \"虛擬碼步驟\" + space + \"// explanation\".\n\nLet's craft.\n\nAlso need to indicate arrow directions: For decision blocks, indent lines under decision. Use \"Yes →\" and \"No →\".\n\nWe need to show indentation for sub-steps. Let's produce like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 isSubsequence(word, s) // 檢查 word 是否為 s 的子序列\n    → Step 1.1: i ← 0; j ← 0 // 初始化兩個指標\n    → Step 1.2: while i < len(word) and j < len(s):\n        → Decision: 如果 word[i] == s[j]?\n            Yes → i ← i + 1\n            No  → (保持 i 不變)\n        → j ← j + 1\n    → Step 1.3: return i == len(word) // 若 i 到達 word 長度，表示為子序列\nStep 2: best ← \"\" // 儲存目前最優答案\nStep 3: 對於 dictionary 中的每個 word:\n    → Decision: 如果 isSubsequence(word, s)?\n        Yes → Decision: 如果 len(word) > len(best) 或 (len(word) == len(best) 且 word < best)?\n            Yes → best ← word // 更新最佳答案\n            No  → (不更新)\n        No  → (跳過此 word)\nStep 4: 返回 best // 結果輸出\nEnd // 程式結束\n\nWe need to ensure each line's format: \"虛擬碼步驟 // 解釋\". We have multi-line sub-steps, each line should be separate. Indentation maybe indicated by spaces? Not necessary but we can show with arrow at each step. But the format example shows indentation using \"Yes →\" etc. We can maintain same.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 isSubsequence(word, s) // 檢查 word 是否為 s 的子序列  \n → Step 1.1: i ← 0; j ← 0 // 初始化兩個指標  \n → Step 1.2: while i < len(word) and j < len(s): // 逐字比對  \n   → Decision: 如果 word[i] == s[j]? // 字元相同則前進  \n    Yes → i ← i + 1  \n    No  → (保持 i 不變)  \n   → j ← j + 1 // 無論相同與否都往下移動 s 的指標  \n → Step 1.3: return i == len(word) // 若 i 到達 word 長度，表示為子序列  \nStep 2: best ← \"\" // 儲存目前最優答案  \nStep 3: 對於 dictionary 中的每個 word: // 遍歷字典  \n  → Decision: 如果 isSubsequence(word, s)? // 判斷是否可由 s 形成  \n   Yes → Decision: 如果 len(word) > len(best) 或 (len(word) == len(best) 且 word < best)? // 長度或字典序判斷  \n    Yes → best ← word // 更新最佳答案  \n    No  → (不更新)  \n   No  → (跳過此 word)  \nStep 4: 返回 best // 輸出結果（若無符合則為空字串）  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\ndef is_subsequence(word: str, s: str) -> bool:\n    \"\"\"Check if `word` is a subsequence of `s`.\"\"\"\n    it = iter(s)\n    return all(c in it for c in word)\n\ndef find_longest_word(s: str, dictionary: list[str]) -> str:\n    \"\"\"Return the longest word in `dictionary` that is a subsequence of `s`.\n    If multiple words share the maximum length, return the lexicographically\n    smallest one. Return an empty string if no such word exists.\"\"\"\n    best = \"\"\n    for word in dictionary:\n        if is_subsequence(word, s):\n            if len(word) > len(best) or (len(word) == len(best) and word < best):\n                best = word\n    return best\n\ndef main() -> None:\n    # Read all non‑empty lines from stdin\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not lines:\n        return\n\n    # Handle two possible input formats:\n    # 1) Two separate lines: first line is `s`, second line is the list\n    # 2) One line: `\"s\", [\"a\",\"b\"]`\n    if len(lines) >= 2:\n        s_line = lines[0]\n        dict_line = lines[1]\n    else:\n        data = lines[0]\n        comma_index = data.find(',')\n        s_line = data[:comma_index]\n        dict_line = data[comma_index + 1:]\n\n    # Strip surrounding quotes from the string `s`\n    s = s_line.strip('\"\\'')\n    # Parse the dictionary list\n    dictionary = ast.literal_eval(dict_line)\n\n    # Compute and output the result\n    result = find_longest_word(s, dictionary)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"]",
          "expected_output": "\"apple\"",
          "success": true,
          "output": "apple"
        },
        {
          "example_index": 1,
          "input": "\"abpcplea\", [\"a\",\"b\",\"c\"]",
          "expected_output": "\"a\"",
          "success": true,
          "output": "a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode599.json",
    "problem_index_in_file": 0,
    "title": "Minimum Index Sum of Two Lists",
    "description_snippet": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\n\nA co...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation in Traditional Chinese. The user wants algorithm: given two lists of strings, find common strings with minimum index sum, return all such strings.\n\nWe produce step-by-step virtual code with arrows and decisions.\n\nWe need to include Start, End, decisions, loops, etc.\n\nWe should consider mapping from string to index in list1 for quick lookup. Then iterate list2 with index j, find if string exists in map; compute sum i+j; maintain min sum and list of result strings.\n\nWe need to produce code steps as per format: each line: \"虛擬碼步驟 // 解釋\".\n\nMake sure to use arrows →, Decision: If..., Yes →, No →.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 建立字典 map1 // 將 list1 中每個字串映射到其索引\n→ Step 2: 初始化 minSum = Infinity, result = [] // 用於儲存最小索引和及其對應字串\n→ Step 3: 對於每個索引 j, 字串 str 在 list2 中迭代 // 遍歷 list2\n    → Decision: 如果 str 存在於 map1? // 檢查 str 是否為 common string\n        Yes → Step 4: 計算 sum = j + map1[str] // 取得索引和\n            → Decision: 如果 sum < minSum? // 是否更小\n                Yes → Step 5: 設置 minSum = sum, result = [str] // 更新最小索引和與結果\n                No  → Decision: 如果 sum == minSum? // 是否等於最小值\n                    Yes → Step 6: result.append(str) // 將該字串加入結果\n                    No  → // 不做任何事\n        No  → // 不是 common string，跳過\nEnd // 程式執行結束\n\nBut need each line as separate line with the arrow indentation as per sample.\n\nMake sure each line starts with arrow or Start/End.\n\nUse \"Decision:\" line.\n\nWe need to consider indentation: For decisions, we need nested lines with Yes → and No →.\n\nWe should keep the same style as example.\n\nLet's write lines:\n\nStart // 程式開始執行\n→ Step 1: 建立 map1：將 list1 中的每個字串映射到其索引 // 建立快速查找結構\n→ Step 2: 初始化 minSum = Infinity, result = [] // 用於追蹤最小索引和與對應字串\n→ Step 3: 對於每個索引 j 和字串 str 在 list2 中迭代 // 遍歷 list2\n    → Decision: 如果 str 存在於 map1? // 判斷是否為共同字串\n        Yes → Step 4: 計算 sum = j + map1[str] // 取得兩個索引之和\n            → Decision: 如果 sum < minSum? // 判斷是否更新最小值\n                Yes → Step 5: minSum = sum, result = [str] // 更新最小索引和與結果\n                No  → Decision: 如果 sum == minSum? // 判斷是否等於目前最小值\n                    Yes → Step 6: result.append(str) // 將該字串加入結果\n                    No  → // 無需處理\n        No  → // str 不在 list1，跳過\nEnd // 程式執行結束\n\nWe might need to indent with spaces to reflect nested decisions. In example they used tab indent or spaces. We'll replicate with 4 spaces for nested. Also the arrows for nested Yes and No lines must be after indentation.\n\nMake sure each line has the arrow or decision start and the explanation comment.\n\nCheck requirement: Each line must include \"虛擬碼步驟\" + space + \"// 解釋\". We need to ensure that each line ends with comment.\n\nOk.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 map1：將 list1 中的每個字串映射到其索引 // 建立快速查找結構  \n→ Step 2: 初始化 minSum = Infinity, result = [] // 用於追蹤最小索引和與對應字串  \n→ Step 3: 對於每個索引 j 和字串 str 在 list2 中迭代 // 遍歷 list2  \n    → Decision: 如果 str 存在於 map1? // 判斷是否為共同字串  \n        Yes → Step 4: 計算 sum = j + map1[str] // 取得兩個索引之和  \n            → Decision: 如果 sum < minSum? // 判斷是否更新最小值  \n                Yes → Step 5: minSum = sum, result = [str] // 更新最小索引和與結果  \n                No  → Decision: 如果 sum == minSum? // 判斷是否等於目前最小值  \n                    Yes → Step 6: result.append(str) // 將該字串加入結果  \n                    No  → // 無需處理  \n        No  → // str 不在 list1，跳過  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findRestaurant(self, list1, list2):\n        index_map = {name: i for i, name in enumerate(list1)}\n        min_sum = float('inf')\n        res = []\n\n        for j, name in enumerate(list2):\n            if name in index_map:\n                total_index = j + index_map[name]\n                if total_index < min_sum:\n                    min_sum = total_index\n                    res = [name]\n                elif total_index == min_sum:\n                    res.append(name)\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出所有列表字面量\n    lists = re.findall(r'\\[.*?\\]', data, re.DOTALL)\n    if len(lists) >= 2:\n        list1 = ast.literal_eval(lists[0])\n        list2 = ast.literal_eval(lists[1])\n    else:\n        list1, list2 = [], []\n\n    solution = Solution()\n    result = solution.findRestaurant(list1, list2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "['Shogun']"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "['Shogun']"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "success": true,
          "output": "['sad', 'happy']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode629.json",
    "problem_index_in_file": 0,
    "title": "K Inverse Pairs Array",
    "description_snippet": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.leng...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for counting permutations of 1..n with exactly k inversion pairs. Classic DP: dp[n][k] = sum_{i=0 to min(k, n-1)} dp[n-1][k-i], with base dp[0][0] = 1. Use modulo. Output steps in virtual code.\n\nWe need to produce virtual code line by line, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc.\n\nWe must avoid actual code but show algorithm. We'll present initialization, loops, modulo.\n\nWe must use arrow arrows etc. So like:\n\nStart // 程式開始\n\n→ Step 1: 定義 MOD = 10^9 + 7 // 設定模數\n\n→ Step 2: 建立 dp 數組 dp[n+1][k+1] 全部 0 // 用於儲存子問題答案\n\n→ Step 3: dp[0][0] = 1 // 空陣列有 0 逆序對\n\n→ Decision: 是否 n == 0? // 檢查邊界\n\n    Yes → End // 直接結束\n\n    No  →\n\n→ Step 4: For i從1到n: // 主迴圈\n\n    → Step 5: For j從0到k: // 次迴圈\n\n        → Decision: 是否 j == 0? // 特殊處理 j=0\n\n            Yes → dp[i][j] = dp[i-1][j] // 只取上一層的相同 j\n\n            No  →\n\n        → Step 6: 計算 sum = 0\n\n        → For t從1到 min(j, i-1):\n\n            → sum = (sum + dp[i-1][j-t]) % MOD\n\n        → dp[i][j] = (dp[i-1][j] + sum) % MOD\n\nBut we can compress using prefix sums to reduce to O(nk). Provide DP recurrence with prefix sum.\n\nWe need to produce virtual code line by line with arrows. Use Decision: and Yes/No arrows.\n\nAlso explain each line. Provide modular arithmetic explanation.\n\nLet's produce a clear algorithm:\n\nStart\n\n→ Set MOD\n\n→ Initialize dp matrix of size (n+1) x (k+1) zeros\n\n→ dp[0][0] = 1\n\n→ For i from 1 to n:\n\n    → For j from 0 to k:\n\n        → Decision: j < i? // Because min(i-1, j)\n\n            Yes → dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % MOD // using prefix sums\n\n            No  → dp[i][j] = (dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i]) % MOD\n\nBut maybe we can present using prefix sum approach.\n\nAlternatively show simple recurrence with inner loop sum.\n\nI'll produce virtual code using prefix sums for clarity.\n\nWe need each line with arrow or decision.\n\nLet's craft:\n\nStart // 開始計算\n\n→ Step 1: Set MOD = 1000000007 // 模數\n\n→ Step 2: Create 2D array dp of size (n+1) x (k+1) with 0 // dp[i][j] 代表前 i 個數字有 j 個逆序對\n\n→ Step 3: dp[0][0] = 1 // 空集合只有一種排列且 0 逆序對\n\n→ Decision: n == 0? // n 為 0 時\n\n    Yes → End // 直接輸出 dp[0][k] (只有 k=0 時為 1)\n\n    No  →\n\n→ Step 4: For i from 1 to n: // 處理第 i 個數字\n\n    → Step 5: dp[i][0] = 1 // 任何 i，若逆序對為 0，只能遞增排列\n\n    → Step 6: For j from 1 to k: // 計算所有 j\n\n        → Decision: j < i? // 是否 j 小於 i\n\n            Yes → dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % MOD // 加上不把新數字放在最左端的情況\n\n            No  → dp[i][j] = (dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i] + MOD) % MOD // 移除超過 i-1 的項\n\n→ End // 輸出 dp[n][k] // 最終答案\n\nBut we need to include explanation after each line.\n\nLet's produce full lines accordingly.\n\nWe'll also add comment about why dp[i][0] = 1: only one increasing permutation.\n\nNeed to use arrow arrows and Decision.\n\nAlso each line after '→' or 'Decision:' with arrow.\n\nLet's produce step-by-step.\n\nAlso include \"Start // 程式開始執行\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set MOD = 1000000007 // 取模數，防止答案過大  \n→ Step 2: Create 2D array dp of size (n+1) × (k+1) initialized to 0 // dp[i][j] 表示前 i 個數字 (1..i) 產生 j 個逆序對的排列數  \n→ Step 3: dp[0][0] = 1 // 空陣列只有一種排列且逆序對數為 0  \n→ Decision: 是否 n == 0? // 檢查 n 是否為 0（邊界情況）  \n  Yes → End // 若 n 為 0，只需回傳 dp[0][k]（只有 k=0 時為 1）  \n  No  →  \n→ Step 4: For i from 1 to n: // 逐步插入第 i 個數字  \n  → Step 5: dp[i][0] = 1 // 任何 i，若逆序對為 0，只能遞增排列 (1,2,…,i)  \n  → Step 6: For j from 1 to k: // 計算所有逆序對數 j  \n  → Decision: 是否 j < i? // 判斷可用的位移範圍  \n    Yes → dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % MOD // 新數字放在最右端或中間，累加前面所有合法排列  \n    No  → dp[i][j] = (dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i] + MOD) % MOD // 移除超過 i-1 的過大逆序對，保持正整數  \n→ End // 程式結束，輸出 dp[n][k] 作為答案（已取模）",
      "generated_code": "import sys\nimport re\n\nMOD = 10**9 + 7\n\ndef k_inverse_pairs(n: int, k: int) -> int:\n    # dp[i][j] = number of permutations of 1..i with exactly j inverse pairs\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        dp[i][0] = 1  # only one increasing permutation\n        for j in range(1, k + 1):\n            val = dp[i][j - 1] + dp[i - 1][j]\n            if j >= i:\n                val -= dp[i - 1][j - i]\n            dp[i][j] = val % MOD\n    return dp[n][k]\n\nif __name__ == \"__main__\":\n    data = re.findall(r'\\d+', sys.stdin.read())\n    if len(data) >= 2:\n        n, k = int(data[0]), int(data[1])\n        result = k_inverse_pairs(n, k)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode693.json",
    "problem_index_in_file": 0,
    "title": "Binary Number with Alternating Bits",
    "description_snippet": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines per requirement: start, step, decision, etc. The requirement: Given a positive integer, check whether it has alternating bits: two adjacent bits always different. So algorithm: while number > 0: check parity of current bit vs previous? Alternatively use XOR trick: n ^ (n >> 1) should be all 1's if alternating. Then check if (x & (x + 1)) == 0. But keep simple: extract bits iteratively. We'll produce virtual steps: Start, Step 1: Input number, Step 2: Set previousBit to -1 (none). Step 3: While number > 0: currentBit = number & 1; If previousBit != -1 and currentBit == previousBit → return false; previousBit = currentBit; number = number >> 1. After loop return true. End.\n\nAdd explanation comments.\n\nUse virtual code with arrows: Start, → Step 1: Input number // etc. For decisions: Decision: if number > 0? etc.\n\nWe need to produce each line of virtual code with a space and // explanation. Use Start, End. Use Decision for conditional checks.\n\nWe must be careful about syntax: \"Start // 程式開始執行\" then \"→ Step 1: 輸入使用者正整數 // 取得輸入\" etc. For decisions we use \"Decision: 兩個相鄰位元是否相同?\" etc.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入正整數 n // 從使用者取得正整數\n→ Step 2: 設定 previousBit 為 -1 // 用於記錄前一位元\n→ Decision: n > 0? // 先確認有位元可處理\n    Yes → Step 3: currentBit ← n & 1 // 取最低位元\n    No  → Step 4: 輸出 true // 空數字視為交替\n→ Decision: previousBit != -1 且 currentBit == previousBit? // 檢查是否有相同相鄰位元\n    Yes → Step 5: 輸出 false // 不交替，直接結束\n    No  → Step 6: previousBit ← currentBit // 更新前一位元\n→ Step 7: n ← n >> 1 // 移除已處理的最低位元\n→ Decision: n > 0? // 是否還有剩餘位元\n    Yes → (回到) Step 3\n    No  → Step 8: 輸出 true // 所有位元都交替\nEnd // 程式執行結束\n\nBut we need to keep structure: use \"Decision:\" lines properly. But in example, they indent with 4 spaces for nested steps. We'll do similar.\n\nWe should also show the loop. Use \"→ Decision: n > 0?\" then Yes branch contains steps until loop ends. We might use \"→ Decision: n > 0?\" and then \"Yes → (loop body)\", \"No → Step 8: 輸出 true\". For loop body we need to go back to step 3. But we can show \"Yes → (回到) Step 3\" or \"Yes → Step 3\" but that may cause recursion. Use \"Yes → (重複) Step 3\". We'll write:\n\nYes → (重複) Step 3\n\nBut maybe better to write \"Yes → (返回) Step 3\". Provide explanation.\n\nAlternatively, we can express loop using \"Decision\" after step 7. The Yes branch leads to Step 3 again. We'll keep it.\n\nLet's craft final virtual code lines.\n\nWe must not output actual code, only virtual.\n\nAlso ensure Chinese characters in explanation. Use short intuitive explanation. We'll provide comments in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 n // 取得使用者輸入的正整數  \n→ Step 2: 設定 previousBit 為 -1 // 用於記錄前一位元，初始值表示尚未處理任何位元  \n→ Decision: n > 0? // 判斷是否還有位元可處理  \n Yes → Step 3: currentBit ← n & 1 // 取出最低位元  \n No  → Step 4: 輸出 true // n 為 0 時視為交替位元，直接回傳真  \n→ Decision: previousBit != -1 且 currentBit == previousBit? // 檢查兩個相鄰位元是否相同  \n Yes → Step 5: 輸出 false // 出現相同相鄰位元，交替失敗，直接回傳假  \n No  → Step 6: previousBit ← currentBit // 更新前一位元以便下次比較  \n→ Step 7: n ← n >> 1 // 右移一位，移除已處理的最低位元  \n→ Decision: n > 0? // 是否還有剩餘位元  \n Yes → (回到) Step 3 // 重新取最低位元，進入下一輪循環  \n No  → Step 8: 輸出 true // 所有位元皆交替，回傳真  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hasAlternatingBits(self, n: int) -> bool:\n        # 取得最低位元作為上一位元\n        prev_bit = n & 1\n        n >>= 1\n        # 逐位檢查剩餘位元\n        while n:\n            curr_bit = n & 1\n            if curr_bit == prev_bit:\n                return False\n            prev_bit = curr_bit\n            n >>= 1\n        return True\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n    # 從輸入中擷取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        sys.exit(0)\n    n = int(match.group())\n    sol = Solution()\n    result = sol.hasAlternatingBits(n)\n    # 輸出符合題目要求的字串\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode13.json",
    "problem_index_in_file": 0,
    "title": "Roman to Integer",
    "description_snippet": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Val...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each line with a step description and comment. No actual code. Use arrows, decision etc.\n\nWe should outline algorithm: iterate over string, compare value of current char to next char; if next > current, subtract current else add. At end sum. Also handle mapping of Roman to int.\n\nWe will produce virtual steps:\n\nStart\n\n→ Step 1: 初始化映射表 (Roman → value)\n\n→ Step 2: 读取输入字符串 S\n\n→ Step 3: 初始化 total = 0\n\n→ Step 4: 初始化 index = 0\n\n→ Decision: index < length(S)?\n\n  Yes → Step 5: 设 cur = value(S[index])\n\n  → Decision: index+1 < length(S) 且 value(S[index+1]) > cur?\n\n    Yes → Step 6: total = total + (value(S[index+1]) - cur)\n\n         → Step 7: index = index + 2\n\n    No  → Step 8: total = total + cur\n\n         → Step 9: index = index + 1\n\n  No → End\n\nBut we need to provide explanation each line.\n\nLet's craft. Use virtual code like:\n\nStart // 程式開始執行\n\n→ Step 1: 建立符號對應值表 // 定義 I=1, V=5, ... , M=1000\n\n→ Step 2: 讀入羅馬數字字串 S // 從使用者或函式參數取得\n\n→ Step 3: 設 total = 0 // 用於累加最終整數值\n\n→ Step 4: 設 index = 0 // 從字串首位開始掃描\n\n→ Decision: index < length(S)? // 判斷是否還有未處理的字元\n\n   Yes → Step 5: curVal = value_of(S[index]) // 取得目前字元對應數值\n\n   → Decision: index+1 < length(S) 且 value_of(S[index+1]) > curVal? // 檢查下一個字元是否更大，需使用減法規則\n\n      Yes → Step 6: total = total + (value_of(S[index+1]) - curVal) // 加入減法組合的值\n\n          → Step 7: index = index + 2 // 跳過兩個字元\n\n      No  → Step 8: total = total + curVal // 普通加法\n\n          → Step 9: index = index + 1 // 只跳過目前字元\n\n   No  → End // 所有字元已處理\n\nEnd // 輸出 total\n\nBut we must include arrow format. Use '→' for next step, 'Yes →', 'No →'.\n\nMake sure each line ends with comment after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立符號對應值表 // 定義 I=1, V=5, X=10, L=50, C=100, D=500, M=1000  \n→ Step 2: 讀入羅馬數字字串 S // 從使用者或函式參數取得輸入  \n→ Step 3: 設 total = 0 // 用於累加最終整數值  \n→ Step 4: 設 index = 0 // 從字串首位開始掃描  \n→ Decision: index < length(S)? // 判斷是否還有未處理的字元  \n  Yes → Step 5: curVal = value_of(S[index]) // 取得目前字元對應數值  \n   → Decision: index+1 < length(S) 且 value_of(S[index+1]) > curVal? // 檢查下一個字元是否更大，需使用減法規則  \n    Yes → Step 6: total = total + (value_of(S[index+1]) - curVal) // 加入減法組合的值  \n     → Step 7: index = index + 2 // 跳過兩個字元  \n    No → Step 8: total = total + curVal // 普通加法  \n     → Step 9: index = index + 1 // 只跳過目前字元  \n  No → End // 所有字元已處理  \nEnd // 輸出 total",
      "generated_code": "import sys\nimport re\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"將羅馬數字轉換為整數。\"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev_value = 0\n    # 從右向左遍歷，根據前一個值判斷是加還是減\n    for char in reversed(s):\n        value = roman_map[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 先嘗試從字串中提取引號內的內容\n    match = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    if match:\n        roman_str = match.group(1)\n    else:\n        # 若沒有引號，直接把整個輸入視為羅馬數字\n        roman_str = data\n    result = roman_to_int(roman_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"III\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"LVIII\"",
          "expected_output": "58",
          "success": true,
          "output": "58"
        },
        {
          "example_index": 2,
          "input": "s = \"MCMXCIV\"",
          "expected_output": "1994",
          "success": true,
          "output": "1994"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode134.json",
    "problem_index_in_file": 0,
    "title": "Gas Station",
    "description_snippet": "There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode, line by line, using the specified format. For the problem: given arrays gas and cost, find starting index to complete circuit or return -1. We produce a solution: standard algorithm O(n). Pseudocode lines: Start, variables total_gas, total_cost, tank, start, loop i 0..n-1, update totals, update tank, if tank<0: start = i+1, tank=0, end loop, decision if total_gas<total_cost then -1 else start.\n\nWe must use the specified arrow and structure: Start, → Step, → Decision, etc.\n\nWe need to output line by line, each line: virtual code step + space + // explanation.\n\nUse arrow '→' for normal step. Decision lines use 'Decision:' and sub-branches with Yes → and No →.\n\nWe must include Start and End. Use indices.\n\nWe should not produce actual code, just virtual code.\n\nLet's produce.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Initialize total_gas = 0, total_cost = 0, tank = 0, start = 0 // 初始化全局變量\n\nLine 3: → For i from 0 to n-1 // 遍歷所有加油站\n\nWe need to structure decision within loop.\n\nInside loop:\n\nLine 4:     → Add gas[i] to total_gas // 累計總加油量\n\nLine 5:     → Add cost[i] to total_cost // 累計總耗油量\n\nLine 6:     → Add gas[i] - cost[i] to tank // 更新當前油量差\n\nLine 7:     → Decision: if tank < 0? // 檢查是否無法繼續從此起點\n\nBranches:\n\nLine 8:         Yes → Set start = i + 1 // 重新設定起點為下一個站\n\nLine 9:         Yes → Reset tank = 0 // 重置油量為0，因為從新起點開始\n\nLine 10:         No // 若油量不負，則保持當前起點\n\nEnd loop.\n\nAfter loop:\n\nLine 11: → Decision: if total_gas < total_cost? // 檢查總加油量是否足以完成整個路程\n\nLine 12:     Yes → Return -1 // 無法完成，返回 -1\n\nLine 13:     No → Return start // 可以完成，返回找到的起點\n\nEnd // 程式結束\n\nMake sure each line ends with explanation comment. Use arrows appropriately.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize total_gas = 0, total_cost = 0, tank = 0, start = 0 // 初始化總加油量、總耗油量、當前油量差與起點索引  \n→ For i from 0 to n-1 // 遍歷所有加油站  \n → Add gas[i] to total_gas // 累計總加油量  \n → Add cost[i] to total_cost // 累計總耗油量  \n → Add gas[i] - cost[i] to tank // 更新當前油量差（加油減去消耗）  \n → Decision: if tank < 0? // 檢查從目前起點是否還能到下一站  \n  Yes → Set start = i + 1 // 重新設定起點為下一個站  \n  Yes → Reset tank = 0 // 重置油量，因為從新起點開始  \n  No // 油量不負，維持現有起點  \n→ Decision: if total_gas < total_cost? // 檢查整體加油量是否足夠完成一圈  \n Yes → Return -1 // 總加油量不足，無法完成環行  \n No → Return start // 總加油量足夠，返回找到的唯一起點  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef canCompleteCircuit(gas, cost):\n    if sum(gas) < sum(cost):\n        return -1\n    start = 0\n    tank = 0\n    for i in range(len(gas)):\n        tank += gas[i] - cost[i]\n        if tank < 0:\n            start = i + 1\n            tank = 0\n    return start\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    gas_match = re.search(r'gas\\s*=\\s*(\\[[^\\]]*\\])', data)\n    cost_match = re.search(r'cost\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if gas_match and cost_match:\n        gas = ast.literal_eval(gas_match.group(1))\n        cost = ast.literal_eval(cost_match.group(1))\n    else:\n        # Fallback parsing if format differs\n        parts = data.split(',')\n        gas = ast.literal_eval(parts[0].strip())\n        cost = ast.literal_eval(parts[1].strip())\n    result = canCompleteCircuit(gas, cost)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode540.json",
    "problem_index_in_file": 0,
    "title": "Single Element in a Sorted Array",
    "description_snippet": "You are given a sorted array consisting of only integers where every element appears exactly twice, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solution to problem: find single element in sorted array where all others appear twice. O(log n) time, O(1) space. Use binary search on indices; property: before the unique element, pairs start at even indices; after unique, pairs shift. Approach: low=0 high=n-1; while low<high: mid=(low+high)//2; ensure mid is even: if mid%2==1: mid--; if nums[mid]==nums[mid+1]: low=mid+2 else high=mid. At end low==high -> unique. Provide virtual code line by line with explanations.\n\nWe need to output lines each with virtual code + comment. No actual code. Use arrows, Start, End, Decision.\n\nLet's produce step-by-step:\n\nStart\n→ Step 1: 初始化 low=0, high= n-1 // 設定搜尋區間\n→ Decision: low < high? // 判斷搜尋是否結束\n    Yes → Step 2: 計算 mid=(low+high)//2 // 取中點\n    → Step 3: 如果 mid 為奇數，mid=mid-1 // 讓 mid 變為偶數\n    → Decision: nums[mid]==nums[mid+1]? // 判斷 mid 位置的數字是否與右邊相同\n        Yes → Step 4: low=mid+2 // 左側已無單一元素，縮小搜尋區到右側\n        No  → Step 5: high=mid // 右側有單一元素，縮小搜尋區到左側\n    No → Step 6: 返回 nums[low] // low==high 時即為唯一元素\nEnd\n\nBut ensure format: each line must have virtual code and comment. Use arrows: → etc. Also decisions.\n\nLet's structure with indentation? Example shows indentation for nested decisions. We should mimic.\n\nAlso we must include Start and End lines.\n\nSo produce lines:\n\nStart // 程式開始執行\n→ Step 1: low = 0, high = n-1 // 初始化搜尋區間\n→ Decision: low < high? // 檢查是否還有區間可搜尋\n    Yes → Step 2: mid = (low + high) // 2 // 計算中點\n    → Step 3: if mid % 2 == 1 then mid = mid - 1 // 使 mid 為偶數索引\n    → Decision: nums[mid] == nums[mid + 1]? // 判斷 mid 對齊的重複\n        Yes → Step 4: low = mid + 2 // 唯一元素在右側\n        No  → Step 5: high = mid // 唯一元素在左側\n    No  → Step 6: return nums[low] // low==high，即唯一元素\nEnd // 程式執行結束\n\nNeed to ensure each line has virtual code and comment. For nested decisions, use indentation. Use \"Decision:\" and \"Yes →\" etc.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: low = 0, high = n-1 // 初始化搜尋區間\n→ Decision: low < high? // 判斷是否還有區間可搜尋\n    Yes → Step 2: mid = (low + high) // 2 // 計算中點\n    → Step 3: if mid % 2 == 1 then mid = mid - 1 // 使 mid 為偶數索引，方便配對檢查\n    → Decision: nums[mid] == nums[mid + 1]? // 判斷 mid 位置的數字是否與右側相同\n        Yes → Step 4: low = mid + 2 // 唯一元素位於右半邊，縮小搜尋區間至右側\n        No  → Step 5: high = mid // 唯一元素位於左半邊，縮小搜尋區間至左側\n    No  → Step 6: return nums[low] // low==high 時即為唯一元素\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNonDuplicate(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if mid % 2 == 1:\n                mid -= 1\n            if nums[mid] == nums[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid\n        return nums[left]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        nums = ast.literal_eval(data)\n        result = Solution().singleNonDuplicate(nums)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,2,3,3,4,4,8,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[3,3,7,7,10,11,11]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode622.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Queue",
    "description_snippet": "Design your implementation of the circular queue. The circular queue is a linear data structure in w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing MyCircularQueue with given methods. Provide step-by-step. The virtual code should use arrow syntax, Decision, etc. Each line: virtual code step + space + // explanation.\n\nWe must avoid actual code, only pseudo-code. Provide initialization, operations. Use array and two pointers head, tail and count or size. Let's produce steps:\n\nStart // start program\n→ Step 1: Initialize array of size k // allocate storage\n→ Step 2: Set head = 0, tail = 0, count = 0 // pointers and count\n...\n\nBut for each method separate blocks maybe? The instruction: produce virtual code for implementation. Might produce high-level skeleton for class, with methods. Provide pseudo code for each method. Use Start and End at class level? We'll produce overall flow.\n\nWe need to output step by step. We'll include Start and End at class initialization. For methods, we can produce separate pseudo-code blocks.\n\nBetter: produce one block covering class methods.\n\nLet's design:\n\nStart // Begin MyCircularQueue class definition\n\n→ Constructor(k): // Initialize queue with capacity k\n    → Allocate array of size k // storage\n    → head = 0 // index of front\n    → tail = 0 // index where next element will be inserted\n    → size = 0 // number of elements\n\n→ Method Enqueue(value):\n    → Decision: If size == k? // check full\n        Yes → Return false // cannot insert\n        No  → array[tail] = value // insert at tail\n            → tail = (tail + 1) mod k // move tail\n            → size = size + 1 // increment count\n            → Return true\n\n→ Method Dequeue():\n    → Decision: If size == 0? // check empty\n        Yes → Return false\n        No  → head = (head + 1) mod k // move head\n            → size = size - 1 // decrement count\n            → Return true\n\n→ Method Front():\n    → Decision: If size == 0? // empty\n        Yes → Return -1\n        No  → Return array[head]\n\n→ Method Rear():\n    → Decision: If size == 0? // empty\n        Yes → Return -1\n        No  → index = (tail - 1 + k) mod k // last element\n            → Return array[index]\n\n→ Method IsEmpty():\n    → Return size == 0\n\n→ Method IsFull():\n    → Return size == k\n\nEnd // End class definition\n\nWe need to format each line as \"虛擬碼步驟 // 解釋\". Each line must start with \"Start\" or arrow. Use arrow \"→\" for steps. Use \"Decision:\" for condition.\n\nLet's write step by step.\n\nWe should ensure every line ends with // explanation.\n\nLet's produce:\n\nStart // Begin MyCircularQueue class definition\n→ Constructor(k): // Initialize queue with capacity k\n    → Allocate array of size k // allocate storage\n    → head = 0 // front pointer\n    → tail = 0 // next insertion pointer\n    → size = 0 // element count\n\n→ Enqueue(value): // Insert value into queue\n    → Decision: If size == k? // check if full\n        Yes → Return false // cannot insert\n        No  → array[tail] = value // place value\n            → tail = (tail + 1) mod k // advance tail circularly\n            → size = size + 1 // increment count\n            → Return true // insertion successful\n\n→ Dequeue(): // Remove front element\n    → Decision: If size == 0? // check if empty\n        Yes → Return false // nothing to remove\n        No  → head = (head + 1) mod k // advance head circularly\n            → size = size - 1 // decrement count\n            → Return true // deletion successful\n\n→ Front(): // Get front item\n    → Decision: If size == 0? // empty?\n        Yes → Return -1 // indicate empty\n        No  → Return array[head] // front value\n\n→ Rear(): // Get last item\n    → Decision: If size == 0? // empty?\n        Yes → Return -1 // indicate empty\n        No  → index = (tail - 1 + k) mod k // compute last index\n            → Return array[index] // rear value\n\n→ IsEmpty(): // Check if queue is empty\n    → Return size == 0 // true if empty\n\n→ IsFull(): // Check if queue is full\n    → Return size == k // true if full\n\nEnd // End MyCircularQueue class definition\n\nWe need each line as \"虛擬碼步驟 [space] // 解釋\". Indentation lines should still be separate lines but we need to ensure each line has explanation. For nested lines we can indent but still each line separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 開始定義 MyCircularQueue 類別  \n→ Constructor(k): // 建構子：初始化容量為 k  \n → Allocate array of size k // 申請大小為 k 的陣列作為儲存空間  \n → head = 0 // 前端指標（指向隊首元素）  \n → tail = 0 // 後端指標（下一個要插入的位置）  \n → size = 0 // 目前佔用元素數量  \n\n→ Enqueue(value): // 將值插入隊列  \n → Decision: If size == k? // 檢查是否已滿  \n  Yes → Return false // 無法插入，回傳失敗  \n  No  → array[tail] = value // 將值放在後端指標位置",
      "generated_code": "import sys\nimport json\n\nclass MyCircularQueue:\n    def __init__(self, k):\n        self.queue = [0] * k\n        self.head = -1\n        self.tail = -1\n        self.size = k\n\n    def enQueue(self, value):\n        if self.isFull():\n            return False\n        if self.isEmpty():\n            self.head = 0\n        self.tail = (self.tail + 1) % self.size\n        self.queue[self.tail] = value\n        return True\n\n    def deQueue(self):\n        if self.isEmpty():\n            return False\n        if self.head == self.tail:\n            self.head = self.tail = -1\n        else:\n            self.head = (self.head + 1) % self.size\n        return True\n\n    def Front(self):\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self):\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self):\n        return self.head == -1\n\n    def isFull(self):\n        return (self.tail + 1) % self.size == self.head\n\ndef main():\n    # Read non‑empty lines from stdin\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if len(lines) < 2:\n        return\n    methods = json.loads(lines[0])\n    params  = json.loads(lines[1])\n\n    results = []\n    obj = None\n    for meth, arg in zip(methods, params):\n        if meth == \"MyCircularQueue\":\n            obj = MyCircularQueue(*arg)\n            results.append(None)  # constructor returns null\n        else:\n            func = getattr(obj, meth)\n            res = func(*arg)\n            results.append(res)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"Rear\", \"isFull\", \"deQueue\", \"enQueue\", \"Rear\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 3, true, true, true, 4]",
          "success": true,
          "output": "[null, true, true, true, false, 3, true, true, true, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode22.json",
    "problem_index_in_file": 0,
    "title": "Generate Parentheses",
    "description_snippet": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parenthes...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for generating all combinations of well-formed parentheses. Use recursion/backtracking approach. Steps: start, function generate(n) returns list, helper(current, open, close). Add parentheses when open < n, close < open. Append to list. Output final list. Include decision nodes. Let's write lines accordingly.\n\nAlso need to output in Traditional Chinese. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" etc. Should include Start, End. Use indentation maybe but not necessary. We'll just indent with spaces for readability.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Function GenerateParentheses(n) // 定義主函數，輸入括號對數\n→     List result = [] // 用於儲存所有合法組合\n→     → Helper(current, open, close, result) // 呼叫遞迴協助函數\n→     Return result // 回傳結果列表\n→ End // 主函數結束\n\nNow define Helper.\n\n→ Function Helper(current, open, close, result) // 生成括號組合的遞迴函數\n→     Decision: 如果 open < n? // 若仍有未放置左括號\n→         Yes → Append '(' to current // 加入左括號\n→         → Helper(current, open + 1, close, result) // 進一步遞迴\n→         → Remove last char from current // 回溯\n→     Decision: 如果 close < open? // 若右括號可放置\n→         Yes → Append ')' to current // 加入右括號\n→         → Helper(current, open, close + 1, result) // 進一步遞迴\n→         → Remove last char from current // 回溯\n→     Decision: 如果 open == n 且 close == n? // 完成一個合法組合\n→         Yes → Append copy of current to result // 儲存結果\n→ End // Helper 函數結束\n\nBut we need each line in same format: \"虛擬碼步驟 // 解釋\". We'll produce each line accordingly.\n\nAlso we should include Start and End for entire algorithm? The spec says use Start, End. We can have overall Start and End. Let's include.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Function GenerateParentheses(n) // 主函數，輸入括號對數  \n→     List result = [] // 儲存所有合法組合的列表  \n→     → Helper(\"\", 0, 0, result) // 呼叫遞迴協助函數  \n→     Return result // 回傳結果列表  \nEnd // 主函數結束  \n\n→ Function Helper(current, open, close, result) // 生成括號組合的遞迴函數  \n→     Decision: 如果 open < n? // 還有未放置的左括號  \n→         Yes → Append '(' to current // 加入左括號  \n→         → Helper(current, open + 1, close, result) // 進一步遞迴  \n→         → Remove last char from current // 回溯到上一層  \n→     Decision: 如果 close < open? // 右括號可放置且不超過左括號  \n→         Yes → Append ')' to current // 加入右括號  \n→         → Helper(current, open, close + 1, result) // 進一步遞迴  \n→         → Remove last char from current // 回溯  \n→     Decision: 如果 open == n 且 close == n? // 已形成完整合法組合  \n→         Yes → Append copy of current to result // 將完整組合加入結果  \n→ End // Helper 函數結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def generateParenthesis(self, n: int) -> list[str]:\n        \"\"\"\n        生成所有合法的括號組合\n        \"\"\"\n        res = []\n\n        def backtrack(s: str = \"\", left: int = 0, right: int = 0) -> None:\n            # 兩個括號總長度為 2*n\n            if len(s) == 2 * n:\n                res.append(s)\n                return\n            # 若還有左括號可以放\n            if left < n:\n                backtrack(s + \"(\", left + 1, right)\n            # 右括號只能在左括號多於右括號時放\n            if right < left:\n                backtrack(s + \")\", left, right + 1)\n\n        backtrack()\n        return res\n\ndef parse_input(input_str: str) -> int:\n    \"\"\"\n    從輸入字串中擷取整數 n\n    支援 \"n = 3\"、\"3\" 等格式\n    \"\"\"\n    input_str = input_str.strip()\n    if \"=\" in input_str:\n        _, value = input_str.split(\"=\", 1)\n        return int(value.strip())\n    else:\n        return int(input_str)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有資料\n    raw_input = sys.stdin.read()\n    n = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.generateParenthesis(n)\n\n    # 輸出 JSON 格式的字串，符合範例要求\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
          "success": true,
          "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[\"()\"]",
          "success": true,
          "output": "[\"()\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode217.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate",
    "description_snippet": "Given an integer array nums, return true if any value appears at least twice in the array, and retur...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for checking duplicates in an integer array. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision, etc. We'll provide step-by-step pseudocode.\n\nWe need Start, End, Decision, Yes, No. Use \"→\" for flow.\n\nWe'll produce code lines:\n\nStart\n→ Step 1: 建立空集合 seen // 用於存儲已遇過的數字\n→ Step 2: 對於每個元素 num 在 nums 中循環 // 遍歷陣列\n    → Decision: 若 num 已在 seen 中? // 檢查是否重複\n        Yes → Step 3: 返回 true // 立即回傳 true\n        No  → Step 4: 將 num 加入 seen // 記錄此數字\n→ Step 5: 返回 false // 所有元素均唯一，回傳 false\nEnd\n\nAdd comments. Ensure each line with arrow and comments. Use proper indentation? Might be plain lines; use indent inside decision blocks.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 seen // 用於存儲已遇過的數字  \n→ Step 2: 對於每個元素 num 在 nums 中循環 // 遍歷陣列  \n → Decision: 若 num 已在 seen 中? // 檢查是否重複  \n  Yes → Step 3: 返回 true // 立即回傳 true，表示存在重複  \n  No  → Step 4: 將 num 加入 seen // 記錄此數字以供後續比較  \n→ Step 5: 返回 false // 所有元素均唯一，回傳 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def containsDuplicate(self, nums):\n        \"\"\"檢查 nums 中是否存在重複元素。\"\"\"\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中抽取陣列並轉為 Python list。\"\"\"\n    data = data.strip()\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        return []\n    list_str = data[start:end+1]\n    try:\n        return eval(list_str)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    result = Solution().containsDuplicate(nums)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode389.json",
    "problem_index_in_file": 0,
    "title": "Find the Difference",
    "description_snippet": "You are given two strings s and t.\n\nString t is generated by random shuffling string s and then add ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that given two strings s and t, where t is s shuffled plus an extra letter, we need to find the added letter.\n\nWe need to produce step-by-step virtual code, each line with explanation, using arrow syntax.\n\nWe must not output actual code. Just pseudocode steps. Use Start, End, Decision. Likely need to compute difference using frequency counts or XOR.\n\nWe'll produce steps:\n\n- Start\n- Step: Initialize array counts for letters (size 26) to 0 // frequency difference\n- For each char in s: increment count\n- For each char in t: decrement count\n- Then iterate counts to find non-zero => added letter\n- Output that letter\n\nAlternatively XOR approach:\n\n- Step: initialize char xorVal = 0\n- For each char in s: xorVal ^= char\n- For each char in t: xorVal ^= char\n- The xorVal is added letter.\n\nEither fine. Provide explanation per line.\n\nWe'll do the XOR approach because simpler.\n\nUse steps:\n\nStart // program starts\n\n→ Step 1: 初始化 xorVal 為 0 // 用於存儲 XOR 結果\n\n→ Step 2: 循環遍歷 s，對每個字符 c 執行 xorVal = xorVal XOR c // 將 s 的字符 XOR\n\n→ Step 3: 循環遍歷 t，對每個字符 c 執行 xorVal = xorVal XOR c // 將 t 的字符 XOR\n\n→ Step 4: xorVal 現在保存了 t 中多出的字符 // XOR 消除相同字符，剩下唯一字符\n\n→ Step 5: 輸出 xorVal 作為答案 // 打印新增字母\n\nEnd // 程式結束\n\nBut we need \"Step\" maybe with a number? Format example shows \"Step 1:\". We'll follow that. Add decision? Not needed.\n\nBut to follow requirement: Each line must have \"虛擬碼步驟 [空格] // 解釋\". Use arrow: \"→\". Use Start, End.\n\nLet's produce.\n\nUse Start // 程式開始執行\n\n→ Step 1: 初始化 xorVal 為 0 // 用來儲存所有字符的 XOR 結果\n\n→ Step 2: 遍歷字符串 s，對每個字符 c 執行 xorVal = xorVal XOR c // 將 s 中的字符 XOR 到 xorVal\n\n→ Step 3: 遍歷字符串 t，對每個字符 c 執行 xorVal = xorVal XOR c // 將 t 中的字符 XOR 到 xorVal\n\n→ Step 4: xorVal 現在等於 t 中多出的那個字符 // 其餘字符已被對消，剩下唯一字符\n\n→ Step 5: 輸出 xorVal 作為答案 // 將新增字母顯示給使用者\n\nEnd // 程式執行結束\n\nMake sure each line has arrow except Start and End. In example, Start had no arrow. So we produce:\n\nStart // 程式開始執行\n\n→ Step 1: ...\n\n→ Step 2: ...\n\n...\n\nEnd // 程式執行結束\n\nAlso include decisions? Not necessary.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 xorVal 為 0 // 用來儲存所有字符的 XOR 結果  \n→ Step 2: 遍歷字符串 s，對每個字符 c 執行 xorVal = xorVal XOR c // 將 s 中的字符 XOR 到 xorVal  \n→ Step 3: 遍歷字符串 t，對每個字符 c 執行 xorVal = xorVal XOR c // 將 t 中的字符 XOR 到 xorVal  \n→ Step 4: xorVal 現在等於 t 中多出的那個字符 // 其餘字符已被對消，剩下唯一字符  \n→ Step 5: 輸出 xorVal 作為答案 // 將新增字母顯示給使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef find_the_difference(s: str, t: str) -> str:\n    \"\"\"利用 XOR 找出 t 中多出的那個字母。\"\"\"\n    xor_val = 0\n    for ch in s:\n        xor_val ^= ord(ch)\n    for ch in t:\n        xor_val ^= ord(ch)\n    return chr(xor_val)\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入中提取兩個字串 s 與 t。\n    支援：\n    1. 「s = \"abcd\", t = \"abcde\"」格式\n    2. 兩行分別為 s 和 t\n    3. 兩個空格分隔的字串\n    \"\"\"\n    # 先嘗試匹配雙引號中的內容\n    matches = re.findall(r'\"(.*?)\"', data)\n    if len(matches) == 2:\n        return matches[0], matches[1]\n\n    # 再嘗試兩行分隔\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n\n    # 最後嘗試空格分隔\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # 如果都沒抓到，直接回傳原始資料\n    return data.strip(), \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s_str, t_str = parse_input(raw_input)\n    result = find_the_difference(s_str, t_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "success": true,
          "output": "e"
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "success": true,
          "output": "y"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode75.json",
    "problem_index_in_file": 0,
    "title": "Sort Colors",
    "description_snippet": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for Dutch National Flag problem. We need to output line by line, each with virtual code step and comment. Use arrow \"→\" and \"Yes →\", \"No →\". Provide Start and End. The virtual code steps can be something like:\n\nStart // start\n→ Step 1: initialize low=0, mid=0, high=n-1 // set pointers\n→ Decision: While mid <= high? // loop condition\n    Yes → Step 2: If nums[mid]==0 // check value\n        Yes → Step 3: swap nums[low] and nums[mid] // swap red to front\n                → Step 4: low++ ; mid++ // move pointers\n        No → Step 5: If nums[mid]==1 // white\n            Yes → Step 6: mid++ // move mid\n            No → Step 7: If nums[mid]==2 // blue\n                Yes → Step 8: swap nums[mid] and nums[high] // swap blue to end\n                        → Step 9: high-- // move high pointer\n    No → End loop\nEnd\n\nWe should keep each line separate. We might need to include indentation for nested decisions? The format example shows indentation with spaces before the inner decisions.\n\nWe need to use \"Decision:\" before condition. For decisions we may need \"Yes →\" and \"No →\" lines. We should maintain proper indentation: maybe use four spaces indent for nested.\n\nWe'll produce step numbers maybe not necessary. We can just use descriptive labels. Use \"Step X\" with description.\n\nWe also need to follow \"每行虛擬碼步驟 + [空格] + // 解釋/說明\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: low = 0; mid = 0; high = n - 1 // 初始化三個指標\n→ Decision: mid <= high? // 循環條件：是否還有未處理元素\n    Yes → Step 2: if nums[mid] == 0 // 若當前元素為紅色\n        Yes → Step 3: swap(nums[low], nums[mid]) // 將紅色移至前面\n                → Step 4: low++; mid++ // 更新指標\n        No → Step 5: if nums[mid] == 1 // 若當前元素為白色\n            Yes → Step 6: mid++ // 白色保持位置\n            No → Step 7: if nums[mid] == 2 // 若當前元素為藍色\n                Yes → Step 8: swap(nums[mid], nums[high]) // 將藍色移至後面\n                        → Step 9: high-- // 更新後端指標\n    No → End // 循環結束\nEnd // 程式結束\n\nBut the indentation: we can indent inner steps by spaces.\n\nAlso \"Decision:\" lines are separate lines? The example shows Decision line, then Yes/No lines under it indented. So we need to use \"Decision:\" line and then \"Yes →\" and \"No →\" lines with indentation.\n\nWe need to keep each line separate with virtual code step and comment. We can use \"→\" for steps, \"Decision:\" for decision, \"Yes →\" and \"No →\" for branches.\n\nWe need to ensure each line ends with // comment. For steps that have multiple actions we can chain them? But we should keep each line separate. We can break into multiple steps: Step 1, Step 2, etc.\n\nLet's produce the final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0; mid = 0; high = n - 1 // 初始化低、中、高三個指標  \n→ Decision: mid <= high? // 只要中指標不超過高指標就繼續處理  \n    Yes → Step 2: if nums[mid] == 0 // 若中指標指向紅色元素  \n        Yes → Step 3: swap(nums[low], nums[mid]) // 把紅色交換到前面  \n                → Step 4: low++; mid++ // 移動低指標與中指標  \n        No → Step 5: if nums[mid] == 1 // 若中指標指向白色元素  \n            Yes → Step 6: mid++ // 白色保持位置，僅移動中指標  \n            No → Step 7: if nums[mid] == 2 // 若中指標指向藍色元素  \n                Yes → Step 8: swap(nums[mid], nums[high]) // 把藍色交換到後面  \n                        → Step 9: high-- // 移動高指標  \n    No → End // mid > high 時結束循環  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef sortColors(nums):\n    \"\"\"\n    Rearrange nums in-place so that 0s come first, then 1s, then 2s.\n    \"\"\"\n    low, mid, high = 0, 0, len(nums) - 1\n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:  # nums[mid] == 2\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1\n    return nums\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list expression between '[' and ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        nums = []\n    else:\n        nums = eval(data[start:end + 1])\n    sortColors(nums)\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,0,2,1,1,0]",
          "expected_output": "[0,0,1,1,2,2]",
          "success": true,
          "output": "[0, 0, 1, 1, 2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,0,1]",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode378.json",
    "problem_index_in_file": 0,
    "title": "K^th Smallest Element in a Sorted Matrix",
    "description_snippet": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find kth smallest in sorted matrix. Use binary search on value range, counting <= mid via binary search per row or from bottom-left. Complexity O(n log(range)). Memory O(1). Provide step-by-step with arrows and comments. Use Start, Decision, End.\n\nWe need to generate virtual code lines. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow → for steps. Use Decision. Let's outline:\n\nStart\n→ Initialize low = matrix[0][0] // smallest element\n→ Initialize high = matrix[n-1][n-1] // largest element\n→ While low < high:\n    → Decision: if count <=? Actually need loop: while low < high:\n         mid = low + (high - low) // 2\n         count = 0\n         i = n-1; j=0\n         while i >=0 and j < n:\n             if matrix[i][j] <= mid:\n                 count += i+1\n                 j +=1\n             else:\n                 i -=1\n         Decision: if count >= k? // enough elements <= mid\n             high = mid\n         else\n             low = mid +1\n→ End while\n→ Return low // kth smallest\n\nAlso we need explanation after each line.\n\nLet's produce step by step.\n\nNeed to follow format: \"Start // 程式開始執行\". Each line includes arrow. For decisions, indent. Provide comments.\n\nLet's craft.\n\nWe also should show initialization of n? We can assume matrix variable defined, n = len(matrix). Provide step: n = length.\n\nWe need to produce memory complexity note maybe. Provide explanation.\n\nLet's produce.\n\nAlso we may mention using binary search on value range. Provide comments.\n\nEnsure each line ends with // 解釋. Use Traditional Chinese.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ n = length(matrix) // 取得矩陣的維度  \n→ low = matrix[0][0] // 最小元素作為搜尋下界  \n→ high = matrix[n-1][n-1] // 最大元素作為搜尋上界  \n→ While low < high: // 進行值域二分搜尋  \n    → mid = low + (high - low) // 計算中值  \n    → count = 0 // 初始化小於等於 mid 的元素數目  \n    → i = n-1 // 從最底部開始搜尋  \n    → j = 0 // 從最左邊開始搜尋  \n    → While i >= 0 and j < n: // 遍歷矩陣以計算 count  \n        → Decision: matrix[i][j] <= mid? // 判斷當前元素是否小於等於 mid  \n            Yes → count += i + 1 // 這一列中所有 i+1 個元素都 <= mid  \n            Yes → j += 1 // 前往下一列  \n            No  → i -= 1 // 向上一行  \n    → Decision: count >= k? // 判斷小於等於 mid 的元素是否足夠  \n        Yes → high = mid // k 個元素都在 [low, mid] 範圍內，縮小上界  \n        No  → low = mid + 1 // 必須在更大的範圍內尋找  \n→ End While // 二分搜尋結束，low 即為第 k 小元素  \n→ Return low // 回傳答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef kth_smallest(matrix, k):\n    n = len(matrix)\n    low = matrix[0][0]\n    high = matrix[-1][-1]\n    while low < high:\n        mid = low + (high - low) // 2\n        # Count elements <= mid using bottom‑left traversal\n        i, j = n - 1, 0\n        count = 0\n        while i >= 0 and j < n:\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n        if count >= k:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 支援「matrix = ... , k = ...」格式\n    if 'matrix =' in data:\n        _, rest = data.split('matrix =', 1)\n        matrix_part, k_part = rest.split(', k =', 1)\n        matrix = ast.literal_eval(matrix_part.strip())\n        k = int(k_part.strip())\n    else:\n        # 其他簡單格式：第一行矩陣，第二行 k\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            matrix = ast.literal_eval(lines[0].strip())\n            k = int(lines[1].strip())\n        else:\n            return\n    result = kth_smallest(matrix, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "success": true,
          "output": "13"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "success": true,
          "output": "-5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode164.json",
    "problem_index_in_file": 0,
    "title": "Maximum Gap",
    "description_snippet": "Given an integer array nums, return the maximum difference between two successive elements in its so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. Algorithm: linear time, linear space: use bucket sort approach (Pigeonhole). Steps: if len<2 return 0. Compute min and max. If min==max return 0. Compute bucket size = ceil((max-min)/(n-1)). Use buckets array of size n-1, each bucket holds min and max. Initialize buckets min=inf, max=-inf. For each number, find bucket index = (num-min)//bucket_size. Skip if num==min or num==max? Actually they go to bucket index. Fill. Then traverse buckets computing max gap between prev_max and bucket_min. Also consider edges: max - last bucket's max. Return max gap. Use linear time.\n\nNeed to produce virtual code step by step with explanation.\n\nLet's write.\n\nAlso use Start, End, Decision.\n\nWe must produce only virtual code lines. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's create.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 從使用者處取得整數陣列  \n→ Decision: 若 nums 長度 < 2? // 檢查是否不足兩個元素  \n    Yes → Step 2: 回傳 0 // 沒辦法計算差距  \n    No → Step 3: 計算 minVal = min(nums), maxVal = max(nums) // 找出最小與最大值  \n→ Decision: 若 minVal == maxVal? // 所有元素相同  \n    Yes → Step 4: 回傳 0 // 差距皆為 0  \n    No → Step 5: 設定 bucketSize = ceil((maxVal - minVal) / (len(nums)-1)) // 計算每個桶的大小  \n→ Step 6: 建立 buckets 陣列長度為 len(nums)-1，內部為 {bucketMin: +∞, bucketMax: -∞} // 初始化桶  \n→ Step 7: 對每個 num in nums  \n    → Decision: 若 num == minVal 或 num == maxVal? // 這兩個值不需要放入桶，直接處理  \n        Yes → 跳過 // 不放入桶  \n        No → Step 8: 計算 bucketIndex = (num - minVal) // bucketSize // 確定桶編號  \n        → Step 9: 更新 bucket[bucketIndex].bucketMin = min(bucketMin, num)  \n        → Step 10: 更新 bucket[bucketIndex].bucketMax = max(bucketMax, num)  \n→ Step 11: 設定 maxGap = 0, prevMax = minVal // prevMax 代表前一個非空桶的最大值  \n→ Step 12: 對每個 bucket in buckets  \n    → Decision: 若 bucket.bucketMin == +∞? // 棚空桶  \n        Yes → 跳過 // 無元素  \n        No → Step 13: maxGap = max(maxGap, bucket.bucketMin - prevMax) // 取前一桶最大值到本桶最小值的差  \n        → Step 14: prevMax = bucket.bucketMax // 更新前一桶最大值  \n→ Step 15: maxGap = max(maxGap, maxVal - prevMax) // 最後一個桶到全局最大值的差  \n→ Step 16: 回傳 maxGap // 給出最大相鄰差距  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\nimport ast\nfrom typing import List\n\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        # 1. 小於兩個元素時直接回傳 0\n        if len(nums) < 2:\n            return 0\n\n        # 2. 找出最小值與最大值\n        min_val = min(nums)\n        max_val = max(nums)\n\n        # 3. 如果所有數值相同，差距皆為 0\n        if min_val == max_val:\n            return 0\n\n        n = len(nums)\n        # 4. 計算桶的大小，使用 ceil 以確保能覆蓋所有數值\n        bucket_size = math.ceil((max_val - min_val) / (n - 1))\n\n        # 5. 建立 n-1 個桶，每個桶記錄最小值與最大值\n        bucket_min = [math.inf] * (n - 1)\n        bucket_max = [-math.inf] * (n - 1)\n\n        # 6. 將數值分配到相對應的桶\n        for num in nums:\n            if num == min_val or num == max_val:\n                continue  # 這兩個極值不放入桶\n            idx = (num - min_val) // bucket_size\n            bucket_min[idx] = min(bucket_min[idx], num)\n            bucket_max[idx] = max(bucket_max[idx], num)\n\n        # 7. 遍歷桶，計算最大相鄰差距\n        max_gap = 0\n        prev_max = min_val\n        for i in range(n - 1):\n            if bucket_min[i] == math.inf:\n                continue  # 空桶\n            max_gap = max(max_gap, bucket_min[i] - prev_max)\n            prev_max = bucket_max[i]\n\n        # 8. 最後一個桶到最大值的差距\n        max_gap = max(max_gap, max_val - prev_max)\n        return max_gap\n\ndef parse_input(input_str: str) -> List[int]:\n    \"\"\"\n    解析類似 'nums = [3,6,9,1]' 或僅有列表 '[3,6,9,1]' 的輸入字串。\n    \"\"\"\n    s = input_str.strip()\n    if s.lower().startswith(\"nums\"):\n        # 取等號右邊的內容\n        s = s.split('=', 1)[1].strip()\n    # 使用 literal_eval 以避免 eval 的安全風險\n    try:\n        nums = ast.literal_eval(s)\n    except Exception as e:\n        raise ValueError(f\"無法解析輸入: {s}\") from e\n    if not isinstance(nums, list):\n        raise ValueError(\"輸入必須為整數列表\")\n    return nums\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read()\n    # 解析為列表\n    nums_list = parse_input(raw_input)\n    # 計算結果\n    result = Solution().maximumGap(nums_list)\n    # 輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [10]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode350.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays II",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code with steps and explanations. Format: each line \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. Let's outline algorithm: Use hash map to count freq in nums1, then iterate nums2, if count > 0 add to result, decrement count. Return result array. We'll generate steps accordingly.\n\nWe need to produce a list of virtual code steps. Use \"Start //\". \"→\" to denote flow.\n\nLet's create:\n\nStart\n→ Step 1: 初始化哈希表 countMap // 统计 nums1 的元素出现次数\n→ Step 2: 遍历 nums1，将每个数计入 countMap\n→ Step 3: 初始化结果列表 result // 用于存放交集\n→ Step 4: 遍历 nums2 // 检查每个元素是否在 countMap 中且计数>0\n    → Decision: countMap 中该元素计数 > 0? // 判断是否能加入结果\n        Yes → Step 5: 将该元素添加到 result // 交集元素\n        Yes → Step 6: 将 countMap 中该元素计数减 1 // 处理重复出现\n        No  → Step 7: 跳过该元素 // 不满足条件\n→ Step 8: 返回 result // 输出交集数组\nEnd\n\nNeed to ensure \"Yes →\" and \"No →\" each line with indentation.\n\nLet's craft.\n\nAlso need to maintain formatting: use arrow for each step, but within decision, the Yes and No branches.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化空哈希表 countMap // 用於存儲 nums1 中每個元素的出現次數\n→ Step 2: 對 nums1 中的每個元素 num 做:\n    → Action: 如果 countMap 中已存在 num, 則將其值加 1\n    → Action: 否則將 countMap[num] 設為 1\n→ Step 3: 初始化空列表 result // 用於存放交集元素\n→ Step 4: 對 nums2 中的每個元素 num 做:\n    → Decision: countMap[num] 存在且 > 0? // 是否能加入交集\n        Yes → Step 5: 把 num 添加到 result // 加入交集\n        Yes → Step 6: 把 countMap[num] 減 1 // 更新剩餘次數\n        No  → Step 7: 跳過該元素 // 不符合條件\n→ Step 8: 回傳 result // 結束並返回交集結果\nEnd // 程式執行結束\n\nBut the format requires each line \"虛擬碼步驟 // 解釋\" and using arrows and structure. The indentation lines within decision may also be separate lines.\n\nMake sure to use \"Decision:\" line then branches. So maybe:\n\n→ Decision: countMap[num] 存在且 > 0? // 判斷元素是否能加入結果\n    Yes → Step 5: 把 num 添加到 result // 加入交集\n    Yes → Step 6: 把 countMap[num] 減 1 // 更新次數\n    No  → Step 7: 跳過該元素 // 不符合條件\n\nBut we cannot have duplicate \"Yes\". Typically we have two branches: Yes and No. Here we need two actions on Yes. We could split into two separate steps within Yes: first add, second decrement. But arrow for each. Might have two Yes lines.\n\nLet's produce as:\n\n→ Decision: countMap[num] 存在且 > 0? // 判斷元素是否能加入結果\n    Yes → Step 5: 把 num 添加到 result // 加入交集\n    Yes → Step 6: 把 countMap[num] 減 1 // 更新次數\n    No  → Step 7: 跳過該元素 // 不符合條件\n\nBut there might be confusion: two Yes lines, same condition. It's fine, as each step after Yes.\n\nAlternatively we can combine into one step: but we need two operations. It's okay.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 countMap // 用於存儲 nums1 中每個元素的出現次數  \n→ Step 2: 對 nums1 中的每個元素 num 做:  \n  → Action: 若 countMap[num] 存在，將其值加 1  \n  → Action: 否則將 countMap[num] 設為 1  \n→ Step 3: 初始化空列表 result // 用於存放交集元素  \n→ Step 4: 對 nums2 中的每個元素 num 做:  \n  → Decision: countMap[num] 存在且 > 0? // 判斷元素是否能加入結果  \n   Yes → Step 5: 把 num 添加到 result // 加入交集  \n   Yes → Step 6: 把 countMap[num] 減 1 // 更新剩餘次數  \n   No  → Step 7: 跳過該元素 // 不符合條件  \n→ Step 8: 回傳 result // 結束並返回交集結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        Return the intersection of two integer lists, including duplicates\n        as many times as they appear in both lists.\n        \"\"\"\n        count1 = Counter(nums1)\n        count2 = Counter(nums2)\n        result = []\n        # Iterate over the smaller counter for efficiency\n        if len(count1) > len(count2):\n            count1, count2 = count2, count1\n        for num in count1:\n            if num in count2:\n                result.extend([num] * min(count1[num], count2[num]))\n        return result\n\ndef parse_input(text):\n    \"\"\"\n    Parse a string that contains assignments like:\n    'nums1 = [1,2,2,1], nums2 = [2,2]'\n    into a dictionary {'nums1': [...], 'nums2': [...]}.\n    \"\"\"\n    # Remove newlines and surrounding whitespace\n    text = text.strip().replace('\\n', ' ')\n    if not text:\n        return {}\n    # Wrap the assignments in braces to form a dictionary literal\n    dict_str = '{' + text + '}'\n    # Use ast.literal_eval for safe evaluation\n    return ast.literal_eval(dict_str)\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read()\n    data = parse_input(raw_input)\n    # Extract the two lists; default to empty lists if not provided\n    nums1 = data.get('nums1', [])\n    nums2 = data.get('nums2', [])\n    # Compute intersection and print the result\n    sol = Solution()\n    intersection = sol.intersect(nums1, nums2)\n    print(intersection)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpk40c8uj2.py\", line 40, in <module>\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk40c8uj2.py\", line 35, in parse_input\n    return ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {nums1 = [1,2,2,1], nums2 = [2,2]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp5am7u_ya.py\", line 40, in <module>\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5am7u_ya.py\", line 35, in parse_input\n    return ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {nums1 = [4,9,5], nums2 = [9,4,9,8,4]}\n     ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode691.json",
    "problem_index_in_file": 0,
    "title": "Stickers to Spell Word",
    "description_snippet": "We are given n different types of stickers. Each sticker has a lowercase English word on it.\nYou wou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a virtual code step-by-step for solving the problem of minimum stickers needed to form target. The algorithm likely uses DP with bitmask or BFS/DP over subsets. Since stickers unlimited, typical solution: DP over subsets of target characters? Actually typical LeetCode problem: Minimum Stickers. Use memoization with recursion: For each state (remaining target string sorted), compute min stickers. Complexity: 2^target length.\n\nBut we need to produce virtual code steps in specified format. We need to explain each line. Provide step-by-step pseudocode.\n\nThe problem: infinite stickers, each sticker word; we can cut letters. We need minimum stickers.\n\nAlgorithm: use DFS with memoization. Precompute sticker counts. Sort target, use recursion: for remaining string, pick first char, try each sticker that contains that char, reduce counts, form new remaining string, recursively compute. Use memo.\n\nSimplify: For each sticker, compute letter counts array of size 26. For recursion, we maintain remaining string as array of counts or string.\n\nWe can produce virtual code:\n\nStart\n→ Compute stickerCounts: for each sticker, count letters → Step 1\n→ Define memo map: string→int → Step 2\n→ Define function dfs(remainingString) → Step 3\n    → If remainingString is empty: return 0\n    → If remainingString in memo: return memo[remainingString]\n    → minStickers = INF\n    → For each sticker in stickers: \n        → If sticker does not contain first char of remainingString: continue\n        → newRemaining = subtract counts of sticker from remainingString\n        → sub = dfs(newRemaining)\n        → If sub != -1: minStickers = min(minStickers, 1+sub)\n    → If minStickers == INF: result = -1 else result = minStickers\n    → memo[remainingString] = result\n    → return result\n→ Call result = dfs(target)\n→ If result == -1: print -1 else print result\nEnd\n\nNeed to produce each line with comment after // explanation.\n\nWe must ensure each line uses \"虛擬碼步驟\" and comment. Use arrows → and indentation for decisions.\n\nWe'll produce in Chinese. Use \"Start // 程式開始執行\" etc. Provide step by step.\n\nAlso include decisions: e.g., Decision: If remainingString empty? etc.\n\nLet's craft.\n\nWe need to avoid actual code. Provide virtual steps. We should maintain format: each line includes \"→\" or \"Start\". Use proper indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 先把每張貼紙轉成 26 個字母的計數表 // 方便後續扣減  \n→ Step 2: 建立快取 memo: 目標剩餘字串 → 最小貼紙數 // 速度提升  \n→ Decision: 是否要定義遞迴函式 dfs(remaining)？ // 決定是否需要遞迴  \n    Yes → Step 3: 定義 dfs(remainingString) // 開始遞迴  \n        → Decision:  remainingString 為空？ // 基本結束情形  \n            Yes → Step 4: 回傳 0 // 不需要貼紙  \n            No  → Step 5: 若 remainingString 已在 memo，回傳 memo[remainingString] // 直接取快取  \n        → Step 6: 初始化 minStickers = INF // 記錄目前最小貼紙數  \n        → For each sticker in stickers: // 嘗試每張貼紙  \n            → Decision: sticker 中是否包含 remainingString 的第一個字母？ // 篩選有效貼紙  \n                Yes → Step 7: newRemaining = remainingString 減去 sticker 的字母計數 // 扣掉已用字母  \n                → Step 8: sub = dfs(newRemaining) // 递归求解剩餘字串  \n                → Decision: sub 是否為 -1？ // 判斷是否可行  \n                    Yes → Step 9: // 跳過不可行的貼紙  \n                    No  → Step 10: minStickers = min(minStickers, 1 + sub) // 更新最小貼紙數  \n        → Decision: minStickers 是否仍為 INF？ // 判斷是否有可行方案  \n            Yes → Step 11: result = -1 // 無法完成  \n            No  → Step 12: result = minStickers // 找到最小貼紙數  \n        → Step 13: memo[remainingString] = result // 記錄結果  \n        → Step 14: 回傳 result // 結束遞迴  \n→ Step 15: result = dfs(target) // 從目標字串開始遞迴  \n→ Decision: result 是否為 -1？ // 判斷是否成功  \n    Yes → Step 16: 輸出 -1 // 任務無法完成  \n    No  → Step 17: 輸出 result // 最小貼紙數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def minStickers(self, stickers, target):\n        # Precompute letter count for each sticker\n        sticker_counts = [Counter(s) for s in stickers]\n        memo = {}\n\n        def dp(t):\n            if t == \"\":\n                return 0\n            if t in memo:\n                return memo[t]\n\n            t_count = Counter(t)\n            best = float('inf')\n\n            for sc in sticker_counts:\n                # Skip stickers that don't contain the first needed letter\n                if t[0] not in sc:\n                    continue\n                # Build new remaining string after using this sticker\n                new_t = \"\".join(\n                    c * max(0, t_count[c] - sc.get(c, 0))\n                    for c in t_count\n                )\n                sub = dp(new_t)\n                if sub != -1:\n                    best = min(best, 1 + sub)\n\n            memo[t] = -1 if best == float('inf') else best\n            return memo[t]\n\n        return dp(target)\n\ndef parse_input(data: str):\n    \"\"\"Parse input of form: stickers = [...], target = \"...\" \"\"\"\n    # Extract stickers list\n    lst_start = data.find('[')\n    lst_end = data.find(']', lst_start)\n    stickers_part = data[lst_start:lst_end + 1]\n    stickers = ast.literal_eval(stickers_part)\n\n    # Extract target string\n    target_key = data.find('target', lst_end)\n    if target_key == -1:\n        target = \"\"\n    else:\n        eq = data.find('=', target_key)\n        target_expr = data[eq + 1 :].strip()\n        comma = target_expr.find(',')\n        if comma != -1:\n            target_expr = target_expr[:comma].strip()\n        target = ast.literal_eval(target_expr)\n\n    return stickers, target\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    stickers, target = parse_input(raw)\n    sol = Solution()\n    result = sol.minStickers(stickers, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "stickers = [\"notice\",\"possible\"], target = \"basicbasic\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode583.json",
    "problem_index_in_file": 0,
    "title": "Delete Operation for Two Strings",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and wor...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for problem: min steps to make word1 and word2 same by deleting chars. Classic: find LCS length, answer = len1 + len2 - 2*LCS. We can produce algorithm: compute LCS via DP. Steps: start, input words, compute lengths, initialize DP table (m+1)x(n+1) with zeros, iterate i from1..m, j from1..n, if chars match set dp[i][j]=dp[i-1][j-1]+1 else dp[i][j]=max(dp[i-1][j], dp[i][j-1]). After loops, lcs=dp[m][n], result = m + n - 2*lcs, output result. End.\n\nNeed to output line by line: \"Start // 程式開始執行\" etc. Each line has virtual code step and comment.\n\nWe'll produce steps: Start, input words, assign m,n, initialize dp, loops, compute lcs, compute steps, output, End.\n\nUse arrow \"→\" before each step. Indent decision if needed? No decisions aside from loops. For loops we can denote as \"→ Loop: i 1 to m\" etc.\n\nLet's craft.\n\nNote: Use 1-based indexing for DP. Each line: \"→ Step: ...\" with comment.\n\nLet's produce.\n\nEnsure each line ends with \"// 解釋\".\n\nMake sure to include decisions for if char equal, else branch. We can use Decision: ... Yes→ ... No→ ... structure inside loop. Provide comments.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入字串 word1, word2 // 從使用者取得兩個字串  \n→ Step 2: 設定 m ← length(word1), n ← length(word2) // 取得兩個字串長度  \n→ Step 3: 建立 DP 表 dp[0..m][0..n] 以 0 初始化 // 用於存儲子問題的最長公共子序列長度  \n→ Loop i 1 to m // 逐行遍歷 word1  \n → Loop j 1 to n // 逐列遍歷 word2  \n  → Decision: word1[i-1] == word2[j-1]? // 判斷目前字符是否相同  \n   Yes → Step 4: dp[i][j] ← dp[i-1][j-1] + 1 // 相同則延長 LCS  \n   No  → Step 5: dp[i][j] ← max(dp[i-1][j], dp[i][j-1]) // 否則取前一行或前一列較大的值  \n→ Step 6: 設定 lcs ← dp[m][n] // 最長公共子序列長度  \n→ Step 7: 計算最小刪除步數 steps ← m + n - 2 * lcs // 兩字串總長減去兩倍 LCS  \n→ Step 8: 輸出 steps // 將結果顯示給使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_steps_to_same(word1: str, word2: str) -> int:\n    \"\"\"\n    透過 LCS（長度相同的子序列）計算最小刪除步數。\n    若 LCS 長度為 lcs，則兩字串總長為 m + n，\n    所以需要刪除 m + n - 2*lcs 個字元。\n    \"\"\"\n    m, n = len(word1), len(word2)\n    # 建立 DP 表 dp[i][j] 代表 word1[:i] 與 word2[:j] 的 LCS 長度\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    lcs = dp[m][n]\n    return m + n - 2 * lcs\n\n\ndef parse_input() -> tuple[str, str]:\n    \"\"\"\n    從 stdin 讀取資料，並抽取兩個字串。\n    支援以下兩種常見輸入格式：\n    1. word1 = \"sea\", word2 = \"eat\"\n    2. word1 = \"sea\"\n       word2 = \"eat\"\n    \"\"\"\n    data = sys.stdin.read()\n    # 先嘗試抓取雙引號內的字串\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n\n    # 若沒有雙引號，則以空白或換行切分\n    parts = re.split(r'\\s+', data.strip())\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # 預設空字串\n    return \"\", \"\"\n\n\ndef main() -> None:\n    word1, word2 = parse_input()\n    result = min_steps_to_same(word1, word2)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"sea\", word2 = \"eat\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "word1 = \"leetcode\", word2 = \"etco\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode28.json",
    "problem_index_in_file": 0,
    "title": "Implement strStr()",
    "description_snippet": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code (like pseudocode) for finding the index of first occurrence of needle in haystack, or -1 if not found. They want it in Traditional Chinese. Must follow format:\n\n- Each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n- Use Start, End, Decision:, arrow.\n\nWe need to produce a step-by-step pseudocode. Should be line-by-line, with indentation maybe.\n\nWe must not output actual code, just pseudocode.\n\nWe should mention variables: n = length of haystack, m = length of needle. Loop over i from 0 to n-m. For each i, check substring equality. If found, return i. If loop ends, return -1.\n\nUse decisions for length check.\n\nWe also need to include a decision about needle length zero: if needle is empty, return 0? Usually in strStr, if needle empty return 0. The spec says \"return index of first occurrence or -1\". Could incorporate.\n\nLet's craft.\n\nStart // program start\n→ Step 1: Set needleLength = length(needle) // get length of needle\n→ Step 2: Set haystackLength = length(haystack) // get length of haystack\n→ Decision: needleLength == 0? // check if needle empty\n    Yes → Return 0 // empty needle found at index 0\n    No  → Decision: needleLength > haystackLength? // needle longer than haystack\n        Yes → Return -1 // cannot be found\n        No  → Step 3: Set i = 0 // start index in haystack\n            → Step 4: While i <= haystackLength - needleLength // iterate over possible positions\n                → Step 5: Set match = true // assume match\n                → Step 6: Set j = 0 // position in needle\n                    → Step 7: While j < needleLength // compare each character\n                        → Decision: haystack[i+j] == needle[j]? // compare characters\n                            Yes → j = j + 1 // advance in needle\n                            No  → match = false // mismatch\n                               → Break // exit inner loop\n                    → Decision: match? // if all characters matched\n                        Yes → Return i // found at index i\n                        No  → i = i + 1 // move to next position\n            → Return -1 // not found after loop\nEnd // program end\n\nWe should format each line with the arrow \"→\" for step lines. For decisions, use \"Decision:\" line. Indentation is not mandatory but for readability.\n\nWe must provide each line with explanation after //.\n\nEnsure Traditional Chinese: use \"程式開始執行\", \"取得長度\", etc.\n\nAlso, note that we need to use \"Yes →\" and \"No →\" after Decision lines.\n\nWe must ensure each line ends with \"// 解釋\".\n\nLet's produce.\n\nNote: The first line: \"Start // 程式開始執行\".\n\nOk.\n\nNow produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set needleLength = length(needle) // 取得子字串長度  \n→ Step 2: Set haystackLength = length(haystack) // 取得大字串長度  \n→ Decision: 針對 needleLength == 0? // 檢查子字串是否為空  \n    Yes → Return 0 // 空子字串視為在索引 0 之處出現  \n    No  → Decision: 針對 needleLength > haystackLength? // 子字串長度大於大字串  \n        Yes → Return -1 // 無法找到，直接返回 -1  \n        No  → Step 3: Set i = 0 // 初始化大字串索引  \n            → Step 4: While i <= haystackLength - needleLength // 遍歷所有可能的位置  \n                → Step 5: Set match = true // 預設為匹配  \n                → Step 6: Set j = 0 // 初始化子字串索引  \n                    → Step 7: While j < needleLength // 比較每個字符  \n                        → Decision: haystack[i+j] == needle[j]? // 字符是否相同  \n                            Yes → j = j + 1 // 進行下個字符比較  \n                            No  → match = false // 發現不匹配  \n                                → Break // 退出內部循環  \n                    → Decision: match? // 所有字符是否都匹配  \n                        Yes → Return i // 找到首次出現的位置  \n                        No  → i = i + 1 // 移動到下一個起始位置  \n            → Return -1 // 循環結束仍未找到，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef strStr(haystack: str, needle: str) -> int:\n    \"\"\"\n    找出 needle 在 haystack 中首次出現的位置。\n    若 needle 為空字串，依照 LeetCode 規則回傳 0。\n    若找不到，回傳 -1。\n    \"\"\"\n    if not needle:\n        return 0\n\n    n, m = len(haystack), len(needle)\n    for i in range(n - m + 1):\n        if haystack[i:i + m] == needle:\n            return i\n    return -1\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，格式為：\n        haystack = \"...\" , needle = \"...\"\n    解析 haystack 與 needle，呼叫 strStr，並將結果列印出來。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 使用正則表達式抓取兩個 quoted 字串\n    pattern = re.compile(r'haystack\\s*=\\s*\"([^\"]*)\",\\s*needle\\s*=\\s*\"([^\"]*)\"')\n    match = pattern.search(data)\n    if match:\n        haystack, needle = match.group(1), match.group(2)\n    else:\n        # 若格式不符，嘗試用簡單的 split 方式解析\n        parts = [p.strip() for p in data.split(',')]\n        haystack = needle = \"\"\n        for part in parts:\n            if part.startswith('haystack'):\n                haystack = part.split('=', 1)[1].strip().strip('\"')\n            elif part.startswith('needle'):\n                needle = part.split('=', 1)[1].strip().strip('\"')\n    result = strStr(haystack, needle)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "haystack = \"sadbutsad\", needle = \"sad\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "haystack = \"leetcode\", needle = \"leeto\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode605.json",
    "problem_index_in_file": 0,
    "title": "Can Place Flowers",
    "description_snippet": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in Chinese, step by step, with explanations. It's about the problem: can we plant n new flowers in a flowerbed array of 0/1 with no adjacent ones. Classic solution: iterate over array, if current is 0 and neighbors are 0 or out of bounds, plant (set to 1) and decrement n. After loop, return n <= 0. The pseudocode should reflect that.\n\nWe need to output each line with \"虛擬碼步驟 // 解釋/說明\" format, using arrows.\n\nWe should include Start, End, Decision, etc.\n\nWe should not output actual code, just virtual steps.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 index i 為 0 // 設定迴圈起點\n→ Decision: i < flowerbed.length? // 檢查是否已遍歷完所有欄位\n    Yes → Step 2: 檢查當前欄位是否為 0? // 只處理空位\n        Yes → Decision: 左鄰是否為 1? 或 i==0? // 左邊空或不存在\n            Yes → Decision: 右鄰是否為 1? 或 i==length-1? // 右邊空或不存在\n                Yes → Step 3: 在當前欄位種植花朵 (設為 1) // 符合條件可種植\n                No → Step 4: 不種植 // 右邊已有花\n            No → Step 4: 不種植 // 左邊已有花\n        No → Step 5: 跳過此欄位 // 不是空位\n    No → End // 完成遍歷\n→ Step 6: 返回 n <= 0 // 判斷是否已種滿需求\n\nBut we also need to decrement n after planting. So after Step 3 we should decrement n.\n\nAlso after each iteration, we need i++.\n\nSo we need steps for incrementing index.\n\nLet's structure:\n\nStart\n→ Step 1: i ← 0 // 設定索引\n→ Decision: i < length? // 是否還有欄位未檢查\n    Yes → Step 2: If flowerbed[i] == 0? // 只在空位進一步檢查\n        Yes → Decision: (i == 0 OR flowerbed[i-1] == 0)? // 左邊空或不存在\n            Yes → Decision: (i == length-1 OR flowerbed[i+1] == 0)? // 右邊空或不存在\n                Yes → Step 3: flowerbed[i] ← 1 // 種花\n                → Step 4: n ← n - 1 // 需求減一\n            No → // 右邊已有花\n        No → // 左邊已有花\n    No → // 當前非空\n    No → // 不是空位\n    No → // 左右都有空\n→ Step 5: i ← i + 1 // 移動到下一個欄位\n→ Go back to Decision: i < length? // 迴圈結束條件\n\nAfter loop:\n\n→ Step 6: return n <= 0 // 判斷是否足夠種植\n\nWe need to use virtual code arrows and structure. Use \"Decision:\" and indent.\n\nLet's craft final answer in required format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0 // 設定陣列索引初值  \n→ Decision: i < flowerbed.length? // 判斷是否還有欄位可檢查  \n    Yes → Step 2: If flowerbed[i] == 0? // 只在空位進一步檢查  \n        Yes → Decision: (i == 0 OR flowerbed[i-1] == 0)? // 左邊是否為空或不存在  \n            Yes → Decision: (i == flowerbed.length-1 OR flowerbed[i+1] == 0)? // 右邊是否為空或不存在  \n                Yes → Step 3: flowerbed[i] ← 1 // 種植花朵  \n                → Step 4: n ← n - 1 // 減少需種植數量  \n                No  → // 右邊已有花，不能種植  \n            No  → // 左邊已有花，不能種植  \n        No → // 當前非空，直接跳過  \n    No → // 當前欄位已滿，跳過  \n→ Step 5: i ← i + 1 // 移動到下一個欄位  \n→ (回到 Decision: i < flowerbed.length?) // 迴圈結束條件  \n→ Step 6: return n <= 0 // 判斷是否已種滿需求  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canPlaceFlowers(self, flowerbed, n):\n        \"\"\"判斷能否在 flowerbed 中種植 n 棵花而不違反相鄰規則\"\"\"\n        count = 0\n        length = len(flowerbed)\n        i = 0\n        while i < length:\n            if flowerbed[i] == 0:\n                empty_prev = (i == 0) or (flowerbed[i - 1] == 0)\n                empty_next = (i == length - 1) or (flowerbed[i + 1] == 0)\n                if empty_prev and empty_next:\n                    flowerbed[i] = 1\n                    count += 1\n                    if count >= n:\n                        return True\n                    i += 1  # skip next plot because it cannot have a flower\n            i += 1\n        return count >= n\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 解析花床列表\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if list_match:\n        list_str = list_match.group(1).strip()\n        flowerbed = [int(x.strip()) for x in list_str.split(',')] if list_str else []\n    else:\n        flowerbed = []\n\n    # 解析 n\n    n_match = re.search(r'n\\s*=\\s*([0-9]+)', data)\n    n = int(n_match.group(1)) if n_match else 0\n\n    result = Solution().canPlaceFlowers(flowerbed, n)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "flowerbed = [1,0,0,0,1], n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "flowerbed = [1,0,0,0,1], n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode768.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted II",
    "description_snippet": "You are given an integer array arr.\n\nWe split arr into some number of chunks (i.e., partitions), and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm: Given integer array arr, we want largest number of chunks to partition such that sorting each chunk and concatenating gives sorted array. Equivalent to LeetCode 768: max chunks to make sorted.\n\nAlgorithm: compute prefix max array and suffix min array; count positions where prefix max <= suffix min next.\n\nPseudo: compute maxLeft[i] = max(arr[0..i]); minRight[i] = min(arr[i..n-1]); For each i from 0 to n-2 if maxLeft[i] <= minRight[i+1] count++ ; return count+1.\n\nAlso handle empty array.\n\nWe need to produce virtual code steps line by line with explanation comments.\n\nLet's generate: Start, Step: if arr empty return 0? Actually if array empty, 0 chunks. But problem may require at least 0? The algorithm returns 0? In LeetCode, result 0 for empty? They might return 0. We'll implement: if length 0 return 0.\n\nImplement: Determine n = len(arr). If n==0 return 0.\n\nCompute prefix max list length n. Set prefixMax[0] = arr[0]. For i from 1 to n-1: prefixMax[i] = max(prefixMax[i-1], arr[i]).\n\nCompute suffix min list length n. Set suffixMin[n-1] = arr[n-1]. For i from n-2 down to 0: suffixMin[i] = min(suffixMin[i+1], arr[i]).\n\nInitialize count=0. For i from 0 to n-2: if prefixMax[i] <= suffixMin[i+1] then count++.\n\nReturn count+1.\n\nEdge: if n==0 return 0 else return count+1.\n\nAlso consider negative numbers, duplicates.\n\nWe produce virtual steps accordingly.\n\nWe must use arrow notation.\n\nLet's output:\n\nStart\n\n→ Step 1: 如果 arr 為空陣列? // 判斷是否有元素\n\n... Provide decision branches.\n\nOk. Let's produce.\n\nWe will use \"Decision:\" with Yes/No arrows.\n\nLet's produce code lines.\n\nUse \"→\" to indent deeper steps.\n\nOk. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: arr 为空? // 檢查輸入是否為空陣列  \n    Yes → Step 1: 返回 0 // 空陣列無法分塊，直接返回 0  \n    No  → Step 2: n ← len(arr) // 取得陣列長度  \n→ Step 3: prefixMax ← new 整數陣列長度 n // 用於存前綫最大值  \n→ Step 4: prefixMax[0] ← arr[0] // 初始化前綫最大值  \n→ Decision: i 取值 1 到 n-1? // 循環計算前綫最大值  \n    Yes → Step 5: prefixMax[i] ← max(prefixMax[i-1], arr[i]) // 更新前綫最大  \n    No  → End of Step 3 // 前綫最大值計算完成  \n→ Step 6: suffixMin ← new 整數陣列長度 n // 用於存後綫最小值  \n→ Step 7: suffixMin[n-1] ← arr[n-1] // 初始化後綫最小值  \n→ Decision: i 取值 n-2 到 0? // 循環計算後綫最小值  \n    Yes → Step 8: suffixMin[i] ← min(suffixMin[i+1], arr[i]) // 更新後綫最小  \n    No  → End of Step 6 // 後綫最小值計算完成  \n→ Step 9: count ← 0 // 用於計數可切分的位置  \n→ Decision: i 取值 0 到 n-2? // 檢查每個分割點  \n    Yes → Decision: prefixMax[i] ≤ suffixMin[i+1]? // 判斷是否可以切分  \n        Yes → Step 10: count ← count + 1 // 可切分，累加計數  \n        No  → Step 11: 不做任何事 // 不能切分，保持計數不變  \n    No  → End of Step 9 // 所有分割點已檢查完畢  \n→ Step 12: result ← count + 1 // 最終切分塊數為可切分點數 + 1  \n→ Step 13: 返回 result // 回傳最大切分數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxChunksToSorted(self, arr):\n        \"\"\"Return the maximum number of chunks that can be sorted to form the sorted array.\"\"\"\n        n = len(arr)\n        if n == 0:\n            return 0\n\n        # Compute the minimum of suffixes\n        right_min = [0] * n\n        right_min[-1] = arr[-1]\n        for i in range(n - 2, -1, -1):\n            right_min[i] = min(arr[i], right_min[i + 1])\n\n        # Scan from left to right, counting valid split points\n        chunks = 0\n        left_max = float('-inf')\n        for i in range(n - 1):\n            left_max = max(left_max, arr[i])\n            if left_max <= right_min[i + 1]:\n                chunks += 1\n\n        return chunks + 1  # Add the last chunk\n\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Extract the list part, handling optional \"arr =\" prefix\n    if '=' in raw_input:\n        _, arr_part = raw_input.split('=', 1)\n        arr_part = arr_part.strip()\n    else:\n        arr_part = raw_input\n\n    # Safely evaluate the list\n    try:\n        arr = ast.literal_eval(arr_part)\n        if not isinstance(arr, list):\n            raise ValueError\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    # Compute and output the result\n    solution = Solution()\n    result = solution.maxChunksToSorted(arr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [5,4,3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [2,1,3,4,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode664.json",
    "problem_index_in_file": 0,
    "title": "Strange Printer",
    "description_snippet": "There is a strange printer with the following two special properties:\n\nThe printer can only print a ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to compute minimum turns of strange printer. Typical DP: dp[i][j] minimal turns to print s[i..j]. Recurrence: dp[i][j] = dp[i][j-1]+1, then for k in [i, j-1] if s[k]==s[j] dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j-1]). Or alternate: dp[l][r] = min over split mid: dp[l][mid]+dp[mid+1][r] then if s[l]==s[r] dp[l][r]--. But typical.\n\nWe need to output step-by-step pseudocode with explanations.\n\nLet's craft a high-level algorithm:\n\nStart\n→ Read string s\n→ n = length(s)\n→ Initialize dp[n][n] to 0\n→ For len from 1 to n:\n    → For i from 0 to n-len:\n        → j = i+len-1\n        → If i==j:\n            → dp[i][j] = 1 // single character\n        → Else:\n            → dp[i][j] = dp[i][j-1] + 1 // worst case: print s[j] separately\n            → For k from i to j-1:\n                → If s[k]==s[j]:\n                    → temp = dp[i][k] + (k+1 <= j-1 ? dp[k+1][j-1] : 0)\n                    → If temp < dp[i][j]: dp[i][j] = temp\n→ Return dp[0][n-1]\nEnd\n\nWe should incorporate decisions and arrows. Each step line includes explanation. We'll format as required: \"Start // ...\" etc. Use arrows \"→\" before each step. For decisions use \"Decision: ...\".\n\nLet's produce lines accordingly. Ensure each line ends with comment.\n\nWe'll include nested loops with indentation but still each line separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read input string s // 取得欲列印的字串  \n→ n ← length(s) // 計算字串長度  \n→ Create 2‑D array dp[n][n] // 用來存最小列印次數  \n\n→ For len ← 1 to n: // 逐長度處理子字串  \n  → For i ← 0 to n−len: // 子字串起始位置  \n    j ← i + len − 1 // 子字串結束位置  \n    Decision: 是否單一字元? // 檢查子字串長度  \n     Yes → dp[i][j] ← 1 // 單個字元只需一次列印  \n     No → \n      dp[i][j] ← dp[i][j−1] + 1 // 預設把 s[j] 單獨列印  \n      → For k ← i to j−1: // 檢查是否能合併列印  \n       Decision: s[k] == s[j]? // 相同字元可合併  \n        Yes → temp ← dp[i][k] + (k+1 ≤ j−1 ? dp[k+1][j−1] : 0) // 合併列印結果  \n         If temp < dp[i][j]: dp[i][j] ← temp // 取最小值  \n\n→ Return dp[0][n−1] // 回傳整個字串的最小列印次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def strangePrinter(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        # dp[i][j] : minimum turns to print s[i..j]\n        dp = [[0] * n for _ in range(n)]\n        # length 1 substrings\n        for i in range(n):\n            dp[i][i] = 1\n        # build up by increasing length\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                # worst case: print s[j] separately after printing s[i..j-1]\n                dp[i][j] = dp[i][j - 1] + 1\n                # try merging s[j] with any same character inside\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        # if k+1 > j-1, dp part is 0\n                        mid = dp[k + 1][j - 1] if k + 1 <= j - 1 else 0\n                        dp[i][j] = min(dp[i][j], dp[i][k] + mid)\n        return dp[0][n - 1]\n\ndef parse_input(data: str) -> str:\n    \"\"\"Extract the string to be printed from the raw input.\"\"\"\n    data = data.strip()\n    if not data:\n        return ''\n    # Case: s = \"aaabbb\"\n    if '\"' in data:\n        first = data.find('\"')\n        second = data.find('\"', first + 1)\n        if second != -1:\n            return data[first + 1:second]\n    # Case: s = aaabbb or similar\n    if '=' in data:\n        parts = data.split('=', 1)\n        return parts[1].strip().strip('\"')\n    # Plain string\n    return data\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    sol = Solution()\n    print(sol.strangePrinter(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabbb\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode377.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum IV",
    "description_snippet": "Given an array of distinct integers nums and a target integer target, return the number of possible ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for the problem: count combinations of distinct integers (each can be used unlimited times? Wait typical problem \"Combination Sum IV\" uses unlimited uses of each element. The phrase \"combinations\" maybe order matters? Usually in this problem (target sum combinations) the answer counts number of sequences where order matters (like coin change with permutations). It's typical dynamic programming. So we need to produce steps: DP array dp[0..target], dp[0]=1. For each i from 1 to target, for each num in nums, if i>=num: dp[i]+=dp[i-num]. Finally return dp[target]. Should mention distinct integers in nums. So produce lines. Use Start, End, Decision. Each line includes virtual code step and explanation. Also include arrows.\n\nWe produce step by step lines. Eg:\n\nStart // 程式開始\n\n→ Step 1: 建立 dp 陣列長度 target+1，並初始化 dp[0] = 1, 其餘為 0 // 用於存放到每個子目標的組合數\n\n→ Step 2: 迭代 i 從 1 到 target // 逐個計算子目標\n\n    → Step 3: 迭代每個 num 在 nums // 嘗試把 num 加入子目標\n\n        → Decision: 如果 i >= num? // 確認 num 可用於組合\n\n            Yes → Step 4: dp[i] += dp[i-num] // 若可用，累加前面子目標的組合數\n\n            No → Step 5: 跳過此 num // 不可用則不做任何事\n\n→ Step 6: 返回 dp[target] // 最終答案\n\nEnd // 程式結束\n\nMake sure each line ends with // 解釋. Use virtual arrows accordingly. The \"Decision\" line might need indentation. Provide structure. Use '→ Decision: ...' and then indent Yes/No lines with some spaces or arrow? Example from example: Yes → ... etc.\n\nWe should keep each line separate. Let's generate.\n\nAlso, we might include step to sort nums? Not necessary. Also mention that we can use unlimited times.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 初始化 dp 陣列長度為 target+1，並設定 dp[0] = 1，其餘元素設為 0 // 建立子目標的組合數表  \n→ Step 2: 從 i = 1 到 target 逐個迭代 // 依序計算每個子目標  \n    → Step 3: 對於 nums 中的每一個 num 進行迭代 // 嘗試將該數字加入子目標  \n        → Decision: i >= num? // 判斷 num 是否能被放入當前子目標  \n            Yes → Step 4: dp[i] = dp[i] + dp[i-num] // 若能，累加前面子目標的組合數  \n            No  → Step 5: 跳過此 num // 若不能，直接忽略此數字  \n→ Step 6: 回傳 dp[target] // 最終返回所有組合的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        dp = [0] * (target + 1)\n        dp[0] = 1  # 基本情況：有一種方法到達目標 0\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入（可以包含換行）\n    raw_input = sys.stdin.read().strip().replace(\"\\n\", \" \")\n    if not raw_input:\n        sys.exit()\n\n    # 解析類似 \"nums = [1,2,3], target = 4\" 的格式\n    # 將分號或逗號分隔的片段拆開\n    parts = raw_input.split(\",\")\n    nums = []\n    target = 0\n    for part in parts:\n        key, value = part.split(\"=\", 1)\n        key = key.strip()\n        value = value.strip()\n        if key == \"nums\":\n            nums = ast.literal_eval(value)\n        elif key == \"target\":\n            target = int(value)\n\n    solution = Solution()\n    result = solution.combinationSum4(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmppa6_94oi.py\", line 30, in <module>\n    nums = ast.literal_eval(value)\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode726.json",
    "problem_index_in_file": 0,
    "title": "Number of Atoms",
    "description_snippet": "Given a string formula representing a chemical formula, return the count of each atom.\n\nThe atomic e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for parsing chemical formula counting atoms. Provide step by step with arrows and explanations. Use virtual code only. Each line: \"虛擬碼步驟 // 解釋\". Provide structure: Start, Decision, etc.\n\nWe need algorithm: parse string with stack, recursion, or using stack of maps. Use index pointer. We'll produce pseudocode.\n\nWe should outline: Start, set stack with empty map, i=0. While i < len: if char '(' push new map, i++; else if char ')' process closing: read number (default 1), pop top map, multiply counts, merge into previous map; i moves; else if uppercase letter: parse element name, parse number, add to current map; else error. After loop, output sorted keys.\n\nWe'll write virtual steps. Use arrow indent for decision branches.\n\nLet's craft.\n\nRemember to use arrow characters. Use indentation. Use \"Decision:\" lines.\n\nAlso at end produce output string building.\n\nWe'll produce lines with explanatory comments.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialise stack with one empty map `stack = [{ }]` // 以堆疊儲存各層公式的原子計數\n→ Set index `i = 0`, let `s = input formula` // 準備從左至右掃描字串\n→ Decision: 是否已經掃描完所有字符? // 判斷是否結束主循環\n    No → Decision: s[i] 是 '('? // 檢查是否為子公式開頭\n        Yes → Push new empty map onto stack, i++ // 新的括號層，開始一個空計數表\n        No  → Decision: s[i] 是 ')'?\n            Yes → i++ // 跳過右括號，接著讀取後面的數字\n            No  → Decision: s[i] 是大寫字母?\n                Yes → // 解析元素名\n                    → 取 `elem = s[i]`，i++ // 讀取首字母\n                    → Decision: i < len(s) 且 s[i] 是小寫字母?\n                        Yes → Loop: while i < len(s) 且 s[i] 是小寫字母, `elem += s[i]`, i++ // 把後續小寫字母加入元素名\n                        No  → // 結束元素名解析\n                    → // 解析數字（如果有）\n                    → `num = 0`\n                    → Decision: i < len(s) 且 s[i] 是數字?\n                        Yes → Loop: while i < len(s) 且 s[i] 是數字, `num = num*10 + (s[i]-'0')`, i++ // 把數字轉為整數\n                        No  → `num = 1` // 若沒有數字，預設為 1\n                    → // 更新當前層計數表\n                    → `top = stack[-1]`\n                    → `top[elem] = top.get(elem, 0) + num` // 加總同一元素\n                No  → // 遇到非預期字符，跳過或報錯\n                    → i++ // 跳過未知字符\n    Yes → // 主循環結束，所有字符已處理完\nEnd // 主循環結束\n→ // 若遇到 ')' 時需要處理括號內的乘數\n    // 這一步放在處理 ')' 之後的分支中\n    → // 讀取乘數\n    → `mul = 0`\n    → Decision: i < len(s) 且 s[i] 是數字?\n        Yes → Loop: while i < len(s) 且 s[i] 是數字, `mul = mul*10 + (s[i]-'0')`, i++ // 取得乘數\n        No  → `mul = 1` // 若沒有數字，乘數為 1\n    → // 取出剛閉合的計數表\n    → `inner = stack.pop()` // 取出子公式的計數表\n    → `prev = stack[-1]` // 父層表\n    → // 將子公式乘以乘數後合併回父層\n    → For each `(k, v)` in `inner`:\n        → `prev[k] = prev.get(k, 0) + v * mul` // 加總計數\n→ // 合併完所有層後，堆疊只剩一個表\n→ `result = stack.pop()` // 最終計數表\n→ // 排序元素並組成輸出字串\n→ `keys = sorted(result.keys())` // 按字典序排序\n→ `output = ''`\n→ For each `k` in `keys`:\n    → `output += k`\n    → `if result[k] > 1: output += str(result[k])` // 只在數量 >1 時附加數字\n→ Return `output` // 回傳符合規格的字串\n\n// 以上虛擬碼描述了從左到右掃描化學式、使用堆疊處理括號、累加元素計數，最後排序並組裝輸出字符串的完整流程。",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def countOfAtoms(self, formula: str) -> str:\n        n = len(formula)\n        i = 0\n\n        def parse() -> defaultdict:\n            nonlocal i\n            cnt = defaultdict(int)\n            while i < n and formula[i] != ')':\n                if formula[i] == '(':\n                    i += 1                      # skip '('\n                    inner = parse()              # parse inside parentheses\n                    i += 1                      # skip ')'\n                    mult = 0\n                    while i < n and formula[i].isdigit():\n                        mult = mult * 10 + int(formula[i])\n                        i += 1\n                    if mult == 0:\n                        mult = 1\n                    for atom, c in inner.items():\n                        cnt[atom] += c * mult\n                else:\n                    # parse element name\n                    start = i\n                    i += 1\n                    while i < n and formula[i].islower():\n                        i += 1\n                    name = formula[start:i]\n                    # parse count\n                    num = 0\n                    while i < n and formula[i].isdigit():\n                        num = num * 10 + int(formula[i])\n                        i += 1\n                    if num == 0:\n                        num = 1\n                    cnt[name] += num\n            return cnt\n\n        counts = parse()\n        parts = []\n        for atom in sorted(counts.keys()):\n            parts.append(atom + (str(counts[atom]) if counts[atom] > 1 else \"\"))\n        return \"\".join(parts)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract the formula string surrounded by double quotes, if present\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        formula = match.group(1)\n    else:\n        formula = data.strip()\n    solution = Solution()\n    result = solution.countOfAtoms(formula)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "formula = \"H2O\"",
          "expected_output": "\"H2O\"",
          "success": true,
          "output": "H2O"
        },
        {
          "example_index": 1,
          "input": "formula = \"Mg(OH)2\"",
          "expected_output": "\"H2MgO2\"",
          "success": true,
          "output": "H2MgO2"
        },
        {
          "example_index": 2,
          "input": "formula = \"K4(ON(SO3)2)2\"",
          "expected_output": "\"K4N2O14S4\"",
          "success": true,
          "output": "K4N2O14S4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode575.json",
    "problem_index_in_file": 0,
    "title": "Distribute Candies",
    "description_snippet": "Alice has n candies, where the i^th candy is of type candyType[i]. Alice noticed that she started to...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Problem: maximum distinct candy types when choosing n/2 candies from array of n even. The answer is min(number of distinct types, n/2). So virtual code: compute set of types, size, n/2, return min. Use structure with Start, End, Decision etc. Provide explanation each line. Use virtual arrow. Use \"→\". Ensure each line includes \"虛擬碼步驟\" plus space then comment. Provide step by step. Let's craft:\n\nStart\n→ Step 1: 計算總糖果數 n ← 長度 of candyType // 取得糖果總數\n→ Step 2: 建立空集合 uniqueTypes // 用來記錄不同種類\n→ Step 3: 對於每個 candy 在 candyType 做\n    → Step 3.1: 將 candy 加入 uniqueTypes // 把種類加入集合\n→ Step 4: 取集合大小 distinctCount ← uniqueTypes 的大小 // 取得不同種類數\n→ Step 5: 取 nHalf ← n 除以 2 // 需要吃的數量上限\n→ Decision: 若 distinctCount 大於 nHalf? // 判斷能吃的種類是否超過上限\n    Yes → Step 6: 回傳 nHalf // 上限是 n/2\n    No  → Step 7: 回傳 distinctCount // 取實際不同種類\nEnd\n\nNeed to adhere to format: each line with 虛擬碼步驟 + space + comment. For indentation, we can use spaces or indentation. Use arrows for decisions. Let's produce exactly.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n ← candyType 的長度 // 取得糖果總數\n→ Step 2: uniqueTypes ← 空集合 // 用來存放不同種類的糖果\n→ Step 3: 對於每個 candy 在 candyType 做 // 逐一遍歷所有糖果\n    → Step 3.1: uniqueTypes ← uniqueTypes ∪ {candy} // 將種類加入集合\n→ Step 4: distinctCount ← uniqueTypes 的大小 // 取得不同種類的數量\n→ Step 5: nHalf ← n 除以 2 // 需要吃的糖果上限\n→ Decision: 如果 distinctCount 大於 nHalf? // 判斷可吃種類是否超過上限\n    Yes → Step 6: 回傳 nHalf // 回傳上限 n/2\n    No  → Step 7: 回傳 distinctCount // 回傳實際不同種類數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中找出第一個 '[' 與 ']' 之間的列表字串，\n    並使用 eval 轉成真正的 Python list。\n    \"\"\"\n    match = re.search(r'\\[.*\\]', text)\n    if not match:\n        return []\n\n    try:\n        # 直接 eval 列表字串，得到 list\n        return eval(match.group(0))\n    except Exception:\n        return []\n\n\ndef max_distinct_candies(candy_type):\n    \"\"\"\n    計算 Alice 能吃到的最大不同種類糖果數量。\n    根據題目限制：只能吃 n / 2 顆，n 為偶數。\n    \"\"\"\n    n = len(candy_type)\n    distinct = len(set(candy_type))   # 不同種類數量\n    return min(distinct, n // 2)       # 取兩者較小值\n\n\ndef main():\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 解析出 candyType 列表\n    candy_type = parse_input(raw_input)\n    # 計算結果並輸出\n    print(max_distinct_candies(candy_type))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candyType = [1,1,2,2,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "candyType = [1,1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "candyType = [6,6,6,6]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode532.json",
    "problem_index_in_file": 0,
    "title": "K-diff Pairs in an Array",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the ar...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, no actual code. Provide explanation per line. The algorithm: count unique pairs with difference k. Approach: use hash map to count occurrences, then iterate unique numbers, for each number check if k==0 -> need freq>=2; else check if num+k exists. Count pairs accordingly. Ensure unique pairs counted once.\n\nLet's produce steps: Start, Step 1: Build frequency map of nums. Step 2: Initialize count=0. Step 3: For each unique number num in map: Decision: if k==0? Yes → if freq[num] >=2 → count++ ; No → Decision: if num + k exists in map → count++ ; End For. End.\n\nAlso need to handle k<0? Problem says k-diff pairs absolute difference equals k, k likely non-negative. We'll mention decision for k<0 -> return 0.\n\nLet's produce virtual steps accordingly with arrows and explanation. Ensure use Decision: If k < 0? etc.\n\nLet's craft.\n\nAlso need to ensure that when checking num+k exists, we count pair once. Since we iterate over unique numbers, counting only when num+k exists. That works.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個哈希表 freq，將每個數字在 nums 中出現的次數記錄下來 // 方便之後快速查詢出現頻率  \n→ Decision: k 是否為負數? // 差值不能為負，若為負則無解  \n    Yes → Step 2: 回傳 0 // 直接結束，無任何 k-diff pair  \n    No →  \n→ Step 2: 初始化變數 pairCount 為 0 // 用於計數獨特的 k-diff pair  \n→ Step 3: 對 freq 中每一個唯一數字 num 進行迭代 // 只需考慮一次每個數字  \n→ Decision: k 是否為 0? // 特殊情況，兩個相同數字的差值為 0  \n    Yes → Decision: freq[num] 是否至少為 2? // 需要兩個以上才形成差值為 0 的 pair  \n        Yes → pairCount ← pairCount + 1 // 計入一個 (num, num) pair  \n        No  → // 什麼也不做，沒有足夠重複數字  \n    No  →  \n→ Decision: num + k 是否存在於 freq? // 檢查能否找到差值為 k 的另一個數字  \n        Yes → pairCount ← pairCount + 1 // 計入 (num, num+k) pair，避免重複  \n        No  → // 什麼也不做，無法配對  \n→ End // 迴圈結束  \n→ Step 4: 回傳 pairCount // 輸出最終計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef find_pairs(nums, k):\n    \"\"\"\n    計算 nums 中所有獨特的 k-diff pair 數量。\n    - 若 k < 0: 差值不可能為負，直接返回 0\n    - k == 0 時，需要出現次數至少為 2 的數字\n    - k > 0 時，對於每個唯一數字 num，若 num + k 存在於數組中則計數\n    \"\"\"\n    if k < 0:\n        return 0\n    freq = Counter(nums)\n    if k == 0:\n        return sum(1 for count in freq.values() if count > 1)\n    return sum(1 for num in freq if num + k in freq)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 將輸入分成數組字串和 k 的兩部分\n    # 以最後一次逗號分割，這樣可以處理包含逗號的列表\n    nums_part, k_part = data.rsplit(',', 1)\n    nums = ast.literal_eval(nums_part.strip())\n    k = int(k_part.strip())\n    result = find_pairs(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode611.json",
    "problem_index_in_file": 0,
    "title": "Valid Triangle Number",
    "description_snippet": "Given an integer array nums, return the number of triplets chosen from the array that can make trian...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for this problem: count number of triplets that can form triangle.\n\nWe need to output in the given format, no actual code. Steps: Start, sort array, then nested loops or two pointers. Explanation each line. Use arrow and decisions. Must be line by line. Provide a step-by-step algorithm. Should include sorting, then for each i as largest side, use two pointers left, right to count pairs where sum>nums[i]. Actually condition: for triangle sides a,b,c sorted a<=b<=c, triangle if a+b>c. So we can sort array ascending. Then for each i from 2 to n-1 as c, set left=0, right=i-1, while left<right: if nums[left]+nums[right]>nums[i], then all pairs between left and right-1 with right will satisfy, count += right-left, right-- else left++.\n\nWe produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Sort array nums ascending // 排序方便判斷三角形條件\n→ Step 2: Initialize count = 0 // 用於累計有效三角形個數\n→ Decision: If nums length < 3? // 無法組成三角形\n    Yes → Step 3: Return count // 直接回傳 0\n    No  → Step 4: For i from 2 to nums.length-1 // 選取最大的邊為 c\n        → Step 5: Set left = 0, right = i-1 // 左右指標尋找 a,b\n        → Decision: While left < right? // 仍有可比對的兩個邊\n            Yes → Decision: If nums[left] + nums[right] > nums[i]? // 判斷是否能形成三角形\n                Yes → Step 6: count += right - left // 所有左邊的 a 都能和 current right 形成三角形\n                Yes → right = right - 1 // 移動右指標\n                No  → left = left + 1 // 移動左指標\n            No  → End loop\n        → End for\n→ Step 7: Return count // 回傳總數\nEnd // 程式結束\n\nWe need to use \"→\" and \"Decision:\" lines.\n\nWe also need to ensure each line has explanation after //.\n\nLet's format each line accordingly.\n\nWe might need to indicate nested decisions, indent or use spacing. Format example uses indent lines inside Decision: block.\n\nWe can follow same indentation style: 4 spaces? The example shows indentation by spaces.\n\nWe'll produce lines accordingly. Use \"Yes →\" and \"No →\" for Decision branches. For loops we use \"→ Step X: ...\" and \"Decision: ...\".\n\nLet's create.\n\nAlso include that we treat i as index of largest side.\n\nWe need to output only virtual code lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort array nums ascending // 先將邊長排序，方便後續判斷三角形條件  \n→ Step 2: Initialize count = 0 // 用於累計能形成三角形的三元組個數  \n→ Decision: 如果 nums 長度 < 3? // 不足三條邊，無法組成三角形  \n  Yes → Step 3: Return count // 直接回傳 0  \n  No  → Step 4: For i from 2 to nums.length - 1 // 以索引 i 為最大邊 (c)  \n   → Step 5: Set left = 0, right = i - 1 // 左右指標尋找兩條較短邊 (a, b)  \n   → Decision: While left < right? // 仍有可比對的兩條邊  \n    Yes → Decision: 如果 nums[left] + nums[right] > nums[i]? // 判斷 a + b 是否大於 c  \n      Yes → Step 6: count += right - left // 右指標右側所有 a 均能與右指標形成三角形  \n      Yes → right = right - 1 // 移動右指標往左  \n      No  → left = left + 1 // 移動左指標往右  \n    No  → End while // 退出 while 循環  \n   → End for // 完成所有可能的最大邊  \n→ Step 7: Return count // 回傳總共能形成三角形的三元組個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def triangleNumber(self, nums):\n        nums.sort()\n        count = 0\n        n = len(nums)\n        for k in range(n-1, 1, -1):\n            i, j = 0, k-1\n            while i < j:\n                if nums[i] + nums[j] > nums[k]:\n                    count += j - i\n                    j -= 1\n                else:\n                    i += 1\n        return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Handle multiple lines: join them\n    data = ' '.join(data.splitlines())\n    if data.startswith('nums ='):\n        nums_str = data[len('nums ='):].strip()\n    else:\n        nums_str = data\n    try:\n        nums = eval(nums_str, {})\n    except Exception:\n        nums = []\n    result = Solution().triangleNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode3.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring Without Repeating Characters",
    "description_snippet": "Given a string s, find the length of the longest substring without duplicate characters....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a virtual code in the format: each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows → and Decision: etc. Should not output actual code.\n\nWe need to design algorithm: sliding window, using map to store last index of each char, or using set.\n\nWe'll produce step-by-step virtual code: Start, input string s, initialize map/array, left pointer 0, maxLen 0. For each right pointer iterate over characters. If char seen before and its index >= left, move left to lastIndex+1. Update maxLen. End.\n\nWe'll produce steps: Start, Step 1: Initialize left=0, maxLen=0, map=empty, Step 2: For each char at index i, Step 3: Check if char exists in map and map[char] >= left, if so, move left to map[char]+1. Step 4: Update map[char] = i. Step 5: Update maxLen = max(maxLen, i-left+1). End, Output maxLen.\n\nUse Decision lines for the condition. Ensure each line has arrow and explanation.\n\nWe'll format each line accordingly. Probably no indentation required, just using arrows. Use '→' at start of step.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定左指標 left = 0，最大長度 maxLen = 0，並建立空的字元索引映射 map // 初始化滑動窗口參數  \n→ Step 2: 從左到右遍歷字串 s 的每個字元，索引為 i // 逐個檢查字元  \n→ Decision: 是否已在 map 中記錄此字元且其索引 ≥ left? // 判斷字元是否重複且落在當前窗口內  \n  Yes → Step 3a: 設定 left = map[字元] + 1 // 移動左指標到重複字元右側  \n  No  → Step 3b: // 無需移動左指標，保持現狀  \n→ Step 4: 更新 map[字元] = i // 記錄或覆寫字元最後出現的索引  \n→ Step 5: 計算當前窗口長度 i - left + 1，並更新 maxLen = max(maxLen, i - left + 1) // 追蹤最長子字串長度  \nEnd // 程式執行結束，最長子字串長度存於 maxLen\n\n(Note: 輸出最終結果為 maxLen。)",
      "generated_code": "import sys\nimport re\n\ndef length_of_longest_substring(s: str) -> int:\n    \"\"\"Return the length of the longest substring without duplicate characters.\"\"\"\n    char_set = set()\n    left = 0\n    max_len = 0\n\n    for right, ch in enumerate(s):\n        # If current char already in the window, shrink window from left\n        while ch in char_set:\n            char_set.remove(s[left])\n            left += 1\n        char_set.add(ch)\n        max_len = max(max_len, right - left + 1)\n    return max_len\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the string value from raw input which may be like\n       's = \"abcabcbb\"' or just 'abcabcbb'. \"\"\"\n    # Find first quoted substring\n    m = re.search(r'[\"\\'](.*?)[\"\\']', raw)\n    if m:\n        return m.group(1)\n    # If no quotes, look for equals sign\n    if '=' in raw:\n        return raw.split('=', 1)[1].strip()\n    return raw.strip()\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = length_of_longest_substring(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcabcbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"bbbbb\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \"pwwkew\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode715.json",
    "problem_index_in_file": 0,
    "title": "Range Module",
    "description_snippet": "A Range Module is a module that tracks ranges of numbers. Design a data structure to track the range...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. We need to interpret requirement: design data structure to track ranges half-open. Provide operations addRange, queryRange, removeRange. Use virtual code lines with explanations.\n\nWe need to produce \"逐行\" pseudocode lines, each line with arrow notation and explanation. We'll design using an interval tree or sorted list of intervals. Provide high-level steps for each operation.\n\nThe user wants virtual code; no actual code. We need to produce something like:\n\nStart\n→ Step: 初始化區間集合為空\n→ Decision: 任何操作?\n\nBut we might show methods.\n\nWe should produce a clear step-by-step algorithm.\n\nProbably produce pseudocode that uses a sorted list of disjoint intervals. Outline addRange, queryRange, removeRange.\n\nWe should produce a linear flow for each method.\n\nMaybe we produce pseudo code for entire class: constructor, addRange, queryRange, removeRange.\n\nLet's craft:\n\nStart\n→ Step 1: RangeModule() // 建立空的區間列表\n→ Step 2: addRange(left,right) // 進入添加區間\n→ Decision: 查找重疊區間\n...\nBut we need to be explicit.\n\nLet's produce separate pseudo code for each method. Each step line with explanation. Use arrow for flow.\n\nUse \"→\" for normal steps, \"Decision:\" lines for conditionals, \"Yes →\", \"No →\" for branches.\n\nWe need to be careful to maintain each line as separate.\n\nLet's produce something like:\n\nStart // 程式開始執行\n\n→ Step: 初始化 intervals 為空有序列表 // 用來儲存已追蹤的區間\n\nThen method definitions: maybe we list each method block separately.\n\nMethod: addRange(left, right)\n\nWe'll describe algorithm: find first interval with end > left, merge all overlapping or adjacent intervals, insert new merged interval.\n\nBut we should keep pseudocode simple: iterate over intervals, find overlapping, adjust left/right, remove overlapped, etc.\n\nSimilarly queryRange: find interval that covers left, and check if interval's end >= right.\n\nRemoveRange: similar to add but remove overlapping parts.\n\nWe should produce a pseudocode representation.\n\nOk let's produce.\n\nWe need to output the lines exactly.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: intervals ← [] // 空的區間列表\n\nThen we might list methods as separate blocks.\n\nMethod: addRange\n→ Step: addRange(left,right) // 新增區間\n\nBut we might keep all inside one flow.\n\nHowever the requirement: \"逐行產生對應的虛擬碼\" maybe for the entire class, including methods. We can output pseudocode lines for the class definition and each method.\n\nWe should keep each line separate.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step: 初始化 intervals 為空列表 // 用來儲存已追蹤的區間\n\n→ Step: 定義 addRange(left, right) // 進入新增區間\n\nWithin addRange:\n\n→ Step: idx ← 第一個 intervals[i].end > left 的索引 // 找到可能重疊的起始位置\n\n→ Decision: idx 是否存在? // 確認有沒有區間可以參考\n\nIf exists, else.\n\nBut we need to illustrate loops.\n\nOk maybe we can use pseudocode like:\n\n→ Step: i ← 0\n→ Decision: i < intervals.length and intervals[i].end < left? // 区间结束在左侧，跳过\n    Yes → i ← i+1 // 跳过\n    No  → // i 指向可能重叠区间或右侧第一个\n\nThen merge.\n\nThis is a bit messy.\n\nAlternative: use high-level logic: \"while current interval overlaps, merge\".\n\nBut we need to maintain each line.\n\nMaybe easier: use pseudocode for operations with conceptual steps.\n\nWe can produce:\n\naddRange:\n→ Step: new_left ← left\n→ Step: new_right ← right\n→ Step: i ← 0\n→ Decision: i < intervals.length? // 迭代区间列表\n    Yes →\n        → Decision: intervals[i].end < new_left? // 区间在左侧，未重叠\n            Yes → i ← i+1\n            No →\n                → Decision: intervals[i].start > new_right? // 区间在右侧，停止\n                    Yes → // 插入新区间\n                        → Step: intervals.insert(i, [new_left, new_right])\n                        → Step: return\n                    No →\n                        → Step: new_left ← min(new_left, intervals[i].start)\n                        → Step: new_right ← max(new_right, intervals[i].end)\n                        → Step: intervals.remove(i) // 删除已合并的区间\n                        → Step: // 继续检查下一个相同索引\n    No  → // 迭代完毕，插入新区间\n        → Step: intervals.append([new_left, new_right])\n\nThis may be enough.\n\nSimilarly for queryRange: find interval containing left.\n\n→ Step: i ← 0\n→ Decision: i < intervals.length? \n   Yes →\n        → Decision: intervals[i].end < left? // interval ends before left\n            Yes → i ← i+1\n            No →\n                → Decision: intervals[i].start <= left? // interval starts before left\n                    Yes →\n                        → Decision: intervals[i].end >= right? // covers right\n                            Yes → return true\n                            No  → return false\n                    No → // left before interval start\n                        → return false\n   No → return false\n\nRemoveRange: similar to addRange but splits.\n\nPseudo:\n\n→ Step: i ← 0\n→ Decision: i < intervals.length? // iterate\n    Yes →\n        → Decision: intervals[i].end <= left? // interval ends before left\n            Yes → i ← i+1\n            No →\n                → Decision: intervals[i].start >= right? // interval starts after right\n                    Yes → // all remaining intervals are beyond removal range\n                        → return\n                    No →\n                        → // There is overlap\n                        → Decision: intervals[i].start < left? // left inside interval\n                            Yes →\n                                → Step: left_interval ← [intervals[i].start, left]\n                                → Step: // keep left part\n                            No →\n                                → // left part not kept\n                        → Decision: intervals[i].end > right? // right inside interval\n                            Yes →\n                                → Step: right_interval ← [right, intervals[i].end]\n                                → Step: // keep right part\n                            No →\n                                → // right part not kept\n                        → Step: intervals.remove(i) // remove original interval\n                        → // insert left_interval if exists\n                        → Step: if left_interval exists: intervals.insert(i, left_interval); i←i+1\n                        → // insert right_interval if exists\n                        → Step: if right_interval exists: intervals.insert(i, right_interval)\n                        → // continue loop with i unchanged\n    No → // done\n\nOk.\n\nWe must output lines each with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow, etc.\n\nLet's produce final answer accordingly.\n\nWe should use Chinese explanation.\n\nMake sure to use \"Start\" and \"End\".\n\nWe'll separate methods but within same block? It's okay.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: intervals ← [] // 初始化一個空的有序區間列表，用來儲存已追蹤的區間  \n\n---  \n// ----------  addRange  ----------  \n→ Step: addRange(left, right) // 進入新增區間的流程  \n→ Step: new_left ← left // 以左端點作為新區間的起點  \n→ Step: new_right ← right // 以右端點作為新區間的終點  \n→ Step: i ← 0 // 從列表最左側開始掃描  \n→ Decision: i < intervals.length? // 是否還有區間可檢查？  \n    Yes →  \n        → Decision: intervals[i].end < new_left? // 目前區間完全在新區間左側，無重疊  \n            Yes → i ← i + 1 // 跳過這個區間  \n            No →  \n                → Decision: intervals[i].start > new_right? // 目前區間完全在新區間右側，掃描完畢  \n                    Yes →  \n                        → Step: intervals.insert(i, [new_left, new_right]) // 在此位置插入合併後的區間  \n                        → Step: return // 完成新增  \n                    No →  \n                        → Step: new_left ← min(new_left, intervals[i].start) // 取最小左端點  \n                        → Step: new_right ← max(new_right, intervals[i].end) // 取最大右端點  \n                        → Step: intervals.remove(i) // 刪除已被合併的舊區間  \n                        → // 仍在同一索引處檢查下一個可能重疊的區間  \n    No →  \n        → Step: intervals.append([new_left, new_right]) // 列表已掃描完畢，直接追加區間  \n→ End // addRange 完成  \n\n---  \n// ----------  queryRange  ----------  \n→ Step: queryRange(left, right) // 進入查詢區間的流程  \n→ Step: i ← 0 // 從列表最左側開始搜尋  \n→ Decision: i < intervals.length? // 是否還有區間可比對？  \n    Yes →  \n        → Decision: intervals[i].end < left? // 目前區間結束在左端點之前  \n            Yes → i ← i + 1 // 跳過此區間  \n            No →  \n                → Decision: intervals[i].start <= left? // 左端點落在此區間內  \n                    Yes →  \n                        → Decision: intervals[i].end >= right? // 區間同時覆蓋右端點  \n                            Yes → Step: return true // 完全覆蓋，查詢成功  \n                            No  → Step: return false // 無法覆蓋右端點，查詢失敗  \n                    No → Step: return false // 左端點在此區間左側，無法覆蓋  \n    No → Step: return false // 所有區間已掃描完，仍未找到覆蓋，查詢失敗  \n→ End // queryRange 完成  \n\n---  \n// ----------  removeRange  ----------  \n→ Step: removeRange(left, right) // 進入移除區間的流程  \n→ Step: i ← 0 // 從最左側區間開始  \n→ Decision: i < intervals.length? // 是否還有區間可檢查？  \n    Yes →  \n        → Decision: intervals[i].end <= left? // 目前區間結束在左端點之前，無影響  \n            Yes → i ← i + 1 // 跳過此區間  \n            No →  \n                → Decision: intervals[i].start >= right? // 目前區間開始在右端點之後，剩餘區間全不受影響  \n                    Yes → Step: return // 所有後續區間已不在移除範圍內，結束  \n                    No →  \n                        → // 有重疊，需調整或拆分  \n                        → Step: left_part ← null // 用於存儲左側保留區間  \n                        → Step: right_part ← null // 用於存儲右側保留區間  \n                        → Decision: intervals[i].start < left? // 左端點落在本區間內  \n                            Yes →  \n                                → Step: left_part ← [intervals[i].start, left] // 保留左側片段  \n                            No → // 不保留左側片段  \n                        → Decision: intervals[i].end > right? // 右端點落在本區間內  \n                            Yes →  \n                                → Step: right_part ← [right, intervals[i].end] // 保留右側片段  \n                            No → // 不保留右側片段  \n                        → Step: intervals.remove(i) // 刪除原本重疊的區間  \n                        → // 依序插入保留片段（若存在）  \n                        → Decision: left_part ≠ null?  \n                            Yes →  \n                                → Step: intervals.insert(i, left_part)  \n                                → Step: i ← i + 1 // 左片段已插入，下一個索引移動  \n                            No → // 無左片段，索引不變  \n                        → Decision: right_part ≠ null?  \n                            Yes →  \n                                → Step: intervals.insert(i, right_part) // 右片段插入（位於左片段之後）  \n                                → // i 仍指向此位置，繼續檢查下一個區間  \n                            No → // 無右片段，繼續檢查下一個區間  \n    No → // 所有區間已掃描完畢，結束  \n→ End // removeRange 完成  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # overlap\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i - 1][0] <= left and right <= self.ranges[i - 1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    lines = [line.strip() for line in sys.stdin.read().splitlines() if line.strip()]\n    outputs = []\n    rng_module = None\n\n    for line in lines:\n        if 'new RangeModule' in line:\n            rng_module = RangeModule()\n            outputs.append('null')\n        elif '.addRange(' in line:\n            nums = list(map(int, re.findall(r'-?\\d+', line)))\n            rng_module.addRange(nums[0], nums[1])\n            outputs.append('null')\n        elif '.removeRange(' in line:\n            nums = list(map(int, re.findall(r'-?\\d+', line)))\n            rng_module.removeRange(nums[0], nums[1])\n            outputs.append('null')\n        elif '.queryRange(' in line:\n            nums = list(map(int, re.findall(r'-?\\d+', line)))\n            res = rng_module.queryRange(nums[0], nums[1])\n            outputs.append('true' if res else 'false')\n        else:\n            # ignore unknown lines\n            pass\n\n    print('[' + ', '.join(outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode641.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Deque",
    "description_snippet": "Design your implementation of the circular double-ended queue (deque).\n\nImplement the MyCircularDequ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for MyCircularDeque class with specified methods. Each line with // explanation. Use Start, End, Decision, arrow. Likely include initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Need to simulate circular buffer. Represent using array of size k, head index, tail index, count.\n\nWe'll produce pseudo-code:\n\nStart MyCircularDeque constructor\n-> Step: set size = k\n-> Step: create array of size k\n-> Step: set head = 0\n-> Step: set tail = 0\n-> Step: set count = 0\nEnd\n\nInsertFront:\n-> Decision: if isFull? // if full cannot insert\n   Yes → Return false\n   No → Step: set head = (head - 1 + size) mod size\n   Step: array[head] = value\n   Step: count++\n   Return true\n\nInsertLast similar.\n\nDeleteFront: if empty return false\n else set head = (head + 1) mod size, count--, return true.\n\nDeleteLast: similar.\n\ngetFront: if empty return -1 else return array[head].\n\ngetRear: if empty return -1 else index = (tail - 1 + size) mod size, return array[index].\n\nisEmpty: return count == 0\n\nisFull: return count == size\n\nNeed to produce lines with \"虛擬碼步驟\" and explanation.\n\nProbably use Start/End around class definition and each method block.\n\nLet's craft step-by-step.\n\nWe'll prefix each line with arrow '→' except Start and End.\n\nNeed to include class name? Could show 'MyCircularDeque' as start block.\n\nWill produce:\n\nStart MyCircularDeque // 開始定義循環雙端佇列類別\n\n→ Constructor(k) // 建構函式\n\n... etc.\n\nBut need to follow formatting: each line has \"虛擬碼步驟\" and // explanation.\n\nWe'll not output actual code, just pseudo steps.\n\nLet's produce:\n\nStart MyCircularDeque // 程式開始定義 MyCircularDeque 類別\n→ Constructor(k) // 初始化 deque，參數 k 為最大容量\n    → Step: size ← k // 記錄容量\n    → Step: data ← new array of length k // 儲存元素\n    → Step: head ← 0 // 前端指標\n    → Step: tail ← 0 // 後端指標\n    → Step: count ← 0 // 目前元素數\n→ insertFront(val) // 在前端插入元素\n    → Decision: isFull()？ // 檢查是否已滿\n        Yes → Return false // 插入失敗\n        No  →\n            → Step: head ← (head - 1 + size) mod size // 前移指標\n            → Step: data[head] ← val // 存值\n            → Step: count ← count + 1 // 元素數加一\n            → Return true // 插入成功\n→ insertLast(val) // 在後端插入元素\n    → Decision: isFull()？\n        Yes → Return false\n        No  →\n            → Step: data[tail] ← val\n            → Step: tail ← (tail + 1) mod size\n            → Step: count ← count + 1\n            → Return true\n→ deleteFront() // 從前端刪除元素\n    → Decision: isEmpty()？\n        Yes → Return false\n        No  →\n            → Step: head ← (head + 1) mod size\n            → Step: count ← count - 1\n            → Return true\n→ deleteLast() // 從後端刪除元素\n    → Decision: isEmpty()？\n        Yes → Return false\n        No  →\n            → Step: tail ← (tail - 1 + size) mod size\n            → Step: count ← count - 1\n            → Return true\n→ getFront() // 取得前端元素\n    → Decision: isEmpty()？\n        Yes → Return -1\n        No  →\n            → Return data[head]\n→ getRear() // 取得後端元素\n    → Decision: isEmpty()？\n        Yes → Return -1\n        No  →\n            → Step: index ← (tail - 1 + size) mod size\n            → Return data[index]\n→ isEmpty() // 判斷是否為空\n    → Return count == 0\n→ isFull() // 判斷是否為滿\n    → Return count == size\nEnd MyCircularDeque // 結束定義 MyCircularDeque 類別\n\nNeed to make sure each line includes \"虛擬碼步驟\" e.g., \"Constructor(k)\". Use arrow before each step? Format: \"→ Step: ...\" For decision lines we need \"Decision: ...\".\n\nWe'll maintain consistent formatting. Use \"Decision:\" lines indented. For lines inside decision, use \"Yes →\" and \"No →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart MyCircularDeque // 程式開始定義 MyCircularDeque 類別  \n→ Constructor(k) // 建構函式，k 為最大容量  \n → Step: size ← k // 記錄容量  \n → Step: data ← new array of length k // 儲存元素  \n → Step: head ← 0 // 前端指標  \n → Step: tail ← 0 // 後端指標  \n → Step: count ← 0 // 目前元素數  \n→ insertFront(val) // 在前端插入元素  \n → Decision: isFull()? // 檢查是否已滿  \n  Yes → Return false // 插入失敗  \n  No  →  \n    → Step: head ← (head - 1 + size) mod size // 前移指標  \n    → Step: data[head] ← val // 存值  \n    → Step: count ← count + 1 // 元素數加一  \n    → Return true // 插入成功  \n→ insertLast(val) // 在後端插入元素  \n → Decision: isFull()?  \n  Yes → Return false  \n  No  →  \n    → Step: data[tail] ← val // 存值  \n    → Step: tail ← (tail + 1) mod size // 後移指標  \n    → Step: count ← count + 1 // 元素數加一  \n    → Return true  \n→ deleteFront() // 從前端刪除元素  \n → Decision: isEmpty()? // 檢查是否為空  \n  Yes → Return false // 刪除失敗  \n  No  →  \n    → Step: head ← (head + 1) mod size // 前端指標後移  \n    → Step: count ← count - 1 // 元素數減一  \n    → Return true // 刪除成功  \n→ deleteLast() // 從後端刪除元素  \n → Decision: isEmpty()?  \n  Yes → Return false  \n  No  →  \n    → Step: tail ← (tail - 1 + size) mod size // 後端指標前移  \n    → Step: count ← count - 1 // 元素數減一  \n    → Return true  \n→ getFront() // 取得前端元素  \n → Decision: isEmpty()?  \n  Yes → Return -1 // 空時回傳 -1  \n  No  →  \n    → Return data[head] // 回傳前端值  \n→ getRear() // 取得後端元素  \n → Decision: isEmpty()?  \n  Yes → Return -1  \n  No  →  \n    → Step: index ← (tail - 1 + size) mod size // 後端索引  \n    → Return data[index] // 回傳後端值  \n→ isEmpty() // 判斷是否為空  \n → Return count == 0  \n→ isFull() // 判斷是否為滿  \n → Return count == size  \nEnd MyCircularDeque // 程式執行結束定義 MyCircularDeque 類別",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0   # front index\n        self.count = 0  # current number of elements\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n\n    lines = data.strip().splitlines()\n    ops = ast.literal_eval(lines[0].strip())\n    vals = ast.literal_eval(lines[1].strip())\n\n    obj = None\n    out = []\n\n    for op, val in zip(ops, vals):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(val[0])\n            out.append(None)\n        elif op == \"insertFront\":\n            out.append(obj.insertFront(val[0]))\n        elif op == \"insertLast\":\n            out.append(obj.insertLast(val[0]))\n        elif op == \"deleteFront\":\n            out.append(obj.deleteFront())\n        elif op == \"deleteLast\":\n            out.append(obj.deleteLast())\n        elif op == \"getFront\":\n            out.append(obj.getFront())\n        elif op == \"getRear\":\n            out.append(obj.getRear())\n        elif op == \"isEmpty\":\n            out.append(obj.isEmpty())\n        elif op == \"isFull\":\n            out.append(obj.isFull())\n\n    print(json.dumps(out))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp2s92ka1n.py\", line 64, in <module>\n    ops = ast.literal_eval(lines[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n                                                                                                                                                ^\nSyntaxError: unexpected character after line continuation character"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode410.json",
    "problem_index_in_file": 0,
    "title": "Split Array Largest Sum",
    "description_snippet": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the la...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. Problem is classic \"Split Array Largest Sum\" with binary search. Steps: define low = max(nums), high = sum(nums). binary search while low < high. mid = (low+high)//2. count subarrays needed if each <= mid. if count <= k -> high=mid else low=mid+1. Return low. Also need to include explanation. Provide each line with arrow and explanation. Use structure with Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". Use arrow and indentation.\n\nLet's produce lines:\n\nStart // Start program\n→ Step 1: 計算 low = max(nums) // 取陣列最大值作為最低可能分割和\n→ Step 2: 計算 high = sum(nums) // 取陣列所有元素和作為最高可能分割和\n→ Decision: While low < high? // 判斷是否仍有搜尋空間\n    Yes →\n        → Step 3: 計算 mid = (low + high) // 2 // 取中間值作為候選分割和\n        → Step 4: 初始化 count = 1, currentSum = 0 // 以新子陣列開始\n        → For each num in nums: // 遍歷陣列\n            → Decision: currentSum + num <= mid? // 判斷是否能加入目前子陣列\n                Yes →\n                    → currentSum = currentSum + num // 加入\n                No →\n                    → count = count + 1 // 新建子陣列\n                    → currentSum = num // 重新開始累加\n        → Decision: count <= k? // 判斷需要的子陣列是否不超過 k\n            Yes →\n                → high = mid // 可接受，縮小上界\n            No →\n                → low = mid + 1 // 需要更大分割和，增大下界\n    No →\nEnd // 返回 low 為最小化的最大子陣列和\n\nNeed to format each line with code then comment. Use virtual code arrow format. Provide the steps. Each line separate. Use \"→\" to indicate next. For loops and decisions, show indentation. Use \"Decision:\" lines and \"Yes →\", \"No →\". Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 low = max(nums) // 取陣列最大值作為最低可能分割和  \n→ Step 2: 計算 high = sum(nums) // 取陣列所有元素和作為最高可能分割和  \n→ Decision: While low < high? // 判斷是否仍有搜尋空間  \n  Yes →  \n   → Step 3: 計算 mid = (low + high) // 2 // 取中間值作為候選分割和  \n   → Step 4: 初始化 count = 1, currentSum = 0 // 以新子陣列開始  \n   → For each num in nums: // 遍歷陣列  \n     Decision: currentSum + num <= mid? // 判斷能否加入目前子陣列  \n      Yes →  \n       currentSum = currentSum + num // 加入元素  \n      No →  \n       count = count + 1 // 新建子陣列  \n       currentSum = num // 重新開始累加  \n    → Decision: count <= k? // 判斷需要的子陣列是否不超過 k  \n     Yes →  \n      high = mid // 可接受，縮小上界  \n     No →  \n      low = mid + 1 // 需要更大分割和，增大下界  \n  No →  \nEnd // 程式執行結束，low 為最小化的最大子陣列和 (返回 low)",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def splitArray(self, nums, m):\n        def can_split(mid):\n            count, curr_sum = 1, 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= m\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if can_split(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if not numbers:\n        return\n    k = numbers[-1]\n    nums = numbers[:-1]\n    solution = Solution()\n    print(solution.splitArray(nums, k))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [7,2,5,10,8], k = 2",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,5], k = 2",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode274.json",
    "problem_index_in_file": 0,
    "title": "H-Index",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing h-index. Use Start, End, Decision etc. Provide step-by-step algorithm. Probably sort citations descending then find largest index where citations[i] >= i+1. Provide steps accordingly.\n\nWe'll output:\n\nStart\n→ Step 1: 輸入 array citations // get input\n→ Step 2: 進行遞減排序 // sort descending\n→ Step 3: 初始化 h = 0 // init\n→ Step 4: 循環 i 從 0 到 length-1 // loop over sorted array\n    → Decision: 如果 citations[i] >= i+1?\n        Yes → Step 5: 設定 h = i+1 // update h\n        No  → No action // continue loop\n→ Step 6: 輸出 h // final h-index\nEnd\n\nBut we need arrow format.\n\nBetter: use arrow and indentation. Provide explanation comments.\n\nLet's craft. Use arrow \"→\" before each step. Use indentation for nested decision.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 array citations // 取得引用次數的陣列\n→ Step 2: 將 citations 以降序排列 // 方便後續比較\n→ Step 3: 設定變數 h ← 0 // h-index 初始值\n→ Step 4: 針對索引 i 從 0 到 citations.length-1 進行迴圈 // 逐筆檢查\n    → Decision: 如果 citations[i] ≥ i+1? // 判斷第 i+1 篇論文是否至少被 i+1 次引用\n        Yes → Step 5: 將 h ← i+1 // 更新 h-index 為較大值\n        No  → // 不更新，繼續檢查下一篇\n→ Step 6: 輸出 h // 回傳最終的 h-index\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def hIndex(self, citations):\n        # 將 citations 以降序排列\n        citations.sort(reverse=True)\n        h = 0\n        # 逐一檢查，若第 i+1 篇論文至少被 i+1 次引用則更新 h\n        for i, c in enumerate(citations):\n            if c >= i + 1:\n                h = i + 1\n            else:\n                break\n        return h\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取出陣列字串，例如 '[3,0,6,1,5]'，使用 ast.literal_eval 解析成 list\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # 若格式不符，直接結束\n        return\n    list_str = data[start:end+1]\n    try:\n        citations = ast.literal_eval(list_str)\n    except Exception:\n        return\n\n    sol = Solution()\n    result = sol.hIndex(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [3,0,6,1,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode462.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements II",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: Given integer array nums, find minimal moves to make all equal by increment/decrement 1 each move. Standard solution: choose median of array, sum absolute differences. So steps: sort array, find median, sum differences. Or use nth_element but virtual code fine.\n\nWe need to produce lines with \"Start\" etc. Each line with virtual code step + space + comment. Use arrows. For decisions? We don't need decision for median selection maybe. But we can include decision to handle odd/even length? Actually median for even count could be any value between two middle numbers; choose lower middle. Implementation: sort, median = arr[n/2]. Sum abs.\n\nPseudo steps:\n\nStart\n→ Input array nums\n→ Assign n = length(nums)\n→ Sort nums\n→ If n is odd:\n    median = nums[n/2]\n   Else:\n    median = nums[n/2 - 1] (or average but integer)\n→ Initialize moves = 0\n→ For each element val in nums:\n    moves += abs(val - median)\n→ Output moves\nEnd\n\nAdd explanation comments.\n\nWe need \"Decision:\" for if n odd? Use Decision: n % 2 == 1?\n\nYes.\n\nLet's produce. Ensure each line has code then comment. Use arrow. Format:\n\nStart // 程式開始\n\n→ Step 1: Input nums // 取得輸入陣列\n\n→ Step 2: n ← length(nums) // 計算陣列長度\n\n→ Step 3: Sort(nums) // 對陣列排序以便找中位數\n\n→ Decision: 如果 n 為奇數? // 判斷長度是否為奇數\n\n    Yes → Step 4: median ← nums[n/2] // 奇數時中位數為中間元素\n\n    No  → Step 5: median ← nums[n/2 - 1] // 偶數時取下中位數\n\n→ Step 6: moves ← 0 // 初始化總移動步數\n\n→ For each val in nums:\n\n    → Step 7: moves ← moves + abs(val - median) // 累加到目標中位數的距離\n\n→ Step 8: Output moves // 回傳最小移動步數\n\nEnd // 程式結束\n\nBut need arrow for loop? Use \"→ For each val in nums:\"? Should include.\n\nAlso need to include comments at each line.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input nums // 取得使用者輸入的整數陣列  \n→ Step 2: n ← length(nums) // 計算陣列長度 n  \n→ Step 3: Sort(nums) // 對 nums 進行升序排序，方便取得中位數  \n→ Decision: 如果 n 為奇數? // 判斷陣列長度是奇數還是偶數  \n    Yes → Step 4: median ← nums[n/2] // 奇數時中位數為中間索引的元素  \n    No  → Step 5: median ← nums[n/2 - 1] // 偶數時取下中位數（任一中位值皆可）  \n→ Step 6: moves ← 0 // 初始化總移動步數為 0  \n→ For each val in nums: // 逐個遍歷陣列元素  \n    → Step 7: moves ← moves + abs(val - median) // 將每個元素到中位數的距離累加到 moves  \n→ Step 8: Output moves // 回傳最小移動步數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef min_moves2(nums):\n    \"\"\"將所有元素移動到中位數即可得到最小步數。\"\"\"\n    nums.sort()\n    median = nums[len(nums) // 2]\n    return sum(abs(num - median) for num in nums)\n\ndef parse_input(input_str):\n    \"\"\"\n    解析輸入字串，支援：\n    - 'nums = [1,2,3]'\n    - '[1,2,3]'\n    \"\"\"\n    input_str = input_str.strip()\n    # 若以 'nums =' 開頭，移除前綴\n    if input_str.lower().startswith('nums'):\n        try:\n            _, _, part = input_str.partition('=')\n            input_str = part.strip()\n        except ValueError:\n            pass\n    # 使用 eval 解析列表，禁止執行任何全域函式\n    try:\n        nums = eval(input_str, {\"__builtins__\": None}, {})\n    except Exception:\n        raise ValueError(\"無法解析輸入的數字列表\")\n    if not isinstance(nums, list):\n        raise ValueError(\"輸入不是一個列表\")\n    return nums\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n    try:\n        nums = parse_input(data)\n    except Exception as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n        sys.exit(1)\n    result = min_moves2(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,10,2,9]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode209.json",
    "problem_index_in_file": 0,
    "title": "Minimum Size Subarray Sum",
    "description_snippet": "Given an array of positive integers nums and a positive integer target, return the minimal length of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, with arrows, decisions, etc. Provide explanation after each line. Must not output actual code. Just virtual steps. Provide step-by-step algorithm for minimal subarray length >= target.\n\nWe can use sliding window. Steps: Start, input array, target. Initialize left=0, sum=0, minLen=∞. Loop right from 0 to end: add nums[right] to sum. While sum >= target: update minLen = min(minLen, right-left+1); subtract nums[left]; left++. After loop, if minLen still ∞ then return 0 else return minLen. End.\n\nWe need to produce each line with explanation. Use arrow \"→\". Use Decision for while loop? Could use Decision to represent while sum >= target. Provide Yes branch.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums 與目標值 target // 從使用者取得資料\n→ Step 2: 初始化 left = 0, sum = 0, minLen = ∞ // 設定滑動窗口指標與最小長度\n→ Step 3: 針對 right 從 0 到 nums.Length-1 進行迴圈 // 遍歷陣列\n    → Decision: 是否已超過陣列結束? // 控制迴圈終止\n        No  → Step 4: sum += nums[right] // 將右端元素加入窗口總和\n        No  → Decision: sum 是否 >= target? // 檢查是否滿足條件\n            Yes → Step 5: minLen = min(minLen, right-left+1) // 更新最小長度\n            Yes → Step 6: sum -= nums[left] // 從窗口左端移除元素\n            Yes → Step 7: left++ // 左指標右移\n            Yes → 回到 Decision: sum 是否 >= target? // 可能還有更小子陣列\n        No  → Step 8: right++ // 移動右指標\n→ Step 9: Decision: minLen 是否為 ∞? // 判斷是否找到合法子陣列\n    Yes → Step 10: 回傳 0 // 沒有符合條件的子陣列\n    No  → Step 11: 回傳 minLen // 回傳最小長度\nEnd // 程式執行結束\n\nBut we need each line after arrow and comment. Need to include arrows for each step. For steps inside loops, we can indent with spaces and maintain arrow. Example: \"→ Step 3:\" etc. For nested decision, maybe use indentation. But spec says use arrows and structure. We can follow pattern: \"→ Decision:\" then indent branches.\n\nLet's produce final answer with proper formatting. Ensure each line ends with // explanation. Use Chinese explanation. Let's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums 與目標值 target // 讀取使用者輸入  \n→ Step 2: 初始化 left = 0, sum = 0, minLen = ∞ // 設定滑動窗口指標與最小長度變數  \n→ Step 3: 針對 right 從 0 到 nums.Length-1 進行迴圈 // 逐個遍歷陣列  \n  → Decision: 是否已到達陣列結束? // 控制迴圈結束條件  \n   No → Step 4: sum += nums[right] // 把右端元素加入窗口總和  \n   No → Decision: sum 是否 >= target? // 檢查窗口是否滿足條件  \n    Yes → Step 5: minLen = min(minLen, right-left+1) // 更新最小長度  \n    Yes → Step 6: sum -= nums[left] // 從窗口左端移除元素  \n    Yes → Step 7: left++ // 左指標右移  \n    Yes → 回到 Decision: sum 是否 >= target? // 可能還有更小子陣列  \n   No → Step 8: right++ // 移動右指標  \n→ Step 9: Decision: minLen 是否為 ∞? // 判斷是否找到合法子陣列  \n  Yes → Step 10: 回傳 0 // 沒有符合條件的子陣列  \n  No  → Step 11: 回傳 minLen // 回傳最小長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minSubArrayLen(self, target, nums):\n        left = 0\n        total = 0\n        min_len = float('inf')\n\n        for right in range(len(nums)):\n            total += nums[right]\n            while total >= target:\n                min_len = min(min_len, right - left + 1)\n                total -= nums[left]\n                left += 1\n\n        return 0 if min_len == float('inf') else min_len\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit()\n\n    # Extract target\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    target = int(target_match.group(1)) if target_match else 0\n\n    # Extract nums list\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    nums_str = nums_match.group(1) if nums_match else ''\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n\n    sol = Solution()\n    result = sol.minSubArrayLen(target, nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode633.json",
    "problem_index_in_file": 0,
    "title": "Sum of Square Numbers",
    "description_snippet": "Given a non-negative integer c, decide whether there're two integers a and b such that a^2 + b^2 = c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code with steps: Start, Decision, loops, etc. Need to decide if given c non-negative integer, find if there exist a,b integers such that a^2 + b^2 = c. This is representation of integer as sum of two squares. Approach: loop a from 0 to sqrt(c). For each a, compute b2 = c - a^2. Check if b2 is perfect square. If yes, return true. Else continue. If none found, return false. We'll use virtual code structure. Must include each line with // explanation. Use arrow '→'. Use Decision: '如果 b2 是完全平方?' etc. Use Yes/No branches.\n\nLet's craft:\n\nStart // start\n\n→ Step 1: 計算最大 a 值 = floor(√c) // Determine upper bound for a\n\n→ Step 2: 設 a = 0 // 初始化 a\n\n→ Decision: a <= max_a? // 是否還有 a 值可嘗試\n\n    Yes → Step 3: 計算 b2 = c - a^2 // b2 是剩餘值\n\n    → Decision: b2 是否為完全平方? // 檢查是否能表示為 b^2\n\n        Yes → Step 4: 輸出 \"存在 a,b\" // 找到解\n\n        No  → Step 5: a = a + 1 // 增加 a\n\n    → Decision: a <= max_a? // 重新判斷\n\n        Yes → 回到 Step 3\n\n        No  → Step 6: 輸出 \"不存在\" // 無解\n\nEnd // 結束\n\nBut need to follow format. Each line: virtual code step + space + // explanation.\n\nLet's produce with arrow notation:\n\nStart // 程式開始執行\n→ Step 1: 計算 max_a ← floor(√c) // 取得 a 的上限\n→ Step 2: a ← 0 // 初始化 a\n→ Decision: a <= max_a? // 檢查 a 是否在可嘗試範圍內\n    Yes → Step 3: b2 ← c - a^2 // 計算剩餘值\n    → Decision: b2 是完全平方? // 判斷剩餘值是否為平方數\n        Yes → Step 4: 輸出 \"存在 a,b\" // 找到符合條件的 a,b\n        No  → Step 5: a ← a + 1 // 進一步嘗試下一個 a\n    → Decision: a <= max_a? // 再次檢查是否還有 a 可嘗試\n        Yes → 回到 Step 3 // 進入下一輪循環\n        No  → Step 6: 輸出 \"不存在\" // 所有 a 都嘗試完畢仍未找到\nEnd // 程式執行結束\n\nBut the arrow indentation: We need to use 'Yes →' and 'No →' for branches.\n\nSo we need to format:\n\n→ Decision: a <= max_a? \n    Yes → Step 3...\n    No  → Step 6...\n\nSimilarly for inner decision.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 max_a ← floor(√c) // 取得 a 的上限  \n→ Step 2: a ← 0 // 初始化 a  \n→ Decision: a <= max_a? // 檢查 a 是否在可嘗試範圍內  \n    Yes → Step 3: b2 ← c - a^2 // 計算剩餘值  \n    → Decision: b2 是完全平方? // 判斷剩餘值是否為平方數  \n        Yes → Step 4: 輸出 \"存在 a,b\" // 找到符合條件的 a,b  \n        No  → Step 5: a ← a + 1 // 進一步嘗試下一個 a  \n    → Decision: a <= max_a? // 再次檢查是否還有 a 可嘗試  \n        Yes → 回到 Step 3 // 進入下一輪循環  \n        No  → Step 6: 輸出 \"不存在\" // 所有 a 都嘗試完畢仍未找到  \nEnd // 程式執行結束",
      "generated_code": "import math\nimport sys\nimport re\n\nclass Solution:\n    def judgeSquareSum(self, c: int) -> bool:\n        \"\"\"判斷是否存在 a, b 使得 a^2 + b^2 = c\"\"\"\n        left, right = 0, int(math.isqrt(c))\n        while left <= right:\n            total = left * left + right * right\n            if total == c:\n                return True\n            elif total < c:\n                left += 1\n            else:\n                right -= 1\n        return False\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 c，輸出 true/false\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中擷取第一個數字\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    c = int(match.group())\n    solution = Solution()\n    result = solution.judgeSquareSum(c)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "c = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "c = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode667.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement II",
    "description_snippet": "Given two integers n and k, construct a list answer that contains n different positive integers rang...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step solution to construct such list. It's combinatorial problem: given n,k produce permutation of 1..n such that number of distinct absolute differences between consecutive elements equals k. We need to produce algorithm. We can use known approach: we can create pattern that yields certain distinct differences. Approach: For k distinct differences, we can use sequence that alternates small and large numbers to create differences from 1 to k. Classic approach: for i from 1 to k: if i odd pick low = i//2 +1? Actually typical solution: Start with low=1, high=k+1, produce alternating to get differences 1..k. Then append remaining numbers increasing or decreasing.\n\nLet's design algorithm: let answer = []\nlow = 1\nhigh = k+1\nfor i in 1..k:\n    if i%2==1: answer.append(low); low+=1\n    else: answer.append(high); high-=1\nAfter loop, append remaining numbers from k+2 to n in increasing order. This yields differences set of {1..k}. For n>k+1, we keep distinct count k. Works.\n\nEdge cases: k==n-1? Then high becomes n, low increments. After loop will have all numbers 1..n. Works.\n\nReturn answer.\n\nNow produce virtual code lines. Each line with arrow and explanation.\n\nLet's produce:\n\nStart\n→ Input n, k\n→ Decision: k == 0? Not needed? Actually k>=1 because distinct differences cannot be 0 unless n=1? But we can ignore. Provide generic.\nBut we produce steps.\n\nLet's create variable answer as empty list.\n\nInitialize low=1, high=k+1\n\nLoop i from 1 to k:\n  If i odd: append low; low+=1\n  else: append high; high-=1\n\nAfter loop, for num from k+2 to n:\n  append num\n\nReturn answer\n\nNow produce virtual code lines.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\"\n\nWe can use arrow \"→\" for steps.\n\nWe'll show decision steps.\n\nLet's craft.\n\nLine1: Start // 程式開始\n\nLine2: → Input n, k // 取得輸入參數\n\nLine3: → Initialize answer as empty list // 建立結果儲存容器\n\nLine4: → Initialize low = 1 // 最小數字起點\n\nLine5: → Initialize high = k + 1 // 最大數字起點\n\nLine6: → For i from 1 to k: // 產生 k 個差值\n\nLine7:     → Decision: i is odd? // 判斷奇偶\n\nLine8:         Yes → Append low to answer // 奇數時取較小數\n\nLine9:         Yes → Increment low by 1 // 更新低值\n\nLine10:        No  → Append high to answer // 偶數時取較大數\n\nLine11:        No  → Decrement high by 1 // 更新高值\n\nLine12: → For num from k+2 to n: // 將剩餘數字按順序加入\n\nLine13:     → Append num to answer // 追加剩餘數字\n\nLine14: → Return answer // 完成結果\n\nLine15: End // 程式結束\n\nWe need to ensure arrow structure correct.\n\nWe also need to ensure \"Decision:\" lines preceded by \"Decision:\" token and subsequent lines preceded by \"Yes →\" and \"No →\" accordingly.\n\nThus final output.\n...done thinking.\n\nStart // 程式開始  \n→ Input n, k // 取得輸入參數  \n→ Initialize answer as empty list // 建立結果儲存容器  \n→ Initialize low = 1 // 最小數字起點  \n→ Initialize high = k + 1 // 最大數字起點  \n→ For i from 1 to k: // 產生 k 個差值  \n → Decision: i is odd? // 判斷奇偶  \n  Yes → Append low to answer // 奇數時取較小數  \n  Yes → Increment low by 1 // 更新低值  \n  No  → Append high to answer // 偶數時取較大數  \n  No  → Decrement high by 1 // 更新高值  \n→ For num from k+2 to n: // 將剩餘數字按順序加入  \n  → Append num to answer // 追加剩餘數字  \n→ Return answer // 完成結果  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef construct_array(n: int, k: int) -> list[int]:\n    \"\"\"Construct a permutation of 1..n with exactly k distinct consecutive differences.\"\"\"\n    answer = []\n    low, high = 1, k + 1\n\n    # Generate the first k+1 numbers to guarantee k distinct differences\n    for i in range(k + 1):\n        if i % 2 == 0:\n            answer.append(low)\n            low += 1\n        else:\n            answer.append(high)\n            high -= 1\n\n    # Append the remaining numbers in increasing order\n    for num in range(k + 2, n + 1):\n        answer.append(num)\n\n    return answer\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = construct_array(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 1",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 2",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode69.json",
    "problem_index_in_file": 0,
    "title": "Sqrt(x)",
    "description_snippet": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for integer sqrt floor, no exponent, so use binary search. Output each line with explanation. Use Start, End, Decision, etc. Provide line by line.\n\nWe must include steps: input x, if x<2 return x, set low=1, high=x/2 (or x), while low<=high, mid=(low+high)//2, square=mid*mid, if square==x return mid, if square<x low=mid+1, else high=mid-1. After loop return high. All without exponent. Use integer multiplication.\n\nAdd explanation comments.\n\nNeed to maintain arrow formatting. Use \"→\" for next step. Use indentation. Provide \"Decision:\" lines with Yes →, No →.\n\nEnsure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nLet's craft.\n\nWe should start with Start. Then Step 1: Input x. Step 2: If x < 2 return x. Step 3: Set low=1, high=x//2. Step 4: While low <= high: Decision: mid = (low+high)//2. Actually we need to compute mid. So Decision or Step? We'll write Step 4: While low <= high // start loop. Then inside:\n\n→ Decision: If (mid*mid == x) // Check equality\n    Yes → Step 5: Return mid // Found exact sqrt\n    No  → Decision: If (mid*mid < x) // Smaller than x\n        Yes → Step 6: low = mid + 1 // Search upper half\n        No  → Step 7: high = mid - 1 // Search lower half\n\nAfter loop, Step 8: Return high // high is floor sqrt\n\nEnd.\n\nNeed to ensure each line has proper indentation. Use arrows.\n\nWe should incorporate step numbers. Use numbers sequentially. Ensure every line has explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 x // 從使用者取得非負整數  \n→ Decision: 如果 x < 2? // 小數字直接處理  \n  Yes → Step 2: 回傳 x // 0 或 1 的平方根即自身  \n  No  → Step 3: low = 1, high = x // 初始搜尋區間設定  \n→ Step 4: while low ≤ high // 進入二分搜尋迴圈  \n  → Step 5: mid = (low + high) // 2 // 取區間中點  \n  → Decision: 如果 mid * mid == x? // 判斷是否正好相等  \n    Yes → Step 6: 回傳 mid // 找到精確平方根  \n    No  → Decision: 如果 mid * mid < x? // 小於目標  \n      Yes → Step 7: low = mid + 1 // 搜尋更大數值區間  \n      No  → Step 8: high = mid - 1 // 搜尋更小數值區間  \n→ Step 9: 回傳 high // 迴圈結束後 high 為 floor(√x)  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef my_sqrt(x: int) -> int:\n    \"\"\"Return floor(sqrt(x)) without using exponentiation.\"\"\"\n    if x < 2:\n        return x\n\n    left, right = 1, x // 2\n    while left <= right:\n        mid = (left + right) // 2\n        sq = mid * mid\n        if sq == x:\n            return mid\n        elif sq < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right\n\ndef main() -> None:\n    # 讀取整個輸入並提取第一個整數\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    x = int(match.group())\n    print(my_sqrt(x))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 8",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode385.json",
    "problem_index_in_file": 0,
    "title": "Mini Parser",
    "description_snippet": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code for parsing a string serialization of nested lists, similar to LeetCode 385 Nested List Parser. Provide step by step virtual code lines with explanation comments. We need to parse string s, use stack, etc. Provide start, steps. No actual code, only virtual steps. Let's produce a thorough flow: Start, parse char by char, handle digits, negative sign, open bracket '[' push new list, close ']' pop and add to previous, etc. Also handle single integer string. Provide final nested integer. Also decision steps. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 s // 取得要被反序列化的字串\n\n→ Decision: s 是否為純數字? // 判斷整個字串是否只包含一個整數\n    Yes → Step 2: 建立 NestedInteger 並以 s 轉成整數為值 // 直接回傳單一整數\n    No  → Step 3: 初始化 stack 為空堆疊 // 用於存放尚未完成的 NestedInteger\n\n→ Step 4: 將字串 s 以字元陣列陣列化 // 方便逐字檢查\n→ Step 5: 定義 currentNumber 為空字串 // 用於累積多位數字\n→ Step 6: 定義 isNegative 為 false // 標記負數\n\n→ Loop: for each character ch in s\n    → Decision: ch 是否為 '['? // 開啟新子列表\n        Yes →\n            → Step 7: 若 currentNumber 非空，將其轉為數字並加入堆疊頂層 // 處理前面緊跟著的數字\n            → Step 8: 建立新 NestedInteger list\n            → Step 9: 若 stack 非空，將此新 list 加入堆疊頂層\n            → Step 10: 推進堆疊，將新 list 作為堆疊頂層\n            → Step 11: 重置 currentNumber, isNegative\n        No →\n            → Decision: ch 是否為 ']'? // 關閉當前子列表\n                Yes →\n                    → Step 12: 若 currentNumber 非空，將其轉為數字並加入堆疊頂層\n                    → Step 13: 若 isNegative 為 true，將數字乘 -1\n                    → Step 14: 取出堆疊頂層 list，pop\n                    → Step 15: 若 stack 非空，將此 list 加入新的堆疊頂層\n                    → Step 16: 重置 currentNumber, isNegative\n                No →\n                    → Decision: ch 是否為 ','? // 分隔符，表示已完成一個元素\n                        Yes →\n                            → Step 17: 若 currentNumber 非空，將其轉為數字並加入堆疊頂層\n                            → Step 18: 若 isNegative 為 true，將數字乘 -1\n                            → Step 19: 重置 currentNumber, isNegative\n                        No →\n                            → Decision: ch 是否為 '-'? // 負號標記\n                                Yes →\n                                    → Step 20: 設置 isNegative 為 true\n                                No →\n                                    → Step 21: 將 ch 加到 currentNumber // 累積數字字元\n\n→ EndLoop // 逐字檢查完畢\n\n→ Decision: currentNumber 是否非空? // 最後一個數字未被處理\n    Yes →\n        → Step 22: 若 isNegative 為 true，將 currentNumber 乘 -1\n        → Step 23: 建立 NestedInteger 並加入堆疊頂層\n    No  → No action\n\n→ Step 24: 若 stack 非空，stack.top 為最外層 NestedInteger // 結束時堆疊只剩一個元素\n→ Step 25: 取出並回傳 stack.top // 反序列化完成\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom typing import List\n\nclass NestedInteger:\n    \"\"\"\n    A minimal implementation of the NestedInteger interface used in\n    LeetCode problem 385.  Each instance can hold either a single integer\n    or a nested list of NestedInteger objects.\n    \"\"\"\n    def __init__(self, value=None):\n        if value is None:\n            self._list: List[NestedInteger] = []\n            self._integer = None\n        elif isinstance(value, int):\n            self._list = None\n            self._integer = value\n        else:\n            raise ValueError(\"NestedInteger can only be initialized with None or int\")\n\n    def isInteger(self) -> bool:\n        \"\"\"Return True if this NestedInteger holds a single integer.\"\"\"\n        return self._integer is not None\n\n    def add(self, elem: \"NestedInteger\") -> None:\n        \"\"\"Add a NestedInteger element to this list.\"\"\"\n        if self.isInteger():\n            raise ValueError(\"Cannot add to a NestedInteger that holds a single integer\")\n        self._list.append(elem)\n\n    def setInteger(self, value: int) -> None:\n        \"\"\"Set this NestedInteger to hold a single integer.\"\"\"\n        self._integer = value\n        self._list = None\n\n    def getInteger(self):\n        \"\"\"Return the single integer that this NestedInteger holds, or None.\"\"\"\n        return self._integer\n\n    def getList(self):\n        \"\"\"Return the list that this NestedInteger holds, or None.\"\"\"\n        return self._list\n\n    def __str__(self) -> str:\n        \"\"\"Serialize the NestedInteger back to the format used in the problem.\"\"\"\n        if self.isInteger():\n            return str(self._integer)\n        return \"[\" + \",\".join(str(x) for x in self._list) + \"]\"\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        \"\"\"\n        Deserialize a string that represents a nested list into a NestedInteger object.\n        \"\"\"\n        if not s:\n            return NestedInteger()\n\n        # If the string does not start with '[', it represents a single integer.\n        if s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack: List[NestedInteger] = []\n        num_buffer = \"\"\n        negative = False\n\n        for ch in s:\n            if ch == '[':\n                # Start a new list; push it onto the stack\n                new_list = NestedInteger()\n                if stack:\n                    stack[-1].add(new_list)\n                stack.append(new_list)\n                num_buffer = \"\"\n                negative = False\n            elif ch == ']':\n                # Finish current number if any\n                if num_buffer:\n                    value = -int(num_buffer) if negative else int(num_buffer)\n                    stack[-1].add(NestedInteger(value))\n                    num_buffer = \"\"\n                    negative = False\n                # Close the current list\n                if len(stack) > 1:\n                    finished = stack.pop()\n                    stack[-1].add(finished)\n            elif ch == ',':\n                # Separator between elements; finalize any pending number\n                if num_buffer:\n                    value = -int(num_buffer) if negative else int(num_buffer)\n                    stack[-1].add(NestedInteger(value))\n                    num_buffer = \"\"\n                    negative = False\n            elif ch == '-':\n                negative = True\n            else:  # digit\n                num_buffer += ch\n\n        # After the loop, there might be a number left (for the outermost list)\n        if num_buffer:\n            value = -int(num_buffer) if negative else int(num_buffer)\n            stack[-1].add(NestedInteger(value))\n\n        return stack[0]\n\ndef main():\n    \"\"\"\n    Read input from stdin, deserialize it, and print the serialized form.\n    The input format is expected to be something like:\n        s = \"[123,[456,[789]]]\"\n    The quotes around the string are part of the input.\n    \"\"\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Extract the string literal between the first and last double quotes.\n    first_quote = raw_input.find('\"')\n    last_quote = raw_input.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = raw_input[first_quote + 1:last_quote]\n    else:\n        # Fallback: if no quotes, use the whole trimmed input\n        s = raw_input\n\n    solution = Solution()\n    result = solution.deserialize(s)\n    print(str(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"324\"",
          "expected_output": "324",
          "success": true,
          "output": "324"
        },
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[123,[456,[789]]]'\nGot (Norm):      '[123,[456,[789],[789]],[456,[789],[789]]]'\n--- (Raw) ---\nRaw Expected: '[123,[456,[789]]]'\nRaw Got:      '[123,[456,[789],[789]],[456,[789],[789]]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode477.json",
    "problem_index_in_file": 0,
    "title": "Total Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for computing sum of Hamming distances between all pairs of integers in array nums. We need step by step explanation. Must not output actual code, only virtual steps.\n\nWe must output line by line, each line: virtual code step, space, // explanation.\n\nUse virtual arrows, Start, End, Decision, etc.\n\nLet's craft algorithm: For each bit position 0-31, count number of numbers with bit=1, let cnt1. Then cnt0 = n - cnt1. Each pair with one bit 1 and other 0 contributes 1 to Hamming distance. Number of such pairs = cnt1 * cnt0. Sum over bits. Total sum = sum(cnt1*cnt0) * 1 (since each bit diff contributes 1). But careful: each pair counted once. We can compute total sum = sum over bits cnt1*cnt0. That gives total number of differing bits across all unordered pairs. Since Hamming distance between pair is sum over bits of XOR. So algorithm: iterate bits, compute count1, add cnt1*(n-cnt1) to result. Complexity O(32*n).\n\nThus produce pseudocode. We need lines. Steps: Start, Step 1: initialize sum=0. Step 2: n=length(nums). Step 3: for bit in 0..31: Step 4: count1=0; Step 5: for each num in nums: if num bit set: count1++ ; Step 6: count0 = n - count1; Step 7: sum += count1 * count0 ; Step 8: return sum; End.\n\nAlso can add Decision: if nums empty? but not needed. Provide decisions maybe.\n\nLet's craft. Use arrow notation: \"→\" before step. Use \"Decision:\" lines maybe.\n\nWe can include \"Start\" line. \"End\" line.\n\nAdd \"Decision: If nums is empty? // 若空則直接回傳 0\".\n\nWe can produce:\n\nStart // 程式開始執行\n→ Decision: nums 是否為空？ // 檢查陣列是否為空\n    Yes → Step 1: 回傳 0 // 空陣列無對子，距離總和為 0\n    No  → Step 2: 初始化 sum = 0, n = nums.length // 設定結果與陣列長度\n→ Step 3: 對每個 bit 位 (0~31) 做循環 // 逐位計算差異\n    → Step 4: 計算 count1 = 0 // 這個位元為 1 的數量\n    → Step 5: 對 nums 中每個 num 做循環\n        → Decision: (num >> bit) & 1 == 1 ? // 檢查此位是否為 1\n            Yes → count1 += 1 // 位元為 1 的數量加一\n            No  → // 不變，跳過\n    → Step 6: count0 = n - count1 // 這個位元為 0 的數量\n    → Step 7: sum += count1 * count0 // 加上此位對所有對子的貢獻\n→ Step 8: 回傳 sum // 結束，輸出總 Hamming 距離\nEnd // 程式執行結束\n\nCheck formatting: each line has \"虛擬碼步驟\" and then space then comment.\n\nWe need to use arrow for lines within loops: Use \"→\" before each step. For nested steps, indent? We can include \"→\" for each nested step. Use indentation maybe with spaces. But maintain format: each line separate.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: nums 是否為空？ // 檢查陣列是否為空  \n  Yes → Step 1: 回傳 0 // 空陣列無對子，距離總和為 0  \n  No  → Step 2: 初始化 sum = 0, n = nums.length // 設定結果與陣列長度  \n→ Step 3: 對每個 bit 位 (0~31) 做循環 // 逐位計算差異  \n  → Step 4: 計算 count1 = 0 // 這個位元為 1 的數量  \n  → Step 5: 對 nums 中每個 num 做循環  \n    → Decision: (num >> bit) & 1 == 1 ? // 檢查此位是否為 1  \n      Yes → count1 += 1 // 位元為 1 的數量加一  \n      No  → // 不變，跳過  \n  → Step 6: count0 = n - count1 // 這個位元為 0 的數量  \n  → Step 7: sum += count1 * count0 // 加上此位對所有對子的貢獻  \n→ Step 8: 回傳 sum // 結束，輸出總 Hamming 距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def totalHammingDistance(self, nums):\n        total = 0\n        n = len(nums)\n        for i in range(32):  # 32 位整數\n            count_ones = sum((num >> i) & 1 for num in nums)\n            count_zeros = n - count_ones\n            total += count_ones * count_zeros\n        return total\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，預期格式為 'nums = [4,14,2]' 或直接為 '[4,14,2]'。\n    \"\"\"\n    # 只取中括號內的部分\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end <= start:\n        # 無法找到列表，返回空列表\n        return []\n    list_str = data[start:end+1]\n    try:\n        return ast.literal_eval(list_str)\n    except Exception:\n        # 若解析失敗，回傳空列表\n        return []\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.totalHammingDistance(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,14,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [4,14,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode115.json",
    "problem_index_in_file": 0,
    "title": "Distinct Subsequences",
    "description_snippet": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\n\nThe test...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: count distinct subsequences of s that equal t. Standard DP: dp[i][j] count of subsequences of s[0..i-1] that equal t[0..j-1]. Or 1D dp. We'll produce step-by-step algorithm, explaining each line.\n\nWe need to output as per format: each line \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision, arrow. Provide step-by-step including input reading, initializing, DP loops, final output.\n\nWe must avoid actual code, but provide pseudo-steps. For example:\n\nStart // Program starts\n→ Step 1: Read strings s and t // get input\n→ Step 2: Let m = length of s, n = length of t // define lengths\n→ Step 3: If n == 0 → Return 1 // empty t matches any subsequence once\n→ Decision: If m < n? // if s shorter than t cannot match\n    Yes → Return 0\n    No → Continue\n→ Step 4: Create array dp[0..n] // DP array\n→ Step 5: Initialize dp[0] = 1 // empty t matches any prefix of s\n→ Step 6: For i from 1 to m:\n    → Step 7: For j from n down to 1:\n        → Decision: If s[i-1] == t[j-1]?\n            Yes → dp[j] = dp[j] + dp[j-1] // include match\n            No → dp[j] = dp[j] // unchanged\n    → Step 8: // After inner loop, dp holds counts for s[0..i-1]\n→ Step 9: Return dp[n] // result\n\nWe need to add comments. Use arrow \"→\". Use \"Yes →\" \"No →\". Use indentation maybe.\n\nMake sure each line is separate. For loops, we may show nested steps. Example:\n\n→ Step 6: For i in 1..m: // iterate over characters of s\n    → Step 7: For j in n down to 1: // iterate t backwards\n        → Decision: If s[i-1] == t[j-1]?\n            Yes → dp[j] = dp[j] + dp[j-1] // update count\n            No → dp[j] = dp[j] // no change\n\nBut maybe better to separate nested steps with indentation or arrow again.\n\nWe need to show virtual code lines with \"Start\" \"End\" and \"Decision:\" etc. We'll keep simple.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取兩個字串 s 與 t // 取得輸入資料  \n→ Step 2: 設 m = s 的長度，n = t 的長度 // 定義長度變數  \n→ Step 3: Decision: 如果 n == 0? // 判斷 t 是否為空字串  \n  Yes → Step 4: 回傳 1 // 空字串只會有一種子序列（空子序列）  \n  No → 進行下一步  \n→ Step 5: Decision: 如果 m < n? // s 仍短於 t 不能匹配  \n  Yes → Step 6: 回傳 0 // 無法得到 t  \n  No → 進行下一步  \n→ Step 7: 建立 dp[0..n] 的數列 // dp[j] 代表前 i 個 s 形成 t[0..j-1] 的子序列數  \n→ Step 8: 初始化 dp[0] = 1 // 空子序列能匹配 t 的空前綴  \n→ Step 9: Decision: 開始外層迴圈 for i 取 1 至 m  \n  Yes → Step 10: Decision: 內層迴圈 for j 取 n 降至 1  \n    Yes → Step 11: Decision: 若 s[i-1] == t[j-1]?  \n      Yes → dp[j] = dp[j] + dp[j-1] // 加入新的匹配子序列  \n      No → dp[j] = dp[j] // 不變，保持原先計數  \n    No → 跳出內層迴圈  \n  No → 跳出外層迴圈  \n→ Step 12: 回傳 dp[n] // dp[n] 為整個 s 中等於 t 的子序列總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_distinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    if n == 0:\n        return 1\n    if m < n:\n        return 0\n\n    dp = [0] * (n + 1)\n    dp[0] = 1  # empty t matches any prefix of s\n\n    for i in range(1, m + 1):\n        # iterate backwards to avoid overwriting needed values\n        for j in range(n, 0, -1):\n            if s[i - 1] == t[j - 1]:\n                dp[j] += dp[j - 1]\n    return dp[n]\n\ndef parse_input(data: str):\n    \"\"\"\n    將 stdin 內容轉成兩個字串 s、t。\n    支援以下兩種常見輸入方式：\n    1. 每行一個字串（常見的競賽輸入格式）。\n    2. 單行，格式類似 's = \"rabbbit\", t = \"rabbit\"'。\n    \"\"\"\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # 單行格式，先尋找雙引號中的內容\n    quoted = re.findall(r'\"([^\"]*)\"', lines[0])\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # 失敗時直接按空白切分\n    parts = lines[0].split()\n    return parts[0], parts[1] if len(parts) > 1 else \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, t = parse_input(raw_input)\n    result = num_distinct(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode211.json",
    "problem_index_in_file": 0,
    "title": "Design Add and Search Words Data Structure",
    "description_snippet": "Design a data structure that supports adding new words and finding if a string matches any previousl...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for a WordDictionary with addWord and search, supporting wildcard '.' . This is classic trie with DFS. Provide line-by-line virtual code with arrows. Provide explanation in Chinese. No actual code. Should be structured. Let's produce steps:\n\nStart\n→ Step 1: Initialize root node with children dict and isEnd flag // Trie root\n→ Step 2: addWord(word): iterate chars, traverse/create child nodes, set isEnd at end // Add word\n→ Step 3: search(word): call helper function searchFrom(node, index) // Recursively search\n→ Step 4: helper(node, index): if index==len(word): return node.isEnd // reached end\n→ Step 5: char = word[index]\n    Decision: char is '.' ?\n        Yes → For each child in node.children:\n                  if searchFrom(child, index+1): return True\n               return False // no child matched\n        No → if char in node.children:\n                 return searchFrom(node.children[char], index+1)\n               else return False // no matching child\n→ End\n\nWe need to produce with arrow indentation. Use '→' for sequential steps, 'Decision:' for branching. Each line with comment. Ensure format matches example: \"Start // 程式開始執行\" etc. We must use '虛擬碼步驟' and comment. Use same format. Provide each line. Use arrow '→' before step lines. Use indentation maybe spaces. Provide consistent. Use Chinese explanations.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 Trie 根節點，包含 children map 與 isEnd 標誌 // 初始化資料結構\n→ Step 2: 定義 addWord(word) // 方法開始\n    → Step 2.1: node ← root // 從根開始\n    → Step 2.2: for 每個字元 c in word: // 遍歷字串\n        → Decision: c 是否已存在於 node.children?\n            Yes → node ← node.children[c] // 移動到已有節點\n            No  → node.children[c] ← 新節點 // 新增節點\n    → Step 2.3: node.isEnd ← True // 設定單字結束標誌\n→ Step 3: 定義 search(word) // 方法開始\n    → Decision: 直接呼叫 helper(root, 0) // 由根節點遞迴搜尋\n        Yes → return helper(root, 0)\n→ Step 4: 定義 helper(node, idx) // 內部遞迴函式\n    → Decision: idx == len(word)?\n        Yes → return node.isEnd // 完全匹配時檢查結束標誌\n        No  → char ← word[idx] // 取當前字元\n        → Decision: char 是否為 '.' ?\n            Yes → // '.' 可以匹配任意字母\n                → For 每個 child 在 node.children.values():\n                    → Decision: helper(child, idx+1) 為 True?\n                        Yes → return True // 任一分支匹配成功\n                → return False // 無分支匹配\n            No  → // 正常字母\n                → Decision: char 是否存在於 node.children?\n                    Yes → return helper(node.children[char], idx+1) // 直接遞迴\n                    No  → return False // 沒有對應節點\n→ End // 程式執行結束\n\nMake sure each line has format: \"→ Step 1: ...\" with comment. For indentation, we can use spaces before arrow? The example uses a single arrow for each line, with indentation for decisions. We'll replicate that.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Trie 根節點，包含 children map 與 isEnd 標誌 // 初始化資料結構  \n\n→ Step 2: 定義 addWord(word) // 方法開始  \n    → Step 2.1: node ← root // 從根節點開始  \n    → Step 2.2: for 每個字元 c in word: // 遍歷字串  \n        → Decision: c 是否已存在於 node.children?  \n            Yes → node ← node.children[c] // 移動到已存在節點  \n            No  → node.children[c] ← 新節點 // 新增節點  \n    → Step 2.3: node.isEnd ← True // 標記單字結束  \n\n→ Step 3: 定義 search(word) // 方法開始  \n    → Decision: 直接呼叫 helper(root, 0) // 由根節點遞迴搜尋  \n        Yes → return helper(root, 0)  \n\n→ Step 4: 定義 helper(node, idx) // 內部遞迴函式  \n    → Decision: idx == len(word)?  \n        Yes → return node.isEnd // 完全匹配時檢查結束標誌  \n        No  → char ← word[idx] // 取當前字元  \n    → Decision: char 是否為 '.' ?  \n        Yes → // '.' 可以匹配任意字母  \n            → For 每個 child 在 node.children.values():  \n                → Decision: helper(child, idx+1) 為 True?  \n                    Yes → return True // 任一分支匹配成功  \n            → return False // 無分支匹配  \n        No  → // 正常字母  \n            → Decision: char 是否存在於 node.children?  \n                Yes → return helper(node.children[char], idx+1) // 直接遞迴  \n                No  → return False // 沒有對應節點  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return node.is_end\n            if word[i] == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if word[i] not in node.children:\n                    return False\n                return dfs(node.children[word[i]], i + 1)\n        return dfs(self.root, 0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, args = json.loads(data)\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            results.append(None)\n        elif op == \"search\":\n            results.append(obj.search(arg[0]))\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmprs9sxayh.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmprs9sxayh.py\", line 40, in main\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode556.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element III",
    "description_snippet": "Given a positive integer n, find the smallest integer which has exactly the same digits existing in ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows etc. The problem: \"next greater element\" problem. Steps: Input n. Convert to array of digits. Find pivot: rightmost digit that is smaller than its next digit to the right. If none, return -1. Then find rightmost successor to pivot that is greater than pivot. Swap. Reverse suffix after pivot. Convert back to number, check 32-bit overflow, return number or -1. Need virtual steps.\n\nWe must output in Traditional Chinese. Each line with arrow structure. Let's produce Start, Input, etc. Provide explanation in Chinese.\n\nWe should include decision nodes.\n\nLet's produce:\n\nStart\n→ Step 1: 取得輸入整數 n // 獲取使用者輸入\n→ Step 2: 將 n 轉為數字陣列 digits // 方便操作各位\n→ Decision: 如果 digits 長度 <= 1? // 只一位無法構成更大數\n    Yes → Step 3: 回傳 -1 // 返回失敗\n    No  → Step 4: 設定 pivot = -1 // 需要尋找升序點\n→ Step 5: 從右往左遍歷 digits，尋找第一個 digits[i] < digits[i+1] 並設 pivot = i // 找升序點\n→ Decision: pivot == -1? // 若無升序點\n    Yes → Step 6: 回傳 -1 // 無更大數\n    No  → Step 7: 找 successor: 從右往左遍歷 digits，尋找第一個 digits[j] > digits[pivot] 並設 successor = j\n→ Step 8: 交換 digits[pivot] 與 digits[successor] // 交換兩位\n→ Step 9: 逆序 digits[pivot+1 .. end] // 將後綴升序（即升級為最小）\n→ Step 10: 將 digits 轉回整數 result // 重新組合數字\n→ Decision: result > 2^31-1? // 檢查是否超出 32-bit\n    Yes → Step 11: 回傳 -1 // 超限\n    No  → Step 12: 回傳 result // 成功\nEnd\n\nMake sure each line has // explanation after space. Use arrow for decision. Use indentation for nested. Provide explanation.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入整數 n // 獲取使用者輸入  \n→ Step 2: 將 n 轉為數字陣列 digits // 方便對每位數進行操作  \n→ Decision: 如果 digits 長度 <= 1? // 只有一位數時無法構成更大的數  \n    Yes → Step 3: 回傳 -1 // 直接返回失敗結果  \n    No  → Step 4: 設定 pivot = -1 // 初始化升序點位置  \n→ Step 5: 從右往左遍歷 digits，尋找第一個 digits[i] < digits[i+1] 並設 pivot = i // 找到可升級的位  \n→ Decision: pivot == -1? // 若無升序點，無更大排列  \n    Yes → Step 6: 回傳 -1 // 無可行答案  \n    No  → Step 7: 從右往左遍歷 digits，尋找第一個 digits[j] > digits[pivot] 並設 successor = j // 找到最小的大於 pivot 的位  \n→ Step 8: 交換 digits[pivot] 與 digits[successor] // 交換兩位  \n→ Step 9: 逆序 digits[pivot+1 .. end] // 將後綴升序以獲得最小更大數  \n→ Step 10: 將 digits 轉回整數 result // 重新組合成整數  \n→ Decision: result > 2^31-1? // 檢查是否超出 32 位整數範圍  \n    Yes → Step 11: 回傳 -1 // 超限則返回失敗  \n    No  → Step 12: 回傳 result // 返回有效答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def nextGreaterElement(self, n: int) -> int:\n        digits = list(str(n))\n        i = len(digits) - 2\n        # 找到第一個升序點\n        while i >= 0 and digits[i] >= digits[i + 1]:\n            i -= 1\n        if i == -1:\n            return -1  # 沒有更大的排列\n        j = len(digits) - 1\n        # 找到比升序點大且最小的數字\n        while digits[j] <= digits[i]:\n            j -= 1\n        digits[i], digits[j] = digits[j], digits[i]\n        # 逆序後續數字，得到最小的更大數\n        digits[i + 1:] = reversed(digits[i + 1:])\n        result = int(\"\".join(digits))\n        return result if result < 2 ** 31 else -1\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，支援 \"n = 12\" 或直接 \"12\" 的格式\n    if '=' in data:\n        _, num_str = data.split('=', 1)\n        n = int(num_str.strip())\n    else:\n        n = int(data)\n    sol = Solution()\n    print(sol.nextGreaterElement(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "21",
          "success": true,
          "output": "21"
        },
        {
          "example_index": 1,
          "input": "n = 21",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode507.json",
    "problem_index_in_file": 0,
    "title": "Perfect Number",
    "description_snippet": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. The algorithm: To check if n is perfect number. Steps: If n <= 1 return false. Compute sum of divisors excluding n. For i from 1 to sqrt(n), if i divides n: add i, if i != 1 and i != n/i then add n/i. Then compare sum to n. Return true/false.\n\nNeed to use virtual code style: Start, Decision, Step, End. We need arrows and indent for nested decisions. Use \"Decision:\" lines for conditions. Use \"Yes →\" and \"No →\". Use Start and End.\n\nLet's produce virtual code:\n\nStart\n→ Decision: n <= 1? // 如果 n 小於等於 1 就不是完美數\n    Yes → Step: return False // 直接返回 False\n    No  → Step: sum ← 0 // 初始化除數總和\n→ Step: max ← floor(sqrt(n)) // 只需檢查到平方根\n→ Step: i ← 1 // 從 1 開始\n→ Decision: i <= max? // 循環條件\n    Yes → Decision: n mod i == 0? // i 是否為 n 的除數\n        Yes → Step: sum ← sum + i // 加上 i\n        No  → // 不做任何事\n    Yes → Decision: i ≠ 1 AND i ≠ n / i? // i 與配對除數不同\n        Yes → Step: sum ← sum + n / i // 加上配對除數\n        No  → // 配對除數為 i 本身，已加過\n    → Step: i ← i + 1 // 下一個 i\n    → Go back to Decision: i <= max?\n    No  → // i 大於 max，結束循環\n→ Decision: sum == n? // 最終判斷\n    Yes → Step: return True\n    No  → Step: return False\nEnd\n\nBut need to follow format: Each line \"虛擬碼步驟\" then space then // explanation. Also use arrow arrow \"→\" etc.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Decision: n <= 1? // 判斷 n 是否小於等於 1\n    Yes → Step: return False // n <= 1 不是完美數，直接返回 False\n    No  → Step: sum ← 0 // 初始化除數總和為 0\n→ Step: max ← floor(sqrt(n)) // 計算 n 的平方根作為上限\n→ Step: i ← 1 // 設定迴圈起始值\n→ Decision: i <= max? // 判斷是否還有數字要檢查\n    Yes → Decision: n mod i == 0? // i 是否能整除 n\n        Yes → Step: sum ← sum + i // 將 i 加到總和\n        No  → // i 不是除數，略過\n    Yes → Decision: i ≠ 1 AND i ≠ n / i? // 配對除數是否不同\n        Yes → Step: sum ← sum + n / i // 加入配對除數\n        No  → // 配對除數等於 i，已在前面加過\n    → Step: i ← i + 1 // 移動到下一個 i\n    → Go back to Decision: i <= max? // 重新檢查循環條件\n    No  → // i 超過 max，結束循環\n→ Decision: sum == n? // 最終比較總和與 n\n    Yes → Step: return True // 相等即為完美數\n    No  → Step: return False // 不相等則不是\nEnd // 程式結束\n\nWe need to ensure each line has virtual code step and explanation. Also the indentation for nested decisions. Use \"→\" and \"Yes →\" \"No →\". For Go back to Decision we can just use arrow back? In previous example they used \"Yes →\" \"No →\" inside Decision. They also used \"→\" for Step lines. So we can maintain.\n\nHowever the line \"→ Go back to Decision: i <= max?\" is not typical; we could instead use \"→ Step: // 重新檢查 i <= max\" but maybe simpler: after step i++ we can go back to the Decision i <= max, but that's implicit loop. We can represent as arrow: \"→ Decision: i <= max?\" again but maybe it's okay.\n\nWe need to keep structure: Use Decision: ... then Yes/No arrow lines. For loop, we can use Decision with Yes/No to handle iteration. After Yes path, we go back to start of loop; after No path we exit.\n\nThus produce:\n\nStart // 程式開始執行\n→ Decision: n <= 1? // 判斷 n 是否小於等於 1\n    Yes → Step: return False // n <= 1 不是完美數，直接返回 False\n    No  → Step: sum ← 0 // 初始化除數總和為 0\n→ Step: max ← floor(sqrt(n)) // 計算 n 的平方根作為上限\n→ Step: i ← 1 // 設定迴圈起始值\n→ Decision: i <= max? // 循環判斷 i 是否小於等於 max\n    Yes → Decision: n mod i == 0? // i 是否為 n 的除數\n        Yes → Step: sum ← sum + i // 加入 i 到總和\n        No  → // i 不是除數，無操作\n    Yes → Decision: i ≠ 1 AND i ≠ n / i? // 配對除數是否不同\n        Yes → Step: sum ← sum + n / i // 加入配對除數\n        No  → // 配對除數等於 i，已加過\n    → Step: i ← i + 1 // 進入下一個 i\n    → Go back to Decision: i <= max? // 重新檢查循環條件\n    No  → // i > max，結束循環\n→ Decision: sum == n? // 最終判斷是否為完美數\n    Yes → Step: return True // 相等即為完美數\n    No  → Step: return False // 不相等則不是\nEnd // 程式執行結束\n\nWe need each line to have \"虛擬碼步驟\" + space + \"// 解釋/說明\". The arrow lines are part of virtual code. The \"→ Go back to Decision: i <= max?\" is maybe okay.\n\nBut we need to be careful: \"→ Go back to Decision: i <= max?\" has explanation. But that line is not exactly a step; we might just use \"→ Decision: i <= max?\" again. But inside we have nested decisions; maybe we can restructure as typical loop: after the last Step: i ← i + 1, we just go back to Decision: i <= max? with arrow. That is okay.\n\nBut we must adhere to format: each line \"虛擬碼步驟\" + \" // 解釋\". So we need to add explanation for each line. Let's rewrite:\n\nStart // 程式開始執行\n→ Decision: n <= 1? // 判斷 n 是否小於等於 1\n    Yes → Step: return False // n <= 1 不是完美數，直接返回 False\n    No  → Step: sum ← 0 // 初始化除數總和為 0\n→ Step: max ← floor(sqrt(n)) // 計算 n 的平方根作為上限\n→ Step: i ← 1 // 設定迴圈起始值\n→ Decision: i <= max? // 判斷 i 是否還在可檢查範圍內\n    Yes → Decision: n mod i == 0? // 判斷 i 是否為 n 的除數\n        Yes → Step: sum ← sum + i // 將 i 加入總和\n        No  → // i 不是除數，跳過\n    Yes → Decision: i ≠ 1 AND i ≠ n / i? // 判斷配對除數是否不同\n        Yes → Step: sum ← sum + n / i // 加入配對除數\n        No  → // 配對除數等於 i，已加過\n    → Step: i ← i + 1 // i 增加 1，準備下一次迴圈\n    → Decision: i <= max? // 重新檢查循環條件\n    No  → // i 超過 max，結束循環\n→ Decision: sum == n? // 最終比較總和與 n\n    Yes → Step: return True // 相等即為完美數\n    No  → Step: return False // 不相等則不是\nEnd // 程式執行結束\n\nWe have repeated Decision: i <= max? twice. In second instance, we don't need \"No\" because we already handle No earlier; but we still need to produce line.\n\nBetter: after \"→ Step: i ← i + 1\", we simply go back to \"Decision: i <= max?\" which is the top of loop. So we can have arrow \"→ Decision: i <= max?\" which will be evaluated again; the No branch of this decision will exit loop. That is fine.\n\nBut we must indent properly. The second Decision lines are nested inside the first Yes branch? Actually after the first Decision (i <= max?) Yes branch includes all the steps inside; after i++ we should go back to Decision again. So we don't need to indent the second Decision; it's at same level as the earlier Decision, but inside the Yes branch. We can represent it as arrow after i++.\n\nWe need to format indentation properly. Let's produce final virtual code.\n\nAlso ensure each line has explanation. Let's write:\n\nStart // 程式開始執行\n→ Decision: n <= 1? // 判斷 n 是否小於等於 1\n    Yes → Step: return False // n <= 1 不是完美數，直接返回 False\n    No  → Step: sum ← 0 // 初始化除數總和為 0\n→ Step: max ← floor(sqrt(n)) // 計算 n 的平方根作為上限\n→ Step: i ← 1 // 設定迴圈起始值\n→ Decision: i <= max? // 判斷 i 是否還在可檢查範圍內\n    Yes → Decision: n mod i == 0? // 判斷 i 是否為 n 的除數\n        Yes → Step: sum ← sum + i // 將 i 加入總和\n        No  → // i 不是除數，跳過\n    Yes → Decision: i ≠ 1 AND i ≠ n / i? // 判斷配對除數是否不同\n        Yes → Step: sum ← sum + n / i // 加入配對除數\n        No  → // 配對除數等於 i，已加過\n    → Step: i ← i + 1 // i 增加 1，準備下一次迴圈\n    → Decision: i <= max? // 重新檢查循環條件\n    No  → // i 超過 max，結束循環\n→ Decision: sum == n? // 最終比較總和與 n\n    Yes → Step: return True // 相等即為完美數\n    No  → Step: return False // 不相等則不是\nEnd // 程式執行結束\n\nCheck each line: For lines with No or Yes we have arrow. For the second Decision: i <= max? we use Yes and No. But we wrote \"No  → // i 超過 max，結束循環\" after the Decision; but we need to include arrow for No branch. In format, we should indent as Yes → and No → after Decision. In the above we wrote \"Yes → Decision: ...\". Actually we need indentation like:\n\n    Yes → Decision: n mod i == 0? // ...\n        Yes → Step: ...\n        No  → // ...\n\nSimilarly for i <= max? we need:\n\n    Yes → Decision: n mod i == 0?\n        ...\n    Yes → Decision: i ≠ 1 AND i ≠ n / i?\n        ...\n    → Step: i ← i + 1\n    → Decision: i <= max?\n        Yes → // loop again\n        No  → // exit\n\nBut we also need the Yes branch of the second Decision; but we don't need a Yes arrow because it loops again (which is implicit). But we can keep the structure.\n\nLet's restructure carefully:\n\nStart // 程式開始執行\n→ Decision: n <= 1? // 判斷 n 是否小於等於 1\n    Yes → Step: return False // n <= 1 不是完美數，直接返回 False\n    No  → Step: sum ← 0 // 初始化除數總和為 0\n→ Step: max ← floor(sqrt(n)) // 計算 n 的平方根作為上限\n→ Step: i ← 1 // 設定迴圈起始值\n→ Decision: i <= max? // 判斷 i 是否還在可檢查範圍內\n    Yes → Decision: n mod i == 0? // 判斷 i 是否為 n 的除數\n        Yes → Step: sum ← sum + i // 將 i 加入總和\n        No  → // i 不是除數，跳過\n    Yes → Decision: i ≠ 1 AND i ≠ n / i? // 判斷配對除數是否不同\n        Yes → Step: sum ← sum + n / i // 加入配對除數\n        No  → // 配對除數等於 i，已加過\n    → Step: i ← i + 1 // i 增加 1，準備下一次迴圈\n    → Decision: i <= max? // 重新檢查循環條件\n        Yes → // 迴圈持續\n        No  → // i 超過 max，結束循環\n→ Decision: sum == n? // 最終比較總和與 n\n    Yes → Step: return True // 相等即為完美數\n    No  → Step: return False // 不相等則不是\nEnd // 程式執行結束\n\nNow each line has explanation after //. But we need to ensure that lines like \"Yes → // 迴圈持續\" have explanation. But we might want to express as \"Yes → // 迴圈持續，返回上層判斷\" but it's fine.\n\nHowever some lines like \"Yes → // 迴圈持續\" are not necessary; we could just have \"Yes → // 迴圈繼續\" or \"Yes → // 繼續迴圈\".\n\nWe need to ensure each line has at least explanation.\n\nAlso the line \"→ Decision: i <= max?\" inside the Yes branch should have Yes and No sub-branches. Already added.\n\nBut the formatting might be off: The indentation for Yes/No lines should align. It's okay.\n\nAlso, we may need to include the \"Go back to Decision: i <= max?\" line earlier but we've used arrow with Decision.\n\nCheck for missing arrow lines: In the second Decision: i <= max? we need Yes and No arrows. Already there.\n\nNow final answer: produce the code block as per format. Ensure no extraneous spaces? Use code block with triple backticks. Let's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Decision: n <= 1? // 判斷 n 是否小於等於 1\n    Yes → Step: return False // n <= 1 不是完美數，直接返回 False\n    No  → Step: sum ← 0 // 初始化除數總和為 0\n→ Step: max ← floor(sqrt(n)) // 計算 n 的平方根作為上限\n→ Step: i ← 1 // 設定迴圈起始值\n→ Decision: i <= max? // 判斷 i 是否還在可檢查範圍內\n    Yes → Decision: n mod i == 0? // 判斷 i 是否為 n 的除數\n        Yes → Step: sum ← sum + i // 將 i 加入總和\n        No  → // i 不是除數，跳過\n    Yes → Decision: i ≠ 1 AND i ≠ n / i? // 判斷配對除數是否不同\n        Yes → Step: sum ← sum + n / i // 加入配對除數\n        No  → // 配對除數等於 i，已加過\n    → Step: i ← i + 1 // i 增加 1，準備下一次迴圈\n    → Decision: i <= max? // 重新檢查循環條件\n        Yes → // 迴圈持續，返回上層判斷\n        No  → // i 超過 max，結束循環\n→ Decision: sum == n? // 最終比較總和與 n\n    Yes → Step: return True // 相等即為完美數\n    No  → Step: return False // 不相等則不是\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\n\nclass Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        if num < 2:\n            return False\n        s = 1\n        i = 2\n        while i * i <= num:\n            if num % i == 0:\n                s += i\n                if i != num // i:\n                    s += num // i\n            i += 1\n        return s == num\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    n = int(data)\n    sol = Solution()\n    result = sol.checkPerfectNumber(n)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "28",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode476.json",
    "problem_index_in_file": 0,
    "title": "Number Complement",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode in the format requested. Steps: Start, input num, get binary string? But can do bitwise complement within bit length. Steps: find highest set bit, compute mask with same bits, complement by XOR. Or simpler: convert to binary string, flip bits, convert back. But we want generic. Use loop to find bit length. Then compute mask = (1 << length) -1. complement = num ^ mask. Return complement. Provide explanation per line.\n\nMake sure to adhere to format: \"Start // 程式開始執行\". Use arrows. Use Decision etc. We'll break into steps.\n\nStep 1: Input num. Step 2: Find highest bit position: while temp >0. Step 3: Compute mask. Step 4: Compute complement. Step 5: Return.\n\nWe can include decision to handle zero? For zero, complement would be 1? Wait 0 in binary \"0\" complement \"1\" -> integer 1. But using mask approach: highest bit position 0? We need at least one bit: if num==0, mask=1. So include decision: if num==0, mask=1 else compute. We'll use Decision: If num==0? Yes -> mask=1 else compute loop.\n\nLet's produce pseudocode accordingly.\n\nWe must output step by step lines, each with // explanation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入整數 num // 從使用者或調用處取得欲求補碼的數字  \n→ Decision: 若 num 為 0? // 特殊情況：0 的二進位為 '0'，其補碼為 '1'  \n  Yes → Step 2: 設定 mask = 1 // 只需要一個 1 來翻轉 0  \n  No  → Step 3: 設定 temp = num // 用 temp 來找最高位數",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        \"\"\"\n        取得 num 的二進位長度，建立全 1 掩碼，\n        再用 XOR 取得補碼。對於 0，bit_length() 為 0，\n        此時 mask 計算會得到 0，需要特別處理。\n        \"\"\"\n        if num == 0:\n            # 0 的二進位是 '0'，補碼為 '1' -> 整數 1\n            return 1\n        bit_length = num.bit_length()\n        mask = (1 << bit_length) - 1\n        return num ^ mask\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，找出第一個整數\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    num = int(match.group())\n    # 計算補碼並輸出\n    result = Solution().findComplement(num)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode703.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in a Stream",
    "description_snippet": "You are part of a university admissions office and need to keep track of the kth highest test score ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing KthLargest class with initialization and add method, using a min-heap of size k to maintain kth largest. Virtual code lines with arrow. Need to be clear: Start, Step 1: Define class, etc.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's produce flow: Start -> Define class KthLargest(k, nums) -> Initialize minHeap size k -> Insert first k elements into heap -> For remaining nums, if val > heap.min, replace. Then add method: if heap size < k, push val; else if val > heap.min, replace. Return heap.min. Use decisions.\n\nWe'll structure: Start // Begin program\n\n→ Step: 定義 KthLargest 類別 // 宣告類別\n→ Step: 成員變數: k, minHeap // 儲存 k 與小根堆\n\n→ Decision: 初始化時是否已有 nums? // 進行初始化\n\n    Yes → → Step: 將 nums 前 k 個元素插入 minHeap // 建立堆\n    Yes → → Step: 對於 nums 後續元素，如果大於 minHeap.min，替換並調整堆 // 保持堆大小 k\n    Yes → → Step: 這樣完成建構\n\n→ Step: 定義 add(val) 方法 // 新增分數\n\n    → Decision: minHeap.size < k? // 若堆還未滿\n        Yes → → Step: 將 val 插入 minHeap // 放入\n        Yes → → Step: 返回 minHeap.min // 目前 kth 大\n\n    → Decision: val > minHeap.min? // 若新值大於堆最小\n        Yes → → Step: 替換 minHeap.min 為 val // 更新堆\n        Yes → → Step: 返回 minHeap.min\n        No  → → Step: 返回 minHeap.min // 仍為 kth 大\n\nEnd // 結束\n\nMake sure arrow syntax as requested: \"→\" for normal steps, \"Decision:\" for decisions, with Yes → and No → inside.\n\nLet's write each line separately. Use Chinese. We'll include spaces after arrow. Also each line must have the comment after space. We'll follow format exactly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 定義 KthLargest 類別 // 建立一個類別來維護 kth 大\n→ Step: 成員變數: k, minHeap // k 表示順位, minHeap 是小根堆\n→ Step: 建構子 KthLargest(k, nums) 初始化 k 和 minHeap // 構造函式\n→ Decision: nums 是否存在? // 確認輸入陣列\n    Yes → → Step: 把 nums 的前 k 個元素插入 minHeap // 先填滿堆\n    Yes → → Step: 對 nums 後續元素若 val > minHeap.min，取代並重建堆 // 保持堆大小為 k\n    Yes → → Step: 初始化完成\n→ Step: 定義 add(val) 方法 // 新增分數並返回 kth 大\n    → Decision: minHeap.size < k? // 堆還未滿 k\n        Yes → → Step: 把 val 插入 minHeap // 直接加入\n        Yes → → Step: 返回 minHeap.min // 目前的 kth 大\n    → Decision: val > minHeap.min? // 新分數是否比堆最小大\n        Yes → → Step: 把 minHeap.min 替換為 val // 更新堆\n        Yes → → Step: 返回 minHeap.min // 更新後的 kth 大\n        No  → → Step: 返回 minHeap.min // 沒有變更，仍為 kth 大\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass KthLargest:\n    \"\"\"\n    用最小堆（size k）維護第 k 大元素。\n    \"\"\"\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        # 先把所有初始數字塞進堆中\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        \"\"\"\n        新增一個分數，並回傳目前的第 k 大元素。\n        \"\"\"\n        heapq.heappush(self.min_heap, val)\n        # 如果堆長度超過 k，丟掉最小的那個\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        # 堆的頂端就是第 k 大元素\n        return self.min_heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，預期兩行：方法名與對應參數\n    parts = data.splitlines()\n    if len(parts) >= 2:\n        methods = json.loads(parts[0].strip())\n        args = json.loads(parts[1].strip())\n    else:\n        # 若輸入僅一行，使用逗號分隔的方法與參數\n        first, second = data.split('],', 1)\n        methods = json.loads(first + ']')\n        args = json.loads('[' + second)\n\n    results = []\n    obj = None\n\n    for method, arg in zip(methods, args):\n        if method == 'KthLargest':\n            k, nums = arg\n            obj = KthLargest(k, nums)\n            results.append(None)          # 建構子對應 null\n        elif method == 'add':\n            val = arg[0]\n            results.append(obj.add(val))\n\n    # 輸出結果，JSON 會自動把 None 轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp_dbrfder.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmp_dbrfder.py\", line 41, in main\n    args = json.loads('[' + second)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 48 (char 47)"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpiewq773_.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpiewq773_.py\", line 41, in main\n    args = json.loads('[' + second)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 49 (char 48)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode315.json",
    "problem_index_in_file": 0,
    "title": "Count of Smaller Numbers After Self",
    "description_snippet": "Given an integer array nums, return an integer array counts where counts[i] is the number of smaller...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code that, given an integer array nums, returns an integer array counts where counts[i] is the number of smaller elements to the right of nums[i]. They want a virtual code representation, not actual code. They want each line with the virtual code and explanation, with Start, End, Decision: and arrows. We need to produce a solution. For this problem, typical solution uses binary indexed tree, or order statistic tree, or divide and conquer. We need to write pseudo algorithm steps. The instructions: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋\". We need to output in structure: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow. Use \"Start\", \"End\", \"Decision:\".\n\nThus we can produce pseudo-code for an algorithm.\n\nLet's outline algorithm:\n\nStart\n→ Initialize result array counts of same length as nums with zeros\n→ Initialize an empty Binary Indexed Tree (Fenwick tree) or order statistic tree\n→ For i from nums.length-1 down to 0:\n    → Decision: If BIT empty? // no need\n    → Step: Query BIT for count of elements less than nums[i] // number of smaller to right\n    → Store query result in counts[i]\n    → Step: Update BIT by inserting nums[i] // add this element\n→ End // return counts\n\nBut we need to mention BIT initialization and coordinate compression. Let's produce steps:\n\nStart\n→ Step 1: Compress values in nums to ranks // to use in BIT\n→ Step 2: Create BIT of size equal to number of unique values\n→ Step 3: Initialize counts array of length nums.length with zeros\n→ Step 4: For i from nums.length-1 down to 0:\n    → Decision:  // inside loop\n        Yes → Step 4.1: Query BIT for prefix sum up to rank(nums[i]) - 1 // number of smaller elements seen\n        Yes → Step 4.2: Set counts[i] = query result\n        Yes → Step 4.3: Update BIT at rank(nums[i]) by adding 1 // record current element\n→ End // return counts\n\nBut we need \"Yes\" arrow only if we want to branch. The Decision step can check something, but we might not need decision. But can use a Decision for loop? We can express loop as Step 4: For i ... but that's a step. But we can treat loop as Step 4: While i >= 0. Or use a Decision: while i >=0? Yes.\n\nWe need each line with arrow.\n\nWe can use:\n\nStart // 程式開始\n\n→ Step 1: Create array counts same length as nums, initialized to 0 // 用於存儲結果\n\n→ Step 2: Build a list of unique values from nums and sort // 進行壓縮映射\n\n→ Step 3: Create a mapping value -> rank (1-based) // 用於 BIT 索引\n\n→ Step 4: Initialize Binary Indexed Tree (Fenwick) of size equal to number of unique values // 用於快速查詢和更新\n\n→ Step 5: Set index i = nums.length - 1 // 從右往左遍歷\n\n→ Decision: i >= 0? // 仍有元素未處理\n\n    Yes → Step 5.1: Let rank = mapping[nums[i]] // 找到當前值的排名\n\n    Yes → Step 5.2: Query BIT for sum of indices 1 to rank-1 // 取得右側較小元素數量\n\n    Yes → Step 5.3: Set counts[i] = query result // 存入結果\n\n    Yes → Step 5.4: Update BIT at index rank by +1 // 記錄這個元素已經出現\n\n    Yes → Step 5.5: i = i - 1 // 移動到下一個\n\n    Yes → (loop back to Decision)\n\n    No  → End // 所有元素已處理，返回 counts\n\nEnd // 程式結束\n\nBut need to maintain arrow structure: The arrow \"→\" before each step. For Decision we use \"Decision:\" and then indent \"Yes →\", \"No →\". The lines inside decision have arrow.\n\nWe need to ensure each line is separate, with explanation after //.\n\nWe should keep the numbering consistent: \"Step 1:\", \"Step 2:\" etc. Use proper explanation.\n\nWe need to produce virtual code lines only, not actual code. Should use bullet arrow notation as in example.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立與 nums 長度相同的 counts 陣列，並初始化為 0 // 用於儲存每個位置右側更小元素的個數  \n→ Step 2: 從 nums 取得所有唯一值並按升序排序 // 為了進行座標壓縮  \n→ Step 3: 建立 value → rank（1 為最小） 的映射表 // 方便在 BIT 中做索引  \n→ Step 4: 初始化一個大小為唯一值數量的 Binary Indexed Tree (Fenwick) // 以支援快速查詢和更新  \n→ Step 5: 設定 i = nums.length - 1 // 從右向左遍歷數組  \n→ Decision: i >= 0? // 是否還有未處理的元素  \n  Yes → Step 5.1: rank = mapping[nums[i]] // 取得當前元素的壓縮排名  \n  Yes → Step 5.2: query = BIT.query(rank - 1) // 取得已處理元素中比 nums[i] 小的個數  \n  Yes → Step 5.3: counts[i] = query // 將結果存回 counts  \n  Yes → Step 5.4: BIT.update(rank, 1) // 將當前元素加入 BIT，以供後續查詢使用  \n  Yes → Step 5.5: i = i - 1 // 前往下一個元素  \n  Yes → (回到 Decision)  \n  No → End // 所有元素已處理，結束循環  \nEnd // 程式執行結束，返回 counts 數組",
      "generated_code": "import sys\nimport re\n\nclass BIT:\n    def __init__(self, size):\n        self.tree = [0] * (size + 1)\n        self.size = size\n\n    def update(self, index, delta):\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index):\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\nclass Solution:\n    def countSmaller(self, nums):\n        # 壓縮座標：將不同的數值映射到 1~k 的索引\n        sorted_unique = sorted(set(nums))\n        ranks = {num: i + 1 for i, num in enumerate(sorted_unique)}\n\n        bit = BIT(len(ranks))\n        res = []\n\n        # 從右往左遍歷，計算右側更小元素的個數\n        for num in reversed(nums):\n            rank = ranks[num]\n            res.append(bit.query(rank - 1))\n            bit.update(rank, 1)\n\n        return res[::-1]  # 反轉回原順序\n\ndef main():\n    data = sys.stdin.read()\n    # 取得所有整數，無論前後有何文字\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    result = sol.countSmaller(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,2,6,1]",
          "expected_output": "[2,1,1,0]",
          "success": true,
          "output": "[2, 1, 1, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-1]",
          "expected_output": "[0,0]",
          "success": true,
          "output": "[0, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode537.json",
    "problem_index_in_file": 0,
    "title": "Complex Number Multiplication",
    "description_snippet": "A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\nreal is the re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for multiplying two complex numbers given as strings like \"a+bi\". Steps: parse numbers, multiply: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Output as string \"real+imaginaryi\". Handle signs? Input format always \"real+imaginaryi\" maybe with negative? It says real and imaginary integer ranges -100 to 100. Likely format always includes '+' between real and imaginary part, e.g., \"1+1i\". Negative imaginary part would be \"1-1i\"? but they say \"real+imaginaryi\" where imaginary is integer, could be negative so string would be \"1-1i\". So parsing should detect sign before imaginary. Steps: parse real part: from start until '+' or '-' that is part of imaginary. Easiest: split by 'i' then split left part by last '+' or '-'. We'll produce pseudocode with decisions.\n\nWe need to output lines with virtual code + explanation.\n\nLet's structure: Start, parse num1, parse num2, compute real, imag, format output, End.\n\nUse Decision: For parsing, identify sign of imaginary.\n\nLet's write step by step.\n\nAlso ensure arrow representation.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 num1, num2 // 取得兩個複數字串  \n→ Step 2: 解析 num1 為 (a, b)  \n    → Decision: num1 是否包含 '-' 作為 imaginary 的符號？  \n        Yes → Step 3a: 找到最後一個 '+' 或 '-' 並分割為 realPart, imagPart（去掉 trailing 'i'）  \n            → Step 4a: a ← 整數化 realPart  \n            → Step 5a: b ← 整數化 imagPart  \n        No  → Step 3b: 分割方式同上（即使符號為 '+'）  \n            → Step 4b: a ← 整數化 realPart  \n            → Step 5b: b ← 整數化 imagPart  \n→ Step 6: 解析 num2 為 (c, d)  // 同上步驟  \n    → Decision: num2 是否包含 '-' 作為 imaginary 的符號？  \n        Yes → Step 7a: 分割為 realPart2, imagPart2  \n            → Step 8a: c ← 整數化 realPart2  \n            → Step 9a: d ← 整數化 imagPart2  \n        No  → Step 7b: 分割為 realPart2, imagPart2  \n            → Step 8b: c ← 整數化 realPart2  \n            → Step 9b: d ← 整數化 imagPart2  \n→ Step 10: 計算實部 realResult ← a * c - b * d // (ac - bd)  \n→ Step 11: 計算虛部 imagResult ← a * d + b * c // (ad + bc)  \n→ Step 12: 產生輸出字串 output  \n    → Decision: imagResult 是否為負？  \n        Yes → Step 13a: output ← concatenate realResult, imagResult, 'i'（負號已包含於 imagResult）  \n        No  → Step 13b: output ← concatenate realResult, '+', imagResult, 'i'  \n→ Step 14: 輸出 output // 回傳乘法結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"\n        將兩個複數字串相乘，輸出格式仍為 'real+imaginaryi'。\n        \"\"\"\n        def parse(s: str):\n            \"\"\"\n            解析形如 'real+imaginaryi' 或 'real-imaginaryi'（也可能是\n            'real+-imaginaryi' 之類的）字串，回傳 (real, imag) 整數。\n            \"\"\"\n            s = s.strip()\n            # 正則表達式分離實部與虛部\n            pattern = re.compile(r'^([+-]?\\d+)([+-]\\d+)i$')\n            m = pattern.match(s)\n            if not m:\n                raise ValueError(f\"無法解析複數字串: {s}\")\n            real = int(m.group(1))\n            imag_str = m.group(2)\n            # 若虛部前帶 + 號，去除後面可能的 - 號\n            if imag_str[0] == '+':\n                imag_str = imag_str[1:]\n            imag = int(imag_str)\n            return real, imag\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        # (a+bi)(c+di) = (ac - bd) + (ad + bc)i\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 期望輸入格式如： \"1+1i\", \"1+1i\"\n    # 先去除雙引號，再以逗號分隔\n    parts = [p.strip() for p in data.replace('\"', '').split(',')]\n    if len(parts) != 2:\n        raise ValueError(\"輸入格式錯誤，應為兩個複數字串\")\n    num1, num2 = parts[0], parts[1]\n\n    solver = Solution()\n    result = solver.complexNumberMultiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"1+1i\", \"1+1i\"",
          "expected_output": "\"0+2i\"",
          "success": true,
          "output": "0+2i"
        },
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpzav1vf1n.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpzav1vf1n.py\", line 49, in main\n    result = solver.complexNumberMultiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzav1vf1n.py\", line 28, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmpzav1vf1n.py\", line 19, in parse\n    raise ValueError(f\"無法解析複數字串: {s}\")\nValueError: 無法解析複數字串: 1+-1i"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode609.json",
    "problem_index_in_file": 0,
    "title": "Find Duplicate File in System",
    "description_snippet": "Given a list paths of directory info, including the directory path, and all the files with contents ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc. We need to describe algorithm: parse input list, for each directory info string, split by space: first part path, rest files. For each file: extract name and content inside parentheses. Build mapping content->list of paths. Finally iterate mapping and collect lists with len>=2. Output list.\n\nWe need to write step-by-step in pseudocode with arrows. We'll produce steps. Use \"Start\" then \"→\" lines. For decisions, use Decision:.\n\nWe should be concise. Use \"Step\" labels.\n\nLet's produce virtual code.\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\".\n\nWe can use arrow \"→\" to indicate steps, \"Decision:\" for branching.\n\nWe should maybe include \"Initialize\" etc.\n\nOk produce.\n\nWe'll include:\n\nStart\n\n→ Step 1: Initialize map contentToPaths = {} // map content string to list of file paths\n\n→ Step 2: For each dirInfo in paths // iterate input list\n\n→ Step 3: Split dirInfo by space into parts // separate directory path and file entries\n\n→ Decision: parts length > 0? // ensure valid\n\nYes → Step 4: dirPath = parts[0] // directory path\n\n→ Step 5: For each fileEntry in parts[1..] // iterate files\n\n→ Step 6: Parse fileEntry to get fileName and content // split at '(' and ')'\n\n→ Step 7: filePath = dirPath + '/' + fileName // construct full path\n\n→ Step 8: If content not in contentToPaths: create empty list\n\n→ Step 9: Append filePath to contentToPaths[content] // add path\n\nAfter loops\n\n→ Step 10: Initialize result = []\n\n→ Step 11: For each entry in contentToPaths\n\n→ Decision: entry.value.size >= 2? // duplicate group\n\nYes → Step 12: Append entry.value to result // add group to result\n\nEnd\n\nAdd comments each line.\n\nMake sure each line contains space between code and // explanation. Provide arrows. Let's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 map contentToPaths = {} // 建立內容到檔案路徑的對應表  \n→ Step 2: 對於每個 dirInfo 在 paths 之中 // 遍歷所有目錄資訊字串  \n→ Step 3: 將 dirInfo 以空格拆分為 parts // 第一項為目錄路徑，其餘為檔案資訊  \n→ Decision: parts 內是否至少有 1 個元素? // 檢查拆分結果有效  \n Yes → Step 4: dirPath = parts[0] // 取得目錄路徑  \n Yes → Step 5: 對於每個 fileEntry 在 parts[1..] 之中 // 遍歷該目錄下的所有檔案  \n  → Step 6: 解析 fileEntry 取得 fileName 與 content // 以 '(' 與 ')' 分割得到檔名與內容  \n  → Step 7: filePath = dirPath + '/' + fileName // 組成完整檔案路徑  \n  → Decision: content 是否已存在於 contentToPaths? // 判斷該內容是否已被記錄  \n   Yes → Step 8: contentToPaths[content].append(filePath) // 若存在，加入此路徑  \n   No  → Step 9: contentToPaths[content] = [filePath] // 若不存在，建立新列表並加入路徑  \n→ Step 10: 初始化 result = [] // 用於存放重複檔案的分組  \n→ Step 11: 對於每個 entry 在 contentToPaths 之中 // 遍歷內容到路徑的對應表  \n→ Decision: entry.value.size >= 2? // 判斷是否為重複檔案組  \n Yes → Step 12: result.append(entry.value) // 若至少兩個路徑，加入結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"Return groups of duplicate file paths based on file content.\"\"\"\n        content_map = defaultdict(list)\n        for entry in paths:\n            parts = entry.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content.rstrip(')')  # remove trailing ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n        # Filter only groups that have more than one file\n        return [paths for paths in content_map.values() if len(paths) > 1]\n\ndef main():\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # Extract the list expression after '=' if present\n    if '=' in raw_input:\n        raw_input = raw_input.split('=', 1)[1].strip()\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception as e:\n        # If parsing fails, print empty list\n        print(\"[]\")\n        return\n    sol = Solution()\n    result = sol.findDuplicate(paths)\n    # Output as JSON string to match expected double-quoted format\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\", \"root/4.txt\"]]'"
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\"]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode208.json",
    "problem_index_in_file": 0,
    "title": "Implement Trie (Prefix Tree)",
    "description_snippet": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and r...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with comments. No real code. Need structure: Start, Steps, Decision, End. Represent Trie class operations: constructor, insert, search, startsWith. We'll use pseudo-steps: Node structure, root, insert loop, search loop, etc.\n\nWe should not output actual code. Each line: virtual step + // explanation.\n\nLet's craft.\n\nStart // Program start\n→ Step 1: 定義 Node 物件 // 建立 Trie 節點類別\n    → SubStep: 儲存子節點映射 // key: 字符, value: 子節點\n    → SubStep: isEndFlag // 標記單詞結束\n→ Step 2: 定義 Trie 類別 // 包含根節點\n    → SubStep: root ← New Node // 初始空節點\n→ Step 3: Trie() // 建構子\n    → Action: 初始化 root 為新 Node // 設置根\n→ Step 4: insert(word) // 插入單詞\n    → Variable: node ← root // 以根節點開始\n    → Loop: for each char c in word\n        → Decision: 若 node 子節點中無 c\n            Yes → 新增子節點 Node 並指向 node.child[c]\n            No  → 直接取得子節點\n        → node ← node.child[c] // 移動至子節點\n    → After loop: node.isEndFlag ← true // 標記單詞結束\n→ Step 5: search(word) // 搜尋完整單詞\n    → Variable: node ← root\n    → Loop: for each char c in word\n        → Decision: 若 node 子節點中無 c\n            Yes → Return false // 字串不在 Trie\n            No  → node ← node.child[c]\n    → After loop: Return node.isEndFlag // 若為終點則存在\n→ Step 6: startsWith(prefix) // 前綴搜尋\n    → Variable: node ← root\n    → Loop: for each char c in prefix\n        → Decision: 若 node 子節點中無 c\n            Yes → Return false // 前綴不存在\n            No  → node ← node.child[c]\n    → After loop: Return true // 至少一個單詞具有此前綴\nEnd // 程式結束\n\nBut must follow the exact format: each line like \"Start //\". Use arrow '→'. Need each line with explanation. Sub-steps can be indented? Might not be necessary. Let's produce each line separately. Use indentation maybe with spaces but still separate lines.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: 定義 Node 類別 // 建立 Trie 節點資料結構\n→ SubStep: 儲存子節點映射 // Map<字符, Node>\n→ SubStep: isEndFlag // 標記該節點是否為單詞結束\n→ Step 2: 定義 Trie 類別 // 包含根節點與操作方法\n→ SubStep: root ← New Node // 初始化根節點\n→ Step 3: Trie() // 建構子\n→ SubStep: root ← New Node // 設置根節點\n→ Step 4: insert(word) // 將單詞插入 Trie\n→ SubStep: node ← root // 從根節點開始\n→ SubStep: for each 字符 c in word\n→ SubStep:   Decision: 若 node 子節點不包含 c\n→ SubStep:       Yes → node.child[c] ← New Node // 新增子節點\n→ SubStep:       No  → // 已存在，直接使用\n→ SubStep:   node ← node.child[c] // 移動到子節點\n→ SubStep: node.isEndFlag ← true // 標記單詞結束\n→ Step 5: search(word) // 判斷單詞是否已插入\n→ SubStep: node ← root // 從根節點開始\n→ SubStep: for each 字符 c in word\n→ SubStep:   Decision: 若 node 子節點不包含 c\n→ SubStep:       Yes → Return false // 單詞不存在\n→ SubStep:       No  → node ← node.child[c]\n→ SubStep: Return node.isEndFlag // 若為終點則存在\n→ Step 6: startsWith(prefix) // 判斷是否存在以 prefix 開頭的單詞\n→ SubStep: node ← root // 從根節點開始\n→ SubStep: for each 字符 c in prefix\n→ SubStep:   Decision: 若 node 子節點不包含 c\n→ SubStep:       Yes → Return false // 前綴不存在\n→ SubStep:       No  → node ← node.child[c]\n→ SubStep: Return true // 至少一個單詞具有此前綴\nEnd // 程式執行結束\n\nBut ensure each line has arrow '→' at start. For substeps maybe still '→'? The example uses indented with spaces but still '→'. We'll follow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類別 // 建立 Trie 節點資料結構  \n→ SubStep: 儲存子節點映射 // Map<字符, Node>  \n→ SubStep: isEndFlag // 標記此節點是否為單詞結束  \n→ Step 2: 定義 Trie 類別 // 包含根節點與各操作方法  \n→ SubStep: root ← New Node // 初始化根節點  \n→ Step 3: Trie() // 建構子  \n→ SubStep: root ← New Node // 設置根節點  \n→ Step 4: insert(word) // 將單詞插入 Trie  \n→ SubStep: node ← root // 從根節點開始  \n→ SubStep: for each 字符 c in word  \n→ SubStep:   Decision: 若 node 子節點不包含 c  \n→ SubStep:       Yes → node.child[c] ← New Node // 新增子節點  \n→ SubStep:       No  → // 已存在，直接使用  \n→ SubStep:   node ← node.child[c] // 移動到子節點  \n→ SubStep: node.isEndFlag ← true // 標記單詞結束  \n→ Step 5: search(word) // 判斷單詞是否已插入  \n→ SubStep: node ← root // 從根節點開始  \n→ SubStep: for each 字符 c in word  \n→ SubStep:   Decision: 若 node 子節點不包含 c  \n→ SubStep:       Yes → Return false // 單詞不存在  \n→ SubStep:       No  → node ← node.child[c]  \n→ SubStep: Return node.isEndFlag // 若為終點則存在  \n→ Step 6: startsWith(prefix) // 判斷是否存在以 prefix 開頭的單詞  \n→ SubStep: node ← root // 從根節點開始  \n→ SubStep: for each 字符 c in prefix  \n→ SubStep:   Decision: 若 node 子節點不包含 c  \n→ SubStep:       Yes → Return false // 前綴不存在  \n→ SubStep:       No  → node ← node.child[c]  \n→ SubStep: Return true // 至少一個單詞具有此前綴  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析為兩個列表的元組\n    commands, args_list = ast.literal_eval(data)\n\n    trie = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == 'Trie':\n            trie = Trie()\n            results.append(None)\n        elif cmd == 'insert':\n            trie.insert(*args)\n            results.append(None)\n        elif cmd == 'search':\n            results.append(trie.search(*args))\n        elif cmd == 'startsWith':\n            results.append(trie.startsWith(*args))\n        else:\n            # 若有其他指令，直接忽略\n            results.append(None)\n\n    # 輸出結果，使用 json 以獲得 null、true、false 的字串表示\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "success": true,
          "output": "[null, null, true, false, true, null, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode268.json",
    "problem_index_in_file": 0,
    "title": "Missing Number",
    "description_snippet": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm to find missing number in array 0..n inclusive with n elements. Usually compute sum 0..n minus sum(nums). We'll produce virtual code with steps.\n\nWe must follow format: Each line: \"虛擬碼步驟 // 解釋\". Use arrows. We'll structure:\n\nStart\n→ Step 1: 取得 n ← length(nums) // array length\n→ Step 2: 計算 totalSum ← n * (n + 1) / 2 // sum 0..n\n→ Step 3: 計算 arraySum ← sum(nums) // sum of array\n→ Decision: if totalSum > arraySum? // missing number >? Actually missing is totalSum - arraySum\n    Yes → Step 4: missing ← totalSum - arraySum // compute missing\n    No → Step 4: missing ← arraySum - totalSum? Wait scenario cannot be negative? But we can just compute missing directly.\nBut simpler: Step 4: missing ← totalSum - arraySum\n→ Step 5: return missing\nEnd\n\nBut need to follow format. Use arrows and decisions? They said use arrows and decision. But we don't need decision; we can just compute. But we might show a decision: if totalSum > arraySum? But difference is positive anyway. We can just compute difference. Let's still include decision for clarity.\n\nWe produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: totalSum ← n * (n + 1) / 2 // 計算 0 至 n 的總和\n→ Step 3: arraySum ← 0 // 初始化陣列元素總和\n→ Step 4: for each num in nums: arraySum ← arraySum + num // 累加陣列元素\n→ Decision: 如果 totalSum > arraySum? // 檢查差值是否為正\n    Yes → Step 5: missing ← totalSum - arraySum // 計算缺失數字\n    No  → Step 5: missing ← arraySum - totalSum // 反向計算（不會發生）\n→ Step 6: return missing // 返回缺失的數字\nEnd // 程式執行結束\n\nMake sure each line has format \"虛擬碼步驟 // 解釋\". Also use arrows. Use \"→\" for flow. Use \"Decision:\" with Yes→ and No→ lines.\n\nWe should ensure that each line begins with \"Start\" or \"→ ...\". For decision, we need to indent? The example shows indentation. But they didn't specify indentation but they used indentation for nested. We can follow same style.\n\nMake sure we don't produce actual code. So we use simple pseudo names.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: totalSum ← n * (n + 1) / 2 // 計算 0 到 n 的理論總和  \n→ Step 3: arraySum ← 0 // 初始化陣列元素總和  \n→ Step 4: for each num in nums: arraySum ← arraySum + num // 累加陣列所有元素  \n→ Decision: 如果 totalSum > arraySum? // 檢查差值是否為正  \n  Yes → Step 5: missing ← totalSum - arraySum // 計算缺失數字  \n  No  → Step 5: missing ← arraySum - totalSum // 反向計算（此情況不會發生）  \n→ Step 6: return missing // 返回缺失的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef missing_number(nums):\n    n = len(nums)\n    total = n * (n + 1) // 2\n    return total - sum(nums)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        _, nums_str = data.split('=', 1)\n    else:\n        nums_str = data\n    nums_str = nums_str.strip()\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        nums = [int(x) for x in nums_str.strip('[]').split(',') if x]\n    result = missing_number(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [9,6,4,2,3,5,7,0,1]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode470.json",
    "problem_index_in_file": 0,
    "title": "Implement Rand10() Using Rand7()",
    "description_snippet": "Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating rand10() using rand7(). Classic solution: use two rand7 calls to generate 49 outcomes, reject >40, map 1-40 to 1-10.\n\nWe need to produce step-by-step pseudo-code with arrow notation. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc. Use arrows: →. Provide explanation per line.\n\nWe need to ensure it's clear. Let's design:\n\nStart\n→ Generate r1 = rand7() // first random\n→ Generate r2 = rand7() // second random\n→ Combine to produce value: val = (r1-1)*7 + r2 // yields 1-49\n→ Decision: if val <= 40? // only accept first 40\n    Yes → Step: result = (val-1)%10 +1 // map to 1-10\n    No  → Go back to start // reject and retry\n→ Return result\nEnd\n\nBut need to maintain the loop structure: perhaps use a while loop. But we must use virtual code lines.\n\nCould also express with a loop:\n\nStart\n→ Decision: loop?\nBut better to show:\n\nStart\n→ Step 1: r1 = rand7()\n→ Step 2: r2 = rand7()\n→ Step 3: val = (r1-1)*7 + r2\n→ Decision: val <= 40?\n    Yes → result = (val-1)%10 +1\n    No  → Go to Step 1 // repeat\n→ Return result\nEnd\n\nBut need arrow to show flow. Use \"→\" for next step, indent inside decision. Provide explanation per line.\n\nAlso we may need to show the retry mechanism. For clarity, we might include \"Repeat\" label.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: r1 ← rand7() // 產生 1~7 的隨機數\n→ Step 2: r2 ← rand7() // 產生第二個 1~7 的隨機數\n→ Step 3: val ← (r1-1)*7 + r2 // 組合得到 1~49 的值\n→ Decision: val ≤ 40? // 只接受前 40 個結果\n    Yes → Step 4: result ← (val-1) mod 10 + 1 // 映射到 1~10\n    No  → Step 1 // 超過 40 時重新開始\n→ Return result // 回傳 1~10 的隨機數\nEnd // 程式結束\n\nBut we should maintain proper arrow format: \"→\" before each step. For decision, we need indent: \"Decision:\" then Yes → etc.\n\nAlso we might need to indicate \"→\" to the next step or branch. Let's write:\n\nStart // 程式開始執行\n→ Step 1: r1 ← rand7() // 產生 1~7 的隨機數\n→ Step 2: r2 ← rand7() // 再次產生 1~7 的隨機數\n→ Step 3: val ← (r1-1)*7 + r2 // 轉換成 1~49 的值\n→ Decision: val ≤ 40? // 只接受前 40 個數字\n    Yes → Step 4: result ← (val-1) mod 10 + 1 // 映射到 1~10\n    No  → Step 1 // 若 >40，重新產生\n→ Return result // 回傳隨機數 1~10\nEnd // 程式結束\n\nBut we need to maintain arrow between steps. Each line includes arrow. The \"Yes →\" and \"No →\" lines include arrow.\n\nLet's produce final answer accordingly.\n\nAlso the request says \"Please do not use a language's built-in random API.\" It's covered.\n\nNow produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: r1 ← rand7() // 產生 1~7 的隨機數\n→ Step 2: r2 ← rand7() // 再次產生 1~7 的隨機數\n→ Step 3: val ← (r1-1)*7 + r2 // 將兩個隨機數合併成 1~49 的值\n→ Decision: val ≤ 40? // 只接受前 40 個結果，以確保均勻分佈\n    Yes → Step 4: result ← (val-1) mod 10 + 1 // 將 1~40 映射到 1~10\n    No  → Step 1 // 超過 40 時丟棄並重新開始\n→ Return result // 回傳 1~10 的隨機數\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def rand10(self):\n        while True:\n            r1 = rand7()\n            r2 = rand7()\n            val = (r1 - 1) * 7 + r2  # 1-49\n            if val <= 40:\n                return 1 + (val - 1) % 10\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    sol = Solution()\n    result = [sol.rand10() for _ in range(n)]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpz6g_5xdr.py\", line 24, in <module>\n    main()\n  File \"/tmp/tmpz6g_5xdr.py\", line 20, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmpz6g_5xdr.py\", line 7, in rand10\n    r1 = rand7()\n         ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpntepi6ut.py\", line 24, in <module>\n    main()\n  File \"/tmp/tmpntepi6ut.py\", line 20, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmpntepi6ut.py\", line 7, in rand10\n    r1 = rand7()\n         ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmppcgs6et9.py\", line 24, in <module>\n    main()\n  File \"/tmp/tmppcgs6et9.py\", line 20, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmppcgs6et9.py\", line 7, in rand10\n    r1 = rand7()\n         ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode7.json",
    "problem_index_in_file": 0,
    "title": "Reverse Integer",
    "description_snippet": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for reversing 32-bit integer with overflow check, no 64-bit integers allowed. Should detect overflow by checking before pushing digit. Use loop to pop digits, build result. Need to handle negative sign. Steps: initialize sign, convert to positive using abs? but cannot use abs beyond 32-bit? We can handle sign separately. Use x as signed int. Use variable rev = 0. While x != 0: pop = x % 10; x = x / 10. Check overflow: if rev > INT_MAX/10 or (rev == INT_MAX/10 && pop > 7) for positive. For negative: rev < INT_MIN/10 or (rev == INT_MIN/10 && pop < -8). But rev is positive? We'll handle rev as signed int too. Use rev as signed int. For negative x, pop will be negative? In many languages, % with negative gives negative remainder. But we can handle using abs and sign. Better: Work with unsigned? But no 64-bit. Let's do: sign = 1; if x < 0 then sign = -1; x = -x; // careful overflow at INT_MIN can't negate. Instead treat digits: use original x, pop = x % 10; x = x / 10. In languages like C/C++ negative division truncates toward zero, remainder same sign as dividend. Example: -123 % 10 = -3? Actually in C++: -123 / 10 = -12, -123 % 10 = -3. That's fine. rev built as signed. Need overflow checks accordingly. We'll implement: if rev > INT_MAX/10 or (rev == INT_MAX/10 && pop > 7) then overflow. If rev < INT_MIN/10 or (rev == INT_MIN/10 && pop < -8) then overflow. Append rev = rev * 10 + pop.\n\nThis fits 32-bit.\n\nNow produce virtual code line by line with explanation.\n\nLet's produce structure:\n\nStart\n→ Step 1: 定義 INT_MAX = 2147483647, INT_MIN = -2147483648 // 32位整數範圍\n→ Step 2: 初始化 rev = 0 // 儲存反轉後的數\n→ Decision: x 為 0? // 若輸入為 0 直接返回 0\n    Yes → Step 3: 返回 0 // 結束\n    No  → Loop: while x ≠ 0 // 逐位取出 x 的最後一位\n        → Step 4: pop = x % 10 // 取出最後一位\n        → Step 5: x = x / 10 // 去掉最後一位\n        → Decision: 是否會導致溢出? // 檢查加入 pop 後是否超出 32 位範圍\n            Yes → Step 6: 返回 0 // 溢出時返回 0\n            No  → Step 7: rev = rev * 10 + pop // 將 pop 加入 rev\n    → End Loop\n→ Step 8: 返回 rev // 完成反轉\nEnd\n\nBut need arrow structure: Use arrow \"→\" at each step. Use \"Decision:\" lines with Yes →, No → inside.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 INT_MAX = 2147483647, INT_MIN = -2147483648 // 32 位整數最大、最小值  \n→ Step 2: 初始化 rev = 0 // 用於累積反轉後的數值  \n→ Decision: 如果 x 等於 0? // 直接返回 0  \n  Yes → Step 3: 返回 0 // 結束程式  \n  No  → Loop: while x ≠ 0 // 逐位處理 x  \n    → Step 4: pop = x % 10 // 取得 x 的最後一位（負數亦可）  \n    → Step 5: x = x / 10 // 去掉最後一位  \n    → Decision: rev 乘 10 加 pop 後會否溢出?  \n     Yes → Step 6: 返回 0 // 溢出時直接返回 0  \n     No  → Step 7: rev = rev * 10 + pop // 安全累積  \n    → End Loop  \n→ Step 8: 返回 rev // 完成反轉後的數值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2**31 - 1\nINT_MIN = -2**31\n\ndef reverse_int(x: int) -> int:\n    rev = 0\n    while x != 0:\n        pop = x % 10          # 取最後一位（負數也會是負）\n        x //= 10              # 去掉最後一位\n        # 檢查乘 10 再加 pop 是否會造成溢出\n        if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and pop > 7):\n            return 0\n        if rev < INT_MIN // 10 or (rev == INT_MIN // 10 and pop < -8):\n            return 0\n        rev = rev * 10 + pop\n    return rev\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if match:\n        x_val = int(match.group())\n    else:\n        x_val = 0\n    result = reverse_int(x_val)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 123",
          "expected_output": "321",
          "success": true,
          "output": "321"
        },
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        },
        {
          "example_index": 2,
          "input": "x = 120",
          "expected_output": "21",
          "success": true,
          "output": "21"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode67.json",
    "problem_index_in_file": 0,
    "title": "Add Binary",
    "description_snippet": "Given two binary strings a and b, return their sum as a binary string....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for adding two binary strings, step by step with explanations. Must use Start, End, Decision, etc. Must output line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrow and structure.\n\nWe need to produce algorithm: iterate from end to start, adding bits, carry, etc. Steps: set pointers i, j; carry=0; result list; while i>=0 or j>=0 or carry: bitA= int(a[i]) if i>=0 else 0; bitB= int(b[j]) if j>=0 else 0; sum=bitA+bitB+carry; result.append(str(sum%2)); carry=sum//2; i--, j--; after loop, reverse result, join.\n\nWe need to produce virtual code lines.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: i ← length(a) - 1 // i 指向 a 最後一位\n→ Step 2: j ← length(b) - 1 // j 指向 b 最後一位\n→ Step 3: carry ← 0 // 初始化進位\n→ Step 4: result ← empty list // 用於儲存逆序結果\n→ Decision: i ≥ 0 或 j ≥ 0 或 carry ≠ 0? // 判斷是否還有位數或進位\n    Yes → Step 5: bitA ← if i ≥ 0 then int(a[i]) else 0 // 取得 a 的位元\n    Yes → Step 6: bitB ← if j ≥ 0 then int(b[j]) else 0 // 取得 b 的位元\n    Yes → Step 7: sum ← bitA + bitB + carry // 位元相加\n    Yes → Step 8: result.append(str(sum mod 2)) // 取得此位結果\n    Yes → Step 9: carry ← sum div 2 // 更新進位\n    Yes → Step 10: i ← i - 1 // 移動到前一位\n    Yes → Step 11: j ← j - 1 // 移動到前一位\n    Yes → Decision: (repeat loop) // 迴圈結束於 Decision\n    No  → Step 12: reversedResult ← reverse(result) // 逆轉結果\n    No  → Step 13: answer ← join(reversedResult) // 轉為字串\nEnd // 結束\n\nBut must reflect structure: Decision should be nested. Use proper indentation.\n\nWe need to use \"Decision:\" then indent Yes → etc. Provide lines accordingly. Ensure each line is a separate statement.\n\nLet's format accordingly.\n\nUse arrows.\n\nWe might need a 'Loop' structure? Use Decision and Yes branch.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← length(a) - 1 // i 指向字串 a 的最後一位  \n→ Step 2: j ← length(b) - 1 // j 指向字串 b 的最後一位  \n→ Step 3: carry ← 0 // 初始化進位為 0  \n→ Step 4: result ← empty list // 用於儲存逆序計算結果  \n\n→ Decision: i ≥ 0 或 j ≥ 0 或 carry ≠ 0? // 判斷是否還有位數或進位  \n    Yes → Step 5: bitA ← if i ≥ 0 then int(a[i]) else 0 // 取得 a 的當前位元  \n    Yes → Step 6: bitB ← if j ≥ 0 then int(b[j]) else 0 // 取得 b 的當前位元  \n    Yes → Step 7: sum ← bitA + bitB + carry // 位元相加  \n    Yes → Step 8: result.append(str(sum mod 2)) // 將此位結果加入結果表  \n    Yes → Step 9: carry ← sum div 2 // 更新進位  \n    Yes → Step 10: i ← i - 1 // 移動到 a 的前一位  \n    Yes → Step 11: j ← j - 1 // 移動到 b 的前一位  \n    Yes → Decision: (loop back to 前一行) // 重新評估條件  \n    No  → Step 12: reversedResult ← reverse(result) // 逆轉結果以得到正序  \n    No  → Step 13: answer ← join(reversedResult) // 將列表轉成字串  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef add_binary(a: str, b: str) -> str:\n    \"\"\"返回兩個二進制字串相加後的結果，結果為二進制字串。\"\"\"\n    i, j = len(a) - 1, len(b) - 1\n    carry = 0\n    res = []\n\n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        res.append(str(total % 2))\n        carry = total // 2\n\n    return ''.join(reversed(res))\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從引號中提取兩個字串\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        a_str, b_str = parts[0], parts[1]\n    else:\n        # 若輸入格式不含引號，則嘗試直接分行或以空格分隔\n        tokens = data.strip().replace(',', ' ').split()\n        if len(tokens) >= 2:\n            a_str, b_str = tokens[0], tokens[1]\n        else:\n            raise ValueError(\"輸入格式錯誤，請提供兩個二進制字串。\")\n\n    result = add_binary(a_str, b_str)\n    # 按範例輸出加上雙引號\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"11\", b = \"1\"",
          "expected_output": "\"100\"",
          "success": true,
          "output": "\"100\""
        },
        {
          "example_index": 1,
          "input": "a = \"1010\", b = \"1011\"",
          "expected_output": "\"10101\"",
          "success": true,
          "output": "\"10101\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode371.json",
    "problem_index_in_file": 0,
    "title": "Sum of Two Integers",
    "description_snippet": "Given two integers a and b, return the sum of the two integers without using the operators + and -....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to compute sum of two integers without using + and -. This likely uses bitwise operations: addition via bitwise XOR and carry via AND shifted left. The algorithm: while (b != 0) { carry = a & b; a = a ^ b; b = carry << 1; } return a. Also handle sign maybe.\n\nWe need to output step by step, each line with \"虛擬碼步驟\" and comment. Use arrow '→'. Also include Start, End, Decision. Provide explanation. We need to output in Traditional Chinese.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: Initialize sum ← a, carry ← b // 設定 sum 為 a，carry 為 b\n→ Decision: 是否 carry 為 0? // 檢查是否已完成加法\n    No → Step 2: newCarry ← sum AND carry // 計算進位\n    → Step 3: sum ← sum XOR carry // 更新 sum 為不帶進位的相加\n    → Step 4: carry ← newCarry << 1 // 進位左移\n    → Jump back to Decision\n    Yes → Step 5: Return sum // 回傳最終結果\nEnd // 結束\n\nBut we must follow format: each line has \"虛擬碼步驟\" + space + comment. Use \"Start\" etc. Use arrows '→', decisions. Provide explanation.\n\nAlso include \"Start // 程式開始執行\" etc. Provide each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sum ← a, carry ← b // 將兩個數字分別存入 sum 與 carry  \n→ Decision: 是否 carry = 0? // 檢查是否已無進位  \n  Yes → Step 2: Return sum // 無進位，回傳累加結果  \n  No  → Step 3: newCarry ← sum AND carry // 計算進位位  \n  → Step 4: sum ← sum XOR carry // 用 XOR 進行不帶進位的相加  \n  → Step 5: carry ← newCarry << 1 // 進位左移一位以備下一輪  \n  → Jump back to Decision // 重複迴圈直到 carry 為 0  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef parse_input(text: str):\n    \"\"\"從輸入字串中抓取兩個整數。\"\"\"\n    # 先用正則表達式抓取所有整數（含負號）\n    nums = re.findall(r'-?\\d+', text)\n    if len(nums) >= 2:\n        return int(nums[0]), int(nums[1])\n    # 若正則找不到，則以逗號、空白或換行分割\n    parts = re.split(r'[, \\n]+', text.strip())\n    nums = [int(p) for p in parts if p]\n    return nums[0], nums[1]\n\nclass Solution:\n    def getSum(self, a: int, b: int) -> int:\n        \"\"\"不使用 + 或 -，利用位運算計算 a 與 b 的和。\"\"\"\n        MASK = 0xFFFFFFFF          # 32 位掩碼\n        MAX_INT = 0x7FFFFFFF       # 最高正整數（2^31 - 1）\n        while b != 0:\n            carry = (a & b) & MASK          # 進位\n            a = (a ^ b) & MASK              # 沒進位的相加\n            b = (carry << 1) & MASK         # 進位左移一位\n        # 若最終結果超過 32 位正整數，則為負數，轉換成負數表示\n        return a if a <= MAX_INT else ~(a ^ MASK)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    a, b = parse_input(data)\n    result = Solution().getSum(a, b)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 1, b = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode593.json",
    "problem_index_in_file": 0,
    "title": "Valid Square",
    "description_snippet": "Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for checking if four points form a square. Must be step-by-step virtual code. Include Start, End, Decision. Provide explanation after each line. Not actual code.\n\nWe must cover input: list of four points [x,y]. Approach: compute all 6 pairwise distances squared. In a square: we will have 4 equal smallest distances (sides), and 2 equal largest distances (diagonals), and diagonal = side * sqrt(2), so squared diagonal = 2 * side^2. So we can sort distances, check first 4 equal >0, last 2 equal, and last == 2*first. Or use counts of distances. Also ensure all distances > 0.\n\nWe also need to handle arbitrary order.\n\nVirtual code lines:\n\nStart // 程式開始執行\n→ Step 1: 建立空陣列 distList // 存放所有兩兩之間距離平方\n→ Step 2: 對於 i 從 0 到 3\n    → Step 2a: 對於 j 從 i+1 到 3\n        → Step 2b: 計算 dx = p[i].x - p[j].x, dy = p[i].y - p[j].y\n        → Step 2c: dist = dx*dx + dy*dy\n        → Step 2d: 加入 distList\n→ Step 3: 排序 distList // 由小到大\n→ Decision: 是否至少 6 個距離? // 理論上固定 6\n    Yes → Step 4: 取 side = distList[0], diag = distList[5]\n        → Decision: side > 0? // 確保邊長正\n            Yes → Step 5: Decision: distList[0]==distList[1]==distList[2]==distList[3]?\n                Yes → Step 6: Decision: distList[4]==distList[5]?\n                    Yes → Step 7: Decision: diag == 2*side?\n                        Yes → Step 8: 輸出 true // 是正方形\n                        No → Step 9: 輸出 false // 角度不對\n                    No → Step 10: 輸出 false // 對角相等檢查失敗\n                No → Step 11: 輸出 false // 四條邊不相等\n            No → Step 12: 輸出 false // 邊長為 0\n        No → Step 13: 輸出 false // 沒有 6 個距離\nEnd // 程式結束\n\nBut we need to be careful to handle decision tree properly. Could combine decisions: We can check if all 4 smallest equal and >0, then 2 largest equal, then diag == 2*side. If any fail -> false.\n\nAlso ensure there are 6 distances.\n\nLet's produce virtual code with indentation using arrows and decision.\n\nWe'll output each line with virtual code and comment.\n\nUse \"Start\", \"End\", \"Decision:\".\n\nAlso, the Step numbers optional, but fine.\n\nNeed to use Chinese explanations.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空陣列 distList // 用來存放所有兩兩點的距離平方  \n→ Step 2: 對 i 取 0 至 3  \n  → Step 2a: 對 j 取 i+1 至 3  \n    → Step 2b: 計算 dx = p[i].x - p[j].x, dy = p[i].y - p[j].y  \n    → Step 2c: 計算 dist = dx*dx + dy*dy // 距離平方，避免開根號  \n    → Step 2d: 把 dist 加入 distList  \n→ Step 3: 把 distList 由小到大排序 // 方便後續檢查  \n→ Decision: 是否為 6 個距離? // 正方形必須有 6 條兩兩距離  \n  Yes → Step 4: 取 side = distList[0], diag = distList[5] // 最小值為邊長，最大值為對角線  \n    → Decision: side > 0? // 邊長不能為 0  \n     Yes → Step 5: Decision: distList[0]==distList[1]==distList[2]==distList[3]? // 四條邊長相等  \n      Yes → Step 6: Decision: distList[4]==distList[5]? // 對角線相等  \n       Yes → Step 7: Decision: diag == 2*side? // 斜對角應為邊長的 √2 倍，平方後為 2 倍  \n        Yes → Step 8: 輸出 true // 四邊相等且角為 90°, 為正方形  \n        No → Step 9: 輸出 false // 對角長不符合正方形比例  \n      No → Step 10: 輸出 false // 對角長不相等  \n     No → Step 11: 輸出 false // 四邊長不相等  \n    No → Step 12: 輸出 false // 邊長為 0 或負  \n  No → Step 13: 輸出 false // 距離個數不足 6 個，資料不完整  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n        dists.sort()\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 找出所有形如 [x,y] 的座標\n    coords = re.findall(r'\\[(-?\\d+),\\s*(-?\\d+)\\]', data)\n    if len(coords) != 4:\n        # 如果格式不符，直接輸出 false\n        print(\"false\")\n        sys.exit(0)\n    points = [[int(x), int(y)] for x, y in coords]\n    sol = Solution()\n    is_square = sol.validSquare(*points)\n    print(\"true\" if is_square else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode35.json",
    "problem_index_in_file": 0,
    "title": "Search Insert Position",
    "description_snippet": "Given a sorted array of distinct integers and a target value, return the index if the target is foun...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with arrows etc, step by step, describing binary search. Each line: virtual code step plus explanation. No real code. So format: \"Start // ...\", \"→ Step 1: ...\" etc. Provide explanation in Chinese. We need to output step-by-step algorithm with decision, loops.\n\nWe need to implement binary search: low=0, high=len-1. While low <= high: mid=(low+high)//2; if arr[mid]==target return mid; elif arr[mid] < target low=mid+1 else high=mid-1. After loop return low.\n\nWe need to output line by line with arrows. We can use \"Step 1\" etc. Also need decision. Example.\n\nLet's structure:\n\nStart\n→ Step 1: 初始化 low = 0, high = len(arr) - 1 // 設定搜尋範圍\n→ Decision: low <= high? // 判斷是否還有元素可搜尋\n    Yes →\n        → Step 2: mid = (low + high) // 2 // 取中間索引\n        → Decision: arr[mid] == target? // 判斷中間值是否為目標\n            Yes → Step 3: 返回 mid // 找到目標，返回索引\n            No →\n                → Decision: arr[mid] < target? // 中間值小於目標\n                    Yes → Step 4: low = mid + 1 // 往右半邊搜尋\n                    No  → Step 5: high = mid - 1 // 往左半邊搜尋\n    No → Step 6: 返回 low // 搜尋完畢，返回插入位置\nEnd\n\nNeed to use \"→\" arrow, \"Decision:\" lines with Yes →, No →. We need each line includes explanation comment.\n\nAlso ensure no actual code but just pseudocode. We need to not output actual code but the virtual code lines. So we should not use code syntax like if/else; just words.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 low = 0, high = len(arr) - 1 // 設定搜尋範圍  \n→ Decision: low <= high? // 判斷是否仍有元素可搜尋  \n Yes →  \n  → Step 2: mid = (low + high) // 2 // 取中間索引  \n  → Decision: arr[mid] == target? // 判斷中間值是否為目標  \n   Yes → Step 3: 返回 mid // 找到目標，返回其索引  \n   No →  \n    → Decision: arr[mid] < target? // 中間值小於目標  \n     Yes → Step 4: low = mid + 1 // 往右半邊繼續搜尋  \n     No → Step 5: high = mid - 1 // 往左半邊繼續搜尋  \n No → Step 6: 返回 low // 搜尋結束，返回插入位置  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef search_insert(nums, target):\n    \"\"\"二分搜尋：在有序且不重複的列表中找到 target 的索引，\n    若不存在，回傳可以插入的位置索引。\"\"\"\n    left, right = 0, len(nums)\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef parse_input(text):\n    \"\"\"\n    解析輸入字串，支援兩種常見格式：\n    1. nums = [1,3,5,6], target = 5\n    2. nums = [1,3,5,6]\n       target = 5\n    \"\"\"\n    # 先嘗試一行式格式\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    m = re.search(pattern, text, re.S)\n    if m:\n        nums = ast.literal_eval(m.group(1))\n        target = int(m.group(2))\n        return nums, target\n\n    # 其次嘗試多行或逗號分隔\n    nums_str = None\n    target_str = None\n    parts = re.split(r',|\\n', text)\n    for part in parts:\n        part = part.strip()\n        if part.startswith('nums'):\n            nums_str = part.split('=', 1)[1].strip()\n        elif part.startswith('target'):\n            target_str = part.split('=', 1)[1].strip()\n\n    if nums_str is None or target_str is None:\n        # 最後嘗試直接 eval（不建議但能覆蓋不標準輸入）\n        try:\n            nums, target = eval(text)\n            return nums, target\n        except Exception:\n            raise ValueError(\"無法解析輸入\")\n\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    return nums, target\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums, target = parse_input(data)\n    result = search_insert(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode154.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array II",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find minimum in rotated sorted array with duplicates, minimize steps. Typical approach: binary search with duplicates. Outline:\n\nStart\nInitialize left=0, right=n-1\nWhile left < right:\n  mid = left + (right-left)/2\n  if nums[mid] > nums[right]: left = mid+1\n  else if nums[mid] < nums[right]: right = mid\n  else: right--   // when equal reduce right\nReturn nums[left]\n\nAlso handle n=0.\n\nNeed to produce each step with explanation. Use arrow formatting. Each line: \"虛擬碼步驟 // 解釋\". Use start/end/decision. We'll produce step lines as per example. We'll need to include Start, End.\n\nLet's produce:\n\nStart\nInitialize left = 0 // left index\nInitialize right = n - 1 // right index\nDecision: while left < right? // loop condition\n  Yes → Step: mid = left + (right - left) / 2 // compute mid\n  Decision: nums[mid] > nums[right]? // compare\n    Yes → Step: left = mid + 1 // discard left half\n    No → Decision: nums[mid] < nums[right]? // check\n      Yes → Step: right = mid // discard right half\n      No → Step: right = right - 1 // nums[mid]==nums[right], shrink right\nEnd of loop\nStep: return nums[left] // min element\n\nAlso handle empty array: Decision: n == 0? -> return null? but assume not.\n\nLet's format exactly as required. Use arrow \"→\" preceding each step. Each line with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ left = 0 // 設定左指標為陣列起始位置  \n→ right = n - 1 // 設定右指標為陣列結尾位置  \n\n→ Decision: 是否有更多可搜尋區段？ (left < right)  \n    Yes → mid = left + (right - left) / 2 // 計算中點  \n    Decision: nums[mid] > nums[right]?  \n        Yes → left = mid + 1 // 中點右側必不含最小值，縮小左半區  \n        No → Decision: nums[mid] < nums[right]?  \n            Yes → right = mid // 中點左側可能含最小值，縮小右半區  \n            No → right = right - 1 // nums[mid] == nums[right]，只能縮小右指標  \n    No → End of loop // left >= right，搜尋結束  \n\n→ Step: return nums[left] // left 所指向即為最小元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[left] if nums else None\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the list part from the input string, e.g. \"nums = [1,3,5]\"\n    match = re.search(r'\\[.*?\\]', data)\n    nums = ast.literal_eval(match.group()) if match else []\n    result = Solution().findMin(nums)\n    if result is not None:\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode638.json",
    "problem_index_in_file": 0,
    "title": "Shopping Offers",
    "description_snippet": "In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code solution for the problem. It's LeetCode 638 Shopping Offers. The goal: minimal price using recursion/backtracking with memoization (DFS + DP). Provide steps: start, input arrays, define function dfs(needs) returns min cost, if cached return, base cost sum(needs[i]*price[i]), then iterate special offers, check if applicable: for each offer, if offer[i]<=needs[i] for all i, then newNeeds=needs- offer counts, cost=offer price + dfs(newNeeds), min. Cache. Return min. Also main: call dfs(initialNeeds). End.\n\nWe need to output lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 dfs(needs) // 用於計算剩餘需求的最小價格\n\nWe need to follow virtual code syntax with arrows and decisions.\n\nWe need to not output actual code, just pseudocode steps with explanations.\n\nLet's produce thorough steps. We must use structure: Start, End, Decision.\n\nWe need to handle input arrays. Provide variable names: price, needs, special.\n\nWe need to mention memo dictionary.\n\nWe'll produce the lines:\n\nStart // 程式開始執行\n→ Step 1: 讀取 price, needs, special // 從輸入取得資料\n→ Step 2: 建立 memo 物件 // 用於快取已計算需求組合\n→ Step 3: 定義遞迴函式 dfs(currentNeeds) // 計算剩餘需求的最小價格\n→ Step 4: 在 dfs 中，若 currentNeeds 在 memo 中，回傳 memo[currentNeeds] // 快取檢查\n→ Step 5: 計算未使用優惠的成本 base = Σ currentNeeds[i] * price[i] // 基本價格\n→ Step 6: 將 minCost 設為 base // 初始化最小成本\n→ Step 7: Decision: 是否有特殊優惠可套用? // 檢查每個優惠是否適用\n    Yes → Step 8: 對於每個 offer 在 special\n        → Decision: 是否 offer[i] <= currentNeeds[i] for all i? // 檢查可否使用此優惠\n            Yes → Step 9: 計算 newNeeds = currentNeeds - offer[i] for all i // 減去優惠後需求\n            → Step 10: Recursively計算 offerCost = offer price + dfs(newNeeds) // 方案成本\n            → Step 11: 若 offerCost < minCost，更新 minCost // 取較低成本\n            No → Step 12: 跳過此 offer // 不適用\n    No → Step 13: // 直接使用 base 成本\n→ Step 14: 在 memo 中儲存 memo[currentNeeds] = minCost // 快取結果\n→ Step 15: 回傳 minCost // 回傳最小成本\n→ Step 16: 呼叫 dfs(needs) 並將結果存為 result // 開始遞迴\n→ Step 17: 輸出 result // 回傳答案\nEnd // 程式執行結束\n\nWe must ensure each line includes explanation after //. Use arrow '→' preceding lines. Use 'Decision:' for decision points. Use indentation maybe but still each line separate.\n\nLet's produce accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取 price, needs, special // 從輸入取得商品價格、需求數量及優惠方案\n→ Step 2: 建立 memo 物件 // 用於快取已計算需求組合的最小價格\n→ Step 3: 定義遞迴函式 dfs(currentNeeds) // 計算剩餘需求的最小價格\n    → Step 4: Decision: currentNeeds 已在 memo 中? // 檢查是否已計算過此需求組合\n        Yes → Step 5: 回傳 memo[currentNeeds] // 直接回傳快取結果\n        No  → // 進入計算流程\n    → Step 6: 計算 base = Σ currentNeeds[i] * price[i] // 未使用任何優惠時的價格\n    → Step 7: 設定 minCost = base // 初始化最小成本為基礎價格\n    → Step 8: Decision: 是否存在可套用的特殊優惠? // 檢查每個優惠是否符合需求\n        Yes → Step 9: 對於每個 offer 在 special\n            → Decision: 這個 offer 可否全部使用? // 檢查 offer[i] <= currentNeeds[i] for all i\n                Yes → Step 10: 計算 newNeeds = currentNeeds - offer[i] for all i // 減去優惠後的需求\n                → Step 11: 取得 offerPrice = offer[n] // 優惠價格\n                → Step 12: Recursively 計算 offerCost = offerPrice + dfs(newNeeds) // 方案成本\n                → Step 13: Decision: offerCost < minCost? // 檢查是否更便宜\n                    Yes → Step 14: minCost = offerCost // 更新最小成本\n                    No  → // 保留舊的 minCost\n                No  → // 這個 offer 無法使用，跳過\n        No → // 沒有可用優惠，保留 base 成本\n    → Step 15: 在 memo[currentNeeds] = minCost // 快取計算結果\n    → Step 16: 回傳 minCost // 回傳最小價格\n→ Step 17: result = dfs(needs) // 開始遞迴計算整體需求\n→ Step 18: 輸出 result // 回傳答案\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List, Dict, Tuple\n\nclass Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        memo: Dict[Tuple[int, ...], int] = {}\n\n        def dfs(curr_needs: List[int]) -> int:\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n\n            # Cost without any special offers\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n\n            # Try every special offer\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\n\ndef parse_input(data: str) -> Tuple[List[int], List[List[int]], List[int]]:\n    \"\"\"\n    Parse a string like:\n    'price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]'\n    \"\"\"\n    pattern = r'(\\w+)\\s*=\\s*(.+?)(?=,\\s*\\w+\\s*=|$)'\n    matches = re.findall(pattern, data, re.DOTALL)\n    parsed = {}\n    for key, val in matches:\n        parsed[key] = ast.literal_eval(val.strip())\n    return parsed['price'], parsed['special'], parsed['needs']\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    price, special, needs = parse_input(raw_input)\n    solution = Solution()\n    result = solution.shoppingOffers(price, special, needs)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "success": true,
          "output": "14"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode709.json",
    "problem_index_in_file": 0,
    "title": "To Lower Case",
    "description_snippet": "Given a string s, return the string after replacing every uppercase letter with the same lowercase l...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. For the given requirement: input string s, return string after replacing every uppercase letter with same lowercase. That is string transformation. Steps: Start, Step: input string s, Step: create result empty string, Step: iterate each character c in s, Decision: if c is uppercase? Yes -> Step: append lowercase(c) to result, No -> append c to result. End, return result.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Format example uses \"Start // 程式開始執行\" etc. We'll produce.\n\nWe should maintain indentation for decision branches: Use tabs or spaces? In example they used 4 spaces indent for decisions. We'll follow.\n\nEnsure each line includes \"虛擬碼步驟\" followed by space then comment. Provide the virtual code line then comment.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入字串 s // 取得待處理字串\n→ Step 2: 初始化空字串 result // 用於儲存轉換後的字串\n→ Step 3: 從頭到尾遍歷 s 的每個字元 c // 逐個檢查每個字元\n    → Decision: 是否為大寫字母? // 判斷字元是否為大寫\n        Yes → Step 4: result += toLowerCase(c) // 將對應小寫字元加入結果\n        No  → Step 5: result += c // 非大寫字元直接加入結果\n→ Step 6: 回傳 result // 將完整的轉換後字串回傳\nEnd // 程式執行結束\n\nWe must ensure each line ends with comment. For decision lines, we can include comment after arrow. They used \"Decision: 如果數字大於 0?\" etc. So use similar: \"Decision: 是否為大寫字母?\" with comment. But they also had comment for the decision? In example they had comment after decision arrow? Actually example shows:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n\nYes we need to put comment after decision line too. So for decision we produce: \"→ Decision: 是否為大寫字母? // 判斷字元是否為大寫\".\n\nThen indent Yes and No lines with 4 spaces before arrow. In example they had \"Yes → Step 2: ... // ...\". We'll replicate.\n\nAlso, for Step 6: 回傳 result. Provide comment.\n\nMake sure each line has \"虛擬碼步驟\" part and comment after space. We'll produce exactly as needed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 s // 取得待處理字串  \n→ Step 2: 初始化空字串 result // 用於儲存轉換後的字串  \n→ Step 3: 從頭到尾遍歷 s 的每個字元 c // 逐個檢查每個字元  \n    → Decision: 是否為大寫字母? // 判斷字元是否為大寫  \n        Yes → Step 4: result += toLowerCase(c) // 將對應小寫字元加入結果  \n        No  → Step 5: result += c // 非大寫字元直接加入結果  \n→ Step 6: 回傳 result // 將完整的轉換後字串回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def toLowerCase(self, s: str) -> str:\n        \"\"\"\n        將字串 s 中所有大寫字母轉成小寫。\n        \"\"\"\n        result = []\n        for c in s:\n            # 如果 c 是大寫字母，則轉成小寫；否則保持不變\n            if 'A' <= c <= 'Z':\n                result.append(chr(ord(c) + 32))\n            else:\n                result.append(c)\n        return ''.join(result)\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取格式為 's = \"文字\"' 的字串，\n    轉成小寫後，輸出為 '\"小寫文字\"'。\n    \"\"\"\n    # 讀取整個輸入，並移除前後空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 用正則表達式抓取雙引號內的內容\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', raw_input)\n    if match:\n        original = match.group(1)\n    else:\n        # 若沒有符合格式，直接把整個輸入作為字串處理\n        original = raw_input\n\n    # 轉成小寫\n    solution = Solution()\n    lowered = solution.toLowerCase(original)\n\n    # 輸出結果，包含雙引號\n    print(f'\"{lowered}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello\"",
          "expected_output": "\"hello\"",
          "success": true,
          "output": "\"hello\""
        },
        {
          "example_index": 1,
          "input": "s = \"here\"",
          "expected_output": "\"here\"",
          "success": true,
          "output": "\"here\""
        },
        {
          "example_index": 2,
          "input": "s = \"LOVELY\"",
          "expected_output": "\"lovely\"",
          "success": true,
          "output": "\"lovely\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode153.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations, for algorithm to find min in rotated sorted array using binary search O(log n). Use Start, End, Decision, steps. No actual code. Let's produce a clear pseudo-code.\n\nSteps: Initialize left=0 right=n-1. While left<right: mid=(left+right)//2. If nums[mid] > nums[right], left=mid+1 else right=mid. After loop, return nums[left].\n\nWe'll format each line: e.g., \"Start // 程式開始執行\". Then lines with arrows.\n\nWe should include comment after each line. Use arrow after each step.\n\nWe need to include decision lines with Yes→ and No→. Use proper formatting.\n\nLet's produce.\n\nAlso include step to handle case n=0? maybe not needed.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = nums.length - 1 // 初始化搜尋區間  \n→ Decision: 是否 left < right? // 判斷是否還有未檢查的區域  \n    Yes → Step 2: 計算 mid = (left + right) // 2 // 取中點索引  \n    → Decision: nums[mid] > nums[right]? // 比較中點與右端值  \n        Yes → Step 3: 設定 left = mid + 1 // 左側最大值，最小值在右側  \n        No  → Step 4: 設定 right = mid // 右側包含最小值  \n    No  → Step 5: 返回 nums[left] // left 位置即為最小值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_min(nums):\n    \"\"\"\n    找出已升序排序且旋轉過的陣列中的最小值。\n    使用二分搜尋，時間複雜度為 O(log n)。\n    \"\"\"\n    left, right = 0, len(nums) - 1\n\n    # 若陣列未被旋轉，直接回傳第一個元素\n    if nums[left] <= nums[right]:\n        return nums[left]\n\n    while left < right:\n        mid = (left + right) // 2\n        # 若中間元素大於右端，最小值必在右半部\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            # 否則最小值在左半部（包含 mid）\n            right = mid\n\n    return nums[left]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，可能包含多行\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 從字串中抽取陣列部分，例如 \"nums = [3,4,5,1,2]\"\n    start = raw_input.find('[')\n    end = raw_input.rfind(']')\n    if start == -1 or end == -1:\n        # 無法找到陣列，直接結束\n        sys.exit()\n\n    array_str = raw_input[start:end+1]\n    try:\n        nums = ast.literal_eval(array_str)\n    except Exception:\n        # 解析失敗時結束\n        sys.exit()\n\n    result = find_min(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,4,5,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [11,13,15,17]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode552.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record II",
    "description_snippet": "An attendance record for a student can be represented as a string where each character signifies whe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for counting number of strings of length n over {A, L, P} with at most one 'A' and no 3 consecutive 'L's. Classic problem \"Student Attendance Record II\" from Leetcode. Approach: DP with states: number of As used (0 or 1), consecutive L count (0,1,2). We iterate days. Use mod. Finally sum over states with any As count <=1 and any L count <=2. We'll produce virtual code lines.\n\nWe should produce steps line by line with comments. Use Start, End, Decision, Yes/No arrow. Include loops, conditions, variable updates.\n\nLet's write:\n\nStart\n→ Initialize mod = 1000000007\n→ Initialize dp array of size [2][3] with zeros // dp[a][l] = count for current day\n→ Set dp[0][0] = 1 // empty string\n→ For day from 1 to n:\n    → NewDP = [2][3] zeros\n    → For a in 0..1:\n        → For l in 0..2:\n            → If dp[a][l]==0 continue\n            → // Add P\n                → NewDP[a][0] = (NewDP[a][0] + dp[a][l]) % mod\n            → // Add A if a==0\n                → If a==0:\n                    → NewDP[1][0] = (NewDP[1][0] + dp[a][l]) % mod\n            → // Add L if l<2\n                → If l<2:\n                    → NewDP[a][l+1] = (NewDP[a][l+1] + dp[a][l]) % mod\n    → dp = NewDP\n→ Sum result = sum over a=0..1, l=0..2 dp[a][l] % mod\n→ Output result\nEnd\n\nWe need to format each line with virtual code step and comment. Include arrows and decisions.\n\nWe need to use `Decision:` for if statements.\n\nWe need to show loops as steps maybe like \"For day = 1 to n:\" and inside decisions.\n\nWe should maintain indentation? But we can just show line by line.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 設定 mod 為 10^9 + 7? // 設定模數  \n    Yes → Step 1: Set mod = 1000000007 // 定義模數  \n→ Decision: 建立 2×3 的 dp 陣列? // dp[a][l] 代表目前已經用 a 次 A 且連續 L 為 l 的情形數  \n    Yes → Step 2: Initialise dp[0][0] = 1, 其餘為 0 // 起始空字串  \n→ For day = 1 to n: // 逐日處理  \n    → Step 3: Create newDP[2][3] all 0 // 新的一天的計數  \n    → For a = 0 to 1: // 兩種 A 使用情形  \n        → For l = 0 to 2: // 連續 L 的三種可能  \n            → Decision: dp[a][l] == 0? // 無此情形  \n                Yes → Continue // 跳過  \n            → // Add 'P'  \n            → Step 4: newDP[a][0] = (newDP[a][0] + dp[a][l]) % mod  \n            → Decision: a == 0? // 可以再加一個 'A'  \n                Yes → Step 5: newDP[1][0] = (newDP[1][0] + dp[a][l]) % mod  \n            → Decision: l < 2? // 可以再加一個 'L'  \n                Yes → Step 6: newDP[a][l+1] = (newDP[a][l+1] + dp[a][l]) % mod  \n    → Step 7: dp = newDP // 更新 dp 為今天的結果  \n→ Step 8: result = 0  \n→ For a = 0 to 1:  \n    → For l = 0 to 2:  \n        → Step 9: result = (result + dp[a][l]) % mod // 求所有符合條件的總數  \n→ Output result // 回傳答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\nclass Solution:\n    def checkRecord(self, n: int) -> int:\n        # dp[a][l] = count of sequences with a 'A's and ending with l consecutive 'L's\n        dp = [[0] * 3 for _ in range(2)]\n        dp[0][0] = 1\n\n        for _ in range(n):\n            new_dp = [[0] * 3 for _ in range(2)]\n            for a in range(2):\n                for l in range(3):\n                    val = dp[a][l]\n                    if val == 0:\n                        continue\n                    # Add 'P'\n                    new_dp[a][0] = (new_dp[a][0] + val) % MOD\n                    # Add 'A' if not used yet\n                    if a == 0:\n                        new_dp[1][0] = (new_dp[1][0] + val) % MOD\n                    # Add 'L' if consecutive L < 2\n                    if l < 2:\n                        new_dp[a][l + 1] = (new_dp[a][l + 1] + val) % MOD\n            dp = new_dp\n\n        return sum(dp[a][l] for a in range(2) for l in range(3)) % MOD\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    n = int(data)\n    solution = Solution()\n    result = solution.checkRecord(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "10101",
          "expected_output": "183236316",
          "success": true,
          "output": "183236316"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode334.json",
    "problem_index_in_file": 0,
    "title": "Increasing Triplet Subsequence",
    "description_snippet": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i <...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Traditional Chinese. The algorithm: detect increasing triplet subsequence. Known solution O(n) with two variables first and second. We'll produce steps. Each line \"虛擬碼步驟 // 解釋\". Use arrow symbols, Start, End. Let's produce.\n\nLines:\n\nStart\n→ Step 1: 初始化 first = ∞, second = ∞ // 初始化兩個最小值\n→ Step 2: 循環遍歷每個 num in nums // 遍歷數組\n    → Decision: 如果 num <= first? // 判斷是否小於等於第一個\n        Yes → first = num // 更新第一個\n        No  → Decision: 如果 num <= second? // 判斷是否小於等於第二個\n            Yes → second = num // 更新第二個\n            No  → Decision: 如果 num > second? // 找到第三個\n                Yes → Return true // 找到升序三元組\n                No  → Continue\n→ End // 沒有找到，返回 false\n\nNeed to include return false at End. Use End step: Return false. Let's format.\n\nUse proper indent. Ensure arrow arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: first ← ∞, second ← ∞ // 初始化兩個最小值，分別代表可能的第一、第二個元素\n→ Step 2: 針對每個 num 在 nums 內迴圈 // 遍歷整個陣列\n    → Decision: 是否 num ≤ first? // 若小於等於目前最小值，可能是新的第一個\n        Yes → first ← num // 更新第一個\n        No  → Decision: 是否 num ≤ second? // 若小於等於第二個，可能是新的第二個\n            Yes → second ← num // 更新第二個\n            No  → Decision: 是否 num > second? // 若比第二個大，則形成升序三元組\n                Yes → Return true // 找到符合條件的 i<j<k\n                No  → Continue // 否則繼續遍歷\n→ End // 迴圈結束，未找到升序三元組\n→ Step 3: Return false // 無符合條件，返回 false\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def increasingTriplet(self, nums):\n        first = second = float('inf')\n        for num in nums:\n            if num <= first:\n                first = num\n            elif num <= second:\n                second = num\n            else:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，支援 \"nums = [1,2,3]\" 或僅 \"[1,2,3]\"\n    try:\n        if '=' in data:\n            _, list_part = data.split('=', 1)\n            nums = ast.literal_eval(list_part.strip())\n        else:\n            nums = ast.literal_eval(data)\n    except Exception as e:\n        print(\"false\")\n        return\n\n    sol = Solution()\n    result = sol.increasingTriplet(nums)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [5,4,3,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,5,0,4,6]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode390.json",
    "problem_index_in_file": 0,
    "title": "Elimination Game",
    "description_snippet": "You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code that follows algorithm described: Josephus-like elimination with alternating directions. We must produce step-by-step virtual code with explanations. Format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows.\n\nWe need to produce algorithm to find last number for given n. The list arr is [1..n]. We simulate elimination? We can compute mathematically: it's Josephus variant. For alternating direction elimination known as \"flipping\" elimination. Equivalent to the problem \"Elimination Game\" from LeetCode. The solution uses left to right and right to left, updating head, step, remaining, direction. Virtual code should capture that algorithm.\n\nWe'll write pseudo code: Start, initialize head=1, step=1, remaining=n, left=true. While remaining>1: If left or remaining%2==1: head += step. step*=2; remaining//=2; left = not left. After loop, return head.\n\nLet's produce virtual code line by line:\n\nStart // start\n→ Initialize head = 1 // first number\n→ Initialize step = 1 // distance between remaining numbers\n→ Initialize remaining = n // number of elements left\n→ Initialize left = true // direction flag, left to right first\n→ Decision: while remaining > 1? // more than one number?\n    Yes → Step 1: If left OR remaining mod 2 == 1? // update head when elimination from left or odd count from right\n        Yes → head += step // move head to next remaining number\n    Step 2: step *= 2 // double distance\n    Step 3: remaining //= 2 // half the list\n    Step 4: left = NOT left // toggle direction\n    No  → End of loop\n→ Result: output head // last remaining number\n\nBut we need to use structure like Decision, Yes →, No →. Also using arrows. Use \"Decision:\" with indent. Need to produce proper formatting.\n\nLet's produce pseudo code lines with comments. Ensure each line has arrow or Start, etc. For decisions, use nested indent.\n\nWe must output only virtual code lines with explanations, each line ending with comment. Use Chinese explanation.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: head ← 1 // 初始頭元素為 1\n\nLine 3: → Step 2: step ← 1 // 每次保留元素之間的距離\n\nLine 4: → Step 3: remaining ← n // 目前剩餘元素個數\n\nLine 5: → Step 4: left ← true // 初始方向為從左到右\n\nLine 6: → Decision: remaining > 1? // 還有多於一個元素需要處理？\n\nLine 7:     Yes → Decision: left OR remaining % 2 == 1? // 從左到右或右到左且剩餘數為奇數時頭元素會移動\n\nLine 8:         Yes → head ← head + step // 更新頭元素為下一個剩餘元素\n\nLine 9:     No  → // 不需要更新頭元素\n\nLine 10: → Step 5: step ← step * 2 // 下一輪保留元素之間距離翻倍\n\nLine 11: → Step 6: remaining ← remaining // 2 // 殘餘元素數減半\n\nLine 12: → Step 7: left ← NOT left // 方向翻轉\n\nLine 13: → Decision: remaining > 1? // 仍有多於一個元素？\n\nLine 14:     Yes → // 迴圈重複\n\nLine 15:     No  → // 結束迴圈\n\nLine 16: → Result: output head // 最後剩下的唯一元素\n\nLine 17: End // 程式結束執行\n\nBut the indentation is not necessary but helpful. The format example uses indentation for nested steps, but we can just list sequential lines. Must maintain arrow for each line except decisions? The format shows \"Decision:\" lines and sub-lines with Yes → and No →.\n\nThus need to produce as nested. Let's restructure properly:\n\nStart\n→ Step 1: head ← 1\n→ Step 2: step ← 1\n→ Step 3: remaining ← n\n→ Step 4: left ← true\n→ Decision: remaining > 1?\n    Yes →\n        Decision: left OR remaining % 2 == 1?\n            Yes → head ← head + step\n            No  →\n        Step 5: step ← step * 2\n        Step 6: remaining ← remaining // 2\n        Step 7: left ← NOT left\n        → Decision: remaining > 1? // loop back\n            Yes → // continue loop\n            No  →\n    No  →\nResult: output head\nEnd\n\nBut we need to use '→' before each line. In example, they used '→' before Step 1, etc. For nested decisions, they indent with spaces. We can produce:\n\nStart // 程式開始執行\n→ Step 1: head ← 1 // 初始化頭元素\n→ Step 2: step ← 1 // 初始化距離\n→ Step 3: remaining ← n // 剩餘元素數\n→ Step 4: left ← true // 初始方向\n→ Decision: remaining > 1? // 仍有多於一個元素？\n    Yes →\n        Decision: left OR remaining % 2 == 1? // 從左到右或右到左且剩餘為奇數時需要移動頭\n            Yes → head ← head + step // 更新頭元素\n            No  →\n        Step 5: step ← step * 2 // 距離翻倍\n        Step 6: remaining ← remaining // 2 // 剩餘減半\n        Step 7: left ← NOT left // 方向翻轉\n        → Decision: remaining > 1? // 回到迴圈判斷\n            Yes → // 迴圈繼續\n            No  →\n    No  →\n→ Result: output head // 最後剩餘的唯一數字\nEnd // 程式結束\n\nWe need to ensure each line ends with comment after '//'.\n\nAlso we may need \"→ Decision:\" lines for loop back? The example didn't show \"→ Decision:\" inside loop but used nested. We can maintain same style.\n\nSimplify: We'll produce pseudo-code with while loop concept: \"Decision: remaining > 1?\" and inside, steps, then after steps we go back to start of decision. But we can simply produce nested decision and at the end of block we go back. It's okay.\n\nAlso must ensure each line uses arrow before. In the example, the decision line had '→ Decision:'. Inside nested yes/no lines had 'Yes →', 'No →'.\n\nThus we should replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: head ← 1 // 初始頭元素為 1  \n→ Step 2: step ← 1 // 每次保留元素之間的距離  \n→ Step 3: remaining ← n // 目前剩餘元素個數  \n→ Step 4: left ← true // 初始方向為從左到右  \n→ Decision: remaining > 1? // 還有多於一個元素需要處理？  \n&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: left OR remaining % 2 == 1? // 從左到右或右到左且剩餘為奇數時頭元素會移動  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → head ← head + step // 更新頭元素為下一個剩餘元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 不需要更新頭元素  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 5: step ← step * 2 // 下一輪保留元素之間距離翻倍  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 6: remaining ← remaining // 2 // 剩餘元素數減半  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 7: left ← NOT left // 方向翻轉  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: remaining > 1? // 迴圈回到判斷  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → // 仍有多於一個元素，繼續迴圈  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 結束迴圈  \n&nbsp;&nbsp;No  → // 已經只剩一個元素，結束迴圈  \n→ Result: output head // 最後剩下的唯一元素  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\ndef last_remaining(n: int) -> int:\n    \"\"\"\n    Return the last remaining number after alternating elimination\n    from left-to-right and right-to-left on the list [1, 2, ..., n].\n    \"\"\"\n    head = 1          # current head of the remaining list\n    step = 1          # distance between adjacent remaining numbers\n    remaining = n     # number of elements still in the list\n    left = True       # direction flag: True for left-to-right\n\n    while remaining > 1:\n        # If we are going left-to-right, or if the remaining count is odd\n        # when going right-to-left, the head moves to the next element.\n        if left or remaining % 2 == 1:\n            head += step\n\n        remaining //= 2\n        step *= 2\n        left = not left\n\n    return head\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract the first integer from the input (handles formats like \"n = 9\")\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    print(last_remaining(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 9",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode456.json",
    "problem_index_in_file": 0,
    "title": "132 Pattern",
    "description_snippet": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j]...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve 132 pattern detection. Use stack-based approach O(n). Provide steps with explanation.\n\nWe'll need:\n\nStart\n→ Step 1: Initialize stack empty and variable third = -infinity // store candidate for nums[k]\n→ Step 2: Iterate array from end to start\n    → For each current value num = nums[i]\n        → Decision: If num < third\n            Yes → Return true\n        → Decision: While stack not empty and num > stack.top()\n            Yes → third = stack.pop() // update third\n        → Push num onto stack\n→ End // No pattern found return false\n\nBut need virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, decisions.\n\nLet's create lines:\n\nStart // 開始\n→ Step 1: Initialize empty stack S and set third = -∞ // 準備存放候選值\n→ Step 2: For each index i from n-1 downto 0\n    → Step 3: current = nums[i] // 取得目前元素\n    → Decision: current < third ?\n        Yes → Return true // 找到 132 模式\n        No  →\n    → Decision: S is not empty AND current > S.top() ?\n        Yes → Step 4: third = S.pop() // 更新第三個數字\n        No  →\n    → Step 5: Push current onto S // 將當前值加入堆疊\n→ End // 未找到，返回 false\n\nBut need explicit return false at end. So maybe add after loop: Step 6: Return false.\n\nAdd arrow after loop.\n\nLet's structure:\n\nStart\n→ Step 1: S ← empty stack\n→ Step 2: third ← -∞\n→ Step 3: for i ← n-1 downto 0\n    → Step 4: current ← nums[i]\n    → Decision: current < third ?\n        Yes → Return true\n        No  →\n    → Decision: S not empty AND current > S.top() ?\n        Yes → Step 5: third ← S.pop()\n        No  →\n    → Step 6: S.push(current)\n→ Step 7: Return false\nEnd\n\nBut need arrow lines. Provide hierarchical indentation with arrow or nested lines. Use spaces to indent. Provide decision with Yes →, No →. Provide explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: S ← empty stack // 建立一個空堆疊 S  \n→ Step 2: third ← -∞ // 初始化第三個數字（nums[k] 的候選值）  \n→ Step 3: for i ← n-1 downto 0 // 從陣列尾部向前遍歷  \n  → Step 4: current ← nums[i] // 取得目前元素  \n  → Decision: current < third? // 檢查是否已符合 132 模式  \n    Yes → Return true // 找到符合條件的子序列，直接返回  \n    No → // 繼續後續判斷  \n  → Decision: S not empty AND current > S.top()? // 若目前值大於堆疊頂端，更新 third  \n    Yes → Step 5: third ← S.pop() // 將比 current 小的較大值移到 third，表示可能的 nums[k]  \n    No → // 不變更 third  \n  → Step 6: S.push(current) // 將目前值放入堆疊，作為未來可能的 nums[j]  \n→ Step 7: Return false // 完成遍歷仍未找到 132 模式，返回假  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def find132pattern(self, nums):\n        stack = []\n        s3 = float('-inf')\n        for num in reversed(nums):\n            if num < s3:\n                return True\n            while stack and stack[-1] < num:\n                s3 = stack.pop()\n            stack.append(num)\n        return False\n\ndef parse_input(data: str):\n    \"\"\"Parse input like 'nums = [1,2,3]' or just a list representation.\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    try:\n        return ast.literal_eval(expr)\n    except Exception:\n        # Fallback: attempt to extract numbers manually\n        import re\n        nums = list(map(int, re.findall(r'-?\\d+', expr)))\n        return nums\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    sol = Solution()\n    result = sol.find132pattern(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,3,2,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode6.json",
    "problem_index_in_file": 0,
    "title": "ZigZag Conversion",
    "description_snippet": "Convert a string to a zigzag pattern and read line by line....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for converting a string to zigzag pattern and read line by line. This is the LeetCode 6: Zigzag Conversion. Input string s and number of rows numRows, output string reading row by row.\n\nWe need to generate pseudo-code step by step with explanation after each line.\n\nWe need to use the specified format: each line has \"虛擬碼步驟 // 解釋\". Use arrow and Decision. Provide start, end. We should cover initialization, handling edge cases, building rows, loop over characters, adding to rows, toggling direction, concatenating final string.\n\nWe need to keep step-by-step.\n\nLet's draft:\n\nStart\n→ Decision: If numRows <= 1 or length of s <= numRows? // check trivial case\n    Yes → Step 1: Return s // 若行數 1 或字串短於行數，直接返回\n    No  → Step 2: 初始化 rows[0..numRows-1] 為空字符串 // 建立每行容器\n→ Step 3: currentRow ← 0 // 設定起始行\n→ Step 4: direction ← -1 // 初始方向設為下降 (負)\n→ Decision: For each character c in s? // 逐字符處理\n    Yes → Step 5: rows[currentRow] ← rows[currentRow] + c // 把字符加入當前行\n    Yes → Step 6: If currentRow == 0 or currentRow == numRows-1? // 判斷是否需要反轉方向\n        Yes → Step 7: direction ← -direction // 反轉方向\n        No  → // 方向不變\n    Yes → Step 8: currentRow ← currentRow + direction // 移動到下一行\n    No  → // 迴圈結束\n→ Step 9: result ← Concatenate rows[0] + rows[1] + ... + rows[numRows-1] // 合併所有行\n→ Step 10: Return result // 輸出結果\nEnd\n\nBut need to align format: Each line \"虛擬碼步驟 // 解釋\".\n\nWe need to use arrow and decision structures. Use \"→\" after each step.\n\nLet's format carefully:\n\nStart // 程式開始執行\n→ Decision: 如果 numRows <= 1 或 s.length <= numRows? // 檢查簡單情況\n    Yes → Step 1: 返回 s // 行數1或字串短於行數，直接回傳\n    No  → Step 2: 初始化 rows 為一個長度為 numRows 的空字串陣列 // 為每一行準備容器\n→ Step 3: currentRow ← 0 // 設定目前行索引為最上面\n→ Step 4: direction ← -1 // 初始方向為向下（-1）\n→ Decision: 逐字符遍歷 s? // 逐一處理每個字元\n    Yes → Step 5: rows[currentRow] ← rows[currentRow] + c // 把字元加入對應行\n    Yes → Step 6: 如果 currentRow == 0 或 currentRow == numRows-1? // 判斷是否到達頂或底\n        Yes → Step 7: direction ← -direction // 反轉上下方向\n        No  → // 方向保持不變\n    Yes → Step 8: currentRow ← currentRow + direction // 移動到下一行\n    No  → // 完成所有字元\n→ Step 9: result ← 空字串\n→ Decision: i 從 0 到 numRows-1? // 逐行拼接\n    Yes → Step 10: result ← result + rows[i] // 將行內容加入結果\n    No  → // 拼接完成\n→ Step 11: 返回 result // 輸出最終字串\nEnd // 程式結束\n\nWe might need to maintain consistent indentation, but formatting is fine.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Decision: 如果 numRows <= 1 或 s.length <= numRows? // 檢查簡單情況\n    Yes → Step 1: 返回 s // 行數 1 或字串短於行數，直接回傳\n    No  → Step 2: 初始化 rows 為一個長度為 numRows 的空字串陣列 // 為每一行準備容器\n→ Step 3: currentRow ← 0 // 設定目前行索引為最上面\n→ Step 4: direction ← -1 // 初始方向為向下（-1）\n→ Decision: 逐字符遍歷 s? // 逐一處理每個字元\n    Yes → Step 5: rows[currentRow] ← rows[currentRow] + c // 把字元加入對應行\n    Yes → Step 6: 如果 currentRow == 0 或 currentRow == numRows-1? // 判斷是否到達頂或底\n        Yes → Step 7: direction ← -direction // 反轉上下方向\n        No  → // 方向保持不變\n    Yes → Step 8: currentRow ← currentRow + direction // 移動到下一行\n    No  → // 完成所有字元\n→ Step 9: result ← 空字串\n→ Decision: i 從 0 到 numRows-1? // 逐行拼接\n    Yes → Step 10: result ← result + rows[i] // 將行內容加入結果\n    No  → // 拼接完成\n→ Step 11: 返回 result // 輸出最終字串\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        # 如果只有一行或行數大於等於字串長度，直接返回原字串\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        # 建立每一行的字串容器\n        rows = [''] * numRows\n        # currentRow 追蹤目前所在行\n        current_row = 0\n        # direction 方向：+1 下降，-1 上升\n        direction = 1\n\n        for ch in s:\n            # 把字元加入對應行\n            rows[current_row] += ch\n            # 若已到達最上或最下，反轉方向\n            if current_row == 0:\n                direction = 1\n            elif current_row == numRows - 1:\n                direction = -1\n            # 移動到下一行\n            current_row += direction\n\n        # 合併所有行得到最終字串\n        return ''.join(rows)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試從輸入中解析 s 和 numRows\n    # 例子：s = 'PAYPALISHIRING', numRows = 3\n    str_match = re.search(r\"['\\\"]([^'\\\"]*)['\\\"]\", data)\n    num_match = re.search(r\"numRows\\s*=\\s*(\\d+)\", data)\n\n    if str_match and num_match:\n        s = str_match.group(1)\n        num_rows = int(num_match.group(1))\n    else:\n        # 若格式不同，假設第一行是字串，第二行是數字\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            s = lines[0].strip()\n            try:\n                num_rows = int(lines[1].strip())\n            except ValueError:\n                num_rows = 1\n        else:\n            # 只有一行輸入，試著以逗號分隔\n            parts = data.split(',')\n            s = parts[0].strip()\n            try:\n                num_rows = int(parts[1].split('=')[-1].strip())\n            except (IndexError, ValueError):\n                num_rows = 1\n\n    result = Solution().convert(s, num_rows)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "success": true,
          "output": "PAHNAPLSIIGYIR"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode140.json",
    "problem_index_in_file": 0,
    "title": "Word Break II",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve word break II problem. Must produce step-by-step virtual code lines with comments. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision: etc.\n\nWe need to produce algorithm: use DFS with memoization or DP.\n\nWe'll produce steps:\n\nStart\n\n→ Step 1: 初始化字典集合 from wordDict // O(1) lookup\n\n→ Step 2: 定義遞迴函式 dfs(start) // 計算從索引 start 開始的所有可能斷句\n\n→ Step 3: Decision: 如果 start 等於 s.length? // 到達字串結束\n\n    Yes → Return list containing empty string // 回傳空句子表示此路徑完成\n\n    No  → Decision: 如果 start 在 memo? // 快取已計算結果\n\n        Yes → Return memo[start] // 直接回傳已存\n\n        No  → Step 4: 初始化 result = empty list\n\n        → Step 5: 迭代 end 位置從 start+1 到 s.length\n\n             → Step 6: substring = s.substring(start, end)\n\n             → Decision: 如果 substring 在字典? // 單詞檢查\n\n                 Yes → Step 7: 子句 = dfs(end) // 取得後續斷句\n\n                 → Step 8: 迭代子句\n\n                      → Step 9: 如果子句 為空字符串\n\n                          Yes → newSentence = substring // 只剩單詞\n\n                          No  → newSentence = substring + \" \" + 子句 // 加上空格\n\n                      → Step 10: result.add(newSentence) // 收集結果\n\n        → Step 11: memo[start] = result // 記錄快取\n\n        → Step 12: Return result\n\n→ Step 13: Call dfs(0) // 開始斷句\n\n→ Step 14: Return list from dfs(0) // 輸出所有句子\n\nEnd\n\nWe must use arrow lines. Provide each line. Use indentation? We need to show decision branches with indent. Use spaces maybe. But format: each line start with arrow or Decision. For branch lines use indentation by spaces.\n\nLet's craft:\n\nStart // 程式開始執行\n\n→ Step 1: 將 wordDict 轉成 hash set dictSet // O(1) 字串查找\n\n→ Step 2: 定義遞迴函式 dfs(start) // 從索引 start 開始拆分\n\n    → Decision: 如果 start == s.length? // 已到結尾\n\n        Yes → Return list containing \"\" // 空句子表示成功\n\n        No  → Decision: 如果 memo.containsKey(start)? // 快取已計算\n\n            Yes → Return memo.get(start) // 回傳已存結果\n\n            No  →\n\n                → Step 3: result = 空列表 // 用於儲存當前起點的所有句子\n\n                → Step 4: 迭代 end 取值從 start+1 到 s.length\n\n                    → Step 5: sub = s.substring(start, end) // 取子字串\n\n                    → Decision: 如果 sub 在 dictSet? // 是合法單字\n\n                        Yes →\n\n                            → Step 6: 後續句子列表 = dfs(end) // 遞歸處理剩餘\n\n                            → Step 7: 迭代後續句子\n\n                                → Step 8: 如果後續句子為 \"\" // 無剩字\n\n                                    Yes → newSent = sub // 只剩此單字\n\n                                    No  → newSent = sub + \" \" + 後續句子 // 加空格\n\n                                → Step 9: result.add(newSent) // 收集\n\n                → Step 10: memo.put(start, result) // 記錄快取\n\n                → Step 11: Return result\n\n→ Step 12: sentences = dfs(0) // 從起始索引拆分\n\n→ End // 程式結束\n\nWe should ensure each line has \"虛擬碼步驟\" followed by comment. Use arrow or decision lines accordingly. We'll keep indentation using 4 spaces maybe.\n\nWe need to show \"→\" before each step; \"Decision:\" lines with Yes → or No → lines. We need to make sure each line includes arrow or \"Decision:\".\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: dictSet = HashSet(wordDict) // 把 dictionary 轉成 hash set 以便 O(1) 檢查  \n→ Step 2: 定義遞迴函式 dfs(start) // 從索引 start 開始拆分 s  \n  Decision: 如果 start == s.length? // 已經到字串結尾  \n   Yes → Return [\"\"] // 回傳空字串表示成功分割  \n   No → Decision: 如果 memo.containsKey(start)? // 看是否已經計算過  \n    Yes → Return memo.get(start) // 直接回傳快取結果  \n    No →  \n     → Step 3: result = [] // 用來收集當前起點的所有句子  \n     → Step 4: 迭代 end 從 start+1 到 s.length  \n      → Step 5: sub = s.substring(start, end) // 取子字串  \n      → Decision: 如果 sub 在 dictSet? // 是合法單字  \n       Yes →  \n        → Step 6: suffixList = dfs(end) // 取得剩餘字串的所有拆分  \n        → Step 7: 迭代 suffixList  \n         → Step 8: 如果 suffix == \"\" // 剩下沒有字  \n          Yes → newSent = sub // 只剩此單字  \n          No → newSent = sub + \" \" + suffix // 加空格後續句子  \n         → Step 9: result.add(newSent) // 收集句子  \n       → Step 10: memo.put(start, result) // 記錄快取  \n      → Step 11: Return result  \n→ Step 12: sentences = dfs(0) // 從字串起始處拆分  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub in backtrack(end):\n                        if sub:\n                            res.append(word + \" \" + sub)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    parts = [p.strip() for p in data.split(',')]\n    parsed = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        parsed[key] = ast.literal_eval(val)\n    s = parsed.get('s', '')\n    wordDict = parsed.get('wordDict', [])\n    result = Solution().wordBreak(s, wordDict)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpwqx35fik.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmpwqx35fik.py\", line 40, in main\n    parsed[key] = ast.literal_eval(val)\n                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ['cat'\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpnegf2hqd.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmpnegf2hqd.py\", line 40, in main\n    parsed[key] = ast.literal_eval(val)\n                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ['apple'\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp2qu_9nzc.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp2qu_9nzc.py\", line 40, in main\n    parsed[key] = ast.literal_eval(val)\n                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ['cats'\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode396.json",
    "problem_index_in_file": 0,
    "title": "Rotate Function",
    "description_snippet": "You are given an integer array nums of length n.\n\nAssume arrk to be an array obtained by rotating nu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the described problem. The problem: given array nums length n. Rotation function F(k) defined as sum i * arrk[i] after rotating k positions clockwise. We need maximum over k from 0 to n-1. Classic Leetcode problem \"Maximum Rotation Function\". Efficient solution: compute initial F(0), sum of nums, then iteratively compute F(k) from F(k-1) using formula: F(k) = F(k-1) + sum - n * nums[n-k]. Actually formula: Let sum = total sum of nums. Then for k from 1 to n-1: F(k) = F(k-1) + sum - n * nums[n-k]. But careful: rotation by k positions clockwise means new array arrk[i] = nums[(i-k + n) % n]? Let's confirm: rotate right by k: arrk = last k elements first. Then F(k) computed. The formula works. Provide pseudo code lines.\n\nWe need to produce each line with explanation. We must use Start, End, Decision, arrow. Provide line numbers maybe not necessary but we can provide steps.\n\nWe need to produce virtual code lines sequentially. Each line \"虛擬碼步驟\" + space + \"// 解釋\".\n\nLet's produce steps:\n\nStart\n\n→ Step 1: Initialize n ← length(nums) // get array length\n\n→ Step 2: Compute totalSum ← sum of all elements in nums // used to update rotation function\n\n→ Step 3: Compute currentF ← 0 // will store F(0) initially\n\n→ Step 4: For i from 0 to n-1: currentF ← currentF + i * nums[i] // calculate F(0)\n\n→ Step 5: Set maxF ← currentF // maximum found so far\n\n→ Step 6: Set rotation ← 1 // start computing F(1)\n\n→ Decision: If rotation < n? // iterate rotations\n\n    Yes → Step 7: Update currentF ← currentF + totalSum - n * nums[n - rotation] // recurrence\n\n        → Step 8: If currentF > maxF? // check new max\n\n            Yes → maxF ← currentF\n\n        No → (do nothing)\n\n    No → End // finish loop\n\n→ End // return maxF\n\nBut we need to ensure each line ends with // explanation. And use Decision: if ... Then Yes → and No → lines. We need to indent? In example, they used indentation to show nested decision. We'll mimic that.\n\nWe need to produce \"虛擬碼步驟\" part. We can use \"Step X:\" or \"Decision:\" etc. We'll produce lines like:\n\nStart // 程式開始執行\n\n→ Step 1: n ← length(nums) // 取得陣列長度\n\n→ Step 2: totalSum ← 0 // 用於累加總和\n\n→ Step 3: currentF ← 0 // 初始化旋轉函數值\n\n→ Step 4: For i from 0 to n-1: // 迭代計算 F(0)\n    → currentF ← currentF + i * nums[i] // 加入每個位置的貢獻\n\n→ Step 5: maxF ← currentF // 設定目前最大值為 F(0)\n\n→ Step 6: rotation ← 1 // 開始計算下一個旋轉\n\n→ Decision: rotation < n? // 是否還有剩餘旋轉\n    Yes → // 先更新 totalSum 先前已計算\n        → currentF ← currentF + totalSum - n * nums[n - rotation] // 使用遞推公式得到 F(rotation)\n        → Decision: currentF > maxF? // 檢查是否為新最大值\n            Yes → maxF ← currentF // 更新最大值\n            No → // 不更新\n    No → // 旋轉完成\n\n→ End // 返回最大值\n\nBut we also need to compute totalSum earlier. We forgot to sum nums. We'll do Step 2 compute totalSum. Also we need to sum. So Step 2: totalSum ← sum(nums) // compute total.\n\nLet's refine:\n\nStep 1: n ← length(nums)\nStep 2: totalSum ← sum of all elements in nums // compute total sum\nStep 3: currentF ← 0 // initial rotation function value\nStep 4: For i from 0 to n-1: currentF ← currentF + i * nums[i] // F(0)\nStep 5: maxF ← currentF // set max\nStep 6: rotation ← 1 // start next rotation\nDecision: rotation < n?\nYes → currentF ← currentF + totalSum - n * nums[n - rotation] // update using recurrence\n    → Decision: currentF > maxF?\n        Yes → maxF ← currentF\n        No → \n    → rotation ← rotation + 1\n    → Go back to Decision\nNo → End\n\nWe also need to loop until rotation >= n. We can use while. The example uses Decision only. We'll do:\n\n→ Decision: rotation < n? // loop condition\n    Yes → // compute new F\n        ...\n        → rotation ← rotation + 1 // increment\n        → Decision: rotation < n? // check again\n            ... (but we can't repeat nested decisions; maybe use loop arrow.)\nBut the example uses a Decision with Yes and No. We can embed loop using recursion? Or we can express as:\n\n→ Decision: rotation < n? // while rotation < n\n    Yes → // compute next rotation\n        ...\n        → rotation ← rotation + 1\n        → Decision: rotation < n? // go back\n            Yes → // repeat\n            No → // exit\n    No → // exit\n\nBut that's nested. It's okay.\n\nLet's produce final pseudocode lines accordingly.\n\nWe need each line preceded by \"→\" except Start and End? In example they used \"→\" at start of each step. We'll use that.\n\nWe also need to keep indentation for nested decisions: we can indent lines after Decision lines with spaces.\n\nLet's write final output with each line and explanation.\n\nAlso we need to output in Chinese. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: totalSum ← sum(nums) // 計算所有元素之和  \n→ Step 3: currentF ← 0 // 初始化旋轉函數值  \n→ Step 4: For i from 0 to n-1: // 逐位累加得到 F(0)  \n  → currentF ← currentF + i * nums[i] // 每個位置的貢獻  \n→ Step 5: maxF ← currentF // 初始最大值為 F(0)  \n→ Step 6: rotation ← 1 // 準備計算 F(1)  \n→ Decision: rotation < n? // 是否還有旋轉需要處理？  \n  Yes → // 更新到下一個旋轉的函數值  \n   → currentF ← currentF + totalSum - n * nums[n - rotation] // 利用遞推公式得到 F(rotation)  \n   → Decision: currentF > maxF? // 檢查是否為新最大值？  \n    Yes → maxF ← currentF // 更新最大值  \n    No → // 不更新  \n   → rotation ← rotation + 1 // 進入下一次旋轉  \n   → Decision: rotation < n? // 重新檢查是否繼續迴圈  \n    Yes → // 回到 Yes 分支重複計算  \n    No → // 迴圈結束  \n  No → // 旋轉完成  \nEnd // 程式執行結束，回傳 maxF",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxRotateFunction(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = sum(nums)\n        F = sum(i * num for i, num in enumerate(nums))\n        max_val = F\n        # Iterate over rotations 1..n-1\n        for i in range(n - 1, 0, -1):\n            F = F + total - n * nums[i]\n            if F > max_val:\n                max_val = F\n        return max_val\n\nif __name__ == \"__main__\":\n    # Read entire input, e.g. \"nums = [4,3,2,6]\"\n    data = sys.stdin.read().strip()\n    # Extract all integers from the input\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    result = sol.maxRotateFunction(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "success": true,
          "output": "26"
        },
        {
          "example_index": 1,
          "input": "nums = [100]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode307.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Mutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following types:\n\nUpdate the value of an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementation of NumArray with update and sumRange. Use Start, End, Decision. Provide step by step. Likely include tree or fenwick. Provide generic. Use virtual code lines like \"Start\", \"→ Step 1: Initialize FenwickTree with nums\" etc. Provide explanation. Ensure each line has \"//\" after. Provide arrow and decisions for conditions. Not actual code, but algorithm steps. Use pseudocode style. Ensure each line separate. Use \"→\". For loops maybe \"→ Loop\" but we can represent decisions. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收整數陣列 nums，初始化一個長度為 n 的 Binary Indexed Tree (Fenwick Tree) // 用於快速更新與區間求和  \n→ Step 2: 對 nums 的每個元素 i 執行 add(i, nums[i])，將其值加入 Fenwick Tree // 建立初始樹結構  \n→ Step 3: 儲存原始陣列 nums，便於後續更新時取得舊值 // 方便計算差值  \n→ Step 4: 完成建構，準備接受使用者指令 // NumArray 物件建立完畢  \n\nDecision: 使用者是否要執行 update？ // 判斷指令類型  \n    Yes → Step 5: 讀取 index 與 val，計算 diff = val - nums[index] // 需要的差值  \n    → Step 6: 執行 add(index, diff) 於 Fenwick Tree // 更新樹結構  \n    → Step 7: 更新 nums[index] = val // 同步原始陣列  \n    No  → Decision: 使用者是否要執行 sumRange？ // 另一條指令  \n        Yes → Step 8: 讀取 left 與 right，計算 sum = prefixSum(right) - prefixSum(left - 1) // 利用前綴和求區間和  \n        → Step 9: 回傳 sum // 結果輸出  \n        No  → Step 10: End // 無其他指令，結束執行  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        self.tree = [0] * (self.n + 1)\n        for i in range(self.n):\n            self._add(i + 1, nums[i])\n\n    def _add(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._add(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._prefix(right + 1) - self._prefix(left)\n\n    def _prefix(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入: 兩個列表之間用逗號分隔\n    # 例如: '[\"NumArray\", \"sumRange\"], [[1,2,3], [0,2]]'\n    try:\n        ops, params = ast.literal_eval('(' + data + ')')\n    except Exception as e:\n        # 若輸入格式不符合，直接結束\n        sys.exit()\n    result = []\n    obj = None\n    for op, p in zip(ops, params):\n        if op == \"NumArray\":\n            obj = NumArray(p[0])\n            result.append(None)\n        elif op == \"update\":\n            obj.update(p[0], p[1])\n            result.append(None)\n        elif op == \"sumRange\":\n            result.append(obj.sumRange(p[0], p[1]))\n        else:\n            # 不支持的操作，忽略\n            result.append(None)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "success": true,
          "output": "[null, 9, null, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode342.json",
    "problem_index_in_file": 0,
    "title": "Power of Four",
    "description_snippet": "Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm: check if integer n is power of 4. Approach: if n <=0 return false. While n%4==0, n/=4. At end if n==1 return true else false. Could also use bit manipulation: check that n>0, only one bit set and that bit position is even: (n & (n-1))==0 and ((n-1)/3)%2==0 or (log2(n)%2==0). But simple while loop is fine.\n\nWe need to output each line with arrow notation. Use Start, End, Decision, Step. Use \"Step: ...\" lines. Provide explanation after //.\n\nSo produce steps:\n\nStart\n→ Step 1: Input n // 获取输入整数\n→ Decision: n <= 0? // 判断是否为正数\n    No → Step 2: 返回 false // 非正数直接返回 false\n    Yes → Decision: n == 1? // 1是4^0，直接返回 true\n        Yes → Step 3: 返回 true // n为1，返回真\n        No  → Step 4: 重复检查除以4 // 开始循环检查是否能被4整除\n            → Step 5: While n % 4 == 0? // 判断是否能被4整除\n                Yes → Step 6: n = n / 4 // 继续除\n                No  → Decision: n == 1? // 循环结束后判断是否为1\n                    Yes → Step 7: 返回 true // 是1，返回真\n                    No  → Step 8: 返回 false // 不是1，返回假\nEnd\n\nWe need to use arrow for decision branches.\n\nMake sure each line ends with // explanation.\n\nLet's format accordingly.\n\nAlso we might need to use indentation or not. In example, they use indentation for nested. We'll indent with 4 spaces maybe.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input n // 取得使用者輸入的整數  \n→ Decision: n <= 0? // 檢查 n 是否為正整數  \n Yes → Step 2: Return false // 非正數直接回傳 false  \n No  → Decision: n == 1? // 1 為 4^0，先判斷是否為 1  \n  Yes → Step 3: Return true // n 為 1，回傳 true  \n  No  → Step 4: Begin division loop // 開始檢查是否能被 4 整除  \n\n   → Step 5: While n % 4 == 0? // 判斷是否能被 4 整除  \n    Yes → Step 6: n = n / 4 // 進行除法  \n    No  → Decision: n == 1? // 循環結束後判斷 n 是否為 1  \n     Yes → Step 7: Return true // 仍為 1，回傳 true  \n     No  → Step 8: Return false // 不是 1，回傳 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        \"\"\"\n        判斷 n 是否為 4 的整次冪。\n        使用位運算判斷：n 必須是正整數、只有一個 1 位，且該位在偶數位置\n        (對 4^k，k 為整數時，n-1 可被 3 整除)\n        \"\"\"\n        return n > 0 and (n & (n - 1)) == 0 and (n - 1) % 3 == 0\n\ndef main():\n    # 從標準輸入讀取整行文字，例如 \"n = 16\"\n    line = sys.stdin.read().strip()\n    if not line:\n        return\n    # 解析輸入，假設格式為 \"n = <number>\"\n    try:\n        _, value = line.split('=', 1)\n        n = int(value.strip())\n    except ValueError:\n        # 若格式不符合，嘗試直接將整行轉為整數\n        n = int(line)\n    solution = Solution()\n    result = solution.isPowerOfFour(n)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode327.json",
    "problem_index_in_file": 0,
    "title": "Count of Range Sum",
    "description_snippet": "Given an integer array nums and two integers lower and upper, return the number of range sums that l...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, using arrows etc. This is a typical \"Range Sum Count\" problem, solved with prefix sums + divide and conquer (mergesort style) or BIT. We'll provide a virtual algorithm. Probably use prefix sums and a sorted array with two pointers to count how many subarray sums in range. We need to explain each line.\n\nThe pseudocode will include Start, compute prefix sums, define recursive function count_while_merge_sort, etc.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows: \"→\".\n\nWe need decisions with Yes/No.\n\nLet's produce something like:\n\nStart // 程式開始\n\n→ Step 1: 計算 prefix sums array P // P[0] = 0, P[i] = P[i-1] + nums[i-1]\n\n→ Step 2: 呼叫遞迴函式 CountRange(P, 0, len(P)-1, lower, upper) // 進行分治計算\n\nDefine function CountRange(P, left, right, lower, upper) // 計算區間 [left, right] 的符合條件的子陣列數\n\n   if left == right: return 0 // 單元素區間無子陣列\n\n   mid = (left + right) // 2\n\n   count = CountRange(P, left, mid, lower, upper) + CountRange(P, mid+1, right, lower, upper) // 分別計算左、右半部\n\n   → Decision: 是否需要合併？ // 需要合併以計算跨越中點的子陣列\n\n        Yes → Step ... etc\n\n   Merge two halves while counting cross sums\n\nWe need to show counting cross sums: for each i in left half, find number of j in right half such that P[j] - P[i] in [lower, upper]. Use two pointers low_ptr and high_ptr.\n\nDetailed steps:\n\n   Initialize low_ptr = mid+1, high_ptr = mid+1\n\n   For each i from left to mid:\n\n        while low_ptr <= right and P[low_ptr] - P[i] < lower: low_ptr++\n\n        while high_ptr <= right and P[high_ptr] - P[i] <= upper: high_ptr++\n\n        count += high_ptr - low_ptr\n\n   → Merge P[left..mid] and P[mid+1..right] into temp array sorted ascending // 以便上層使用\n\n   → Copy temp back to P[left..right]\n\n   return count\n\nFinally, Step 3: 輸出 count\n\nEnd\n\nWe need to provide each step as a line with \"虛擬碼步驟\" and comment. Ensure each line uses arrow. Use \"Decision:\" with Yes→ and No→ lines.\n\nLet's produce the pseudocode step by step. Ensure each line is separate.\n\nUse \"→\" before each step except Start and End. For function definition maybe not arrow? The example uses \"→ Step 1\". So we follow.\n\nDefine function: maybe \"→ Function CountRange(P, left, right, lower, upper) // 定義遞迴函式\".\n\nInside function, indent lines with arrow too.\n\nWe'll produce line by line.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: 計算前綴和陣列 P // P[0] = 0，P[i] = P[i-1] + nums[i-1] (i 從 1 到 nums.length)  \n\n→ Step 2: 呼叫遞迴函式 CountRange(P, 0, len(P)-1, lower, upper) // 進行分治計算並回傳符合條件的子陣列數  \n\n→ Function CountRange(P, left, right, lower, upper) // 定義遞迴函式  \n\n  → Decision: left == right? // 判斷區間是否只有一個前綴和  \n    Yes → Return 0 // 單元素區間不含子陣列，回傳 0  \n    No →  // 区间有多个前缀和，继续分治  \n\n    → Step 3: mid = (left + right) // 2 // 找到中点  \n\n    → Step 4: leftCount = CountRange(P, left, mid, lower, upper) // 递归计算左半区  \n\n    → Step 5: rightCount = CountRange(P, mid+1, right, lower, upper) // 递归计算右半区  \n\n    → Step 6: count = leftCount + rightCount // 累加左、右两半的结果  \n\n    → Step 7: lowPtr = mid + 1 // 初始化指向右半区的指针  \n    → Step 8: highPtr = mid + 1 // 初始化指向右半区的指针  \n\n    → Decision: 迭代 i 從 left 到 mid? // 逐个处理左半区的前缀和  \n      Yes → Step 9: For i in [left, mid]  \n              → Step 10: while lowPtr <= right and P[lowPtr] - P[i] < lower: lowPtr++ // 找到首个满足 lower 的索引  \n              → Step 11: while highPtr <= right and P[highPtr] - P[i] <= upper: highPtr++ // 找到超出 upper 的索引  \n              → Step 12: count += highPtr - lowPtr // 计数满足区间的数量  \n              → Step 13: 结束 For 循环  \n              No → // 迭代结束  \n\n    → Step 14: temp = [] // 用于存放已排序的前缀和  \n    → Step 15: i = left, j = mid + 1 // 初始化左右指针  \n\n    → Decision: i <= mid 或 j <= right? // 合并两个已排序的子区间  \n      Yes → Step 16: while i <= mid and j <= right  \n            → Step 17: if P[i] <= P[j]: temp.append(P[i]); i++ else: temp.append(P[j]); j++  \n            → Step 18: 结束 while 循环  \n            → Step 19: while i <= mid: temp.append(P[i]); i++  \n            → Step 20: while j <= right: temp.append(P[j]); j++  \n            → Step 21: 结束 Decision  \n    → Step 22: for k in range(left, right+1): P[k] = temp[k-left] // 把已排序的前缀和写回原数组  \n\n    → Return count // 返回当前区间内满足条件的子数组计数  \n\n→ Step 3: 輸出計算結果 // 顯示符合 [lower, upper] 的子陣列總數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        # 建立前綴和\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        # 分治計算跨越區間的符合條件子陣列數\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:  # 只剩一個前綴和，沒有子陣列\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            # 兩指針計算跨越中點的區間\n            i = j = mid\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            # 合併兩個已排序的區間\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 用正則表達式從輸入中抽取 nums、lower、upper\n    pattern = r\"nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*lower\\s*=\\s*(-?\\d+)\\s*,\\s*upper\\s*=\\s*(-?\\d+)\"\n    match = re.search(pattern, data, re.S)\n    if not match:\n        raise ValueError(\"輸入格式不正確，無法解析 nums、lower、upper。\")\n\n    nums_str, lower_str, upper_str = match.group(1), match.group(2), match.group(3)\n    nums = ast.literal_eval(nums_str)          # 轉成真正的 list\n    lower = int(lower_str)\n    upper = int(upper_str)\n\n    solution = Solution()\n    result = solution.countRangeSum(nums, lower, upper)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0], lower = 0, upper = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode228.json",
    "problem_index_in_file": 0,
    "title": "Summary Ranges",
    "description_snippet": "You are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm: Given sorted unique integer array nums, find ranges covering all numbers exactly. Standard solution: iterate through nums, track start of current range; if next number is not previous+1, then close current range and start new. Finally output list of strings. The output format: if start==end -> just start, else start->end. Return list sorted (by default). So produce virtual code lines with explanation. Must use \"Start\", \"End\", \"Decision:\", \"Yes →\", \"No →\", etc. No real code. Provide line by line. Use arrows. Should be thorough. Provide step definitions. Probably use Step 1: Initialize result list, etc. Also handle edge case when array empty? In problem, maybe non-empty? We can handle anyway.\n\nLet's craft virtual code.\n\nStart\n→ Step 1: Initialize an empty list result // 用於儲存範圍字串\n→ Step 2: If nums is empty, return result // 空陣列直接回傳空清單\n→ Step 3: Set start = nums[0] // 當前範圍起始點\n→ Step 4: Set prev = nums[0] // 前一個數值\n→ Decision: 是否已處理完所有數字? // 判斷是否已到陣列尾\n    No → Step 5: 從 index=1 到 nums.length-1 逐個檢查 // 迴圈遍歷剩餘數字\n        → Step 5.1: curr = nums[index] // 取得目前數字\n        → Decision: curr == prev + 1? // 是否連續\n            Yes → Step 5.2: prev = curr // 連續，更新 prev\n            No  → Step 5.3: Output範圍(start, prev) // 產生範圍字串\n                    → Step 5.4: Append 到 result // 加入結果\n                    → Step 5.5: start = curr // 新範圍起始點\n                    → Step 5.6: prev = curr // 更新 prev\n    Yes → Step 6: 迴圈結束\n→ Step 7: Output範圍(start, prev) // 追加最後一個範圍\n→ Step 8: Append 到 result\n→ End // 回傳結果\n\nBut we need to produce in the specific format with \"Step\" and arrows and explanation.\n\nAlso need to define \"Output範圍\" function maybe as sub-step.\n\nLet's produce code lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化空清單 result = [] // 用於存放範圍字串\n→ Step 2: 如果 nums 為空，返回 result // 空陣列直接回傳空清單\n→ Step 3: 設定 start = nums[0] // 目前範圍起始點\n→ Step 4: 設定 prev = nums[0] // 上一個已處理數值\n→ Decision: 是否已處理完所有數字? // 判斷是否已走到陣列尾\n    No → Step 5: 迴圈從 index=1 到 nums.length-1 // 遍歷剩餘數字\n        → Step 5.1: curr = nums[index] // 取得目前數字\n        → Decision: curr == prev + 1? // 判斷是否連續\n            Yes → Step 5.1.1: prev = curr // 連續，更新 prev\n            No  → Step 5.1.2: 呼叫 AppendRange(start, prev) // 產生範圍字串並加入結果\n                    → Step 5.1.3: start = curr // 新範圍起始點\n                    → Step 5.1.4: prev = curr // 更新 prev\n    Yes → Step 6: 迴圈結束\n→ Step 7: 呼叫 AppendRange(start, prev) // 追加最後一個範圍\n→ End // 程式執行結束\n\nBut we need to incorporate AppendRange definition: maybe as a step earlier. Let's define step for AppendRange. For clarity:\n\nStep 8: 定義 AppendRange(a, b):\n        → Step 8.1: 如果 a == b，rangeStr = str(a) // 單一數字\n        → Step 8.2: 否則 rangeStr = f\"{a}->{b}\" // 範圍字串\n        → Step 8.3: 把 rangeStr 加入 result // 添加到結果清單\n\nBut we must embed within code? Usually we define before use. Let's move AppendRange step earlier.\n\nLet's craft final answer:\n\nStart // 程式開始執行\n→ Step 1: 初始化空清單 result = [] // 用於存放範圍字串\n→ Step 2: 定義函式 AppendRange(a, b):\n    → Step 2.1: 如果 a == b，將 str(a) 加入 result // 單一數字\n    → Step 2.2: 否則，將 f\"{a}->{b}\" 加入 result // 範圍字串\n→ Step 3: 如果 nums 為空，返回 result // 空陣列直接回傳空清單\n→ Step 4: 設定 start = nums[0] // 目前範圍起始點\n→ Step 5: 設定 prev = nums[0] // 上一個已處理數值\n→ Decision: 是否已處理完所有數字? // 判斷是否已走到陣列尾\n    No → Step 6: 迴圈從 index=1 到 nums.length-1 // 遍歷剩餘數字\n        → Step 6.1: curr = nums[index] // 取得目前數字\n        → Decision: curr == prev + 1? // 判斷是否連續\n            Yes → Step 6.1.1: prev = curr // 連續，更新 prev\n            No  → Step 6.1.2: 呼叫 AppendRange(start, prev) // 產生範圍並加入結果\n                    → Step 6.1.3: start = curr // 新範圍起始點\n                    → Step 6.1.4: prev = curr // 更新 prev\n    Yes → Step 7: 迴圈結束\n→ Step 8: 呼叫 AppendRange(start, prev) // 追加最後一個範圍\n→ End // 程式執行結束\n\nNeed to ensure arrows \"→\". Also each step includes explanation. We must output only virtual code lines. Use correct format. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空清單 result = [] // 用於存放範圍字串  \n→ Step 2: 定義函式 AppendRange(a, b): // 產生範圍字串並加入結果  \n  → Step 2.1: 如果 a == b，將 str(a) 加入 result // 單一數字  \n  → Step 2.2: 否則，將 f\"{a}->{b}\" 加入 result // 範圍字串  \n→ Step 3: 如果 nums 為空，返回 result // 空陣列直接回傳空清單  \n→ Step 4: 設定 start = nums[0] // 目前範圍起始點  \n→ Step 5: 設定 prev = nums[0] // 上一個已處理數值  \n→ Decision: 是否已處理完所有數字? // 判斷是否已走到陣列尾  \n  No → Step 6: 迴圈從 index=1 到 nums.length-1 // 遍歷剩餘數字  \n   → Step 6.1: curr = nums[index] // 取得目前數字  \n   → Decision: curr == prev + 1? // 判斷是否連續  \n    Yes → Step 6.1.1: prev = curr // 連續，更新 prev  \n    No → Step 6.1.2: 呼叫 AppendRange(start, prev) // 產生範圍並加入結果  \n     → Step 6.1.3: start = curr // 新範圍起始點  \n     → Step 6.1.4: prev = curr // 更新 prev  \n  Yes → Step 7: 迴圈結束  \n→ Step 8: 呼叫 AppendRange(start, prev) // 追加最後一個範圍  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def summaryRanges(self, nums):\n        if not nums:\n            return []\n        res = []\n        start = end = nums[0]\n        for n in nums[1:]:\n            if n == end + 1:\n                end = n\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(f\"{start}->{end}\")\n                start = end = n\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(f\"{start}->{end}\")\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        nums = []\n    else:\n        # Extract the part after '=' if present\n        if '=' in raw_input:\n            _, expr = raw_input.split('=', 1)\n            expr = expr.strip()\n        else:\n            expr = raw_input\n        # Safely evaluate the list expression\n        try:\n            nums = ast.literal_eval(expr)\n            if not isinstance(nums, list):\n                nums = []\n        except Exception:\n            nums = []\n\n    solution = Solution()\n    result = solution.summaryRanges(nums)\n    # Print the result as a JSON array of strings\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,2,4,5,7]",
          "expected_output": "[\"0->2\",\"4->5\",\"7\"]",
          "success": true,
          "output": "[\"0->2\", \"4->5\", \"7\"]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,2,3,4,6,8,9]",
          "expected_output": "[\"0\",\"2->4\",\"6\",\"8->9\"]",
          "success": true,
          "output": "[\"0\", \"2->4\", \"6\", \"8->9\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode731.json",
    "problem_index_in_file": 0,
    "title": "My Calendar II",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementing MyCalendarTwo with book method ensuring no triple booking. Use virtual code with arrows, decisions. Must produce line by line with explanation. Not actual code. Provide steps of algorithm: maintain list of intervals, and list of double-book intervals. For each new interval, check overlapping with double-book intervals, if overlap > 0 then reject. Else add overlapping parts to double-book list. Finally add interval to event list and return true.\n\nWe output step-by-step structure:\n\nStart\n→ Step 1: Initialize events list // store all bookings\n→ Step 2: Initialize overlaps list // store intervals already double-booked\n→ Decision: book called with start, end // start of method\n    → Step 3: For each interval in overlaps:\n        → Decision: if new interval overlaps interval in overlaps? // triple check\n            Yes → Return false // triple booking\n    → Step 4: For each interval in events:\n        → Decision: if new interval overlaps interval? \n            Yes → Compute overlap interval = [max(start, existing.start), min(end, existing.end)]\n                → Append overlap to overlaps list\n    → Step 5: Append new interval to events list\n    → Return true\nEnd\n\nBut we need line by line with arrow syntax and explanation. Use \"Decision:\" etc. Must follow format: \"虛擬碼步驟 // 解釋\". Use spaces.\n\nLet's produce like:\n\nStart // 程式開始\n→ Step 1: Create empty list events // 儲存所有已預約的區間\n→ Step 2: Create empty list overlaps // 儲存已雙重預約的區間\n→ Step 3: book(start, end) // 當呼叫預約方法\n    → Decision: 是否已有 triple booking? // 判斷新區間是否與任何 double-book 交集\n        Yes → Return false // 若交集，拒絕預約\n    → Step 4: For each ev in events\n        → Decision: new區間與 ev 是否交集? // 判斷是否形成雙重預約\n            Yes → overlap_start = max(start, ev.start)\n                 overlap_end = min(end, ev.end)\n                 Append [overlap_start, overlap_end] to overlaps\n    → Step 5: Append [start, end] to events // 新增成功\n    → Return true\nEnd // 程式結束\n\nBut we must use arrow syntax precisely: \"→\" at start of each line. Use indentation for nested steps.\n\nMake sure each line ends with // 解釋.\n\nAlso use \"Decision:\" and \"Yes →\" \"No →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 建立空列表 events // 用來儲存所有已成功加入的區間  \n→ Step 2: 建立空列表 overlaps // 用來儲存所有已雙重預約（兩個事件重疊）的區間  \n→ Step 3: book(start, end) // 處理一次預約請求  \n  → Decision: 新區間與 overlaps 中任意區間是否有交集？ // 檢查是否會造成三重預約  \n    Yes → Return false // 若有交集，表示三重預約，拒絕加入  \n    No →  \n     → Step 4: 針對 events 中每一個已存在區間 ev  \n      → Decision: 新區間與 ev 是否有交集？  \n       Yes → overlap_start ← max(start, ev.start) // 計算交集開始點  \n        overlap_end ← min(end, ev.end) // 計算交集結束點  \n        Append [overlap_start, overlap_end] to overlaps // 將交集區間加入 double-book 清單  \n       No → 何也不做  \n     → Step 5: Append [start, end] to events // 成功加入新區間  \n     → Return true // 表示預約成功  \nEnd // 程式結束",
      "generated_code": "import sys\nimport json\n\nclass MyCalendarTwo:\n    \"\"\"\n    Calendar that allows double bookings but forbids triple bookings.\n    \"\"\"\n    def __init__(self):\n        # All booked intervals\n        self.booked = []\n        # Intervals that are already double booked\n        self.overlaps = []\n\n    def book(self, start, end):\n        \"\"\"\n        Try to book an event [start, end).\n        Returns True if successful, False otherwise.\n        \"\"\"\n        # Check for triple booking: new interval overlaps any double-booked interval\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):  # intersection is non-empty\n                return False\n\n        # Record new double bookings\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                # Overlap interval\n                self.overlaps.append((max(s, start), min(e, end)))\n\n        # Accept the new booking\n        self.booked.append((start, end))\n        return True\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input string into two lists: commands and arguments.\n    The input format is like:\n    [\"MyCalendarTwo\",\"book\",\"book\"],[[],[10,20],[50,60]]\n    \"\"\"\n    # Wrap the string in brackets to form a valid JSON array\n    json_str = '[' + data.strip() + ']'\n    return json.loads(json_str)\n\ndef to_output(value):\n    \"\"\"\n    Convert Python value to the expected JSON-like string representation.\n    None -> null, True -> true, False -> false, list -> [...], etc.\n    \"\"\"\n    if value is None:\n        return 'null'\n    if isinstance(value, bool):\n        return 'true' if value else 'false'\n    if isinstance(value, list):\n        return '[' + ', '.join(to_output(v) for v in value) + ']'\n    return str(value)\n\ndef main():\n    raw_input = sys.stdin.read()\n    commands, args_list = parse_input(raw_input)\n\n    outputs = []\n    calendar = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCalendarTwo\":\n            calendar = MyCalendarTwo()\n            outputs.append(None)  # constructor returns null\n        elif cmd == \"book\":\n            start, end = args\n            result = calendar.book(start, end)\n            outputs.append(result)\n        else:\n            # Unknown command, skip or raise error\n            pass\n\n    # Print the output list in the required format\n    print(to_output(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "success": true,
          "output": "[null, true, true, true, false, true, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode560.json",
    "problem_index_in_file": 0,
    "title": "Subarray Sum Equals K",
    "description_snippet": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps with explanations, no actual code. For subarray sum equals k. Use prefix sums and hashmap. Steps: Start, input array and k, initialize hashmap with (0:1), prefix sum=0, count=0, iterate i over nums: prefix += nums[i], if hashmap contains prefix-k: count+=hashmap[prefix-k], increment hashmap[prefix] count. After loop, output count. End.\n\nWe need each line with virtual code step and comment. Use arrow formatting: \"→ Step: ...\" and Decision nodes etc. We need to show decisions like if map contains.\n\nWe need to adhere to formatting: each line: `虛擬碼步驟 [space] // 解釋/說明`.\n\nWe need Start and End markers. Use arrow for steps.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取陣列 nums 與目標值 k // 從使用者或環境取得輸入\n→ Step 2: 初始化哈希表 prefixCount，將 {0:1} 加入 // 代表前綴和為0時出現一次\n→ Step 3: 設定變數 prefixSum ← 0 // 用於累加子陣列和\n→ Step 4: 設定變數 result ← 0 // 用於計算符合條件的子陣列數量\n→ Decision: 是否還有元素可遍歷? // 判斷迴圈是否結束\n    Yes → Step 5: 取下一個元素 num ← nums[i] // 取下一個數字\n    → Step 6: 更新前綴和 prefixSum ← prefixSum + num // 加上當前數字\n    → Decision: 是否存在 (prefixSum - k) 在 prefixCount? // 檢查是否有前綴和差為 k\n        Yes → Step 7: result ← result + prefixCount[prefixSum - k] // 加上對應前綴和出現的次數\n        No  → // 不做任何事\n    → Step 8: 在 prefixCount 中增加 prefixSum 的計數\n        prefixCount[prefixSum] ← prefixCount.get(prefixSum, 0) + 1 // 更新或新增\n    → Decision: 是否已遍歷完陣列? // 迴圈判斷\n        Yes → Step 9: 輸出 result // 回傳符合條件的子陣列總數\n        No  → 回到 Decision: 是否還有元素可遍歷?\nEnd // 程式執行結束\n\nNeed to ensure formatting: each line with arrow and comment.\n\nWe need to keep decisions properly indented? Not necessary but maintain.\n\nBetter to use consistent arrow lines: \"→ Step ...\". For Decision we can use \"→ Decision: ...\" etc.\n\nEnsure every line ends with comment after \"//\". Provide explanation. Provide indentation maybe but not required.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取陣列 nums 與目標值 k // 從使用者或環境取得輸入  \n→ Step 2: 初始化哈希表 prefixCount，將 {0:1} 加入 // 代表前綴和為 0 時已出現一次  \n→ Step 3: 設定變數 prefixSum ← 0 // 用於累加子陣列的前綴和  \n→ Step 4: 設定變數 result ← 0 // 用於統計符合條件的子陣列數量  \n→ Decision: 是否還有元素可遍歷? // 判斷是否進入迴圈  \n    Yes → Step 5: 取下一個元素 num ← nums[i] // 取得陣列中下一個數字  \n    → Step 6: 更新前綴和 prefixSum ← prefixSum + num // 加上目前數字得到新的前綴和  \n    → Decision: 是否存在 (prefixSum - k) 在 prefixCount? // 檢查是否已有前綴和差為 k  \n        Yes → Step 7: result ← result + prefixCount[prefixSum - k] // 加上對應前綴和已出現次數  \n        No  → // 無需處理  \n    → Step 8: 在 prefixCount 中更新 prefixSum 的計數  \n        prefixCount[prefixSum] ← prefixCount.get(prefixSum, 0) + 1 // 新增或遞增計數  \n    → Decision: 是否已遍歷完陣列? // 判斷迴圈結束條件  \n        Yes → Step 9: 輸出 result // 回傳符合條件的子陣列總數  \n        No  → 回到 Decision: 是否還有元素可遍歷?  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def subarraySum(self, nums, k):\n        \"\"\"Return the number of subarrays whose sum equals k.\"\"\"\n        count = 0\n        prefix_sum = 0\n        sum_map = {0: 1}  # prefix sum 0 occurs once initially\n\n        for num in nums:\n            prefix_sum += num\n            # If prefix_sum - k has been seen, we found that many subarrays\n            if prefix_sum - k in sum_map:\n                count += sum_map[prefix_sum - k]\n            # Record the current prefix sum\n            sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n        return count\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract all integers from the input\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if not numbers:\n        print(0)\n        sys.exit(0)\n\n    k = numbers[-1]          # the last number is k\n    nums = numbers[:-1]      # all preceding numbers form the array\n\n    result = Solution().subarraySum(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode600.json",
    "problem_index_in_file": 0,
    "title": "Non-negative Integers without Consecutive Ones",
    "description_snippet": "Given a positive integer n, return the number of the integers in the range [0, n] whose binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode to count number of integers in [0,n] with no consecutive ones in binary representation. Classic problem: count Fibonacci numbers, dynamic programming.\n\nWe need line by line pseudocode with explanation after each line.\n\nWe need to output in the format: each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision etc.\n\nWe'll produce steps: Start, compute binary of n, determine length L, precompute Fibonacci array up to L, iterate bits from most significant to least, accumulate count, handle consecutive ones flag. At the end, if no consecutive ones found, include n itself. Then End.\n\nLet's produce concise pseudocode.\n\nWe'll use arrow symbol \"→\" for steps, indentation for decisions.\n\nLet's produce.\n\nProbably:\n\nStart // program starts\n\n→ Step 1: Convert n to binary string bits // get bit representation\n\n→ Step 2: Let L = length(bits) // number of bits\n\n→ Step 3: Initialize array fib[0..L] // fib[i] = number of binary strings of length i with no consecutive ones\n\n    → fib[0] = 1 // empty string\n\n    → fib[1] = 2 // \"0\" or \"1\"\n\n    → For i from 2 to L: fib[i] = fib[i-1] + fib[i-2] // recurrence\n\n→ Step 4: Set count = 0 // result counter\n\n→ Step 5: Set prev_bit = 0 // previous bit (most significant processed so far)\n\n→ Decision: For i from 0 to L-1: // iterate over bits from msb to lsb\n\n    Yes → (current_bit = bits[i]) // current bit value\n\n    → Decision: If current_bit == 1?\n\n        Yes → \n\n            → count += fib[L - i - 1] // add all valid strings for remaining positions\n\n            → Decision: If prev_bit == 1?\n\n                Yes → \n\n                    → Return count // consecutive ones found, stop\n\n                No → \n\n                    → prev_bit = 1 // set flag for next iteration\n\n        No → \n\n            → prev_bit = 0 // reset flag if current bit 0\n\n    (end decision)\n\n→ Step 6: count += 1 // include n itself\n\n→ End // finished\n\nNeed to format each line with explanation.\n\nWe need to indent decisions properly. Use \"Decision:\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 n 的二進位字串 bits // 取得 n 的位元表示  \n→ Step 2: 設定 L = bits 的長度 // 位元總數  \n→ Step 3: 初始化 Fibonacci 陣列 fib[0..L] // 用於計算合法串數  \n  → fib[0] = 1 // 空串  \n  → fib[1] = 2 // \"0\" 或 \"1\"  \n  → For i = 2 to L: fib[i] = fib[i-1] + fib[i-2] // 斐波那契遞迴  \n→ Step 4: 設 count = 0 // 結果計數  \n→ Step 5: 設 prev_bit = 0 // 先前位元（最左邊的位元已處理前）  \n→ Decision: 對每個位元 i 從 0 到 L-1 進行迴圈 // 逐位檢查  \n  Yes → current_bit = bits[i] // 取當前位元值  \n  → Decision: 如果 current_bit == 1? // 是否為 1  \n    Yes →  \n     → count += fib[L - i - 1] // 加上剩餘位元可合法排列數  \n     → Decision: 如果 prev_bit == 1? // 前一位元是否也為 1  \n       Yes →  \n        → Return count // 發現連續 1，結束計算  \n       No →  \n        → prev_bit = 1 // 記錄當前為 1，繼續迴圈  \n       End  \n     End  \n    No →  \n     → prev_bit = 0 // 當前為 0，重置前一位元標記  \n    End  \n→ Step 6: count += 1 // 加上 n 本身（已確認沒有連續 1）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_no_consecutive_ones(n: int) -> int:\n    # dp[i] 表示長度為 i 的二進制不含連續 1 的數量\n    dp = [0] * 32\n    dp[0] = 1\n    dp[1] = 2\n    for i in range(2, 32):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    ans = 0\n    prev_bit = 0\n    # 逐位檢查從最高位到最低位\n    for i in range(31, -1, -1):\n        if (n >> i) & 1:\n            ans += dp[i]\n            if prev_bit:          # 已經有連續 1，直接回傳\n                return ans\n            prev_bit = 1\n        else:\n            prev_bit = 0\n    return ans + 1                 # 包含 n 本身\n\ndef parse_input(data: str) -> int:\n    \"\"\"從輸入字串中擷取第一個整數。\"\"\"\n    m = re.search(r'-?\\d+', data)\n    return int(m.group()) if m else 0\n\ndef main() -> None:\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    n = parse_input(raw)\n    result = count_no_consecutive_ones(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode282.json",
    "problem_index_in_file": 0,
    "title": "Expression Add Operators",
    "description_snippet": "Given a string num that contains only digits and an integer target, return all possibilities to inse...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: given num string, insert operators to evaluate to target. Classic Leetcode 282. Provide steps: Start, parse input, backtracking function, decision, recursion, avoid leading zeros, handle multiplication precedence, etc. Provide step-by-step pseudocode with arrows and explanations. Use \"→\" arrows and \"Decision:\".\n\nWe must output line by line. Each line: virtual code step + space + // explanation.\n\nWe need to reflect algorithm: function dfs(index, path, eval, prev). At each index, iterate over possible splits, check leading zeros, compute new eval and prev for multiplication. Append result when index==len(num) and eval==target.\n\nLet's produce steps.\n\nWe should include Start, End. Provide variable declarations: num, target. Provide function call.\n\nLet's produce.\n\nWe'll format:\n\nStart // 程式開始執行\n→ Read num and target // 取得輸入的字串和目標值\n→ Function dfs(position, expr, current_value, last_operand) // 定義遞迴函式\n    → Decision: 若 position == len(num)? // 到達字串結尾\n        Yes → Decision: 若 current_value == target? // 判斷結果是否符合目標\n            Yes → Step: Add expr to answer list // 存儲合法表達式\n            No → No action // 不符合目標，返回\n        No → Decision: 從 position 開始，嘗試擷取所有可能的數字片段\n            For each end from position+1 to len(num):\n                substring = num[position:end] // 取得目前片段\n                若 substring 以 '0' 為首且長度>1 → continue // 跳過有前導零的數字\n                num_val = int(substring)\n                若 position == 0? // 第一個數字\n                    → dfs(end, substring, num_val, num_val) // 直接進行下一步\n                Else:\n                    → dfs(end, expr + '+' + substring, current_value + num_val, num_val) // 加法\n                    → dfs(end, expr + '-' + substring, current_value - num_val, -num_val) // 減法\n                    → dfs(end, expr + '*' + substring, current_value - last_operand + last_operand * num_val, last_operand * num_val) // 乘法，調整 eval\n→ Call dfs(0, \"\", 0, 0) // 開始遞迴\n→ Return answer list // 輸出結果\nEnd // 程式結束\n\nBut we need arrow format: Use \"→\" to go to next step, and indent. Provide decision branches.\n\nAlso need to include variable declarations. Let's produce step-by-step pseudocode.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Read num, target // 取得輸入的字串與目標值\n→ Declare result = [] // 用於儲存所有符合條件的表達式\n\n→ Function dfs(index, expr, value, prev) // 定義遞迴函式\n    → Decision: 是否已走到字串末尾? // 判斷是否已處理完所有數字\n        Yes → Decision: value == target? // 檢查目前計算結果是否等於目標\n            Yes → result.append(expr) // 符合條件，加入結果集\n            No  → No action // 不符合，直接返回\n        No  → For end in range(index+1, len(num)+1): // 嘗試取從 index 開始的所有數字片段\n            → Substring = num[index:end] // 取子字串\n            → Decision: 子字串長度>1 且首字元為 '0'? // 判斷是否有前導零\n                Yes → Continue // 跳過該片段\n                No  → SubVal = int(Substring) // 轉為整數\n                → Decision: index == 0? // 是否是第一個數字\n                    Yes → dfs(end, Substring, SubVal, SubVal) // 第一個數字直接進入遞迴\n                    No  → // 之後的數字需考慮三種運算\n                        → dfs(end, expr + '+' + Substring, value + SubVal, SubVal) // 加法\n                        → dfs(end, expr + '-' + Substring, value - SubVal, -SubVal) // 減法\n                        → dfs(end, expr + '*' + Substring, value - prev + prev * SubVal, prev * SubVal) // 乘法：先抵消上一個乘法的影響，再加上新乘積\n\n→ Call dfs(0, \"\", 0, 0) // 從起始位置啟動遞迴\n→ Return result // 輸出所有符合的表達式\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index, path, value, last):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Try to parse \"num = \"123\", target = 6\" format\n    match = re.search(r'num\\s*=\\s*\"([^\"]*)\",\\s*target\\s*=\\s*(-?\\d+)', data)\n    if match:\n        num_str = match.group(1)\n        target_val = int(match.group(2))\n    else:\n        # Fallback: assume first line num, second line target\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            num_str = lines[0].strip()\n            target_val = int(lines[1].strip())\n        else:\n            # If only one line with space-separated values\n            parts = data.strip().split()\n            num_str = parts[0]\n            target_val = int(parts[1]) if len(parts) > 1 else 0\n\n    sol = Solution()\n    result = sol.addOperators(num_str, target_val)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1+2+3\",\"1*2*3\"]",
          "success": true,
          "output": "['1+2+3', '1*2*3']"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2+3*2\",\"2*3+2\"]",
          "success": true,
          "output": "['2+3*2', '2*3+2']"
        },
        {
          "example_index": 2,
          "input": "num = \"3456237490\", target = 9191",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode167.json",
    "problem_index_in_file": 0,
    "title": "Two Sum II - Input Array Is Sorted",
    "description_snippet": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with comments. Should describe two-pointer algorithm. Use Start, End, Decision, etc. Provide each step line by line. We'll include variables: left=1, right=n, target, numbers, result.\n\nImportant: Use 1-indexed array; but code uses 0-index? In virtual code, we might mention 1-index or use 0-index and adjust. We'll do 1-index to keep simple: left=1, right=length.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 left = 1, right = numbers.length // 設定左右指標\n\n→ Decision: 直到 left < right // 確保兩指標未交叉\n\n    Yes → Step 2: current_sum = numbers[left] + numbers[right] // 計算兩端數字之和\n\n    → Decision: current_sum 與 target 的關係\n\n        Yes → Step 3: 如果 current_sum 等於 target → Return [left, right] // 找到答案\n\n        No → Decision: current_sum 大於 target? // 判斷是否需要縮小右指標\n\n            Yes → Step 4: right = right - 1 // 右指標左移\n\n            No → Step 5: left = left + 1 // 左指標右移\n\n        End\n\n    End\n\nEnd // 程式執行結束\n\nWe need to add comments for each line. Use `//` after each line.\n\nAlso we need arrow lines like `→ Step 1: ... // ...`. Provide indentation maybe.\n\nLet's produce output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 left = 1, right = numbers.length // 設定左右指標，使用 1‑索引  \n→ Decision: left < right? // 只在兩指標未交叉時繼續  \n    Yes → Step 2: current_sum = numbers[left] + numbers[right] // 計算左、右兩端數字之和  \n    → Decision: current_sum == target? // 檢查是否已符合目標值  \n        Yes → Step 3: Return [left, right] // 找到唯一答案，直接返回  \n        No → Decision: current_sum > target? // 若和太大，需縮小右端  \n            Yes → Step 4: right = right - 1 // 右指標左移，減少和  \n            No → Step 5: left = left + 1 // 左指標右移，增加和  \n    End  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        # 兩指標法，時間 O(n)，空間 O(1)\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            s = numbers[left] + numbers[right]\n            if s == target:\n                # 回傳 1-indexed 索引\n                return [left + 1, right + 1]\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n        # 根據題目，必定有解，以下僅為安全返回\n        return []\n\ndef parse_input(input_str: str):\n    \"\"\"\n    從輸入字串中解析 numbers 列表與 target 整數。\n    預期輸入形如：numbers = [2,7,11,15], target = 9\n    \"\"\"\n    pattern = r'numbers\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, input_str)\n    if not match:\n        raise ValueError(\"Invalid input format\")\n    numbers_str, target_str = match.groups()\n    numbers = ast.literal_eval(numbers_str)  # 安全解析列表\n    target = int(target_str)\n    return numbers, target\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    input_data = sys.stdin.read().strip()\n    numbers, target = parse_input(input_data)\n\n    sol = Solution()\n    result = sol.twoSum(numbers, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "success": true,
          "output": "[1, 3]"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode682.json",
    "problem_index_in_file": 0,
    "title": "Baseball Game",
    "description_snippet": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. The task is to compute sum of scores from operations. Use stack or list. Steps: start, init stack, iterate operations, handle each case. After loop sum stack. End.\n\nNeed to use virtual code arrows and decision.\n\nWe must follow format: each line \"虛擬碼步驟 // 解釋\". Use \"→\" for flow. Let's produce.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化空陣列 record // 建立記錄\n→ For each op in operations: // 遍歷操作\n    → Decision: op 為 '+', 'D', 'C', 或 整數 // 判斷類型\n        Yes → ... need to differentiate. But we can create sub decisions.\n\nMaybe better: inside loop:\n\n    → Decision: op == '+'?\n        Yes → Step 2: sumPrev = record[-1] + record[-2] // 計算前兩分之和\n              → record.append(sumPrev) // 加入\n        No  → Decision: op == 'D'?\n            Yes → Step 3: doublePrev = record[-1] * 2 // 兩倍前分\n                  → record.append(doublePrev)\n            No  → Decision: op == 'C'?\n                Yes → Step 4: record.pop() // 刪除最後一分\n                No  → Step 5: record.append(int(op)) // 整數則直接加入\nAfter loop: Step 6: total = sum(record) // 計算總分\n→ End\n\nNeed to use arrow indent: Use indentation with spaces for nested decision? Format: \"→ Decision: ...\". Indent lines for nested actions? The example shows indentation with spaces for nested blocks. So we can use same style.\n\nWe need to maintain that each line has \"虛擬碼步驟\" and comment. Use \"Step X:\" etc.\n\nLet's produce. Ensure no actual code, just virtual.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空陣列 record // 建立空的得分記錄\n→ Step 2: 循環遍歷 operations // 逐一處理每個操作\n    → Decision: op 為 '+'? // 判斷是否為加總操作\n        Yes → Step 3: sumPrev = record[-1] + record[-2] // 取前兩分之和\n              → record.append(sumPrev) // 將新分數加入記錄\n        No  → Decision: op 為 'D'? // 判斷是否為翻倍操作\n            Yes → Step 4: doublePrev = record[-1] * 2 // 取前一分翻倍\n                  → record.append(doublePrev) // 加入新分數\n            No  → Decision: op 為 'C'? // 判斷是否為撤銷操作\n                Yes → Step 5: record.pop() // 移除最近的一分\n                No  → Step 6: record.append(int(op)) // 其餘為整數，直接加入\n→ Step 7: total = sum(record) // 計算所有分數之和\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef calculate_score(ops):\n    \"\"\"計算給定操作列表的最終總分。\"\"\"\n    stack = []\n    for op in ops:\n        if op == \"C\":\n            stack.pop()\n        elif op == \"D\":\n            stack.append(2 * stack[-1])\n        elif op == \"+\":\n            stack.append(stack[-1] + stack[-2])\n        else:\n            stack.append(int(op))\n    return sum(stack)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 取得列表字串（例如 'ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]' 或直接 '[...]'）\n    match = re.search(r'\\[.*\\]', raw_input)\n    if match:\n        ops_str = match.group(0)\n    else:\n        # 若沒有中括號，直接將整行當作列表字串處理\n        ops_str = raw_input\n\n    # 解析字串為真正的列表物件\n    ops = ast.literal_eval(ops_str)\n\n    # 計算結果並輸出\n    result = calculate_score(ops)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]",
          "expected_output": "30",
          "success": true,
          "output": "30"
        },
        {
          "example_index": 1,
          "input": "ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
          "expected_output": "27",
          "success": true,
          "output": "27"
        },
        {
          "example_index": 2,
          "input": "ops = [\"1\",\"C\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode981.json",
    "problem_index_in_file": 0,
    "title": "Time Based Key-Value Store",
    "description_snippet": "Design a time-based key-value data structure that can store multiple values for the same key at diff...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines step-by-step for implementing this data structure, with explanations. Use virtual code arrows, decisions. Provide code structure: Class TimeMap, constructor, set, get. For set: store mapping from key to list of (timestamp, value). For get: binary search to find latest <= timestamp. Use dictionary. Provide algorithm.\n\nNeed to produce step-by-step code lines with comments. Each line with \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows like →, Decision. Use Start, End. Provide maybe high-level steps: Initialize data structure, set method, get method. For get, we need to search in list. Represent list as array of pairs. Use binary search.\n\nWe need to be careful: The output format: each line is separate line. Use Start, End, Decision. Provide virtual code for whole class.\n\nMaybe format:\n\nStart // 程式開始\n→ Step: 定義類別 TimeMap // 定義資料結構\n→ Step: 建構子 TimeMap() // 初始化空字典\n→ Step: 設定 set 方法 // 以 key->list 存儲\n→ Step: 設定 get 方法 // 取值\n\nBut need to show internal steps: within set, append to list; within get, check if key exists, binary search.\n\nWe should produce more detailed lines.\n\nLet's produce:\n\nStart // 程式開始\n→ Step: 定義類別 TimeMap // 類別用於存儲時序鍵值\n→ Step: 成員變數 data: Map<String, List<Pair<int, String>>> // 每個 key 連結時間戳和值清單\n→ Step: TimeMap() // 建構子\n    → Step: 初始化 data 為空 HashMap // 空字典\n→ Step: set(String key, String value, int timestamp) // 存儲值\n    → Decision: data 是否包含 key? // 檢查 key 是否已存在\n        Yes → Step: 將 (timestamp, value) 加入 data[key] 清單 // 已有則追加\n        No  → Step: 建立新清單 [(timestamp, value)] 並加入 data // 新建\n→ Step: get(String key, int timestamp) // 取值\n    → Decision: data 是否包含 key? // 若無直接回傳 \"\"\n        Yes →\n            → Step: arr = data[key] // 取得時間戳清單\n            → Step: binary search arr 以找最大 <= timestamp // 找最近時間\n            → Decision: 是否找到有效索引? // 檢查是否有符合時間的項目\n                Yes → Step: 回傳 arr[索引].value // 回傳對應值\n                No  → Step: 回傳 \"\" // 無符合時間\n        No → Step: 回傳 \"\" // key 不存在\nEnd // 程式結束\n\nBut the instructions ask \"逐行產生對應的虛擬碼\" - each line should have arrow maybe? We should use arrow \"→\" for normal steps. For decision, indent inside. Use \"Yes →\" and \"No →\". Let's produce.\n\nBe careful: Use consistent indentation. For Decision we should indent. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義類別 TimeMap // 用於儲存時序鍵值資料結構  \n→ Step: 成員變數 data: Map<String, List<Pair<int, String>>> // key → 時間戳與值的有序清單  \n→ Step: TimeMap() // 建構子  \n    → Step: 初始化 data 為空 HashMap // 空字典  \n→ Step: set(String key, String value, int timestamp) // 存儲值  \n    → Decision: data 是否包含 key? // 檢查 key 是否已存在  \n        Yes → Step: data[key].append((timestamp, value)) // 已有則直接追加  \n        No  → Step: data[key] = [(timestamp, value)] // 新建清單並加入資料  \n→ Step: get(String key, int timestamp) // 取得值  \n    → Decision: data 是否包含 key? // 若無則直接回傳空字串  \n        Yes →  \n            → Step: arr = data[key] // 取得時間戳清單  \n            → Step: binarySearch(arr, timestamp) → idx // 找最大 ≤ timestamp 的索引  \n            → Decision: idx != -1? // 是否找到符合條件的項目  \n                Yes → Step: return arr[idx].value // 回傳對應值  \n                No  → Step: return \"\" // 無符合時間的值  \n        No  → Step: return \"\" // key 不存在  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\nimport bisect\n\nclass TimeMap:\n    def __init__(self):\n        self.store = defaultdict(list)\n\n    def set(self, key, value, timestamp):\n        self.store[key].append((timestamp, value))\n\n    def get(self, key, timestamp):\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # 找到第一個大於 timestamp 的位置\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i-1][1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入包成 tuple 以便一次解析\n    try:\n        ops, args = ast.literal_eval(f'({data})')\n    except Exception as e:\n        # 如果輸入格式不是兩個列表，直接結束\n        return\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            obj = TimeMap()\n            result.append(None)\n        elif op == \"set\":\n            obj.set(*arg)\n            result.append(None)\n        elif op == \"get\":\n            res = obj.get(*arg)\n            result.append(res)\n        else:\n            # 未知操作，跳過\n            result.append(None)\n\n    # 用 json.dumps 讓 None 轉成 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "success": true,
          "output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode31.json",
    "problem_index_in_file": 0,
    "title": "Next Permutation",
    "description_snippet": "A permutation of an array of integers is an arrangement of its members into a sequence or linear ord...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: next permutation in-place O(1) memory. Provide explanation each line. Use arrows. Provide Start, End. Provide Decision nodes.\n\nLet's outline steps:\n\n1. Start\n2. Find largest index i such that nums[i] < nums[i+1]; if none, reverse entire array.\n3. If found i, find largest index j > i such that nums[j] > nums[i].\n4. Swap nums[i] and nums[j].\n5. Reverse subarray nums[i+1:].\n6. End.\n\nProvide comments.\n\nWe must use arrow lines.\n\nUse indentation for nested decisions. Provide explanation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: i ← len(nums)-2 // 從倒數第二個元素開始\n→ Decision: 是否存在 nums[i] < nums[i+1]? // 檢查是否還有更大的排列\n    Yes → Step 2: 從 i+1 到末尾尋找最大 j 使 nums[j] > nums[i] // 找到比 nums[i] 大的最右元素\n        → Step 3: Swap nums[i] 和 nums[j] // 交換以獲得更大的排列\n        → Step 4: Reverse子陣列 nums[i+1:len(nums)] // 將後半段重新排列成最小升序\n        → End\n    No  → Step 5: Reverse整個陣列 nums[0:len(nums)] // 重新排序成最小升序\n        → End\n\nBut we need to express algorithm lines step-by-step; may separate loops for finding indices. Provide explanation.\n\nLet's produce more detailed lines:\n\nStart\n→ Step 1: i ← len(nums)-2 // 初始化指向倒數第二個元素\n→ Decision: nums[i] < nums[i+1]? // 判斷是否存在更大的排列\n    Yes → Step 2: While i>=0 and nums[i] >= nums[i+1] → i-- // 找到第一個下降點\n    No  → Step 3: Reverse(nums, 0, len(nums)-1) // 逆轉整個陣列\n        → End\nBut that's too many. Simpler.\n\nLet's just produce:\n\nStart\n→ Step 1: i ← len(nums)-2\n→ Decision: nums[i] < nums[i+1]? // 如果存在更大的排列\n    Yes → Step 2: i ← find_largest_index_smaller(nums, i) // 從後向前找到下降點\n    No  → Step 3: reverse(nums, 0, len(nums)-1) // 逆轉整體\n        → End\nBut need to produce virtual code lines. Maybe produce a more straightforward representation:\n\nStart\n→ Step 1: i ← len(nums)-2 // 準備從倒數第二個開始\n→ Decision: i ≥ 0 and nums[i] < nums[i+1]? // 是否還有更大排列？\n    Yes → Step 2: While i ≥ 0 and nums[i] ≥ nums[i+1] → i-- // 找到下降點\n    No  → Step 3: Reverse(nums, 0, len(nums)-1) // 重新排成升序\n        → End\n    Yes → Step 4: j ← len(nums)-1 // 從末尾開始尋找\n→ Decision: nums[j] ≤ nums[i]? // 找到比 nums[i] 大的元素\n    Yes → Step 5: j-- // 移動到更大的\n    No  → Step 6: Swap(nums[i], nums[j]) // 交換\n        → Step 7: Reverse(nums, i+1, len(nums)-1) // 逆轉後半\n        → End\n\nBut the algorithm: first find i: while i>=0 and nums[i] >= nums[i+1] i--. If i<0, reverse entire. Else find j: while nums[j] <= nums[i] j--. Swap, reverse suffix.\n\nLet's produce lines accordingly.\n\nWe must include explanation for each line.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ i ← len(nums)-2 // 從倒數第二個元素開始尋找下降點  \n→ Decision: i ≥ 0 and nums[i] < nums[i+1]? // 是否還存在更大的排列？  \n    Yes → Step 1: While i ≥ 0 and nums[i] ≥ nums[i+1] → i-- // 從右往左找到第一個下降點 i  \n    No  → Step 2: Reverse(nums, 0, len(nums)-1) // 逆轉整個陣列得到最小升序  \n        → End // 程式結束  \n    Yes → Step 3: j ← len(nums)-1 // 從最後一個元素開始尋找更大的元素 j  \n→ Decision: nums[j] ≤ nums[i]? // 找到比 nums[i] 大的最右元素？  \n    Yes → Step 4: j-- // 向左移動直到找到更大的元素  \n    No  → Step 5: Swap(nums[i], nums[j]) // 交換兩個元素  \n        → Step 6: Reverse(nums, i+1, len(nums)-1) // 逆轉 i 之後的子陣列得到最小升序  \n        → End // 程式結束\n\n說明：  \n- `Reverse(arr, start, end)` 代表把子陣列 `arr[start:end+1]` 反轉。  \n- `Swap(a, b)` 代表把兩個元素交換。  \n- 這個流程在原地完成下一個排列，並只使用常數額外記憶體。",
      "generated_code": "import sys\n\nclass Solution:\n    def nextPermutation(self, nums):\n        \"\"\"\n        改變 nums 為其字典序的下一個排列，若不存在則改為最小升序排列。\n        \"\"\"\n        n = len(nums)\n        # 1. 找到第一個下降點 i（從右往左）\n        i = n - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n\n        if i >= 0:\n            # 2. 在 i 右側找到比 nums[i] 大的最右元素 j\n            j = n - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            # 3. 交換 nums[i] 與 nums[j]\n            nums[i], nums[j] = nums[j], nums[i]\n\n        # 4. 將 i+1 到末尾的子陣列反轉，得到最小升序\n        left, right = i + 1, n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析可能的 'nums = [1,2,3]' 或僅 '[1,2,3]' 形式\n    try:\n        if '=' in raw_input:\n            _, arr_str = raw_input.split('=', 1)\n            nums = eval(arr_str.strip())\n        else:\n            nums = eval(raw_input)\n    except Exception as e:\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    Solution().nextPermutation(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1]",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,5]",
          "expected_output": "[1,5,1]",
          "success": true,
          "output": "[1, 5, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode678.json",
    "problem_index_in_file": 0,
    "title": "Valid Parenthesis String",
    "description_snippet": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is va...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps with explanation. We need to think of algorithm: we can use two counters leftMin and leftMax to track range of possible unmatched '(' count after processing each char, considering '*' as either '(', ')' or ''. At end return leftMin==0.\n\nSo produce Start, iterate each char, update counters, check conditions, Decision etc. Use arrow representation. Need step lines each with \"虛擬碼步驟\" then comment.\n\nLet's design:\n\nStart\n→ Step 1: 初始化 leftMin = 0, leftMax = 0 // range of unmatched '('\n→ Step 2: 迭代字符串 s 的每個字符 ch\n→ Decision: ch 為 '('?\n    Yes → leftMin++, leftMax++ // 兩邊都增加\n    No  → Decision: ch 為 ')'? \n        Yes → leftMin--, leftMax-- // 兩邊減\n        No  → // ch 為 '*'\n            leftMin-- // '*' 可作 ')', so min decrease\n            leftMax++ // '*' 可作 '(', so max increase\n→ Decision: leftMax < 0? // 若 max < 0，表示過多右括號\n    Yes → End False // 不合法\n    No  → // 正常\n→ Decision: leftMin < 0? // 若 min < 0，表示左括號不足，設為 0\n    Yes → leftMin = 0\n    No  →\n→ Step 3: 完成迭代\n→ End // 返回 leftMin == 0\n\nAlso need final check return leftMin == 0. But maybe integrate in final step. Let's produce.\n\nNeed to ensure every line has \"虛擬碼步驟\" then comment. Use arrow \"→\" after each step? The example uses \"→ Step X: ...\" lines. We'll follow same.\n\nWe need to output step by step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 leftMin = 0, leftMax = 0 // leftMin 為最小可能未配對左括號數，leftMax 為最大可能未配對左括號數\n→ Step 2: 針對 s 的每個字符 ch 進行迭代 // 逐字符處理字符串\n→ Decision: ch == '('? // 判斷是否為左括號\n    Yes → Step 3a: leftMin++, leftMax++ // 左括號都視為未配對\n    No  → Decision: ch == ')'?\n        Yes → Step 3b: leftMin--, leftMax-- // 右括號視為減少未配對\n        No  → // ch 為 '*'\n            Step 3c: leftMin-- // '*' 可以當作右括號，減少未配對\n            Step 3d: leftMax++ // '*' 可以當作左括號，增加未配對\n→ Decision: leftMax < 0? // 若最大未配對小於 0，表示右括號過多\n    Yes → End // 程式執行結束，結果為 False\n    No  → // 繼續\n→ Decision: leftMin < 0? // 若最小未配對小於 0，表示左括號不足，調整為 0\n    Yes → Step 4a: leftMin = 0\n    No  →\n→ Step 5: 完成所有字符的迭代 // 迴圈結束\n→ End // 程式執行結束，結果為 leftMin == 0\n\nBut we need return value. The final End line should indicate result true/false.\n\nBetter to have final check: Step 6: 返回 leftMin == 0 // 若最小未配對為 0，則有效\n\nLet's adjust: After Step 5, add Decision: leftMin == 0? // 最終判斷\n    Yes → End // 回傳 true\n    No  → End // 回傳 false\n\nBut the example only uses End. Let's do:\n\n→ Decision: leftMin == 0? // 判斷是否有效\n    Yes → End // 回傳 true\n    No  → End // 回傳 false\n\nBut need to indicate return value. Use comment.\n\nLet's produce final.\n\nMake sure each line has \"虛擬碼步驟\" or \"Start\"/\"End\" etc. Format: e.g. \"Start // 程式開始執行\". The steps start with arrow \"→\". So produce.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 leftMin = 0, leftMax = 0 // leftMin 為最小可能未配對左括號數，leftMax 為最大可能未配對左括號數  \n→ Step 2: 針對 s 的每個字符 ch 進行迭代 // 逐字符處理字符串  \n→ Decision: ch == '('? // 判斷是否為左括號  \n Yes → Step 3a: leftMin++, leftMax++ // 左括號都視為未配對  \n No → Decision: ch == ')'? // 判斷是否為右括號  \n  Yes → Step 3b: leftMin--, leftMax-- // 右括號視為減少未配對  \n  No → // ch 為 '*', 可視為左括號、右括號或空字串  \n   Step 3c: leftMin-- // '*' 當作右括號，減少未配對  \n   Step 3d: leftMax++ // '*' 當作左括號，增加未配對  \n→ Decision: leftMax < 0? // 若最大未配對小於 0，表示右括號過多  \n Yes → End // 程式執行結束，結果為 False  \n No → // 繼續處理  \n→ Decision: leftMin < 0? // 若最小未配對小於 0，表示左括號不足，調整為 0  \n Yes → Step 4a: leftMin = 0  \n No → // 仍保持當前值  \n→ Step 5: 完成所有字符的迭代 // 迴圈結束  \n→ Decision: leftMin == 0? // 判斷是否有效  \n Yes → End // 回傳 true  \n No → End // 回傳 false",
      "generated_code": "import sys\n\nclass Solution:\n    def checkValidString(self, s: str) -> bool:\n        \"\"\"\n        使用兩個計數器 low 與 high 來跟蹤可能的未配對左括號數。\n        low 代表最小可能未配對左括號數；high 代表最大可能未配對左括號數。\n        \"\"\"\n        low = 0   # 最少未配對的 '(' 數\n        high = 0  # 最多未配對的 '(' 數\n\n        for c in s:\n            if c == '(':\n                low += 1\n                high += 1\n            elif c == ')':\n                if low > 0:\n                    low -= 1\n                high -= 1\n            else:  # c == '*'\n                if low > 0:\n                    low -= 1\n                high += 1\n\n            # 如果 high 為負，表示右括號過多，無法合法配對\n            if high < 0:\n                return False\n\n        # 若最少未配對數為 0，則所有左括號都能配對成功\n        return low == 0\n\ndef parse_input(line: str) -> str:\n    \"\"\"\n    解析輸入行，支持兩種格式：\n    1. s = \"()\"\n    2. \"()\"\n    會移除外層引號（若有）並回傳純粹的字串。\n    \"\"\"\n    line = line.strip()\n    if '=' in line:\n        # 取等號右側作為字串\n        _, right = line.split('=', 1)\n        s = right.strip()\n    else:\n        s = line\n    # 移除可能的引號\n    if s and s[0] in ('\"', \"'\") and s[-1] == s[0]:\n        s = s[1:-1]\n    return s\n\ndef main() -> None:\n    # 從標準輸入讀取第一個非空行\n    raw_input = ''\n    for raw_input in sys.stdin:\n        if raw_input.strip():\n            break\n    if not raw_input:\n        return\n\n    s = parse_input(raw_input)\n    solution = Solution()\n    is_valid = solution.checkValidString(s)\n    print('true' if is_valid else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"(*)\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(*))\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode70.json",
    "problem_index_in_file": 0,
    "title": "Climbing Stairs",
    "description_snippet": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for computing number of ways to climb stairs. This is Fibonacci. So virtual steps: start, input n, maybe use dynamic programming. Should handle base cases: if n <= 1? Actually ways for n=1: 1, n=2:2. Use loop from 3 to n computing dp[i] = dp[i-1] + dp[i-2]. Then output dp[n]. Or recursion with memo.\n\nWe should produce step-by-step pseudocode. Each line with arrow \"→\". Should be structured with Start, End, Decision etc. Let's produce a straightforward DP.\n\nPseudo:\n\nStart\n→ Input n // get number of steps\n→ Decision: 如果 n <= 0? // check invalid\n    Yes → Step: 返回 0 // no ways\n    No → Decision: 如果 n == 1? // single step\n        Yes → Step: 返回 1 // only one way\n        No → Decision: 如果 n == 2? // two steps\n            Yes → Step: 返回 2 // two ways\n            No → Step: 初始化 prev1 = 1, prev2 = 2 // ways for step1, step2\n                 → Loop i from 3 to n // compute ways iteratively\n                     → Step: current = prev1 + prev2 // sum previous two\n                     → Step: prev1 = prev2 // shift\n                     → Step: prev2 = current\n                 → Step: 返回 prev2 // result for step n\nEnd\n\nMake sure each line uses \"→\" preceding step label. Provide explanation after //.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 從使用者處取得樓梯總階數  \n→ Decision: 如果 n <= 0? // 檢查階數是否為非正數  \n Yes → Step: 返回 0 // 無法爬上非正階數  \n No  → Decision: 如果 n == 1? // 單階情況  \n  Yes → Step: 返回 1 // 只有一種走法  \n  No  → Decision: 如果 n == 2? // 雙階情況  \n   Yes → Step: 返回 2 // 兩種走法  \n   No  → Step: 初始化 prev1 = 1, prev2 = 2 // 分別代表 n=1 與 n=2 的走法數  \n    → Loop i from 3 to n // 逐步計算從第三階到第 n 階  \n     → Step: current = prev1 + prev2 // 本階走法為前兩階走法之和  \n     → Step: prev1 = prev2 // 將 prev1 與 prev2 依序向前移動  \n     → Step: prev2 = current // 更新 prev2 為本階走法數  \n    → Step: 返回 prev2 // prev2 現在存的是第 n 階的走法數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef climb_stairs(n: int) -> int:\n    if n <= 0:\n        return 0\n    if n <= 2:\n        return n\n    first, second = 1, 2\n    for _ in range(3, n+1):\n        first, second = second, first + second\n    return second\n\ndef main():\n    data = sys.stdin.read()\n    # Try to extract the first integer from the input\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = climb_stairs(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode372.json",
    "problem_index_in_file": 0,
    "title": "Super Pow",
    "description_snippet": "Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large pos...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Problem: compute a^b mod 1337 where b is large given as array of digits (big integer). Classic modular exponent with exponent as array digits. Approach: use exponentiation by squaring with processing each digit. We can process exponent as number in base 10 digits: use algorithm: result=1; for each digit d in b: result = (result^10 mod M * a^d mod M) mod M. Precompute a_pow[d] for d 0-9: a_pow[d] = a^d mod M. Also maintain result = result^10 mod M. Use fast power for result^10 (but exponent 10 small). We can use repeated squaring or use powmod with exponent 10.\n\nAlso compute powmod(base, exp, mod) generic.\n\nWe need to produce virtual code lines.\n\nLet's produce:\n\nStart\n→ Step 1: 定義 M = 1337 // 模數\n→ Step 2: 讀取 a, b_array // a為正整數, b_array為b的十進位數字陣列\n→ Step 3: 先計算 a 的 0~9 次方模 M // 便於後續使用\n    → For d從0到9:\n        → SubStep: a_pow[d] = powmod(a, d, M) // 快速模指數\n→ Step 4: 初始化 result = 1 // 記錄 a^b mod M 的中間結果\n→ Step 5: 循環處理 b_array 的每一個數位 d\n    → Decision: 若為最後一個數位? // 這裡不需要特殊處理，可直接更新\n    → SubStep: result = powmod(result, 10, M) // 先將已計算部分提升到 10 次方\n    → SubStep: result = (result * a_pow[d]) mod M // 再乘上 a^d\n→ Step 6: 輸出 result // 最終答案\nEnd\n\nNeed to also include explanation after each line.\n\nAlso need to explain powmod function. Let's include separate steps for powmod.\n\nAdd:\n\n→ Step 7: 定義函式 powmod(base, exp, mod)\n    → SubStep: result = 1\n    → SubStep: while exp > 0:\n        → Decision: exp % 2 == 1 ?\n            Yes → result = (result * base) mod mod\n        → base = (base * base) mod mod\n        → exp = exp // 2\n    → Return result\n\nBut we need to ensure step ordering: We should define powmod before using it. So Step 7 earlier.\n\nAlso we need to ensure virtual code lines. Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: M ← 1337 // 定義模數  \n→ Step 2: 讀取 a, b_array // a 為正整數，b_array 為 b 的十進位數字陣列  \n→ Step 3: 定義函式 powmod(base, exp, mod) // 快速模指數輔助函式  \n    → SubStep: result ← 1  \n    → SubStep: while exp > 0 do  \n        → Decision: exp mod 2 = 1?  \n            Yes → result ← (result * base) mod mod // 若 exp 為奇數，乘上 base  \n            No → // 無需操作  \n        → base ← (base * base) mod mod // base 取平方  \n        → exp ← exp // 2 // 右移一位  \n    → SubStep: return result // 回傳模指數結果  \n→ Step 4: // 先計算 a 的 0~9 次方模 M，便於後續使用  \n    → For d from 0 to 9 do  \n        → SubStep: a_pow[d] ← powmod(a, d, M) // 預先算好 a^d mod M  \n→ Step 5: result ← 1 // 初始化中間結果  \n→ Step 6: // 逐位處理 b_array 中的每一個十進位數字 d  \n    → For each digit d in b_array do  \n        → SubStep: result ← powmod(result, 10, M) // 已計算部分提升到 10 次方  \n        → SubStep: result ← (result * a_pow[d]) mod M // 再乘上 a^d  \n→ Step 7: 輸出 result // 顯示最終的 a^b mod 1337  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nMOD = 1337\n\ndef powmod(base: int, exp: int, mod: int) -> int:\n    \"\"\"快速模指數，使用平方取指演算法。\"\"\"\n    result = 1\n    base %= mod\n    while exp > 0:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef super_pow(a: int, b_digits: list[int]) -> int:\n    \"\"\"計算 a^b mod 1337，其中 b 用數字陣列表示。\"\"\"\n    result = 1\n    for d in b_digits:\n        result = powmod(result, 10, MOD)          # 把已計算部分提升到 10 次方\n        result = (result * powmod(a, d, MOD)) % MOD  # 再乘上 a^d\n    return result\n\ndef main() -> None:\n    \"\"\"主程式：讀取輸入、計算並輸出結果。\"\"\"\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if not numbers:\n        return\n    a = numbers[0]\n    b_digits = numbers[1:]\n    answer = super_pow(a, b_digits)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 2, b = [3]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "success": true,
          "output": "1024"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode466.json",
    "problem_index_in_file": 0,
    "title": "Count The Repetitions",
    "description_snippet": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm to compute maximum m such that [s2,n2] repeated m times is a subsequence of [s1,n1] repeated n1 times. This is classic Leetcode problem \"Maximum Number of Repetitions\" problem 466? Actually 466. Approach: use cycle detection to compute how many s2 repeats per s1 block.\n\nPseudo: Count how many times s2 appears in one s1 block by scanning through s1 block and counting progress. Also detect cycle on index in s2 when iterating s1 blocks to speed up.\n\nSo produce steps with virtual code lines and comments. Each line with arrow.\n\nLet's produce step by step:\n\nStart\n→ Initialize variables: indexInS2=0, count=0, map={} // map to store seen indexInS2 to pair of (blockCount, count)\n\nThen loop blockCount from 1 to n1:\n  → if indexInS2 exists in map:\n       previousBlockCount, previousCount = map[indexInS2]\n       cycleBlock = blockCount - previousBlockCount\n       cycleCount = count - previousCount\n       remainingBlocks = n1 - blockCount +1? need careful: after current block, remainingBlocks = n1 - blockCount\n       fullCycles = remainingBlocks // cycleBlock\n       count += fullCycles * cycleCount\n       blockCount += fullCycles * cycleBlock\n   → for each char in s1:\n        if char == s2[indexInS2]:\n           indexInS2 +=1\n           if indexInS2 == len(s2):\n              indexInS2=0\n              count+=1\n   → store map[indexInS2] = (blockCount, count)\n\nAfter loop, answer = count // n2\n\nReturn answer.\n\nBut need to produce virtual code lines accordingly. Each line with explanation.\n\nWe must use arrow and Decision structure.\n\nLet's craft.\n\nRemember each line must have \"虛擬碼步驟 [space] // 解釋\". We'll use \"→\" for steps. Use \"Start\" and \"End\".\n\nAlso for decisions, we can embed. Use nested arrow indent.\n\nWe need to produce steps line by line.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Initialize indexInS2 = 0, count = 0, block = 0 // 追蹤在 s2 中的位置、已完成的 s2 次數與目前已處理的 s1 區塊數\n→ Create empty map: visited // 用於偵測 (indexInS2) 何時重複以找到週期\n\n→ Decision: block < n1? // 是否還有 s1 區塊要處理\n    Yes → block += 1 // 進入下一個 s1 區塊\n    No  → Jump to End // 所有區塊已處理\n\nBut we need to produce loops elegantly. Let's produce a loop.\n\nWe'll produce:\n\n→ While block < n1:\n      // Process next s1 block\n   -> Decision: indexInS2 in visited? // 週期偵測\n     Yes → ...\n     No  → ...\n\nOk.\n\nLet's produce.\n\nWe must maintain indentation. Provide each line separately.\n\nLet's craft final virtual code.\n\nAlso we need to ensure we don't produce actual code.\n\nOk. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set indexInS2 = 0, count = 0, block = 0 // indexInS2 追蹤在 s2 中的進度，count 計算已完成的 s2 次數，block 追蹤已處理的 s1 區塊  \n→ Create empty map visited // key: indexInS2，value: (block, count) 用於偵測週期  \n\n→ While block < n1: // 處理每個 s1 區塊  \n    → block += 1 // 進入新的 s1 區塊  \n    → Decision: indexInS2 in visited? // 週期偵測  \n        Yes →  \n            → (prevBlock, prevCount) = visited[indexInS2] // 取出之前相同位置的紀錄  \n            → cycleBlock = block - prevBlock // 週期的區塊長度  \n            → cycleCount = count - prevCount // 週期內完成的 s2 次數  \n            → remaining = n1 - block // 仍未處理的區塊數  \n            → fullCycles = remaining // cycleBlock // 多少個完整週期可跳過  \n            → count += fullCycles * cycleCount // 加上跳過週期所產生的 s2 次數  \n            → block += fullCycles * cycleBlock // 跳過這些區塊  \n        No →  \n            → visited[indexInS2] = (block, count) // 記錄此 indexInS2 的位置  \n\n    → For each char c in s1: // 在此 s1 區塊中搜尋 s2  \n        → Decision: c == s2[indexInS2]?  \n            Yes →  \n                → indexInS2 += 1 // 確認一個字符匹配  \n                → Decision: indexInS2 == len(s2)?  \n                    Yes →  \n                        → indexInS2 = 0 // s2 完成一次，重置為下一次搜尋  \n                        → count += 1 // 完成一次 s2  \n                    No →  \n                        // 繼續等待剩餘字符  \n            No →  \n                // 這個字符不匹配，直接跳過  \n\n→ End // 完成所有 s1 區塊的處理  \n\n→ result = count // n2 // 將完成的 s2 次數除以每個 str2 區塊需要的 s2 次數，得到最大 m  \n→ Return result // 輸出結果  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if n1 == 0:\n            return 0\n\n        index = 0          # current position in s2\n        s2_count = 0       # how many times s2 has been completed\n        s1_count = 0       # how many times s1 has been processed\n        recall = {}        # map from index to (s1_count, s2_count)\n\n        # Process s1 blocks until we either finish or detect a cycle\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n\n            if index in recall:\n                # Cycle detected\n                s1_prev, s2_prev = recall[index]\n                pre_loop_s1 = s1_prev\n                pre_loop_s2 = s2_prev\n                loop_s1 = s1_count - s1_prev\n                loop_s2 = s2_count - s2_prev\n                break\n            else:\n                recall[index] = (s1_count, s2_count)\n        else:\n            # No cycle, all s1 blocks processed\n            return s2_count // n2\n\n        # Use the cycle to fast‑forward\n        full_loops = (n1 - pre_loop_s1) // loop_s1\n        result = pre_loop_s2 + full_loops * loop_s2\n\n        # Process the remaining part after the last full cycle\n        rest = (n1 - pre_loop_s1) % loop_s1\n        rest_s2 = 0\n        rest_index = index\n        for _ in range(rest):\n            for ch in s1:\n                if ch == s2[rest_index]:\n                    rest_index += 1\n                    if rest_index == len(s2):\n                        rest_index = 0\n                        rest_s2 += 1\n        result += rest_s2\n\n        return result // n2\n\n\ndef parse_input(data: str):\n    \"\"\"Parse a line like: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\"\"\"\n    parts = [p.strip() for p in data.split(',')]\n    values = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = [x.strip() for x in part.split('=', 1)]\n        if val.startswith('\"') and val.endswith('\"'):\n            val = val[1:-1]\n        elif val.startswith(\"'\") and val.endswith(\"'\"):\n            val = val[1:-1]\n        else:\n            val = int(val)\n        values[key] = val\n    return values['s1'], values['n1'], values['s2'], values['n2']\n\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    s1, n1, s2, n2 = parse_input(raw)\n    sol = Solution()\n    print(sol.getMaxRepetitions(s1, n1, s2, n2))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode526.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement",
    "description_snippet": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm steps. Problem: count number of beautiful arrangements for n. Known as Leetcode 1353. Approach: backtracking with used array, recursion. We'll produce pseudocode step-by-step. Let's produce virtual code lines. We'll incorporate Start, End, Decision, steps, Yes, No. Provide simple algorithm: use recursion index i. Use boolean array used[n+1]. For each number j from 1 to n if not used and (j % i == 0 or i % j == 0) then mark used, recurse to i+1, accumulate count, then unmark. Return count. Complexity. Let's write pseudocode lines. Need to include explanation after each line. We'll structure as virtual code. Let's start. We'll add lines: Start, function definition, initialization, recursive function definition, base case, loop, condition, recursion, backtrack, result. Use decision with Yes/No for loops. We'll produce as required. Ensure each line has \" // 說明\". Use \"虛擬碼步驟\". For readability, we may denote lines as \"Step:\". Use arrow '→'. We'll use \"Decision:\" lines. We'll incorporate recursion function call. Let's produce.\n\nMake sure no actual code, just virtual steps. Provide explanation in Chinese. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義變數 n 為輸入整數 // 取得題目給定的 n  \n→ Step: 建立布林陣列 used[1..n] 全設 False // 標記每個數字是否已被使用  \n→ Step: 建立全域計數器 result = 0 // 用於累計滿足條件的排列數量  \n→ Step: 呼叫遞迴函式 dfs(i=1) // 從位置 1 開始嘗試排列  \n→ Function: dfs(i) // i 為目前要放置的索引位置  \n    → Decision: 如果 i > n? // 判斷是否已填完所有位置  \n        Yes → result = result + 1 // 成功完成一個美麗排列，計數加一  \n        No  → Decision: 遍歷 j 從 1 到 n? // 嘗試所有尚未使用的數字  \n            Yes → Decision: used[j] 為 False? // 此數字尚未被放置  \n                Yes → Decision: (j % i == 0) 或 (i % j == 0)? // 檢查美麗條件  \n                    Yes → Step: used[j] = True // 標記數字已使用  \n                    → Step: dfs(i + 1) // 進入下一個位置  \n                    → Step: used[j] = False // 回溯，取消使用標記  \n                    No  → // j 不符合條件，直接略過  \n                No  → // j 已被使用，略過  \n            No  → // j 為已使用數字，略過  \n→ End // 程式執行結束  \n→ Output: result // 回傳所有美麗排列的總數。",
      "generated_code": "import sys\n\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        used = [False] * (n + 1)\n        self.result = 0\n\n        def dfs(pos: int):\n            if pos > n:\n                self.result += 1\n                return\n            for num in range(1, n + 1):\n                if not used[num] and (num % pos == 0 or pos % num == 0):\n                    used[num] = True\n                    dfs(pos + 1)\n                    used[num] = False\n\n        dfs(1)\n        return self.result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    n = int(data)\n    sol = Solution()\n    print(sol.countArrangement(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode324.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Sort II",
    "description_snippet": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for reorder array into wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3]... Standard solution: iterate i from 0 to n-2, if i%2==0 then nums[i] > nums[i+1] swap else nums[i] < nums[i+1] swap. But careful: For wiggle sort: if i%2==0 (even index), need nums[i] < nums[i+1]; if it's not, swap. For odd index, need nums[i] > nums[i+1]; if not, swap.\n\nWe'll produce virtual steps.\n\nAlso mention assumption: array always has valid answer.\n\nWe need each line with virtual code + comment.\n\nLet's produce steps:\n\nStart // start\n→ Step 1: Let n = length of nums // get array size\n→ Step 2: For i from 0 to n-2 // iterate adjacent pairs\n    → Decision: If i is even? // check index parity\n        Yes → Decision: If nums[i] > nums[i+1]? // if current pair violates '<'\n            Yes → Step 3: Swap nums[i] and nums[i+1] // swap to satisfy\n            No → // no action\n        No  → Decision: If nums[i] < nums[i+1]? // for odd indices, need '>'\n            Yes → Step 4: Swap nums[i] and nums[i+1] // swap to satisfy\n            No → // no action\n→ End // finished\n\nWe need to provide each line separately. For loops and decisions, we need to show arrows.\n\nLet's format.\n\nAlso we may include the step numbers for clarity but not necessary.\n\nUse virtual code style: \"Start\", \"Step 1: ...\", \"Decision: ...\", \"Yes → ...\", \"No → ...\".\n\nWe'll provide each line. Let's do it.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = length(nums) // 取得陣列長度  \n→ Step 2: For i = 0 to n-2 // 遍歷相鄰兩個元素  \n    → Decision: i % 2 == 0? // 判斷索引是偶數還是奇數  \n        Yes → Decision: nums[i] > nums[i+1]? // 偶數位需 <，若大則不符  \n            Yes → Step 3: Swap(nums[i], nums[i+1]) // 交換以滿足 nums[i] < nums[i+1]  \n            No → // 已符合條件，無需操作  \n        No  → Decision: nums[i] < nums[i+1]? // 奇數位需 >，若小則不符  \n            Yes → Step 4: Swap(nums[i], nums[i+1]) // 交換以滿足 nums[i] > nums[i+1]  \n            No → // 已符合條件，無需操作  \n→ End // 程式執行結束",
      "generated_code": "import sys\n\ndef wiggle_sort(nums):\n    n = len(nums)\n    for i in range(n - 1):\n        if i % 2 == 0:\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            if nums[i] < nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 處理形如 \"nums = [1,5,1,1,6,4]\" 的輸入\n    try:\n        if '=' in data:\n            _, expr = data.split('=', 1)\n            nums = eval(expr.strip(), {})\n        else:\n            nums = eval(data.strip(), {})\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    wiggle_sort(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode32.json",
    "problem_index_in_file": 0,
    "title": "Longest Valid Parentheses",
    "description_snippet": "Given a string containing just the characters '(' and ')', return the length of the longest valid (w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for longest valid parentheses substring. Approach: use stack or DP. Use stack: push index of last unmatched '('? Actually push -1 initial. For each char, if '(' push index; else pop stack; if stack empty push current index; else length = i - stack.top(); maxlen = max.\n\nWe will produce virtual code lines with comments.\n\nWe must include Start, End. Use arrow arrows.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 初始化 stack with -1 // 用於計算長度\n→ Step 2: maxLen = 0 // 儲存最大長度\n→ Step 3: 循環遍歷字符串 s，索引 i 從 0 到 len(s)-1 // 遍歷每個字符\n    → Decision: 如果 s[i] 是 '('? // 判斷字符\n        Yes → Step 4: 推入 i 到 stack // '(' 進入堆疊\n        No  → Step 5: 從 stack 彈出一個元素 // ')', 先彈出匹配的 '('\n        → Decision: stack 是否為空? // 判斷是否還有匹配的開括號\n            Yes → Step 6: 推入 i 到 stack // 無匹配時把當前索引作為基準\n            No  → Step 7: currentLen = i - stack.top() // 以當前索引與最近未匹配的開括號計算長度\n                → Step 8: maxLen = max(maxLen, currentLen) // 更新最大長度\n→ End // 程式執行結束\n\nNeed to make sure the structure: use indentation for nested decisions.\n\nAdd \"Step\" naming. Let's produce as final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 stack 為 [-1] // 堆疊用於追蹤未匹配的 '(' 的索引，-1 作為基準點\n→ Step 2: maxLen ← 0 // 儲存目前為止找到的最長有效子字串長度\n→ Step 3: 循環遍歷字符串 s，索引 i 從 0 到 len(s)-1 // 逐字符處理\n    → Decision: 如果 s[i] 為 '('? // 判斷當前字符類型\n        Yes → Step 4: 將 i 推入 stack // '(' 進入堆疊，等待後續匹配\n        No  → Step 5: 從 stack 彈出一個元素 // 遇到 ')'，先嘗試匹配最近的 '('\n        → Decision: stack 是否為空? // 判斷是否已無可匹配的 '('\n            Yes → Step 6: 將 i 推入 stack // 無匹配時，以當前索引作為新的基準\n            No  → Step 7: currentLen ← i - stack.top() // 以最新未匹配的 '(' 的索引計算有效長度\n                → Step 8: maxLen ← max(maxLen, currentLen) // 更新最長長度\n→ End // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        stack = [-1]           # 初始化堆疊，-1 作為基準索引\n        max_len = 0\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)          # '(' 進堆疊，等待匹配\n            else:                         # char == ')'\n                if stack:\n                    stack.pop()          # 優先彈出最近的 '('\n                if not stack:\n                    stack.append(i)      # 沒有匹配的 '('，把當前索引作為基準\n                else:\n                    max_len = max(max_len, i - stack[-1])  # 計算有效長度\n        return max_len\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    解析輸入字串，支持兩種格式：\n    1. 直接輸入括號字串，例如 (()()\n    2. 格式為 s = \"(()\" 的字串\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return \"\"\n    # 若包含 's ='，則提取引號之間的內容\n    if 's' in raw and '=' in raw:\n        start = raw.find('\"')\n        end = raw.rfind('\"')\n        if start != -1 and end != -1 and start < end:\n            return raw[start + 1:end]\n    # 否則直接回傳原始字串\n    return raw\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = Solution().longestValidParentheses(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"(()\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \")()())\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode565.json",
    "problem_index_in_file": 0,
    "title": "Array Nesting",
    "description_snippet": "You are given an integer array nums of length n where nums is a permutation of the numbers in the ra...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The requirement: produce a step-by-step virtual code that solves the problem: find longest set s[k] length defined as following: starting at index k, repeatedly apply nums[] to get next index, adding elements to set until a duplicate occurs. Essentially we need to find longest cycle length in the permutation.\n\nThus algorithm: for each index not visited, traverse following chain, keep count length until repeat, update max. Use visited array to avoid recomputation. Complexity O(n).\n\nNow produce virtual code lines: Start, then initialization, then loop over i from 0 to n-1, decision if visited, else traverse chain: set count =0; current = i; while not visited[current], mark visited, increment count, current = nums[current]. After loop, update maxLen. End.\n\nWe need to output each line of virtual code with explanation comment after //.\n\nUse structure: Start // program start\n\n→ Step 1: Read input array nums // obtains array\n\n→ Step 2: n = length(nums) // get length\n\n→ Step 3: visited = array of n booleans set to false // visited flags\n\n→ Step 4: maxLen = 0 // store maximum set size\n\n→ Decision: For i from 0 to n-1? We need a loop; use Decision: if i < n? Actually we can use a loop construct but as virtual code we can express as Decision with Yes/No? The example uses Decision with Yes →. But loops can be represented as Decision with loop condition? We can do:\n\n→ Decision: i < n? // loop condition\n\nYes → Step: i = 0 // initialize index\n\nBut maybe better: use a loop structure like\n\n→ Decision: i < n? // while i < n\n\nYes → ... but we need to increment.\n\nMaybe we can represent loop like:\n\n→ Decision: i < n? // Iterate over indices\n\n    Yes → Step: if visited[i] continue to next\n\n    No  → End\n\nBut we need to increment i each iteration. Could use a \"Loop\" block? The spec doesn't mention loop block; only arrow and Decision. Could use Decision to simulate while loop: at end of loop, we set i = i + 1 and jump back.\n\nSimplify: use a higher-level \"For each index i in 0..n-1\" step. Represent as:\n\n→ Step 5: For i in 0 to n-1 // iterate indices\n\nBut the spec didn't mention For loops but we can still use a step description \"For i in 0 to n-1\".\n\nLet's adhere to spec: we can use Decision to check visited. So:\n\n→ Decision: visited[i]? // check visited\n\n    Yes → Step: i = i + 1 // skip visited\n\n    No  → Step: count = 0 // start new chain\n\n        Step: current = i // current pointer\n\n        Decision: visited[current]? // traverse\n\n            Yes → Step: maxLen = max(maxLen, count) // update max\n\n            No  → Step: visited[current] = true // mark visited\n\n                Step: count = count + 1 // increment count\n\n                Step: current = nums[current] // next\n\n                Decision: visited[current]? // loop again\n\nWe need to replicate loop; but this representation is messy.\n\nSimplify: Represent algorithm at high level: use while loop for traversal; but virtual code can show as:\n\n→ Step: While current < n and not visited[current] // traverse\n\nBut we need arrow.\n\nMaybe it's acceptable to use generic \"While\" construct. The spec didn't forbid it. They used Decision, but not exclusive. The sample uses Decision but not while. I think using While is okay.\n\nThus produce lines:\n\n→ Step 5: For i from 0 to n-1 // iterate over indices\n\n    → Decision: visited[i]? // skip if already visited\n\n        Yes → continue // skip to next i\n\n        No  → Step 6: count = 0 // reset length counter\n\n            Step 7: current = i // start index\n\n            → While not visited[current] // traverse chain\n\n                → Step 8: visited[current] = true // mark visited\n\n                → Step 9: count = count + 1 // increment size\n\n                → Step 10: current = nums[current] // move to next\n\n            End While\n\n            → Step 11: maxLen = max(maxLen, count) // update answer\n\nEnd For\n\nEnd // program end\n\nWe must output each line with explanation after //.\n\nWe also need to include the arrow lines. For For and While, we may use \"→\" to indicate steps inside loop. But the spec uses \"→\" at start of line, e.g., \"→ Step 1:\".\n\nThus:\n\nStart // 程式開始執行\n\n→ Step 1: Read array nums // 取得輸入的整數陣列\n\n→ Step 2: n = length(nums) // 取得陣列長度\n\n→ Step 3: visited = array of n booleans initialized to false // 標記是否已訪問\n\n→ Step 4: maxLen = 0 // 儲存目前最大的集合長度\n\n→ Step 5: For i = 0 to n-1 // 逐個索引遍歷\n\n    → Decision: visited[i]? // 若已訪問則跳過\n\n        Yes → Continue // 進入下一個 i\n\n        No  → Step 6: count = 0 // 新鏈路長度計數器\n\n            Step 7: current = i // 從索引 i 開始\n\n            → While not visited[current] // 迭代追蹤鏈路\n\n                → Step 8: visited[current] = true // 標記為已訪問\n\n                → Step 9: count = count + 1 // 集合大小加一\n\n                → Step 10: current = nums[current] // 移動到下一個索引\n\n            End While // 完成當前鏈路\n\n            → Step 11: maxLen = max(maxLen, count) // 更新最大長度\n\nEnd For\n\nEnd // 程式結束\n\nHowever, spec says we need \"Start\" and \"End\". Use \"Start\" at first line. Then each step uses \"→\". We must not use \"Continue\" maybe not allowed. We can use \"→ Step: i = i + 1\" but loop constructs are not explicit.\n\nBut we can simplify: use While loop for outer loop too. Provide \"While i < n\". Let's produce:\n\nStart\n\n→ Step 1: Read nums\n\n→ Step 2: n = length(nums)\n\n→ Step 3: visited = array of n booleans false\n\n→ Step 4: maxLen = 0\n\n→ Step 5: i = 0 // 初始化索引\n\n→ Decision: i < n? // 外層迴圈條件\n\n    Yes → Decision: visited[i]? // 是否已處理\n\n        Yes → Step 6: i = i + 1 // 跳過已訪問索引\n\n        No  → Step 7: count = 0 // 重新計數\n\n            Step 8: current = i // 開始鏈路\n\n            → While not visited[current] // 內部鏈路追蹤\n\n                → Step 9: visited[current] = true\n\n                → Step 10: count = count + 1\n\n                → Step 11: current = nums[current]\n\n            End While\n\n            → Step 12: maxLen = max(maxLen, count) // 更新答案\n\n            → Step 13: i = i + 1 // 進到下一個外層索引\n\n    No  → End // i >= n\n\nEnd\n\nBut spec expects each line \"虛擬碼步驟\" + \" // 解釋\". We need to keep \"Start\" \"End\".\n\nLet's finalize with such representation.\n\nEnsure we use \"Decision:\" lines with Yes and No branches each indented. Use \"→\" before each step inside.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Read nums // 取得輸入的整數陣列\n→ Step 2: n = length(nums) // 取得陣列長度\n→ Step 3: visited = array of n booleans initialized to false // 標記每個索引是否已被訪問\n→ Step 4: maxLen = 0 // 儲存目前最大的集合長度\n→ Step 5: i = 0 // 初始化外層索引\n→ Decision: i < n? // 是否還有索引需要處理\n    Yes → Decision: visited[i]? // 此索引是否已處理過\n        Yes → Step 6: i = i + 1 // 跳過已處理的索引，繼續下一個\n        No  → Step 7: count = 0 // 新鏈路長度計數器重置\n            Step 8: current = i // 從索引 i 開始追蹤鏈路\n            → While not visited[current] // 追蹤直到遇到重複為止\n                → Step 9: visited[current] = true // 標記當前索引已訪問\n                → Step 10: count = count + 1 // 集合大小加一\n                → Step 11: current = nums[current] // 移動到下一個索引\n            End While // 完成當前鏈路\n            → Step 12: maxLen = max(maxLen, count) // 更新最大長度\n            → Step 13: i = i + 1 // 進入下一個外層索引\n    No  → End // i >= n，全部索引已處理完畢\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport re\n\ndef array_nesting(nums):\n    \"\"\"回傳最大集合長度 s[k] 的長度。\"\"\"\n    visited = [False] * len(nums)\n    max_len = 0\n\n    for i in range(len(nums)):\n        if not visited[i]:\n            count = 0\n            cur = i\n            while not visited[cur]:\n                visited[cur] = True\n                cur = nums[cur]\n                count += 1\n            if count > max_len:\n                max_len = count\n    return max_len\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得輸入字串中的所有整數（允許負數）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    result = array_nesting(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,4,0,3,1,6,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode706.json",
    "problem_index_in_file": 0,
    "title": "Design HashMap",
    "description_snippet": "Design a HashMap without using any built-in hash table libraries.\n\nImplement the MyHashMap class:\n\nM...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The user wants design a HashMap without built-in hash table libraries. Implement MyHashMap class with constructor, put, get, remove.\n\nWe need to produce virtual code line by line with explanation.\n\nWe must not output actual code. Use virtual code steps: Start, Decision, etc.\n\nWe need to design a hash map, maybe using array of buckets with linked lists or dynamic arrays.\n\nWe'll describe initialization: define bucket size, array of linked lists.\n\nPut: compute hash, index, traverse bucket to find key, update or add.\n\nGet: compute hash, find, return value or -1.\n\nRemove: compute hash, find, remove.\n\nWe need to produce virtual code lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義常數 BUCKET_SIZE = 1000 // 數量為 1000\n→ Step 2: 創建 array buckets[BUCKET_SIZE] // 每個桶為鏈表\n\nand so on.\n\nWe need to include arrow and decision.\n\nWe must include '→' before each step. For decisions, use 'Decision:'.\n\nWe need to use 'Yes →' and 'No →'.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 BUCKET_SIZE = 1000 // 定義哈希表桶數\n→ Step 2: 初始化 buckets 為長度 BUCKET_SIZE 的空鏈表 // 每個桶存儲 (key, value) 項\n→ End // 初始化完成\n\nBut we need separate for each method? Maybe we produce generic virtual code for the class: constructor, put, get, remove.\n\nWe can break into sections:\n\nStart // MyHashMap 類初始化\n\n→ Step 1: Set up bucket array\n\n→ End // constructor done\n\nThen for put:\n\nStart // put(key, value)\n→ Step 1: compute hashIndex = hash(key) mod BUCKET_SIZE // 獲取桶索引\n→ Decision: bucket[hashIndex] 是否為空?\n    Yes → Step 2: 建立新的節點並插入 bucket[hashIndex] // 新增 (key, value)\n    No → Step 3: 遍歷 bucket[hashIndex] 以尋找 key\n        Yes → Step 4: 更新該節點的 value // key 已存在\n        No  → Step 5: 建立新節點並插入桶末尾 // key 不存在\n\nSimilarly for get and remove.\n\nWe need to use 'Decision:' and 'Yes →', 'No →'.\n\nMake sure each line has arrow or indentation.\n\nLet's produce the entire virtual code as sequence lines.\n\nNeed to be careful about indentation: In example, they used indentation with spaces for decision branches. We'll use similar.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // MyHashMap 類初始化\n→ Step 1: 定義常數 BUCKET_SIZE = 1000 // 設定哈希表桶數\n→ Step 2: 創建 buckets[BUCKET_SIZE] 為空鏈表陣列 // 每個桶用於存放 (key, value) 項\n→ End // 建構子完成\n\nStart // put(key, value)\n→ Step 1: 計算 hashIndex = hash(key) mod BUCKET_SIZE // 取得對應桶索引\n→ Decision: bucket[hashIndex] 是否為空?\n    Yes → Step 2: 建立新節點 (key, value) 並設為 bucket[hashIndex] 的 head // 新增項\n    No  → Step 3: 初始化 current = bucket[hashIndex]\n→ Step 4: Decision: current.key == key ?\n    Yes → Step 5: current.value = value // key 存在，更新值\n    No  → Step 6: current = current.next // 移到下一節點\n→ Step 7: Decision: current 為 null ?\n    Yes → Step 8: 建立新節點 (key, value) 並 append 到原 bucket 末尾 // key 不存在，追加\n    No  → 回到 Step 4 // 仍在遍歷中\n→ End // put 完成\n\nStart // get(key)\n→ Step 1: 計算 hashIndex = hash(key) mod BUCKET_SIZE // 取得對應桶索引\n→ Step 2: current = bucket[hashIndex]\n→ Step 3: Decision: current 為 null ?\n    Yes → Step 4: 返回 -1 // 桶為空，無此 key\n    No  → Step 5: Decision: current.key == key ?\n        Yes → Step 6: 返回 current.value // 找到 key，返回其值\n        No  → Step 7: current = current.next // 移到下一節點\n→ Step 8: 回到 Step 3 // 繼續搜尋\n→ End // get 完成\n\nStart // remove(key)\n→ Step 1: 計算 hashIndex = hash(key) mod BUCKET_SIZE // 取得對應桶索引\n→ Step 2: current = bucket[hashIndex]\n→ Step 3: previous = null\n→ Step 4: Decision: current 為 null ?\n    Yes → Step 5: 返回 // 桶為空，無需刪除\n    No  → Step 6: Decision: current.key == key ?\n        Yes → Step 7: If previous 為 null then bucket[hashIndex] = current.next else previous.next = current.next // 刪除節點\n        No  → Step 8: previous = current\n                current = current.next // 移到下一節點\n→ Step 9: 回到 Step 4 // 繼續搜尋\n→ End // remove 完成\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyHashMap:\n    def __init__(self):\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def put(self, key: int, value: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for idx, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket[idx] = (key, value)\n                return\n        bucket.append((key, value))\n\n    def get(self, key: int) -> int:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return -1\n\n    def remove(self, key: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for idx, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket.pop(idx)\n                return\n\nif __name__ == \"__main__\":\n    # 讀取兩行輸入：指令與對應參數\n    commands_line = sys.stdin.readline()\n    args_line = sys.stdin.readline()\n    if not commands_line or not args_line:\n        sys.exit()\n\n    commands = ast.literal_eval(commands_line.strip())\n    args_list = ast.literal_eval(args_line.strip())\n\n    results = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyHashMap\":\n            obj = MyHashMap()\n            results.append(None)\n        elif cmd == \"put\":\n            obj.put(args[0], args[1])\n            results.append(None)\n        elif cmd == \"get\":\n            val = obj.get(args[0])\n            results.append(val)\n        elif cmd == \"remove\":\n            obj.remove(args[0])\n            results.append(None)\n\n    # 將結果轉成符合 LeetCode 輸出格式的字串\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]",
          "expected_output": "[null, null, null, 1, -1, null, 1, null, -1]",
          "success": true,
          "output": "[null, null, null, 1, -1, null, 1, null, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode399.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Division",
    "description_snippet": "You are given an array of variable pairs equations and an array of real numbers values, where equati...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving equations division queries. This is typical LeetCode problem \"Evaluate Division\". Approach: build graph with adjacency weights, BFS/DFS queries. Steps: Build graph, then for each query perform DFS to find product path. Return -1 if not connected. Use adjacency map. Need to handle undefined variables. Virtual code lines.\n\nWe must output each line with \"虛擬碼步驟 // 解釋\". Use arrows etc. Ensure format like example.\n\nLet's design:\n\nStart\n→ Build adjacency graph: for each equation Ai/Bi = val, add Ai->Bi with val, Bi->Ai with 1/val\n→ For each query Cj, Dj:\n    Decision: Is Cj or Dj not in graph? // undefined\n        Yes → Output -1.0\n        No → Decision: Cj == Dj? // trivial\n            Yes → Output 1.0\n            No → Run DFS from Cj to Dj\n                Decision: DFS finds path?\n                    Yes → Output product\n                    No → Output -1.0\nEnd\n\nNeed to include step for DFS recursion stack. Represent as DFS: function search(current, target, visited, acc). Use stack or recursion. In virtual code, we can just represent as Step: DFS(current,target,visited,acc)\n\nWe don't output actual code, just virtual. Let's craft lines:\n\nStart\n→ Step 1: 建立圖形：對每個方程式 [Ai,Bi]，將 Ai → Bi 連線權重為 values[i]，Bi → Ai 連線權重為 1/values[i] // 建立雙向圖\n→ For each query [Cj,Dj] in queries:\n    Decision: 是否存在 Cj 或 Dj 於圖形中？ // 檢查變量是否已定義\n        Yes → Step 2: 回傳 -1.0 // 未定義變量\n        No  → Decision: Cj == Dj? // 同一變量\n            Yes → Step 3: 回傳 1.0 // 任何數除以自身\n            No  → Step 4: DFS 找路徑 Cj → Dj // 開始深度優先搜尋\n                Step 5: DFS(node, target, visited, acc)\n                    Decision: node == target? // 找到目標\n                        Yes → Step 6: 回傳 acc // 乘積即為答案\n                        No  → Decision: 所有鄰居未訪問？\n                            Yes → Step 7: 回傳 -1.0 // 無路徑\n                            No  → Decision: 任意鄰居 neighbour?\n                                Yes → Step 8: 設定 visited(neighbour)=true\n                                → Step 9: newAcc = acc * weight(node, neighbour)\n                                → Step 10: 呼叫 DFS(neighbour, target, visited, newAcc)\n                                → Decision: DFS 回傳非 -1.0?\n                                    Yes → Step 11: 回傳該值 // 直接傳遞上層\n                                    No  → Step 12: 繼續搜尋其他鄰居\n                    // 若所有鄰居皆處理完仍未找到，則回傳 -1.0\n    // 將查詢結果加入結果列表\nEnd\n\nBut we need each line separately. Let's break into lines.\n\nNeed to show arrow steps. Use \"→ Step X:\" etc. Use Decision indentation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化鄰接表 graph // 用來儲存變量之間的比例關係\n→ Decision: 為每個方程式 (Ai, Bi, val) 建立雙向連線？\n    Yes → Step 2: graph[Ai][Bi] = val, graph[Bi][Ai] = 1/val // 建立雙向邊\n    No  → // 只要處理完所有方程式即可\n→ Step 3: 建立結果列表 result // 儲存每個查詢的答案\n→ For 每個查詢 (Cj, Dj) in queries:\n    Decision: Cj 或 Dj 不在 graph? // 變量未定義\n        Yes → Step 4: append -1.0 to result // 無法計算\n        No  → Decision: Cj == Dj? // 同一變量\n            Yes → Step 5: append 1.0 to result // x/x = 1\n            No  → Step 6: 執行 DFS 以尋找從 Cj 到 Dj 的路徑 // 開始搜尋\n                → Step 7: 呼叫 DFS(Cj, Dj, visited=set(), acc=1.0)\n                // DFS 函式的虛擬實作\n                → Step 8: 定義 DFS(node, target, visited, acc)\n                    Decision: node == target? // 找到目標節點\n                        Yes → Step 9: 回傳 acc // 計算結果\n                        No  → Decision: 迴圈遍歷 graph[node] 的所有 neighbour\n                            Yes → Step 10: 若 neighbour 未被訪問\n                                → Step 11: 設 visited[neighbour] = true\n                                → Step 12: newAcc = acc * graph[node][neighbour]\n                                → Step 13: 回傳值 = DFS(neighbour, target, visited, newAcc)\n                                → Decision: 回傳值 != -1.0? // 找到有效路徑\n                                    Yes → Step 14: 回傳回傳值 // 結果傳遞上層\n                                    No  → Step 15: 繼續處理下一個 neighbour\n                            No  → // 所有 neighbour 已處理\n                    Decision: 所有 neighbour 處理完仍未找到目標？\n                        Yes → Step 16: 回傳 -1.0 // 無路徑\n                // DFS 完成\n                → Step 17: 如果 DFS 回傳值 != -1.0\n                    Yes → Step 18: append 回傳值 to result // 成功計算\n                    No  → Step 19: append -1.0 to result // 無法計算\n→ End // 程式結束\n\nBut we need each line as single line with \"虛擬碼步驟 // 解釋\". We must use arrow and indent accordingly? Example shows indentation inside Decision but each line separate. We can include indentation spaces for readability. Must keep one line per step. The arrow symbol and indentation maybe part of the step string. For Decision we can use \"Decision:\" with indentation. In example, Decision lines and Yes/No branches appear as separate lines with indentation. Each line includes the virtual step then comment. So we need to produce many lines. Let's produce.\n\nWe'll maintain consistent format: start with \"Start\", then each arrow line with \"→\". For Decision we write \"Decision:\" etc. For branches, indent with spaces maybe 4 spaces then \"Yes →\" etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化鄰接表 graph // 用來儲存變量之間的比例關係  \n→ Decision: 為每個方程式 (Ai, Bi, val) 建立雙向連線？  \n    Yes → Step 2: graph[Ai][Bi] = val, graph[Bi][Ai] = 1/val // 建立雙向邊  \n    No  → // 只要處理完所有方程式即可  \n→ Step 3: 建立結果列表 result // 儲存每個查詢的答案  \n→ For 每個查詢 (Cj, Dj) in queries:  \n    Decision: Cj 或 Dj 不在 graph? // 變量未定義  \n        Yes → Step 4: result.append(-1.0) // 無法計算  \n        No  → Decision: Cj == Dj? // 同一變量  \n            Yes → Step 5: result.append(1.0) // x/x = 1  \n            No  → Step 6: 執行 DFS 以尋找從 Cj 到 Dj 的路徑 // 開始搜尋  \n                → Step 7: 呼叫 DFS(Cj, Dj, visited=set(), acc=1.0)  \n                // DFS 函式的虛擬實作  \n                → Step 8: 定義 DFS(node, target, visited, acc)  \n                    Decision: node == target? // 找到目標節點  \n                        Yes → Step 9: 回傳 acc // 計算結果  \n                        No  → Decision: 迴圈遍歷 graph[node] 的所有 neighbour  \n                            Yes → Step 10: 若 neighbour 未被訪問  \n                                → Step 11: 設 visited[neighbour] = true  \n                                → Step 12: newAcc = acc * graph[node][neighbour]  \n                                → Step 13: 回傳值 = DFS(neighbour, target, visited, newAcc)  \n                                → Decision: 回傳值 != -1.0? // 找到有效路徑  \n                                    Yes → Step 14: 回傳回傳值 // 結果傳遞上層  \n                                    No  → Step 15: 繼續處理下一個 neighbour  \n                            No  → // 所有 neighbour 已處理  \n                    Decision: 所有 neighbour 處理完仍未找到目標？  \n                        Yes → Step 16: 回傳 -1.0 // 無路徑  \n                // DFS 完成  \n                → Step 17: 若 DFS 回傳值 != -1.0  \n                    Yes → Step 18: result.append(回傳值) // 成功計算  \n                    No  → Step 19: result.append(-1.0) // 無法計算  \n→ End // 程式結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef parse_input(data: str):\n    # Locate the three parts\n    eq_idx = data.find('equations =')\n    val_idx = data.find('values =')\n    qry_idx = data.find('queries =')\n\n    eq_part = data[eq_idx + len('equations ='):val_idx].strip()\n    val_part = data[val_idx + len('values ='):qry_idx].strip()\n    qry_part = data[qry_idx + len('queries ='):].strip()\n\n    # Remove trailing commas if any\n    if eq_part.endswith(','):\n        eq_part = eq_part[:-1]\n    if val_part.endswith(','):\n        val_part = val_part[:-1]\n    if qry_part.endswith(','):\n        qry_part = qry_part[:-1]\n\n    equations = ast.literal_eval(eq_part)\n    values = ast.literal_eval(val_part)\n    queries = ast.literal_eval(qry_part)\n    return equations, values, queries\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    equations, values, queries = parse_input(raw)\n    sol = Solution()\n    results = sol.calcEquation(equations, values, queries)\n    formatted = [f\"{x:.5f}\" for x in results]\n    print(f\"[{','.join(formatted)}]\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "success": true,
          "output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "success": true,
          "output": "[3.75000,0.40000,5.00000,0.20000]"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "success": true,
          "output": "[0.50000,2.00000,-1.00000,-1.00000]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode707.json",
    "problem_index_in_file": 0,
    "title": "Design Linked List",
    "description_snippet": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode. It's a design of MyLinkedList class with operations. We need to produce virtual code steps. We need to not produce actual code but pseudo steps. Each line must have \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows →, Decision:, Start, End.\n\nWe must design a singly linked list? Probably singly as simplest. Node has val, next. LinkedList has head, tail, size. Provide operations.\n\nWe need to output the virtual code for the whole implementation? Probably step-by-step algorithmic outline for each method. Let's produce the structure: Start, initialize list, then for each method: get, addAtHead, addAtTail, addAtIndex, deleteAtIndex. Use Decision steps. Let's produce pseudocode with operations.\n\nWe need to be careful: each line has a step. For methods, we need to show steps inside. Possibly use indentation with spaces. The arrow indicates next step. Use \"Decision:\" for if statements. Let's produce final output.\n\nWe need to include \"Start\" and \"End\" at the very beginning and end? The requirement: \"Start // 程式開始執行\". But since this is a class definition, maybe Start before class definition, End after class. But it's okay.\n\nWe need to use the arrow for each step. Let's produce:\n\nStart\n→ Step 1: Define Node with attributes val, next // Node structure\n→ Step 2: Define MyLinkedList class with head = null, tail = null, size = 0 // Initialize list\nNow methods.\n\nMethod MyLinkedList() // constructor\n→ Step 3: Set head = null // list empty\n→ Step 4: Set tail = null\n→ Step 5: Set size = 0\n\nMethod get(index)\n→ Step 6: If index < 0 or index >= size → Return -1 // invalid\n→ Decision: Index valid?\n   Yes → Step 7: node = head // start traversal\n   → Step 8: repeat index times: node = node.next // move forward\n   → Step 9: Return node.val\n   No → Step 10: Return -1\n\nMethod addAtHead(val)\n→ Step 11: Create newNode with val\n→ Step 12: newNode.next = head // point to old head\n→ Decision: size == 0?\n    Yes → Step 13: tail = newNode // first node also tail\n    No  → Step 14: // nothing special\n→ Step 15: head = newNode // new node becomes head\n→ Step 16: size++ // increment size\n\nMethod addAtTail(val)\n→ Step 17: Create newNode with val\n→ Decision: size == 0?\n    Yes → Step 18: head = newNode // first node\n    No  → Step 19: tail.next = newNode // link after current tail\n→ Step 20: tail = newNode // update tail\n→ Step 21: size++\n\nMethod addAtIndex(index, val)\n→ Step 22: If index < 0 or index > size → Return // no insertion\n→ Decision: index == 0?\n    Yes → Step 23: addAtHead(val) // reuse method\n    No  → Decision: index == size?\n        Yes → Step 24: addAtTail(val)\n        No  → Step 25: node = head\n              Step 26: repeat index-1 times: node = node.next // node before insertion\n              Step 27: newNode = new Node(val)\n              Step 28: newNode.next = node.next\n              Step 29: node.next = newNode\n              Step 30: size++\n\nMethod deleteAtIndex(index)\n→ Step 31: If index < 0 or index >= size → Return // invalid\n→ Decision: index == 0?\n    Yes → Step 32: head = head.next // remove head\n          Decision: size == 1?\n             Yes → Step 33: tail = null // list becomes empty\n             No  → Step 34: // nothing\n    No  → Step 35: node = head\n          Step 36: repeat index-1 times: node = node.next // node before target\n          Step 37: node.next = node.next.next // bypass target\n          Decision: index == size-1?\n             Yes → Step 38: tail = node // new tail\n             No  → Step 39: // nothing\n→ Step 40: size-- // decrement size\n\nEnd\n\nWe need to put arrows before each step. Use \"→\". Use indentation maybe. Ensure each line ends with comment after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define Node with attributes val, next // Node 只包含值與下一節點指標  \n→ Step 2: Define MyLinkedList class with head = null, tail = null, size = 0 // 初始化連結串列  \n→ Step 3: Constructor MyLinkedList() // 建構子  \n→ Step 4: Set head = null // 空串列的頭指標  \n→ Step 5: Set tail = null // 空串列的尾指標  \n→ Step 6: Set size = 0 // 數量為 0  \n\n→ Step 7: Method get(index) // 取得第 index 個節點的值  \n→ Step 8: If index < 0 or index >= size → Return -1 // 索引無效  \n→ Decision: Index valid?  \n    Yes → Step 9: node = head // 從頭開始遍歷  \n    → Step 10: repeat index times: node = node.next // 移動到目標節點  \n    → Step 11: Return node.val // 回傳值  \n    No → Step 12: Return -1  \n\n→ Step 13: Method addAtHead(val) // 在頭部新增節點  \n→ Step 14: Create newNode with val // 建立新節點  \n→ Step 15: newNode.next = head // 指向舊頭  \n→ Decision: size == 0?  \n    Yes → Step 16: tail = newNode // 第一個節點同時為尾節點  \n    No  → Step 17: // 無需處理  \n→ Step 18: head = newNode // 新節點成為頭節點  \n→ Step 19: size++ // 數量加 1  \n\n→ Step 20: Method addAtTail(val) // 在尾部新增節點  \n→ Step 21: Create newNode with val  \n→ Decision: size == 0?  \n    Yes → Step 22: head = newNode // 第一個節點成為頭  \n    No  → Step 23: tail.next = newNode // 尾節點指向新節點  \n→ Step 24: tail = newNode // 更新尾指標  \n→ Step 25: size++  \n\n→ Step 26: Method addAtIndex(index, val) // 在指定索引前新增節點  \n→ Step 27: If index < 0 or index > size → Return // 不插入  \n→ Decision: index == 0?  \n    Yes → Step 28: addAtHead(val) // 直接新增在頭  \n    No  → Decision: index == size?  \n        Yes → Step 29: addAtTail(val) // 新增在尾  \n        No  → Step 30: node = head // 找到前一節點  \n              Step 31: repeat index-1 times: node = node.next // 往前走 index-1 步  \n              Step 32: newNode = new Node(val) // 建立新節點  \n              Step 33: newNode.next = node.next // 指向原本的下一節點  \n              Step 34: node.next = newNode // 插入新節點  \n              Step 35: size++ // 數量加 1  \n\n→ Step 36: Method deleteAtIndex(index) // 刪除指定索引的節點  \n→ Step 37: If index < 0 or index >= size → Return // 索引無效  \n→ Decision: index == 0?  \n    Yes → Step 38: head = head.next // 移除頭節點  \n          Decision: size == 1?  \n             Yes → Step 39: tail = null // 空串列  \n             No  → Step 40: // 無需處理  \n    No  → Step 41: node = head // 找到前一節點  \n          Step 42: repeat index-1 times: node = node.next // 前往目標前的節點  \n          Step 43: node.next = node.next.next // 跳過目標節點  \n          Decision: index == size-1?  \n             Yes → Step 44: tail = node // 更新尾指標  \n             No  → Step 45: // 無需處理  \n→ Step 46: size-- // 數量減 1  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyLinkedList:\n    class Node:\n        def __init__(self, val=0):\n            self.val = val\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def get(self, index):\n        if index < 0 or index >= self.size:\n            return -1\n        curr = self.head\n        for _ in range(index):\n            curr = curr.next\n        return curr.val\n\n    def addAtHead(self, val):\n        node = self.Node(val)\n        node.next = self.head\n        self.head = node\n        if self.size == 0:\n            self.tail = node\n        self.size += 1\n\n    def addAtTail(self, val):\n        node = self.Node(val)\n        if self.size == 0:\n            self.head = node\n            self.tail = node\n        else:\n            self.tail.next = node\n            self.tail = node\n        self.size += 1\n\n    def addAtIndex(self, index, val):\n        if index < 0 or index > self.size:\n            return\n        if index == 0:\n            self.addAtHead(val)\n        elif index == self.size:\n            self.addAtTail(val)\n        else:\n            node = self.Node(val)\n            curr = self.head\n            for _ in range(index - 1):\n                curr = curr.next\n            node.next = curr.next\n            curr.next = node\n            self.size += 1\n\n    def deleteAtIndex(self, index):\n        if index < 0 or index >= self.size:\n            return\n        if index == 0:\n            self.head = self.head.next\n            if self.size == 1:\n                self.tail = None\n        else:\n            curr = self.head\n            for _ in range(index - 1):\n                curr = curr.next\n            curr.next = curr.next.next\n            if index == self.size - 1:\n                self.tail = curr\n        self.size -= 1\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip())\n\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyLinkedList\":\n            obj = MyLinkedList()\n            result.append(None)\n        elif op == \"addAtHead\":\n            obj.addAtHead(arg[0])\n            result.append(None)\n        elif op == \"addAtTail\":\n            obj.addAtTail(arg[0])\n            result.append(None)\n        elif op == \"addAtIndex\":\n            obj.addAtIndex(arg[0], arg[1])\n            result.append(None)\n        elif op == \"get\":\n            res = obj.get(arg[0])\n            result.append(res)\n        elif op == \"deleteAtIndex\":\n            obj.deleteAtIndex(arg[0])\n            result.append(None)\n        else:\n            result.append(None)\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]",
          "expected_output": "[null, null, null, null, 2, null, 3]",
          "success": true,
          "output": "[null, null, null, null, 2, null, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode481.json",
    "problem_index_in_file": 0,
    "title": "Magical String",
    "description_snippet": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to compute number of 1's in first n numbers of magical string s. It's similar to LeetCode 320. Approach: generate magical string up to n. Maintain count of ones. Use two pointers: idx to read current value (1 or 2) and cnt to append that many same numbers. While length < n, we read current value from s, number of times to append it (value), append that many to s. Keep count of ones added. After loop, return count of ones up to n (maybe trimmed). Need to output virtual code line by line with explanation.\n\nWe'll produce steps: Start, initialize array s with [1,2,2], countOnes=1, index=2 (next to read), while s.length < n, read val = s[index], for i=0; i<val; i++: append val to s; if val==1 countOnes++; then index++; end loop. After loop, if s.length>n, maybe we don't care because we appended until >=n. We might need to trim count to first n. But since we appended until >=n, countOnes may include extra beyond n; we can adjust: subtract ones added beyond n. Simplest: after loop, if s.length>n, we need to check last appended group length and subtract extra ones. Implementation details: we can maintain current length, but virtual code fine.\n\nWe'll produce pseudocode with steps: Start, initialize variables, while loop, inside loop: read value, loop append, update count, increment index. After loop: if s.length>n, adjust count. Return countOnes. End.\n\nAlso handle n<3? For small n: we can slice s to n and count ones. But algorithm covers.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 s = [1, 2, 2] // 第三個元素固定為 2，開始產生魔法字串\n→ Step 2: 初始化 countOnes = 1 // s 中已經有一個 1\n→ Step 3: 初始化 index = 2 // 從 s[2] 開始讀取下一個需要重複的數值\n→ Decision: 只要 s.length < n? // 檢查還沒生成到 n 個數字\n    Yes → Step 4: val = s[index] // 取得當前要重複的數字 (1 或 2)\n    → Step 5: for i = 0 to val-1\n        → Step 5a: append val 到 s // 把 val 重複 val 次加入 s\n        → Step 5b: 如果 val == 1 → countOnes++ // 只計算 1 的個數\n    → Step 6: index++ // 移到下一個要讀取的位置\n    → Step 7: 回到 Decision: 只要 s.length < n? // 重新判斷是否還需繼續生成\n    No → Decision: s.length > n? // 生成的字串可能超過 n，需調整\n        Yes → Step 8: 剩餘 = s.length - n // 多生成的個數\n        → Step 9: 從 s[n-1] 開始倒數，找到這些多生成的元素\n            → Step 9a: 如果多生成的元素為 1 → countOnes-- // 將超出的 1 減去\n        No → Step 10: // s 恰好長度為 n，無需調整\n→ Step 11: return countOnes // 回傳前 n 個數字中 1 的總數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef magical_string_one_count(n: int) -> int:\n    \"\"\"Return the number of '1's in the first n elements of the magical string.\"\"\"\n    if n == 0:\n        return 0\n\n    # 初始化魔法字串 s 為 [1, 2, 2]\n    s = [1, 2, 2]\n    head = 2          # 讀取下一個需要重複的數值的位置\n    num = 1           # 下一個要加入的數值（1 或 2）\n\n    # 持續生成字串直到長度至少為 n\n    while len(s) < n:\n        repeat_times = s[head]          # 這次要重複 num 的次數\n        s.extend([num] * repeat_times) # 把 num 重複 repeat_times 次加入 s\n        num ^= 3                        # 1 ↔ 2 的切換\n        head += 1\n\n    # 只計算前 n 個元素中的 1\n    return s[:n].count(1)\n\n\nif __name__ == \"__main__\":\n    # 讀取輸入，允許輸入類似 \"n = 6\" 或單獨的數字\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    result = magical_string_one_count(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode200.json",
    "problem_index_in_file": 0,
    "title": "Number of Islands",
    "description_snippet": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation. The user is requesting algorithm: number of islands in a 2D grid. Should use DFS or BFS. We'll produce a virtual code that iterates through grid, when find '1', increment count, do DFS to mark visited. Use a stack or recursion. Provide step-by-step virtual code.\n\nWe need to adhere to format: Each line: `虛擬碼步驟 // 解釋`. Use Start, End, Decision, etc. Use arrows →.\n\nWe should produce \"Start // 程式開始執行\" then \"→ Step 1: 初始化 count 為 0 // ...\", etc. Use \"Decision:\" lines for condition checks.\n\nLet's produce something like:\n\nStart\n→ Step 1: 取得 grid 维度 m, n // get dimensions\n→ Step 2: 建立 visited 二維布林陣列 (m x n) 全 False // visited map\n→ Step 3: 初始化 islands 為 0 // count islands\n→ Step 4: 循環 i 0 到 m-1 // iterate rows\n    → Step 5: 循環 j 0 到 n-1 // iterate cols\n        → Decision: 若 grid[i][j] == '1' 且未訪問？ // check if land and not visited\n            Yes → Step 6: islands += 1 // 新島，計數加一\n            Yes → Step 7: DFS(i, j) // 標記整個島\n            No  → // 跳過\n→ Step 8: 回傳 islands // 結果\n\nDFS function pseudo:\n→ Step 9: Function DFS(r, c):\n    → Decision: 若 r<0 或 r>=m 或 c<0 或 c>=n 或 grid[r][c] == '0' 或 visited[r][c] == True → Return // out of bounds or water or visited\n    → Step 10: visited[r][c] = True // 標記已訪問\n    → Step 11: DFS(r-1, c) // 上\n    → Step 12: DFS(r+1, c) // 下\n    → Step 13: DFS(r, c-1) // 左\n    → Step 14: DFS(r, c+1) // 右\n→ End // 程式結束\n\nWe need to format lines accordingly. Use \"→\" arrow before each step.\n\nMake sure to include indentation? The example uses indent for nested lines. We'll replicate same style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 grid 之 m, n // 取得矩陣的行列數  \n→ Step 2: 建立 visited 二維布林陣列 (m x n) 全 False // 標記每格是否已掃描  \n→ Step 3: 初始化 islands 為 0 // 記錄島嶼數量  \n→ Step 4: 循環 i 0 到 m-1 // 逐行遍歷  \n  → Step 5: 循環 j 0 到 n-1 // 逐列遍歷  \n    → Decision: 若 grid[i][j] == '1' 且未訪問？ // 判斷是否為未掃描的陸地  \n      Yes → Step 6: islands += 1 // 發現新島，計數+1  \n      Yes → Step 7: DFS(i, j) // 從此格遞迴掃描整座島  \n      No  → // 不是未掃描的陸地，直接跳過  \n→ Step 8: 回傳 islands // 返回總島嶼數  \n→ Step 9: Function DFS(r, c): // DFS 子程序  \n    → Decision: 若 r<0 或 r>=m 或 c<0 或 c>=n 或 grid[r][c] == '0' 或 visited[r][c] == True → Return // 超出邊界或水域或已訪問，終止  \n    → Step 10: visited[r][c] = True // 標記此格已訪問  \n    → Step 11: DFS(r-1, c) // 向上遞迴  \n    → Step 12: DFS(r+1, c) // 向下遞迴  \n    → Step 13: DFS(r, c-1) // 向左遞迴  \n    → Step 14: DFS(r, c+1) // 向右遞迴  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numIslands(self, grid):\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return\n            if grid[i][j] == '0' or visited[i][j]:\n                return\n            visited[i][j] = True\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    dfs(i, j)\n                    count += 1\n        return count\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Remove a leading variable assignment if present\n    if data.startswith(\"grid\"):\n        _, _, expr = data.partition(\"=\")\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # Safely evaluate the expression to get the grid\n    try:\n        grid = ast.literal_eval(expr)\n    except Exception:\n        # If parsing fails, exit silently\n        sys.exit(1)\n\n    # Ensure grid elements are strings of \"0\" or \"1\"\n    if isinstance(grid, list) and all(isinstance(row, list) for row in grid):\n        solution = Solution()\n        result = solution.numIslands(grid)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode762.json",
    "problem_index_in_file": 0,
    "title": "Prime Number of Set Bits in Binary Representation",
    "description_snippet": "Given two integers left and right, return the count of numbers in the inclusive range [left, right] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines. We have to respond in Traditional Chinese. Each line: virtual code step + space + // explanation. Use arrows and structure. Should not produce actual code.\n\nWe need algorithm: iterate from left to right inclusive, count bits, check if count is prime. Count primes. So need function to count bits, check prime. Could precompute primes up to 32 bits maybe. Use while loop.\n\nLet's produce pseudo lines:\n\nStart\n→ Step 1: 初始化變數 result = 0 // 結果計數\n→ Step 2: 為 i 從 left 到 right 執行循環 // 遍歷範圍\n    → Step 2.1: 計算 i 的 setBits = countSetBits(i) // 計數1位數\n    → Step 2.2: 判斷 setBits 是否為質數 // 判斷質數\n        Yes → Step 2.2a: result += 1 // 若質數，結果加一\n    → Step 2.3: (可選) 進行下個 i\n→ Step 3: 返回 result // 回傳計數\nEnd\n\nNeed to include countSetBits and isPrime functions:\n\nDefine function countSetBits(num):\n    setBits = 0\n    while num > 0:\n        setBits += num & 1\n        num = num >> 1\n    return setBits\n\nDefine function isPrime(n):\n    if n < 2: return false\n    for d from 2 to sqrt(n):\n        if n % d == 0: return false\n    return true\n\nAlso maybe precompute primes up to 32. But include generic.\n\nLet's craft steps accordingly.\n\nWe need to use virtual code arrow arrows: Start, End, Decision:.\n\nSo we can produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 result = 0 // 初始化結果計數\n→ Step 2: 定義函式 countSetBits(num) // 計算 set bits\n    → Step 2.1: setBits = 0\n    → Step 2.2: Decision: 若 num > 0? // 循環直到 num 為 0\n        Yes → Step 2.2a: setBits += num & 1 // 加上最低位\n        Yes → Step 2.2b: num = num >> 1 // 右移一位\n        Yes → Step 2.2c: 返回 setBits // 迴圈結束後回傳\n    → Step 2.3: End // 函式結束\n→ Step 3: 定義函式 isPrime(n) // 判斷質數\n    → Step 3.1: Decision: 若 n < 2? // 小於 2 為非質數\n        Yes → Step 3.1a: 返回 false\n    → Step 3.2: for d = 2 to floor(sqrt(n))\n        → Step 3.2a: Decision: 若 n % d == 0? // 找到因數\n            Yes → Step 3.2a1: 返回 false\n    → Step 3.3: 返回 true // 所有檢查通過\n→ Step 4: Decision: 若 left <= right? // 確保範圍合法\n    Yes → Step 4a: for i = left to right\n        → Step 4a1: setBits = countSetBits(i) // 取得 set bits\n        → Step 4a2: Decision: 若 isPrime(setBits)? // 檢查質數\n            Yes → Step 4a2a: result += 1 // 質數則計數\n    No → Step 4b: result = 0 // 若範圍無效，計數為 0\n→ Step 5: 返回 result // 輸出最終計數\nEnd // 程式結束\n\nWe need to ensure format: each line includes virtual code + space + // explanation. For indentation, maybe spaces before arrow? Use the arrow '→' for steps, 'Decision:' lines. Each line separate. Ensure no actual code.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 result = 0 // 初始化結果計數  \n→ Step 2: 定義函式 countSetBits(num) // 計算 set bits  \n&nbsp;&nbsp;→ Step 2.1: setBits = 0 // 初始化計數  \n&nbsp;&nbsp;→ Step 2.2: Decision: 若 num > 0? // 循環直到 num 為 0  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.2a: setBits += num & 1 // 加上最低位  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.2b: num = num >> 1 // 右移一位  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step 2.2c: 返回 setBits // 迴圈結束後回傳  \n&nbsp;&nbsp;→ Step 2.3: End // 函式結束  \n→ Step 3: 定義函式 isPrime(n) // 判斷質數  \n&nbsp;&nbsp;→ Step 3.1: Decision: 若 n < 2? // 小於 2 為非質數  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3.1a: 返回 false  \n&nbsp;&nbsp;→ Step 3.2: for d = 2 to floor(sqrt(n))  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.2a: Decision: 若 n % d == 0? // 找到因數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3.2a1: 返回 false  \n&nbsp;&nbsp;→ Step 3.3: 返回 true // 所有檢查通過  \n→ Step 4: Decision: 若 left <= right? // 確保範圍合法  \n&nbsp;&nbsp;Yes → Step 4a: for i = left to right  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4a1: setBits = countSetBits(i) // 取得 set bits  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4a2: Decision: 若 isPrime(setBits)? // 檢查質數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4a2a: result += 1 // 質數則計數  \n&nbsp;&nbsp;No → Step 4b: result = 0 // 若範圍無效，計數為 0  \n→ Step 5: 返回 result // 輸出最終計數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    \"\"\"計算給定區間內，二進位表示中 1 的個數為質數的數字個數\"\"\"\n    def __init__(self):\n        # 2~31 之間的質數（最多 32 位整數的 1 的個數不會超過 32）\n        self.primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}\n\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        \"\"\"返回 [left, right] 區間內 1 的個數為質數的數字個數\"\"\"\n        # 確保 left <= right\n        if left > right:\n            left, right = right, left\n\n        count = 0\n        for num in range(left, right + 1):\n            bits = bin(num).count('1')  # 計算二進位中的 1 的個數\n            if bits in self.primes:    # 判斷是否為質數\n                count += 1\n        return count\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取兩個整數，預期格式類似於\n    'left = 6, right = 10' 或任何包含兩個整數的字串。\n    \"\"\"\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 2:\n        return nums[0], nums[1]\n    raise ValueError(\"輸入格式不正確，必須包含兩個整數。\")\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    try:\n        left, right = parse_input(raw_input)\n    except ValueError as e:\n        print(e)\n        sys.exit(1)\n\n    sol = Solution()\n    result = sol.countPrimeSetBits(left, right)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 6, right = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 10, right = 15",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode215.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in an Array",
    "description_snippet": "Given an integer array nums and an integer k, return the k^th largest element in the array.\n\nNote th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Approach: use min-heap of size k, iterate array, maintain heap of k largest elements. Finally top of heap is kth largest. We need not actually show code, but pseudocode. Use steps: Start, Input, Initialize heap, For each num, if size<k push, else if num>heap.min then pop min and push num. After loop, return heap.min. End. Also explain. Use Decision: if k > length? Maybe error. Keep simple.\n\nWe must obey formatting: each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Format as sample.\n\nLet's produce.\n\nNeed to include Start, End. Use \"Decision:\" lines for conditions.\n\nUse lines like \"→ Step 1: 讀取輸入 nums, k\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums 與整數 k // 從使用者或呼叫處取得資料  \n→ Decision: 若 k 大於 nums 長度? // 檢查 k 是否合法  \n Yes → Step 2: 回傳錯誤訊息或拋出例外 // k 不能大於陣列長度  \n No  → Step 3: 初始化最小堆 heap，容量為 0 // 用來儲存目前最大的 k 個元素  \n→ For Each num in nums: // 遍歷每個元素  \n  Decision: 若 heap 容量 < k? // 堆尚未滿  \n   Yes → Step 4: heap.push(num) // 直接加入堆中  \n   No → Decision: 若 num > heap.min()? // 新元素是否比最小堆頂大  \n    Yes → Step 5: heap.pop() → heap.push(num) // 替換最小值  \n    No → Step 6: 跳過 // 不符合 k 大元素條件，維持堆不變  \n→ Step 7: 回傳 heap.min() // 堆頂即為第 k 大元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass Solution:\n    def findKthLargest(self, nums, k):\n        # 建立最小堆，保持 k 個最大的元素\n        heap = nums[:k]\n        heapq.heapify(heap)\n        # 遍歷其餘元素，維持堆中為最大的 k 個\n        for num in nums[k:]:\n            if num > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, num)\n        return heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 例: \"nums = [3,2,1,5,6,4], k = 2\"\n    parts = data.split(', k =')\n    nums_part = parts[0].replace('nums =', '').strip()\n    k_part = parts[1].strip()\n    nums = ast.literal_eval(nums_part)\n    k = int(k_part)\n    sol = Solution()\n    result = sol.findKthLargest(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode318.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Word Lengths",
    "description_snippet": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given array of words, find max product of lengths of two words without common letters. Use bitmask for each word to represent letters. Then double loop over pairs, check if bitmask & bitmask ==0, compute product. Output max.\n\nNeed virtual code lines with comments.\n\nMake sure to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision etc.\n\nWe must not output real code, just pseudo.\n\nLet's produce step-by-step: Start, read words, compute bitmask array, max product init to 0. Loop i from 0 to n-1, j from i+1 to n-1, decision: if mask[i] & mask[j] == 0 then compute product, if product > max then update max. After loops, output max, End.\n\nNeed to include bitmask creation step: For each word, initialize mask=0, loop each char, set bit char - 'a'. Could use Decision? But easier to show loop with setting bit.\n\nWe should use virtual code lines. Provide explanation in Chinese.\n\nLet's craft.\n\nAlso we should maybe include array length and variable initialization.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串陣列 words // 取得輸入的單字清單  \n→ Step 2: 設定 n ← length(words) // 取得字串數量  \n→ Step 3: 建立陣列 masks[n] // 用於儲存每個字串的位元遮罩  \n→ Step 4: 設定 maxProduct ← 0 // 儲存最大乘積  \n\n// 為每個字串計算位元遮罩  \n→ Step 5: for i from 0 to n-1  \n  → SubStep 5.1: mask ← 0 // 初始遮罩  \n  → SubStep 5.2: for each character c in words[i]  \n    → SubStep 5.2.1: bit ← 1 << (c - 'a') // 取得對應字母的位元  \n    → SubStep 5.2.2: mask ← mask OR bit // 將該字母位元加入遮罩  \n  → SubStep 5.3: masks[i] ← mask // 儲存完成的遮罩  \n\n// 逐對比較字串，尋找不共用字母的組合  \n→ Step 6: for i from 0 to n-1  \n  → Step 6.1: for j from i+1 to n-1  \n    → Decision: 如果 masks[i] AND masks[j] == 0? // 判斷兩字串是否共有字母  \n      Yes → Step 6.1.1: product ← length(words[i]) * length(words[j]) // 計算長度乘積  \n       → Decision: 如果 product > maxProduct? // 檢查是否為新最大值  \n         Yes → Step 6.1.2: maxProduct ← product // 更新最大乘積  \n         No  → // 不更新  \n      No  → // 兩字串有共用字母，跳過  \n\n→ Step 7: 輸出 maxProduct // 顯示最終結果  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_product(words):\n    \"\"\"回傳兩個不共用字母之單字長度乘積最大值。\"\"\"\n    n = len(words)\n    masks = [0] * n\n    # 建立每個單字的 26 位元遮罩\n    for i, w in enumerate(words):\n        mask = 0\n        for ch in w:\n            mask |= 1 << (ord(ch) - ord('a'))\n        masks[i] = mask\n\n    max_prod = 0\n    # 逐對比對，檢查是否沒有共用字母\n    for i in range(n):\n        for j in range(i + 1, n):\n            if masks[i] & masks[j] == 0:\n                prod = len(words[i]) * len(words[j])\n                if prod > max_prod:\n                    max_prod = prod\n    return max_prod\n\ndef main():\n    # 從標準輸入讀取整段文字\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 去除可能的前置文字，例如 \"words = \"\n    idx = data.find('[')\n    list_str = data[idx:] if idx != -1 else data\n    # 解析成 Python list\n    try:\n        words = ast.literal_eval(list_str)\n    except Exception:\n        words = eval(list_str)\n    # 計算並輸出結果\n    result = max_product(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode698.json",
    "problem_index_in_file": 0,
    "title": "Partition to K Equal Sum Subsets",
    "description_snippet": "Given an integer array nums and an integer k, return true if it is possible to divide this array int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for partitioning array into k equal sum subsets (classic problem). Provide line by line virtual steps. No actual code, only structure. Use Start, Decision, Yes→ etc. Provide explanations after each line. Let's produce steps: compute total sum, check divisibility by k, target sum, if target is zero maybe handle. Then sort array descending. Use backtracking function. Steps: maintain visited bitmask or used array. Backtrack to assign numbers to subsets. Provide recursion steps. Use decisions: if current sum equals target, move to next subset. If sum > target, backtrack. Use pruning: skip duplicates. Use start index to avoid repeated assignments.\n\nWe need to produce the virtual code and explanation. Use arrow arrows as required. Ensure each line ends with // explanation. Let's produce. Ensure proper indentation maybe? We'll keep each line with arrow or indent for nested decision. Use `→` for steps, and `Decision:` for branching.\n\nWe'll start with `Start`. Provide high-level steps: compute sum, check, sort, backtrack. We'll provide recursion steps: `Step: backtrack(remaining_k, current_sum, start_index)`. In pseudocode we can show recursion.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 nums 總和 totalSum ← sum(nums) // 先求整個陣列的總和  \n→ Decision: 如果 totalSum % k ≠ 0? // 判斷是否能被 k 整除  \n  Yes → Step 2: 回傳 false // 若不能整除，無法平均分配，直接結束  \n  No  → Continue // 否則進行後續處理  \n→ Step 3: 設定目標子集和 targetSum ← totalSum / k // 每個子集需要達到的總和  \n→ Step 4: 將 nums 陣列降序排列 nums ← sort_desc(nums) // 降序能加速剪枝  \n→ Step 5: 建立 visited 陣列 visited ← array(len(nums), false) // 標記每個元素是否已被使用  \n→ Step 6: 呼叫 backtrack(k, 0, 0) // 從第一個子集開始回溯，已完成子集數目、目前子集和、起始索引  \n\nStart backtrack(remaining, currentSum, startIndex) // 進行回溯搜索  \n→ Decision: 如果 remaining = 0? // 所有子集已成功分配  \n  Yes → Return true // 成功完成分割  \n  No  → Continue // 仍有子集未完成  \n\n→ Decision: 如果 currentSum = targetSum? // 本子集已達到目標和  \n  Yes → Step 7: 呼叫 backtrack(remaining - 1, 0, 0) // 進入下一個子集，重置和與索引  \n    → Decision: 如果回傳 true?  \n     Yes → Return true  \n     No  → Return false // 若下一子集失敗，回傳失敗  \n  No  → Continue // 尚未達到目標和，嘗試添加更多數字  \n\n→ Decision: 如果 currentSum > targetSum? // 超過目標和  \n  Yes → Return false // 無法繼續此路徑，回溯  \n  No  → Continue  \n\n→ For i from startIndex to len(nums)-1: // 迭代未使用的數字  \n  Decision: 如果 visited[i] 或 (i > 0 且 nums[i] == nums[i-1] 且 not visited[i-1])? // 避免重複子集組合  \n    Yes → Continue // 跳過重複或已使用的數字  \n    No  → Step 8: visited[i] ← true // 標記使用  \n     → Step 9: 呼叫 backtrack(remaining, currentSum + nums[i], i + 1) // 將數字加入目前子集並遞增索引  \n      → Decision: 如果回傳 true?  \n       Yes → Return true // 成功，傳回真  \n       No  → visited[i] ← false // 回溯，取消使用  \n         ← Continue // 繼續嘗試下一個數字  \n\n→ End backtrack // 所有選項嘗試完畢，返回 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def canPartitionKSubsets(self, nums, k):\n        total = sum(nums)\n        if total % k != 0:\n            return False\n        target = total // k\n        n = len(nums)\n        nums.sort(reverse=True)\n\n        # 如果每個子集的和為 0，則所有元素必須都是 0\n        if target == 0:\n            return all(x == 0 for x in nums)\n\n        # 最大的元素若大於目標和，直接失敗\n        if nums[0] > target:\n            return False\n\n        memo = {}\n\n        def dfs(used, curr_sum, k_remaining):\n            if k_remaining == 0:\n                return True\n            key = (used, curr_sum, k_remaining)\n            if key in memo:\n                return memo[key]\n\n            for i in range(n):\n                if not (used >> i) & 1:          # 未使用的元素\n                    if curr_sum + nums[i] <= target:\n                        new_used = used | (1 << i)\n                        new_sum = curr_sum + nums[i]\n                        new_k_remain = k_remaining\n                        if new_sum == target:   # 本子集已滿\n                            new_k_remain -= 1\n                            new_sum = 0\n                        if dfs(new_used, new_sum, new_k_remain):\n                            memo[key] = True\n                            return True\n            memo[key] = False\n            return False\n\n        return dfs(0, 0, k)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 取得 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not k_match:\n        print('false')\n        return\n    nums = ast.literal_eval(nums_match.group(1))\n    k = int(k_match.group(1))\n\n    solution = Solution()\n    result = solution.canPartitionKSubsets(nums, k)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,3,5,2,1], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode740.json",
    "problem_index_in_file": 0,
    "title": "Delete and Earn",
    "description_snippet": "You are given an integer array nums. You want to maximize the number of points you get by performing...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: maximize points by deleting numbers with neighbors. This is classic House Robber on frequencies. Steps: Count frequency of each number, compute DP. Outline: start, build freq map, find max number, create DP array size max+1, DP[0]=0, DP[1]=freq[1]*1, iterate i from 2 to max: DP[i]=max(DP[i-1], DP[i-2]+freq[i]*i). End, return DP[max]. Provide virtual code line by line. Use \"Start\" \"End\". Use arrows. Provide short explanation after each line. Let's craft.\n\nAlso need to handle 0? Numbers could be up to maybe large but we can compress. Keep simple.\n\nWrite lines:\n\nStart // Program start\n\n→ Step 1: 初始化頻率映射 freq = {} // 建立空映射存各數字出現次數\n\n→ Step 2: 遍歷 nums，對每個 num 更新 freq[num]++ // 統計每個數字的出現頻次\n\n→ Step 3: 找出 maxNum = 最大鍵值(freq) // 知道需要計算的 DP 限界\n\n→ Decision: maxNum 是否為 0? // 檢查是否有元素\n\n    Yes → Step 4: 回傳 0 // 若無元素，點數為 0\n\n    No → Step 5: 初始化 dp[0] = 0 // dp[0] 代表不取任何數字\n\n→ Step 6: dp[1] = freq.get(1,0) * 1 // 第1個數字的點數\n\n→ Step 7: 從 i = 2 到 maxNum，依序計算\n\n    → Step 7a: currGain = i * freq.get(i,0) // 取 i 時獲得的點數\n\n    → Step 7b: dp[i] = max(dp[i-1], dp[i-2] + currGain) // 選擇保留或跳過\n\n→ Step 8: 回傳 dp[maxNum] // 最大點數\n\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use arrow formatting: \"→\". For decision use indent and Yes/No.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率映射 freq = {} // 建立空映射存各數字出現次數  \n→ Step 2: 遍歷 nums，對每個 num 更新 freq[num]++ // 統計每個數字的出現頻次  \n→ Step 3: 找出 maxNum = 最大鍵值(freq) // 知道需要計算的 DP 限界  \n→ Decision: maxNum 是否為 0? // 檢查是否有元素  \n Yes → Step 4: 回傳 0 // 若無元素，點數為 0  \n No  → Step 5: 初始化 dp[0] = 0 // dp[0] 代表不取任何數字  \n→ Step 6: dp[1] = freq.get(1,0) * 1 // 第1個數字的點數  \n→ Step 7: 從 i = 2 到 maxNum，依序計算  \n → Step 7a: currGain = i * freq.get(i,0) // 取 i 時獲得的點數  \n → Step 7b: dp[i] = max(dp[i-1], dp[i-2] + currGain) // 選擇保留或跳過  \n→ Step 8: 回傳 dp[maxNum] // 最大點數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef delete_and_earn(nums):\n    \"\"\"計算可獲得的最大點數。\"\"\"\n    if not nums:               # 空陣列直接返回 0\n        return 0\n\n    count = Counter(nums)      # 統計每個數字的出現次數\n    max_num = max(nums)        # 需要 DP 的上限\n\n    # 若所有數字都是 0，直接回傳 0（0 乘 任何次數仍為 0）\n    if max_num == 0:\n        return 0\n\n    dp = [0] * (max_num + 1)\n    dp[0] = 0\n    dp[1] = count.get(1, 0) * 1\n\n    # 依次計算 dp[i]，類似「打家劫舍」的 DP\n    for i in range(2, max_num + 1):\n        take = dp[i - 2] + count.get(i, 0) * i\n        skip = dp[i - 1]\n        dp[i] = take if take > skip else skip\n\n    return dp[max_num]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：形如 \"[3,4,2]\"\n    nums = ast.literal_eval(data)\n    result = delete_and_earn(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "[2,2,3,3,3,4]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode66.json",
    "problem_index_in_file": 0,
    "title": "Plus One",
    "description_snippet": "You are given a large integer represented as an integer array digits, where each digits[i] is the it...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The requirement: \"用繁體中文回答。你是一個虛擬碼生成助理。任務：根據使用者的自然語言需求，**逐行地**產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後**立即**提供該行的**簡短、直觀的解釋**。⚠️ 請勿輸出實際程式碼，只輸出結構化的步驟。\"\n\nWe need to follow format: each line: 虛擬碼步驟 + space + // 解釋/說明. Use virtual code arrow and structure. Start, End, Decision:.\n\nWe need to produce algorithm: adding one to digits array.\n\nWe need to produce step-by-step pseudocode lines. We'll use steps like:\n\nStart\n→ Step 1: Set carry = 1 // Initialize carry to 1 for the +1\n→ Step 2: For i from length-1 down to 0 // iterate digits from least significant\n   → Step 3: Sum = digits[i] + carry // add carry\n   → Decision: If sum >= 10? \n       Yes → digits[i] = sum - 10 // set new digit\n       Yes → carry = 1 // carry remains 1\n       No → digits[i] = sum // no carry\n       No → carry = 0\n   → Decision: If carry == 0? \n       Yes → Break // no more carry, exit loop\n       No → Continue // continue loop\n→ Decision: If carry == 1? // after loop\n   Yes → Insert 1 at beginning of digits // new most significant digit\n   No → // nothing\nEnd\n\nBut need to use the specified formatting with arrow and decisions properly. Also need to reflect Step numbers maybe. Use \"Step x:\".\n\nWe must not output actual code. Just structure.\n\nUse Chinese comments: // 解釋/說明\n\nMake sure each line is separate.\n\nWe need to use \"Decision:\" with Yes →, No → lines.\n\nAlso must use \"Start\" and \"End\" lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 設定 carry = 1 // 初始化進位為 1，因為要加 1\n→ Step 2: 設定 i = digits.Length - 1 // 從最低有效位開始\n→ Decision: i >= 0? // 仍有位數未處理\n    Yes → Step 3: sum = digits[i] + carry // 將進位加到當前位\n    → Decision: sum >= 10? // 是否需要進位\n        Yes → digits[i] = sum - 10 // 取餘數作為新位\n        Yes → carry = 1 // 進位保持 1\n        No  → digits[i] = sum // 直接存位\n        No  → carry = 0 // 進位為 0\n    → Decision: carry == 0? // 進位已歸零\n        Yes → Break // 可以結束循環\n        No  → i = i - 1 // 移至下一位\n        No  → Continue // 繼續迴圈\n→ Decision: carry == 1? // 循環結束後還有進位\n    Yes → Insert 1 at position 0 in digits // 在最前面新增 1\n    No  → // 不需要新增\nEnd // 程式執行結束\n\nNeed to adjust formatting: each line must be separate. The \"Decision\" lines need to be properly indented maybe. But each line must be separate line with // comment.\n\nWe also need to include \"Start\" and \"End\".\n\nBut the decision block includes multiple lines, each line after Decision: may be indented, but in our text we just put each line separately. Use \"Decision:\" lines for decisions. For loops, we use Steps with \"Decision:\".\n\nAlso \"Break\" and \"Continue\" may be just pseudo. It's okay.\n\nWe need to ensure each line is preceded by either \"→\" or nothing? According to format, they used \"→\" for steps, and \"Decision:\" for decisions, with \"Yes →\" and \"No →\". The \"Start\" and \"End\" lines don't have arrow.\n\nSo each line should be like:\n\nStart // ...\n\n→ Step 1: ... // ...\n→ Step 2: ... // ...\n→ Decision: i >= 0? // ...\n    Yes → Step 3: ... // ...\n    ... etc.\n\nBut we can't have line breaks inside same line. Each line must be separate. So the indentation and the \"Yes →\" lines each are separate lines.\n\nWe need to maintain the structure.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 carry = 1 // 初始化進位為 1，因為要加 1\n→ Step 2: 設定 i = digits.Length - 1 // 從最低有效位開始\n→ Decision: i >= 0? // 仍有位數未處理\n    Yes → Step 3: sum = digits[i] + carry // 將進位加到當前位\n    → Decision: sum >= 10? // 是否需要進位\n        Yes → digits[i] = sum - 10 // 取餘數作為新位\n        Yes → carry = 1 // 進位保持 1\n        No  → digits[i] = sum // 直接存位\n        No  → carry = 0 // 進位為 0\n    → Decision: carry == 0? // 進位已歸零\n        Yes → Break // 可以結束循環\n        No  → i = i - 1 // 移至下一位\n        No  → Continue // 繼續迴圈\n→ Decision: carry == 1? // 循環結束後還有進位\n    Yes → Insert 1 at position 0 in digits // 在最前面新增 1\n    No  → // 不需要新增\nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def plusOne(self, digits):\n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits\n\nif __name__ == \"__main__\":\n    import sys\n    import re\n\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 找出第一個 [ 與 ] 之間的內容\n    match = re.search(r'\\[(.*?)\\]', data)\n    if not match:\n        # 沒有找到陣列，直接輸出空陣列\n        print('[]')\n        sys.exit(0)\n\n    nums_str = match.group(1).strip()\n    if nums_str:\n        digits = list(map(int, nums_str.split(',')))\n    else:\n        digits = []\n\n    sol = Solution()\n    result = sol.plusOne(digits)\n\n    # 以逗號無空格的方式輸出\n    print('[' + ','.join(map(str, result)) + ']')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "digits = [1,2,3]",
          "expected_output": "[1,2,4]",
          "success": true,
          "output": "[1,2,4]"
        },
        {
          "example_index": 1,
          "input": "digits = [4,3,2,1]",
          "expected_output": "[4,3,2,2]",
          "success": true,
          "output": "[4,3,2,2]"
        },
        {
          "example_index": 2,
          "input": "digits = [9]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1,0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode646.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Pair Chain",
    "description_snippet": "You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.\n\nA pair...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find longest chain length of pairs. Classic problem: Longest Chain of Pairs. Approach: sort by right ascending, then greedily choose pairs where left > last_right. This yields longest chain length.\n\nAlternatively DP O(n^2). We'll produce greedy as simpler.\n\nWe need to output each line: step + comment.\n\nStart, sort, loop, etc.\n\nLet's produce:\n\nStart\n→ Step 1: Sort pairs by right ascending // arrange by increasing right\n→ Step 2: Initialize count = 0, lastRight = -∞ // count of chain, last selected pair's right\n→ Step 3: For each pair [left, right] in sorted pairs // iterate\n  Decision: If left > lastRight? // can extend chain\n   Yes → Step 4: count += 1 // add to chain\n     → Update lastRight = right // update last selected right\n   No → Step 5: continue // skip pair\n→ End // return count\n\nAdd details: step lines with arrow. For loops we can indicate with indentation.\n\nNeed to include comments after each line.\n\nLet's format:\n\nStart // 程式開始\n→ Step 1: Sort pairs by right ascending // 先按右端點遞增排序\n→ Step 2: Initialize count = 0, lastRight = -∞ // 記錄鏈長及上一次選取的右端\n→ Step 3: For each [left, right] in pairs // 逐一檢查每個對\n  Decision: if left > lastRight? // 是否能接續上一對\n   Yes → Step 4: count += 1 // 接續，鏈長加一\n     → Step 4a: lastRight = right // 更新最後一個右端點\n   No → Step 5: // 跳過此對\n\nBut we need each line separate. For nested steps we need indentation.\n\nThe virtual code arrow can be like \"→\" preceding each line. Indentation can be represented by spaces.\n\nWe need to output each line separately. So we might break step 4a as separate line. Indent maybe 4 spaces.\n\nLet's produce.\n\nAlso final line: Return count.\n\nSo after loop, we output.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Sort pairs by right ascending // 先按右端點遞增排序\n→ Step 2: Initialize count = 0, lastRight = -∞ // 記錄鏈長及上一次選取的右端點\n→ Step 3: For each pair in sorted pairs // 逐一檢查每個對\n  Decision: 如果 pair.left > lastRight? // 是否能接續上一對\n   Yes → Step 4: count += 1 // 接續，鏈長加一\n     → Step 4a: lastRight = pair.right // 更新最後一個右端點\n   No → // 跳過此對\n→ Step 5: Return count // 回傳最大鏈長\n\nBut we need each line after arrow. For decision branches we need \"Decision:\" line and then Yes/No lines.\n\nAlso we need to ensure correct indentation. We can use tab or spaces.\n\nThe output must be strictly lines with format: 虛擬碼步驟 [space] // 解釋\n\nSo each line must end with comment after //.\n\nThus \"Decision:\" line is a line too. Example from prompt: \"Decision: 如果數字大於 0? // 檢查數值是否為正\".\n\nSo our decision line: \"Decision: 如果 pair.left > lastRight? // 檢查左端點是否能接續\"\n\nYes and No lines: \"Yes → Step 4: ...\" etc.\n\nAlso Step 4a can be \"Yes → Step 4a: Update lastRight = pair.right // 更新最後一個右端點\". But we need only \"Yes →\" for branch; for nested we can keep \"Yes →\" again? Might use \"Yes → Step 4a:\" but that indicates a step after Yes branch.\n\nBetter to treat Step 4 as \"Yes → Step 4: count += 1\" then step 4a as \"→ Step 4a: lastRight = pair.right\" but then not part of branch? But we might keep \"→ Step 4a: ...\".\n\nBut according to format, \"Yes →\" or \"No →\" should be used.\n\nSo:\n\nDecision: if pair.left > lastRight? // ...\n  Yes → Step 4: count += 1 // ...\n   → Step 4a: lastRight = pair.right // ...\n\nAlternatively we can treat Step 4a as part of same line? Could combine: \"Yes → Step 4: count += 1; lastRight = pair.right // ...\" but that's multiple statements.\n\nBetter keep separate.\n\nAlso after the for loop, we need \"End\" maybe.\n\nWe can include End at end.\n\nLet's produce final answer.\n\nAlso we need to mention \"Return count\" step.\n\nLet's finalize.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort pairs by right ascending // 先按右端點遞增排序  \n→ Step 2: Initialize count = 0, lastRight = -∞ // 記錄鏈長及上一次選取的右端點  \n→ Step 3: For each pair in sorted pairs // 逐一檢查每個對  \n  Decision: 如果 pair.left > lastRight? // 檢查左端點是否能接續上一對  \n   Yes → Step 4: count += 1 // 接續，鏈長加一  \n     → Step 4a: lastRight = pair.right // 更新最後一個右端點  \n   No → // 跳過此對  \n→ Step 5: Return count // 回傳最大鏈長  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLongestChain(self, pairs):\n        # 先以右端點遞增排序\n        pairs.sort(key=lambda x: x[1])\n        curr = float('-inf')\n        count = 0\n        # 逐一檢查每個對\n        for a, b in pairs:\n            # 若左端點在前一個右端點之後，則可接續\n            if a > curr:\n                curr = b\n                count += 1\n        return count\n\ndef main():\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入包含前綴 \"pairs = \"，先去除\n    if data.startswith('pairs'):\n        eq_index = data.find('=')\n        if eq_index != -1:\n            data = data[eq_index + 1:].strip()\n\n    # 轉成 Python 物件（安全）\n    try:\n        pairs = ast.literal_eval(data)\n    except Exception as e:\n        # 若解析失敗，直接結束\n        print(\"0\")\n        return\n\n    # 計算並輸出結果\n    solution = Solution()\n    result = solution.findLongestChain(pairs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pairs = [[1,2],[2,3],[3,4]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "pairs = [[1,2],[7,8],[4,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode472.json",
    "problem_index_in_file": 0,
    "title": "Concatenated Words",
    "description_snippet": "Given an array of strings words (without duplicates), return all the concatenated words in the given...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: given array words, find all concatenated words that are comprised entirely of at least two shorter words from the list. Need to produce step-by-step virtual code with explanation. Should use arrow notation and Decision, etc. No actual code, just pseudocode steps.\n\nWe should outline algorithm: Use Trie or set. For each word sorted by length ascending, check if can be segmented into two or more words from set of already processed words. Use DP or recursion. Build set, check.\n\nWe produce start, steps: sort words by length. Iterate. For each word, use DP array length+1, dp[0]=true, for i from 1 to len, for j from 0 to i-1, if dp[j] && (word[j:i] in set) then dp[i]=true and break. After loop, if dp[len] true and count of words used >=2 -> add to result. Use counting? We can check if word is not in set at start? Use set of words processed. So we need to avoid using the word itself. But we only add after processed.\n\nBut algorithm may be simpler: For each word, call function canForm(word) using DFS with memo and set. Use recursion to check splits. Use set of words for quick lookup. Must ensure that we don't treat the word itself as component. Approach: for each word, temporarily remove from set, then check.\n\nLet's produce pseudocode with decision points: For each word: remove from set, if canForm(word) true add to result, then add back. canForm(word) uses recursion: if word in memo return memo[word]; for i from 1 to len-1: left=word[:i], right=word[i:]; if left in set and (right in set or canForm(right)) then memo[word]=true return true; end; memo[word]=false; return false.\n\nBut need at least two words. This recursion ensures at least one split, so if canForm returns true, that implies at least two words.\n\nWill produce pseudocode lines accordingly.\n\nWe should provide each line with explanation.\n\nLet's craft pseudocode:\n\nStart\n→ Step 1: Define wordsSet = set(words) // collection of all words for quick lookup\n→ Step 2: Define memo = empty map // for caching results of canForm\n→ Step 3: Define result = empty list // store concatenated words\n→ Step 4: Sort words by length ascending // ensure shorter words processed first\n    // Actually can also just iterate unsorted, but sorting helps.\n→ Step 5: For each word in sorted words:\n    // iterate through all words\n    → Decision: If word already in wordsSet? yes // always true, but we need to process\n        → Step 6: Remove word from wordsSet // avoid using itself as part\n        → Step 7: If canForm(word) returns true:\n            → Step 8: Append word to result // word is concatenated\n        → Step 9: Add word back to wordsSet // restore set for next words\n→ Step 10: Return result // list of concatenated words\n\nDefine function canForm(word):\n→ Start // function start\n→ Decision: If word in memo? Yes → Step 11: Return memo[word] // cached result\n→ Step 12: For i from 1 to len(word)-1:\n    // try all possible split positions\n    → Decision: If word[:i] in wordsSet? Yes:\n        → Decision: If word[i:] in wordsSet? Yes:\n            → Step 13: memo[word] = true // word can be formed from two words\n            → Step 14: Return true\n        → Decision: Else if canForm(word[i:]) returns true? Yes:\n            → Step 15: memo[word] = true\n            → Step 16: Return true\n→ Step 17: memo[word] = false // cannot form\n→ Step 18: Return false\n→ End // function end\n\nBut we also need to ensure at least two words: recursion ensures that because it requires at least one split, but if right part itself is in wordsSet, it's still at least two words. If right part is formed by recursion, recursion ensures at least two words. So it's fine.\n\nNeed to produce each line as pseudocode line plus comment. Use arrows and decision.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: wordsSet ← Set(words) // 建立所有單字的集合，便於快速查找  \n→ Step 2: memo ← EmptyMap() // 用來快取已判斷過的子字串結果  \n→ Step 3: result ← EmptyList() // 儲存符合條件的連字詞  \n→ Step 4: Sort(words, key=Length) // 先按長度升序排列，方便後續判斷  \n\n→ Step 5: For each word in words: // 逐一檢查每個字串  \n    → Decision: 若 wordsSet 包含 word? Yes // 事實上一定為真  \n        → Step 6: wordsSet.Remove(word) // 暫時移除自身，避免被當作組成部分  \n        → Decision: 若 canForm(word) 為 true? Yes  \n            → Step 7: result.Append(word) // 加入結果列表  \n        → Step 8: wordsSet.Add(word) // 重新加入集合，供後續字串使用  \n\n→ Step 9: Return result // 回傳所有連字詞  \n\nFunction canForm(word): // 判斷 word 是否能由至少兩個較短字串組合而成  \n    → Step 10: If word ∈ memo? Yes  \n        → Step 11: Return memo[word] // 直接回傳快取結果  \n    → Step 12: For i from 1 to Length(word)-1: // 嘗試所有分割位置  \n        → Decision: 若 word[0:i] ∈ wordsSet? Yes  \n            → Decision: 若 word[i:] ∈ wordsSet? Yes  \n                → Step 13: memo[word] ← True // 兩段皆在集合中，符合條件  \n                → Step 14: Return True  \n            → Decision: 若 canForm(word[i:]) 為 True? Yes  \n                → Step 15: memo[word] ← True // 右半段可再拆分，符合條件  \n                → Step 16: Return True  \n    → Step 17: memo[word] ← False // 無法拆分成兩個或以上字串  \n    → Step 18: Return False // 回傳失敗  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        word_set = set(words)\n        memo = {}\n\n        def canForm(word):\n            if word in memo:\n                return memo[word]\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in word_set:\n                    if suffix in word_set or canForm(suffix):\n                        memo[word] = True\n                        return True\n            memo[word] = False\n            return False\n\n        res = []\n        for word in words:\n            if not word:\n                continue\n            word_set.remove(word)\n            if canForm(word):\n                res.append(word)\n            word_set.add(word)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list part from input like: words = [\"a\",\"b\"]\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        words = []\n    else:\n        list_str = data[start:end+1]\n        words = ast.literal_eval(list_str)\n\n    solution = Solution()\n    result = solution.findAllConcatenatedWordsInADict(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "success": true,
          "output": "['catsdogcats', 'dogcatsdog', 'ratcatdogcat']"
        },
        {
          "example_index": 1,
          "input": "words = [\"cat\",\"dog\",\"catdog\"]",
          "expected_output": "[\"catdog\"]",
          "success": true,
          "output": "['catdog']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode341.json",
    "problem_index_in_file": 0,
    "title": "Flatten Nested List Iterator",
    "description_snippet": "You are given a nested list of integers nestedList. Each element is either an integer or a list whos...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudocode) line by line, with explanation. For a NestedIterator, we can use a stack of iterators. Outline:\n\nStart\n→ Initialize stack with iterator of nestedList\n→ hasNext() loops while stack not empty:\n    peek top iterator, if it has next:\n        nextElem = top.next()\n        if nextElem is integer: push onto stack? Actually we need to store this integer to return next.\n        else it's a list: push iterator of that list onto stack\n    else: pop stack\nBut easier: In hasNext, we need to ensure the top of stack points to next integer. We can use a variable nextInt.\n\nSimplify: We'll implement class with stack of iterators and a variable nextVal.\n\nPseudo:\n\nStart\n→ Class NestedIterator\n    → Stack<Iterator<NestedInteger>> st\n    → Integer nextVal = null\n    → Constructor(nestedList):\n        → st.push(nestedList.iterator()) // push iterator of input list\n        → hasNext() // preload next integer\n    → boolean hasNext():\n        → While st not empty:\n            → If nextVal != null: return true\n            → If st.peek().hasNext() == false:\n                → st.pop()\n                → continue\n            → NestedInteger ni = st.peek().next()\n            → If ni.isInteger():\n                → nextVal = ni.getInteger()\n                → return true\n            → Else:\n                → st.push(ni.getList().iterator())\n        → return false\n    → int next():\n        → int result = nextVal\n        → nextVal = null\n        → return result\n\nBut we need to produce virtual code lines with explanation. Use arrow and Decision constructs.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Class NestedIterator // 定義迭代器類別\n    → Stack st // 堆疊用於追蹤各層列表的迭代器\n    → Integer nextVal = null // 暫存下一個要回傳的整數\n    → Constructor(nestedList) // 初始化\n        → st.push(nestedList.iterator()) // 將輸入列表的迭代器推進堆疊\n        → hasNext() // 立即預先尋找第一個整數\n    → boolean hasNext() // 檢查是否還有整數可供取用\n        → While st not empty:\n            → If nextVal != null: return true // 已找到下一個整數\n            → If st.peek().hasNext() == false:\n                → st.pop() // 當前層已無更多元素，退回上一層\n                → continue\n            → NestedInteger ni = st.peek().next() // 取得下一個元素\n            → Decision: 如果 ni.isInteger()? // 判斷是否為整數\n                → Yes → nextVal = ni.getInteger() // 存儲整數以供 next() 使用\n                → Yes → return true\n                → No  → st.push(ni.getList().iterator()) // 若為子列表，推入其迭代器\n        → return false // 沒有更多整數\n    → int next() // 取得下一個整數\n        → int result = nextVal // 取出預先存儲的值\n        → nextVal = null // 清空緩存\n        → return result\nEnd // 程式結束\n\nBut we need to be careful with indentation and arrows. The sample shows indentation with arrows. Let's follow that style:\n\nStart // 程式開始執行\n→ Class NestedIterator // 定義迭代器類別\n    → Stack st // 堆疊追蹤列表迭代器\n    → Integer nextVal = null // 暫存下一個整數\n    → Constructor(nestedList) // 初始化\n        → st.push(nestedList.iterator()) // 推入初始列表迭代器\n        → hasNext() // 預先尋找第一個整數\n    → boolean hasNext() // 檢查是否還有整數\n        → While st not empty:\n            → If nextVal != null: return true // 已找到整數\n            → If st.peek().hasNext() == false:\n                → st.pop() // 當前層無元素，退回上一層\n                → continue\n            → NestedInteger ni = st.peek().next() // 取得下一個元素\n            → Decision: 如果 ni.isInteger()? // 判斷是否為整數\n                → Yes → nextVal = ni.getInteger() // 存儲整數\n                → Yes → return true // 整數已準備好\n                → No  → st.push(ni.getList().iterator()) // 子列表，推入迭代器\n        → return false // 沒有更多整數\n    → int next() // 取得下一個整數\n        → int result = nextVal // 取得預存值\n        → nextVal = null // 清空緩存\n        → return result\nEnd // 程式結束\n\nCheck formatting: Use \"→\" at each step, nested steps indent with spaces. For Decision, use Decision: if ...? and Yes/No branches. That matches spec.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class NestedIterator // 定義迭代器類別  \n    → Stack st // 堆疊追蹤各層列表的迭代器  \n    → Integer nextVal = null // 暫存下一個要回傳的整數  \n    → Constructor(nestedList) // 初始化  \n        → st.push(nestedList.iterator()) // 將輸入列表的迭代器推入堆疊  \n        → hasNext() // 立即尋找第一個整數  \n    → boolean hasNext() // 檢查是否還有整數可供取用  \n        → While st not empty:  \n            → If nextVal != null: return true // 已找到下一個整數，直接返回  \n            → If st.peek().hasNext() == false:  \n                → st.pop() // 當前層已無更多元素，退回上一層  \n                → continue  \n            → NestedInteger ni = st.peek().next() // 取得下一個元素  \n            → Decision: 如果 ni.isInteger()? // 判斷是否為整數  \n                → Yes → nextVal = ni.getInteger() // 存儲整數以供 next() 使用  \n                → Yes → return true // 整數已準備好  \n                → No  → st.push(ni.getList().iterator()) // 若為子列表，推入其迭代器  \n        → return false // 沒有更多整數  \n    → int next() // 取得下一個整數  \n        → int result = nextVal // 取出預先存儲的值  \n        → nextVal = null // 清空緩存  \n        → return result  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass NestedIterator:\n    \"\"\"\n    迭代器，將嵌套的整數列表展平成一維序列。\n    使用堆疊跟蹤當前迭代器，並預先尋找下一個整數以支援 hasNext()。\n    \"\"\"\n    def __init__(self, nestedList):\n        # 用迭代器追蹤每層列表，最外層首先進入堆疊\n        self.stack = [iter(nestedList)]\n        self.next_val = None\n        self._advance()  # 尋找第一個整數\n\n    def _advance(self):\n        \"\"\"尋找下一個整數，將其存入 self.next_val。若沒有則保持為 None。\"\"\"\n        self.next_val = None\n        while self.stack:\n            try:\n                elem = next(self.stack[-1])  # 取得當前層的下一個元素\n            except StopIteration:\n                # 當前層已結束，退回上一層\n                self.stack.pop()\n                continue\n\n            if isinstance(elem, int):\n                # 找到整數，存入並返回\n                self.next_val = elem\n                return\n            else:\n                # 找到子列表，將其迭代器加入堆疊\n                self.stack.append(iter(elem))\n\n    def next(self):\n        \"\"\"取得下一個整數。若沒有則拋出 StopIteration。\"\"\"\n        if self.next_val is None:\n            raise StopIteration\n        val = self.next_val\n        self._advance()\n        return val\n\n    def hasNext(self):\n        \"\"\"若還有可取的整數則回傳 True，否則 False。\"\"\"\n        return self.next_val is not None\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 允許輸入類似 \"nestedList = [[1,1],2,[1,1]]\" 或僅為列表表示\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    # 用安全的 literal_eval 解析成 Python 物件\n    nested_list = ast.literal_eval(data)\n\n    # 建立迭代器並取得展平成一維的結果\n    iterator = NestedIterator(nested_list)\n    result = []\n    while iterator.hasNext():\n        result.append(iterator.next())\n\n    # 輸出結果，符合題目要求的列表字串格式\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nestedList = [[1,1],2,[1,1]]",
          "expected_output": "[1,1,2,1,1]",
          "success": true,
          "output": "[1, 1, 2, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "nestedList = [1,[4,[6]]]",
          "expected_output": "[1,4,6]",
          "success": true,
          "output": "[1, 4, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode485.json",
    "problem_index_in_file": 0,
    "title": "Max Consecutive Ones",
    "description_snippet": "Given a binary array nums, return the maximum number of consecutive 1's in the array....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each line with \"虛擬碼步驟 // 解釋\". We must not output actual code. Use Start, End, Decision, arrow. The algorithm: iterate array, count current streak, track max. Provide steps. We'll produce step lines: Start, Step 1: 初始化 maxCount, currentCount to 0 // initialize counters. Step 2: 遍歷 nums // iterate. Inside loop: if element==1 then currentCount++ else reset currentCount=0. After updating, update maxCount = max(maxCount,currentCount). Finally output maxCount. We'll use Decision blocks for element==1? or not. Provide explanation each line.\n\nWe need each line as \"虛擬碼步驟 // 解釋\". Use arrows. Let's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxCount ← 0, currentCount ← 0 // 設定計數器\n→ Step 2: For each num in nums // 逐個處理陣列元素\n    → Decision: 如果 num 等於 1? // 判斷是否為 1\n        Yes → Step 3: currentCount ← currentCount + 1 // 連續 1 加一\n        No  → Step 4: currentCount ← 0 // 遇到 0，重置連續計數\n    → Step 5: maxCount ← max(maxCount, currentCount) // 更新最大值\n→ Step 6: Return maxCount // 輸出結果\nEnd // 程式執行結束\n\nWe need each line in this format. Also we might need to include \"Start\" line. Ensure each line ends with \"// 解釋\".\n\nAlso \"虛擬碼步驟\" includes arrow for decisions. Use proper spacing.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxCount ← 0, currentCount ← 0 // 設定兩個計數器，分別用於儲存目前連續 1 的數量與已找到的最大值  \n→ Step 2: For each num in nums // 逐個遍歷輸入陣列 nums  \n  → Decision: 如果 num 等於 1? // 判斷目前元素是否為 1  \n   Yes → Step 3: currentCount ← currentCount + 1 // 若為 1，將連續 1 的計數器加 1  \n   No  → Step 4: currentCount ← 0 // 若為 0，重置連續 1 的計數器為 0  \n  → Step 5: maxCount ← max(maxCount, currentCount) // 更新最大連續 1 的數量  \n→ Step 6: Return maxCount // 回傳最終得到的最大連續 1 的長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums):\n        max_count = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n        return max_count\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 移除可能的前綴 \"nums =\"，只保留列表字面量\n    start = data.find('[')\n    if start != -1:\n        data = data[start:]\n    else:\n        # 若沒有找到 '['，直接嘗試 eval 整個字串\n        data = data\n\n    # 使用 ast.literal_eval 安全地解析列表\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，直接終止\n        sys.exit()\n\n    # 確保得到的是列表\n    if not isinstance(nums, list):\n        sys.exit()\n\n    solution = Solution()\n    result = solution.findMaxConsecutiveOnes(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,0,1,1,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode453.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code, step by step, explaining each line, in Traditional Chinese. The problem: given integer array nums, find min number of moves to make all elements equal. Operation: increment n-1 elements by 1. Known solution: equivalent to decrement one element by 1 each move. Minimal moves = sum(nums) - n * min(nums). So algorithm: compute sum and min, then result.\n\nWe need to output line by line: Start, then steps: Input array, compute sum, compute min, compute moves, output moves, End.\n\nAlso maybe check empty? Not needed. We'll produce virtual code steps.\n\nWe need to use the format: \"Start // 程式開始執行\" etc.\n\nInclude arrows. Use indentation. Provide explanation after //.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數陣列 nums // 從使用者取得整數陣列\n→ Step 2: 計算陣列長度 n // 獲得陣列元素個數\n→ Step 3: 初始化 sum = 0, minVal = +∞ // 準備累加總和與最小值\n→ Decision: 是否還有未處理元素? // 檢查是否需要遍歷陣列\n    Yes → Step 4: 取出下個元素 val // 取得陣列中下一個數值\n    → Step 5: sum = sum + val // 將值加入總和\n    → Step 6: 若 val < minVal 則 minVal = val // 更新最小值\n    → Decision: 是否已經處理完所有元素? // 判斷是否繼續\n        No  → 回到 Decision: 是否還有未處理元素? // 重新檢查\n        Yes → 轉到 Step 7 // 完成遍歷\n→ Step 7: 計算 moves = sum - n * minVal // 依公式算出最小移動次數\n→ Step 8: 輸出 moves // 將結果傳回使用者\nEnd // 程式執行結束\n\nWe must ensure arrow usage: Use '→' for step, 'Decision:' for branching. For Yes/No we need indent. Use consistent style. Provide explanation after //. For decisions: explanation. For Yes/No branches: explanation after //.\n\nWe need to produce exactly as requirement: Each line must contain virtual code step + space + comment.\n\nWe can add indentation with spaces or tabs; not specified but can indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 從使用者取得整數陣列  \n→ Step 2: 計算陣列長度 n // 獲得陣列元素個數  \n→ Step 3: 初始化 sum = 0, minVal = +∞ // 準備累加總和與最小值  \n→ Decision: 是否還有未處理元素? // 檢查是否需要遍歷陣列  \n Yes → Step 4: 取出下個元素 val // 取得陣列中下一個數值  \n → Step 5: sum = sum + val // 將值加入總和  \n → Step 6: 若 val < minVal 則 minVal = val // 更新最小值  \n → Decision: 是否已經處理完所有元素? // 判斷是否繼續  \n  No  → 回到 Decision: 是否還有未處理元素? // 重新檢查  \n  Yes → Step 7: // 完成遍歷  \n→ Step 7: 計算 moves = sum - n * minVal // 依公式算出最小移動次數  \n→ Step 8: 輸出 moves // 將結果傳回使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef min_moves(nums):\n    \"\"\"\n    依題目定義計算最小移動次數。\n    每次操作可將 n-1 個元素加 1，等價於每次減少 1 個元素。\n    所以最終答案等於所有元素總和減去最小元素乘以元素個數。\n    \"\"\"\n    return sum(nums) - min(nums) * len(nums)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 期望輸入格式為「nums = [1,2,3]」或僅為「[1,2,3]」\n    try:\n        # 若包含等號，切割取得右邊\n        if \"=\" in data:\n            _, rhs = data.split(\"=\", 1)\n            nums = ast.literal_eval(rhs.strip())\n        else:\n            nums = ast.literal_eval(data)\n    except Exception as e:\n        # 無法解析輸入時直接結束\n        sys.exit(1)\n\n    # 計算並輸出結果\n    result = min_moves(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode225.json",
    "problem_index_in_file": 0,
    "title": "Implement Stack using Queues",
    "description_snippet": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should suppo...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Not actual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrow syntax. We need to implement stack using two queues. Provide steps for class, push, pop, top, empty. Let's produce high-level pseudo steps.\n\nWe need to think of algorithm: use two queues q1 and q2. push: enqueue to q1. pop: move all except last element from q1 to q2, dequeue last element as result, swap q1 and q2. top similar but not remove. empty: check q1 empty.\n\nWe'll write step-by-step with decisions.\n\nAlso mention initialization: q1 empty, q2 empty.\n\nLet's output sequential lines.\n\nMake sure use 'Start' 'End'.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyStack 類別，內部包含兩個佇列 queue1 與 queue2 // 初始化兩個佇列  \n→ Step 2: 檢查 queue1 是否為空，若是則 queue2 亦為空，兩佇列皆為空 // 確保初始狀態  \n→ Step 3: push(x) // 入栈操作  \n    → queue1 入隊 x // 把新元素加入 queue1 的尾部  \n→ Step 4: pop() // 出栈操作  \n    → Decision: 若 queue1 為空? // 若空則直接返回或拋例外  \n        Yes → Return null // 無元素可彈出  \n        No  →  \n            → Decision: 若 queue1 大於 1? // 是否有多於一個元素  \n                Yes →  \n                    → Step 5: 轉移 queue1 前 N-1 個元素到 queue2 // 循環 N-1 次  \n                    → queue1 前置元素 dequeue 為 result // 最後一個元素即為頂部元素  \n                No  →  \n                    → Step 6: queue1 前置元素 dequeue 為 result // 只有一個元素時直接彈出  \n            → Step 7: 交換 queue1 與 queue2 的參照 // 讓 queue1 成為新的主佇列  \n            → Return result // 返回彈出的元素  \n→ Step 8: top() // 取得頂部元素而不移除  \n    → Decision: 若 queue1 為空? // 若空則直接返回或拋例外  \n        Yes → Return null // 無元素  \n        No  →  \n            → Decision: 若 queue1 大於 1?  \n                Yes →  \n                    → Step 9: 轉移 queue1 前 N-1 個元素到 queue2  \n                    → queue1 前置元素 peek 為 topVal // 取得頂部元素但不彈出  \n                    → Step 10: queue1 前置元素 dequeue，並 enqueue 回 queue2 // 保持元素  \n                No  →  \n                    → Step 11: queue1 前置元素 peek 為 topVal // 只有一個元素  \n            → Step 12: 交換 queue1 與 queue2 // 重新整理佇列  \n            → Return topVal // 回傳頂部值  \n→ Step 13: empty() // 判斷是否為空  \n    → Return queue1.isEmpty() // 只需檢查主佇列是否空  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"把元素放入主佇列\"\"\"\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"移除並回傳最上層元素\"\"\"\n        if not self.q1:\n            return None\n        # 把除最後一個以外的所有元素移到輔助佇列\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 最後一個元素即為頂部\n        top = self.q1.popleft()\n        # 交換兩個佇列，q1 成為新的主佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return top\n\n    def top(self) -> int:\n        \"\"\"回傳最上層元素但不移除\"\"\"\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_val = self.q1.popleft()\n        # 把頂部元素放回輔助佇列\n        self.q2.append(top_val)\n        # 交換佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return top_val\n\n    def empty(self) -> bool:\n        \"\"\"判斷堆疊是否為空\"\"\"\n        return not self.q1\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：兩個列表，第一個是操作名，第二個是參數\n    ops, args = ast.literal_eval(data)\n\n    stack = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            stack = MyStack()\n            results.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n\n    # 轉成符合題目要求的輸出格式\n    out = []\n    for v in results:\n        if v is None:\n            out.append(\"null\")\n        elif isinstance(v, bool):\n            out.append(\"true\" if v else \"false\")\n        else:\n            out.append(str(v))\n    print(\"[\" + \", \".join(out) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpev13s3v2.py\", line 81, in <module>\n    main()\n  File \"/tmp/tmpev13s3v2.py\", line 50, in main\n    ops, args = ast.literal_eval(data)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 90, in _convert\n    return tuple(map(_convert, node.elts))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Subscript object at 0x72a23e2f7b50>"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode279.json",
    "problem_index_in_file": 0,
    "title": "Perfect Squares",
    "description_snippet": "Given an integer n, return the least number of perfect square numbers that sum to n.\n\nA perfect squa...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code step-by-step for solving the \"Perfect Squares\" problem: given n, find minimal number of perfect squares that sum to n. Use DP or BFS. Provide step-by-step virtual code with explanations. Ensure format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows: →, Decision: etc. Must not output actual code, only virtual steps. Need to produce lines starting from Start, ending End. Include decision points, loops, etc.\n\nWe need to think about algorithm: For integer n, we can use DP: dp[i] = min number of squares to represent i. Initialize dp[0] = 0. For each i from 1 to n, for each j from 1 to sqrt(i), dp[i] = min(dp[i], dp[i - j*j] + 1). Alternatively BFS approach: push n, subtract squares, until reach 0. Let's choose DP. Steps: Start; Input n; Compute list of squares up to n; Initialize dp array; For each i from 1 to n, set dp[i] = large; For each square s, if i >= s, dp[i] = min(dp[i], dp[i-s]+1); End; Output dp[n]. Provide decision for initialization? Could include decision to choose DP vs BFS. But requirement: \"逐行產生對應的虛擬碼\". So produce linear steps. Use loops.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 n // 取得要分解的整數\n→ Step 2: 建立列表 squares ← [i*i for i in 1..⌊√n⌋] // 先列出所有不超過 n 的完全平方數\n→ Step 3: 初始化 dp[0] ← 0 // 0 需要 0 個平方數\n→ Decision: dp[1..n] ← Infinity? // 為每個 i 先設為無限大\n    Yes → for i = 1 to n: dp[i] ← ∞ // 這一步先把 dp 除了 0 都設為無限\n→ Step 4: for i = 1 to n: // 逐個計算 dp[i]\n    → Step 4a: for each s in squares: // 遍歷所有平方數\n        → Decision: 如果 i ≥ s? // 判斷是否可以用 s 做為一項\n            Yes → Step 4b: dp[i] ← min(dp[i], dp[i - s] + 1) // 更新 dp[i]\n            No  → Step 4c: break // 之後的平方數都比 s 大，已無法再使用\n→ Step 5: 輸出 dp[n] // 返回最小平方數個數\nEnd // 程式執行結束\n\nBut we need to include arrow for loops properly? Use arrow for each nested step. Provide each line. Ensure each line has \"虛擬碼步驟 // 解釋\". For loops, we can represent as \"for i = 1 to n: // ...\". For decision: \"Decision: 如果 i ≥ s?\" etc. Let's produce.\n\nAlso ensure we don't output actual code, just pseudo steps. Provide \"Step 3: 初始化 dp[0] ← 0\" etc.\n\nAlso ensure the arrow lines: For loops, we can just use \"for i = 1 to n:\". For nested loops, we can indent with arrow but just lines with arrow. We'll output as plain lines with arrow? The sample shows \"→ Step 1: ...\". So we follow that.\n\nWe need to produce one line per step. For nested loops, we may have multiple lines: \"→ Step 4: for i = 1 to n:\" and then inside \"→ Step 4a: for each s in squares:\" etc. The arrow should be preceded by indentation? In sample, they just have \"→ Decision: ...\" etc. We'll keep same style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 n // 取得要分解的整數  \n→ Step 2: 建立列表 squares ← [i*i for i in 1..⌊√n⌋] // 列出所有不超過 n 的完全平方數  \n→ Step 3: 初始化 dp[0] ← 0 // 0 需要 0 個平方數  \n→ Decision: 為每個 i (1..n) 設為無限大？ // 先把 dp 除了 0 的位置設為無限大  \n  Yes → for i = 1 to n: dp[i] ← ∞ // 初始化 dp 表  \n→ Step 4: for i = 1 to n: // 逐個計算 dp[i]  \n  → Step 4a: for each s in squares: // 遍歷所有平方數  \n    → Decision: 如果 i ≥ s? // 判斷是否可以用 s 做為一項  \n     Yes → Step 4b: dp[i] ← min(dp[i], dp[i - s] + 1) // 更新 dp[i]  \n     No  → Step 4c: break // 之後的平方數都更大，已無法再使用  \n→ Step 5: 輸出 dp[n] // 返回最小平方數個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\nimport re\n\ndef num_squares(n):\n    dp = [math.inf] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j*j] + 1)\n            j += 1\n    return dp[n]\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    print(num_squares(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 13",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode330.json",
    "problem_index_in_file": 0,
    "title": "Patching Array",
    "description_snippet": "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm known as \"Patching Array\" problem. The algorithm: given sorted array nums, need to cover [1,n] using sums. We iterate through array with a variable current coverage up to reachable = 1; patch count. For each num, if num > reachable, we patch with reachable, increase patches, reachable*=2. Else reachable += num. After processing all numbers, while reachable <= n, patch reachable, increase patches, reachable*=2. Return patches.\n\nWe need to produce virtual code lines with explanation. Should be step by step.\n\nLet's craft:\n\nStart // begin\n→ Step 1: 初始化 reachable = 1 // 目标是能够生成 [1, reachable-1] 区间\n→ Step 2: 初始化 patches = 0 // 记录补丁数量\n→ Step 3: 初始化 index = 0 // 当前遍历 nums 的索引\n→ Decision: while index < nums.length AND reachable <= n? // 只要还有数组元素且还没覆盖 n\n    → Decision: 如果 nums[index] <= reachable? // 当前元素能扩展可覆盖范围\n        → Step 4: reachable += nums[index] // 加上该元素，扩展可达范围\n        → Step 5: index += 1 // 移动到下一个元素\n    → No → Step 6: patches += 1 // 补齐 reachable 这个数\n        → Step 7: reachable += reachable // 通过补齐，将可达范围翻倍\n→ Step 8: Decision: while reachable <= n? // 处理剩余范围\n        → Step 9: patches += 1\n        → Step 10: reachable += reachable\n→ End // 返回 patches\n\nBut need to reflect patch step: reachable += reachable means we add a number equal to reachable, so reachable doubles. That's fine.\n\nBetter to write more clear: Step 6: patches += 1; reachable = reachable * 2.\n\nLet's produce lines accordingly. Ensure each line has a space before comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: reachable ← 1 // 目標是能形成 [1, reachable‑1] 的數字  \n→ Step 2: patches ← 0 // 需要的補丁數量  \n→ Step 3: index ← 0 // 目前正在查看 nums 的位置  \n\n→ Decision: index < nums.length AND reachable ≤ n? // 只要還有數字且尚未覆蓋 n  \n  Yes → Decision: nums[index] ≤ reachable? // 該數字能擴大可達範圍  \n    Yes → Step 4: reachable ← reachable + nums[index] // 加入此數字，擴張覆蓋區間  \n     → Step 5: index ← index + 1 // 移到下一個數字  \n    No  → Step 6: patches ← patches + 1 // 補上一個值 equal to reachable  \n     → Step 7: reachable ← reachable * 2 // 補足後可覆蓋範圍翻倍  \n\n→ Decision: reachable ≤ n? // 若仍未覆蓋到 n  \n  Yes → Step 8: patches ← patches + 1 // 補足一個值 equal to reachable  \n    → Step 9: reachable ← reachable * 2 // 使可覆蓋範圍翻倍  \n  No  → End // 所有必要補丁已計算完成  \n\nEnd // 程式執行結束，返回 patches 其值即最小補丁數量",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def minPatches(self, nums, n):\n        \"\"\"\n        Greedy algorithm to find the minimum number of patches needed\n        so that every number in [1, n] can be represented as a sum\n        of elements from nums (including the added patches).\n        \"\"\"\n        patches = 0\n        # `miss` represents the smallest number that cannot be formed\n        # with the current set of numbers and patches.\n        miss = 1\n        i = 0  # index for nums\n\n        while miss <= n:\n            # If the next number in nums can help reach `miss`,\n            # use it and extend the reachable range.\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                # Otherwise, we need to patch with `miss` itself.\n                # Adding `miss` doubles the reachable range.\n                miss += miss\n                patches += 1\n        return patches\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list and n from a line like: nums = [1,3], n = 6\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*n\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format must be 'nums = [..], n = ..'\")\n\n    nums_str, n_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    n = int(n_str)\n\n    solution = Solution()\n    result = solution.minPatches(nums, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3], n = 6",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,10], n = 20",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,2], n = 5",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode210.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule II",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user requests: \"使用者需求: ... 請根據輸出格式要求產生虛擬碼和逐行解釋\". They want a virtual code for the problem: course scheduling, find topological order of courses given prerequisites; if impossible, return empty array.\n\nWe need to output virtual code line by line, each line with \"虛擬碼步驟 // 解釋\". Use arrows, decisions. We need to represent algorithm, e.g., Kahn's algorithm or DFS. Use start, decisions, etc.\n\nLet's produce algorithm: Build adjacency list, indegree array. Use queue of zero indegree. While queue not empty: pop, add to result, reduce indegree of neighbors, if zero indegree push. After loop, if result length==numCourses return result else return empty array.\n\nWe can represent steps.\n\nMake sure to follow format. Each line with arrow and explanation. Start, End.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化空 adjacency list 與 indegree 陣列 // 建立課程圖與入度\n→ Step 2: 為每個 prerequisites pair (a, b) 加入邊 b → a 與更新 indegree[a] // 建立依賴關係\n→ Step 3: 建立空 queue 用於儲存入度為 0 的課程 // 待處理的課程\n→ Step 4: 將所有 indegree 為 0 的課程加入 queue // 初始可選課程\n→ Decision: queue 是否為空? // 判斷是否還有課程可處理\n    Yes → End // 沒有課程可處理，結束迴圈\n    No  → Step 5: 從 queue 取出一個課程 cur // 取下一個可修課程\n→ Step 6: 將 cur 加入結果序列 // 記錄修課順序\n→ Step 7: 對 cur 的每一個相鄰課程 nxt 執行\n        → Step 8: indegree[nxt] 減 1 // 更新入度\n        → Decision: indegree[nxt] 是否為 0? // 判斷是否可即時修課\n            Yes → Step 9: 將 nxt 加入 queue // 新可修課程\n            No  → // 仍有前置課程，保持不變\n→ Step 10: 重複 Step 4-9 // 迭代處理所有可修課程\n→ Decision: result 長度是否等於 numCourses? // 檢查是否所有課程都已排定\n    Yes → Step 11: 回傳 result // 成功取得順序\n    No  → Step 12: 回傳空陣列 // 仍有循環，無法完成\nEnd // 程式執行結束\n\nNeed to keep each line unique. Use \"→\" lines.\n\nMake sure formatting: \"虛擬碼步驟 // 解釋\". Use arrow or step names.\n\nAdd \"Start // 程式開始執行\". Use \"End // 程式執行結束\".\n\nWe need to ensure each line has step.\n\nAlso we need to show \"Decision:\" lines properly.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空 adjacency list 與 indegree 陣列 // 建立課程圖與入度  \n→ Step 2: 為每個 prerequisites pair (a, b) 加入邊 b → a 與更新 indegree[a] // 建立依賴關係  \n→ Step 3: 建立空 queue 用於儲存入度為 0 的課程 // 待處理的課程  \n→ Step 4: 將所有 indegree 為 0 的課程加入 queue // 初始可選課程  \n→ Decision: queue 是否為空? // 判斷是否還有課程可處理  \n Yes → End // 沒有課程可處理，結束迴圈  \n No  → Step 5: 從 queue 取出一個課程 cur // 取下一個可修課程  \n→ Step 6: 將 cur 加入結果序列 // 記錄修課順序  \n→ Step 7: 對 cur 的每一個相鄰課程 nxt 執行  \n  → Step 8: indegree[nxt] 減 1 // 更新入度  \n  → Decision: indegree[nxt] 是否為 0? // 判斷是否可即時修課  \n   Yes → Step 9: 將 nxt 加入 queue // 新可修課程  \n   No  → // 仍有前置課程，保持不變  \n→ Step 10: 重複 Step 4-9 // 迭代處理所有可修課程  \n→ Decision: result 長度是否等於 numCourses? // 檢查是否所有課程都已排定  \n Yes → Step 11: 回傳 result // 成功取得順序  \n No  → Step 12: 回傳空陣列 // 仍有循環，無法完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # Build graph and indegree array\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # Queue all courses with zero indegree\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Process courses in topological order\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # If all courses are processed, return the order; otherwise return empty list\n        return order if len(order) == numCourses else []\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract numCourses\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    numCourses = int(num_match.group(1)) if num_match else 0\n\n    # Extract prerequisites list\n    prereq_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data, re.S)\n    prereq_str = prereq_match.group(1) if prereq_match else '[]'\n    prerequisites = eval(prereq_str)\n\n    solution = Solution()\n    order = solution.findOrder(numCourses, prerequisites)\n    print(order)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "success": true,
          "output": "[0, 1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode516.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Subsequence",
    "description_snippet": "Given a string s, find the longest palindromic subsequence's length in s.\n\nA subsequence is a sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for computing longest palindromic subsequence length. We must produce step-by-step using virtual code constructs: Start, Decision, etc. We should outline algorithm: dynamic programming: dp[i][j] longest palindromic subsequence length for substring s[i..j]. Use 2D array, iterate i from n-1 downto 0, j from i+1 to n-1. If s[i]==s[j], dp[i][j]=dp[i+1][j-1]+2 else max(dp[i+1][j], dp[i][j-1]). Return dp[0][n-1]. Also handle base case dp[i][i] =1. Also handle empty string. Provide virtual steps. Must not produce actual code. Use virtual steps like Step 1: Read input string s // etc. Use decisions. Also need to mention initialization. We need to produce as many lines as needed, with virtual code and comments.\n\nWe'll output:\n\nStart // program starts\n\n→ Step 1: Read string s // get input\n\n→ Step 2: Let n = length of s // string length\n\n→ Decision: If n == 0? // check empty\n\n    Yes → Step 3: Output 0 // no subsequence\n\n    No → Step 4: Initialize 2D array dp[n][n] with zeros // prepare DP\n\n→ Step 5: For i from 0 to n-1: dp[i][i] = 1 // single chars\n\n→ Step 6: For len from 2 to n: // substring length\n\n→ Step 7: For i from 0 to n - len:\n\n→ Step 8: Let j = i + len -1\n\n→ Decision: If s[i] == s[j]?\n\n    Yes → Step 9: If len == 2? // two equal chars\n\n        Yes → dp[i][j] = 2\n\n        No → dp[i][j] = dp[i+1][j-1] + 2\n\n    No → Step 10: dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n\n→ Step 11: Output dp[0][n-1] // answer\n\nEnd\n\nBut we must use arrows and indent. Use Decision: If etc. The format: Use indentation as example.\n\nWe must provide each line: virtual step + comment.\n\nWe need to maintain arrow structure.\n\nLet's craft properly:\n\nStart // 程式開始\n\n→ Step 1: 讀取字串 s // 取得輸入字串\n\n→ Step 2: 令 n = s 的長度 // 取得字串長度\n\n→ Decision: n 為 0? // 判斷是否為空字串\n\n    Yes → Step 3: 輸出 0 // 空字串長度為 0\n\n    No  → Step 4: 初始化 2D 陣列 dp[n][n] 為 0 // 建立 DP 表\n\n→ Step 5: 依序設定 dp[i][i] = 1 // 單個字元為回文子序列長度 1\n\n→ Step 6: 迴圈 len 從 2 到 n // 依子字串長度遞增\n\n→ Step 7: 迴圈 i 從 0 到 n - len // 迭代子字串起點\n\n→ Step 8: 設 j = i + len - 1 // 取得子字串結束索引\n\n→ Decision: s[i] 與 s[j] 相等? // 檢查兩端字元是否相同\n\n    Yes → Decision: len 為 2? // 兩字元相同時特殊處理\n\n        Yes → Step 9: dp[i][j] = 2 // 兩字元相同，長度 2\n\n        No  → Step 10: dp[i][j] = dp[i+1][j-1] + 2 // 內部已計算，外加兩端\n\n    No  → Step 11: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取最大子序列長度\n\n→ Step 12: 輸出 dp[0][n-1] // 回傳整個字串的長度\n\nEnd // 程式結束\n\nNeed to ensure each line uses arrow appropriately. Use “→” preceding each step. For Decision branches, indent Yes/No.\n\nAlso we used Step numbers for clarity.\n\nReturn final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s // 從使用者取得輸入字串  \n→ Step 2: 令 n = s 的長度 // 取得字串長度  \n→ Decision: n 為 0? // 判斷是否為空字串  \n Yes → Step 3: 輸出 0 // 空字串長度為 0  \n No  → Step 4: 初始化 2D 陣列 dp[n][n] 為 0 // 建立 DP 表格  \n→ Step 5: 依序設定 dp[i][i] = 1 // 單個字元為回文子序列長度 1  \n→ Step 6: 迴圈 len 從 2 到 n // 依子字串長度遞增  \n → Step 7: 迴圈 i 從 0 到 n - len // 迭代子字串起點  \n  → Step 8: 設 j = i + len - 1 // 取得子字串結束索引  \n  → Decision: s[i] 與 s[j] 相等? // 檢查兩端字元是否相同  \n   Yes → Decision: len 為 2? // 兩字元相同時特殊處理  \n    Yes → Step 9: dp[i][j] = 2 // 兩字元相同，長度 2  \n    No  → Step 10: dp[i][j] = dp[i+1][j-1] + 2 // 內部已計算，外加兩端  \n   No  → Step 11: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取最大子序列長度  \n→ Step 12: 輸出 dp[0][n-1] // 回傳整個字串的長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]\n\ndef main():\n    data = sys.stdin.read()\n    s = data.strip()\n    # 如果輸入帶引號，移除外層引號\n    if len(s) >= 2 and s[0] == s[-1] == '\"':\n        s = s[1:-1]\n    solution = Solution()\n    result = solution.longestPalindromeSubseq(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode4.json",
    "problem_index_in_file": 0,
    "title": "Median of Two Sorted Arrays",
    "description_snippet": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. The problem is find median of two sorted arrays in O(log(m+n)). Classic algorithm: binary search partition. We'll describe steps. Provide virtual code steps with explanation. Use arrows and Decision etc. Should be clear.\n\nWe need to use Start, End, Decision, etc. Should produce a step-by-step. We don't output actual code. Just pseudo-code.\n\nOk produce lines. Let's write:\n\nStart // begin\n→ Step 1: Ensure nums1 is the smaller array // easier binary search on shorter array\n\n→ Decision: If m > n? // if first array longer\n    Yes → Step 2: Swap nums1 and nums2; m↔n // swap so nums1 is shorter\n    No  → Continue\n\n→ Step 3: Set low=0, high=m // search range on first array\n\n→ Decision: While low <= high? // binary search loop\n    Yes →\n        → Step 4: Compute partitionX = (low+high)/2 // mid index in nums1\n        → Step 5: Compute partitionY = (m+n+1)/2 - partitionX // corresponding index in nums2\n        → Step 6: maxLeftX = if partitionX==0 ? -∞ : nums1[partitionX-1] // left max of nums1\n        → Step 7: minRightX = if partitionX==m ? +∞ : nums1[partitionX] // right min of nums1\n        → Step 8: maxLeftY = if partitionY==0 ? -∞ : nums2[partitionY-1] // left max of nums2\n        → Step 9: minRightY = if partitionY==n ? +∞ : nums2[partitionY] // right min of nums2\n        → Decision: If maxLeftX <= minRightY AND maxLeftY <= minRightX? // correct partition\n            Yes →\n                → Step 10: If (m+n) is even? // total length even\n                    Yes →\n                        → Step 11: median = (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2 // average of two middles\n                    No →\n                        → Step 12: median = max(maxLeftX, maxLeftY) // middle element\n                → Step 13: Return median // output result\n            No →\n                → Decision: If maxLeftX > minRightY? // too far right in nums1\n                    Yes → Step 14: high = partitionX - 1 // move left\n                    No  → Step 15: low = partitionX + 1 // move right\n    No  → End // exit loop\n\nBut we need line by line with arrows and explanation. Provide each line. Ensure each line is one statement. For decisions with branches, we indent. Use 'Yes →' 'No →' lines. Keep format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: If length(nums1) > length(nums2) swap(nums1, nums2) // 確保 nums1 為較短陣列，便於二分搜尋  \n→ Step 2: m ← length(nums1) ← length(nums1) // 重新設定 m 為 nums1 長度  \n→ Step 3: n ← length(nums2) ← length(nums2) // 重新設定 n 為 nums2 長度  \n→ Step 4: low ← 0 // 二分搜尋的左邊界  \n→ Step 5: high ← m // 二分搜尋的右邊界  \n→ Decision: low ≤ high? // 是否仍有搜尋空間  \n    Yes → Step 6: partitionX ← (low + high) // 2 // 計算 nums1 的分割點  \n    → Step 7: partitionY ← (m + n + 1) // 2 - partitionX // 對應 nums2 的分割點  \n    → Step 8: maxLeftX ← if partitionX == 0 then -∞ else nums1[partitionX - 1] // nums1 左側最大值  \n    → Step 9: minRightX ← if partitionX == m then +∞ else nums1[partitionX] // nums1 右側最小值  \n    → Step 10: maxLeftY ← if partitionY == 0 then -∞ else nums2[partitionY - 1] // nums2 左側最大值  \n    → Step 11: minRightY ← if partitionY == n then +∞ else nums2[partitionY] // nums2 右側最小值  \n    → Decision: maxLeftX ≤ minRightY AND maxLeftY ≤ minRightX? // 是否找到正確分割  \n        Yes → Step 12: If (m + n) % 2 == 0? // 總長度是否為偶數  \n            Yes → Step 13: median ← (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2 // 偶數時取兩中間值平均  \n            No  → Step 14: median ← max(maxLeftX, maxLeftY) // 奇數時取中間值  \n        → Step 15: Return median // 回傳結果  \n        No  → Decision: maxLeftX > minRightY? // 是否需要往左調整  \n            Yes → Step 16: high ← partitionX - 1 // 向左移動搜尋區間  \n            No  → Step 17: low ← partitionX + 1 // 向右移動搜尋區間  \n    → End // 所有分割情況已處理完畢  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        # Ensure nums1 is the smaller array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        total = m + n\n        half = total // 2\n\n        left, right = 0, m - 1\n        while True:\n            i = (left + right) // 2\n            j = half - i - 2\n\n            Aleft = nums1[i] if i >= 0 else float('-inf')\n            Aright = nums1[i + 1] if (i + 1) < m else float('inf')\n            Bleft = nums2[j] if j >= 0 else float('-inf')\n            Bright = nums2[j + 1] if (j + 1) < n else float('inf')\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0\n            elif Aleft > Bright:\n                right = i - 1\n            else:\n                left = i + 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Find the two list literals in the input\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) >= 2:\n        nums1 = ast.literal_eval(lists[0])\n        nums2 = ast.literal_eval(lists[1])\n    else:\n        nums1, nums2 = [], []\n\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "success": true,
          "output": "2.00000"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "expected_output": "2.50000",
          "success": true,
          "output": "2.50000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode201.json",
    "problem_index_in_file": 0,
    "title": "Bitwise AND of Numbers Range",
    "description_snippet": "Given two integers left and right that represent the range [left, right], return the bitwise AND of ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code, step by step, with explanations. The problem: bitwise AND of all numbers in range left..right inclusive. We need algorithm: find common prefix of left and right by shifting right until equal, count shifts, then left << shift. Steps: input left, right, shift counter 0, while left != right: left = left >> 1; right = right >> 1; shift++ ; result = left << shift ; output result. Also handle edge cases. Let's produce virtual code lines. Use structure: Start, Step 1: Input left, right, Step 2: Initialize shift = 0, Step 3: While left != right, do shift++ and shift both right, left. After loop, result = left << shift. Output. End. Provide explanations. Use arrow etc.\n\nWe need to adhere to formatting: \"虛擬碼步驟 [space] // 解釋\". Use arrow: \"→\". Provide indentation maybe but keep formatting consistent.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input left, right // 從使用者取得兩個整數代表區間端點  \n→ Step 2: Set shift ← 0 // 用來計算左移位數，初始為 0  \n→ Decision: 當 left ≠ right? // 判斷是否還有不相同的位元  \n  Yes → Step 3: left ← left >> 1 // 將左端點右移一位，丟棄最低位元  \n    right ← right >> 1 // 將右端點右移一位，丟棄最低位元  \n    shift ← shift + 1 // 記錄已經右移的位數  \n    → Decision: 回到 \"當 left ≠ right?\" // 重複直到兩數相同  \n  No → Step 4: result ← left << shift // 把已找到的公共前綴左移回原位，得到區間 AND 結果  \n→ Step 5: Output result // 顯示最終的位元 AND 值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        \"\"\"Compute bitwise AND of all numbers in the inclusive range [left, right].\"\"\"\n        shift = 0\n        while left < right:\n            left >>= 1\n            right >>= 1\n            shift += 1\n        return left << shift\n\ndef main() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中提取所有整數（支援負數）\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) < 2:\n        return\n    left, right = map(int, nums[:2])\n\n    solution = Solution()\n    result = solution.rangeBitwiseAnd(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 5, right = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 0, right = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "left = 1, right = 2147483647",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode313.json",
    "problem_index_in_file": 0,
    "title": "Super Ugly Number",
    "description_snippet": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step, using the format. The algorithm: typical super ugly number problem. Use DP with pointers array idx for each prime. Ugly numbers array of size n. For i from 1 to n-1 compute next ugly = min(primes[j]*ugly[idx[j]]). Then increment idx for each prime that equals next. Output ugly[n-1]. Provide steps accordingly.\n\nLet's produce lines like:\n\nStart\n→ Step 1: 初始化 ugly[0] = 1 // 第一个超丑数\n→ Step 2: 初始化 idx[j] = 0 for all primes // 每个质因子指针\n→ Step 3: 初始化 nexts[j] = primes[j] // 初始候选值\n→ For i from 1 to n-1:\n    → Step 4: minNext = min(nexts) // 找到最小候选\n    → Step 5: ugly[i] = minNext // 记录下一个超丑数\n    → Step 6: For each j where nexts[j] == minNext:\n        → Increment idx[j]\n        → Update nexts[j] = primes[j] * ugly[idx[j]]\nEnd\n\nNeed to output each line with comment. Use \"→ Decision:\" maybe for loops but not necessary. We can express loops as \"→ For ...\".\n\nOk produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 ugly[0] = 1 // 第一個超丑數固定為 1  \n→ Step 2: 初始化 idx[j] = 0 for all j in 0..primes.length-1 // 每個質因子對應的指標初始為 0  \n→ Step 3: 初始化 nexts[j] = primes[j] // 初始候選值為每個質因子本身  \n→ For i from 1 to n-1: // 產生第 2~n 個超丑數  \n  → Step 4: minNext = min(nexts) // 找出所有候選值中的最小者  \n  → Step 5: ugly[i] = minNext // 把最小值記錄為第 i 個超丑數  \n  → Step 6: For each j where nexts[j] == minNext: // 所有產生此最小值的質因子  \n    → idx[j] = idx[j] + 1 // 對應指標往後移  \n    → nexts[j] = primes[j] * ugly[idx[j]] // 更新該質因子對應的下一候選值  \nEnd // 程式執行結束，ugly[n-1] 為答案。",
      "generated_code": "import sys\nimport re\n\ndef nth_super_ugly_number(n, primes):\n    # ugly[0] is 1\n    ugly = [1]\n    # indices for each prime\n    indices = [0] * len(primes)\n    # current candidate values for each prime\n    vals = list(primes)\n\n    for _ in range(1, n):\n        # next ugly number is the smallest candidate\n        next_ugly = min(vals)\n        ugly.append(next_ugly)\n\n        # update all primes that produced this next ugly\n        for i in range(len(primes)):\n            if vals[i] == next_ugly:\n                indices[i] += 1\n                vals[i] = ugly[indices[i]] * primes[i]\n\n    return ugly[-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    # Extract n\n    n_match = re.search(r'n\\s*=\\s*(\\d+)', data)\n    if n_match:\n        n = int(n_match.group(1))\n    else:\n        # Fallback: try to read first integer\n        nums = re.findall(r'\\d+', data)\n        n = int(nums[0]) if nums else 0\n\n    # Extract primes list\n    primes_match = re.search(r'primes\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if primes_match:\n        try:\n            primes = eval(primes_match.group(1))\n        except Exception:\n            primes = []\n    else:\n        # Fallback: try to find all numbers after the first one\n        nums = re.findall(r'\\d+', data)\n        primes = list(map(int, nums[1:]))\n\n    result = nth_super_ugly_number(n, primes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12, primes = [2,7,13,19]",
          "expected_output": "32",
          "success": true,
          "output": "32"
        },
        {
          "example_index": 1,
          "input": "n = 1, primes = [2,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode448.json",
    "problem_index_in_file": 0,
    "title": "Find All Numbers Disappeared in an Array",
    "description_snippet": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines for algorithm: find missing numbers in array. Classic algorithm O(n) time and O(1) extra (except output). Steps: iterate, mark presence by negating index. Then iterate to find positives. We produce pseudocode with arrows and decisions. Use Start, End, Decision. Provide brief explanation after //. Must not output real code. Use virtual code. Each line: \"虛擬碼步驟 // 解釋\". Let's create.\n\nLine1: Start\nLine2: → Input nums // 取得輸入陣列\nLine3: → n = length of nums // 取得陣列長度\nLine4: → For i from 0 to n-1 // 迭代每個元素\nLine5: →     val = abs(nums[i]) // 取得正值\nLine6: →     idx = val - 1 // 對應索引\nLine7: →     If nums[idx] > 0? // 判斷是否未標記\nLine8: →         Yes → nums[idx] = -nums[idx] // 標記為已出現\nLine9: →         No  // 已標記，無需變動\nLine10: → End For // 完成標記\nLine11: → missing = empty list // 初始化結果\nLine12: → For i from 0 to n-1 // 迭代檢查未標記\nLine13: →     If nums[i] > 0? // 若為正則未出現\nLine14: →         Yes → missing.append(i+1) // 加入結果\nLine15: →         No  // 已出現，跳過\nLine16: → End For // 完成收集\nLine17: → Return missing // 輸出結果\nLine18: End\n\nBut we need arrow syntax. We should show arrow at each step. For loops we show → For. For decision inside loops, indent with arrow? Example: Decision lines: Decision: If nums[idx] > 0? etc. Use Yes→ etc.\n\nLet's create exactly as example. Use \"Decision:\" lines. So we rewrite.\n\nStart // 程式開始執行\n→ Input nums // 取得輸入陣列\n→ n = length of nums // 取得陣列長度\n→ For i from 0 to n-1 // 迭代每個元素\n    → val = abs(nums[i]) // 取得 nums[i] 的正值\n    → idx = val - 1 // 對應索引\n    → Decision: nums[idx] > 0? // 判斷 idx 元素是否未標記\n        Yes → nums[idx] = -nums[idx] // 標記為已出現\n        No  // 已標記，保持不變\n→ End For // 標記完成\n→ missing = empty list // 初始化結果\n→ For i from 0 to n-1 // 迭代檢查未標記\n    → Decision: nums[i] > 0? // 判斷 i 位置是否未出現\n        Yes → missing.append(i+1) // 加入缺失數字\n        No  // 已出現，跳過\n→ End For // 收集完成\n→ Return missing // 回傳缺失數字\nEnd // 程式結束\n\nCheck formatting: Use arrows \"→\". For decision lines need \"Decision: ... ?\" and indent the Yes / No lines with spaces.\n\nEnsure each line has space after code then // explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得輸入陣列  \n→ n = length of nums // 取得陣列長度  \n→ For i from 0 to n-1 // 迭代每個元素  \n → val = abs(nums[i]) // 取得 nums[i] 的正值  \n → idx = val - 1 // 對應索引  \n → Decision: nums[idx] > 0? // 判斷 idx 元素是否未標記  \n  Yes → nums[idx] = -nums[idx] // 標記為已出現  \n  No  // 已標記，保持不變  \n→ End For // 標記完成  \n→ missing = empty list // 初始化結果  \n→ For i from 0 to n-1 // 迭代檢查未標記  \n → Decision: nums[i] > 0? // 判斷 i 位置是否未出現  \n  Yes → missing.append(i+1) // 加入缺失數字  \n  No  // 已出現，跳過  \n→ End For // 收集完成  \n→ Return missing // 回傳缺失數字  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\ndef findDisappearedNumbers(nums):\n    n = len(nums)\n    for num in nums:\n        index = abs(num) - 1\n        nums[index] = -abs(nums[index])\n    return [i + 1 for i in range(n) if nums[i] > 0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將可能包含的前綴 \"nums = \" 去除\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n    else:\n        rhs = data\n    rhs = rhs.strip()\n    try:\n        nums = ast.literal_eval(rhs)\n    except Exception:\n        nums = eval(rhs)  # 只在 literal_eval 失敗時使用\n    result = findDisappearedNumbers(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[5,6]",
          "success": true,
          "output": "[5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode273.json",
    "problem_index_in_file": 0,
    "title": "Integer to English Words",
    "description_snippet": "Convert a non-negative integer num to its English words representation....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for converting a non-negative integer to English words. We need to output step-by-step, each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows, Start, End, Decision.\n\nWe need to describe algorithm: handle numbers 0-999, thousands, millions, billions. Use mapping arrays. Steps: define words for units, teens, tens, thousands groups. Split number into groups of three digits. For each group, convert to words. Assemble with scale names (thousand, million, billion). Edge case 0 -> \"Zero\".\n\nWe need to present as virtual code, not actual code.\n\nOk produce steps.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義單位、十位、百位字典 // 準備數字到英文單詞的映射  \n→ Step 2: 定義千級別詞語（如 Thousand, Million, Billion） // 用於拼接較大數字  \n→ Decision: 檢查輸入數字 num 是否等於 0?  \n    Yes → Step 3: 輸出 'Zero' // 零的直接輸出  \n    No  → Step 4: 將 num 轉成字串，按每三位分組 // 方便後續分段處理  \n→ Step 5: 初始化空列表 words // 用於存儲各段的英文詞  \n→ Decision: 從最右邊開始，遍歷每個三位數段  \n    Yes → Step 6: 取出該段的三位數值 seg // 取單獨段落  \n    → Step 7: 如果 seg 為 0，跳過此段並繼續 // 零段不需輸出  \n    → Decision: 先處理百位（若有）  \n        Yes → Step 8: words.add(單位[百位]) + 'Hundred' // 加入百位詞  \n        No  → Step 9: 不做任何操作 // 無百位時略過  \n    → Decision: 處理十位與個位（十到十九）  \n        Yes → Step 10: 如果十位為 1，words.add(十到十九[個位]) // 直接用特殊詞  \n        No  → Step 11: words.add(十位詞[十位]) // 加入十位詞（Twenty, Thirty…）  \n            → Decision: 個位是否為 0?  \n                Yes → Step 12: 跳過個位處理  \n                No  → Step 13: words.add(單位[個位]) // 加入個位詞  \n    → Decision: 是否有千級別詞需要加入？  \n        Yes → Step 14: words.add(千級別詞[段索引]) // 加入 Thousand/Million/Billion 等  \n        No  → Step 15: 不加入任何級別詞 // 最右段不加  \n    → Step 16: 轉換完此段後，返回上一決策循環  \n→ Step 17: 將 words 列表倒序並用空格連接成最終字串 // 反轉順序，合併成一句話  \n→ Step 18: 輸出最終字串 // 顯示完整英文表示  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        def one(n: int) -> str:\n            words = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n            return words[n]\n\n        def two_less_20(n: int) -> str:\n            words = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\n                     \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            return words[n - 10]\n\n        def ten(n: int) -> str:\n            words = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            return words[n]\n\n        def two(n: int) -> str:\n            if n == 0:\n                return \"\"\n            if n < 10:\n                return one(n)\n            if n < 20:\n                return two_less_20(n)\n            tens = n // 10\n            rest = n % 10\n            return ten(tens) + (\" \" + one(rest) if rest != 0 else \"\")\n\n        def three(n: int) -> str:\n            hundred = n // 100\n            rest = n % 100\n            if hundred != 0 and rest != 0:\n                return one(hundred) + \" Hundred \" + two(rest)\n            if hundred == 0 and rest != 0:\n                return two(rest)\n            if hundred != 0 and rest == 0:\n                return one(hundred) + \" Hundred\"\n            return \"\"\n\n        billion = num // 1_000_000_000\n        million = (num - billion * 1_000_000_000) // 1_000_000\n        thousand = (num - billion * 1_000_000_000 - million * 1_000_000) // 1_000\n        rest = num % 1_000\n\n        result_parts = []\n        if billion != 0:\n            result_parts.append(three(billion) + \" Billion\")\n        if million != 0:\n            result_parts.append(three(million) + \" Million\")\n        if thousand != 0:\n            result_parts.append(three(thousand) + \" Thousand\")\n        if rest != 0:\n            result_parts.append(three(rest))\n\n        return \" \".join(result_parts)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r\"-?\\d+\", data)\n    num = int(match.group()) if match else 0\n    solution = Solution()\n    result = solution.numberToWords(num)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 123",
          "expected_output": "\"One Hundred Twenty Three\"",
          "success": true,
          "output": "One Hundred Twenty Three"
        },
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "success": true,
          "output": "Twelve Thousand Three Hundred Forty Five"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "success": true,
          "output": "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode632.json",
    "problem_index_in_file": 0,
    "title": "Smallest Range Covering Elements from K Lists",
    "description_snippet": "You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for algorithm to find smallest range covering at least one number from each of k sorted lists. Classic problem: find minimum range that includes at least one number from each of the k lists. Approach: use min-heap of size k, keep track of current max. Slide window. Steps: initialize heap with first element of each list along with list index and element index. Maintain current_max as max of first elements. While heap not empty: pop min, update range if current range smaller. Then push next element from same list if exists, update current_max. Continue. End. Output range. Provide virtual code lines with explanation. Use Start, End, Decision. We'll need variable names. Provide logic: Input: lists[][]; k = number of lists.\n\nWe produce:\n\nStart // program start\n→ Step 1: k ← number of lists // determine number of lists\n→ Step 2: initialize min-heap H // heap to store (value, list_index, element_index)\n→ Step 3: max_val ← -∞ // current maximum value in heap\n→ Decision: For each list i from 0 to k-1 // iterate through lists\n    → Step 4: if list i is not empty\n        → Step 5: insert (list[i][0], i, 0) into H\n        → Step 6: if list[i][0] > max_val → max_val ← list[i][0]\n    → No → // skip empty lists (if any)\n→ Step 7: best_start ← 0, best_end ← ∞ // best range found\n→ Step 8: while H is not empty\n    → Step 9: (min_val, i, idx) ← pop from H // smallest current value\n    → Decision: if (max_val - min_val) < (best_end - best_start) or ((max_val - min_val) == (best_end - best_start) and min_val < best_start)\n        → Step 10: best_start ← min_val\n        → Step 11: best_end ← max_val\n    → Decision: if idx + 1 < length of list i\n        → Step 12: next_val ← list[i][idx+1]\n        → Step 13: insert (next_val, i, idx+1) into H\n        → Decision: if next_val > max_val\n            → Step 14: max_val ← next_val\n        → No → // no update to max\n    → No → // no more elements in list i; loop ends when heap empty\n→ Step 15: output [best_start, best_end] // result\nEnd // program finish\n\nNeed to use decision arrows. Provide explanation. Ensure each line ends with // explanation. Use virtual code formatting. Provide each step with line breaks. Ensure '→' arrow after indent? They want each line with arrow if step? Format: \"→ Step 1: ...\" They also used indent for nested decisions. We'll follow sample.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: k ← number of lists // 確定有幾個列表  \n→ Step 2: initialize min-heap H // 用最小堆保存 (值, 列表索引, 元素索引)  \n→ Step 3: max_val ← -∞ // 目前堆中最大的值  \n→ Decision: 對於每個列表 i 從 0 到 k-1  \n  Yes → Step 4: if list[i] 非空  \n   Yes → Step 5: insert (list[i][0], i, 0) into H // 把每個列表的第一個元素放入堆  \n   Yes → Step 6: if list[i][0] > max_val → max_val ← list[i][0] // 更新最大值  \n  No → // 若列表為空則略過  \n→ Step 7: best_start ← 0, best_end ← ∞ // 儲存目前最小範圍  \n→ Step 8: while H is not empty // 當堆中還有元素時  \n  Step 9: (min_val, i, idx) ← pop from H // 取出最小值  \n  Decision: if (max_val - min_val) < (best_end - best_start) 或者 (max_val - min_val == best_end - best_start 且 min_val < best_start)  \n   Yes → Step 10: best_start ← min_val // 更新最小起點  \n   Yes → Step 11: best_end ← max_val // 更新最大終點  \n  Decision: if idx + 1 < length(list[i]) // 該列表還有下一個元素  \n   Yes → Step 12: next_val ← list[i][idx+1]  \n   Yes → Step 13: insert (next_val, i, idx+1) into H // 把下一個元素放入堆  \n   Yes → Decision: if next_val > max_val  \n    Yes → Step 14: max_val ← next_val // 更新最大值  \n    No → // 不需要更新最大值  \n  No → // 該列表已經沒有更多元素，直接回到 while 迴圈  \n→ Step 15: output [best_start, best_end] // 回傳最小範圍  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass Solution:\n    def smallestRange(self, nums):\n        \"\"\"\n        Find the smallest range that includes at least one number from each of the k lists.\n        nums: List[List[int]] - each inner list is sorted in non-decreasing order.\n        Returns: List[int] - [start, end] of the smallest range.\n        \"\"\"\n        # Initialize min-heap and current maximum value\n        heap = []\n        current_max = float('-inf')\n        for i, lst in enumerate(nums):\n            heapq.heappush(heap, (lst[0], i, 0))  # (value, list_index, element_index)\n            current_max = max(current_max, lst[0])\n\n        # Best range found so far\n        best_start, best_end = -1, -1\n        best_len = float('inf')\n\n        # Slide window until one list is exhausted\n        while True:\n            min_val, list_idx, elem_idx = heapq.heappop(heap)\n\n            # Update best range if this window is smaller or ties with smaller start\n            window_len = current_max - min_val\n            if window_len < best_len or (window_len == best_len and min_val < best_start):\n                best_len = window_len\n                best_start, best_end = min_val, current_max\n\n            # If the current list has more elements, push the next one\n            if elem_idx + 1 < len(nums[list_idx]):\n                next_val = nums[list_idx][elem_idx + 1]\n                heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n                current_max = max(current_max, next_val)\n            else:\n                # One list is exhausted; cannot find a better range\n                break\n\n        return [best_start, best_end]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Parse input: expect format like \"nums = [[...], [...], ...]\"\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception as e:\n        raise ValueError(f\"Invalid input format: {e}\")\n\n    sol = Solution()\n    result = sol.smallestRange(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]",
          "expected_output": "[20,24]",
          "success": true,
          "output": "[20, 24]"
        },
        {
          "example_index": 1,
          "input": "nums = [[1,2,3],[1,2,3],[1,2,3]]",
          "expected_output": "[1,1]",
          "success": true,
          "output": "[1, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode567.json",
    "problem_index_in_file": 0,
    "title": "Permutation in String",
    "description_snippet": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, each line with \"虛擬碼步驟\" and comment. Must use arrows and structure. Problem: given two strings s1 and s2, determine if s2 contains a permutation of s1. Classic sliding window. Use frequency array or map. Steps: if s1 length > s2 length return false. Count freq of s1. Use window count for s2 sliding. Count matches or difference. For simplicity, use frequency difference array. Steps: initialize counts for s1, window of s2 first len(s1), check if equal, slide. Return true if any match. End. Ensure virtual code syntax. Provide explanation for each line. Use \"Start\", \"End\". Use Decision arrows. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 s1 長度是否大於 s2 長度 // 若 s1 長於 s2，無法匹配  \n→ Decision: s1 長度 > s2 長度?  \n    Yes → Step 2: 回傳 false // 不可能包含任何排列  \n    No  → Step 3: 建立陣列 count[26] 初始化為 0 // 用於統計 s1 中每個字母的頻率  \n→ Step 4: 迭代 i 從 0 到 len(s1)-1  \n    → Step 5: count[ s1[i] - 'a' ]++ // 增加 s1 字母的頻率  \n→ Step 6: 建立陣列 window[26] 初始化為 0 // 滑動視窗中 s2 的字母頻率  \n→ Step 7: 迭代 i 從 0 到 len(s1)-1  \n    → Step 8: window[ s2[i] - 'a' ]++ // 將 s2 前 len(s1) 個字母加入窗口  \n→ Step 9: 迭代 i 從 0 到 25  \n    → Decision: count[i] == window[i]?  \n        Yes → continue  \n        No  → Step 10: 匹配失敗 → 跳至 Step 11  \n→ Step 10: 匹配成功 → 回傳 true // 初始窗口已符合 s1 的排列  \n→ Step 11: 迭代 i 從 len(s1) 到 len(s2)-1  \n    → Step 12: window[ s2[i] - 'a' ]++ // 新字母進入窗口  \n    → Step 13: window[ s2[i-len(s1)] - 'a' ]-- // 失去的舊字母移出窗口  \n    → Step 14: 迭代 j 從 0 到 25  \n        → Decision: count[j] == window[j]?  \n            Yes → continue  \n            No  → Step 15: 匹配失敗 → 跳至 Step 16  \n    → Step 15: 匹配成功 → 回傳 true // 滑動窗口現在符合排列  \n    → Step 16: 繼續下一個窗口  \n→ Step 17: 所有窗口都檢查完畢 → 回傳 false // 沒有任何窗口符合排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        \"\"\"\n        回傳 s2 是否包含 s1 任一排列的子字串。\n        透過滑動窗口與字母頻率 Counter 比對是否相等。\n        \"\"\"\n        len1, len2 = len(s1), len(s2)\n        if len1 > len2:\n            return False\n\n        # s1 的字母頻率\n        s1_count = Counter(s1)\n        # s2 前 len1 個字母的頻率\n        window_count = Counter(s2[:len1])\n\n        if s1_count == window_count:\n            return True\n\n        for i in range(len1, len2):\n            start_char = s2[i - len1]   # 失去的字母\n            end_char = s2[i]            # 新進入的字母\n\n            # 新字母進入窗口\n            window_count[end_char] += 1\n            # 舊字母離開窗口\n            window_count[start_char] -= 1\n            if window_count[start_char] == 0:\n                del window_count[start_char]\n\n            if window_count == s1_count:\n                return True\n\n        return False\n\ndef main():\n    \"\"\"\n    讀取標準輸入，格式可能為：\n    s1 = \"ab\", s2 = \"eidbaooo\"\n    或簡單的兩個字串以空白或換行分隔。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 嘗試抓取雙引號中的字串\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        s1, s2 = quoted[0], quoted[1]\n    else:\n        # 以空白或換行分割，取前兩個非空項\n        parts = [part for part in data.split() if part]\n        if len(parts) >= 2:\n            s1, s2 = parts[0], parts[1]\n        else:\n            # 讀取不到足夠資料時直接結束\n            return\n\n    solution = Solution()\n    result = solution.checkInclusion(s1, s2)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode89.json",
    "problem_index_in_file": 0,
    "title": "Gray Code",
    "description_snippet": "An n-bit gray code sequence is a sequence of 2^n integers where:\n\nEvery integer is in the inclusive ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines that describe algorithm. Use Start, Decision, etc. Provide step by step. Should produce a Gray code sequence of length 2^n, first 0, each adjacent differs by one bit, first and last differ by one bit. We can use standard recursive or iterative method: for n bits, Gray code G(n) = [0]*G(n-1) + [2^(n-1)+x for x in reversed(G(n-1))]. That yields cycle. Implementation steps: compute length, initialize list with [0], for i in range(1, n+1) produce new list. Provide algorithm. Output should be virtual code lines, not actual code. Use arrows. Provide explanation after each line.\n\nWe need to output step by step, no real code. Each line includes virtual code step and comment.\n\nWe need to produce final answer. Let's craft lines:\n\nStart\n→ Step 1: Initialize result list with [0] // start with first gray code\n→ Decision: n equals 0? // handle trivial case\n    Yes → Step 2: Return result // if n=0, sequence is just [0]\n    No  → Step 3: Set current_bit = 1 // bit position to add, start with 1 (2^0)\n→ Step 4: While current_bit <= 2^(n-1) // iterate over bits 1 to n-1\n    // but easier: for i from 1 to n-1: generate new list\nBut maybe simpler: loop i from 1 to n-1. Use Step 5.\n\nLet's write algorithm:\n\nStep 4: For i from 1 to n-1:\n   → Step 4.1: Compute prefix = 1 << (i-1) // value of new bit\n   → Step 4.2: For each number x in reversed(result): append prefix + x // reflect and add new bit\n   → Step 4.3: Append new numbers to result // extend list\nBut we need to maintain result list.\n\nAlternatively we can just loop i in 1..n-1: new_list = result + [prefix + x for x in reversed(result)]; result = new_list.\n\nWe'll produce virtual code lines accordingly.\n\nEdge case n=1: sequence [0,1] works. Our loop i from 1 to n-1 would not execute if n=1. We need to handle n=1 separately: result currently [0], we then need to append 1. That can be handled by loop if we loop i from 0 to n-1 inclusive? Let's do for i from 0 to n-1: each iteration adds bit 2^i. Starting with result [0], for i=0: prefix = 1<<0 = 1; new_list = result + [prefix + x for x in reversed(result)] = [0] + [1] => [0,1]; for i=1 if n>1: prefix=2; etc.\n\nThus loop i from 0 to n-1.\n\nWe'll produce:\n\n→ Step 4: For i from 0 to n-1:\n   → Step 4.1: prefix = 1 << i // value of new bit\n   → Step 4.2: new_part = [prefix + x for x in reversed(result)] // reflect with new bit\n   → Step 4.3: result = result + new_part // extend list\n\nAt the end result length is 2^n, first element 0, adjacent differ by one bit, cyclic property holds.\n\nReturn result.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: Set result = [0] // initial gray code list\n→ Decision: n equals 0? // handle n=0\n    Yes → Step 2: Return result // only 0\n    No  → Step 3: For i from 0 to n-1 // iterate through each bit position\n        → Step 3.1: prefix = 1 << i // bit value to add\n        → Step 3.2: new_part = [prefix + x for x in reversed(result)] // reflect and set new bit\n        → Step 3.3: result = result + new_part // append reflected part\n→ Step 4: Return result // final gray code sequence\n\nBut we need to maintain the structure of decisions: we can embed for loop inside else branch.\n\nAlternatively, we can treat for loop as part of algorithm step, not decision.\n\nBut per format, we can use Decision for n=0. Provide loop.\n\nLet's produce final answer accordingly.\n\nAlso we may include explanation of cyclic property: result ensures adjacency difference because each new part differs by one bit from previous part and first and last differ by one bit due to construction.\n\nLet's craft final virtual code lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 result = [0] // 初始 Gray Code 序列為 0\n→ Decision: n 等於 0? // 是否為零位\n    Yes → Step 2: 回傳 result // 零位 Gray Code 只有 0\n    No  → Step 3: 迴圈 i 從 0 到 n-1 // 逐個新增位元\n        → Step 3.1: prefix = 1 << i // 新增位元的數值 2^i\n        → Step 3.2: new_part = [prefix + x for x in reversed(result)] // 反轉現有序列並在最高位設置 1\n        → Step 3.3: result = result + new_part // 把反轉後的序列追加到 result\n→ Step 4: 回傳 result // 完整的 n 位 Gray Code 序列\n\nThat's all.\n\nBut need to include \"End\" at the end. So:\n\nEnd // 程式執行結束\n\nLet's include that. Also ensure each line ends with comment after //. Provide explanation.\n\nWe'll output as per format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 result = [0] // 初始 Gray Code 序列為 0  \n→ Decision: n 等於 0? // 是否為零位  \n    Yes → Step 2: 回傳 result // 零位 Gray Code 只有 0  \n    No → Step 3: 迴圈 i 從 0 到 n-1 // 逐個新增位元  \n        → Step 3.1: prefix = 1 << i // 新增位元的數值 2^i  \n        → Step 3.2: new_part = [prefix + x for x in reversed(result)] // 反轉現有序列並在最高位設置 1  \n        → Step 3.3: result = result + new_part // 把反轉後的序列追加到 result  \n→ Step 4: 回傳 result // 完整的 n 位 Gray Code 序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef gray_code(n):\n    \"\"\"生成 n 位 Gray 码序列。\"\"\"\n    result = [0]\n    for i in range(n):\n        add = 1 << i            # 新增位元的值 2^i\n        result += [x + add for x in reversed(result)]\n    return result\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中抓取第一個數字作為 n\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n    seq = gray_code(n)\n    print(seq)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,3,2]",
          "success": true,
          "output": "[0, 1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode16.json",
    "problem_index_in_file": 0,
    "title": "3Sum Closest",
    "description_snippet": "Given an integer array nums of length n and an integer target, find three integers in nums such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for three sum closest problem. Use sorting, two-pointer, track best sum. Provide steps line by line. Let's design: Start, Step 1: sort array. Step 2: initialize bestSum to large value. Step 3: for i from 0 to n-3: left=i+1 right=n-1 while left<right: sum=nums[i]+nums[left]+nums[right]; if abs(sum-target) < abs(bestSum-target) update bestSum; if sum==target return target; else if sum<target left++ else right--; End loop. End.\n\nAdd decision steps for sum==target. Provide comments.\n\nLet's format each line with arrow or not. Use Start and End. Use Decision. Use arrow for steps. Ensure each line has virtual code step and // explanation. Use \"→\" arrow after each step. The Decision lines need indentation and arrows.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: sort(nums) // 將數組遞增排序，方便雙指標操作  \n→ Step 2: bestSum ← nums[0] + nums[1] + nums[2] // 初始化最接近目標的三元和  \n→ Step 3: n ← length(nums) // 取得數組長度  \n→ Decision: n < 3? // 檢查是否至少有三個元素  \n    Yes → End // 若不足三個，直接結束（此題已假設 n≥3）  \n    No  → Continue  \n→ For i from 0 to n-3: // 依次選擇第一個元素  \n    → left ← i + 1 // 第二個元素的起始指標  \n    → right ← n - 1 // 第三個元素的終止指標  \n    → While left < right: // 雙指標掃描剩餘部分  \n        → currentSum ← nums[i] + nums[left] + nums[right] // 計算目前三元和  \n        → Decision: abs(currentSum - target) < abs(bestSum - target)? // 比較與最佳值的距離  \n            Yes → bestSum ← currentSum // 更新更接近的和  \n            No  → Continue  \n        → Decision: currentSum == target? // 若正好等於目標  \n            Yes → Return target // 找到最優答案，直接返回  \n            No  → Continue  \n        → Decision: currentSum < target? // 判斷應向哪側調整指標  \n            Yes → left ← left + 1 // 和太小，左指標右移  \n            No  → right ← right - 1 // 和太大，右指標左移  \n→ End // 程式執行結束，bestSum 即為最接近目標的三元和  \nEnd // 程式結束輸出最終結果",
      "generated_code": "import sys\nimport re\n\ndef three_sum_closest(nums, target):\n    \"\"\"\n    Find the sum of three integers in nums that is closest to target.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    # Initialise with a large value (sum of first three after sort)\n    closest = nums[0] + nums[1] + nums[2]\n\n    for i in range(n - 2):\n        left, right = i + 1, n - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            # Update closest if this total is closer to target\n            if abs(total - target) < abs(closest - target):\n                closest = total\n            if total == target:\n                return target            # Exact match, cannot get closer\n            elif total < target:\n                left += 1                 # Need a larger sum\n            else:\n                right -= 1                # Need a smaller sum\n    return closest\n\ndef parse_input(data):\n    \"\"\"\n    Extract 'nums' list and 'target' integer from the input string.\n    Expected format (flexible whitespace):\n        nums = [1, 2, 3], target = 4\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        raise ValueError(\"Input format not recognized.\")\n    nums_str = nums_match.group(1)\n    target_str = target_match.group(1)\n    nums = eval(nums_str)          # Safe in controlled environment\n    target = int(target_str)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    result = three_sum_closest(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,2,1,-4], target = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,0], target = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode747.json",
    "problem_index_in_file": 0,
    "title": "Largest Number At Least Twice of Others",
    "description_snippet": "You are given an integer array nums where the largest integer is unique.\n\nDetermine whether the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem. Use Start, End, Decision, etc. Provide each line with // explanation.\n\nLet's produce steps: initialize variables max1 and max2, idxMax, iterate array to find top two max values, then check condition max1 >= 2*max2. If yes, return idxMax else -1.\n\nMake sure each line is step with arrow. Provide arrow from Start. Use decision with Yes/No. Provide simple explanation. Use virtual code style.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 max1 = -∞, max2 = -∞, idxMax = -1 // 設定最大值、第二大值與最大值索引  \n→ Step 2: 循環遍歷 nums，對每個 index i 與元素 num // 逐一檢查陣列元素  \n    → Decision: 如果 num > max1? // 判斷是否為目前最大值  \n        Yes → Step 3: max2 = max1, max1 = num, idxMax = i // 更新第二大值、最大值與索引  \n        No  → Decision: 如果 num > max2? // 若不是最大值，檢查是否為第二大值  \n            Yes → Step 4: max2 = num // 更新第二大值  \n            No  → Step 5: 繼續下一個元素 // 其它情況不需要改變  \n→ Step 6: Decision: 如果 max1 >= 2 * max2? // 判斷最大值是否至少是第二大值的兩倍  \n    Yes → Step 7: 回傳 idxMax // 最大值符合條件，回傳其索引  \n    No  → Step 8: 回傳 -1 // 不符合條件，回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def dominantIndex(self, nums):\n        # 如果陣列為空直接回傳 -1\n        if not nums:\n            return -1\n\n        # 初始化最大值、第二大值以及最大值索引\n        max1 = -float('inf')\n        max2 = -float('inf')\n        idxMax = -1\n\n        # 逐一遍歷陣列，找出最大值、第二大值和最大值索引\n        for i, num in enumerate(nums):\n            if num > max1:\n                max2 = max1\n                max1 = num\n                idxMax = i\n            elif num > max2:\n                max2 = num\n\n        # 判斷最大值是否至少是第二大值的兩倍\n        if max1 >= 2 * max2:\n            return idxMax\n        return -1\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，並解析為列表\n    data = sys.stdin.read().strip()\n    if not data:\n        nums = []\n    else:\n        # 允許輸入形如 [1,2,3] 的字串\n        nums = ast.literal_eval(data)\n\n    solution = Solution()\n    result = solution.dominantIndex(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,6,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode65.json",
    "problem_index_in_file": 0,
    "title": "Valid Number",
    "description_snippet": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numb...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for validating string s as number per given spec. We need to produce step by step pseudocode, with explanations. Each line: virtual code step + // explanation. Use arrows etc. The structure: Start, → Step X: ...; Decision: ...; Yes → ... No → ... ; End. We should handle parsing logic.\n\nWe need to produce a line by line algorithm.\n\nPlan: Define function isValidNumber(s). Steps: trim whitespace? Not mentioned, but examples no spaces. We'll ignore spaces.\n\nAlgorithm: Use two-phase parse: check integer part optional sign, digits optional, optional dot and fractional digits, optional exponent part.\n\nSimplify: Use regex? But we must produce algorithmic steps.\n\nSo pseudocode: start, set index = 0, len = s.length\n\n1. If s empty → return false.\n\n2. Check optional sign at start: if s[0] in '+-' → index++.\n\n3. Parse digits before dot: count digitsBeforeDot = 0 while index<len && isDigit(s[index]) → index++ count++.\n\n4. Parse optional dot: if index<len && s[index]=='.': index++ ; parse digits after dot: count digitsAfterDot = 0 while index<len && isDigit(s[index]) → index++ count++.\n\n5. Decide if we have a number part: valid if digitsBeforeDot>0 or digitsAfterDot>0 (can't have just '.' alone). If neither → return false.\n\n6. Parse optional exponent: if index<len && (s[index]=='e' || s[index]=='E'): index++; parse optional sign: if index<len && (s[index]=='+'||s[index]=='-') → index++; parse exponent digits: expDigits=0 while index<len && isDigit(s[index]) → index++ expDigits++ ; if expDigits==0 → return false.\n\n7. At end, if index==len → return true else false.\n\nBut we need to produce each step with arrow lines. Use Decision nodes. Let's produce lines accordingly.\n\nUse \"→ Step 1: 定義指標 idx ← 0\" etc.\n\nWe need to produce \"Decision:\" lines for decisions like \"是否為空\" etc.\n\nWe'll produce algorithmic steps, each with explanation.\n\nWe should produce Start, then steps, decisions.\n\nLet's write.\n\nWe can group steps into substeps with indentation. But each line must be a separate line.\n\nOk. Let's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 idx ← 0 // 初始化指標\n→ Step 2: 定義 len ← s.length // 取得字串長度\n→ Decision: 若 len = 0? // 判斷字串是否為空\n    Yes → Step 3: 回傳 False // 空字串不是合法數字\n    No  → // 繼續下一步\n→ Step 4: 若 s[idx] 為 '+' 或 '-'? // 處理前綴符號\n    Yes → idx ← idx + 1 // 跳過符號\n    No  → // 沒有符號\n→ Step 5: 定義 digitBeforeDot ← 0 // 數字前面位數\n→ Decision: 當 idx < len 且 s[idx] 是數字? // 解析整數部分\n    Yes → idx ← idx + 1; digitBeforeDot ← digitBeforeDot + 1; // 累加位數並移動指標\n    No  → // 整數部分結束\n    // 這裡使用迴圈結構，重複上述決策直到不再為數字\n→ Step 6: 判斷是否遇到小數點\n    Yes → idx ← idx + 1 // 跳過 '.'\n    → Step 7: 定義 digitAfterDot ← 0 // 小數點後位數\n    → Decision: 當 idx < len 且 s[idx] 是數字? // 解析小數部分\n        Yes → idx ← idx + 1; digitAfterDot ← digitAfterDot + 1; // 累加並移動\n        No  → // 小數部分結束\n        // 迴圈重複以上決策\n    No  → // 沒有小數點\n→ Decision: 若 digitBeforeDot = 0 且 digitAfterDot = 0? // 需要至少一個數字\n    Yes → Step 8: 回傳 False // 只剩 '.' 或空，非法\n    No  → // 合法的數字部份已存在\n→ Decision: idx < len 且 (s[idx] = 'e' 或 'E')? // 是否有指數\n    Yes → idx ← idx + 1 // 跳過 'e/E'\n    → Step 9: 若 idx < len 且 s[idx] 為 '+' 或 '-'? // 指數符號\n        Yes → idx ← idx + 1 // 跳過符號\n        No  → // 無符號\n    → Step 10: 定義 expDigits ← 0 // 指數部分位數\n    → Decision: 當 idx < len 且 s[idx] 是數字? // 解析指數\n        Yes → idx ← idx + 1; expDigits ← expDigits + 1; // 累加並移動\n        No  → // 指數結束\n        // 重複上述決策直到非數字\n    → Decision: expDigits = 0? // 指數必須至少一個數字\n        Yes → Step 11: 回傳 False // 指數格式錯誤\n        No  → // 指數有效\n    No  → // 沒有指數，直接跳過\n→ Decision: idx = len? // 是否已讀完全部字元\n    Yes → Step 12: 回傳 True // 所有條件滿足，合法數字\n    No  → Step 13: 回傳 False // 存在未處理的字元，非法\nEnd // 程式執行結束\n\nBut we need to maintain \"→\" arrow after each step. Each line is separate.\n\nLet's produce exactly that. Ensure each line ends with comment after //.\n\nMake sure we use arrow for decision nodes: \"Decision:\" etc. Indentation for sub-steps is optional but we can indent lines after decision.\n\nLet's output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: idx ← 0 // 初始化指標\n→ Step 2: len ← s.length // 取得字串長度\n→ Decision: 若 len = 0? // 判斷字串是否為空\n    Yes → Step 3: 回傳 False // 空字串不是合法數字\n    No  → // 繼續下一步\n→ Step 4: 若 s[idx] 為 '+' 或 '-'? // 處理前綴符號\n    Yes → idx ← idx + 1 // 跳過符號\n    No  → // 沒有符號\n→ Step 5: digitBeforeDot ← 0 // 整數部分位數計數\n→ Decision: 當 idx < len 且 s[idx] 是數字? // 解析整數部分\n    Yes → idx ← idx + 1; digitBeforeDot ← digitBeforeDot + 1; // 累加並移動指標\n    No  → // 整數部分結束\n    // 重複上述決策直到非數字\n→ Decision: idx < len 且 s[idx] = '.'? // 檢查是否有小數點\n    Yes → idx ← idx + 1 // 跳過 '.'\n        → Step 6: digitAfterDot ← 0 // 小數點後位數計數\n        → Decision: 當 idx < len 且 s[idx] 是數字? // 解析小數部分\n            Yes → idx ← idx + 1; digitAfterDot ← digitAfterDot + 1; // 累加並移動\n            No  → // 小數部分結束\n            // 重複上述決策直到非數字\n    No  → // 沒有小數點\n→ Decision: digitBeforeDot = 0 且 digitAfterDot = 0? // 至少需要一個數字\n    Yes → Step 7: 回傳 False // 只剩 '.' 或空，非法\n    No  → // 合法的數字部份已存在\n→ Decision: idx < len 且 (s[idx] = 'e' 或 'E')? // 是否有指數\n    Yes → idx ← idx + 1 // 跳過 'e/E'\n        → Step 8: 若 idx < len 且 s[idx] 為 '+' 或 '-'? // 指數符號\n            Yes → idx ← idx + 1 // 跳過符號\n            No  → // 無符號\n        → Step 9: expDigits ← 0 // 指數部分位數計數\n        → Decision: 當 idx < len 且 s[idx] 是數字? // 解析指數\n            Yes → idx ← idx + 1; expDigits ← expDigits + 1; // 累加並移動\n            No  → // 指數結束\n            // 重複上述決策直到非數字\n        → Decision: expDigits = 0? // 指數必須至少一個數字\n            Yes → Step 10: 回傳 False // 指數格式錯誤\n            No  → // 指數有效\n    No  → // 沒有指數，直接跳過\n→ Decision: idx = len? // 是否已讀完全部字元\n    Yes → Step 11: 回傳 True // 所有條件滿足，合法數字\n    No  → Step 12: 回傳 False // 存在未處理的字元，非法\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        if not s:\n            return False\n        num_seen = False\n        dot_seen = False\n        e_seen = False\n        for i, ch in enumerate(s):\n            if ch.isdigit():\n                num_seen = True\n            elif ch == '.':\n                if dot_seen or e_seen:\n                    return False\n                dot_seen = True\n            elif ch in ('e', 'E'):\n                if e_seen or not num_seen:\n                    return False\n                e_seen = True\n                num_seen = False\n            elif ch in ('+', '-'):\n                if i != 0 and s[i - 1] not in ('e', 'E'):\n                    return False\n            else:\n                return False\n        return num_seen\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data.strip()\n        if s.startswith('\"') and s.endswith('\"'):\n            s = s[1:-1]\n    sol = Solution()\n    print(sol.isNumber(s))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"0\"",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "s = \"e\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        },
        {
          "example_index": 2,
          "input": "s = \".\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode121.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou wan...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with comments. It's a standard max profit single transaction. Steps: find min price so far, compute profit, track max. Use loop. Pseudocode lines with arrows. Use Start End, Decision. Provide explanation. Use virtual arrow. Ensure each line has code + space + // explanation. No actual code. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 minPrice ← Infinity // 設定最小價格為無限大  \n→ Step 2: 初始化 maxProfit ← 0 // 設定最大利潤為 0  \n→ Step 3: 初始化 index ← 0 // 設定陣列索引為 0  \n→ Decision: 如果 index 小於 prices.length? // 判斷是否還有天數可處理  \n Yes → Step 4: 更新 minPrice ← min(minPrice, prices[index]) // 更新最小價格  \n  → Step 5: 計算 potentialProfit ← prices[index] - minPrice // 以目前價格與最小價格計算利潤  \n  → Decision: 如果 potentialProfit 大於 maxProfit? // 判斷是否為新最大利潤  \n   Yes → Step 6: maxProfit ← potentialProfit // 更新最大利潤  \n   No → Step 7: // 保持目前最大利潤不變  \n  → Step 8: index ← index + 1 // 移動到下一天  \n  → 回到 Decision  \n No → Step 9: // 已處理完所有天數  \n→ Step 10: 回傳 maxProfit // 回傳最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"Return the maximum profit from a single buy/sell transaction.\"\"\"\n        if not prices:\n            return 0\n        min_price = prices[0]\n        max_profit = 0\n        for price in prices[1:]:\n            # Update maximum profit if selling at current price is better\n            max_profit = max(max_profit, price - min_price)\n            # Update the minimum price seen so far\n            min_price = min(min_price, price)\n        return max_profit\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract all integers (including negative numbers if any)\n    nums = [int(x) for x in re.findall(r'-?\\d+', data)]\n    # Compute and print the result\n    result = Solution().maxProfit(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode44.json",
    "problem_index_in_file": 0,
    "title": "Wildcard Matching",
    "description_snippet": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The task: given string s and pattern p, implement wildcard matching with '?' and '*', covering entire string. Provide step-by-step virtual code with explanations. Use Start, End, Decision etc. Should be line by line. We'll need to define algorithm, maybe DP. Use virtual code lines, each with comment. Provide explanation. Should not output actual code. Ok.\n\nLet's design pseudo steps:\n\n- Start\n- Input s, p\n- Define lengths n, m\n- Create DP table (n+1)*(m+1)\n- Initialize dp[0][0] = true\n- For j from 1 to m: if p[j-1]=='*' dp[0][j] = dp[0][j-1] else break\n- For i from 1 to n:\n   - For j from 1 to m:\n       - If p[j-1]=='*': dp[i][j] = dp[i][j-1] OR dp[i-1][j]  // '*' matches empty or one char\n       - Else if p[j-1]=='?' or s[i-1]==p[j-1]: dp[i][j] = dp[i-1][j-1]\n       - Else dp[i][j] = false\n- Result = dp[n][m]\n- Output result\n\nBut the virtual code may need to be line by line. We can summarise each step but we cannot use code. We'll use steps like:\n\nStart\n→ Input s, p // 取得輸入字串與模式\n→ Step 1: 計算 n = len(s), m = len(p) // 取得長度\n→ Step 2: 初始化 dp[0…n][0…m] 為 false // 建立 DP 表\n→ Step 3: dp[0][0] = true // 空字串匹配空模式\n→ Decision: p[0] 為 '*'? // 判斷前置星號\n  Yes → Loop j from 1 to m while p[j-1]=='*' : dp[0][j] = true // 空字串與多個星號匹配\n  No  → // 其餘情況保持 false\n→ Loop i from 1 to n: // 主迴圈\n   → Loop j from 1 to m: // 子迴圈\n      → Decision: p[j-1] 為 '*'? // 判斷是否為星號\n          Yes → dp[i][j] = dp[i][j-1] OR dp[i-1][j] // 星號可匹配空或一個字元\n          No  → Decision: p[j-1]=='?' OR s[i-1]==p[j-1]? // 匹配單字元或問號\n                Yes → dp[i][j] = dp[i-1][j-1]\n                No  → dp[i][j] = false\n→ Step final: return dp[n][m] // 結果\nEnd\n\nWe need to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrow lines. Use indentation for decisions? In example they used indentation after Decision lines.\n\nWe will produce like:\n\nStart // 程式開始執行\n→ Input s, p // 取得輸入字串與模式\n→ Step 1: 計算 n = len(s), m = len(p) // 取得字串與模式長度\n→ Step 2: 初始化 dp[0…n][0…m] 為 false // 建立 DP 表\n→ Step 3: dp[0][0] = true // 空字串與空模式匹配\n→ Decision: p[0] 為 '*'? // 判斷前置星號是否能匹配空字串\n    Yes → Loop j=1 to m while p[j-1]=='*': dp[0][j] = true // 空字串匹配多個星號\n    No  → // 其餘保持 false\n→ Loop i=1 to n: // 遍歷字串 s\n    → Loop j=1 to m: // 遍歷模式 p\n        → Decision: p[j-1] 為 '*'? // 判斷是否為星號\n            Yes → dp[i][j] = dp[i][j-1] OR dp[i-1][j] // 星號匹配空或單個字元\n            No  → Decision: p[j-1]=='?' OR s[i-1]==p[j-1]? // 匹配問號或相同字元\n                Yes → dp[i][j] = dp[i-1][j-1] // 前一步匹配成功\n                No  → dp[i][j] = false // 不匹配\n→ Step final: return dp[n][m] // 返回是否整體匹配\nEnd // 程式結束\n\nBut we must keep each line one line, but indentation may show hierarchy. In the example, they had indentation lines after Decision. They used \"→ Decision: ...\". And indent the Yes / No lines with spaces. We'll use similar style.\n\nThus final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s, p // 取得輸入字串與模式  \n→ Step 1: 計算 n = len(s), m = len(p) // 取得字串與模式長度  \n→ Step 2: 初始化 dp[0…n][0…m] 為 false // 建立 DP 表格  \n→ Step 3: dp[0][0] = true // 空字串匹配空模式  \n→ Decision: 前置是否為 '*'? // 判斷是否能用星號匹配空字串  \n    Yes → Loop j = 1 to m while p[j-1] == '*': dp[0][j] = true // 空字串可匹配多個星號  \n    No  → // 其餘保持 false  \n→ Loop i = 1 to n: // 逐個處理字串 s  \n    → Loop j = 1 to m: // 逐個處理模式 p  \n        → Decision: p[j-1] 為 '*'? // 判斷是否為星號  \n            Yes → dp[i][j] = dp[i][j-1] OR dp[i-1][j] // 星號可匹配空或一個字元  \n            No  → Decision: p[j-1] 為 '?' 或 s[i-1] == p[j-1]? // 匹配問號或相同字元  \n                Yes → dp[i][j] = dp[i-1][j-1] // 前一步成功繼續匹配  \n                No  → dp[i][j] = false // 不匹配  \n→ Step final: return dp[n][m] // 回傳整體是否匹配  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"Wildcard matching with '?' and '*'.\"\"\"\n        m, n = len(s), len(p)\n        # dp[i][j] means s[:i] matches p[:j]\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # Patterns that start with '*' can match empty string\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    # '*' matches empty (dp[i][j-1]) or one more char (dp[i-1][j])\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                elif p[j - 1] == '?' or p[j - 1] == s[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = False\n        return dp[m][n]\n\ndef parse_input(data: str) -> tuple[str, str]:\n    \"\"\"\n    Parse input of the form: s = \"string\", p = \"pattern\"\n    Handles optional whitespace and empty strings.\n    \"\"\"\n    # Find all key=value pairs\n    pairs = re.findall(r'([sp])\\s*=\\s*\"([^\"]*)\"', data)\n    values = {k: v for k, v in pairs}\n    return values.get('s', ''), values.get('p', '')\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    s, p = parse_input(data)\n    sol = Solution()\n    result = sol.isMatch(s, p)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"cb\", p = \"?a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode216.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum III",
    "description_snippet": "Find all valid combinations of k numbers that sum up to n such that the following conditions are tru...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations. The problem: find all combinations of k numbers from 1-9, each used at most once, sum to n. Typical backtracking solution. We should produce steps. We need to use virtual code arrows. Should be in Traditional Chinese. Format:\n\nStart // 程式開始執行\n→ Step 1: 定義遞迴函式 search(start, k, n, path, result) // ... \n...\n\nUse Decision: ... Yes → ... No → ...\nWe need to be careful about indentation? In example, indentation uses tabs? Actually they used space indentation. Let's mimic.\n\nWe should produce list of all combos. Steps: Start, define result list, call search with start=1, k, n, path empty. Search function: if k==0 and n==0, add path to result. If k==0 or n<0, return. For i from start to 9: if i>n? maybe skip. Recursively call search(i+1, k-1, n-i, path+[i], result). After loop, return. Then after initial call, return result.\n\nWe must provide virtual code lines step by step.\n\nLet's produce. We'll include variables definitions. We must not output actual code but pseudocode. Provide explanation after //.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 result 為空集合 // 用於儲存所有合法組合\n→ Step 2: 呼叫 search(start = 1, k, n, path = 空, result) // 啟動遞迴尋找\n→ End // 程式結束\n\nBut we also need to define search. In pseudocode, we can include definition as a step with indentation? Example from sample: \"Step 1: 輸入使用者數字\" etc. They didn't show function definition separately. We might need to show step lines inside recursion? We can do:\n\n→ Step 3: 定義函式 search(start, k, n, path, result) // 設定遞迴搜尋\n    → Decision: k==0 且 n==0? // 檢查是否已找到合法組合\n        Yes → Step 4: 加入 path 至 result // 存入結果\n        No → Decision: k==0 或 n<0? // 檢查是否應該結束\n            Yes → Step 5: 返回 // 無效路徑\n            No → Step 6: 從 i = start 到 9 迭代 // 逐一嘗試數字\n                → Decision: i > n? // 如果數字已超過目標和\n                    Yes → Step 7: 跳過此 i // 不再嘗試\n                    No  → Step 8: 呼叫 search(i+1, k-1, n-i, path+[i], result) // 進一步遞迴\n\nBut indentation: use tabs? They used spaces indentation but with arrows. Let's just use spaces.\n\nWe must maintain step numbering? Not necessary. Use descriptive steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 result 為空集合 // 用於儲存所有合法組合  \n→ Step 2: 呼叫 search(start = 1, k, n, path = 空, result) // 啟動遞迴搜尋  \n→ Step 3: 定義函式 search(start, k, n, path, result) // 設定遞迴搜尋  \n → Decision: k == 0 且 n == 0? // 檢查是否已找到合法組合  \n  Yes → Step 4: 加入 path 至 result // 存入結果  \n  No → Decision: k == 0 或 n < 0? // 檢查是否應該結束遞迴  \n   Yes → Step 5: 返回 // 路徑無效，終止此分支  \n   No → Step 6: 從 i = start 到 9 逐一嘗試數字 // 逐步搜尋可能的組合  \n    → Decision: i > n? // 數字已超過剩餘目標和  \n     Yes → Step 7: 跳過此 i // 不再嘗試此數字  \n     No → Step 8: 呼叫 search(i + 1, k - 1, n - i, path + [i], result) // 進一步遞迴  \n→ End // 程式結束，result 即為所有合法組合列表",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum3(self, k: int, n: int):\n        res = []\n\n        def backtrack(start: int, path: list[int], total: int):\n            if len(path) == k and total == n:\n                res.append(path.copy())\n                return\n            if len(path) > k or total > n:\n                return\n            for i in range(start, 10):\n                path.append(i)\n                backtrack(i + 1, path, total + i)\n                path.pop()\n\n        backtrack(1, [], 0)\n        return res\n\ndef parse_input(data: str):\n    # 找出所有整數，順序應為 k, n\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        return nums[0], nums[1]\n    raise ValueError(\"輸入格式錯誤，需包含 k 與 n\")\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    k, n = parse_input(raw)\n    solution = Solution()\n    result = solution.combinationSum3(k, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 3, n = 7",
          "expected_output": "[[1,2,4]]",
          "success": true,
          "output": "[[1, 2, 4]]"
        },
        {
          "example_index": 1,
          "input": "k = 3, n = 9",
          "expected_output": "[[1,2,6],[1,3,5],[2,3,4]]",
          "success": true,
          "output": "[[1, 2, 6], [1, 3, 5], [2, 3, 4]]"
        },
        {
          "example_index": 2,
          "input": "k = 4, n = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode721.json",
    "problem_index_in_file": 0,
    "title": "Accounts Merge",
    "description_snippet": "Given a list of accounts where each element accounts[i] is a list of strings, where the first elemen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Need to use Start, End, Decision, etc. Use arrow lines. Provide simple algorithm: Union-Find to merge emails. Steps: iterate accounts, map email to name, union emails. After all unions, group emails by root, sort, output. Provide line by line.\n\nEnsure each line: 虛擬碼步驟 [space] // 解釋.\n\nUse arrow \"→\" before each step. Use Decision: lines for if. Use Start, End.\n\nLet's produce.\n\nWe can start: Start.\n\n→ Step 1: Initialize UnionFind structure for emails // DSU.\n\n→ Step 2: Initialize email_to_name map // store name.\n\n→ Step 3: For each account in accounts: // iterate accounts.\n\n→ Decision: account has emails? // check.\n\n    Yes → Step 4: first_email = account[1] // first email.\n\n        → Step 5: email_to_name[first_email] = account[0] // name mapping.\n\n        → Step 6: For each email in account[1:]: // iterate emails.\n\n            → Decision: email not in UnionFind? // if first time.\n\n                Yes → Step 7: UnionFind.add(email) // add to DSU.\n\n                No  → (do nothing)\n\n            → Decision: email != first_email? // union with first email.\n\n                Yes → Step 8: UnionFind.union(first_email, email) // merge sets.\n\n                No  → (do nothing)\n\n→ Step 9: Initialize dictionary groups // root -> set of emails.\n\n→ Step 10: For each email in email_to_name: // iterate all emails.\n\n    → Step 11: root = UnionFind.find(email) // find root.\n\n    → Step 12: groups[root].add(email) // add to group.\n\n→ Step 13: Initialize result list // final output.\n\n→ Step 14: For each root, emails in groups.items(): // iterate groups.\n\n    → Step 15: sorted_emails = sorted(emails) // lexicographic.\n\n    → Step 16: name = email_to_name[next(iter(emails))] // get name.\n\n    → Step 17: result.append([name] + sorted_emails) // add to result.\n\n→ End // 程式執行結束.\n\nWe also need to include DSU methods? Might add.\n\nWe can include a Step to define UnionFind class.\n\nBetter: add steps:\n\n→ Step 1: Define UnionFind class with parent map, find, union, add. // DSU.\n\nBut keep simple.\n\nOk produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 UnionFind 類別，包含 parent 映射、find、union 與 add 方法 // 建立並查集以合併電子郵件  \n→ Step 2: 初始化空的 email_to_name 映射 // 用來儲存每個電子郵件對應的姓名  \n→ Step 3: 初始化空的 UnionFind 物件 // 用於合併相同人的電子郵件  \n→ Step 4: 對於 accounts 中的每一筆帳號 // 逐筆處理  \n  → Decision: 這筆帳號是否至少有一個電子郵件？ // 確認帳號內容  \n   Yes → Step 5: first_email ← accounts[i][1] // 取得該帳號的第一封電子郵件  \n    → Step 6: email_to_name[first_email] ← accounts[i][0] // 將姓名儲存到映射  \n    → Step 7: 針對 accounts[i][1:] 中的每一封電子郵件 // 逐個處理  \n      → Decision: email 尚未在 UnionFind 中？ // 第一次出現的郵件  \n       Yes → Step 8: UnionFind.add(email) // 將其加入集合  \n       No  → // 已存在，無需再加  \n      → Decision: email 與 first_email 不同？ // 需要合併  \n       Yes → Step 9: UnionFind.union(first_email, email) // 將兩封郵件合併到同一集合  \n       No  → // 相同郵件，無需合併  \n→ Step 10: 初始化 groups 字典，鍵為根節點，值為對應的電子郵件集合 // 用於分組  \n→ Step 11: 對於 email_to_name 中的每一封電子郵件 // 逐個查找集合根節點  \n  → Step 12: root ← UnionFind.find(email) // 找到其代表節點  \n  → Step 13: 若 groups[root] 未存在，則建立空集合  \n  → Step 14: groups[root].add(email) // 將郵件加入對應組別  \n→ Step 15: 初始化 result 清單 // 儲存合併後的帳號  \n→ Step 16: 對於 groups 中的每一個 (root, emails) // 逐組處理  \n  → Step 17: sorted_emails ← sorted(emails) // 將郵件按字典序排序  \n  → Step 18: name ← email_to_name[next(iter(emails))] // 取任一郵件對應的姓名  \n  → Step 19: result.append([name] + sorted_emails) // 形成一筆帳號資料並加入結果  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self):\n        self.parent = {}\n\n    def find(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        self.parent[self.find(y)] = self.find(x)\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        uf = UnionFind()\n        email_to_name = {}\n\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            email_to_name[first_email] = name\n            for email in acc[1:]:\n                email_to_name[email] = name\n                uf.union(first_email, email)\n\n        groups = defaultdict(list)\n        for email in email_to_name:\n            root = uf.find(email)\n            groups[root].append(email)\n\n        result = []\n        for root, emails in groups.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 若輸入包含等號，取等號右邊的表達式\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n        accounts_str = expr.strip()\n    else:\n        accounts_str = data\n    # 解析字串為 Python 物件\n    accounts = ast.literal_eval(accounts_str)\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "expected_output": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "success": true,
          "output": "[['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com']]"
        },
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode763.json",
    "problem_index_in_file": 0,
    "title": "Partition Labels",
    "description_snippet": "You are given a string s. We want to partition the string into as many parts as possible so that eac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm: partition string into maximal parts so each letter appears in at most one part. Classic Leetcode 763 Partition Labels. Approach: record last occurrence index of each character. Then iterate, keep current partition end = max last occurrence of chars seen. When index reaches current partition end, partition ends. Record length. Provide step-by-step virtual code lines.\n\nWe output lines: Start, → Step etc. Use arrow for decisions. Provide explanation in Chinese.\n\nLet's craft. Need to use Start, End, Decision: lines.\n\nWe'll produce step-by-step:\n\nStart\n→ Step 1: Initialize dictionary lastIndex // store last occurrence for each char\n→ Step 2: For each char in s with index i, set lastIndex[char] = i // update last index\n→ Step 3: Initialize list result, int start=0, int end=0 // result sizes and pointers\n→ Step 4: For each char in s with index i\n    → Decision: if i > end? // if current index beyond current partition end? but actually we update end each step\n        No → continue\n    → Step 5: Update end = max(end, lastIndex[char]) // extend partition end\n    → Decision: if i == end? // reached partition end\n        Yes → Step 6: Append i - start + 1 to result // record size\n                 → Step 7: start = i + 1 // next start\n        No  → No action\n\nEnd.\n\nBut we need to incorporate \"Yes →\" arrow inside Decision: if i == end? Yes.\n\nBut the Step 5 should be executed before checking equality. So we can structure:\n\nFor each index i:\n    → Step 5: Update end = max(end, lastIndex[char])\n    → Decision: If i == end? \n         Yes → Step 6 ...\n         No  → No action\n\nAlso we need to use arrow lines properly.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Create map lastIndex // 存放每個字母最後出現的索引\n→ Step 2: 循環遍歷 s 的每個字符與索引 i，將 lastIndex[char] 設為 i // 更新最後索引\n→ Step 3: 初始化結果列表 result、起始指標 start = 0、結束指標 end = 0 // 準備分割\n→ Step 4: 循環遍歷 s 的每個字符與索引 i\n    → Step 5: end = max(end, lastIndex[char]) // 擴大目前區塊結束位置\n    → Decision: 如果 i == end? // 判斷是否達到區塊結束\n        Yes → Step 6: result.add(i - start + 1) // 記錄區塊大小\n        Yes → Step 7: start = i + 1 // 設定下一個區塊的起始位置\n        No  → No action // 仍在同一區塊中\nEnd // 程式執行結束\n\nBut we need to maintain the arrow style: each line preceded by \"→\". And Decision block lines indented.\n\nThe arrow \"Yes →\" lines. Provide \"No →\" lines maybe but we can just write \"No → No action\". The spec example uses \"No → Decision: ...\".\n\nWe can follow example: \"Decision: 如果數字大於 0?\" then indentation for Yes and No. For our algorithm:\n\nDecision: i == end? // 判斷是否達到區塊結束\n    Yes → Step 6: result.add(...) // ...\n    Yes → Step 7: start = i + 1 // ...\n    No  → No action // ... \n\nBut we might combine step 6 and 7 into same Yes block, but spec uses separate lines. We'll produce as two Yes lines.\n\nAlternatively combine into one Yes: but keep consistent.\n\nLet's produce final answer accordingly. Ensure each line ends with comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 lastIndex // 存放每個字母最後一次出現的索引  \n→ Step 2: 循環遍歷 s，對於每個字符 c 與索引 i，將 lastIndex[c] 設為 i // 更新最後索引  \n→ Step 3: 初始化結果列表 result、起始指標 start = 0、目前區塊結束指標 end = 0 // 準備分割  \n→ Step 4: 再次循環遍歷 s，對於每個字符 c 與索引 i  \n    → Step 5: end = max(end, lastIndex[c]) // 擴大目前區塊結束位置  \n    → Decision: 如果 i == end? // 判斷是否已到達區塊結束  \n        Yes → Step 6: result.add(i - start + 1) // 記錄此區塊的大小  \n        Yes → Step 7: start = i + 1 // 設定下一個區塊的起始位置  \n        No  → No action // 尚未到達區塊結束，繼續處理下個字符  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def partitionLabels(self, s: str):\n        \"\"\"\n        Partition the string so that each letter appears in at most one part.\n        Return a list of the sizes of these parts.\n        \"\"\"\n        # Record the last occurrence index of each character\n        last = {c: i for i, c in enumerate(s)}\n        partitions = []\n        start = end = 0\n\n        # Scan through the string\n        for i, c in enumerate(s):\n            # Extend the current partition's end if necessary\n            end = max(end, last[c])\n            # When the current index reaches the partition's end,\n            # we can finalize this part\n            if i == end:\n                partitions.append(i - start + 1)\n                start = i + 1\n\n        return partitions\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    raw = sys.stdin.read().strip()\n\n    # Extract the string value; support formats like:\n    #   s = \"abcdef\"\n    #   \"abcdef\"\n    if '\"' in raw:\n        first_quote = raw.find('\"')\n        last_quote = raw.rfind('\"')\n        s = raw[first_quote + 1:last_quote]\n    else:\n        s = raw\n\n    solution = Solution()\n    result = solution.partitionLabels(s)\n\n    # Print result in the required format: e.g., [9,7,8]\n    print(json.dumps(result, separators=(',', ':')))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ababcbacadefegdehijhklij\"",
          "expected_output": "[9,7,8]",
          "success": true,
          "output": "[9,7,8]"
        },
        {
          "example_index": 1,
          "input": "s = \"eccbbbbdec\"",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode126.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder II",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines, with explanation after //. The problem is classic Word Ladder II. We need to produce steps: BFS to find distances, then DFS/Backtracking to build paths. Provide virtual code steps line by line.\n\nWe'll design steps: Start, Input words, Preprocess wordList into set, Check endWord in set, BFS to find shortest distances and adjacency mapping, then DFS to build paths using distances. If no path, return empty list. End.\n\nWe need to use arrow syntax.\n\nWe'll write like:\n\nStart\n→ Step 1: 初始化 wordSet = set(wordList)\n→ Decision: 是否 endWord 在 wordSet? Yes → ... else → return empty\n\n→ Step 2: 初始化 queue, distances map, adjacency dict\n→ Step 3: BFS loop\n   ... \nBut each line must be separate, not nested block of many lines. Use indentation maybe not needed; but we can write each action.\n\nBetter to use a linear list of steps, with decisions as separate lines, and Yes/No branches.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 轉換 wordList 為 Set wordSet // 方便 O(1) 搜尋\n→ Decision: endWord 是否在 wordSet? // 確認終點可達\n    Yes → Step 2: 初始化 queue 為 beginWord, distances[beginWord]=0 // BFS 開始\n    No  → Step 3: 回傳空清單 // 無可行路徑\n→ Step 4: 初始化 adjacency dict // 存每個字對應下一層可達字\n→ Step 5: BFS: while queue 非空\n    → Step 6: 取出當前單字 cur\n    → Step 7: 對於 cur 的每一個可能字母替換\n        → Step 8: 生成 newWord\n        → Decision: newWord 是否在 wordSet? // 只考慮字典裡的單字\n            Yes → Decision: distances 是否已經有 newWord? // 是否已探索過\n                Yes → Decision: distances[newWord] 是否等於 distances[cur]+1? // 只保留最短層\n                    Yes → Step 9: adjacency[cur].append(newWord) // 紀錄關聯\n                    No  → No operation\n                No  → Step 10: distances[newWord]=distances[cur]+1\n                → Step 11: adjacency[cur].append(newWord)\n                → Step 12: queue.append(newWord) // 下一層搜尋\n            No  → No operation\n→ Decision: distances 是否含 endWord? // 判斷是否找到終點\n    Yes → Step 13: 初始化結果 list\n    No  → Step 14: 回傳空清單 // 無最短路徑\n→ Step 15: 定義 DFS(current, path)\n    → Decision: current==endWord? // 完成一條路徑\n        Yes → Step 16: 將 copy of path 加入結果\n        No  → Step 17: 對於 next in adjacency[current]\n            → Decision: distances[next]==distances[current]+1? // 確保走最短\n                Yes → Step 18: path.append(next)\n                → Step 19: DFS(next, path)\n                → Step 20: path.pop()\n                No  → No operation\n→ Step 21: 呼叫 DFS(beginWord, [beginWord]) // 開始回溯\n→ Step 22: 回傳結果 // 所有最短序列\nEnd // 程式結束\n\nBut we need each line as a single virtual code step with explanation. The DFS definition counts as one line? Could split.\n\nHowever, we need to use arrows and decisions.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 轉換 wordList 為 Set wordSet // 方便 O(1) 搜尋  \n→ Decision: endWord 是否在 wordSet? // 確認終點可達  \n    Yes → Step 2: 初始化 queue 為 [beginWord], distances[beginWord] = 0 // BFS 開始  \n    No  → Step 3: 回傳空清單 // 無可行路徑  \n→ Step 4: 初始化 adjacency 為空字典 // 存每個字對應下一層可達字  \n→ Step 5: BFS: while queue 非空  \n    → Step 6: 取出 queue 的第一個字 cur // 目前層級的字  \n    → Step 7: 對於 cur 的每一個可能字母位置 i  \n        → Step 8: 對於字母 'a'~'z'  \n            → Step 9: 生成 newWord = cur 取代位置 i 為 該字母 // 產生相鄰字  \n            → Decision: newWord 是否在 wordSet? // 只考慮字典裡的單字  \n                Yes → Decision: distances 是否已經有 newWord? // 是否已探索過  \n                    Yes → Decision: distances[newWord] 是否等於 distances[cur]+1? // 保留最短層  \n                        Yes → Step 10: adjacency[cur].append(newWord) // 紀錄關聯  \n                        No  → No operation  \n                    No  → Step 11: distances[newWord] = distances[cur] + 1  \n                    → Step 12: adjacency[cur].append(newWord)  \n                    → Step 13: queue.append(newWord) // 下一層搜尋  \n                No  → No operation  \n→ Decision: distances 是否含 endWord? // 判斷是否找到終點  \n    Yes → Step 14: 初始化 results 為空清單 // 存儲所有最短路徑  \n    No  → Step 15: 回傳空清單 // 無最短路徑  \n→ Step 16: 定義 DFS(current, path) // 回溯尋找所有路徑  \n    → Decision: current == endWord? // 完成一條路徑  \n        Yes → Step 17: results.append(copy(path)) // 加入結果  \n        No  → Step 18: 對於 next in adjacency[current]  \n            → Decision: distances[next] == distances[current] + 1? // 確保走最短  \n                Yes → Step 19: path.append(next)  \n                → Step 20: DFS(next, path)  \n                → Step 21: path.pop()  \n                No  → No operation  \n→ Step 22: 呼叫 DFS(beginWord, [beginWord]) // 開始回溯  \n→ Step 23: 回傳 results // 所有最短序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return []\n\n        # BFS 先找最短距離\n        level = {beginWord: 0}\n        parents = defaultdict(list)   # child -> list of parents\n        queue = deque([beginWord])\n        while queue:\n            word = queue.popleft()\n            step = level[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        if new_word not in level:\n                            level[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif level[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        # 若沒有到達 endWord，直接回傳空清單\n        if endWord not in parents:\n            return []\n\n        res = []\n\n        def dfs(path, word):\n            \"\"\"回溯產生所有最短路徑\"\"\"\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        dfs([endWord], endWord)\n        return res\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取完整文字，並執行解析\n    input_data = sys.stdin.read()\n    env = {}\n    exec(input_data, {}, env)\n\n    beginWord = env[\"beginWord\"]\n    endWord = env[\"endWord\"]\n    wordList = env[\"wordList\"]\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpdzy9ou9k.py\", line 49, in <module>\n    exec(input_data, {}, env)\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpgzjxo43f.py\", line 49, in <module>\n    exec(input_data, {}, env)\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode436.json",
    "problem_index_in_file": 0,
    "title": "Find Right Interval",
    "description_snippet": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: given intervals with unique starts, find right interval for each. Classic approach: sort intervals by start, keep original indices. For each interval, binary search for minimal start >= end. Output indices or -1.\n\nWe need to output line-by-line virtual code steps with explanation. Let's produce high-level algorithm steps: Start, Build list of tuples (start, end, index). Sort by start. Extract sorted starts array. For each original interval i: end=intervals[i][1]; binary search lower bound on sorted starts; if found, find corresponding original index from sorted list; else -1. Append to result. End.\n\nWe need to use virtual code arrows and decisions. Provide steps like:\n\nStart\n→ Step 1: Initialize list L = []\n→ Step 2: For each interval (s, e) at index i: Append (s, e, i) to L // keep original index\n→ Decision: Is L empty? No → Step 3: Sort L by s ascending // sort by start\n→ Step 4: Create array starts from sorted L // only start values\n→ Step 5: Initialize result array res of size n with -1 // default -1\n→ Step 6: For each interval (s, e, idx) in original order:\n    → Step 6.1: BinarySearchLowerBound(starts, e) → pos // find first start >= e\n    → Decision: pos < n? Yes → Step 6.2: res[idx] = L[pos].originalIndex // found\n    → No → Step 6.3: res[idx] remains -1 // none found\n→ End // return res\n\nWe need to include explanations after each line. Use \"虛擬碼步驟 // 解釋\". Use proper arrows.\n\nWe'll produce lines accordingly.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: L ← empty list // 建立空的幫助清單來儲存 (開始, 結束, 原始索引)  \n→ Step 2: For each interval i from 0 to n-1:  \n  → Step 2.1: Append (intervals[i].start, intervals[i].end, i) to L // 將每個區間與其原始索引一起存入 L  \n→ Decision: Is L empty? No → Step 3: Sort L by start value ascending // 依開始時間排序，方便後續二分搜尋  \n→ Step 4: starts ← array of all start values from sorted L // 只取開始時間做為搜尋關鍵字  \n→ Step 5: res ← array of size n, initialise all elements to -1 // 預設沒有右區間  \n→ Step 6: For each original interval i from 0 to n-1:  \n  → Step 6.1: e ← intervals[i].end // 取得該區間的結束時間  \n  → Step 6.2: pos ← BinarySearchLowerBound(starts, e) // 找第一個 start >= e 的位置  \n  → Decision: pos < n? Yes → Step 6.3: res[i] ← L[pos].originalIndex // 找到右區間，存原始索引",
      "generated_code": "import sys\nimport ast\nfrom bisect import bisect_left\n\ndef find_right_intervals(intervals):\n    \"\"\"\n    尋找每個區間的右區間索引。\n\n    1. 建立一個由 (開始時間, 原始索引) 組成的列表並依開始時間排序。\n    2. 用二分搜尋找出最小的開始時間 >= 當前區間結束時間。\n    3. 若找到對應的區間，將其原始索引放入結果；否則放入 -1。\n    \"\"\"\n    # 依開始時間排序，保持原始索引\n    starts = sorted((interval[0], i) for i, interval in enumerate(intervals))\n\n    res = []\n    for interval in intervals:\n        end = interval[1]\n        # 找到第一個 start >= end 的位置\n        idx = bisect_left(starts, (end, -1))\n        if idx < len(starts):\n            res.append(starts[idx][1])  # 右區間的原始索引\n        else:\n            res.append(-1)              # 沒有符合的右區間\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 允許輸入格式為 \"intervals = [[...]]\" 或僅 \"[[...]]\"\n    if '=' in raw_input:\n        raw_input = raw_input.split('=', 1)[1].strip()\n\n    # 使用安全的 literal_eval 解析 Python 表達式\n    intervals = ast.literal_eval(raw_input)\n\n    # 計算結果並輸出\n    result = find_right_intervals(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2]]",
          "expected_output": "[-1]",
          "success": true,
          "output": "[-1]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[3,4],[2,3],[1,2]]",
          "expected_output": "[-1,0,1]",
          "success": true,
          "output": "[-1, 0, 1]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,4],[2,3],[3,4]]",
          "expected_output": "[-1,2,-1]",
          "success": true,
          "output": "[-1, 2, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode517.json",
    "problem_index_in_file": 0,
    "title": "Super Washing Machines",
    "description_snippet": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps solving the problem. It's Leetcode 517. We need algorithm: calculate average, if sum not divisible by n => -1. Then iterate, compute prefix imbalance, track max moves needed as max(max(prefix_dress, -prefix_dress)). Actually solution: for each machine i, compute current load, diff = curr - avg. Track cumulative diff. For each i, the moves needed for machine i is max(prev_cumulative, abs(curr_cumulative)), but simpler: keep max of abs(cumulative) and max of diff. Actually algorithm: let sum=0, avg; if sum% n !=0 return -1. Then moves=0, prefix=0. For each i: diff = machines[i] - avg; prefix += diff; moves = max(moves, abs(prefix), diff); end. Return moves.\n\nWe produce virtual code steps line by line. Each line \"→ Step X: ...\" etc. Use decision for impossible. We must not output actual code but pseudocode. Provide explanations after //. Use structure. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 n ← len(machines) // 取得洗衣機總數  \n→ Step 2: 計算 total ← sum(machines) // 取得所有衣服總數  \n→ Decision: 如果 total % n != 0? // 檢查是否能平均分配  \n    Yes → Step 3: 回傳 -1 // 若無法整除，無法達成目標，直接結束  \n    No → Step 4: 計算 avg ← total / n // 每台洗衣機應該擁有的衣服數  \n→ Step 5: 初始化 moves ← 0 // 記錄所需的最大步數  \n→ Step 6: 初始化 prefix ← 0 // 記錄前綫的累積差額  \n→ Step 7: 循環 i 從 0 到 n-1 // 遍歷每台洗衣機  \n    → Step 7a: 計算 diff ← machines[i] - avg // 本台與平均值之差  \n    → Step 7b: 更新 prefix ← prefix + diff // 累計差額到目前為止  \n    → Step 7c: 更新 moves ← max(moves, abs(prefix), diff) // 取目前步數、累計差額與本台差額的最大值  \n→ End // 返回最小步數  \n→ Step 8: 回傳 moves // 所需的最小動作數量\n\n// 完整流程已經以逐行虛擬碼說明，符合輸出格式要求。",
      "generated_code": "import sys\nimport ast\n\ndef find_min_moves(machines):\n    \"\"\"\n    計算使所有洗衣機擁有相同衣服數量所需的最小步數。\n    \"\"\"\n    total = sum(machines)\n    n = len(machines)\n\n    # 若總衣服數無法被洗衣機數整除，無法平均分配\n    if total % n != 0:\n        return -1\n\n    avg = total // n          # 每台洗衣機應該擁有的衣服數\n    res = 0                   # 記錄所需的最大步數\n    cum = 0                   # 前綫的累積差額\n\n    for load in machines:\n        diff = load - avg    # 本台與平均值之差\n        cum += diff          # 累計差額\n        # 需要的步數至少為 abs(cum)，並且本台差額 diff 也可能是瓶頸\n        res = max(res, abs(cum), diff)\n\n    return res\n\ndef main():\n    \"\"\"\n    從標準輸入讀取洗衣機衣服數量列表，輸出最小動作數量。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，例如 '[1,0,5]'\n    machines = ast.literal_eval(data)\n    answer = find_min_moves(machines)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,0,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,2,0]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode657.json",
    "problem_index_in_file": 0,
    "title": "Robot Return to Origin",
    "description_snippet": "There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation. The task: given string moves, check if robot ends at origin. Virtual code. Use Start, End, Decision, etc. For each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Let's produce steps: initialize x,y=0; iterate each char; adjust; after loop check if x==0 && y==0 return true else false. Or using count approach. Virtual code lines.\n\nLet's produce: Start; → Step 1: Initialize x=0, y=0 // start coordinates; → Step 2: For each char in moves // iterate over moves; inside: Decision: If char == 'R'? Yes→ x+=1 No: Decision: char=='L'? Yes→ x-=1 No: Decision: char=='U'? Yes→ y+=1 No: Decision: char=='D'? Yes→ y-=1; After loop: Decision: if x==0 && y==0? Yes → Step 3: Return true; No → Step 4: Return false; End.\n\nNeed to follow format exactly. Let's produce each line. Use arrows: \"→ Step 1: ...\". For nested decisions, indent maybe but not necessary. Use \"Decision:\" with Yes→ and No→. Ensure every line has explanation after //.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set x = 0, y = 0 // 初始座標為原點  \n→ Step 2: For each character c in moves // 逐一處理每個移動指令  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: c == 'R'? // 判斷是否為右移  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → x = x + 1 // 右移一格  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: c == 'L'? // 判斷是否為左移  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → x = x - 1 // 左移一格  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: c == 'U'? // 判斷是否為上移  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → y = y + 1 // 上移一格  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: c == 'D'? // 判斷是否為下移  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → y = y - 1 // 下移一格  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → // 不符合任何指令，忽略  \n→ Decision: x == 0 && y == 0? // 檢查是否回到原點  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: Return true // 代表回到原點  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step 4: Return false // 未回到原點  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        \"\"\"\n        Determine if the robot returns to the origin after performing all moves.\n        \"\"\"\n        x = y = 0\n        for move in moves:\n            if move == 'U':\n                y += 1\n            elif move == 'D':\n                y -= 1\n            elif move == 'L':\n                x -= 1\n            elif move == 'R':\n                x += 1\n        return x == 0 and y == 0\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Try to extract the moves string inside double quotes\n    quoted = re.search(r'\"([^\"]*)\"', raw_input)\n    if quoted:\n        moves = quoted.group(1)\n    else:\n        # Fallback: strip possible \"moves = \" prefix and surrounding quotes or spaces\n        if raw_input.lower().startswith(\"moves\"):\n            parts = raw_input.split(\"=\", 1)\n            if len(parts) == 2:\n                moves = parts[1].strip().strip('\"\\'')\n            else:\n                moves = raw_input.strip().strip('\"\\'')\n        else:\n            moves = raw_input.strip().strip('\"\\'')\n\n    solution = Solution()\n    result = solution.judgeCircle(moves)\n\n    # Output 'true' or 'false' in lowercase as required\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "moves = \"UD\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "moves = \"LL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode738.json",
    "problem_index_in_file": 0,
    "title": "Monotone Increasing Digits",
    "description_snippet": "An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisf...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce step-by-step pseudocode. We need to process integer n, find largest monotone increasing <= n. Known algorithm: convert to string digits. Iterate from left to right. Find first position where digit > next digit. Then decrement current digit by 1, set all following digits to 9, but need to propagate carry backwards if resulting digit becomes -1? Actually standard algorithm: convert to array of digits. Find first decreasing position i where digits[i] > digits[i+1]. Then decrement digits[i] by 1, set all digits after i to 9. Then move left while digits[i-1] > digits[i] and adjust. After that, remove leading zeros. Then convert to number. We'll produce pseudocode.\n\nWe need line by line: Start, Step 1: convert n to list of digits, Step 2: find index i where decreasing occurs. etc. Include Decision nodes.\n\nLet's write.\n\nAlso explain each line.\n\nLet's produce pseudocode. Use arrow arrow. Also include indentation maybe.\n\nLet's produce.\n\nUse Start, End. Use Decision:.\n\nLet's start.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n_str ← Convert n to string of digits // 把整數轉成字串方便逐位處理  \n→ Step 2: digits ← List of integer values from n_str // 取得每一個數字的整數列表  \n→ Step 3: i ← 0 // 初始化指標，用於尋找不遞增的位置  \n→ Decision: 是否存在 i 使得 digits[i] > digits[i+1]? // 判斷是否有下降的相鄰位  \n    Yes → Step 4: i ← 第一次發現 digits[i] > digits[i+1] 的索引 // 找到第一個下降的位置  \n    No  → Step 5: Return n // 整個數字已經是單調遞增，直接返回原數  \n→ Step 6: digits[i] ← digits[i] - 1 // 把發現的位置的數字減 1，為了不超過 n  \n→ Step 7: for j from i+1 to length(digits)-1 do // 將後續所有位設為 9  \n        digits[j] ← 9  \n→ Step 8: i ← i - 1 // 從下降位置往前檢查是否還需要調整（因為減 1 可能導致前一位也下降）  \n→ Decision: i ≥ 0 且 digits[i] > digits[i+1]? // 檢查前一位是否仍然不遞增  \n    Yes → Step 9: digits[i] ← digits[i] - 1 // 再次減 1  \n        → Step 10: for j from i+1 to length(digits)-1 do digits[j] ← 9 // 後續都設為 9  \n        → Step 11: i ← i - 1 // 重新檢查更前面的位置  \n        → Go back to Decision // 重新判斷  \n    No  → Step 12: // 目前所有位已經符合單調遞增條件  \n→ Step 13: if digits[0] == 0 then // 移除可能出現的前導零（例如 1000 → 0999）  \n        → Step 14: Remove the first element of digits // 刪除首位 0  \n→ Step 15: result ← Concatenate digits into a string and convert to integer // 重新組合成整數  \n→ Step 16: Return result // 回傳最大的單調遞增數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef monotone_increasing_digits(n: int) -> int:\n    \"\"\"\n    找到小於或等於 n 的最大單調遞增數字。\n    \"\"\"\n    digits = list(str(n))\n    i = 1\n    # 先找第一個不遞增的位置\n    while i < len(digits) and digits[i] >= digits[i - 1]:\n        i += 1\n    # 若不存在下降位置，直接返回 n\n    if i == len(digits):\n        return n\n    # 向左回溯，將可能需要減 1 的位減 1\n    while i > 0 and digits[i] < digits[i - 1]:\n        digits[i - 1] = str(int(digits[i - 1]) - 1)\n        i -= 1\n    # 後續所有位設為 9\n    for j in range(i + 1, len(digits)):\n        digits[j] = '9'\n    return int(''.join(digits))\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，可能包含「n = 1234」或僅僅是「1234」\n    raw_input = sys.stdin.read().strip()\n    # 用正則表達式找出第一個出現的整數\n    match = re.search(r'(-?\\d+)', raw_input)\n    if not match:\n        raise ValueError(\"未找到合法的整數輸入\")\n    n = int(match.group(1))\n    result = monotone_increasing_digits(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "n = 1234",
          "expected_output": "1234",
          "success": true,
          "output": "1234"
        },
        {
          "example_index": 2,
          "input": "n = 332",
          "expected_output": "299",
          "success": true,
          "output": "299"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode729.json",
    "problem_index_in_file": 0,
    "title": "My Calendar I",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: use array/list of intervals; for each book, check if overlaps existing intervals; if none, add. Or could use BST. But keep simple. We'll design pseudo:\n\nStart\n→ Step: Initialize list of intervals // empty list\n→ Function book(start, end):\n    → Step: For each interval in list:\n        → Decision: If start < interval.end && end > interval.start? // overlap condition\n            Yes → Step: Return false // double booking\n    → Step: Append [start, end] to list\n    → Step: Return true\nEnd\n\nWe should write in virtual code style. Provide each line with explanation. Use arrows.\n\nLet's produce line by line. Use 'Start', 'End', 'Decision', etc. Also show function declaration. Use '→' arrow for steps. Also show 'Yes →', 'No →'. Provide comments.\n\nLet's craft.\n\nUse \"Start // 程式開始執行\" etc.\n\nWe need to include function definitions inside pseudocode. We might show:\n\n→ Step 1: Define class MyCalendar // 定義日曆類別\n→ Step 2: Declare intervals = [] // 存放已預訂的區間\n\n→ Function book(start, end) // 方法：預訂事件\n\nWithin function:\n\n→ Step 3: For each (s, e) in intervals:\n    → Decision: start < e AND end > s? // 檢查是否重疊\n        Yes → Step 4: Return false // 造成雙重預訂\n        No  → Continue // 沒有重疊，檢查下一個\n\n→ Step 5: Append (start, end) to intervals // 無衝突，加入\n→ Step 6: Return true\n\nWe also need to include Start and End for class? maybe not.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MyCalendar // 建立日曆物件  \n→ Step 2: intervals ← [] // 用空陣列存放已預訂區間  \n\n→ Function book(start, end) // 方法：嘗試預訂新事件  \n    → Step 3: 對每個 (s, e) 在 intervals 中執行  \n        → Decision: start < e 且 end > s? // 判斷是否與已預訂區間重疊  \n            Yes → Step 4: Return false // 發現重疊，拒絕預訂  \n            No  → Step 5: 繼續檢查下一個區間 // 沒重疊，繼續循環  \n    → Step 6: intervals.append((start, end)) // 所有檢查無誤，加入新區間  \n    → Step 7: Return true // 成功預訂  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyCalendar:\n    \"\"\"\n    Calendar that disallows double bookings.\n    Each booking is a half‑open interval [start, end).\n    \"\"\"\n    def __init__(self):\n        # 存放已預訂的區間，形式 (start, end)\n        self.bookings = []\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"\n        嘗試加入一個新的事件。\n        若與任何已存在的事件重疊則返回 False，否則加入並返回 True。\n        \"\"\"\n        for s, e in self.bookings:\n            # 兩個區間重疊的判斷：max(s, start) < min(e, end)\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\n\ndef main() -> None:\n    \"\"\"\n    主函式，從標準輸入讀取 LeetCode 樣式的測試用例，\n    執行相應操作，並以 JSON‑style 文字列輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析兩個列表：操作名與參數\n    # 例子: '[\"MyCalendar\", \"book\", ...], [[], [10,20], ...]'\n    parts = data.split('], ', 1)\n    ops_part = parts[0] + ']'      # 加回閉括號\n    args_part = '[' + parts[1]     # 加上開括號\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    outputs = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendar\":\n            obj = MyCalendar()\n            outputs.append(None)          # constructor 的返回值對應 null\n        else:\n            res = getattr(obj, op)(*arg)\n            outputs.append(res)\n\n    # 將結果轉成 LeetCode 樣式的輸出：null / true / false\n    out_str = '[' + ', '.join(\n        'null' if v is None else 'true' if v is True else 'false' if v is False else str(v)\n        for v in outputs\n    ) + ']'\n    print(out_str)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpe_o27r36.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpe_o27r36.py\", line 41, in main\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [10, 20], [15, 25], [20, 30]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode278.json",
    "problem_index_in_file": 0,
    "title": "First Bad Version",
    "description_snippet": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search to find first bad version. Use Start, Decision, etc. The steps: initialize low=1 high=n; while low<high: mid=(low+high)//2; if isBadVersion(mid) true => high=mid else low=mid+1. End return low.\n\nAlso minimize API calls, so binary search. Provide comments.\n\nWe must output in Chinese Traditional. Format: \"虛擬碼步驟 // 解釋\". Each line with arrow. Need Start, End, Decision. Use Yes → etc.\n\nWe need to include variable initialization lines.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: low ← 1 // 初始化最小版本號\n→ Step 2: high ← n // 初始化最大版本號\n→ Decision: low < high? // 檢查是否還有區間可搜尋\n    Yes → Step 3: mid ← (low + high) // 2 // 計算中間版本號\n        Yes → Step 4: if isBadVersion(mid) // 檢查中間版本是否為壞版\n            Yes → Step 5: high ← mid // 仍在左半區間搜尋\n            No  → Step 6: low ← mid + 1 // 右半區間繼續搜尋\n        No  → Step 7: low ← mid + 1 // 不可能的分支（實際不會發生）\n    No  → Step 8: return low // low 即為第一個壞版\nEnd // 程式結束\n\nBut we should refine: In Decision we need Yes and No branches.\n\nWe can use nested decisions.\n\nBetter:\n\nStart\n→ Step 1: low ← 1 // 初始化最小版本\n→ Step 2: high ← n // 初始化最大版本\n→ Decision: low < high? // 是否還有未搜尋區間\n    Yes →\n        → Step 3: mid ← (low + high) // 2 // 計算中間\n        → Decision: isBadVersion(mid)? // 中間是否壞版\n            Yes →\n                → Step 4: high ← mid // 搜尋左側包含 mid\n            No  →\n                → Step 5: low ← mid + 1 // 搜尋右側\n    No  →\n        → Step 6: return low // low 是第一個壞版\nEnd\n\nWe also note to return at end. That is the algorithm.\n\nWe should include lines for API call counts? Not necessary.\n\nAlso we can optionally include \"minimize calls\" comment.\n\nLet's output accordingly.\n\nMake sure each line includes virtual code and comment separated by a space and //.\n\nWe need to ensure that after each decision, we indent or not? Example format shows indent lines.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 1: low ← 1 // 初始化最小版本號\n→ Step 2: high ← n // 初始化最大版本號\n→ Decision: low < high? // 判斷是否還有未搜尋的區間\n    Yes →\n        → Step 3: mid ← (low + high) // 2 // 計算中間版本\n        → Decision: isBadVersion(mid)? // 檢查中間版本是否為壞版\n            Yes →\n                → Step 4: high ← mid // 將搜尋範圍縮小到左半區間\n            No  →\n                → Step 5: low ← mid + 1 // 將搜尋範圍縮小到右半區間\n    No  →\n        → Step 6: return low // low 即為第一個壞版\nEnd // 程式結束\n\nThat meets format.\n\nDouble-check: Each line has \"虛擬碼步驟 // 解釋\". Yes.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: low ← 1 // 初始化最小版本號\n→ Step 2: high ← n // 初始化最大版本號\n→ Decision: low < high? // 判斷是否還有未搜尋的區間\n    Yes →\n        → Step 3: mid ← (low + high) // 2 // 計算中間版本\n        → Decision: isBadVersion(mid)? // 檢查中間版本是否為壞版\n            Yes →\n                → Step 4: high ← mid // 將搜尋範圍縮小到左半區間\n            No  →\n                → Step 5: low ← mid + 1 // 將搜尋範圍縮小到右半區間\n    No  →\n        → Step 6: return low // low 即為第一個壞版\nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def firstBadVersion(self, n, isBadVersion):\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\ndef parse_input(data: str):\n    # Replace symbols and split to extract numbers\n    parts = data.replace('=', ' ').replace(',', ' ').split()\n    nums = [int(p) for p in parts if p.lstrip('-').isdigit()]\n    if len(nums) < 2:\n        raise ValueError(\"Input must contain at least two integers: n and bad.\")\n    return nums[0], nums[1]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    n, bad = parse_input(raw_input)\n\n    # Define the isBadVersion API for this test\n    def isBadVersion(version: int) -> bool:\n        return version >= bad\n\n    solution = Solution()\n    result = solution.firstBadVersion(n, isBadVersion)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode81.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array II",
    "description_snippet": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode (Virtual Code) for rotated sorted array search with duplicates. Use binary search variant that handles duplicates. Must be line by line. Use Start, End, Decision, etc.\n\nWe should give step-by-step logic: Initialize left, right; loop while left <= right; mid; check mid == target; else decide which side is sorted or duplicates; update bounds accordingly.\n\nWe must use arrow symbols. Provide explanation after //.\n\nEnsure each line is virtual code. For example:\n\nStart // start\n\n→ Set left = 0, right = len(nums)-1 // initialize pointers\n\n→ Decision: left <= right? // loop condition\n\n    Yes → Step: mid = (left + right) // 2 // compute mid index\n\n    → Decision: nums[mid] == target? // check target\n\n        Yes → Return true // found\n\n        No → Decision: nums[left] < nums[mid]? // left side strictly increasing?\n\n            Yes → Decision: nums[left] <= target < nums[mid]? // target in left side?\n\n                Yes → right = mid - 1 // narrow to left\n\n                No → left = mid + 1 // narrow to right\n\n            No → Decision: nums[left] == nums[mid]? // duplicates, cannot determine\n\n                Yes → left = left + 1 // skip duplicate\n\n                No → Decision: nums[mid] < nums[right]? // right side sorted\n\n                    Yes → Decision: nums[mid] < target <= nums[right]? // target in right side\n\n                        Yes → left = mid + 1 // narrow right\n\n                        No → right = mid - 1 // narrow left\n\n                    No → // fallback\n\n    End // end decision\n\n→ End // loop\n\n→ Return false // not found\n\nWe need to reflect that Start and End for function, etc. Use arrow to indicate transitions.\n\nLet's produce final answer accordingly. Ensure each line ends with // explanation. Use Chinese for explanation.\n\nEnsure to not output actual code. Use arrow. Provide correct format. Let's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = len(nums) - 1 // 初始化左右指標\n→ Decision: left <= right? // 判斷是否還有區間可搜尋\n    Yes → Step 2: mid = (left + right) // 2 // 計算中間索引\n    → Decision: nums[mid] == target? // 檢查中點是否為目標\n        Yes → Step 3: Return true // 找到目標，直接回傳\n        No → Decision: nums[left] < nums[mid]? // 判斷左半段是否為升序\n            Yes → Decision: nums[left] <= target < nums[mid]? // 目標是否在左半段\n                Yes → Step 4: right = mid - 1 // 收縮搜尋範圍到左側\n                No  → Step 5: left = mid + 1 // 收縮搜尋範圍到右側\n            No → Decision: nums[left] == nums[mid]? // 左側與中點相同，無法確定排序\n                Yes → Step 6: left = left + 1 // 跳過重複的左端點\n                No  → Decision: nums[mid] < nums[right]? // 判斷右半段是否為升序\n                    Yes → Decision: nums[mid] < target <= nums[right]? // 目標是否在右半段\n                        Yes → Step 7: left = mid + 1 // 收縮搜尋範圍到右側\n                        No  → Step 8: right = mid - 1 // 收縮搜尋範圍到左側\n                    No  → Step 9: left = left + 1 // 若右半段也無法確定，亦跳過左端點\n    No → // left > right 時停止循環\nEnd // 結束搜尋循環\n→ Step 10: Return false // 未找到目標，回傳 false\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n\n            # 如果左右端點和中點都相等，無法判斷哪一邊是排序好的，先跳過兩邊\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n                continue\n\n            # 左半段是升序的\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # 右半段是升序的\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 使用正則表達式抓取 nums 和 target\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if nums_match and target_match:\n        nums = eval(nums_match.group(1), {}, {})\n        target = int(target_match.group(1))\n    else:\n        # 無法解析輸入格式，直接退出\n        sys.exit()\n\n    solution = Solution()\n    result = solution.search(nums, target)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,5,6,0,0,1,2], target = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [2,5,6,0,0,1,2], target = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode648.json",
    "problem_index_in_file": 0,
    "title": "Replace Words",
    "description_snippet": "In English, we have a concept called root, which can be followed by some other word to form another ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: replace words in sentence with root if word starts with a root. Choose shortest root if multiple match. Provide lines: Start, then steps. We need to be clear: Build a trie or check each word with roots list. For each word, find shortest root that is prefix. Approach: For each word in sentence, iterate through roots sorted by length ascending, check prefix. That yields O(n * r * w). Could use trie for efficiency. But we can describe generic approach.\n\nWe'll produce virtual code:\n\nStart\n→ Step: Split sentence into words // split by spaces\n→ Step: Sort roots by length ascending // ensures shortest first\n→ Step: For each word in words: // iterate over words\n    → Decision: Does word start with any root? // prefix check\n        Yes → Find first root that is prefix // since sorted, first match\n            → Step: Replace word with that root\n        No  → keep original word\n→ Step: Join words with spaces // rebuild sentence\nEnd\n\nBut we also need to explain each line. Let's produce step-by-step.\n\nWe might also include building a set for quick prefix? We can include a loop over roots to check prefix. Or use trie. But we just need pseudo steps.\n\nLet's craft:\n\nStart\n→ Step 1: words ← split(sentence, \" \") // 把句子拆成單字陣列\n→ Step 2: sorted_roots ← sort(roots, ascending by length) // 先按長度升序排列根\n→ Step 3: For each idx, word in words: // 逐字處理\n    → Decision: 是否存在 root 使得 word 以 root 為前綴？ // 檢查前綴\n        Yes → For each root in sorted_roots: // 由短到長\n            → Decision: word starts with root? // 檢查\n                Yes → words[idx] ← root // 替換成根\n                No → continue // 若不匹配，繼續尋找\n        No → words[idx] ← word // 若無匹配，保持原字\n→ Step 4: result ← join(words, \" \") // 用空格重新連接單字\nEnd // 回傳 result\n\nAdd comments after each line.\n\nEnsure each line: `虛擬碼步驟 // 解釋/說明`. Use arrow etc. Let's produce lines with arrow indent etc.\n\nMake sure to keep indentation and arrow syntax. Provide \"Start // 程式開始執行\". Provide steps with indentation under loops.\n\nAlso we need \"Decision:\" lines. For loops, we use \"For each ...\" not a Decision. We can still indent. Provide \"→\" for each step. For decision, we use \"Decision:\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: words ← split(sentence, \" \") // 把整句拆成單字陣列  \n→ Step 2: sorted_roots ← sort(roots, ascending by length) // 先按長度升序排列根，確保最短根優先  \n→ Step 3: For each idx, word in words: // 逐字處理  \n  Decision: 是否存在 root 使得 word 以 root 為前綴？ // 檢查是否能被任何根取代  \n   Yes → For each root in sorted_roots: // 由短到長逐一比對  \n     Decision: word starts with root? // 判斷前綴是否匹配  \n      Yes → words[idx] ← root // 找到最短匹配根，替換當前單字  \n      No → Continue // 不匹配則繼續檢查下一個根  \n   No → words[idx] ← word // 無任何匹配根，保持原字  \n→ Step 4: result ← join(words, \" \") // 用空格重新連接單字成句子  \nEnd // 程式執行結束（返回 result）",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def replaceWords(self, dictionary, sentence):\n        trie = {}\n        END = True\n\n        # 建立 Trie\n        for root in dictionary:\n            node = trie\n            for char in root:\n                node = node.setdefault(char, {})\n            node[END] = root\n\n        def replace(word):\n            node = trie\n            for char in word:\n                if char not in node:\n                    break\n                node = node[char]\n                if END in node:\n                    return node[END]\n            return word\n\n        return ' '.join(map(replace, sentence.split()))\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得 dictionary 列表\n    dict_match = re.search(r'dictionary\\s*=\\s*(\\[.*?\\])', data, flags=re.DOTALL)\n    if dict_match:\n        dictionary_str = dict_match.group(1)\n        dictionary = eval(dictionary_str)\n    else:\n        dictionary = []\n\n    # 取得 sentence 字串\n    sent_match = re.search(r'sentence\\s*=\\s*(\".*?\")', data, flags=re.DOTALL)\n    if sent_match:\n        sentence_str = sent_match.group(1)\n        sentence = eval(sentence_str)\n    else:\n        sentence = \"\"\n\n    solution = Solution()\n    result = solution.replaceWords(dictionary, sentence)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"",
          "expected_output": "\"the cat was rat by the bat\"",
          "success": true,
          "output": "the cat was rat by the bat"
        },
        {
          "example_index": 1,
          "input": "dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"",
          "expected_output": "\"a a b c\"",
          "success": true,
          "output": "a a b c"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode435.json",
    "problem_index_in_file": 0,
    "title": "Non-overlapping Intervals",
    "description_snippet": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudocode) line by line with explanation after //.\n\nThe problem: Minimum number of intervals to remove to make rest non-overlapping. Standard solution: sort by end, iterate, keep count of non-overlap intervals, remove count = n - keep.\n\nSo produce steps: Start, Step 1: sort intervals by end ascending, Step 2: initialize countNonOverlap=0, prevEnd = -infinity, Step 3: for each interval, if start >= prevEnd, increment countNonOverlap and set prevEnd=end, else increment removeCount. Step 4: result = removeCount, End.\n\nWe'll include decision steps. Provide arrow lines.\n\nAlso note intervals that touch at a point are non-overlapping: so condition start >= prevEnd.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 intervals 按照結束點 end 升序排序 // 方便一次掃描判斷重疊  \n→ Step 2: 初始化變數 keepCount ← 0 // 追蹤已保留的非重疊區間數量  \n→ Step 3: 初始化變數 prevEnd ← -∞ // 前一個保留區間的結束點  \n→ Decision: 對於每個 interval (start, end) in intervals? // 開始遍歷所有區間  \n  Yes → Step 4: 如果 start ≥ prevEnd? // 判斷此區間是否與前一個保留區間無重疊  \n    Yes → Step 5: keepCount ← keepCount + 1 // 保留此區間  \n      prevEnd ← end // 更新前一個保留區間的結束點  \n    No → Step 6: // 需要移除此區間，keepCount 不變，prevEnd 亦不改  \n      （此步驟實際上不改變任何變數，只是算上已被移除的區間）  \n→ Step 7: 計算 removeCount ← totalIntervals - keepCount // 移除的最少區間數  \n→ End // 程式執行結束，返回 removeCount",
      "generated_code": "import sys\nimport ast\n\ndef erase_overlap_intervals(intervals):\n    \"\"\"Return the minimum number of intervals to remove so that the rest are non‑overlapping.\"\"\"\n    if not intervals:\n        return 0\n    # 按結束時間升序排序\n    intervals.sort(key=lambda x: x[1])\n    keep = 1           # 至少保留第一個區間\n    prev_end = intervals[0][1]\n    for start, end in intervals[1:]:\n        if start >= prev_end:          # 不重疊（含相切）\n            keep += 1\n            prev_end = end\n    # 要移除的數量 = 總數 - 保留數\n    return len(intervals) - keep\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    # 取得等號後的部分，或直接使用整行\n    if '=' in raw:\n        _, expr = raw.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw\n    try:\n        intervals = ast.literal_eval(expr)\n    except Exception as e:\n        # 若解析失敗則視為空清單\n        intervals = []\n    result = erase_overlap_intervals(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[1,2],[1,2]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode710.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Blacklist",
    "description_snippet": "You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line with explanation comments. No actual code, just virtual code. Provide steps for initialization and pick. Use Start/End, Decision, etc. Should reflect algorithm: map blacklisted numbers < M to allowed numbers >= M; precompute mapping and M = n - len(blacklist). In pick, random integer from 0..M-1, if mapping exists then return mapping value else return index. Provide explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input n, blacklist // 取得總範圍長度和黑名單\n→ Step 2: M ← n − count(blacklist) // 計算可選數量（合法數的數目）\n→ Step 3: Create empty hash map remap // 用來把黑名單中 < M 的數映射到合法的 ≥ M 整數\n→ Step 4: cur ← n − 1 // 從最大值開始，準備映射至合法數\n→ Step 5: For each b in blacklist sorted ascending // 處理黑名單中的每個數\n    → Decision: 如果 b < M? // 僅對低於 M 的黑名單數進行映射\n        Yes → Decision: 如果 cur in blacklist? // 若 cur 也在黑名單，需遞減\n            Yes → cur ← cur − 1 // 遞減直到找到非黑名單數\n            No  → remap[b] ← cur // 把 b 映射到合法的 cur\n        No  → Skip // 高於 M 的黑名單不需要映射\n→ Step 6: End For // 映射表完成\n→ End // 初始化結束\n\nStart // 程式開始執行\n→ Step 7: r ← random_int(0, M − 1) // 取得 0 到 M-1 的隨機整數\n→ Decision: 如果 r in remap? // 檢查 r 是否為黑名單映射鍵\n    Yes → Return remap[r] // 若是，返回映射到合法數的值\n    No  → Return r // 若不是，直接返回 r（已是合法數）\n→ End // pick 完成\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\ndef main():\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n    ops = json.loads(lines[0])\n    args_list = json.loads(lines[1])\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            method = getattr(obj, op)\n            # args is a list of arguments for the method\n            results.append(method(*args))\n\n    # Output as JSON to match expected format (null for None)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,6,4,6,1,1,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 6, 4, 6, 1, 1, 6]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode677.json",
    "problem_index_in_file": 0,
    "title": "Map Sum Pairs",
    "description_snippet": "Design a map that allows you to do the following:\n\nMaps a string key to a given value.\nReturns the s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output pseudo-code for the described MapSum class. Should be line-by-line with virtual code steps and comment. We must use the specified format. Each line: \"虛擬碼步驟 [space] // 解釋\". Use arrows etc. Let's design steps: Start, initialize root of Trie with sum 0, children map. insert: traverse, updating sums; track old value. sum: traverse prefix accumulate sum. Also need storage of key to value map for overrides. Represent pseudo-code logic.\n\nWe need to provide structure: Start, End. Use Decision lines? We can just present algorithm steps. Provide arrow formatting as per examples: \"→ Step 1: ...\" etc.\n\nLet's output.\n\nUse \"Start // 初始化MapSum\". Then \"→ Step 1: 建立 TrieRoot\" etc.\n\nWe must include arrow for decisions. Provide mapping.\n\nLet's produce a pseudo-code:\n\nStart\n→ Step 1: 定義 TrieNode { int sum; Map<char, TrieNode> children } // Trie節點，保存前綴和\n→ Step 2: 初始化 root = new TrieNode() // 以空節點作為根\n→ Step 3: 定義 keyToVal = {} // 存儲每個 key 的目前值\n→ Step 4: 定義 insert(key, val) // 插入或覆蓋\n→ Decision: key 是否已存在? // 檢查覆蓋\n    Yes → Step 5: old = keyToVal[key] // 取得舊值\n    No  → Step 5: old = 0 // 若不存在，舊值為0\n→ Step 6: keyToVal[key] = val // 更新鍵值對\n→ Step 7: delta = val - old // 計算差值\n→ Step 8: node = root\n→ Step 9: node.sum += delta // 更新根節點的 sum\n→ Step 10: for each char c in key\n        Decision: node.children 是否包含 c? // 若沒有子節點\n            Yes → Step 11: node = node.children[c]\n            No  → Step 11: node.children[c] = new TrieNode(); node = node.children[c]\n        Step 12: node.sum += delta // 更新此節點的 sum\n→ End // insert 完成\n\nSimilarly sum(prefix):\n\n→ Step 13: node = root\n→ Step 14: for each char c in prefix\n        Decision: node.children 是否包含 c? // 若不存在，返回0\n            Yes → Step 15: node = node.children[c]\n            No  → Step 15: return 0 // 無前綴\n→ Step 16: return node.sum // 回傳前綴總和\n\nEnd.\n\nNeed to use \"End // 程式執行結束\"? But this is the class; we can end overall pseudo-code after sum function. Use End at end of class definition.\n\nLet's produce.\n...done thinking.\n\nStart // MapSum 類別開始初始化  \n→ Step 1: 定義 TrieNode { int sum; Map<char, TrieNode> children } // Trie 節點，存前綴和值總和  \n→ Step 2: root = new TrieNode() // 建立根節點，sum 先為 0  \n→ Step 3: keyToVal = {} // 字典，儲存每個 key 的目前值  \n\n// --------------------------\n// 1. insert 方法  \n// --------------------------\n→ Step 4: insert(key, val) // 插入或覆蓋 key‑val  \n→ Decision: key 是否已存在? // 檢查是否需要覆蓋舊值  \n Yes → Step 5: old = keyToVal[key] // 取得舊值  \n No  → Step 5: old = 0 // 沒有舊值，視為 0  \n→ Step 6: keyToVal[key] = val // 更新 key 與新值  \n→ Step 7: delta = val - old // 計算要加到每個前綴的差值  \n→ Step 8: node = root  \n→ Step 9: node.sum += delta // 更新根節點的 sum  \n→ Step 10: for each char c in key  \n  Decision: node.children 是否包含 c? // 若無子節點  \n   Yes → Step 11: node = node.children[c] // 進入已存在的子節點  \n   No  → Step 11: node.children[c] = new TrieNode(); node = node.children[c] // 新建子節點  \n   Step 12: node.sum += delta // 更新該節點的 sum  \n→ End // insert 方法結束  \n\n// --------------------------\n// 2. sum 方法  \n// --------------------------\n→ Step 13: sum(prefix) // 回傳所有以 prefix 開頭的 key 的值總和  \n→ Step 14: node = root  \n→ Step 15: for each char c in prefix  \n  Decision: node.children 是否包含 c? // 若沒有，則無符合前綴  \n   Yes → Step 16: node = node.children[c] // 進入下一節點  \n   No  → Step 16: return 0 // 沒有此前綴，總和為 0  \n→ Step 17: return node.sum // 返回最後節點的 sum，即前綴總和  \nEnd // MapSum 類別結束",
      "generated_code": "import sys\nimport ast\n\nclass MapSum:\n    def __init__(self):\n        # 存儲 key -> val 的字典\n        self.store = {}\n\n    def insert(self, key: str, val: int) -> None:\n        # 直接覆蓋或新增 key\n        self.store[key] = val\n\n    def sum(self, prefix: str) -> int:\n        # 計算所有以 prefix 開頭的 key 的值總和\n        total = 0\n        for k, v in self.store.items():\n            if k.startswith(prefix):\n                total += v\n        return total\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops_line = data[0].strip()\n    args_line = data[1].strip() if len(data) > 1 else \"[]\"\n\n    ops = ast.literal_eval(ops_line)\n    args = ast.literal_eval(args_line)\n\n    result = []\n    instance = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MapSum\":\n            instance = MapSum()\n            result.append(None)\n        elif op == \"insert\":\n            instance.insert(*arg)\n            result.append(None)\n        elif op == \"sum\":\n            res = instance.sum(*arg)\n            result.append(res)\n        else:\n            # 若有未知操作，忽略\n            result.append(None)\n\n    # 將結果轉成指定格式：None 用 null 表示\n    output = '[' + ', '.join('null' if x is None else str(x) for x in result) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      '[]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode137.json",
    "problem_index_in_file": 0,
    "title": "Single Number II",
    "description_snippet": "Given an integer array nums where every element appears three times except for one, which appears ex...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode. Use virtual code style. We must not output real code. The algorithm: bitwise counting. For each bit position 0-31, count sum of bits mod 3. Then reconstruct number. Use 32-bit integer. We also consider negative numbers: use two's complement. After building number, if msb set, convert to negative.\n\nSo produce step-by-step. Use virtual code. Format: each line: \"虛擬碼步驟 // 解釋\". Include arrows. Start/End. Use Decision, loops, etc. Let's produce lines.\n\nPossible steps:\n\nStart\n→ Initialize result = 0\n→ For bit from 0 to 31:\n    → sum = 0\n    → For each num in nums:\n        → If ((num >> bit) & 1) == 1:\n            → sum = sum + 1\n    → If (sum % 3) != 0:\n        → Set bit in result: result = result | (1 << bit)\n→ After loop: Check if result's sign bit is set (bit 31). \n    → Decision: if (result & (1 << 31)) != 0\n        Yes → result = result - (1 << 32)  // Convert to negative\n→ Return result\nEnd\n\nAdd explanation after each line. Ensure format.\n\nLet's produce. Use 虛擬碼 with arrow. Use Decision: etc. Provide explanation. Ensure each line ends with // 解釋. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Result = 0 // 初始化結果為 0  \n→ For bit = 0 to 31: // 逐位檢查 32 位元  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Sum = 0 // 為每個位元位置初始化計數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ For each Num in nums: // 遍歷數組  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ If ((Num >> bit) & 1) == 1: // 檢查該位是否為 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Sum = Sum + 1 // 計數加一  \n&nbsp;&nbsp;&nbsp;&nbsp;→ If (Sum % 3) != 0: // 若位元總數不是 3 的倍數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Result = Result | (1 << bit) // 設置該位為 1  \n→ Decision: 如果 Result 的最高位 (bit 31) 為 1? // 判斷是否為負數  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Result = Result - (1 << 32) // 轉換為負數（補碼調整）  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → // 仍為正數，保持 Result 不變  \n→ Return Result // 傳回唯一出現一次的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def singleNumber(self, nums):\n        # 使用位元統計法，對 32 位元逐位計算出現次數的餘數\n        result = 0\n        for bit in range(32):\n            bit_sum = 0\n            for num in nums:\n                # 取得 num 在 bit 位置上的位元\n                if (num >> bit) & 1:\n                    bit_sum += 1\n            # 若該位元出現的次數不是 3 的倍數，則該位在結果中為 1\n            if bit_sum % 3:\n                result |= (1 << bit)\n        # 若最高位為 1，表示是負數，需要轉換為 Python 的負整數\n        if result & (1 << 31):\n            result -= (1 << 32)\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 只取第一個出現的陣列字串\n    start = data.find('[')\n    end = data.find(']', start)\n    if start == -1 or end == -1:\n        print(\"0\")\n        return\n    nums_str = data[start:end+1]\n    nums = eval(nums_str)  # 轉成實際的 list\n    sol = Solution()\n    print(sol.singleNumber(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "success": true,
          "output": "99"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode478.json",
    "problem_index_in_file": 0,
    "title": "Generate Random Point in a Circle",
    "description_snippet": "Given the radius and the position of the center of a circle, implement the function randPoint which ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for solution class with constructor and randPoint generating uniform random point inside circle. Use random uniform. Approach: choose radius sqrt(U)*R, angle uniform 0 to 2π. Then x = center_x + r*cosθ, y = center_y + r*sinθ. So we produce steps.\n\nWe must output in given format: each line: virtual code step + space + // explanation.\n\nUse Start, End, Decision. Use arrows.\n\nWe need to structure pseudo steps: Start, Step 1: initialize variables, Step 2: generate random number u, Step 3: compute r, Step 4: generate random angle theta, Step 5: compute x, y, Step 6: return [x,y]. Also include constructor.\n\nLet's produce pseudocode:\n\nStart\n→ Class Solution: // 定義 Solution 類\n    → Constructor: Solution(radius, x_center, y_center) // 初始化半徑與中心座標\n        → Set self.radius = radius\n        → Set self.x_center = x_center\n        → Set self.y_center = y_center\n    → Method: randPoint() // 產生隨機點\n        → Step 1: Generate uniform u in [0,1] // 隨機數\n        → Step 2: Compute r = sqrt(u) * self.radius // 調整半徑以保證均勻分佈\n        → Step 3: Generate uniform angle θ in [0, 2π] // 隨機角度\n        → Step 4: x = self.x_center + r * cos(θ) // 計算 x 坐標\n        → Step 5: y = self.y_center + r * sin(θ) // 計算 y 坐標\n        → Return [x, y] // 回傳點座標\nEnd\n\nBut we need to use arrows and structure: Use Start, End, Decision: not needed.\n\nWe can include nested steps but just simple lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution: // 定義 Solution 類  \n    → Constructor: Solution(radius, x_center, y_center) // 初始化半徑與中心座標  \n        → Set self.radius = radius // 保存半徑  \n        → Set self.x_center = x_center // 保存中心 X 座標  \n        → Set self.y_center = y_center // 保存中心 Y 座標  \n    → Method: randPoint() // 產生隨機點  \n        → Generate uniform u in [0, 1] // 產生均勻分佈的隨機數  \n        → Compute r = sqrt(u) * self.radius // 轉換半徑以確保均勻分佈  \n        → Generate uniform angle θ in [0, 2π] // 產生隨機角度  \n        → Compute x = self.x_center + r * cos(θ) // 計算 X 坐標  \n        → Compute y = self.y_center + r * sin(θ) // 計算 Y 坐標  \n        → Return [x, y] // 回傳隨機點座標  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 以極座標方式產生均勻分佈的隨機點\n        r = self.radius * math.sqrt(random.random())   # sqrt 以確保半徑分佈均勻\n        theta = random.uniform(0, 2 * math.pi)          # 隨機角度\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行：方法名列表，第二行：每個方法的參數列表\n    funcs = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    obj = None\n    outputs = []\n\n    for func, args in zip(funcs, args_list):\n        if func == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)          # 建構子不回傳值\n        else:\n            method = getattr(obj, func)\n            res = method(*args)\n            outputs.append(res)\n\n    # 將結果序列化為 JSON 格式輸出\n    print(json.dumps(outputs, separators=(\",\", \":\")))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.8159668236196048,-0.07354689700196754],[-0.5627668837670451,-0.05192121406889954],[-0.8562101212998855,0.42423649798300134]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null,[-0.8159668236196048,-0.07354689700196754],[-0.5627668837670451,-0.05192121406889954],[-0.8562101212998855,0.42423649798300134]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode77.json",
    "problem_index_in_file": 0,
    "title": "Combinations",
    "description_snippet": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations for generating all combinations of k numbers from 1..n. We should present algorithm (backtracking). Virtual code lines with arrow etc. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc.\n\nLet's design:\n\nStart // start\n→ Step 1: 定義空結果列表 res // 用於存儲所有組合\n→ Step 2: 定義遞歸函式 backtrack(start, path) // 回溯函式，start 為下一個可選取數字，path 為當前組合\n    → Decision: path 長度是否等於 k? // 檢查是否已選 k 個數字\n        Yes → Step 3: 把 path 複製加入 res // 完成一個組合，加入結果\n        No  → Decision: start 是否大於 n? // 檢查是否已超出範圍\n            Yes → Step 4: 返回 // 無更多選項，返回上一層\n            No  → Step 5: For i 在 start 到 n:\n                    → Step 6: path 加入 i // 選擇 i\n                    → Step 7: backtrack(i+1, path) // 進一步選取剩餘數字\n                    → Step 8: path 移除最後一個 // 撤銷選擇，回溯\n→ Step 9: 呼叫 backtrack(1, 空列表) // 開始回溯\n→ Step 10: 返回 res // 返回所有組合\nEnd // 程式結束\n\nBut need to be per line. For loops may be represented as separate steps. Use arrow.\n\nLet's format with spaces and // explanation.\n\nWe must output each line with \"虛擬碼步驟 // 解釋\". Use \"Start\" and \"End\". Use \"Decision:\" lines. Use arrow \"→\" before steps. Use indentation for sub-steps maybe? But the example used indentation. We should follow same style. Each sub-step with arrow and indent.\n\nWe'll produce each line with appropriate spacing and comment.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 定義空列表 res // 用於儲存所有組合\n→ Step 2: 定義遞歸函式 backtrack(start, path) // 回溯函式，start 為下一個可選取的數字，path 為當前組合\n    → Decision: path 長度是否等於 k? // 檢查是否已選到 k 個數字\n        Yes → Step 3: 把 path 複製加入 res // 完整組合，加入結果\n        No  → Decision: start 是否大於 n? // 檢查是否已超出可選範圍\n            Yes → Step 4: 返回 // 無可選項，回到上一層\n            No  → Step 5: For i 從 start 到 n: // 循環遍歷剩餘數字\n                    → Step 6: path 加入 i // 選擇 i\n                    → Step 7: backtrack(i+1, path) // 進一步遞歸\n                    → Step 8: path 移除最後一個 // 撤銷選擇，回溯\n→ Step 9: 呼叫 backtrack(1, 空列表) // 開始回溯過程\n→ Step 10: 返回 res // 返回所有組合\nEnd // 程式執行結束\n\nNeed to ensure each line is separate with line breaks. Also maybe need to include arrow for Start and End? In example they wrote \"Start // 程式開始執行\" without arrow. So we keep as is.\n\nNow deliver final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空列表 res // 用於儲存所有組合  \n→ Step 2: 定義遞歸函式 backtrack(start, path) // 回溯函式，start 為下一個可選取的數字，path 為當前組合  \n  → Decision: path 長度是否等於 k? // 檢查是否已選到 k 個數字  \n    Yes → Step 3: 把 path 複製加入 res // 完整組合，加入結果  \n    No  → Decision: start 是否大於 n? // 檢查是否已超出可選範圍  \n      Yes → Step 4: 返回 // 無可選項，回到上一層  \n      No  → Step 5: For i 從 start 到 n: // 循環遍歷剩餘數字  \n        → Step 6: path 加入 i // 選擇 i  \n        → Step 7: backtrack(i+1, path) // 進一步遞歸  \n        → Step 8: path 移除最後一個 // 撤銷選擇，回溯  \n→ Step 9: 呼叫 backtrack(1, 空列表) // 開始回溯過程  \n→ Step 10: 返回 res // 返回所有組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combine(self, n, k):\n        res = []\n\n        def backtrack(start, path):\n            if len(path) == k:\n                res.append(path[:])\n                return\n            for i in range(start, n + 1):\n                path.append(i)\n                backtrack(i + 1, path)\n                path.pop()\n\n        backtrack(1, [])\n        return res\n\n\ndef main():\n    # 讀取整個輸入並提取數字\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n\n    solution = Solution()\n    combos = solution.combine(n, k)\n\n    # 將結果轉成沒有空格的字串格式\n    output = '[' + ','.join('[' + ','.join(map(str, combo)) + ']' for combo in combos) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4, k = 2",
          "expected_output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
          "success": true,
          "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode365.json",
    "problem_index_in_file": 0,
    "title": "Water and Jug Problem",
    "description_snippet": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Ret...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps to determine if target can be reached with two jugs. Classic problem: solution exists iff target <= x + y and target % gcd(x,y) == 0. Need to output steps.\n\nWe need to produce virtual code steps with arrows. Steps:\n\nStart, compute gcd, check capacity, check divisibility, output result.\n\nWe need to follow formatting: \"虛擬碼步驟 [space] // 解釋/說明\"\n\nWe need to use Start, End, Decision: with Yes →, No →.\n\nWe also need to include operations maybe? But we just need logic.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 計算 x 與 y 的最大公因數 g // 用於判斷可否達到 target\n→ Step 2: If target > x + y then\n    No → Step 3: 回傳 false // 目標超出兩個水桶總容量\n    Yes → Decision: target % g == 0? // 檢查可否整除\n        Yes → Step 4: 回傳 true // 可達到 target\n        No  → Step 5: 回傳 false // 不可達到 target\nEnd // 程式執行結束\n\nBut we must use proper arrow formatting: Decision: If condition? // explanation\n    Yes → Step: ...\n    No  → Step: ...\n\nAlso use Start, End. Let's format accordingly.\n\nWe need each line with a single step. So Step 1, Step 2, etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: g ← gcd(x, y) // 計算兩個水桶容量的最大公因數\n→ Decision: target > x + y? // 檢查目標是否超過兩桶總容量\n    Yes → Step 2: return false // 目標水量無法達成\n    No  → Decision: target % g == 0? // 檢查目標是否能被最大公因數整除\n        Yes → Step 3: return true // 可達成目標\n        No  → Step 4: return false // 無法達成目標\nEnd // 程式執行結束\n\nThat's acceptable. Ensure no code but virtual. Use arrows as specified. Provide one step per line. Done.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: g ← gcd(x, y) // 計算兩個水桶容量的最大公因數\n→ Decision: target > x + y? // 檢查目標是否超過兩桶總容量\n    Yes → Step 2: return false // 目標水量無法達成\n    No  → Decision: target % g == 0? // 檢查目標是否能被最大公因數整除\n        Yes → Step 3: return true // 可達成目標\n        No  → Step 4: return false // 無法達成目標\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef gcd(a: int, b: int) -> int:\n    \"\"\"計算兩個數的最大公因數。\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef can_measure_water(x: int, y: int, target: int) -> bool:\n    \"\"\"\n    判斷是否可以用容量為 x 和 y 的兩個水桶達到 target 的總水量。\n    原則：target 必須不大於 x + y，且 target 必須能被 gcd(x, y) 整除。\n    \"\"\"\n    if target > x + y:\n        return False\n    return target % gcd(x, y) == 0\n\ndef main() -> None:\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n    # 提取所有整數\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 3:\n        # 如果輸入不足三個數字，直接輸出 false\n        print(\"false\")\n        return\n    x, y, target = nums[0], nums[1], nums[2]\n    result = can_measure_water(x, y, target)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 3, y = 5, target = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = 2, y = 6, target = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 1, y = 2, target = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode689.json",
    "problem_index_in_file": 0,
    "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
    "description_snippet": "Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. Provide steps using arrow format. Must be line by line. Use Start, End, Decision. Provide explanation comments. Need to generate pseudocode for algorithm to find three non-overlapping subarrays length k maximizing sum and lexicographically smallest. Classic Leetcode 689.\n\nWe need to produce pseudocode. Use steps: compute prefix sums, sliding windows sums array of length n-k+1. Then dynamic programming: leftBest array storing best index up to i for first subarray. Also leftDP storing best sum. Similarly rightBest. Then iterate middle subarray index j from k to n-2k. For each, left index from leftBest[j-k], right index from rightBest[j+k]. Evaluate total sum. Keep best total and indices.\n\nAlso we need lexicographically smallest: if total sum equals best, choose smaller left index; if equal left then smaller middle; else smaller right. But typical algorithm ensures leftBest and rightBest choose smallest index for tie sums. Then scanning j increasing ensures lexicographically smallest.\n\nWe can incorporate tie-breaking.\n\nLet's produce lines with pseudocode: Start, compute sums array, leftBest, leftSum, rightBest, rightSum, bestTotal, bestIndices, loop j.\n\nLet's craft explanation.\n\nMake sure to use \"Step\" or \"Decision\". We'll use \"Step\" lines with arrow.\n\nLet's produce.\n\nWe'll produce about maybe 20 lines.\n\nRemember: each line has `虛擬碼步驟` + space + `// 解釋/說明`. Use Chinese comments.\n\nLet's craft.\n\nAlso we need arrow '→' after Start, maybe we don't need arrow for Start? Format: \"Start // 程式開始執行\" no arrow. After that we use \"→ Step 1:\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 prefixSum[0..n]，其中 prefixSum[i] 為 nums[0..i-1] 的累加和 // 方便 O(1) 取子陣列和  \n→ Step 2: 建立 sum[0..m-1]，m = n-k+1，sum[i] = prefixSum[i+k]-prefixSum[i] // 取得所有長度 k 的子陣列和  \n→ Step 3: 初始化 leftBest[0..m-1]、leftSum[0..m-1]  \n    → Step 3a: leftSum[0] = sum[0]，leftBest[0] = 0 // 第一個子陣列最佳選擇  \n    → Decision: for i from 1 to m-1? // 迭代所有子陣列索引  \n        Yes → Step 3b: 若 sum[i] > leftSum[i-1]  \n            → Step 3c: leftSum[i] = sum[i]，leftBest[i] = i // 新更大，更新  \n            → Decision: 否?  \n                Yes → Step 3d: leftSum[i] = leftSum[i-1]，leftBest[i] = leftBest[i-1] // 舊最佳保持  \n→ Step 4: 初始化 rightBest[0..m-1]、rightSum[0..m-1]  \n    → Step 4a: rightSum[m-1] = sum[m-1]，rightBest[m-1] = m-1 // 最後一個子陣列最佳  \n    → Decision: for i from m-2 downto 0? // 逆向迭代  \n        Yes → Step 4b: 若 sum[i] > rightSum[i+1]  \n            → Step 4c: rightSum[i] = sum[i]，rightBest[i] = i // 新更大，更新  \n            → Decision: 否?  \n                Yes → Step 4d: rightSum[i] = rightSum[i+1]，rightBest[i] = rightBest[i+1] // 舊最佳保持  \n→ Step 5: bestTotal = -∞，bestIndices = [0,0,0] // 用於存儲目前最佳三個子陣列  \n→ Decision: for mid from k to m-k-1? // mid 為第二個子陣列起始索引，確保左右兩邊有空間  \n    Yes → Step 5a: left = leftBest[mid-k] // 左邊最佳起始  \n        → Step 5b: right = rightBest[mid+k] // 右邊最佳起始  \n        → Step 5c: total = sum[left] + sum[mid] + sum[right] // 目前總和  \n        → Decision: if total > bestTotal? // 找更大總和  \n            Yes → Step 5d: bestTotal = total  \n                → Step 5e: bestIndices = [left, mid, right] // 更新最佳索引  \n            No → Decision: if total == bestTotal? // 相同總和時進行字典序比較  \n                Yes → Step 5f: 若 left < bestIndices[0] 或 (left == bestIndices[0] 且 mid < bestIndices[1])  \n                    → Step 5g: bestIndices = [left, mid, right] // 獲得更小字典序  \n                No → Do nothing  \n→ End // 程式執行結束，返回 bestIndices\n\n---  \n\n**說明**  \n- `prefixSum` 讓我們能在 O(1) 內取得任意長度 k 的子陣列和。  \n- `sum` 儲存所有可能的子陣列和，索引對應起始位置。  \n- `leftBest` 與 `leftSum` 在左半邊累積，對於每個位置 i 傳遞至 i 的最佳左側子陣列。  \n- `rightBest` 與 `rightSum` 在右半邊累積，類似處理右側子陣列。  \n- 迭代 `mid` 時，確保左邊至少有 k 個位置，右邊亦如此。  \n- `total` 為三個子陣列的總和，若大於目前最佳則更新；若相等則依字典序選擇更小的索引組。  \n- 最後 `bestIndices` 即為三個不重疊子陣列的起始索引（0-indexed）。",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        # 1. Compute all subarray sums of length k\n        w = [0] * (n - k + 1)\n        s = sum(nums[:k])\n        w[0] = s\n        for i in range(1, n - k + 1):\n            s += nums[i + k - 1] - nums[i - 1]\n            w[i] = s\n\n        # 2. left[i] = best starting index for first subarray in range [0, i]\n        left = [0] * len(w)\n        best = 0\n        for i in range(len(w)):\n            if w[i] > w[best]:\n                best = i\n            left[i] = best\n\n        # 3. right[i] = best starting index for third subarray in range [i, end]\n        right = [0] * len(w)\n        best = len(w) - 1\n        for i in range(len(w) - 1, -1, -1):\n            if w[i] >= w[best]:\n                best = i\n            right[i] = best\n\n        # 4. Iterate over middle subarray start index\n        res = None  # store (total_sum, [i, j, l])\n        for j in range(k, len(w) - k):\n            i = left[j - k]\n            l = right[j + k]\n            total = w[i] + w[j] + w[l]\n            if res is None or total > res[0]:\n                res = (total, [i, j, l])\n\n        return res[1] if res else []\n\ndef parse_input(data: str):\n    # Extract list of numbers\n    nums_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not nums_match:\n        raise ValueError(\"Cannot find nums list in input.\")\n    nums_str = nums_match.group(0)\n    nums = eval(nums_str)\n\n    # Extract k\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if not k_match:\n        raise ValueError(\"Cannot find k value in input.\")\n    k = int(k_match.group(1))\n    return nums, k\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    nums, k = parse_input(input_data)\n    solution = Solution()\n    result = solution.maxSumOfThreeSubarrays(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,2,6,7,5,1], k = 2",
          "expected_output": "[0,3,5]",
          "success": true,
          "output": "[0, 3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,2,1,2,1,2,1], k = 2",
          "expected_output": "[0,2,4]",
          "success": true,
          "output": "[0, 2, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode680.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome II",
    "description_snippet": "Given a string s, return true if the s can be palindrome after deleting at most one character from i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for the problem: check if string can be palindrome after deleting at most one char. We need to produce lines with arrow etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, decisions.\n\nWe need to design algorithm: two pointers i, j. While i<j, if s[i]==s[j] increment i, decrement j; else need to check either skip i or skip j; return result of either substring being palindrome. For at most one deletion. So we need helper function isPalindromeRange(l,r). We'll produce pseudocode.\n\nLet's craft lines:\n\nStart // start\n\n→ Step 1: Define two pointers left = 0, right = length(s)-1 // initialize pointers\n\n→ Decision: while left < right? // main loop condition\n\n   Yes → Decision: if s[left] == s[right]? // check characters match\n\n      Yes → Step 2: left++; right-- // move inward\n\n      No  → Step 3: Check if substring left+1..right is palindrome OR left..right-1 is palindrome // try one deletion\n\n           → Decision: if isPalindromeRange(left+1, right) OR isPalindromeRange(left, right-1)? // check either side\n\n               Yes → Step 4: return true // can form palindrome\n\n               No  → Step 5: return false // cannot\n\n   No  → Step 6: return true // pointers crossed, already palindrome\n\nEnd\n\nWe also need to define isPalindromeRange. But we can incorporate within.\n\nWe should output each line as virtual code with comment. Let's produce.\n\nMake sure each line ends with comment. Use arrow for step lines.\n\nLet's produce the final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個指標 left = 0, right = s.length - 1 // 設定左右指標  \n→ Decision: 如果 left < right? // 進入主迴圈  \n    Yes → Decision: s[left] == s[right]? // 檢查左右字符是否相同  \n        Yes → Step 2: left = left + 1; right = right - 1 // 匹配，向內移動指標  \n        No  → Step 3: 檢查左右任一側刪除一個字符後是否為回文 // 嘗試刪除  \n               → Decision: isPalindromeRange(left+1, right) 或 isPalindromeRange(left, right-1)?  \n                    Yes → Step 4: return true // 可以成為回文  \n                    No  → Step 5: return false // 無法成為回文  \n    No  → Step 6: return true // 指標相遇或交叉，已經是回文  \nEnd // 程式執行結束  \n\n// isPalindromeRange(l, r) 的虛擬碼（可單獨放在主程式之外）  \nStart // 檢查子字串是否為回文  \n→ Decision: 當 l < r?  \n    Yes → Decision: s[l] == s[r]?  \n        Yes → l = l + 1; r = r - 1 // 兩端相等，繼續檢查  \n        No  → return false // 不相等，非回文  \n    No  → return true // 左右指標相遇，為回文  \nEnd // 函式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        # Helper function to check if s[i:j+1] is a palindrome\n        def is_palindrome_range(i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] != s[j]:\n                # Try skipping either the left or the right character\n                return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1)\n            i += 1\n            j -= 1\n        return True\n\ndef read_input() -> str:\n    \"\"\"\n    Reads the entire input from stdin and extracts the string value.\n    Supports two common input formats:\n    1. s = \"some_string\"\n    2. some_string\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return \"\"\n\n    # Search for a quoted string\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        return match.group(1)\n\n    # If no quoted string, return the raw input (strip whitespace)\n    return data.strip()\n\ndef main() -> None:\n    s = read_input()\n    solution = Solution()\n    result = solution.validPalindrome(s)\n    # Output as lowercase 'true'/'false' to match the examples\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aba\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"abca\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"abc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode730.json",
    "problem_index_in_file": 0,
    "title": "Count Different Palindromic Subsequences",
    "description_snippet": "Given a string s, return the number of different non-empty palindromic subsequences in s. Since the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: Count distinct non-empty palindromic subsequences. Classic DP with next/prev arrays or dp[l][r] with recurrence. Use modulo. We'll write steps. Let's produce virtual code with Start, Decision, End.\n\nWe need to show each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's produce steps: read s, compute next and prev positions for each char? simpler: use dp table size n x n. Recurrence:\n\nIf s[l]==s[r]: dp[l][r] = dp[l+1][r] + dp[l][r-1] + 1\nElse: dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]\n\nBut need distinct: need to handle duplicates. Use next/prev arrays: For each char c, next[l][c] = next occurrence of c after l; prev[r][c] = prev occurrence of c before r.\n\nRecurrence:\n\nIf s[l]==s[r]:\n  let c = s[l]\n  nl = next[l+1][c]\n  pr = prev[r-1][c]\n  if nl > pr: dp[l][r] = dp[l+1][r-1] * 2 + 2\n  else if nl == pr: dp[l][r] = dp[l+1][r-1] * 2 + 1\n  else: dp[l][r] = dp[l+1][r-1] * 2 - dp[nl+1][pr-1]\nElse:\n  dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]\n\nAll mod. Finally answer dp[0][n-1].\n\nLet's produce pseudo code steps accordingly. We'll include loops. Let's output each step with comment.\n\nAlso include mod constant. Provide initialization dp with zeros.\n\nWe'll produce steps:\n\nStart\n→ Input string s // read input\n→ n = length(s)\n→ mod = 1e9+7 // modulo value\n→ Initialize 2D array dp[n][n] to 0 // dp[l][r] will store answer for substring l..r\n→ Precompute nextPos[n][26] and prevPos[n][26] // next and previous occurrence arrays\n  → For each char i from 0 to 25:\n      nextPos[n-1][i] = n // sentinel beyond end\n  → For l from n-2 down to 0:\n      For each char i:\n          nextPos[l][i] = nextPos[l+1][i]\n      nextPos[l][s[l]-'a'] = l+1\n  → For prevPos[0][i] = -1\n  → For r from 1 to n-1:\n      For each char i:\n          prevPos[r][i] = prevPos[r-1][i]\n      prevPos[r][s[r]-'a'] = r-1\n→ Compute dp for substrings of increasing length\n  → For length from 1 to n:\n      For l from 0 to n-length:\n          r = l + length -1\n          If length == 1:\n              dp[l][r] = 1 // single char palindrome\n          Else:\n              If s[l] == s[r]:\n                  c = s[l]-'a'\n                  nl = nextPos[l+1][c]\n                  pr = prevPos[r-1][c]\n                  If nl > pr:\n                      dp[l][r] = (dp[l+1][r-1] * 2 + 2) % mod\n                  Else If nl == pr:\n                      dp[l][r] = (dp[l+1][r-1] * 2 + 1) % mod\n                  Else:\n                      dp[l][r] = (dp[l+1][r-1] * 2 - dp[nl+1][pr-1]) % mod\n                      If dp[l][r] < 0: dp[l][r] += mod\n              Else:\n                  dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]) % mod\n                  If dp[l][r] < 0: dp[l][r] += mod\n→ answer = dp[0][n-1] % mod\n→ Output answer\nEnd\n\nWe need each line with // explanation. Use arrow formatting.\n\nLet's produce each line. We must be careful about each step line. Provide arrow '→' for substeps. Use indent? They used indentation in example with nested decisions. We can show indentation using spaces. Let's craft.\n\nWe need to list lines exactly with code-like steps. Use \"→ Step: ...\". For loops, we can use \"→ For ...:\" lines.\n\nLet's produce.\n\nBe mindful of mod adjustments. Provide comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input string s // 從使用者處取得輸入字串  \n→ n = length(s) // 字串長度  \n→ mod = 1000000007 // 取模數  \n\n// 初始化 DP 陣列  \n→ 初始化 dp[n][n] 為 0 // dp[l][r] 為子字串 l..r 的答案  \n\n// 先計算 nextPos 與 prevPos，方便快速取得同一字母的下次與上次位置  \n→ Initialize nextPos[n][26] 為 n // 限界值，表示沒有更後面同字母  \n→ For l = n-2 downto 0:  \n    → For i = 0 to 25:  \n        → nextPos[l][i] = nextPos[l+1][i] // 先複製下一個位置的資訊  \n    → nextPos[l][s[l]-'a'] = l+1 // 本位置字母的下一個位置是 l+1  \n\n→ Initialize prevPos[n][26] 為 -1 // 限界值，表示沒有前一個同字母  \n→ For r = 1 to n-1:  \n    → For i = 0 to 25:  \n        → prevPos[r][i] = prevPos[r-1][i] // 先複製前一個位置的資訊  \n    → prevPos[r][s[r]-'a'] = r-1 // 本位置字母的前一個位置是 r-1  \n\n// DP 逐長度計算子字串的答案  \n→ For length = 1 to n:  \n    → For l = 0 to n - length:  \n        → r = l + length - 1 // 子字串結束位置  \n        → If length == 1:  \n            → dp[l][r] = 1 // 單字母本身是唯一的回文子序列  \n        → Else:  \n            → If s[l] == s[r]: // 兩端字母相同  \n                → c = s[l] - 'a' // 對應字母編號  \n                → nl = nextPos[l+1][c] // 從 l+1 開始的下一個同字母位置  \n                → pr = prevPos[r-1][c] // 從 r-1 開始的上一個同字母位置  \n                → If nl > pr: // 兩端之間沒有相同字母  \n                    → dp[l][r] = (dp[l+1][r-1] * 2 + 2) % mod // 新增兩種長度 +1 的子序列  \n                → Else If nl == pr: // 只有一個相同字母  \n                    → dp[l][r] = (dp[l+1][r-1] * 2 + 1) % mod // 新增兩種長度 +1 的子序列，減一個重複  \n                → Else: // 兩端之間有多個相同字母  \n                    → dp[l][r] = (dp[l+1][r-1] * 2 - dp[nl+1][pr-1]) % mod // 減去重複計算的子序列  \n                    → If dp[l][r] < 0: dp[l][r] += mod // 確保非負  \n            → Else: // s[l] != s[r]  \n                → dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]) % mod // 合併兩側子序列，扣除重疊  \n                → If dp[l][r] < 0: dp[l][r] += mod // 確保非負  \n\n→ answer = dp[0][n-1] % mod // 最終答案  \n→ Output answer // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[l][r] will store number of distinct palindromic subsequences in s[l:r+1]\n    dp = [[0] * n for _ in range(n)]\n\n    # next_pos[i][c] = smallest index > i where s[index] == c, or n if none\n    next_pos = [[n] * 26 for _ in range(n)]\n    # prev_pos[i][c] = largest index < i where s[index] == c, or -1 if none\n    prev_pos = [[-1] * 26 for _ in range(n)]\n\n    # build next_pos\n    for i in range(n - 1, -1, -1):\n        if i < n - 1:\n            for c in range(26):\n                next_pos[i][c] = next_pos[i + 1][c]\n        next_pos[i][ord(s[i]) - 97] = i + 1\n\n    # build prev_pos\n    for i in range(1, n):\n        for c in range(26):\n            prev_pos[i][c] = prev_pos[i - 1][c]\n        prev_pos[i][ord(s[i]) - 97] = i - 1\n\n    # base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n\n    # DP over increasing length\n    for length in range(2, n + 1):\n        for l in range(n - length + 1):\n            r = l + length - 1\n            if s[l] == s[r]:\n                c = ord(s[l]) - 97\n                nl = next_pos[l + 1][c]\n                pr = prev_pos[r - 1][c]\n                if nl > pr:\n                    # no inner same character\n                    dp[l][r] = (dp[l + 1][r - 1] * 2 + 2) % MOD\n                elif nl == pr:\n                    # exactly one inner same character\n                    dp[l][r] = (dp[l + 1][r - 1] * 2 + 1) % MOD\n                else:\n                    # more than one inner same character\n                    dp[l][r] = (dp[l + 1][r - 1] * 2 - dp[nl + 1][pr - 1]) % MOD\n                    if dp[l][r] < 0:\n                        dp[l][r] += MOD\n            else:\n                dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1]) % MOD\n                if dp[l][r] < 0:\n                    dp[l][r] += MOD\n\n    return dp[0][n - 1] % MOD\n\ndef parse_input(raw: str) -> str:\n    raw = raw.strip()\n    if raw.startswith(\"s =\"):\n        # extract string inside quotes\n        start = raw.find('\"')\n        end = raw.rfind('\"')\n        if start != -1 and end != -1 and end > start:\n            return raw[start + 1:end]\n    return raw\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = count_palindromic_subsequences(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '428469043'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '428469043'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode5.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Substring",
    "description_snippet": "Given a string s, return the longest palindromic substring in s....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line. The requirement: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows, decision structure. Must not output actual code, only steps. Provide steps for algorithm: find longest palindrome substring. We can choose center expansion approach or DP or Manacher. Provide virtual steps.\n\nWe'll produce something like:\n\nStart\n→ Step 1: 定義變數 maxStart = 0, maxLen = 0 // 初始最大子串起點及長度\n→ Step 2: 定義函式 ExpandAroundCenter(left, right) -> 返回該中心擴展得到的長度 // 用於擴展\n→ Decision: 如果 s 為空? // 檢查空字串\n    Yes → Step 3: 返回 \"\" // 空字串直接返回\n    No  → Decision: 循環 i from 0 to len(s)-1? // 迭代每個字符作為中心\n        Yes → Step 4: 長度1 = ExpandAroundCenter(i, i) // 奇數長度\n        → Step 5: 長度2 = ExpandAroundCenter(i, i+1) // 偶數長度\n        → Decision: 長度1 > maxLen? ...\nWe need to provide each step line. The code should not have actual code, just conceptual steps. We'll produce lines for each step, including decisions.\n\nWe need to ensure that every line ends with // explanation.\n\nMake sure we use Start, End. Use arrows →, decisions with Yes → and No →. Provide the steps for algorithm.\n\nWe might need a line for returning substring: Step final: Return s[maxStart:maxStart+maxLen] // 提取子串.\n\nLet's produce around maybe 15-20 lines.\n\nLet's proceed.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義變數 maxStart = 0, maxLen = 0 // 記錄目前最長回文子串的起點與長度\n→ Step 2: 定義函式 ExpandAroundCenter(left, right) → length // 從指定中心向兩側擴展，計算得到的回文長度\n→ Decision: 如果 s 為空字符串? // 檢查輸入是否為空\n    Yes → Step 3: 返回 \"\" // 空字符串直接回傳空\n    No  → Decision: 循環 i 從 0 到 len(s)-1? // 依次把每個字符作為中心\n        Yes → Step 4: len1 = ExpandAroundCenter(i, i) // 奇數長度回文擴展\n        → Step 5: len2 = ExpandAroundCenter(i, i+1) // 偶數長度回文擴展\n        → Decision: len1 > len2? // 比較兩種擴展得到的長度\n            Yes → Step 6: curLen = len1, curLeft = i - (len1-1)/2 // 取奇數擴展結果\n            No  → Step 6: curLen = len2, curLeft = i - (len2-1)/2 // 取偶數擴展結果\n        → Decision: curLen > maxLen? // 判斷是否更新目前最長回文\n            Yes → Step 7: maxLen = curLen, maxStart = curLeft // 更新最大長度與起點\n            No  → // 保持目前最大值不變\nEnd // 程式執行結束\n→ Step 8: 返回子串 s[maxStart : maxStart + maxLen] // 取出並回傳最長回文子串",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Return the longest palindromic substring in s.\n        \"\"\"\n        if not s:\n            return \"\"\n        max_start, max_len = 0, 0\n\n        def expand(left: int, right: int) -> int:\n            \"\"\"\n            Expand around the given center and return the length of the palindrome.\n            \"\"\"\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            # after the loop, left and right are one step beyond the palindrome\n            return right - left - 1\n\n        for i in range(len(s)):\n            # odd length palindrome centered at i\n            len1 = expand(i, i)\n            if len1 > max_len:\n                max_len = len1\n                max_start = i - (len1 - 1) // 2\n\n            # even length palindrome centered between i and i+1\n            len2 = expand(i, i + 1)\n            if len2 > max_len:\n                max_len = len2\n                max_start = i - (len2 - 1) // 2\n\n        return s[max_start:max_start + max_len]\n\ndef _parse_input(raw: str) -> str:\n    \"\"\"\n    Parse the input string to extract the actual string value.\n    Expected formats:\n        s = 'babad'\n        \"babad\"\n        'babad'\n    \"\"\"\n    raw = raw.strip()\n    # Look for a quoted string within the line\n    match = re.search(r\"['\\\"]([^'\\\"]+)['\\\"]\", raw)\n    if match:\n        return match.group(1)\n    # If no quotes found, return the stripped line as is\n    return raw\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read()\n    s = _parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.longestPalindrome(s)\n\n    # Print the result with quotes to match the sample output\n    print(repr(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "success": true,
          "output": "'bab'"
        },
        {
          "example_index": 1,
          "input": "s = 'cbbd'",
          "expected_output": "'bb'",
          "success": true,
          "output": "'bb'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode454.json",
    "problem_index_in_file": 0,
    "title": "4Sum II",
    "description_snippet": "Given four integer arrays A, B, C, and D all of length n, return the number of tuples (i, j, k, l) s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for solving the 4-sum zero count problem using hash map of pair sums. We need line-by-line with explanation. Use arrows and decisions. Should include Start, End. Should show loops, build sumAB map, loop CD, etc.\n\nWe need to output only virtual code lines, no actual code, only lines with \"→ Step: ... // explanation\". Use \"Start // ...\" at top, \"End // ...\" at bottom. Use decision blocks.\n\nWe need to produce a step-by-step algorithm. Use a hash map to count sums of A+B. Then for each pair C+D compute negative and look up count.\n\nAlso handle possible overflow? Not necessary.\n\nLet's produce lines:\n\nStart\n→ Step 1: Initialize empty hash map sumCount // 用於存儲 A[i]+B[j] 的頻率\n→ Step 2: For each element a in array A // 迭代 A\n    → Step 3: For each element b in array B // 迭代 B\n        → Step 4: Compute sumAB = a + b\n        → Step 5: Increment sumCount[sumAB] by 1 // 記錄這個和的出現次數\n→ Step 6: Initialize totalPairs = 0 // 用於累計符合條件的四元組數\n→ Step 7: For each element c in array C // 迭代 C\n    → Step 8: For each element d in array D // 迭代 D\n        → Step 9: Compute target = -(c + d)\n        → Decision: target exists in sumCount? // 檢查是否有對應的 A+B 和\n            Yes → Step 10: totalPairs += sumCount[target] // 加上對應次數\n            No  → Step 11: // 不做任何事，繼續\n→ End // 返回 totalPairs 作為答案\n\nBut we need to use Decision block formatting: \"Decision: ...?\" with Yes→ and No→ lines. Ensure arrow formatting as specified.\n\nAlso, we need to mention that the algorithm uses O(n^2) time and O(n^2) space.\n\nAlso include comments.\n\nLet's produce final output.\n\nMake sure each line ends with // 解釋. Use arrow arrow \"→\" before each step, decision uses \"Decision:\". The lines with nested arrows maybe need indentation? In sample, indentation uses spaces. We'll mimic.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 sumCount // 用於儲存 A[i] + B[j] 的頻率  \n→ Step 2: 對於每個 a ∈ A // 迭代陣列 A  \n    → Step 3: 對於每個 b ∈ B // 迭代陣列 B  \n        → Step 4: 計算 sumAB = a + b // 取得 A 和 B 的和  \n        → Step 5: sumCount[sumAB] += 1 // 記錄這個和的出現次數  \n→ Step 6: 初始化 totalPairs = 0 // 用於累加符合條件的四元組數  \n→ Step 7: 對於每個 c ∈ C // 迭代陣列 C  \n    → Step 8: 對於每個 d ∈ D // 迭代陣列 D  \n        → Step 9: 計算 target = -(c + d) // 需要的 A+B 和以使總和為 0  \n        → Decision: target 是否存在於 sumCount? // 檢查是否有對應的 A+B 和  \n            Yes → Step 10: totalPairs += sumCount[target] // 加上對應的出現次數  \n            No → Step 11: // 若不存在，則不做任何事，繼續迭代  \n→ End // 程式執行結束，totalPairs 為答案。",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef parse_array(var: str, text: str) -> list[int]:\n    \"\"\"\n    從整個輸入文字中提取變量 var 所對應的整數列表。\n    例如：var='A' 且 text 包含 \"A = [1,2]\" 時會返回 [1, 2]。\n    \"\"\"\n    pattern = rf'{var}\\s*=\\s*\\[([^\\]]*)\\]'\n    match = re.search(pattern, text)\n    if not match:\n        return []\n    inside = match.group(1)\n    # 抓取所有整數（正負號皆允許）\n    numbers = re.findall(r'-?\\d+', inside)\n    return [int(n) for n in numbers]\n\ndef four_sum_count(A: list[int], B: list[int], C: list[int], D: list[int]) -> int:\n    \"\"\"\n    計算四元組 (i, j, k, l) 滿足 A[i] + B[j] + C[k] + D[l] == 0 的個數。\n    \"\"\"\n    # A+B 的所有和以及出現次數\n    sum_ab = Counter(a + b for a in A for b in B)\n    total = 0\n    for c in C:\n        for d in D:\n            target = -(c + d)\n            total += sum_ab.get(target, 0)\n    return total\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析四個陣列\n    A = parse_array('A', data)\n    B = parse_array('B', data)\n    C = parse_array('C', data)\n    D = parse_array('D', data)\n\n    # 計算並輸出答案\n    result = four_sum_count(A, B, C, D)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "A = [0], B = [0], C = [0], D = [0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode50.json",
    "problem_index_in_file": 0,
    "title": "Pow(x, n)",
    "description_snippet": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n)....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants to implement pow(x, n) function in virtual code, step by step, no actual code, just pseudo with arrows. Provide lines: Start, step to compute pow, handle negative n? Usually implement exponentiation by squaring. They didn't specify constraints, but typical problem \"pow(x, n)\" from Leetcode. Use recursion or iterative. Provide steps: input x, n. If n==0 return 1. If n<0, compute 1/pow(x, -n). Else use exponentiation by squaring: if n%2==0 => pow(x, n/2)^2 else => x*pow(x, n-1). Provide iterative? We'll choose recursive. Provide virtual steps.\n\nMake sure each line includes \"→\" and comments.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 接收參數 x, n // 取得底數與指數\n\n→ Decision: n==0? // 檢查指數是否為 0\n\n    Yes → Step 2: 回傳 1 // x^0 = 1\n\n    No  → Decision: n<0? // 指數為負數時\n\n        Yes → Step 3: 計算 1 / pow(x, -n) // 先處理負數指數\n\n        No  → Decision: n 為偶數? // n 為偶數可用平方\n\n            Yes → Step 4: 先計算 half = pow(x, n/2) // 計算 x^(n/2)\n\n            → Step 5: 回傳 half * half // 再平方得到 x^n\n\n            No  → Step 6: 回傳 x * pow(x, n-1) // n 為奇數，拆成 x * x^(n-1)\n\nEnd // 程式結束\n\nBut we need to include arrow for recursive calls maybe? Might need to show recursion steps: Step 4 uses pow. We might show \"→ Call pow(x, n/2)\" but as step. Actually we want to express algorithm. Each line must be a step. The recursion can be represented by \"→ Step 4: half = pow(x, n/2) // 先計算 x^(n/2)\" which itself calls same procedure. But we can keep recursion implicit.\n\nWe must use \"→\" for arrows. Provide indentation for decisions. The example uses indentation with tabs or spaces? They used spaces: each nested Decision lines indented with 4 spaces maybe. We'll replicate.\n\nThus output lines with \"→\". For steps inside decisions, we indent accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收參數 x, n // 取得底數與指數  \n→ Decision: n==0? // 檢查指數是否為 0  \n Yes → Step 2: 回傳 1 // x^0 = 1  \n No  → Decision: n<0? // 指數為負數時  \n  Yes → Step 3: 計算 1 / pow(x, -n) // 先處理負數指數  \n  No  → Decision: n 為偶數? // n 為偶數可用平方  \n   Yes → Step 4: half = pow(x, n/2) // 計算 x^(n/2)  \n    → Step 5: 回傳 half * half // 再平方得到 x^n  \n   No  → Step 6: 回傳 x * pow(x, n-1) // n 為奇數，拆成 x * x^(n-1)  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef my_pow(x: float, n: int) -> float:\n    \"\"\"計算 x 的 n 次方，使用指數平方法（Exponentiation by Squaring）。\"\"\"\n    if n == 0:\n        return 1.0\n    # 先把負指數轉成正指數，並把底數取倒數\n    if n < 0:\n        x = 1.0 / x\n        n = -n\n\n    def fast_pow(base: float, exp: int) -> float:\n        if exp == 0:\n            return 1.0\n        half = fast_pow(base, exp // 2)\n        if exp % 2 == 0:\n            return half * half\n        else:\n            return half * half * base\n\n    return fast_pow(x, n)\n\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 x 與 n，計算並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 以正則表達式抓取所有數字（包含正負號與小數）\n    numbers = re.findall(r'[-+]?\\d*\\.?\\d+', data)\n    if len(numbers) < 2:\n        return\n\n    x = float(numbers[0])\n    n = int(float(numbers[1]))  # 把可能的 10.0 轉成 int\n\n    result = my_pow(x, n)\n    # 按題目要求輸出五位小數\n    print(f\"{result:.5f}\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 2.00000, n = 10",
          "expected_output": "1024.00000",
          "success": true,
          "output": "1024.00000"
        },
        {
          "example_index": 1,
          "input": "x = 2.10000, n = 3",
          "expected_output": "9.26100",
          "success": true,
          "output": "9.26100"
        },
        {
          "example_index": 2,
          "input": "x = 2.00000, n = -2",
          "expected_output": "0.25000",
          "success": true,
          "output": "0.25000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode8.json",
    "problem_index_in_file": 0,
    "title": "String to Integer (atoi)",
    "description_snippet": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe al...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps following format. For each line: virtual code step, space, // explanation. Use arrow \"→\", \"Yes →\", \"No →\", Decision blocks.\n\nImplement myAtoi algorithm.\n\nSteps:\n\nStart\n→ Step 1: Input s // get string\n→ Step 2: Initialize i = 0 // index\n→ Decision: skip leading whitespace\n   Yes → Step 3: while s[i] == ' ' → i++ // skip spaces\n   No → ...\nThen determine sign:\n→ Step 4: sign = 1 // default\n→ Decision: s[i] == '-' or '+'\n   Yes → If s[i] == '-' → sign = -1\n         i++ // skip sign\n   No → nothing\nThen parse digits:\n→ Step 5: result = 0\n→ Decision: i < len(s) and s[i] is digit\n   Yes → Step 6: while i < len(s) and s[i] is digit\n           digit = int(s[i])\n           result = result * 10 + digit\n           i++\n   No → ...\nThen apply sign:\n→ Step 7: result = sign * result\nRounding/clamping:\n→ Decision: result < INT_MIN\n   Yes → result = INT_MIN\n   No → Decision: result > INT_MAX\n       Yes → result = INT_MAX\n       No → ...\nReturn result\n\nNeed to include constants INT_MIN = -2^31, INT_MAX = 2^31-1\n\nInclude explanation comments.\n\nLet's write each line accordingly.\n\nUse Start and End markers.\n\nRemember each line: virtual code + space + // explanation\n\nAlso use Decision blocks.\n\nWe should use \"Decision:\" for conditions.\n\nFor loops, maybe \"Step 3: While s[i] == ' ' → i++\" but we might incorporate in decision.\n\nLet's draft.\n\nLine by line:\n\nStart // 程式開始執行\n→ Step 1: input s // 取得輸入字串\n→ Step 2: i = 0 // 初始化索引\n→ Decision: 是否有前導空白？ // 判斷是否存在空白字元\n    Yes → Step 3: While s[i] == ' ' → i++ // 跳過所有空白\n    No  → // 無空白，直接進行下一步\n→ Step 4: sign = 1 // 預設正號\n→ Decision: s[i] == '-' 或 '+'？ // 檢查符號\n    Yes → Decision: s[i] == '-'？ // 判斷是負號還是正號\n        Yes → sign = -1 // 設為負號\n        No  → sign = 1 // 正號\n        → i++ // 跳過符號字元\n    No  → // 無符號字元，保持正號\n→ Step 5: result = 0 // 初始化結果\n→ Decision: i < len(s) 且 s[i] 為數字？ // 是否有數字可讀\n    Yes → Step 6: While i < len(s) 且 s[i] 為數字 → // 讀取所有數字\n            digit = int(s[i]) // 取得數位\n            result = result * 10 + digit // 累加\n            i++ // 移動到下一位\n    No  → // 沒有數字，結果保持 0\n→ Step 7: result = sign * result // 加上符號\n→ Decision: result < INT_MIN？ // 檢查下界\n    Yes → result = INT_MIN // 取下界值\n    No  → Decision: result > INT_MAX？ // 檢查上界\n        Yes → result = INT_MAX // 取上界值\n        No  → // 在合法範圍內\n→ Step 8: return result // 回傳結果\nEnd // 程式執行結束\n\nWe should define INT_MIN, INT_MAX. Maybe include constants earlier.\n\nAdd Step 0: define constants.\n\nLet's adjust:\n\nStart\n→ Step 0: INT_MIN = -2^31 // 32位整數下界\n→ Step 1: INT_MAX = 2^31 - 1 // 上界\n...\n\nLet's craft final.\n\nMake sure each line ends with // explanation.\n\nCheck formatting.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: INT_MIN = -2^31 // 定義 32 位整數下界  \n→ Step 1: INT_MAX = 2^31 - 1 // 定義 32 位整數上界  \n→ Step 2: input s // 取得輸入字串  \n→ Step 3: i = 0 // 初始化索引  \n→ Decision: 是否有前導空白？ // 判斷字串前方是否有空白  \n Yes → Step 4: While s[i] == ' ' → i++ // 跳過所有空白字元  \n No  → // 無空白，直接進行下一步  \n→ Step 5: sign = 1 // 預設正號  \n→ Decision: s[i] == '-' 或 '+'？ // 檢查是否存在符號字元  \n Yes → Decision: s[i] == '-'？ // 判斷是負號還是正號  \n  Yes → sign = -1 // 設為負號  \n  No  → sign = 1 // 正號  \n  → i++ // 跳過符號字元  \n No  → // 無符號字元，保持正號  \n→ Step 6: result = 0 // 初始化結果  \n→ Decision: i < len(s) 且 s[i] 為數字？ // 是否有數字可讀  \n Yes → Step 7: While i < len(s) 且 s[i] 為數字 → // 讀取所有數字  \n   digit = int(s[i]) // 取得當前數位  \n   result = result * 10 + digit // 累加到結果  \n   i++ // 移動到下一個字符  \n No  → // 沒有數字，結果保持 0  \n→ Step 8: result = sign * result // 加上符號  \n→ Decision: result < INT_MIN？ // 檢查是否低於下界  \n Yes → result = INT_MIN // 取下界值  \n No  → Decision: result > INT_MAX？ // 檢查是否高於上界  \n  Yes → result = INT_MAX // 取上界值  \n  No  → // 在合法範圍內  \n→ Step 9: return result // 回傳最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Convert a string to a 32-bit signed integer following the specified rules.\n        \"\"\"\n        # 1. Remove leading whitespace\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        # 2. Determine sign\n        sign = 1\n        index = 0\n        if s[0] == '+':\n            index += 1\n        elif s[0] == '-':\n            sign = -1\n            index += 1\n\n        # 3. Convert digits to integer\n        result = 0\n        while index < len(s) and s[index].isdigit():\n            result = result * 10 + int(s[index])\n            index += 1\n\n        # 4. Apply sign\n        result *= sign\n\n        # 5. Clamp to 32-bit signed integer range\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n\n        return result\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read()\n\n    # Try to extract the string inside quotes (e.g., s = \"42\")\n    match = re.search(r'\"(.*?)\"', raw_input)\n    if match:\n        input_str = match.group(1)\n    else:\n        # Fallback: treat the whole trimmed input as the string\n        input_str = raw_input.strip()\n\n    solver = Solution()\n    output = solver.myAtoi(input_str)\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"42\"",
          "expected_output": "42",
          "success": true,
          "output": "42"
        },
        {
          "example_index": 1,
          "input": "s = \" -042\"",
          "expected_output": "-42",
          "success": true,
          "output": "-42"
        },
        {
          "example_index": 2,
          "input": "s = \"1337c0d3\"",
          "expected_output": "1337",
          "success": true,
          "output": "1337"
        },
        {
          "example_index": 3,
          "input": "s = \"0-1\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 4,
          "input": "s = \"words and 987\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode151.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String",
    "description_snippet": "Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-spa...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Need to implement reverse words. Steps: trim spaces, split by spaces, filter empties, reverse, join with space. Use virtual steps. Each line with explanation. Use Start, Decision etc. Use arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者處取得待處理字串  \n→ Step 2: s = s.trim() // 移除首尾空白  \n→ Step 3: words = s.split(' ') // 以空格分割字串，產生單字列表  \n→ Decision: 若 words 中存在空字串? // 檢查是否因連續空格產生空元素  \n    Yes → Step 4: words = words.filter(word → word.length > 0) // 刪除所有空元素  \n    No  → No Operation // 若無空元素則保持原樣  \n→ Step 5: words = words.reverse() // 反轉單字順序  \n→ Step 6: result = words.join(' ') // 用單一空格連接單字，形成結果字串  \n→ Step 7: 輸出 result // 回傳最終字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"\n        把字串裡的單字反轉順序，並以單一空白連結。\n        \"\"\"\n        # 先移除前後空白，使用 split() 會自動忽略連續空格\n        words = s.strip().split()\n        # 反轉單字順序\n        words.reverse()\n        # 用單一空格重新連結\n        return ' '.join(words)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    解析 stdin 的內容，取得真正的字串資料。\n    支援 's = \"hello world\"' 以及單純的字串輸入。\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        # 取等號右側作為字串\n        _, val = raw.split('=', 1)\n        val = val.strip()\n    else:\n        val = raw\n    # 若字串被單/雙引號包住，去除引號\n    if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):\n        val = val[1:-1]\n    return val\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    s = parse_input(raw_input)\n    sol = Solution()\n    reversed_str = sol.reverseWords(s)\n    # 按範例輸出，結果用雙引號包住\n    print(f'\"{reversed_str}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"the sky is blue\"",
          "expected_output": "\"blue is sky the\"",
          "success": true,
          "output": "\"blue is sky the\""
        },
        {
          "example_index": 1,
          "input": "s = \"  hello world  \"",
          "expected_output": "\"world hello\"",
          "success": true,
          "output": "\"world hello\""
        },
        {
          "example_index": 2,
          "input": "s = \"a good   example\"",
          "expected_output": "\"example good a\"",
          "success": true,
          "output": "\"example good a\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode27.json",
    "problem_index_in_file": 0,
    "title": "Remove Element",
    "description_snippet": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines. The task is to remove elements equal to val from array in-place and return k. Use two-pointer technique. Provide step-by-step virtual code.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 index 0 // start pointer\n→ Step 2: 迭代遍歷 array 直到 end // for each element\n    → Decision: 當元素不等於 val? // if not equal\n        Yes → Step 3: 把該元素放到 nums[index] // assign\n                → Step 4: index +=1 // move index\n        No → Step 5: 跳過 // do nothing\n→ Step 6: k = index // k is number of kept elements\n→ Step 7: 返回 k // return\nEnd\n\nAdd explanatory comments. Use arrow syntax.\n\nMake sure each line has \"虛擬碼步驟\" and comment. Use spaces accordingly. Use arrow \"→\". Let's craft.\n\nAlso include Decision block indentation. Provide each decision branch as separate line. Use correct indentation? In example, they indent under Decision with a tab? They used four spaces indent? They used two spaces maybe. We'll replicate style: indent Decision with a tab or spaces. We'll just use 4 spaces indent. Use \"Decision:\" line and then branches.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 index = 0 // 用於紀錄不等於 val 的元素位置  \n→ Step 2: 迭代遍歷 nums 直到索引 i < nums.length // 對每個元素進行檢查  \n    → Decision: 如果 nums[i] 不等於 val? // 判斷是否需要保留  \n        Yes → Step 3: 把 nums[i] 存到 nums[index] // 將符合條件的元素搬到前面  \n            → Step 4: index += 1 // index 前進，準備放下下一個符合條件的元素  \n        No  → Step 5: 跳過 // 符合 val 的元素不處理，直接跳到下一個  \n→ Step 6: k = index // index 現在就是保留元素的個數  \n→ Step 7: 返回 k // 回傳結果給呼叫者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef remove_element(nums, val):\n    \"\"\"移除 nums 中所有等於 val 的元素，並回傳剩餘元素個數 k。\"\"\"\n    slow = 0\n    for fast in range(len(nums)):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n    return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入字串\n    nums_match = re.search(r'nums\\s*=\\s*\\[(.*?)\\]', data, re.S)\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not val_match:\n        return\n\n    nums_str = nums_match.group(1)\n    # 把逗號分隔的數字轉成整數列表\n    nums = [int(x) for x in nums_str.split(',') if x.strip() != '']\n    val = int(val_match.group(1))\n\n    # 執行移除操作\n    k = remove_element(nums, val)\n\n    # 建立輸出字串\n    elements = [str(nums[i]) for i in range(k)] + ['_'] * (len(nums) - k)\n    output = f\"{k}, nums = [{','.join(elements)}]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "success": true,
          "output": "2, nums = [2,2,_,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "success": true,
          "output": "5, nums = [0,1,3,0,4,_,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode357.json",
    "problem_index_in_file": 0,
    "title": "Count Numbers with Unique Digits",
    "description_snippet": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code steps explaining algorithm to count numbers with unique digits less than 10^n. This is classic LeetCode 357 Unique Digit. Approach: Use combinatorics. Count numbers with unique digits of length 0 to n. For n=0, return 1 (just zero). For n>0, count numbers of length 1: 10 (0-9). For length k>1: 9 * 9P(k-1). Sum.\n\nWe produce pseudocode step-by-step with decisions.\n\nWe must output each line with virtual code step and comment. Use arrow syntax. Provide Start, End, Decision. We should include loops? For combinatorial approach: maybe use loop for length from 1 to n.\n\nWe'll produce lines:\n\nStart\n→ Step 1: Input integer n // read n\n→ Decision: If n == 0? // check base case\n    Yes → Step 2: Return 1 // only number 0\n    No  → Step 3: Initialize count = 1 // include zero\n        → Step 4: If n >= 1: count += 10 // one-digit numbers\n        → Step 5: Initialize available = 9 // remaining digits for first position of multi-digit numbers\n        → Step 6: For len from 2 to n: // iterate lengths\n            → Step 7: available -= 1 // reduce available digits\n            → Step 8: count += 9 * product(available) // but product? We'll accumulate product\nBetter: Use variable mult = 9, for len=2: mult = mult * (9) * (available)? Actually we need to compute number of unique-digit numbers of length len: 9 * P(9, len-1). We can iteratively compute mult. Starting mult = 9 for len=1. For each len from 2 to n: mult = mult * (10 - len) maybe? Let's think:\n\nFor len=1: numbers = 10. For len>=2: count = 9 * 9 * 8 * ... * (10-len). Implementation: start mult = 9; for len=2 to n: mult = mult * (10 - len); count += mult.\n\nSimpler: Use variable mult = 9; for len=2 to n: mult = mult * (10 - len); count += mult.\n\nAdd Step 9: Return count.\n\nWe must use arrow and decision.\n\nLet's craft.\n\nWe may need a Decision to loop: For len from 2 to n: but that's a loop, not decision.\n\nWe can use arrow for loop: → Loop: for len = 2 to n // iterating lengths\n    → Step ... etc.\n\nBut the format only allowed arrow, Decision: etc. But we can still use arrow for loop lines.\n\nLet's produce:\n\nStart\n→ Step 1: Read integer n //取得輸入的整數\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Step 2: Return 1 // 只有數字 0\n    No  → Step 3: Set count = 1 // 包含 0\n        → Step 4: If n >= 1: count += 10 // 一位數\n        → Step 5: Set mult = 9 // 初始多位數的第一位選擇\n        → Loop: len = 2 to n // 依序處理 2 位以上\n            → Step 6: mult = mult * (10 - len) // 乘上剩餘可用位數\n            → Step 7: count += mult // 累加此長度的數量\n        → Step 8: Return count // 回傳總數\n\nEnd\n\nWe need to be careful: In Step 5: set mult = 9. But the algorithm for length 2: mult = mult * (10 - 2) = 9 * 8 = 72? Wait for len=2, mult should be 9*9=81. Actually the product formula: For length 2, numbers = 9 * 9 = 81. Our approach: mult starts as 9? For len=2: mult = mult * (10 - len) = 9 * 8 = 72, wrong. So need correct iterative formula: start mult = 9; for len=2: mult = mult * 9 (since we can use any of 9 digits for second position). That suggests mult = mult * (10 - (len-1))? For len=2: 10 - 1 = 9; for len=3: 10 - 2 = 8; So formula: mult = mult * (10 - (len-1)). Let's compute: len=2: mult=9*9=81; len=3: mult=81*8=648; good.\n\nSo Step 6: mult = mult * (10 - (len - 1)). Then Step 7: count += mult.\n\nLet's adjust.\n\nAlso Step 4: if n>=1: count +=10 includes one-digit numbers, but we already set count=1 for zero. So total count after step 4 is 11 if n>=1? Actually we want 10 one-digit numbers including 0? Wait we already counted zero in count=1. One-digit numbers (including 0) are 10 numbers. So count should be 10 after adding one-digit numbers? Actually we want to count numbers from 0 to 10^n - 1 with unique digits. For n>=1, the numbers include 0-9 as well. So count should be 10. But we set count=1, then add 10 -> 11. That's wrong. We should set count = 0 initially, then add 1 for zero separately? Or we could just set count=1, then add 9 for one-digit numbers excluding 0? Let's do: count=1 (zero), then if n>=1: count += 9 (digits 1-9). That's better. Because we counted zero already. So Step 4: count += 9.\n\nAlternatively we can count all one-digit numbers including zero as 10, but then we don't need the separate zero. Let's do: count=1 (zero). Then for n>=1: count += 9. That yields 10 total.\n\nSo we adjust: Step 4: count += 9 // add digits 1-9\n\nNow mult starts at 9 for first digit? For length 2, we have 9 (choices for first digit 1-9) times 9 (remaining digits 0-9 excluding first). So mult should be 9*9=81. Starting mult=9. For len=2: mult = mult * 9 -> 81. For len=3: mult = 81 * 8 = 648. So Step 6: mult = mult * (10 - (len - 1)). That's correct.\n\nSo Step 5: mult = 9 // choices for first digit when length >=2.\n\nNow produce final pseudocode.\n\nAlso we need to ensure we handle n>=1 condition: If n>=1, we add one-digit numbers.\n\nEdge case: n==0: return 1.\n\nWe also need to ensure that loop runs only if n>=2, but we can loop for len=2 to n and if n<2, loop will not run.\n\nThus final pseudocode lines:\n\nStart\n→ Step 1: Read integer n // 取得輸入的整數\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Step 2: Return 1 // 只有數字 0\n    No  → Step 3: Set count = 1 // 包含 0\n        → Step 4: If n >= 1: count += 9 // 加上 1~9 的一位數\n        → Step 5: Set mult = 9 // 第一位數字的選擇（1~9）\n        → Loop: len = 2 to n // 處理 2 位以上的數字\n            → Step 6: mult = mult * (10 - (len - 1)) // 乘上剩餘可用位數\n            → Step 7: count += mult // 累加此長度的數量\n        → Step 8: Return count // 回傳總數\nEnd\n\nCheck explanation: In step 6, for len=2: mult = 9 * (10 - 1) = 9*9=81; for len=3: mult = 81 * (10 - 2) = 81*8=648; etc.\n\nNow ensure format: Each line includes virtual code step + space + comment.\n\nUse arrow '→'. Use 'Decision: ...' with nested Yes / No.\n\nUse 'Loop: ...' to denote loop.\n\nWe should also indent inside decisions and loop? In sample, they indent with spaces. We can indent using spaces.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Read integer n // 取得使用者輸入的整數 n\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Step 2: Return 1 // 只有數字 0，回傳 1\n    No  → Step 3: Set count = 1 // 初始化計數，已包含 0\n        → Step 4: If n >= 1: count += 9 // 加上 1~9 的一位數，共 9 個\n        → Step 5: Set mult = 9 // 兩位以上時第一位可選 1~9，共 9 種\n        → Loop: len = 2 to n // 處理 2 位以上的數字長度\n            → Step 6: mult = mult * (10 - (len - 1)) // 乘上剩餘可用位數\n            → Step 7: count += mult // 累加此長度的唯一數字個數\n        → Step 8: Return count // 回傳總計數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef countNumbersWithUniqueDigits(n: int) -> int:\n    \"\"\"Return the number of unique‑digit numbers less than 10^n.\"\"\"\n    if n == 0:\n        return 1                      # only the number 0\n    n = min(n, 10)                     # beyond 10 digits repetition is unavoidable\n    result = 10                        # 0–9\n    unique = 9                         # first digit options for multi‑digit numbers\n    available = 9                      # remaining digits available for subsequent positions\n    for _ in range(2, n + 1):\n        unique *= available\n        result += unique\n        available -= 1\n    return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r'\\d+', data)\n    if not match:\n        sys.exit(0)\n    n = int(match.group())\n    print(countNumbersWithUniqueDigits(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "success": true,
          "output": "91"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode392.json",
    "problem_index_in_file": 0,
    "title": "Is Subsequence",
    "description_snippet": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\nA subsequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line. The task: given two strings s and t, return true if s is a subsequence of t.\n\nSo we need steps: Start, Step 1: initialize pointers i, j. Step 2: while loop i < len(s) and j < len(t). Inside loop check char match. If match increment i. Always increment j. After loop, if i == len(s) return true else false. End.\n\nWe need each line with virtual code step + space + // explanation. Use arrow notation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: i ← 0, j ← 0 // 初始化 s 與 t 的指標\n→ Decision: 是否已檢查完 s? // 檢查是否已經比對完 s\n    No → Step 2: j < len(t)? // 若未完成，檢查 t 是否還有字元\n        Yes → Step 3: s[i] == t[j]? // 比對兩個字元\n            Yes → i ← i + 1 // 若相同，前進 s 的指標\n            No → // 不變動 i\n        → j ← j + 1 // 無論是否相同，前進 t 的指標\n        → Go back to Decision: 是否已檢查完 s?\n        No → Step 4: Return false // t 已結束，但 s 未比對完，返回 false\n    Yes → Step 5: Return true // s 已比對完，返回 true\nEnd // 程式執行結束\n\nNeed to format lines as \"虛擬碼步驟 // 解釋\". Use arrows. Provide each line accordingly.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0, j ← 0 // 初始化 s 與 t 的指標  \n→ Decision: 是否已檢查完 s? // 檢查是否已經比對完 s  \n No → Step 2: j < len(t)? // 若未完成，檢查 t 是否還有字元  \n  Yes → Step 3: s[i] == t[j]? // 比對 s 的字元與 t 的字元  \n   Yes → i ← i + 1 // 若相同，前進 s 的指標  \n   No → // i 不變，繼續比對  \n  → j ← j + 1 // 無論是否相同，前進 t 的指標  \n  → Go back to Decision: 是否已檢查完 s? // 重新檢查 s 是否完成  \n  No → Step 4: Return false // t 已結束，但 s 未比對完，返回 false  \n Yes → Step 5: Return true // s 已比對完，返回 true  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        # 若 s 為空字串，直接回傳 True\n        if not s:\n            return True\n        index_s = 0\n        for char in t:\n            if char == s[index_s]:\n                index_s += 1\n                if index_s == len(s):\n                    return True\n        return False\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中抽取 s 與 t 的值。\n    允許輸入格式為：s = \"abc\", t = \"ahbgdc\"\n    \"\"\"\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', text)\n    t_match = re.search(r't\\s*=\\s*\"([^\"]*)\"', text)\n    s = s_match.group(1) if s_match else \"\"\n    t = t_match.group(1) if t_match else \"\"\n    return s, t\n\ndef main():\n    data = sys.stdin.read()\n    s, t = parse_input(data)\n    result = Solution().isSubsequence(s, t)\n    # 按題目要求輸出小寫字串\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\", t = \"ahbgdc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"axc\", t = \"ahbgdc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode91.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways",
    "description_snippet": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for decoding count. Standard DP: count[i] ways to decode suffix starting at i or prefix. We'll use DP from end. Steps: Start, check s empty? If empty return 0? Actually empty string maybe 0 ways? Usually 1 for empty, but we can set 1. We'll iterate from len-1 to 0. For each i, if s[i]=='0' skip (dp[i]=0). else dp[i]=dp[i+1]. if i+1 < n and 10 <= int(s[i:i+2]) <= 26 then dp[i] += dp[i+2]. Finally return dp[0]. Need handle out of bounds. Also handle impossible: if dp[0]==0 return 0.\n\nWe'll produce pseudo lines.\n\nLet's craft.\n\nUse variables: n, dp array length n+1, dp[n]=1 (empty string). For i from n-1 down to 0.\n\nEdge: if s[i]=='0' set dp[i]=0 else dp[i]=dp[i+1] then if i+1<n and int(s[i:i+2]) <=26 and >=10 then dp[i] += dp[i+2].\n\nReturn dp[0].\n\nAlso if entire string cannot decode return 0.\n\nNow produce lines following format.\n\nWe must use \"Start\", \"End\", \"Decision:\" etc.\n\nLet's structure:\n\nStart // start\n\n→ Step 1: n ← length of s // 取得字串長度\n\n→ Decision: 如果 n == 0? // 檢查是否為空字串\n\n    Yes → Step 2: return 0 // 空字串視為無法解碼\n\n    No  → Step 3: 初始化 dp 陣列大小 n+1 // dp[n] = 1\n\n→ Step 4: dp[n] ← 1 // 空字串有一種解碼方式\n\n→ Step 5: i ← n-1 // 從最後一個字符開始迴圈\n\n→ Decision: 迴圈 i >= 0? // 逐位檢查\n\n    Yes → Step 6: 如果 s[i] == '0'? // '0' 不能單獨解碼\n\n            Yes → Step 7: dp[i] ← 0 // 這個位置無解碼方式\n\n            No  → Step 8: dp[i] ← dp[i+1] // 至少可以使用單字元\n\n            → Decision: 如果 i+1 < n 且 10 <= int(s[i:i+2]) <= 26? // 二位數合法\n\n                Yes → Step 9: dp[i] ← dp[i] + dp[i+2] // 加上兩位數解碼方式\n\n                No  → // 不做任何變動\n\n    No  → // 迴圈結束\n\n→ Step 10: 結果 ← dp[0] // 最終解碼方式數\n\n→ Decision: 如果 結果 == 0? // 無法解碼\n\n    Yes → Step 11: return 0\n\n    No  → Step 12: return 結果\n\nEnd // 程式結束\n\nMake sure each line includes virtual code then // explanation.\n\nWe must use arrow for steps, decisions. Indentation: maybe use spaces.\n\nLet's format. Use \"Start\" etc. Each line must be \"虛擬碼步驟 [space] // 解釋\". Use \"→\" for steps, \"Decision:\" for decisions. For nested decisions we can indent.\n\nWe can add indentation with spaces or tabs. Provide each line. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(s) // 取得字串長度  \n→ Decision: n == 0? // 檢查是否為空字串  \n Yes → Step 2: return 0 // 空字串視為無法解碼  \n No  → Step 3: dp ← new array of size n+1 // 建立 DP 陣列  \n→ Step 4: dp[n] ← 1 // 空字串有一種解碼方式  \n→ Step 5: i ← n-1 // 從最後一個字符開始迴圈  \n→ Decision: i ≥ 0? // 逐位檢查是否還有字符  \n Yes → Step 6: if s[i] == '0'? // '0' 不能單獨解碼  \n  Yes → Step 7: dp[i] ← 0 // 這個位置無解碼方式  \n  No  → Step 8: dp[i] ← dp[i+1] // 至少可以使用單字元  \n  → Decision: i+1 < n AND 10 ≤ int(s[i:i+2]) ≤ 26? // 二位數是否合法  \n   Yes → Step 9: dp[i] ← dp[i] + dp[i+2] // 加上兩位數解碼方式  \n   No  → // 不做任何變動  \n No  → // 迴圈結束  \n→ Step 10: result ← dp[0] // 最終解碼方式數  \n→ Decision: result == 0? // 無法解碼  \n Yes → Step 11: return 0 // 回傳 0  \n No  → Step 12: return result // 回傳計算出的數量  \nEnd // 程式結束執行",
      "generated_code": "import sys\n\ndef num_decodings(s: str) -> int:\n    \"\"\"\n    Count the number of ways to decode the numeric string `s` according to\n    the mapping 1->A, 2->B, ..., 26->Z.\n    \"\"\"\n    if not s or s[0] == '0':\n        # Empty string or leading zero cannot be decoded.\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[n] = 1  # Base case: empty suffix has one decoding\n\n    # Iterate from the end of the string towards the start\n    for i in range(n - 1, -1, -1):\n        if s[i] == '0':\n            dp[i] = 0  # '0' cannot be decoded alone\n        else:\n            dp[i] = dp[i + 1]  # At least the single-digit option\n\n            # Check two-digit decoding if it stays within bounds\n            if i + 1 < n:\n                two_digit = int(s[i:i + 2])\n                if 10 <= two_digit <= 26:\n                    dp[i] += dp[i + 2]\n\n    return dp[0] if dp[0] != 0 else 0\n\n\nif __name__ == \"__main__\":\n    # Read all input and extract digits\n    raw_input = sys.stdin.read()\n    digits = ''.join(ch for ch in raw_input if ch.isdigit())\n\n    # Compute and print the result\n    result = num_decodings(digits)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"12\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"226\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"06\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode649.json",
    "problem_index_in_file": 0,
    "title": "Dota2 Senate",
    "description_snippet": "In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code algorithm to determine which party wins. Problem known as \"Dota2 Senate\" similar to Leetcode 804. Approach: use queues of indices or counts. We'll produce algorithm lines with virtual code steps.\n\nWe need to respond with lines like \"Start // ...\" etc. The algorithm: maintain two queues: radiant indices, dire indices. While both not empty: pop front of each. Compare indices: the one with smaller index bans the other, pushes back with index + n. Return winner.\n\nWe'll write in steps.\n\nWe must provide virtual code lines with explanation after //.\n\nMake sure each line has virtual code step, then space, then // explanation.\n\nWe need to start with Start, End. Use arrows.\n\nLet's craft.\n\nLine1: Start // 程式開始\n\nLine2: → Initialize n = length of senate // 取得議員總數\n\nLine3: → Initialize queueR = empty // Radiant 索引隊列\n\nLine4: → Initialize queueD = empty // Dire 索引隊列\n\nLine5: → For i from 0 to n-1 // 逐一遍歷議員\n\nLine6:     → If senate[i] == 'R' → Append i to queueR // Radiant 的索引加入隊列\n\nLine7:     → Else → Append i to queueD // Dire 的索引加入隊列\n\nLine8: → While queueR not empty AND queueD not empty // 只要兩方都有剩餘\n\nLine9:     → r = queueR.dequeue() // 取 Radiant 最前者\n\nLine10:    → d = queueD.dequeue() // 取 Dire 最前者\n\nLine11:    → If r < d // Radiant 先行\n\nLine12:        Yes → Append r + n to queueR // Radiant 再次參與下一輪\n\nLine13:        No  → Append d + n to queueD // Dire 再次參與下一輪\n\nLine14: → Decision: queueR empty? // 檢查誰被消滅\n\nLine15:     Yes → End // Radiant 失敗, Dire 贏\n\nLine16:     No  → End // Radiant 存活, Radiant 贏\n\nBut need to output winner string, so we need to output \"Radiant\" or \"Dire\". We'll add step after while loop to output result.\n\nLet's adjust.\n\nLine14: → Decision: queueR empty? // 判斷 Radiant 是否被消滅\n\nLine15:     Yes → Output 'Dire' // Dire 勝利\n\nLine16:     No  → Output 'Radiant' // Radiant 勝利\n\nEnd // 程式結束\n\nMake sure arrow lines indent etc. Provide \"→\" lines. Use \"Yes →\" and \"No →\".\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始  \n→ Initialize n = length of senate // 取得議員總數  \n→ Initialize queueR = empty // Radiant 的索引隊列  \n→ Initialize queueD = empty // Dire 的索引隊列  \n→ For i from 0 to n-1 // 逐一遍歷議員  \n → If senate[i] == 'R' → Append i to queueR // Radiant 的索引加入隊列  \n → Else → Append i to queueD // Dire 的索引加入隊列  \n→ While queueR not empty AND queueD not empty // 只要兩方都有剩餘  \n → r = queueR.dequeue() // 取 Radiant 最前者  \n → d = queueD.dequeue() // 取 Dire 最前者  \n → If r < d // Radiant 先行  \n  Yes → Append r + n to queueR // Radiant 再次參與下一輪  \n  No  → Append d + n to queueD // Dire 再次參與下一輪  \n→ Decision: queueR empty? // 判斷 Radiant 是否被消滅  \n Yes → Output 'Dire' // Dire 勝利  \n No  → Output 'Radiant' // Radiant 勝利  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def predictPartyVictory(self, senate: str) -> str:\n        n = len(senate)\n        radiant = deque()\n        dire = deque()\n\n        for i, s in enumerate(senate):\n            if s == 'R':\n                radiant.append(i)\n            else:\n                dire.append(i)\n\n        while radiant and dire:\n            r_index = radiant.popleft()\n            d_index = dire.popleft()\n            if r_index < d_index:\n                radiant.append(r_index + n)\n            else:\n                dire.append(d_index + n)\n\n        return \"Radiant\" if radiant else \"Dire\"\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract the senate string between quotes (handles both \"...\" and '...')\n    match = re.search(r'\"(.*?)\"|\\'(.*?)\\'', data)\n    if match:\n        senate_str = match.group(1) if match.group(1) is not None else match.group(2)\n    else:\n        # Fallback: if no quotes, assume the whole input is the string\n        senate_str = data\n\n    solver = Solution()\n    result = solver.predictPartyVictory(senate_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "senate = \"RD\"",
          "expected_output": "\"Radiant\"",
          "success": true,
          "output": "Radiant"
        },
        {
          "example_index": 1,
          "input": "senate = \"RDD\"",
          "expected_output": "\"Dire\"",
          "success": true,
          "output": "Dire"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode523.json",
    "problem_index_in_file": 0,
    "title": "Continuous Subarray Sum",
    "description_snippet": "Given an integer array nums and an integer k, return true if nums has a good subarray or false other...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code, line by line, with explanation comments. Virtual code should not be real code, but structure with arrows. Must follow format: each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use Start, End, Decision, etc.\n\nWe need algorithm to determine if there exists subarray of length >=2 with sum % k == 0.\n\nWe can use prefix sums and hash map of remainder to earliest index. Standard approach.\n\nPseudo:\n\nStart\n→ Step 1: 初始化哈希表 remainderIndex，键是余数，值是最早出现该余数的索引；先放入 (0, -1) // 余数0在虚拟起始位置\n→ Step 2: 初始化 prefixSum = 0\n→ For i from 0 to n-1:\n    → Step 3: prefixSum += nums[i]\n    → Step 4: if k != 0: remainder = prefixSum % k else remainder = prefixSum\n    → Decision: remainder 是否在 remainderIndex? \n        Yes → Step 5: earliest = remainderIndex[remainder]\n            → Decision: i - earliest >= 2?\n                Yes → Step 6: return true // 找到满足条件的子数组\n                No → Step 7: // 继续循环\n        No → Step 8: remainderIndex[remainder] = i // 记录首次出现\n→ Step 9: return false // 未找到\nEnd\n\nWe need to include explanation after each line. Use arrow \"→\". For loops we can use \"For\" line. For decisions we indent with Yes → and No →. Use the formatting example.\n\nWe need to maintain virtual code style: \"Start // 程式開始執行\". Then lines like \"→ Step 1: ...\" etc.\n\nWe need to ensure each line has space between code and comment. Use \" // \" then explanation.\n\nLet's produce.\n\nAlso mention that we treat 0 as multiple of k automatically.\n\nWe should handle k=0 separately: if k==0, we need subarray sum ==0. So remainder logic still works but modulo by zero not allowed. Use condition.\n\nWe'll keep code simple.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的雜湊表 remainderIndex，並將 (0, -1) 放入 // 代表餘數0在起始位置之前，方便計算長度 ≥ 2 的子陣列  \n→ Step 2: 設定 prefixSum = 0 // 用來累加前綴和  \n→ Step 3: For i in 0 .. nums.length - 1: // 逐一遍歷陣列元素  \n  → Step 4: prefixSum += nums[i] // 加入當前元素  \n  → Step 5: 若 k ≠ 0: remainder = prefixSum % k 否則 remainder = prefixSum // 取餘數，k=0 時直接用前綴和  \n  → Decision: remainder 是否已存在於 remainderIndex? // 檢查此餘數之前是否有相同值  \n   Yes → Step 6: earliestIndex = remainderIndex[remainder] // 取第一次出現此餘數的索引  \n    Decision: i - earliestIndex ≥ 2? // 子陣列長度是否至少為 2  \n     Yes → Step 7: Return true // 找到符合條件的子陣列，結束程式  \n     No → Step 8: // 這個子陣列長度不足，繼續下一個迭代  \n   No → Step 9: remainderIndex[remainder] = i // 若此餘數第一次出現，記錄索引  \n→ Step 10: Return false // 迴圈結束仍未找到，回傳 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkSubarraySum(self, nums, k):\n        \"\"\"\n        Return True if there exists a subarray of length at least 2\n        whose sum is a multiple of k.\n        \"\"\"\n        mod_map = {0: -1}          # remainder -> earliest index\n        total = 0\n        for i, num in enumerate(nums):\n            total += num\n            if k != 0:\n                total %= k\n            if total in mod_map:\n                if i - mod_map[total] > 1:\n                    return True\n            else:\n                mod_map[total] = i\n        return False\n\ndef main():\n    \"\"\"\n    Reads input from stdin in the format:\n        [a1,a2,...,an], k\n    Prints 'true' or 'false' according to the result.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split on the last comma to separate the list and the integer k\n    parts = data.rsplit(',', 1)\n    if len(parts) != 2:\n        raise ValueError(\"Input must contain a list and an integer k separated by a comma.\")\n    nums_str, k_str = parts[0].strip(), parts[1].strip()\n    nums = ast.literal_eval(nums_str)   # safely evaluate the list string\n    k = int(k_str)\n    sol = Solution()\n    result = sol.checkSubarraySum(nums, k)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[23,2,4,6,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "[23,2,6,4,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "[23,2,6,4,7], 13",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode41.json",
    "problem_index_in_file": 0,
    "title": "First Missing Positive",
    "description_snippet": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find smallest missing positive in unsorted array, O(n) time, O(1) space. Standard approach: index placement. Steps: first separate positives? Approach: use index mapping: for each num, while 1 <= num <= n and arr[num-1] != num, swap. Then find first index i where arr[i] != i+1. Return i+1 else n+1.\n\nWe output each line with arrow, decision, etc.\n\nNeed step by step.\n\nStart\n→ Step 1: Let n = length of nums // get array size\n→ Step 2: For i from 0 to n-1: // iterate each element\n    → Decision: If nums[i] <= 0 or nums[i] > n? // ignore numbers out of range\n        Yes → Continue to next i // skip\n        No  → While nums[i] != i+1 and nums[nums[i]-1] != nums[i] // correct position\n            → Step 3: Swap nums[i] and nums[nums[i]-1] // place number at correct index\n            → Continue loop // repeat until no change\n\nAfter loop, iterate again:\n→ Step 4: For i from 0 to n-1:\n    → Decision: If nums[i] != i+1? // find missing\n        Yes → Return i+1 // first missing positive\n        No  → Continue\n\nIf none found:\n→ Step 5: Return n+1 // all numbers 1..n present\n\nEnd.\n\nNeed to include arrows for decisions. Use `Yes →` and `No →`. Use indentation for nested.\n\nAlso we need to note that the loop \"while\" could be represented as Decision and nested steps.\n\nWe must not output actual code. Just virtual steps.\n\nLet's produce each line accordingly.\n\nWe should start with `Start`. Then `→ Step 1`. Then inside for loop we use Decision.\n\nWe need to show for loops maybe as step? Represent as Step 2: For each index i from 0 to n-1 // iterate array\n\nInside loop: Decision if out of range? etc.\n\nFor the while, we can use Decision: While condition? but we might use loop arrow.\n\nSimplify: Use Step 2: Iterate each element, reposition valid numbers.\n\nWe might express as:\n\n→ Step 2: For i from 0 to n-1 // iterate indices\n    → Decision: nums[i] <= 0 or nums[i] > n? // out of usable range\n        Yes → Continue // skip this element\n        No  → Step 3: While nums[i] != i+1 and nums[nums[i]-1] != nums[i] // proper position check\n            → Step 4: Swap nums[i] and nums[nums[i]-1] // place value correctly\n            → Continue while // repeat\n\nAfter loop, Step 5: For i from 0 to n-1 // find missing\n    → Decision: nums[i] != i+1?\n        Yes → Return i+1 // found missing\n        No  → Continue\n\nStep 6: Return n+1 // all present\n\nEnd.\n\nLet's craft.\n\nWe need to include explanation comment after each line.\n\nAlso include arrow '→' before step statements. Use `Decision:` lines with indentation.\n\nWe need to maintain line by line.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = length(nums) // 取得陣列長度  \n→ Step 2: For i from 0 to n-1 // 逐一檢查每個元素  \n  Decision: nums[i] <= 0 or nums[i] > n? // 此數值不在可使用範圍內  \n   Yes → Continue // 跳過此元素  \n   No  → Step 3: While nums[i] != i+1 and nums[nums[i]-1] != nums[i] // 仍未正確放置  \n    Step 4: Swap nums[i] and nums[nums[i]-1] // 把數值放到正確索引位置  \n    Continue // 重新檢查條件，直至滿足  \n→ Step 5: For i from 0 to n-1 // 再次遍歷尋找缺失正數  \n  Decision: nums[i] != i+1? // 找到第一個不對應的索引  \n   Yes → Return i+1 // 這即為最小缺失正整數  \n   No  → Continue // 檢查下一個索引  \n→ Step 6: Return n+1 // 所有 1~n 都存在，缺失的是 n+1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef first_missing_positive(nums):\n    \"\"\"\n    Find the smallest positive integer missing from the list nums.\n    Implements the O(n) time, O(1) auxiliary space algorithm.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        # Place nums[i] at its correct index if possible\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            # Swap current element with the element at its target position\n            target_index = nums[i] - 1\n            nums[i], nums[target_index] = nums[target_index], nums[i]\n    # After placement, the first index where value differs from i+1\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    # All numbers 1..n are present\n    return n + 1\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    # Extract the list part from the input string\n    if '=' in raw_input:\n        _, list_part = raw_input.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = raw_input\n    # Safely evaluate the list\n    nums = ast.literal_eval(list_part)\n    result = first_missing_positive(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,0]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [3,4,-1,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [7,8,9,11,12]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode551.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record I",
    "description_snippet": "You are given a string s representing an attendance record for a student where each character signif...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for checking attendance eligibility. Provide each line with // explanation. Use Start, End, Decision:, etc. No actual code. Let's produce algorithm: iterate through string, count As and check consecutive L's. If absences>=2, fail. If consecutive L>=3, fail. Return result.\n\nLet's produce pseudo steps:\n\nStart\n→ Initialize countA = 0 // absent counter\n→ Initialize consecutiveL = 0 // consecutive late counter\n→ Initialize flagEligible = true // assume eligible\n→ Decision: iterate over each character in s? We'll use loop steps: For i in s: \n- Decision: char == 'A'? ...\n- Decision: char == 'L'? ...\n- Else (P) -> reset consecutiveL\n- After each step, Decision: countA >= 2? -> set flagEligible false and break\n- Decision: consecutiveL >=3? -> flagEligible false and break\nAt end, Return flagEligible\nEnd\n\nNeed to use virtual code arrows and decisions.\n\nMake sure each line has code then // explanation.\n\nLet's craft.\n\nUse structure: \nStart // \n→ Step 1: Set countA = 0 // initialize absent counter\n→ Step 2: Set consecutiveL = 0 // initialize consecutive late counter\n→ Step 3: Set flagEligible = true // assume eligible until proven otherwise\n→ Step 4: For each character c in s: // iterate through record\n    → Decision: c == 'A'? // check if absent\n        Yes → Step 5: Increment countA // increase absent count\n            → Decision: countA >= 2? // too many absences?\n                Yes → Step 6: Set flagEligible = false // disqualify\n                    → Decision: flagEligible == false? // already disqualified\n                        Yes → Step 7: Break out of loop // stop checking\n        No → Decision: c == 'L'? // check if late\n            Yes → Step 8: Increment consecutiveL // count consecutive L\n                → Decision: consecutiveL >= 3? // too many consecutive late\n                    Yes → Step 9: Set flagEligible = false // disqualify\n                        → Decision: flagEligible == false? // already disqualified\n                            Yes → Step 10: Break // stop checking\n            No → Step 11: Set consecutiveL = 0 // reset on present\n→ Step 12: Return flagEligible // give result\nEnd // end program\n\nMake sure each line includes arrow formatting. For indentation maybe not needed but maintain arrow. Use Yes → and No → after Decision lines. Provide step numbering maybe but not required. Let's craft.\n\nAlso include Step numbers maybe. Ok. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 countA = 0 // 初始化缺勤計數  \n→ Step 2: 設定 consecutiveL = 0 // 初始化連續遲到計數  \n→ Step 3: 設定 flagEligible = true // 預設符合資格  \n→ Step 4: 對於每個字元 c 在 s 中進行迴圈 // 遍歷出勤紀錄  \n  → Decision: c == 'A'? // 判斷是否為缺勤  \n   Yes → Step 5: countA++ // 增加缺勤計數  \n    → Decision: countA >= 2? // 缺勤是否已達兩天  \n     Yes → Step 6: flagEligible = false // 失去資格  \n      → Decision: flagEligible == false? // 已失去資格  \n       Yes → Step 7: 跳出迴圈 // 不再檢查  \n   No → Decision: c == 'L'? // 判斷是否為遲到  \n    Yes → Step 8: consecutiveL++ // 增加連續遲到計數  \n     → Decision: consecutiveL >= 3? // 連續遲到是否達三天  \n      Yes → Step 9: flagEligible = false // 失去資格  \n       → Decision: flagEligible == false? // 已失去資格  \n        Yes → Step 10: 跳出迴圈 // 不再檢查  \n    No → Step 11: consecutiveL = 0 // 遇到出席，重置遲到計數  \n→ Step 12: 回傳 flagEligible // 回傳是否符合資格  \nEnd // 程式結束執行",
      "generated_code": "import sys\n\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        \"\"\"\n        Determine if a student is eligible for an attendance award.\n\n        Eligibility rules:\n        1. The student must have less than 2 'A' (absent) days.\n        2. The student must never have 3 or more consecutive 'L' (late) days.\n        \"\"\"\n        # Count total absences\n        if s.count('A') >= 2:\n            return False\n        # Check for 3 or more consecutive 'L'\n        if 'LLL' in s:\n            return False\n        return True\n\ndef main():\n    # Read entire input, strip whitespace and surrounding quotes if present\n    raw_input = sys.stdin.read().strip()\n    s = raw_input.strip('\\'\"')\n    solution = Solution()\n    result = solution.checkRecord(s)\n    # Output in lowercase as required by the examples\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"PPALLP\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"PPALLL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode26.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code, line by line, with explanations. It's Leetcode 26 Remove Duplicates from Sorted Array. Approach: use two pointers, fast and slow. Initialize slow=0. Iterate fast from 1 to n-1. If nums[fast] != nums[slow], increment slow, set nums[slow] = nums[fast]. At end, k = slow+1. Return k. Also consider empty array.\n\nWe need to produce virtual code with arrows and decision steps. We'll output each line with explanation. Let's construct. Use Start, End. Use Decision: If n==0? etc. Provide step-by-step.\n\nWe should produce minimal pseudo-code but with steps. Each line: \"Start // ...\" then arrow.\n\nMake sure each line ends with explanation. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n // 先取得 nums 的長度  \n→ Decision: n 是否為 0? // 判斷是否為空陣列  \n  Yes → Step 2: 回傳 0 // 空陣列直接回傳 0  \n  No → Step 3: 設定 slow = 0 // slow 指向第一個唯一元素的位置  \n  No → Step 4: 迴圈 fast 從 1 到 n-1 // fast 為遍歷指標  \n   Decision: fast < n? // 判斷是否還有元素要檢查  \n    Yes → Step 5: 如果 nums[fast] ≠ nums[slow]? // 比較快指標位置值與慢指標位置值  \n      Decision: nums[fast] ≠ nums[slow]?  \n        Yes → Step 6: slow++ // 找到新唯一元素，移動 slow  \n        Yes → Step 7: nums[slow] = nums[fast] // 把新唯一元素寫入 slow 位置  \n        No → Step 8: // 兩個指標相同，跳過重複元素  \n      No → Step 9: // fast 仍遞增，繼續迴圈  \n       Decision: fast < n? // 重複迴圈條件  \n        Yes → 回到 Step 5  \n        No → Step 10: k = slow + 1 // 最後 unique 個數是 slow+1  \n        No → Step 11: 回傳 k // 回傳 unique 個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        Remove duplicates in-place from a sorted list.\n        Return the number of unique elements.\n        \"\"\"\n        if not nums:            # 空陣列直接回傳 0\n            return 0\n\n        slow = 0                # slow 指向目前唯一元素的最後一個位置\n        for fast in range(1, len(nums)):   # fast 從第二個元素開始遍歷\n            if nums[fast] != nums[slow]:   # 發現新唯一元素\n                slow += 1                  # 移動 slow\n                nums[slow] = nums[fast]    # 把新元素寫入 slow 位置\n        return slow + 1                # unique 數量為 slow+1\n\ndef main():\n    # 讀取整個 stdin，並抽取方括號內的數字列表\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        start = data.index('[')\n        end = data.index(']', start)\n        nums = ast.literal_eval(data[start:end+1])\n    except (ValueError, SyntaxError):\n        # 若解析失敗，直接終止\n        return\n\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # 準備輸出，將剩餘位置用 '_' 標示\n    display = []\n    for i in range(k):\n        display.append(nums[i])\n    for _ in range(k, len(nums)):\n        display.append('_')\n    print(f\"{k}, nums = {display}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[1,2,_]'\nGot (Norm):      '2,nums=[1,2,\"_\"]'\n--- (Raw) ---\nRaw Expected: '2, nums = [1,2,_]'\nRaw Got:      \"2, nums = [1, 2, '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,2,3,4,_,_,_,_,_]'\nGot (Norm):      '5,nums=[0,1,2,3,4,\"_\",\"_\",\"_\",\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,2,3,4,_,_,_,_,_]'\nRaw Got:      \"5, nums = [0, 1, 2, 3, 4, '_', '_', '_', '_', '_']\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode414.json",
    "problem_index_in_file": 0,
    "title": "Third Maximum Number",
    "description_snippet": "Given an integer array nums, return the third distinct maximum number in this array. If the third ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Use Start, Step, Decision. Provide explanation comments after space.\n\nGoal: find third distinct maximum, else maximum.\n\nWe need to iterate, maintain three distinct maximums. Approach: use variables max1, max2, max3 initialize to None. For each num, if num==max1 or max2 or max3 skip. Else compare to max1 etc.\n\nAt end, if max3 is None, return max1 else max3.\n\nWe produce virtual steps.\n\nLet's write:\n\nStart\n→ Step 1: 初始化 max1, max2, max3 為 None // 初始三個最大值\n→ Step 2: 從 nums 迭代每個 num // 遍歷輸入陣列\n    → Decision: 如果 num 等於 max1, max2 或 max3? // 排除重複\n        Yes → Step 3: 跳過該 num // 重複值不處理\n        No  → Decision: 如果 max1 為 None 或 num > max1? // 最高\n            Yes → Step 4: max3 = max2, max2 = max1, max1 = num // 更新三個最大\n            No  → Decision: 如果 max2 為 None 或 num > max2? // 第二高\n                Yes → Step 5: max3 = max2, max2 = num // 更新第二、第三\n                No  → Decision: 如果 max3 為 None 或 num > max3? // 第三高\n                    Yes → Step 6: max3 = num // 更新第三\n                    No  → Step 7: 無變化 // num 低於第三\n→ Decision: 如果 max3 為 None? // 是否存在第三最大\n    Yes → Step 8: 回傳 max1 // 沒有第三個，回傳最大\n    No  → Step 9: 回傳 max3 // 回傳第三個\nEnd\n\nNeed to ensure each line includes '虛擬碼步驟' plus comment.\n\nAdd arrows and indentation with 4 spaces for nested steps. Use appropriate arrow for decision. Use 'Yes →', 'No →'.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 max1, max2, max3 為 None // 設定三個最大值為空  \n→ Step 2: 從 nums 迭代每個 num // 開始遍歷輸入陣列  \n  → Decision: 如果 num 等於 max1, max2 或 max3? // 排除重複值  \n    Yes → Step 3: 跳過該 num // 重複值不處理  \n    No  → Decision: 如果 max1 為 None 或 num > max1? // 判斷是否為最高值  \n      Yes → Step 4: max3 = max2, max2 = max1, max1 = num // 更新三個最大值  \n      No  → Decision: 如果 max2 為 None 或 num > max2? // 判斷是否為第二高  \n        Yes → Step 5: max3 = max2, max2 = num // 更新第二、第三  \n        No  → Decision: 如果 max3 為 None 或 num > max3? // 判斷是否為第三高  \n          Yes → Step 6: max3 = num // 更新第三最大值  \n          No  → Step 7: 無變化 // num 低於第三最大  \n→ Decision: 如果 max3 為 None? // 判斷第三最大值是否存在  \n  Yes → Step 8: 回傳 max1 // 若不存在第三最大，回傳最大值  \n  No  → Step 9: 回傳 max3 // 否則回傳第三最大值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def thirdMax(self, nums):\n        # 使用 set 去重，避免重複值影響結果\n        unique_nums = set(nums)\n        first = second = third = None\n\n        for num in unique_nums:\n            if first is None or num > first:\n                third = second\n                second = first\n                first = num\n            elif second is None or num > second:\n                third = second\n                second = num\n            elif third is None or num > third:\n                third = num\n\n        # 若至少有三個不同的數字，返回第三大；否則返回最大值\n        return third if len(unique_nums) >= 3 else first\n\ndef main():\n    # 從標準輸入讀取完整內容\n    data = sys.stdin.read().strip()\n    # 從輸入中抽取所有整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    result = Solution().thirdMax(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,2,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode639.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways II",
    "description_snippet": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n'A' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, not actual code. Steps for decoding string with '*' etc. Should produce virtual code with arrows, Start, End, Decision. Provide explanation each line. Probably need to outline algorithm: dynamic programming, ways[i] for prefix length i. We'll handle single char and double char. For each position i from 1..n, compute dp[i] from dp[i-1] and dp[i-2] depending on current and previous char. Handle '*' possibilities.\n\nWe just need to output pseudocode, not actual code. So lines like:\n\nStart\n→ Initialize MOD = 1e9+7\n→ Initialize dp[0] = 1\n→ For i = 1 to len(s):\n    → Decision: s[i-1] == '*'\n        Yes → ways1 = 9 * dp[i-1] mod MOD\n        No  → If s[i-1] != '0': ways1 = 1 * dp[i-1] else ways1 = 0\n    → Decision: i >= 2\n        Yes → Decision: previous char logic with '*' combos\n            ...\n    → dp[i] = (ways1 + ways2) mod MOD\n→ End\n\nBut we need to provide step-by-step with explanations. Use arrows.\n\nWe should not output actual code but pseudocode steps. Let's craft.\n\nNeed to show for each character we consider single-digit and double-digit decoding.\n\nEdge cases: '*' can represent 1-9; combination with previous char: if previous is '*', current char 'digit' or '*'.\n\nDefine counts: singleCount, doubleCount.\n\nWe might use variables: singleCount, doubleCount, prevChar, currChar.\n\nWe'll provide steps.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Set MOD = 1_000_000_007 // 模式數，用於結果取餘\n→ Let n = length of input string s // 獲得字串長度\n→ Create array dp[0..n] // dp[i] 表示前 i 個字符的解碼方法數\n→ Set dp[0] = 1 // 空字串有一種解碼方式\n\n→ For i from 1 to n // 遍歷每個位置\n    → Let curr = s[i-1] // 當前字符（0-index）\n    → // 計算以單個字符作為最後一段的解碼數\n    → Decision: curr == '*'\n        Yes → singleWays = 9 * dp[i-1] mod MOD // '*' 可為 1-9\n        No  → Decision: curr == '0'\n            Yes → singleWays = 0 // '0' 不能獨立映射\n            No  → singleWays = 1 * dp[i-1] mod MOD // 1-9 有唯一映射\n    → // 若 i>=2，還需考慮兩字符合併解碼\n    → Decision: i >= 2\n        Yes →\n            → Let prev = s[i-2] // 前一字符\n            → // 初始化雙字符解碼數\n            → doubleWays = 0\n            → Decision: prev == '*' and curr == '*'\n                Yes → doubleWays = 15 * dp[i-2] mod MOD // '**' 可表示 11-19, 21-26 共 15 種\n                No →\n                    Decision: prev == '*'\n                        Yes →\n                            → Decision: curr == '0'\n                                Yes → doubleWays = 2 * dp[i-2] mod MOD // '*0' 可為 10,20\n                                No  → // curr 是 1-9\n                                    → doubleWays = 2 * dp[i-2] mod MOD // '*d' 可為 1d 或 2d 若 d≤6\n                                    // 但若 d>6 只可為 1d\n                                    → Decision: curr > '6'\n                                        Yes → doubleWays = 1 * dp[i-2] mod MOD\n                                        No  → // already counted 2\n                    No →\n                        → Decision: curr == '*'\n                            Yes →\n                                → Decision: prev == '1'\n                                    Yes → doubleWays = 9 * dp[i-2] mod MOD // '1*' 可為 11-19\n                                    No →\n                                        → Decision: prev == '2'\n                                            Yes → doubleWays = 6 * dp[i-2] mod MOD // '2*' 可為 21-26\n                                            No  → doubleWays = 0\n                            No  → // prev and curr both digits\n                                → Decision: prev == '1' or (prev == '2' and curr <= '6')\n                                    Yes → doubleWays = 1 * dp[i-2] mod MOD // 有效的兩位數\n                                    No  → doubleWays = 0\n    → // 計算 dp[i] 為單字符和雙字符方式之和\n    → dp[i] = (singleWays + doubleWays) mod MOD\n→ End // 程式執行結束（dp[n] 為最終答案）",
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\ndef num_decodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(1, n + 1):\n        # Single character decoding\n        if s[i - 1] == '*':\n            dp[i] = 9 * dp[i - 1]\n        elif s[i - 1] != '0':\n            dp[i] = dp[i - 1]\n\n        # Two character decoding\n        if i > 1:\n            prev, cur = s[i - 2], s[i - 1]\n            if prev == '*' and cur == '*':\n                dp[i] += 15 * dp[i - 2]          # 11-19, 21-26\n            elif prev == '*':\n                if cur <= '6':\n                    dp[i] += 2 * dp[i - 2]       # 1cur or 2cur\n                else:\n                    dp[i] += 1 * dp[i - 2]       # only 1cur\n            elif cur == '*':\n                if prev == '1':\n                    dp[i] += 9 * dp[i - 2]       # 11-19\n                elif prev == '2':\n                    dp[i] += 6 * dp[i - 2]       # 21-26\n            else:\n                # Both digits\n                if 10 <= int(prev + cur) <= 26:\n                    dp[i] += dp[i - 2]\n\n        dp[i] %= MOD\n\n    return dp[n]\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # Extract string between quotes if present, otherwise use entire input\n    first_quote = data.find('\"')\n    last_quote = data.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = data[first_quote + 1:last_quote]\n    else:\n        s = data\n    result = num_decodings(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"*\"",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "s = \"1*\"",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 2,
          "input": "s = \"2*\"",
          "expected_output": "15",
          "success": true,
          "output": "15"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode367.json",
    "problem_index_in_file": 0,
    "title": "Valid Perfect Square",
    "description_snippet": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The algorithm: binary search from 1 to num/2? Or from 1 to num. Since no sqrt. But we can use integer math. For positive integer num.\n\nVirtual code structure: Start, then maybe check if num <= 0? but requirement positive integer. But could include check. Then binary search: left = 1, right = num, while left <= right: mid = left + (right-left)/2, square = mid*mid, compare with num. If equal, return true; if less, left=mid+1; else right=mid-1. Finally return false. Also avoid overflow: mid*mid might overflow; but maybe assume fits 64-bit. But we can use division: if num / mid == mid? That works for perfect square check. Use integer division: if mid*mid == num; or if mid == num / mid and num % mid ==0. But use mid*mid maybe simpler. Use BigInt? But okay.\n\nWe need no built-in sqrt, but can use division. So virtual code steps:\n\nStart\n→ Decision: 如果 num < 1? // check for positive integer\n    Yes → Step: 返回 false // less than 1 not a perfect square\n    No → Step: 初始化 left = 1, right = num // search range\n→ Step: while left <= right: // binary search loop\n    → Step: mid = left + (right - left) / 2 // compute mid\n    → Step: product = mid * mid // compute square\n    → Decision: 如果 product == num? // compare\n        Yes → Step: 返回 true // found perfect square\n        No → Decision: 如果 product < num? // adjust bounds\n            Yes → Step: left = mid + 1 // search higher half\n            No  → Step: right = mid - 1 // search lower half\n→ Step: 返回 false // not found\nEnd\n\nBut each line with comment. Use \"Yes →\" and \"No →\" for decisions. Format exactly. We must not output actual code but virtual code lines with arrow, step, decision, etc. We must include comment after space.\n\nWe need to ensure each line includes arrow and comment. For decisions we have nested decisions. Use indentation? The example uses indentation. We can indent with spaces. Use 4 spaces per indent maybe.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 num < 1? // 檢查輸入是否為正整數  \n  Yes → Step: 返回 false // 非正數不為完全平方數  \n  No  → Step: 初始化 left = 1, right = num // 設定二分搜尋範圍  \n→ Step: while left <= right: // 進入二分搜尋迴圈  \n  → Step: mid = left + (right - left) / 2 // 計算中點  \n  → Step: product = mid * mid // 取得中點的平方  \n  → Decision: 如果 product == num? // 判斷是否為完全平方數  \n    Yes → Step: 返回 true // 找到完全平方數，結束程式  \n    No  → Decision: 如果 product < num? // 需要搜尋更高的數值範圍？  \n      Yes → Step: left = mid + 1 // 將搜尋範圍縮小至右半部  \n      No  → Step: right = mid - 1 // 將搜尋範圍縮小至左半部  \n→ Step: 返回 false // 未在範圍內找到完全平方數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        \"\"\"\n        Determine whether num is a perfect square without using sqrt().\n        Uses binary search between 1 and num//2 (or 2 for num > 1).\n        \"\"\"\n        if num < 2:\n            return True\n        left, right = 2, num // 2\n        while left <= right:\n            mid = (left + right) // 2\n            guess = mid * mid\n            if guess == num:\n                return True\n            elif guess > num:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return False\n\ndef main():\n    \"\"\"\n    Reads input from stdin, extracts the integer value, evaluates whether it\n    is a perfect square, and prints 'true' or 'false' accordingly.\n    \"\"\"\n    data = sys.stdin.read()\n    # 尋找第一個整數（允許負號）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return  # 無有效數字，直接結束\n    num = int(match.group())\n    result = Solution().isPerfectSquare(num)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "num = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode53.json",
    "problem_index_in_file": 0,
    "title": "Maximum Subarray",
    "description_snippet": "Given an integer array nums, find the subarray with the largest sum, and return its sum....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for finding maximum subarray sum (Kadane). Provide line by line steps with arrows. Use Start, End, Decision. Provide explanation after //.\n\nEnsure no actual code, just virtual steps. Use arrow lines. Let's produce.\n\nStructure: Start, Step 1: 初始化 max_so_far, current_sum to nums[0]. Step 2: Iterate from index 1 to end. Step 3: Decision if current element > current_sum + element. If Yes → set current_sum = element else current_sum += element. Step 4: Decision if current_sum > max_so_far? If Yes update max_so_far. After loop End. Output max_so_far. But virtual code needs to output sum. We can add Step 5: 輸出 max_so_far.\n\nLet's format with arrow lines. Use \"→\" for steps, \"Decision:\" for conditions. Use \"Yes →\" and \"No →\" for branches. Provide brief explanation after each line. Should be concise.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 max_so_far ← nums[0], current_sum ← nums[0] // 初始化最大子陣列和與目前子陣列和為第一個元素  \n→ Step 2: 從 i = 1 開始迭代至 nums 長度 - 1 // 遍歷陣列的其餘元素  \n    → Decision: 若 nums[i] > current_sum + nums[i]? // 判斷是否重新開始子陣列  \n        Yes → Step 3a: current_sum ← nums[i] // 重新開始新子陣列，使用當前元素作為唯一元素  \n        No  → Step 3b: current_sum ← current_sum + nums[i] // 延續現有子陣列，加入當前元素  \n    → Decision: 若 current_sum > max_so_far? // 檢查是否更新全局最大和  \n        Yes → Step 4: max_so_far ← current_sum // 更新最大子陣列和  \n        No  → // 目前最大值保持不變  \n→ Step 5: 輸出 max_so_far // 回傳最大子陣列和  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef max_subarray(nums):\n    \"\"\"使用 Kadane 演算法計算最大子陣列和。\"\"\"\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        # 重新開始或延續子陣列\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 若輸入包含「nums =」前綴，去除它\n    if \"=\" in data:\n        data = data.split(\"=\", 1)[1].strip()\n\n    # 評估為 Python list（例如「[-2,1,-3]」）\n    nums = eval(data)\n\n    # 計算並輸出結果\n    result = max_subarray(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [5,4,-1,7,8]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode14.json",
    "problem_index_in_file": 0,
    "title": "Longest Common Prefix",
    "description_snippet": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for a function that finds longest common prefix among array of strings. Use the specified format: each line with virtual code step and comment. Use arrows, decisions, start, end. No actual code, just structure. Should include input, output, etc. So:\n\nStart\n→ Step: 接收字符串陣列 inputList //取得輸入\n→ Decision: 陣列是否為空? //檢查是否有元素\n   Yes → Step: 回傳 \"\" //無元素則返回空字串\n   No → Step: 取第一個字串作為初始前綴 prefix //初始前綴\n→ Step: 循環遍歷陣列中其餘字串\n   For each str in inputList[1:]:\n     → Decision: prefix 是否為空? //如果已無前綴直接跳出\n         Yes → Break //結束循環\n         No → Step: 將 str 轉換為陣列 charList //方便比對\n         → Step: 找到最小長度 minLen = min(len(prefix), len(str))\n         → Step: 建立 newPrefix = \"\"\n         → Step: 循環索引 i 0 to minLen-1\n             → Decision: prefix[i] == str[i]?\n                 Yes → Step: newPrefix += prefix[i] //累加相同字符\n                 No  → Break //不相同直接跳出\n         → Step: prefix = newPrefix //更新前綴\n→ Step: 回傳 prefix //最後前綴\n\nBut we need to produce virtual code lines, each with arrow and explanation. Use arrow \"→\" for sequence, \"Decision:\" for if. Indent with spaces maybe.\n\nAlso need End. Let's craft lines accordingly.\n\nWe need to maintain structure with Start, End. Use decisions for conditions.\n\nAlso the array iteration should be represented generically. Use \"Loop over inputList starting from index 1\". Represent with a decision maybe.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: inputList ← 取得輸入的字串陣列 // 從使用者或函式參數獲取字串清單\n→ Decision 1: 是否有任何字串? // 檢查陣列是否為空\n    Yes → Step 2: prefix ← inputList[0] // 以第一個字串作為初始前綴\n    No  → Step 3: 回傳 \"\" // 若陣列為空，直接回傳空字串\n→ Step 4: 從 inputList 的第二個字串開始迭代 // 準備比較每個字串\n    → Loop for each str in inputList[1:]:\n        → Decision 2: prefix 是否已經為空? // 前綴已無共同字符時可提前結束\n            Yes → Break // 退出迴圈\n            No  →\n                → Step 5: minLen ← 最小值(len(prefix), len(str)) // 取得比較範圍\n                → Step 6: newPrefix ← \"\" // 用於累積新的前綴\n                → Loop i from 0 to minLen - 1:\n                    → Decision 3: prefix[i] == str[i]? // 比對每個位置的字元\n                        Yes → Step 7: newPrefix ← newPrefix + prefix[i] // 字元相同，加入新前綴\n                        No  → Break // 字元不同，結束內部迴圈\n                → Step 8: prefix ← newPrefix // 更新前綴為目前已知的最大公共前綴\n→ Step 9: 回傳 prefix // 最終得到的最長公共前綴\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef longest_common_prefix(strs):\n    \"\"\"\n    找到給定字串列表中的最長公共前綴。\n    \"\"\"\n    if not strs:                 # 空列表直接回傳空字串\n        return \"\"\n    prefix = strs[0]             # 初始前綴取第一個字串\n    for s in strs[1:]:\n        # 當前字串不以現有前綴開頭時，逐步縮短前綴\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]   # 刪除最後一個字元\n            if not prefix:         # 前綴已經變為空字串，直接結束\n                return \"\"\n    return prefix\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        strs = []\n    else:\n        # 嘗試從輸入中提取字串列表\n        match = re.search(r'\\[.*\\]', data, re.S)\n        if match:\n            list_str = match.group(0)\n        else:\n            list_str = data\n        try:\n            strs = ast.literal_eval(list_str)\n        except Exception:\n            # 如果解析失敗，視為空列表\n            strs = []\n\n    result = longest_common_prefix(strs)\n    # 將結果包裝成帶引號的字串輸出\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "expected_output": "\"fl\"",
          "success": true,
          "output": "\"fl\""
        },
        {
          "example_index": 1,
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode72.json",
    "problem_index_in_file": 0,
    "title": "Edit Distance",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of operations required to convert word1...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for edit distance DP. Provide steps. Each line with virtual code + explanation. Use arrow, decision etc. It's a typical algorithm. We'll output steps: Start, input, set up dp table dimensions len1+1 by len2+1, initialize base cases, nested loops, compute min of delete, insert, replace, fill dp[i][j], then after loops output dp[len1][len2], End. Provide explanation each line. Ensure \"virtual code\" is like \"→ Step 1: ...\" etc. Let's produce. Ensure each line ends with // explanation. Use Chinese. Provide steps line by line. We'll use consistent style. Let's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 word1, word2 // 從使用者取得兩個輸入字串  \n→ Step 2: 取得 word1 長度 m, word2 長度 n // 計算兩字串的長度  \n→ Step 3: 初始化二維 dp 陣列，大小 (m+1) × (n+1) // 用於儲存子問題的解  \n→ Decision: 初始化 dp[0][0] = 0 // 兩個空字串相同，零步驟  \n    → Step 4: 對 i 從 1 到 m: dp[i][0] = i // 把 word1 前 i 個字元轉成空字串需刪除 i 次  \n    → Step 5: 對 j 從 1 到 n: dp[0][j] = j // 把空字串轉成 word2 前 j 個字元需插入 j 次  \n→ Step 6: 嵌套迴圈: 對 i 從 1 到 m  \n→ Decision: 對 j 從 1 到 n  \n    → Step 7: 若 word1[i-1] == word2[j-1]  \n        → Decision: 则 dp[i][j] = dp[i-1][j-1] // 字元相同，保持上一狀態  \n        → Else  \n        → Step 8: 計算三個候選值  \n            → Step 9: delete = dp[i-1][j] + 1 // 從 word1 刪除一字元  \n            → Step 10: insert = dp[i][j-1] + 1 // 在 word1 插入一字元  \n            → Step 11: replace = dp[i-1][j-1] + 1 // 替換 word1[i-1] 為 word2[j-1]  \n            → Step 12: dp[i][j] = min(delete, insert, replace) // 取最小步驟  \n→ Step 13: 回傳 dp[m][n] // 最終答案是將整個 word1 轉成 word2 所需的最少操作數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_distance(word1: str, word2: str) -> int:\n    \"\"\"計算將 word1 轉換成 word2 所需的最少操作數（插入、刪除、替換）。\"\"\"\n    m, n = len(word1), len(word2)\n    # dp[i][j] 代表 word1 前 i 個字母轉換成 word2 前 j 個字母的最小步驟\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # 初始化第一行和第一列\n    for i in range(m + 1):\n        dp[i][0] = i          # 刪除\n    for j in range(n + 1):\n        dp[0][j] = j          # 插入\n\n    # DP 迭代\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]      # 字符相同，直接遺留\n            else:\n                delete = dp[i - 1][j] + 1        # 刪除 word1[i-1]\n                insert = dp[i][j - 1] + 1        # 插入 word2[j-1]\n                replace = dp[i - 1][j - 1] + 1   # 替換\n                dp[i][j] = min(delete, insert, replace)\n    return dp[m][n]\n\ndef main() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 解析 format: word1 = \"xxx\", word2 = \"yyy\"\n    pattern = r'word1\\s*=\\s*\"([^\"]*)\"\\s*,\\s*word2\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, data)\n    if not match:\n        # 如果格式不符合，直接嘗試從行拆分\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            word1 = lines[0].strip()\n            word2 = lines[1].strip()\n        else:\n            word1, word2 = \"\", \"\"\n    else:\n        word1, word2 = match.group(1), match.group(2)\n\n    result = min_distance(word1, word2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode765.json",
    "problem_index_in_file": 0,
    "title": "Couples Holding Hands",
    "description_snippet": "There are n couples sitting in 2n seats arranged in a row and want to hold hands.\n\nThe people and se...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. The user wants solution for LeetCode 765 \"Couples Holding Hands\". We need algorithm: graph cycles or union-find. We'll produce steps: map person to seat index. Then iterate seats i even, check partner seat. If partner not next, swap with the seat of partner. Count swaps. We'll output virtual code step by step. Use Start, End, Decision. Provide explanation.\n\nLet's craft lines:\n\nStart\n→ Step 1: Build mapping person->seat // O(2n)\n→ Step 2: Initialize swaps=0 // swap counter\n→ For i from 0 to 2n-1 step 2 // iterate even seats\n    → Decision: if partner of person at seat i is already at seat i+1? // check if pair is adjacent\n        Yes → continue // no swap needed\n        No → \n            → Step: partner = person at seat i // Actually we need partner ID of current person\n            → Step: partnerSeat = mapping[partner] // seat of partner\n            → Step: swap person at seat i+1 with person at partnerSeat // swap\n            → Step: update mapping for swapped persons // O(1)\n            → Step: swaps +=1\n→ End // return swaps\n\nBut we need virtual code step lines. Use syntax like: `→ Step X: ... // ...`. For loops and decisions, we use indentation? In example, indentation uses spaces before Decision? The example shows indentation with four spaces before `Decision: ...`. For each nested block, we indent 4 spaces. Use arrows for steps. We'll mimic example.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立座位對應表 seatMap 以 person ID 為鍵，座位編號為值 // 建立 O(2n) 的映射\n→ Step 2: 設定 swaps = 0 // 用於計算需要的交換次數\n→ For i = 0; i < 2n; i += 2 // 只處理偶數座位（左邊座位）\n    → Decision: row[i] 的配偶 ID 是否已在座位 i+1？ // 判斷是否已成對\n        Yes → continue // 已成對，移至下一對\n        No  → \n            → Step 3: partnerID = row[i] // 目前座位 i 上的人的配偶是 person ID+1 或 -1\n            → Step 4: partnerSeat = seatMap[partnerID] // 配偶目前所在的座位\n            → Step 5: swap row[i+1] 與 row[partnerSeat] // 交換座位 i+1 與配偶所在座位\n            → Step 6: 更新 seatMap： seatMap[row[i+1]] = i+1; seatMap[row[partnerSeat]] = partnerSeat // 反映交換後的位置\n            → Step 7: swaps += 1 // 記錄一次交換\n→ End // 回傳 swaps，完成最小交換數\n\nBut we need to include `End` after loops. Provide return maybe earlier. Let's add `→ Step 8: return swaps // 輸出最小交換數` inside End? The example uses `End // 程式執行結束`. We can add before End or inside. We'll include a Step before End to return.\n\nLet's structure:\n\nStart\n→ Step 1: ...\n→ Step 2: ...\n→ For i...\n    → Decision...\n        Yes → ...\n        No →\n            ...\n→ Step 9: return swaps // 回傳最小交換數\nEnd\n\nBut the example's End includes comment. We'll follow pattern: `End // 程式執行結束`. We'll also add `Step 9: return swaps // 回傳最小交換數` before End.\n\nLet's produce final output.\n\nMake sure each line ends with `//` and explanation.\n\nLet's produce lines with indentation: 4 spaces for inside loops? The example uses 4 spaces for nested Decision content: lines after Decision have indentation of 8 spaces? Actually example shows:\n\n```\n    Yes → Step 2: ...\n    No  → Decision: ...\n        Yes → Step 3: ...\n```\n\nThey indent each nested block. So we need similar. We'll use 4 spaces for indentation at each level. For loop, we might use indentation 4 spaces for body.\n\nLet's produce:\n\n```\nStart // 程式開始執行\n→ Step 1: 建立 seatMap 為 person ID → 座位編號 的映射 // O(2n)\n→ Step 2: 設定 swaps = 0 // 交換次數統計\n→ For i = 0; i < 2n; i += 2 // 只檢查偶數座位（左邊座位）\n    → Decision: row[i] 的配偶是否已在座位 i+1？ // 判斷是否已成對\n        Yes → continue // 已成對，跳過\n        No  → \n            → Step 3: partnerID = row[i] // 目前座位 i 上人員的配偶 ID\n            → Step 4: partnerSeat = seatMap[partnerID] // 配偶目前所在座位\n            → Step 5: swap row[i+1] 與 row[partnerSeat] // 交換座位\n            → Step 6: 更新 seatMap： seatMap[row[i+1]] = i+1; seatMap[row[partnerSeat]] = partnerSeat // 反映新位置\n            → Step 7: swaps += 1 // 記錄一次交換\n→ Step 8: return swaps // 回傳最小交換次數\nEnd // 程式執行結束\n```\n\nCheck: Step numbering may conflict. We used Step 3,4,5,6,7 inside No block. Step 8 after loop. That's fine.\n\nBut we used `continue` inside loop; might need a line: `→ Step 3: continue // 跳過此對` but we already used Yes path.\n\nBut we used `Yes → continue`. Good.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 seatMap 為 person ID → 座位編號 的映射 // O(2n)  \n→ Step 2: 設定 swaps = 0 // 交換次數統計  \n→ For i = 0; i < 2n; i += 2 // 只檢查偶數座位（左邊座位）  \n    → Decision: row[i] 的配偶是否已在座位 i+1？ // 判斷是否已成對  \n        Yes → continue // 已成對，跳過  \n        No  →  \n            → Step 3: partnerID = row[i] // 目前座位 i 上人員的配偶 ID  \n            → Step 4: partnerSeat = seatMap[partnerID] // 配偶目前所在座位  \n            → Step 5: swap row[i+1] 與 row[partnerSeat] // 交換座位  \n            → Step 6: 更新 seatMap： seatMap[row[i+1]] = i+1; seatMap[row[partnerSeat]] = partnerSeat // 反映新位置  \n            → Step 7: swaps += 1 // 記錄一次交換  \n→ Step 8: return swaps // 回傳最小交換次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minSwapsCouples(self, row):\n        n = len(row)\n        pos = [0] * n\n        for i, x in enumerate(row):\n            pos[x] = i\n        swaps = 0\n        for i in range(0, n, 2):\n            x = row[i]\n            y = x ^ 1  # partner's ID\n            if row[i + 1] != y:\n                partner_idx = pos[y]\n                # swap seat i+1 with partner's seat\n                row[i + 1], row[partner_idx] = row[partner_idx], row[i + 1]\n                # update positions\n                pos[row[partner_idx]] = partner_idx\n                pos[row[i + 1]] = i + 1\n                swaps += 1\n        return swaps\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 找出列表部分\n    start = data.find('[')\n    if start != -1:\n        list_str = data[start:]\n    else:\n        list_str = data\n    # 轉換為 Python 列表\n    row = ast.literal_eval(list_str)\n    # 計算並輸出結果\n    solution = Solution()\n    result = solution.minSwapsCouples(row)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "row = [0,2,1,3]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "row = [3,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode374.json",
    "problem_index_in_file": 0,
    "title": "Guess Number Higher or Lower",
    "description_snippet": "We are playing the Guess Game. The game is as follows: \n\nI pick a number from 1 to n. You have to gu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving Guess Game problem. The algorithm: binary search. Input: n. Use guess API. Return pick. Steps: Start, set low=1, high=n. While low<=high: mid=(low+high)/2; res=guess(mid); if res==0 return mid; else if res==-1 high=mid-1; else low=mid+1. End.\n\nAlso include explanation. Must be each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Use Start End. Format similar to example. Provide each line as separate.\n\nWe must be careful to include the logic: \"Start\" then \"→ Step 1: low=1 // 初始化搜尋範圍\" etc. Use Decision blocks. We'll produce virtual code with decisions. Each line can include arrows.\n\nWe need to output in Traditional Chinese. Provide each line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: low = 1 // 將搜尋範圍下界設為 1\n→ Step 2: high = n // 將搜尋範圍上界設為 n\n→ Decision: while low ≤ high? // 判斷是否仍有未檢查範圍\n    Yes → Step 3: mid = (low + high) / 2 // 取中間值作為猜測\n    → Step 4: result = guess(mid) // 呼叫 API 取得回傳\n    → Decision: result == 0? // 猜中\n        Yes → Step 5: return mid // 回傳正確答案\n        No  → Decision: result == -1? // 猜高\n            Yes → Step 6: high = mid - 1 // 限定上界\n            No  → Step 7: low = mid + 1 // 限定下界\n    No → Continue // 迴圈重複\nEnd // 程式執行結束\n\nBut we need to keep each line separated with arrow and explanation. For decisions we need nested lines. The example uses indentation with spaces. We can use spaces before the lines inside Decision. Use \"→ Decision: ...\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: low = 1 // 初始化搜尋下界\n→ Step 2: high = n // 初始化搜尋上界\n→ Decision: low ≤ high? // 判斷是否還有未搜尋區間\n    Yes → Step 3: mid = (low + high) / 2 // 計算中間值\n    → Step 4: result = guess(mid) // 呼叫猜數字 API\n    → Decision: result == 0? // 判斷是否猜中\n        Yes → Step 5: return mid // 回傳正確答案\n        No  → Decision: result == -1? // 猜的數字太大\n            Yes → Step 6: high = mid - 1 // 調整上界\n            No  → Step 7: low = mid + 1 // 調整下界\n    No → // 迴圈繼續\nEnd // 程式執行結束\n\nBut we should ensure each line ends with // 解釋. The \"No → // 迴圈繼續\" line is missing explanation after //, but we can include \"繼續下一輪\". Let's add: \"No → // 繼續迴圈\".\n\nWe also need to reflect that after decision branches, we go back to the start of while loop. Might need to represent loop. The above representation uses \"Decision: low ≤ high? // ...\". For loops, we might use while structure. But we can use Decision and after the branch we loop back. Use \"←\" maybe? But example used \"→\". We can keep arrow. It's okay.\n\nWe need to include that after adjusting boundaries, we go back to Decision: low ≤ high? So we can add \"←\" maybe. But it's not required. We can assume the loop.\n\nWe can produce final virtual code.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 1 // 將搜尋區間下界設為 1  \n→ Step 2: high = n // 將搜尋區間上界設為 n  \n→ Decision: low ≤ high? // 判斷是否還有未搜尋的區間  \n    Yes → Step 3: mid = (low + high) / 2 // 取中間值作為猜測  \n    → Step 4: result = guess(mid) // 呼叫 API 取得回傳結果  \n    → Decision: result == 0? // 判斷是否猜中  \n        Yes → Step 5: return mid // 回傳正確答案，結束程式  \n        No → Decision: result == -1? // 猜的數字太大  \n            Yes → Step 6: high = mid - 1 // 把上界調整到 mid - 1  \n            No → Step 7: low = mid + 1 // 把下界調整到 mid + 1  \n    No → // 繼續下一輪迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# Global variable to store the number to guess\npick = None\n\ndef guess(num: int) -> int:\n    \"\"\"\n    模擬 API：根據全局變量 pick 返回結果\n    -1 : num > pick  (猜的數字太大)\n     1 : num < pick  (猜的數字太小)\n     0 : num == pick (猜中)\n    \"\"\"\n    global pick\n    if num > pick:\n        return -1\n    elif num < pick:\n        return 1\n    else:\n        return 0\n\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        \"\"\"\n        利用二分搜尋的方式尋找 pick。\n        \"\"\"\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid          # 找到正確答案\n            elif res < 0:\n                right = mid - 1     # 目標在左半邊\n            else:\n                left = mid + 1      # 目標在右半邊\n        return -1                    # 理論上不會執行到這裡\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入文字中提取兩個整數：n 和 pick。\n    支援多種格式，例如：\n        'n = 10, pick = 6'\n        'n=10 pick=6'\n        '10 6'\n    \"\"\"\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        raise ValueError(\"輸入格式不正確，需包含 n 和 pick。\")\n    n, pick_val = map(int, nums[:2])\n    return n, pick_val\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入\n    raw_data = sys.stdin.read().strip()\n    # 解析 n 與 pick\n    n_val, pick_val = parse_input(raw_data)\n    # 設置全局 pick 變量\n    pick = pick_val\n    # 呼叫解法並輸出結果\n    result = Solution().guessNumber(n_val)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10, pick = 6",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode18.json",
    "problem_index_in_file": 0,
    "title": "4Sum",
    "description_snippet": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the 4-sum problem. Provide line-by-line with arrows and decisions. No actual code. Use Chinese. Provide explanation after //.\n\nLet's outline typical algorithm: sort array, then 3 nested loops with two pointers to find quadruplets. Avoid duplicates. Steps: Start, Input nums and target, sort, initialize result array. For i from 0 to n-4: skip duplicates; for j from i+1 to n-3: skip duplicates; left=j+1; right=n-1; while left<right: sum=nums[i]+nums[j]+nums[left]+nums[right]; if sum==target: add quadruplet; move left and right skipping duplicates; else if sum<target: left++; else right--. End loops. Return result.\n\nNeed to output each step line with explanation. Use arrows and decisions. Each line should have \"→ Step: ... // explanation\". Also decisions with Yes→ etc.\n\nWe need to be careful to include all steps: Start, Input, Sort, etc. Let's produce virtual code lines. Use 'Start' at top. Use 'End' at bottom. For loops, show as 'Step X: For i ...' etc.\n\nAlso decisions: For duplicates, check if i>0 && nums[i]==nums[i-1] then skip.\n\nLet's produce.\n\nAlso at end: Return result.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums 與目標值 target // 從使用者或測試環境取得必要資料  \n→ Step 2: 取得陣列長度 n // 方便後續迴圈邏輯  \n→ Step 3: 對 nums 進行升序排序 // 使相同元素相鄰，便於跳過重複與雙指標搜尋  \n→ Step 4: 建立空集合 result 用於儲存所有符合條件的四元組 // 為避免重複結果，使用集合或後續排重  \n→ Decision: 如果 n < 4? // 若元素不足四個，無法形成四元組  \n    Yes → Step 5: 返回 result（空） // 直接結束，無結果  \n    No  →  \n→ Step 6: 進入外層迴圈 i 從 0 到 n-4  \n    → Decision: 如果 i > 0 且 nums[i] == nums[i-1]? // 跳過相同起始元素以避免重複四元組  \n        Yes → Step 7: 進行 i++  // 跳過此個 i  \n        No  →  \n    → Step 8: 進入中層迴圈 j 從 i+1 到 n-3  \n        → Decision: 如果 j > i+1 且 nums[j] == nums[j-1]? // 跳過相同第二個元素  \n            Yes → Step 9: 進行 j++  // 跳過此個 j  \n            No  →  \n        → Step 10: 設定 left = j+1, right = n-1 // 初始化左右指標  \n        → Decision: 只要 left < right? // 進行雙指標搜尋  \n            Yes →  \n                → Step 11: 計算 currentSum = nums[i] + nums[j] + nums[left] + nums[right] // 取得目前四元組總和  \n                → Decision: currentSum == target? // 判斷是否符合目標  \n                    Yes →  \n                        → Step 12: 將 [nums[i], nums[j], nums[left], nums[right]] 加入 result // 存儲符合條件的四元組  \n                        → Step 13: 移動 left++ 同時 while left < right 且 nums[left] == nums[left-1] do left++ // 跳過重複左邊元素  \n                        → Step 14: 移動 right-- 同時 while left < right 且 nums[right] == nums[right+1] do right-- // 跳過重複右邊元素  \n                    No  →  \n                        → Decision: currentSum < target? // 若總和小於目標，需要增大和  \n                            Yes → Step 15: left++ // 向右移動左指標  \n                            No  → Step 16: right-- // 向左移動右指標  \n                → 回到 Decision: left < right? // 迴圈繼續  \n            No  →  \n        → 回到 Step 8: j++ // 結束中層迴圈的下一個 j  \n    → 回到 Step 6: i++ // 結束外層迴圈的下一個 i  \n→ Step 17: 返回 result // 程式結束，輸出所有符合條件的四元組  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def fourSum(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\ndef parse_input():\n    raw = sys.stdin.read().strip()\n    # Replace commas with newlines to allow exec of multiple assignments\n    raw = raw.replace(',', '\\n')\n    namespace = {}\n    exec(raw, {}, namespace)\n    nums = namespace.get('nums')\n    target = namespace.get('target')\n    return nums, target\n\nif __name__ == \"__main__\":\n    nums, target = parse_input()\n    solution = Solution()\n    result = solution.fourSum(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp96w6cnd6.py\", line 43, in <module>\n    nums, target = parse_input()\n                   ^^^^^^^^^^^^^\n  File \"/tmp/tmp96w6cnd6.py\", line 37, in parse_input\n    exec(raw, {}, namespace)\n  File \"<string>\", line 1\n    nums = [1\n            ^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmptroz5buy.py\", line 43, in <module>\n    nums, target = parse_input()\n                   ^^^^^^^^^^^^^\n  File \"/tmp/tmptroz5buy.py\", line 37, in parse_input\n    exec(raw, {}, namespace)\n  File \"<string>\", line 1\n    nums = [2\n            ^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode509.json",
    "problem_index_in_file": 0,
    "title": "Fibonacci Number",
    "description_snippet": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for calculating Fibonacci. Should be step-by-step algorithm, using Start, Decision, etc. We need to consider typical algorithm: either iterative or recursive. Use iterative for efficiency. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrow and indentation. Let's produce:\n\nStart\n→ Input n\n→ Decision: if n == 0? // check if n is 0\n    Yes → Output 0\n    No  → Decision: if n == 1? // check if n is 1\n        Yes → Output 1\n        No  → Step: Set a = 0, b = 1 // initialize\n              Set i = 2 // start index\n              → Decision: i <= n? // loop until i > n\n                  Yes → Step: temp = a + b // next Fibonacci\n                         Set a = b\n                         Set b = temp\n                         Set i = i + 1\n                         → Decision: i <= n? // repeat\n                     No  → Output b // result\nEnd\n\nNeed to include arrows \"→\" for each step. Also we need to use \"Decision:\" lines with Yes → and No →. Provide simple explanation after each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 從使用者取得欲計算的 Fibonacci 索引  \n→ Decision: n 等於 0? // 檢查是否為最小值  \n  Yes → Output 0 // 若 n 為 0，直接輸出 0  \n  No  → Decision: n 等於 1? // 檢查是否為次小值  \n    Yes → Output 1 // 若 n 為 1，直接輸出 1  \n    No  → Step: a = 0, b = 1 // 初始化前兩個 Fibonacci 數值  \n     Step: i = 2 // 設定目前索引為 2  \n     → Decision: i ≤ n? // 判斷是否已達目標索引  \n      Yes → Step: temp = a + b // 計算下一個 Fibonacci 數值  \n       Step: a = b // 更新前一個值  \n       Step: b = temp // 更新目前值  \n       Step: i = i + 1 // 進行索引遞增  \n       → Decision: i ≤ n? // 重新檢查條件，若還未到目標索引則重複循環  \n        … // 重複上述循環步驟  \n      No  → Output b // 當 i 超過 n 時，b 即為 F(n)  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef fib(n: int) -> int:\n    \"\"\"Return the nth Fibonacci number (0-indexed).\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r\"-?\\d+\", data)\n    if match:\n        n = int(match.group())\n        result = fib(n)\n        print(result)\n    else:\n        # No integer found; do nothing or raise an error\n        pass",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode15.json",
    "problem_index_in_file": 0,
    "title": "3Sum",
    "description_snippet": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the 3Sum problem. Output line-by-line, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Should cover sorting, loop, two pointers, skip duplicates. Use arrows. Provide concise explanation. No actual code.\n\nLet's craft.\n\nStart // begin\n→ Step 1: Sort nums // 方便後續雙指針和去重\n→ Decision: If length(nums) < 3? // 判斷是否足夠三個數\n    Yes → Step 2: Return empty list // 不足三個，直接返回空集\n    No  → Step 3: 初始化結果 list // 用來存儲符合條件的三元組\n→ Loop i from 0 to len(nums)-3 // 固定第一個元素\n    → Decision: nums[i] > 0? // 由於已排序，若首元素正，後續和不可能為0\n        Yes → Step 4: Break loop // 結束外層循環\n        No  → Decision: i > 0 AND nums[i] == nums[i-1]? // 去重第一個元素\n            Yes → Step 5: Continue // 跳過重複的首元素\n            No  → Step 6: Set left = i+1, right = len(nums)-1 // 初始化左右指標\n                → Loop while left < right // 遍歷可能的第二、三個元素\n                    → Step 7: sum = nums[i] + nums[left] + nums[right] // 計算三數之和\n                    → Decision: sum == 0? // 判斷是否符合條件\n                        Yes → Step 8: Append [nums[i], nums[left], nums[right]] to result // 加入結果\n                               → Step 9: Increment left while left < right AND nums[left] == nums[left-1] // 跳過重複的第二元素\n                               → Step 10: Decrement right while left < right AND nums[right] == nums[right+1] // 跳過重複的第三元素\n                               → Step 11: left = left + 1, right = right - 1 // 移動兩指標進行下一輪\n                        No  → Decision: sum < 0? // 和小於0，需增大和\n                            Yes → Step 12: left = left + 1 // 移動左指標右移\n                            No  → Step 13: right = right - 1 // 移動右指標左移\n→ Step 14: Return result // 所有符合條件的三元組\nEnd // 程式結束\n\nEnsure each line is separate. Let's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums // 對輸入陣列進行升序排序，方便後續使用雙指針和去重  \n→ Decision: 如果 length(nums) < 3? // 判斷數組長度是否足以組成三元組  \n    Yes → Step 2: Return empty list // 不足三個元素，直接返回空集合  \n    No  → Step 3: 初始化結果 list // 用於存放所有符合條件的三元組  \n→ Loop i from 0 to len(nums)-3 // 固定第一個元素，外層循環  \n    → Decision: nums[i] > 0? // 已排序，若首元素為正，後續三數之和不可能為 0  \n        Yes → Step 4: Break loop // 結束外層循環  \n        No  → Decision: i > 0 AND nums[i] == nums[i-1]? // 去重第一個元素  \n            Yes → Step 5: Continue // 跳過重複的首元素  \n            No  → Step 6: Set left = i+1, right = len(nums)-1 // 初始化左右指標  \n                → Loop while left < right // 遍歷可能的第二、三個元素  \n                    → Step 7: sum = nums[i] + nums[left] + nums[right] // 計算三數之和  \n                    → Decision: sum == 0? // 判斷是否符合條件  \n                        Yes → Step 8: Append [nums[i], nums[left], nums[right]] to result // 加入結果集合  \n                            → Step 9: Increment left while left < right AND nums[left] == nums[left-1] // 跳過重複的第二元素  \n                            → Step 10: Decrement right while left < right AND nums[right] == nums[right+1] // 跳過重複的第三元素  \n                            → Step 11: left = left + 1, right = right - 1 // 移動兩指標進行下一輪  \n                        No  → Decision: sum < 0? // 和小於 0，需增大和  \n                            Yes → Step 12: left = left + 1 // 左指標右移  \n                            No  → Step 13: right = right - 1 // 右指標左移  \n→ Step 14: Return result // 返回所有符合條件的三元組  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        res = []\n        n = len(nums)\n\n        for i in range(n):\n            # skip duplicate first elements\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            # early termination: if current number > 0, sum cannot be zero\n            if nums[i] > 0:\n                break\n            left, right = i + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total == 0:\n                    res.append([nums[i], nums[left], nums[right]])\n                    # skip duplicate second elements\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    # skip duplicate third elements\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif total < 0:\n                    left += 1\n                else:\n                    right -= 1\n        return res\n\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    # Extract the list part from input like \"nums = [-1,0,1,2,-1,-4]\"\n    idx = input_data.find('[')\n    if idx == -1:\n        nums = []\n    else:\n        nums_str = input_data[idx:]\n        # safely evaluate the list string\n        nums = eval(nums_str, {\"__builtins__\": None}, {})\n\n    solution = Solution()\n    result = solution.threeSum(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,1,2,-1,-4]",
          "expected_output": "[[-1,-1,2],[-1,0,1]]",
          "success": true,
          "output": "[[-1, -1, 2], [-1, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,0,0]",
          "expected_output": "[[0,0,0]]",
          "success": true,
          "output": "[[0, 0, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode474.json",
    "problem_index_in_file": 0,
    "title": "Ones and Zeroes",
    "description_snippet": "You are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for given problem: largest subset of binary strings with at most m zeros and n ones. Classic DP: 2D DP with dimensions m+1,n+1. Iterate strings, count zeros and ones, update dp from high to low. Output max dp value. Provide step-by-step pseudocode with explanations. Need to format each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. We'll produce start, iterate over strs, count zeros and ones, inner loops from m downto zeros and n downto ones, update dp, after all, find max? Actually dp[m][n] holds maximum number of strings. We'll output that.\n\nLet's produce pseudocode with loops and decisions. Also explanation for DP update. Format lines with arrows. Example: \"→ Step 1: Initialize DP array dp[0..m][0..n] to 0 // dp[i][j] 表示在限制 i 個 0 和 j 個 1 時可以選的最大字串數\". Then iterate.\n\nWe'll include Decision for each string's count? Not necessary. But we can show decision to skip string if counts > m/n. Use Decision.\n\nWe'll use Start, End.\n\nLet's generate. Ensure each line ends with // explanation. Use arrow at start for lines inside loops? The format uses \"→ Step ...\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告 2D 陣列 dp 形狀 (m+1) × (n+1)，並將所有元素初始化為 0 // dp[i][j] 代表在最多 i 個 0 與 j 個 1 的限制下，能挑選的最大字串數  \n→ Step 2: 對每個 binary 字串 s 於 strs 進行迭代 // 逐一考慮是否加入子集  \n    → Step 3: 計算 s 的 0 個數 zeros 與 1 個數 ones // 這兩個數字是本字串所消耗的資源  \n    → Decision: 如果 zeros > m 或 ones > n? // 若資源需求超過限制，無法加入  \n        Yes → Step 4: 跳過此字串 // 直接處理下一個字串  \n        No  → Step 5: 從 i = m 到 zeros 之間倒序迴圈  \n            → Step 6: 從 j = n 到 ones 之間倒序迴圈  \n                → Step 7: 更新 dp[i][j] 為 max(dp[i][j], dp[i-zeros][j-ones] + 1)  \n                // 若將 s 加入，則在剩餘 i-zeros 個 0 與 j-ones 個 1 的情況下能得到的最大字串數加 1，與不加進行比較  \n→ Step 8: 在全部字串處理完畢後，dp[m][n] 為可得到的最大子集大小 // dp[m][n] 已累積最佳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        \"\"\"計算在最多 m 個 0 與 n 個 1 的限制下，能挑選的最大字串數\"\"\"\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，抽取 strs、m 與 n。\n    支援如下形式：\n        strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    \"\"\"\n    # 先找出方括號內的內容\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if list_match:\n        list_str = '[' + list_match.group(1) + ']'\n        # 將單引號改為雙引號以符合 json 解析\n        strs = json.loads(list_str.replace(\"'\", \"\\\"\"))\n    else:\n        strs = []\n\n    # 找出數字，取前兩個作為 m, n\n    nums = re.findall(r'[-]?\\d+', data[list_match.end():] if list_match else data)\n    if len(nums) >= 2:\n        m, n = int(nums[0]), int(nums[1])\n    else:\n        m, n = 0, 0\n\n    return strs, m, n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    strs, m, n = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findMaxForm(strs, m, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode227.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator II",
    "description_snippet": "Given a string s which represents an expression, evaluate this expression and return its value.\n\nThe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for evaluating an arithmetic expression string containing integers, +, -, *, /, with spaces? Typically Leetcode 227 Basic Calculator II. We need to parse and evaluate with operator precedence. Use stack or two stacks or variable tracking. We produce step-by-step virtual code. Provide explanation after each line. No actual code. Use Start, End, Decision, etc. Provide arrow lines. Let's craft.\n\nWe need algorithm: iterate characters, build number, handle operators. Use last operator. Use stack to accumulate values with multiplication/division first.\n\nWe will produce pseudo lines like:\n\nStart\n→ Initialize stack empty\n→ Initialize num=0, lastOp='+'\n→ For each char c in s plus a dummy operator at end:\n   → If c is digit: num = num*10 + int(c)\n   → Else if c is space: continue\n   → Else if c in '+-*/':\n       → Decision: if lastOp == '+':\n           Yes → push num\n           No → Decision: if lastOp == '-': ...\n   → Set lastOp = c\n   → Reset num = 0\n→ After loop, result = sum of stack\n→ Return result\nEnd\n\nAdd detailed lines. Provide decision branches. Use arrow and explanation. Must include line numbers? Not necessary.\n\nWe'll output each line with arrow. Use \"→\" for each step. For decisions, use indentation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 stack 為空 // 用來存放中間計算結果  \n→ 初始化 num 為 0，lastOp 為 '+' // 用來儲存目前正在構造的數字與上一個遇到的運算符  \n→ 對 s 逐字元迭代，並在最後加入一個任意運算符（例如 '+'）以觸發最後一次計算  \n  → Decision: 如果 c 為數字? // 判斷是否在構造數字  \n   Yes → num = num * 10 + 數字值 of c // 逐位拼接完整整數  \n   No → Decision: c 為空格? // 忽略空白字元  \n    Yes → (無操作) // 空格不影響計算  \n    No → Decision: c 為 '+', '-', '*', '/'? // 碰到真正的運算符時執行累加/減/乘/除  \n     Yes → Decision: lastOp 為 '+'? // 根據上一個運算符決定如何處理 num  \n      Yes → stack.push(num) // 加法，直接加入 stack  \n      No → Decision: lastOp 為 '-'?  \n       Yes → stack.push(-num) // 減法，加入負數  \n       No → Decision: lastOp 為 '*'?  \n        Yes → stack.push(stack.pop() * num) // 乘法，先取前一個值再相乘  \n        No → Decision: lastOp 為 '/'?  \n         Yes → stack.push(int(stack.pop() / num)) // 除法，使用截斷向零的除法（語言內建 int 轉換即可）  \n         No → (無操作) // 不可能發生  \n         // 以上為處理上一個運算符的所有情況  \n       // 更新 lastOp 為目前的 c，並將 num 重置為 0，準備處理下一個數字  \n       lastOp = c  \n       num = 0  \n       // 迴圈結束  \n       // (重複上述步驟直到遍歷完 s 及後面添加的 dummy operator)  \n       // 迴圈結束後，stack 中已經存放了所有要相加的值  \n       result = sum(stack) // 將 stack 中的所有數字相加得到最終結果  \n       // Return result as integer  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        stack = []\n        num = 0\n        sign = '+'\n        s += '+'  # 方便最後處理最後一個數字\n\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-*/':\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    top = stack.pop()\n                    # 截斷向零\n                    if top < 0:\n                        stack.append(-(-top // num))\n                    else:\n                        stack.append(top // num)\n                sign = c\n                num = 0\n            # 空白字符直接忽略\n        return sum(stack)\n\ndef extract_expression(text: str) -> str:\n    \"\"\"\n    從輸入文字中抽取表達式內容。\n    允許 's = \"3+2*2\"' 或單獨的 '3+2*2'。\n    \"\"\"\n    # 找尋雙引號內的內容\n    m = re.search(r'\"([^\"]*)\"', text)\n    if m:\n        return m.group(1)\n    # 找尋單引號內的內容\n    m = re.search(r\"'([^']*)'\", text)\n    if m:\n        return m.group(1)\n    # 直接返回去除首尾空白的整行文字\n    return text.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    expr = extract_expression(raw_input)\n    solution = Solution()\n    result = solution.calculate(expr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3+2*2\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \" 3/2 \"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \" 3+5 / 2 \"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode673.json",
    "problem_index_in_file": 0,
    "title": "Number of Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the number of longest increasing subsequences.\n\nNotice that the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: count number of longest increasing subsequences (LIS). Classic DP: maintain lengths and counts arrays. For each i, consider j < i; if nums[j] < nums[i], then update. Complexity O(n^2). We'll produce pseudocode lines accordingly.\n\nWe need to start with Start, End, Decision, etc. Provide step-by-step.\n\nLet's outline:\n\nStart\n→ Input array nums // get input\n→ Initialize n = length of nums\n→ Decision: if n == 0? // handle empty\n    Yes → Output 0 // no subsequences\n    No → continue\n\n→ Initialize arrays len[0..n-1] with 1 // each element is LIS of length 1\n→ Initialize arrays cnt[0..n-1] with 1 // count of LIS ending at each position\n\n→ For i from 0 to n-1 // outer loop\n    → For j from 0 to i-1 // inner loop\n        → Decision: if nums[j] < nums[i]? // can extend\n            Yes → Decision: if len[j] + 1 > len[i]? // longer\n                Yes → len[i] = len[j] + 1 // update length\n                       cnt[i] = cnt[j] // new count\n                No → Decision: if len[j] + 1 == len[i]? // equal length\n                    Yes → cnt[i] += cnt[j] // accumulate\n                    No → // nothing\n            No → // nothing\n\n→ After loops, find maxLen = max(len)\n\n→ Initialize total = 0\n→ For i from 0 to n-1\n    → Decision: if len[i] == maxLen?\n        Yes → total += cnt[i]\n        No → // nothing\n\n→ Output total // number of LIS\n\n→ End\n\nNeed to include comments after each line. Use arrow format.\n\nAlso include decisions indentation.\n\nMake sure to keep each line with virtual code and comment.\n\nLet's produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得輸入整數陣列  \n→ Decision: 若 nums 为空? // 先檢查陣列是否為空  \n  Yes → Output 0 // 空陣列沒有遞增子序列  \n  No → // 继续执行  \n\n→ Initialize n = length(nums) // 取得陣列長度  \n→ Initialize len[0…n-1] = 1 // 每個元素本身是一個長度為 1 的遞增子序列  \n→ Initialize cnt[0…n-1] = 1 // 每個元素對應的子序列個數為 1  \n\n→ For i = 0 to n-1 // 逐個遍歷每個元素作為結尾  \n  → For j = 0 to i-1 // 檢查前面所有元素  \n    → Decision: 若 nums[j] < nums[i]? // 可否延伸遞增子序列  \n      Yes → Decision: 若 len[j] + 1 > len[i]? // 更長的子序列  \n        Yes → len[i] = len[j] + 1 // 更新長度  \n         cnt[i] = cnt[j] // 新子序列個數等於前者  \n        No → Decision: 若 len[j] + 1 == len[i]? // 相同長度  \n          Yes → cnt[i] += cnt[j] // 累加個數  \n          No → // 無需處理  \n      No → // 不能延伸，跳過  \n\n→ Decision: 若 n == 0? // 再次檢查空陣列（可省略）  \n  Yes → // 直接返回 0  \n  No → // 繼續  \n\n→ Initialize maxLen = max(len) // 找出最大子序列長度  \n\n→ Initialize total = 0 // 用於累計所有最大長度的子序列個數  \n→ For i = 0 to n-1 // 遍歷所有結尾位置  \n  → Decision: 若 len[i] == maxLen? // 只計算最大長度的子序列  \n    Yes → total += cnt[i] // 累加個數  \n    No → // 跳過  \n\n→ Output total // 回傳最長遞增子序列的個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\n\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 0:\n            return 0\n\n        lengths = [1] * n          # lengths[i] = length of LIS ending at i\n        counts = [1] * n           # counts[i]   = number of LIS ending at i\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if lengths[j] + 1 > lengths[i]:\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                    elif lengths[j] + 1 == lengths[i]:\n                        counts[i] += counts[j]\n\n        longest = max(lengths)\n        return sum(c for l, c in zip(lengths, counts) if l == longest)\n\n\ndef parse_input(data: str) -> List[int]:\n    \"\"\"\n    Extract integer list from a string like 'nums = [1,3,5,4,7]'.\n    \"\"\"\n    # Find all integer numbers in the input\n    numbers = re.findall(r'-?\\d+', data)\n    return list(map(int, numbers))\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums = parse_input(data)\n    sol = Solution()\n    result = sol.findNumberOfLIS(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode686.json",
    "problem_index_in_file": 0,
    "title": "Repeated String Match",
    "description_snippet": "Given two strings a and b, return the minimum number of times you should repeat string a so that str...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps.\n\nWe need to produce algorithm: given a, b. Find minimal repeats of a such that b is substring. Approach: calculate minimal repeats needed based on lengths: ceil(len(b)/len(a)). Then we test repeated string of that many repeats and plus maybe one more repeat to cover overlap. So algorithm:\n\n- Compute minimal repeats = ceil(len(b) / len(a)).\n- Build string repeatedA = a repeated minimal repeats times.\n- If b in repeatedA: return minimal repeats.\n- Else: Append one more a to repeatedA (repeatedA += a). If b in repeatedA: return minimal repeats + 1.\n- Else: return -1.\n\nEdge cases: if b empty return 0? But not necessary.\n\nNow produce virtual code line by line, each line with explanation. Use structure Start, End, Decision. Provide arrow formatting.\n\nLet's craft:\n\nStart\n→ Step 1: 取得 a 與 b // 讀入兩個字串\n→ Step 2: 計算 a 的長度 lenA // 取得字串長度\n→ Step 3: 計算 b 的長度 lenB // 取得字串長度\n→ Step 4: 計算最小重複次數 repeats = ceil(lenB / lenA) // 估計至少需要的重複次數\n→ Step 5: 建立 repeatedA = a 重複 repeats 次 // 建立重複後的字串\n→ Decision: 是否存在 b 在 repeatedA 之內? // 檢查是否已符合條件\n    Yes → Step 6: 回傳 repeats // 最小重複次數符合\n    No  → Step 7: repeatedA += a // 再連接一次 a 以覆蓋可能的跨界情況\n        → Decision: 是否存在 b 在 updated repeatedA 之內? // 再次檢查\n            Yes → Step 8: 回傳 repeats + 1 // 若符合，回傳次數+1\n            No  → Step 9: 回傳 -1 // 無法成為子字串，返回 -1\nEnd\n\nWe might need to show Step 5: repeatedA = Repeat(a, repeats). In virtual code maybe \"→ Step 5: 重複 a repeats 次得到 repeatedA // 建立重複後的字串\" Good.\n\nMake sure each line ends with // explanation.\n\nAlso incorporate Ceil calculation. Use \"ceil\" function.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 a 與 b // 從輸入取得兩個字串  \n→ Step 2: 計算 lenA = 長度(a) // 取得字串 a 的長度  \n→ Step 3: 計算 lenB = 長度(b) // 取得字串 b 的長度  \n→ Step 4: 計算 repeats = ceil(lenB / lenA) // 估算至少需要重複的次數  \n→ Step 5: 建立 repeatedA = a 重複 repeats 次 // 產生重複後的字串  \n→ Decision: b 是否為 repeatedA 的子字串? // 檢查是否已滿足條件  \n    Yes → Step 6: 回傳 repeats // 最小重複次數即為答案  \n    No  → Step 7: repeatedA += a // 再連接一次 a 以覆蓋跨界情況  \n        → Decision: b 是否為 repeatedA 的子字串? // 再次檢查  \n            Yes → Step 8: 回傳 repeats + 1 // 若符合，回傳多一次的重複次數  \n            No  → Step 9: 回傳 -1 // 無法成為子字串，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef repeated_string_match(a: str, b: str) -> int:\n    \"\"\"\n    以最少次數重複字串 a，使得 b 成為其子字串。\n    若無法達成則回傳 -1。\n    \"\"\"\n    # 估計至少需要重複的次數\n    repeat = (len(b) + len(a) - 1) // len(a)\n    # 先建立重複後的字串\n    s = a * repeat\n    if b in s:\n        return repeat\n    # 可能還需要再多一次 a 以覆蓋跨界情況\n    s += a\n    if b in s:\n        return repeat + 1\n    return -1\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取兩個字串 a 與 b，輸出所需最少重複次數。\n    支援兩種輸入格式：\n      1. a = \"abcd\", b = \"cdabcdab\"\n      2. 兩行文字，分別為 a 與 b\n    \"\"\"\n    data = sys.stdin.read().strip()\n\n    # 嘗試匹配 \"a = \\\"...\\\", b = \\\"...\\\"\" 的格式\n    pattern = r'a\\s*=\\s*\"([^\"]*)\"\\s*,\\s*b\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, data)\n    if match:\n        a, b = match.group(1), match.group(2)\n    else:\n        # 其餘情況：按行分割或按空白分割\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            a, b = lines[0].strip(), lines[1].strip()\n        else:\n            parts = data.split()\n            if len(parts) >= 2:\n                a, b = parts[0], parts[1]\n            else:\n                # 若無法解析，直接退出\n                return\n\n    result = repeated_string_match(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"abcd\", b = \"cdabcdab\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = \"a\", b = \"aa\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode152.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product Subarray",
    "description_snippet": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for max product subarray. Use dynamic programming tracking max and min product up to i because negative flips. Outline steps: Start, input array, initialize currentMax,currentMin, globalMax. Iterate each element, update temp, compute max/min using element, prevMax, prevMin. Update globalMax. End. Provide line-by-line with arrow and comments. Ensure format as described. Use \"→\" arrow.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Provide decision blocks? Not necessary but can include if needed. But simple loop with updates. Use pseudocode steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數陣列 nums // 從使用者或測試資料取得整數列表  \n→ Step 2: 若 nums 為空，返回 0 // 空陣列無子陣列，產生的最大積為 0  \n→ Step 3: 初始化 currentMax ← nums[0] // 以第一個元素作為初始最大積  \n→ Step 4: 初始化 currentMin ← nums[0] // 以第一個元素作為初始最小積（負數可能產生更大正積）  \n→ Step 5: 初始化 globalMax ← nums[0] // 追蹤整個陣列中的最大積  \n→ Step 6: 從索引 1 開始遍歷 nums 的每個元素 num  \n→     Decision: 如果 num 為 0? // 零會重置積，直接考慮自身  \n→         Yes → currentMax ← 0 // 設置為 0，因為 0 作為子陣列的積  \n→         Yes → currentMin ← 0  \n→         Yes → globalMax ← max(globalMax, 0) // 0 可能是全陣列最大積  \n→         Yes → 繼續下個元素 // 跳過後續計算，直接進入下一輪  \n→     No → Step 7: 計算 tempMax ← currentMax * num // 先存前一個最大積乘新元素  \n→     No → Step 8: 計算 tempMin ← currentMin * num // 先存前一個最小積乘新元素  \n→     No → Step 9: 更新 currentMax ← max(num, tempMax, tempMin) // 新子陣列最大積  \n→     No → Step 10: 更新 currentMin ← min(num, tempMax, tempMin) // 新子陣列最小積  \n→     No → Step 11: globalMax ← max(globalMax, currentMax) // 更新全局最大積  \n→ End // 程式執行結束，globalMax 為所求最大子陣列積  \n→ Step 12: 回傳 globalMax // 將結果傳回呼叫者",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProduct(self, nums):\n        \"\"\"Return the maximum product of a contiguous subarray.\"\"\"\n        if not nums:\n            return 0\n\n        max_prod = min_prod = result = nums[0]\n\n        for num in nums[1:]:\n            # If num is negative, swapping helps keep track of min product\n            if num < 0:\n                max_prod, min_prod = min_prod, max_prod\n\n            # Update max and min products ending at current position\n            max_prod = max(num, max_prod * num)\n            min_prod = min(num, min_prod * num)\n\n            # Update global maximum\n            result = max(result, max_prod)\n\n        return result\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse the input string into a list of integers.\n    Handles inputs like:\n        nums = [2,3,-2,4]\n    or simply:\n        [2,3,-2,4]\n    \"\"\"\n    input_str = input_str.strip()\n    if input_str.startswith(\"nums\"):\n        # Remove 'nums' and the following '='\n        _, _, value_part = input_str.partition(\"=\")\n        input_str = value_part.strip()\n    # Use literal_eval for safe evaluation\n    try:\n        nums = ast.literal_eval(input_str)\n    except Exception:\n        # Fallback: try to split manually if eval fails\n        nums = [int(x) for x in input_str.replace(\"[\", \"\").replace(\"]\", \"\").split(\",\") if x.strip()]\n    return nums\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n\n    solver = Solution()\n    result = solver.maxProduct(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-2,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [-2,0,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode494.json",
    "problem_index_in_file": 0,
    "title": "Target Sum",
    "description_snippet": "You are given an integer array nums and an integer target.\n\nYou want to build an expression out of n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: Count number of ways to assign + or - to each number in array such that sum equals target. This is classic target sum DP/recursive. We need to output virtual code line by line, each line with virtual code and comment. Use arrow etc.\n\nWe need to produce something like:\n\nStart\n→ Step 1: 初始化 DP array with size 20001 (offset 10000) // offset to handle negative sums\n→ Step 2: DP[10000] = 1 // base case sum 0 has one way\n→ Decision: iterate nums\n  For each num\n    → Step: create newDP array of zeros\n    → Decision: iterate sum indices 0 to 20000\n      If DP[sum] > 0\n        → Step: newDP[sum+num] += DP[sum] // add plus\n        → Step: newDP[sum-num] += DP[sum] // add minus\n    → Step: DP = newDP\n→ Step: return DP[target+10000] // result\nEnd\n\nBut need arrow structure as per format. Use indentation.\n\nWe need to use \"Decision:\" for loops? The example uses Decision for conditions. For loops maybe use Step with loop notation. We can show loops explicitly as Step 1: For each num in nums // iterate array.\n\nLet's craft.\n\nMake sure each line has arrow symbol '→' for steps. For nested decision, indent.\n\nWe should incorporate explanation.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 offset = 10000 // 以 0 為中心，允許負數下標  \n→ Step 2: 建立 DP 陣列長度 20001，所有元素初始化為 0 // 代表各可能的總和  \n→ Step 3: DP[offset] = 1 // 基本情況：和為 0 有一種方式（不選任何符號）  \n→ Step 4: For each num in nums // 逐個處理陣列中的數字  \n  → Step 4.1: 建立 newDP 陣列長度 20001，所有元素初始化為 0 // 用於存放本輪計算結果  \n  → Step 4.2: For sumIdx from 0 to 20000 // 遍歷所有可能的總和索引  \n    → Decision: 如果 DP[sumIdx] > 0? // 只有存在方式才能擴展  \n      Yes → Step 4.2.1: newDP[sumIdx + num] += DP[sumIdx] // 加號組合  \n      Yes → Step 4.2.2: newDP[sumIdx - num] += DP[sumIdx] // 減號組合  \n      No  → // 沒有方式，跳過  \n  → Step 4.3: DP = newDP // 更新為本輪結果  \n→ Step 5: Return DP[target + offset] // 取得目標總和的計數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def findTargetSumWays(self, nums, target):\n        # dp[s] 表示能得到總和 s 的方式數量\n        dp = defaultdict(int)\n        dp[0] = 1\n\n        for num in nums:\n            next_dp = defaultdict(int)\n            for s, cnt in dp.items():\n                next_dp[s + num] += cnt\n                next_dp[s - num] += cnt\n            dp = next_dp\n\n        return dp[target]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 輸入格式示例: \"nums = [1,1,1,1,1], target = 3\"\n    # 將關鍵字去除後使用 eval 解析為 (nums, target)\n    cleaned = raw.replace(\"nums = \", \"\").replace(\"target = \", \"\")\n    nums, target = eval(cleaned)\n\n    solution = Solution()\n    result = solution.findTargetSumWays(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1], target = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode447.json",
    "problem_index_in_file": 0,
    "title": "Number of Boomerangs",
    "description_snippet": "You are given n points in the plane that are all distinct, where points[i] = [x_i, y_i]. A boomerang...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. Use approach: For each point i, compute distances to others, count frequency, sum f*(f-1) for each distance. Count total. We output steps line by line.\n\nLet's produce code steps:\n\nStart\n→ Step 1: 初始化总计 boomerangs = 0\n→ Step 2: 循环 i 从 0 到 n-1\n    → Step 3: 创建空字典 distanceCount\n    → Step 4: 循环 j 从 0 到 n-1\n        → Decision: j 是否等于 i?\n            Yes → Step 5: 跳过\n            No  → Step 6: 计算距离 squared d = (x_i - x_j)^2 + (y_i - y_j)^2\n                 → Step 7: 统计 distanceCount[d]++\n    → Step 8: 对每个距离计数 f in distanceCount.values\n        → Decision: f 是否大于 1?\n            Yes → Step 9: boomerangs += f * (f - 1)\n            No  → Skip\n→ End: 返回 boomerangs\n\nWe need each line with explanation. Use arrows and decisions. Let's produce.\n\nWe should include indentations for decision branches. Use the arrow format: Yes → ... No → ... For each branch.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 totalBoomerangs 為 0 // 用來儲存所有符合條件的三元組數量  \n→ Step 2: 循環遍歷每一個點 i (0 ≤ i < n) // 以每個點作為固定點  \n  → Step 3: 創建空字典 distanceCount // 用於記錄從點 i 到其他點的距離出現次數  \n  → Step 4: 循環遍歷所有點 j (0 ≤ j < n) // 計算從點 i 到點 j 的距離  \n    → Decision: j 是否等於 i? // 同一點不算距離  \n      Yes → Step 5: 跳過這次迭代 // 當 j == i 時不進行任何操作  \n      No  → Step 6: 計算距離平方 d = (x_i - x_j)^2 + (y_i - y_j)^2 // 以平方避免浮點誤差  \n       → Step 7: 更新 distanceCount[d] = distanceCount.get(d, 0) + 1 // 記錄此距離出現次數  \n  → Step 8: 遍歷 distanceCount 的每個距離值 f // 為每個相同距離的點組合計算  \n    → Decision: f 是否大於 1? // 需要至少兩個點才能形成兩條相等距離的邊  \n      Yes → Step 9: totalBoomerangs += f * (f - 1) // 對於 f 個點，排列組合為 f*(f-1)  \n      No  → Step 10: 不做任何事 // f <= 1 時不產生任何布爾揚  \n→ End // 程式結束，回傳結果  \n  → Step 11: 返回 totalBoomerangs // 結果即為所有 (i, j, k) 的數量  \n\n（以上虛擬碼逐行展示了完整的布爾揚計算流程，並配備簡短解釋以利理解。）",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfBoomerangs(self, points):\n        total = 0\n        for x1, y1 in points:\n            dist_count = defaultdict(int)\n            for x2, y2 in points:\n                if x1 != x2 or y1 != y2:\n                    d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n                    dist_count[d] += 1\n            for count in dist_count.values():\n                total += count * (count - 1)\n        return total\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 去除可能的「points =」前綴\n    if raw_input.lower().startswith(\"points\"):\n        eq_index = raw_input.find(\"=\")\n        if eq_index != -1:\n            raw_input = raw_input[eq_index + 1:].strip()\n    # 解析為 Python 資料結構\n    try:\n        points = ast.literal_eval(raw_input)\n    except Exception:\n        # 如果解析失敗，輸出 0\n        print(0)\n        sys.exit(0)\n\n    # 檢查輸入是否為合法的列表形式\n    if not isinstance(points, list):\n        print(0)\n        sys.exit(0)\n\n    # 進行計算\n    solution = Solution()\n    result = solution.numberOfBoomerangs(points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[0,0],[1,0],[2,0]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,1],[2,2],[3,3]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "points = [[1,1]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode384.json",
    "problem_index_in_file": 0,
    "title": "Shuffle an Array",
    "description_snippet": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, not actual code. Steps to design algorithm. We need to produce steps for class, constructor, reset, shuffle, using Fisher-Yates shuffle. Provide explanation per line.\n\nWe need to structure with Start, End, Decision, etc.\n\nWe need to be \"逐行\" and each line \"虛擬碼步驟\" + space + \"// explanation\". Use arrow for steps. Must use virtual code arrows: →, Yes →, No →, Decision:. Use Start, End. So produce flow.\n\nWe should include steps for class initialization, storing original array, copy, resetting, shuffling.\n\nLet's produce lines:\n\nStart\n→ Step 1: 建立 Solution 物件並儲存原始陣列 nums 為 original // 儲存原始資料\n→ Step 2: 建立可變陣列 current 為 original 的複製 // 用於 shuffle\n→ Step 3: 定義 reset() // 重新回到原始順序\n→ Decision: 若呼叫 reset() // 何時重設\n    Yes → Step 4: current ← original 的複製 // 重新複製\n    No  → (none)\n→ Step 5: reset() 回傳 current // 回傳重置後陣列\n→ Step 6: 定義 shuffle() // 隨機打亂\n→ Step 7: 對 i 從 current.length-1 到 1 迴圈 // Fisher-Yates\n→ Decision: 產生隨機索引 j 在 0..i\n    Yes → Step 8: 交換 current[i] 與 current[j] // 交換\n    No  → (none)\n→ Step 9: 結束迴圈\n→ Step 10: shuffle() 回傳 current // 回傳打亂後陣列\nEnd\n\nBut need to include decisions for loops etc. Use Decision: if i > 0? or for loop. Use arrow for each step. Also include \"End\".\n\nLet's write in required format: each line as \"虛擬碼步驟 // 解釋\".\n\nLet's do:\n\nStart // 程式開始執行\n→ Step 1: 建立 Solution 物件並儲存原始陣列 nums 為 original // 儲存原始資料\n→ Step 2: 建立 current 為 original 的深複製 // 用於 shuffle\n→ Step 3: 定義 reset() 方法 // 重置功能\n→ Decision: 是否呼叫 reset()? // 判斷\n    Yes → Step 4: current ← original 的深複製 // 重新設定為原始順序\n    No  → (無操作)\n→ Step 5: reset() 回傳 current // 回傳重置後陣列\n→ Step 6: 定義 shuffle() 方法 // 隨機打亂\n→ Step 7: 對 i 從 current.length-1 下降到 1 執行迴圈 // Fisher‑Yates 迴圈\n→ Decision: 產生隨機整數 j 在 [0, i] 範圍內 // 取得交換索引\n    Yes → Step 8: 交換 current[i] 與 current[j] // 交換兩個元素\n    No  → (無操作)\n→ Step 9: 迴圈結束 // 完成所有交換\n→ Step 10: shuffle() 回傳 current // 回傳隨機排列\nEnd // 程式執行結束\n\nEnsure each line has virtual code and explanation separated by space? The requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So after code we need space then //.\n\nThus \"Start // 程式開始執行\". Good.\n\nFor arrow lines we use \"→\". For Decision lines we use \"Decision:\". For indented lines under decision we may indent or keep same.\n\nBetter to include indentation for readability but still maintain same format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Solution 物件並儲存原始陣列 nums 為 original // 儲存原始資料  \n→ Step 2: 建立 current 為 original 的深複製 // 用於 shuffle  \n→ Step 3: 定義 reset() 方法 // 重置功能  \n→ Decision: 是否呼叫 reset()? // 判斷是否需要重置  \n  Yes → Step 4: current ← original 的深複製 // 重新設定為原始順序  \n  No  → // 無操作  \n→ Step 5: reset() 回傳 current // 回傳重置後陣列  \n→ Step 6: 定義 shuffle() 方法 // 隨機打亂  \n→ Step 7: 對 i 從 current.length-1 下降到 1 執行迴圈 // Fisher‑Yates 迴圈  \n  Decision: 產生隨機整數 j 在 [0, i] 範圍內 // 取得交換索引  \n   Yes → Step 8: 交換 current[i] 與 current[j] // 交換兩個元素  \n   No  → // 無操作  \n→ Step 9: 迴圈結束 // 完成所有交換  \n→ Step 10: shuffle() 回傳 current // 回傳隨機排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)          # 原始陣列的複製\n\n    def reset(self):\n        return list(self.original)          # 回傳原始順序\n\n    def shuffle(self):\n        arr = list(self.original)           # 先複製原始陣列\n        n = len(arr)\n        for i in range(n):                 # Fisher‑Yates 洗牌\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\nif __name__ == \"__main__\":\n    s = sys.stdin.read().strip()\n    if not s:\n        sys.exit(0)\n\n    # 把輸入包成一個 tuple 以便解析\n    data = ast.literal_eval('(' + s + ')')\n    commands, args = data\n\n    outputs = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(arg[0])\n            outputs.append(None)           # Solution 建構子不回傳值\n        elif cmd == \"reset\":\n            outputs.append(obj.reset())\n        elif cmd == \"shuffle\":\n            outputs.append(obj.shuffle())\n        else:\n            outputs.append(None)           # 未知指令\n\n    print(json.dumps(outputs))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "success": true,
          "output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode405.json",
    "problem_index_in_file": 0,
    "title": "Convert a Number to Hexadecimal",
    "description_snippet": "Given a 32-bit integer num, return a string representing its hexadecimal representation. For negativ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for converting a 32-bit integer to hex string, handling negative via two's complement, no leading zeros except zero, lowercase. No built-in conversion. Provide step-by-step pseudocode lines with comments.\n\nWe need to use virtual code constructs: Start, Decision, arrows. We should outline algorithm: If num==0 return \"0\". else compute hex digits: For negative, treat as unsigned 32-bit via masking 0xFFFFFFFF. Then loop: while n>0: digit = n & 0xF; map to char; prepend or build string reversed then reverse. Avoid leading zeros automatically by loop condition. After loop, reverse string. For negative, we must mask first.\n\nLet's produce lines. Use Start, Decision: If num==0? etc.\n\nWe'll produce lines like:\n\nStart // 程式開始\n→ Step 1: 檢查 num 是否等於 0 // 判斷是否為 0\n    Yes → Step 2: 輸出字串 '0' // 回傳 \"0\"\n    No → Step 3: 若 num 為負數，將其轉成 32 位無符號整數 // 處理負數\n→ Step 4: 定義字元對照表 \"0123456789abcdef\" // 用於映射\n→ Step 5: 初始化空字串 hex // 存放結果\n→ Step 6: 進行 while n>0 // 逐位處理\n    → Step 7: 取最低 4 位：digit = n & 0xF // 提取十六進位位元\n    → Step 8: 取得對應字符：char = map[digit] // 對應字元\n    → Step 9: 將字符加入 hex 前面或後面 // 依此決定順序\n    → Step 10: 右移 4 位：n = n >> 4 // 移除已處理位元\n→ Decision: 迴圈結束? // n 是否為 0\n    No → 回到 Step 6\n→ Step 11: 如果使用的是後插入方式，則將 hex 反轉 // 確保順序正確\n→ End // 完成\n\nBut need to output one line per step, with \"→\" arrow, and comments.\n\nLet's produce final answer with lines. Ensure each line includes a comment after //.\n\nLet's produce maybe 15 lines.\n\nWe need to include decision arrow \"Decision:\" lines with Yes →, No →. Use indent to show nested steps.\n\nLet's craft:\n\n```\nStart // 程式開始執行\n→ Decision: num 等於 0? // 判斷是否為 0\n    Yes → Step: 輸出 '0' // 回傳 \"0\"\n    No  → Step: 若 num 為負數，將 num 轉成 32 位無符號整數 // 處理負數\n→ Step: 定義字元對照表 hexMap = \"0123456789abcdef\" // 用於轉換\n→ Step: 初始化 n = num // 以 32 位整數開始處理\n→ Step: 初始化空字串 result // 存放轉換後的字元\n→ Decision: n 大於 0? // 進行位元循環\n    Yes →\n        → Step: digit = n & 0xF // 取得最低 4 位\n        → Step: char = hexMap[digit] // 對應十六進位字元\n        → Step: result = char + result // 將字元加到前面\n        → Step: n = n >> 4 // 右移 4 位，移除已處理位元\n        → Decision: n 大於 0? // 繼續循環\n            Yes → 回到 上層決策\n            No  → Exit 循環\n    No  → // n 為 0，結束循環\n→ End // 程式執行結束\n```\n\nWe need to be consistent: use \"Decision:\" for decisions, indent with Yes→ and No→.\n\nAlso need to consider for negative: we need to mask with 0xFFFFFFFF. So maybe Step: n = num if num >=0 else num & 0xFFFFFFFF. Let's refine.\n\nLet's write:\n\n```\nStart // 程式開始執行\n→ Decision: num 等於 0? // 判斷是否為 0\n    Yes → Step: 輸出 '0' // 回傳 \"0\"\n    No  → Step: n = (num < 0) ? (num & 0xFFFFFFFF) : num // 轉成 32 位無符號整數\n→ Step: 定義字元對照表 hexMap = \"0123456789abcdef\" // 用於轉換\n→ Step: 初始化空字串 result // 存放轉換後的字元\n→ Decision: n 大於 0? // 進行位元循環\n    Yes →\n        → Step: digit = n & 0xF // 取得最低 4 位\n        → Step: char = hexMap[digit] // 對應十六進位字元\n        → Step: result = char + result // 將字元加到前面\n        → Step: n = n >> 4 // 右移 4 位，移除已處理位元\n        → Decision: n 大於 0? // 繼續循環\n            Yes → 回到 上層決策\n            No  → Exit 循環\n    No  → // n 為 0，結束循環\n→ End // 程式執行結束\n```\n\nWe should include explanation for each line. Provide each line separately. Let's output lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: num 等於 0? // 判斷輸入值是否為 0  \n Yes → Step: 輸出 '0' // 若為 0，直接回傳字串 \"0\"  \n No  → Step: n = (num < 0) ? (num & 0xFFFFFFFF) : num // 對負數取 32‑位兩補碼，正數保持不變  \n→ Step: 定義字元對照表 hexMap = \"0123456789abcdef\" // 用於把 0~15 映射為十六進位字元  \n→ Step: 初始化空字串 result // 用於累積轉換後的字元  \n→ Decision: n 大於 0? // 開始處理每一個 4 位區塊  \n Yes →  \n  → Step: digit = n & 0xF // 取最低 4 位（即 16 進位位元）  \n  → Step: char = hexMap[digit] // 取得對應字元  \n  → Step: result = char + result // 把新字元加到前面，保持順序  \n  → Step: n = n >> 4 // 右移 4 位，移除已處理的位元  \n  → Decision: n 大於 0? // 判斷是否還有未處理的位元  \n   Yes → 回到 上層決策 // 重新進入循環  \n   No  → Exit 循環 // 所有位元已處理  \n No  → // n 為 0，已完成所有轉換  \n→ End // 程式執行結束，result 為最終的十六進位字串",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def toHex(self, num: int) -> str:\n        # 如果是 0，直接回傳 \"0\"\n        if num == 0:\n            return \"0\"\n        # 十六進位對應字元表\n        hex_chars = \"0123456789abcdef\"\n        # 負數使用 32 位兩補碼表示\n        if num < 0:\n            num += 1 << 32  # 等同於 num += 2**32\n        res = \"\"\n        # 循環取得每個 4 位的十六進位位元\n        while num > 0:\n            digit = num & 0xF          # 取得最低 4 位\n            res = hex_chars[digit] + res  # 前置，保持順序\n            num >>= 4                   # 右移 4 位，移除已處理的位元\n        return res\n\ndef main() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從字串中尋找第一個整數（可能是負數）\n    match = re.search(r'[-]?\\d+', data)\n    if not match:\n        # 如果找不到數字，則不做任何輸出\n        return\n    num_str = match.group(0)\n    num = int(num_str)\n    sol = Solution()\n    result = sol.toHex(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 26",
          "expected_output": "1a",
          "success": true,
          "output": "1a"
        },
        {
          "example_index": 1,
          "input": "num = -1",
          "expected_output": "ffffffff",
          "success": true,
          "output": "ffffffff"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode722.json",
    "problem_index_in_file": 0,
    "title": "Remove Comments",
    "description_snippet": "Given a C++ program, remove comments from it. The program source is an array of strings source where...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for removing comments. Should be line by line. Provide explanation per line. Use Start, End, Decision, arrow. Should not output actual code. Provide pseudocode only. Ensure each line includes virtual code step and comment. We'll need loops over lines and characters. Track inBlock boolean. For each line, process chars. Use index i. We'll use while loops. Build output lines. Skip empty. Provide steps.\n\nLet's craft.\n\nStart\n→ Initialize result array // store lines without comments\n→ Initialize inBlock = False // flag whether inside block comment\n→ For each line in source // iterate over each source line\n    → Initialize i = 0 // index in current line\n    → Initialize cur = \"\" // current processed characters\n    → While i < length(line) // process each character\n        → Decision: if inBlock? // check if inside block comment\n            Yes → Decision: if line[i:i+2] == \"*/\"? // check end of block\n                Yes → inBlock = False // exit block comment\n                → i += 2 // skip closing\n                No  → i += 1 // skip current char inside block\n            No  → Decision: if line[i:i+2] == \"//\"? // line comment start\n                Yes → Break // rest of line ignored\n                No  → Decision: if line[i:i+2] == \"/*\"? // block comment start\n                    Yes → inBlock = True // enter block comment\n                    → i += 2 // skip opening\n                    No  → cur += line[i] // keep current char\n                    → i += 1\n    → Decision: if cur trimmed not empty? // after processing line\n        Yes → Append cur to result // add non-empty line\n        No  → Do nothing // skip empty line\nEnd // finished processing\n\nNeed each line in output with arrow and comment.\n\nEnsure each line starts with \"→\" except Start and End? Use arrow for steps after Start? In example they used \"→\" for each step. So we should use \"→\" before each line except Start and End. But the example had \"→\" before each step. We'll follow.\n\nWe'll produce lines accordingly.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 result = [] // 用來儲存去除註解後的程式碼行\n→ Step 2: 初始化 inBlock = False // 標記目前是否在區塊註解內\n→ Decision: 迭代 source 的每一行？ // 遍歷原始程式碼的每一行\n    Yes →\n        → Step 3: 設定 i = 0 // 目前行的索引\n        → Step 4: 設定 cur = \"\" // 用來收集當前行的有效字元\n        → While i < length(line) // 逐字元處理\n            → Decision: if inBlock? // 判斷是否已進入區塊註解\n                Yes →\n                    → Decision: if line[i:i+2] == \"*/\"? // 檢查是否結束區塊註解\n                        Yes →\n                            → Step 5: inBlock = False // 離開區塊註解\n                            → Step 6: i += 2 // 跳過 \"*/\"\n                        No →\n                            → Step 7: i += 1 // 在區塊內忽略所有字元\n                No →\n                    → Decision: if line[i:i+2] == \"//\"? // 判斷是否為行註解開始\n                        Yes →\n                            → Step 8: Break // 跳出 while，忽略此行剩餘字元\n                        No →\n                            → Decision: if line[i:i+2] == \"/*\"? // 判斷是否為區塊註解開始\n                                Yes →\n                                    → Step 9: inBlock = True // 進入區塊註解\n                                    → Step 10: i += 2 // 跳過 \"/*\"\n                                No →\n                                    → Step 11: cur += line[i] // 將字元加入有效內容\n                                    → Step 12: i += 1 // 進一步處理下一字元\n        → Decision: if cur.trim() != \"\"? // 這一行處理完後是否還有有效內容\n            Yes →\n                → Step 13: result.append(cur) // 將非空行加入結果\n            No →\n                → Step 14: 何不做 // 空行不加入結果\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n\n        for line in source:\n            i = 0\n            new_line = []\n            while i < len(line):\n                if not in_block:\n                    # 检测块注释开始\n                    if i + 1 < len(line) and line[i] == '/' and line[i + 1] == '*':\n                        in_block = True\n                        i += 2\n                        continue\n                    # 检测行注释开始\n                    if i + 1 < len(line) and line[i] == '/' and line[i + 1] == '/':\n                        break\n                else:\n                    # 检测块注释结束\n                    if i + 1 < len(line) and line[i] == '*' and line[i + 1] == '/':\n                        in_block = False\n                        i += 2\n                        continue\n                # 不是注释，写入结果\n                if not in_block:\n                    new_line.append(line[i])\n                i += 1\n            # 只有非空行才加入最终结果\n            if new_line and not in_block:\n                res.append(\"\".join(new_line))\n        return res\n\nif __name__ == \"__main__\":\n    # 读取所有输入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 去掉可能存在的前缀 \"source =\"\n    if raw_input.lower().startswith(\"source\"):\n        try:\n            _, expr = raw_input.split(\"=\", 1)\n        except ValueError:\n            expr = raw_input\n    else:\n        expr = raw_input\n\n    # 解析列表字符串为 Python 列表\n    try:\n        source = ast.literal_eval(expr.strip())\n    except Exception:\n        # 若解析失败，直接退出\n        sys.exit()\n\n    # 调用解决方案\n    solution = Solution()\n    result = solution.removeComments(source)\n\n    # 输出结果，使用 Python 列表表示方式\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]",
          "expected_output": "[\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]",
          "success": true,
          "output": "['int main()', '{ ', '  ', 'int a, b, c;', 'a = b + c;', '}']"
        },
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"ab\"]'\nGot (Norm):      '[\"b\"]'\n--- (Raw) ---\nRaw Expected: '[\"ab\"]'\nRaw Got:      \"['b']\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode292.json",
    "problem_index_in_file": 0,
    "title": "Nim Game",
    "description_snippet": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for Nim game: return true if you can win, assuming optimal play. It's the standard Nim variant: can win if n % 4 != 0.\n\nWe produce a virtual code starting with Start, then input n, then Decision: if n % 4 == 0? Yes → Step: return false else return true. Then End.\n\nWe must use arrow syntax. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: n // 取得堆中石子總數  \n→ Decision: 是否 n % 4 == 0? // 判斷石子數能否被 4 整除  \n  Yes → Return false // 若能整除，對手可以始終讓你面對 4 的倍數，最終你輸  \n  No  → Return true  // 若不是 4 的倍數，你可先取走恰當數量使剩餘為 4 的倍數，最終取走最後一枚  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canWinNim(self, n: int) -> bool:\n        \"\"\"\n        在 Nim 遊戲中，如果石子數是 4 的倍數，先手必輸；否則先手必勝。\n        \"\"\"\n        return n % 4 != 0\n\ndef main() -> None:\n    # 讀取全部輸入\n    data = sys.stdin.read()\n    # 從輸入中提取第一個整數\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n\n    sol = Solution()\n    result = sol.canWinNim(n)\n    # 根據題目要求輸出小寫字串\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode263.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number",
    "description_snippet": "An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.\n\nGiv...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanations. The algorithm: check if n>0 else false. Then divide by 2 while divisible, then 3, then 5. If remaining==1 true else false. Need to follow format: Start, steps, Decision, End.\n\nLet's craft steps:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得使用者輸入的正整數\n→ Decision: 如果 n <= 0? // 判斷是否為正整數\n    No → Step 2: 回傳 false // 非正整數不是醜數\n    Yes → Step 3: 設定變數 num = n // 用於後續除法\n→ Decision: num 可被 2 整除? // 檢查是否有 2 為因子\n    Yes → Step 4: num = num / 2 // 刪除 2 的因子\n    No → Decision: num 可被 3 整除? // 繼續檢查 3\n        Yes → Step 5: num = num / 3 // 刪除 3 的因子\n        No → Decision: num 可被 5 整除? // 繼續檢查 5\n            Yes → Step 6: num = num / 5 // 刪除 5 的因子\n            No → Decision: num > 1? // 是否還剩餘其他質因子\n                Yes → Step 7: 回傳 false // 有其他質因子，非醜數\n                No  → Step 8: 回傳 true // 只剩 1，為醜數\nEnd // 程式執行結束\n\nBut we must reflect loops: we can do while loops. The format requires arrow and decision lines, but we can embed loops. Could represent repeated division as Decision: num % 2 == 0? and then loop back. But the given format: arrow lines. We can represent loops with Decision and arrow back. Provide structure like:\n\n→ Decision: num % 2 == 0? // \n    Yes → Step: num = num / 2 // \n        → Decision: num % 2 == 0? // loop back\n        ...\n\nBut easier: we can simply show step \"除以 2 直到不能除\" with explanation. Use Step.\n\nLet's design:\n\nStart\n→ Step 1: 輸入整數 n\n→ Decision: n <= 0? \n    No → Step 2: 回傳 false\n    Yes → Step 3: 設定 num = n\n→ Step 4: 重複 while num % 2 == 0: num = num / 2 // 移除所有 2 的因子\n→ Step 5: 重複 while num % 3 == 0: num = num / 3 // 移除所有 3 的因子\n→ Step 6: 重複 while num % 5 == 0: num = num / 5 // 移除所有 5 的因子\n→ Decision: num == 1? // 是否剩下 1\n    Yes → Step 7: 回傳 true\n    No  → Step 8: 回傳 false\nEnd\n\nNeed to add explanations per line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得使用者輸入的正整數  \n→ Decision: n <= 0? // 判斷是否為正整數  \n    No → Step 2: 回傳 false // 非正整數不是醜數  \n    Yes → Step 3: 設定變數 num = n // 用於後續除法  \n→ Step 4: 重複 while num % 2 == 0: num = num / 2 // 刪除所有 2 的因子  \n→ Step 5: 重複 while num % 3 == 0: num = num / 3 // 刪除所有 3 的因子  \n→ Step 6: 重複 while num % 5 == 0: num = num / 5 // 刪除所有 5 的因子  \n→ Decision: num == 1? // 檢查是否已經沒有其他質因子  \n    Yes → Step 7: 回傳 true // 只剩 1，為醜數  \n    No  → Step 8: 回傳 false // 還有其他質因子，非醜數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_ugly(n: int) -> bool:\n    \"\"\"判斷 n 是否為醜數（只能由質因子 2、3、5 組成）。\"\"\"\n    if n <= 0:\n        return False\n    for p in (2, 3, 5):\n        while n % p == 0:\n            n //= p\n    return n == 1\n\ndef main() -> None:\n    # 讀取整個輸入，並抽取第一個整數\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n\n    result = is_ugly(n)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode78.json",
    "problem_index_in_file": 0,
    "title": "Subsets",
    "description_snippet": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line-by-line with explanations. Input: array of unique integers. Need to return all subsets. Classic backtracking or bitmask. We can choose backtracking recursion. Provide Start, Decision, etc.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow arrows.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義 function generateSubsets(nums) // 主函式，接收數組\n→ Decision: nums 是否為空? // 檢查輸入是否為空\n    Yes → Step 2: 返回 [[]] // 空集合的子集是只有空集\n    No  → Step 3: 初始化 result = [] // 存放所有子集\n→ Step 4: 定義 recursive function backtrack(start, path) // backtrack 參數 start 與目前路徑\n    → Step 5: 將 path 複製並加入 result // 每次遞歸都將目前子集加入結果\n    → Decision: start 是否小於 nums.length? // 確保有元素可選\n        Yes → Step 6: 從 i = start 到 nums.length-1 迴圈\n            → Step 7: path.append(nums[i]) // 選擇當前元素\n            → Step 8: backtrack(i+1, path) // 進一步遞歸\n            → Step 9: path.pop() // 回溯，移除最後選擇\n        No  → End // 不再有元素可選\n→ Step 10: 呼叫 backtrack(0, []) // 從索引0開始，空路徑\n→ Step 11: 返回 result // 回傳所有子集\nEnd // 程式結束\n\nNeed to ensure each line with arrow indentation maybe. Use \"→\" for steps, \"Decision:\" for decisions. Provide \"Yes →\" and \"No →\" inside decision.\n\nAlso need \"Start\" and \"End\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 function generateSubsets(nums) // 主函式，接收數組  \n→ Decision: nums 是否為空? // 檢查輸入是否為空  \n Yes → Step 2: 返回 [[]] // 空集合的子集是只有空集  \n No  → Step 3: 初始化 result = [] // 存放所有子集  \n→ Step 4: 定義 recursive function backtrack(start, path) // 回溯函式，start 為下一個可選元素索引，path 為目前子集  \n → Step 5: 將 path 複製並加入 result // 每次遞歸都將目前子集加入結果  \n → Decision: start 是否小於 nums.length? // 確保還有元素可選  \n  Yes → Step 6: 從 i = start 到 nums.length-1 迴圈  \n   → Step 7: path.append(nums[i]) // 選擇當前元素  \n   → Step 8: backtrack(i+1, path) // 進一步遞歸  \n   → Step 9: path.pop() // 回溯，移除最後選擇  \n  No  → End // 不再有元素可選  \n→ Step 10: 呼叫 backtrack(0, []) // 從索引 0 開始，空路徑  \n→ Step 11: 返回 result // 回傳所有子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\ndef parse_input(data):\n    \"\"\"Parse input of the form 'nums = [1,2,3]' or just '[1,2,3]'.\"\"\"\n    data = data.strip()\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    # Safe eval for list literal\n    try:\n        nums = eval(expr, {\"__builtins__\": None}, {})\n    except Exception:\n        nums = []\n    return nums\n\ndef format_output(subsets):\n    \"\"\"Format the list of subsets without spaces after commas.\"\"\"\n    subset_strs = []\n    for subset in subsets:\n        if not subset:\n            subset_strs.append('[]')\n        else:\n            subset_strs.append('[' + ','.join(map(str, subset)) + ']')\n    return '[' + ','.join(subset_strs) + ']'\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    sol = Solution()\n    result = sol.subsets(nums)\n    print(format_output(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[],[0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode423.json",
    "problem_index_in_file": 0,
    "title": "Reconstruct Original Digits from English",
    "description_snippet": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given string s containing letters forming words \"zero\", \"one\", \"two\", \"three\", ... \"nine\", but out of order. Need to output digits in ascending order. Classic Leetcode problem 423. Approach: count letters, use unique letters to identify digits. Steps: initialize count array for 26 letters. Count letters from s. Then for each digit in order of unique letters: \"z\" for zero, \"w\" for two, \"u\" for four, \"x\" for six, \"g\" for eight, then \"o\" for one, \"h\" for three, \"f\" for five, \"s\" for seven, \"i\" for nine. Build result string accordingly. Then sort digits ascending (since we added in order maybe not sorted? Actually order we process yields ascending digits? Not exactly: order zero, two, four, six, eight, one, three, five, seven, nine. That's not sorted. So final string should be sorted. We could accumulate counts per digit then build sorted string.\n\nSo produce virtual steps: Start, Count letters, Decision steps? Not many decisions; just loops. Provide steps line by line with arrow. Provide explanation. No actual code.\n\nLet's craft lines:\n\nStart // Start program\n\n→ Step 1: Initialize array letterCount[26] = 0 // 26 letter counts\n\n→ Step 2: For each char c in s: letterCount[c - 'a']++ // count letters\n\n→ Step 3: Initialize array digitCount[10] = 0 // count of each digit\n\n→ Step 4: For each digit with unique identifying letter: // process unique letters to find counts\n\n    4.1 → digitCount[0] = letterCount['z' - 'a'] // 'z' only in \"zero\"\n\n    4.2 → digitCount[2] = letterCount['w' - 'a'] // 'w' only in \"two\"\n\n    4.3 → digitCount[4] = letterCount['u' - 'a'] // 'u' only in \"four\"\n\n    4.4 → digitCount[6] = letterCount['x' - 'a'] // 'x' only in \"six\"\n\n    4.5 → digitCount[8] = letterCount['g' - 'a'] // 'g' only in \"eight\"\n\n    4.6 → digitCount[1] = letterCount['o' - 'a'] - digitCount[0] - digitCount[2] - digitCount[4] // 'o' appears in one, zero, two, four\n\n    4.7 → digitCount[3] = letterCount['h' - 'a'] - digitCount[8] // 'h' in three and eight\n\n    4.8 → digitCount[5] = letterCount['f' - 'a'] - digitCount[4] // 'f' in five and four\n\n    4.9 → digitCount[7] = letterCount['s' - 'a'] - digitCount[6] // 's' in seven and six\n\n    4.10 → digitCount[9] = letterCount['i' - 'a'] - digitCount[5] - digitCount[6] - digitCount[8] // 'i' in nine, five, six, eight\n\n→ Step 5: Initialize result string empty\n\n→ Step 6: For digit from 0 to 9: repeat digitCount[digit] times, append digit character to result // build sorted digits\n\n→ End // Output result\n\nBut we also need decision structure? The specification says use Decision:, but not mandatory if not needed. We can add a Decision to check if letterCount >0 etc.\n\nLet's produce final virtual code with arrows. Use indentation for nested steps. Use Start and End.\n\nMake sure each line has virtual code step and // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化字母計數陣列 letterCount[26] ← 0 // 用來統計每個字母出現次數\n→ Step 2: 逐字元遍歷輸入字串 s：\n    → For char c in s：\n        → letterCount[c - 'a'] ← letterCount[c - 'a'] + 1 // 以字母索引更新計數\n→ Step 3: 初始化數字計數陣列 digitCount[10] ← 0 // 用來統計每個數字出現次數\n→ Step 4: 根據唯一識別字母確定各數字個數：\n    → digitCount[0] ← letterCount['z' - 'a'] // 'z' 只出現在 \"zero\"\n    → digitCount[2] ← letterCount['w' - 'a'] // 'w' 只出現在 \"two\"\n    → digitCount[4] ← letterCount['u' - 'a'] // 'u' 只出現在 \"four\"\n    → digitCount[6] ← letterCount['x' - 'a'] // 'x' 只出現在 \"six\"\n    → digitCount[8] ← letterCount['g' - 'a'] // 'g' 只出現在 \"eight\"\n    → digitCount[1] ← letterCount['o' - 'a'] - digitCount[0] - digitCount[2] - digitCount[4] // 'o' 同時出現在 one, zero, two, four\n    → digitCount[3] ← letterCount['h' - 'a'] - digitCount[8] // 'h' 同時出現在 three, eight\n    → digitCount[5] ← letterCount['f' - 'a'] - digitCount[4] // 'f' 同時出現在 five, four\n    → digitCount[7] ← letterCount['s' - 'a'] - digitCount[6] // 's' 同時出現在 seven, six\n    → digitCount[9] ← letterCount['i' - 'a'] - digitCount[5] - digitCount[6] - digitCount[8] // 'i' 同時出現在 nine, five, six, eight\n→ Step 5: 初始化結果字串 result ← \"\" // 用於儲存最終升序的數字\n→ Step 6: 依數字 0 至 9 迭代：\n    → For digit from 0 to 9：\n        → For count from 1 to digitCount[digit]：\n            → result ← result + digit // 把相應數字加入結果，保持升序\n→ End // 程式執行結束，結果為升序排列的數字字串",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        count = Counter(s)\n        out = {}\n\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n\n        res = [k * out[k] for k in sorted(out.keys())]\n        return ''.join(res)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 嘗試從輸入中提取雙引號內的字串，若無則直接使用整個輸入\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        s = raw_input\n\n    solution = Solution()\n    result = solution.originalDigits(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "success": true,
          "output": "012"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "success": true,
          "output": "45"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode479.json",
    "problem_index_in_file": 0,
    "title": "Largest Palindrome Product",
    "description_snippet": "Given an integer n, return the largest palindromic integer that can be represented as the product of...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for algorithm: largest palindrome product of two n-digit numbers modulo 1337. Standard problem: find largest palindrome from multiplication of two n-digit numbers. Approach: iterate from largest n-digit number downwards for both, break when found. Use modulo. Complexity: O(10^n). For n up to maybe 3? But algorithm.\n\nWe need to output line by line pseudocode with explanation. Include start, end, decision arrows.\n\nLet's craft.\n\nStart\n→ Step: 設定 maxDigit = 10^n - 1 // 最大的 n 位數\n→ Step: 設定 minDigit = 10^(n-1) // 最小的 n 位數\n→ Step: 初始化 answer = 0\n→ Decision: 如果 n 為 1? // 特殊情況\n    Yes → Step: 設定 answer = 9 // 9 是最大的 1 位數回文\n    No  → Step: 進入主迴圈\n主迴圈: 從 i = maxDigit 到 minDigit 步減 1\n    → Decision: 如果 i * maxDigit < answer? // 已經無法比答案大，停止\n        Yes → Step: 跳出主迴圈\n        No  → 子迴圈: 從 j = i 到 minDigit 步減 1\n            → Decision: 如果 i * j < answer? // 進一步剪枝\n                Yes → Step: 跳出子迴圈\n                No  → Decision: (i * j) % 1337 是否為回文? // 檢查模 1337 後是否為回文\n                    Yes → Decision: (i * j) > answer? // 若更大則更新\n                        Yes → Step: 設定 answer = i * j\n                        No  → Step: 继续\n                    No  → Step: 继续\nEnd // 完成\nOutput: answer % 1337 // 回傳答案模 1337\n\nBut we also need step by step. We must include arrow formatting with \"→\" etc.\n\nWe need to ensure each line: \"虛擬碼步驟 // 解釋\". Use spaces. Use arrow indentation for decisions.\n\nAlso need to handle modulo: final answer is answer % 1337.\n\nBetter to maintain answerMod variable.\n\nSimplify: For each product, compute productMod = (i * j) % 1337. Check if productMod is palindrome. If yes and i*j > answer, update answer.\n\nWe also can prune if product < answer.\n\nLet's produce final answer accordingly. Use Chinese.\n\nAlso use \"Decision:\" lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 設定 maxDigit = 10^n - 1 // 最大的 n 位數  \n→ Step: 設定 minDigit = 10^(n-1) // 最小的 n 位數  \n→ Step: 初始化 answer = 0 // 儲存目前找到的最大回文乘積  \n→ Decision: 如果 n = 1? // 特殊處理 1 位數情況  \n    Yes → Step: 設定 answer = 9 // 9 是最大的 1 位數回文  \n    No → Step: 進入主迴圈  \n→ Decision: 如果 answer > 0? // 已經有答案則直接結束  \n    Yes → End // 程式執行結束  \n    No → Step: 開始搜尋回文乘積  \n→ Step: 從 i = maxDigit 到 minDigit 逐步遞減 // 迭代第一個因數  \n    → Decision: 如果 i * maxDigit < answer? // 進一步剪枝，已經無法得到更大的乘積  \n        Yes → End // 已無更大可能，結束搜尋  \n        No → Step: 進入第二層迴圈  \n            → Step: 從 j = i 到 minDigit 逐步遞減 // 迭代第二個因數  \n                → Decision: 如果 i * j < answer? // 進一步剪枝，已經無法超過現有答案  \n                    Yes → Step: 跳出第二層迴圈  \n                    No → Step: 計算 product = i * j  \n                        → Step: 計算 productMod = product % 1337 // 取模  \n                        → Decision: 如果 productMod 是回文? // 判斷是否為回文  \n                            Yes → Decision: 如果 product > answer? // 是否更新答案  \n                                Yes → Step: 設定 answer = product // 更新最大回文乘積  \n                                No → Step: 什麼都不做  \n                            No → Step: 什麼都不做  \nEnd // 程式執行結束  \n→ Step: 輸出 answer % 1337 // 回傳最終答案取模 1337",
      "generated_code": "import sys\nimport re\n\ndef largest_palindrome_product(n: int) -> int:\n    \"\"\"\n    找到兩個 n 位數的乘積中最大的回文數，並返回其模 1337 的結果。\n    \"\"\"\n    # n = 1 的特殊情況\n    if n == 1:\n        return 9  # 9 是最大的 1 位數回文\n\n    max_digit = 10 ** n - 1          # 最大的 n 位數\n    min_digit = 10 ** (n - 1)        # 最小的 n 位數\n    best = 0                         # 目前找到的最大回文乘積\n\n    # 逐步降序遍歷第一個因數\n    for i in range(max_digit, min_digit - 1, -1):\n        # 這裡做一個剪枝：如果 i 乘上最大的 n 位數已經小於已知答案\n        if i * max_digit < best:\n            break\n        # 逐步降序遍歷第二個因數\n        for j in range(i, min_digit - 1, -1):\n            prod = i * j\n            # 如果乘積已經不比已知答案大，則內層迴圈可以終止\n            if prod <= best:\n                break\n            # 檢查 prod 是否為回文\n            if str(prod) == str(prod)[::-1]:\n                best = prod\n                break\n\n    # 返回答案對 1337 的模\n    return best % 1337\n\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入，計算結果並輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    # 從輸入中擷取第一個整數（可能有 'n = 2' 之類的字串）\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    result = largest_palindrome_product(n)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "987",
          "success": true,
          "output": "987"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2410.json",
    "problem_index_in_file": 0,
    "title": "Maximum Matching of Players With Trainers",
    "description_snippet": "You are given a 0-indexed integer array players, where players[i] represents the ability of the i^th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with explanations. The task is to produce algorithm: given arrays players and trainers, count maximum matches where each player matched with at most one trainer, trainer at most one, condition ability <= capacity. Classic matching problem where greedy after sorting: sort players ascending, trainers ascending, two pointers.\n\nSo produce pseudo steps: Start, sort players, sort trainers, init pointers i=0,j=0, count=0. While i<players.length and j<trainers.length: if players[i] <= trainers[j] => count++ ; i++; j++; else j++ (trainer too small). End.\n\nWe need line by line with arrow, and comments after //.\n\nLet's format as per example. Each line: e.g., \"Start // 程式開始執行\". Then arrow lines: \"→ Step 1: ...\". Use Decision where needed: Decision: if players[i] <= trainers[j]? Yes → ... No → ... .\n\nLet's craft. Use Chinese explanations. Ensure each line has virtual code step and comment. Use appropriate indent for decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort the array `players` in ascending order // 先把玩家的能力值排好順序  \n→ Step 2: Sort the array `trainers` in ascending order // 先把訓練師的訓練容量排好順序  \n→ Step 3: 初始化指標 `i = 0`（玩家指標）與 `j = 0`（訓練師指標） // 用兩個指標分別走玩家與訓練師陣列  \n→ Step 4: 初始化 `count = 0` // 用來記錄目前的匹配數量  \n→ Decision: 只要 `i < players.length` 且 `j < trainers.length`? // 確認還有玩家與訓練師可比對  \n    Yes → Decision: 若 `players[i] <= trainers[j]`? // 判斷玩家能力是否能被此訓練師接納  \n        Yes → Step 5: 匹配成功，`count += 1` // 兩者都成功配對  \n        Yes → Step 6: `i += 1` // 移動到下一個玩家  \n        Yes → Step 7: `j += 1` // 移動到下一個訓練師  \n        No  → Step 8: `j += 1` // 訓練師能力不足，嘗試下一個訓練師  \n    No → End // 所有可能的配對已處理完畢  \n→ Step 9: 回傳 `count` // 回傳最大匹配數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def matchPlayersAndTrainers(self, players, trainers):\n        \"\"\"\n        以兩個指標從小到大遍歷已排序的 players 與 trainers。\n        若玩家能力 <= 訓練師容量，兩者匹配成功，指標均往前移。\n        否則只移動訓練師指標，尋找更大的容量。\n        \"\"\"\n        players.sort()\n        trainers.sort()\n        i = j = matches = 0\n        while i < len(players) and j < len(trainers):\n            if players[i] <= trainers[j]:\n                matches += 1\n                i += 1\n            j += 1\n        return matches\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 找出兩個方括號中的列表\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) >= 2:\n        players = ast.literal_eval(lists[0])\n        trainers = ast.literal_eval(lists[1])\n    else:\n        # 若格式不符，直接嘗試解析整個輸入為兩個列表\n        try:\n            parts = data.split(',')\n            players = ast.literal_eval(parts[0].strip().split('=')[1].strip())\n            trainers = ast.literal_eval(parts[1].strip().split('=')[1].strip())\n        except Exception:\n            players, trainers = [], []\n\n    solution = Solution()\n    result = solution.matchPlayersAndTrainers(players, trainers)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "players = [4,7,9], trainers = [8,2,5,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "players = [1,1,1], trainers = [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode704.json",
    "problem_index_in_file": 0,
    "title": "Binary Search",
    "description_snippet": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user asks for pseudocode for binary search. Must follow format. Use virtual code steps. Each line: \"Step: ... // explanation\". Use arrow \"→\". Use Decision: lines. Need Start and End. Use O(log n) runtime. Let's produce.\n\nWe need to be mindful: each line includes the step and explanation. No actual code. Just virtual steps.\n\nWe need to include variable definitions like left, right, mid. Steps: initialize left=0, right=len(nums)-1. Loop while left <= right. Compute mid = (left+right)/2. Compare nums[mid] with target. Decision: if equal, return mid. Else if target < nums[mid], set right = mid-1. Else left = mid+1. After loop, return -1.\n\nWe need to use Start, End. Each step prefixed with arrow? The format example: \"Start // 程式開始執行\". Then \"→ Step 1: ...\" So the arrow goes after Start. For each step, we use \"→\" then step description. For Decision, we use \"→ Decision: 如果...\" and then indentation lines with Yes → Step etc.\n\nWe must follow the format exactly: each line must have \"虛擬碼步驟\" followed by a space and \"// 解釋/說明\". Use the arrow etc. Use Chinese explanations.\n\nLet's produce.\n\nEnsure no actual code, just virtual steps. Use step numbers? In example they had Step 1, Step 2 etc. Could use Step: initialize left and right. Let's produce a sequence.\n\nAlso mention algorithm complexity: O(log n). Maybe as comment in End.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = nums.length - 1 // 初始化搜尋範圍  \n→ Decision: 是否還有未檢查元素? (left <= right) // 判斷是否仍在有效範圍內  \n    Yes → Step 2: 計算 mid = (left + right) // 取中間索引  \n    Yes → Decision: nums[mid] 與 target 比較  \n        Yes → Step 3: 若 nums[mid] 等於 target，返回 mid // 找到目標，終止搜尋  \n        Yes → Decision: target 是否小於 nums[mid]?  \n            Yes → Step 4: right = mid - 1 // 目標在左半邊，更新右邊界  \n            No  → Step 5: left = mid + 1 // 目標在右半邊，更新左邊界  \n    No  → Step 6: return -1 // 搜尋完畢仍未找到，返回 -1  \nEnd // 程式執行結束，複雜度為 O(log n) 典型的二分搜尋算法。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        \"\"\"\n        二分搜尋：O(log n) 時間複雜度\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n\n    # 從輸入字串中抓取 nums 與 target\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*([-\\d]+)', data)\n\n    if nums_match and target_match:\n        # 解析列表字串為實際 list\n        nums_str = nums_match.group(1)\n        nums = eval(nums_str)  # 這裡使用 eval，前提是輸入受控制\n        # 解析目標值\n        target = int(target_match.group(1))\n\n        # 呼叫搜尋函式並輸出結果\n        sol = Solution()\n        result = sol.search(nums, target)\n        print(result)\n    else:\n        # 若輸入格式不符合預期，可自行處理或直接終止\n        pass",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode724.json",
    "problem_index_in_file": 0,
    "title": "Find Pivot Index",
    "description_snippet": "Given an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode lines with comments, using structure: Start, →, Decision, Yes →, No →. Provide explanation each line. Must not output actual code. Provide the algorithm: compute total sum, iterate indices, maintain left sum, check if leftSum == totalSum - leftSum - nums[i]. If true, return i. After loop, return -1. Use pseudo-steps.\n\nNeed to output in Traditional Chinese. Each line: virtual step and comment after space, // explanation.\n\nUse arrow: Start, → Step 1, etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算陣列 nums 的總和 totalSum // 先算出整個陣列的元素總和  \n→ Step 2: 初始化 leftSum 為 0 // 用來儲存目前索引左側的累加和  \n→ Step 3: 迭代索引 i 從 0 到 nums.length - 1 // 逐個檢查每個可能的樞紐點  \n→ Decision: 檢查 leftSum 是否等於 totalSum - leftSum - nums[i] // 左邊和是否等於右邊和  \n  Yes → Step 4: 返回 i // 找到左邊最小的樞紐點即停止並返回索引  \n  No  → Step 5: 更新 leftSum 加上 nums[i] // 索引左側的和加上當前元素，進入下一個索引  \n→ Step 6: 迴圈結束後，沒有找到樞紐點 // 完成所有索引的檢查  \n→ Step 7: 返回 -1 // 表示不存在符合條件的樞紐點  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def pivotIndex(self, nums):\n        \"\"\"計算並回傳陣列的樞紐點索引，若不存在則回傳 -1。\"\"\"\n        total = sum(nums)          # 整個陣列的總和\n        left_sum = 0               # 目前索引左側的累加和\n        for i, num in enumerate(nums):\n            # 若左側和等於右側和，則 i 為樞紐點\n            if left_sum == total - left_sum - num:\n                return i\n            left_sum += num        # 更新左側和\n        return -1                   # 沒有樞紐點時回傳 -1\n\ndef parse_nums(raw_input: str):\n    \"\"\"\n    從輸入字串中提取 nums 陣列。\n    允許輸入形如 \"nums = [1, 7, 3]\" 或僅為 \"[1, 7, 3]\"。\n    \"\"\"\n    raw = raw_input.strip()\n    if '=' in raw:\n        # 取等號右側的部分\n        _, right = raw.split('=', 1)\n        raw = right.strip()\n    try:\n        # 安全地解析字面量\n        nums = ast.literal_eval(raw)\n    except Exception:\n        nums = []\n    return nums\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入\n    raw_data = sys.stdin.read()\n    # 解析出 nums 陣列\n    nums = parse_nums(raw_data)\n    # 執行樞紐點計算\n    result = Solution().pivotIndex(nums)\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,3,6,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode761.json",
    "problem_index_in_file": 0,
    "title": "Special Binary String",
    "description_snippet": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for algorithm to find lexicographically largest string after swapping consecutive special substrings. This is a known problem: \"Largest Binary String After Swapping\". We need to output virtual code steps.\n\nWe need to produce step-by-step pseudocode with comments. Ensure Start, End, Decision. Provide lines.\n\nLet's craft algorithm: parse string, find special substrings via stack. Build list of special substrings. Sort by lex order descending? Actually we can transform by swapping. It's known that swapping consecutive special substrings with the larger lex string earlier leads to lexicographically largest string. So algorithm: identify all special substrings, get their lex order, sort descending; then reconstruct string by swapping accordingly: the lexicographically largest order is to reorder substrings in descending order by lexicographic compare.\n\nImplementation: use stack to find boundaries: for i from 0 to n-1, push index; maintain count; when count==0 pop start, record substring.\n\nCollect substrings in list. Then sort list by descending lex compare. Then rebuild string by concatenating sorted substrings.\n\nReturn result.\n\nNow produce virtual code lines.\n\nWe'll produce:\n\nStart\n→ Step 1: Initialize empty stack and list // ...\n→ Step 2: For each index i in s // ...\n→ Decision: s[i]=='1'? // ...\n... etc.\n\nWe need each line with comment.\n\nLet's craft.\n\nAlso include sorting step.\n\nWe need to use Decision, loops, etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的堆疊 stack 與空列表 substrings // 用來紀錄特殊子字串的起始與終止位置  \n→ Step 2: 設定 counter = 0 // 追蹤當前子字串中 1 與 0 的差  \n→ Step 3: 從左到右遍歷字串 s 的每個字元 i // 逐位掃描  \n  Decision: s[i] 是 '1' ? // 判斷當前字元  \n   Yes → counter += 1 // 1 數量增加  \n   No → counter -= 1 // 0 數量減少  \n  Decision: counter == 0 ? // 是否形成一個特殊子字串  \n   Yes → start = stack.pop() // 取出最近未匹配的起始位置  \n    → substring = s[start..i] // 擷取完整子字串  \n    → substrings.append(substring) // 加入列表  \n   No → stack.push(i) // 將當前索引入堆疊等待匹配  \n→ Step 4: // 所有特殊子字串已被收集於 substrings  \n→ Step 5: 將 substrings 按字典序降序排列 // 使較大的子字串排在前面  \n  → substrings.sort(reverse=True) // Python 風格的降序排序  \n→ Step 6: 初始化空字串 result // 用來組合最終答案  \n→ Step 7: 逐一將排好序的子字串加到 result 上 // 重新拼接  \n  → For each sub in substrings  \n    → result += sub  \n→ End // 程式執行結束，返回 result 為最終字串",
      "generated_code": "import sys\n\nclass Solution:\n    def makeLargestSpecial(self, s: str) -> str:\n        \"\"\"\n        將特殊二進位字串重新排序，得到字典序最大的字串。\n        \"\"\"\n        res = []\n        i = 0\n        count = 0\n        for j, c in enumerate(s):\n            # 1 增加計數，0 減少計數\n            count += 1 if c == '1' else -1\n            # 當 count 為 0 時，代表從 i 到 j 的子字串是一個特殊字串\n            if count == 0:\n                # 先遞迴處理子字串的內部\n                inner = self.makeLargestSpecial(s[i + 1:j])\n                # 將外層的 1 與 0 包裝回去\n                res.append('1' + inner + '0')\n                # 更新下一個子字串的起始位置\n                i = j + 1\n        # 將所有特殊子字串按字典序降序排列\n        res.sort(reverse=True)\n        return ''.join(res)\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    從 stdin 讀取的原始字串，可能形如 s = \"11011000\" 或僅為 11011000。\n    這個函式會取出其中的二進位字串。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return ''\n    # 如果有引號，提取引號內部的內容\n    if '\"' in data:\n        start = data.find('\"') + 1\n        end = data.rfind('\"')\n        return data[start:end]\n    # 否則直接把整行作為字串\n    return data\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    solution = Solution()\n    result = solution.makeLargestSpecial(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"11011000\"",
          "expected_output": "\"11100100\"",
          "success": true,
          "output": "11100100"
        },
        {
          "example_index": 1,
          "input": "s = \"10\"",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode461.json",
    "problem_index_in_file": 0,
    "title": "Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Input: two integers x and y. Compute Hamming distance: number of differing bits. Standard algorithm: XOR then count 1s. Steps: Start, input x and y, compute xor = x XOR y, initialize count = 0, while xor > 0: if xor & 1 == 1: count++, xor = xor >> 1. Return count. End. Provide comments.\n\nNeed to use arrow syntax. Use Decision. Use Start, End. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取兩個整數 x, y // 從使用者或函式輸入取得兩個整數\n→ Step 2: 計算 xor = x XOR y // 取得兩個數字不同位元的組合\n→ Step 3: 初始化 count = 0 // 記錄不同位元的個數\n→ Decision: 是否 xor > 0? // 判斷是否還有未處理的位元\n    Yes → Step 4: 如果 xor & 1 == 1? // 檢查最低位是否為 1\n        Yes → Step 5: count += 1 // 若為 1，遞增計數\n        No  → Step 5: // 低位為 0，無需改變計數\n    → Step 6: xor = xor >> 1 // 右移 1 位，處理下一個位元\n    → Step 7: 回到 Decision // 重複檢查剩餘位元\n    No  → Step 8: 回傳 count // 所有位元已處理，回傳 Hamming distance\nEnd // 程式執行結束",
      "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\nimport re\n\nclass Solution:\n    \"\"\"\n    計算兩個整數之間的 Hamming distance。\n    Hamming distance 為兩個二進位表示不同位元的個數。\n    \"\"\"\n    def hammingDistance(self, x: int, y: int) -> int:\n        # 先 XOR 兩個數，得到不同位元的位置\n        xor = x ^ y\n        distance = 0\n        # 逐位檢查 XOR 結果，累加 1 的個數\n        while xor:\n            distance += xor & 1\n            xor >>= 1\n        return distance\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入字串中擷取整數。\n    支援「x = 1, y = 4」或「1 4」等格式。\n    \"\"\"\n    numbers = re.findall(r'-?\\d+', text)\n    if len(numbers) < 2:\n        raise ValueError(\"輸入不足兩個整數\")\n    return int(numbers[0]), int(numbers[1])\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    # 解析得到 x 和 y\n    try:\n        x, y = parse_input(raw_input)\n    except ValueError as e:\n        sys.exit(f\"錯誤: {e}\")\n\n    # 建立解法實例並計算 Hamming distance\n    solution = Solution()\n    result = solution.hammingDistance(x, y)\n\n    # 將結果輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 1, y = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 3, y = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode754.json",
    "problem_index_in_file": 0,
    "title": "Reach a Number",
    "description_snippet": "You are standing at position 0 on an infinite number line. There is a destination at position target...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code solution for \"minimum number of moves to reach target\" classic Leetcode problem 779. Approach: Find minimal n such that sum_{i=1..n} >= |target| and parity matches: (sum - target) % 2 == 0. So algorithm: target=abs(target). sum=0; n=0; while sum<target or (sum-target)%2 !=0: n++; sum+=n; return n.\n\nWe need to produce virtual code with steps, explanation, using arrows, decision etc. Must be line by line, each line with \"虛擬碼步驟\" and \"// 解釋/說明\".\n\nLet's craft steps: Start, input target, absolute value, initialize sum=0, n=0, loop condition, inside loop increment n, sum+=n, after loop return n, End.\n\nAdd Decision: while sum<target or parity mismatch? Use Decision node: while condition? Yes -> body, No -> exit.\n\nWe need to adhere to format with arrow.\n\nLet's write:\n\nStart // 程式開始\n→ Input: target // 取得目標位置\n→ Step 1: target ← abs(target) // 取目標的絕對值，因左右對稱\n→ Step 2: sum ← 0 // 初始化已走步數總和\n→ Step 3: n ← 0   // 初始化已走步數個數\n→ Decision: sum < target OR (sum - target) mod 2 ≠ 0? // 判斷是否還需要再走\n    Yes → Step 4: n ← n + 1 // 下一步長度\n    Yes → Step 5: sum ← sum + n // 更新總步數\n    Yes → ← Decision // 重新檢查條件\n    No  → Step 6: return n // 找到最小步數\nEnd // 程式結束\n\nBut we need arrow structure: Use \"→\" for sequence. For loop we might use Decision with Yes arrow to loop. Might need to show indentation.\n\nUse:\n\nDecision: sum < target OR (sum - target) mod 2 ≠ 0? // 判斷是否仍需走\n    Yes → Step 4...\n    No  → Step 6: return n\n\nBut we also need to loop back. So after Step5 we go back to Decision. So can show arrow back: Step5 → Decision.\n\nLet's produce final.\n\nAlso ensure no actual code, just pseudo.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Input: target // 取得目標位置  \n→ Step 1: target ← abs(target) // 取目標的絕對值，因左右對稱  \n→ Step 2: sum ← 0 // 初始化已走步數總和  \n→ Step 3: n ← 0   // 初始化已走步數個數  \n→ Decision: sum < target OR (sum - target) mod 2 ≠ 0? // 判斷是否還需要再走  \n&nbsp;&nbsp;Yes → Step 4: n ← n + 1 // 下一步長度  \n&nbsp;&nbsp;Yes → Step 5: sum ← sum + n // 更新總步數  \n&nbsp;&nbsp;Yes → ← Decision // 重新檢查條件  \n&nbsp;&nbsp;No  → Step 6: return n // 找到最小步數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef min_moves(target: int) -> int:\n    \"\"\"\n    取得最小步數以達到目標位置。\n    target 為絕對值，步數 1,2,3,… 逐步累加，直到\n    1. 總步數 >= |target|\n    2. (總步數 - |target|) 為偶數\n    \"\"\"\n    target = abs(target)\n    step = 0\n    total = 0\n    while total < target or (total - target) % 2 != 0:\n        step += 1\n        total += step\n    return step\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入，計算並輸出結果。\n    輸入格式示例：'target = 2' 或者僅包含整數 2。\n    \"\"\"\n    data = sys.stdin.read()\n    # 取第一個出現的整數（含負號）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    target = int(match.group())\n    print(min_moves(target))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "target = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode621.json",
    "problem_index_in_file": 0,
    "title": "Task Scheduler",
    "description_snippet": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CP...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to compute minimum CPU intervals given tasks with cooldown n. Classic LeetCode 621. Approach: count frequencies, find max frequency, count tasks with max freq, compute idle slots = (maxFreq-1)*(n+1) - sum(min(freq, maxFreq-1))? Or simpler formula: idle = max(0, (maxFreq-1)*(n+1) - tasksCount + countMaxFreq). Then result = idle + tasksCount. We'll output steps.\n\nLet's craft pseudocode:\n\nStart\n→ Step 1: Count frequency of each task // get how many times each letter appears\n→ Step 2: Find max frequency maxFreq // highest occurrence\n→ Step 3: Count how many tasks have frequency equal to maxFreq // countMax\n→ Step 4: Calculate intervals for idle slots: idle = (maxFreq - 1) * (n + 1) - (tasksCount - countMax) // tasksCount = total tasks\n→ Decision: If idle < 0? // if negative, no idle needed\n        Yes → idle = 0 // set to zero\n        No  → keep idle as computed\n→ Step 5: Result = idle + tasksCount // total intervals\nEnd\n\nWe also need to add explanations. Provide each line with comment. Use arrow symbol. For decision lines we use Decision:.\n\nLet's produce. Ensure each line has \"→\" at start? In example, Start has no arrow. But they use \"Start\". Next lines: \"→ Step 1:\" etc. We'll follow that. Provide comment after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 計算每個任務字母的出現次數 // 產生頻率表，方便後續分析\n→ Step 2: 找出最大頻率 maxFreq // 代表同一任務需要最多重複的次數\n→ Step 3: 計算頻率等於 maxFreq 的任務種類數 countMax // 這些任務同時排佈於最緊湊的時間線\n→ Step 4: 計算可能需要的空閒間隔 idle = (maxFreq - 1) * (n + 1) - (totalTasks - countMax) // 基於最少間距的理論值，扣除已佔用的槽位\n→ Decision: 如果 idle < 0? // 若計算結果為負，代表不需要空閒時間\n    Yes → idle = 0 // 直接將空閒時間設為 0\n    No  → // 留下計算出的 idle 值不變\n→ Step 5: 取得總時間 intervals = idle + totalTasks // 將空閒時間與實際任務時間相加得到最小 CPU 週期數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"\n    計算完成所有任務所需的最小 CPU 週期數。\n    \"\"\"\n    # 1. 統計每個任務的頻率\n    freq = Counter(tasks)\n\n    # 2. 找出最大頻率以及同樣最大頻率的任務種類數\n    max_freq = max(freq.values())\n    max_count = sum(1 for v in freq.values() if v == max_freq)\n\n    # 3. 計算最理論上需要的時間，然後取與實際任務數量較大的值\n    intervals = (max_freq - 1) * (n + 1) + max_count\n    return max(intervals, len(tasks))\n\ndef parse_input(input_text):\n    \"\"\"\n    從原始輸入文字中解析 tasks 列表與 n 整數。\n    支援輸入類似於：\n    tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n    也能處理多行或不同空格情況。\n    \"\"\"\n    # 提取 tasks 列表\n    tasks_match = re.search(r'tasks\\s*=\\s*(\\[[^\\]]*\\])', input_text)\n    if not tasks_match:\n        raise ValueError(\"Cannot find 'tasks' list in input.\")\n    tasks_str = tasks_match.group(1)\n    tasks = ast.literal_eval(tasks_str)\n\n    # 提取 n 整數\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', input_text)\n    if not n_match:\n        raise ValueError(\"Cannot find 'n' value in input.\")\n    n = int(n_match.group(1))\n\n    return tasks, n\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n\n    # 解析輸入\n    tasks, n = parse_input(raw_input)\n\n    # 計算答案並輸出\n    result = least_interval(tasks, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode355.json",
    "problem_index_in_file": 0,
    "title": "Design Twitter",
    "description_snippet": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code line by line with explanations, following arrow format. Provide steps for class design. No actual code. Just pseudo. Use Start, End, Decision. Need to cover init, postTweet, getNewsFeed, follow, unfollow. Also internal data structures: maybe a map userId -> list of tweetIds with timestamps, map userId -> set of followees. Also global timestamp increment. Implementation of getNewsFeed: merge last 10 from each followee. Use priority queue.\n\nWe'll write step by step algorithm.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 timestamp = 0, tweets_map = {}, follow_map = {} // 初始化資料結構\n→ Step 2: 定義 Twitter() // 建構子\n\nBut we need pseudo for class methods.\n\nBetter to produce pseudo steps for each method. We'll separate.\n\nLet's craft pseudo:\n\nStart\n→ Step 1: Define class Twitter\n    → Step 2: Initialize global timestamp counter\n    → Step 3: Initialize tweets_map: mapping userId → list of (tweetId, timestamp)\n    → Step 4: Initialize follow_map: mapping userId → set of followees\n\nMethod postTweet\n→ Step 1: postTweet(userId, tweetId)\n    → Step 2: timestamp += 1\n    → Step 3: If userId not in tweets_map, add empty list\n    → Step 4: Append (tweetId, timestamp) to tweets_map[userId]\n    → End\n\nMethod follow\n→ Step 1: follow(followerId, followeeId)\n    → Step 2: If followerId not in follow_map, add empty set\n    → Step 3: Add followeeId to follow_map[followerId]\n    → End\n\nMethod unfollow\n→ Step 1: unfollow(followerId, followeeId)\n    → Step 2: If followerId in follow_map and followeeId in set\n    → Step 3: Remove followeeId\n    → End\n\nMethod getNewsFeed\n→ Step 1: getNewsFeed(userId)\n    → Step 2: Initialize result list\n    → Step 3: Initialize list of sources = {userId} ∪ follow_map[userId] if exists\n    → Step 4: For each source in sources\n        → Step 5: Retrieve last up to 10 tweets from tweets_map[source]\n        → Step 6: For each tweet, push into min-heap of size at most 10 (max-heap by timestamp)\n    → Step 7: Extract from heap into result in descending timestamp order\n    → Step 8: Return result\n    → End\n\nBut we need arrow style. Use \"→\" arrow.\n\nWe should show decision nodes for checking existence etc.\n\nLet's write. Use indentation? They used indentation in example: Decision: ... Yes → etc.\n\nWe'll replicate.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: 定義類別 Twitter // 建立 Twitter 類別  \n    → Step 2: 初始化全域時間戳記 counter ← 0 // 用於排序推文  \n    → Step 3: 初始化 tweets_map ← {} // userId → 推文列表 (tweetId, timestamp)  \n    → Step 4: 初始化 follow_map ← {} // userId → 追蹤者集合  \n\n→ Step 5: 定義方法 postTweet(userId, tweetId) // 發佈推文  \n    → Step 6: counter ← counter + 1 // 時間戳更新  \n    → Decision: 如果 userId 不在 tweets_map? // 確保資料結構存在  \n        Yes → Step 7: tweets_map[userId] ← [] // 初始化空列表  \n    → Step 8: 將 (tweetId, counter) 附加至 tweets_map[userId] // 存儲推文  \n    → End // 發佈完成  \n\n→ Step 9: 定義方法 follow(followerId, followeeId) // 追蹤對象  \n    → Decision: 如果 followerId 不在 follow_map?  \n        Yes → Step 10: follow_map[followerId] ← {} // 初始化追蹤集合  \n    → Step 11: 將 followeeId 加入 follow_map[followerId] // 更新關係  \n    → End // 追蹤完成  \n\n→ Step 12: 定義方法 unfollow(followerId, followeeId) // 解除追蹤  \n    → Decision: 如果 followerId 在 follow_map 且 followeeId 在 follow_map[followerId]?  \n        Yes → Step 13: 移除 followeeId 從 follow_map[followerId] // 解除關係  \n    → End // 解除追蹤完成  \n\n→ Step 14: 定義方法 getNewsFeed(userId) // 取得新聞訂閱  \n    → Step 15: result ← [] // 結果列表  \n    → Decision: 如果 userId 在 follow_map?  \n        Yes → Step 16: sources ← follow_map[userId] ∪ {userId} // 包含自己  \n        No  → Step 17: sources ← {userId} // 只有自己  \n    → Step 18: 初始化最大堆 heap（優先級根據 timestamp） // 取最近 10 篇  \n    → For each source in sources  \n        → Decision: 如果 source 在 tweets_map 且 tweets_map[source] 非空?  \n            Yes → Step 19: recent ← tweets_map[source] 的最後 10 篇（按時間遞增）  \n            No  → Step 20: recent ← [] // 沒有推文  \n        → For each (tId, ts) in recent  \n            → Step 21: heap.push((ts, tId)) // 插入堆  \n            → Decision: 如果 heap 大小 > 10?  \n                Yes → Step 22: heap.pop() // 移除最舊的推文  \n    → Step 23: While heap 不是空  \n        → Step 24: pop (ts, tId) 從 heap（最舊先出）  \n        → Step 25: result.prepend(tId) // 以時間遞減順序加入結果  \n    → Step 26: 返回 result // 前 10 篇最新推文  \n    → End // 取得新聞訂閱完成  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        # 時間戳，越大越新\n        self.time = 0\n        # userId -> list of (time, tweetId)\n        self.tweets = defaultdict(list)\n        # userId -> set of followees\n        self.following = defaultdict(set)\n\n    def postTweet(self, userId, tweetId):\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n\n    def follow(self, followerId, followeeId):\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId, followeeId):\n        self.following[followerId].discard(followeeId)\n\n    def getNewsFeed(self, userId):\n        res = []\n        # 取得自己及追蹤者\n        sources = set(self.following.get(userId, []))\n        sources.add(userId)\n        # 最大堆：以時間遞減為優先級\n        heap = []\n        for fid in sources:\n            tws = self.tweets.get(fid, [])\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n        # 取最多 10 篇\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，將兩個列表包起來成為合法 JSON\n    raw = sys.stdin.read().strip()\n    # 把「], [」改成「],[」方便解析\n    raw = raw.replace('], [', '],[')\n    ops, args = json.loads('[' + raw + ']')\n\n    obj = None\n    outputs = []\n    for op, arg in zip(ops, args):\n        if op == \"Twitter\":\n            obj = Twitter()\n            outputs.append(None)\n        elif op == \"postTweet\":\n            obj.postTweet(*arg)\n            outputs.append(None)\n        elif op == \"follow\":\n            obj.follow(*arg)\n            outputs.append(None)\n        elif op == \"unfollow\":\n            obj.unfollow(*arg)\n            outputs.append(None)\n        elif op == \"getNewsFeed\":\n            outputs.append(obj.getNewsFeed(*arg))\n        else:\n            # 未知方法，忽略\n            outputs.append(None)\n    # 輸出結果，None 會被轉成 JSON 的 null\n    print(json.dumps(outputs))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "success": true,
          "output": "[null, null, [5], null, null, [6, 5], null, [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode670.json",
    "problem_index_in_file": 0,
    "title": "Maximum Swap",
    "description_snippet": "You are given an integer num. You can swap two digits at most once to get the maximum valued number....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code steps for the problem: given an integer num, can swap two digits at most once to get maximum number. Return maximum. So we need to produce pseudo code line by line with explanations. Use Start, Decision, etc. Provide each line with `→ Step X: ... // explanation`. No real code.\n\nWe should outline algorithm: Convert to string, find maximum digit to the right of each position, find best swap. One pass from right: track max digit and its index. When we find a digit less than max digit to its right, we swap them. Return int.\n\nSteps:\n\nStart\n→ Step 1: Convert num to string array digits // representation\n→ Step 2: Initialize maxDigit = -1, maxIndex = -1 // placeholder\n→ Decision: For each index i from rightmost to leftmost // iterate\n    Yes → Step 3: If digits[i] > maxDigit // update max info\n    Yes → Step 4: Set maxDigit = digits[i], maxIndex = i\n    No  → Step 5: If digits[i] < maxDigit // potential swap\n    Yes → Step 6: Swap digits[i] and digits[maxIndex] // perform swap\n    Yes → Step 7: Break loop // only one swap\nEnd // after loop, convert back to number and return\n\nAlso handle no swap scenario: if no digits[i] < maxDigit, return original number.\n\nWe need to format exactly with arrows and decisions.\n\nLet's craft.\n\nUse Start, End.\n\nUse arrows for steps. Use Decision lines with indentation.\n\nMake sure each line ends with `// 解釋/說明`.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 轉換 num 為字元陣列 digits // 以字元形式處理每一位數字  \n→ Step 2: 設定 maxDigit ← -1, maxIndex ← -1 // 用於追蹤右邊最大的數字與其位置  \n→ Decision: 從右到左遍歷 digits 的每個索引 i  \n  Yes → Step 3: 如果 digits[i] > maxDigit  \n   Yes → Step 4: 設定 maxDigit ← digits[i], maxIndex ← i // 更新右邊最大的數字與位置  \n   No → Step 5: 如果 digits[i] < maxDigit  \n    Yes → Step 6: 交換 digits[i] 與 digits[maxIndex] // 執行一次交換以獲得更大的數字  \n    Yes → Step 7: 退出循環 // 僅允許一次交換  \nEnd // 將字元陣列轉回整數並返回結果",
      "generated_code": "import sys\nimport re\n\ndef maximum_swap(num: int) -> int:\n    \"\"\"\n    透過一次交換，將給定整數 num 轉換為可能的最大值。\n    \"\"\"\n    digits = list(str(num))                     # 以字元陣列處理\n    last = {int(d): i for i, d in enumerate(digits)}  # 各數字最後出現的位置\n\n    for i, d in enumerate(digits):\n        # 從 9 開始檢查，比目前數字大的數字\n        for x in range(9, int(d), -1):\n            if x in last and last[x] > i:\n                # 找到可交換的數字，執行交換並返回結果\n                digits[i], digits[last[x]] = digits[last[x]], digits[i]\n                return int(''.join(digits))\n    # 若無法交換，直接返回原數字\n    return int(''.join(digits))\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整數，允許輸入格式為「num = 2736」或「2736」等\n    input_data = sys.stdin.read()\n    match = re.search(r'\\d+', input_data)\n    if match:\n        num = int(match.group())\n        result = maximum_swap(num)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 2736",
          "expected_output": "7236",
          "success": true,
          "output": "7236"
        },
        {
          "example_index": 1,
          "input": "num = 9973",
          "expected_output": "9973",
          "success": true,
          "output": "9973"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode303.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Immutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of th...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step, with explanation. The user gives a requirement: implement a NumArray class for sumRange queries. Virtual code: steps: start, class definition, constructor, building prefix sum, sumRange method, end.\n\nWe need to use \"Start\", \"End\", \"Decision:\", \"Yes →\", \"No →\" etc. We need to include each line: \"虛擬碼步驟\" + space + \"// 解釋\". No actual code. Just structured steps.\n\nProbably something like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 宣告類別\n→ Step 2: 宣告私有變數 prefixSum // 儲存前綴和\n→ Step 3: NumArray(int[] nums) // 建構子\n    → Step 4: 初始化 prefixSum 為長度 len(nums)+1 的陣列 // 前綴和陣列大小\n    → Step 5: prefixSum[0] = 0 // 前綴和初值\n    → Decision: 遍歷 nums? // 檢查是否需要計算\n        Yes → Step 6: 循環 i 從 0 到 nums.length-1\n            → Step 7: prefixSum[i+1] = prefixSum[i] + nums[i] // 計算前綴和\n        No → ...\n→ Step 8: int sumRange(int left, int right) // 方法\n    → Step 9: 返回 prefixSum[right+1] - prefixSum[left] // 計算區間和\nEnd // 程式結束\n\nBut need to use arrow for decisions. Actually each step line should end with comment. We must avoid actual code. Use descriptive virtual steps.\n\nThe format requires each line: \"虛擬碼步驟\" + \" \" + \"// 解釋\". We can include indentation maybe but not required.\n\nWe should include Decision blocks with Yes →, No →. But there are not many decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 宣告類別 NumArray // 定義要實作的類別\n→ Step 2: 宣告私有變數 prefixSum: 整數陣列 // 儲存前綴和\n→ Step 3: NumArray(nums: 整數陣列) // 建構子\n    → Step 4: 初始化 prefixSum 為長度 nums.length + 1 的陣列 // 建立前綴和空間\n    → Step 5: 設定 prefixSum[0] = 0 // 前綴和起始值\n    → Decision: nums 是否為空? // 判斷是否需要填充\n        Yes → Step 6: 若 nums 為空，直接結束建構子 // 空陣列不需計算\n        No  → Step 7: 循環 i 從 0 到 nums.length - 1\n            → Step 8: 計算 prefixSum[i+1] = prefixSum[i] + nums[i] // 填充前綴和\n→ Step 9: sumRange(left: 整數, right: 整數) // 查詢方法\n    → Step 10: 回傳 prefixSum[right+1] - prefixSum[left] // 計算並返回區間和\nEnd // 程式結束\n\nNeed to ensure each line ends with \"// 解釋\". Provide explanation after space. Use arrow \"→\". Use indentation maybe.\n\nWe must ensure each line is a separate line. Let's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告類別 NumArray // 定義要實作的類別  \n→ Step 2: 宣告私有變數 prefixSum: 整數陣列 // 用於儲存前綴和  \n→ Step 3: NumArray(nums: 整數陣列) // 建構子，接收輸入陣列  \n    → Step 4: 初始化 prefixSum 為長度 nums.length + 1 的陣列 // 建立前綴和空間  \n    → Step 5: 設定 prefixSum[0] = 0 // 前綴和起始值  \n    → Decision: nums 是否為空? // 判斷是否需要填充前綴和  \n        Yes → Step 6: 若 nums 為空，直接結束建構子 // 空陣列不需計算  \n        No  → Step 7: 循環 i 從 0 到 nums.length - 1  \n            → Step 8: 計算 prefixSum[i+1] = prefixSum[i] + nums[i] // 填充前綴和  \n→ Step 9: sumRange(left: 整數, right: 整數) // 查詢方法  \n    → Step 10: 回傳 prefixSum[right+1] - prefixSum[left] // 計算並返回區間和  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 取得第一個結束的右括號，分隔兩個陣列\n    end_idx = data.find(']')\n    ops_str = data[:end_idx + 1]\n    params_str = data[end_idx + 2:]  # 跳過 '],'\n\n    # 解析兩個陣列\n    ops = ast.literal_eval(ops_str)\n    params = ast.literal_eval(params_str)\n\n    # 執行指令並收集結果\n    results = []\n    obj = None\n    for op, param in zip(ops, params):\n        if op == \"NumArray\":\n            obj = NumArray(param[0] if param else [])\n            results.append(None)\n        elif op == \"sumRange\":\n            res = obj.sumRange(param[0], param[1])\n            results.append(res)\n\n    # 輸出結果，使用 json 讓 None 變成 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "success": true,
          "output": "[null, 1, -1, -3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode80.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array II",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanations. Use Start, End, Decision, arrow etc. Provide steps for removing duplicates with at most two occurrences. Use two-pointer approach. Let's outline:\n\nStart\n→ Initialize write_index = 0 // position to write next allowed element\n→ For each element read_index from 0 to length-1:\n    → Decision: if write_index < 2 OR nums[read_index] != nums[write_index - 2]?\n        Yes → nums[write_index] = nums[read_index] // copy\n            → write_index += 1\n        No  → skip // do nothing\n→ Return write_index // final length k\nEnd\n\nNeed to produce each line with explanation comment. Use arrow lines for decisions. Use indentation? In example, they use indentation for decisions but plain text lines are fine.\n\nWe need to include \"虛擬碼步驟\" with the arrow notation. Provide step numbers maybe but not required. Let's create:\n\nStart // 程式開始執行\n→ Step 1: write_index ← 0 // 初始化寫入指標\n→ Step 2: for read_index from 0 to length(nums)-1 do // 逐個讀取元素\n    → Decision: write_index < 2 OR nums[read_index] != nums[write_index-2] ?\n        Yes → nums[write_index] ← nums[read_index] // 允許此元素\n            → write_index ← write_index + 1 // 更新寫入位置\n        No  → // 跳過此元素\n→ Step 3: return write_index // 回傳新長度 k\nEnd // 程式執行結束\n\nWe should keep each line separate. Use \"虛擬碼步驟\" then comment. In example, they put \"Start\" line then arrow. Let's match format: \"Start // ...\" and arrow lines begin with \"→\". For decision, they used \"Decision:\" preceding the decision condition. So:\n\nStart // 程式開始執行\n→ write_index ← 0 // 初始化寫入指標\n→ for read_index from 0 to length(nums)-1 do // 逐個讀取元素\n    → Decision: write_index < 2 OR nums[read_index] != nums[write_index-2] ?\n        Yes → nums[write_index] ← nums[read_index] // 允許此元素\n            → write_index ← write_index + 1 // 更新寫入位置\n        No  → // 跳過此元素\n→ return write_index // 回傳新長度 k\nEnd // 程式執行結束\n\nBut need \"虛擬碼步驟\" at beginning of each line: They want \"虛擬碼步驟 + [space] + // 解釋\". So each line should contain code + space + comment. Eg \"Start // 程式開始執行\". They already did.\n\nWe should ensure each line starts with code, then a space, then comment. So \"→ write_index ← 0 // 初始化寫入指標\". Good.\n\nFor decision, they used \"Decision: 如果數字大於 0?\" etc. So we use \"Decision:\".\n\nFor indentation, maybe just add spaces before sub lines. But we keep same style: In example, they indent lines inside decision with spaces: \"Yes → Step 2: 輸出 '正數' // ...\". We'll mimic that.\n\nThus produce lines accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ write_index ← 0 // 初始化寫入指標，指向第一個可以放置元素的位置  \n→ for read_index from 0 to length(nums)-1 do // 逐個遍歷原始陣列  \n    → Decision: write_index < 2 OR nums[read_index] ≠ nums[write_index-2] ? // 判斷是否允許寫入此元素  \n        Yes → nums[write_index] ← nums[read_index] // 允許此元素，複製到寫入位置  \n            → write_index ← write_index + 1 // 更新寫入指標  \n        No → // 跳過此元素，因為已經有兩個相同值  \n→ return write_index // 回傳新陣列長度 k，前 k 個位置即為結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n        k = 1          # write index\n        count = 1      # current element count\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                count += 1\n            else:\n                count = 1\n            if count <= 2:\n                nums[k] = nums[i]\n                k += 1\n        return k\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，提取陣列部分並使用 ast.literal_eval 轉成 list。\n    允許輸入形式為 'nums = [1,1,1,2,2,3]' 等。\n    \"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        return []\n    list_str = data[start:end + 1]\n    return ast.literal_eval(list_str)\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # 準備輸出，將多餘位置用 '_' 代替\n    out_parts = []\n    for i in range(len(nums)):\n        out_parts.append(str(nums[i]) if i < k else '_')\n    result = f\"{k}, nums = [{','.join(out_parts)}]\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "success": true,
          "output": "5, nums = [1,1,2,2,3,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "success": true,
          "output": "7, nums = [0,0,1,1,2,3,3,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode29.json",
    "problem_index_in_file": 0,
    "title": "Divide Two Integers",
    "description_snippet": "Given two integers dividend and divisor, divide two integers without using multiplication, division,...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for dividing two integers without using multiplication, division, and mod. Use bit shift, subtraction, maybe long. Use 32-bit limits. Provide steps: convert to long, handle signs, use bitwise left shifts, accumulate result.\n\nWe need to output step by step lines in virtual code format with explanations. Must not output actual code, only pseudo-steps. Each line includes \"→ Step X: ...\" with explanation.\n\nLet's craft:\n\nStart\n→ Step 1: Convert dividend and divisor to long to avoid overflow // for safe operations\n→ Step 2: Determine sign of result based on XOR of signs // negative if signs differ\n→ Step 3: Take absolute values of dividend and divisor // use positive values for calculation\n→ Decision: If divisor == 0? // handle divide by zero\n    Yes → Step 4: Return MAX_INT // or error\n    No → Continue\n→ Step 5: Initialize quotient = 0 // store result\n→ Step 6: Loop while dividend_abs >= divisor_abs // perform repeated subtraction via shifts\n    → Decision: Find the largest shift such that (divisor_abs << shift) <= dividend_abs\n        Use inner loop or binary search\n        If found shift:\n            → Step 7: Subtract (divisor_abs << shift) from dividend_abs // reduce dividend\n            → Step 8: Add (1 << shift) to quotient // accumulate quotient\n        Else\n            → Break loop\n→ Step 9: Apply sign to quotient // if negative, make negative\n→ Decision: If quotient > INT_MAX? // clamp\n    Yes → Step 10: Set quotient = INT_MAX\n    No → Continue\n→ Decision: If quotient < INT_MIN? // clamp\n    Yes → Step 11: Set quotient = INT_MIN\n    No → Continue\n→ Step 12: Return quotient // final result\nEnd\n\nNeed to use \"Decision:\" lines with Yes →, No →. Provide explanation after //.\n\nAlso we need to ensure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 dividend 與 divisor 轉為 long 型別以避免溢位 // 使用長整數確保計算安全  \n→ Step 2: 計算結果符號：若 dividend 與 divisor 符號不同則結果為負 // 簡單透過 XOR 判斷  \n→ Step 3: 取得 dividend 與 divisor 的絕對值 // 以正整數進行除法計算  \n→ Decision: 若 divisor_abs 為 0? // 檢查除數是否為零  \n  Yes → Step 4: 回傳 INT_MAX // 0 除以 0 以最大整數回應  \n  No → （繼續執行）  \n→ Step 5: 初始化 quotient 為 0 // 用來累加除法結果  \n→ Step 6: 當 dividend_abs >= divisor_abs 時重複以下流程 // 進行位移減法除法  \n  → Decision: 找到最大的 shift 使得 divisor_abs << shift <= dividend_abs  \n   Yes → Step 7: dividend_abs = dividend_abs - (divisor_abs << shift) // 減去位移後的除數  \n    → Step 8: quotient = quotient + (1 << shift) // 累加對應的位移商  \n   No → （跳出迴圈）  \n→ Step 9: 若結果應為負則 quotient = -quotient // 應用符號  \n→ Decision: 若 quotient > INT_MAX? // 檢查是否超過 32 位最大值  \n  Yes → Step 10: quotient = INT_MAX // 進行上限裁剪  \n  No → （繼續）  \n→ Decision: 若 quotient < INT_MIN? // 檢查是否低於 32 位最小值  \n  Yes → Step 11: quotient = INT_MIN // 進行下限裁剪  \n  No → （繼續）  \n→ Step 12: 回傳 quotient // 給出除法最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2 ** 31 - 1\nINT_MIN = -2 ** 31\n\ndef divide(dividend: int, divisor: int) -> int:\n    # Handle overflow when dividend is INT_MIN and divisor is -1\n    if dividend == INT_MIN and divisor == -1:\n        return INT_MAX\n\n    # Determine sign of the result\n    negative = (dividend < 0) != (divisor < 0)\n\n    # Work with absolute values to simplify the loop\n    dividend_abs = abs(dividend)\n    divisor_abs = abs(divisor)\n\n    # Edge case: divisor is 0 (not expected by problem constraints)\n    if divisor_abs == 0:\n        return INT_MAX\n\n    quotient = 0\n\n    # Repeatedly subtract multiples of divisor using bit shifts\n    while dividend_abs >= divisor_abs:\n        temp = divisor_abs\n        multiple = 1\n        # Double temp until it is just below dividend_abs\n        while dividend_abs >= (temp << 1):\n            temp <<= 1\n            multiple <<= 1\n        dividend_abs -= temp\n        quotient += multiple\n\n    # Apply sign\n    if negative:\n        quotient = -quotient\n\n    # Clamp to 32-bit signed integer range\n    if quotient > INT_MAX:\n        return INT_MAX\n    if quotient < INT_MIN:\n        return INT_MIN\n\n    return quotient\n\nif __name__ == \"__main__\":\n    # Read all input from stdin, extract integers\n    data = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', data)\n    if len(numbers) >= 2:\n        dividend = int(numbers[0])\n        divisor = int(numbers[1])\n        result = divide(dividend, divisor)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dividend = 10, divisor = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "dividend = 7, divisor = -3",
          "expected_output": "-2",
          "success": true,
          "output": "-2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode290.json",
    "problem_index_in_file": 0,
    "title": "Word Pattern",
    "description_snippet": "Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match,...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. Need to generate steps for algorithm: check if string s follows pattern bijection. Approach: split s by spaces into words list. If len(pattern)!=len(words) return False. Use two dicts: char->word, word->char. Iterate over pattern and words. For each pair, check mapping consistency. If conflict return False. After loop return True. Also handle invalid inputs. Provide Start End, Decision etc.\n\nMake sure each line includes virtual code step and explanation comment. Use arrow. Eg: Start // 程式開始執行.\n\nWe need to output step by step. Provide each line with code step. Use \"→\" for transitions. Use Decision lines with Yes/No branches. Provide explanation after //.\n\nWe must not output actual code, just pseudocode. Should be in Chinese. Provide explanation. Use arrow. Provide decisions. Use Start End.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 將 s 以空格分割成 words // 取得單字列表\n\nLine 3: → Step 2: 如果 len(pattern) ≠ len(words)？ // 檢查模式長度與單字數是否相同\n\nLine 4:   Yes → Step 3: 回傳 False // 不相同則無法對應\n\nLine 5:   No  → Step 4: 初始化空字典 charToWord, wordToChar // 建立映射關係\n\nLine 6: → Step 5: 循環 i 從 0 到 len(pattern)-1 // 遍歷每個字母和對應單字\n\nLine 7:     → Decision: pattern[i] 已在 charToWord? // 判斷是否已有映射\n\nLine 8:         Yes → Decision: charToWord[pattern[i]] ≠ words[i]? // 比對已映射單字是否一致\n\nLine 9:             Yes → Step 6: 回傳 False // 映射不一致，失敗\n\nLine 10:            No  → Decision: words[i] 已在 wordToChar 且 wordToChar[words[i]] ≠ pattern[i]? // 檢查單字是否被映射到其他字母\n\nLine 11:                Yes → Step 7: 回傳 False // 單字已被其他字母使用，失敗\n\nLine 12:                No  → Step 8: (無需做任何事) // 一致性已確認\n\nLine 13:         No → Decision: words[i] 已在 wordToChar? // 沒有映射，先檢查單字是否已被其他字母映射\n\nLine 14:             Yes → Step 9: 回傳 False // 會產生衝突，失敗\n\nLine 15:             No  → Step 10: 添加映射 charToWord[pattern[i]] = words[i], wordToChar[words[i]] = pattern[i] // 建立新映射\n\nLine 16: → Step 11: 回傳 True // 所有對應一致，成功\n\nLine 17: End // 程式執行結束\n\nBut we need to ensure each line has single step and explanation. Maybe group decisions into single lines with substeps.\n\nMake sure to include arrow and spaces properly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 s 以空格分割成 words // 取得單字列表  \n→ Step 2: 如果 len(pattern) ≠ len(words)？ // 檢查模式長度與單字數是否相同  \n    Yes → Step 3: 回傳 False // 不相同則無法對應  \n    No  → Step 4: 初始化空字典 charToWord, wordToChar // 建立映射關係  \n→ Step 5: 循環 i 從 0 到 len(pattern)-1 // 遍歷每個字母和對應單字  \n    → Decision: pattern[i] 已在 charToWord? // 判斷是否已有映射  \n        Yes → Decision: charToWord[pattern[i]] ≠ words[i]? // 比對已映射單字是否一致  \n            Yes → Step 6: 回傳 False // 映射不一致，失敗  \n            No  → Decision: words[i] 已在 wordToChar 且 wordToChar[words[i]] ≠ pattern[i]? // 檢查單字是否被映射到其他字母  \n                Yes → Step 7: 回傳 False // 單字已被其他字母使用，失敗  \n                No  → Step 8: (無需做任何事) // 一致性已確認  \n        No → Decision: words[i] 已在 wordToChar? // 沒有映射，先檢查單字是否已被其他字母映射  \n            Yes → Step 9: 回傳 False // 會產生衝突，失敗  \n            No  → Step 10: 添加映射 charToWord[pattern[i]] = words[i], wordToChar[words[i]] = pattern[i] // 建立新映射  \n→ Step 11: 回傳 True // 所有對應一致，成功  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n\n        char_to_word = {}\n        word_to_char = {}\n\n        for c, w in zip(pattern, words):\n            if c in char_to_word:\n                if char_to_word[c] != w:\n                    return False\n            else:\n                char_to_word[c] = w\n\n            if w in word_to_char:\n                if word_to_char[w] != c:\n                    return False\n            else:\n                word_to_char[w] = c\n\n        return True\n\ndef parse_input(text: str):\n    # Try to find pattern and s in the format:\n    # pattern = \"abba\", s = \"dog cat cat dog\"\n    pattern_match = re.search(r'pattern\\s*=\\s*\"([^\"]+)\"', text)\n    s_match = re.search(r's\\s*=\\s*\"([^\"]+)\"', text)\n    if pattern_match and s_match:\n        return pattern_match.group(1), s_match.group(1)\n    # Fallback: assume first line is pattern, second line is s\n    lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # If only one line, treat it as s and pattern is empty\n    return '', text.strip()\n\ndef main():\n    data = sys.stdin.read()\n    pattern_str, s_str = parse_input(data)\n    solution = Solution()\n    result = solution.wordPattern(pattern_str, s_str)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode581.json",
    "problem_index_in_file": 0,
    "title": "Shortest Unsorted Continuous Subarray",
    "description_snippet": "Given an integer array nums, you need to find one continuous subarray such that if you only sort thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that solve the problem: find minimal subarray that if sorted will make whole array sorted. Equivalent to known LeetCode problem 581. Steps: find left boundary where array goes out of order, right boundary similarly, then adjust left by checking min of subarray, right by max. Output length = right-left+1 else 0.\n\nWe need to produce line-by-line pseudocode, with arrows and decisions. Provide explanation per line.\n\nLet's write.\n\nStart\n\n→ Step 1: n ← length(nums) // array size\n\n→ Step 2: left ← n // initial left boundary as n (sentinel)\n\n→ Step 3: right ← 0 // initial right boundary as 0\n\n→ Step 4: max_val ← nums[0] // current maximum while iterating left to right\n\n→ Decision: Iterate i from 0 to n-1 // scan array\n\n    → Step 5: If nums[i] < max_val Then // out of order on left side\n        → Step 6: left ← min(left, i) // update left boundary\n    → End Decision\n\n    → Step 7: max_val ← max(max_val, nums[i]) // update maximum\n\n→ End Decision\n\n→ Step 8: min_val ← nums[n-1] // current minimum while iterating right to left\n\n→ Decision: Iterate i from n-1 downto 0\n\n    → Step 9: If nums[i] > min_val Then // out of order on right side\n        → Step 10: right ← max(right, i) // update right boundary\n    → End Decision\n\n    → Step 11: min_val ← min(min_val, nums[i]) // update minimum\n\n→ End Decision\n\n→ Decision: If right - left + 1 > 0 Then // subarray exists\n        Yes → Step 12: result ← right - left + 1 // length\n        No → Step 12: result ← 0 // already sorted\n→ End Decision\n\n→ End // output result\n\nNeed to keep each line with arrow and comment. Use structure: Start, End, Decision: Yes→, No→.\n\nLet's craft.\n\nUse proper arrow formatting.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: left ← n // 初始化左邊界為 n（最大可能值）  \n→ Step 3: right ← 0 // 初始化右邊界為 0  \n→ Step 4: max_val ← nums[0] // 左至右掃描時的最大值  \n\nDecision: 從 0 到 n-1 迭代陣列  \n    → Step 5: If nums[i] < max_val Then // 此位置小於前面最大值，表示左邊界需更新  \n        → Step 6: left ← min(left, i) // 設置最左邊不符合排序的索引  \n    → End Decision  \n    → Step 7: max_val ← max(max_val, nums[i]) // 更新最大值  \n→ End Decision  \n\n→ Step 8: min_val ← nums[n-1] // 右至左掃描時的最小值  \n\nDecision: 從 n-1 到 0 迭代陣列  \n    → Step 9: If nums[i] > min_val Then // 此位置大於後面最小值，表示右邊界需更新  \n        → Step 10: right ← max(right, i) // 設置最右邊不符合排序的索引  \n    → End Decision  \n    → Step 11: min_val ← min(min_val, nums[i]) // 更新最小值  \n→ End Decision  \n\nDecision: 是否存在需要排序的子陣列？  \n    Yes → Step 12: result ← right - left + 1 // 子陣列長度  \n    No  → Step 12: result ← 0 // 陣列已經排序  \n→ End Decision  \n\nEnd // 程式執行結束，輸出 result。",
      "generated_code": "import sys\n\ndef find_unsorted_subarray(nums):\n    n = len(nums)\n    # 如果数组为空或只有一个元素，已经有序\n    if n <= 1:\n        return 0\n\n    left, right = n, 0\n    max_so_far = nums[0]\n    # 从左往右扫描，寻找左边界\n    for i in range(n):\n        if nums[i] < max_so_far:\n            left = min(left, i)\n        max_so_far = max(max_so_far, nums[i])\n\n    min_so_far = nums[-1]\n    # 从右往左扫描，寻找右边界\n    for i in range(n - 1, -1, -1):\n        if nums[i] > min_so_far:\n            right = max(right, i)\n        min_so_far = min(min_so_far, nums[i])\n\n    # 如果没有需要排序的子数组，right <= left\n    return right - left + 1 if right > left else 0\n\ndef parse_input(input_str):\n    \"\"\"\n    解析类似 'nums = [1, 2, 3]' 的字符串，返回整数列表。\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n\n    # 尝试寻找 '[' 和 ']' 之间的内容\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start != -1 and end != -1 and start < end:\n        try:\n            return eval(input_str[start:end+1])\n        except Exception:\n            pass\n\n    # 退化为空列表\n    return []\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    result = find_unsorted_subarray(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '3'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode400.json",
    "problem_index_in_file": 0,
    "title": "Nth Digit",
    "description_snippet": "Given an integer n, return the n^th digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step. We have to follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrow arrows, Start, End, Decision. We need to find nth digit of infinite sequence. Approach: iterate digits length groups. Each number contributes digits. We need to find block where cumulative digits reach n.\n\nPseudo:\n\nStart\n→ Initialize len=1 // current number length\n→ Initialize count=9 // numbers with current length\n→ Initialize base=1 // first number of current length\n→ Initialize n_temp = n\n→ Decision: while n_temp > len*count? if yes subtract and move to next block\n→ Else found block\nAfter loop:\nCompute offset = (n_temp-1)/len // number index offset from base\nCompute targetNumber = base + offset\nCompute digitIndex = (n_temp-1) % len\nConvert targetNumber to string, get digit at digitIndex\n→ Output digit\nEnd\n\nLet's produce each line.\n\nEnsure each line ends with // explanation.\n\nInclude decision indentation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 n_temp ← n // 把輸入的 n 存到暫存變數\n→ Step 2: 設定 len ← 1 // 目前處理的數字位數\n→ Step 3: 設定 count ← 9 // 同位數的數字個數（1~9）\n→ Step 4: 設定 base ← 1 // 同位數數字的起始值\n→ Decision: n_temp > len * count? // 判斷 n 是否超過當前位數區塊的總位數\n    Yes → Step 5: n_temp ← n_temp - len * count // 把超過的位數減掉\n        → Step 6: len ← len + 1 // 位數增加\n        → Step 7: count ← count * 10 // 同位數數字個數翻倍\n        → Step 8: base ← base * 10 // 同位數起始值翻倍\n        → Decision: n_temp > len * count? // 重新檢查，若還大則重複\n            Yes → (回到 Step 5) // 迴圈繼續\n            No  → (結束迴圈) // 進入下一步\n    No  → (進入下一步) // 已在正確區塊\n→ Step 9: offset ← (n_temp - 1) // len // 找到目標數字在區塊內的索引\n→ Step 10: targetNumber ← base + offset // 取得目標數字\n→ Step 11: digitIndex ← (n_temp - 1) % len // 目標數字中要取的位數索引\n→ Step 12: digit ← 取得 targetNumber 的 digitIndex 位置的位數 // 轉成字串後取字符\n→ Step 13: 輸出 digit // 回傳結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef find_nth_digit(n: int) -> int:\n    \"\"\"\n    依序把 1, 2, 3, … 這些整數拼成一長串\n    取第 n 位（1 進位）所對應的數字。\n    \"\"\"\n    length = 1          # 目前處理的位數\n    count = 9           # 同位數的數字個數\n    start = 1           # 同位數數字的起始值\n\n    # 循環直到第 n 位落在目前的位數區塊內\n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # 在此區塊內，計算實際的數字與索引\n    start += (n - 1) // length\n    s = str(start)\n    return int(s[(n - 1) % length])\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有文字，並找出第一個整數作為 n\n    raw_input = sys.stdin.read()\n    match = re.search(r'\\d+', raw_input)\n    if not match:\n        raise ValueError(\"輸入中必須包含一個整數 n\")\n    n = int(match.group())\n\n    # 計算並輸出結果\n    result = find_nth_digit(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 11",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode769.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted",
    "description_snippet": "You are given an integer array arr of length n that represents a permutation of the integers in the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm. Problem: largest number of chunks to sort array. Known solution: iterate through array, track max index seen so far. When max index equals current index, we can increment chunk count. So steps: start, read array, initialize maxSeen, chunkCount, loop i from 0 to n-1: update maxSeen = max(maxSeen, arr[i]); if maxSeen == i: chunkCount++. End. Return chunkCount.\n\nWe need to output each line with virtual code arrow and explanation. Use virtual code syntax. Provide Start, End, Decision, etc. Should be step-by-step. Provide arrow → etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 arr 以及其長度 n // 取得輸入資料\n→ Step 2: 初始化變數 maxSeen ← -1, chunkCount ← 0 // maxSeen 追蹤目前已見的最大值，chunkCount 計數區塊數\n→ Step 3: 循環 i 從 0 到 n-1 // 遍歷陣列每個索引\n    → Decision: 是否更新 maxSeen? // 判斷當前值是否大於已知最大值\n        Yes → maxSeen ← max(maxSeen, arr[i]) // 若更大則更新 maxSeen\n        No  → 無操作 // 若不大則保持原值\n    → Decision: maxSeen 是否等於 i? // 檢查是否可以切分區塊\n        Yes → chunkCount ← chunkCount + 1 // 能切分，累加區塊計數\n        No  → 無操作 // 不能切分，繼續遍歷\n→ End // 瀏覽完所有索引\n→ Step 4: 輸出 chunkCount // 回傳最大的區塊數目\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        Calculate the maximum number of chunks that can be sorted independently\n        such that concatenating the sorted chunks gives the fully sorted array.\n        \"\"\"\n        chunks = 0          # number of valid chunks found\n        left_max = -1       # maximum value seen so far in the current segment\n        for i, val in enumerate(arr):\n            left_max = max(left_max, val)  # update the maximum seen\n            if left_max == i:              # if the maximum equals the index,\n                chunks += 1                # we can split here\n        return chunks\n\ndef parse_input(input_text: str):\n    \"\"\"\n    Extract the list of integers from the input string.\n    Supports formats like:\n        - 'arr = [4,3,2,1,0]'\n        - '[1,0,2,3,4]'\n    \"\"\"\n    match = re.search(r'\\[.*?\\]', input_text, re.S)\n    if not match:\n        raise ValueError(\"No list found in the input.\")\n    list_str = match.group(0)\n    return ast.literal_eval(list_str)\n\ndef main():\n    # Read all input from stdin\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        return\n    arr = parse_input(input_text)\n    sol = Solution()\n    result = sol.maxChunksToSorted(arr)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [4,3,2,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [1,0,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode504.json",
    "problem_index_in_file": 0,
    "title": "Base 7",
    "description_snippet": "Given an integer num, return a string of its base 7 representation....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode, line by line, each line with code step and comment after space.\n\nWe need steps: Start, input num, handle zero case, negative sign, compute base 7 representation by division and remainder, build string (maybe using stack or building reversed then reverse). Use Decision for zero. Also use Decision for negative. At the end output string. Use End.\n\nWe must not output actual code. Use virtual code. Use arrows: \"→\" before each step.\n\nLet's create lines:\n\nStart\n→ Input: num // 取得輸入整數\n→ Decision: 如果 num 等於 0? // 檢查是否為 0\n    Yes → Output: \"0\" // 直接輸出 0\n    No  → Decision: 如果 num 小於 0? // 判斷是否為負數\n        Yes → Step: sign = \"-\" // 記錄負號\n             → num = -num // 取正值\n        No  → Step: sign = \"\" // 無符號\n→ Step: result = \"\" // 用於累積剩餘位數\n→ Step: 循環: 當 num > 0 時\n    → Step: remainder = num mod 7 // 取餘數\n    → Step: result = remainder + result // 將餘數加入字串前面\n    → Step: num = num // 7 // 除以 7 取整\n→ Step: finalString = sign + result // 拼接符號與位數\n→ Output: finalString // 回傳最終字串\nEnd\n\nBut we need arrow \"→\" before each step. For Decision lines we need indentation and Yes→ and No→. Provide in plain text.\n\nWe need each line in format \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nLet's produce. Use Chinese comments.\n\nAlso ensure proper indentation: maybe use 4 spaces before Yes→ lines.\n\nLet's generate:\n\nStart // 程式開始執行\n→ Input: num // 取得使用者輸入的整數\n→ Decision: 如果 num 等於 0? // 判斷輸入是否為零\n    Yes → Output: \"0\" // 若為零，直接輸出字串 \"0\"\n    No  → Decision: 如果 num 小於 0? // 判斷是否為負數\n        Yes → Step: sign = \"-\" // 記錄負號\n             → Step: num = -num // 將 num 轉為正數\n        No  → Step: sign = \"\" // 正數不需要符號\n→ Step: result = \"\" // 用於儲存計算得到的 base7 字串\n→ Step: 循環: 當 num > 0 時\n    → Step: remainder = num mod 7 // 取得 num 除以 7 的餘數\n    → Step: result = remainder + result // 將餘數加到結果字串前面\n    → Step: num = num // 7 // 更新 num 為整數除法結果\n→ Step: finalString = sign + result // 將符號與結果串接成最終字串\n→ Output: finalString // 回傳 base7 表示字串\nEnd // 程式執行結束\n\nNeed to check formatting: each line must start with \"Start\" or \"→\". Decision lines use indentation.\n\nWe must ensure each line ends with // comment.\n\nAll lines produce valid virtual code. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: num // 取得使用者輸入的整數  \n→ Decision: 如果 num 等於 0? // 判斷輸入是否為零  \n    Yes → Output: \"0\" // 若為零，直接輸出字串 \"0\"  \n    No  → Decision: 如果 num 小於 0? // 判斷是否為負數  \n        Yes → Step: sign = \"-\" // 記錄負號  \n             → Step: num = -num // 將 num 轉為正數  \n        No  → Step: sign = \"\" // 正數不需要符號  \n→ Step: result = \"\" // 用於儲存計算得到的 base7 字串  \n→ Step: 循環: 當 num > 0 時  \n    → Step: remainder = num mod 7 // 取得 num 除以 7 的餘數  \n    → Step: result = remainder + result // 將餘數加到結果字串前面  \n    → Step: num = num // 7 // 更新 num 為整數除法結果  \n→ Step: finalString = sign + result // 將符號與結果串接成最終字串  \n→ Output: finalString // 回傳 base7 表示字串  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def convertToBase7(self, num: int) -> str:\n        \"\"\"將整數轉換為 base 7 字串\"\"\"\n        if num == 0:\n            return \"0\"\n        neg = num < 0\n        num = abs(num)\n        digits = []\n        while num > 0:\n            digits.append(str(num % 7))\n            num //= 7\n        if neg:\n            digits.append('-')\n        return ''.join(reversed(digits))\n\n\ndef main() -> None:\n    import sys\n\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    num = int(data)\n    solution = Solution()\n    result = solution.convertToBase7(num)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "100",
          "expected_output": "\"202\"",
          "success": true,
          "output": "202"
        },
        {
          "example_index": 1,
          "input": "-7",
          "expected_output": "\"-10\"",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode460.json",
    "problem_index_in_file": 0,
    "title": "LFU Cache",
    "description_snippet": "Design and implement a data structure for a Least Frequently Used (LFU) cache.\n\nImplement the LFUCac...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for LFU cache with O(1) operations. Use typical design: maintain freq map, key map, freq lists using doubly linked lists. Provide steps for initialization, get, put, internal update frequency, eviction. We need to produce step-by-step with arrows and decisions. Provide explanation comments. Each line is a \"虛擬碼步驟\". The format: line: code + space + // explanation.\n\nLet's design algorithm:\n\nStart\n→ Initialize capacity, minFreq, keyMap, freqMap.\n\nGet(key):\n→ If key not in keyMap: return -1\n→ Retrieve node, val\n→ Call increaseFreq(node)\n→ Return val\n\nincreaseFreq(node):\n→ oldFreq = node.freq\n→ Remove node from freqMap[oldFreq] list\n→ If freqMap[oldFreq] empty and oldFreq == minFreq: minFreq++\n→ node.freq++\n→ Add node to freqMap[node.freq] list at front (most recently used in that freq)\n→ Done\n\nPut(key, value):\n→ If capacity == 0: return\n→ If key exists:\n    → Update node.val = value\n    → Call increaseFreq(node)\n    → Return\n→ If size == capacity:\n    → Evict node from freqMap[minFreq] list tail (least recently used in minFreq)\n    → Remove key from keyMap\n    → Remove node from freqMap[minFreq] list\n→ Create new node with key, value, freq=1\n→ Add node to keyMap\n→ Add node to freqMap[1] list at front\n→ minFreq = 1\n\nEviction details: freqMap is map from freq to doubly linked list (head, tail). We maintain ordering by recency: head is most recent, tail is least recent. In eviction, choose tail of minFreq list.\n\nWe'll output as virtual code with decisions. Use arrows. Each line: step description.\n\nNeed to ensure we output in lines; each line must be separate. Use \"Start\" and \"End\".\n\nWe need to structure:\n\nStart\n→ Initialize LFUCache with capacity // set capacity\n→ Set minFreq = 0\n→ Create empty keyMap\n→ Create empty freqMap\nEnd\n\nBut we need to produce code for class methods? Possibly produce separate sections: Constructor, get, put. But requirement: \"逐行地產生對應的虛擬碼\" based on user requirement. So we should produce virtual code that defines the structure and operations. So we can write:\n\nStart // 程式開始\n→ Step 1: Define LFUCache class with capacity, minFreq, keyMap, freqMap // 初始化\n...\n\nWe need to maintain clarity.\n\nLet's produce algorithm step by step with decisions. Provide explanation comment for each line.\n\nWe'll output the entire algorithm as series of lines. We'll use indent for decisions. Provide arrow lines.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始，建立 LFUCache 結構  \n→ Step 1: 定義 LFUCache 類別並宣告以下變數  \n  → capacity : int // 最大容量  \n  → minFreq : int // 最小頻率（即目前最少使用的頻率）  \n  → keyMap : Map<int, Node> // key → Node，快速查找  \n  → freqMap : Map<int, DoublyLinkedList<Node>> // frequency → 連結表，存放同一頻率的節點  \n\n→ Constructor(capacity) // 初始化  \n  → Set this.capacity = capacity  \n  → Set this.minFreq = 0  \n  → Initialize this.keyMap as empty map  \n  → Initialize this.freqMap as empty map  \n\n// ---------- Node 定義 ----------  \n→ Node(key, value, freq = 1) // 節點包含 key、value、頻率  \n  → key, value, freq  \n  → prev, next // 連結表節點指標  \n\n// ---------- DoublyLinkedList ----------  \n→ DLList()  \n  → head, tail // 佔位節點，方便操作  \n  → size = 0  \n\n→ DLList.addToHead(node) // 在頻率表頭插入（最新使用）  \n  → Insert node after head  \n\n→ DLList.remove(node) // 從表中移除節點  \n  → Adjust prev.next and next.prev  \n\n→ DLList.removeTail() // 移除最舊節點（尾部）  \n  → Remove node before tail and return it  \n\n// ---------- get 方法 ----------  \n→ get(key)  \n  → Decision: key 是否在 keyMap?  \n    Yes → Step 1: node = keyMap[key] // 取得節點  \n      → Step 2: val = node.value  \n      → Step 3: call increaseFreq(node) // 更新頻率  \n      → Return val  \n    No → Return -1 // 缺失時回傳 -1  \n\n// ---------- put 方法 ----------  \n→ put(key, value)  \n  → Decision: capacity == 0?  \n    Yes → Return // 無容量無法放入  \n    No → Continue  \n\n  → Decision: key 是否在 keyMap?  \n    Yes → Step 1: node = keyMap[key] // 已存在  \n      → node.value = value // 更新值  \n      → call increaseFreq(node) // 更新頻率  \n      → Return  \n    No → Continue  \n\n  → Decision: keyMap.size == capacity?  \n    Yes → Step 1: lfuNode = freqMap[minFreq].removeTail() // 找最少頻率最舊節點  \n      → Remove lfuNode.key from keyMap  \n      → If freqMap[minFreq] 變為空，刪除該鍵（可選）  \n      → Continue  \n    No → Continue  \n\n  → Step 2: newNode = Node(key, value, freq=1)  \n  → keyMap[key] = newNode  \n  → If freqMap[1] 不存在，建立新的 DLList  \n  → freqMap[1].addToHead(newNode)  \n  → minFreq = 1 // 新節點頻率為 1，重設最小頻率  \n\n// ---------- increaseFreq 方法 ----------  \n→ increaseFreq(node)  \n  → oldFreq = node.freq  \n  → freqMap[oldFreq].remove(node) // 從舊頻率表移除  \n  → If freqMap[oldFreq].size == 0 AND oldFreq == minFreq?  \n    Yes → minFreq = oldFreq + 1 // 更新最小頻率  \n    No → Continue  \n\n  → node.freq = oldFreq + 1  \n  → If freqMap[node.freq] 不存在，建立新的 DLList  \n  → freqMap[node.freq].addToHead(node) // 新頻率表頭部插入  \n\nEnd // 程式結束，整體流程完成",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}  # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys preserving LRU order\n\n    def _update(self, key: int) -> None:\n        \"\"\"Increase frequency of the key after get/put access.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current frequency list\n        del self.freq_to_keys[freq][key]\n        # If this was the only key with the minimum frequency, increment min_freq\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Insert key into the next higher frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict the least frequently used key, break ties by LRU (OrderedDict popitem(last=False))\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key with frequency 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    # Parse input: could be one line with two lists, or two separate lines\n    lines = input_data.splitlines()\n    if len(lines) == 1:\n        # Combine into a tuple for literal_eval\n        data = ast.literal_eval(\"(\" + lines[0] + \")\")\n    else:\n        ops = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n        data = (ops, args)\n\n    ops, args = data\n\n    result = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            result.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            result.append(None)\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            result.append(val)\n        else:\n            # Unknown operation; skip or handle as needed\n            result.append(None)\n\n    # Convert result to LeetCode-style output (null for None)\n    output = \"[\" + \", \".join(\"null\" if v is None else str(v) for v in result) + \"]\"\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "success": true,
          "output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode241.json",
    "problem_index_in_file": 0,
    "title": "Different Ways to Add Parentheses",
    "description_snippet": "Given a string expression of numbers and operators, return all possible results from computing all t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for problem: compute all possible results from different ways to parenthesize expression with numbers and operators. This is classic LeetCode 241. We'll produce virtual pseudocode steps. Use Start, Decision, etc. Each line should be virtual code + explanation comment. We'll generate a recursive divide and conquer approach, use memoization, base case when no operator. Also mention parsing string to list tokens.\n\nLet's produce line-by-line:\n\nStart // start\n\n→ Step 1: Parse expression into tokens list // split numbers and operators\n\n→ Decision: if tokens list contains no operator? // base case\n\n   Yes → Step 2: Return list containing single integer token // only one number\n\n   No  → Step 3: Initialize results list // to store all possible results\n\n→ Step 4: For each index i in tokens where token is operator // iterate over operators\n\n   → Step 5: leftTokens = tokens[0:i] // left subexpression\n\n   → Step 6: rightTokens = tokens[i+1:] // right subexpression\n\n   → Step 7: leftResults = Recursively compute leftTokens // get all left results\n\n   → Step 8: rightResults = Recursively compute rightTokens // get all right results\n\n   → Decision: if operator == '+'? // compute combinations\n\n      Yes → Step 9: For each l in leftResults, for each r in rightResults: add l+r to results\n\n      No → Decision: if operator == '-'?\n\n         Yes → Step 10: For each l, r: add l-r to results\n\n         No → Decision: if operator == '*'?\n\n            Yes → Step 11: For each l, r: add l*r to results\n\n   → End of operator loop\n\n→ Step 12: Return results // after exploring all splits\n\n→ End // program end\n\nBut need to show memoization: we can add a cache dictionary mapping expression string to results.\n\nWe'll integrate that: before parsing tokens, check memo.\n\nLet's restructure with a function.\n\nWe'll produce Virtual steps: maybe:\n\n→ Function diffWays(expr) // compute all results for expr\n\nBut we need to output each line.\n\nLet's produce:\n\nStart // start\n\n→ Step 1: Define Function DiffWays(expr) // recursive function\n\n   → Decision: if expr in memo? // check cache\n\n      Yes → Step 2: Return memo[expr] // cached result\n\n      No  → Step 3: Parse expr into tokens list // split numbers and operators\n\n      → Decision: tokens contain no operator? // base case\n\n          Yes → Step 4: Return [int(tokens[0])] // single number result\n\n          No  → Step 5: Initialize resultList // list for storing results\n\n          → For each index i, token in tokens where token is operator // iterate operators\n\n              → Step 6: leftExpr = join tokens[0:i] // left part string\n\n              → Step 7: rightExpr = join tokens[i+1:] // right part string\n\n              → Step 8: leftResults = DiffWays(leftExpr) // recursive\n\n              → Step 9: rightResults = DiffWays(rightExpr) // recursive\n\n              → For each l in leftResults\n\n                  → For each r in rightResults\n\n                      → Decision: token == '+'?\n\n                          Yes → Step 10: Append l + r to resultList\n\n                          No → Decision: token == '-'?\n\n                              Yes → Step 11: Append l - r to resultList\n\n                              No → Step 12: Append l * r to resultList\n\n          → Step 13: memo[expr] = resultList // cache result\n\n          → Step 14: Return resultList\n\n→ End // end\n\nBut each line must be formatted as virtual code plus comment.\n\nLet's produce each line accordingly.\n\nMake sure to use arrow characters and indent? The example shows arrow preceding step. We'll just keep arrow on each line. Use \"→\" and \"Decision:\" etc.\n\nWill produce lines like:\n\nStart // 程式開始\n\n→ Step 1: Define Function DiffWays(expr) // 定義遞迴函式\n\n→ Decision: if expr in memo? // 檢查是否已計算過\n\n    Yes → Step 2: Return memo[expr] // 回傳快取結果\n\n    No  → Step 3: Parse expr into tokens list // 把字串拆成數字與運算符\n\n... etc.\n\nNeed to use indentation? The example uses indentation for decisions. We'll mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: Define Function DiffWays(expr) // 定義遞迴函式，用來計算所有可能的結果\n\n→ Decision: if expr in memo? // 檢查是否已經計算並快取過該子表達式的結果\n\n  Yes → Step 2: Return memo[expr] // 若已快取，直接回傳快取值，避免重複計算\n\n  No  → Step 3: Parse expr into tokens list // 將字串拆成數字與運算符的列表，例如「2*3-4*5」→[2, *, 3, -, 4, *, 5]\n\n→ Decision: tokens list contains no operator? // 基本情況：僅有一個數字\n\n  Yes → Step 4: Return [int(tokens[0])] // 將該數字轉成整數，並包裝在單一元素的列表中\n\n  No  → Step 5: Initialize resultList // 用於存放所有可能的計算結果\n\n    → For each index i, token in tokens where token is operator // 遍歷所有運算符，將表達式分成左右兩部分\n\n     → Step 6: leftExpr = join tokens[0:i] // 取得左邊子表達式的字串，例如「2*3」\n\n     → Step 7: rightExpr = join tokens[i+1:] // 取得右邊子表達式的字串，例如「4*5」\n\n     → Step 8: leftResults = DiffWays(leftExpr) // 递归計算左邊子表達式的所有結果\n\n     → Step 9: rightResults = DiffWays(rightExpr) // 递归計算右邊子表達式的所有結果\n\n     → For each l in leftResults\n\n      → For each r in rightResults\n\n        → Decision: token == '+'? // 根據運算符計算組合結果\n\n          Yes → Step 10: Append l + r to resultList // 加法結果加入列表\n\n          No → Decision: token == '-'?\n\n           Yes → Step 11: Append l - r to resultList // 減法結果加入列表\n\n           No → Step 12: Append l * r to resultList // 乘法結果加入列表\n\n      → End of inner loops\n\n    → End of operator loop\n\n    → Step 13: memo[expr] = resultList // 將計算完成的結果快取起來，以便未來重複使用\n\n    → Step 14: Return resultList // 返回所有可能的計算結果\n\n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:  # '*'\n                                res.append(l * r)\n\n            if not res:          # no operator found → single number\n                res.append(int(expr))\n\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract expression string between double quotes if present\n    match = re.search(r'\"([^\"]*)\"', data)\n    expression = match.group(1) if match else data.strip()\n    result = Solution().diffWaysToCompute(expression)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[2,0]",
          "success": true,
          "output": "[2, 0]"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-10,-14,-10,10]",
          "success": true,
          "output": "[-34, -10, -14, -10, 10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode260.json",
    "problem_index_in_file": 0,
    "title": "Single Number III",
    "description_snippet": "Given an integer array nums, in which exactly two elements appear only once and all the other elemen...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: given array, find two unique numbers, rest duplicate. Use XOR to get xor of all, get diff bit, partition, etc. Provide step-by-step with decision, arrow, comments. No actual code. Use Start, End, Decision. We'll do: Start, Step1: compute xor of all nums -> uniqueXor, Step2: find rightmost set bit via uniqueXor & -uniqueXor or using while loop. Step3: partition into two groups and XOR separately to find two uniques. Then End. Also add Decision maybe for checking empty array? Not necessary. We'll produce steps.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". So first line: \"Start // 程式開始執行\". Next arrow lines: \"→ Step 1: ... // ...\". etc. Ensure each line ends with // 解釋. Provide decision if needed. Provide use of Yes→, No→ for decisions.\n\nLet's craft.\n\nWe can include Decision for checking if array empty: \"Decision: 如果 nums 为空? // 確保輸入合法\" with Yes→ End, No→ proceed. That shows linear runtime and constant space. Might not need but fine.\n\nAlso decision for computing rightmost set bit: We can just compute directly. Might not need decision. Provide steps straightforward.\n\nWe will use \"→ Step 1: ...\" lines. Provide arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 xorSum = 0 // 用於累計所有元素的 XOR  \n→ Decision: 如果 nums 為空? // 檢查輸入是否合法  \n    Yes → Step 2: Return 空結果 // 沒有元素時無法找到兩個唯一值  \n    No  → Step 3: 對每個 num 進行 xorSum = xorSum XOR num // 取得兩個唯一數字的 XOR 結果  \n→ Step 4: 找出 xorSum 中最右邊的 1 位，設為 diffBit = xorSum AND (-xorSum) // 只為分組做標記  \n→ Step 5: 初始化 uniq1 = 0, uniq2 = 0 // 存放兩個唯一數字  \n→ Step 6: 對 nums 中的每個 num 進行  \n    → Decision: 如果 (num AND diffBit) ≠ 0? // 根據 diffBit 將 num 分入第一組  \n        Yes → uniq1 = uniq1 XOR num // 第一組內再 XOR，最後得到第一個唯一值  \n        No  → uniq2 = uniq2 XOR num // 第二組內 XOR，得到第二個唯一值  \n→ Step 7: Return [uniq1, uniq2] // 將兩個唯一數字輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        xor = 0\n        for num in nums:\n            xor ^= num\n\n        # 找到 xor 的最右邊 1\n        diff_bit = xor & -xor\n\n        a = b = 0\n        for num in nums:\n            if num & diff_bit:\n                a ^= num\n            else:\n                b ^= num\n        return [a, b]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 允許輸入格式為 \"nums = [...]\" 或僅 \"[...]\"\n    if data.startswith(\"nums\"):\n        _, nums_part = data.split(\"=\", 1)\n        nums_part = nums_part.strip()\n    else:\n        nums_part = data\n    nums = ast.literal_eval(nums_part)\n    solution = Solution()\n    result = solution.singleNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,3,2,5]",
          "expected_output": "[3,5]",
          "success": true,
          "output": "[3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0]",
          "expected_output": "[-1,0]",
          "success": true,
          "output": "[-1, 0]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,1]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode224.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator",
    "description_snippet": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and r...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for evaluating a basic calculator for a string expression. Likely includes + - * / and parentheses? They didn't specify operators, but basic calculator usually includes + - * /. We need to parse string without eval. Provide step-by-step pseudocode with arrows and decisions. No actual code. Let's generate algorithm: Use stack to handle precedence. Process characters, skip spaces. When digit, build number. When operator encountered, push to stack based on precedence. Use two stacks: numbers and operators, or use stack for values and handle multiplication/division immediate. Simpler: Use stack for numbers and handle current sign, and use prev operator. Classic solution: iterate string, maintain current number, sign. When encountering '+' or '-', push signed number. When encountering '*' or '/', pop last number, compute, push result. At end, sum stack.\n\nAlso handle parentheses: use recursion or stack to push previous sign and stack. Provide pseudocode.\n\nWe'll output lines with comments. Let's produce around 30-40 lines. Use \"Start\", \"End\". Use decisions. Provide explanations.\n\nLet's start.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空堆疊 `stack`、變數 `num = 0`、變數 `sign = '+'`、指標 `i = 0` // 準備解析輸入字串\n→ Decision: `i < len(s)`? // 是否還有字元未處理\n    Yes → Step 2: 讀取 `c = s[i]` // 取得當前字元\n    No  → Step 3: End // 所有字元已解析，結束\n→ Decision: `c` 是空格? // 忽略空白\n    Yes → Step 4: i = i + 1 → Decision: `i < len(s)`? // 跳至下一個字元\n    No  → Decision: `c` 是數字? // 是否為數字字符\n        Yes → Step 5: 建立 `num = num * 10 + int(c)` // 形成多位數\n                i = i + 1 → Decision: `i < len(s)`? // 繼續讀取數字\n        No  → Decision: `c` 是 '('? // 進入括號\n            Yes → Step 6: 記錄 `prev_sign = sign` // 保存外層符號\n                Step 7: i = i + 1 → Decision: `i < len(s)`? // 移至括號內部\n                Step 8: Call 子流程 `evaluate()` 並取得 `num` // 递归计算括号内部\n                Step 9: sign = prev_sign // 恢復外層符號\n            No  → Decision: `c` 是 '+' 或 '-'? // 判斷加減符號\n                Yes → Step 10: 處理前一個 `num` 與 `sign` // 根據前一符號將 `num` 推入堆疊或計算\n                        sign = c // 更新符號\n                        num = 0 // 重置數字\n                        i = i + 1 → Decision: `i < len(s)`? // 繼續處理\n                No  → Decision: `c` 是 '*' 或 '/'? // 判斷乘除符號\n                    Yes → Step 11: i = i + 1 → Decision: `i < len(s)`? // 讀取下一個數字或括號\n                            Step 12: 讀取 `next_num` // 解析乘除後的數值\n                            Step 13: 取得 `top = stack.pop()` // 取出堆疊頂部數字\n                            Step 14: 計算 `result = top * next_num` 若 `c == '*'`，否則 `result = top / next_num` // 執行乘除運算\n                            Step 15: stack.push(result) // 推回結果\n                            i = i + len_of_next_num → Decision: `i < len(s)`? // 移動指標\n                    No  → Step 16: Error // 無效字符，跳出\n→ Decision: `i >= len(s)`? // 是否結束解析\n    Yes → Step 17: 處理最後一個 `num` 與 `sign` // 推入堆疊或計算\n    No  → Step 18: 回到 Decision: `i < len(s)`? // 重新處理下一字元\n→ Step 19: 計算 `result = sum(stack)` // 將堆疊中的所有數值相加\n→ Step 20: 返回 `result` // 結果輸出\nEnd // 程式執行結束\n\n// 子流程 `evaluate()` 说明\nStart // 子流程開始\n→ Step 1: 初始化空堆疊 `stack`、變數 `num = 0`、變數 `sign = '+'`、指標 `i = 0` // 用於解析括號內部\n→ Decision: `i < len(s)`? // 是否還有字元未處理\n    Yes → Step 2: 讀取 `c = s[i]`\n    No  → Step 3: Return `num` // 括號結束，返回數值\n→ Decision: `c` 是空格? // 忽略空白\n    Yes → Step 4: i = i + 1 → Decision: `i < len(s)`? // 繼續\n    No  → Decision: `c` 是數字? // 數字\n        Yes → Step 5: 建立 `num = num * 10 + int(c)` // 形成多位數\n                i = i + 1 → Decision: `i < len(s)`? // 繼續讀取\n        No  → Decision: `c` 是 '('? // 進入更深括號\n            Yes → Step 6: 記錄 `prev_sign = sign`\n                Step 7: i = i + 1 → Decision: `i < len(s)`? // 進入括號內部\n                Step 8: Call 子流程 `evaluate()` 並取得 `num` // 递归处理\n                Step 9: sign = prev_sign\n            No  → Decision: `c` 是 '+' 或 '-'? // 加減符號\n                Yes → Step 10: 處理前一個 `num` 與 `sign`\n                        sign = c\n                        num = 0\n                        i = i + 1 → Decision: `i < len(s)`?\n                No  → Decision: `c` 是 '*' 或 '/'? // 乘除符號\n                    Yes → Step 11: i = i + 1 → Decision: `i < len(s)`?\n                            Step 12: 讀取 `next_num`\n                            Step 13: `top = stack.pop()`\n                            Step 14: `result = top * next_num` 若 `c == '*'`，否則 `result = top / next_num`\n                            Step 15: stack.push(result)\n                            i = i + len_of_next_num → Decision: `i < len(s)`?\n                    No → Step 16: Error\n→ Decision: `i >= len(s)`? // 可能遇到 ')'，返回結果\n    Yes → Step 17: 處理最後一個 `num` 與 `sign`\n          Return `num`\n    No  → Step 18: 回到 Decision: `i < len(s)`? // 繼續處理\n→ Step 19: 計算 `result = sum(stack)`\n→ Step 20: 返回 `result`\nEnd // 子流程結束",
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        \"\"\"\n        Evaluate a simple arithmetic expression that may contain\n        integers, '+', '-', and parentheses.\n        \"\"\"\n        stack = []          # 存放前一層的結果和符號\n        res = 0             # 當前層的累積結果\n        num = 0             # 當前正在組合的數字\n        sign = 1            # 當前符號，1 表示 '+', -1 表示 '-'\n\n        for ch in s:\n            if ch.isdigit():\n                num = num * 10 + int(ch)      # 組合多位數\n            elif ch in '+-':\n                res += sign * num             # 加上上一個數字\n                num = 0\n                sign = 1 if ch == '+' else -1\n            elif ch == '(':\n                # 把目前的結果和符號推入堆疊，開始新層\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif ch == ')':\n                # 將括號內的結果與符號合併\n                res += sign * num\n                num = 0\n                res *= stack.pop()            # 括號前的符號\n                res += stack.pop()            # 括號前的累積結果\n\n        # 結束後還有未加入的數字\n        res += sign * num\n        return res\n\ndef extract_expression(data: str) -> str:\n    \"\"\"\n    從輸入中提取表達式文字。\n    如果輸入類似 `s = \"1 + 1\"`，則返回 `1 + 1`。\n    若沒有雙引號，直接返回整個輸入。\n    \"\"\"\n    first = data.find('\"')\n    last = data.rfind('\"')\n    if first != -1 and last != -1 and first < last:\n        return data[first + 1:last]\n    return data.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    expression = extract_expression(raw_input)\n    solver = Solution()\n    result = solver.calculate(expression)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode561.json",
    "problem_index_in_file": 0,
    "title": "Array Partition",
    "description_snippet": "Given an integer array nums of 2n integers, group these integers into n pairs (a_1, b_1), (a_2, b_2)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: given array of 2n integers, group into n pairs to maximize sum of min of each pair. The known solution: sort ascending, then sum every second element starting from index 1? Actually to maximize sum of min, we should pair smallest with next smallest? Let's recall: For sorted ascending, pairing adjacent elements (ai, ai+1) gives min = ai. Sum over ai where i odd? Wait index: 0-based. If we pair (0,1),(2,3)... sum of elements at even indices (0,2,4,...) gives sum of mins. That's maximum. So algorithm: sort ascending, iterate over even indices, sum.\n\nWe produce virtual code lines with explanation. Use structure: Start, Step, Decision. Let's craft:\n\nStart\n→ Step 1: Sort nums ascending // arrange numbers in non-decreasing order\n→ Step 2: Initialize sum = 0 // 用於累積最小值總和\n→ Step 3: For i from 0 to length(nums)-1 step 2 // 每兩個元素一組\n    → Step 4: sum += nums[i] // 累加每對的最小值\n→ End // 回傳 sum\n\nAlso may include decision to check if length even? But problem says 2n. Could still check.\n\nLet's output lines accordingly.\n\nEnsure each line: virtual code + space + // explanation. Use arrow symbols. Use \"Start\", \"End\", \"Decision:\"? We might not need decision. But we can include a Decision to check array length is even. Provide simple decision.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: If nums.length mod 2 != 0 → Decision: 不是 2n 整數 // 檢查輸入合法性\n    No → ... (but not necessary). We can skip.\n\nBut the format example uses Decision: If. So we can add.\n\nLet's keep simple: no decision, just steps.\n\nMake each line:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 將數組按升序排列\n→ Step 2: Initialize sum = 0 // 用於累計每對最小值之和\n→ Step 3: For i from 0 to nums.length - 1 step 2 // 以兩個為一組遍歷\n    → Step 4: sum += nums[i] // 加入當前對的最小值\n→ End // 回傳 sum\n\nWe also need to show return statement: \"→ Step 5: Return sum // 結果回傳\" after loop.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 將數組按升序排列\n→ Step 2: Initialize sum = 0 // 用於累計最小值總和\n→ Step 3: For i = 0 to nums.length - 1 step 2 // 依序取每對\n    → Step 4: sum += nums[i] // 將當前對的最小值加入總和\n→ Step 5: Return sum // 回傳最大化的最小值總和\nEnd // 程式執行結束\n\nMake sure formatting: each line with arrow or indentation. Use \"→\" arrow before each Step. For the For loop line, we can indent inner step.\n\nWe need to maintain format exactly: virtual code step + space + // explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 將數組按升序排列  \n→ Step 2: Initialize sum = 0 // 用於累計每對最小值之和  \n→ Step 3: For i = 0 to nums.length - 1 step 2 // 依序取每對（兩個元素一組）  \n  → Step 4: sum += nums[i] // 將當前對的最小值（較小的那個）加入總和  \n→ Step 5: Return sum // 回傳最大化的最小值總和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef array_pair_sum(nums):\n    nums.sort()\n    return sum(nums[::2])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    nums = ast.literal_eval(data)\n    result = array_pair_sum(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,4,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "[6,2,6,5,1,2]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode55.json",
    "problem_index_in_file": 0,
    "title": "Jump Game",
    "description_snippet": "You are given an integer array nums. You are initially positioned at the array's first index, and ea...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in Chinese. The requirement: use Start, End, Decision. Each line: virtual code step + space + // explanation. Use arrows →, Yes →, No →. For the algorithm: Jump Game problem. We can do greedy algorithm: maxReach = 0; for i from 0 to n-1: if i>maxReach break false; maxReach = max(maxReach, i+nums[i]); if maxReach >= n-1 return true. End.\n\nWe need step-by-step virtual code. For clarity, we can split into steps: Initialize variables, iterate, check condition, update, final check. Use decision nodes. Let's produce something like:\n\nStart\n→ Step 1: Set n = length of nums // 獲取陣列長度\n→ Step 2: Set maxReach = 0 // 目前能達到的最遠索引\n→ Decision: 是否需要遍歷? // 判斷是否已經完成遍歷\n    Yes → Step 3: 遍歷 i 從 0 到 n-1 // 逐個索引檢查\n        → Decision: i > maxReach? // 如果目前索引超出能達到範圍\n            Yes → Step 4: 返回 False // 無法繼續前進，返回失敗\n            No  → Step 5: 更新 maxReach = max(maxReach, i + nums[i]) // 更新能達到的最遠距離\n            → Decision: maxReach >= n-1? // 能否到達最後索引\n                Yes → Step 6: 返回 True // 成功到達\n                No  → (loop continues)\n→ End\n\nBut we need to output as separate lines. We need to include arrows and indent decisions. We need each line with step name. Use \"Decision:\" lines. The arrows for branching: Yes → and No → lines.\n\nWe need to ensure each line has format: `虛擬碼步驟 // 解釋`. Each step is a line. For decision lines, we may also need to include arrow in line like `Decision: ...`. But the example shows:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // ...\n    No  → Decision: ... // ...\n\nThus we need to format accordingly: The decision line and the Yes/No lines are indented? We can indent with spaces. We'll include four spaces before Yes → and No →. Use arrow and Yes/No labels.\n\nLet's produce final output.\n\nAlso, each line must be in the format: \"虛擬碼步驟 // 解釋\". For decision line, that is \"Decision: ...\" part. For Yes/No lines: \"Yes → Step ...\" etc.\n\nAlso, we need to keep Start and End lines.\n\nLet's write out:\n\nStart // 程式開始執行\n→ Step 1: n = length of nums // 獲取陣列長度\n→ Step 2: maxReach = 0 // 設定目前能達到的最遠索引\n→ Decision: 是否需要遍歷? // 判斷是否已經完成遍歷\n    Yes → Step 3: for i in 0 to n-1 // 逐個索引檢查\n        → Decision: i > maxReach? // 如果目前索引超出能達到範圍\n            Yes → Step 4: return False // 無法繼續前進，返回失敗\n            No  → Step 5: maxReach = max(maxReach, i + nums[i]) // 更新能達到的最遠距離\n            → Decision: maxReach >= n-1? // 能否到達最後索引\n                Yes → Step 6: return True // 成功到達\n                No  → (continue loop)\nEnd // 程式執行結束\n\nWe need to ensure each line is separate. Let's write as code block. Each line includes `//` comment.\n\nMake sure indentation is correct. Use tabs? The example uses spaces.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: n = length of nums // 取得陣列長度\n→ Step 2: maxReach = 0 // 設定目前能達到的最遠索引\n→ Decision: 是否需要遍歷? // 判斷是否已經完成遍歷\n    Yes → Step 3: for i in 0 to n-1 // 逐個索引檢查\n        → Decision: i > maxReach? // 若目前索引超出可達範圍\n            Yes → Step 4: return False // 無法前進，返回失敗\n            No  → Step 5: maxReach = max(maxReach, i + nums[i]) // 更新能達到的最遠距離\n            → Decision: maxReach >= n-1? // 能否到達最後索引\n                Yes → Step 6: return True // 成功到達最後索引\n                No  → (continue loop) // 仍在遍歷\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canJump(self, nums):\n        max_reach = 0\n        n = len(nums)\n        for i in range(n):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        nums = []\n    else:\n        nums_str = data[start:end+1]\n        nums = ast.literal_eval(nums_str)\n    solution = Solution()\n    result = solution.canJump(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,0,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode220.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate III",
    "description_snippet": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indice...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode in the specified format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows. Use virtual code, no actual code. Need to find pair indices satisfying constraints. Approach: nested loops with bounds maybe sliding window or hash map. But as pseudocode we can outline nested loops: for each i iterate j from i+1 to min(n-1, i+indexDiff). Check value diff. Break if found. Return true else false. Complexity O(n * indexDiff). Alternatively sliding window but simpler. We'll produce pseudo steps.\n\nEnsure each line includes a space between code and comment.\n\nInclude arrow syntax as described: \"→\". Use Decision: lines.\n\nLet's produce:\n\nStart // start\n→ Step 1: 初始化 n = nums.length // get array length\n→ Step 2: for i = 0 to n-1 do // outer loop over indices\n    → Decision: i + indexDiff < n? // check if there are possible j within bounds\n        Yes → Step 3: set jMax = i + indexDiff\n        No → Step 3: set jMax = n-1\n    → Step 4: for j = i+1 to jMax do // inner loop over potential j\n        → Decision: abs(nums[i] - nums[j]) <= valueDiff? // check value diff\n            Yes → Step 5: return true // pair found\n            No → continue // try next j\n→ Step 6: return false // no pair found after all loops\nEnd // program ends\n\nBut need to format each line as \"虛擬碼步驟 // 解釋\". Use \"Start\" and \"End\". Use arrow lines with indentation. Must use \"Decision:\" lines for conditional. For loops we can use \"→ Step\". For arrow lines we must use \"→\" preceding each line. Example: \"→ Step 1: ...\" etc.\n\nAlso we need to indent inner lines maybe but not necessary. Use indentation spaces maybe.\n\nLet's craft.\n\nAlso note: For \"Decision:\" lines we should format as \"Decision: if condition? // ...\". And then indent Yes →, No → lines. They can be separate lines. Let's produce accordingly.\n\nWe need to adhere to formatting: \"Start // 程式開始執行\" example uses no arrow. For steps inside we use \"→\".\n\nThus final output:\n\nStart // 程式開始執行\n→ Step 1: n = nums.length // 取得陣列長度\n→ Step 2: for i = 0 to n-1 do // 逐一遍歷每個索引\n    → Decision: i + indexDiff < n? // 判斷可用的 j 範圍\n        Yes → Step 3: jMax = i + indexDiff // 內層迴圈上限為 i + indexDiff\n        No  → Step 3: jMax = n - 1 // 若超過陣列長度，則上限為最後一個索引\n    → Step 4: for j = i + 1 to jMax do // 針對每個可行 j 進行比對\n        → Decision: abs(nums[i] - nums[j]) <= valueDiff? // 檢查數值差是否符合\n            Yes → Step 5: return true // 找到符合條件的索引對，直接返回\n            No  → continue // 否則嘗試下一個 j\n→ Step 6: return false // 所有組合皆不符合，返回 false\nEnd // 程式執行結束\n\nNeed to ensure indentation is represented maybe with spaces. Use consistent spaces.\n\nWill produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = nums.length // 取得陣列長度  \n→ Step 2: for i = 0 to n-1 do // 逐一遍歷每個索引  \n  → Decision: i + indexDiff < n? // 判斷可用的 j 範圍  \n   Yes → Step 3: jMax = i + indexDiff // 內層迴圈上限為 i + indexDiff  \n   No  → Step 3: jMax = n - 1 // 若超過陣列長度，則上限為最後一個索引  \n  → Step 4: for j = i + 1 to jMax do // 針對每個可行 j 進行比對  \n    → Decision: abs(nums[i] - nums[j]) <= valueDiff? // 檢查數值差是否符合  \n     Yes → Step 5: return true // 找到符合條件的索引對，直接返回  \n     No  → continue // 否則嘗試下一個 j  \n→ Step 6: return false // 所有組合皆不符合，返回 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom bisect import bisect_left, insort\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        以滑動窗口+有序列表實作，時間複雜度 O(n log k)\n        \"\"\"\n        if k <= 0 or t < 0:\n            return False\n\n        window = []  # 有序列表\n        for i, num in enumerate(nums):\n            # 在窗口中搜尋第一個 >= num - t 的位置\n            pos = bisect_left(window, num - t)\n            if pos < len(window) and abs(window[pos] - num) <= t:\n                return True\n\n            # 把當前數字加入窗口\n            insort(window, num)\n\n            # 若窗口大小超過 k，移除最舊的元素\n            if len(window) > k:\n                old = nums[i - k]\n                idx = bisect_left(window, old)\n                # 刪除最左邊的等於 old 的位置\n                window.pop(idx)\n\n        return False\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 nums、indexDiff、valueDiff。\n    假設輸入格式類似: 'nums = [1,2,3,1], indexDiff = 3, valueDiff = 0'\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    index_match = re.search(r'indexDiff\\s*=\\s*(-?\\d+)', data)\n    value_match = re.search(r'valueDiff\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not index_match or not value_match:\n        raise ValueError(\"輸入格式不正確\")\n\n    nums_str = nums_match.group(1)\n    nums = eval(nums_str)          # 解析列表\n    indexDiff = int(index_match.group(1))\n    valueDiff = int(value_match.group(1))\n\n    return nums, indexDiff, valueDiff\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    nums, indexDiff, valueDiff = parse_input(input_data)\n\n    sol = Solution()\n    result = sol.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode229.json",
    "problem_index_in_file": 0,
    "title": "Majority Element II",
    "description_snippet": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps line by line with comments. It's Boyer-Moore majority vote for n/3. We need steps: Start, initialization of two candidates and counts, first pass to find candidates, second pass to verify counts, output candidates, End.\n\nWe must use arrow syntax as per example. We'll include indentation maybe with arrow.\n\nEnsure each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc.\n\nLet's craft.\n\n1. Start\n2. Initialize candidates c1, c2 to None; counts count1, count2 to 0.\n3. First pass: For each num in array:\n    Decision: If num equals c1? -> increment count1\n    Else if num equals c2? -> increment count2\n    Else if count1==0? -> set c1=num, count1=1\n    Else if count2==0? -> set c2=num, count2=1\n    Else decrement both counts.\nWe need to show each step as separate lines, but we can combine decisions.\n\nWe'll write as nested Decision blocks. Use indentation maybe with tabs? Not necessary. Just line by line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set candidate1 = None, candidate2 = None, count1 = 0, count2 = 0 // 初始化兩個可能的頻率大於 n/3 的候選元素與計數器  \n\n→ Step 2: For each num in array // 第一趟掃描，確定候選者  \n    → Decision: num == candidate1?  \n        Yes → count1 = count1 + 1 // 如果與候選者1相同，計數器加一  \n        No → Decision: num == candidate2?  \n            Yes → count2 = count2 + 1 // 如果與候選者2相同，計數器加一  \n            No → Decision: count1 == 0?  \n                Yes → candidate1 = num, count1 = 1 // 候選者1為空，設定為當前數值  \n                No → Decision: count2 == 0?  \n                    Yes → candidate2 = num, count2 = 1 // 候選者2為空，設定為當前數值  \n                    No → count1 = count1 - 1, count2 = count2 - 1 // 兩個計數器都減一  \n\n→ Step 3: Reset count1 = 0, count2 = 0 // 第二趟掃描，確認實際出現次數  \n→ Step 4: For each num in array  \n    → Decision: num == candidate1?  \n        Yes → count1 = count1 + 1 // 累加候選者1的實際頻率  \n        No → Decision: num == candidate2?  \n            Yes → count2 = count2 + 1 // 累加候選者2的實際頻率  \n\n→ Step 5: Initialize result list = [] // 用於儲存符合條件的元素  \n→ Decision: count1 > floor(n/3)?  \n    Yes → result.append(candidate1) // 若候選者1超過 n/3 次，加入結果  \n→ Decision: count2 > floor(n/3)?  \n    Yes → result.append(candidate2) // 若候選者2超過 n/3 次，加入結果  \n\nEnd // 程式執行結束，result 為所有出現頻率大於 ⌊n/3⌋ 的元素列表",
      "generated_code": "import sys\n\nclass Solution:\n    def majorityElement(self, nums):\n        if not nums:\n            return []\n\n        candidate1, candidate2 = None, None\n        count1, count2 = 0, 0\n\n        # 第一趟：找出兩個可能的候選者\n        for num in nums:\n            if candidate1 == num:\n                count1 += 1\n            elif candidate2 == num:\n                count2 += 1\n            elif count1 == 0:\n                candidate1, count1 = num, 1\n            elif count2 == 0:\n                candidate2, count2 = num, 1\n            else:\n                count1 -= 1\n                count2 -= 1\n\n        # 第二趟：確認實際出現次數\n        count1, count2 = 0, 0\n        for num in nums:\n            if num == candidate1:\n                count1 += 1\n            elif num == candidate2:\n                count2 += 1\n\n        result = []\n        n = len(nums)\n        if count1 > n // 3:\n            result.append(candidate1)\n        if count2 > n // 3:\n            result.append(candidate2)\n\n        return result\n\ndef parse_input(raw: str):\n    \"\"\"\n    解析輸入字串，預期格式為「nums = [1,2,3]」或類似形態。\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return []\n\n    # 如果有等號，取等號右側並評估為 Python 列表\n    if '=' in raw:\n        _, expr = raw.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw\n\n    try:\n        nums = eval(expr, {\"__builtins__\": None}, {})\n        if isinstance(nums, list):\n            return nums\n        # 若不是列表，試著把它當作單一元素包裝\n        return [nums]\n    except Exception:\n        # 若解析失敗，回傳空清單\n        return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.majorityElement(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "[3]",
          "success": true,
          "output": "[3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode748.json",
    "problem_index_in_file": 0,
    "title": "Shortest Completing Word",
    "description_snippet": "Given a string licensePlate and an array of strings words, find the shortest completing word in word...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code with arrows and explanations line by line, no real code. Provide steps to solve problem. Provide Start, End, decisions. For each line, after virtual code add // explanation.\n\nLet's think about algorithm: Preprocess licensePlate: count letters ignoring case and digits/spaces. Build map of letter to required count.\n\nThen iterate over words array in order: for each word, check if it satisfies counts. Count letters in word ignoring case. For each letter in requirement, check count >= required. If yes, compare length: keep smallest length; if equal, keep first occurrence. Since we iterate in order, first shortest will be chosen automatically if we only update when smaller length found.\n\nReturn best word.\n\nImplement pseudo-code steps accordingly.\n\nLet's generate lines.\n\nStart.\n\n→ Step 1: Initialize requirementMap as empty map // store letter counts from licensePlate\n\n→ Step 2: For each character ch in licensePlate // iterate licensePlate characters\n\n→ Decision: If ch is alphabetic? // check if letter\n\n→ Yes → Normalize ch to lowercase // treat case-insensitive\n\n→ Step 3: Increment requirementMap[ch] by 1 // count occurrences\n\n→ End (Decision)\n\n→ Step 4: Initialize bestWord as empty string // store result\n\n→ Step 5: Initialize minLength as Infinity // store shortest length\n\n→ Step 6: For each word in words // iterate words in given order\n\n→ Step 7: Initialize wordMap as empty map // letter counts of current word\n\n→ Step 8: For each character wch in word // iterate word characters\n\n→ Decision: If wch is alphabetic? // ignore non-letters\n\n→ Yes → Normalize wch to lowercase\n\n→ Step 9: Increment wordMap[wch] by 1\n\n→ End (Decision)\n\n→ End (inner loop)\n\n→ Step 10: Initialize isCompleting as true // flag\n\n→ Step 11: For each letter l in requirementMap // check all required letters\n\n→ Step 12: If wordMap[l] < requirementMap[l] // missing or insufficient\n\n→ Yes → Set isCompleting to false\n\n→ Step 13: Break // no need to check further\n\n→ End (Decision)\n\n→ End (inner loop)\n\n→ Decision: If isCompleting AND word.length < minLength? // candidate\n\n→ Yes → Set bestWord = word\n\n→ Set minLength = word.length\n\n→ End (Decision)\n\n→ End (outer loop)\n\n→ Step 12: Return bestWord // result\n\n→ End.\n\nAdd comments each line. Ensure each line contains \"虛擬碼步驟\" and \"// 解釋\".\n\nWe must use arrow syntax: →. Use \"Decision:\" with Yes →, No →. Use Start and End.\n\nLet's produce. Use \"Start\" line.\n\nNeed each line unique. Let's format.\n\nCheck: For inner loops, we can denote Step numbers accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: requirementMap ← 空映射 // 用於存放 licensePlate 中各字母的需求數量  \n→ Step 2: For 每個字符 ch 在 licensePlate // 遍歷 licensePlate 的每個字符  \n→ Decision: ch 是否為字母? // 判斷是否為字母，忽略數字與空白  \n  Yes → ch ← 小寫(ch) // 轉成小寫，統一大小寫  \n  Yes → requirementMap[ch] ← requirementMap[ch] + 1 // 需求數量累加  \n  No → 跳過 // 非字母直接跳過  \n→ End // 遍歷 licensePlate 結束  \n→ Step 3: bestWord ← \"\" // 儲存目前找到的最短完成字詞  \n→ Step 4: minLength ← ∞ // 儲存目前最短長度  \n→ Step 5: For 每個 word 在 words // 依照給定順序遍歷 words  \n  → Step 6: wordMap ← 空映射 // 儲存當前 word 的字母頻率  \n  → Step 7: For 每個字符 wch 在 word // 遍歷 word 的每個字符  \n    Decision: wch 是否為字母? // 只計算字母  \n     Yes → wch ← 小寫(wch)  \n     Yes → wordMap[wch] ← wordMap[wch] + 1  \n     No → 跳過  \n    End // 遍歷 word 結束  \n  → Step 8: isCompleting ← true // 假設 word 能完成 licensePlate  \n  → Step 9: For 每個字母 l 在 requirementMap // 檢查所有需求字母  \n    Decision: wordMap[l] < requirementMap[l]? // 不足夠  \n     Yes → isCompleting ← false  \n     Yes → 跳出循環 // 立即結束檢查  \n     No → 繼續檢查下個字母  \n    End // 檢查結束  \n  → Decision: isCompleting 並且 word.length < minLength? // 是完成且更短  \n    Yes → bestWord ← word  \n    Yes → minLength ← word.length  \n    No → 跳過  \n  End // 遍歷 words 結束  \n→ Step 10: Return bestWord // 回傳最短完成字詞  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def shortestCompletingWord(self, licensePlate: str, words: list[str]) -> str:\n        # Count required letters from licensePlate\n        req = {}\n        for ch in licensePlate:\n            if ch.isalpha():\n                lc = ch.lower()\n                req[lc] = req.get(lc, 0) + 1\n\n        best = None\n        best_len = float('inf')\n\n        for word in words:\n            # Count letters in the current word\n            cnt = {}\n            for ch in word:\n                if ch.isalpha():\n                    lc = ch.lower()\n                    cnt[lc] = cnt.get(lc, 0) + 1\n\n            # Check if word satisfies all required counts\n            ok = True\n            for letter, needed in req.items():\n                if cnt.get(letter, 0) < needed:\n                    ok = False\n                    break\n\n            # Update best word if valid and shorter\n            if ok and len(word) < best_len:\n                best = word\n                best_len = len(word)\n\n        return best\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses the input string in the form:\n        licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]\n    Returns the licensePlate string and a list of words.\n    \"\"\"\n    # Extract licensePlate string\n    lp_match = re.search(r'licensePlate\\s*=\\s*\"([^\"]*)\"', data)\n    if not lp_match:\n        raise ValueError(\"Invalid input: missing licensePlate\")\n    license_plate = lp_match.group(1)\n\n    # Extract words list string\n    words_match = re.search(r'words\\s*=\\s*\\[(.*)\\]', data)\n    if not words_match:\n        raise ValueError(\"Invalid input: missing words\")\n    words_str = words_match.group(1)\n\n    # Split words, strip surrounding quotes and whitespace\n    words = [w.strip().strip('\"').strip(\"'\") for w in words_str.split(',') if w.strip()]\n    return license_plate, words\n\n\ndef main():\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    license_plate, words = parse_input(data)\n\n    solution = Solution()\n    result = solution.shortestCompletingWord(license_plate, words)\n\n    # Print result surrounded by double quotes as shown in examples\n    print(f'\"{result}\"')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]",
          "expected_output": "\"steps\"",
          "success": true,
          "output": "\"steps\""
        },
        {
          "example_index": 1,
          "input": "licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]",
          "expected_output": "\"pest\"",
          "success": true,
          "output": "\"pest\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode136.json",
    "problem_index_in_file": 0,
    "title": "Single Number",
    "description_snippet": "Given a non-empty array of integers nums, every element appears twice except for one. Find that sing...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Use XOR approach. Steps: initialize result = 0, iterate over nums, result ^= num. End. Provide explanation after each line. Use Start, End. Include Decision? No decision needed. But can mention decision if result != 0? Not needed. Just linear iteration. Provide lines: Start, initialize, loop, XOR, output. Use virtual arrow. Format: \"→ Step 1: ... // explanation\". Use \"→ Decision\" not needed. So produce steps.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化結果為 0\n→ Step 2: 對於每個 num 在 nums 中 循環 // 逐個遍歷陣列\n    → Step 3: result ← result XOR num // 將元素與結果做 XOR，重複的會抵消\n→ Step 4: 輸出 result // 迴圈結束後，剩下的非重複元素即為答案\nEnd // 程式執行結束\n\nNeed to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow before step lines. Indentation for loop? The example shows nested lines after Decision. We can use indentation for loop body: use a tab or space. We'll produce as shown.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化結果為 0\n→ Step 2: 對於每個 num 在 nums 中 循環 // 逐個遍歷陣列\n → Step 3: result ← result XOR num // 將元素與結果做 XOR，重複的會抵消\n→ Step 4: 輸出 result // 迴圈結束後，剩下的非重複元素即為答案\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 從輸入中找出陣列字串\n    l = raw_input.find('[')\n    r = raw_input.rfind(']')\n    if l != -1 and r != -1:\n        list_str = raw_input[l:r+1]\n    else:\n        list_str = raw_input\n    # 解析陣列\n    nums = ast.literal_eval(list_str)\n    # 解題\n    solution = Solution()\n    single = solution.singleNumber(nums)\n    # 輸出答案\n    print(single)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,1,2,1,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1991.json",
    "problem_index_in_file": 0,
    "title": "Find the Middle Index in Array",
    "description_snippet": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step algorithm, with explanations. Must not output actual code. Just pseudo steps. Should handle edge cases. Approach: compute prefix sums and total sum, then iterate. For each index i, left sum = prefix[i] (sum up to i-1). right sum = totalSum - prefix[i+1] (sum after i). Check equality. Return i. If none, return -1.\n\nVirtual code steps: Start. Compute total sum. Compute prefix array maybe. Or compute left sum on the fly.\n\nBut we must produce step by step. Use decision blocks.\n\nLet's produce:\n\nStart // start\n→ Step 1: Calculate totalSum = sum of all elements in nums // total sum of array\n→ Step 2: Initialize leftSum = 0 // sum of left side before current index\n→ Step 3: Initialize result = -1 // default result\n→ Step 4: For each index i from 0 to nums.length-1 // iterate\n    → Step 4a: rightSum = totalSum - leftSum - nums[i] // sum of elements after current index\n    → Decision: if leftSum == rightSum? // check if current index is middle\n        Yes → Step 4b: result = i // store index\n            → Decision: if result == -1? // if first found\n                Yes → Step 4c: result = i // set (redundant)\n                No → End // not necessary? Actually we can break because we want leftmost, so break\n                // break loop\n    → Step 4d: leftSum = leftSum + nums[i] // update left sum for next iteration\n→ Decision: if result == -1? // no index found\n    Yes → Step 5: Output -1\n    No → Step 5: Output result\nEnd\n\nBut must produce per line with arrows.\n\nBetter:\n\nStart // 程式開始\n→ Step 1: totalSum ← Sum(nums) // 計算整數陣列總和\n→ Step 2: leftSum ← 0 // 左側已累加的和\n→ Step 3: result ← -1 // 預設回傳值\n→ Step 4: For i from 0 to length(nums)-1 // 遍歷每個索引\n    → Step 4a: rightSum ← totalSum - leftSum - nums[i] // 右側和\n    → Decision: leftSum == rightSum? // 判斷是否為中間索引\n        Yes → result ← i // 記錄左邊最小的中間索引\n            → Decision: result == -1? // 第一個符合\n                Yes → result ← i // 實際上已設置\n                No → Break // 已找到左邊最小，跳出迴圈\n        No  →\n    → Step 4b: leftSum ← leftSum + nums[i] // 更新左側和\n→ Decision: result == -1? // 是否有找到\n    Yes → Step 5: Return -1 // 沒找到\n    No  → Step 5: Return result // 回傳找到的索引\nEnd // 程式結束\n\nBut we must not output code; just virtual steps. Use arrow syntax with \"→\".\n\nMake sure each line ends with // 解釋.\n\nAlso maintain indentation? The example uses indentation and nested lines. We can use indentation to show hierarchy. Use spaces. We'll provide each line with step number. Provide arrow for nested steps. Use indentation accordingly.\n\nWe should ensure each line includes virtual code step and comment. Use Chinese explanations. Provide the logic. Use \"Decision:\" lines.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: totalSum ← Sum(nums) // 計算整個陣列的總和  \n→ Step 2: leftSum ← 0 // 左側已累加的和，初始為 0  \n→ Step 3: result ← -1 // 預設結果，若未找到符合條件的索引則保持 -1  \n→ Step 4: For i from 0 to Length(nums)-1 // 從左到右逐一檢查每個索引  \n  → Step 4a: rightSum ← totalSum - leftSum - nums[i] // 右側和 = 總和 - 左側和 - 當前元素  \n  → Decision: leftSum == rightSum? // 判斷當前索引是否為中間索引  \n   Yes → result ← i // 記錄左邊最小的符合條件索引  \n    Decision: result == -1? // 是否是第一個符合的索引  \n     Yes → result ← i // 已在上一行設定，保持不變  \n     No → Break // 找到左邊最小的索引後跳出迴圈  \n   No → // 不符合條件，繼續下一個索引  \n  → Step 4b: leftSum ← leftSum + nums[i] // 更新左側和，加入當前元素  \n→ Decision: result == -1? // 判斷是否存在符合條件的索引  \n  Yes → Step 5: Return -1 // 未找到，回傳 -1  \n  No → Step 5: Return result // 找到，回傳最左邊的中間索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMiddleIndex(self, nums):\n        total = sum(nums)\n        left = 0\n        for i, num in enumerate(nums):\n            if left == total - left - num:\n                return i\n            left += num\n        return -1\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    print(sol.findMiddleIndex(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-1,8,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,-1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,5]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode520.json",
    "problem_index_in_file": 0,
    "title": "Detect Capital",
    "description_snippet": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll le...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step following format. Each line: \"虛擬碼步驟 // 解釋\". We need to include Start, Decision, Steps. Use arrow arrows.\n\nWe must produce algorithm: Check if word is all caps, all lower, or capitalized first only. Return true if any of those.\n\nPseudo:\n\nStart\n→ Step 1: Initialize isAllCaps = true // check all caps\n→ Step 2: Initialize isAllLower = true // check all lower\n→ Step 3: Initialize isCapitalized = (first char uppercase) // first uppercase?\n→ For each char i from 0 to length-1\n    → Decision: if i == 0:\n        → Decision: If char is uppercase? \n            Yes → isCapitalized remains\n            No  → isCapitalized = false\n    → Decision: If char is uppercase? \n        Yes → do nothing for isAllLower (set false)\n        No  → do nothing for isAllCaps (set false)\n    → Decision: If char is lowercase? \n        Yes → isAllCaps = false\n        No  → isAllLower = false\n→ Decision: If isAllCaps or isAllLower or isCapitalized? \n    Yes → Step return true\n    No  → Step return false\nEnd\n\nBut we need to use arrow syntax: \"→ Step X: ...\" etc.\n\nWe also need to provide concise explanation after //.\n\nLet's craft.\n\nFirst line Start.\n\nThen Step 1: Determine word length maybe not needed.\n\nWe can simplify:\n\nStart // 程式開始\n\n→ Step 1: Initialize flagAllUpper = true // 假設所有字母為大寫\n→ Step 2: Initialize flagAllLower = true // 假設所有字母為小寫\n→ Step 3: Initialize flagFirstUpper = true // 第一個字母為大寫\n→ For i from 0 to len(word)-1 // 逐字檢查\n    → Decision: 如果 i == 0? // 第一個字母判斷\n        Yes → Decision: word[i] 是否大寫? \n            Yes → flagFirstUpper remains true // 第一個字母大寫\n            No  → flagFirstUpper = false // 第一個字母不是大寫\n        No  →  // 後續字母\n    → Decision: word[i] 是否大寫?\n        Yes → flagAllLower = false // 若大寫則非全部小寫\n        No  → flagAllUpper = false // 若小寫則非全部大寫\n    → Decision: word[i] 是否小寫?\n        Yes → flagAllUpper = false // 若小寫則非全部大寫\n        No  → flagAllLower = false // 若大寫則非全部小寫\n\nAfter loop:\n\n→ Decision: flagAllUpper 或 flagAllLower 或 flagFirstUpper? // 判斷是否符合任何一種情況\n    Yes → Step return true // 使用正確\n    No  → Step return false // 不符合\n\nEnd.\n\nBut ensure each line has \"虛擬碼步驟 // 解釋\".\n\nLet's format with arrow lines: \"→ Step ...\" etc.\n\nWe need to indent decisions.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: flagAllUpper ← true // 假設所有字母均為大寫  \n→ Step 2: flagAllLower ← true // 假設所有字母均為小寫  \n→ Step 3: flagFirstUpper ← true // 假設第一個字母為大寫  \n→ Step 4: For i ← 0 to len(word)-1 // 逐字母檢查  \n\n  → Decision: i == 0? // 是否為第一個字母  \n    Yes → Decision: isUpper(word[i])?  \n      Yes → flagFirstUpper ← true // 第一個字母為大寫  \n      No  → flagFirstUpper ← false // 第一個字母不是大寫  \n    No → // 後續字母  \n      // 下面的判斷適用於所有字母  \n\n    → Decision: isUpper(word[i])? // 是否大寫  \n      Yes → flagAllLower ← false // 大寫則不可能全部小寫  \n      No  → flagAllUpper ← false // 小寫則不可能全部大寫  \n\n    → Decision: isLower(word[i])? // 是否小寫  \n      Yes → flagAllUpper ← false // 小寫則不可能全部大寫  \n      No  → flagAllLower ← false // 大寫則不可能全部小寫  \n\n→ Decision: flagAllUpper ∨ flagAllLower ∨ flagFirstUpper? // 是否符合任一規則  \n  Yes → Step 5: return true // 用法正確  \n  No  → Step 6: return false // 用法不正確  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        \"\"\"\n        判斷給定單詞的大小寫使用是否正確。\n        只要符合以下三種情況之一即返回 True：\n        1. 全部字母都是大寫\n        2. 全部字母都是小寫\n        3. 只有第一個字母大寫，後續都是小寫\n        \"\"\"\n        # 直接利用字串方法判斷三種情況\n        return word.isupper() or word.islower() or word.istitle()\n\ndef main() -> None:\n    # 從標準輸入讀取單詞，去除可能存在的空白與引號\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 若輸入包含雙引號，將其移除\n    if data.startswith('\"') and data.endswith('\"'):\n        word = data[1:-1]\n    else:\n        word = data\n\n    solution = Solution()\n    result = solution.detectCapitalUse(word)\n    # 輸出與題目範例一致的字串\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"USA\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"FlaG\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode171.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Number",
    "description_snippet": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for mapping Excel column title to number. Provide step-by-step lines with explanation. Use Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". We must not output actual code, only pseudo steps.\n\nWe need to consider algorithm: iterate over characters from left to right, result = result*26 + (char - 'A' + 1). Provide pseudo code.\n\nLet's produce lines:\n\nStart\n→ Step 1: Initialize result = 0 // 结果变量\n→ Step 2: For each character ch in columnTitle // 遍历字符串\n    → Step 3: result = result * 26 + (ch - 'A' + 1) // 计算当前位\n→ Step 4: Return result // 输出列号\nEnd\n\nWe can use Decision? Not needed. But we can illustrate loop with decision. Use Decision to check end-of-string. Could use \"While index < length\". Provide pseudo.\n\nLet's produce with loop:\n\nStart\n→ Step 1: Set index = 0 // 指向首字符\n→ Step 2: Set result = 0 // 累计列号\n→ Decision: index < length of columnTitle? // 判断是否还有字符\n    Yes → Step 3: Let ch = columnTitle[index] // 取当前字符\n    → Step 4: result = result * 26 + (ch - 'A' + 1) // 计算\n    → Step 5: index = index + 1 // 移动到下一个\n    → Decision: index < length of columnTitle? // 循环判断\n        (repeat)\n    No  → Step 6: Return result // 输出\nEnd\n\nBut we need to adhere to format: each line separate, no nested lines? Example shows indent lines under Decision with spaces? In example, they used indent lines with two spaces before Yes. So we should replicate.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: index = 0 // 初始化索引\n→ Step 2: result = 0 // 初始化結果\n→ Decision: index < len(columnTitle) ? // 檢查是否還有字元\n    Yes → Step 3: ch = columnTitle[index] // 取得目前字元\n    → Step 4: result = result * 26 + (ch - 'A' + 1) // 轉換為數字並累加\n    → Step 5: index = index + 1 // 移動索引\n    → Decision: index < len(columnTitle) ? // 重新檢查\n        Yes → (回到 Step 3)\n        No  → Step 6: Return result // 回傳列號\n    No  → Step 6: Return result // 沒有字元直接回傳\nEnd // 程式執行結束\n\nBut they might want no nested decisions. We can keep simple. Use a While loop concept:\n\nStart\n→ Step 1: Set index = 0\n→ Step 2: Set result = 0\n→ Decision: index < len(columnTitle) ?\n    Yes → Step 3: ch = columnTitle[index]\n    → Step 4: result = result * 26 + (ch - 'A' + 1)\n    → Step 5: index = index + 1\n    → Decision: index < len(columnTitle) ?\n        Yes → (repeat from Step 3)\n        No  → Step 6: Return result\n    No  → Step 6: Return result\nEnd\n\nBut we might be overcomplicating. Provide simpler:\n\nStart\n→ Step 1: result = 0\n→ Step 2: For each ch in columnTitle\n    → Step 3: result = result * 26 + (ch - 'A' + 1)\n→ Step 4: Return result\nEnd\n\nBut they said must use Decision, arrow. However, the example uses Decision. Not mandatory? It says \"使用虛擬碼的箭頭 ... 和結構\". So we should use at least some decision.\n\nThus produce algorithm:\n\nStart // 程式開始\n→ Step 1: index = 0 // 初始索引\n→ Step 2: result = 0 // 初始結果\n→ Decision: index < len(columnTitle) ?\n    Yes → Step 3: ch = columnTitle[index] // 取字元\n    → Step 4: result = result * 26 + (ch - 'A' + 1) // 轉換\n    → Step 5: index = index + 1 // 移動\n    → Decision: index < len(columnTitle) ?\n        Yes → (跳回 Step 3)\n        No  → Step 6: Return result\n    No  → Step 6: Return result\nEnd\n\nBut we need to keep lines unique. The indent lines for Yes branch should start with 4 spaces? The example uses two spaces indent before Yes and the following lines. So replicate.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: index = 0 // 初始化字元索引\n→ Step 2: result = 0 // 初始化累積列號\n→ Decision: index < len(columnTitle) ? // 判斷是否還有字元\n    Yes → Step 3: ch = columnTitle[index] // 取得目前字元\n    → Step 4: result = result * 26 + (ch - 'A' + 1) // 將字元轉為數值並累加\n    → Step 5: index = index + 1 // 移動到下一個字元\n    → Decision: index < len(columnTitle) ?\n        Yes → (回到 Step 3)\n        No  → Step 6: Return result // 所有字元已處理，回傳最終列號\n    No  → Step 6: Return result // 若輸入為空字串，直接回傳 0\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef extract_title(text: str) -> str:\n    \"\"\"\n    從輸入文字中提取單引號包圍的字串。\n    例如「columnTitle = 'AB'」會回傳 \"AB\"。\n    若找不到符合模式，回傳空字串。\n    \"\"\"\n    match = re.search(r\"'([^']*)'\", text)\n    return match.group(1) if match else \"\"\n\ndef title_to_number(column_title: str) -> int:\n    \"\"\"\n    把 Excel 列標題轉成對應的整數值。\n    演算法：從左到右掃描字元，使用 base‑26 累積。\n    \"\"\"\n    result = 0\n    for ch in column_title:\n        result = result * 26 + (ord(ch) - ord('A') + 1)\n    return result\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 擷取標題字串\n    title = extract_title(raw_input.strip())\n    # 如果輸入合法，輸出對應的數字\n    if title:\n        print(title_to_number(title))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnTitle = 'A'",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "columnTitle = 'AB'",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 2,
          "input": "columnTitle = 'ZY'",
          "expected_output": "701",
          "success": true,
          "output": "701"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode39.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum",
    "description_snippet": "Given an array of distinct integers candidates and a target integer target, return a list of all uni...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for combination sum problem. Need to output lines with \"虛擬碼步驟 // 解釋\". Must use arrows and structure. Let's produce algorithm using backtracking recursion. Steps: Start, initialize result list, define recursive function backtrack(start, current_sum, current_combination). Loop over candidates from start index (to avoid duplicates). Add candidate to combination, if sum <= target then recurse with same index (since unlimited usage). If sum == target, add copy to result. Then backtrack. Finally output result. We'll produce virtual code lines.\n\nWe need each line: \"虛擬碼步驟 // 解釋\".\n\nLet's create lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 results ← [] // 用於儲存所有符合條件的組合\n→ Step 2: 定義遞迴函式 backtrack(start, current_sum, current_comb) // backtrack 用於探索所有組合\n    → Step 3: 如果 current_sum 等於 target\n        → Yes → Step 4: 將 current_comb 的複本加入 results // 找到合法組合，加入結果\n        → No → Step 5: 若 current_sum 大於 target\n            → Yes → Step 6: 返回 // 超過目標，終止此路徑\n    → Step 7: 循環遍歷候選數字 candidates[start…end]\n        → Step 8: current_comb 加入 candidates[i] // 選擇一個數字\n        → Step 9: backtrack(i, current_sum + candidates[i], current_comb) // 允許重複使用\n        → Step 10: 從 current_comb 移除最後一個數字 // 回溯\n→ Step 11: 呼叫 backtrack(0, 0, []) // 從第一個候選數字開始探索\n→ Step 12: 返回 results // 輸出所有符合條件的組合\nEnd // 程式執行結束\n\nWe need to ensure format: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Also for decisions \"Decision:\" etc. We can incorporate decision for check sum==target.\n\nLet's produce lines with proper structure: Use \"Decision:\" for if statements. Provide indentation with tabs or spaces? Use spaces for clarity.\n\nI'll craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果列表 results ← [] // 用於儲存所有符合條件的組合  \n→ Step 2: 定義遞迴函式 backtrack(start, current_sum, current_comb) // backtrack 用於探索所有組合  \n  Decision: 如果 current_sum 等於 target? // 判斷是否已達目標  \n   Yes → Step 3: 將 current_comb 的複本加入 results // 找到合法組合，加入結果  \n   No → Decision: 如果 current_sum 大於 target? // 超過目標則終止此路徑  \n    Yes → Step 4: 返回 // 返回上一層遞迴  \n    No → Step 5: 循環遍歷候選數字 candidates[start…end] // 從起始位置開始枚舉  \n     Step 6: current_comb 加入 candidates[i] // 選擇一個數字並加入目前組合  \n     Step 7: backtrack(i, current_sum + candidates[i], current_comb) // 允許重複使用相同數字  \n     Step 8: 從 current_comb 移除最後一個數字 // 回溯，恢復狀態  \n→ Step 9: 呼叫 backtrack(0, 0, []) // 從第一個候選數字開始探索  \n→ Step 10: 返回 results // 輸出所有符合條件的組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse a single line of the form:\n        candidates = [2,3,6,7], target = 7\n    \"\"\"\n    pattern = r'candidates\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    candidates = eval(match.group(1))      # safe for this controlled format\n    target = int(match.group(2))\n    return candidates, target\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        candidates, target = parse_input(data)\n        sol = Solution()\n        result = sol.combinationSum(candidates, target)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "success": true,
          "output": "[[2, 2, 3], [7]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "success": true,
          "output": "[[2, 2, 2, 2], [2, 3, 3], [3, 5]]"
        },
        {
          "example_index": 2,
          "input": "candidates = [2], target = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode525.json",
    "problem_index_in_file": 0,
    "title": "Contiguous Array",
    "description_snippet": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: given binary array, find max length subarray with equal 0 and 1. Classic: convert 0->-1, maintain prefix sum, map first occurrence of sum, compute max difference. Need to output as virtual code lines with explanations. Use Start, Step, Decision, Yes→, No→. Provide step-by-step. Use \"→\" arrow. Let's craft.\n\nSteps:\n\nStart\n→ Step 1: 初始化哈希表 map, 以 sum 0 映射到索引 -1 // 用於處理從開頭開始的子陣列\n→ Step 2: 初始化 sum = 0, maxLen = 0 // sum 用於累計，maxLen 追蹤最大長度\n→ Step 3: 對於每個索引 i, 值 val in nums // 逐元素遍歷\n    → Decision: 如果 val 為 0? // 判斷 0 或 1\n        Yes → Step 4a: sum = sum - 1 // 0 視為 -1\n        No  → Step 4b: sum = sum + 1 // 1 視為 +1\n    → Step 5: Decision: sum 是否已在 map 中? // 檢查是否之前出現過\n        Yes → Step 6: len = i - map[sum] // 計算子陣列長度\n        → Step 7: maxLen = max(maxLen, len) // 更新最大長度\n        No  → Step 8: map[sum] = i // 記錄第一次出現此 sum 的索引\n→ Step 9: End // 完成遍歷\n→ Step 10: Return maxLen // 輸出結果\n\nNeed to use arrows and indentations for nested decisions. Use \"Yes →\" and \"No →\". Provide each line with // explanation.\n\nMake sure each line contains \"虛擬碼步驟\" followed by space and explanation. Also use \"Start\" \"End\". Use arrow at beginning of each step line. For decisions, include \"Decision:\" line and sub-steps with Yes/No. For step lines inside decisions, include arrow. Use indentation by spaces.\n\nLet's craft output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 map, 將 sum 0 映射到索引 -1 // 方便計算從開頭開始的子陣列  \n→ Step 2: 初始化 sum = 0, maxLen = 0 // sum 用於累計 0/1 的平衡，maxLen 追蹤最大長度  \n→ Step 3: 對於每個索引 i 與對應值 val in nums // 逐個遍歷陣列  \n  → Decision: 如果 val 為 0? // 判斷是 0 還是 1  \n   Yes → Step 4a: sum = sum - 1 // 把 0 視為 -1 以平衡計算  \n   No  → Step 4b: sum = sum + 1 // 把 1 視為 +1  \n  → Decision: sum 是否已存在於 map? // 檢查此平衡值之前是否出現過  \n   Yes → Step 5: len = i - map[sum] // 兩次相同 sum 之間即為 0 與 1 數量相等的子陣列  \n    → Step 6: maxLen = max(maxLen, len) // 更新最大長度  \n   No  → Step 7: map[sum] = i // 記錄第一次出現此 sum 的索引  \n→ Step 8: End // 迴圈結束  \n→ Step 9: Return maxLen // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxLength(self, nums):\n        \"\"\"\n        找到子陣列中 0 與 1 數量相等的最大長度。\n        將 0 視為 -1，1 視為 +1，計算前綴和。\n        \"\"\"\n        count_map = {0: -1}   # 前綴和 0 的第一次出現位置（-1 表示前面沒有元素）\n        max_len = 0\n        count = 0\n        for i, num in enumerate(nums):\n            count += 1 if num == 1 else -1\n            if count in count_map:\n                max_len = max(max_len, i - count_map[count])\n            else:\n                count_map[count] = i\n        return max_len\n\ndef main():\n    # 讀取整個輸入，並解析成 Python list\n    data = sys.stdin.read().strip()\n    if not data:\n        nums = []\n    else:\n        try:\n            nums = ast.literal_eval(data)\n        except Exception:\n            # 若解析失敗，直接輸出 0\n            print(0)\n            return\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.findMaxLength(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[0,1,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,1,1,1,1,1,0,0,0]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode207.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: determine if all courses can be finished given prerequisites (topological sort / cycle detection). Virtual code step-by-step with arrows, decisions, etc. The output should be line by line with \"虛擬碼步驟 // 解釋\". Should not output actual code. Just pseudo-steps.\n\nNeed to produce a step-by-step algorithm: Build graph, indegree array, queue of zero indegree, BFS, count courses processed, if count == numCourses return true else false. Use decisions for cycle detection maybe.\n\nWe need to produce each step line with \"虛擬碼步驟 // 解釋\".\n\nWe'll include Start, End, Decision, Steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化圖與入度 // 建立鄰接表並計算每門課的前置課程數\n→ Step 2: 建立空的佇列 // 用於儲存目前可立即修習的課程\n→ Step 3: 將所有入度為 0 的課程加入佇列 // 初始可修課\n→ Decision: 佇列是否為空? // 判斷是否還有可修課程\n    Yes → End // 若佇列空且尚未處理完所有課程，將在後面處理\n    No  → Step 4: 從佇列取出一門課程 current // 取下一門可修課\n        → Step 5: 已修課程計數加 1 // 記錄已完成課程\n        → Step 6: 對 current 的所有相鄰課程 neighbour 做\n            → Step 6.1: 其入度減 1 // 減少尚未完成前置課程數\n            → Step 6.2: 如果 neighbour 入度變為 0, 將 neighbour 加入佇列 // 新可修課\n        → Step 7: 回到 Decision: 佇列是否為空? // 重複處理\n→ End // 所有可修課程已處理完\n→ Decision: 已修課程計數是否等於 numCourses? // 判斷是否所有課程都已完成\n    Yes → Return true // 可以完成所有課程\n    No  → Return false // 存在循環，無法完成\n\nMake sure each line ends with // 解釋. Use correct formatting. Ensure the decision lines indent with Yes → ... etc. The \"End\" line should not have nested decisions.\n\nAlso note we had an extra Decision after the while loop. Actually we might combine with while loop; but it's okay.\n\nWe need to maintain \"Start\", \"End\" as per format.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化圖與入度 // 建立鄰接表並計算每門課的前置課程數  \n→ Step 2: 建立空的佇列 // 用於儲存目前可立即修習的課程  \n→ Step 3: 將所有入度為 0 的課程加入佇列 // 初始可修課  \n→ Decision: 佇列是否為空? // 判斷是否還有可修課程  \n Yes → End // 若佇列空，跳出循環  \n No  → Step 4: 從佇列取出一門課程 current // 取下一門可修課  \n  → Step 5: 已修課程計數加 1 // 記錄已完成課程  \n  → Step 6: 對 current 的所有相鄰課程 neighbour 做  \n   → Step 6.1: 其入度減 1 // 減少尚未完成前置課程數  \n   → Step 6.2: 如果 neighbour 入度變為 0, 將 neighbour 加入佇列 // 新可修課  \n  → 回到 Decision: 佇列是否為空? // 重複處理  \nEnd // 所有可修課程已處理完  \n→ Decision: 已修課程計數是否等於 numCourses? // 判斷是否所有課程都已完成  \n Yes → Return true // 可以完成所有課程  \n No  → Return false // 存在循環，無法完成",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 填充圖與入度\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 將所有入度為 0 的節點加入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        # BFS 逐步移除入度為 0 的節點\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若已訪問節點數等於課程數，則能完成所有課程\n        return visited == numCourses\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析 numCourses 與 prerequisites。\"\"\"\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data, re.S)\n    if not num_match or not pre_match:\n        raise ValueError(\"Invalid input format\")\n    numCourses = int(num_match.group(1))\n    prerequisites = ast.literal_eval(pre_match.group(1))\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read()\n    # 解析輸入\n    numCourses, prerequisites = parse_input(raw_input)\n    # 呼叫解法\n    sol = Solution()\n    result = sol.canFinish(numCourses, prerequisites)\n    # 輸出結果\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode459.json",
    "problem_index_in_file": 0,
    "title": "Repeated Substring Pattern",
    "description_snippet": "Given a string s, check if it can be constructed by taking a substring of it and appending multiple ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: Given string s, check if it can be constructed by taking a substring and appending multiple copies of the substring together. That's typical \"repeated substring pattern\" problem. The virtual code steps: start, length n, for i from 1 to n/2, if n % i == 0 then candidate substring s[0:i], repeat times n/i, if repeated equals s return true. End false. Provide step-by-step with explanation. Need to output line by line. Use virtual code with arrow →. Use Decision lines. Use Start and End. Provide explanation after // each line. Let's craft.\n\nWe must ensure each line has \"虛擬碼步驟\" and \"// 解釋/說明\". Let's start.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 計算 s 的長度 n // 取得字符串長度\n\nLine 3: → Decision: 如果 n <= 1? // 判斷是否足夠長\n\nLine 4: Yes → Step 2: 回傳 False // 單字串無法重複\n\nLine 5: No → Step 3: 建立迴圈 i 從 1 到 n/2 // 嘗試所有可能子串長度\n\nLine 6: → Decision: 如果 n mod i == 0? // 子串長度需整除總長度\n\nLine 7: Yes → Step 4: 取子串 sub = s[0:i] // 取得候選子串\n\nLine 8: → Step 5: 重複 sub (n / i) 次得到 repeatStr // 重複子串以匹配長度\n\nLine 9: → Decision: 如果 repeatStr == s? // 檢查是否完全相同\n\nLine 10: Yes → Step 6: 回傳 True // 找到符合條件\n\nLine 11: No → Step 7: 繼續迴圈 // 進一步檢查\n\nLine 12: End → Step 8: 回傳 False // 所有長度皆不符合\n\nBut need to maintain arrow indentations? Format example uses arrow before each step and Decision with indentation. We should indent sub-steps under Decision accordingly. Use spaces. Let's produce with indentation lines as in example.\n\nWe'll maintain structure: \nStart\n→ Step 1...\n→ Decision: ...\n   Yes → Step 2...\n   No  → Step 3...\n   → Decision: ...\n      Yes → Step ...\n      No → Step ...\n   → Step ...\nEnd\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 s 的長度 n // 取得字符串長度  \n→ Decision: 如果 n <= 1? // 判斷是否足夠長  \n   Yes → Step 2: 回傳 False // 單字串無法重複  \n   No  → Step 3: 建立迴圈 i 從 1 到 n/2 // 嘗試所有可能子串長度  \n       → Decision: 如果 n mod i == 0? // 子串長度需整除總長度  \n           Yes → Step 4: 取子串 sub = s[0:i] // 取得候選子串  \n               → Step 5: 重複 sub (n / i) 次得到 repeatStr // 重複子串以匹配長度  \n               → Decision: 如果 repeatStr == s? // 檢查是否完全相同  \n                   Yes → Step 6: 回傳 True // 找到符合條件  \n                   No  → Step 7: 繼續迴圈 // 進一步檢查  \n           No  → Step 8: 繼續迴圈 // 子串長度不整除，跳過  \n→ End // 所有長度皆不符合，回傳 False   (程式執行結束)",
      "generated_code": "import sys\nimport re\n\ndef repeatedSubstringPattern(s: str) -> bool:\n    \"\"\"\n    判斷字符串 s 是否可以由一個子串多次連接得到。\n    1. 先取得字符串長度 n。\n    2. 若 n <= 1，直接回傳 False。\n    3. 從 1 開始檢查每一個長度 i，直到 n//2。\n        - 若 n 可以被 i 整除，代表可能的子串長度。\n        - 取子串 s[:i]，重複 (n // i) 次後與 s 比較。\n        - 若相等即代表成功，回傳 True。\n    4. 所有長度都檢查完仍未成功，回傳 False。\n    \"\"\"\n    n = len(s)\n    if n <= 1:\n        return False\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            if s[:i] * (n // i) == s:\n                return True\n    return False\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析出字符串 s，呼叫 repeatedSubstringPattern\n    並將結果以小寫字串 'true' / 'false' 輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 先嘗試從雙引號中提取內容\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若找不到雙引號，嘗試去除兩端的引號或多餘字元\n        s = data.strip()\n        if s.startswith('\"') and s.endswith('\"'):\n            s = s[1:-1]\n        s = s.replace('\"', '').replace(\"'\", \"\").strip()\n\n    result = repeatedSubstringPattern(s)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"abcabcabcabc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode528.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Weight",
    "description_snippet": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith in...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Should include building prefix sums array, generating random number between 0 and sum-1 inclusive, binary search or linear search to find index. Provide steps with arrows and explanation.\n\nWe must produce only virtual code lines, each with // explanation. Must be in Traditional Chinese. Use Start, End, Decision, etc.\n\nWe'll produce algorithm: Initialize cumulative array in constructor. In pickIndex, generate random int r in [0, total-1] inclusive. Then iterate cumulative to find first index where cumulative > r. Return index. Complexity.\n\nLet's produce lines.\n\nRemember each line: \"虛擬碼步驟 [space] // 解釋\". Provide arrow for transitions. Use Start and End.\n\nWe'll produce:\n\nStart\n→ Step 1: 建立物件時，計算每個索引的累積權重總和並儲存於 cumulative[] // 先將 w 轉為前綴和，方便快速查找\n→ Step 2: 記錄總重量 totalWeight = cumulative[last] // 總權重可直接取得\n→ Step 3: pickIndex() 開始 // 進入隨機挑選流程\n→ Step 4: 產生隨機整數 r 取值範圍 0 ~ totalWeight - 1 // 用於選擇權重區間\n→ Decision: r < cumulative[0]? // 檢查 r 是否落在第一個區間\n    Yes → Step 5: 回傳 0 // r 在第一個索引區間\n    No → Step 6: 從 i = 1 開始循環直到 cumulative[i] > r // 逐一檢查每個累積值\n        → Step 7: 如果 cumulative[i] > r, 回傳 i // 找到對應索引\n→ End\n\nBut need to show line numbers maybe not needed. Just lines.\n\nAlso include arrow transitions like → Step. For decisions use Yes → and No →. Let's produce. Ensure each line has \"虛擬碼步驟\" and explanation.\n\nWill include \"Constructor\" step. Maybe better:\n\nStart\n→ Constructor: 取得 w // 接收權重陣列\n→ Step 1: cumulative = 新空陣列 // 用來儲存前綴和\n→ Step 2: for i in 0..w.length-1: cumulative[i] = (i == 0 ? w[i] : cumulative[i-1] + w[i]) // 計算前綴和\n→ Step 3: totalWeight = cumulative[last] // 總重量\n→ Step 4: pickIndex() 開始 // 函式執行\n→ Step 5: r = 隨機整數 0 ~ totalWeight-1 // 產生隨機數\n→ Decision: r < cumulative[0]?\n    Yes → Step 6: 回傳 0 // r 在第一個索引\n    No → Step 7: i = 1\n    → Decision: cumulative[i] > r?\n        Yes → Step 8: 回傳 i // 找到對應索引\n        No  → Step 7: i++ ; goto Decision: cumulative[i] > r?\n→ End\n\nBut arrow usage: need to use \"→ Decision:\" and \"Yes →\" \"No →\". Also maintain flow. Could be simplified by using linear search. Provide explanation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Constructor: 取得權重陣列 w // 接收使用者傳入的正整數陣列  \n→ Step 1: cumulative = 新空陣列 // 用來儲存前綴和，方便後續查找  \n→ Step 2: for i = 0 to w.length-1  \n  → cumulative[i] = (i == 0 ? w[0] : cumulative[i-1] + w[i]) // 計算並儲存每個索引的累積權重  \n→ Step 3: totalWeight = cumulative[w.length-1] // 總權重即最後一個累積值  \n→ Step 4: pickIndex() 開始 // 進入隨機挑選流程  \n→ Step 5: r = 隨機整數 0 ~ totalWeight-1 // 產生一個在總權重範圍內的隨機數  \n→ Decision: r < cumulative[0]? // 判斷 r 是否落在第一個索引的區間  \n  Yes → Step 6: 回傳 0 // r 在第一個索引，直接返回  \n  No → Step 7: i = 1 // 否則從第二個索引開始搜尋  \n  → Decision: cumulative[i] > r? // 檢查 r 是否落在當前索引的區間  \n   Yes → Step 8: 回傳 i // 找到對應索引，返回  \n   No  → Step 7: i++ ; goto Decision: cumulative[i] > r? // 沒找到則遞增索引繼續搜尋  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並包裝成合法的 JSON 列表\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    data = json.loads('[' + raw_input + ']')\n    ops, args_list = data[0], data[1]\n\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)   # 代表 null\n        elif op == \"pickIndex\":\n            results.append(obj.pickIndex())\n        else:\n            # 若有其他方法，可在此處擴充\n            results.append(None)\n\n    # 輸出 JSON 形式，null 以小寫表示\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "success": true,
          "output": "[null, 0]"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode394.json",
    "problem_index_in_file": 0,
    "title": "Decode String",
    "description_snippet": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. Use Start, End, Decision, etc. Should describe algorithm to decode string with repetition. Use stack approach. Outline: read string char by char, maintain stack of (prevString, repeatCount). When digit read, parse full number. When '[' push current string and count. When ']' pop and repeat, append. At end return result. Provide each step as virtual code line. Need to produce explanation after each line.\n\nWe must not output actual code but virtual steps. Use arrow and decisions. Provide maybe 20-30 lines. Let's design:\n\nStart\n→ Step 1: 初始化輸入字符串 S // 設定待解碼的字符串\n→ Step 2: 初始化空棧 stack // 用於儲存 (累積字符串, 重複次數)\n→ Step 3: 初始化 currentString 為空 // 當前正在構造的子串\n→ Step 4: 初始化 number 為 0 // 解析 k 值\n→ Decision: 若 S 的第一個字符為數字? // 判斷是否開始解析 k\n    Yes → Step 5: 讀取並累加數字到 number // 解析完整的 k\n    No  → Step 6: 讀取字符到 currentString // 直接加入字符串\n... Actually algorithm processes char by char; we can use loop over S.\n\nWe need to produce step-by-step pseudo-code.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 將輸入字串存入變數 S // 保存待解碼字符串\n→ Step 2: 創建空棧 stack // 用於儲存 (累積字串, 重複次數)\n→ Step 3: 初始化 currentString 為空字串 // 當前正構造的字串\n→ Step 4: 初始化 number 為 0 // 用於解析重複次數 k\n→ Step 5: 循環遍歷 S 中每個字符 c // 逐字符處理\n    → Decision: 如果 c 為數字? // 判斷是否在解析 k\n        Yes → Step 6: number = number * 10 + 數字值(c) // 解析多位數\n        No  → Decision: 如果 c 為 '['? // 開始新的編碼區段\n            Yes → Step 7: 推入 stack (currentString, number) // 保存前一層狀態\n                    → Step 8: currentString 設為空 // 開始構造新區段\n                    → Step 9: number 設為 0 // 重置重複次數\n            No  → Decision: 如果 c 為 ']'? // 結束編碼區段\n                Yes → Step 10: 從 stack 彈出 prevString, repeatCount // 取出上一層\n                         → Step 11: currentString = prevString + currentString * repeatCount // 重複並合併\n                No  → Step 12: currentString += c // 普通字符直接加入\n→ End // 回傳 currentString 作為解碼結果\n\nBut need to include return at End maybe Step 13: return currentString // 最終解碼字串\n\nBetter to add final return. Provide explanation.\n\nMake sure each line includes '→' arrow for nested decisions? Use indentation. Use 'Decision:' with Yes→, No→. Provide simple structure.\n\nLet's craft full output accordingly.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: 將輸入字串存入變數 S // 保存待解碼的字串\n→ Step 2: 創建空棧 stack // 用於儲存 (累積字串, 重複次數)\n→ Step 3: 初始化 currentString 為空字串 // 當前正在構造的子串\n→ Step 4: 初始化 number 為 0 // 用於解析重複次數 k\n→ Step 5: 循環遍歷 S 中每個字符 c // 逐字符處理\n    → Decision: 如果 c 為數字? // 判斷是否在解析 k\n        Yes → Step 6: number = number * 10 + 數字值(c) // 解析多位數\n        No  → Decision: 如果 c 為 '['? // 開始新的編碼區段\n            Yes → Step 7: 推入 stack (currentString, number) // 保存前一層狀態\n                    → Step 8: currentString 設為空 // 開始構造新區段\n                    → Step 9: number 設為 0 // 重置重複次數\n            No  → Decision: 如果 c 為 ']'? // 結束編碼區段\n                Yes → Step 10: 從 stack 彈出 prevString, repeatCount // 取出上一層\n                         → Step 11: currentString = prevString + currentString * repeatCount // 重複並合併\n                No  → Step 12: currentString += c // 普通字符直接加入\n→ Step 13: 回傳 currentString // 最終解碼字串\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_num = 0\n        current_str = ''\n        \n        for char in s:\n            if char.isdigit():\n                current_num = current_num * 10 + int(char)\n            elif char == '[':\n                stack.append((current_str, current_num))\n                current_str = ''\n                current_num = 0\n            elif char == ']':\n                last_str, num = stack.pop()\n                current_str = last_str + current_str * num\n            else:\n                current_str += char\n        return current_str\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Try to extract the string inside double quotes, if present\n    match = re.search(r'\"(.*?)\"', data)\n    if match:\n        encoded = match.group(1)\n    else:\n        # If no quotes, use the whole input after possible variable assignment\n        parts = data.split('=', 1)\n        encoded = parts[-1].strip().strip('\"').strip()\n    decoded = Solution().decodeString(encoded)\n    print(f'\"{decoded}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3[a]2[bc]\"",
          "expected_output": "\"aaabcbc\"",
          "success": true,
          "output": "\"aaabcbc\""
        },
        {
          "example_index": 1,
          "input": "s = \"3[a2[c]]\"",
          "expected_output": "\"accaccacc\"",
          "success": true,
          "output": "\"accaccacc\""
        },
        {
          "example_index": 2,
          "input": "s = \"2[abc]3[cd]ef\"",
          "expected_output": "\"abcabccdcdcdef\"",
          "success": true,
          "output": "\"abcabccdcdcdef\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode191.json",
    "problem_index_in_file": 0,
    "title": "Number of 1 Bits",
    "description_snippet": "Given a positive integer n, write a function that returns the number of set bits in its binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode lines with explanation, following the format. Use arrow, decision, etc. Provide virtual code lines. We'll design algorithm: count bits by iterating until n becomes zero, increment count when n & 1 == 1, then n >>= 1. Or use n &= n-1 method. Provide pseudocode with step lines. Provide start, decision, end. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe must adhere to format: \"Start // 程式開始執行\" etc. Use arrows. Each line must contain \"虛擬碼步驟\" then space then \"// 解釋/說明\". Use arrow arrows for steps.\n\nWe need to write the virtual code for the function. We should include function definition step. Provide steps:\n\nStart\n→ Step 1: 定義函式 CountSetBits(n) // 建立計算函式\n→ Step 2: 設定 count = 0 // 初始化計數器\n→ Decision: n 是否為 0? // 檢查是否還有位元需要處理\n    Yes → End // 直接返回 count\n    No → Step 3: 如果 n & 1 == 1? // 判斷最低位是否為 1\n        Yes → Step 4: count = count + 1 // 計數加 1\n        No  → // 不做任何改動\n    → Step 5: n = n >> 1 // 右移 1 位，去掉已檢查的位元\n    → Go back to Decision: n 是否為 0? // 迴圈結束條件\n→ Step 6: Return count // 回傳最終計數\n\nBut we need to use arrow \"→\" for next steps, \"Decision:\" with Yes/No arrows.\n\nLet's produce final output with proper indentation. Use spaces indent before Yes / No lines maybe. Format example uses indentation and arrow. Use same pattern: \n```\nDecision: if n == 0? \n    Yes → End\n    No  → ...\n```\nSo we produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 CountSetBits(n) // 建立計算函式  \n→ Step 2: 設定 count = 0 // 初始化計數器  \n→ Decision: n 是否為 0? // 檢查是否還有位元需要處理  \n Yes → End // 若 n 為 0，直接結束並回傳計數  \n No  → Decision: n & 1 是否為 1? // 判斷最低位是否為 1  \n  Yes → Step 3: count = count + 1 // 若最低位為 1，計數器加 1  \n  No  → // 若最低位為 0，無需變更計數器  \n → Step 4: n = n >> 1 // 右移 1 位，去除已檢查的位元  \n → Go back to Decision: n 是否為 0? // 重複檢查下一位  \n→ Step 5: Return count // 所有位元檢查完畢，回傳總計數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef hamming_weight(n: int) -> int:\n    \"\"\"計算 n 的二進制表示中 1 的個數（Hamming weight）。\"\"\"\n    count = 0\n    while n:\n        count += n & 1   # 若最低位為 1，則加 1\n        n >>= 1          # 右移 1 位，繼續檢查下一位\n    return count\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取數字，輸出其二進制中 1 的個數。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取第一個出現的整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        print(0)\n        return\n\n    n = int(match.group())\n    result = hamming_weight(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 128",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2147483645",
          "expected_output": "30",
          "success": true,
          "output": "30"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1337.json",
    "problem_index_in_file": 0,
    "title": "The K Weakest Rows in a Matrix",
    "description_snippet": "You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civili...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. Provide pseudocode for algorithm: count soldiers per row (binary matrix sorted rows). Then sort rows by (count, index). Then output first k indices. Virtual code steps: Start, compute counts, etc. Use arrow formatting. Need to follow example formatting.\n\nWe need to not output actual code but virtual steps. Let's produce algorithm. Use \"→\" arrow for each step. Use Decision for sorting? Actually sorting step can be represented as a step \"Sort rows by (count, index)\" not decision. Then pick first k. Provide final output step.\n\nLet's craft lines:\n\nStart // 開始\n→ Step 1: Initialize an empty list rows // 建立空清單以存放行資訊\n→ Step 2: For each row index i from 0 to m-1 // 遍歷所有行\n    → Step 3: Count number of 1s in mat[i] using binary search // 由於每行已排序，可快速計算\n    → Step 4: Append (i, count) to rows // 儲存行號與兵力數\n→ Step 5: Sort rows by count ascending, then index ascending // 按兵力和行號排序\n→ Step 6: Initialize empty list weakest // 存放最弱行索引\n→ Step 7: For j from 0 to k-1\n    → Step 8: Append rows[j].index to weakest // 取前k個\n→ Step 9: Return weakest // 回傳結果\nEnd // 結束\n\nWe can use Decision? Not needed. But maybe binary search decision? Provide decision \"Decision: If row has 1s?\" Actually counting binary search may include a decision to check mid. Could represent a small binary search procedure. But we can simplify: use linear scan or built-in count. Let's keep it simple.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空清單 rows // 建立用來存放每一行的行號與兵力數量  \n→ Step 2: 對於每個行號 i 從 0 到 m-1  \n  → Step 3: 計算 mat[i] 中 1 的數目 count  \n    Decision: 兵力數量為 0? // 判斷該行是否完全沒有士兵  \n     Yes → Step 4: count = 0 // 若全為 0，直接設為 0  \n     No  → Step 5: 使用二分搜尋在已排序的行中找最後一個 1，並以此得到 count // 快速獲取兵力數  \n  → Step 6: 將 (i, count) 加入 rows // 存入行號與兵力  \n→ Step 7: 對 rows 按 (count, index) 升冪排序 // 先按兵力再按行號  \n→ Step 8: 初始化空清單 weakest // 儲存最弱的行索引  \n→ Step 9: 從排序後的 rows 取前 k 個項目，將其索引加入 weakest  \n  → Step 10: 返回 weakest // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並處理可能的空格\n    raw = sys.stdin.read().strip()\n    # 移除「mat =」與「k =」的字串\n    raw = raw.replace(\"mat =\", \"\").replace(\"k =\", \"\").strip()\n    # 包裝成一個 tuple 方便 eval\n    raw = f\"({raw})\"\n    # 使用 eval 將字串轉成實際資料結構\n    mat, k = eval(raw)\n    # 呼叫解法並輸出結果\n    result = Solution().kWeakestRows(mat, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "success": true,
          "output": "[2, 0, 3]"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "success": true,
          "output": "[0, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode753.json",
    "problem_index_in_file": 0,
    "title": "Cracking the Safe",
    "description_snippet": "There is a safe protected by a password. The password is a sequence of n digits where each digit can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve: find a minimal-length string over digits 0..k-1 that contains all possible n-digit sequences as substrings? Actually we want a string such that at some point, the most recent n digits equal the correct password. We can choose any password (unknown). So we need a de Bruijn sequence of order n over alphabet size k. That is minimal length k^n + n -1. Provide algorithm to generate. Steps: Start, Input k, n. Compute total = k^n. Initialize string as n zeros. Use DFS recursion over de Bruijn graph. Append digits. Build string. Output string. Provide explanation. Use virtual code. Use Decision, loops. Use recursion. We'll provide generic pseudo. Use variables: alphabet = 0..k-1. Use function DFS(node). For each digit d in alphabet: newNode = (node * k + d) mod k^(n-1). If edge not visited: mark visited, DFS(newNode), append d to output. At end return output + first n-1 digits. Or typical algorithm: de Bruijn. Provide steps.\n\nLet's produce step-by-step virtual code with explanation. Use Start, End, Decision. Include loops. Use recursion. We'll avoid actual code syntax. We'll just describe algorithm. Provide line by line. Ensure each line has virtual code + comment. Use arrow to indicate flow.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 k, n // 取得字母表大小與密碼長度  \n→ Decision: 若 n = 1? // 特殊情況，直接產生所有 k 個字元  \n Yes → Step 2: 產生字串 = 「0」到「k-1」連接 // 例如「012…k-1」  \n No → Decision: 若 k = 1? // 只有一個字元時，最短字串為 n 個 0  \n  Yes → Step 3: 產生字串 = 重複 '0' n 次 // 例如「000…0」  \n  No → Step 4: 執行 de Bruijn 產生流程 // 正常情況  \n→ Step 5: 計算 tot = k^n // 需要考慮的 n 位序列總數  \n→ Step 6: 建立陣列 visited[tot] 設為 false // 標記邊是否已使用  \n→ Step 7: 建立空字串 path // 儲存 DFS 生成的序列  \n→ Step 8: 定義函式 DFS(node) // node 代表前 n-1 位的數值  \n → Decision: 若 node 已訪問完所有輸出? // 需要遍歷所有 k 個輸出  \n  Yes → Step 9: 退回 // DFS 完成  \n  No → Decision: 對每個 digit d in [0, k-1]  \n   Yes → Step 10: newNode = (node * k + d) mod k^(n-1) // 轉到下一節點  \n    Decision: 若 visited[newNode * k + d] 為 false? // 邊未使用  \n     Yes → Step 11: 設置 visited[newNode * k + d] = true // 標記使用  \n      → DFS(newNode) // 深度優先遞迴  \n      → Step 12: path += char('0'+d) // 將輸出位加入路徑  \n      No → Step 13: 繼續下一個 d  \n→ Step 14: 呼叫 DFS(0) // 從全 0 開始  \n→ Step 15: 組合結果 = path + 前 n-1 個 '0' // 加上首部以形成循環  \n→ Step 16: 輸出結果 // 這個字串最短且包含所有 n 位序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        start = \"0\" * (n - 1)\n        seen = set()\n        res = []\n\n        def dfs(node: str):\n            for x in map(str, range(k)):\n                nxt = node + x\n                if nxt not in seen:\n                    seen.add(nxt)\n                    dfs(nxt[1:])\n                    res.append(x)\n\n        dfs(start)\n        return \"\".join(res) + start\n\n\ndef main() -> None:\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(numbers) < 2:\n        return\n    n, k = numbers[0], numbers[1]\n    sol = Solution()\n    answer = sol.crackSafe(n, k)\n    print(answer)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 2, k = 2",
          "expected_output": "\"01100\"",
          "success": true,
          "output": "01100"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode172.json",
    "problem_index_in_file": 0,
    "title": "Factorial Trailing Zeroes",
    "description_snippet": "Given an integer n, return the number of trailing zeroes in n!. \n\nNote that n! = n * (n - 1) * (n - ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode lines with comments explaining each line. The problem: compute number of trailing zeros in n!. Standard algorithm: count factors of 5. Count sum of floor(n/5^i). Provide pseudocode. Use Start, End, Decision. The steps: Input n. Initialize count=0. Initialize divisor=5. While n/divisor >=1: count += n/divisor; divisor*=5. Output count. End. Also could include decision to handle n=0? but trailing zeros of 0! is 1 trailing zero? Actually 0! =1 has zero trailing zeros. So n>=0. We can include decision if n==0: output 0. But we can treat loop will produce 0. But for clarity we may add decision.\n\nWe must output each line of pseudocode with comment. The pseudocode syntax: \"Start\", \"→ Step X: ...\", \"Decision: ...\", \"Yes → ...\", \"No → ...\". Also End.\n\nWe need to produce minimal steps. Provide explanation after space. So e.g.:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得使用者輸入的整數\n→ Decision: 如果 n < 0? // 檢查輸入是否為負數\n    Yes → Step 2: 輸出 '輸入錯誤' // 如果負數，顯示錯誤訊息\n    No  → Step 3: 初始化 count = 0 // 用來累加五的因子數量\n→ Step 4: 初始化 divisor = 5 // 從 5 開始，向上乘 5 以計算每個五的倍數\n→ Decision: 是否 n / divisor >= 1? // 判斷是否還有更高次的五因子\n    Yes → Step 5: count += n / divisor // 加上當前五因子次數\n        → Step 6: divisor *= 5 // 更新 divisor 為下個五的倍數\n        → Step 7: 轉回 Decision // 重新檢查是否還有更高次的五因子\n    No  → Step 8: 輸出 count // 輸出計算得到的尾隨零數\nEnd // 程式執行結束\n\nBut need \"→ Step\" formatting. For loop, we need to simulate with decision. The above uses Decision and Yes/No. The \"→ Step 7: 轉回 Decision\" is not correct format. We need to use the \"Decision:\" line again maybe labelled. Could also use \"→ Decision: 是否 n / divisor >= 1?\" inside the loop. We need to use nested indentation? The sample shows indentation with spaces. Use spaces to indicate nested levels. But we just produce lines, not indentation? The example shows indentation but we can also produce plain lines. But to be safe, we can mimic the indentation with spaces.\n\nWe need to show each line with \"虛擬碼步驟\" plus comment. We'll produce each line starting with \"Start\", \"→ Step 1:\" etc. For decisions, \"→ Decision: 如果 n < 0?\" etc. For yes branch: \"Yes → Step 2:\" etc. The code lines inside loops should have indentation. We can produce each line as separate string with comment.\n\nWe need to include the \"End\" line.\n\nWe should include explanation after each line.\n\nWe need to avoid actual code like loops. Use decision and steps.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得使用者輸入的整數\n→ Decision: 如果 n < 0? // 檢查輸入是否為負數\n    Yes → Step 2: 輸出 '輸入錯誤' // 顯示錯誤訊息\n    No  → Step 3: 初始化 count = 0 // 設定累加器為 0\n→ Step 4: 初始化 divisor = 5 // 從 5 開始\n→ Decision: 是否 n / divisor >= 1? // 判斷是否還有更高次的五因子\n    Yes → Step 5: count += n / divisor // 加入此層五因子個數\n        → Step 6: divisor *= 5 // 更新 divisor 為下一個五的倍數\n        → Decision: 是否 n / divisor >= 1? // 重新檢查\n            Yes → Step 5 (循環) // 重複步驟 5\n            No  → Step 7: 輸出 count // 輸出尾隨零數\n    No  → Step 7: 輸出 count // 若第一次就不符合，直接輸出\nEnd // 程式執行結束\n\nBut we need each line as separate, not nested like \"→ Step 5 (循環)\" inside Step 6. We could instead use \"→ Decision:\" again for loop. Maybe easier: Use a while-like structure:\n\n→ Step 5: while n / divisor >= 1? // 只要 divisor <= n\n    → Step 6: count += n / divisor // 加入此層五因子個數\n    → Step 7: divisor *= 5 // 更新 divisor\n→ Step 8: 輸出 count\n\nBut we need to express while with Decision, but can use \"→ Decision: n / divisor >= 1?\" etc. We can do:\n\n→ Decision: n / divisor >= 1? // 判斷是否繼續\n    Yes → Step 5: count += n / divisor // 加入當前層五因子個數\n        → Step 6: divisor *= 5 // 更新 divisor\n        → Decision: n / divisor >= 1? // 重新檢查\n            Yes → Step 5 // 循環\n            No  → Step 7: 輸出 count\n    No  → Step 7: 輸出 count\n\nBut this is messy. We can use a simpler approach: Use a \"Loop\" step: \"→ Step 5: 重複以下直到 n / divisor < 1\". But requirement: use Decision arrow. Could use \"→ Decision: n / divisor >= 1?\" and branch Yes to perform operations and return to Decision.\n\nLet's produce final pseudocode:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得使用者輸入的整數\n→ Decision: 如果 n < 0? // 檢查輸入是否為負數\n    Yes → Step 2: 輸出 '輸入錯誤' // 顯示錯誤訊息\n    No  → Step 3: 初始化 count = 0 // 設定尾隨零計數器\n→ Step 4: 初始化 divisor = 5 // 從 5 開始計算\n→ Decision: n / divisor >= 1? // 檢查是否還有更高次的五因子\n    Yes → Step 5: count += n / divisor // 加入此層五因子個數\n        → Step 6: divisor *= 5 // 更新 divisor 為下一個五的倍數\n        → Decision: n / divisor >= 1? // 重新檢查是否繼續\n            Yes → Step 5 // 重新執行同一個累加步驟\n            No  → Step 7: 輸出 count // 輸出尾隨零數\n    No  → Step 7: 輸出 count // 若第一次就不符合，直接輸出\nEnd // 程式執行結束\n\nBut we must keep each line separate and comment. Indentation can be represented by spaces but not required. Provide as plain lines.\n\nMake sure each line ends with // explanation. We need to ensure each line uses \"→ Step X:\" etc. Provide all lines.\n\nLet's finalize.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 取得使用者輸入的整數  \n→ Decision: 如果 n < 0? // 檢查輸入是否為負數  \n    Yes → Step 2: 輸出 '輸入錯誤' // 顯示錯誤訊息，結束程式  \n    No → Step 3: 初始化 count = 0 // 設定尾隨零計數器  \n→ Step 4: 初始化 divisor = 5 // 從 5 開始，向上乘 5 以計算五的倍數  \n→ Decision: n / divisor >= 1? // 判斷是否還有更高次的五因子  \n    Yes → Step 5: count += n / divisor // 加入當前層五因子個數  \n        → Step 6: divisor *= 5 // 更新 divisor 為下一個五的倍數  \n        → Decision: n / divisor >= 1? // 重新檢查是否還有更高次的五因子  \n            Yes → Step 5 // 重新執行累加步驟，形成迴圈  \n            No → Step 7: 輸出 count // 輸出尾隨零數，結束計算  \n    No → Step 7: 輸出 count // 若第一次就不符合，直接輸出尾隨零數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef trailing_zeroes(n: int) -> int:\n    \"\"\"\n    計算 n! 的尾隨零數量。\n    只需要統計 5 的因子數量，因為 2 的因子遠多於 5。\n    \"\"\"\n    count = 0\n    while n > 0:\n        n //= 5          # 取 n 除以 5 的整數商，表示此階層的 5 的個數\n        count += n       # 把所有階層的 5 的個數相加\n    return count\n\ndef main() -> None:\n    \"\"\"\n    主程式：從 stdin 讀取輸入，計算並輸出尾隨零數。\n    支援輸入格式如 'n = 3' 或單純的 '3'。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 透過正則表達式抓取第一個出現的整數（可帶負號）\n    match = re.search(r'-?\\d+', data)\n    n = int(match.group()) if match else 0\n\n    result = trailing_zeroes(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode720.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary",
    "description_snippet": "Given an array of strings words representing an English Dictionary, return the longest word in words...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem: find longest word that can be built one character at a time, each prefix must exist in dictionary. If tie, smallest lexicographical. Return empty string if none. So algorithm: sort words by length asc then lexicographic. Use set of built words; for each word in sorted list: if length 1 or prefix exists in set, add to set; track best: longer or same length lexicographically smaller. But since sorted ascending, we can maintain best easily. Implementation: create set built. best = \"\". Iterate sorted words. For each word, if len==1 or word[:-1] in built: add to built; if len>len(best) or (len==len(best) and word<best): best=word. End. Return best.\n\nSo produce virtual code steps with explanation. Must be line by line. Use Start, End, Decision. Let's do:\n\nStart\n→ Step 1: Sort words by length ascending then lexicographic ascending // order ensures prefixes processed before longer words\n→ Step 2: Initialize BuiltSet = empty set // store words that can be built\n→ Step 3: Initialize BestWord = \"\" // store current best answer\n→ Step 4: For each Word in SortedWords // iterate each word\n    → Decision: If Word length == 1? // single-letter words always buildable\n        Yes → Step 5a: Add Word to BuiltSet // add to set\n        No → Decision: If Word without last char in BuiltSet? // check if prefix exists\n            Yes → Step 5b: Add Word to BuiltSet\n            No  → Step 5c: Continue to next Word // cannot be built, skip\n    → Step 6: Decision: If Word length > length(BestWord) OR (length equal AND Word < BestWord)? // determine if current word is better\n        Yes → Step 7: Set BestWord = Word // update best\n        No  → Step 8: Do nothing // keep current best\n→ End // finished processing all words\n→ Step 9: Return BestWord // output result\n\nNeed to produce virtual code with arrow. Provide each line: step name, then // explanation.\n\nUse \"→\" arrows. Also indent substeps? Example: use indentation for nested decision? In example, they indent with 4 spaces. Let's follow same.\n\nAlso ensure each line has code then // explanation.\n\nLet's craft. Use \"Step 1:\", \"Decision:\" etc.\n\nMake sure each line ends with // explanation. Provide the arrow and indentation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by length ascending then lexicographic ascending // 先按長度再字典序排序，確保前綴先被處理  \n→ Step 2: Initialize BuiltSet = empty set // 用於存儲已構造可用的單詞  \n→ Step 3: Initialize BestWord = \"\" // 儲存目前為止最長且字典序最小的單詞  \n→ Step 4: For each Word in SortedWords // 逐個遍歷排序後的單詞  \n    → Decision: Word length == 1? // 單字符單詞總是可構造  \n        Yes → Step 5a: Add Word to BuiltSet // 將單字符單詞加入集合  \n        No → Decision: Word without last char in BuiltSet? // 檢查前綴是否已可構造  \n            Yes → Step 5b: Add Word to BuiltSet // 前綴存在，將此單詞加入集合  \n            No → Step 5c: Continue to next Word // 前綴不存在，跳過此單詞  \n    → Step 6: Decision: Word length > len(BestWord) OR (Word length == len(BestWord) AND Word < BestWord)? // 判斷是否為更佳答案  \n        Yes → Step 7: Set BestWord = Word // 更新最佳單詞  \n        No → Step 8: Do nothing // 保持目前最佳  \n→ End // 所有單詞已處理完  \n→ Step 9: Return BestWord // 回傳最終答案（若無則為空字串）",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def longestWord(self, words):\n        \"\"\"\n        Find the longest word that can be built one character at a time.\n        Words are sorted by length then lexicographical order so that all\n        prefixes are processed before the words that extend them.\n        \"\"\"\n        # Sort words: first by length, then by lexicographical order\n        words.sort(key=lambda w: (len(w), w))\n        built = set()   # Words that can be constructed\n        best = \"\"       # Current best answer\n\n        for w in words:\n            # A word can be added if it is a single character\n            # or its prefix (all but the last character) is already built\n            if len(w) == 1 or w[:-1] in built:\n                built.add(w)\n                # Update best if this word is longer, or same length but smaller lexicographically\n                if len(w) > len(best) or (len(w) == len(best) and w < best):\n                    best = w\n\n        return best\n\ndef main():\n    \"\"\"\n    Reads input from stdin, parses it into a list of words, runs the solver,\n    and prints the result to stdout.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Expected input format: words = [\"a\", \"b\", ...]\n    # Extract the part that contains the list representation\n    if data.startswith(\"words\"):\n        idx = data.find(\"[\")\n        if idx != -1:\n            list_str = data[idx:]\n            words = ast.literal_eval(list_str)\n        else:\n            words = []\n    else:\n        # If input is just a list representation\n        words = ast.literal_eval(data)\n\n    solver = Solution()\n    result = solver.longestWord(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]",
          "expected_output": "world",
          "success": true,
          "output": "world"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]",
          "expected_output": "apple",
          "success": true,
          "output": "apple"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode131.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe task: produce virtual code steps (line by line) for solving the palindrome partitioning problem. Need to output steps like Start, Step1, Decision etc, each line with // explanation.\n\nWe need to produce algorithm steps: input string, recursively backtrack, check palindrome, accumulate results, output list.\n\nWe need to use virtual code with arrow and structure. Ensure each line contains virtual code step, space, // explanation. Use arrows →, Yes →, No →. Use Start, End.\n\nWe should include steps like:\nStart\n→ Step 1: Read input string s // ...\n→ Step 2: Define result list partitions // ...\n→ Step 3: Define recursive function backtrack(start, current_partition) // ...\n    → Step 4: If start == length(s) → Step 5: Append copy of current_partition to result // base case\n    → Decision: For end from start+1 to length(s):\n        → Step 6: If substring s[start:end] is palindrome:\n            → Step 7: Append substring to current_partition\n            → Step 8: Call backtrack(end, current_partition)\n            → Step 9: Remove last element from current_partition // backtrack\n    // After loop\n→ Step 10: Call backtrack(0, empty list)\n→ Step 11: Return result // output\nEnd\n\nAlso need to note palindrome check: define function isPalindrome(sub) // O(n) or O(1) if precomputed.\n\nMaybe we need to explain caching? But likely not.\n\nUse arrow indentations? They didn't specify indent style but sample shows indent with spaces.\n\nWe should ensure each line has a virtual code step followed by space and // explanation.\n\nWe also need to use Decision structure for loop, but we can show nested decision: Decision: if palindrome? Yes → else → but we can keep simple.\n\nLet's produce each line.\n\nWe'll produce the code:\n\nStart // 程式開始執行\n→ Step 1: Read input string s // 從使用者取得欲分割之字串\n→ Step 2: Initialize result list partitions = [] // 用來儲存所有分割結果\n→ Step 3: Define function isPalindrome(sub) // 判斷子字串是否為回文\n    → Step 4: Return sub == reverse(sub) // 回文判斷\n→ Step 4: Define recursive function backtrack(start, current) // 從 start 開始遞迴搜尋\n    → Decision: start == length(s)? // 是否已到字串結尾\n        Yes → Step 5: Append copy of current to partitions // 完整分割\n        No  → Decision: end from start+1 to length(s)? // 循環可能結尾\n            → Step 6: Set sub = s[start:end] // 取子字串\n            → Decision: isPalindrome(sub)? // 檢查是否為回文\n                Yes → Step 7: Append sub to current // 加入目前分割\n                → Step 8: Call backtrack(end, current) // 進行下一層遞迴\n                → Step 9: Remove last element from current // 回溯\n                No  → // 跳過非回文子字串\n→ Step 10: Call backtrack(0, []) // 開始遞迴\n→ Step 11: Return partitions // 回傳所有分割結果\nEnd // 程式執行結束\n\nBut need arrow indentation: Use '→' before each step inside recursion, but maintain indentation level? The sample shows:\n\nStart\n→ Step 1: ...\n→ Decision: ...\n    Yes → Step ...\n    No  → Decision ...\n\nSo for nested blocks we indent with spaces.\n\nLet's produce accordingly.\n\nWe need to ensure each line has \"虛擬碼步驟 [space] // 解釋/說明\".\n\nThus we need to output something like:\n\nStart // 程式開始執行\n→ Step 1: Read input string s // 從使用者取得欲分割之字串\n→ Step 2: Initialize result list partitions = [] // 用來儲存所有分割結果\n→ Step 3: Define function isPalindrome(sub) // 判斷子字串是否為回文\n    → Step 4: Return sub == reverse(sub) // 回文判斷\n→ Step 5: Define recursive function backtrack(start, current) // 從 start 開始遞迴搜尋\n    → Decision: start == length(s)? // 是否已到字串結尾\n        Yes → Step 6: Append copy of current to partitions // 完整分割\n        No  → Decision: end from start+1 to length(s)? // 循環可能結尾\n            → Step 7: Set sub = s[start:end] // 取子字串\n            → Decision: isPalindrome(sub)? // 檢查是否為回文\n                Yes → Step 8: Append sub to current // 加入目前分割\n                → Step 9: Call backtrack(end, current) // 進行下一層遞迴\n                → Step 10: Remove last element from current // 回溯\n                No  → // 跳過非回文子字串\n→ Step 11: Call backtrack(0, []) // 開始遞迴\n→ Step 12: Return partitions // 回傳所有分割結果\nEnd // 程式執行結束\n\nWe also need to ensure each line after the arrow uses same indentation level.\n\nWe should also include maybe an intermediate step to copy current list when appending.\n\nAlso, we need to ensure the indentation for nested decision is consistent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read input string s // 從使用者取得欲分割之字串  \n→ Step 2: Initialize result list partitions = [] // 用來儲存所有分割結果  \n→ Step 3: Define function isPalindrome(sub) // 判斷子字串是否為回文  \n    → Step 4: Return sub == reverse(sub) // 回文判斷（若正序等於倒序即為回文）  \n→ Step 5: Define recursive function backtrack(start, current) // 從 start 開始遞迴搜尋  \n    → Decision: start == length(s)? // 是否已到字串結尾  \n        Yes → Step 6: Append copy of current to partitions // 完整分割時將結果加入集合  \n        No  → Decision: end from start+1 to length(s)? // 依序嘗試所有可能的結尾位置  \n            → Step 7: Set sub = s[start:end] // 取子字串  \n            → Decision: isPalindrome(sub)? // 檢查此子字串是否為回文  \n                Yes → Step 8: Append sub to current // 加入目前分割  \n                → Step 9: Call backtrack(end, current) // 進行下一層遞迴  \n                → Step 10: Remove last element from current // 回溯，撤銷上一層的決策  \n                No  → // 跳過非回文子字串，繼續嘗試下一個 end  \n→ Step 11: Call backtrack(0, []) // 開始從字串起始位置遞迴  \n→ Step 12: Return partitions // 回傳所有可能的回文分割結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def partition(self, s: str):\n        res = []\n\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n\n        def dfs(start: int, path: list):\n            if start == len(s):\n                res.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    dfs(end, path + [s[start:end]])\n\n        dfs(0, [])\n        return res\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the string between double quotes, if present.\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        s = m.group(1)\n    else:\n        # Fallback: use the whole trimmed input as the string.\n        s = data.strip()\n\n    solution = Solution()\n    result = solution.partition(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
          "success": true,
          "output": "[['a', 'a', 'b'], ['aa', 'b']]"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode43.json",
    "problem_index_in_file": 0,
    "title": "Multiply Strings",
    "description_snippet": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for multiplication of two non-negative integer strings, output string, no big integer or int conversion.\n\nWe need to do grade school multiplication: for each digit of num1 and num2, compute product and add to result array at proper index. Steps: parse lengths, result array of size len1+len2 zeros, iterate i from len1-1 down to 0, j from len2-1 down to 0, multiply digit1*digit2, add to result[i+j+1], carry to result[i+j] etc. After loop, convert array to string, skipping leading zeros.\n\nWe must produce virtual code lines with explanation, using Start, Decision, arrows.\n\nLet's craft lines:\n\nStart // start program\n→ Step 1: let m = length of num1, n = length of num2 // obtain string lengths\n→ Decision: if m == 0 or n == 0? // check if either string empty (though non-negative integers)\n    Yes → Step 2: return \"0\" // if one is empty return 0\n    No  →\n→ Step 3: create array result of size m+n initialized to 0 // prepare result container\n→ Step 4: for i from m-1 down to 0 // iterate digits of num1\n→ Step 5:   digit1 = integer value of num1[i] // convert char to int\n→ Step 6:   for j from n-1 down to 0 // iterate digits of num2\n→ Step 7:       digit2 = integer value of num2[j] // convert char to int\n→ Step 8:       product = digit1 * digit2 // compute partial product\n→ Step 9:       sum = product + result[i+j+1] // add to existing place\n→ Step 10:      result[i+j+1] = sum % 10 // store digit\n→ Step 11:      result[i+j] += sum / 10 // carry to next left position\n→ Step 12: end inner loop // finish j loop\n→ Step 13: end outer loop // finish i loop\n→ Step 14: start building string builder sb // for final output\n→ Decision: if result[0] == 0? // skip leading zero\n    Yes → Step 15: index = 1 // start from next position\n    No  → Step 16: index = 0\n→ Step 17: while index < m+n // iterate through result array\n→ Step 18:   append result[index] to sb // add digit to string\n→ Step 19:   index += 1\n→ Step 20: end while // finished building\n→ Step 21: return sb as string // return final product string\nEnd // program ends\n\nNeed to keep each line with virtual code and comment. Ensure using arrow for decisions. Also \"Step\" lines. Let's output.\n\nNote: use Start, End, Decision:, Yes →, No → etc. Ensure each line has \"虛擬碼步驟 [space] // 解釋/說明\". Provide Chinese explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: let m = length of num1, n = length of num2 // 取得兩個字串的長度  \n→ Decision: m == 0 或 n == 0? // 檢查是否有空字串  \n  Yes → Step 2: return \"0\" // 若任一為空，直接回傳 0  \n  No  →  \n→ Step 3: create array result of size m + n, all elements 0 // 準備儲存結果的暫存陣列  \n→ Step 4: for i from m-1 down to 0 // 迴圈遍歷 num1 的每一位  \n  → Step 5: digit1 = integer value of num1[i] // 把字元轉成數字  \n  → Step 6: for j from n-1 down to 0 // 迴圈遍歷 num2 的每一位  \n    → Step 7: digit2 = integer value of num2[j] // 把字元轉成數字  \n    → Step 8: product = digit1 * digit2 // 計算兩位數的乘積  \n    → Step 9: sum = product + result[i+j+1] // 加上先前的值（含進位）  \n    → Step 10: result[i+j+1] = sum % 10 // 存入此位數字  \n    → Step 11: result[i+j] += sum / 10 // 將進位加到左側位置  \n    → Step 12: end inner loop // 完成對 j 的迭代  \n  → Step 13: end outer loop // 完成對 i 的迭代  \n→ Step 14: start building string sb // 準備組裝最終字串  \n→ Decision: result[0] == 0? // 判斷首位是否為 0，需不需要跳過  \n  Yes → Step 15: index = 1 // 從第二個位置開始  \n  No  → Step 16: index = 0 // 從第一個位置開始  \n→ Step 17: while index < m + n // 逐位將陣列內容轉為字串  \n  → Step 18: append result[index] to sb // 加入當前位數字  \n  → Step 19: index += 1 // 移動到下一個位置  \n  → Step 20: end while // 結束迴圈  \n→ Step 21: return sb as string // 回傳乘積字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        pos = [0] * (m + n)\n\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n                pos[p1] += sum_ // 10\n                pos[p2] = sum_ % 10\n\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Attempt to extract numbers from quoted format\n    quoted = re.findall(r\"'([^']*)'\", data)\n    if len(quoted) >= 2:\n        num1, num2 = quoted[0], quoted[1]\n    else:\n        # Fallback: try to find two numeric strings in the input\n        numbers = re.findall(r'\\d+', data)\n        if len(numbers) >= 2:\n            num1, num2 = numbers[0], numbers[1]\n        else:\n            # If still not found, use first two lines as input\n            lines = data.splitlines()\n            if len(lines) >= 2:\n                num1, num2 = lines[0].strip(), lines[1].strip()\n            else:\n                # As a last resort, treat entire input as num1, empty num2\n                num1, num2 = data, \"\"\n\n    result = Solution().multiply(num1, num2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "success": true,
          "output": "56088"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode539.json",
    "problem_index_in_file": 0,
    "title": "Minimum Time Difference",
    "description_snippet": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference b...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. The user wants algorithm: given list of time strings, find min difference between any two times, considering circular nature midnight. We need to output steps: Start, parse times to minutes, sort, compute min diff between adjacent, including wrap around last and first. End. Also need decision structure? Not many decisions but maybe a decision for empty list? We can include.\n\nLet's produce step-by-step with arrow. For each line include explanation.\n\nLet's generate something like:\n\nStart\n→ Step 1: 接收時間列表 // Input list of HH:MM strings\n→ Decision: 是否為空列表? // check\n    Yes → Step 2: 回傳 0 // no difference\n    No  → Step 3: 將每個時間字串轉成分鐘數 // convert\n    → Step 4: 按升序排序分鐘列表 // sort\n    → Step 5: 設定 minDiff = Infinity // init\n    → Step 6: 對於 i 從 0 到 len-2:\n        → Step 7: diff = times[i+1] - times[i] // adjacent diff\n        → Step 8: 如果 diff < minDiff: minDiff = diff // update\n    → Step 9: 計算 wrapDiff = (times[0] + 1440) - times[-1] // between last and first across midnight\n    → Step 10: 如果 wrapDiff < minDiff: minDiff = wrapDiff\n    → Step 11: 回傳 minDiff // result\nEnd\n\nWe need to use arrow syntax: \"→\" before each step. For decision, we use \"Decision:\" with Yes/No arrows. Ensure each line has \" // \" explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收時間列表 // 從使用者處取得時間字串陣列  \n→ Decision: 是否為空列表? // 檢查輸入是否為空  \n    Yes → Step 2: 回傳 0 // 空列表無法計算差距，直接回傳 0  \n    No → Step 3: 將每個時間字串轉成分鐘數 // 解析 HH:MM 為 0-1439 分鐘  \n→ Step 4: 按升序排序分鐘列表 // 為方便計算相鄰差距  \n→ Step 5: 設定 minDiff = Infinity // 初始化最小差距  \n→ Step 6: 對於 i 從 0 到 len-2: // 逐一比較相鄰時間差  \n    → Step 7: diff = times[i+1] - times[i] // 計算相鄰時間差  \n    → Decision: diff < minDiff? // 是否更新最小差距  \n        Yes → Step 8: minDiff = diff // 更新 minDiff  \n        No  → // 保持當前 minDiff  \n→ Step 9: 計算 wrapDiff = (times[0] + 1440) - times[-1] // 計算跨午夜的差距  \n→ Decision: wrapDiff < minDiff? // 檢查跨午夜差距是否更小  \n    Yes → Step 10: minDiff = wrapDiff // 更新 minDiff  \n    No  → // 保持當前 minDiff  \n→ Step 11: 回傳 minDiff // 返回最小分鐘差距  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findMinDifference(self, timePoints):\n        \"\"\"Return the minimum difference in minutes between any two time points.\"\"\"\n        minutes = []\n        for t in timePoints:\n            h, m = map(int, t.split(':'))\n            minutes.append(h * 60 + m)\n        minutes.sort()\n\n        min_diff = float('inf')\n        for i in range(1, len(minutes)):\n            min_diff = min(min_diff, minutes[i] - minutes[i - 1])\n\n        # Difference between the last and first time points across midnight\n        min_diff = min(min_diff, 1440 - (minutes[-1] - minutes[0]))\n        return min_diff\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    # Parse the input as a JSON array of strings\n    time_points = json.loads(input_data)\n    solution = Solution()\n    result = solution.findMinDifference(time_points)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"23:59\",\"00:00\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[\"00:00\",\"23:59\",\"00:00\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode665.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Array",
    "description_snippet": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a step-by-step virtual code in Chinese (Traditional) with explanation. So produce a virtual algorithm: iterate over array, count violations. If more than one, return false. If one violation, need to check if modification possible: either modify nums[i] to nums[i-1] or nums[i+1] to nums[i] etc. Classic solution: for i from 0 to n-2, if nums[i] > nums[i+1], increment count. If count >1 return false. If i==0 or nums[i-1] <= nums[i+1] then set nums[i] = nums[i+1] else set nums[i+1] = nums[i]. Continue. At end return true.\n\nWe'll produce virtual steps accordingly.\n\nWe need each line with \"虛擬碼步驟\" and explanation.\n\nStart, Step, Decision, etc.\n\nLet's do:\n\nStart\n→ Step 1: Initialize count = 0 // count of modifications\n→ Step 2: For i from 0 to n-2 // iterate through pairs\n    → Decision: nums[i] > nums[i+1]? // check if violation\n        Yes → Step 3: Increment count // one violation found\n        No  → Continue loop // no violation\n        Yes → Decision: count > 1? // more than one violation\n            Yes → Step 4: Return false // cannot fix\n            No  → Decision: i == 0 OR nums[i-1] <= nums[i+1]? // can modify nums[i]\n                Yes → Step 5: nums[i] = nums[i+1] // adjust lower element\n                No  → Step 6: nums[i+1] = nums[i] // adjust upper element\n        Continue loop\n→ Step 7: Return true // all good\n\nBut we need to format each line individually.\n\nWe should use arrows and Decision.\n\nUse Chinese comments.\n\nLet's write each line separately.\n\nWe'll produce maybe like:\n\nStart // 程式開始\n\n→ Step 1: 初始化 count = 0 // 記錄需要修改的次數\n\n→ Step 2: For i from 0 to n-2 // 遍歷相鄰元素\n\n    → Decision: 如果 nums[i] > nums[i+1]? // 檢查是否有降序\n\n        Yes → Step 3: count++ // 發現一次降序，需考慮修改\n\n        No  →  // 什麼都不做，繼續\n\n        Yes → Decision: 如果 count > 1? // 已經有多於一次的降序\n\n            Yes → Step 4: 返回 false // 超過一次，無法修正\n\n            No  → Decision: 如果 i == 0 或 nums[i-1] <= nums[i+1]? // 判斷可以改哪一個\n\n                Yes → Step 5: nums[i] = nums[i+1] // 把左側調整到右側\n\n                No  → Step 6: nums[i+1] = nums[i] // 把右側調整到左側\n\n    // 之後繼續循環\n\n→ Step 7: 返回 true // 只需一次或沒有降序，符合條件\n\nEnd // 程式結束\n\nMake sure each line ends with // 解釋.\n\nLet's format with proper indentation? The example shows indentation for Decision branches but each line still separate.\n\nLet's produce each line with arrow or decision. For decisions we need \"Decision:\" line. For each branch we use Yes → and No →.\n\nWe need each line a separate virtual step line with explanation. So we should not merge multiple steps into one line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 count = 0 // 用來記錄需要修改的次數\n→ Step 2: 從 i = 0 到 n-2 遍歷 // 逐對比相鄰元素\n    → Decision: 如果 nums[i] > nums[i+1]? // 檢查是否存在下降\n        Yes → Step 3: count = count + 1 // 發現一次下降，計數加一\n        No  →  // 沒有下降，直接跳到下一對\n        Yes → Decision: 如果 count > 1? // 已經有超過一次下降\n            Yes → Step 4: 返回 false // 兩次以上無法修正\n            No  → Decision: 如果 i == 0 或 nums[i-1] <= nums[i+1]? // 判斷哪邊可調整\n                Yes → Step 5: nums[i] = nums[i+1] // 調整左側為右側值\n                No  → Step 6: nums[i+1] = nums[i] // 調整右側為左側值\n    // 之後繼續循環\n→ Step 7: 返回 true // 只需要一次或沒有下降，即可滿足非遞減\nEnd // 程式執行結束\n\nBut we need each line to be separate, not nested with comments. In the example, each line is separate, but indentation inside Decision indicates nested lines. The Decision line is a separate line, and the branches Yes → and No → are separate lines.\n\nThus we need separate lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 count = 0 // 用來記錄需要修改的次數\n→ Step 2: 從 i = 0 到 n-2 遍歷 // 逐對比相鄰元素\n    → Decision: 如果 nums[i] > nums[i+1]? // 檢查是否存在下降\n        Yes → Step 3: count = count + 1 // 發現一次下降，計數加一\n        No  → // 沒有下降，直接跳到下一對\n        Yes → Decision: 如果 count > 1? // 已經有超過一次下降\n            Yes → Step 4: 返回 false // 兩次以上無法修正\n            No  → Decision: 如果 i == 0 或 nums[i-1] <= nums[i+1]? // 判斷哪邊可調整\n                Yes → Step 5: nums[i] = nums[i+1] // 調整左側為右側值\n                No  → Step 6: nums[i+1] = nums[i] // 調整右側為左側值\n    // 之後繼續循環\n→ Step 7: 返回 true // 只需要一次或沒有下降，即可滿足非遞減\nEnd // 程式執行結束\n\nWe should include \"→\" before each step except Start and End. But inside Decision we use \"→\". In example, Decision line itself has \"Decision:\". So we need:\n\n→ Decision: ...\n\nAlso, for \"No  → // ...\" we need \"No →\". But no explanation needed? Should include explanation. For No branch we could still give explanation like \"無需調整\" etc.\n\nLet's produce final output accordingly.\n\nCheck formatting: Use tabs or spaces? In example they use indentation with spaces. Use four spaces for nested. We'll do that.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 count = 0 // 用來記錄需要修改的次數  \n→ Step 2: 從 i = 0 到 n-2 遍歷 // 逐對比相鄰元素  \n    → Decision: 如果 nums[i] > nums[i+1]? // 檢查是否存在下降  \n        Yes → Step 3: count = count + 1 // 發現一次下降，計數加一  \n        No  → // 沒有下降，直接跳到下一對  \n        Yes → Decision: 如果 count > 1? // 已經有超過一次下降  \n            Yes → Step 4: 返回 false // 兩次以上無法修正  \n            No  → Decision: 如果 i == 0 或 nums[i-1] <= nums[i+1]? // 判斷哪邊可調整  \n                Yes → Step 5: nums[i] = nums[i+1] // 調整左側為右側值  \n                No  → Step 6: nums[i+1] = nums[i] // 調整右側為左側值  \n    // 之後繼續循環  \n→ Step 7: 返回 true // 只需要一次或沒有下降，即可滿足非遞減  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef check_possibility(nums):\n    \"\"\"判斷 nums 是否能在最多修改一次元素後變成非遞減。\"\"\"\n    count = 0\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i - 1]:\n            count += 1\n            if count > 1:\n                return False\n            # 判斷是修改前一個還是當前元素較易\n            if i == 1 or nums[i] >= nums[i - 2]:\n                nums[i - 1] = nums[i]  # 修改左側\n            else:\n                nums[i] = nums[i - 1]  # 修改右側\n    return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入中的 list，假設格式類似 \"nums = [4,2,3]\"\n    try:\n        start = data.index('[')\n        end = data.index(']', start)\n        list_str = data[start:end + 1]\n        nums = eval(list_str)\n    except Exception:\n        nums = []\n\n    result = check_possibility(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,2,3]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode446.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices II - Subsequence",
    "description_snippet": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n\nA sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step explanation. For problem: count arithmetic subsequences of at least length 3. Known solution: use DP with hashmap of difference counts per index. For each pair i<j, compute diff = nums[j]-nums[i]; use dp[j][diff] += dp[i][diff] + 1; ans += dp[i][diff]; Actually ans counts sequences of length>=3: when extending dp[i][diff] to j, the added sequences are dp[i][diff] (since dp[i][diff] counts sequences ending at i with diff, at least length 2?) We use dp[i][diff] counts number of subsequences ending at i with diff, including length>=2. Then when we form new pair (i,j), we add dp[i][diff] to ans (those extended to length>=3). Then dp[j][diff] += dp[i][diff] + 1 (add the new pair itself as length 2 subsequence). Implementation details: use array of HashMap<Long,Integer> dp. Use long for diff. answer as long. Return int.\n\nWe need virtual code line by line with explanation. Let's design steps:\n\nStart\n→ Step 1: Initialize variable n as length of nums // array length\n→ Step 2: Create array dp of size n, each entry is empty map // map from difference to count\n→ Step 3: Initialize ans = 0 // result\n→ Step 4: For each index i from 0 to n-1 // outer loop over pairs\n    → Step 5: For each index j from i+1 to n-1 // inner loop\n        → Step 6: Compute diff = nums[j] - nums[i] // difference\n        → Step 7: Retrieve count_i = dp[i].getOrDefault(diff,0) // sequences ending at i with this diff\n        → Step 8: ans += count_i // extend to length>=3\n        → Step 9: Update dp[j][diff] = dp[j].getOrDefault(diff,0) + count_i + 1 // add new sequences ending at j\nEnd\n\nReturn (int)ans\n\nBut we need to produce virtual code with arrows and decision? No decision needed. Just loops.\n\nLet's format:\n\nStart\n→ Step 1: n = length(nums) // array length\n→ Step 2: dp = array of n empty maps // maps of diff->count\n→ Step 3: ans = 0 // total count\n→ Decision: if n < 3? // quick exit\n    Yes → Step 4: Return 0 // no subsequence possible\n    No  → \n        → For i = 0 to n-1\n            → For j = i+1 to n-1\n                → Step 5: diff = nums[j] - nums[i] // compute difference\n                → Step 6: count_i = dp[i].getOrDefault(diff, 0) // existing seq ending at i\n                → Step 7: ans += count_i // extend to length >=3\n                → Step 8: dp[j].put(diff, dp[j].getOrDefault(diff, 0) + count_i + 1) // update dp[j]\n→ Step 9: Return ans as int // final result\n\nNeed to follow format: \"虛擬碼步驟 [空格] // 解釋\".\n\nLet's produce each line accordingly. Ensure use arrow \"→\" preceding step lines. For decision block, indent with spaces? In example, indentation using spaces. We'll indent Decision lines with tabs? Use spaces. Provide \"Yes →\" \"No →\" accordingly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length(nums) // 取得輸入陣列長度  \n→ Step 2: dp = array of n empty maps // 每個位置存放差值到子序列數量的映射  \n→ Step 3: ans = 0 // 結果累計  \n→ Decision: 如果 n < 3? // 快速判斷是否能形成至少三元素的子序列  \n  Yes → Step 4: Return 0 // 無法形成，直接回傳 0  \n  No →  \n   → For i = 0 to n-1 // 外層迴圈，遍歷所有起始點  \n    → For j = i+1 to n-1 // 內層迴圈，遍歷所有可延伸的終點  \n     → Step 5: diff = nums[j] - nums[i] // 計算當前兩點的差值  \n     → Step 6: count_i = dp[i].getOrDefault(diff, 0) // 取出以 i 為結束、差值為 diff 的子序列數量  \n     → Step 7: ans += count_i // 這些子序列延伸至 j 後長度至少 3，累加到答案  \n     → Step 8: dp[j].put(diff, dp[j].getOrDefault(diff, 0) + count_i + 1) // 更新以 j 為結束、差值為 diff 的子序列數量（包含新的長度 2 子序列）  \n→ Step 9: Return ans as int // 回傳最終計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        if n < 3:\n            return 0\n        dp = [defaultdict(int) for _ in range(n)]\n        total = 0\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                count = dp[j][diff]\n                dp[i][diff] += count + 1\n                total += count\n        return total\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Extract the list part from the input string\n    start = data.find('[')\n    if start != -1:\n        list_str = data[start:]\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            nums = list(map(int, data.replace('nums', '').replace('=', '').split()))\n    else:\n        nums = list(map(int, data.split()))\n    solution = Solution()\n    result = solution.numberOfArithmeticSlices(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,4,6,8,10]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [7,7,7,7,7]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode309.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem of maximum profit with cooldown. Provide step-by-step virtual code. The user wants steps and explanation in Chinese Traditional.\n\nWe need to output lines like:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化狀態 dp_hold, dp_sold, dp_cool 等 // etc\n\nWe need to produce algorithm. Likely use DP: dp[i][0] hold, dp[i][1] sold, dp[i][2] rest.\n\nBut we produce simpler description.\n\nWe'll produce the virtual code:\n\nStart\n→ Step 1: n ← length of prices\n→ Decision: 如果 n == 0? → Yes → Step 2: Return 0 // 無天數無利潤\n→ No  → Step 3: 初始化 dp arrays: hold[0] = -prices[0]; sold[0] = 0; rest[0] = 0\n→ Step 4: 從 i=1 到 n-1 循環\n    → Step 4.1: hold[i] ← max( hold[i-1], rest[i-1] - prices[i] ) // 保持持有或今天買進\n    → Step 4.2: sold[i] ← hold[i-1] + prices[i] // 今天賣出\n    → Step 4.3: rest[i] ← max( rest[i-1], sold[i-1] ) // 休息：上一天未持有或上天賣完\n→ Step 5: Return max( sold[n-1], rest[n-1] ) // 最終最大利潤\n\nEnd\n\nBut we need each line: \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe need to include arrow, etc.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: n ← length(prices) // 取得天數\n→ Decision: n == 0? // 如果沒有天數\n    Yes → Step 2: Return 0 // 無交易可做，利潤為 0\n    No  → Step 3: hold ← array(n) ; sold ← array(n) ; rest ← array(n) // 初始化 DP 陣列\n→ Step 4: hold[0] ← -prices[0] ; sold[0] ← 0 ; rest[0] ← 0 // 初始狀態：持有、已賣、休息\n→ Step 5: For i from 1 to n-1 Do // 逐日迭代\n    → Step 5.1: hold[i] ← max( hold[i-1], rest[i-1] - prices[i] ) // 先持有或今天買進\n    → Step 5.2: sold[i] ← hold[i-1] + prices[i] // 今天賣出\n    → Step 5.3: rest[i] ← max( rest[i-1], sold[i-1] ) // 休息：上天未持有或已賣完\n→ Step 6: Return max( sold[n-1], rest[n-1] ) // 最終最大利潤\nEnd // 程式結束\n\nBut the requirement: \"每行必須包含：虛擬碼步驟 + 空格 + // 解釋/說明\" and use arrow.\n\nAlso need to show Decision block indentation.\n\nWe should indent decisions with two spaces? The format example uses indentation inside Decision. Let's mimic.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(prices) // 取得天數\n→ Decision: n == 0? // 若沒有交易天數\n    Yes → Step 2: Return 0 // 無利潤\n    No  → Step 3: hold ← array(n) ; sold ← array(n) ; rest ← array(n) // 初始化三個 DP 陣列\n→ Step 4: hold[0] ← -prices[0] ; sold[0] ← 0 ; rest[0] ← 0 // 初始狀態\n→ Step 5: For i = 1 to n-1 Do // 逐日處理\n    → Step 5.1: hold[i] ← max( hold[i-1], rest[i-1] - prices[i] ) // 持有或今天買進\n    → Step 5.2: sold[i] ← hold[i-1] + prices[i] // 今天賣出\n    → Step 5.3: rest[i] ← max( rest[i-1], sold[i-1] ) // 休息或上天賣完\n→ Step 6: Return max( sold[n-1], rest[n-1] ) // 最終最大利潤\nEnd // 程式結束\n\nWe must ensure each line has \"虛擬碼步驟 + 空格 + // 解釋\".\n\nAlso \"Start\" and \"End\" lines should have // comments.\n\nWe need to include arrow \"→\" before each step except Start? In example, Start is on its own line without arrow. They used \"Start // 程式開始執行\". So same.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: n ← length(prices) // 取得天數\n→ Decision: n == 0? // 若沒有交易天數\n    Yes → Step 2: Return 0 // 無利潤\n    No  → Step 3: hold ← array(n) ; sold ← array(n) ; rest ← array(n) // 初始化三個 DP 陣列\n→ Step 4: hold[0] ← -prices[0] ; sold[0] ← 0 ; rest[0] ← 0 // 初始狀態\n→ Step 5: For i = 1 to n-1 Do // 逐日處理\n    → Step 5.1: hold[i] ← max( hold[i-1], rest[i-1] - prices[i] ) // 持有或今天買進\n    → Step 5.2: sold[i] ← hold[i-1] + prices[i] // 今天賣出\n    → Step 5.3: rest[i] ← max( rest[i-1], sold[i-1] ) // 休息或上天賣完\n→ Step 6: Return max( sold[n-1], rest[n-1] ) // 最終最大利潤\nEnd // 程式結束\n\nWe need to ensure each line after \"Decision:\" block is indented. The example uses 4 spaces before inner lines. We'll use similar. In the example:\n\nDecision: 如果數字大於 0? \n    Yes → Step 2: 輸出 '正數' \n    No  → Decision: 如果數字等於 0? \n        Yes → Step 3: 輸出 '零' \n        No  → Step 4: 輸出 '負數' \n\nSo indentation increases for nested. For our code, we need indentation for the Yes/No lines. For No branch, we have Step 3. So we need to indent 4 spaces before \"Yes\" and \"No\". For No's nested Step 3, indent 4 spaces. That is okay.\n\nThus final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(prices) // 取得天數  \n→ Decision: n == 0? // 若沒有交易天數  \n    Yes → Step 2: Return 0 // 無利潤  \n    No  → Step 3: hold ← array(n) ; sold ← array(n) ; rest ← array(n) // 初始化三個 DP 陣列  \n→ Step 4: hold[0] ← -prices[0] ; sold[0] ← 0 ; rest[0] ← 0 // 初始狀態  \n→ Step 5: For i = 1 to n-1 Do // 逐日處理  \n    → Step 5.1: hold[i] ← max( hold[i-1], rest[i-1] - prices[i] ) // 持有或今天買進  \n    → Step 5.2: sold[i] ← hold[i-1] + prices[i] // 今天賣出  \n    → Step 5.3: rest[i] ← max( rest[i-1], sold[i-1] ) // 休息或上天賣完  \n→ Step 6: Return max( sold[n-1], rest[n-1] ) // 最終最大利潤  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n        n = len(prices)\n        hold = -prices[0]   # 持有股票的最大收益\n        sold = 0            # 剛賣出股票的最大收益\n        rest = 0            # 不持有股票且未剛賣出的最大收益\n        for price in prices[1:]:\n            prev_sold = sold\n            sold = hold + price              # 今天賣出\n            hold = max(hold, rest - price)   # 今天持有或買入\n            rest = max(rest, prev_sold)      # 今天休息\n        return max(sold, rest)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，可能為 \"prices = [1,2,3]\" 或直接 \"[1,2,3]\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(0)\n        sys.exit()\n    # 取出方括號內的數列\n    try:\n        # 若輸入包含 '='，則切分取得右側\n        if '=' in raw_input:\n            raw_input = raw_input.split('=', 1)[1].strip()\n        # 使用 ast.literal_eval 解析安全的 Python 表達式\n        prices = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，視為空列表\n        prices = []\n    solution = Solution()\n    profit = solution.maxProfit(prices)\n    print(profit)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,2,3,0,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "prices = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode275.json",
    "problem_index_in_file": 0,
    "title": "H-Index II",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo code step by step. Input sorted citations array. Compute h-index: find max h such that at least h papers have ≥h citations. Since sorted ascending. We can binary search for index i where citations[i] >= n - i? Let's recall formula: For sorted ascending length n, we need to find largest h such that citations[n-h] >= h? Wait typical algorithm: For sorted ascending array a[0..n-1]. We want maximum h such that a[n-h] >= h. Because there are h papers with at least h citations: choose last h papers. So find largest h satisfying that condition. We can binary search on h from 0 to n. Condition: a[n-h] >= h. If true, h is possible, search higher. else search lower. So binary search. Complexity O(log n). We'll produce pseudocode with Start, Decision, etc.\n\nWe output each line of virtual code with comment.\n\nLet's produce.\n\nStart\n→ Step 1: Input citations array // 获取已排序的引用数组\n→ Step 2: Let n ← length of citations // 记录数组长度\n→ Step 3: Let left ← 0, right ← n // 设置二分搜索区间（h 的取值范围）\n→ Decision: left <= right? // 判断是否还有搜索区间\n    Yes →\n        → Step 4: mid ← (left + right) // 2 // 取中间值作为候选 h\n        → Decision: citations[n - mid] >= mid? // 检查前 mid 位置的引用是否满足条件\n            Yes →\n                → Step 5: left ← mid + 1 // 当前 mid 满足，尝试更大的 h\n                → Step 6: result ← mid // 记录当前可行的 h\n            No →\n                → Step 7: right ← mid - 1 // 当前 mid 不满足，缩小 h\n    No → End // 搜索结束\nEnd // 输出 result\n\nBut we need to include end after loop? We can restructure to have loop. Maybe use Decision and branches. We should show result output.\n\nLet's output more explicit loop. We'll include a loop structure: while left <= right. We'll do Decision, Yes branch with body, No branch with End.\n\nLet's produce final.\n\nWe'll include final step: Output result // 返回 h-index\n\nAlso include comments.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input citations // 取得已排序的引用數列  \n→ Step 2: Let n ← length of citations // 取得數列長度  \n→ Step 3: Let left ← 0, right ← n, result ← 0 // 初始化二分搜尋範圍與答案  \n→ Decision: left ≤ right? // 判斷是否還有搜尋空間  \n    Yes →  \n        → Step 4: mid ← (left + right) // 2 // 取中間作為候選 h  \n        → Decision: citations[n - mid] ≥ mid? // 檢查最後 mid 篇是否每篇至少被 mid 次引用  \n            Yes →  \n                → Step 5: result ← mid // 目前可行的最大 h  \n                → Step 6: left ← mid + 1 // 嘗試更大的 h  \n            No →  \n                → Step 7: right ← mid - 1 // 需要更小的 h  \n    No → End // 當 left > right 時結束搜尋  \n→ Step 8: Output result // 返回計算得到的 h-index  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def hIndex(self, citations):\n        \"\"\"\n        Compute the h-index of a researcher given a sorted (non‑decreasing) list of citation counts.\n        Uses a binary search that runs in O(log n) time.\n        \"\"\"\n        n = len(citations)\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            # Number of papers with at least citations[mid] citations\n            papers_ge = n - mid\n            if citations[mid] == papers_ge:\n                return papers_ge\n            elif citations[mid] < papers_ge:\n                # Need more citations per paper → search right side\n                left = mid + 1\n            else:\n                # Too many citations per paper → search left side\n                right = mid - 1\n        # When loop exits, left is the smallest index such that\n        # citations[left] >= n - left is false for all left <= current left\n        # The h-index is then n - left\n        return n - left\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the standard input which may look like:\n        citations = [0,1,3,5,6]\n    or simply\n        [0,1,3,5,6]\n    Returns the list of integers.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n\n    # Remove a possible leading variable assignment\n    if data.startswith('citations'):\n        eq_index = data.find('=')\n        if eq_index != -1:\n            data = data[eq_index + 1:].strip()\n\n    try:\n        return ast.literal_eval(data)\n    except Exception:\n        # Fallback: extract all integers\n        import re\n        return [int(x) for x in re.findall(r'-?\\d+', data)]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    citations = parse_input(raw_input)\n    result = Solution().hIndex(citations)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode403.json",
    "problem_index_in_file": 0,
    "title": "Frog Jump",
    "description_snippet": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. It's a typical frog crossing problem. We'll produce steps: start, build set of stones for O(1) lookup, DFS or BFS with memoization. Use stack or recursion. We'll provide steps line by line.\n\nWe'll output as lines starting with Start, arrow \"→\". Need to ensure each line: \"虛擬碼步驟 // 解釋/說明\". Use virtual code style. Use \"Decision:\" and \"Yes →\", \"No →\" for branching. Let's design algorithm: Use DFS with memoization. Steps:\n\n1. Start.\n2. Input stones array.\n3. Convert to set for O(1).\n4. Define recursive function canCross(index, lastJump) where index is current stone index.\n5. Decision: index == last stone? return true.\n6. For nextJump in {lastJump-1, lastJump, lastJump+1}:\n   - If nextJump <=0 skip.\n   - NextPos = stones[index] + nextJump\n   - Decision: nextPos in stones set? Yes -> find nextIndex via map\n        - Decision: (nextIndex, nextJump) not visited? (memo)\n           - Recurse.\n           - If true, return true.\n7. After loop, memoize false, return false.\n\nBut we need virtual code lines. We'll use arrow for recursion calls.\n\nLet's produce pseudocode:\n\nStart // 程式開始執行\n→ Step 1: 獲取 stones array // 取得石頭位置清單\n→ Step 2: stonesSet ← Set(stones) // 將位置存入集合便於 O(1) 查詢\n→ Step 3: indexMap ← Map position→index // 方便尋找下一個石頭的索引\n→ Step 4: memo ← Empty Set // 併存已失敗的 (index, jump) 組合\n→ Step 5: Function canCross(idx, lastJump) // 定義遞迴函式\n    → Decision: 如果 idx 為最後一個石頭? // 檢查是否已到終點\n        Yes → Return True // 成功\n        No  → For each nextJump in {lastJump-1, lastJump, lastJump+1} // 嘗試三種跳距\n            → Decision: nextJump <= 0? // 跳距不能為負或零\n                No → NextPos ← stones[idx] + nextJump // 計算下一位置\n                → Decision: NextPos in stonesSet? // 是否有石頭\n                    Yes → NextIdx ← indexMap[NextPos] // 找到下一索引\n                    → Decision: (NextIdx, nextJump) 已在 memo? // 已嘗試失敗\n                        No → If canCross(NextIdx, nextJump) == True\n                            → Return True // 找到成功路徑\n                    No  → Continue // 不是石頭，嘗試下一跳距\n            Yes → Continue // 跳距不合法，嘗試下一跳距\n        → memo.add((idx, lastJump)) // 所有跳距失敗，記錄失敗\n        → Return False // 無路可通\n→ Step 6: result ← canCross(0, 1) // 從第一石頭開始，第一次跳距為1\n→ End // 程式結束\n\nWe need to include \"→\" each line, but for nested we might indent but keep arrow. Use \"Decision:\" lines. For loops, we use \"For each\" line. We need to maintain formatting: each line starts with \"→\" or \"Decision:\" with indentation.\n\nAlso need \"Yes →\" and \"No →\" for branching. For loop, we can't use arrow for each iteration. But we can just represent loop as one line: \"→ For each nextJump in {...}\". Then inside decisions we can use \"Decision:\" lines.\n\nLet's produce final answer with each line accordingly.\n\nAlso include End line.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 獲取 stones array // 取得石頭位置清單  \n→ Step 2: stonesSet ← Set(stones) // 將位置存入集合便於 O(1) 查詢  \n→ Step 3: indexMap ← Map position → index // 建立位置到索引的映射  \n→ Step 4: memo ← Empty Set // 用於記錄已失敗的 (index, lastJump) 組合  \n→ Step 5: Function canCross(idx, lastJump) // 定義遞迴函式  \n&nbsp;&nbsp;→ Decision: idx 為最後一個石頭? // 檢查是否已到終點  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return True // 成功，到達最後一塊石頭  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → For each nextJump in {lastJump-1, lastJump, lastJump+1} // 嘗試三種跳距  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: nextJump ≤ 0? // 跳距不能為負或零  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → NextPos ← stones[idx] + nextJump // 計算下一位置  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: NextPos ∈ stonesSet? // 是否有石頭  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → NextIdx ← indexMap[NextPos] // 找到下一索引  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: (NextIdx, nextJump) 已在 memo? // 已嘗試失敗  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → If canCross(NextIdx, nextJump) == True  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Return True // 找到成功路徑  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Continue // 不是石頭，嘗試下一跳距  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Continue // 跳距不合法，嘗試下一跳距  \n&nbsp;&nbsp;&nbsp;&nbsp;→ memo.add((idx, lastJump)) // 所有跳距失敗，記錄失敗  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Return False // 無路可通  \n→ Step 6: result ← canCross(0, 1) // 從第一石頭開始，第一次跳距為1  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canCross(self, stones):\n        \"\"\"Return True if the frog can reach the last stone.\"\"\"\n        if not stones:\n            return False\n\n        stone_set = set(stones)\n        # Map each stone to a set of possible last jump lengths that can reach it\n        jumps = {stones[0]: {0}}\n\n        for stone in stones:\n            for last_jump in jumps.get(stone, []):\n                for step in (last_jump - 1, last_jump, last_jump + 1):\n                    if step <= 0:\n                        continue\n                    next_pos = stone + step\n                    if next_pos in stone_set:\n                        jumps.setdefault(next_pos, set()).add(step)\n\n        return bool(jumps.get(stones[-1]))\n\nif __name__ == \"__main__\":\n    # Read all input\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # Parse the input into a list of integers\n    if '=' in raw:\n        _, expr = raw.split('=', 1)\n    else:\n        expr = raw\n    expr = expr.strip()\n    try:\n        stones = ast.literal_eval(expr)\n    except Exception:\n        # Fallback: treat as comma-separated numbers\n        stones = [int(x) for x in expr.replace(' ', '').split(',') if x]\n\n    # Ensure the stones are sorted (the problem statement guarantees this)\n    stones.sort()\n\n    result = Solution().canCross(stones)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stones = [0,1,3,5,6,8,12,17]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "stones = [0,1,2,3,4,8,9,11]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  }
]