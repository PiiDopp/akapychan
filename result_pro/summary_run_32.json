{
  "run_index": 32,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 389,
  "generation_or_validation_failure_count": 50,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,3,3,5,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 3, 3, 5, 4]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    模擬擲 n 次六面骰，回傳所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼，並在本模組的全域環境中執行\n    input_code = sys.stdin.read()\n    exec(input_code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese, step by step with arrow and explanation. Use random module. The function roll_dice(n) simulating n rolls, returns list of results. Steps: import random, define function, initialize list, loop n times, append random.randint(1,6), return list. End.\n\nUse format: Start // Start. Use arrow. Use Decision maybe not needed. Provide line by line with explanation. We'll produce:\n\nStart // 程式開始執行\n→ Step 1: 導入 random 模組 // 需要使用 random 產生隨機數\n→ Step 2: 定義函式 roll_dice(n) // 接收擲骰次數\n→ Step 3: 初始化空列表 results // 用於儲存每次擲骰結果\n→ Step 4: 循環 i 於 1 到 n // 執行 n 次擲骰\n    → Step 4a: 在 results 中追加 random.randint(1, 6) // 擲出 1-6 隨機整數\n→ Step 5: 回傳 results // 返回所有結果的列表\nEnd // 程式執行結束\n\nNeed to include arrows: For loop maybe use → for each. Might need indentation. Use arrow and decision? Not necessary. Provide each line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 導入 random 模組 // 需要使用 random 產生隨機數  \n→ Step 2: 定義函式 roll_dice(n) // 接收擲骰次數  \n→ Step 3: 初始化空列表 results // 用於儲存每次擲骰結果  \n→ Step 4: 循環 i 於 1 到 n  \n    → Step 4a: 在 results 中追加 random.randint(1, 6) // 擲出 1-6 隨機整數  \n→ Step 5: 回傳 results // 返回所有結果的列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 執行所需的秒數，並回傳四捨五入到小數點 3 位的結果。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取標準輸入中的程式碼，並以包含 measure_time 及 time 的命名空間執行。\n    \"\"\"\n    # 讀取全部輸入 (可能是一段完整的 Python 程式碼)\n    code = sys.stdin.read()\n\n    # 建立一個包含 measure_time 與 time 的執行環境\n    exec_namespace = {\n        'measure_time': measure_time,\n        'time': time\n    }\n\n    # 執行輸入的程式碼，輸出將直接寫入標準輸出\n    exec(code, exec_namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with arrow syntax. The requirement: use time module, write function measure_time(func, *args) to measure execution time in seconds, return rounded to 3 decimals. So steps: Start, import time, define function, record start, call func(*args), record end, compute elapsed, round to 3 decimal places, return elapsed, End.\n\nNeed to follow format: \"虛擬碼步驟 // 解釋\". Include arrows and decision? Not needed as no branching. Just linear steps. Should start with Start // 程式開始執行. Use \"→ Step X: ...\". Provide explanation after each.\n\nMake sure to include imports. Also note the function signature: measure_time(func, *args). Might include comment. Provide pseudo steps. No actual code. So produce lines:\n\nStart\n→ Step 1: Import time module // 引入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: Record start_time ← time.time() // 取得開始時間\n→ Step 4: Call result ← func(*args) // 執行傳入的函式並取得結果\n→ Step 5: Record end_time ← time.time() // 取得結束時間\n→ Step 6: Calculate elapsed ← end_time - start_time // 計算耗時\n→ Step 7: Round elapsed_seconds ← round(elapsed, 3) // 四捨五入到小數點3位\n→ Step 8: Return elapsed_seconds // 回傳測量時間\nEnd\n\nBut we must also return the result? Problem statement says return the result (rounded). It says \"並回傳結果 (四捨五入到小數點 3 位)\". It's ambiguous whether to return the elapsed seconds or the function result. Likely return elapsed time. Provide step: Return elapsed_seconds.\n\nOk.\n\nNow produce virtual code accordingly. Ensure each line ends with comment.\n\nLet's craft output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import time module // 引入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: Record start_time ← time.time() // 取得開始時間\n→ Step 4: Call result ← func(*args) // 執行傳入的函式並取得結果\n→ Step 5: Record end_time ← time.time() // 取得結束時間\n→ Step 6: Calculate elapsed ← end_time - start_time // 計算耗時\n→ Step 7: Round elapsed_seconds ← round(elapsed, 3) // 四捨五入到小數點 3 位\n→ Step 8: Return elapsed_seconds // 回傳測量時間\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"apple\",\"grape\",\"melon\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'apple', 'grape', 'melon'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取輸入（即使此題不需要實際輸入，也保持通用性）\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 新增橘子\n    fruits.add('orange')\n\n    # 同時新增葡萄與哈密瓜\n    fruits.update(['grape', 'melon'])\n\n    # 移除香蕉\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的菠蘿（不會拋錯）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, following format. Each line: virtual code step + space + comment // explanation. Use Start, End, Decision, arrows. For operations: initialize set, add, update, remove, discard, print. Provide step numbers? Not required. Just steps. Use arrow →. For decision maybe not needed. But we can include simple steps. Provide step names. Let's create:\n\nStart // 程式開始執行\n→ Step 1: Set fruits = {'apple', 'banana'} // 建立集合\n→ Step 2: Call fruits.add('orange') // 新增橘子\n→ Step 3: Call fruits.update(['grape', 'melon']) // 同時新增葡萄與哈密瓜\n→ Step 4: Call fruits.remove('banana') // 移除香蕉\n→ Step 5: Call fruits.discard('pineapple') // 嘗試移除不存在的菠蘿\n→ Step 6: Output fruits // 顯示最終集合\nEnd // 程式結束\n\nWe need to match format: Use virtual code step e.g. \"Start\". Use arrow \"→\". Provide comment after //. Ensure each line ends with comment. Provide line numbers? Not needed. Provide \"Decision:\" maybe not necessary. But we can keep simple steps.\n\nLet's format exactly. Ensure each line ends with comment. Use the exact syntax: `→ Step 1: ... // ...`.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set fruits = {'apple', 'banana'} // 建立初始集合 fruits  \n→ Step 2: Call fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: Call fruits.update(['grape', 'melon']) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: Call fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: Call fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'（不會拋錯）  \n→ Step 6: Output fruits // 輸出最終集合 fruits  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.76TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.76 TWD'"
        }
      ],
      "generated_code": "import requests\nimport sys\n\ndef fetch_rate():\n    \"\"\"\n    從 exchangerate-api 取得 USD 對 TWD 的匯率。\n    若發生例外，回傳 None。\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取指令，若為「按下「更新匯率」按鈕」則取得並輸出匯率。\n    \"\"\"\n    # 讀取全部輸入\n    user_input = sys.stdin.read().strip()\n    # 檢查輸入指令\n    if user_input == '按下「更新匯率」按鈕':\n        rate = fetch_rate()\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n    else:\n        # 若輸入不是預期指令，直接不輸出任何結果\n        pass\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line steps, using the arrow syntax, and comments. No actual code. The user wants to connect to exchangerate-api, get USD to TWD, display in tkinter window, update with button. We'll produce virtual steps:\n\nStart\n→ Import modules: requests, tkinter\n→ Create main window\n→ Create label to display rate\n→ Create button \"Refresh\"\n→ Define function refresh_rate: send GET request to API, parse JSON, get rates['TWD'], update label text\n→ Bind button to refresh_rate\n→ Call refresh_rate initially to display first rate\n→ Start mainloop\nEnd\n\nNeed to use Decision? Probably not needed. But we can add error handling decisions.\n\nMake sure each line has virtual code step + comment.\n\nAlso note use of arrows, maybe indentation for decision branches. But simple steps.\n\nLet's write:\n\nStart // 程式開始執行\n→ Import requests, tkinter // 載入需要的模組\n→ Create main window Tk() // 建立 tkinter 主視窗\n→ Create label variable rate_var = StringVar() // 用於顯示匯率的變數\n→ Create label with textvariable rate_var // 建立顯示匯率的標籤\n→ Pack or grid the label // 將標籤加入視窗\n→ Create button \"Refresh\" // 建立更新按鈕\n→ Pack the button // 將按鈕加入視窗\n→ Define function refresh_rate(): // 定義更新匯率的函式\n    → Send GET request to https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料\n    → Decision: 如果請求成功? // 檢查 HTTP 狀態碼\n        Yes → Parse JSON response // 解析回傳的 JSON\n        → Extract rates['TWD'] // 取出台幣匯率\n        → Update rate_var with \"1 USD = X TWD\" // 更新顯示文字\n        No → Update rate_var with \"取得匯率失敗\" // 顯示失敗訊息\n→ Bind button click to refresh_rate // 把按鈕事件連到函式\n→ Call refresh_rate() // 初始取得並顯示匯率\n→ Start mainloop() // 啟動 tkinter 事件循環\nEnd // 程式執行結束\n\nNeed to ensure the format: Each line separate. For nested lines we can indent but still show arrow. Probably easier to maintain single lines. For function, we can use indentation but each line still \"→\".\n\nThe decision lines: \"Decision:\" maybe inside function. But we can show as separate lines. Let's produce.\n\nLet's output as requested.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import requests, tkinter // 載入需要的模組  \n→ Create main window Tk() // 建立 tkinter 主視窗  \n→ Create StringVar rate_var // 用於顯示匯率的變數  \n→ Create label with textvariable=rate_var // 建立顯示匯率的標籤  \n→ Pack the label // 將標籤加入視窗  \n→ Create button \"Refresh\" // 建立更新按鈕  \n→ Pack the button // 將按鈕加入視窗  \n→ Define function refresh_rate(): // 定義更新匯率的函式  \n→ Send GET request to https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料  \n→ Decision: 如果請求成功? // 檢查 HTTP 狀態碼  \n  Yes → Parse JSON response // 解析回傳的 JSON  \n   → Extract rates['TWD'] // 取出台幣匯率  \n   → Update rate_var with \"1 USD = X TWD\" // 更新顯示文字  \n  No  → Update rate_var with \"取得匯率失敗\" // 顯示失敗訊息  \n→ Bind button click to refresh_rate // 把按鈕事件連到函式  \n→ Call refresh_rate() // 初始取得並顯示匯率  \n→ Start mainloop() // 啟動 tkinter 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Open the Lock",
      "source_file": "Leetcode/leetcode752.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphoalu60x.py\", line 28, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "deadends = [\"8888\"], target = \"0009\"",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd4n4vekb.py\", line 28, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    deadends = [\"8888\"], target = \"0009\"\n    ^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpa09orahj.py\", line 28, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def openLock(self, deadends, target):\n        dead = set(deadends)\n        if '0000' in dead:\n            return -1\n        queue = deque([('0000', 0)])\n        visited = {'0000'}\n        while queue:\n            state, steps = queue.popleft()\n            if state == target:\n                return steps\n            for i in range(4):\n                digit = int(state[i])\n                for move in (-1, 1):\n                    new_digit = (digit + move) % 10\n                    new_state = state[:i] + str(new_digit) + state[i+1:]\n                    if new_state not in dead and new_state not in visited:\n                        visited.add(new_state)\n                        queue.append((new_state, steps + 1))\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Execute the input line to define deadends and target\n    exec(data, globals())\n    solution = Solution()\n    result = solution.openLock(deadends, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to solve lock problem (like Leetcode 752). Use BFS, maintain visited, deadends set, queue, etc. Provide step-by-step. We'll output lines with \"Start\", \"→\" arrow etc.\n\nNeed to be careful with formatting. Provide each line: virtual code step + space + comment. Use arrow '→'. For decisions: \"Decision:\" lines. Use indent for nested branches maybe indent spaces. Example earlier used indentation.\n\nWe need to include Start, End. Provide steps:\n\n- Initialize deadend set.\n- Check if start in deadend: return -1.\n- If target is '0000': return 0.\n- Initialize queue with start and depth 0.\n- Mark visited start.\n- While queue not empty:\n  - pop current, depth.\n  - For each of 4 wheels:\n    - Generate next by rotating +1 and -1.\n    - If next == target: return depth+1.\n    - If next not in deadends and not visited: add to queue, mark visited.\n\n- After loop: return -1.\n\nWe should produce pseudo-code lines accordingly. Use arrow and Decision lines.\n\nWe need to format as requested. Each line: \"虛擬碼步驟\" then space then comment. Example earlier used \"Start // 程式開始執行\". We'll produce Chinese comments.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: deadSet ← set(deadends) // 建立死結點集合\n→ Step 2: start ← '0000' // 初始鎖狀態\n→ Decision: 如果 start 在 deadSet? // 檢查起始碼是否為死結點\n    Yes → End ← -1 // 起始即為死結點，無法開鎖\n    No  →\n→ Decision: 如果 target 為 '0000'? // 目標即為起始狀態\n    Yes → End ← 0 // 已開鎖\n    No  →\n→ Step 3: queue ← [(start, 0)] // BFS 隊列，存 (狀態, 步驟數)\n→ Step 4: visited ← {start} // 記錄已訪問的狀態\n→ Decision: queue 是否為空? // 檢查 BFS 是否結束\n    No →\n        → Step 5: current, steps ← queue.pop_front() // 取出首個狀態\n        → Step 6: for i in [0,1,2,3] // 遍歷四個輪\n            → Step 7: nextPlus ← rotate(current, i, +1) // 轉一格向上\n            → Step 8: if nextPlus == target? // 檢查是否達到目標\n                Yes → End ← steps + 1 // 找到最短路徑\n                No  →\n                    → Decision: nextPlus 在 deadSet 或 visited? // 檢查有效性\n                        Yes → // 跳過\n                        No  →\n                            → Step 9: queue.append((nextPlus, steps+1)) // 加入隊列\n                            → Step 10: visited.add(nextPlus) // 標記已訪問\n            → Step 11: nextMinus ← rotate(current, i, -1) // 轉一格向下\n            → Step 12: if nextMinus == target? // 檢查是否達到目標\n                Yes → End ← steps + 1\n                No  →\n                    → Decision: nextMinus 在 deadSet 或 visited?\n                        Yes → \n                        No  →\n                            → Step 13: queue.append((nextMinus, steps+1))\n                            → Step 14: visited.add(nextMinus)\n        → Decision: queue 是否為空? // 迴圈結束條件\n            Yes → End ← -1 // 所有可能已探索完仍未到目標\n            No  →\n→ End // 程式結束\n\nNeed to maintain proper indentation: Use spaces for nested decisions. In sample, they used indent of 4 spaces for nested lines. We'll replicate.\n\nAlso use arrow for steps: \"→ Step ...\". For decision we use \"→ Decision:\" lines.\n\nWe need to ensure we don't include actual code, just pseudo steps. Provide comment.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: deadSet ← set(deadends) // 建立死結點集合  \n→ Step 2: start ← '0000' // 初始鎖狀態  \n→ Decision: 如果 start 在 deadSet? // 檢查起始碼是否為死結點  \n Yes → End ← -1 // 起始即為死結點，無法開鎖  \n No →  \n→ Decision: 如果 target 為 '0000'? // 目標即為起始狀態  \n Yes → End ← 0 // 已開鎖  \n No →  \n→ Step 3: queue ← [(start, 0)] // BFS 隊列，存 (狀態, 步驟數)  \n→ Step 4: visited ← {start} // 記錄已訪問的狀態  \n→ Decision: queue 是否為空? // 檢查 BFS 是否結束  \n No →  \n  → Step 5: current, steps ← queue.pop_front() // 取出首個狀態  \n  → Step 6: for i in [0,1,2,3] // 遍歷四個輪  \n   → Step 7: nextPlus ← rotate(current, i, +1) // 轉一格向上  \n   → Step 8: if nextPlus == target? // 檢查是否達到目標  \n    Yes → End ← steps + 1 // 找到最短路徑  \n    No →  \n     → Decision: nextPlus 在 deadSet 或 visited? // 檢查有效性  \n      Yes → // 跳過  \n      No →  \n       → Step 9: queue.append((nextPlus, steps+1)) // 加入隊列  \n       → Step 10: visited.add(nextPlus) // 標記已訪問  \n    → Step 11: nextMinus ← rotate(current, i, -1) // 轉一格向下  \n    → Step 12: if nextMinus == target? // 檢查是否達到目標  \n     Yes → End ← steps + 1  \n     No →  \n      → Decision: nextMinus 在 deadSet 或 visited?  \n       Yes →  \n       No →  \n        → Step 13: queue.append((nextMinus, steps+1))  \n        → Step 14: visited.add(nextMinus)  \n  → Decision: queue 是否為空? // 迴圈結束條件  \n   Yes → End ← -1 // 所有可能已探索完仍未到目標  \n   No →  \nEnd // 程式結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[None,True,False,True,2,True,False,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[None, True, False, True, 2, True, False, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # 1. 存放元素的列表\n        self.values = []\n        # 2. 元素到索引的映射\n        self.val_to_index = {}\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：兩個列表，中間以 '], ' 分隔\n    close_bracket = data.find(']')\n    ops_str = data[:close_bracket + 1]\n    params_str = data[close_bracket + 2:]\n\n    ops = ast.literal_eval(ops_str)\n    params = ast.literal_eval(params_str)\n\n    res = []\n    obj = None\n\n    for op, param in zip(ops, params):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(obj.insert(param[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(param[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n        else:\n            # 若有其他操作，可在此處處理\n            res.append(None)\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for RandomizedSet. Use Start, Decision, etc. Provide step-by-step logic. Need to include insert, remove, getRandom, with average O(1). Data structures: array/list to store values; hashmap from val to index in array. For insert: check map, if exists return false; else push to array, set map[val]=size-1, return true. Remove: check map; if not exists return false; else get index; swap with last element; update map of last element to index; pop last; delete map entry; return true. getRandom: generate random index from 0 to size-1, return array[index].\n\nWe need to output virtual code line by line, with explanations. Let's produce code structure: Start; Step: Initialize data structures. For methods: Insert, Remove, GetRandom. Use decision arrows. Each line has comment. Ensure no actual code. Use virtual steps. Use \"←\" arrow or \"→\". We'll use \"→\" to indicate next step.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 0: 建立空陣列 elements 和空哈希表 idxMap // 用於儲存元素和其索引\n\nThen methods:\n\nInsert:\n→ Decision: val 已存在於 idxMap? // 檢查是否已存在\n    Yes → Step 1: return false // 已存在，插入失敗\n    No  → Step 2: 把 val 加入 elements // 將值加入陣列\n    → Step 3: idxMap[val] = elements.size - 1 // 記錄索引\n    → Step 4: return true // 插入成功\n\nRemove:\n→ Decision: val 存在於 idxMap? // 檢查是否存在\n    Yes → Step 1: index = idxMap[val] // 取得索引\n    → Step 2: lastVal = elements.last // 取得最後一個值\n    → Step 3: elements[index] = lastVal // 交換位置\n    → Step 4: idxMap[lastVal] = index // 更新最後一個值索引\n    → Step 5: elements.pop() // 移除最後一個元素\n    → Step 6: delete idxMap[val] // 刪除映射\n    → Step 7: return true // 刪除成功\n    No  → Step 8: return false // 元素不存在，刪除失敗\n\nGetRandom:\n→ Step 0: randIdx = random(0, elements.size-1) // 隨機產生索引\n→ Step 1: return elements[randIdx] // 返回隨機元素\n\nEnd // 程式結束\n\nBut we need to produce virtual code lines with explanation after each. Provide one line per step. Use arrows for transitions. For decision, include Yes and No branches.\n\nLet's structure: Use indentation? They didn't require indentation, but can show with spaces.\n\nWe'll output as per example: each line \"虛擬碼步驟 // 解釋\". So we produce lines like:\n\nStart // 程式開始執行\n→ Step 0: 建立空陣列 elements 和空哈希表 idxMap // 用於儲存元素和其索引\n\nThen decision etc.\n\nLet's craft.\n\nAlso ensure each line has \"→\" before step? In example they had \"→ Step 1:\" lines. Use same.\n\nFor decision: \"→ Decision: ...\" and then sub-lines with indentation. But we can still produce each line as separate lines: decision line, then branch lines with indent? We can represent indentation with spaces before \"Yes →\" etc. Example from specification: they show indented lines:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // ...\n    No  → Decision: ...\n\nThus we can produce similar.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 建立空陣列 elements 和空哈希表 idxMap // 用於儲存元素及其索引  \n\n// ---------- insert ----------\n→ Decision: val 已存在於 idxMap? // 檢查元素是否已在集合  \n    Yes → Step 1: return false // 已存在，插入失敗  \n    No  → Step 2: elements.append(val) // 將新值加入陣列  \n        → Step 3: idxMap[val] = elements.size - 1 // 記錄新值的索引  \n        → Step 4: return true // 插入成功  \n\n// ---------- remove ----------\n→ Decision: val 存在於 idxMap? // 檢查元素是否在集合  \n    Yes → Step 1: index = idxMap[val] // 取得要移除值的索引  \n        → Step 2: lastVal = elements.last // 取得陣列最後一個值  \n        → Step 3: elements[index] = lastVal // 用最後一個值覆蓋要移除的位置  \n        → Step 4: idxMap[lastVal] = index // 更新最後一個值的新索引  \n        → Step 5: elements.pop() // 移除陣列最後一個元素  \n        → Step 6: idxMap.delete(val) // 刪除該值的映射  \n        → Step 7: return true // 移除成功  \n    No  → Step 8: return false // 元素不存在，移除失敗  \n\n// ---------- getRandom ----------\n→ Step 0: randIdx = random(0, elements.size - 1) // 隨機產生有效索引  \n→ Step 1: return elements[randIdx] // 返回隨機選中的元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [1, 0], [2, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n            # 仍為 0 的格數\n        self.mapping = {}             # 只對已被映射的索引存儲對應值\n\n    def flip(self):\n        # 在剩餘區間 [0, total-1] 隨機選取一個索引\n        r = random.randint(0, self.total - 1)\n\n        # 若 r 已映射，取其對應值；否則直接使用 r\n        val = self.mapping.get(r, r)\n\n        # 把最終未被翻轉的索引放到 r 位置\n        last = self.total - 1\n        last_val = self.mapping.get(last, last)\n        self.mapping[r] = last_val\n\n        # 若 last 位置曾被映射，需要把它從映射表中移除\n        if last in self.mapping:\n            del self.mapping[last]\n\n        self.total -= 1              # 失去一個 0 的格\n        return [val // self.n, val % self.n]  # 轉換回 (i, j)\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.mapping.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入拆分為兩個列表：方法名和對應參數\n    split_pos = data.find('],')\n    calls_part = data[:split_pos + 1]\n    args_part = data[split_pos + 2:].strip()\n\n    calls = json.loads(calls_part)\n    args_list = json.loads(args_part)\n\n    result = []\n    obj = None\n\n    for call, args in zip(calls, args_list):\n        if call == \"Solution\":\n            obj = Solution(args[0], args[1])\n            result.append(None)\n        elif call == \"flip\":\n            result.append(obj.flip())\n        elif call == \"reset\":\n            obj.reset()\n            result.append(None)\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode lines. Use Start, End, Decision. Provide line by line pseudocode with explanation after //.\n\nGoal: design algorithm for random flip without bias, minimizing random calls.\n\nStandard solution: use reservoir mapping from index to remaining indices. Map 0..m*n-1 to themselves initially. On flip: pick random r from [0, remaining-1]; swap mapping[r] with mapping[remaining-1] (or mapping[remaining-1] is 0). Return index mapping[r] as (i,j). Decrease remaining. Reset: clear map and set remaining=m*n.\n\nAlso use hashmap for mapping.\n\nWe must output virtual code line by line.\n\nWe'll produce a pseudocode structure: Start -> initialize variables: total, remaining, map. flip() pseudocode with random calls minimal. Use decision if map contains r etc. Provide explanation.\n\nWe'll produce code lines like:\n\nStart\n→ Step 1: Initialize total ← m × n // Total cells\n→ Step 2: Initialize remaining ← total // Cells still 0\n→ Step 3: Initialize map ← empty hashmap // Mapping from random index to actual index\n\nBut we need to structure into a class with constructor, flip, reset. Use blocks.\n\nWe need to use arrow lines with indentation? The example uses indentation for nested decisions. We'll follow.\n\nLet's design:\n\nStart // 程式開始執行\n→ Class Solution // 定義解決方案類別\n    → Constructor(m, n) // 初始化\n        → total ← m × n // 總格數\n        → remaining ← total // 仍為 0 的格數\n        → mapping ← empty hashmap // 將 0~total-1 映射\n    → Method flip() // 隨機翻轉\n        → idx ← random(0, remaining-1) // 取剩餘區間的隨機索引\n        → If idx in mapping? // 判斷是否已映射\n            Yes → val ← mapping[idx] // 若已映射，取得映射值\n            No  → val ← idx // 若未映射，使用自身\n        → last ← remaining-1 // 最後一個未翻轉的索引\n        → If last in mapping? // 取 last 的映射\n            Yes → lastVal ← mapping[last]\n            No  → lastVal ← last\n        → mapping[idx] ← lastVal // 把 idx 指向 last 的值\n        → Remove mapping[last] if exists // 清除 last 的映射\n        → remaining ← remaining - 1 // 減少剩餘\n        → Return [val / n, val % n] // 將一維索引轉為二維\n    → Method reset() // 重置\n        → remaining ← total // 重新設為全部\n        → mapping ← empty hashmap // 清空映射\nEnd // 程式結束\n\nAdd explanations after // for each line.\n\nWe need to follow format: each line: 虛擬碼步驟 [space] // 解釋.\n\nMake sure to use arrows properly. Indentation maybe not necessary but we can use indentation with spaces for readability.\n\nWe'll include Decision: lines for if conditions.\n\nLet's format:\n\nStart // 程式開始執行\n→ Class Solution // 定義解決方案類別\n    → Constructor(m, n) // 初始化\n        → total ← m × n // 總格數\n        → remaining ← total // 仍為 0 的格數\n        → mapping ← empty hashmap // 用於映射未翻轉的索引\n    → Method flip() // 隨機翻轉\n        → idx ← random(0, remaining-1) // 在剩餘格數中隨機選取\n        → Decision: idx 在 mapping 中? // 判斷 idx 是否已映射\n            Yes → val ← mapping[idx] // 若已映射，取得映射值\n            No  → val ← idx // 若未映射，使用自身\n        → last ← remaining-1 // 最後一個可用索引\n        → Decision: last 在 mapping 中? // 判斷 last 是否已映射\n            Yes → lastVal ← mapping[last] // 若已映射，取得映射值\n            No  → lastVal ← last // 若未映射，使用自身\n        → mapping[idx] ← lastVal // 把 idx 映射到 last 的值\n        → Decision: last 在 mapping 中? // 如 last 已映射，需要刪除\n            Yes → Remove mapping[last] // 刪除映射\n            No  → // 不需要刪除\n        → remaining ← remaining - 1 // 減少剩餘格數\n        → Return [val / n, val % n] // 轉換為行列索引\n    → Method reset() // 重置\n        → remaining ← total // 重新設為全部\n        → mapping ← empty hashmap // 清空映射\nEnd // 程式執行結束\n\nCheck format: We must put a space after each line before //. Also we must use arrow '→' after Start. For decisions we used \"Decision:\" lines and indentation.\n\nLet's ensure each line has exactly: virtual code step + space + // explanation.\n\nWe'll keep indentation for clarity but it's part of the virtual code step; the indentation should be part of the step text. The arrow '→' at beginning of line.\n\nMake sure to include arrow for inner lines? The example shows arrow only at start of each step, even within nested decisions. So we should prefix each line with '→' even for nested lines? The example: they used indent but same arrow. We'll replicate.\n\nThus lines like \"→ Decision: ...\". Then nested lines also have '→' and indentation? In example, they have:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: ...\n\nThey indent 'Yes →' etc but also arrow. So we should mimic that.\n\nThus for nested decision branches, we should indent and prefix with Yes → etc.\n\nLet's craft accordingly.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Class Solution // 定義解決方案類別\n    → Constructor(m, n) // 初始化\n        → total ← m × n // 總格數\n        → remaining ← total // 仍為 0 的格數\n        → mapping ← empty hashmap // 用於映射未翻轉的索引\n    → Method flip() // 隨機翻轉\n        → idx ← random(0, remaining-1) // 在剩餘格數中隨機選取\n        → Decision: idx 在 mapping 中? // 判斷 idx 是否已映射\n            Yes → val ← mapping[idx] // 若已映射，取得映射值\n            No  → val ← idx // 若未映射，使用自身\n        → last ← remaining-1 // 最後一個可用索引\n        → Decision: last 在 mapping 中? // 判斷 last 是否已映射\n            Yes → lastVal ← mapping[last] // 若已映射，取得映射值\n            No  → lastVal ← last // 若未映射，使用自身\n        → mapping[idx] ← lastVal // 把 idx 映射到 last 的值\n        → Decision: last 在 mapping 中? // 如 last 已映射，需要刪除\n            Yes → Remove mapping[last] // 刪除映射\n            No  → // 不需要刪除\n        → remaining ← remaining - 1 // 減少剩餘格數\n        → Return [val / n, val % n] // 轉換為行列索引\n    → Method reset() // 重置\n        → remaining ← total // 重新設為全部\n        → mapping ← empty hashmap // 清空映射\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdhppgn4m.py\", line 67, in <module>\n    main()\n  File \"/tmp/tmpdhppgn4m.py\", line 54, in main\n    magic_dict.buildDict(args)\n  File \"/tmp/tmpdhppgn4m.py\", line 13, in buildDict\n    self.words_by_len.setdefault(len(word), set()).add(word)\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        # 以單字長度作為索引，避免不必要的長度比對\n        self.words_by_len = {}\n\n    def buildDict(self, dictionary):\n        # 重新組織資料，確保每個長度只有一次初始化\n        self.words_by_len = {}\n        for word in dictionary:\n            self.words_by_len.setdefault(len(word), set()).add(word)\n\n    def search(self, searchWord):\n        l = len(searchWord)\n        # 若此長度不存在，直接返回 False\n        if l not in self.words_by_len:\n            return False\n        candidates = self.words_by_len[l]\n        for word in candidates:\n            diff = 0\n            # 逐字比對，早停優化\n            for a, b in zip(word, searchWord):\n                if a != b:\n                    diff += 1\n                    if diff > 1:\n                        break\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    # 讀取整個輸入並拆分成兩個列表\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 兩個列表之間以 '],' 分隔，保持原始格式\n    parts = raw.split('],', 1)\n    commands_str = parts[0].strip() + ']'\n    args_str = parts[1].strip()\n\n    commands = json.loads(commands_str)\n    args_list = json.loads(args_str)\n\n    results = []\n    magic_dict = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MagicDictionary\":\n            magic_dict = MagicDictionary()\n            results.append(None)  # constructor returns null\n        elif cmd == \"buildDict\":\n            magic_dict.buildDict(args)\n            results.append(None)  # method returns null\n        elif cmd == \"search\":\n            res = magic_dict.search(args)\n            results.append(res)\n        else:\n            # 不應該出現的命令，安全處理\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 可自動轉為 null、true、false\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrow arrows and decision, no actual code, just steps.\n\nWe need to design data structure that can support search with one edit difference. Approach: build dictionary of words, and for each word, generate all possible patterns with a wildcard for each position, mapping to count or list. Search: for each position, replace with wildcard and check if any dictionary word matches that pattern and not same word.\n\nSimpler: Build map from pattern to list of words. For search, iterate positions, replace char with '*' and look up pattern, check if any word in list is not same.\n\nImplement MagicDictionary class with methods.\n\nWe need virtual steps: Start, Step for constructor, Step for buildDict, Step for search. Inside search we iterate positions. We'll show decision whether pattern matches.\n\nWe must output virtual code only, no actual code. Provide explanation per line. Use arrow and indentation.\n\nLet's produce something like:\n\nStart\n→ Step 1: 初始化魔法字典 // 建立空的字典映射\n→ Step 2: 讀取單字陣列 // 接收不同的單字\n→ Decision: 如果字典為空? // 若無字可處理\n    Yes → End // 直接結束\n    No → For each word in dictionary // 逐字處理\n        → Step 3: 為單字生成所有「一位置為通配符」的模式 // 取代每個字元為 '*'\n        → Step 4: 將模式與單字關聯存入映射 // map[pattern] = list of words\nEnd\n\nSimilarly search.\n\nLet's produce more detailed.\n\nNeed to show arrow arrows and decisions. Use Start, End.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空的模式映射 Map<string, List<string>> patternMap // 用於存放所有「一個位置為通配符」的模式\n→ Step 2: 建立空的字典集合 Set<string> wordSet // 用於快速判斷完整字是否存在\n→ Step 3: 建構子 MagicDictionary() // 初始化時只建立兩個空資料結構\n    // 這一步完成後即完成建構子\n\n→ Step 4: 進入 buildDict(String[] dictionary) 方法 // 接收一組不同的單字\n    → Decision: dictionary 為空? // 若沒有單字可處理\n        Yes → End // 建構完成，結束建構過程\n        No  → For each word in dictionary // 逐字處理每個單字\n            → Step 5: 把 word 加入 wordSet // 以便後續直接判斷完整相符\n            → Step 6: 取字長 L = word.length\n            → For i from 0 to L-1 // 為每個位置產生模式\n                → Step 7: 建立 pattern = word[0..i-1] + '*' + word[i+1..L-1] // 以 '*' 取代第 i 個字元\n                → Step 8: patternMap[pattern] ← patternMap[pattern] ∪ {word} // 將單字加入對應模式的清單\n    → End // buildDict 完成\n\n→ Step 9: 進入 search(String searchWord) 方法 // 接收欲搜尋的字串\n    → Decision: searchWord 為空? // 若字串長度為 0\n        Yes → Return false // 無法改變一個字元得到任何單字\n        No  → For each index i in searchWord\n            → Step 10: 取字長 L = searchWord.length\n            → Step 11: 建立 pattern = searchWord[0..i-1] + '*' + searchWord[i+1..L-1] // 以 '*' 取代第 i 個字元\n            → Step 12: 取得 patternList = patternMap[pattern] // 所有在這個模式下的字\n            → Decision: patternList 是否為空? // 若無匹配模式\n                Yes → Continue // 試下個位置\n                No  → For each candidateWord in patternList\n                    → Decision: candidateWord ≠ searchWord? // 確保改變字元後字串不等於原本字串\n                        Yes → Return true // 找到符合條件的字，搜尋成功\n                        No  → Continue // 跳過與原字相同的字\n    → Return false // 所有位置都未找到符合條件的字，搜尋失敗\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        # 計算需要刪除的左括號和右括號數量\n        left, right = 0, 0\n        for ch in s:\n            if ch == '(':\n                left += 1\n            elif ch == ')':\n                if left == 0:\n                    right += 1\n                else:\n                    left -= 1\n\n        res = set()\n\n        def dfs(index: int, left_rem: int, right_rem: int, path: str, balance: int):\n            \"\"\"\n            index      : 當前處理的字元位置\n            left_rem   : 仍須刪除的左括號數\n            right_rem  : 仍須刪除的右括號數\n            path       : 已經構造好的字串\n            balance    : 當前 '(' 的個數減去 ')' 的個數\n            \"\"\"\n            if index == len(s):\n                if left_rem == 0 and right_rem == 0 and balance == 0:\n                    res.add(path)\n                return\n\n            ch = s[index]\n\n            # 1. 嘗試刪除當前括號（如果是括號且有剩餘可刪除）\n            if ch == '(' and left_rem > 0:\n                dfs(index + 1, left_rem - 1, right_rem, path, balance)\n            if ch == ')' and right_rem > 0:\n                dfs(index + 1, left_rem, right_rem - 1, path, balance)\n\n            # 2. 保留當前字元\n            if ch == '(':\n                dfs(index + 1, left_rem, right_rem, path + ch, balance + 1)\n            elif ch == ')':\n                if balance > 0:\n                    dfs(index + 1, left_rem, right_rem, path + ch, balance - 1)\n            else:  # 字母\n                dfs(index + 1, left_rem, right_rem, path + ch, balance)\n\n        dfs(0, left, right, \"\", 0)\n        return list(res)\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從輸入字串中抽取要處理的字串 s。\n    支援兩種形式：\n    1. s = \"...\"\n    2. 直接給字串\n    \"\"\"\n    raw = raw.strip()\n    if raw.lower().startswith(\"s\"):\n        # 可能是 \"s = \\\"...\\\"\" 或 \"s = '...'\"\n        _, _, value = raw.partition(\"=\")\n        value = value.strip()\n        if (value.startswith('\"') and value.endswith('\"')) or (value.startswith(\"'\") and value.endswith(\"'\")):\n            value = value[1:-1]\n        return value\n    return raw\n\n\ndef main():\n    data = sys.stdin.read()\n    s = parse_input(data)\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    # 輸出為 JSON 格式，保持原始字串的順序不重要\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for algorithm to remove invalid parentheses to produce all unique valid strings with minimal removals. Standard solution: BFS or DFS with pruning, or count removals needed left and right. Use DFS with backtracking, skip duplicates. Provide algorithm steps: compute left/right removals needed. Then recursive function to generate. Need to output as virtual code lines with explanations. Format: lines like \"Start // ...\", \"→ Step 1: ...\". Should use decision arrows.\n\nWe'll produce steps: start, compute removals, define DFS, iterate over characters, if '(' increase left count else if ')' and right count >0 skip etc. Provide steps to build string, use set for results. End.\n\nWe need to keep virtual code lines for each logical step. Since not actual code, but pseudo steps. Provide as lines. Use decision arrows.\n\nLet's craft:\n\nStart // Program starts\n\n→ Step 1: Input string s // receive the string\n\n→ Step 2: Initialize left=0, right=0 // counts for removals\n\n→ Decision: For each char c in s? // iterate\n\n    → If c=='(' // increment left\n\n    → Else if c==')' // if left==0 then right++ else left--\n\nAfter loop, left/right hold minimal removals needed.\n\n→ Step 3: Define ResultSet = empty set // store unique results\n\n→ Step 4: Call DFS(startIndex=0, leftRem=left, rightRem=right, curString=\"\") // recursive build\n\n→ Inside DFS:\n\n    Decision: If startIndex==len(s) // reached end\n\n        → If leftRem==0 and rightRem==0 // valid string\n\n            → Add curString to ResultSet\n\n        → Return\n\n    → Let c = s[startIndex]\n\n    Decision: If c is '(' or ')' // potential removal\n\n        → If c=='(' and leftRem>0\n\n            → DFS(startIndex+1, leftRem-1, rightRem, curString) // skip '('\n\n        → If c==')' and rightRem>0\n\n            → DFS(startIndex+1, leftRem, rightRem-1, curString) // skip ')'\n\n    → Decision: If c=='(' // need to keep\n\n        → DFS(startIndex+1, leftRem, rightRem, curString+'(')\n\n    → Decision: If c==')' // need to keep only if leftRem==0\n\n        → If leftRem==0\n\n            → DFS(startIndex+1, leftRem, rightRem, curString+')')\n\n    → Else // c is letter\n\n        → DFS(startIndex+1, leftRem, rightRem, curString+c)\n\nEnd // finish\n\nReturn list(ResultSet)\n\nWe need to format each line with arrow or decision.\n\nBetter to format: \"→ Decision: ...\"\n\nLet's write each step.\n\nWe'll produce maybe 30-40 lines.\n\nRemember: every line must be \"虛擬碼步驟 [space] // 解釋\". Use arrows: \"→\", \"Decision:\".\n\nLet's produce.\n\nWe need to start with Start line.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得待處理的原始字串  \n→ Step 2: 初始化 left = 0, right = 0 // 用於計算需要刪除的左右括號數量  \n\n→ Decision: 對每個字元 c 在 s 進行迴圈  \n  → If c == '(' // 遇到左括號  \n    → left++ // 需要更多右括號來配對  \n    → Decision: 如果左括號已經足夠?  \n      No → 執行下個字元  \n      Yes → 右括號數量減一，左括號數量減一  \n        // 這裡表示已配對，減少需要刪除的右括號  \n        左括號減一，右括號減一  \n        // 但在計算階段通常不需要這一步，直接計算 left/right  \n        // 這行僅為說明  \n    → Decision: 如果右括號多於左括號?  \n      No → 執行下個字元  \n      Yes → right++ // 右括號沒有左括號配對，記錄需要刪除  \n    → 執行下個字元  \n  → If c == ')' // 遇到右括號  \n    → Decision: 如果 left == 0?  \n      Yes → right++ // 無左括號可配對，右括號需要刪除  \n      No → left-- // 有左括號可配對，減少左括號需求  \n  → 執行下個字元  \n  → Else // 字母  \n    → 執行下個字元  \nEnd // 完成左右括號需求計算  \n\n→ Step 3: 建立空集合 ResultSet = {} // 用於儲存唯一合法字串  \n\n→ Step 4: 呼叫 DFS(0, left, right, \"\") // 從索引 0 開始遞迴搜尋  \n  → DFS(index, leftRem, rightRem, current)  \n   → Decision: 如果 index == len(s) // 已處理完所有字元  \n      → Decision: 如果 leftRem == 0 AND rightRem == 0?  \n        Yes → ResultSet.add(current) // 目前字串合法且已刪除最少括號  \n        No → 返回 // 不合法，忽略  \n      → 返回  \n   → Decision: 取 s[index] 為 c  \n   → Decision: 是否為可刪除字元?（'(' 或 ')'）  \n      → Decision: c == '(' 且 leftRem > 0?  \n        Yes → DFS(index+1, leftRem-1, rightRem, current) // 刪除 '('  \n        No → 無操作  \n      → Decision: c == ')' 且 rightRem > 0?  \n        Yes → DFS(index+1, leftRem, rightRem-1, current) // 刪除 ')'  \n        No → 無操作  \n   → Decision: 是否保留 c?  \n      → Decision: c == '('?  \n        Yes → DFS(index+1, leftRem, rightRem, current + '(') // 保留 '('  \n        No → 無操作  \n      → Decision: c == ')' 且 leftRem == 0?  \n        Yes → DFS(index+1, leftRem, rightRem, current + ')') // 只在有足夠左括號時保留 ')'  \n        No → 無操作  \n      → Decision: c 是字母?  \n        Yes → DFS(index+1, leftRem, rightRem, current + c) // 直接保留字母  \n        No → 無操作  \n\n→ Step 5: 回傳 ResultSet 轉成列表 // 輸出所有唯一合法字串  \n\nEnd // 程式執行結束"
    },
    {
      "title": "License Key Formatting",
      "source_file": "Leetcode/leetcode482.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6_nz401p.py\", line 50, in parse_input\n    k_int = int(k_val)\n            ^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp6_nz401p.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmp6_nz401p.py\", line 57, in main\n    s, k = parse_input(data)\n           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6_nz401p.py\", line 52, in parse_input\n    k_int = int(k_val.split()[-1])\n                ~~~~~~~~~~~~~^^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk_h0xxgh.py\", line 50, in parse_input\n    k_int = int(k_val)\n            ^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ''\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpk_h0xxgh.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpk_h0xxgh.py\", line 57, in main\n    s, k = parse_input(data)\n           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk_h0xxgh.py\", line 52, in parse_input\n    k_int = int(k_val.split()[-1])\n                ~~~~~~~~~~~~~^^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        \"\"\"\n        1. 去除字串中的 '-'，並轉成大寫。\n        2. 先算出第一組的長度：若總長除以 K 之餘數為 0，則第一組長度為 K，否則為餘數。\n        3. 依照第一組長度切分字串，剩下的每組長度都為 K。\n        4. 以 '-' 連接各組字串。\n        \"\"\"\n        cleaned = S.replace('-', '').upper()\n        n = len(cleaned)\n        if n == 0:\n            return ''\n\n        first_len = n % K or K\n        groups = [cleaned[:first_len]]\n        for i in range(first_len, n, K):\n            groups.append(cleaned[i:i+K])\n        return '-'.join(groups)\n\ndef parse_input(lines):\n    \"\"\"\n    解析輸入資料。支援兩種常見格式：\n    1. 兩行，第一行為字串，第二行為整數。\n    2. 兩行，格式如 \"s = \\\"...\\\", k = ...\".\n    \"\"\"\n    # 取第一行非空\n    s_line = ''\n    k_line = ''\n    for line in lines:\n        if line.strip():\n            if not s_line:\n                s_line = line.strip()\n            elif not k_line:\n                k_line = line.strip()\n    # 去除可能的變數名和引號\n    if s_line.lower().startswith('s'):\n        # 取冒號或等號後面部分\n        s_val = s_line.split('=')[-1].strip()\n        s_val = s_val.strip('\"').strip(\"'\")\n    else:\n        s_val = s_line.strip('\"').strip(\"'\")\n    if k_line.lower().startswith('k'):\n        k_val = k_line.split('=')[-1].strip()\n        k_val = k_val.strip('\"').strip(\"'\")\n    else:\n        k_val = k_line\n    try:\n        k_int = int(k_val)\n    except ValueError:\n        k_int = int(k_val.split()[-1])\n    return s_val, k_int\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    s, k = parse_input(data)\n    sol = Solution()\n    result = sol.licenseKeyFormatting(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for reformat license key. Steps: remove dashes, uppercase, compute groups, handle first group length mod k. Build result. End. Provide each line with arrow etc.\n\nWe need to output lines: Start, then steps. Use \"→\" arrow each step. Use Decision for conditions. Provide explanation comments. Not actual code.\n\nLet's design:\n\nStart\n→ Step 1: Remove all dashes from s // Clean string\n→ Step 2: Convert cleaned string to uppercase // Uppercase letters\n→ Decision: If length of cleaned string ≤ k? // If short\n    Yes → Step 3: Return cleaned string // Only one group\n    No → Step 4: Calculate remainder = length % k // Determine first group length\n→ Decision: If remainder == 0? // If exact division\n    Yes → Step 5: Split cleaned string into groups of k starting from index 0 // Normal groups\n    No → Step 6: FirstGroupLength = remainder // Determine first group size\n        → Step 7: Build result string with first group of length FirstGroupLength\n        → Step 8: For remaining characters, append dash and next group of k characters // Remaining groups\n→ Step 9: Return result string // Output reformatted key\nEnd\n\nBut we need each line with \"→\" for steps, \"Decision:\" for decisions. Also indentation. Use \"Yes →\" \"No →\".\n\nAlso need to compute groups, maybe using loop.\n\nWe should be careful: Step 5: Use loop to slice every k characters and join with dash. Step 7 and 8 details.\n\nLet's craft the output with lines. Include indentation. Provide explanation comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: CleanedString ← Remove all dashes from s // 先把字串裡所有 '-' 去掉\n→ Step 2: UpperString ← Convert CleanedString to uppercase // 把所有小寫字母轉成大寫\n→ Decision: 如果 UpperString 長度 ≤ k? // 檢查字串是否已經可以成為單一群組\n    Yes → Step 3: Return UpperString // 只需要回傳這一組\n    No  → Step 4: Length ← Length of UpperString // 計算字串總長\n→ Decision: 如果 Length mod k == 0? // 是否可以均分為 k 位長的群組\n    Yes → Step 5: Groups ← Split UpperString into substrings of size k starting at index 0 // 正常切分\n        → Step 6: Result ← Join Groups with '-' as separator // 用 '-' 連接所有群組\n        → Step 7: Return Result // 回傳重新格式化的字串\n    No  → Step 8: FirstGroupSize ← Length mod k // 第一群組長度\n        → Step 9: Result ← Substring of UpperString from 0 to FirstGroupSize // 取第一群組\n        → Step 10: Index ← FirstGroupSize // 設定起始位置為第一群組結束處\n        → Decision: 是否還有剩餘字元? // 檢查是否還有未處理的字元\n            Yes → Step 11: While Index < Length\n                → Step 12: Result ← Result + '-' + Substring of UpperString from Index to Index+k // 加上下一群組\n                → Step 13: Index ← Index + k // 移動到下一群組起點\n            No  → // 無剩餘字元\n        → Step 14: Return Result // 回傳重新格式化的字串\nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar III",
      "source_file": "Leetcode/leetcode732.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcqdw5t48.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpcqdw5t48.py\", line 33, in main\n    commands = json.loads(data[0])\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 68 (char 67)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCalendarThree:\n    \"\"\"\n    使用差分映射（差分陣列）來維護每個時間點的活動變化，\n    於 book 時重新計算目前最大的重疊數量。\n    \"\"\"\n    def __init__(self):\n        # key: 時間點，value: 這個時間點的活動數量變化\n        self.timeline = {}\n\n    def book(self, start: int, end: int) -> int:\n        # 事件開始時活動數量 +1\n        self.timeline[start] = self.timeline.get(start, 0) + 1\n        # 事件結束時活動數量 -1\n        self.timeline[end] = self.timeline.get(end, 0) - 1\n\n        # 計算目前最大重疊數\n        curr = 0\n        max_overlap = 0\n        for time in sorted(self.timeline):\n            curr += self.timeline[time]\n            if curr > max_overlap:\n                max_overlap = curr\n        return max_overlap\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 解析指令和參數\n    commands = json.loads(data[0])\n    arguments = json.loads(data[1]) if len(data) > 1 else []\n\n    results = []\n    calendar = None\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"MyCalendarThree\":\n            calendar = MyCalendarThree()\n            results.append(None)  # LeetCode 需要返回 null\n        elif cmd == \"book\":\n            res = calendar.book(*args)\n            results.append(res)\n        else:\n            # 若有其他指令，直接忽略或可根據需求處理\n            results.append(None)\n\n    # 將 None 轉成 null 以符合 LeetCode 輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for MyCalendarThree class with book method that returns max overlap. Likely use difference array or segment tree or sweep line. Let's produce simple sweep line using sorted map of time points increments. Steps: maintain map<time, delta>. On book: add +1 at start, -1 at end. Then iterate through sorted times accumulating current, update max. Return max. Complexity O(n log n). Provide virtual code line by line.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCalendarThree 類別 // 建立日曆物件\n→ Step 2: 在類別中新增資料成員：Map<時間, 數量> timePoints // 用於記錄時間點增減\n→ Step 3: MyCalendarThree() 初始化 timePoints 為空 map // 建構子\n→ Decision: book(start, end) 被呼叫? // 判斷是否有新增事件\n    Yes → Step 4: 在 timePoints 中 timePoints[start] += 1 // 事件開始時數量+1\n    Yes → Step 5: 在 timePoints 中 timePoints[end] -= 1 // 事件結束時數量-1\n    Yes → Step 6: 初始化 maxOverlap = 0 // 儲存目前最大重疊數\n    Yes → Step 7: 初始化 current = 0 // 當前重疊數\n    Yes → Step 8: 遍歷 timePoints 按時間升序\n        → Step 8.1: current += delta // 根據時間點增減更新當前重疊\n        → Step 8.2: 若 current > maxOverlap 則 maxOverlap = current // 更新最大值\n    Yes → Step 9: 回傳 maxOverlap // 結果為最大的 k-booking\nEnd // 程式執行結束"
    },
    {
      "title": "Parse Lisp Expression",
      "source_file": "Leetcode/leetcode736.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpw8tiohtl.py\", line 87, in <module>\n    print(sol.evaluate(expr))\n          ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpw8tiohtl.py\", line 73, in evaluate\n    result, _ = eval_tokens(tokens, 0, {})\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpw8tiohtl.py\", line 61, in eval_tokens\n    val, idx = eval_tokens(tokens, idx, new_env)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpw8tiohtl.py\", line 33, in eval_tokens\n    return env[token], idx + 1\n           ~~~^^^^^^^\nKeyError: 'mult'"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4ou9bt4r.py\", line 87, in <module>\n    print(sol.evaluate(expr))\n          ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4ou9bt4r.py\", line 73, in evaluate\n    result, _ = eval_tokens(tokens, 0, {})\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4ou9bt4r.py\", line 61, in eval_tokens\n    val, idx = eval_tokens(tokens, idx, new_env)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4ou9bt4r.py\", line 33, in eval_tokens\n    return env[token], idx + 1\n           ~~~^^^^^^^\nKeyError: 'add'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        \"\"\"\n        Evaluate a Lisp-like expression and return its integer value.\n        \"\"\"\n        # 1. Tokenize the expression\n        def tokenize(s: str):\n            tokens = []\n            i = 0\n            while i < len(s):\n                if s[i] in '()':\n                    tokens.append(s[i])\n                    i += 1\n                elif s[i] == ' ':\n                    i += 1\n                else:\n                    j = i\n                    while j < len(s) and s[j] not in ' ()':\n                        j += 1\n                    tokens.append(s[i:j])\n                    i = j\n            return tokens\n\n        # 2. Recursive evaluation using an index pointer\n        def eval_tokens(tokens, idx, env):\n            # If current token is a number or variable\n            if tokens[idx] != '(':\n                token = tokens[idx]\n                if token[0].isalpha():          # variable\n                    return env[token], idx + 1\n                else:                            # integer literal\n                    return int(token), idx + 1\n\n            # Skip '('\n            idx += 1\n            op = tokens[idx]\n            idx += 1\n\n            # Handle add / mult\n            if op == 'add' or op == 'mult':\n                left, idx = eval_tokens(tokens, idx, env)\n                right, idx = eval_tokens(tokens, idx, env)\n                assert tokens[idx] == ')'\n                idx += 1\n                return (left + right if op == 'add' else left * right), idx\n\n            # Handle let\n            if op == 'let':\n                # Create a new scope copying the current environment\n                new_env = env.copy()\n                # Process variable/value pairs until the final expression\n                while idx <= len(tokens) - 2:   # at least two tokens left before ')'\n                    # If the current token is the final expression\n                    if idx == len(tokens) - 2:\n                        break\n                    var = tokens[idx]\n                    idx += 1\n                    val, idx = eval_tokens(tokens, idx, new_env)\n                    new_env[var] = val\n                # Evaluate the final expression\n                val, idx = eval_tokens(tokens, idx, new_env)\n                assert tokens[idx] == ')'\n                idx += 1\n                return val, idx\n\n            # Should never reach here for valid input\n            raise ValueError(f\"Unknown operator: {op}\")\n\n        tokens = tokenize(expression)\n        result, _ = eval_tokens(tokens, 0, {})\n        return result\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    # Extract the expression string between the first pair of double quotes\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        # Fallback: remove leading \"expression = \" if present\n        expr = data.replace(\"expression = \", \"\").strip()\n    sol = Solution()\n    print(sol.evaluate(expr))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for evaluating such expression. Provide a step-by-step algorithm: parse, evaluate recursively with environment stack. Provide virtual code line by line. Let's outline:\n\nStart\n→ Step 1: Parse expression string into tokens // Tokenize\n→ Step 2: Call Evaluate(tokens, envStack) // Recursively evaluate\n→ In Evaluate:\n   Decision: If token is '(' then\n      -> Read operator\n      -> If operator is 'let'\n           - create new scope env\n           - for each pair until last expr\n               * evaluate expression e\n               * assign to variable in current scope\n           - evaluate final expr in envStack\n           - pop scope\n      -> If operator is 'add' or 'mult'\n           - evaluate first operand\n           - evaluate second operand\n           - compute\n      -> else error\n   Decision: Else if token is integer // parse int\n   Decision: Else token is variable\n           - lookup variable in envStack from innermost to outermost\n→ Step 3: Return result\nEnd\n\nWe need to include arrow and decision steps.\n\nLet's produce virtual code lines. Each line should include a brief explanation comment.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: Tokenize the input expression string into a list of tokens // 將輸入字串拆分成單獨的標記\n→ Step 2: Create an empty environment stack // 建立空的環境堆疊用於變量作用域\n→ Step 3: Call Evaluate(tokens, envStack) and store result // 進行遞歸評估，得到整數結果\n→ Step 4: Output result // 將最終整數輸出\nEnd // 程式執行結束\n\nNow define Evaluate procedure as subroutine; but we need to produce virtual code for Evaluate logic line by line. We can use a subroutine block.\n\nWe can write:\n\n→ Sub Evaluate(tokens, envStack) // 評估一個表達式，返回整數\n\nInside, we need to read next token; but we can treat tokens list pointer. We'll use pseudo variable idx.\n\nBetter to treat tokens as queue.\n\nLet's write:\n\n→ Decision: If next token is '(' // 判斷是否為複合表達式\n    Yes →\n        → Consume '(' // 移除左括號\n        → Read operator token // 讀取操作符\n        → Decision: If operator == 'let'\n            Yes →\n                → Push new empty scope onto envStack // 新建一個局部作用域\n                → Loop while there are more than two tokens left before ')'\n                    → Read variable name // 變量名\n                    → Evaluate next expression recursively // 計算其值\n                    → Assign value to variable in current scope // 存入環境\n                → Evaluate final expression inside let // 最後一個表達式\n                → Pop scope from envStack // 退出局部作用域\n                → Return result // 返還 let 表達式值\n            No →\n                → Decision: If operator == 'add' or 'mult'\n                    Yes →\n                        → Evaluate first operand recursively // 先計算第一個子表達式\n                        → Evaluate second operand recursively // 再計算第二個子表達式\n                        → Decision: If operator == 'add'\n                            Yes → Return sum of operands // add 的結果\n                            No  → Return product of operands // mult 的結果\n                    No → Error // 非法操作符\n        → Consume ')' // 移除右括號\n    No →\n        → Decision: If token is an integer // 直接整數\n            Yes → Convert token to integer and return // 轉成整數回傳\n            No  → // token 是變量名\n                → Lookup variable value from envStack (innermost first)\n                → Return the found value // 取得並回傳變量值\n\nBut we need to produce lines accordingly.\n\nWe need to be careful: We cannot produce nested subroutines lines? It's okay.\n\nWe can include subroutine start and end.\n\nLet's produce lines:\n\n→ Sub Evaluate(tokens, envStack) // 評估一個表達式，返回整數\n→ Decision: If tokens.peek() == '(' // 檢查是否為複合表達式\n    Yes →\n        → tokens.consume('(') // 移除左括號\n        → op = tokens.consume() // 讀取操作符\n        → Decision: If op == 'let'\n            Yes →\n                → envStack.push({}) // 新建局部作用域\n                → While tokens.peek() != ')'\n                    → varName = tokens.consume() // 讀取變量名\n                    → value = Evaluate(tokens, envStack) // 計算對應表達式\n                    → envStack.top()[varName] = value // 設定變量\n                → result = Evaluate(tokens, envStack) // 計算 let 的最後表達式\n                → envStack.pop() // 退出局部作用域\n                → Return result // 回傳 let 結果\n            No →\n                → Decision: If op == 'add' or op == 'mult'\n                    Yes →\n                        → left = Evaluate(tokens, envStack) // 先計算左邊\n                        → right = Evaluate(tokens, envStack) // 再計算右邊\n                        → Decision: If op == 'add'\n                            Yes → Return left + right // 加法\n                            No  → Return left * right // 乘法\n                    No → Error // 非法操作符\n        → tokens.consume(')') // 移除右括號\n    No →\n        → token = tokens.consume() // 取得單個標記\n        → Decision: If token is integer\n            Yes → Return int(token) // 轉成整數回傳\n            No  → // 變量名\n                → For scope in reverse(envStack) // 從內層到外層搜尋\n                    → If varName in scope\n                        Yes → Return scope[varName] // 回傳找到的值\n                        No  → Continue\n                → Error // 未定義變量\n→ End Sub // 評估子程式結束\n\nBut we need each line with virtual code step + comment. We'll list them sequentially.\n\nLet's craft final output accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Tokenize the input expression string into a list of tokens // 將輸入字串拆分成單獨的標記  \n→ Step 2: Create an empty environment stack // 建立空的環境堆疊用於變量作用域  \n→ Step 3: Call Evaluate(tokens, envStack) and store result // 進行遞歸評估，得到整數結果  \n→ Step 4: Output result // 將最終整數輸出  \nEnd // 程式執行結束  \n\n→ Sub Evaluate(tokens, envStack) // 評估一個表達式，返回整數  \n→ Decision: If tokens.peek() == '(' // 檢查是否為複合表達式  \n Yes →  \n  → tokens.consume('(') // 移除左括號  \n  → op = tokens.consume() // 讀取操作符  \n  → Decision: If op == 'let' // 判斷是否為 let 表達式  \n   Yes →  \n    → envStack.push({}) // 新建局部作用域  \n    → While tokens.peek() != ')'  \n     → varName = tokens.consume() // 讀取變量名  \n     → value = Evaluate(tokens, envStack) // 計算對應表達式  \n     → envStack.top()[varName] = value // 設定變量  \n    → result = Evaluate(tokens, envStack) // 計算 let 的最後表達式  \n    → envStack.pop() // 退出局部作用域  \n    → Return result // 回傳 let 結果  \n   No →  \n    → Decision: If op == 'add' or op == 'mult' // 判斷是加法或乘法  \n     Yes →  \n      → left = Evaluate(tokens, envStack) // 計算第一個子表達式  \n      → right = Evaluate(tokens, envStack) // 計算第二個子表達式  \n      → Decision: If op == 'add'  \n       Yes → Return left + right // 加法  \n       No  → Return left * right // 乘法  \n     No → Error // 非法操作符  \n  → tokens.consume(')') // 移除右括號  \n No →  \n  → token = tokens.consume() // 取得單個標記  \n  → Decision: If token is integer // 直接整數  \n   Yes → Return int(token) // 轉成整數回傳  \n   No  → // token 為變量名  \n    → For scope in reverse(envStack) // 從內層到外層搜尋  \n     If varName in scope  \n      Return scope[varName] // 回傳找到的值  \n     Else Continue  \n    → Error // 未定義變量  \n→ End Sub // 評估子程式結束"
    },
    {
      "title": "Divide Array in Sets of K Consecutive Numbers",
      "source_file": "Leetcode/leetcode1296.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,3,4,4,5,6], k = 4",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk7ck7bwv.py\", line 34, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 0\n    \nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkduzvl9u.py\", line 34, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 0\n    \nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpa6h6b7qr.py\", line 34, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 0\n    \nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef is_possible_divide(nums, k):\n    if len(nums) % k != 0:\n        return False\n    count = Counter(nums)\n    for num in sorted(count):\n        if count[num] > 0:\n            need = count[num]\n            for i in range(num, num + k):\n                if count.get(i, 0) < need:\n                    return False\n                count[i] -= need\n    return True\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，假設格式為 \"nums = [...], k = ...\"\n    parts = [p.strip() for p in data.split(',')]\n    nums = []\n    k = 0\n    for part in parts:\n        if part.startswith('nums'):\n            # 取得方括號中的列表字串\n            start = part.find('[')\n            end = part.rfind(']')\n            nums_str = part[start:end+1]\n            nums = ast.literal_eval(nums_str)\n        elif part.startswith('k'):\n            _, value = part.split('=', 1)\n            k = int(value.strip())\n\n    result = is_possible_divide(nums, k)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: given array nums and positive k, check if can divide into sets of k consecutive numbers. Classic LeetCode 846. Approach: count frequencies, sort keys, iterate over sorted keys, for each value v, if count[v] >0, we need to take count[v] groups starting at v covering v, v+1,... v+k-1. For each i from v to v+k-1, reduce count[i] by count[v], if any count negative, return false. At end return true.\n\nWe need to output line-by-line pseudocode with comments. Use Start, End, Decision, Yes →, No → etc.\n\nWe should handle input, count map, sort keys, loop. Use dictionary. Use variables. Use pseudocode language.\n\nLet's craft steps:\n\nStart\n→ Step 1: 初始化頻率表 count ← 空字典 // 用於計算每個數字出現次數\n→ Step 2: 對 nums 中每個 num: count[num] ← count.get(num,0)+1 // 進行計數\n→ Step 3: 將 count 的鍵排序得到 sorted_keys ← 排序(count.keys()) // 依序處理\n\n→ Decision: 如果 count 中任一鍵的值不等於 0? Actually we need loop over sorted_keys\nWe can structure as: For each key in sorted_keys do.\n\nSo:\n→ Step 4: 循環每個 num 在 sorted_keys 中\n    → Decision: 如果 count[num] == 0? // 已經被消耗，跳過\n        Yes → 继续 // Next key\n        No  → \n            → Step 5: 取 group_count ← count[num] // 需要的組數\n            → Step 6: 對 i 從 num 到 num+k-1 做\n                → Decision: 如果 count.get(i,0) < group_count? // 沒有足夠數量\n                    Yes → Step 7: 返回 false // 不可分組\n                    No  → \n                        → Step 8: count[i] ← count[i] - group_count // 消耗\n            // 結束內部循環\n→ End // 如果所有檢查通過，返回 true\n\nBut we need to use Yes →, No → arrows within decision. Use End at last.\n\nLet's produce line by line:\n\nStart // 程式開始執行\n→ Step 1: count ← {} // 建立頻率表\n→ Step 2: 對每個 num in nums: count[num] ← count.get(num, 0) + 1 // 計算每個數字出現次數\n→ Step 3: sorted_keys ← Sort(count.keys()) // 依升序排序所有鍵\n→ Step 4: 循環 num 在 sorted_keys 中\n    → Decision: 如果 count[num] == 0? // 若已被消耗，跳過\n        Yes → // 下一個 key\n        No  → \n            → Step 5: group_count ← count[num] // 需要的組數\n            → Step 6: 循環 i 在 [num, num+k-1] 內\n                → Decision: 如果 count.get(i, 0) < group_count? // 數量不足\n                    Yes → Step 7: 返回 false // 無法完成分組\n                    No  → \n                        → Step 8: count[i] ← count[i] - group_count // 消耗\n    // 結束 num 的循環\n→ End // 所有檢查通過，返回 true\n\nBut we need to include explicit return statements. At Step 7 we return false, at the end return true.\n\nLet's produce as lines.\n\nWe also may need to mention return true at the end.\n\nMake sure to use \"→\" at start of each step. Use indentation as shown in example.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: count ← {} // 初始化頻率表  \n→ Step 2: 對每個 num in nums: count[num] ← count.get(num, 0) + 1 // 統計每個數字的出現次數  \n→ Step 3: sorted_keys ← Sort(count.keys()) // 把所有鍵按升序排序  \n\n→ Step 4: 循環 num 在 sorted_keys 中  \n    → Decision: 如果 count[num] == 0? // 若已被消耗，直接跳過  \n        Yes → // 下一個鍵  \n        No  →  \n            → Step 5: group_count ← count[num] // 需要從 num 開始的組數  \n            → Step 6: 循環 i 在 [num, num + k - 1]  \n                → Decision: 如果 count.get(i, 0) < group_count? // 檢查是否足夠  \n                    Yes → Step 7: 返回 false // 無法完成分組，直接結束  \n                    No  →  \n                        → Step 8: count[i] ← count[i] - group_count // 消耗相應數量  \n\n→ End // 所有檢查都通過，返回 true"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpainx9wgb.py\", line 45, in parse_input\n    parsed = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7801565fba50>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpainx9wgb.py\", line 53, in <module>\n    params = parse_input(raw)\n             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpainx9wgb.py\", line 47, in parse_input\n    raise ValueError(f\"無法解析輸入：{data}\") from e\nValueError: 無法解析輸入：{beginWord : \"hit\", endWord : \"cog\", wordList : [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]}"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4lkmu2b_.py\", line 45, in parse_input\n    parsed = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7269866f7a10>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp4lkmu2b_.py\", line 53, in <module>\n    params = parse_input(raw)\n             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4lkmu2b_.py\", line 47, in parse_input\n    raise ValueError(f\"無法解析輸入：{data}\") from e\nValueError: 無法解析輸入：{beginWord : \"hit\", endWord : \"cog\", wordList : [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]}"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        使用 BFS 找到最短轉換序列的長度。\n        若 endWord 不在字典，直接回傳 0。\n        \"\"\"\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (目前單字, 目前路徑長度)\n\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            # 嘗試每個位置換成 a~z\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        wordSet.remove(new_word)       # 標記已訪問\n                        queue.append((new_word, length + 1))\n        return 0\n\ndef parse_input(data: str):\n    \"\"\"\n    將類似 'beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\"]' 的字串\n    轉成 dict。使用 ast.literal_eval 以避免 eval 的安全風險。\n    \"\"\"\n    # 先去除前後空白\n    data = data.strip()\n    if not data:\n        return {}\n    # 把 '=' 換成 ':'，並包上花括號形成字典字串\n    data = data.replace('=', ':')\n    data = '{' + data + '}'\n    try:\n        parsed = ast.literal_eval(data)\n    except Exception as e:\n        raise ValueError(f\"無法解析輸入：{data}\") from e\n    return parsed\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有資料\n    raw = sys.stdin.read()\n    params = parse_input(raw)\n\n    # 取得必要參數\n    beginWord = params.get(\"beginWord\", \"\")\n    endWord = params.get(\"endWord\", \"\")\n    wordList = params.get(\"wordList\", [])\n\n    # 只保留字串型別的元素，排除非字串或重複\n    wordList = [w for w in wordList if isinstance(w, str)]\n\n    sol = Solution()\n    result = sol.ladderLength(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the word ladder problem: compute length of shortest transformation sequence. Use BFS. Steps: check endWord in wordList, if not return 0. Use set for wordList. Use queue with (word, level). Use visited set. For each word, for each position, change letter a-z, if new word in list and not visited, add to queue, mark visited. If new word==endWord return level+1. If BFS ends return 0.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Start, End, Decision:. Provide step labels: Start, → Step 1: ... etc. Use indentation for nested. Use \"Decision:\" lines.\n\nLet's create step numbers. Use \"Step 1\", \"Step 2\" etc. Also \"Decision: endWord in wordList?\" etc. Use Yes → etc.\n\nWe need to be careful with format: each line: 虛擬碼步驟[space]//解釋.\n\nAlso we can show pseudo code.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 beginWord, endWord, wordList // 從輸入取得起點、終點與字典  \n→ Step 2: 若 endWord 不在 wordList → End // 沒有可達終點，直接返回 0  \n→ Decision: 若 endWord 在 wordList?  \n    Yes → Step 3: 初始化 queue 為 [(beginWord, 1)] // 起點與初始層級 1  \n    No  → End // 這行實際上不會執行，因為已在前面處理  \n→ Step 4: 建立 visited 集合並加入 beginWord // 標記已訪問過的字  \n→ Step 5: 建立 setDict 為 wordList 的集合 // 方便 O(1) 查詢  \n→ Step 6: 進入 BFS 迴圈  \n    → Decision: 若 queue 為空?  \n        Yes → Step 7: 回傳 0 // 所有可能已被探索完，無路徑  \n        No  → Step 8: 取出 queue 內首項 (currentWord, level)  \n→ Step 9: 若 currentWord == endWord → Step 10: 回傳 level // 找到最短路徑  \n→ Step 11: 對每個字元位置 i 在 currentWord  \n    → Step 12: 對每個小寫字母 c 從 'a' 到 'z'  \n        → Decision: 若 c == currentWord[i]?  \n            Yes → Skip // 不需要替換成同一字母  \n            No  → Step 13: 建立 nextWord = currentWord 先替換第 i 個字為 c  \n→ Step 14: Decision: 若 nextWord 在 setDict 且未在 visited?  \n        Yes → Step 15: 加入 visited nextWord  \n              → Step 16: queue 加入 (nextWord, level + 1) // 下一層級  \n        No  → Skip // 無效或已訪問  \n→ Step 17: 迴圈結束後返回 0 // BFS 完結仍未找到 endWord  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,2,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 2, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"\n        把每個數字對應到它在陣列中的所有索引。\n        這樣就能在 pick 時直接取得所有可能的索引。\n        \"\"\"\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        隨機挑選 target 在陣列中的一個索引。\n        \"\"\"\n        return random.choice(self.indices[target])\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 把輸入分成兩部分：操作列表與參數列表\n    # 例如： '[\"Solution\",\"pick\",\"pick\"],[[[1,2,3]],[3],[2]]'\n    # 先找到第一個 '],' 位置，保證拆分在操作列表結束處\n    split_idx = data.find('],')\n    if split_idx == -1:\n        raise ValueError(\"Invalid input format\")\n    ops_str = data[:split_idx+1]      # 包含第一個列表\n    args_str = data[split_idx+2:].strip()  # 後續列表\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    # 執行操作\n    outputs = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])\n            outputs.append(None)  # 第一個輸出是 null\n        elif op == \"pick\":\n            res = obj.pick(arg[0])\n            outputs.append(res)\n\n    # 將結果格式化成 LeetCode 風格的輸出\n    formatted = []\n    for out in outputs:\n        if out is None:\n            formatted.append(\"null\")\n        else:\n            formatted.append(str(out))\n    print(\"[\" + \", \".join(formatted) + \"]\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step. The problem: given array nums with duplicates, pick random index of target. We need to implement Solution class with constructor storing nums, and pick method.\n\nIn virtual code, we need steps like Start, → Step: initialize, → Decision. We'll need to handle random picking. Approach: in constructor, store array. In pick, iterate and collect indices of target, then random choose one.\n\nAlternatively, use reservoir sampling to avoid storing indices. But for simplicity, we can just store indices list. But virtual code might show building list and picking random index.\n\nWe'll generate lines:\n\nStart\n→ Step 1: Initialize Solution with nums // store array\n→ End\n\nFor pick:\n\nStart\n→ Step 1: Initialize empty list indices // store positions\n→ Step 2: For each i in 0..len(nums)-1: // iterate array\n    → Decision: nums[i]==target? // check\n        Yes → Step 3: Append i to indices // collect\n        No  → Step 4: Continue // skip\n→ Step 5: Randomly select k from 0..len(indices)-1 // random index\n→ Step 6: Return indices[k] // return chosen index\nEnd\n\nBut we need to produce virtual code with arrows and decisions. Let's format accordingly.\n\nRemember to include // explanations after each line.\n\nWe should keep each line as \"虛擬碼步驟 [space] // 解釋\".\n\nAlso use arrows: \"→\" for step, \"Decision:\".\n\nWe can incorporate \"Yes →\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Store input array nums into member variable // 將傳入的陣列保存在物件屬性中  \nEnd // 建構子結束  \n\n---  \n\nStart // pick 方法執行  \n→ Step 1: 初始化空列表 indices // 用於保存所有目標值的位置  \n→ Step 2: 迭代遍歷 nums 中每個索引 i  \n    → Decision: nums[i] 是否等於 target? // 判斷目前元素是否為目標值  \n        Yes → Step 3: 將索引 i 加入 indices 列表 // 收集所有符合的索引  \n        No  → Step 4: 繼續迭代 // 忽略非目標值  \n→ Step 5: 計算 indices 的長度 n  \n→ Step 6: 生成隨機整數 k，範圍 0 ~ n-1 // 隨機選擇一個有效索引  \n→ Step 7: 返回 indices[k] // 回傳隨機挑選的目標索引  \nEnd // pick 方法結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[2,3]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[2, 3]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        \"\"\"\n        找出所有 (i, j) 使得 words[i] + words[j] 為回文。\n        時間複雜度 O(total_len)，使用哈希表和字串切分判斷。\n        \"\"\"\n        # 建立「單字的逆序 → 索引」映射\n        rev_index = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            length = len(word)\n            # 從 0 到 length 進行所有切分\n            for cut in range(length + 1):\n                prefix = word[:cut]\n                suffix = word[cut:]\n\n                # 1. 前綴是回文，查找 suffix 的逆序是否存在\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    j = rev_index.get(rev_suffix)\n                    if j is not None and j != i:\n                        res.append([i, j])\n\n                # 2. 後綴是回文，查找 prefix 的逆序是否存在\n                #   cut 必須不為 0，避免重複把整個字串作為後綴\n                if cut != 0 and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    j = rev_index.get(rev_prefix)\n                    if j is not None and j != i:\n                        res.append([j, i])\n\n        return res\n\ndef main():\n    # 從 stdin 讀取整個內容，並解析出 words 列表\n    data = sys.stdin.read().strip()\n    # 取出第一個 '[' 之後的內容作為字串列表\n    idx = data.find('[')\n    if idx == -1:\n        words = []\n    else:\n        try:\n            words = ast.literal_eval(data[idx:])\n        except Exception:\n            words = []\n\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudocode step by step, explaining. Should be O(total length). Approach: for each word, insert reversed word into map with index. For each word, iterate prefixes and suffixes: if prefix is palindrome, find reversed suffix; if suffix palindrome, find reversed prefix. Avoid same index. Complexity O(n * L^2?) But using precomputed suffix? But we can do O(total length). We'll produce generic pseudocode.\n\nNeed to output in lines, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrows. Provide each step.\n\nLet's craft:\n\nStart\n→ Build map reverse_word -> index for all words\n→ Initialize result list\n→ For each word with index i:\n    → For each split position k from 0 to len(word):\n        → prefix = word[0:k], suffix = word[k:]\n        → Decision: prefix is palindrome?\n            Yes → reversed_suffix = reverse(suffix)\n                 Decision: reversed_suffix in map and map[reversed_suffix] != i?\n                     Yes → Append [i, map[reversed_suffix]] to result\n        → Decision: suffix is palindrome and k != len(word)?\n            Yes → reversed_prefix = reverse(prefix)\n                 Decision: reversed_prefix in map and map[reversed_prefix] != i?\n                     Yes → Append [map[reversed_prefix], i] to result\n→ End\n\nExplain each step.\n\nNeed to ensure no duplicates: we can skip if i==j. Also skip duplicate pairs if needed. Provide explanation.\n\nOk. Let's craft lines.\n\nWe need to include arrows and decision statements.\n\nWe'll use \"→\" after step, then \"Decision:\" for if.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 為每個單字 words[i] 建立 reverse_word_map[reverse(words[i])] = i // 方便後續快速查找相反的字串  \n→ Step 2: 初始化空的 result_list // 用來儲存所有符合條件的 (i, j)  \n→ Decision: 是否還有單字要處理？ // 迴圈開始  \n    Yes → Step 3: 取出單字 word 及其索引 i // 進入主迴圈  \n        → Step 4: 對 word 進行所有可能的分割 (k = 0 .. len(word)) // 以檢查前後子字串  \n            → Decision: 前綴 prefix = word[0:k] 是否為回文？ // 檢查前綴是否能形成回文  \n                Yes → Step 5: 計算 suffix 的反轉 reversed_suffix = reverse(word[k:])  \n                    → Decision: reversed_suffix 是否存在於 reverse_word_map 且 map[reversed_suffix] ≠ i？ // 確認不同索引  \n                        Yes → Step 6: 將 (i, map[reversed_suffix]) 加入 result_list // 找到符合的 (i, j)  \n                No → (不做任何事)  \n            → Decision: 後綴 suffix = word[k:] 是否為回文？且 k ≠ len(word) // 避免重複把整個字串作為前綴  \n                Yes → Step 7: 計算 prefix 的反轉 reversed_prefix = reverse(word[0:k])  \n                    → Decision: reversed_prefix 是否存在於 reverse_word_map 且 map[reversed_prefix] ≠ i？  \n                        Yes → Step 8: 將 (map[reversed_prefix], i) 加入 result_list // 找到符合的 (j, i)  \n                No → (不做任何事)  \n        → (結束所有分割)  \n    → (回到 Decision: 是否還有單字要處理？)  \n→ End // 程式執行結束，result_list 為所有回文對的集合"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> list[str]:\n        \"\"\"\n        Find all 10-letter-long substrings that occur more than once in s.\n        Uses a sliding window with two sets to track seen and repeated sequences.\n        \"\"\"\n        seen = set()\n        repeated = set()\n\n        # Only iterate if the string is long enough\n        for i in range(len(s) - 9):\n            seq = s[i:i + 10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n\n        return list(repeated)\n\n\ndef main() -> None:\n    \"\"\"\n    Reads the DNA sequence from standard input, processes it, and prints\n    a JSON-formatted list of repeated 10-letter sequences.\n    \"\"\"\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n\n    # Extract DNA string: support \"s = '...'\" or plain string\n    match = re.search(r\"'([^']*)'\", raw_input)\n    dna_seq = match.group(1) if match else raw_input\n\n    # Compute repeated sequences\n    solution = Solution()\n    repeated = solution.findRepeatedDnaSequences(dna_seq)\n\n    # Output as JSON array string\n    print(json.dumps(repeated))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: find all 10-letter-long substrings that appear more than once in a given string s. Typical solution uses sliding window and set or hash map.\n\nWe must output step-by-step lines with arrow and comments.\n\nWe need to include Start, End, Decision lines, etc. Provide each step with explanation.\n\nMake sure to not output real code. Just virtual steps.\n\nLet's design:\n\nStart.\n\n→ Step 1: Input string s // get DNA sequence.\n\n→ Decision: If length of s < 10? // if too short.\n\n    Yes → Step 2: Return empty list // no substrings.\n\n    No → Step 3: Initialize seen set and repeated set // track substrings seen once and those repeated.\n\n→ Step 4: For i from 0 to length(s)-10: // sliding window.\n\n    → Substring = s[i:i+10] // get 10-length substring.\n\n    → Decision: If substring in seen? // already seen.\n\n        Yes → Step 5: Add substring to repeated // add to repeated set.\n\n        No → Step 6: Add substring to seen // record first time.\n\n→ Step 7: Convert repeated set to list // produce output.\n\n→ Step 8: Return list // result.\n\nEnd.\n\nAlso maybe consider storing counts via dictionary.\n\nBut okay.\n\nAdd comments after each step.\n\nInclude arrow lines: \"→\". For decision, indent children.\n\nLet's format.\n\nRemember: each line has `虛擬碼步驟` + space + `// 解釋`.\n\nWe'll keep arrow and indent properly.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得 DNA 序列  \n→ Decision: 如果 len(s) < 10? // 序列太短無法形成 10 字元子字串  \n  Yes → Step 2: 返回空清單 // 直接結束  \n  No  → Step 3: 初始化 seen 集合與 repeated 集合 // 追蹤已見與重複的子字串  \n→ Step 4: 循環 i 從 0 到 len(s)-10: // 滑動窗口遍歷所有可能的 10 字元子字串  \n  → Substring ← s[i : i+10] // 取出當前 10 字元子字串  \n  → Decision: 如果 Substring 在 seen? // 已經見過一次  \n    Yes → Step 5: 把 Substring 加入 repeated // 標記為重複子字串  \n    No  → Step 6: 把 Substring 加入 seen // 記錄第一次出現  \n→ Step 7: 把 repeated 集合轉成清單 // 準備輸出結果  \n→ Step 8: 返回清單 // 結束並回傳所有重複的 10 字元子字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nimport json\n\ndef solve() -> None:\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中擷取方括號內的部分，並安全評估為列表\n    match = re.search(r'\\[.*\\]', data)\n    nums = ast.literal_eval(match.group()) if match else []\n\n    res = []\n\n    def backtrack(start: int) -> None:\n        if start == len(nums):\n            res.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    backtrack(0)\n\n    # 用 json.dumps 並去除空格，符合範例輸出格式\n    print(json.dumps(res, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The problem: generate all permutations of an array of distinct integers. Standard backtracking algorithm.\n\nWe need to output line by line: each line is a \"virtual code step\" followed by comment. Use arrow, etc. No actual code.\n\nWe'll produce steps:\n\nStart\n→ Step 1: define function permute(nums) // main function\n→ Step 2: initialize result list // store permutations\n→ Step 3: initialize visited array of false // track used elements\n→ Step 4: call backtrack(currentPermutation) // start recursion\n\nDefine backtrack(current):\n→ Decision: if current.length == nums.length? // check if a full permutation built\n   Yes → Step: add copy of current to result // add to result\n   No → loop over i from 0 to nums.length-1\n         if not visited[i] // if element not used\n            Mark visited[i] = true // include element\n            Append nums[i] to current // add to permutation\n            → Step: backtrack(current) // recurse\n            → Step: remove last element from current // backtrack\n            → Step: visited[i] = false // unmark\n\nAfter backtracking complete, return result\n\nEnd\n\nWe need to ensure each line uses virtual code style.\n\nWe'll produce each line with a number? Not necessary. Use \"→\" for steps, \"Decision:\" for decisions, \"Yes →\", \"No →\" etc. Each line comment after //.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: function permute(nums) // 定義主函式，輸入為整數陣列\n→ Step 2: result ← [] // 建立儲存結果的空陣列\n→ Step 3: visited ← Array(nums.length).fill(false) // 建立布林標記陣列，追蹤元素是否已使用\n→ Step 4: backtrack([]) // 開始回溯，初始排列為空\n→ Step 5: return result // 回傳所有排列\nEnd // 程式結束\n\nDefine backtrack(current):\nStart // 回溯函式開始\n→ Decision: current.length == nums.length? // 檢查是否已生成完整排列\n    Yes → Step 6: result.push(current.slice()) // 將排列副本加入結果\n    No → for i ← 0 to nums.length-1 do // 逐一考慮每個元素\n          → Decision: not visited[i]? // 若元素未被使用\n              Yes →\n                  → Step 7: visited[i] = true // 標記元素已使用\n                  → Step 8: current.push(nums[i]) // 加入元素到當前排列\n                  → Step 9: backtrack(current) // 進行下一層遞迴\n                  → Step 10: current.pop() // 回溯，移除最後加入的元素\n                  → Step 11: visited[i] = false // 取消標記，恢復狀態\n              No → // 若已使用，直接跳過\nEnd // 回溯函式結束\n\nBut we need each line of virtual code. Must maintain structure.\n\nProbably best to write:\n\nStart // 程式開始執行\n→ Step 1: function permute(nums) // 定義主函式\n→ Step 2: result ← [] // 儲存所有排列\n→ Step 3: visited ← Array(nums.length).fill(false) // 標記陣列\n→ Step 4: backtrack([]) // 開始回溯\n→ Step 5: return result // 回傳結果\nEnd // 程式結束\n\nStart // 回溯函式開始\n→ Decision: current.length == nums.length? // 完整排列判斷\n    Yes → Step 6: result.push(current.slice()) // 加入結果\n    No → for i ← 0 to nums.length-1 do // 迭代所有元素\n          → Decision: not visited[i]? // 尚未使用\n              Yes →\n                  → Step 7: visited[i] = true // 標記使用\n                  → Step 8: current.push(nums[i]) // 加入元素\n                  → Step 9: backtrack(current) // 遞迴\n                  → Step 10: current.pop() // 回溯移除\n                  → Step 11: visited[i] = false // 取消標記\n              No → // 跳過已使用的元素\nEnd // 回溯函式結束\n\nWe must output each line as \"虛擬碼步驟 [space] // 解釋\". So each line begins with arrow or step label.\n\nEnsure no actual code. Use placeholders like ← etc. Avoid parentheses that indicate actual code.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: function permute(nums) // 定義主函式，輸入為整數陣列  \n→ Step 2: result ← [] // 建立儲存所有排列的空陣列  \n→ Step 3: visited ← Array(nums.length).fill(false) // 建立布林標記陣列，追蹤每個元素是否已使用  \n→ Step 4: backtrack([]) // 開始回溯，初始排列為空  \n→ Step 5: return result // 回傳所有產生的排列  \nEnd // 程式結束  \n\nStart // 回溯函式開始  \n→ Decision: current.length == nums.length? // 檢查是否已完成一個完整排列  \n  Yes → Step 6: result.push(current.slice()) // 把當前排列的副本加入結果  \n  No → for i ← 0 to nums.length-1 do // 逐一嘗試每個元素  \n    → Decision: not visited[i]? // 若元素未被使用  \n     Yes →  \n       → Step 7: visited[i] = true // 標記元素已使用  \n       → Step 8: current.push(nums[i]) // 加入元素到目前排列  \n       → Step 9: backtrack(current) // 進行下一層遞迴  \n       → Step 10: current.pop() // 回溯，移除最後加入的元素  \n       → Step 11: visited[i] = false // 取消標記，恢復狀態  \n     No → // 若已使用，直接跳過此元素  \nEnd // 回溯函式結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 用於存儲所有元素的列表\n        self.data = []\n        # 哈希表：值 -> 其在 data 中的所有索引集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        插入元素 val。\n        若 val 原本不存在於集合，返回 True；否則返回 False。\n        \"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此時索引集合大小為 1，表示 val 原本不存在\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        移除元素 val（若存在）。若成功移除，返回 True；否則返回 False。\n        \"\"\"\n        if not self.idx_map[val]:\n            return False\n        # 任取一個要移除的索引\n        remove_idx = self.idx_map[val].pop()\n        # 取最後一個元素的位置\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 若要移除的不是最後一個，將最後一個元素搬到要移除的位置\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            # 更新 last_val 的索引集合\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n        # 移除最後一個元素\n        self.data.pop()\n        # 若 val 的索引集合已空，刪除鍵以釋放空間\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        隨機返回一個元素。每個元素的返回機率與其出現次數成正比。\n        \"\"\"\n        return random.choice(self.data)\n\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    # 以換行分割，期望兩行：命令列表和參數列表\n    parts = raw_input.strip().splitlines()\n    if len(parts) < 2:\n        return\n    # 使用 eval 解析，因為輸入使用單引號而非 JSON\n    commands = eval(parts[0])\n    args_list = eval(parts[1])\n\n    result = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)\n        elif cmd == \"insert\":\n            res = obj.insert(args[0])\n            result.append(res)\n        elif cmd == \"remove\":\n            res = obj.remove(args[0])\n            result.append(res)\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n        else:\n            # 未知命令，輸出 None\n            result.append(None)\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 的格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for the RandomizedCollection class, implementing insert, remove, getRandom in O(1). Should be pseudocode, no actual code. Use virtual code lines, each line has explanation.\n\nWe must describe initialization, data structures: vector for values, map from value to set of indices. And for removal, we swap with last element, update indices, etc.\n\nWe should produce steps for the whole algorithm: class definition, constructor, insert, remove, getRandom.\n\nEach line: \"虛擬碼步驟 // 解釋\"\n\nUse arrow notation. Let's produce:\n\nStart RandomizedCollection // start of constructor?\n\nBetter structure: Start class RandomizedCollection // class definition start.\n\nBut requirement: Use Start, End, Decision: etc. Might structure like:\n\nStart // 程式開始\n→ Step: 定義 class RandomizedCollection // 定義類別\n→ Step: 初始化 values list 和 indices map // 建立兩個資料結構\n...\n\nAlternatively break into methods.\n\nWe must show virtual code for insert, remove, getRandom.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step 1: 定義 RandomizedCollection 類別 // 建立類別\n\n→ Step 2: 建立空 vector values // 用於存放元素\n\n→ Step 3: 建立哈希表 indices mapping val -> set of indices // 追蹤每個值在 values 中的位置\n\n→ Step 4: 方法 insert(val)\n\n  → Decision: 若 indices[val] 為空? // 檢查 val 是否已存在\n\n    Yes → Step 5: 插入 val 到 values 並新增其索引到 indices[val] // 新增元素\n\n      → Step 6: 返回 true // 新元素\n\n    No  → Step 7: 插入 val 到 values 並新增索引到 indices[val] // 重複元素\n\n      → Step 8: 返回 false // 不是新元素\n\n→ Step 9: 方法 remove(val)\n\n  → Decision: 若 indices[val] 為空? // 是否存在該值\n\n    No → Step 10: 取得 indices[val] 的任意索引 idx_to_remove // 取一個要移除的索引\n\n      → Step 11: 取得 values 最後一個元素 last_val, last_index\n\n      → Decision: 若 idx_to_remove != last_index? // 是否不是最後一個\n\n        Yes → Step 12: 把 last_val 放到 idx_to_remove 的位置 // 替換\n\n          → Step 13: 更新 indices[last_val] 的索引集合：移除 last_index，新增 idx_to_remove\n\n        No → Step 14: // idx_to_remove 是最後一個，直接覆蓋\n\n      → Step 15: 從 values 刪除最後一個元素 // 移除\n\n      → Step 16: 在 indices[val] 刪除 idx_to_remove // 更新索引\n\n      → Decision: 若 indices[val] 空? // 是否還有該值\n\n        Yes → Step 17: 刪除 indices[val] 進行清理\n\n      → Step 18: 返回 true // 成功移除\n\n    Yes → Step 19: 返回 false // 沒有該元素\n\n→ Step 20: 方法 getRandom()\n\n  → Step 21: 隨機產生 0 到 values.size()-1 的索引 r // 隨機位置\n\n  → Step 22: 返回 values[r] // 返回隨機元素\n\nEnd // 程式結束\n\nWe should use \"Step\" or \"Step X:\" but format example uses \"Step 1:\" etc. So we will use \"Step 1:\" style.\n\nAlso use arrows: \"→\" before each step.\n\nWe'll include decisions with indentation.\n\nMake sure each line has \"// 解釋\".\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 定義 RandomizedCollection 類別 // 建立類別\n→ Step 2: 建立空 vector values // 用於儲存所有元素，允許快速存取最後一項\n→ Step 3: 建立哈希表 indices mapping val -> set of indices // 追蹤每個值在 values 中所有位置\n→ Step 4: 方法 insert(val) // 插入一個值\n    → Decision: 若 indices[val] 為空? // 判斷 val 是否首次出現\n        Yes → Step 5: 將 val 推入 values 並把其索引加入 indices[val] // 新增元素並記錄索引\n            → Step 6: 返回 true // 表示 val 原本不存在\n        No  → Step 7: 將 val 推入 values 並把其索引加入 indices[val] // 仍需記錄索引\n            → Step 8: 返回 false // 表示 val 已存在\n→ Step 9: 方法 remove(val) // 移除一個值\n    → Decision: 若 indices[val] 為空? // 判斷 val 是否存在\n        No → Step 10: 取 indices[val] 的任意一個索引 idx_to_remove // 選擇要移除的位置\n            → Step 11: 取 values 的最後一個元素 last_val 及其索引 last_index // 需要移動\n            → Decision: 若 idx_to_remove != last_index? // 需要交換\n                Yes → Step 12: 把 last_val 放到 idx_to_remove 的位置 // 交換位置\n                    → Step 13: 在 indices[last_val] 移除 last_index 並加入 idx_to_remove // 更新索引集合\n                No  → Step 14: // idx_to_remove 是最後一項，無需交換\n            → Step 15: 從 values 刪除最後一個元素 // 真正移除\n            → Step 16: 在 indices[val] 移除 idx_to_remove // 更新索引集合\n            → Decision: 若 indices[val] 空? // 是否還有該值剩餘\n                Yes → Step 17: 刪除 indices[val] 以釋放空間\n            → Step 18: 返回 true // 成功移除\n        Yes → Step 19: 返回 false // val 不存在\n→ Step 20: 方法 getRandom() // 取得隨機元素\n    → Step 21: 隨機產生索引 r 在 [0, values.size()-1] 之間 // 隨機位置\n    → Step 22: 返回 values[r] // 回傳隨機元素\nEnd // 程式結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp29crehz2.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp29crehz2.py\", line 38, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    ^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp99b0ew54.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp99b0ew54.py\", line 38, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\n    ^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank) -> int:\n        \"\"\"返回從 start 到 end 所需的最少突變步數，若無法達成則回傳 -1。\"\"\"\n        if start == end:\n            return 0\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n\n        queue = deque([(start, 0)])  # (目前基因, 已經突變的步數)\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutated = current[:i] + g + current[i + 1:]\n                    if mutated in bank_set and mutated not in visited:\n                        if mutated == end:\n                            return steps + 1\n                        visited.add(mutated)\n                        queue.append((mutated, steps + 1))\n        return -1\n\ndef main():\n    # 讀取輸入並執行 eval 以獲得 startGene、endGene、bank 變數\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    local_vars = {}\n    exec(data, {}, local_vars)\n\n    start_gene = local_vars.get('startGene')\n    end_gene = local_vars.get('endGene')\n    bank = local_vars.get('bank', [])\n\n    result = Solution().minMutation(start_gene, end_gene, bank)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for BFS minimal mutation steps. Provide step-by-step with decision arrows. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide lines. Should include algorithm: convert bank to set, if endGene not in bank return -1. BFS queue. For each gene, for each position mutate each char, if in bank not visited then enqueue and visited, record steps. When reach endGene return steps. If queue empty return -1. We'll output steps with arrows. Ensure each line has //.\n\nLet's produce.\n\nWe need to represent variables: queue, visited, bankSet, steps.\n\nPseudo code:\n\nStart\n→ Initialize bankSet from bank // convert list to set\n→ Decision: endGene ∈ bankSet? // if not valid mutation\n    No → Return -1 // cannot reach\n    Yes →\n→ Initialize queue with (startGene, 0) // starting gene and steps 0\n→ Initialize visited set with startGene\n→ While queue not empty\n    → Pop gene, steps\n    → Decision: gene == endGene? // reached\n        Yes → Return steps\n        No →\n            → For each position i in 0..7\n                → For each nucleotide in ['A','C','G','T']\n                    → If nucleotide != gene[i]\n                        → mutated = replace char at i\n                        → Decision: mutated in bankSet AND not in visited?\n                            Yes → Add mutated to visited\n                                → Enqueue (mutated, steps+1)\n                            No → Continue\n→ Return -1 // no path found\nEnd\n\nWe need to follow the formatting.\n\nLet's produce each line accordingly.\n\nWe'll use indentation maybe with tabs or spaces? Not required. Just lines with arrow. Provide explanation after //.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize bankSet = Set(bank) // 把 gene bank 轉成集合方便快速查找\n→ Decision: endGene ∈ bankSet? // 檢查終點基因是否為合法基因\n    No  → Return -1 // 若終點不在 bank，無法完成突變\n    Yes →\n→ Initialize queue = [(startGene, 0)] // 佇列中存放 (基因, 已經突變步數)\n→ Initialize visited = {startGene} // 記錄已訪問過的基因，避免重複\n→ While queue is not empty // 從佇列中取出基因進行 BFS\n    → Pop (current, steps) from queue // 取出最先進入佇列的基因及其步數\n    → Decision: current == endGene? // 檢查是否已達到終點\n        Yes → Return steps // 若相等，直接回傳所需最少步數\n        No  →\n            → For i from 0 to 7 // 遍歷基因字串的每個位置\n                → For nucleotide in ['A', 'C', 'G', 'T'] // 可能的四種字母\n                    → If nucleotide != current[i] // 只考慮改變位置的情況\n                        → mutated = current with position i replaced by nucleotide\n                        → Decision: mutated ∈ bankSet AND mutated ∉ visited? // 檢查合法且未訪問\n                            Yes → Add mutated to visited // 標記為已訪問\n                                → Enqueue (mutated, steps + 1) // 將新基因加入佇列，步數+1\n                            No  → Continue // 無效或已訪問，忽略\n→ Return -1 // 佇列空了仍未找到終點，代表無法達成\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        # max heap (store negatives)\n        self.small = []\n        # min heap\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # push into small (max heap)\n        heapq.heappush(self.small, -num)\n        # balance between heaps if necessary\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # The input is two lists separated by a comma.\n    # Wrap them into a tuple for literal_eval.\n    ops, args = ast.literal_eval(f\"({data})\")\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            result.append(median)\n        else:\n            result.append(None)\n    # Use json.dumps to get 'null' for None and correct formatting\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. Provide algorithm for MedianFinder using two heaps. Let's design: initialize two heaps: maxHeap (lower half) and minHeap (upper half). addNum: if maxHeap empty or num <= maxHeap.peek, push to maxHeap else push to minHeap. Rebalance: if size difference >1, move top from larger heap to other. findMedian: if sizes equal, return (maxHeap.peek+minHeap.peek)/2.0 else return peek of larger. Provide virtual code.\n\nWe need to use arrow, Start End, Decision, etc. Provide step by step.\n\nLet's produce:\n\nStart // 初始化\n→ Step 1: 建立最大堆 low // 儲存較小的一半\n→ Step 2: 建立最小堆 high // 儲存較大的一半\n\nMethod: addNum(num)\n→ Step 3: Decision: if low empty or num <= low.peek? // 判斷放進哪個堆\n    Yes → Step 4: 插入 low (maxHeap) // 小於等於下界\n    No  → Step 5: 插入 high (minHeap) // 大於下界\n\n→ Step 6: Decision: |low.size - high.size| > 1? // 平衡堆\n    Yes → Decision: low.size > high.size? // 哪個堆太大\n        Yes → Step 7: 移動 low.peek() 到 high // 從大堆移到小堆\n        No  → Step 8: 移動 high.peek() 到 low // 從小堆移到大堆\n    No  → No operation\n\nMethod: findMedian()\n→ Step 9: Decision: low.size == high.size? // 是否相等\n    Yes → Step 10: 取 low.peek() + high.peek() / 2.0 // 平均\n    No  → Decision: low.size > high.size? // 低堆較大\n        Yes → Step 11: 取 low.peek() // 回傳低堆頂\n        No  → Step 12: 取 high.peek() // 回傳高堆頂\n\nEnd\n\nBut we need to put \"虛擬碼步驟\" with explanation.\n\nWe should use arrow \"→\" before steps. \"Decision:\" lines. For operations like \"Insert\" we use \"Insert num into low\". Provide explanation. Must follow format: each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立最大堆 low // 儲存較小的一半元素\n→ Step 2: 建立最小堆 high // 儲存較大的一半元素\n\n// addNum(num) 方法\n→ Step 3: Decision: 若 low 為空 或 num ≤ low.peek()？ // 判斷 num 應加入哪個堆\n    Yes → Step 4: Insert num into low // 把小於等於下界的數放入最大堆\n    No  → Step 5: Insert num into high // 把大於下界的數放入最小堆\n\n→ Step 6: Decision: |low.size - high.size| > 1？ // 檢查兩堆大小是否失衡\n    Yes → Decision: low.size > high.size？ // 判斷哪一堆太大\n        Yes → Step 7: Move low.peek() to high // 從最大堆移至最小堆\n        No  → Step 8: Move high.peek() to low // 從最小堆移至最大堆\n    No  → No  // 堆已平衡，無需操作\n\n// findMedian() 方法\n→ Step 9: Decision: low.size == high.size？ // 判斷兩堆大小是否相等\n    Yes → Step 10: Return (low.peek() + high.peek()) / 2.0 // 平均兩個中位數\n    No  → Decision: low.size > high.size？ // 判斷哪一堆多個元素\n        Yes → Step 11: Return low.peek() // 最大堆頂即為中位數\n        No  → Step 12: Return high.peek() // 最小堆頂即為中位數\n\nEnd // 程式執行結束"
    },
    {
      "title": "1-bit and 2-bit Characters",
      "source_file": "Leetcode/leetcode717.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "bits = [1,0,0]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def isOneBitCharacter(self, bits):\n        i = 0\n        n = len(bits)\n        while i < n - 1:\n            if bits[i] == 1:\n                i += 2\n            else:\n                i += 1\n        return i == n - 1\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 允許輸入格式為 \"bits = [1,0,0]\" 或僅為 \"[1,0,0]\"\n    if \"bits\" in data:\n        # 將 \"bits =\" 轉換為簡單的賦值形式\n        data = data.replace(\"bits =\", \"bits\")\n    try:\n        local_vars = {}\n        exec(data, {}, local_vars)\n        bits = local_vars.get(\"bits\", [])\n    except Exception:\n        # 若解析失敗，則視為空陣列\n        bits = []\n\n    solution = Solution()\n    result = solution.isOneBitCharacter(bits)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrow syntax and explanation comments. The task: given binary array bits that ends with 0, return true if the last character must be a one-bit character. We need to produce a flowchart-like pseudo-code.\n\nWe need to generate steps: start, iterate through bits until before last index? We need to consider the rule: 0 is one-bit, 10 or 11 is two-bit. We need to determine if last 0 is one-bit char, meaning that all previous bits cannot form a 2-bit char that consumes the last 0.\n\nStandard solution: iterate i from 0 to len-2; if bits[i]==0 then i+=1; else i+=2. After loop, if i==len-1 return true else false.\n\nSo produce virtual code steps:\n\nStart\n→ Step 1: Set i=0 // 初始化指標\n→ Decision: i < len(bits)-1? // 只要還有足夠位可判斷\n    Yes → Decision: bits[i] == 0? // 檢查當前位\n        Yes → Step 2: i = i + 1 // 0 為一位字元，向右移一位\n        No  → Step 3: i = i + 2 // 10/11 為兩位字元，向右移兩位\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd\n\nBut we might need to include Step 4 and Step 5 outside of decisions. Actually after loop ends, we check i==len-1.\n\nAlternatively we can write:\n\nStart\n→ Step 1: Set i = 0\n→ While i < len(bits) - 1:\n    → Decision: bits[i] == 0 ?\n        Yes → i += 1\n        No  → i += 2\n→ Decision: i == len(bits) - 1 ?\n    Yes → Step 2: return true\n    No  → Step 3: return false\nEnd\n\nBut we need to include arrow syntax, \"→\" for steps and decisions, \"Decision:\" for conditions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標到陣列起點\n→ Decision: i < len(bits)-1? // 判斷是否還有足夠位數可處理\n    Yes → Decision: bits[i] == 0? // 判斷目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10 或 11 為兩位字元，指標右移兩位\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 最後一位必為一位字元\n        No  → Step 5: return false // 最後一位不是一位字元\nEnd // 程式結束\n\nBut we need to maintain the flow: the while loop continues until i >= len-1. The outer decision should loop. The pseudo-code structure: Start, Step1, Decision to check loop, inside loop we handle bits, after loop we decide return.\n\nSimplify: Use a while loop concept: \"Decision: i < len(bits)-1?\" with Yes -> Inside, No -> After loop.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 只要還有至少兩位可判斷\n    Yes → Decision: bits[i] == 0? // 檢查目前位\n        Yes → Step 2: i ← i + 1 // 0 是一位字元\n        No  → Step 3: i ← i + 2 // 10/11 是兩位字元\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續循環\n            Yes → (loop back to the previous Decision)\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut we need to avoid recursion loops in pseudo-code. We could indicate \"← Loop\" but simpler is to write \"While i < len(bits)-1:\" etc.\n\nBut we have to adhere to arrow format: \"→ Step\" and \"Decision:\".\n\nLet's design as:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 是否還有足夠位數可判斷\n    Yes → Decision: bits[i] == 0? // 判斷當前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10 或 11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續\n            Yes → (回到第一個 Decision) // 迴圈回到頂部\n            No  → // 迴圈結束\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut we need to express loops properly. Maybe simpler: use \"While\" concept:\n\nStart\n→ Step 1: i ← 0\n→ Decision: i < len(bits)-1? // 只要還有至少兩位可判斷\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1\n        No  → Step 3: i ← i + 2\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到上方 Decision) // 迴圈\n            No  → // 退出\n    No  → Decision: i == len(bits)-1? // 判斷最後一位\n        Yes → Step 4: return true\n        No  → Step 5: return false\nEnd\n\nBut arrow syntax \"←\" may be allowed? The requirement: Use arrows `→`, `Yes →`, `No →` and structure `Start`, `End`, `Decision:`. We can use `→ Step 1: i ← 0` but arrow is `→` to indicate step. That's okay.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10 或 11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續循環\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut the instruction: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\" and \"使用虛擬碼的箭頭 (→, Yes →, No →)\". So we need to use `Yes →` and `No →` after Decision? In example, they used `Yes → Step 2: ...` and `No  → Decision: ...` The \"Yes →\" and \"No →\" are placed after the line that is a decision. Actually in example:\n\nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nSo for each Decision, we indent two spaces? They use indentation for nested decisions. So we need to replicate.\n\nThus for our code: Each Decision line ends with `?`. Then we indent `Yes →` or `No →` lines under it.\n\nLet's produce final answer accordingly.\n\nBe careful: Each line after indent may contain \"Yes →\" or \"No  →\". Use two spaces before Yes or No? In example, they used two spaces before Yes and No. Use same. Also keep arrow symbol after Yes or No: `Yes →`.\n\nWe should output each line exactly. Ensure no trailing spaces after code.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標為陣列起點\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10 或 11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut the line \"→ Decision: i < len(bits)-1? // 重新判斷是否繼續\" maybe we need to indent under Step 2 and Step 3? In example, after Step 2, they didn't indent further. For our flow, we can simply treat the loop as separate: After Step 2 or Step 3, go back to outer Decision. Instead of nested Decision again, we can have a loop. But we need to stay within the arrow structure.\n\nSimplify: Represent loop by \"→ Decision: i < len(bits)-1?\" inside Yes branch, and the steps inside. After steps, we loop back automatically. But need to show \"Yes →\" back to the same decision. But we can avoid nested decisions by using \"Yes →\" line referencing the Decision again. But we cannot produce arrow referencing previous step. But we can simulate: After Step 2 and Step 3, we need to go back to the outer Decision. So we could just use \"Yes →\" on the outer Decision line again? Actually we can produce like:\n\nYes → (回到上一 Decision) // 迴圈\n\nBut maybe better: \"Yes → Decision: i < len(bits)-1?\" again. But the example used \"Yes → Step 2: 輸出 '正數'\". So we need to produce a step after Yes. So maybe \"Yes → Step 1: i ← i + 1\" etc. But we can't have infinite recursion. For clarity, we can structure loop as:\n\nStart\n→ Step 1: i ← 0\n→ Decision: i < len(bits)-1?\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1\n        No  → Step 3: i ← i + 2\n        → Decision: i < len(bits)-1? // loop check\n            Yes → (回到上方 Decision) // 迴圈\n            No  → // 退出\n    No  → Decision: i == len(bits)-1?\n        Yes → Step 4: return true\n        No  → Step 5: return false\nEnd\n\nBut the \"回到上方 Decision\" might be okay as a comment. However, the specification might expect only steps and decisions, not \"回到\" comments. But we can keep.\n\nMaybe we can structure as:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut the arrow after the nested Decision maybe wrong. Actually after Step 2 or Step 3, we should immediately check again. So we can treat the outer Decision as a loop. We can represent like:\n\nStart\n→ Step 1: i ← 0\n→ Decision: i < len(bits)-1?\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1\n        No  → Step 3: i ← i + 2\n        → Decision: i < len(bits)-1? // loop check\n            Yes → (回到上方 Decision) // 迴圈\n            No  → // 退出\n    No  → Decision: i == len(bits)-1?\n        Yes → Step 4: return true\n        No  → Step 5: return false\nEnd\n\nBut the structure is a bit weird. We can simplify to avoid nested decisions:\n\nWe can implement loop explicitly: Use \"While\" concept but keep arrow format:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 只要還有至少兩位可判斷\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1 // 0 為一位字元\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到第一個 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut we should keep consistent formatting: indentation of Yes/No lines under Decision. Use two spaces before Yes or No.\n\nBetter: Represent the loop as:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 只要還有至少兩位可判斷\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1 // 0 為一位字元\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut \"→ (回到上一 Decision)\" may be considered as a step? Might not be necessary. We can just omit the loop and rely on the outer decision as loop. Actually we can use the outer Decision to loop. Represent:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷指標是否停在最後一位\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nMaybe we should restructure to avoid nested Decision inside Decision. Instead, we can treat the loop as:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 只要還有至少兩位可判斷\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1 // 0 為一位字元\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nBut this may not meet strict format. Let's try simpler: Use while loop concept but expressed:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續\n            Yes → (回到上方 Decision) // 迴圈\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n\nI think this is okay.\n\nBut the requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So we must keep comment after //.\n\nThus each line ends with comment. For lines with \"→ (回到上一 Decision)\", we need comment too.\n\nBut we need to keep arrow symbol: \"→\" at the start of each step line. For decisions, we use \"Decision:\".\n\nLet's craft final output.\n\nOne possible final answer:\n\n```\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10/11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 再次判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈回到判斷條件\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n```\n\nBut \"→ (回到上一 Decision)\" is not a step; we can just keep \"→ Decision: i < len(bits)-1? // 迴圈回到判斷\" again? Actually we can just have \"→ Decision: i < len(bits)-1? // 迴圈回到判斷\" but that duplicates. But it's fine.\n\nAlternatively, we can use a simpler representation:\n\nStart\n→ Step 1: i ← 0\n→ Decision: i < len(bits)-1?\n    Yes → Decision: bits[i] == 0?\n        Yes → Step 2: i ← i + 1\n        No  → Step 3: i ← i + 2\n        → Decision: i < len(bits)-1? // 迴圈\n            Yes → (回到上一 Decision) // 迴圈\n            No  → // 退出\n    No  → Decision: i == len(bits)-1?\n        Yes → Step 4: return true\n        No  → Step 5: return false\nEnd\n\nBut we must keep comments after each line.\n\nOk, I'll produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化指標為陣列起點\n→ Decision: i < len(bits)-1? // 判斷是否還有至少兩位可處理\n    Yes → Decision: bits[i] == 0? // 檢查目前位元\n        Yes → Step 2: i ← i + 1 // 0 為一位字元，指標右移一位\n        No  → Step 3: i ← i + 2 // 10 或 11 為兩位字元，指標右移兩位\n        → Decision: i < len(bits)-1? // 重新判斷是否繼續\n            Yes → (回到上一 Decision) // 迴圈回到判斷條件\n            No  → // 退出循環\n    No  → Decision: i == len(bits)-1? // 判斷最後一位是否為一位字元\n        Yes → Step 4: return true // 必定為一位字元\n        No  → Step 5: return false // 不是一位字元\nEnd // 程式結束\n```"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\n# Colors in fixed order for consistent indexing\nCOLORS = ['R', 'Y', 'B', 'G', 'W']\nINF = 10 ** 9\n\ndef collapse(s: str) -> str:\n    \"\"\"\n    Repeatedly remove any group of 3 or more consecutive same-colored balls.\n    \"\"\"\n    while True:\n        n = len(s)\n        i = 0\n        removed = False\n        new_s_parts = []\n        while i < n:\n            j = i\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:\n                # Skip this group -> it's removed\n                removed = True\n            else:\n                new_s_parts.append(s[i:j])\n            i = j\n        if not removed:\n            break\n        s = ''.join(new_s_parts)\n    return s\n\ndef find_min_steps(board: str, hand: str) -> int:\n    \"\"\"\n    Return the minimal number of insertions needed to clear the board,\n    or -1 if impossible.\n    \"\"\"\n    # Count balls in hand\n    hand_count = [hand.count(c) for c in COLORS]\n    memo = {}\n\n    def dfs(cur_board: str, cnt: tuple) -> int:\n        # Base cases\n        if not cur_board:\n            return 0\n        if all(c == 0 for c in cnt):\n            return INF\n\n        key = (cur_board, cnt)\n        if key in memo:\n            return memo[key]\n\n        min_steps = INF\n        n = len(cur_board)\n\n        # Iterate over each group in the board\n        i = 0\n        while i < n:\n            j = i\n            while j < n and cur_board[j] == cur_board[i]:\n                j += 1\n            color = cur_board[i]\n            group_len = j - i\n            color_idx = COLORS.index(color)\n            # Try inserting the same color to form a group of 3\n            needed = 3 - group_len\n            if needed <= cnt[color_idx]:\n                # Insert needed balls at position i\n                new_board = cur_board[:i] + color * needed + cur_board[i:]\n                new_board = collapse(new_board)\n                new_cnt = list(cnt)\n                new_cnt[color_idx] -= needed\n                steps = dfs(new_board, tuple(new_cnt))\n                if steps != INF:\n                    min_steps = min(min_steps, 1 + steps)\n            i = j\n\n        memo[key] = min_steps\n        return min_steps\n\n    result = dfs(board, tuple(hand_count))\n    return -1 if result == INF else result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract strings inside double quotes\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        board_input, hand_input = matches[0], matches[1]\n    else:\n        # Fallback: split by commas if quotes not present\n        parts = data.split(',')\n        board_input = parts[0].split('=')[1].strip().strip('\"').strip(\"'\")\n        hand_input = parts[1].split('=')[1].strip().strip('\"').strip(\"'\")\n\n    answer = find_min_steps(board_input, hand_input)\n    print(answer)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode step by step. It's a variation of Zuma. Problem: given board string and hand string, find minimal insertions to clear board or -1. Classic Leetcode 488 Zuma Game. Approach: DFS with state memoization; using backtracking; for each color count in hand; try inserting into board at each position; simulate removal chain; compute result.\n\nWe need to produce pseudocode lines. Use Start, End, Decision etc. Each line with comment.\n\nWe need to produce pseudocode but not actual code. Just virtual steps.\n\nWe need to cover algorithm: Build hand count map; define DFS(board, handCount). Base: if board empty return 0. If all hand empty return INF. If state in memo return value. For each index in board, find group start and end; color. For each possible color insertion that has at least 1 ball in hand: if color matches group color, need to compute needed = 3 - groupLen; if needed <= count then we can insert needed; else skip. For each insertion, compute new board after removal: simulate collapse: remove group then merge adjacent same color and repeat until no group >=3. Then recursively call DFS on new board with updated handCount. Keep min.\n\nReturn min or INF.\n\nEdge: if min==INF return -1.\n\nWe need to produce pseudocode lines with steps, decisions etc. Also we need to include comments. Let's produce pseudocode in a linear fashion. Use \"→\" for next step. Use Decision lines.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". So each line must include comment.\n\nWe'll start with Start, then steps: preprocess hand counts, define DFS, etc.\n\nWe can structure:\n\nStart // program entry\n→ Initialize handCount map // count balls by color\n→ Define DFS(board, handCount) // recursive function\n    ... (inside)\n→ Call DFS(board, handCount) // get result\n→ If result INF -> output -1 else output result\nEnd // finished\n\nInside DFS: many steps. We can use nested lines? The pseudocode format requires each line separate. We can indent? Example format uses indentation like \"    Yes → ...\". We can use that style.\n\nSo produce:\n\n→ Decision: if board empty? Yes → Return 0 // no balls left\n                No → ...\n\n→ Decision: if hand empty? Yes → Return INF // cannot clear\n\n→ Check memo: if (board, handCount) in memo? Yes → Return memo value\n\n→ Initialize minSteps = INF // track minimum\n\n→ For each position i from 0 to len(board) - 1:\n    → Find j = i; while j < len(board) and board[j] == board[i]: j++ // group end\n    → groupColor = board[i]\n    → groupLen = j - i\n    → For each color c in handCount with count>0:\n        → Decision: if c != groupColor? No -> continue // skip colors not needed\n        → needed = 3 - groupLen\n        → Decision: if needed <= handCount[c]? Yes → ...\n            ... else skip\n\nBut we can just simplify: For each color available, we consider insertion if needed <= count.\n\nWe need to create new board: newBoard = board[0:i] + c * needed + board[i:]; then collapse.\n\nSimulate collapse: while True: find any group of length>=3 in newBoard; if none break; else remove those groups, update newBoard, repeat.\n\nAfter collapse, newHandCount = handCount; newHandCount[c] -= needed\n\nThen recursive steps: result = DFS(newBoard, newHandCount); if result != INF: minSteps = min(minSteps, 1 + result)\n\nAfter loop: memo[board, handCount] = minSteps; return minSteps\n\nAfter DFS: If result == INF -> return -1 else result.\n\nWe need to produce each line as per requirement. Might need to be careful with decision branches.\n\nLet's craft pseudocode accordingly.\n\nAlso, for simulation of collapse, we may use a helper function collapse(board). We can treat it as a step.\n\nWe can include that as separate step: collapse(newBoard) // collapse chain removal\n\nWe'll produce code.\n\nLet's produce the output now.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize handCount map from hand string // 取得手牌中各顏色球的數量  \n→ Define DFS(board, handCount) // 以遞迴方式搜尋最小插入數  \n    → Decision: 如果 board 為空?  \n        Yes → Return 0 // 盤面已被清空，成功  \n        No →  \n    → Decision: 如果手牌已空且 board 非空?  \n        Yes → Return INF // 無法再進行插入，返回無限大  \n        No →  \n    → Decision: 若 (board, handCount) 在 memo 中?  \n        Yes → Return memo[board, handCount] // 回傳已計算結果  \n        No →  \n    → Set minSteps = INF // 追蹤最小步數  \n    → For i from 0 to length(board)-1: // 逐個位置嘗試插入  \n        → Set j = i  \n        → While j < length(board) and board[j] == board[i]: j++ // 找到同色區塊結束  \n        → groupColor = board[i]  \n        → groupLen = j - i  \n        → For each color c in handCount with count>0: // 逐顏色嘗試  \n            → Decision: 若 c != groupColor?  \n                Yes → Continue // 僅插入同色以形成 3 個以上  \n                No →  \n            → needed = 3 - groupLen // 需要插入幾個球才能消除區塊  \n            → Decision: needed <= handCount[c]?  \n                Yes →  \n                    → newBoard = board[0:i] + c * needed + board[i:] // 插入球  \n                    → newBoard = collapse(newBoard) // 連鎖消除  \n                    → newHandCount = handCount; newHandCount[c] -= needed // 更新手牌  \n                    → result = DFS(newBoard, newHandCount) // 進一步遞迴  \n                    → Decision: result != INF?  \n                        Yes → minSteps = min(minSteps, 1 + result) // 更新最小步數  \n                        No →  \n                No → Continue // 這顏色不足以插入  \n    → memo[board, handCount] = minSteps // 記錄結果  \n    → Return minSteps // 回傳此狀態的最小插入數  \n→ Call DFS(initialBoard, handCount) // 啟動遞迴搜尋  \n→ Set answer = result from DFS  \n→ Decision: answer == INF?  \n    Yes → Output -1 // 無法清空盤面  \n    No → Output answer // 最小插入數  \nEnd // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk40c8uj2.py\", line 40, in <module>\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk40c8uj2.py\", line 35, in parse_input\n    return ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {nums1 = [1,2,2,1], nums2 = [2,2]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5am7u_ya.py\", line 40, in <module>\n    data = parse_input(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5am7u_ya.py\", line 35, in parse_input\n    return ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {nums1 = [4,9,5], nums2 = [9,4,9,8,4]}\n     ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        Return the intersection of two integer lists, including duplicates\n        as many times as they appear in both lists.\n        \"\"\"\n        count1 = Counter(nums1)\n        count2 = Counter(nums2)\n        result = []\n        # Iterate over the smaller counter for efficiency\n        if len(count1) > len(count2):\n            count1, count2 = count2, count1\n        for num in count1:\n            if num in count2:\n                result.extend([num] * min(count1[num], count2[num]))\n        return result\n\ndef parse_input(text):\n    \"\"\"\n    Parse a string that contains assignments like:\n    'nums1 = [1,2,2,1], nums2 = [2,2]'\n    into a dictionary {'nums1': [...], 'nums2': [...]}.\n    \"\"\"\n    # Remove newlines and surrounding whitespace\n    text = text.strip().replace('\\n', ' ')\n    if not text:\n        return {}\n    # Wrap the assignments in braces to form a dictionary literal\n    dict_str = '{' + text + '}'\n    # Use ast.literal_eval for safe evaluation\n    return ast.literal_eval(dict_str)\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read()\n    data = parse_input(raw_input)\n    # Extract the two lists; default to empty lists if not provided\n    nums1 = data.get('nums1', [])\n    nums2 = data.get('nums2', [])\n    # Compute intersection and print the result\n    sol = Solution()\n    intersection = sol.intersect(nums1, nums2)\n    print(intersection)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with steps and explanations. Format: each line \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. Let's outline algorithm: Use hash map to count freq in nums1, then iterate nums2, if count > 0 add to result, decrement count. Return result array. We'll generate steps accordingly.\n\nWe need to produce a list of virtual code steps. Use \"Start //\". \"→\" to denote flow.\n\nLet's create:\n\nStart\n→ Step 1: 初始化哈希表 countMap // 统计 nums1 的元素出现次数\n→ Step 2: 遍历 nums1，将每个数计入 countMap\n→ Step 3: 初始化结果列表 result // 用于存放交集\n→ Step 4: 遍历 nums2 // 检查每个元素是否在 countMap 中且计数>0\n    → Decision: countMap 中该元素计数 > 0? // 判断是否能加入结果\n        Yes → Step 5: 将该元素添加到 result // 交集元素\n        Yes → Step 6: 将 countMap 中该元素计数减 1 // 处理重复出现\n        No  → Step 7: 跳过该元素 // 不满足条件\n→ Step 8: 返回 result // 输出交集数组\nEnd\n\nNeed to ensure \"Yes →\" and \"No →\" each line with indentation.\n\nLet's craft.\n\nAlso need to maintain formatting: use arrow for each step, but within decision, the Yes and No branches.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化空哈希表 countMap // 用於存儲 nums1 中每個元素的出現次數\n→ Step 2: 對 nums1 中的每個元素 num 做:\n    → Action: 如果 countMap 中已存在 num, 則將其值加 1\n    → Action: 否則將 countMap[num] 設為 1\n→ Step 3: 初始化空列表 result // 用於存放交集元素\n→ Step 4: 對 nums2 中的每個元素 num 做:\n    → Decision: countMap[num] 存在且 > 0? // 是否能加入交集\n        Yes → Step 5: 把 num 添加到 result // 加入交集\n        Yes → Step 6: 把 countMap[num] 減 1 // 更新剩餘次數\n        No  → Step 7: 跳過該元素 // 不符合條件\n→ Step 8: 回傳 result // 結束並返回交集結果\nEnd // 程式執行結束\n\nBut the format requires each line \"虛擬碼步驟 // 解釋\" and using arrows and structure. The indentation lines within decision may also be separate lines.\n\nMake sure to use \"Decision:\" line then branches. So maybe:\n\n→ Decision: countMap[num] 存在且 > 0? // 判斷元素是否能加入結果\n    Yes → Step 5: 把 num 添加到 result // 加入交集\n    Yes → Step 6: 把 countMap[num] 減 1 // 更新次數\n    No  → Step 7: 跳過該元素 // 不符合條件\n\nBut we cannot have duplicate \"Yes\". Typically we have two branches: Yes and No. Here we need two actions on Yes. We could split into two separate steps within Yes: first add, second decrement. But arrow for each. Might have two Yes lines.\n\nLet's produce as:\n\n→ Decision: countMap[num] 存在且 > 0? // 判斷元素是否能加入結果\n    Yes → Step 5: 把 num 添加到 result // 加入交集\n    Yes → Step 6: 把 countMap[num] 減 1 // 更新次數\n    No  → Step 7: 跳過該元素 // 不符合條件\n\nBut there might be confusion: two Yes lines, same condition. It's fine, as each step after Yes.\n\nAlternatively we can combine into one step: but we need two operations. It's okay.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 countMap // 用於存儲 nums1 中每個元素的出現次數  \n→ Step 2: 對 nums1 中的每個元素 num 做:  \n  → Action: 若 countMap[num] 存在，將其值加 1  \n  → Action: 否則將 countMap[num] 設為 1  \n→ Step 3: 初始化空列表 result // 用於存放交集元素  \n→ Step 4: 對 nums2 中的每個元素 num 做:  \n  → Decision: countMap[num] 存在且 > 0? // 判斷元素是否能加入結果  \n   Yes → Step 5: 把 num 添加到 result // 加入交集  \n   Yes → Step 6: 把 countMap[num] 減 1 // 更新剩餘次數  \n   No  → Step 7: 跳過該元素 // 不符合條件  \n→ Step 8: 回傳 result // 結束並返回交集結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppa6_94oi.py\", line 30, in <module>\n    nums = ast.literal_eval(value)\n           ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        dp = [0] * (target + 1)\n        dp[0] = 1  # 基本情況：有一種方法到達目標 0\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入（可以包含換行）\n    raw_input = sys.stdin.read().strip().replace(\"\\n\", \" \")\n    if not raw_input:\n        sys.exit()\n\n    # 解析類似 \"nums = [1,2,3], target = 4\" 的格式\n    # 將分號或逗號分隔的片段拆開\n    parts = raw_input.split(\",\")\n    nums = []\n    target = 0\n    for part in parts:\n        key, value = part.split(\"=\", 1)\n        key = key.strip()\n        value = value.strip()\n        if key == \"nums\":\n            nums = ast.literal_eval(value)\n        elif key == \"target\":\n            target = int(value)\n\n    solution = Solution()\n    result = solution.combinationSum4(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for the problem: count combinations of distinct integers (each can be used unlimited times? Wait typical problem \"Combination Sum IV\" uses unlimited uses of each element. The phrase \"combinations\" maybe order matters? Usually in this problem (target sum combinations) the answer counts number of sequences where order matters (like coin change with permutations). It's typical dynamic programming. So we need to produce steps: DP array dp[0..target], dp[0]=1. For each i from 1 to target, for each num in nums, if i>=num: dp[i]+=dp[i-num]. Finally return dp[target]. Should mention distinct integers in nums. So produce lines. Use Start, End, Decision. Each line includes virtual code step and explanation. Also include arrows.\n\nWe produce step by step lines. Eg:\n\nStart // 程式開始\n\n→ Step 1: 建立 dp 陣列長度 target+1，並初始化 dp[0] = 1, 其餘為 0 // 用於存放到每個子目標的組合數\n\n→ Step 2: 迭代 i 從 1 到 target // 逐個計算子目標\n\n    → Step 3: 迭代每個 num 在 nums // 嘗試把 num 加入子目標\n\n        → Decision: 如果 i >= num? // 確認 num 可用於組合\n\n            Yes → Step 4: dp[i] += dp[i-num] // 若可用，累加前面子目標的組合數\n\n            No → Step 5: 跳過此 num // 不可用則不做任何事\n\n→ Step 6: 返回 dp[target] // 最終答案\n\nEnd // 程式結束\n\nMake sure each line ends with // 解釋. Use virtual arrows accordingly. The \"Decision\" line might need indentation. Provide structure. Use '→ Decision: ...' and then indent Yes/No lines with some spaces or arrow? Example from example: Yes → ... etc.\n\nWe should keep each line separate. Let's generate.\n\nAlso, we might include step to sort nums? Not necessary. Also mention that we can use unlimited times.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 初始化 dp 陣列長度為 target+1，並設定 dp[0] = 1，其餘元素設為 0 // 建立子目標的組合數表  \n→ Step 2: 從 i = 1 到 target 逐個迭代 // 依序計算每個子目標  \n    → Step 3: 對於 nums 中的每一個 num 進行迭代 // 嘗試將該數字加入子目標  \n        → Decision: i >= num? // 判斷 num 是否能被放入當前子目標  \n            Yes → Step 4: dp[i] = dp[i] + dp[i-num] // 若能，累加前面子目標的組合數  \n            No  → Step 5: 跳過此 num // 若不能，直接忽略此數字  \n→ Step 6: 回傳 dp[target] // 最終返回所有組合的總數  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # overlap\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i - 1][0] <= left and right <= self.ranges[i - 1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef main():\n    lines = [line.strip() for line in sys.stdin.read().splitlines() if line.strip()]\n    outputs = []\n    rng_module = None\n\n    for line in lines:\n        if 'new RangeModule' in line:\n            rng_module = RangeModule()\n            outputs.append('null')\n        elif '.addRange(' in line:\n            nums = list(map(int, re.findall(r'-?\\d+', line)))\n            rng_module.addRange(nums[0], nums[1])\n            outputs.append('null')\n        elif '.removeRange(' in line:\n            nums = list(map(int, re.findall(r'-?\\d+', line)))\n            rng_module.removeRange(nums[0], nums[1])\n            outputs.append('null')\n        elif '.queryRange(' in line:\n            nums = list(map(int, re.findall(r'-?\\d+', line)))\n            res = rng_module.queryRange(nums[0], nums[1])\n            outputs.append('true' if res else 'false')\n        else:\n            # ignore unknown lines\n            pass\n\n    print('[' + ', '.join(outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. We need to interpret requirement: design data structure to track ranges half-open. Provide operations addRange, queryRange, removeRange. Use virtual code lines with explanations.\n\nWe need to produce \"逐行\" pseudocode lines, each line with arrow notation and explanation. We'll design using an interval tree or sorted list of intervals. Provide high-level steps for each operation.\n\nThe user wants virtual code; no actual code. We need to produce something like:\n\nStart\n→ Step: 初始化區間集合為空\n→ Decision: 任何操作?\n\nBut we might show methods.\n\nWe should produce a clear step-by-step algorithm.\n\nProbably produce pseudocode that uses a sorted list of disjoint intervals. Outline addRange, queryRange, removeRange.\n\nWe should produce a linear flow for each method.\n\nMaybe we produce pseudo code for entire class: constructor, addRange, queryRange, removeRange.\n\nLet's craft:\n\nStart\n→ Step 1: RangeModule() // 建立空的區間列表\n→ Step 2: addRange(left,right) // 進入添加區間\n→ Decision: 查找重疊區間\n...\nBut we need to be explicit.\n\nLet's produce separate pseudo code for each method. Each step line with explanation. Use arrow for flow.\n\nUse \"→\" for normal steps, \"Decision:\" lines for conditionals, \"Yes →\", \"No →\" for branches.\n\nWe need to be careful to maintain each line as separate.\n\nLet's produce something like:\n\nStart // 程式開始執行\n\n→ Step: 初始化 intervals 為空有序列表 // 用來儲存已追蹤的區間\n\nThen method definitions: maybe we list each method block separately.\n\nMethod: addRange(left, right)\n\nWe'll describe algorithm: find first interval with end > left, merge all overlapping or adjacent intervals, insert new merged interval.\n\nBut we should keep pseudocode simple: iterate over intervals, find overlapping, adjust left/right, remove overlapped, etc.\n\nSimilarly queryRange: find interval that covers left, and check if interval's end >= right.\n\nRemoveRange: similar to add but remove overlapping parts.\n\nWe should produce a pseudocode representation.\n\nOk let's produce.\n\nWe need to output the lines exactly.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: intervals ← [] // 空的區間列表\n\nThen we might list methods as separate blocks.\n\nMethod: addRange\n→ Step: addRange(left,right) // 新增區間\n\nBut we might keep all inside one flow.\n\nHowever the requirement: \"逐行產生對應的虛擬碼\" maybe for the entire class, including methods. We can output pseudocode lines for the class definition and each method.\n\nWe should keep each line separate.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step: 初始化 intervals 為空列表 // 用來儲存已追蹤的區間\n\n→ Step: 定義 addRange(left, right) // 進入新增區間\n\nWithin addRange:\n\n→ Step: idx ← 第一個 intervals[i].end > left 的索引 // 找到可能重疊的起始位置\n\n→ Decision: idx 是否存在? // 確認有沒有區間可以參考\n\nIf exists, else.\n\nBut we need to illustrate loops.\n\nOk maybe we can use pseudocode like:\n\n→ Step: i ← 0\n→ Decision: i < intervals.length and intervals[i].end < left? // 区间结束在左侧，跳过\n    Yes → i ← i+1 // 跳过\n    No  → // i 指向可能重叠区间或右侧第一个\n\nThen merge.\n\nThis is a bit messy.\n\nAlternative: use high-level logic: \"while current interval overlaps, merge\".\n\nBut we need to maintain each line.\n\nMaybe easier: use pseudocode for operations with conceptual steps.\n\nWe can produce:\n\naddRange:\n→ Step: new_left ← left\n→ Step: new_right ← right\n→ Step: i ← 0\n→ Decision: i < intervals.length? // 迭代区间列表\n    Yes →\n        → Decision: intervals[i].end < new_left? // 区间在左侧，未重叠\n            Yes → i ← i+1\n            No →\n                → Decision: intervals[i].start > new_right? // 区间在右侧，停止\n                    Yes → // 插入新区间\n                        → Step: intervals.insert(i, [new_left, new_right])\n                        → Step: return\n                    No →\n                        → Step: new_left ← min(new_left, intervals[i].start)\n                        → Step: new_right ← max(new_right, intervals[i].end)\n                        → Step: intervals.remove(i) // 删除已合并的区间\n                        → Step: // 继续检查下一个相同索引\n    No  → // 迭代完毕，插入新区间\n        → Step: intervals.append([new_left, new_right])\n\nThis may be enough.\n\nSimilarly for queryRange: find interval containing left.\n\n→ Step: i ← 0\n→ Decision: i < intervals.length? \n   Yes →\n        → Decision: intervals[i].end < left? // interval ends before left\n            Yes → i ← i+1\n            No →\n                → Decision: intervals[i].start <= left? // interval starts before left\n                    Yes →\n                        → Decision: intervals[i].end >= right? // covers right\n                            Yes → return true\n                            No  → return false\n                    No → // left before interval start\n                        → return false\n   No → return false\n\nRemoveRange: similar to addRange but splits.\n\nPseudo:\n\n→ Step: i ← 0\n→ Decision: i < intervals.length? // iterate\n    Yes →\n        → Decision: intervals[i].end <= left? // interval ends before left\n            Yes → i ← i+1\n            No →\n                → Decision: intervals[i].start >= right? // interval starts after right\n                    Yes → // all remaining intervals are beyond removal range\n                        → return\n                    No →\n                        → // There is overlap\n                        → Decision: intervals[i].start < left? // left inside interval\n                            Yes →\n                                → Step: left_interval ← [intervals[i].start, left]\n                                → Step: // keep left part\n                            No →\n                                → // left part not kept\n                        → Decision: intervals[i].end > right? // right inside interval\n                            Yes →\n                                → Step: right_interval ← [right, intervals[i].end]\n                                → Step: // keep right part\n                            No →\n                                → // right part not kept\n                        → Step: intervals.remove(i) // remove original interval\n                        → // insert left_interval if exists\n                        → Step: if left_interval exists: intervals.insert(i, left_interval); i←i+1\n                        → // insert right_interval if exists\n                        → Step: if right_interval exists: intervals.insert(i, right_interval)\n                        → // continue loop with i unchanged\n    No → // done\n\nOk.\n\nWe must output lines each with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow, etc.\n\nLet's produce final answer accordingly.\n\nWe should use Chinese explanation.\n\nMake sure to use \"Start\" and \"End\".\n\nWe'll separate methods but within same block? It's okay.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: intervals ← [] // 初始化一個空的有序區間列表，用來儲存已追蹤的區間  \n\n---  \n// ----------  addRange  ----------  \n→ Step: addRange(left, right) // 進入新增區間的流程  \n→ Step: new_left ← left // 以左端點作為新區間的起點  \n→ Step: new_right ← right // 以右端點作為新區間的終點  \n→ Step: i ← 0 // 從列表最左側開始掃描  \n→ Decision: i < intervals.length? // 是否還有區間可檢查？  \n    Yes →  \n        → Decision: intervals[i].end < new_left? // 目前區間完全在新區間左側，無重疊  \n            Yes → i ← i + 1 // 跳過這個區間  \n            No →  \n                → Decision: intervals[i].start > new_right? // 目前區間完全在新區間右側，掃描完畢  \n                    Yes →  \n                        → Step: intervals.insert(i, [new_left, new_right]) // 在此位置插入合併後的區間  \n                        → Step: return // 完成新增  \n                    No →  \n                        → Step: new_left ← min(new_left, intervals[i].start) // 取最小左端點  \n                        → Step: new_right ← max(new_right, intervals[i].end) // 取最大右端點  \n                        → Step: intervals.remove(i) // 刪除已被合併的舊區間  \n                        → // 仍在同一索引處檢查下一個可能重疊的區間  \n    No →  \n        → Step: intervals.append([new_left, new_right]) // 列表已掃描完畢，直接追加區間  \n→ End // addRange 完成  \n\n---  \n// ----------  queryRange  ----------  \n→ Step: queryRange(left, right) // 進入查詢區間的流程  \n→ Step: i ← 0 // 從列表最左側開始搜尋  \n→ Decision: i < intervals.length? // 是否還有區間可比對？  \n    Yes →  \n        → Decision: intervals[i].end < left? // 目前區間結束在左端點之前  \n            Yes → i ← i + 1 // 跳過此區間  \n            No →  \n                → Decision: intervals[i].start <= left? // 左端點落在此區間內  \n                    Yes →  \n                        → Decision: intervals[i].end >= right? // 區間同時覆蓋右端點  \n                            Yes → Step: return true // 完全覆蓋，查詢成功  \n                            No  → Step: return false // 無法覆蓋右端點，查詢失敗  \n                    No → Step: return false // 左端點在此區間左側，無法覆蓋  \n    No → Step: return false // 所有區間已掃描完，仍未找到覆蓋，查詢失敗  \n→ End // queryRange 完成  \n\n---  \n// ----------  removeRange  ----------  \n→ Step: removeRange(left, right) // 進入移除區間的流程  \n→ Step: i ← 0 // 從最左側區間開始  \n→ Decision: i < intervals.length? // 是否還有區間可檢查？  \n    Yes →  \n        → Decision: intervals[i].end <= left? // 目前區間結束在左端點之前，無影響  \n            Yes → i ← i + 1 // 跳過此區間  \n            No →  \n                → Decision: intervals[i].start >= right? // 目前區間開始在右端點之後，剩餘區間全不受影響  \n                    Yes → Step: return // 所有後續區間已不在移除範圍內，結束  \n                    No →  \n                        → // 有重疊，需調整或拆分  \n                        → Step: left_part ← null // 用於存儲左側保留區間  \n                        → Step: right_part ← null // 用於存儲右側保留區間  \n                        → Decision: intervals[i].start < left? // 左端點落在本區間內  \n                            Yes →  \n                                → Step: left_part ← [intervals[i].start, left] // 保留左側片段  \n                            No → // 不保留左側片段  \n                        → Decision: intervals[i].end > right? // 右端點落在本區間內  \n                            Yes →  \n                                → Step: right_part ← [right, intervals[i].end] // 保留右側片段  \n                            No → // 不保留右側片段  \n                        → Step: intervals.remove(i) // 刪除原本重疊的區間  \n                        → // 依序插入保留片段（若存在）  \n                        → Decision: left_part ≠ null?  \n                            Yes →  \n                                → Step: intervals.insert(i, left_part)  \n                                → Step: i ← i + 1 // 左片段已插入，下一個索引移動  \n                            No → // 無左片段，索引不變  \n                        → Decision: right_part ≠ null?  \n                            Yes →  \n                                → Step: intervals.insert(i, right_part) // 右片段插入（位於左片段之後）  \n                                → // i 仍指向此位置，繼續檢查下一個區間  \n                            No → // 無右片段，繼續檢查下一個區間  \n    No → // 所有區間已掃描完畢，結束  \n→ End // removeRange 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2s92ka1n.py\", line 64, in <module>\n    ops = ast.literal_eval(lines[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n                                                                                                                                                ^\nSyntaxError: unexpected character after line continuation character"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0   # front index\n        self.count = 0  # current number of elements\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n\n    lines = data.strip().splitlines()\n    ops = ast.literal_eval(lines[0].strip())\n    vals = ast.literal_eval(lines[1].strip())\n\n    obj = None\n    out = []\n\n    for op, val in zip(ops, vals):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(val[0])\n            out.append(None)\n        elif op == \"insertFront\":\n            out.append(obj.insertFront(val[0]))\n        elif op == \"insertLast\":\n            out.append(obj.insertLast(val[0]))\n        elif op == \"deleteFront\":\n            out.append(obj.deleteFront())\n        elif op == \"deleteLast\":\n            out.append(obj.deleteLast())\n        elif op == \"getFront\":\n            out.append(obj.getFront())\n        elif op == \"getRear\":\n            out.append(obj.getRear())\n        elif op == \"isEmpty\":\n            out.append(obj.isEmpty())\n        elif op == \"isFull\":\n            out.append(obj.isFull())\n\n    print(json.dumps(out))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for MyCircularDeque class with specified methods. Each line with // explanation. Use Start, End, Decision, arrow. Likely include initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Need to simulate circular buffer. Represent using array of size k, head index, tail index, count.\n\nWe'll produce pseudo-code:\n\nStart MyCircularDeque constructor\n-> Step: set size = k\n-> Step: create array of size k\n-> Step: set head = 0\n-> Step: set tail = 0\n-> Step: set count = 0\nEnd\n\nInsertFront:\n-> Decision: if isFull? // if full cannot insert\n   Yes → Return false\n   No → Step: set head = (head - 1 + size) mod size\n   Step: array[head] = value\n   Step: count++\n   Return true\n\nInsertLast similar.\n\nDeleteFront: if empty return false\n else set head = (head + 1) mod size, count--, return true.\n\nDeleteLast: similar.\n\ngetFront: if empty return -1 else return array[head].\n\ngetRear: if empty return -1 else index = (tail - 1 + size) mod size, return array[index].\n\nisEmpty: return count == 0\n\nisFull: return count == size\n\nNeed to produce lines with \"虛擬碼步驟\" and explanation.\n\nProbably use Start/End around class definition and each method block.\n\nLet's craft step-by-step.\n\nWe'll prefix each line with arrow '→' except Start and End.\n\nNeed to include class name? Could show 'MyCircularDeque' as start block.\n\nWill produce:\n\nStart MyCircularDeque // 開始定義循環雙端佇列類別\n\n→ Constructor(k) // 建構函式\n\n... etc.\n\nBut need to follow formatting: each line has \"虛擬碼步驟\" and // explanation.\n\nWe'll not output actual code, just pseudo steps.\n\nLet's produce:\n\nStart MyCircularDeque // 程式開始定義 MyCircularDeque 類別\n→ Constructor(k) // 初始化 deque，參數 k 為最大容量\n    → Step: size ← k // 記錄容量\n    → Step: data ← new array of length k // 儲存元素\n    → Step: head ← 0 // 前端指標\n    → Step: tail ← 0 // 後端指標\n    → Step: count ← 0 // 目前元素數\n→ insertFront(val) // 在前端插入元素\n    → Decision: isFull()？ // 檢查是否已滿\n        Yes → Return false // 插入失敗\n        No  →\n            → Step: head ← (head - 1 + size) mod size // 前移指標\n            → Step: data[head] ← val // 存值\n            → Step: count ← count + 1 // 元素數加一\n            → Return true // 插入成功\n→ insertLast(val) // 在後端插入元素\n    → Decision: isFull()？\n        Yes → Return false\n        No  →\n            → Step: data[tail] ← val\n            → Step: tail ← (tail + 1) mod size\n            → Step: count ← count + 1\n            → Return true\n→ deleteFront() // 從前端刪除元素\n    → Decision: isEmpty()？\n        Yes → Return false\n        No  →\n            → Step: head ← (head + 1) mod size\n            → Step: count ← count - 1\n            → Return true\n→ deleteLast() // 從後端刪除元素\n    → Decision: isEmpty()？\n        Yes → Return false\n        No  →\n            → Step: tail ← (tail - 1 + size) mod size\n            → Step: count ← count - 1\n            → Return true\n→ getFront() // 取得前端元素\n    → Decision: isEmpty()？\n        Yes → Return -1\n        No  →\n            → Return data[head]\n→ getRear() // 取得後端元素\n    → Decision: isEmpty()？\n        Yes → Return -1\n        No  →\n            → Step: index ← (tail - 1 + size) mod size\n            → Return data[index]\n→ isEmpty() // 判斷是否為空\n    → Return count == 0\n→ isFull() // 判斷是否為滿\n    → Return count == size\nEnd MyCircularDeque // 結束定義 MyCircularDeque 類別\n\nNeed to make sure each line includes \"虛擬碼步驟\" e.g., \"Constructor(k)\". Use arrow before each step? Format: \"→ Step: ...\" For decision lines we need \"Decision: ...\".\n\nWe'll maintain consistent formatting. Use \"Decision:\" lines indented. For lines inside decision, use \"Yes →\" and \"No →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart MyCircularDeque // 程式開始定義 MyCircularDeque 類別  \n→ Constructor(k) // 建構函式，k 為最大容量  \n → Step: size ← k // 記錄容量  \n → Step: data ← new array of length k // 儲存元素  \n → Step: head ← 0 // 前端指標  \n → Step: tail ← 0 // 後端指標  \n → Step: count ← 0 // 目前元素數  \n→ insertFront(val) // 在前端插入元素  \n → Decision: isFull()? // 檢查是否已滿  \n  Yes → Return false // 插入失敗  \n  No  →  \n    → Step: head ← (head - 1 + size) mod size // 前移指標  \n    → Step: data[head] ← val // 存值  \n    → Step: count ← count + 1 // 元素數加一  \n    → Return true // 插入成功  \n→ insertLast(val) // 在後端插入元素  \n → Decision: isFull()?  \n  Yes → Return false  \n  No  →  \n    → Step: data[tail] ← val // 存值  \n    → Step: tail ← (tail + 1) mod size // 後移指標  \n    → Step: count ← count + 1 // 元素數加一  \n    → Return true  \n→ deleteFront() // 從前端刪除元素  \n → Decision: isEmpty()? // 檢查是否為空  \n  Yes → Return false // 刪除失敗  \n  No  →  \n    → Step: head ← (head + 1) mod size // 前端指標後移  \n    → Step: count ← count - 1 // 元素數減一  \n    → Return true // 刪除成功  \n→ deleteLast() // 從後端刪除元素  \n → Decision: isEmpty()?  \n  Yes → Return false  \n  No  →  \n    → Step: tail ← (tail - 1 + size) mod size // 後端指標前移  \n    → Step: count ← count - 1 // 元素數減一  \n    → Return true  \n→ getFront() // 取得前端元素  \n → Decision: isEmpty()?  \n  Yes → Return -1 // 空時回傳 -1  \n  No  →  \n    → Return data[head] // 回傳前端值  \n→ getRear() // 取得後端元素  \n → Decision: isEmpty()?  \n  Yes → Return -1  \n  No  →  \n    → Step: index ← (tail - 1 + size) mod size // 後端索引  \n    → Return data[index] // 回傳後端值  \n→ isEmpty() // 判斷是否為空  \n → Return count == 0  \n→ isFull() // 判斷是否為滿  \n → Return count == size  \nEnd MyCircularDeque // 程式執行結束定義 MyCircularDeque 類別"
    },
    {
      "title": "Mini Parser",
      "source_file": "Leetcode/leetcode385.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[123,[456,[789]]]'\nGot (Norm):      '[123,[456,[789],[789]],[456,[789],[789]]]'\n--- (Raw) ---\nRaw Expected: '[123,[456,[789]]]'\nRaw Got:      '[123,[456,[789],[789]],[456,[789],[789]]]'"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass NestedInteger:\n    \"\"\"\n    A minimal implementation of the NestedInteger interface used in\n    LeetCode problem 385.  Each instance can hold either a single integer\n    or a nested list of NestedInteger objects.\n    \"\"\"\n    def __init__(self, value=None):\n        if value is None:\n            self._list: List[NestedInteger] = []\n            self._integer = None\n        elif isinstance(value, int):\n            self._list = None\n            self._integer = value\n        else:\n            raise ValueError(\"NestedInteger can only be initialized with None or int\")\n\n    def isInteger(self) -> bool:\n        \"\"\"Return True if this NestedInteger holds a single integer.\"\"\"\n        return self._integer is not None\n\n    def add(self, elem: \"NestedInteger\") -> None:\n        \"\"\"Add a NestedInteger element to this list.\"\"\"\n        if self.isInteger():\n            raise ValueError(\"Cannot add to a NestedInteger that holds a single integer\")\n        self._list.append(elem)\n\n    def setInteger(self, value: int) -> None:\n        \"\"\"Set this NestedInteger to hold a single integer.\"\"\"\n        self._integer = value\n        self._list = None\n\n    def getInteger(self):\n        \"\"\"Return the single integer that this NestedInteger holds, or None.\"\"\"\n        return self._integer\n\n    def getList(self):\n        \"\"\"Return the list that this NestedInteger holds, or None.\"\"\"\n        return self._list\n\n    def __str__(self) -> str:\n        \"\"\"Serialize the NestedInteger back to the format used in the problem.\"\"\"\n        if self.isInteger():\n            return str(self._integer)\n        return \"[\" + \",\".join(str(x) for x in self._list) + \"]\"\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        \"\"\"\n        Deserialize a string that represents a nested list into a NestedInteger object.\n        \"\"\"\n        if not s:\n            return NestedInteger()\n\n        # If the string does not start with '[', it represents a single integer.\n        if s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack: List[NestedInteger] = []\n        num_buffer = \"\"\n        negative = False\n\n        for ch in s:\n            if ch == '[':\n                # Start a new list; push it onto the stack\n                new_list = NestedInteger()\n                if stack:\n                    stack[-1].add(new_list)\n                stack.append(new_list)\n                num_buffer = \"\"\n                negative = False\n            elif ch == ']':\n                # Finish current number if any\n                if num_buffer:\n                    value = -int(num_buffer) if negative else int(num_buffer)\n                    stack[-1].add(NestedInteger(value))\n                    num_buffer = \"\"\n                    negative = False\n                # Close the current list\n                if len(stack) > 1:\n                    finished = stack.pop()\n                    stack[-1].add(finished)\n            elif ch == ',':\n                # Separator between elements; finalize any pending number\n                if num_buffer:\n                    value = -int(num_buffer) if negative else int(num_buffer)\n                    stack[-1].add(NestedInteger(value))\n                    num_buffer = \"\"\n                    negative = False\n            elif ch == '-':\n                negative = True\n            else:  # digit\n                num_buffer += ch\n\n        # After the loop, there might be a number left (for the outermost list)\n        if num_buffer:\n            value = -int(num_buffer) if negative else int(num_buffer)\n            stack[-1].add(NestedInteger(value))\n\n        return stack[0]\n\ndef main():\n    \"\"\"\n    Read input from stdin, deserialize it, and print the serialized form.\n    The input format is expected to be something like:\n        s = \"[123,[456,[789]]]\"\n    The quotes around the string are part of the input.\n    \"\"\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Extract the string literal between the first and last double quotes.\n    first_quote = raw_input.find('\"')\n    last_quote = raw_input.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = raw_input[first_quote + 1:last_quote]\n    else:\n        # Fallback: if no quotes, use the whole trimmed input\n        s = raw_input\n\n    solution = Solution()\n    result = solution.deserialize(s)\n    print(str(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for parsing a string serialization of nested lists, similar to LeetCode 385 Nested List Parser. Provide step by step virtual code lines with explanation comments. We need to parse string s, use stack, etc. Provide start, steps. No actual code, only virtual steps. Let's produce a thorough flow: Start, parse char by char, handle digits, negative sign, open bracket '[' push new list, close ']' pop and add to previous, etc. Also handle single integer string. Provide final nested integer. Also decision steps. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 s // 取得要被反序列化的字串\n\n→ Decision: s 是否為純數字? // 判斷整個字串是否只包含一個整數\n    Yes → Step 2: 建立 NestedInteger 並以 s 轉成整數為值 // 直接回傳單一整數\n    No  → Step 3: 初始化 stack 為空堆疊 // 用於存放尚未完成的 NestedInteger\n\n→ Step 4: 將字串 s 以字元陣列陣列化 // 方便逐字檢查\n→ Step 5: 定義 currentNumber 為空字串 // 用於累積多位數字\n→ Step 6: 定義 isNegative 為 false // 標記負數\n\n→ Loop: for each character ch in s\n    → Decision: ch 是否為 '['? // 開啟新子列表\n        Yes →\n            → Step 7: 若 currentNumber 非空，將其轉為數字並加入堆疊頂層 // 處理前面緊跟著的數字\n            → Step 8: 建立新 NestedInteger list\n            → Step 9: 若 stack 非空，將此新 list 加入堆疊頂層\n            → Step 10: 推進堆疊，將新 list 作為堆疊頂層\n            → Step 11: 重置 currentNumber, isNegative\n        No →\n            → Decision: ch 是否為 ']'? // 關閉當前子列表\n                Yes →\n                    → Step 12: 若 currentNumber 非空，將其轉為數字並加入堆疊頂層\n                    → Step 13: 若 isNegative 為 true，將數字乘 -1\n                    → Step 14: 取出堆疊頂層 list，pop\n                    → Step 15: 若 stack 非空，將此 list 加入新的堆疊頂層\n                    → Step 16: 重置 currentNumber, isNegative\n                No →\n                    → Decision: ch 是否為 ','? // 分隔符，表示已完成一個元素\n                        Yes →\n                            → Step 17: 若 currentNumber 非空，將其轉為數字並加入堆疊頂層\n                            → Step 18: 若 isNegative 為 true，將數字乘 -1\n                            → Step 19: 重置 currentNumber, isNegative\n                        No →\n                            → Decision: ch 是否為 '-'? // 負號標記\n                                Yes →\n                                    → Step 20: 設置 isNegative 為 true\n                                No →\n                                    → Step 21: 將 ch 加到 currentNumber // 累積數字字元\n\n→ EndLoop // 逐字檢查完畢\n\n→ Decision: currentNumber 是否非空? // 最後一個數字未被處理\n    Yes →\n        → Step 22: 若 isNegative 為 true，將 currentNumber 乘 -1\n        → Step 23: 建立 NestedInteger 並加入堆疊頂層\n    No  → No action\n\n→ Step 24: 若 stack 非空，stack.top 為最外層 NestedInteger // 結束時堆疊只剩一個元素\n→ Step 25: 取出並回傳 stack.top // 反序列化完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprs9sxayh.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmprs9sxayh.py\", line 40, in main\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return node.is_end\n            if word[i] == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if word[i] not in node.children:\n                    return False\n                return dfs(node.children[word[i]], i + 1)\n        return dfs(self.root, 0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, args = json.loads(data)\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            results.append(None)\n        elif op == \"search\":\n            results.append(obj.search(arg[0]))\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for a WordDictionary with addWord and search, supporting wildcard '.' . This is classic trie with DFS. Provide line-by-line virtual code with arrows. Provide explanation in Chinese. No actual code. Should be structured. Let's produce steps:\n\nStart\n→ Step 1: Initialize root node with children dict and isEnd flag // Trie root\n→ Step 2: addWord(word): iterate chars, traverse/create child nodes, set isEnd at end // Add word\n→ Step 3: search(word): call helper function searchFrom(node, index) // Recursively search\n→ Step 4: helper(node, index): if index==len(word): return node.isEnd // reached end\n→ Step 5: char = word[index]\n    Decision: char is '.' ?\n        Yes → For each child in node.children:\n                  if searchFrom(child, index+1): return True\n               return False // no child matched\n        No → if char in node.children:\n                 return searchFrom(node.children[char], index+1)\n               else return False // no matching child\n→ End\n\nWe need to produce with arrow indentation. Use '→' for sequential steps, 'Decision:' for branching. Each line with comment. Ensure format matches example: \"Start // 程式開始執行\" etc. We must use '虛擬碼步驟' and comment. Use same format. Provide each line. Use arrow '→' before step lines. Use indentation maybe spaces. Provide consistent. Use Chinese explanations.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 Trie 根節點，包含 children map 與 isEnd 標誌 // 初始化資料結構\n→ Step 2: 定義 addWord(word) // 方法開始\n    → Step 2.1: node ← root // 從根開始\n    → Step 2.2: for 每個字元 c in word: // 遍歷字串\n        → Decision: c 是否已存在於 node.children?\n            Yes → node ← node.children[c] // 移動到已有節點\n            No  → node.children[c] ← 新節點 // 新增節點\n    → Step 2.3: node.isEnd ← True // 設定單字結束標誌\n→ Step 3: 定義 search(word) // 方法開始\n    → Decision: 直接呼叫 helper(root, 0) // 由根節點遞迴搜尋\n        Yes → return helper(root, 0)\n→ Step 4: 定義 helper(node, idx) // 內部遞迴函式\n    → Decision: idx == len(word)?\n        Yes → return node.isEnd // 完全匹配時檢查結束標誌\n        No  → char ← word[idx] // 取當前字元\n        → Decision: char 是否為 '.' ?\n            Yes → // '.' 可以匹配任意字母\n                → For 每個 child 在 node.children.values():\n                    → Decision: helper(child, idx+1) 為 True?\n                        Yes → return True // 任一分支匹配成功\n                → return False // 無分支匹配\n            No  → // 正常字母\n                → Decision: char 是否存在於 node.children?\n                    Yes → return helper(node.children[char], idx+1) // 直接遞迴\n                    No  → return False // 沒有對應節點\n→ End // 程式執行結束\n\nMake sure each line has format: \"→ Step 1: ...\" with comment. For indentation, we can use spaces before arrow? The example uses a single arrow for each line, with indentation for decisions. We'll replicate that.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Trie 根節點，包含 children map 與 isEnd 標誌 // 初始化資料結構  \n\n→ Step 2: 定義 addWord(word) // 方法開始  \n    → Step 2.1: node ← root // 從根節點開始  \n    → Step 2.2: for 每個字元 c in word: // 遍歷字串  \n        → Decision: c 是否已存在於 node.children?  \n            Yes → node ← node.children[c] // 移動到已存在節點  \n            No  → node.children[c] ← 新節點 // 新增節點  \n    → Step 2.3: node.isEnd ← True // 標記單字結束  \n\n→ Step 3: 定義 search(word) // 方法開始  \n    → Decision: 直接呼叫 helper(root, 0) // 由根節點遞迴搜尋  \n        Yes → return helper(root, 0)  \n\n→ Step 4: 定義 helper(node, idx) // 內部遞迴函式  \n    → Decision: idx == len(word)?  \n        Yes → return node.isEnd // 完全匹配時檢查結束標誌  \n        No  → char ← word[idx] // 取當前字元  \n    → Decision: char 是否為 '.' ?  \n        Yes → // '.' 可以匹配任意字母  \n            → For 每個 child 在 node.children.values():  \n                → Decision: helper(child, idx+1) 為 True?  \n                    Yes → return True // 任一分支匹配成功  \n            → return False // 無分支匹配  \n        No  → // 正常字母  \n            → Decision: char 是否存在於 node.children?  \n                Yes → return helper(node.children[char], idx+1) // 直接遞迴  \n                No  → return False // 沒有對應節點  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_dbrfder.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmp_dbrfder.py\", line 41, in main\n    args = json.loads('[' + second)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 48 (char 47)"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiewq773_.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpiewq773_.py\", line 41, in main\n    args = json.loads('[' + second)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 49 (char 48)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass KthLargest:\n    \"\"\"\n    用最小堆（size k）維護第 k 大元素。\n    \"\"\"\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        # 先把所有初始數字塞進堆中\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        \"\"\"\n        新增一個分數，並回傳目前的第 k 大元素。\n        \"\"\"\n        heapq.heappush(self.min_heap, val)\n        # 如果堆長度超過 k，丟掉最小的那個\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        # 堆的頂端就是第 k 大元素\n        return self.min_heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，預期兩行：方法名與對應參數\n    parts = data.splitlines()\n    if len(parts) >= 2:\n        methods = json.loads(parts[0].strip())\n        args = json.loads(parts[1].strip())\n    else:\n        # 若輸入僅一行，使用逗號分隔的方法與參數\n        first, second = data.split('],', 1)\n        methods = json.loads(first + ']')\n        args = json.loads('[' + second)\n\n    results = []\n    obj = None\n\n    for method, arg in zip(methods, args):\n        if method == 'KthLargest':\n            k, nums = arg\n            obj = KthLargest(k, nums)\n            results.append(None)          # 建構子對應 null\n        elif method == 'add':\n            val = arg[0]\n            results.append(obj.add(val))\n\n    # 輸出結果，JSON 會自動把 None 轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing KthLargest class with initialization and add method, using a min-heap of size k to maintain kth largest. Virtual code lines with arrow. Need to be clear: Start, Step 1: Define class, etc.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's produce flow: Start -> Define class KthLargest(k, nums) -> Initialize minHeap size k -> Insert first k elements into heap -> For remaining nums, if val > heap.min, replace. Then add method: if heap size < k, push val; else if val > heap.min, replace. Return heap.min. Use decisions.\n\nWe'll structure: Start // Begin program\n\n→ Step: 定義 KthLargest 類別 // 宣告類別\n→ Step: 成員變數: k, minHeap // 儲存 k 與小根堆\n\n→ Decision: 初始化時是否已有 nums? // 進行初始化\n\n    Yes → → Step: 將 nums 前 k 個元素插入 minHeap // 建立堆\n    Yes → → Step: 對於 nums 後續元素，如果大於 minHeap.min，替換並調整堆 // 保持堆大小 k\n    Yes → → Step: 這樣完成建構\n\n→ Step: 定義 add(val) 方法 // 新增分數\n\n    → Decision: minHeap.size < k? // 若堆還未滿\n        Yes → → Step: 將 val 插入 minHeap // 放入\n        Yes → → Step: 返回 minHeap.min // 目前 kth 大\n\n    → Decision: val > minHeap.min? // 若新值大於堆最小\n        Yes → → Step: 替換 minHeap.min 為 val // 更新堆\n        Yes → → Step: 返回 minHeap.min\n        No  → → Step: 返回 minHeap.min // 仍為 kth 大\n\nEnd // 結束\n\nMake sure arrow syntax as requested: \"→\" for normal steps, \"Decision:\" for decisions, with Yes → and No → inside.\n\nLet's write each line separately. Use Chinese. We'll include spaces after arrow. Also each line must have the comment after space. We'll follow format exactly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 定義 KthLargest 類別 // 建立一個類別來維護 kth 大\n→ Step: 成員變數: k, minHeap // k 表示順位, minHeap 是小根堆\n→ Step: 建構子 KthLargest(k, nums) 初始化 k 和 minHeap // 構造函式\n→ Decision: nums 是否存在? // 確認輸入陣列\n    Yes → → Step: 把 nums 的前 k 個元素插入 minHeap // 先填滿堆\n    Yes → → Step: 對 nums 後續元素若 val > minHeap.min，取代並重建堆 // 保持堆大小為 k\n    Yes → → Step: 初始化完成\n→ Step: 定義 add(val) 方法 // 新增分數並返回 kth 大\n    → Decision: minHeap.size < k? // 堆還未滿 k\n        Yes → → Step: 把 val 插入 minHeap // 直接加入\n        Yes → → Step: 返回 minHeap.min // 目前的 kth 大\n    → Decision: val > minHeap.min? // 新分數是否比堆最小大\n        Yes → → Step: 把 minHeap.min 替換為 val // 更新堆\n        Yes → → Step: 返回 minHeap.min // 更新後的 kth 大\n        No  → → Step: 返回 minHeap.min // 沒有變更，仍為 kth 大\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzav1vf1n.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpzav1vf1n.py\", line 49, in main\n    result = solver.complexNumberMultiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzav1vf1n.py\", line 28, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmpzav1vf1n.py\", line 19, in parse\n    raise ValueError(f\"無法解析複數字串: {s}\")\nValueError: 無法解析複數字串: 1+-1i"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"\n        將兩個複數字串相乘，輸出格式仍為 'real+imaginaryi'。\n        \"\"\"\n        def parse(s: str):\n            \"\"\"\n            解析形如 'real+imaginaryi' 或 'real-imaginaryi'（也可能是\n            'real+-imaginaryi' 之類的）字串，回傳 (real, imag) 整數。\n            \"\"\"\n            s = s.strip()\n            # 正則表達式分離實部與虛部\n            pattern = re.compile(r'^([+-]?\\d+)([+-]\\d+)i$')\n            m = pattern.match(s)\n            if not m:\n                raise ValueError(f\"無法解析複數字串: {s}\")\n            real = int(m.group(1))\n            imag_str = m.group(2)\n            # 若虛部前帶 + 號，去除後面可能的 - 號\n            if imag_str[0] == '+':\n                imag_str = imag_str[1:]\n            imag = int(imag_str)\n            return real, imag\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        # (a+bi)(c+di) = (ac - bd) + (ad + bc)i\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 期望輸入格式如： \"1+1i\", \"1+1i\"\n    # 先去除雙引號，再以逗號分隔\n    parts = [p.strip() for p in data.replace('\"', '').split(',')]\n    if len(parts) != 2:\n        raise ValueError(\"輸入格式錯誤，應為兩個複數字串\")\n    num1, num2 = parts[0], parts[1]\n\n    solver = Solution()\n    result = solver.complexNumberMultiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for multiplying two complex numbers given as strings like \"a+bi\". Steps: parse numbers, multiply: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Output as string \"real+imaginaryi\". Handle signs? Input format always \"real+imaginaryi\" maybe with negative? It says real and imaginary integer ranges -100 to 100. Likely format always includes '+' between real and imaginary part, e.g., \"1+1i\". Negative imaginary part would be \"1-1i\"? but they say \"real+imaginaryi\" where imaginary is integer, could be negative so string would be \"1-1i\". So parsing should detect sign before imaginary. Steps: parse real part: from start until '+' or '-' that is part of imaginary. Easiest: split by 'i' then split left part by last '+' or '-'. We'll produce pseudocode with decisions.\n\nWe need to output lines with virtual code + explanation.\n\nLet's structure: Start, parse num1, parse num2, compute real, imag, format output, End.\n\nUse Decision: For parsing, identify sign of imaginary.\n\nLet's write step by step.\n\nAlso ensure arrow representation.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 num1, num2 // 取得兩個複數字串  \n→ Step 2: 解析 num1 為 (a, b)  \n    → Decision: num1 是否包含 '-' 作為 imaginary 的符號？  \n        Yes → Step 3a: 找到最後一個 '+' 或 '-' 並分割為 realPart, imagPart（去掉 trailing 'i'）  \n            → Step 4a: a ← 整數化 realPart  \n            → Step 5a: b ← 整數化 imagPart  \n        No  → Step 3b: 分割方式同上（即使符號為 '+'）  \n            → Step 4b: a ← 整數化 realPart  \n            → Step 5b: b ← 整數化 imagPart  \n→ Step 6: 解析 num2 為 (c, d)  // 同上步驟  \n    → Decision: num2 是否包含 '-' 作為 imaginary 的符號？  \n        Yes → Step 7a: 分割為 realPart2, imagPart2  \n            → Step 8a: c ← 整數化 realPart2  \n            → Step 9a: d ← 整數化 imagPart2  \n        No  → Step 7b: 分割為 realPart2, imagPart2  \n            → Step 8b: c ← 整數化 realPart2  \n            → Step 9b: d ← 整數化 imagPart2  \n→ Step 10: 計算實部 realResult ← a * c - b * d // (ac - bd)  \n→ Step 11: 計算虛部 imagResult ← a * d + b * c // (ad + bc)  \n→ Step 12: 產生輸出字串 output  \n    → Decision: imagResult 是否為負？  \n        Yes → Step 13a: output ← concatenate realResult, imagResult, 'i'（負號已包含於 imagResult）  \n        No  → Step 13b: output ← concatenate realResult, '+', imagResult, 'i'  \n→ Step 14: 輸出 output // 回傳乘法結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\", \"root/4.txt\"]]'"
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"Return groups of duplicate file paths based on file content.\"\"\"\n        content_map = defaultdict(list)\n        for entry in paths:\n            parts = entry.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content.rstrip(')')  # remove trailing ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n        # Filter only groups that have more than one file\n        return [paths for paths in content_map.values() if len(paths) > 1]\n\ndef main():\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # Extract the list expression after '=' if present\n    if '=' in raw_input:\n        raw_input = raw_input.split('=', 1)[1].strip()\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception as e:\n        # If parsing fails, print empty list\n        print(\"[]\")\n        return\n    sol = Solution()\n    result = sol.findDuplicate(paths)\n    # Output as JSON string to match expected double-quoted format\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc. We need to describe algorithm: parse input list, for each directory info string, split by space: first part path, rest files. For each file: extract name and content inside parentheses. Build mapping content->list of paths. Finally iterate mapping and collect lists with len>=2. Output list.\n\nWe need to write step-by-step in pseudocode with arrows. We'll produce steps. Use \"Start\" then \"→\" lines. For decisions, use Decision:.\n\nWe should be concise. Use \"Step\" labels.\n\nLet's produce virtual code.\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\".\n\nWe can use arrow \"→\" to indicate steps, \"Decision:\" for branching.\n\nWe should maybe include \"Initialize\" etc.\n\nOk produce.\n\nWe'll include:\n\nStart\n\n→ Step 1: Initialize map contentToPaths = {} // map content string to list of file paths\n\n→ Step 2: For each dirInfo in paths // iterate input list\n\n→ Step 3: Split dirInfo by space into parts // separate directory path and file entries\n\n→ Decision: parts length > 0? // ensure valid\n\nYes → Step 4: dirPath = parts[0] // directory path\n\n→ Step 5: For each fileEntry in parts[1..] // iterate files\n\n→ Step 6: Parse fileEntry to get fileName and content // split at '(' and ')'\n\n→ Step 7: filePath = dirPath + '/' + fileName // construct full path\n\n→ Step 8: If content not in contentToPaths: create empty list\n\n→ Step 9: Append filePath to contentToPaths[content] // add path\n\nAfter loops\n\n→ Step 10: Initialize result = []\n\n→ Step 11: For each entry in contentToPaths\n\n→ Decision: entry.value.size >= 2? // duplicate group\n\nYes → Step 12: Append entry.value to result // add group to result\n\nEnd\n\nAdd comments each line.\n\nMake sure each line contains space between code and // explanation. Provide arrows. Let's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 map contentToPaths = {} // 建立內容到檔案路徑的對應表  \n→ Step 2: 對於每個 dirInfo 在 paths 之中 // 遍歷所有目錄資訊字串  \n→ Step 3: 將 dirInfo 以空格拆分為 parts // 第一項為目錄路徑，其餘為檔案資訊  \n→ Decision: parts 內是否至少有 1 個元素? // 檢查拆分結果有效  \n Yes → Step 4: dirPath = parts[0] // 取得目錄路徑  \n Yes → Step 5: 對於每個 fileEntry 在 parts[1..] 之中 // 遍歷該目錄下的所有檔案  \n  → Step 6: 解析 fileEntry 取得 fileName 與 content // 以 '(' 與 ')' 分割得到檔名與內容  \n  → Step 7: filePath = dirPath + '/' + fileName // 組成完整檔案路徑  \n  → Decision: content 是否已存在於 contentToPaths? // 判斷該內容是否已被記錄  \n   Yes → Step 8: contentToPaths[content].append(filePath) // 若存在，加入此路徑  \n   No  → Step 9: contentToPaths[content] = [filePath] // 若不存在，建立新列表並加入路徑  \n→ Step 10: 初始化 result = [] // 用於存放重複檔案的分組  \n→ Step 11: 對於每個 entry 在 contentToPaths 之中 // 遍歷內容到路徑的對應表  \n→ Decision: entry.value.size >= 2? // 判斷是否為重複檔案組  \n Yes → Step 12: result.append(entry.value) // 若至少兩個路徑，加入結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz6g_5xdr.py\", line 24, in <module>\n    main()\n  File \"/tmp/tmpz6g_5xdr.py\", line 20, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmpz6g_5xdr.py\", line 7, in rand10\n    r1 = rand7()\n         ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpntepi6ut.py\", line 24, in <module>\n    main()\n  File \"/tmp/tmpntepi6ut.py\", line 20, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmpntepi6ut.py\", line 7, in rand10\n    r1 = rand7()\n         ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppcgs6et9.py\", line 24, in <module>\n    main()\n  File \"/tmp/tmppcgs6et9.py\", line 20, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmppcgs6et9.py\", line 7, in rand10\n    r1 = rand7()\n         ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def rand10(self):\n        while True:\n            r1 = rand7()\n            r2 = rand7()\n            val = (r1 - 1) * 7 + r2  # 1-49\n            if val <= 40:\n                return 1 + (val - 1) % 10\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    sol = Solution()\n    result = [sol.rand10() for _ in range(n)]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating rand10() using rand7(). Classic solution: use two rand7 calls to generate 49 outcomes, reject >40, map 1-40 to 1-10.\n\nWe need to produce step-by-step pseudo-code with arrow notation. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc. Use arrows: →. Provide explanation per line.\n\nWe need to ensure it's clear. Let's design:\n\nStart\n→ Generate r1 = rand7() // first random\n→ Generate r2 = rand7() // second random\n→ Combine to produce value: val = (r1-1)*7 + r2 // yields 1-49\n→ Decision: if val <= 40? // only accept first 40\n    Yes → Step: result = (val-1)%10 +1 // map to 1-10\n    No  → Go back to start // reject and retry\n→ Return result\nEnd\n\nBut need to maintain the loop structure: perhaps use a while loop. But we must use virtual code lines.\n\nCould also express with a loop:\n\nStart\n→ Decision: loop?\nBut better to show:\n\nStart\n→ Step 1: r1 = rand7()\n→ Step 2: r2 = rand7()\n→ Step 3: val = (r1-1)*7 + r2\n→ Decision: val <= 40?\n    Yes → result = (val-1)%10 +1\n    No  → Go to Step 1 // repeat\n→ Return result\nEnd\n\nBut need arrow to show flow. Use \"→\" for next step, indent inside decision. Provide explanation per line.\n\nAlso we may need to show the retry mechanism. For clarity, we might include \"Repeat\" label.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: r1 ← rand7() // 產生 1~7 的隨機數\n→ Step 2: r2 ← rand7() // 產生第二個 1~7 的隨機數\n→ Step 3: val ← (r1-1)*7 + r2 // 組合得到 1~49 的值\n→ Decision: val ≤ 40? // 只接受前 40 個結果\n    Yes → Step 4: result ← (val-1) mod 10 + 1 // 映射到 1~10\n    No  → Step 1 // 超過 40 時重新開始\n→ Return result // 回傳 1~10 的隨機數\nEnd // 程式結束\n\nBut we should maintain proper arrow format: \"→\" before each step. For decision, we need indent: \"Decision:\" then Yes → etc.\n\nAlso we might need to indicate \"→\" to the next step or branch. Let's write:\n\nStart // 程式開始執行\n→ Step 1: r1 ← rand7() // 產生 1~7 的隨機數\n→ Step 2: r2 ← rand7() // 再次產生 1~7 的隨機數\n→ Step 3: val ← (r1-1)*7 + r2 // 轉換成 1~49 的值\n→ Decision: val ≤ 40? // 只接受前 40 個數字\n    Yes → Step 4: result ← (val-1) mod 10 + 1 // 映射到 1~10\n    No  → Step 1 // 若 >40，重新產生\n→ Return result // 回傳隨機數 1~10\nEnd // 程式結束\n\nBut we need to maintain arrow between steps. Each line includes arrow. The \"Yes →\" and \"No →\" lines include arrow.\n\nLet's produce final answer accordingly.\n\nAlso the request says \"Please do not use a language's built-in random API.\" It's covered.\n\nNow produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: r1 ← rand7() // 產生 1~7 的隨機數\n→ Step 2: r2 ← rand7() // 再次產生 1~7 的隨機數\n→ Step 3: val ← (r1-1)*7 + r2 // 將兩個隨機數合併成 1~49 的值\n→ Decision: val ≤ 40? // 只接受前 40 個結果，以確保均勻分佈\n    Yes → Step 4: result ← (val-1) mod 10 + 1 // 將 1~40 映射到 1~10\n    No  → Step 1 // 超過 40 時丟棄並重新開始\n→ Return result // 回傳 1~10 的隨機數\nEnd // 程式結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2**31 - 1\nINT_MIN = -2**31\n\ndef reverse_int(x: int) -> int:\n    rev = 0\n    while x != 0:\n        pop = x % 10          # 取最後一位（負數也會是負）\n        x //= 10              # 去掉最後一位\n        # 檢查乘 10 再加 pop 是否會造成溢出\n        if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and pop > 7):\n            return 0\n        if rev < INT_MIN // 10 or (rev == INT_MIN // 10 and pop < -8):\n            return 0\n        rev = rev * 10 + pop\n    return rev\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if match:\n        x_val = int(match.group())\n    else:\n        x_val = 0\n    result = reverse_int(x_val)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for reversing 32-bit integer with overflow check, no 64-bit integers allowed. Should detect overflow by checking before pushing digit. Use loop to pop digits, build result. Need to handle negative sign. Steps: initialize sign, convert to positive using abs? but cannot use abs beyond 32-bit? We can handle sign separately. Use x as signed int. Use variable rev = 0. While x != 0: pop = x % 10; x = x / 10. Check overflow: if rev > INT_MAX/10 or (rev == INT_MAX/10 && pop > 7) for positive. For negative: rev < INT_MIN/10 or (rev == INT_MIN/10 && pop < -8). But rev is positive? We'll handle rev as signed int too. Use rev as signed int. For negative x, pop will be negative? In many languages, % with negative gives negative remainder. But we can handle using abs and sign. Better: Work with unsigned? But no 64-bit. Let's do: sign = 1; if x < 0 then sign = -1; x = -x; // careful overflow at INT_MIN can't negate. Instead treat digits: use original x, pop = x % 10; x = x / 10. In languages like C/C++ negative division truncates toward zero, remainder same sign as dividend. Example: -123 % 10 = -3? Actually in C++: -123 / 10 = -12, -123 % 10 = -3. That's fine. rev built as signed. Need overflow checks accordingly. We'll implement: if rev > INT_MAX/10 or (rev == INT_MAX/10 && pop > 7) then overflow. If rev < INT_MIN/10 or (rev == INT_MIN/10 && pop < -8) then overflow. Append rev = rev * 10 + pop.\n\nThis fits 32-bit.\n\nNow produce virtual code line by line with explanation.\n\nLet's produce structure:\n\nStart\n→ Step 1: 定義 INT_MAX = 2147483647, INT_MIN = -2147483648 // 32位整數範圍\n→ Step 2: 初始化 rev = 0 // 儲存反轉後的數\n→ Decision: x 為 0? // 若輸入為 0 直接返回 0\n    Yes → Step 3: 返回 0 // 結束\n    No  → Loop: while x ≠ 0 // 逐位取出 x 的最後一位\n        → Step 4: pop = x % 10 // 取出最後一位\n        → Step 5: x = x / 10 // 去掉最後一位\n        → Decision: 是否會導致溢出? // 檢查加入 pop 後是否超出 32 位範圍\n            Yes → Step 6: 返回 0 // 溢出時返回 0\n            No  → Step 7: rev = rev * 10 + pop // 將 pop 加入 rev\n    → End Loop\n→ Step 8: 返回 rev // 完成反轉\nEnd\n\nBut need arrow structure: Use arrow \"→\" at each step. Use \"Decision:\" lines with Yes →, No → inside.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 INT_MAX = 2147483647, INT_MIN = -2147483648 // 32 位整數最大、最小值  \n→ Step 2: 初始化 rev = 0 // 用於累積反轉後的數值  \n→ Decision: 如果 x 等於 0? // 直接返回 0  \n  Yes → Step 3: 返回 0 // 結束程式  \n  No  → Loop: while x ≠ 0 // 逐位處理 x  \n    → Step 4: pop = x % 10 // 取得 x 的最後一位（負數亦可）  \n    → Step 5: x = x / 10 // 去掉最後一位  \n    → Decision: rev 乘 10 加 pop 後會否溢出?  \n     Yes → Step 6: 返回 0 // 溢出時直接返回 0  \n     No  → Step 7: rev = rev * 10 + pop // 安全累積  \n    → End Loop  \n→ Step 8: 返回 rev // 完成反轉後的數值  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Break II",
      "source_file": "Leetcode/leetcode140.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwqx35fik.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmpwqx35fik.py\", line 40, in main\n    parsed[key] = ast.literal_eval(val)\n                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ['cat'\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnegf2hqd.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmpnegf2hqd.py\", line 40, in main\n    parsed[key] = ast.literal_eval(val)\n                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ['apple'\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2qu_9nzc.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp2qu_9nzc.py\", line 40, in main\n    parsed[key] = ast.literal_eval(val)\n                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ['cats'\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub in backtrack(end):\n                        if sub:\n                            res.append(word + \" \" + sub)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    parts = [p.strip() for p in data.split(',')]\n    parsed = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        parsed[key] = ast.literal_eval(val)\n    s = parsed.get('s', '')\n    wordDict = parsed.get('wordDict', [])\n    result = Solution().wordBreak(s, wordDict)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve word break II problem. Must produce step-by-step virtual code lines with comments. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision: etc.\n\nWe need to produce algorithm: use DFS with memoization or DP.\n\nWe'll produce steps:\n\nStart\n\n→ Step 1: 初始化字典集合 from wordDict // O(1) lookup\n\n→ Step 2: 定義遞迴函式 dfs(start) // 計算從索引 start 開始的所有可能斷句\n\n→ Step 3: Decision: 如果 start 等於 s.length? // 到達字串結束\n\n    Yes → Return list containing empty string // 回傳空句子表示此路徑完成\n\n    No  → Decision: 如果 start 在 memo? // 快取已計算結果\n\n        Yes → Return memo[start] // 直接回傳已存\n\n        No  → Step 4: 初始化 result = empty list\n\n        → Step 5: 迭代 end 位置從 start+1 到 s.length\n\n             → Step 6: substring = s.substring(start, end)\n\n             → Decision: 如果 substring 在字典? // 單詞檢查\n\n                 Yes → Step 7: 子句 = dfs(end) // 取得後續斷句\n\n                 → Step 8: 迭代子句\n\n                      → Step 9: 如果子句 為空字符串\n\n                          Yes → newSentence = substring // 只剩單詞\n\n                          No  → newSentence = substring + \" \" + 子句 // 加上空格\n\n                      → Step 10: result.add(newSentence) // 收集結果\n\n        → Step 11: memo[start] = result // 記錄快取\n\n        → Step 12: Return result\n\n→ Step 13: Call dfs(0) // 開始斷句\n\n→ Step 14: Return list from dfs(0) // 輸出所有句子\n\nEnd\n\nWe must use arrow lines. Provide each line. Use indentation? We need to show decision branches with indent. Use spaces maybe. But format: each line start with arrow or Decision. For branch lines use indentation by spaces.\n\nLet's craft:\n\nStart // 程式開始執行\n\n→ Step 1: 將 wordDict 轉成 hash set dictSet // O(1) 字串查找\n\n→ Step 2: 定義遞迴函式 dfs(start) // 從索引 start 開始拆分\n\n    → Decision: 如果 start == s.length? // 已到結尾\n\n        Yes → Return list containing \"\" // 空句子表示成功\n\n        No  → Decision: 如果 memo.containsKey(start)? // 快取已計算\n\n            Yes → Return memo.get(start) // 回傳已存結果\n\n            No  →\n\n                → Step 3: result = 空列表 // 用於儲存當前起點的所有句子\n\n                → Step 4: 迭代 end 取值從 start+1 到 s.length\n\n                    → Step 5: sub = s.substring(start, end) // 取子字串\n\n                    → Decision: 如果 sub 在 dictSet? // 是合法單字\n\n                        Yes →\n\n                            → Step 6: 後續句子列表 = dfs(end) // 遞歸處理剩餘\n\n                            → Step 7: 迭代後續句子\n\n                                → Step 8: 如果後續句子為 \"\" // 無剩字\n\n                                    Yes → newSent = sub // 只剩此單字\n\n                                    No  → newSent = sub + \" \" + 後續句子 // 加空格\n\n                                → Step 9: result.add(newSent) // 收集\n\n                → Step 10: memo.put(start, result) // 記錄快取\n\n                → Step 11: Return result\n\n→ Step 12: sentences = dfs(0) // 從起始索引拆分\n\n→ End // 程式結束\n\nWe should ensure each line has \"虛擬碼步驟\" followed by comment. Use arrow or decision lines accordingly. We'll keep indentation using 4 spaces maybe.\n\nWe need to show \"→\" before each step; \"Decision:\" lines with Yes → or No → lines. We need to make sure each line includes arrow or \"Decision:\".\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: dictSet = HashSet(wordDict) // 把 dictionary 轉成 hash set 以便 O(1) 檢查  \n→ Step 2: 定義遞迴函式 dfs(start) // 從索引 start 開始拆分 s  \n  Decision: 如果 start == s.length? // 已經到字串結尾  \n   Yes → Return [\"\"] // 回傳空字串表示成功分割  \n   No → Decision: 如果 memo.containsKey(start)? // 看是否已經計算過  \n    Yes → Return memo.get(start) // 直接回傳快取結果  \n    No →  \n     → Step 3: result = [] // 用來收集當前起點的所有句子  \n     → Step 4: 迭代 end 從 start+1 到 s.length  \n      → Step 5: sub = s.substring(start, end) // 取子字串  \n      → Decision: 如果 sub 在 dictSet? // 是合法單字  \n       Yes →  \n        → Step 6: suffixList = dfs(end) // 取得剩餘字串的所有拆分  \n        → Step 7: 迭代 suffixList  \n         → Step 8: 如果 suffix == \"\" // 剩下沒有字  \n          Yes → newSent = sub // 只剩此單字  \n          No → newSent = sub + \" \" + suffix // 加空格後續句子  \n         → Step 9: result.add(newSent) // 收集句子  \n       → Step 10: memo.put(start, result) // 記錄快取  \n      → Step 11: Return result  \n→ Step 12: sentences = dfs(0) // 從字串起始處拆分  \n→ End // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\n\ndef wiggle_sort(nums):\n    n = len(nums)\n    for i in range(n - 1):\n        if i % 2 == 0:\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            if nums[i] < nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 處理形如 \"nums = [1,5,1,1,6,4]\" 的輸入\n    try:\n        if '=' in data:\n            _, expr = data.split('=', 1)\n            nums = eval(expr.strip(), {})\n        else:\n            nums = eval(data.strip(), {})\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    wiggle_sort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for reorder array into wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3]... Standard solution: iterate i from 0 to n-2, if i%2==0 then nums[i] > nums[i+1] swap else nums[i] < nums[i+1] swap. But careful: For wiggle sort: if i%2==0 (even index), need nums[i] < nums[i+1]; if it's not, swap. For odd index, need nums[i] > nums[i+1]; if not, swap.\n\nWe'll produce virtual steps.\n\nAlso mention assumption: array always has valid answer.\n\nWe need each line with virtual code + comment.\n\nLet's produce steps:\n\nStart // start\n→ Step 1: Let n = length of nums // get array size\n→ Step 2: For i from 0 to n-2 // iterate adjacent pairs\n    → Decision: If i is even? // check index parity\n        Yes → Decision: If nums[i] > nums[i+1]? // if current pair violates '<'\n            Yes → Step 3: Swap nums[i] and nums[i+1] // swap to satisfy\n            No → // no action\n        No  → Decision: If nums[i] < nums[i+1]? // for odd indices, need '>'\n            Yes → Step 4: Swap nums[i] and nums[i+1] // swap to satisfy\n            No → // no action\n→ End // finished\n\nWe need to provide each line separately. For loops and decisions, we need to show arrows.\n\nLet's format.\n\nAlso we may include the step numbers for clarity but not necessary.\n\nUse virtual code style: \"Start\", \"Step 1: ...\", \"Decision: ...\", \"Yes → ...\", \"No → ...\".\n\nWe'll provide each line. Let's do it.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = length(nums) // 取得陣列長度  \n→ Step 2: For i = 0 to n-2 // 遍歷相鄰兩個元素  \n    → Decision: i % 2 == 0? // 判斷索引是偶數還是奇數  \n        Yes → Decision: nums[i] > nums[i+1]? // 偶數位需 <，若大則不符  \n            Yes → Step 3: Swap(nums[i], nums[i+1]) // 交換以滿足 nums[i] < nums[i+1]  \n            No → // 已符合條件，無需操作  \n        No  → Decision: nums[i] < nums[i+1]? // 奇數位需 >，若小則不符  \n            Yes → Step 4: Swap(nums[i], nums[i+1]) // 交換以滿足 nums[i] > nums[i+1]  \n            No → // 已符合條件，無需操作  \n→ End // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpev13s3v2.py\", line 81, in <module>\n    main()\n  File \"/tmp/tmpev13s3v2.py\", line 50, in main\n    ops, args = ast.literal_eval(data)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 90, in _convert\n    return tuple(map(_convert, node.elts))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Subscript object at 0x72a23e2f7b50>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"把元素放入主佇列\"\"\"\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"移除並回傳最上層元素\"\"\"\n        if not self.q1:\n            return None\n        # 把除最後一個以外的所有元素移到輔助佇列\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 最後一個元素即為頂部\n        top = self.q1.popleft()\n        # 交換兩個佇列，q1 成為新的主佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return top\n\n    def top(self) -> int:\n        \"\"\"回傳最上層元素但不移除\"\"\"\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_val = self.q1.popleft()\n        # 把頂部元素放回輔助佇列\n        self.q2.append(top_val)\n        # 交換佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return top_val\n\n    def empty(self) -> bool:\n        \"\"\"判斷堆疊是否為空\"\"\"\n        return not self.q1\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：兩個列表，第一個是操作名，第二個是參數\n    ops, args = ast.literal_eval(data)\n\n    stack = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            stack = MyStack()\n            results.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n\n    # 轉成符合題目要求的輸出格式\n    out = []\n    for v in results:\n        if v is None:\n            out.append(\"null\")\n        elif isinstance(v, bool):\n            out.append(\"true\" if v else \"false\")\n        else:\n            out.append(str(v))\n    print(\"[\" + \", \".join(out) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Not actual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrow syntax. We need to implement stack using two queues. Provide steps for class, push, pop, top, empty. Let's produce high-level pseudo steps.\n\nWe need to think of algorithm: use two queues q1 and q2. push: enqueue to q1. pop: move all except last element from q1 to q2, dequeue last element as result, swap q1 and q2. top similar but not remove. empty: check q1 empty.\n\nWe'll write step-by-step with decisions.\n\nAlso mention initialization: q1 empty, q2 empty.\n\nLet's output sequential lines.\n\nMake sure use 'Start' 'End'.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyStack 類別，內部包含兩個佇列 queue1 與 queue2 // 初始化兩個佇列  \n→ Step 2: 檢查 queue1 是否為空，若是則 queue2 亦為空，兩佇列皆為空 // 確保初始狀態  \n→ Step 3: push(x) // 入栈操作  \n    → queue1 入隊 x // 把新元素加入 queue1 的尾部  \n→ Step 4: pop() // 出栈操作  \n    → Decision: 若 queue1 為空? // 若空則直接返回或拋例外  \n        Yes → Return null // 無元素可彈出  \n        No  →  \n            → Decision: 若 queue1 大於 1? // 是否有多於一個元素  \n                Yes →  \n                    → Step 5: 轉移 queue1 前 N-1 個元素到 queue2 // 循環 N-1 次  \n                    → queue1 前置元素 dequeue 為 result // 最後一個元素即為頂部元素  \n                No  →  \n                    → Step 6: queue1 前置元素 dequeue 為 result // 只有一個元素時直接彈出  \n            → Step 7: 交換 queue1 與 queue2 的參照 // 讓 queue1 成為新的主佇列  \n            → Return result // 返回彈出的元素  \n→ Step 8: top() // 取得頂部元素而不移除  \n    → Decision: 若 queue1 為空? // 若空則直接返回或拋例外  \n        Yes → Return null // 無元素  \n        No  →  \n            → Decision: 若 queue1 大於 1?  \n                Yes →  \n                    → Step 9: 轉移 queue1 前 N-1 個元素到 queue2  \n                    → queue1 前置元素 peek 為 topVal // 取得頂部元素但不彈出  \n                    → Step 10: queue1 前置元素 dequeue，並 enqueue 回 queue2 // 保持元素  \n                No  →  \n                    → Step 11: queue1 前置元素 peek 為 topVal // 只有一個元素  \n            → Step 12: 交換 queue1 與 queue2 // 重新整理佇列  \n            → Return topVal // 回傳頂部值  \n→ Step 13: empty() // 判斷是否為空  \n    → Return queue1.isEmpty() // 只需檢查主佇列是否空  \nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self):\n        self.parent = {}\n\n    def find(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        self.parent[self.find(y)] = self.find(x)\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        uf = UnionFind()\n        email_to_name = {}\n\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            email_to_name[first_email] = name\n            for email in acc[1:]:\n                email_to_name[email] = name\n                uf.union(first_email, email)\n\n        groups = defaultdict(list)\n        for email in email_to_name:\n            root = uf.find(email)\n            groups[root].append(email)\n\n        result = []\n        for root, emails in groups.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 若輸入包含等號，取等號右邊的表達式\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n        accounts_str = expr.strip()\n    else:\n        accounts_str = data\n    # 解析字串為 Python 物件\n    accounts = ast.literal_eval(accounts_str)\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Need to use Start, End, Decision, etc. Use arrow lines. Provide simple algorithm: Union-Find to merge emails. Steps: iterate accounts, map email to name, union emails. After all unions, group emails by root, sort, output. Provide line by line.\n\nEnsure each line: 虛擬碼步驟 [space] // 解釋.\n\nUse arrow \"→\" before each step. Use Decision: lines for if. Use Start, End.\n\nLet's produce.\n\nWe can start: Start.\n\n→ Step 1: Initialize UnionFind structure for emails // DSU.\n\n→ Step 2: Initialize email_to_name map // store name.\n\n→ Step 3: For each account in accounts: // iterate accounts.\n\n→ Decision: account has emails? // check.\n\n    Yes → Step 4: first_email = account[1] // first email.\n\n        → Step 5: email_to_name[first_email] = account[0] // name mapping.\n\n        → Step 6: For each email in account[1:]: // iterate emails.\n\n            → Decision: email not in UnionFind? // if first time.\n\n                Yes → Step 7: UnionFind.add(email) // add to DSU.\n\n                No  → (do nothing)\n\n            → Decision: email != first_email? // union with first email.\n\n                Yes → Step 8: UnionFind.union(first_email, email) // merge sets.\n\n                No  → (do nothing)\n\n→ Step 9: Initialize dictionary groups // root -> set of emails.\n\n→ Step 10: For each email in email_to_name: // iterate all emails.\n\n    → Step 11: root = UnionFind.find(email) // find root.\n\n    → Step 12: groups[root].add(email) // add to group.\n\n→ Step 13: Initialize result list // final output.\n\n→ Step 14: For each root, emails in groups.items(): // iterate groups.\n\n    → Step 15: sorted_emails = sorted(emails) // lexicographic.\n\n    → Step 16: name = email_to_name[next(iter(emails))] // get name.\n\n    → Step 17: result.append([name] + sorted_emails) // add to result.\n\n→ End // 程式執行結束.\n\nWe also need to include DSU methods? Might add.\n\nWe can include a Step to define UnionFind class.\n\nBetter: add steps:\n\n→ Step 1: Define UnionFind class with parent map, find, union, add. // DSU.\n\nBut keep simple.\n\nOk produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 UnionFind 類別，包含 parent 映射、find、union 與 add 方法 // 建立並查集以合併電子郵件  \n→ Step 2: 初始化空的 email_to_name 映射 // 用來儲存每個電子郵件對應的姓名  \n→ Step 3: 初始化空的 UnionFind 物件 // 用於合併相同人的電子郵件  \n→ Step 4: 對於 accounts 中的每一筆帳號 // 逐筆處理  \n  → Decision: 這筆帳號是否至少有一個電子郵件？ // 確認帳號內容  \n   Yes → Step 5: first_email ← accounts[i][1] // 取得該帳號的第一封電子郵件  \n    → Step 6: email_to_name[first_email] ← accounts[i][0] // 將姓名儲存到映射  \n    → Step 7: 針對 accounts[i][1:] 中的每一封電子郵件 // 逐個處理  \n      → Decision: email 尚未在 UnionFind 中？ // 第一次出現的郵件  \n       Yes → Step 8: UnionFind.add(email) // 將其加入集合  \n       No  → // 已存在，無需再加  \n      → Decision: email 與 first_email 不同？ // 需要合併  \n       Yes → Step 9: UnionFind.union(first_email, email) // 將兩封郵件合併到同一集合  \n       No  → // 相同郵件，無需合併  \n→ Step 10: 初始化 groups 字典，鍵為根節點，值為對應的電子郵件集合 // 用於分組  \n→ Step 11: 對於 email_to_name 中的每一封電子郵件 // 逐個查找集合根節點  \n  → Step 12: root ← UnionFind.find(email) // 找到其代表節點  \n  → Step 13: 若 groups[root] 未存在，則建立空集合  \n  → Step 14: groups[root].add(email) // 將郵件加入對應組別  \n→ Step 15: 初始化 result 清單 // 儲存合併後的帳號  \n→ Step 16: 對於 groups 中的每一個 (root, emails) // 逐組處理  \n  → Step 17: sorted_emails ← sorted(emails) // 將郵件按字典序排序  \n  → Step 18: name ← email_to_name[next(iter(emails))] // 取任一郵件對應的姓名  \n  → Step 19: result.append([name] + sorted_emails) // 形成一筆帳號資料並加入結果  \n→ End // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdzy9ou9k.py\", line 49, in <module>\n    exec(input_data, {}, env)\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgzjxo43f.py\", line 49, in <module>\n    exec(input_data, {}, env)\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return []\n\n        # BFS 先找最短距離\n        level = {beginWord: 0}\n        parents = defaultdict(list)   # child -> list of parents\n        queue = deque([beginWord])\n        while queue:\n            word = queue.popleft()\n            step = level[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        if new_word not in level:\n                            level[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif level[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        # 若沒有到達 endWord，直接回傳空清單\n        if endWord not in parents:\n            return []\n\n        res = []\n\n        def dfs(path, word):\n            \"\"\"回溯產生所有最短路徑\"\"\"\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        dfs([endWord], endWord)\n        return res\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取完整文字，並執行解析\n    input_data = sys.stdin.read()\n    env = {}\n    exec(input_data, {}, env)\n\n    beginWord = env[\"beginWord\"]\n    endWord = env[\"endWord\"]\n    wordList = env[\"wordList\"]\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines, with explanation after //. The problem is classic Word Ladder II. We need to produce steps: BFS to find distances, then DFS/Backtracking to build paths. Provide virtual code steps line by line.\n\nWe'll design steps: Start, Input words, Preprocess wordList into set, Check endWord in set, BFS to find shortest distances and adjacency mapping, then DFS to build paths using distances. If no path, return empty list. End.\n\nWe need to use arrow syntax.\n\nWe'll write like:\n\nStart\n→ Step 1: 初始化 wordSet = set(wordList)\n→ Decision: 是否 endWord 在 wordSet? Yes → ... else → return empty\n\n→ Step 2: 初始化 queue, distances map, adjacency dict\n→ Step 3: BFS loop\n   ... \nBut each line must be separate, not nested block of many lines. Use indentation maybe not needed; but we can write each action.\n\nBetter to use a linear list of steps, with decisions as separate lines, and Yes/No branches.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 轉換 wordList 為 Set wordSet // 方便 O(1) 搜尋\n→ Decision: endWord 是否在 wordSet? // 確認終點可達\n    Yes → Step 2: 初始化 queue 為 beginWord, distances[beginWord]=0 // BFS 開始\n    No  → Step 3: 回傳空清單 // 無可行路徑\n→ Step 4: 初始化 adjacency dict // 存每個字對應下一層可達字\n→ Step 5: BFS: while queue 非空\n    → Step 6: 取出當前單字 cur\n    → Step 7: 對於 cur 的每一個可能字母替換\n        → Step 8: 生成 newWord\n        → Decision: newWord 是否在 wordSet? // 只考慮字典裡的單字\n            Yes → Decision: distances 是否已經有 newWord? // 是否已探索過\n                Yes → Decision: distances[newWord] 是否等於 distances[cur]+1? // 只保留最短層\n                    Yes → Step 9: adjacency[cur].append(newWord) // 紀錄關聯\n                    No  → No operation\n                No  → Step 10: distances[newWord]=distances[cur]+1\n                → Step 11: adjacency[cur].append(newWord)\n                → Step 12: queue.append(newWord) // 下一層搜尋\n            No  → No operation\n→ Decision: distances 是否含 endWord? // 判斷是否找到終點\n    Yes → Step 13: 初始化結果 list\n    No  → Step 14: 回傳空清單 // 無最短路徑\n→ Step 15: 定義 DFS(current, path)\n    → Decision: current==endWord? // 完成一條路徑\n        Yes → Step 16: 將 copy of path 加入結果\n        No  → Step 17: 對於 next in adjacency[current]\n            → Decision: distances[next]==distances[current]+1? // 確保走最短\n                Yes → Step 18: path.append(next)\n                → Step 19: DFS(next, path)\n                → Step 20: path.pop()\n                No  → No operation\n→ Step 21: 呼叫 DFS(beginWord, [beginWord]) // 開始回溯\n→ Step 22: 回傳結果 // 所有最短序列\nEnd // 程式結束\n\nBut we need each line as a single virtual code step with explanation. The DFS definition counts as one line? Could split.\n\nHowever, we need to use arrows and decisions.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 轉換 wordList 為 Set wordSet // 方便 O(1) 搜尋  \n→ Decision: endWord 是否在 wordSet? // 確認終點可達  \n    Yes → Step 2: 初始化 queue 為 [beginWord], distances[beginWord] = 0 // BFS 開始  \n    No  → Step 3: 回傳空清單 // 無可行路徑  \n→ Step 4: 初始化 adjacency 為空字典 // 存每個字對應下一層可達字  \n→ Step 5: BFS: while queue 非空  \n    → Step 6: 取出 queue 的第一個字 cur // 目前層級的字  \n    → Step 7: 對於 cur 的每一個可能字母位置 i  \n        → Step 8: 對於字母 'a'~'z'  \n            → Step 9: 生成 newWord = cur 取代位置 i 為 該字母 // 產生相鄰字  \n            → Decision: newWord 是否在 wordSet? // 只考慮字典裡的單字  \n                Yes → Decision: distances 是否已經有 newWord? // 是否已探索過  \n                    Yes → Decision: distances[newWord] 是否等於 distances[cur]+1? // 保留最短層  \n                        Yes → Step 10: adjacency[cur].append(newWord) // 紀錄關聯  \n                        No  → No operation  \n                    No  → Step 11: distances[newWord] = distances[cur] + 1  \n                    → Step 12: adjacency[cur].append(newWord)  \n                    → Step 13: queue.append(newWord) // 下一層搜尋  \n                No  → No operation  \n→ Decision: distances 是否含 endWord? // 判斷是否找到終點  \n    Yes → Step 14: 初始化 results 為空清單 // 存儲所有最短路徑  \n    No  → Step 15: 回傳空清單 // 無最短路徑  \n→ Step 16: 定義 DFS(current, path) // 回溯尋找所有路徑  \n    → Decision: current == endWord? // 完成一條路徑  \n        Yes → Step 17: results.append(copy(path)) // 加入結果  \n        No  → Step 18: 對於 next in adjacency[current]  \n            → Decision: distances[next] == distances[current] + 1? // 確保走最短  \n                Yes → Step 19: path.append(next)  \n                → Step 20: DFS(next, path)  \n                → Step 21: path.pop()  \n                No  → No operation  \n→ Step 22: 呼叫 DFS(beginWord, [beginWord]) // 開始回溯  \n→ Step 23: 回傳 results // 所有最短序列  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe_o27r36.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpe_o27r36.py\", line 41, in main\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [10, 20], [15, 25], [20, 30]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyCalendar:\n    \"\"\"\n    Calendar that disallows double bookings.\n    Each booking is a half‑open interval [start, end).\n    \"\"\"\n    def __init__(self):\n        # 存放已預訂的區間，形式 (start, end)\n        self.bookings = []\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"\n        嘗試加入一個新的事件。\n        若與任何已存在的事件重疊則返回 False，否則加入並返回 True。\n        \"\"\"\n        for s, e in self.bookings:\n            # 兩個區間重疊的判斷：max(s, start) < min(e, end)\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\n\ndef main() -> None:\n    \"\"\"\n    主函式，從標準輸入讀取 LeetCode 樣式的測試用例，\n    執行相應操作，並以 JSON‑style 文字列輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析兩個列表：操作名與參數\n    # 例子: '[\"MyCalendar\", \"book\", ...], [[], [10,20], ...]'\n    parts = data.split('], ', 1)\n    ops_part = parts[0] + ']'      # 加回閉括號\n    args_part = '[' + parts[1]     # 加上開括號\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    outputs = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendar\":\n            obj = MyCalendar()\n            outputs.append(None)          # constructor 的返回值對應 null\n        else:\n            res = getattr(obj, op)(*arg)\n            outputs.append(res)\n\n    # 將結果轉成 LeetCode 樣式的輸出：null / true / false\n    out_str = '[' + ', '.join(\n        'null' if v is None else 'true' if v is True else 'false' if v is False else str(v)\n        for v in outputs\n    ) + ']'\n    print(out_str)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: use array/list of intervals; for each book, check if overlaps existing intervals; if none, add. Or could use BST. But keep simple. We'll design pseudo:\n\nStart\n→ Step: Initialize list of intervals // empty list\n→ Function book(start, end):\n    → Step: For each interval in list:\n        → Decision: If start < interval.end && end > interval.start? // overlap condition\n            Yes → Step: Return false // double booking\n    → Step: Append [start, end] to list\n    → Step: Return true\nEnd\n\nWe should write in virtual code style. Provide each line with explanation. Use arrows.\n\nLet's produce line by line. Use 'Start', 'End', 'Decision', etc. Also show function declaration. Use '→' arrow for steps. Also show 'Yes →', 'No →'. Provide comments.\n\nLet's craft.\n\nUse \"Start // 程式開始執行\" etc.\n\nWe need to include function definitions inside pseudocode. We might show:\n\n→ Step 1: Define class MyCalendar // 定義日曆類別\n→ Step 2: Declare intervals = [] // 存放已預訂的區間\n\n→ Function book(start, end) // 方法：預訂事件\n\nWithin function:\n\n→ Step 3: For each (s, e) in intervals:\n    → Decision: start < e AND end > s? // 檢查是否重疊\n        Yes → Step 4: Return false // 造成雙重預訂\n        No  → Continue // 沒有重疊，檢查下一個\n\n→ Step 5: Append (start, end) to intervals // 無衝突，加入\n→ Step 6: Return true\n\nWe also need to include Start and End for class? maybe not.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MyCalendar // 建立日曆物件  \n→ Step 2: intervals ← [] // 用空陣列存放已預訂區間  \n\n→ Function book(start, end) // 方法：嘗試預訂新事件  \n    → Step 3: 對每個 (s, e) 在 intervals 中執行  \n        → Decision: start < e 且 end > s? // 判斷是否與已預訂區間重疊  \n            Yes → Step 4: Return false // 發現重疊，拒絕預訂  \n            No  → Step 5: 繼續檢查下一個區間 // 沒重疊，繼續循環  \n    → Step 6: intervals.append((start, end)) // 所有檢查無誤，加入新區間  \n    → Step 7: Return true // 成功預訂  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,6,4,6,1,1,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 6, 4, 6, 1, 1, 6]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\ndef main():\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n    ops = json.loads(lines[0])\n    args_list = json.loads(lines[1])\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            method = getattr(obj, op)\n            # args is a list of arguments for the method\n            results.append(method(*args))\n\n    # Output as JSON to match expected format (null for None)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line with explanation comments. No actual code, just virtual code. Provide steps for initialization and pick. Use Start/End, Decision, etc. Should reflect algorithm: map blacklisted numbers < M to allowed numbers >= M; precompute mapping and M = n - len(blacklist). In pick, random integer from 0..M-1, if mapping exists then return mapping value else return index. Provide explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input n, blacklist // 取得總範圍長度和黑名單\n→ Step 2: M ← n − count(blacklist) // 計算可選數量（合法數的數目）\n→ Step 3: Create empty hash map remap // 用來把黑名單中 < M 的數映射到合法的 ≥ M 整數\n→ Step 4: cur ← n − 1 // 從最大值開始，準備映射至合法數\n→ Step 5: For each b in blacklist sorted ascending // 處理黑名單中的每個數\n    → Decision: 如果 b < M? // 僅對低於 M 的黑名單數進行映射\n        Yes → Decision: 如果 cur in blacklist? // 若 cur 也在黑名單，需遞減\n            Yes → cur ← cur − 1 // 遞減直到找到非黑名單數\n            No  → remap[b] ← cur // 把 b 映射到合法的 cur\n        No  → Skip // 高於 M 的黑名單不需要映射\n→ Step 6: End For // 映射表完成\n→ End // 初始化結束\n\nStart // 程式開始執行\n→ Step 7: r ← random_int(0, M − 1) // 取得 0 到 M-1 的隨機整數\n→ Decision: 如果 r in remap? // 檢查 r 是否為黑名單映射鍵\n    Yes → Return remap[r] // 若是，返回映射到合法數的值\n    No  → Return r // 若不是，直接返回 r（已是合法數）\n→ End // pick 完成\nEnd // 程式執行結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MapSum:\n    def __init__(self):\n        # 存儲 key -> val 的字典\n        self.store = {}\n\n    def insert(self, key: str, val: int) -> None:\n        # 直接覆蓋或新增 key\n        self.store[key] = val\n\n    def sum(self, prefix: str) -> int:\n        # 計算所有以 prefix 開頭的 key 的值總和\n        total = 0\n        for k, v in self.store.items():\n            if k.startswith(prefix):\n                total += v\n        return total\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops_line = data[0].strip()\n    args_line = data[1].strip() if len(data) > 1 else \"[]\"\n\n    ops = ast.literal_eval(ops_line)\n    args = ast.literal_eval(args_line)\n\n    result = []\n    instance = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MapSum\":\n            instance = MapSum()\n            result.append(None)\n        elif op == \"insert\":\n            instance.insert(*arg)\n            result.append(None)\n        elif op == \"sum\":\n            res = instance.sum(*arg)\n            result.append(res)\n        else:\n            # 若有未知操作，忽略\n            result.append(None)\n\n    # 將結果轉成指定格式：None 用 null 表示\n    output = '[' + ', '.join('null' if x is None else str(x) for x in result) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code for the described MapSum class. Should be line-by-line with virtual code steps and comment. We must use the specified format. Each line: \"虛擬碼步驟 [space] // 解釋\". Use arrows etc. Let's design steps: Start, initialize root of Trie with sum 0, children map. insert: traverse, updating sums; track old value. sum: traverse prefix accumulate sum. Also need storage of key to value map for overrides. Represent pseudo-code logic.\n\nWe need to provide structure: Start, End. Use Decision lines? We can just present algorithm steps. Provide arrow formatting as per examples: \"→ Step 1: ...\" etc.\n\nLet's output.\n\nUse \"Start // 初始化MapSum\". Then \"→ Step 1: 建立 TrieRoot\" etc.\n\nWe must include arrow for decisions. Provide mapping.\n\nLet's produce a pseudo-code:\n\nStart\n→ Step 1: 定義 TrieNode { int sum; Map<char, TrieNode> children } // Trie節點，保存前綴和\n→ Step 2: 初始化 root = new TrieNode() // 以空節點作為根\n→ Step 3: 定義 keyToVal = {} // 存儲每個 key 的目前值\n→ Step 4: 定義 insert(key, val) // 插入或覆蓋\n→ Decision: key 是否已存在? // 檢查覆蓋\n    Yes → Step 5: old = keyToVal[key] // 取得舊值\n    No  → Step 5: old = 0 // 若不存在，舊值為0\n→ Step 6: keyToVal[key] = val // 更新鍵值對\n→ Step 7: delta = val - old // 計算差值\n→ Step 8: node = root\n→ Step 9: node.sum += delta // 更新根節點的 sum\n→ Step 10: for each char c in key\n        Decision: node.children 是否包含 c? // 若沒有子節點\n            Yes → Step 11: node = node.children[c]\n            No  → Step 11: node.children[c] = new TrieNode(); node = node.children[c]\n        Step 12: node.sum += delta // 更新此節點的 sum\n→ End // insert 完成\n\nSimilarly sum(prefix):\n\n→ Step 13: node = root\n→ Step 14: for each char c in prefix\n        Decision: node.children 是否包含 c? // 若不存在，返回0\n            Yes → Step 15: node = node.children[c]\n            No  → Step 15: return 0 // 無前綴\n→ Step 16: return node.sum // 回傳前綴總和\n\nEnd.\n\nNeed to use \"End // 程式執行結束\"? But this is the class; we can end overall pseudo-code after sum function. Use End at end of class definition.\n\nLet's produce.\n...done thinking.\n\nStart // MapSum 類別開始初始化  \n→ Step 1: 定義 TrieNode { int sum; Map<char, TrieNode> children } // Trie 節點，存前綴和值總和  \n→ Step 2: root = new TrieNode() // 建立根節點，sum 先為 0  \n→ Step 3: keyToVal = {} // 字典，儲存每個 key 的目前值  \n\n// --------------------------\n// 1. insert 方法  \n// --------------------------\n→ Step 4: insert(key, val) // 插入或覆蓋 key‑val  \n→ Decision: key 是否已存在? // 檢查是否需要覆蓋舊值  \n Yes → Step 5: old = keyToVal[key] // 取得舊值  \n No  → Step 5: old = 0 // 沒有舊值，視為 0  \n→ Step 6: keyToVal[key] = val // 更新 key 與新值  \n→ Step 7: delta = val - old // 計算要加到每個前綴的差值  \n→ Step 8: node = root  \n→ Step 9: node.sum += delta // 更新根節點的 sum  \n→ Step 10: for each char c in key  \n  Decision: node.children 是否包含 c? // 若無子節點  \n   Yes → Step 11: node = node.children[c] // 進入已存在的子節點  \n   No  → Step 11: node.children[c] = new TrieNode(); node = node.children[c] // 新建子節點  \n   Step 12: node.sum += delta // 更新該節點的 sum  \n→ End // insert 方法結束  \n\n// --------------------------\n// 2. sum 方法  \n// --------------------------\n→ Step 13: sum(prefix) // 回傳所有以 prefix 開頭的 key 的值總和  \n→ Step 14: node = root  \n→ Step 15: for each char c in prefix  \n  Decision: node.children 是否包含 c? // 若沒有，則無符合前綴  \n   Yes → Step 16: node = node.children[c] // 進入下一節點  \n   No  → Step 16: return 0 // 沒有此前綴，總和為 0  \n→ Step 17: return node.sum // 返回最後節點的 sum，即前綴總和  \nEnd // MapSum 類別結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.8159668236196048,-0.07354689700196754],[-0.5627668837670451,-0.05192121406889954],[-0.8562101212998855,0.42423649798300134]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null,[-0.8159668236196048,-0.07354689700196754],[-0.5627668837670451,-0.05192121406889954],[-0.8562101212998855,0.42423649798300134]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 以極座標方式產生均勻分佈的隨機點\n        r = self.radius * math.sqrt(random.random())   # sqrt 以確保半徑分佈均勻\n        theta = random.uniform(0, 2 * math.pi)          # 隨機角度\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行：方法名列表，第二行：每個方法的參數列表\n    funcs = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    obj = None\n    outputs = []\n\n    for func, args in zip(funcs, args_list):\n        if func == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)          # 建構子不回傳值\n        else:\n            method = getattr(obj, func)\n            res = method(*args)\n            outputs.append(res)\n\n    # 將結果序列化為 JSON 格式輸出\n    print(json.dumps(outputs, separators=(\",\", \":\")))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for solution class with constructor and randPoint generating uniform random point inside circle. Use random uniform. Approach: choose radius sqrt(U)*R, angle uniform 0 to 2π. Then x = center_x + r*cosθ, y = center_y + r*sinθ. So we produce steps.\n\nWe must output in given format: each line: virtual code step + space + // explanation.\n\nUse Start, End, Decision. Use arrows.\n\nWe need to structure pseudo steps: Start, Step 1: initialize variables, Step 2: generate random number u, Step 3: compute r, Step 4: generate random angle theta, Step 5: compute x, y, Step 6: return [x,y]. Also include constructor.\n\nLet's produce pseudocode:\n\nStart\n→ Class Solution: // 定義 Solution 類\n    → Constructor: Solution(radius, x_center, y_center) // 初始化半徑與中心座標\n        → Set self.radius = radius\n        → Set self.x_center = x_center\n        → Set self.y_center = y_center\n    → Method: randPoint() // 產生隨機點\n        → Step 1: Generate uniform u in [0,1] // 隨機數\n        → Step 2: Compute r = sqrt(u) * self.radius // 調整半徑以保證均勻分佈\n        → Step 3: Generate uniform angle θ in [0, 2π] // 隨機角度\n        → Step 4: x = self.x_center + r * cos(θ) // 計算 x 坐標\n        → Step 5: y = self.y_center + r * sin(θ) // 計算 y 坐標\n        → Return [x, y] // 回傳點座標\nEnd\n\nBut we need to use arrows and structure: Use Start, End, Decision: not needed.\n\nWe can include nested steps but just simple lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution: // 定義 Solution 類  \n    → Constructor: Solution(radius, x_center, y_center) // 初始化半徑與中心座標  \n        → Set self.radius = radius // 保存半徑  \n        → Set self.x_center = x_center // 保存中心 X 座標  \n        → Set self.y_center = y_center // 保存中心 Y 座標  \n    → Method: randPoint() // 產生隨機點  \n        → Generate uniform u in [0, 1] // 產生均勻分佈的隨機數  \n        → Compute r = sqrt(u) * self.radius // 轉換半徑以確保均勻分佈  \n        → Generate uniform angle θ in [0, 2π] // 產生隨機角度  \n        → Compute x = self.x_center + r * cos(θ) // 計算 X 坐標  \n        → Compute y = self.y_center + r * sin(θ) // 計算 Y 坐標  \n        → Return [x, y] // 回傳隨機點座標  \nEnd // 程式執行結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '428469043'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '428469043'"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[l][r] will store number of distinct palindromic subsequences in s[l:r+1]\n    dp = [[0] * n for _ in range(n)]\n\n    # next_pos[i][c] = smallest index > i where s[index] == c, or n if none\n    next_pos = [[n] * 26 for _ in range(n)]\n    # prev_pos[i][c] = largest index < i where s[index] == c, or -1 if none\n    prev_pos = [[-1] * 26 for _ in range(n)]\n\n    # build next_pos\n    for i in range(n - 1, -1, -1):\n        if i < n - 1:\n            for c in range(26):\n                next_pos[i][c] = next_pos[i + 1][c]\n        next_pos[i][ord(s[i]) - 97] = i + 1\n\n    # build prev_pos\n    for i in range(1, n):\n        for c in range(26):\n            prev_pos[i][c] = prev_pos[i - 1][c]\n        prev_pos[i][ord(s[i]) - 97] = i - 1\n\n    # base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n\n    # DP over increasing length\n    for length in range(2, n + 1):\n        for l in range(n - length + 1):\n            r = l + length - 1\n            if s[l] == s[r]:\n                c = ord(s[l]) - 97\n                nl = next_pos[l + 1][c]\n                pr = prev_pos[r - 1][c]\n                if nl > pr:\n                    # no inner same character\n                    dp[l][r] = (dp[l + 1][r - 1] * 2 + 2) % MOD\n                elif nl == pr:\n                    # exactly one inner same character\n                    dp[l][r] = (dp[l + 1][r - 1] * 2 + 1) % MOD\n                else:\n                    # more than one inner same character\n                    dp[l][r] = (dp[l + 1][r - 1] * 2 - dp[nl + 1][pr - 1]) % MOD\n                    if dp[l][r] < 0:\n                        dp[l][r] += MOD\n            else:\n                dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1]) % MOD\n                if dp[l][r] < 0:\n                    dp[l][r] += MOD\n\n    return dp[0][n - 1] % MOD\n\ndef parse_input(raw: str) -> str:\n    raw = raw.strip()\n    if raw.startswith(\"s =\"):\n        # extract string inside quotes\n        start = raw.find('\"')\n        end = raw.rfind('\"')\n        if start != -1 and end != -1 and end > start:\n            return raw[start + 1:end]\n    return raw\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = count_palindromic_subsequences(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: Count distinct non-empty palindromic subsequences. Classic DP with next/prev arrays or dp[l][r] with recurrence. Use modulo. We'll write steps. Let's produce virtual code with Start, Decision, End.\n\nWe need to show each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's produce steps: read s, compute next and prev positions for each char? simpler: use dp table size n x n. Recurrence:\n\nIf s[l]==s[r]: dp[l][r] = dp[l+1][r] + dp[l][r-1] + 1\nElse: dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]\n\nBut need distinct: need to handle duplicates. Use next/prev arrays: For each char c, next[l][c] = next occurrence of c after l; prev[r][c] = prev occurrence of c before r.\n\nRecurrence:\n\nIf s[l]==s[r]:\n  let c = s[l]\n  nl = next[l+1][c]\n  pr = prev[r-1][c]\n  if nl > pr: dp[l][r] = dp[l+1][r-1] * 2 + 2\n  else if nl == pr: dp[l][r] = dp[l+1][r-1] * 2 + 1\n  else: dp[l][r] = dp[l+1][r-1] * 2 - dp[nl+1][pr-1]\nElse:\n  dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]\n\nAll mod. Finally answer dp[0][n-1].\n\nLet's produce pseudo code steps accordingly. We'll include loops. Let's output each step with comment.\n\nAlso include mod constant. Provide initialization dp with zeros.\n\nWe'll produce steps:\n\nStart\n→ Input string s // read input\n→ n = length(s)\n→ mod = 1e9+7 // modulo value\n→ Initialize 2D array dp[n][n] to 0 // dp[l][r] will store answer for substring l..r\n→ Precompute nextPos[n][26] and prevPos[n][26] // next and previous occurrence arrays\n  → For each char i from 0 to 25:\n      nextPos[n-1][i] = n // sentinel beyond end\n  → For l from n-2 down to 0:\n      For each char i:\n          nextPos[l][i] = nextPos[l+1][i]\n      nextPos[l][s[l]-'a'] = l+1\n  → For prevPos[0][i] = -1\n  → For r from 1 to n-1:\n      For each char i:\n          prevPos[r][i] = prevPos[r-1][i]\n      prevPos[r][s[r]-'a'] = r-1\n→ Compute dp for substrings of increasing length\n  → For length from 1 to n:\n      For l from 0 to n-length:\n          r = l + length -1\n          If length == 1:\n              dp[l][r] = 1 // single char palindrome\n          Else:\n              If s[l] == s[r]:\n                  c = s[l]-'a'\n                  nl = nextPos[l+1][c]\n                  pr = prevPos[r-1][c]\n                  If nl > pr:\n                      dp[l][r] = (dp[l+1][r-1] * 2 + 2) % mod\n                  Else If nl == pr:\n                      dp[l][r] = (dp[l+1][r-1] * 2 + 1) % mod\n                  Else:\n                      dp[l][r] = (dp[l+1][r-1] * 2 - dp[nl+1][pr-1]) % mod\n                      If dp[l][r] < 0: dp[l][r] += mod\n              Else:\n                  dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]) % mod\n                  If dp[l][r] < 0: dp[l][r] += mod\n→ answer = dp[0][n-1] % mod\n→ Output answer\nEnd\n\nWe need each line with // explanation. Use arrow formatting.\n\nLet's produce each line. We must be careful about each step line. Provide arrow '→' for substeps. Use indent? They used indentation in example with nested decisions. We can show indentation using spaces. Let's craft.\n\nWe need to list lines exactly with code-like steps. Use \"→ Step: ...\". For loops, we can use \"→ For ...:\" lines.\n\nLet's produce.\n\nBe mindful of mod adjustments. Provide comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input string s // 從使用者處取得輸入字串  \n→ n = length(s) // 字串長度  \n→ mod = 1000000007 // 取模數  \n\n// 初始化 DP 陣列  \n→ 初始化 dp[n][n] 為 0 // dp[l][r] 為子字串 l..r 的答案  \n\n// 先計算 nextPos 與 prevPos，方便快速取得同一字母的下次與上次位置  \n→ Initialize nextPos[n][26] 為 n // 限界值，表示沒有更後面同字母  \n→ For l = n-2 downto 0:  \n    → For i = 0 to 25:  \n        → nextPos[l][i] = nextPos[l+1][i] // 先複製下一個位置的資訊  \n    → nextPos[l][s[l]-'a'] = l+1 // 本位置字母的下一個位置是 l+1  \n\n→ Initialize prevPos[n][26] 為 -1 // 限界值，表示沒有前一個同字母  \n→ For r = 1 to n-1:  \n    → For i = 0 to 25:  \n        → prevPos[r][i] = prevPos[r-1][i] // 先複製前一個位置的資訊  \n    → prevPos[r][s[r]-'a'] = r-1 // 本位置字母的前一個位置是 r-1  \n\n// DP 逐長度計算子字串的答案  \n→ For length = 1 to n:  \n    → For l = 0 to n - length:  \n        → r = l + length - 1 // 子字串結束位置  \n        → If length == 1:  \n            → dp[l][r] = 1 // 單字母本身是唯一的回文子序列  \n        → Else:  \n            → If s[l] == s[r]: // 兩端字母相同  \n                → c = s[l] - 'a' // 對應字母編號  \n                → nl = nextPos[l+1][c] // 從 l+1 開始的下一個同字母位置  \n                → pr = prevPos[r-1][c] // 從 r-1 開始的上一個同字母位置  \n                → If nl > pr: // 兩端之間沒有相同字母  \n                    → dp[l][r] = (dp[l+1][r-1] * 2 + 2) % mod // 新增兩種長度 +1 的子序列  \n                → Else If nl == pr: // 只有一個相同字母  \n                    → dp[l][r] = (dp[l+1][r-1] * 2 + 1) % mod // 新增兩種長度 +1 的子序列，減一個重複  \n                → Else: // 兩端之間有多個相同字母  \n                    → dp[l][r] = (dp[l+1][r-1] * 2 - dp[nl+1][pr-1]) % mod // 減去重複計算的子序列  \n                    → If dp[l][r] < 0: dp[l][r] += mod // 確保非負  \n            → Else: // s[l] != s[r]  \n                → dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]) % mod // 合併兩側子序列，扣除重疊  \n                → If dp[l][r] < 0: dp[l][r] += mod // 確保非負  \n\n→ answer = dp[0][n-1] % mod // 最終答案  \n→ Output answer // 顯示結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array",
      "source_file": "Leetcode/leetcode26.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[1,2,_]'\nGot (Norm):      '2,nums=[1,2,\"_\"]'\n--- (Raw) ---\nRaw Expected: '2, nums = [1,2,_]'\nRaw Got:      \"2, nums = [1, 2, '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,2,3,4,_,_,_,_,_]'\nGot (Norm):      '5,nums=[0,1,2,3,4,\"_\",\"_\",\"_\",\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,2,3,4,_,_,_,_,_]'\nRaw Got:      \"5, nums = [0, 1, 2, 3, 4, '_', '_', '_', '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        Remove duplicates in-place from a sorted list.\n        Return the number of unique elements.\n        \"\"\"\n        if not nums:            # 空陣列直接回傳 0\n            return 0\n\n        slow = 0                # slow 指向目前唯一元素的最後一個位置\n        for fast in range(1, len(nums)):   # fast 從第二個元素開始遍歷\n            if nums[fast] != nums[slow]:   # 發現新唯一元素\n                slow += 1                  # 移動 slow\n                nums[slow] = nums[fast]    # 把新元素寫入 slow 位置\n        return slow + 1                # unique 數量為 slow+1\n\ndef main():\n    # 讀取整個 stdin，並抽取方括號內的數字列表\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        start = data.index('[')\n        end = data.index(']', start)\n        nums = ast.literal_eval(data[start:end+1])\n    except (ValueError, SyntaxError):\n        # 若解析失敗，直接終止\n        return\n\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # 準備輸出，將剩餘位置用 '_' 標示\n    display = []\n    for i in range(k):\n        display.append(nums[i])\n    for _ in range(k, len(nums)):\n        display.append('_')\n    print(f\"{k}, nums = {display}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code, line by line, with explanations. It's Leetcode 26 Remove Duplicates from Sorted Array. Approach: use two pointers, fast and slow. Initialize slow=0. Iterate fast from 1 to n-1. If nums[fast] != nums[slow], increment slow, set nums[slow] = nums[fast]. At end, k = slow+1. Return k. Also consider empty array.\n\nWe need to produce virtual code with arrows and decision steps. We'll output each line with explanation. Let's construct. Use Start, End. Use Decision: If n==0? etc. Provide step-by-step.\n\nWe should produce minimal pseudo-code but with steps. Each line: \"Start // ...\" then arrow.\n\nMake sure each line ends with explanation. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n // 先取得 nums 的長度  \n→ Decision: n 是否為 0? // 判斷是否為空陣列  \n  Yes → Step 2: 回傳 0 // 空陣列直接回傳 0  \n  No → Step 3: 設定 slow = 0 // slow 指向第一個唯一元素的位置  \n  No → Step 4: 迴圈 fast 從 1 到 n-1 // fast 為遍歷指標  \n   Decision: fast < n? // 判斷是否還有元素要檢查  \n    Yes → Step 5: 如果 nums[fast] ≠ nums[slow]? // 比較快指標位置值與慢指標位置值  \n      Decision: nums[fast] ≠ nums[slow]?  \n        Yes → Step 6: slow++ // 找到新唯一元素，移動 slow  \n        Yes → Step 7: nums[slow] = nums[fast] // 把新唯一元素寫入 slow 位置  \n        No → Step 8: // 兩個指標相同，跳過重複元素  \n      No → Step 9: // fast 仍遞增，繼續迴圈  \n       Decision: fast < n? // 重複迴圈條件  \n        Yes → 回到 Step 5  \n        No → Step 10: k = slow + 1 // 最後 unique 個數是 slow+1  \n        No → Step 11: 回傳 k // 回傳 unique 個數  \nEnd // 程式執行結束"
    },
    {
      "title": "4Sum",
      "source_file": "Leetcode/leetcode18.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp96w6cnd6.py\", line 43, in <module>\n    nums, target = parse_input()\n                   ^^^^^^^^^^^^^\n  File \"/tmp/tmp96w6cnd6.py\", line 37, in parse_input\n    exec(raw, {}, namespace)\n  File \"<string>\", line 1\n    nums = [1\n            ^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptroz5buy.py\", line 43, in <module>\n    nums, target = parse_input()\n                   ^^^^^^^^^^^^^\n  File \"/tmp/tmptroz5buy.py\", line 37, in parse_input\n    exec(raw, {}, namespace)\n  File \"<string>\", line 1\n    nums = [2\n            ^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def fourSum(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\ndef parse_input():\n    raw = sys.stdin.read().strip()\n    # Replace commas with newlines to allow exec of multiple assignments\n    raw = raw.replace(',', '\\n')\n    namespace = {}\n    exec(raw, {}, namespace)\n    nums = namespace.get('nums')\n    target = namespace.get('target')\n    return nums, target\n\nif __name__ == \"__main__\":\n    nums, target = parse_input()\n    solution = Solution()\n    result = solution.fourSum(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the 4-sum problem. Provide line-by-line with arrows and decisions. No actual code. Use Chinese. Provide explanation after //.\n\nLet's outline typical algorithm: sort array, then 3 nested loops with two pointers to find quadruplets. Avoid duplicates. Steps: Start, Input nums and target, sort, initialize result array. For i from 0 to n-4: skip duplicates; for j from i+1 to n-3: skip duplicates; left=j+1; right=n-1; while left<right: sum=nums[i]+nums[j]+nums[left]+nums[right]; if sum==target: add quadruplet; move left and right skipping duplicates; else if sum<target: left++; else right--. End loops. Return result.\n\nNeed to output each step line with explanation. Use arrows and decisions. Each line should have \"→ Step: ... // explanation\". Also decisions with Yes→ etc.\n\nWe need to be careful to include all steps: Start, Input, Sort, etc. Let's produce virtual code lines. Use 'Start' at top. Use 'End' at bottom. For loops, show as 'Step X: For i ...' etc.\n\nAlso decisions: For duplicates, check if i>0 && nums[i]==nums[i-1] then skip.\n\nLet's produce.\n\nAlso at end: Return result.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums 與目標值 target // 從使用者或測試環境取得必要資料  \n→ Step 2: 取得陣列長度 n // 方便後續迴圈邏輯  \n→ Step 3: 對 nums 進行升序排序 // 使相同元素相鄰，便於跳過重複與雙指標搜尋  \n→ Step 4: 建立空集合 result 用於儲存所有符合條件的四元組 // 為避免重複結果，使用集合或後續排重  \n→ Decision: 如果 n < 4? // 若元素不足四個，無法形成四元組  \n    Yes → Step 5: 返回 result（空） // 直接結束，無結果  \n    No  →  \n→ Step 6: 進入外層迴圈 i 從 0 到 n-4  \n    → Decision: 如果 i > 0 且 nums[i] == nums[i-1]? // 跳過相同起始元素以避免重複四元組  \n        Yes → Step 7: 進行 i++  // 跳過此個 i  \n        No  →  \n    → Step 8: 進入中層迴圈 j 從 i+1 到 n-3  \n        → Decision: 如果 j > i+1 且 nums[j] == nums[j-1]? // 跳過相同第二個元素  \n            Yes → Step 9: 進行 j++  // 跳過此個 j  \n            No  →  \n        → Step 10: 設定 left = j+1, right = n-1 // 初始化左右指標  \n        → Decision: 只要 left < right? // 進行雙指標搜尋  \n            Yes →  \n                → Step 11: 計算 currentSum = nums[i] + nums[j] + nums[left] + nums[right] // 取得目前四元組總和  \n                → Decision: currentSum == target? // 判斷是否符合目標  \n                    Yes →  \n                        → Step 12: 將 [nums[i], nums[j], nums[left], nums[right]] 加入 result // 存儲符合條件的四元組  \n                        → Step 13: 移動 left++ 同時 while left < right 且 nums[left] == nums[left-1] do left++ // 跳過重複左邊元素  \n                        → Step 14: 移動 right-- 同時 while left < right 且 nums[right] == nums[right+1] do right-- // 跳過重複右邊元素  \n                    No  →  \n                        → Decision: currentSum < target? // 若總和小於目標，需要增大和  \n                            Yes → Step 15: left++ // 向右移動左指標  \n                            No  → Step 16: right-- // 向左移動右指標  \n                → 回到 Decision: left < right? // 迴圈繼續  \n            No  →  \n        → 回到 Step 8: j++ // 結束中層迴圈的下一個 j  \n    → 回到 Step 6: i++ // 結束外層迴圈的下一個 i  \n→ Step 17: 返回 result // 程式結束，輸出所有符合條件的四元組  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Comments",
      "source_file": "Leetcode/leetcode722.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"ab\"]'\nGot (Norm):      '[\"b\"]'\n--- (Raw) ---\nRaw Expected: '[\"ab\"]'\nRaw Got:      \"['b']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n\n        for line in source:\n            i = 0\n            new_line = []\n            while i < len(line):\n                if not in_block:\n                    # 检测块注释开始\n                    if i + 1 < len(line) and line[i] == '/' and line[i + 1] == '*':\n                        in_block = True\n                        i += 2\n                        continue\n                    # 检测行注释开始\n                    if i + 1 < len(line) and line[i] == '/' and line[i + 1] == '/':\n                        break\n                else:\n                    # 检测块注释结束\n                    if i + 1 < len(line) and line[i] == '*' and line[i + 1] == '/':\n                        in_block = False\n                        i += 2\n                        continue\n                # 不是注释，写入结果\n                if not in_block:\n                    new_line.append(line[i])\n                i += 1\n            # 只有非空行才加入最终结果\n            if new_line and not in_block:\n                res.append(\"\".join(new_line))\n        return res\n\nif __name__ == \"__main__\":\n    # 读取所有输入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 去掉可能存在的前缀 \"source =\"\n    if raw_input.lower().startswith(\"source\"):\n        try:\n            _, expr = raw_input.split(\"=\", 1)\n        except ValueError:\n            expr = raw_input\n    else:\n        expr = raw_input\n\n    # 解析列表字符串为 Python 列表\n    try:\n        source = ast.literal_eval(expr.strip())\n    except Exception:\n        # 若解析失败，直接退出\n        sys.exit()\n\n    # 调用解决方案\n    solution = Solution()\n    result = solution.removeComments(source)\n\n    # 输出结果，使用 Python 列表表示方式\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for removing comments. Should be line by line. Provide explanation per line. Use Start, End, Decision, arrow. Should not output actual code. Provide pseudocode only. Ensure each line includes virtual code step and comment. We'll need loops over lines and characters. Track inBlock boolean. For each line, process chars. Use index i. We'll use while loops. Build output lines. Skip empty. Provide steps.\n\nLet's craft.\n\nStart\n→ Initialize result array // store lines without comments\n→ Initialize inBlock = False // flag whether inside block comment\n→ For each line in source // iterate over each source line\n    → Initialize i = 0 // index in current line\n    → Initialize cur = \"\" // current processed characters\n    → While i < length(line) // process each character\n        → Decision: if inBlock? // check if inside block comment\n            Yes → Decision: if line[i:i+2] == \"*/\"? // check end of block\n                Yes → inBlock = False // exit block comment\n                → i += 2 // skip closing\n                No  → i += 1 // skip current char inside block\n            No  → Decision: if line[i:i+2] == \"//\"? // line comment start\n                Yes → Break // rest of line ignored\n                No  → Decision: if line[i:i+2] == \"/*\"? // block comment start\n                    Yes → inBlock = True // enter block comment\n                    → i += 2 // skip opening\n                    No  → cur += line[i] // keep current char\n                    → i += 1\n    → Decision: if cur trimmed not empty? // after processing line\n        Yes → Append cur to result // add non-empty line\n        No  → Do nothing // skip empty line\nEnd // finished processing\n\nNeed each line in output with arrow and comment.\n\nEnsure each line starts with \"→\" except Start and End? Use arrow for steps after Start? In example they used \"→\" for each step. So we should use \"→\" before each line except Start and End. But the example had \"→\" before each step. We'll follow.\n\nWe'll produce lines accordingly.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 result = [] // 用來儲存去除註解後的程式碼行\n→ Step 2: 初始化 inBlock = False // 標記目前是否在區塊註解內\n→ Decision: 迭代 source 的每一行？ // 遍歷原始程式碼的每一行\n    Yes →\n        → Step 3: 設定 i = 0 // 目前行的索引\n        → Step 4: 設定 cur = \"\" // 用來收集當前行的有效字元\n        → While i < length(line) // 逐字元處理\n            → Decision: if inBlock? // 判斷是否已進入區塊註解\n                Yes →\n                    → Decision: if line[i:i+2] == \"*/\"? // 檢查是否結束區塊註解\n                        Yes →\n                            → Step 5: inBlock = False // 離開區塊註解\n                            → Step 6: i += 2 // 跳過 \"*/\"\n                        No →\n                            → Step 7: i += 1 // 在區塊內忽略所有字元\n                No →\n                    → Decision: if line[i:i+2] == \"//\"? // 判斷是否為行註解開始\n                        Yes →\n                            → Step 8: Break // 跳出 while，忽略此行剩餘字元\n                        No →\n                            → Decision: if line[i:i+2] == \"/*\"? // 判斷是否為區塊註解開始\n                                Yes →\n                                    → Step 9: inBlock = True // 進入區塊註解\n                                    → Step 10: i += 2 // 跳過 \"/*\"\n                                No →\n                                    → Step 11: cur += line[i] // 將字元加入有效內容\n                                    → Step 12: i += 1 // 進一步處理下一字元\n        → Decision: if cur.trim() != \"\"? // 這一行處理完後是否還有有效內容\n            Yes →\n                → Step 13: result.append(cur) // 將非空行加入結果\n            No →\n                → Step 14: 何不做 // 空行不加入結果\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\ndef parse_input(data):\n    \"\"\"Parse input of the form 'nums = [1,2,3]' or just '[1,2,3]'.\"\"\"\n    data = data.strip()\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    # Safe eval for list literal\n    try:\n        nums = eval(expr, {\"__builtins__\": None}, {})\n    except Exception:\n        nums = []\n    return nums\n\ndef format_output(subsets):\n    \"\"\"Format the list of subsets without spaces after commas.\"\"\"\n    subset_strs = []\n    for subset in subsets:\n        if not subset:\n            subset_strs.append('[]')\n        else:\n            subset_strs.append('[' + ','.join(map(str, subset)) + ']')\n    return '[' + ','.join(subset_strs) + ']'\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    sol = Solution()\n    result = sol.subsets(nums)\n    print(format_output(result))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line-by-line with explanations. Input: array of unique integers. Need to return all subsets. Classic backtracking or bitmask. We can choose backtracking recursion. Provide Start, Decision, etc.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow arrows.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義 function generateSubsets(nums) // 主函式，接收數組\n→ Decision: nums 是否為空? // 檢查輸入是否為空\n    Yes → Step 2: 返回 [[]] // 空集合的子集是只有空集\n    No  → Step 3: 初始化 result = [] // 存放所有子集\n→ Step 4: 定義 recursive function backtrack(start, path) // backtrack 參數 start 與目前路徑\n    → Step 5: 將 path 複製並加入 result // 每次遞歸都將目前子集加入結果\n    → Decision: start 是否小於 nums.length? // 確保有元素可選\n        Yes → Step 6: 從 i = start 到 nums.length-1 迴圈\n            → Step 7: path.append(nums[i]) // 選擇當前元素\n            → Step 8: backtrack(i+1, path) // 進一步遞歸\n            → Step 9: path.pop() // 回溯，移除最後選擇\n        No  → End // 不再有元素可選\n→ Step 10: 呼叫 backtrack(0, []) // 從索引0開始，空路徑\n→ Step 11: 返回 result // 回傳所有子集\nEnd // 程式結束\n\nNeed to ensure each line with arrow indentation maybe. Use \"→\" for steps, \"Decision:\" for decisions. Provide \"Yes →\" and \"No →\" inside decision.\n\nAlso need \"Start\" and \"End\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 function generateSubsets(nums) // 主函式，接收數組  \n→ Decision: nums 是否為空? // 檢查輸入是否為空  \n Yes → Step 2: 返回 [[]] // 空集合的子集是只有空集  \n No  → Step 3: 初始化 result = [] // 存放所有子集  \n→ Step 4: 定義 recursive function backtrack(start, path) // 回溯函式，start 為下一個可選元素索引，path 為目前子集  \n → Step 5: 將 path 複製並加入 result // 每次遞歸都將目前子集加入結果  \n → Decision: start 是否小於 nums.length? // 確保還有元素可選  \n  Yes → Step 6: 從 i = start 到 nums.length-1 迴圈  \n   → Step 7: path.append(nums[i]) // 選擇當前元素  \n   → Step 8: backtrack(i+1, path) // 進一步遞歸  \n   → Step 9: path.pop() // 回溯，移除最後選擇  \n  No  → End // 不再有元素可選  \n→ Step 10: 呼叫 backtrack(0, []) // 從索引 0 開始，空路徑  \n→ Step 11: 返回 result // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Shortest Unsorted Continuous Subarray",
      "source_file": "Leetcode/leetcode581.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\n\ndef find_unsorted_subarray(nums):\n    n = len(nums)\n    # 如果数组为空或只有一个元素，已经有序\n    if n <= 1:\n        return 0\n\n    left, right = n, 0\n    max_so_far = nums[0]\n    # 从左往右扫描，寻找左边界\n    for i in range(n):\n        if nums[i] < max_so_far:\n            left = min(left, i)\n        max_so_far = max(max_so_far, nums[i])\n\n    min_so_far = nums[-1]\n    # 从右往左扫描，寻找右边界\n    for i in range(n - 1, -1, -1):\n        if nums[i] > min_so_far:\n            right = max(right, i)\n        min_so_far = min(min_so_far, nums[i])\n\n    # 如果没有需要排序的子数组，right <= left\n    return right - left + 1 if right > left else 0\n\ndef parse_input(input_str):\n    \"\"\"\n    解析类似 'nums = [1, 2, 3]' 的字符串，返回整数列表。\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n\n    # 尝试寻找 '[' 和 ']' 之间的内容\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start != -1 and end != -1 and start < end:\n        try:\n            return eval(input_str[start:end+1])\n        except Exception:\n            pass\n\n    # 退化为空列表\n    return []\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    result = find_unsorted_subarray(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that solve the problem: find minimal subarray that if sorted will make whole array sorted. Equivalent to known LeetCode problem 581. Steps: find left boundary where array goes out of order, right boundary similarly, then adjust left by checking min of subarray, right by max. Output length = right-left+1 else 0.\n\nWe need to produce line-by-line pseudocode, with arrows and decisions. Provide explanation per line.\n\nLet's write.\n\nStart\n\n→ Step 1: n ← length(nums) // array size\n\n→ Step 2: left ← n // initial left boundary as n (sentinel)\n\n→ Step 3: right ← 0 // initial right boundary as 0\n\n→ Step 4: max_val ← nums[0] // current maximum while iterating left to right\n\n→ Decision: Iterate i from 0 to n-1 // scan array\n\n    → Step 5: If nums[i] < max_val Then // out of order on left side\n        → Step 6: left ← min(left, i) // update left boundary\n    → End Decision\n\n    → Step 7: max_val ← max(max_val, nums[i]) // update maximum\n\n→ End Decision\n\n→ Step 8: min_val ← nums[n-1] // current minimum while iterating right to left\n\n→ Decision: Iterate i from n-1 downto 0\n\n    → Step 9: If nums[i] > min_val Then // out of order on right side\n        → Step 10: right ← max(right, i) // update right boundary\n    → End Decision\n\n    → Step 11: min_val ← min(min_val, nums[i]) // update minimum\n\n→ End Decision\n\n→ Decision: If right - left + 1 > 0 Then // subarray exists\n        Yes → Step 12: result ← right - left + 1 // length\n        No → Step 12: result ← 0 // already sorted\n→ End Decision\n\n→ End // output result\n\nNeed to keep each line with arrow and comment. Use structure: Start, End, Decision: Yes→, No→.\n\nLet's craft.\n\nUse proper arrow formatting.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: left ← n // 初始化左邊界為 n（最大可能值）  \n→ Step 3: right ← 0 // 初始化右邊界為 0  \n→ Step 4: max_val ← nums[0] // 左至右掃描時的最大值  \n\nDecision: 從 0 到 n-1 迭代陣列  \n    → Step 5: If nums[i] < max_val Then // 此位置小於前面最大值，表示左邊界需更新  \n        → Step 6: left ← min(left, i) // 設置最左邊不符合排序的索引  \n    → End Decision  \n    → Step 7: max_val ← max(max_val, nums[i]) // 更新最大值  \n→ End Decision  \n\n→ Step 8: min_val ← nums[n-1] // 右至左掃描時的最小值  \n\nDecision: 從 n-1 到 0 迭代陣列  \n    → Step 9: If nums[i] > min_val Then // 此位置大於後面最小值，表示右邊界需更新  \n        → Step 10: right ← max(right, i) // 設置最右邊不符合排序的索引  \n    → End Decision  \n    → Step 11: min_val ← min(min_val, nums[i]) // 更新最小值  \n→ End Decision  \n\nDecision: 是否存在需要排序的子陣列？  \n    Yes → Step 12: result ← right - left + 1 // 子陣列長度  \n    No  → Step 12: result ← 0 // 陣列已經排序  \n→ End Decision  \n\nEnd // 程式執行結束，輸出 result。"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並包裝成合法的 JSON 列表\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    data = json.loads('[' + raw_input + ']')\n    ops, args_list = data[0], data[1]\n\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)   # 代表 null\n        elif op == \"pickIndex\":\n            results.append(obj.pickIndex())\n        else:\n            # 若有其他方法，可在此處擴充\n            results.append(None)\n\n    # 輸出 JSON 形式，null 以小寫表示\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Should include building prefix sums array, generating random number between 0 and sum-1 inclusive, binary search or linear search to find index. Provide steps with arrows and explanation.\n\nWe must produce only virtual code lines, each with // explanation. Must be in Traditional Chinese. Use Start, End, Decision, etc.\n\nWe'll produce algorithm: Initialize cumulative array in constructor. In pickIndex, generate random int r in [0, total-1] inclusive. Then iterate cumulative to find first index where cumulative > r. Return index. Complexity.\n\nLet's produce lines.\n\nRemember each line: \"虛擬碼步驟 [space] // 解釋\". Provide arrow for transitions. Use Start and End.\n\nWe'll produce:\n\nStart\n→ Step 1: 建立物件時，計算每個索引的累積權重總和並儲存於 cumulative[] // 先將 w 轉為前綴和，方便快速查找\n→ Step 2: 記錄總重量 totalWeight = cumulative[last] // 總權重可直接取得\n→ Step 3: pickIndex() 開始 // 進入隨機挑選流程\n→ Step 4: 產生隨機整數 r 取值範圍 0 ~ totalWeight - 1 // 用於選擇權重區間\n→ Decision: r < cumulative[0]? // 檢查 r 是否落在第一個區間\n    Yes → Step 5: 回傳 0 // r 在第一個索引區間\n    No → Step 6: 從 i = 1 開始循環直到 cumulative[i] > r // 逐一檢查每個累積值\n        → Step 7: 如果 cumulative[i] > r, 回傳 i // 找到對應索引\n→ End\n\nBut need to show line numbers maybe not needed. Just lines.\n\nAlso include arrow transitions like → Step. For decisions use Yes → and No →. Let's produce. Ensure each line has \"虛擬碼步驟\" and explanation.\n\nWill include \"Constructor\" step. Maybe better:\n\nStart\n→ Constructor: 取得 w // 接收權重陣列\n→ Step 1: cumulative = 新空陣列 // 用來儲存前綴和\n→ Step 2: for i in 0..w.length-1: cumulative[i] = (i == 0 ? w[i] : cumulative[i-1] + w[i]) // 計算前綴和\n→ Step 3: totalWeight = cumulative[last] // 總重量\n→ Step 4: pickIndex() 開始 // 函式執行\n→ Step 5: r = 隨機整數 0 ~ totalWeight-1 // 產生隨機數\n→ Decision: r < cumulative[0]?\n    Yes → Step 6: 回傳 0 // r 在第一個索引\n    No → Step 7: i = 1\n    → Decision: cumulative[i] > r?\n        Yes → Step 8: 回傳 i // 找到對應索引\n        No  → Step 7: i++ ; goto Decision: cumulative[i] > r?\n→ End\n\nBut arrow usage: need to use \"→ Decision:\" and \"Yes →\" \"No →\". Also maintain flow. Could be simplified by using linear search. Provide explanation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Constructor: 取得權重陣列 w // 接收使用者傳入的正整數陣列  \n→ Step 1: cumulative = 新空陣列 // 用來儲存前綴和，方便後續查找  \n→ Step 2: for i = 0 to w.length-1  \n  → cumulative[i] = (i == 0 ? w[0] : cumulative[i-1] + w[i]) // 計算並儲存每個索引的累積權重  \n→ Step 3: totalWeight = cumulative[w.length-1] // 總權重即最後一個累積值  \n→ Step 4: pickIndex() 開始 // 進入隨機挑選流程  \n→ Step 5: r = 隨機整數 0 ~ totalWeight-1 // 產生一個在總權重範圍內的隨機數  \n→ Decision: r < cumulative[0]? // 判斷 r 是否落在第一個索引的區間  \n  Yes → Step 6: 回傳 0 // r 在第一個索引，直接返回  \n  No → Step 7: i = 1 // 否則從第二個索引開始搜尋  \n  → Decision: cumulative[i] > r? // 檢查 r 是否落在當前索引的區間  \n   Yes → Step 8: 回傳 i // 找到對應索引，返回  \n   No  → Step 7: i++ ; goto Decision: cumulative[i] > r? // 沒找到則遞增索引繼續搜尋  \nEnd // 程式執行結束"
    }
  ]
}