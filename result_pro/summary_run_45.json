{
  "run_index": 45,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 399,
  "generation_or_validation_failure_count": 40,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[5,5,2,5,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[5, 5, 2, 5, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳所有結果的列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    \"\"\"\n    從標準輸入讀取程式碼並執行。\n    \"\"\"\n    code = sys.stdin.read()\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. They want a function roll_dice(n) that uses random module, simulates rolling n times a 6-sided die, returns list of results.\n\nSo output steps: Start, import random, define function, create list, loop, generate random int between 1-6, append, end loop, return list, End.\n\nUse the arrow syntax. Each line: Virtual Code Step + space + // explanation.\n\nMake sure to follow the arrow conventions.\n\nLet's create:\n\nStart // 程式開始執行\n\n→ Import random // 載入 random 模組\n\n→ Function: roll_dice(n) // 定義函數\n\n→ Step 1: results = [] // 初始化結果列表\n\n→ Step 2: For i in range(n): // 循環擲 n 次\n\n→ Step 3: roll = random.randint(1, 6) // 產生 1-6 的隨機整數\n\n→ Step 4: results.append(roll) // 將結果加入列表\n\n→ Step 5: Return results // 回傳結果列表\n\nEnd // 程式結束\n\nBut need arrow formatting: Start, then →.\n\nAlso may use Decision but none required.\n\nFollow example: \nStart // 程式開始執行\n→ Step 1: import random // 載入 random 模組\n→ Step 2: define function roll_dice(n) // ...\n\nBetter to use arrows after Start.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import random // 載入 random 模組  \n→ Step 2: Define function roll_dice(n) // 定義擲骰函數  \n→ Step 3: results = [] // 初始化結果列表  \n→ Step 4: For i in range(n): // 循環擲 n 次  \n  → Step 5: roll = random.randint(1, 6) // 產生 1-6 的隨機整數  \n  → Step 6: results.append(roll) // 將結果加入列表  \n→ Step 7: Return results // 回傳所有擲骰結果的列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行時間，並回傳四捨五入到小數點 3 位的秒數\"\"\"\n    start = time.perf_counter()   # 取得高精度開始時間\n    func(*args)                   # 執行傳入的函式\n    end = time.perf_counter()     # 取得結束時間\n    elapsed = end - start         # 計算耗時\n    return round(elapsed, 3)      # 四捨五入到 3 位小數\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入（包含使用者自訂程式碼）\n    code = sys.stdin.read()\n    # 執行時提供 measure_time 與 time 模組\n    exec_globals = {\"measure_time\": measure_time, \"time\": time}\n    exec(code, exec_globals)",
      "virtual_code": "Thinking...\nWe need to output a virtual code for a function measure_time(func,*args) using time module, measure time in seconds, round to 3 decimal places, return result. The user wants pseudocode line by line. Must use \"Start\", \"End\", \"Decision:\" etc. Use arrow \"→\". Provide explanation after // each line. No actual code, just virtual steps. Use Chinese. Provide steps. Probably include import time step, function definition, start time, call func, end time, compute diff, round, return. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 載入 time 模組 // 引入用於計時的模組\n→ Step 2: 定義函式 measure_time(func, *args) // 建立測量時間的函式\n→ Decision: 如果 func 為空? // 檢查函式參數是否有效\n    No  → Step 3: 設定 start_time = time.perf_counter() // 紀錄開始時間（高精度）\n    Yes → Step 4: 回傳 None // 若無法執行，直接回傳空值\n→ Step 5: 執行 result = func(*args) // 呼叫傳入的函式並傳遞參數\n→ Step 6: 設定 end_time = time.perf_counter() // 紀錄結束時間\n→ Step 7: 計算 elapsed = end_time - start_time // 計算耗時秒數\n→ Step 8: 將 elapsed 四捨五入到 3 位小數，得到 rounded = round(elapsed, 3) // 四捨五入至三位小數\n→ Step 9: 回傳 rounded // 返回計算出的秒數\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"apple\",\"melon\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'apple', 'melon', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（如果有的話），但本題不需要實際處理這些資料\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'，使用 discard 不會拋錯\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with each line containing \"虛擬碼步驟\" and \"// 解釋\". Use Start, End, Decision. No actual code. Just steps.\n\nLet's create:\n\nStart // 程式開始\n→ Step 1: 建立集合 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: 呼叫 fruits.add('orange') // 新增 'orange'\n→ Step 3: 呼叫 fruits.update(['grape', 'melon']) // 一次新增兩個元素\n→ Step 4: 呼叫 fruits.remove('banana') // 移除 'banana'\n→ Step 5: 呼叫 fruits.discard('pineapple') // 嘗試移除不存在的元素\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd // 程式結束\n\nEnsure format. Use \"虛擬碼步驟\" not code but maybe just description. The arrow style: \"→ Step 1:\" etc. Good. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立集合 fruits = {'apple', 'banana'} // 初始化集合  \n→ Step 2: 呼叫 fruits.add('orange') // 新增 'orange' 至集合  \n→ Step 3: 呼叫 fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'  \n→ Step 4: 呼叫 fruits.remove('banana') // 移除 'banana'  \n→ Step 5: 呼叫 fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'，不會拋錯  \n→ Step 6: 輸出 fruits // 顯示最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.78TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.78 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef get_rate():\n    \"\"\"取得美元兌台幣匯率，成功返回浮點數，失敗返回 None。\"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef print_rate_from_input():\n    \"\"\"從 stdin 讀取指令，若包含「更新匯率」則輸出目前匯率。\"\"\"\n    content = sys.stdin.read().strip()\n    if not content:\n        return False  # 沒有輸入，讓 GUI 執行\n    if \"更新匯率\" in content:\n        rate = get_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        print(\"未知指令\")\n    return True  # 已處理輸入\n\ndef start_gui():\n    \"\"\"啟動 tkinter GUI，按下按鈕即可更新匯率。\"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update():\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    tk.Button(win, text=\"更新匯率\", command=update).pack(pady=5)\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    # 若 stdin 有輸入，先處理輸入；否則啟動 GUI\n    if not print_rate_from_input():\n        start_gui()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, using the given format. Use Start, End, Decision. Need to include requests, tkinter. Should have a button that when pressed fetches the rate and updates label. Should include error handling maybe. But keep simple.\n\nLet's craft step by step:\n\nStart\n→ Step 1: Import requests and tkinter modules // Bring in needed libraries\n→ Step 2: Define function fetch_rate() // Function to get rate\n    → Step 2.1: response ← requests.get(url) // Send GET request\n    → Decision: If response status 200? // Check success\n        Yes → data ← response.json() // Parse JSON\n        Yes → rate ← data['rates']['TWD'] // Extract rate\n        Yes → Return rate // Return value\n        No  → Return None // On failure return None\n→ Step 3: Create tkinter root window // Initialize UI\n→ Step 4: Create label to display rate // UI element for rate\n→ Step 5: Create button with command fetch_and_update // Button to refresh\n→ Step 6: Define function fetch_and_update() // Action on button press\n    → Step 6.1: rate ← fetch_rate() // Call fetch\n    → Decision: If rate is not None? // Check result\n        Yes → label.config(text = f\"USD to TWD: {rate}\") // Update label\n        No  → label.config(text = \"Error fetching rate\") // Show error\n→ Step 7: Start tkinter mainloop // Run UI\nEnd\n\nNeed to put arrow after each line. Use \"→\". For nested steps maybe indent but it's okay. Use Decision lines with Yes→ and No→ lines.\n\nWe need to include brackets? Example in format: \"Decision: 如果數字大於 0?\" etc. So for each decision, we need to put \"Decision:\" then the condition. Then Yes → etc. Provide explanation comments after //.\n\nLet's produce.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\". For decision lines, after \"Decision:\" we may write condition. Then subsequent Yes and No lines.\n\nAlso Start, End.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter // 載入需要的模組\n→ Step 2: Define function fetch_rate() // 定義抓取匯率的函式\n    → Step 2.1: response ← requests.get(\"https://api.exchangerate-api.com/v4/latest/USD\") // 送出 GET 請求\n    → Decision: response.status_code == 200? // 檢查回應是否成功\n        Yes → data ← response.json() // 解析 JSON\n        Yes → rate ← data[\"rates\"][\"TWD\"] // 取得 TWD 匯率\n        Yes → Return rate // 回傳匯率\n        No  → Return None // 失敗時回傳 None\n→ Step 3: Create tkinter root window // 初始化 tkinter 視窗\n→ Step 4: Create label to display rate // 建立顯示匯率的標籤\n→ Step 5: Create button with command fetch_and_update // 建立按鈕並指定點擊事件\n→ Step 6: Define function fetch_and_update() // 定義點擊按鈕時的行為\n    → Step 6.1: rate ← fetch_rate() // 呼叫抓取匯率函式\n    → Decision: rate is not None? // 檢查是否成功取得匯率\n        Yes → label.config(text = f\"USD to TWD: {rate}\") // 更新標籤文字\n        No  → label.config(text = \"Error fetching rate\") // 顯示錯誤訊息\n→ Step 7: Start tkinter mainloop // 啟動事件循環\nEnd // 程式結束\n\nWe need to follow format: \"虛擬碼步驟 [space] // 解釋\". Use \"→\" preceding each step except Start and End. Also need to indent? Not mandatory but nice. Use same style as example: \"→ Decision: ...\". So we can produce lines accordingly.\n\nMake sure each line has a single // explanation. Also nested steps maybe not required but we can indent with tabs or spaces; example shows indentation of Yes lines.\n\nThus final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests, tkinter // 載入需要的模組  \n→ Step 2: Define function fetch_rate() // 定義抓取匯率的函式  \n → Step 2.1: response ← requests.get(\"https://api.exchangerate-api.com/v4/latest/USD\") // 送出 GET 請求  \n → Decision: response.status_code == 200? // 檢查回應是否成功  \n  Yes → data ← response.json() // 解析 JSON  \n  Yes → rate ← data[\"rates\"][\"TWD\"] // 取得 TWD 匯率  \n  Yes → Return rate // 回傳匯率  \n  No  → Return None // 失敗時回傳 None  \n→ Step 3: Create tkinter root window // 初始化 tkinter 視窗  \n→ Step 4: Create label to display rate // 建立顯示匯率的標籤  \n→ Step 5: Create button with command fetch_and_update // 建立按鈕並指定點擊事件  \n→ Step 6: Define function fetch_and_update() // 定義點擊按鈕時的行為  \n → Step 6.1: rate ← fetch_rate() // 呼叫抓取匯率函式  \n → Decision: rate is not None? // 檢查是否成功取得匯率  \n  Yes → label.config(text = f\"USD to TWD: {rate}\") // 更新標籤文字  \n  No  → label.config(text = \"Error fetching rate\") // 顯示錯誤訊息  \n→ Step 7: Start tkinter mainloop // 啟動事件循環  \nEnd // 程式結束"
    },
    {
      "title": "Top K Frequent Elements",
      "source_file": "Leetcode/leetcode347.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe658v_s5.py\", line 47, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe658v_s5.py\", line 32, in parse_input\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd4vmx3lm.py\", line 47, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpd4vmx3lm.py\", line 32, in parse_input\n    nums = ast.literal_eval(nums_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\nimport heapq\n\ndef top_k_frequent(nums, k):\n    \"\"\"\n    找出 nums 中出現頻率最高的 k 個元素，返回列表。\n    先用 Counter 計算頻率，然後使用 heapq.nlargest 選取 k 個。\n    \"\"\"\n    count = Counter(nums)\n    # nlargest 返回的是 (element, freq) 的元組，按 freq 取前 k 個\n    top_k = [item for item, _ in heapq.nlargest(k, count.items(), key=lambda x: x[1])]\n    return top_k\n\ndef parse_input(raw_input: str):\n    \"\"\"\n    解析標準輸入，支援兩種格式：\n    1) 單行：'nums = [1,1,1,2,2,3], k = 2'\n    2) 兩行：第一行列表，第二行 k\n    \"\"\"\n    lines = raw_input.strip().splitlines()\n    if not lines:\n        return [], 0\n\n    # 先嘗試單行格式\n    if len(lines) == 1 and 'nums' in lines[0]:\n        line = lines[0]\n        # 分割為 nums 部分和 k 部分\n        parts = line.split(',', 1)\n        nums_part = parts[0].split('=', 1)[1].strip()\n        nums = ast.literal_eval(nums_part)\n        if len(parts) > 1:\n            k_part = parts[1].split('=', 1)[1].strip()\n            k = int(k_part)\n        else:\n            k = 0\n        return nums, k\n\n    # 兩行格式\n    nums = ast.literal_eval(lines[0].strip())\n    k = int(lines[1].strip()) if len(lines) > 1 else 0\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    result = top_k_frequent(nums, k)\n    # 按照題目示例輸出，去除空格\n    print(str(result).replace(' ', ''))",
      "virtual_code": "Thinking...\nWe need to produce pseudo code line by line. The pseudo code should be in English? It's natural language requirement: \"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\" We should produce steps: count frequencies using hash map, maybe use priority queue or sort by freq. Let's produce simple algorithm: use hash map for counts, then create list of pairs, sort descending by freq, take first k elements. Or use min-heap of size k. We just need pseudo code, not actual code.\n\nWe must use \"虛擬碼步驟\" each line, plus comment after space.\n\nUse arrow → etc. Use Start, End, Decision. Provide line by line.\n\nWe'll produce something like:\n\nStart\n→ Step 1: Initialize frequency_map as empty map // 用來記錄每個元素出現的次數\n→ Step 2: For each num in nums, increment frequency_map[num] // 逐個計數\n→ Step 3: Initialize an empty list freq_list // 存放 (num, count) 這對\n→ Step 4: For each key,value in frequency_map, append (key,value) to freq_list // 轉成列表\n→ Step 5: Sort freq_list by value descending // 按頻率降序\n→ Step 6: Initialize result as empty list // 存最頻繁的 k 個元素\n→ Step 7: For i from 0 to k-1, append freq_list[i].key to result // 取前 k 個\n→ End // 回傳 result\n\nBut we might want to include Decision step? Not necessary. But we can include Decision for k <= length freq_list? Usually k <= number of unique elements.\n\nWe could add Decision: If k > size of freq_list? but we can assume k <= unique elements. Could skip.\n\nAlternatively we can use min-heap approach: But easier to explain with sorting.\n\nThe instructions: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋。\"\n\nWe need to ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow '→'.\n\nShould we use English or Chinese? The example uses Chinese comments. We'll use Chinese for comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 frequency_map 為空字典 // 用於紀錄每個元素的出現頻率  \n→ Step 2: 對 nums 中每個 num 執行：frequency_map[num] += 1 // 逐一計數  \n→ Step 3: 初始化 freq_list 為空列表 // 存放 (num, count) 這對  \n→ Step 4: 對 frequency_map 中每個 key, value 執行：將 (key, value) 加入 freq_list // 轉成列表形式  \n→ Step 5: 按 value 降序排序 freq_list // 讓頻率最高的排在前面  \n→ Step 6: 初始化 result 為空列表 // 用來存最頻繁的 k 個元素  \n→ Step 7: 從 0 到 k-1，將 freq_list[i].key 加入 result // 取前 k 個元素  \n→ Decision: 如果 k 大於 freq_list 長度? // 這裡假設 k <= 唯一元素數量  \n    Yes → Step 8: 將 result 設為 freq_list 全部元素 // 防止 k 超過可用元素  \n    No  → // 直接回傳 result  \nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[2,0],[0,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [2, 0], [0, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols  # remaining zero cells\n        self.flipped = {}             # map from index to actual position\n\n    def flip(self):\n        # 產生 0 ~ self.total-1 的隨機整數（一次呼叫）\n        r = random.randint(0, self.total - 1)\n        # 取得映射後的實際索引\n        x = self.flipped.get(r, r)\n        # 失去一個可翻轉格子\n        self.total -= 1\n        # 把 r 映射到最後一個可用索引\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # 轉換為行列座標\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包成元組以方便解析\n    if not data.startswith('('):\n        data = '(' + data + ')'\n    ops, args = ast.literal_eval(data)\n\n    random.seed(0)  # 為了可重現的結果\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            result.append(None)\n        elif op == \"flip\":\n            result.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            result.append(None)\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm: maintain list of available indices, use reservoir / random mapping with index swapping. Approach: total m*n cells, maintain mapping from index to real position. Use random number r between 0 and remaining-1, get mapped position via dictionary (if exists else r). Place r in map to last available index. Reduce remaining. flip returns (pos//n, pos % n). reset clears map and remaining=m*n. Complexity O(1) per flip. Need to produce line by line virtual code with explanation.\n\nLet's design virtual steps:\n\nStart class Solution with m,n.\n\nInitialize total = m*n, remaining = total, map = {}.\n\nflip:\n\nIf remaining == 0? maybe not needed.\n\nGenerate random integer r in [0, remaining-1].\n\nmapped_r = map[r] if exists else r.\n\nSet map[r] = map[remaining-1] if exists else remaining-1.\n\nremaining -= 1.\n\nCompute i = mapped_r // n; j = mapped_r % n.\n\nReturn [i,j].\n\nreset: map = {} ; remaining = total.\n\nNeed to incorporate random function call count: we call random once per flip. Provide explanation lines accordingly.\n\nAlso mention complexity.\n\nLet's produce virtual code lines.\n\nWe also need Decision blocks? Not many decisions.\n\nWill use:\n\nStart\n\n→ Initialize Solution class // constructor\n\n→ Step: store m, n, total, remaining, map\n\n→ End Constructor\n\n→ Step: flip() // method start\n\n→ Decision: 是否還有可選索引？ (remaining > 0?) // optional\n\n    Yes → generate r = random(0, remaining-1) // single random call\n\n    ... etc\n\nBut we can keep simple.\n\nLet's output:\n\nStart // 程式開始執行\n\n→ Step 1: 定義類 Solution // 建立類別\n\n→ Step 2: Constructor Solution(m, n) // 初始化\n\n→ Step 3: 設定 total = m * n // 計算總格數\n\n→ Step 4: 設定 remaining = total // 剩餘未翻轉的格數\n\n→ Step 5: 建立空映射 map = {} // 用於映射索引\n\n→ End Constructor // 構造完成\n\n→ Step 6: 定義方法 flip() // 開始隨機翻轉\n\n→ Step 7: r = random_int(0, remaining - 1) // 產生隨機索引，僅一次呼叫\n\n→ Decision: 是否存在 map[r]？ // 檢查是否已映射\n\n    Yes → mapped = map[r] // 取映射值\n\n    No  → mapped = r // 直接使用 r\n\n→ Step 8: last = remaining - 1 // 取得最後可用索引\n\n→ Decision: 是否存在 map[last]？\n\n    Yes → map[r] = map[last] // 把最後映射值搬到 r\n\n    No  → map[r] = last // 使用 last\n\n→ Step 9: remaining = remaining - 1 // 更新剩餘數\n\n→ Step 10: i = mapped // n ; j = mapped % n // 轉換成二維座標\n\n→ Step 11: return [i, j] // 返回結果\n\n→ End flip // flip 方法結束\n\n→ Step 12: 定義方法 reset() // 重置\n\n→ Step 13: remaining = total // 重設剩餘\n\n→ Step 14: map.clear() // 清空映射\n\n→ End reset // 重置結束\n\nEnd // 程式結束\n\nNeed to include explanations after each line.\n\nAlso maybe include complexity comment at end.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義類 Solution // 建立處理矩陣的類別\n→ Step 2: Constructor Solution(m, n) // 初始化物件，接受矩陣大小\n→ Step 3: total = m * n // 計算矩陣中格子總數\n→ Step 4: remaining = total // 記錄目前仍為 0 的格子數量\n→ Step 5: map = {} // 建立映射表，用於交換索引，初始為空\n→ End Constructor // 初始化完成\n\n→ Step 6: 定義方法 flip() // 隨機選取並翻轉一個 0 為 1\n→ Step 7: r = random_int(0, remaining - 1) // 產生 0 到 remaining-1 的隨機整數（一次呼叫）\n→ Decision: 若 map 中存在 r? // 判斷 r 是否已被映射\n    Yes → mapped = map[r] // 若已映射，取得映射後的實際索引\n    No  → mapped = r // 若未映射，直接使用 r\n→ Step 8: last = remaining - 1 // 取得最後一個可用的索引\n→ Decision: 若 map 中存在 last? // 判斷 last 是否已被映射\n    Yes → map[r] = map[last] // 若已映射，將 last 的映射值搬到 r\n    No  → map[r] = last // 若未映射，將 last 本身搬到 r\n→ Step 9: remaining = remaining - 1 // 更新剩餘可翻轉的格子數量\n→ Step 10: i = mapped // n ; j = mapped % n // 把線性索引轉回二維座標\n→ Step 11: return [i, j] // 回傳被翻轉的格子座標\n→ End flip // flip 方法結束\n\n→ Step 12: 定義方法 reset() // 重置整個矩陣\n→ Step 13: remaining = total // 重新設定剩餘數量為全部格子\n→ Step 14: map.clear() // 清空映射表，恢復初始狀態\n→ End reset // reset 方法結束\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Longest Repeating Character Replacement",
      "source_file": "Leetcode/leetcode424.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6e5zk3j2.py\", line 57, in <module>\n    result = character_replacement(s, k)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6e5zk3j2.py\", line 17, in character_replacement\n    freq[idx] += 1\n    ~~~~^^^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkjbz0kmz.py\", line 57, in <module>\n    result = character_replacement(s, k)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkjbz0kmz.py\", line 17, in character_replacement\n    freq[idx] += 1\n    ~~~~^^^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef character_replacement(s: str, k: int) -> int:\n    \"\"\"\n    透過滑動窗口計算在不超過 k 次字符替換後，\n    能得到的最大同字母子字串長度。\n    \"\"\"\n    # 26 個大寫英文字母的頻率表\n    freq = [0] * 26\n    max_freq = 0      # 當前窗口中最高頻率字母\n    left = 0          # 左指標\n    best = 0          # 最長長度\n\n    for right, ch in enumerate(s):\n        idx = ord(ch) - ord('A')\n        freq[idx] += 1\n        max_freq = max(max_freq, freq[idx])\n\n        # 若需要替換的字母數量超過 k，則收縮窗口\n        while (right - left + 1) - max_freq > k:\n            freq[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        # 更新答案\n        best = max(best, right - left + 1)\n\n    return best\n\n\ndef parse_input() -> tuple[str, int]:\n    \"\"\"\n    從標準輸入讀取字串 s 與整數 k。\n    支援兩種常見格式：\n    1. 兩行，第一行是字串，第二行是整數\n    2. 兩行，類似 's = \"ABAB\", k = 2'\n    \"\"\"\n    raw = sys.stdin.read().strip().splitlines()\n    lines = [line.strip() for line in raw if line.strip()]\n\n    if len(lines) >= 2 and lines[0].startswith('s'):\n        # 解析 's = \"ABAB\", k = 2' 這類格式\n        s_match = re.search(r's\\s*=\\s*[\"\\']?([^\"\\']+)[\"\\']?', lines[0])\n        s = s_match.group(1) if s_match else lines[0]\n        k_match = re.search(r'k\\s*=\\s*(\\d+)', lines[1])\n        k = int(k_match.group(1)) if k_match else int(lines[1])\n    else:\n        # 直接給出字串與整數\n        s = lines[0]\n        k = int(lines[1]) if len(lines) > 1 else 0\n\n    return s, k\n\n\nif __name__ == \"__main__\":\n    s, k = parse_input()\n    result = character_replacement(s, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving: longest repeating char after up to k changes. Classic sliding window. We produce stepwise algorithm description. Let's produce virtual code. Use structure: Start, Decision, etc. Let's create steps: Read s,k. Initialize left=0, freq[26]=0, maxFreq=0, ans=0. Loop right from 0 to len-1: update freq, maxFreq= max(maxFreq, freq[s[right]]). If window length - maxFreq > k, shrink: freq[s[left]]--, left++. ans = max(ans, right-left+1). End. Return ans. We'll break into lines with explanation. Use \"→\" arrows.\n\nLet's format each line: \"虛擬碼步驟 // 解釋\".\n\nWe'll include steps: Start, Input, Initialize, Loop etc.\n\nAlso decisions: check window valid. Provide structure with Decision. We'll produce lines.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s, k // 取得字串與可改動次數  \n→ Initialize left = 0 // 左指標起始位置  \n→ Initialize freq[26] = 0 // 各字母出現頻率  \n→ Initialize maxFreq = 0 // 當前窗口中最高頻率字母  \n→ Initialize ans = 0 // 最長可得子字串長度  \n\n→ Decision: 是否已到達字串結尾? // 準備進行滑動窗口  \n    Yes → End // 處理完成，輸出 ans  \n    No  → Step: 右指標 right 從 0 到 s.length-1 逐步移動  \n\n→ Step: 更新 freq[s[right]]++ // 右指標字符進入窗口  \n→ Step: maxFreq = max(maxFreq, freq[s[right]]) // 更新最高頻率  \n→ Decision: (right - left + 1) - maxFreq > k ? // 檢查需改動數是否超過 k  \n    Yes → Step: freq[s[left]]-- // 從窗口中移除左指標字符  \n    → Step: left++ // 移動左指標縮小窗口  \n    No  → // 窗口合法，無需調整  \n→ Step: ans = max(ans, right - left + 1) // 更新答案  \n→ Decision: 是否還有更多右指標? // 繼續迴圈  \n    Yes → Step: 右指標 right++ // 移動到下一個字符  \n    No  → End // 迴圈結束  \n\nEnd // 程式執行結束，ans 為最長相同字母子字串長度"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppfczsnnq.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmppfczsnnq.py\", line 38, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppfczsnnq.py\", line 11, in __init__\n    self.lookup[(word[:i], word[j:])] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):\n                for j in range(L + 1):\n                    self.lookup[(word[:i], word[j:])] = weight\n\n    def f(self, prefix, suffix):\n        return self.lookup.get((prefix, suffix), -1)\n\ndef parse_input(data):\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) == 0:\n        return [], (\"\", \"\")\n    if len(lines) == 1:\n        # Input might be a single expression like: ['apple'], ['a','e']\n        words, query = ast.literal_eval(lines[0])\n    else:\n        words = ast.literal_eval(lines[0])\n        query = ast.literal_eval(lines[1])\n    if isinstance(query, (list, tuple)) and len(query) == 2:\n        prefix, suffix = query\n    else:\n        prefix = str(query)\n        suffix = \"\"\n    return words, (prefix, suffix)\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    words, (prefix, suffix) = parse_input(data)\n    wf = WordFilter(words)\n    print(wf.f(prefix, suffix))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the described algorithm. The user wants design of a special dictionary that searches words by prefix and suffix, WordFilter class with constructor and method f.\n\nWe need to produce step-by-step pseudo code, line by line, with explanation after each line. Use arrows and structure. Use virtual code steps like \"Start\", \"→\", \"Decision:\".\n\nWe need to design the algorithm: Typically, we can pre-process all words to build a Trie for prefix and suffix or use hash maps. For each word we can generate all combinations of prefix and suffix? Since constraints? Not provided. But typical solution: use a combined trie with a special separator. But we just need to produce pseudo-code.\n\nWe need to design WordFilter with initialization storing words, maybe precompute mapping from (prefix,suffix) to index. But naive might be heavy. Instead, we can use a Trie for prefix and suffix. For each node we store a list of indices of words that pass through. Then f: we traverse prefix trie to node, suffix trie to node, intersect indices, return max. But we can also combine into single trie with suffix reversed.\n\nSimpler: Use hash map of (prefix,suffix) -> max index. Precompute by iterating words and all prefixes and suffixes. Complexity high but okay for pseudo. We can show general approach: For each word index i, generate all prefixes and suffixes, add mapping.\n\nWe will produce pseudo code accordingly.\n\nLet's produce pseudo code:\n\nStart\n→ WordFilter(words): // constructor\n    → Store words array // keep words for reference\n    → Initialize dict map // mapping from (pref#suff) to index\n    → For each word with index i\n        → For each prefix p of word\n            → For each suffix s of word\n                → key = p + \"#\" + s\n                → dict[key] = i // store max index (overwrite)\n→ f(pref, suff): // search\n    → key = pref + \"#\" + suff\n    → If key in dict\n        → Return dict[key]\n    → Else\n        → Return -1\nEnd\n\nBut we need to show pseudo with arrows and explanation. Provide each line.\n\nWe should be careful: we might need to specify loops. Use \"For\" lines with indent.\n\nWe should show decision lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ WordFilter(words) // 建構子，接收字典中的單詞陣列\n    → Store words // 將單詞陣列保存到物件屬性\n    → Initialize map // 建立一個空的映射 (prefix#suffix → 最大索引)\n    → For i from 0 to words.length-1\n        → word ← words[i] // 取出當前單詞\n        → For p_len from 1 to word.length\n            → pref ← word.substring(0, p_len) // 取前綴\n            → For s_len from 1 to word.length\n                → suff ← word.substring(word.length - s_len) // 取後綴\n                → key ← pref + \"#\" + suff // 組合鍵\n                → map[key] ← i // 以當前索引覆蓋，確保最大索引\n→ f(pref, suff) // 查詢方法\n    → key ← pref + \"#\" + suff\n    → Decision: 是否存在 key?\n        Yes → Return map[key] // 回傳最大索引\n        No  → Return -1 // 無符合字詞\nEnd // 程式執行結束\n\nBut we also need each line explanation after //.\n\nAlso need to adhere to format: each line must have \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe also need arrows with \"→\". Use \"→\" before each step. For loops use \"→ For i from 0 to words.length-1\". Indent subsequent lines.\n\nLet's format as plain text, each line separated by newline.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ WordFilter(words) // 建構子，接收字典中的單詞陣列  \n    → Store words // 將單詞陣列保存到物件屬性  \n    → Initialize map // 建立一個空的映射 (prefix#suffix → 最大索引)  \n    → For i from 0 to words.length-1 // 逐一處理每個單詞  \n        → word ← words[i] // 取出當前單詞  \n        → For p_len from 1 to word.length // 產生所有前綴  \n            → pref ← word.substring(0, p_len) // 取得長度為 p_len 的前綴  \n            → For s_len from 1 to word.length // 產生所有後綴  \n                → suff ← word.substring(word.length - s_len) // 取得長度為 s_len 的後綴  \n                → key ← pref + \"#\" + suff // 組合前綴與後綴作為鍵  \n                → map[key] ← i // 以當前索引覆蓋，確保存的是最大的索引  \n→ f(pref, suff) // 查詢方法  \n    → key ← pref + \"#\" + suff // 組合查詢鍵  \n    → Decision: 是否存在 key? // 判斷鍵是否在映射中  \n        Yes → Return map[key] // 回傳對應的最大索引  \n        No  → Return -1 // 若不存在，回傳 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvesx92_j.py\", line 32, in <module>\n    commands, args_list = json.loads(raw_input)\n                          ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 64 (char 63)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if self.stack:\n            val = self.stack.pop()\n            if val == self.min_stack[-1]:\n                self.min_stack.pop()\n\n    def top(self):\n        return self.stack[-1] if self.stack else None\n\n    def getMin(self):\n        return self.min_stack[-1] if self.min_stack else None\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並解析 JSON\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 解析成兩個列表：commands 與 arguments\n    commands, args_list = json.loads(raw_input)\n\n    result = []\n    stack_obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MinStack\":\n            stack_obj = MinStack()\n            result.append(None)          # 初始化返回 null\n        elif cmd == \"push\":\n            stack_obj.push(args[0])\n            result.append(None)          # push 返回 null\n        elif cmd == \"pop\":\n            stack_obj.pop()\n            result.append(None)          # pop 返回 null\n        elif cmd == \"top\":\n            result.append(stack_obj.top())\n        elif cmd == \"getMin\":\n            result.append(stack_obj.getMin())\n        else:\n            # 其他未知命令，保持不變\n            result.append(None)\n\n    # 將結果轉成 JSON 字串並輸出\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Use virtual code steps with arrows. The requirement: design a stack that supports push, pop, top, getMin in O(1). Provide virtual code step by step. Should include class initialization, internal structure (two stacks maybe). Provide step lines with explanation comments. Use Start, End. Use Decision etc. Should produce each line.\n\nLet's produce:\n\nStart\n→ Step: Define MinStack class with two internal stacks: mainStack and minStack. // 初始化兩個棧\n→ Step: MinStack() constructor // 建構子，初始化棧\n→ Decision: 是否有任何初始值? // 檢查是否需要預設空棧\n    Yes → Step: mainStack ← Empty // 主棧初始化\n    No  → Step: mainStack ← Empty // 主棧初始化（同上） // optional\n→ Decision: 初始化 minStack // 但同樣\n... Actually simpler: Just show mainStack and minStack.\n\nBetter: We'll produce sequence of operations: push, pop, top, getMin.\n\nNeed to show internal logic:\n\nPush(val):\n  → mainStack.push(val)\n  → Decision: minStack.isEmpty OR val ≤ minStack.top?\n      Yes → minStack.push(val)\n      No → do nothing\n  // Push to minStack only if new value <= current min\n\nPop():\n  → val ← mainStack.pop()\n  → Decision: val == minStack.top?\n      Yes → minStack.pop()\n      No → do nothing\n\nTop():\n  → return mainStack.top()\n\nGetMin():\n  → return minStack.top()\n\nAlso handle empty conditions but not necessary for core.\n\nLet's produce virtual code line by line.\n\nWe must use \"Start\", \"End\" etc. Use \"→\" arrow lines. Provide explanation after comment.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step: 定義 MinStack 類別，內部包含兩個棧 mainStack 與 minStack // 建立兩個棧來儲存值與最小值\n\n→ Step: MinStack() // 建構子，初始化兩棧為空\n\n→ Decision: mainStack.isEmpty? // 確保主棧已初始化\n    Yes → Step: mainStack ← 空 // 主棧空\n    No  → Step: mainStack ← 空 // 主棧空（同上） // 只需初始化一次\n\n→ Decision: minStack.isEmpty? // 確保 minStack 已初始化\n    Yes → Step: minStack ← 空 // minStack 空\n    No  → Step: minStack ← 空 // minStack 空\n\n→ Step: push(val) // 將 val 推進主棧\n    → mainStack.push(val)\n    → Decision: minStack.isEmpty OR val ≤ minStack.top()?\n        Yes → minStack.push(val) // 若是新最小值，推進 minStack\n        No  → // 不做任何事\n    // 完成 push\n\n→ Step: pop() // 從主棧彈出頂部元素\n    → val ← mainStack.pop()\n    → Decision: val == minStack.top()?\n        Yes → minStack.pop() // 若彈出的元素是最小值，亦從 minStack 彈出\n        No  → // 不做任何事\n    // 完成 pop\n\n→ Step: top() // 取得主棧頂部元素\n    → return mainStack.top()\n    // 回傳最上面值\n\n→ Step: getMin() // 取得目前最小值\n    → return minStack.top()\n    // 回傳 minStack 的頂部即為全域最小值\n\nEnd // 程式結束\n\nBut the instruction: each line must be '虛擬碼步驟 + 空格 + // 解釋/說明' So we need each line as one line string.\n\nBetter to produce something like:\n\nStart // 程式開始\n→ Step: 定義 MinStack 類別，包含 mainStack 與 minStack // 建立兩個棧\n→ Step: MinStack() // 建構子\n→ Decision: mainStack.isEmpty? // 確認主棧已初始化\n    Yes → Step: mainStack ← 空 // 主棧空\n    No  → Step: mainStack ← 空 // 主棧空（已初始化）\n→ Decision: minStack.isEmpty? // 確認 minStack 已初始化\n    Yes → Step: minStack ← 空 // minStack 空\n    No  → Step: minStack ← 空 // minStack 空\n→ Step: push(val) // 推進值\n    → mainStack.push(val)\n    → Decision: minStack.isEmpty OR val ≤ minStack.top()?\n        Yes → minStack.push(val) // 新最小值進 minStack\n        No  → // 無操作\n→ Step: pop() // 彈出值\n    → val ← mainStack.pop()\n    → Decision: val == minStack.top()?\n        Yes → minStack.pop() // 同時彈出 minStack\n        No  → // 無操作\n→ Step: top() // 取得主棧頂\n    → return mainStack.top() // 返回頂部\n→ Step: getMin() // 取得最小值\n    → return minStack.top() // 返回 minStack 頂部\nEnd // 程式結束\n\nBut we might need to indent decisions? They used \"Yes →\", \"No →\". In the example, they used indentation like:\n\nDecision: ...  \n    Yes → Step ...  \n    No  → Decision ...  \n\nSo each line of decision must be separate lines.\n\nLet's produce accordingly.\n\nWe also need to include \"虛擬碼步驟\" maybe like \"Step: ...\" or \"Decision: ...\". Let's follow example: Use \"Step\" or \"Decision:\".\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始  \n→ Step: 定義 MinStack 類別，內部包含兩個棧 mainStack 與 minStack // 建立兩個棧來分別儲存值與最小值  \n→ Step: MinStack() // 建構子，初始化兩棧為空  \n→ Decision: mainStack.isEmpty? // 確認主棧已初始化  \n    Yes → Step: mainStack ← 空 // 主棧空  \n    No  → Step: mainStack ← 空 // 主棧空（已初始化）  \n→ Decision: minStack.isEmpty? // 確認 minStack 已初始化  \n    Yes → Step: minStack ← 空 // minStack 空  \n    No  → Step: minStack ← 空 // minStack 空（已初始化）  \n→ Step: push(val) // 推進新值到棧中  \n    → mainStack.push(val) // 將 val 推進主棧  \n    → Decision: minStack.isEmpty OR val ≤ minStack.top()? // 判斷是否為新的最小值  \n        Yes → minStack.push(val) // 新最小值推進 minStack  \n        No  → // 不做任何事  \n→ Step: pop() // 從主棧彈出頂部元素  \n    → val ← mainStack.pop() // 彈出主棧頂部  \n    → Decision: val == minStack.top()? // 判斷彈出元素是否為最小值  \n        Yes → minStack.pop() // 同時從 minStack 彈出  \n        No  → // 不做任何事  \n→ Step: top() // 取得主棧頂部元素  \n    → return mainStack.top() // 回傳主棧頂部值  \n→ Step: getMin() // 取得目前最小值  \n    → return minStack.top() // 回傳 minStack 的頂部（即全局最小）  \nEnd // 程式結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        return random.choice(self.num_indices[target])\n\ndef split_top_level(s: str):\n    \"\"\"Split a string into two top‑level parts separated by a comma.\"\"\"\n    counter = 0\n    for i, ch in enumerate(s):\n        if ch == '[':\n            counter += 1\n        elif ch == ']':\n            counter -= 1\n            if counter == 0:\n                # i is the index of the closing bracket of the first list\n                # Skip the comma and any following spaces\n                return s[:i + 1], s[i + 2:].strip()\n    return s, None\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the input into methods list and arguments list\n    methods_str, args_str = split_top_level(data)\n    methods = ast.literal_eval(methods_str)\n    args_list = ast.literal_eval(args_str)\n\n    results = []\n    instance = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # args is a list containing the nums array\n            instance = Solution(args[0])\n            results.append(None)  # constructor returns null\n        elif method == \"pick\":\n            # args is a list containing the target value\n            results.append(instance.pick(args[0]))\n        else:\n            # In case of other methods, we skip\n            results.append(None)\n\n    # Output results in JSON format (None -> null)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for this problem. The code will be a class Solution with a constructor taking an int array and a pick method. Implementation: Store the array, maybe store mapping from value to list of indices. But the requirement is to pick uniformly random among indices. We can precompute map from value to list of indices. In pick, retrieve list and random choose. Alternatively reservoir sampling: but easier to precompute map. Provide virtual steps: Start, store array, build map, etc. Need to produce line by line with arrow and explanation. Must not output actual code. So produce pseudo steps. Use arrow →. Use Decision where needed. The steps: Start, store nums, build map: iterate over nums, add index to map list. Then End. For pick: Start pick, retrieve list, generate random number between 0 and list size-1, get index, return. Use Decision: if list empty? but guarantee exists. Provide explanation. Also need to consider random selection: Use Random object. So steps: initialize random. Provide explanation.\n\nWe need to adhere to format: each line: \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nWe must include structure arrows. Use \"Start\" and \"End\". Use Decision: If target exists? etc. Use Yes → and No →.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 定義空的 HashMap<Int, List<Int>> indexMap // 用於存儲每個值對應的索引列表\n\n→ Step 2: 定義 Random rng = new Random() // 隨機數生成器\n\n→ Decision: 是否需要在構造函數中建構索引映射？ // 這裡是需要的\n\nYes → Step 3: 在 Constructor: 對於 i 從 0 到 nums.length-1 迭代\n\n→ Step 4:     如果 indexMap 沒有 key nums[i] 則新建空列表\n\n→ Step 5:     將 i 加入 indexMap[nums[i]] 的列表 // 保存索引\n\n→ Decision: 是否還有元素要處理？ // 迭代結束\n\nYes → Step 6: 循環繼續\n\nNo → Step 7: 完成建圖\n\nEnd // 建圖完成\n\nThen pick method:\n\nStart // pick 方法開始\n\n→ Step 1: 從 indexMap 取出 list = indexMap[target] // 找到所有目標索引\n\n→ Decision: list 是否為空？ // 根據題目不可能空\n\nYes → Step 2: return -1 // 這裡不會執行\n\nNo  → Step 3: 生成隨機整數 randIdx = rng.nextInt(list.size()) // 0 <= randIdx < list.size()\n\n→ Step 4: 取得結果索引 result = list.get(randIdx) // 隨機選中索引\n\n→ Step 5: 回傳 result // 結束\n\nEnd // pick 方法結束\n\nBut we need to output in specified format: each line \"虛擬碼步驟 // 解釋\". And use arrow.\n\nWe should separate the constructor and pick into separate sections. Use maybe comment lines.\n\nLet's produce all lines.\n\nWe should not output actual code like \"HashMap<Int, List<Int>>\". But virtual steps can include data structures names.\n\nLet's craft lines.\n\nAlso note: we should use \"Start\" at beginning of whole class? But we can start with \"Start\" for program. But within constructor and method we can use \"Step\" lines.\n\nWe'll do:\n\nStart // 程式開始執行\n\n→ Step 1: 定義 indexMap = new Map() // 建立一個映射，key 為數值，value 為索引列表\n\n→ Step 2: 定義 rng = new Random() // 用於產生隨機數\n\n→ Decision: 進入建圖階段？ // 必須進行\n\nYes → Step 3: 進入 Constructor: for i = 0 to nums.length-1\n\n→ Step 4:     key = nums[i] // 取得目前數值\n\n→ Step 5:     如果 indexMap 沒有 key 則 indexMap[key] = new List() // 初始化列表\n\n→ Step 6:     indexMap[key].add(i) // 把索引加入對應列表\n\n→ Decision: 是否還有未處理元素？ // 迴圈判斷\n\nYes → Step 7: 繼續循環\n\nNo → Step 8: 建圖完成\n\nEnd // 結構初始化完成\n\nThen method pick:\n\nStart // pick 方法開始\n\n→ Step 1: list = indexMap[target] // 取得所有目標索引\n\n→ Decision: list 是否為空？ // 理論上不會\n\nYes → Step 2: return -1 // 異常處理\n\nNo  → Step 3: randIdx = rng.nextInt(list.size()) // 隨機選擇索引位置\n\n→ Step 4: result = list.get(randIdx) // 取得該索引\n\n→ Step 5: return result // 結果回傳\n\nEnd // pick 方法結束\n\nWe must ensure each line with arrow. For lines inside decision, we need \"Decision:\" with Yes → and No →. Provide indentation. Use spaces accordingly. Provide explanation after //.\n\nWe need to maintain format with \"虛擬碼步驟\" + space + \"//\" explanation. So each line must be \"虛擬碼步驟 // 解釋\". For decision lines, we must keep arrow.\n\nExample: \"Decision: 進入建圖階段？\" then next lines with \"Yes → ...\". Let's craft.\n\nWe need to output with line breaks. Use same pattern as example. Provide no additional explanation outside of lines.\n\nLet's write final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 indexMap = new Map() // 建立一個映射，key 為數值，value 為索引列表  \n→ Step 2: 定義 rng = new Random() // 用於產生隨機數  \n→ Decision: 需要建圖？ // 构造函数必须构建索引映射  \n    Yes → Step 3: 進入 Constructor: for i = 0 to nums.length-1 // 循環遍歷數組索引  \n        → Step 4: key = nums[i] // 取得當前元素的值  \n        → Step 5: 如果 indexMap 沒有 key 則 indexMap[key] = new List() // 初始化索引列表  \n        → Step 6: indexMap[key].add(i) // 把索引加入對應列表  \n    Decision: 是否還有未處理元素？ // 循環判斷  \n        Yes → Step 7: 繼續循環  \n        No → Step 8: 建圖完成 // 所有索引已映射  \nEnd // 初始化結束  \n\nStart // pick 方法開始  \n→ Step 1: list = indexMap[target] // 取得所有目標索引列表  \n→ Decision: list 是否為空？ // 理論上不會  \n    Yes → Step 2: return -1 // 異常處理，防止空列表  \n    No → Step 3: randIdx = rng.nextInt(list.size()) // 隨機生成 0~size-1 的索引  \n        → Step 4: result = list.get(randIdx) // 取得隨機選中的索引  \n        → Step 5: return result // 回傳隨機索引  \nEnd // pick 方法結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eetr\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eetr'\nGot (Norm):      'eert'\n--- (Raw) ---\nRaw Expected: '\"eetr\"'\nRaw Got:      'eert'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"cccaaa\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'cccaaa'\nGot (Norm):      'aaaccc'\n--- (Raw) ---\nRaw Expected: '\"cccaaa\"'\nRaw Got:      'aaaccc'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"\n        Sort characters of `s` in decreasing order of frequency.\n        If two characters have the same frequency, any order is fine.\n        \"\"\"\n        # Count frequency of each character\n        freq = Counter(s)\n        # Sort by frequency descending, then by character ascending for stability\n        sorted_pairs = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\n        # Build the result string\n        return ''.join(char * count for char, count in sorted_pairs)\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Extract the string value from the input.\n    Handles formats like:\n        s = \"tree\"\n        \"tree\"\n        tree\n    \"\"\"\n    data = data.strip()\n    if '=' in data:\n        # Split on first '='\n        _, rhs = data.split('=', 1)\n        data = rhs.strip()\n    # Remove surrounding quotes if present\n    if (data.startswith('\"') and data.endswith('\"')) or (data.startswith(\"'\") and data.endswith(\"'\")):\n        data = data[1:-1]\n    return data\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Parse the string value\n    s = parse_input(raw_input)\n    # Compute the frequency sorted string\n    solution = Solution()\n    result = solution.frequencySort(s)\n    # Output the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for sorting string by decreasing frequency. Provide step-by-step. Use Start, End, Decision. Use arrow and each line has explanation. We'll produce algorithm: count frequencies using map; create list of pairs (char, freq); sort by freq descending; build result string by repeating each char freq times; return result. Provide virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者或呼叫者取得要排序的字串  \n→ Step 2: 初始化字典 freqMap 為空 // 用於存放每個字元的頻率  \n→ Step 3: 針對 s 中每個字元 ch 進行迴圈  \n  → Decision: 是否已在 freqMap? // 檢查字元是否已計數  \n   Yes → Step 4: freqMap[ch] ← freqMap[ch] + 1 // 先前已存在，頻率加 1  \n   No  → Step 5: freqMap[ch] ← 1 // 首次遇到，頻率設定為 1  \n→ Step 6: 轉換 freqMap 為字元-頻率對列表 pairList // 方便排序  \n→ Step 7: 以頻率遞減排序 pairList // 主要排序條件  \n  → Decision: 是否需要 tie‑break? // 若頻率相同可任意順序  \n   Yes → Step 8: 以字元遞增排序相同頻率對  \n   No  → Step 9: 保持現有順序  \n→ Step 10: 初始化空字串 result // 用於組裝最終答案  \n→ Step 11: 對 pairList 中每個 (ch, count) 進行迴圈  \n  → Step 12: result ← result + ch repeated count 次 // 將該字元重複拼接  \n→ Step 13: 輸出 result // 回傳按頻率降序排列的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of the distinct integers in nums.\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                # 把目前排列的複製加入結果\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                # 交換當前位置與 i 位置的元素\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                # 回溯：恢復原始順序\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    # 從輸入中擷取列表字串，例如 \"nums = [1,2,3]\"\n    match = re.search(r'nums\\s*=\\s*(\\[.*\\])', raw_input)\n    if match:\n        nums_str = match.group(1)\n        try:\n            nums = ast.literal_eval(nums_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    solution = Solution()\n    permutations = solution.permute(nums)\n    print(permutations)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all permutations of an array of distinct integers, with explanation. Each line should have \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for steps, Decision: for conditions. Use Start, End.\n\nWe need to detail algorithm: backtracking.\n\nWe need to produce step-by-step pseudocode. Each step could be: Start, Step 1: Initialize result list, Step 2: Define backtrack function, etc. Then call backtrack([], set()) etc.\n\nWe need to be concise but include explanation. Use \"→\" arrow before each step. Indent for nested steps? Use the format as in example: \"→ Step 1: ...\". For Decision, indent child steps with 4 spaces? In example, indent two spaces before Yes. We'll follow similar.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: Initialize result list res = [] // 用於儲存所有排列\n→ Step 2: 定義遞迴函式 backtrack(current, used) // current為目前排列, used為已選的索引\n→ Decision: 若 current長度等於 nums長度? // 判斷是否完成一個排列\n    Yes → Step 3: 將 current的複製加入res // 完整排列加入結果\n    No → Decision: 對於每個索引i從0到len(nums)-1? // 遍歷所有元素\n        Yes → Decision: i是否在used? // 檢查此元素是否已使用\n            Yes → Continue // 跳過已使用元素\n            No → Step 4: Add i到current, mark i為used // 選擇元素\n                → Step 5: 呼叫 backtrack(current, used) // 進一步遞迴\n                → Step 6: 移除i自current, 從used中移除 // 回溯\n→ Step 7: 呼叫 backtrack([], empty set) // 開始遞迴\n→ Step 8: 回傳 res // 傳回所有排列\nEnd // 程式執行結束\n\nNeed to ensure each line uses \"→\" except Start and End? In example, Start and End not have arrow. Steps start with \"→\". Decision also start with \"→ Decision:\"? In example, Decision: starts after arrow.\n\nLet's produce. Also each line should have \" // 解釋\" after step. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果列表 res ← [] // 用於儲存所有排列  \n→ Step 2: 定義遞迴函式 backtrack(current, used) // current為目前排列，used為已使用的索引集合  \n→ Decision: 若 current 的長度等於 nums 的長度? // 判斷是否已形成完整排列  \n Yes → Step 3: 把 current 的複製加入 res // 完整排列加入結果  \n No → Decision: 對於每個索引 i 從 0 到 len(nums)-1? // 遍歷所有可能的元素  \n  Yes → Decision: i 是否已在 used? // 檢查此元素是否已被選取  \n   Yes → Continue // 跳過已使用的元素  \n   No → Step 4: 把 nums[i] 加入 current，將 i 加入 used // 選擇此元素  \n    → Step 5: 呼叫 backtrack(current, used) // 進一步遞迴  \n    → Step 6: 移除 nums[i] 從 current，將 i 從 used 移除 // 回溯到上一層  \n→ Step 7: 呼叫 backtrack([], ∅) // 開始遞迴，初始為空排列和空集合  \n→ Step 8: 回傳 res // 傳回所有排列結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7n33c40b.py\", line 77, in <module>\n    words, maxWidth = parse_input(data)\n                      ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7n33c40b.py\", line 63, in parse_input\n    words = ast.literal_eval(words_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"]\n    ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmm0ik01p.py\", line 77, in <module>\n    words, maxWidth = parse_input(data)\n                      ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmm0ik01p.py\", line 63, in parse_input\n    words = ast.literal_eval(words_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"]\n    ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5c6j845p.py\", line 77, in <module>\n    words, maxWidth = parse_input(data)\n                      ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5c6j845p.py\", line 63, in parse_input\n    words = ast.literal_eval(words_part)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # determine how many words can fit in the line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            # build the line\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(word) for word in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # left-justify for last line or single word\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                # fully justify\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k] + ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef parse_input(data):\n    \"\"\"Parse input that may be in one or two lines.\"\"\"\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        # assume first line contains the list, second line the integer\n        words_line = lines[0]\n        max_line = lines[1]\n        try:\n            words = ast.literal_eval(words_line.split('=')[-1].strip())\n        except Exception:\n            words = ast.literal_eval(words_line.strip())\n        try:\n            maxWidth = int(max_line.split('=')[-1].strip())\n        except Exception:\n            maxWidth = int(max_line.strip())\n        return words, maxWidth\n    else:\n        # single line: e.g. 'words = [...], maxWidth = 16'\n        text = lines[0]\n        if 'maxWidth' in text:\n            parts = text.split('maxWidth')\n            words_part = parts[0].split('words')[-1].strip()\n            if words_part.endswith(','):\n                words_part = words_part[:-1]\n            words = ast.literal_eval(words_part)\n            maxWidth = int(parts[1].strip().split('=')[-1])\n            return words, maxWidth\n        else:\n            # fallback: split by space\n            tokens = text.split()\n            maxWidth = int(tokens[-1])\n            words = ast.literal_eval(' '.join(tokens[:-1]))\n            return words, maxWidth\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n    words, maxWidth = parse_input(data)\n    solution = Solution()\n    result = solution.fullJustify(words, maxWidth)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step, each line with arrow, step, comment. No actual code, just pseudocode steps. We must cover algorithm: iterate words, build lines greedily, compute spaces, distribute spaces, last line left justified. Let's produce steps:\n\nStart\n→ Initialize result list\n→ Initialize currentLineWords list, currentLineLength=0\n→ For each word in words:\n    Decision: if currentLineLength + len(word) + len(currentLineWords) > maxWidth?\n        Yes → Process current line: compute spaces and build line string; append to result; reset currentLineWords and currentLineLength\n        No → Add word to currentLineWords; add len(word) to currentLineLength\nAfter loop, process last line (left justified)\n→ Return result\n\nProcessing current line: if only one word -> line = word + spaces; else compute total spaces = maxWidth - currentLineLength; slots = len(currentLineWords)-1; baseSpace = totalSpaces // slots; extra = totalSpaces % slots; build string by iterating words, adding baseSpace+1 for first extra slots, else baseSpace.\n\nLast line: join words with single space, then pad end with spaces to reach maxWidth.\n\nWe need to write these as virtual code lines with arrows. Each line must be: \"虛擬碼步驟 // 解釋\". Use arrows (→). For decisions: \"Decision: ...\" and then Yes→ and No→ with indentation.\n\nLet's produce. Ensure each line separate. Also include \"End\". Let's write accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize result list, currentLineWords list, currentLineLength = 0 // 準備儲存結果與目前行資訊\n→ Decision: 對 words 的每個 word 進行迭代? // 逐個處理輸入字串\n    → For word in words: // 取得下一個字串\n        Decision: 是否將 word 加入目前行? // 檢查行長度是否會超過 maxWidth\n            Yes → \n                → Append currentLineWords to result with full justification // 將目前行完成並加入結果\n                → Reset currentLineWords = [], currentLineLength = 0 // 清空行資料，準備下一行\n            No → \n                → Add word to currentLineWords // 把字串加入目前行\n                → currentLineLength += len(word) // 更新目前行字串長度\n→ Decision: 處理最後一行? // 迴圈結束後需要處理最後一行\n    → \n        → Join currentLineWords with single spaces → leftJustifiedLine // 以單空格連接字串\n        → Pad leftJustifiedLine with trailing spaces to reach maxWidth // 右邊填充空格\n        → Append leftJustifiedLine to result // 加入結果\nEnd // 程式執行結束\n\n// 處理目前行的細節（在 Yes 分支中使用）\n→ Decision: currentLineWords 是否只包含一個字串? // 判斷行中字數\n    → Yes → \n        → line = word + spaces(maxWidth - len(word)) // 只有一個字串，右側填充空格\n    → No → \n        → totalSpaces = maxWidth - currentLineLength // 需要填充的總空格數\n        → slots = len(currentLineWords) - 1 // 空格槽位數\n        → baseSpace = totalSpaces // slots // 每槽基礎空格數\n        → extra = totalSpaces % slots // 左側多餘空格數\n        → Initialize line = \"\"\n        → For i, w in enumerate(currentLineWords): // 遍歷字串\n            → Append w to line // 加入字串\n            → If i < slots: // 不是最後一個字串\n                → spacesToAdd = baseSpace + (1 if i < extra else 0) // 左側多空格\n                → Append ' ' * spacesToAdd to line // 加入空格\n        → // line 現在已完全對齊\n        → // 回傳 line 到上層流程\n// 以上為核心邏輯的虛擬碼示範，具體實作可依據語言語法調整。"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []  # 存放所有元素的陣列\n        self.idx_map = collections.defaultdict(set)  # value -> 集合(其索引)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，若是第一次插入返回 True，否則返回 False\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val，若成功返回 True，否則 False\"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 取出任意一個索引進行移除\n        remove_idx = self.idx_map[val].pop()\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n\n        # 用最後一個元素覆蓋被刪除的位置\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n\n        # 刪除最後一個元素\n        self.data.pop()\n\n        # 若 val 已無剩餘，從映射中移除\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素，機率與其數量成正比\"\"\"\n        return random.choice(self.data)\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析兩個列表：ops 和 args\n    close_bracket_idx = raw_input.find(']')\n    ops_str = raw_input[:close_bracket_idx + 1]\n    rest = raw_input[close_bracket_idx + 1:].strip()\n    if rest.startswith(','):\n        rest = rest[1:].strip()\n    args_str = rest\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)  # 代表 null\n        elif op == \"insert\":\n            result.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            result.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            result.append(obj.getRandom())\n\n    # 輸出符合 LeetCode 期望的 JSON 格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, each line \"虛擬碼步驟 // 解釋\". We need to produce the algorithm for RandomizedCollection. Typical solution uses vector and map<val, set<indices>>. Insert: push_back to vector, add index to set. If val was not present before, return true. Remove: check if map[val] non-empty. Get an index from set, remove that index from set. If index != last index: swap with last element in vector, update map for swapped element's index set. Pop_back. Return true.\n\nAlso need getRandom: random index into vector, return element.\n\nWe need to produce \"Start\" etc. Probably break down steps into high-level algorithm of class methods.\n\nWe need to produce a step-by-step algorithm for each method. Should be in virtual code format. Should not output actual code but conceptual steps.\n\nSo produce sequence: Start, initialize data structures. Then for insert, etc.\n\nProbably each method is separate block. We can produce start of class, then each method block with comments. We need to ensure \"逐行\" means each line separate. Use arrow \"→\". Use Decision etc.\n\nLet's produce:\n\nStart\n→ Init: create list arr = [] // dynamic array for elements\n→ Init: create dict map = {} // value -> set of indices\n\nInsert(val):\n→ Start // method insert\n→ Decision: 是否存在 map[val]? // check if val already in map\n    No  → add new set for val in map\n→ Append val to arr // add to end\n→ index = arr.size() - 1\n→ Add index to map[val]\n→ Decision: map[val] size == 1? // was val absent before\n    Yes → return true // inserted new element\n    No  → return false // duplicate\n\nRemove(val):\n→ Start // method remove\n→ Decision: 是否存在 map[val] 且 非空? // check presence\n    No  → return false\n→ Pick any index from map[val] // e.g., get one element\n→ Remove that index from map[val]\n→ lastIndex = arr.size() - 1\n→ lastVal = arr[lastIndex]\n→ Decision: index != lastIndex?\n    Yes → arr[index] = lastVal // overwrite removed spot\n    → Update map[lastVal]: remove lastIndex, add index\n→ Remove last element from arr // pop_back\n→ Decision: map[val] 为空? // if no more occurrences\n    Yes → delete map[val]\n→ return true\n\ngetRandom():\n→ Start // method getRandom\n→ randIndex = random between 0 and arr.size()-1\n→ return arr[randIndex]\n\nEnd\n\nNeed to follow format: \"虛擬碼步驟 // 解釋\". Use arrow arrow \"→\" and \"Decision:\" etc.\n\nLet's produce the virtual code accordingly.\n\nMake sure to start with \"Start // 程式開始執行\" and end with \"End // 程式執行結束\". We can have sub-blocks inside. We'll use indent maybe but not required.\n\nWe'll produce in Chinese. Ensure each line has step and comment.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Init: 建立動態陣列 list = [] // 用於儲存所有元素\n→ Init: 建立字典 map = {} // key: val, value: 集合(索引)\n\nInsert(val):\n→ Start // 方法 insert 開始\n→ Decision: map 是否已包含 key val? // 檢查 val 是否已存在\n    Yes → // val 已存在\n    No  → map[val] = {} // 新增空集合\n→ Append val 到 list // 把 val 加入陣列尾端\n→ index = list.size() - 1 // 取得新元素的索引\n→ map[val].add(index) // 把索引加入對應集合\n→ Decision: map[val] 的大小 == 1? // 檢查這是否是第一次插入 val\n    Yes → return true // 新元素插入\n    No  → return false // 只新增重複項\n\nRemove(val):\n→ Start // 方法 remove 開始\n→ Decision: map 是否包含 key val 且 map[val] 非空? // 判斷 val 是否存在\n    No  → return false // 沒有要移除的項\n→ idx = map[val].任意取一個索引 // 取得任意一個 val 的位置\n→ map[val].remove(idx) // 從集合移除該索引\n→ lastIdx = list.size() - 1\n→ lastVal = list[lastIdx] // 取陣列最後一個元素\n→ Decision: idx != lastIdx? // 檢查是否刪除的是最後一個元素\n    Yes → // 需要交換\n        list[idx] = lastVal // 用最後一個元素覆蓋被刪除的位置\n        map[lastVal].remove(lastIdx) // 移除 lastVal 的舊索引\n        map[lastVal].add(idx) // 加入新的索引\n→ Remove last element from list // 刪除陣列尾端\n→ Decision: map[val] 为空? // 檢查 val 是否已無剩餘\n    Yes → delete map[val] // 刪除空集合\n→ return true // 成功移除一個\n\nGetRandom():\n→ Start // 方法 getRandom 開始\n→ randIdx = 隨機整數 [0, list.size() - 1] // 隨機選取索引\n→ return list[randIdx] // 回傳該位置的值\n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '-1'"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start, end, bank):\n        # 若目標基因不在銀行中，無法完成突變\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i+1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\ndef parse_input():\n    data = sys.stdin.read()\n    # 匹配形如 key = value 的對\n    pairs = re.findall(r'(\\w+)\\s*=\\s*(.+)', data)\n    values = {}\n    for key, val in pairs:\n        val = val.strip()\n        try:\n            # 對於字串或列表使用 literal_eval 解析\n            values[key] = ast.literal_eval(val)\n        except Exception:\n            # 若解析失敗，直接去掉引號\n            values[key] = val.strip('\"').strip(\"'\")\n    return values.get('startGene'), values.get('endGene'), values.get('bank', [])\n\nif __name__ == \"__main__\":\n    startGene, endGene, bank = parse_input()\n    solution = Solution()\n    result = solution.minMutation(startGene, endGene, bank)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for finding minimum mutations using BFS. Use virtual code lines with arrow etc. No real code. Use Start, Decision, etc. Provide each line with explanation. Ensure each line ends with // explanation. Use 8-char string, choices, bank. We produce BFS. Steps: Start, check endGene in bank, if not return -1. Use queue, visited set, steps counter. While queue not empty, pop, if current equals endGene return steps. For each position 0-7, for each char in 'ACGT', if char != current[i], build new gene, if in bank and not visited, add to queue, mark visited. After loop, increment steps. If BFS ends return -1. Use virtual arrows. Ensure we show lines.\n\nLet's produce.\n\nWe also must show steps for initial check. Also handle bank set.\n\nWe must not produce code. Use virtual code syntax as requested. Use '→' and 'Decision:' etc. Each line as \"Step X: ...\" maybe.\n\nLet's construct. Ensure \"Start // 程式開始執行\".\n\nWe'll use '→' lines. We'll include 'Decision:' for if endGene not in bank? Actually if not in bank, return -1. We could early exit. But BFS will fail anyway. But we can include early decision.\n\nWe'll show:\n\nStart\n\n→ Step 1: 設定 bank_set = bank 列表轉集合 // 方便查詢\n\n→ Decision: 若 endGene 不在 bank_set? // 檢查目標是否有效\n\nYes → Step 2: 回傳 -1 // 無效目標\n\nNo  → Step 3: 初始化 queue = [(startGene, 0)] // 存放基因與步數\n\n→ Step 4: 初始化 visited = {startGene} // 標記已探索\n\n→ Decision: 若 startGene 等於 endGene? // 直接已達目標\n\nYes → Step 5: 回傳 0 // 無需突變\n\nNo  → Step 6: 開始 BFS 迴圈\n\n    → Step 7: 從 queue 取出 current, steps // 取得目前基因與已做突變數\n\n    → Decision: 若 current 等於 endGene? // 判斷是否到達\n\n        Yes → Step 8: 回傳 steps // 找到最短路徑\n\n        No  → Step 9: 為每個位置 i 從 0 到 7\n\n            → Step 10: 對每個字母 ch in 'ACGT'\n\n                → Decision: 若 ch 與 current[i] 不同? // 只嘗試改變\n\n                    Yes → Step 11: 建立 newGene = current[0:i] + ch + current[i+1:] // 產生新基因\n\n                    → Decision: 若 newGene 在 bank_set 且不在 visited? // 有效且未訪問\n\n                        Yes → Step 12: 加入 queue (newGene, steps+1) // 記錄下一步\n\n                        → Step 13: 加入 visited newGene // 標記已訪問\n\n                    No  → Step 14: 跳過\n\n                No  → Step 15: 跳過\n\n            → Step 16: 結束內部循環\n\n        → Step 17: 結束外部循環\n\n    → Step 18: 迴圈結束 // queue 空\n\n→ Step 19: 回傳 -1 // 未找到路徑\n\nEnd // 程式執行結束\n\nMake sure each line has explanation after //.\n\nWe need to include arrow and indentation? The example shows indent using spaces. We'll use similar.\n\nAlso use \"Decision:\" for branching. Use \"Yes →\" and \"No →\".\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 bank_set = bank 列表轉集合 // 方便查詢\n→ Decision: 若 endGene 不在 bank_set? // 檢查目標是否有效\n    Yes → Step 2: 回傳 -1 // 無效目標，無法達成\n    No  → Step 3: 初始化 queue = [(startGene, 0)] // 存放基因與步數\n→ Step 4: 初始化 visited = {startGene} // 標記已探索\n→ Decision: 若 startGene 等於 endGene? // 直接已達目標\n    Yes → Step 5: 回傳 0 // 無需突變\n    No  → Step 6: 開始 BFS 迴圈\n        → Step 7: 從 queue 取出 current, steps // 取得目前基因與已做突變數\n        → Decision: 若 current 等於 endGene? // 判斷是否到達\n            Yes → Step 8: 回傳 steps // 找到最短路徑\n            No  → Step 9: 為每個位置 i 從 0 到 7\n                → Step 10: 對每個字母 ch in 'ACGT'\n                    → Decision: 若 ch 與 current[i] 不同? // 只嘗試改變\n                        Yes → Step 11: 建立 newGene = current[0:i] + ch + current[i+1:] // 產生新基因\n                        → Decision: 若 newGene 在 bank_set 且不在 visited? // 有效且未訪問\n                            Yes → Step 12: 加入 queue (newGene, steps+1) // 記錄下一步\n                            → Step 13: 加入 visited newGene // 標記已訪問\n                        No  → Step 14: 跳過\n                    No  → Step 15: 跳過\n                → Step 16: 結束內部循環\n            → Step 17: 結束外部循環\n        → Step 18: 迴圈結束 // queue 空\n→ Step 19: 回傳 -1 // 未找到路徑\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpywunceul.py\", line 75, in <module>\n    main()\n  File \"/tmp/tmpywunceul.py\", line 50, in main\n    ops, args = parse_input(data)\n                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpywunceul.py\", line 45, in parse_input\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[], [1], [2], [], [3], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (store negatives)\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        if not self.small or num <= -self.small[0]:\n            heapq.heappush(self.small, -num)\n        else:\n            heapq.heappush(self.large, num)\n\n        # balance heaps\n        if len(self.small) > len(self.large) + 1:\n            heapq.heappush(self.large, -heapq.heappop(self.small))\n        elif len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return [], []\n\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) == 1:\n        # single line format: ops, args\n        idx = lines[0].find('],')\n        if idx != -1:\n            ops_str = lines[0][:idx+1]\n            args_str = '[' + lines[0][idx+2:]\n        else:\n            ops_str, args_str = lines[0], '[]'\n    else:\n        ops_str, args_str = lines[0], lines[1]\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    data = sys.stdin.read()\n    ops, args = parse_input(data)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            results.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])  # arg is a single-element list\n            results.append(None)\n        elif op == \"findMedian\":\n            results.append(obj.findMedian())\n\n    # Format output: None -> null, others as is\n    formatted = []\n    for r in results:\n        if r is None:\n            formatted.append(\"null\")\n        else:\n            formatted.append(str(r))\n    print(\"[\" + \", \".join(formatted) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MedianFinder with operations: constructor, addNum, findMedian. Use priority queues: max-heap for lower half, min-heap for upper half. Balance sizes: size difference <=1. findMedian: if sizes equal, average top of both; else top of larger.\n\nWe need step-by-step pseudocode, each line with explanation. Use Start, End, Decision, arrow. Ensure to include method definitions.\n\nWe output:\n\nStart\n→ Step 1: 定義 MedianFinder 類別 // Class definition\n    → Step 2: 宣告 maxHeap: 儲存較小的一半，使用最大堆 // max-heap for lower half\n    → Step 3: 宣告 minHeap: 儲存較大的一半，使用最小堆 // min-heap for upper half\n→ Step 4: 建構子 MedianFinder() // constructor\n        → Step 5: 初始化 maxHeap 為空 // empty max-heap\n        → Step 6: 初始化 minHeap 為空 // empty min-heap\n→ Step 7: 方法 addNum(num) // add number\n        → Decision: num <= maxHeap.top() ? // 若 num <= max element of lower half\n            Yes → Step 8: maxHeap.push(num) // push to maxHeap\n            No  → Step 9: minHeap.push(num) // push to minHeap\n        → Decision: maxHeap.size() > minHeap.size() + 1 ? // balance: maxHeap too large\n            Yes → Step 10: minHeap.push(maxHeap.top()); maxHeap.pop(); // move one from max to min\n            No →\n        → Decision: minHeap.size() > maxHeap.size() + 1 ? // balance: minHeap too large\n            Yes → Step 11: maxHeap.push(minHeap.top()); minHeap.pop(); // move one from min to max\n            No →\n→ Step 12: 方法 findMedian() // find median\n        → Decision: maxHeap.size() == minHeap.size() ? // equal sizes\n            Yes → Step 13: return (maxHeap.top() + minHeap.top()) / 2.0 // average\n            No →\n        → Decision: maxHeap.size() > minHeap.size() ? // maxHeap larger\n            Yes → Step 14: return maxHeap.top() // median is top of maxHeap\n            No → Step 15: return minHeap.top() // median is top of minHeap\nEnd\n\nNeed to ensure each line ends with comment.\n\nAlso include arrow lines properly. Ensure indentation maybe with spaces.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 MedianFinder 類別 // 建立類別框架\n    → Step 2: 宣告 maxHeap: 儲存較小的一半，使用最大堆 // 用於存放較小數值\n    → Step 3: 宣告 minHeap: 儲存較大的一半，使用最小堆 // 用於存放較大數值\n→ Step 4: 建構子 MedianFinder() // 初始化構造函式\n        → Step 5: 初始化 maxHeap 為空 // 空的最大堆\n        → Step 6: 初始化 minHeap 為空 // 空的最小堆\n→ Step 7: 方法 addNum(num) // 將新數字加入資料結構\n        → Decision: num <= maxHeap.top() ? // 判斷新數是否屬於較小的一半\n            Yes → Step 8: maxHeap.push(num) // 放入 maxHeap\n            No  → Step 9: minHeap.push(num) // 放入 minHeap\n        → Decision: maxHeap.size() > minHeap.size() + 1 ? // 平衡：maxHeap 過大\n            Yes → Step 10: minHeap.push(maxHeap.top()); maxHeap.pop(); // 從 maxHeap 移到 minHeap\n            No →\n        → Decision: minHeap.size() > maxHeap.size() + 1 ? // 平衡：minHeap 過大\n            Yes → Step 11: maxHeap.push(minHeap.top()); minHeap.pop(); // 從 minHeap 移到 maxHeap\n            No →\n→ Step 12: 方法 findMedian() // 計算並回傳目前的中位數\n        → Decision: maxHeap.size() == minHeap.size() ? // 數量相等時取平均\n            Yes → Step 13: return (maxHeap.top() + minHeap.top()) / 2.0 // 兩中位數平均\n            No →\n        → Decision: maxHeap.size() > minHeap.size() ? // maxHeap 多一個\n            Yes → Step 14: return maxHeap.top() // maxHeap 顶端即為中位數\n            No → Step 15: return minHeap.top() // minHeap 顶端即為中位數\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nINF = 10 ** 9\n\ndef collapse(s: str) -> str:\n    \"\"\"\n    Remove all consecutive groups of 3 or more same-colored balls recursively.\n    \"\"\"\n    changed = True\n    while changed:\n        changed = False\n        i = 0\n        new_parts = []\n        n = len(s)\n        while i < n:\n            j = i + 1\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:\n                changed = True\n                i = j  # skip this group\n            else:\n                new_parts.append(s[i:j])\n                i = j\n        s = ''.join(new_parts)\n    return s\n\nclass Solution:\n    def __init__(self):\n        self.memo = {}\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        hand_counts = Counter(hand)\n\n        def dfs(b: str, counts: Counter) -> int:\n            if not b:\n                return 0\n            key = (b, tuple(sorted(counts.items())))\n            if key in self.memo:\n                return self.memo[key]\n            best = INF\n            for color, cnt in counts.items():\n                if cnt == 0:\n                    continue\n                for i in range(len(b) + 1):\n                    # Skip useless insertions that cannot help removal\n                    # If left char equals color and right char also equals color, insertion won't change\n                    if i > 0 and b[i - 1] == color:\n                        continue\n                    if i < len(b) and b[i] == color:\n                        continue\n                    # Insert the ball\n                    new_board = b[:i] + color + b[i:]\n                    new_board = collapse(new_board)\n                    counts[color] -= 1\n                    res = dfs(new_board, counts)\n                    counts[color] += 1\n                    if res != INF:\n                        best = min(best, res + 1)\n            self.memo[key] = best\n            return best\n\n        ans = dfs(board, hand_counts)\n        return ans if ans != INF else -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    board_match = re.search(r'board\\s*=\\s*\"([^\"]*)\"', data)\n    hand_match = re.search(r'hand\\s*=\\s*\"([^\"]*)\"', data)\n    board = board_match.group(1) if board_match else ''\n    hand = hand_match.group(1) if hand_match else ''\n    solution = Solution()\n    result = solution.findMinStep(board, hand)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this Zuma problem: find min insertions to clear board, given hand string. Classic problem: use DFS + memoization, backtracking. We need step-by-step pseudocode. Not actual code, but conceptual steps. Use virtual code with arrows. Provide each line with explanation. Need to incorporate recursion, state compression, memo. Outline algorithm:\n\nStart\n→ Define function minInsertions(board, hand) // main\n→ If board empty return 0\n→ Use memo map for state (board, hand counts)\n→ If memo contains return value\n→ For each color in hand counts > 0\n    → For each possible insertion position in board (including ends)\n        → Insert ball at position\n        → Simulate removal chain: while true, find group of >=3, remove, collapse, continue; if none break\n        → Recurse on new board, decrement hand count\n        → Record result+1\n→ Store best in memo, return best or INF\nReturn answer or -1\n\nAlso helper functions: compress board after removal, find groups, etc.\n\nNeed to output virtual code line by line with explanation. Let's produce something like:\n\nStart\n→ Step 1: Initialize memo map // store best result for each state\n→ Step 2: Define recursive function dfs(board, handCount) // returns min inserts\n→ Decision: If board empty? // no balls left\n    Yes → Return 0 // solved\n→ Decision: If memo contains board+handCount? // check cache\n    Yes → Return memo value\n→ Initialize best = INF\n→ For each color c with handCount[c] > 0\n    → For each index i from 0 to board.length // positions between balls\n        → Insert c at i -> newBoard\n        → newBoard = collapse(newBoard) // remove groups recursively\n        → handCount[c]--\n        → result = dfs(newBoard, handCount)\n        → If result != INF\n            → best = min(best, result + 1)\n        → handCount[c]++ // backtrack\n→ memo[board+handCount] = best\n→ Return best\n\nHelper collapse function:\n→ Function collapse(b)\n    → loop\n        → Find any segment of length >=3 of same char\n        → If none break\n        → Remove segment\n    → Return b\n\nReturn final answer: if ans == INF then -1 else ans\n\nWe need to format each line with arrow, etc.\n\nWe need to show steps like Start, End. Use decision blocks.\n\nLet's write more detailed pseudo steps. Provide each line with explanation.\n\nWe can include variables: board string, hand string, handCount map, memo map keyed by board+hand signature.\n\nAlso include conversion from hand string to count map.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 解析手牌為顏色計數表 `handCount` // 例如 {'R':2,'B':1,…}  \n→ Step 2: 建立記憶化字典 `memo` // 以 (board, handCount) 為鍵存儲最小插入數  \n→ Step 3: 定義遞迴函式 `dfs(board, handCount)` // 回傳清除此板面所需最少插入數  \n\n**dfs 函式**  \n→ Decision: 如果 `board` 為空？ // 所有球已被移除  \n    Yes → Return 0 // 成功結束，無需再插入  \n    No  → Continue  \n\n→ Decision: 若 `memo` 包含 `(board, handCount)`？ // 已經計算過此狀態  \n    Yes → Return `memo[board,handCount]` // 直接回傳緩存結果  \n    No  → Continue  \n\n→ Step 4: 設定 `best = INF` // 目前找到的最小插入數  \n\n→ For each `color` in `handCount` where `handCount[color] > 0`  \n    → For each `pos` from `0` to `len(board)` // 可插入的所有位置（含兩端）  \n        → Step 5: 建立新板面 `newBoard = board[:pos] + color + board[pos:]`  \n        → Step 6: 呼叫 `newBoard = collapse(newBoard)` // 連鎖消除所有符合條件的群組  \n        → Step 7: `handCount[color] -= 1` // 使用一顆此顏色球  \n        → Step 8: `res = dfs(newBoard, handCount)` // 進一步遞迴求解  \n        → Step 9: 若 `res != INF`  \n            → `best = min(best, res + 1)` // 加上本次插入的 1  \n        → Step 10: `handCount[color] += 1` // 回溯，恢復手牌計數  \n\n→ Step 11: `memo[board,handCount] = best` // 記錄此狀態的最佳解  \n→ Return `best`  \n\n**collapse 函式**  \n→ Step 12: `changed = True`  \n→ While `changed`  \n    → `changed = False`  \n    → 依序掃描 `board` 找出任何長度 ≥ 3 的連續相同顏色區段  \n    → 若找到  \n        → 刪除該區段 `board = board[:start] + board[end:]`  \n        → `changed = True` // 需要再次檢查連鎖反應  \n→ Return `board`  \n\n**主程式**  \n→ Step 13: 呼叫 `answer = dfs(board, handCount)`  \n→ Decision: 如果 `answer == INF`？ // 無法清除  \n    Yes → Print -1 // 失敗回傳  \n    No  → Print `answer` // 最小插入數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "K Inverse Pairs Array",
      "source_file": "Leetcode/leetcode629.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1000000006'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1000000006'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_inverse_pairs(n: int, k: int) -> int:\n    \"\"\"Return number of arrays of length n with exactly k inverse pairs.\"\"\"\n    # If k is larger than the maximum possible inverse pairs, answer is 0.\n    if k > n * (n - 1) // 2:\n        return 0\n\n    # dp[i][j] : number of arrays of length i having j inverse pairs\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # base case: empty array\n\n    for i in range(1, n + 1):\n        # For j = 0 the value is always 1 (only one way to arrange)\n        dp[i][0] = 1\n        # Use a running prefix sum to compute dp[i][j] in O(1) per j\n        prefix = 0\n        for j in range(1, k + 1):\n            prefix = (prefix + dp[i - 1][j]) % MOD\n            if j >= i:\n                prefix = (prefix - dp[i - 1][j - i]) % MOD\n            dp[i][j] = prefix\n\n    return dp[n][k]\n\ndef main() -> None:\n    \"\"\"Read input from stdin, compute answer, and write to stdout.\"\"\"\n    # Read entire input and extract integers (handles formats like 'n = 3, k = 0')\n    raw_input = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', raw_input)))\n    if len(nums) < 2:\n        # Not enough numbers, nothing to compute\n        return\n    n, k = nums[0], nums[1]\n    result = count_inverse_pairs(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for counting arrays with exactly k inverse pairs given n and k. We should implement dynamic programming approach: dp[i][j] = number of arrays of length i with j inverse pairs. Recurrence dp[i][j] = sum_{x=0}^{min(j, i-1)} dp[i-1][j-x], mod M. Optimize with prefix sums to O(nk). Output dp[n][k] mod M.\n\nWe need to produce line by line virtual code with comments.\n\nLet's design steps:\n\nStart\n→ Input n, k\n→ Define MOD = 1000000007\n→ If k > n*(n-1)/2 then output 0 (no such arrays)\n→ Initialize dp array of size (n+1) x (k+1) with zeros\n→ dp[0][0] = 1 // base case: 0 elements, 0 inversions\n→ For i from 1 to n:\n    → prefix = 0\n    → For j from 0 to k:\n        → prefix = (prefix + dp[i-1][j]) % MOD // accumulate\n        → If j - i >= 0:\n            → prefix = (prefix - dp[i-1][j-i]) % MOD // subtract out-of-range\n        → dp[i][j] = prefix\n→ Output dp[n][k] % MOD\n\nNeed to handle negative modulo.\n\nExplain each line.\n\nLet's output line by line with arrows, decisions, etc. No actual code, just virtual steps. Ensure we use arrow notation.\n\nLet's produce output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n, k // 讀入整數 n 與 k  \n→ Decision: 若 k > n*(n-1)/2? // 若所需逆序對數超過最大可能數  \n    Yes → Output 0 // 沒有符合條件的排列  \n    No  → Proceed // 進一步計算  \n→ Set MOD = 1000000007 // 取模數  \n→ Create dp[0..n][0..k] 以 0 初始化 // dp[i][j] 表示長度 i 的排列中有 j 個逆序對的數目  \n→ dp[0][0] = 1 // 空排列只有 1 種，且逆序對數為 0  \n→ For i = 1 to n: // 處理長度為 i 的排列  \n    → Set prefix = 0 // 前綴和，用於快速計算遞推式  \n    → For j = 0 to k: // 逐個逆序對數計算 dp[i][j]  \n        → prefix = (prefix + dp[i-1][j]) % MOD // 加上前一層所有 j 的組合  \n        → Decision: 若 j - i ≥ 0? // 如果 j 超過 i-1，需扣除過期項  \n            Yes → prefix = (prefix - dp[i-1][j-i] + MOD) % MOD // 從前綴和中扣除過期項，確保非負  \n            No  → Do nothing // 不需扣除  \n        → dp[i][j] = prefix // 儲存長度 i、逆序對 j 的結果  \n→ Output dp[n][k] % MOD // 回傳答案，取模後輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '7'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '7'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        # dp[i] 代表總和為 i 的組合數\n        dp = [0] * (target + 1)\n        dp[0] = 1  # 只有一種方式達到 0：空組合\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\ndef parse_input(text):\n    \"\"\"\n    解析類似 \"nums = [1,2,3], target = 4\" 的輸入字串。\n    \"\"\"\n    text = text.replace('\\n', ' ').strip()\n    if not text:\n        return [], 0\n    parts = text.split(',', 1)  # 只分割成兩部份\n    # 解析 nums\n    nums_part = parts[0]\n    nums_match = re.search(r'\\[(.*?)\\]', nums_part)\n    if nums_match:\n        nums_str = nums_match.group(1)\n        nums = [int(x) for x in nums_str.split(',') if x.strip()]\n    else:\n        nums = []\n    # 解析 target\n    target_part = parts[1]\n    target = int(target_part.split('=')[1].strip())\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    sol = Solution()\n    result = sol.combinationSum4(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining the algorithm: number of combinations that sum to target with distinct integers array, order matters. Classic coin change permutations DP.\n\nWe need to output step-by-step virtual code lines with comments. Use Start, End, Decision. Need to output in Chinese. Use arrow →. Each line \"虛擬碼步驟\" + \" // 解釋\". We should include DP array, iterate target, nested loops.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 定義 dp[0..target] 為 0, 並設 dp[0] = 1 // 初始化動態規劃陣列\n→ Step 2: 對每個數字 num 在 nums 內逐一處理 // 遍歷每個可用數字\n    → Step 3: 從 num 到 target 逐個遞增遍歷 sum // 更新總和範圍\n        → Step 4: dp[sum] ← dp[sum] + dp[sum - num] // 加上以 num 結尾的組合數\n→ Step 5: 回傳 dp[target] // 結果為所有組合數\nEnd // 程式結束\n\nWe need to add decisions? Not necessary. But maybe decision about if num > target skip. But we can include a decision.\n\nAdd:\n\n→ Decision: 如果 num > target? // 若數字大於目標不需要處理\n    Yes → Skip // 跳過\n    No  → (continue)\n\nAlso we can add Decision inside loop: If sum - num < 0? But loop ensures start from num.\n\nOk produce.\n\nAlso include Step 0? Might be fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 陣列，長度為 target + 1，並把 dp[0] 設為 1 // 代表總和為 0 時只有一種空組合\n→ Decision: 若 nums 為空? // 檢查是否有可用數字\n    Yes → End // 若無數字，直接結束並回傳 0\n    No  → // 繼續執行\n→ Step 2: 遍歷每個數字 num 於 nums // 為每個可選數字做一次更新\n    → Decision: 若 num > target? // 超過目標則不可能組合\n        Yes → // 跳過本數字\n        No  → // 進行內部更新\n        → Step 3: 對 sum 從 num 逐步遞增到 target\n            → Step 4: dp[sum] ← dp[sum] + dp[sum - num] // 加上以 num 結尾的所有組合\n→ Step 5: 回傳 dp[target] // 結果為所有可能的組合數\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        i = 0\n        for l, r in self.ranges:\n            if l <= left and right <= r:\n                return True\n            if l > left:\n                break\n        return False\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef parse_command(cmd):\n    start = cmd.find('(')\n    end = cmd.rfind(')')\n    if start == -1 or end == -1:\n        return None, None, None\n    parts = cmd[start+1:end].split(',')\n    left = int(parts[0].strip())\n    right = int(parts[1].strip())\n    return left, right\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n\n    # Split commands by ';' or newline\n    commands = []\n    for part in data.replace('\\n', ';').split(';'):\n        part = part.strip()\n        if part:\n            commands.append(part)\n\n    results = []\n    module = None\n\n    for cmd in commands:\n        if cmd.startswith('RangeModule'):\n            module = RangeModule()\n            results.append(None)\n        elif cmd.startswith('rangeModule.addRange'):\n            left, right = parse_command(cmd)\n            module.addRange(left, right)\n            results.append(None)\n        elif cmd.startswith('rangeModule.removeRange'):\n            left, right = parse_command(cmd)\n            module.removeRange(left, right)\n            results.append(None)\n        elif cmd.startswith('rangeModule.queryRange'):\n            left, right = parse_command(cmd)\n            res = module.queryRange(left, right)\n            results.append(res)\n\n    # Convert results to required string representation\n    out = []\n    for r in results:\n        if r is None:\n            out.append('null')\n        elif isinstance(r, bool):\n            out.append('true' if r else 'false')\n        else:\n            out.append(str(r))\n    print('[' + ', '.join(out) + ']')",
      "virtual_code": "Thinking...\nWe need to output virtual code lines step by step, no actual code, but structure of RangeModule operations. We need design of data structure. Likely using sorted list of intervals, e.g., TreeMap. Provide virtual code for init, addRange, queryRange, removeRange. Provide comments. Each line as \"虛擬碼步驟 // 解釋\". Use Start, End, Decision.\n\nWe need to produce step-by-step algorithm: for initialization create empty structure. For addRange: find first interval that overlaps, merge. For queryRange: check coverage. For removeRange: split intervals.\n\nLet's produce pseudo steps.\n\nWe'll start with \"Start\". Provide step for RangeModule initialization: create sorted map of intervals. Then step for addRange: find lower bound, iterate while overlapping, adjust. For queryRange: find interval containing left, check coverage. For removeRange: find overlapping intervals, adjust.\n\nWe need line by line with arrows. Use \"→\" arrow for sequence. Indent for decisions. Provide explanation each line.\n\nLet's produce:\n\nStart // 開始\n→ RangeModule() // 建構函式\n    → Initialise an empty sorted map `intervals` mapping start to end // 用於存儲已追蹤區間\n→ End // 完成建構\n\nSimilarly for addRange.\n\nWe can produce a more detailed algorithm.\n\nWe need to produce virtual code that matches specification but not actual code. Use \"Step X\". Provide explanation.\n\nLet's structure as:\n\nStart // 程式開始\n→ Step 1: 定義類 RangeModule // 建立資料結構類別\n    → Step 1.1: 成員變數 intervals ← 空有序映射 // 存儲追蹤區間\n→ End // 建構完成\n\nFor addRange:\n\nStart\n→ Step 2: addRange(left, right) // 新增區間\n    → Decision: 是否有已存在區間與 [left, right) 重疊? // 判斷是否需要合併\n        Yes → Step 2.1: 找到第一個重疊區間的起始點 // 用於合併\n        → Step 2.2: 合併所有重疊區間並更新 left, right 為最小起始和最大結束 // 合併邏輯\n        → Step 2.3: 刪除所有重疊區間並插入合併後的新區間 // 更新映射\n        No  → Step 2.4: 直接插入區間 [left, right) // 無重疊，直接新增\n→ End\n\nSimilarly queryRange:\n\nStart\n→ Step 3: queryRange(left, right) // 查詢區間\n    → Step 3.1: 在 intervals 中找到最接近 left 的區間 // 用於檢查起始\n    → Decision: 该区间的起始 ≤ left 且 结束 ≥ right? // 判斷是否覆蓋\n        Yes → Step 3.2: return true // 完全被追蹤\n        No  → Step 3.3: return false // 未覆蓋\n→ End\n\nremoveRange:\n\nStart\n→ Step 4: removeRange(left, right) // 移除區間\n    → Decision: 是否存在重疊區間? // 判斷是否需要處理\n        Yes → Step 4.1: 找到所有重疊區間\n        → Step 4.2: 對於每個重疊區間，若左端 < left 则保留左半段\n        → Step 4.3: 若右端 > right 则保留右半段\n        → Step 4.4: 刪除原始重疊區間並插入保留的半段\n        No  → Step 4.5: 無操作 // 無重疊，直接返回\n→ End\n\nLet's produce final output with arrows, decisions, etc.\n\nBe careful to include \"Start\" and \"End\" for each function? The example shows overall Start End. Probably use Start for overall program. But we can provide for each function too.\n\nBetter: Use Start for entire pseudo code, then step for each method inside.\n\nLet's output.\n\nAlso each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義類 RangeModule // 建立資料結構類別\n    → Step 1.1: 成員變數 intervals ← 空有序映射 // 用於存儲已追蹤區間，鍵為區間起始點，值為結束點\n\n→ End // 建構完成\n\n---\n\n→ Step 2: addRange(left, right) // 新增區間 [left, right)\n    → Decision: 是否有已存在區間與 [left, right) 重疊? // 判斷是否需要合併\n        Yes →\n            → Step 2.1: 找到第一個起始點 >= left 的區間 idxStart // 搜尋重疊起點\n            → Step 2.2: 遍歷所有區間，若區間 start <= right 且 end >= left，則：\n                → Step 2.2.1: 更新 left ← min(left, current_start)\n                → Step 2.2.2: 更新 right ← max(right, current_end)\n                → Step 2.2.3: 刪除 current_interval // 從映射中移除已合併區間\n            → Step 2.3: 在 intervals 中插入新區間 [left, right) // 將合併後的區間加入\n        No →\n            → Step 2.4: 直接在 intervals 中插入區間 [left, right) // 無重疊，直接新增\n    → End // addRange 完成\n\n---\n\n→ Step 3: queryRange(left, right) // 查詢區間 [left, right)\n    → Step 3.1: 在 intervals 中找到最大的 start <= left 的區間 current // 用於檢查起始位置\n    → Decision: current 存在且 current.end >= right? // 判斷區間是否被完全覆蓋\n        Yes → Step 3.2: return true // 所有數值都已被追蹤\n        No  → Step 3.3: return false // 有部分未被追蹤\n    → End // queryRange 完成\n\n---\n\n→ Step 4: removeRange(left, right) // 移除區間 [left, right)\n    → Decision: 是否存在與 [left, right) 重疊的區間? // 判斷是否需要處理\n        Yes →\n            → Step 4.1: 找到所有 start <= right 且 end >= left 的區間 overlappingList\n            → For each interval in overlappingList:\n                → Step 4.1.1: 若 interval.start < left 则保留左半段 [interval.start, left)\n                → Step 4.1.2: 若 interval.end > right 则保留右半段 (right, interval.end]\n                → Step 4.1.3: 刪除原始 interval // 移除被覆蓋的區間\n                → Step 4.1.4: 插入保留的左半段與右半段到 intervals（若存在）\n        No →\n            → Step 4.2: 無操作 // 沒有重疊區間，不需變更\n    → End // removeRange 完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgizkt7e9.py\", line 83, in <module>\n    main()\n  File \"/tmp/tmpgizkt7e9.py\", line 63, in main\n    ops = ast.literal_eval(data[0])          # 例如 [\"MyCircularDeque\", \"insertLast\", ...]\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n                                                                                                                                                ^\nSyntaxError: unexpected character after line continuation character"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k                     # 最大容量\n        self.buf = [0] * k             # 循環緩衝區\n        self.head = 0                  # 指向首元素的索引\n        self.count = 0                 # 當前元素數量\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0])          # 例如 [\"MyCircularDeque\", \"insertLast\", ...]\n    args = ast.literal_eval(data[1])          # 例如 [[3], [1], ...]\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(arg[0])   # arg[0] 為 k\n            res.append(None)                # constructor 返回 null\n        else:\n            # 取得方法並執行\n            method = getattr(obj, op)\n            ret = method(*arg)              # *arg 可能是空列表\n            res.append(ret)\n\n    # 輸出 JSON 格式（null、true、false 等）\n    print(json.dumps(res, ensure_ascii=False))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line for implementing a circular deque. Include steps like class definition, constructor, insertFront, etc. Use arrows and Decision. For each line, include comment after //.\n\nWe need to follow output format: Each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows (→, Yes→, No→). Use Start, End, Decision. We should produce a clear pseudo-code representation.\n\nWe should provide for each method. Should we separate methods? Provide Start at beginning, End at end. For each method, we show steps.\n\nPseudo-code style: Use comments after //.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Class MyCircularDeque // 定義類別\n\nLine 3: → Variables: array[0..k-1], front = 0, rear = 0, size = 0, capacity = k // 初始化屬性\n\nConstructor: Start of constructor.\n\nLine 4: → Constructor: MyCircularDeque(k) // 建構子，接收最大容量\n\nLine 5:   → array = new int[k] // 建立固定長度陣列\n\nLine 6:   → front = 0 // 前指標初始化\n\nLine 7:   → rear = 0 // 後指標初始化\n\nLine 8:   → size = 0 // 目前元素數量為0\n\nLine 9:   → capacity = k // 儲存最大容量\n\nLine 10: End // 建構子結束\n\nInsertFront method:\n\nLine 11: → Method insertFront(value) // 加入前端\n\nLine 12:   → Decision: If size == capacity? // 檢查是否已滿\n\nLine 13:     Yes → Return false // 若已滿，操作失敗\n\nLine 14:     No →\n\nInsert logic: compute newFront = (front - 1 + capacity) % capacity; set array[newFront] = value; front = newFront; size++ ; Return true.\n\nWe need each line separate. So after No → we start new line with indentation? We can maintain same arrow style. Let's keep arrow lines for each step.\n\nLine 15:     No → front = (front - 1 + capacity) % capacity // 計算新前指標\n\nLine 16:     No → array[front] = value // 將值存入前指標位置\n\nLine 17:     No → size++ // 元素數量加一\n\nLine 18:     No → Return true // 成功完成\n\nEnd method.\n\nSimilarly for insertLast.\n\nLine 19: → Method insertLast(value) // 加入後端\n\nLine 20:   → Decision: If size == capacity? // 檢查是否已滿\n\nLine 21:     Yes → Return false // 已滿失敗\n\nLine 22:     No →\n\nLine 23:     No → array[rear] = value // 存值於後指標\n\nLine 24:     No → rear = (rear + 1) % capacity // 更新後指標\n\nLine 25:     No → size++ // 元素數量加一\n\nLine 26:     No → Return true // 成功\n\nDeleteFront:\n\nLine 27: → Method deleteFront() // 刪除前端\n\nLine 28:   → Decision: If size == 0? // 判斷是否為空\n\nLine 29:     Yes → Return false // 空時失敗\n\nLine 30:     No →\n\nLine 31:     No → front = (front + 1) % capacity // 移動前指標\n\nLine 32:     No → size-- // 減少元素數量\n\nLine 33:     No → Return true // 成功\n\nDeleteLast:\n\nLine 34: → Method deleteLast() // 刪除後端\n\nLine 35:   → Decision: If size == 0? // 判斷是否為空\n\nLine 36:     Yes → Return false // 空時失敗\n\nLine 37:     No →\n\nLine 38:     No → rear = (rear - 1 + capacity) % capacity // 後指標回退\n\nLine 39:     No → size-- // 減少數量\n\nLine 40:     No → Return true // 成功\n\nGetFront:\n\nLine 41: → Method getFront() // 取得前端元素\n\nLine 42:   → Decision: If size == 0? // 判斷是否為空\n\nLine 43:     Yes → Return -1 // 空時返回-1\n\nLine 44:     No → Return array[front] // 回傳前指標位置值\n\nGetRear:\n\nLine 45: → Method getRear() // 取得後端元素\n\nLine 46:   → Decision: If size == 0? // 判斷是否為空\n\nLine 47:     Yes → Return -1 // 空時返回-1\n\nLine 48:     No → rearIndex = (rear - 1 + capacity) % capacity // 計算實際後端索引\n\nLine 49:     No → Return array[rearIndex] // 回傳後端元素\n\nisEmpty:\n\nLine 50: → Method isEmpty() // 檢查是否空\n\nLine 51:   → Return size == 0 // 若元素數量為0則為空\n\nisFull:\n\nLine 52: → Method isFull() // 檢查是否滿\n\nLine 53:   → Return size == capacity // 若元素數量等於容量則滿\n\nEnd // 程式結束\n\nWe need each line with \"虛擬碼步驟 // 解釋\".\n\nMake sure each line has arrow or other markers.\n\nWe need to maintain consistent style. Use \"→\" for steps, \"Decision:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MyCircularDeque // 定義類別  \n→ Variables: array[0..k-1], front = 0, rear = 0, size = 0, capacity = k // 初始化屬性  \n\n→ Constructor: MyCircularDeque(k) // 建構子，接收最大容量  \n  → array = new int[k] // 建立固定長度陣列  \n  → front = 0 // 前指標初始化  \n  → rear = 0 // 後指標初始化  \n  → size = 0 // 目前元素數量為0  \n  → capacity = k // 儲存最大容量  \nEnd // 建構子結束  \n\n→ Method insertFront(value) // 加入前端  \n  → Decision: If size == capacity? // 檢查是否已滿  \n    Yes → Return false // 若已滿，操作失敗  \n    No → front = (front - 1 + capacity) % capacity // 計算新前指標  \n    No → array[front] = value // 將值存入前指標位置  \n    No → size++ // 元素數量加一  \n    No → Return true // 成功完成  \n\n→ Method insertLast(value) // 加入後端  \n  → Decision: If size == capacity? // 檢查是否已滿  \n    Yes → Return false // 已滿失敗  \n    No → array[rear] = value // 存值於後指標  \n    No → rear = (rear + 1) % capacity // 更新後指標  \n    No → size++ // 元素數量加一  \n    No → Return true // 成功  \n\n→ Method deleteFront() // 刪除前端  \n  → Decision: If size == 0? // 判斷是否為空  \n    Yes → Return false // 空時失敗  \n    No → front = (front + 1) % capacity // 移動前指標  \n    No → size-- // 減少元素數量  \n    No → Return true // 成功  \n\n→ Method deleteLast() // 刪除後端  \n  → Decision: If size == 0? // 判斷是否為空  \n    Yes → Return false // 空時失敗  \n    No → rear = (rear - 1 + capacity) % capacity // 後指標回退  \n    No → size-- // 減少數量  \n    No → Return true // 成功  \n\n→ Method getFront() // 取得前端元素  \n  → Decision: If size == 0? // 判斷是否為空  \n    Yes → Return -1 // 空時返回-1  \n    No → Return array[front] // 回傳前指標位置值  \n\n→ Method getRear() // 取得後端元素  \n  → Decision: If size == 0? // 判斷是否為空  \n    Yes → Return -1 // 空時返回-1  \n    No → rearIndex = (rear - 1 + capacity) % capacity // 計算實際後端索引  \n    No → Return array[rearIndex] // 回傳後端元素  \n\n→ Method isEmpty() // 檢查是否空  \n  → Return size == 0 // 若元素數量為0則為空  \n\n→ Method isFull() // 檢查是否滿  \n  → Return size == capacity // 若元素數量等於容量則滿  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"\n        Find duplicate file groups by file content.\n        :param paths: List[str]  directory information strings\n        :return: List[List[str]]  list of groups of duplicate file paths\n        \"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                # file_info format: fileName(content)\n                name, content = file_info.split('(')\n                content = content.rstrip(')')\n                content_map[content].append(f\"{root}/{name}\")\n\n        # Only keep groups with at least two files\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read().strip()\n\n    # Handle possible 'paths = ...' prefix\n    if data.startswith('paths'):\n        _, data = data.split('=', 1)\n        data = data.strip()\n\n    # Convert string representation of list to actual list\n    try:\n        paths = ast.literal_eval(data)\n    except Exception as e:\n        # If parsing fails, print empty list and exit\n        print([])\n        return\n\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving this problem, line by line with explanation. It's like an algorithm description for duplicate file detection. We need to use arrows, Decision, Start, End. No actual code, just steps. We'll describe reading input, parsing each string, storing content to list of paths, then group by content, filter size >=2. Use map. Use loops, etc.\n\nLet's produce step-by-step. Each line like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 map contentToPaths = {} // 建立內容到路徑的映射\n→ For each directoryInfo in paths: // 逐個處理每個目錄資訊字串\n    → Step 2: 拆分 directoryInfo 成 directoryPath 和 filesPart // 取得路徑和檔案列表\n    → For each fileEntry in filesPart: // 逐個檔案處理\n        → Step 3: 解析 fileEntry 為 fileName 和 fileContent // 拆分名稱與內容\n        → Step 4: 組合 fullPath = directoryPath + \"/\" + fileName // 完整路徑\n        → Step 5: contentToPaths[fileContent].append(fullPath) // 加入映射\n→ Step 6: 初始化 result = [] // 儲存重複檔案組\n→ For each entry in contentToPaths: // 檢查每個內容\n    → Decision: entry.value.size() >= 2? // 是否至少兩個檔案\n        Yes → Step 7: result.append(entry.value) // 加入結果\n        No  → Step 8: 跳過 // 不重複\n→ End // 回傳結果\n\nBut we need to follow arrow formatting exactly: \"→ Step X: ...\" and decisions with Yes/No.\n\nAlso we need to use Decision blocks properly:\n\nDecision: If condition? // comment\n    Yes → ... // comment\n    No  → ... // comment\n\nSo we need to format accordingly. Let's produce lines.\n\nImportant: Must be \"逐行\" with each line a separate line.\n\nAlso need to start with \"Start\" and end with \"End\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 hashMap contentToPaths = {} // 建立內容對應到檔案路徑的映射  \n→ Step 2: 將輸入列表 paths 逐一處理  \n    → Decision: 是否還有未處理的 directoryInfo?  \n        Yes → Step 3: 取出下一個 directoryInfo // 取得一個目錄資訊字串  \n        No  → Step 4: 跳轉到下一步 // 所有目錄資訊已處理完畢  \n    → Step 5: 使用空格拆分 directoryInfo 為 directoryPath 與 filesPart // 取得目錄路徑與檔案描述列表  \n    → For each fileEntry in filesPart: // 逐個檔案處理  \n        → Step 6: 解析 fileEntry 為 fileName 與 fileContent // 透過括號拆分檔名與內容  \n        → Step 7: 產生 fullPath = directoryPath + \"/\" + fileName // 組合完整路徑  \n        → Step 8: 若 contentToPaths 中不存在 key fileContent，則初始化為空清單  \n        → Step 9: contentToPaths[fileContent].append(fullPath) // 將完整路徑加入對應內容的清單  \n→ Step 10: 初始化結果列表 result = [] // 儲存所有重複檔案組  \n→ For each (fileContent, pathsList) in contentToPaths: // 檢查每個內容對應的路徑清單  \n    → Decision: pathsList 的長度 >= 2? // 是否至少有兩個檔案相同  \n        Yes → Step 11: result.append(pathsList) // 加入重複檔案組  \n        No  → Step 12: 跳過 // 不滿足重複條件，忽略  \n→ End // 程式執行結束，返回 result 其中包含所有重複檔案的路徑組群"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[1,5]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[1, 5]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[7,2,5]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[7, 2, 5]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport random\n\ndef rand7() -> int:\n    \"\"\"\n    產生一個 1~7 的均勻隨機整數。\n    這裡使用 Python 內建的 random 模組做實作。\n    \"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        產生一個 1~10 的均勻隨機整數，僅使用 rand7()。\n        \"\"\"\n        while True:\n            # 兩次 rand7() 組合得到 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:                     # 40 能被 10 整除，保證均勻\n                return 1 + (num - 1) % 10    # 將 1~40 映射到 1~10\n\nif __name__ == \"__main__\":\n    # 讀取輸入，例如: \"n = 3\"\n    raw_input = sys.stdin.read().strip()\n    # 從輸入字串中擷取數字\n    match = re.search(r\"\\d+\", raw_input)\n    if not match:\n        raise ValueError(\"輸入中必須包含一個整數 n\")\n    n = int(match.group())\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps to implement rand10 using rand7. Classic approach: generate two rand7 to get range 1-49. Rejection if >40. Then map to 1-10 via mod 10. Provide steps line by line with explanations. Use virtual code arrow syntax. No actual code. Provide Start, End, Decision.\n\nLet's craft:\n\nStart // begin\n→ Step 1: Call rand7() → value a // first random\n→ Step 2: Call rand7() → value b // second random\n→ Step 3: Compute combined = (a-1)*7 + b // convert to 1-49\n→ Decision: If combined > 40? // 40 is 4*10\n    Yes → Go back to Step 1 // reject and repeat\n    No  → Step 4: Return ((combined-1) mod 10)+1 // map to 1-10\nEnd // end\n\nAdd comments. Each line includes explanation after //. Use arrow formatting. Provide steps sequentially. Ensure each line has virtual code + explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 呼叫 rand7() → a // 取得第一個 1~7 的隨機數\n→ Step 2: 呼叫 rand7() → b // 取得第二個 1~7 的隨機數\n→ Step 3: 計算 combined = (a-1)*7 + b // 將兩個數合併成 1~49 的隨機數\n→ Decision: combined > 40? // 檢查是否在可接受範圍內（1~40）\n    Yes → Go back to Step 1 // 若超過 40，丟棄並重新開始\n    No  → Step 4: 回傳 ((combined-1) mod 10) + 1 // 將 1~40 映射為 1~10 的均勻隨機數\nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        # 計算兩點間距離的平方\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        # 取得所有六組點對的距離平方\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n\n        # 判斷是否為正方形：四邊相等、兩條對角線相等、對角線長度為邊長平方的兩倍\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] == 2 * dists[0]\n        )\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 取得所有整數（含負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        # 如果輸入格式不符合預期，直接輸出 false\n        print('false')\n        return\n    # 將數字分組為四個座標\n    p1 = [nums[0], nums[1]]\n    p2 = [nums[2], nums[3]]\n    p3 = [nums[4], nums[5]]\n    p4 = [nums[6], nums[7]]\n\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for checking if 4 points form a square. Steps: compute all pairwise distances squared. There should be exactly two distinct distances: 4 of one (the side) and 2 of the other (diagonals). The smaller one > 0, and the larger equals 2 * smaller (because diagonal^2 = side^2 + side^2). Implementation: compute list of 6 distances. Count occurrences. Check counts and relation. Provide virtual code steps accordingly. Also need to account for any order. Output boolean. We'll produce virtual code lines with explanation.\n\nLet's produce:\n\nStart\n→ Step 1: Calculate squared distances between all pairs of points → compute list D\n→ Step 2: Identify unique distances and their frequencies → map freq\n→ Decision: Are there exactly 2 unique distances? → Yes / No\n   Yes → Step 3: Assign side = smaller distance, diag = larger distance\n   No → Step 4: Return False\n→ Decision: Is frequency of side == 4 and freq of diag == 2? → Yes / No\n   Yes → Step 5: Check side > 0 and diag == 2 * side\n   No → Step 6: Return False\n→ Decision: Are both conditions true? → Yes → Step 7: Return True\n   No → Step 8: Return False\nEnd\n\nAlso may include sorting or using loops.\n\nOk produce with format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空列表 D 用於儲存六個點對之間的平方距離 // 準備計算距離  \n→ Step 2: 對所有組合 (p1,p2),(p1,p3),(p1,p4),(p2,p3),(p2,p4),(p3,p4)  \n  → 計算 dx = x_i - x_j, dy = y_i - y_j  \n  → D 加入 dx*dx + dy*dy // 取得所有距離的平方  \n→ Step 3: 建立字典 freq 用於統計 D 中每個距離出現的次數 // 方便判斷  \n  → 對 D 中每個 d  \n   → freq[d] = freq.get(d,0)+1  \n→ Decision: 是否只有兩種不同距離？ // 需正方形有兩種距離  \n  Yes → Step 4: 把較小的距離設為 side, 較大的距離設為 diag  \n  No  → Step 5: 回傳 False // 不是正方形  \n→ Decision: side 的出現次數是否為 4，diag 的出現次數是否為 2？ // 兩條邊四條，對角線兩條  \n  Yes → Step 6: 檢查 side > 0 且 diag == 2 * side // 正方形對角線平方等於兩邊平方之和  \n  No  → Step 7: 回傳 False // 不是正方形  \n→ Decision: 是否同時滿足上面兩個條件？  \n  Yes → Step 8: 回傳 True // 四點構成正方形  \n  No  → Step 9: 回傳 False // 不是正方形  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnnjkxi63.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmpnnjkxi63.py\", line 40, in main\n    special = ast.literal_eval(special_match.group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3xhqgjyv.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp3xhqgjyv.py\", line 40, in main\n    special = ast.literal_eval(special_match.group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # direct purchase price without any offer\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:  # offer can be applied\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef main():\n    data = sys.stdin.read()\n    # Extract the three lists using regular expressions\n    price_match = re.search(r'price\\s*=\\s*(\\[.*?\\])', data, re.S)\n    special_match = re.search(r'special\\s*=\\s*(\\[.*?\\])', data, re.S)\n    needs_match = re.search(r'needs\\s*=\\s*(\\[.*?\\])', data, re.S)\n\n    if not (price_match and special_match and needs_match):\n        return  # invalid input format\n\n    price = ast.literal_eval(price_match.group(1))\n    special = ast.literal_eval(special_match.group(1))\n    needs = ast.literal_eval(needs_match.group(1))\n\n    result = Solution().shoppingOffers(price, special, needs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code outline for the LeetCode problem \"Shopping Offers\" with constraints. Provide step by step. Should not output actual code, only virtual code with explanation. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. Let's design a DFS with memoization.\n\nOutline:\n\nStart // program start\n→ Step 1: 定義函數 dfs(需求 vector) // 以需求為 key 計算最小價格\n    → Decision: 如果需求為所有 0? // 檢查是否已購買完\n        Yes → Step 2: 回傳 0 // 無需再買\n    → Step 3: 計算不使用優惠的直接價格 // sum(需求[i] * price[i])\n    → Step 4: 對每個優惠 in special\n        → Decision: 是否能使用此優惠 (需求[i] >= offer[i] for all i)? // 檢查足夠剩餘\n            Yes → Step 5: 計算剩餘需求 = 需求 - offer\n                  → Step 6: price_with_offer = offer_price + dfs(剩餘需求)\n                  → Decision: price_with_offer < current_min?\n                      Yes → Step 7: current_min = price_with_offer\n        // If cannot use, 跳過\n    → Step 8: 記錄 memo[需求] = current_min\n    → Step 9: 回傳 current_min\n→ Step 10: 呼叫 dfs(原始需求) // 開始計算\n→ End // 完成\n\nWe need to use virtual code with arrows and decisions. Each line includes explanation. Use bullet? But example shows lines with \"Start // 程式開始執行\" etc. Use Chinese.\n\nMake sure each line: \"Start // 程式開始執行\" etc.\n\nWe need to include arrow \"→\" after Start, then \"Step 1:\" etc.\n\nWe can include Decision blocks.\n\nWe should output as plain text with each line. Let's produce.\n\nAlso include memoization map: maybe Step 0: 定義 memo map.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 建立 memo 為雜湊表 // 用於記錄已計算的需求組合的最小價格  \n→ Step 1: 定義函式 dfs(需求 vector) // 以需求向量為鍵，計算最小購買成本  \n  → Decision: 如果需求皆為 0? // 檢查是否已購買完所有想要的物品  \n   Yes → Step 2: 回傳 0 // 無需再購買，成本為 0  \n   No → Step 3: 計算「不使用任何優惠」的直接價格 // 直接購買所有剩餘需求  \n    → Step 4: direct = Σ (需求[i] * price[i])  \n   → Step 5: current_min = direct // 初始化最小價格為直接購買價格  \n   → Step 6: 若 memo 已有需求則回傳 memo[需求] // 避免重複計算  \n   → Step 7: 對每個特殊優惠 offer in special  \n     → Decision: 是否能使用此優惠 (需求[i] ≥ offer[i] ∀ i)? // 檢查剩餘需求是否足夠  \n      Yes → Step 8: 生成 new需求 = 需求 - offer // 用優惠後的剩餘需求  \n       → Step 9: price_with_offer = offer_price + dfs(new需求) // 重新計算剩餘需求的最小價格  \n       → Decision: price_with_offer < current_min?  \n        Yes → Step 10: current_min = price_with_offer // 更新更低價格  \n        No → // 保留目前最小價格  \n      No → // 無法使用此優惠，跳過  \n   → Step 11: memo[需求] = current_min // 記錄結果  \n   → Step 12: 回傳 current_min // 返回最小價格  \n→ Step 13: 呼叫 dfs(原始需求) // 開始遞迴計算  \n→ End // 程式執行結束"
    },
    {
      "title": "Elimination Game",
      "source_file": "Leetcode/leetcode390.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 9",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef last_remaining(n: int) -> int:\n    \"\"\"\n    依照題意，最後剩下的數字可以用數學公式直接求得。\n    1. 找到小於等於 n 的最大 2 的冪 L = 2^⌊log₂n⌋。\n    2. 計算 R = 2 * (n - L)。\n       - 若 R 為 0，表示 n 本身就是 2 的冪，答案即為 L。\n       - 否則答案即為 R。\n    \"\"\"\n    if n == 1:\n        return 1\n    # 最大 2 的冪\n    L = 1 << (n.bit_length() - 1)\n    R = 2 * (n - L)\n    return L if R == 0 else R\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 取出第一個整數，忽略任何前後文字\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = last_remaining(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm: list elimination alternates left-to-right and right-to-left removing first/last and every other. This is Josephus variant: solution: last remaining = 2*(n - 2^⌊log2 n⌋). But virtual code: maybe simulate or compute mathematically. Provide steps: Start, compute highest power of 2 <= n, etc.\n\nWe should follow output format: each line \"虛擬碼步驟 // 解釋\". Use arrow etc.\n\nLet's craft steps: Start, compute highest power of 2 <= n (call L). Compute remaining = 2*(n-L). If remaining==0, return L. Else return remaining. Also special case: if n==1 return 1.\n\nOk produce.\n\nLet's produce virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 n 是否為 1 // 檢查最小輸入  \n    Yes → Step 2: 回傳 1 // n=1 時直接回傳  \n    No  → Step 3: 找到小於等於 n 的最大 2 的冪 (L) // 計算 2^⌊log₂n⌋  \n→ Step 4: 計算剩餘數值 R = 2 × (n - L) // 公式得出剩餘位置  \n→ Decision: R 是否為 0? // 判斷是否正好是 2 的冪  \n    Yes → Step 5: 回傳 L // 若 R=0，最後剩餘為最大 2 的冪  \n    No  → Step 6: 回傳 R // 否則回傳計算得到的值  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef wiggle_sort(nums):\n    for i in range(len(nums)-1):\n        if i % 2 == 0:\n            if nums[i] > nums[i+1]:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n        else:\n            if nums[i] < nums[i+1]:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n    return nums\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        exit()\n    # Try to extract list from input\n    try:\n        # if input like 'nums = [1,5,1]'\n        if '=' in data:\n            _, list_str = data.split('=', 1)\n            list_str = list_str.strip()\n        else:\n            list_str = data\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # fallback: use eval\n        nums = eval(data)\n    result = wiggle_sort(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The problem: reorder array to wiggle: nums[0] < nums[1] > nums[2] < nums[3]... known solution: iterate i from 0 to n-1, if i%2==0 check nums[i] > nums[i+1] swap; else if nums[i] < nums[i+1] swap. That's one approach.\n\nSo virtual code: Start -> Step 1: read array nums // input array. Then get length. Then loop i from 0 to n-2? We'll loop i to n-1 and use i+1 bound. Then Decision: if i%2==0? Yes -> check nums[i] > nums[i+1]? if true swap else no. No -> for odd index check nums[i] < nums[i+1]? if true swap else no. After loop, End.\n\nWe need to produce each line with explanation comment after space. Use virtual arrows.\n\nWe need to be careful: The loop includes the i values, we need to represent loop structure: maybe use \"→ Loop i from 0 to n-2:\". Then inside loop decisions.\n\nSo structure:\n\nStart // Start program\n\n→ Step 1: Set n = length(nums) // get array length\n\n→ Loop i from 0 to n-2 // iterate indices except last\n\n    → Decision: i % 2 == 0? // check if index even\n\n        Yes → Decision: nums[i] > nums[i+1]? // for even index need ascending\n\n            Yes → Step 2: Swap nums[i], nums[i+1] // swap to satisfy\n\n            No → // nothing\n\n        No → Decision: nums[i] < nums[i+1]? // for odd index need descending\n\n            Yes → Step 3: Swap nums[i], nums[i+1] // swap to satisfy\n\n            No → // nothing\n\nEnd // End program\n\nNeed to mention Step 2, Step 3 names? Maybe unify step names.\n\nWe can just say Step 2: Swap.\n\nOk.\n\nWe need to produce each line of virtual code with explanation. Each line includes code, space, comment. The virtual code lines: Start, Step 1, Loop, Decision lines indent? The example shows indentation with spaces and nested lines. We should replicate.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: Set n = length(nums) // 取得陣列長度\n→ Loop i from 0 to n-2 // 依序檢查每個相鄰元素對\n    → Decision: i % 2 == 0? // 判斷索引是否為偶數\n        Yes → Decision: nums[i] > nums[i+1]? // 偶數索引需小於下一個\n            Yes → Step 2: Swap nums[i], nums[i+1] // 交換以滿足關係\n            No  → // 不需要交換\n        No  → Decision: nums[i] < nums[i+1]? // 奇數索引需大於下一個\n            Yes → Step 3: Swap nums[i], nums[i+1] // 交換以滿足關係\n            No  → // 不需要交換\nEnd // 程式執行結束\n\nMake sure the format matches: each line includes virtual code step, space, comment with //. Indentation for nested lines.\n\nWe must keep the arrow \"→\" for all lines except Start and End? In example, Start, End lines use no arrow? The example shows \"Start // 程式開始執行\" no arrow. But in nested we see \"→ Decision:\" etc. So we should follow.\n\nThus produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Set n = length(nums) // 取得陣列長度\n→ Loop i from 0 to n-2 // 依序檢查每個相鄰元素對\n    → Decision: i % 2 == 0? // 判斷索引是否為偶數\n        Yes → Decision: nums[i] > nums[i+1]? // 偶數索引需小於下一個\n            Yes → Step 2: Swap nums[i], nums[i+1] // 交換以滿足關係\n            No  → // 不需要交換\n        No  → Decision: nums[i] < nums[i+1]? // 奇數索引需大於下一個\n            Yes → Step 3: Swap nums[i], nums[i+1] // 交換以滿足關係\n            No  → // 不需要交換\nEnd // 程式執行結束"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      '[\"dogcatsdog\", \"catsdogcats\", \"ratcatdogcat\"]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 先按長度排序，確保較短的單詞先加入集合\n        words.sort(key=len)\n        word_set = set()\n        result = []\n\n        for word in words:\n            if not word:  # 空字串不算\n                continue\n            if self.can_form(word, word_set):\n                result.append(word)\n            word_set.add(word)\n        return result\n\n    def can_form(self, word, word_set):\n        n = len(word)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        for i in range(1, n + 1):\n            for j in range(0, i):\n                if dp[j] and word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 允許輸入形式為 words = [\"a\",\"b\"] 或直接 [\"a\",\"b\"]\n    try:\n        words = ast.literal_eval(data.split(\"=\", 1)[-1].strip())\n    except Exception:\n        words = ast.literal_eval(data)\n    solution = Solution()\n    res = solution.findAllConcatenatedWordsInADict(words)\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: given list of words no duplicates, find all concatenated words that can be formed by at least two shorter words from the list. Need virtual code steps.\n\nWe must output each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision, arrows.\n\nWe should design algorithm: Use Trie or hash set. Approach: sort words by length ascending. For each word, use DP to check if can be formed by previous words. Add to result if true. Also add word to set for future usage. Complexity O(n * L^2) maybe.\n\nWe need to provide step-by-step pseudocode.\n\nLet's craft lines:\n\nStart\n→ Step 1: 建立空集合 words_set 用於儲存已處理的較短單詞 // 用於快速查找\n→ Step 2: 建立空列表 result 用於儲存連接單詞 // 結果集合\n→ Step 3: 將 words 按長度遞增排序 // 確保在檢查時所有可能的子詞已加入集合\n→ Decision: 如果 words 為空? // 檢查輸入是否為空\n    Yes → End // 沒有單詞，結束\n→ Step 4: 迭代每個 word in words // 主迴圈\n        → Step 4.1: 呼叫 CanForm(word, words_set) // 判斷是否為連接單詞\n            Decision: 如果 CanForm 返 true? // 是否能由已知單詞組成\n                Yes → Step 4.2: result.append(word) // 加入結果\n            No → // 何也不做\n        → Step 4.3: words_set.add(word) // 將當前單詞加入集合供未來使用\n→ Step 5: 回傳 result // 輸出所有連接單詞\nEnd\n\nDefine function CanForm(word, words_set):\n\n→ Function CanForm(word, words_set) // 判斷 word 是否可由集合中的詞拼接\n    → 建立布林陣列 dp length+1，dp[0]=True // DP 初始\n    → for i in 1..len(word): // 遍歷位置\n        → for j in 0..i-1:\n            → Decision: 如果 dp[j] 為 True? // 前段可組成\n                Yes → Decision: 如果 word[j:i] in words_set? // 後段是否是已知詞\n                    Yes → dp[i]=True; Break // 找到一種分割\n                    No  → // 继续尝试\n            No  → // 不可\n        → // 结束内循环\n    → Return dp[len(word)] AND word 不是空串 // 確保至少兩個詞\nEnd Function\n\nBut need to add note that word itself may be in set; but we need at least two words; so if dp[len] true and word itself not counted as single? In DP, we allow word itself, but we need at least two words. So we can check if dp[len] is true and (some substring used) but simpler: when evaluating dp, we allow word itself but to ensure at least two words, we can check if dp[len] is true AND at least one split occurs. In DP we could ensure that dp[i] true but i< len; so dp[len] true must come from some j< len where dp[j] true and word[j:] in set. Since we inserted word into set after checking, it will not find itself as a whole word. But for first word, set empty, so dp[len] false. So good. For subsequent words, set contains all previous words, but not current. So dp[len] will not be true from word itself. So safe.\n\nOk produce lines accordingly.\n\nWe must output each line with `→` arrow except start maybe no arrow. Use `Decision:` lines with Yes → and No →.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 words_set 用於儲存已處理的較短單詞 // 用於快速查找  \n→ Step 2: 建立空列表 result 用於儲存連接單詞 // 結果集合  \n→ Step 3: 將 words 按長度遞增排序 // 確保所有可能的子詞已加入集合  \n→ Decision: 如果 words 為空? // 檢查輸入是否為空  \n    Yes → End // 沒有單詞，結束  \n→ Step 4: 迭代每個 word in words // 主迴圈  \n        → Step 4.1: 呼叫 CanForm(word, words_set) // 判斷是否為連接單詞  \n            Decision: 如果 CanForm 返 true? // 是否能由已知單詞組成  \n                Yes → Step 4.2: result.append(word) // 加入結果  \n            No → // 何也不做  \n        → Step 4.3: words_set.add(word) // 將當前單詞加入集合供未來使用  \n→ Step 5: 回傳 result // 輸出所有連接單詞  \nEnd // 程式執行結束  \n\n// -----------------------------  \nFunction CanForm(word, words_set) // 判斷 word 是否可由集合中的詞拼接  \n    → 建立布林陣列 dp 其長度為 len(word)+1，並設 dp[0] = True // DP 初始  \n    → for i in 1 .. len(word): // 遍歷位置  \n        → for j in 0 .. i-1: // 嘗試所有前綴分割  \n            → Decision: 如果 dp[j] 為 True? // 前段可組成  \n                Yes → Decision: 如果 word[j:i] in words_set? // 後段是否是已知詞  \n                    Yes → dp[i] = True； Break // 找到一種合法分割  \n                    No  → // 繼續嘗試其他 j  \n            No  → // dp[j] 為 False，跳過  \n    → Return dp[len(word)] // 若能完整分割即為連接單詞  \nEnd Function"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef accountsMerge(accounts):\n    parent = {}\n    email_to_name = {}\n\n    def find(x):\n        \"\"\"Find the root of x with path compression.\"\"\"\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    for acc in accounts:\n        name = acc[0]\n        first_email = acc[1]\n        if first_email not in parent:\n            parent[first_email] = first_email\n\n        for email in acc[1:]:\n            if email not in parent:\n                parent[email] = email\n            # Union the current email with the first email of this account\n            root1 = find(first_email)\n            root2 = find(email)\n            if root1 != root2:\n                parent[root2] = root1\n            email_to_name[email] = name\n\n    # Group emails by their root parent\n    groups = defaultdict(list)\n    for email in email_to_name:\n        root = find(email)\n        groups[root].append(email)\n\n    # Build the merged account list\n    merged = []\n    for root, emails in groups.items():\n        emails.sort()\n        merged.append([email_to_name[root]] + emails)\n\n    return merged\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        return\n\n    # If input contains a variable assignment like \"accounts = ...\",\n    # strip everything before the first '='.\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    try:\n        accounts = ast.literal_eval(expr)\n    except Exception:\n        accounts = []\n\n    result = accountsMerge(accounts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for merging accounts based on shared emails, like Leetcode 721 Accounts Merge. Use union-find. Provide step-by-step pseudocode. Ensure each line has explanation comment. Use arrow and decision constructs. Also show data structures.\n\nLet's produce virtual code: Start, create map email->name and email->parent, DSU find/union functions. Then iterate accounts to union emails. After building DSU, gather groups: map root -> list of emails. Sort each list, prepend name, collect result. End. Provide line-by-line.\n\nLet's craft: \nStart // start\n\n→ Step 1: Initialize email_to_name map // map email to owner name\n\n→ Step 2: Initialize DSU parent map // parent pointer for each email\n\n→ Step 3: For each account in accounts // iterate all accounts\n\n→   Step 4: name ← account[0] // retrieve account owner\n\n→   Step 5: For each email in account[1:] // iterate emails\n\n→     Step 6: If email not in parent map → Step 7: parent[email] ← email // set parent to itself\n\n→     Step 8: email_to_name[email] ← name // record owner name\n\n→     Step 9: If first email of this account → Step 10: root_email ← email // record first email\n\n→     Step 11: Else → Step 12: Union(root_email, email) // union current email with first\n\nAfter building DSU\n\n→ Step 13: Initialize root_to_emails map // groups\n\n→ Step 14: For each email in parent map // iterate all emails\n\n→   Step 15: root ← Find(email) // find root parent\n\n→   Step 16: Append email to root_to_emails[root]\n\n→ Step 17: Initialize result list\n\n→ Step 18: For each root in root_to_emails\n\n→   Step 19: emails ← root_to_emails[root] // list of emails\n\n→   Step 20: Sort(emails) // lexicographical sort\n\n→   Step 21: name ← email_to_name[emails[0]] // get name from any email\n\n→   Step 22: account ← [name] + emails // build merged account\n\n→   Step 23: Append account to result\n\n→ End // finish\n\nNeed to include find/union definitions as separate steps.\n\nWe'll insert:\n\n→ Step 1a: Define Find(x) function // find root with path compression\n\n→ Step 2a: Define Union(x, y) function // merge two sets\n\nBut we can incorporate earlier.\n\nLet's produce final output lines.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Define Find(x) // 找出 email 的根節點，並壓縮路徑  \n  If parent[x] ≠ x → parent[x] ← Find(parent[x]) // 路徑壓縮  \n  Return parent[x] // 回傳根節點  \n\n→ Define Union(x, y) // 合併兩個 email 所屬的集合  \n  rootX ← Find(x)  \n  rootY ← Find(y)  \n  If rootX ≠ rootY → parent[rootY] ← rootX // 把 y 的根指向 x 的根  \n\n→ Step 1: 初始化 email_to_name 映射 // email → 擁有者姓名  \n→ Step 2: 初始化 parent 映射 // email → 其 DSU parent  \n\n→ Step 3: 遍歷每個 account in accounts // 逐帳戶處理  \n  name ← account[0] // 取得帳戶名稱  \n  root_email ← None // 用於記錄此帳戶第一個 email  \n  For each email in account[1:] // 逐個 email  \n   If email ∉ parent → parent[email] ← email // 初始化 parent  \n   email_to_name[email] ← name // 記錄對應姓名  \n   If root_email is None → root_email ← email // 第一個 email 作為 root  \n   Else → Union(root_email, email) // 將後續 email 與 root 合併  \n\n→ Step 4: 初始化 root_to_emails 映射 // 根節點 → 所有屬下 email  \n→ Step 5: 遍歷所有 email in parent // 聚集每個 email 的集合  \n  root ← Find(email) // 找到其根  \n  If root ∉ root_to_emails → root_to_emails[root] ← [] // 建立列表  \n  Append email to root_to_emails[root] // 加入對應集合  \n\n→ Step 6: 初始化 result 列表 // 用於存放合併後的帳戶  \n→ Step 7: 遍歷每個 root in root_to_emails // 逐集合處理  \n  emails ← root_to_emails[root] // 取出該集合的所有 email  \n  Sort(emails) // 依字典順序排序  \n  name ← email_to_name[emails[0]] // 取得對應姓名（任一 email 都相同）  \n  account ← [name] + emails // 組成完整帳戶格式  \n  Append account to result // 加入結果  \n\nEnd // 程式執行結束，返回 result。"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[None,0,4,0,4,6,1,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[None, 0, 4, 0, 4, 6, 1, 0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # m 是可以直接選擇的數量\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        last = n - 1\n        # 建立 mapping: 將左側黑名單數映射到右側白名單數\n        self.mapping = {}\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # 只呼叫一次 random，返回符合條件的數字\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\ndef main():\n    # 讀取操作序列和對應參數\n    ops_line = sys.stdin.readline().strip()\n    args_line = sys.stdin.readline().strip()\n    if not ops_line or not args_line:\n        return\n    ops = ast.literal_eval(ops_line)\n    args = ast.literal_eval(args_line)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)          # 這裡對應 null\n        elif op == \"pick\":\n            results.append(obj.pick())\n        else:\n            results.append(None)\n\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solution design. It's a typical \"random pick with blacklist\" problem (Leetcode 710). The solution: map blacklisted numbers that fall into [0, m) to whitelisted numbers in [m, n). Where m = n - blacklist.size. Then pick random r in [0, m). If r in map, return map[r] else r.\n\nNeed to produce virtual code steps line by line with explanations. Use Start, End, Decision: etc. Also need initialization and pick method. Use steps: Build map, compute m, etc. Then pick: generate random in [0, m). If in map, return mapped else return itself. The code should minimize random calls: only one per pick.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 m = n - blacklist.length // m 為可選取數字的數量  \n→ Step 2: 建立空字典 mapping // 用於把黑名單內落在 [0, m) 的數映射到 [m, n) 的白名單數  \n→ Decision: 如果 blacklist 不為空? // 需要做映射才能避免重複  \n    Yes → Step 3: 將 whitelistNumbers = {x | x ∈ [m, n) 且 x 不在 blacklist} // 收集右側可用數字  \n        → Step 4: 將 blacklistInRange = {x | x ∈ blacklist 且 x < m} // 黑名單中落在左側的數  \n        → Decision: 是否存在 blacklistInRange?  \n            Yes → Step 5: 為每個 x ∈ blacklistInRange 建立映射 mapping[x] = pop one element from whitelistNumbers // 把左側黑名單映射到右側白名單  \n            No → // 無需映射，所有左側數字皆為白名單  \n    No → // blacklist 為空，直接使用 [0, n) 作為白名單  \n→ Step 6: Store m, mapping 以供 pick() 使用 // 初始化完成  \nEnd // 初始化結束  \n\nStart // pick() 方法開始  \n→ Step 7: 產生 r = randomInt(0, m-1) // 隨機選取左側區間內一個數字，僅呼叫一次 random  \n→ Decision: 是否存在 mapping[r]? // r 是否被映射到右側白名單  \n    Yes → Step 8: 返回 mapping[r] // 取映射後的白名單數字  \n    No  → Step 9: 返回 r // 直接返回左側白名單數字  \nEnd // pick() 方法結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp974qilnx.py\", line 67, in <module>\n    main()\n  File \"/tmp/tmp974qilnx.py\", line 42, in main\n    raise ValueError(\"Input format must contain two list expressions.\")\nValueError: Input format must contain two list expressions."
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass MapSum:\n    def __init__(self):\n        # Trie root node: {'sum': cumulative value, 'children': {char: node}}\n        self.root = {'sum': 0, 'children': {}}\n        # Dictionary to keep current value of each key\n        self.kv = {}\n\n    def insert(self, key: str, val: int) -> None:\n        # Calculate difference from previous value (if any)\n        diff = val - self.kv.get(key, 0)\n        # Update stored value\n        self.kv[key] = val\n\n        node = self.root\n        # Update sums along the path for each character\n        for ch in key:\n            if ch not in node['children']:\n                node['children'][ch] = {'sum': 0, 'children': {}}\n            node = node['children'][ch]\n            node['sum'] += diff\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node['children']:\n                return 0\n            node = node['children'][ch]\n        return node['sum']\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract two list expressions from the input\n    parts = re.findall(r'\\[.*?\\]', data, flags=re.DOTALL)\n    if len(parts) != 2:\n        raise ValueError(\"Input format must contain two list expressions.\")\n\n    ops = ast.literal_eval(parts[0])          # list of operation names\n    args = ast.literal_eval(parts[1])         # list of argument lists\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MapSum\":\n            obj = MapSum()\n            results.append(None)  # null in JSON\n        elif op == \"insert\":\n            obj.insert(arg[0], arg[1])\n            results.append(None)\n        elif op == \"sum\":\n            res = obj.sum(arg[0])\n            results.append(res)\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    # Convert Python None to JSON null in the output string\n    output = str(results).replace(\"None\", \"null\")\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a MapSum class with insert and sum operations. Use trie with prefix sums. We'll output step-by-step pseudocode lines with comments. Must follow format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows. Need Start, End. Let's produce: Start, → Step 1: 定義 Node 類 // node has children dict and sum // etc. Then define MapSum class with root node and hashmap for key values. Insert: update diff = val - old if existed. Then traverse node and add diff to node.sum. Sum: traverse prefix, return node.sum or 0. We'll produce stepwise. Use Decision? Only for branching maybe.\n\nWe need line by line with \"→\". Use arrow for sequential steps. Indent decisions. We'll include Decision for checking if key exists. Let's craft.\n\nMake sure each line ends with comment after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類 // 建立 Trie 節點，內含 children (子節點字典) 與 sum (前綴總和)  \n    → Node.children ← {} // 子節點集合  \n    → Node.sum ← 0 // 前綴總和初值  \n→ Step 2: 定義 MapSum 類 // 主類別，包含 root 與 key-value 儲存  \n    → MapSum.root ← new Node() // Trie 根節點  \n    → MapSum.kv ← {} // 儲存每個 key 的目前值  \n→ Step 3: 實作 insert(key, val) 方法 // 插入或更新 key-value  \n    → Decision: key 是否存在於 kv? // 判斷是否為覆寫  \n        Yes → Step 3.1: diff ← val - MapSum.kv[key] // 計算變更量  \n        No  → Step 3.2: diff ← val // 新 key，diff 為 val  \n    → Step 3.3: MapSum.kv[key] ← val // 更新 key 的值  \n    → Step 3.4: node ← MapSum.root // 從根節點開始  \n    → Step 3.5: For 每個字符 ch in key  \n        → Step 3.5.1: Decision: node.children 是否包含 ch?  \n            Yes → Step 3.5.2: node ← node.children[ch] // 進入子節點  \n            No  → Step 3.5.3: node.children[ch] ← new Node() // 新增子節點  \n                → Step 3.5.4: node ← node.children[ch] // 進入新節點  \n        → Step 3.5.5: node.sum ← node.sum + diff // 更新前綴總和  \n→ Step 4: 實作 sum(prefix) 方法 // 回傳前綴對應的總和  \n    → Step 4.1: node ← MapSum.root // 從根節點開始  \n    → Step 4.2: For 每個字符 ch in prefix  \n        → Decision: node.children 是否包含 ch?  \n            Yes → Step 4.2.1: node ← node.children[ch] // 進入子節點  \n            No  → Step 4.3: Return 0 // 前綴不存在，總和為 0  \n    → Step 4.4: Return node.sum // 返回前綴的總和  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.19991314744973887,0.4790184396220629],[0.3809382666573366,-0.12718927242903452],[-0.4553503099266305,0.13863667425540216]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.19991314744973887, 0.4790184396220629], [0.3809382666573366, -0.12718927242903452], [-0.4553503099266305, 0.13863667425540216]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport math\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    methods = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n    obj = None\n    results = []\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            func = getattr(obj, method)\n            if args:\n                res = func(*args)\n            else:\n                res = func()\n            results.append(res)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, for the described algorithm: generate a uniform random point inside a circle of radius r centered at (xc, yc). Approach: use polar coordinates: pick angle uniformly [0,2π), radius sqrt(random()) * r. Or use rejection sampling. The typical solution uses polar method.\n\nThus the steps:\n\nStart\n→ Store radius, xc, yc\n→ randPoint:\n    → Generate random u in [0,1)\n    → Generate random v in [0,1)\n    → Convert to polar: r' = radius * sqrt(u)\n    → θ = 2π * v\n    → x = xc + r' * cos(θ)\n    → y = yc + r' * sin(θ)\n    → Return [x,y]\nEnd\n\nBut the virtual code might need Decision? No decisions.\n\nWe must use arrows, Start, End, Step.\n\nSo each line with \"→ Step X: ...\" with comment. We may use numbering or not. Use sequential.\n\nThe user wants \"逐行生成虛擬碼\" and \"每行虛擬碼之後立即提供該行的簡短、直觀的解釋\".\n\nThus we produce something like:\n\nStart // 程式開始執行\n→ Step 1: 儲存 radius、x_center、y_center // 初始化參數\n→ Step 2: 在 randPoint 中生成隨機數 u, v // 用於計算半徑與角度\n→ Step 3: 計算半徑 r' = radius * sqrt(u) // 使半徑分佈均勻\n→ Step 4: 計算角度 θ = 2π * v // 角度均勻分佈\n→ Step 5: 計算 x = x_center + r' * cos(θ) // 將極座標轉回直角座標\n→ Step 6: 計算 y = y_center + r' * sin(θ) // 同上\n→ Step 7: 返回 [x, y] // 產生的隨機點\nEnd // 程式結束\n\nWe can include the class and methods? But need to be in virtual code. We can include \"Class Solution:\" and \"Constructor\" etc. But we can keep simple.\n\nBut the requirement: implement the Solution class: constructor and randPoint method. So include class definition and methods.\n\nThus we can produce:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n    → Step 1: Constructor(radius, x_center, y_center) // 初始化圓參數\n        → 儲存 radius, x_center, y_center // 將參數存到物件屬性\n    → Step 2: randPoint() // 產生隨機點\n        → Step 3: 生成 u = random() // 0 ≤ u < 1\n        → Step 4: 生成 v = random() // 0 ≤ v < 1\n        → Step 5: r' = radius * sqrt(u) // 轉換半徑為均勻分佈\n        → Step 6: θ = 2π * v // 生成均勻角度\n        → Step 7: x = x_center + r' * cos(θ) // 直角座標 x\n        → Step 8: y = y_center + r' * sin(θ) // 直角座標 y\n        → Step 9: return [x, y] // 回傳隨機點\nEnd // 程式結束\n\nWe need to respect the arrow formatting: use \"→\". For nested steps, we might indent or use further arrows. The example used indentation for decisions. We can indent under class.\n\nBetter to show each line with arrow at start. Use tab for indent maybe. But consistent.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n→   Step 1: Constructor(radius, x_center, y_center) // 初始化圓參數\n→     → 儲存 radius, x_center, y_center // 存儲參數\n→   Step 2: randPoint() // 生成隨機點\n→     → Step 3: u = random() // 產生 [0,1) 隨機數\n→     → Step 4: v = random() // 產生 [0,1) 隨機數\n→     → Step 5: r' = radius * sqrt(u) // 轉換半徑分佈\n→     → Step 6: θ = 2π * v // 產生均勻角度\n→     → Step 7: x = x_center + r' * cos(θ) // 計算 x 座標\n→     → Step 8: y = y_center + r' * sin(θ) // 計算 y 座標\n→     → Step 9: return [x, y] // 回傳點\nEnd // 程式結束\n\nWe should ensure that arrows are present. For each step we might use \"→ Step\". The example didn't indent for class, but we can indent. But the formatting may not allow indentation, but we can include spaces.\n\nThe user said: Use 虛擬碼的箭頭 (→, Yes →, No →) and structure (Start, End, Decision:). So we need arrow on each line. Indentation not required.\n\nWe can do:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n→ Step 1: Constructor(radius, x_center, y_center) // 初始化圓參數\n→     → 儲存 radius, x_center, y_center // 存儲參數\n→ Step 2: randPoint() // 生成隨機點\n→     → Step 3: u = random() // 產生 [0,1) 隨機數\n→     → Step 4: v = random() // 產生 [0,1) 隨機數\n→     → Step 5: r' = radius * sqrt(u) // 轉換半徑分佈\n→     → Step 6: θ = 2π * v // 產生均勻角度\n→     → Step 7: x = x_center + r' * cos(θ) // 計算 x 座標\n→     → Step 8: y = y_center + r' * sin(θ) // 計算 y 座標\n→     → Step 9: return [x, y] // 回傳點\nEnd // 程式結束\n\nBut we need arrow at each line: each line starts with \"→\". So we must prefix all lines after Start and before End with \"→\". The above uses \"→\" on each line. For nested steps we can have more arrows or indent. In example, they didn't indent but used \"Yes →\" etc. For consistency we can use \"→\" for each line. But we might not need nested arrows. But okay.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution // 定義 Solution 類別  \n→ Step 1: Constructor(radius, x_center, y_center) // 初始化圓參數  \n→     → 儲存 radius, x_center, y_center // 存儲參數到物件屬性  \n→ Step 2: randPoint() // 產生隨機點  \n→     → Step 3: u = random() // 產生 0 ≤ u < 1 的隨機數  \n→     → Step 4: v = random() // 產生 0 ≤ v < 1 的隨機數  \n→     → Step 5: r' = radius * sqrt(u) // 轉換半徑使其均勻分佈  \n→     → Step 6: θ = 2π * v // 產生均勻角度  \n→     → Step 7: x = x_center + r' * cos(θ) // 將極座標轉回直角座標，得到 x  \n→     → Step 8: y = y_center + r' * sin(θ) // 同上，得到 y  \n→     → Step 9: return [x, y] // 回傳隨機點  \nEnd // 程式結束"
    },
    {
      "title": "Count Numbers with Unique Digits",
      "source_file": "Leetcode/leetcode357.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '91'\nGot (Norm):      '658'\n--- (Raw) ---\nRaw Expected: '91'\nRaw Got:      '658'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_unique_digits(n: int) -> int:\n    \"\"\"Return the number of integers x with 0 <= x < 10**n that have all unique digits.\"\"\"\n    if n == 0:\n        return 1  # only the number 0\n\n    n = min(n, 10)  # beyond 10 digits, digits must repeat\n    res = 10        # counts 0-9\n    factor = 9      # number of choices for the second digit onward\n    for i in range(2, n + 1):\n        factor *= 10 - i  # update permutation count: 9 * 8 * 7 * ...\n        res += 9 * factor\n    return res\n\ndef main() -> None:\n    # Read entire stdin, extract the first integer as n\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n\n    result = count_unique_digits(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm: count numbers with unique digits less than 10^n. Classic Leetcode 357. Approach: use combinatorics: For n=0 return 1; for n>0: count=1 for 0; then for i=1 to n: count += 9*P(9, i-1). Use permutation.\n\nWe produce virtual code steps. Must be line-by-line, each line: virtual code step + // explanation. Use arrows. Use Start, End, Decision. Provide structure.\n\nLet's produce:\n\nStart // start\n→ Step 1: Input integer n // get n\n→ Decision: 如果 n == 0? // handle trivial\n    Yes → Step 2: Return 1 // only number 0\n    No → Step 3: Initialize result = 1 // count zero\n→ Step 4: Initialize available = 9 // first digit choices (1-9)\n→ Step 5: Initialize factor = 1 // product for permutations\n→ Step 6: For i = 1 to n:\n    → Step 7: factor = factor * (10 - i) // compute permutations for position i\n    → Step 8: result = result + 9 * factor // add numbers with length i\n→ End // return result\n\nNeed to use virtual code arrow and Decision. Use arrow for loop? We'll show as Indentation. Provide arrow to steps.\n\nLet's format as:\n\nStart // 程式開始\n→ Step 1: 讀取整數 n // 取得輸入值\n→ Decision: n == 0? // 判斷 n 是否為 0\n    Yes → Step 2: 回傳 1 // 只有 0 這個數字\n    No  → Step 3: 設定 result = 1 // 先計算 0 的個數\n→ Step 4: 設定 available = 9 // 第一位可以選 1~9\n→ Step 5: 設定 factor = 1 // 用於計算排列數\n→ Step 6: 對 i 從 1 到 n 迴圈 // 處理各位長度\n    → Step 7: factor = factor * (10 - i) // 更新排列數\n    → Step 8: result = result + 9 * factor // 加上長度 i 的數字個數\n→ End // 程式結束，回傳 result\n\nBut maybe we need more precise: Step 7: factor = factor * (10 - i) but correct formula: for i from 1 to n, factor = factor * (10 - i) ??? Wait for i=1: factor=1*(10-1)=9 correct. For i=2: factor=9*(10-2)=9*8=72 correct. For i=3: factor=72*7=504 etc. That works.\n\nBut need to add numbers: result += 9*factor? Actually after computing factor for current i, the count for numbers of length i is 9*factor? For i=1: factor=9; result +=9*9=81? That is wrong. Standard formula: for i from 1 to n: result += 9*P(9, i-1). P(9,i-1)=9*8*...*(10-i). For i=1: P(9,0)=1; result +=9*1=9 (numbers 1-9). For i=2: P(9,1)=9; result +=9*9=81. For i=3: P(9,2)=9*8=72; result+=9*72=648. So factor should be P(9,i-1). So compute factor starting at 1; at each iteration: factor = factor * (10 - i)??? Let's compute: i=1: factor=1*(10-1)=9 => P(9,0)=1? Not correct. Let's derive: For i=1 we need factor=1. For i=2 need factor=9. For i=3 need factor=9*8=72. So recurrence: factor_new = factor_prev * (10 - i). Starting factor=1. For i=1: factor=1*(10-1)=9 -> wrong. So start loop from i=2? Another approach: compute factor at start of iteration: factor = factor * (9 - (i-1)). But we can simply compute factor = factor * (9 - (i-1)). For i=1: factor=1*(9-(1-1))=1*9=9? still wrong. Let's use formula: For i from 1 to n: if i==1: add 9. else: factor = factor * (10 - i); add 9*factor. But that's messy.\n\nSimpler: Keep variable p = 1; for i from 1 to n: p = p * (9 - (i-1))? For i=1: p=1*(9-0)=9; but we want P(9,0)=1. So we should start loop i from 1 to n: if i==1: result += 9; else: p = p * (10 - i); result += 9 * p. Let's produce virtual code accordingly.\n\nLet's design:\n\nStep 6: 設定 perm = 1 // 用於計算排列\nStep 7: 對 i 從 1 到 n 迴圈\n    → Decision: i == 1? // 第一位\n        Yes → result = result + 9 // 只需加 9\n        No  → Step 8: perm = perm * (10 - i) // 更新排列數\n              Step 9: result = result + 9 * perm // 加上長度 i 的數字個數\n\nBut maybe easier: compute perm before adding: for i=1: perm=1; result+=9*perm (9). Then update perm *= (10 - i - 1)? Let's not overcomplicate.\n\nGiven the requirement, the virtual code can use high-level description, not exact formula. So we can just state algorithm: compute count by iterating and accumulating using combinatorial multiplication.\n\nLet's craft lines accordingly.\n\nWe need each line to have arrow `→` at beginning except Start and End. For loops we can represent as indentation with arrow.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得輸入的位數上限\n→ Decision: n == 0? // 檢查是否只需要計算 0\n    Yes → Step 2: 回傳 1 // 只有一個數字 0\n    No  → Step 3: 設定 result = 1 // 初始計算包含數字 0\n→ Step 4: 設定 perm = 1 // 用於計算排列數（從 1 位開始的多位數）\n→ Step 5: 對 i 從 1 到 n 迴圈 // 處理不同長度的數字\n    → Decision: i == 1? // 第一位的特殊處理\n        Yes → Step 6: result = result + 9 // 1 位數 1~9 的個數\n        No  → Step 7: perm = perm * (10 - i) // 更新排列數：P(9, i‑1)\n              Step 8: result = result + 9 * perm // 加上長度 i 的數字個數\n→ End // 程式執行結束，返回 result"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6gdkn27a.py\", line 25, in <module>\n    data_dict = eval(f\"dict({raw})\", {\"__builtins__\": None}, {})\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nTypeError: 'NoneType' object is not subscriptable\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp6gdkn27a.py\", line 31, in <module>\n    raise ValueError(\"Input format not recognized\") from e\nValueError: Input format not recognized"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptwuk2jmt.py\", line 25, in <module>\n    data_dict = eval(f\"dict({raw})\", {\"__builtins__\": None}, {})\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nTypeError: 'NoneType' object is not subscriptable\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmptwuk2jmt.py\", line 31, in <module>\n    raise ValueError(\"Input format not recognized\") from e\nValueError: Input format not recognized"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\nif __name__ == \"__main__\":\n    # Read all input\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    # Combine possible multiline input into a single string\n    raw = ' '.join(raw.splitlines())\n    # Transform into a dict literal for safe parsing\n    try:\n        data_dict = eval(f\"dict({raw})\", {\"__builtins__\": None}, {})\n    except Exception as e:\n        # Fallback: try literal eval if format is simpler\n        try:\n            data_dict = ast.literal_eval(raw)\n        except Exception:\n            raise ValueError(\"Input format not recognized\") from e\n\n    strs = data_dict['strs']\n    m = data_dict['m']\n    n = data_dict['n']\n\n    sol = Solution()\n    result = sol.findMaxForm(strs, m, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: maximum subset size of binary strings limited by counts of zeros and ones (m, n). Classic DP: 0-1 knapsack 2D. We produce virtual code steps: input array, counts per string, DP array 2D size (m+1)*(n+1). For each string, update DP backwards. Then answer dp[m][n]. Provide explanation for each step.\n\nWe should output line by line with \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 陣列大小 (m+1)*(n+1) 並全部設為 0 // 建立 DP 表格\n→ Step 2: 迭代每個字串 s in strs // 處理每個字串\n    → Sub-step: 計算 s 中 0 的數量 zeros，1 的數量 ones // 取得字串的 0/1 數量\n    → Sub-step: 從 m 降到 zeros，從 n 降到 ones // 反向迴圈以避免重複使用同一字串\n        → Step 3: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新 DP，考慮加入該字串\n→ Step 4: 回傳 dp[m][n] // 取得能容納的最大子集大小\nEnd // 程式執行結束\n\nNeed to adhere to format: each line must contain \"虛擬碼步驟 // 解釋\". Also using arrow \"→\" before each step. Use indentation but still lines.\n\nWe need to include Decision maybe not necessary. But we can use Decision for loop? Use Decision for if conditions? Might not be necessary. But the example used Decision for if. We could incorporate Decision: \"Decision: 如果 zeros <= i and ones <= j ?\" but not needed.\n\nBetter to keep simple but consistent with arrow.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 為 (m+1)×(n+1) 的 0 陣列 // 建立 DP 表格\n→ Step 2: 逐一處理 strs 中的每個字串 s // 進行動態規劃\n    → Sub-step 2.1: 計算 s 內 0 的數量 zeros 與 1 的數量 ones // 取得字串的 0/1 數量\n    → Sub-step 2.2: 從 i=m 降到 zeros\n        → Sub-step 2.2.1: 從 j=n 降到 ones\n            → Step 3: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 若加入 s 能增加子集大小則更新\n→ Step 4: 回傳 dp[m][n] // 最終答案\nEnd // 程式執行結束\n\nBut format requires each line contain arrow and explanation. Sub-steps also line. Use indentation but still new line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 為 (m+1)×(n+1) 的 0 陣列 // 建立 DP 表格  \n→ Step 2: 逐一處理 strs 中的每個字串 s // 進行動態規劃  \n  → Sub-step 2.1: 計算 s 內 0 的數量 zeros 與 1 的數量 ones // 取得字串的 0/1 數量  \n  → Sub-step 2.2: 從 i=m 降到 zeros  \n    → Sub-step 2.2.1: 從 j=n 降到 ones  \n      → Step 3: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 若加入 s 能增加子集大小則更新  \n→ Step 4: 回傳 dp[m][n] // 最終答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8jui2pec.py\", line 32, in <module>\n    ops = json.loads(ops_str)\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 12 (char 11)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)          # 原始陣列的副本\n        self.current = list(nums)           # 當前陣列，用於 reset 與 shuffle\n\n    def reset(self):\n        \"\"\"將陣列恢復為原始順序並回傳\"\"\"\n        self.current = list(self.original)\n        return self.current\n\n    def shuffle(self):\n        \"\"\"隨機打亂陣列並回傳，使用 Fisher‑Yates 洗牌演算法\"\"\"\n        arr = list(self.current)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，預期格式：operations_list,arguments_list\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 分割操作與參數兩個部分\n    ops_str, args_str = data.split(',', 1)\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    outputs = []\n    sol = None\n\n    for i, op in enumerate(ops):\n        param = args[i]\n        if op == \"Solution\":\n            # param 形如 [[1,2,3]]，取第一個元素作為陣列\n            sol = Solution(param[0])\n            outputs.append(None)\n        elif op == \"reset\":\n            outputs.append(sol.reset())\n        elif op == \"shuffle\":\n            outputs.append(sol.shuffle())\n        else:\n            # 若遇到未知方法，略過或可自行處理\n            outputs.append(None)\n\n    # 輸出結果，將 None 轉為 null\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The requirement: \"逐行\" and each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow syntax, Start, End, Decision. The algorithm: Fisher-Yates shuffle. Also include reset. So structure: Start, Step 1: Store original array copy, Step 2: Initialize current array to copy. reset returns original copy. shuffle: iterate i from 0 to n-1, pick random j from i to n-1, swap, etc. Provide virtual steps.\n\nLet's create:\n\nStart\n→ Step 1: 儲存原始陣列 nums 的複本為 original // 以便 reset 使用\n→ Step 2: 複製 original 到 current // 初始化當前陣列\n→ Step 3: 定義 reset 方法 // 重新返回原始陣列\n    → Step 3.1: reset(): 複製 original 回 current\n    → Step 3.2: return current\n→ Step 4: 定義 shuffle 方法 // 隨機打亂 current\n    → Step 4.1: n = length of current\n    → Step 4.2: for i from 0 to n-1\n        → Step 4.2.1: j = random integer in [i, n-1]\n        → Step 4.2.2: swap current[i] 與 current[j]\n    → Step 4.3: return current\nEnd\n\nBut we need each line separate. Also use Decision only where needed; maybe in shuffle we decide random. But we can just show loop.\n\nUse arrow \"→\". Need to maintain indentation? Example uses indent.\n\nLet's produce as:\n\nStart // 程式開始執行\n→ Step 1: 儲存原始陣列 nums 的複本為 original // 以便 reset 使用\n→ Step 2: 複製 original 到 current // 初始化當前陣列\n→ Step 3: 定義 reset 方法 // 重新返回原始陣列\n    → Step 3.1: reset(): 複製 original 回 current // 恢復到原始順序\n    → Step 3.2: return current // 提供 reset 結果\n→ Step 4: 定義 shuffle 方法 // 隨機打亂 current\n    → Step 4.1: n = length of current // 取得陣列長度\n    → Step 4.2: for i from 0 to n-1\n        → Step 4.2.1: j = random integer between i and n-1 // 隨機索引\n        → Step 4.2.2: swap current[i] 與 current[j] // 交換元素\n    → Step 4.3: return current // 回傳打亂後陣列\nEnd // 程式執行結束\n\nNeed each line ends with // explanation. Ensure line \"Step 3.1:\" etc. Use arrows. Provide proper indent. That's fine.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 儲存原始陣列 nums 的複本為 original // 以便 reset 使用  \n→ Step 2: 複製 original 到 current // 初始化當前陣列  \n→ Step 3: 定義 reset 方法 // 重新返回原始陣列  \n → Step 3.1: reset(): 複製 original 回 current // 恢復到原始順序  \n → Step 3.2: return current // 提供 reset 結果  \n→ Step 4: 定義 shuffle 方法 // 隨機打亂 current  \n → Step 4.1: n = length of current // 取得陣列長度  \n → Step 4.2: for i from 0 to n-1  \n   → Step 4.2.1: j = random integer between i and n-1 // 隨機索引  \n   → Step 4.2.2: swap current[i] 與 current[j] // 交換元素  \n → Step 4.3: return current // 回傳打亂後陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Comments",
      "source_file": "Leetcode/leetcode722.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsj2_8m_0.py\", line 52, in <module>\n    result = sol.removeComments(source)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpsj2_8m_0.py\", line 25, in removeComments\n    new_line.append(line[i])\n    ^^^^^^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'append'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n        for line in source:\n            i = 0\n            if not in_block:\n                new_line = []\n            else:\n                new_line = None\n            while i < len(line):\n                if not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '*':\n                    in_block = True\n                    i += 2\n                elif in_block and i + 1 < len(line) and line[i] == '*' and line[i + 1] == '/':\n                    in_block = False\n                    i += 2\n                elif not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '/':\n                    break\n                elif not in_block:\n                    new_line.append(line[i])\n                    i += 1\n                else:\n                    i += 1\n            if not in_block and new_line:\n                res.append(\"\".join(new_line))\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Expect input like: source = [\"line1\",\"line2\",...]\n    if data.startswith(\"source\"):\n        # Extract the list part\n        list_str = data.split('=', 1)[1].strip()\n        try:\n            source = ast.literal_eval(list_str)\n        except Exception:\n            source = []\n    else:\n        # If raw list is given\n        try:\n            source = ast.literal_eval(data)\n        except Exception:\n            source = []\n    sol = Solution()\n    result = sol.removeComments(source)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm to remove comments from C++ source represented as array of strings. We need step-by-step pseudo-code, with comments per line. Provide Start, End, Decision. Each step as line: \"→ Step: ... // explanation\".\n\nNeed to process each line, maintain a flag in_block_comment. For each line, process characters with index i. If not in block comment, check for // or /*. If //, break and ignore rest. If /*, set in_block_comment, skip until find */. Need to handle that if block comment ends in same line.\n\nIf line ends and still in block_comment, nothing added to output. If after processing, current_line_buffer not empty, add to result.\n\nEdge: overlapping patterns, but algorithm ensures non-overlapping by scanning char by char. Use i pointer, peek next char.\n\nWe produce virtual code lines accordingly.\n\nLet's write steps: Start, initialize result array, inBlock=false. Loop over each line index.\n\nInside loop: initialize newLine empty string, index i=0.\n\nWhile i < line.length:\n   if inBlock:\n        if line[i]=='*' and i+1<length and line[i+1]=='/': inBlock=false; i+=2; else i+=1\n   else:\n        if line[i]=='/' and i+1<length and line[i+1]=='/': break // ignore rest\n        else if line[i]=='/' and i+1<length and line[i+1]=='*': inBlock=true; i+=2\n        else: newLine += line[i]; i+=1\n\nAfter while, if newLine not empty: append to result.\n\nEnd loop, End.\n\nNeed to include decisions: if inBlock etc.\n\nAlso need to explain each line. Provide steps with \"Step 1:\" etc. The virtual code may have arrow lines. Use \"Decision:\" for condition.\n\nWe must ensure each line has space then comment.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 result 為空列表 // 用於儲存處理後的程式碼行  \n→ Step 2: 設定 inBlock 為 false // 標記是否正在處理區塊註解  \n→ Decision: 是否有更多 source 行? // 檢查是否還有程式碼行可處理  \n Yes → Step 3: 取下一行 source[i] 為 currentLine // 讀取當前程式碼行  \n  → Step 4: 設定 newLine 為空字串 // 儲存當前行去除註解後的內容  \n  → Step 5: 設定 i 為 0 // 字符索引  \n  → Decision: i < currentLine.length? // 是否還有未處理的字符  \n   Yes → Decision: inBlock 為 true? // 是否正在區塊註解中  \n    Yes → Step 6: 判斷 currentLine[i] 是否為 '*' 且 next 為 '/' // 判斷區塊結束  \n     Yes → Step 7: 設定 inBlock 為 false；i += 2 // 結束區塊註解並跳過 '*/'  \n     No → Step 8: i += 1 // 仍在區塊註解，忽略此字符  \n    No → Decision: currentLine[i] 為 '/' 且 next 為 '/'? // 判斷行註解開始  \n     Yes → Step 9: break // 跳出 while，忽略此行剩餘內容  \n     No → Decision: currentLine[i] 為 '/' 且 next 為 '*'? // 判斷區塊註解開始  \n      Yes → Step 10: 設定 inBlock 為 true；i += 2 // 開始區塊註解，跳過 '/*'  \n      No → Step 11: newLine += currentLine[i]；i += 1 // 正常字符，加入新行  \n    No → Step 12: i += 1 // 非註解情況，往後移動指標  \n  → Decision: newLine 不為空? // 判斷去註解後是否有剩餘內容  \n   Yes → Step 13: 將 newLine 加入 result // 保存有效行  \n   No → Step 14: 什麼也不做 // 空行不輸出  \n  → Decision: 是否還有更多 source 行? // 繼續處理下一行  \n   Yes → 回到 Decision: 是否有更多 source 行?  \n   No → End // 所有行已處理完畢  \nEnd // 程式執行結束。"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1, 2],[1, 2, 3],[1, 3],[2],[2, 3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\ndef parse_input(data: str):\n    # 找出第一個 '[' 與最後一個 ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1 and start < end:\n        nums_str = data[start:end+1]\n        try:\n            return ast.literal_eval(nums_str)\n        except Exception:\n            return []\n    return []\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    nums = parse_input(raw)\n    sol = Solution()\n    subsets = sol.subsets(nums)\n    # 轉成沒有空格的字串格式\n    output = '[' + ','.join(str(subset) for subset in subsets) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. For generating all subsets of a set of unique elements. Classic algorithm: use backtracking or bitmask. We can produce iterative bitmask approach: for each mask 0 to (1<<n)-1, construct subset. Or recursive DFS. Let's choose recursive backtracking for clarity.\n\nWe need to produce lines with arrow and comments. Must follow format: Start, then arrow lines. Use Decision lines. Let's produce:\n\nStart\n→ Step 1: 初始化空的結果 list subsets // prepare result\n→ Step 2: 呼叫 DFS( index=0, current=空集合 ) // start backtracking\n→ Decision: index==len(nums)? // if all elements processed\n    Yes → Step 3: 加入 current 到 subsets // add subset\n    No → Step 4: 進行兩種選擇\n        → Decision: 1. Include nums[index] in current?\n            Yes → Step 5: 加入 nums[index] 到 current\n                     → Step 6: 呼叫 DFS(index+1, current)\n                     → Step 7: 移除 nums[index] 從 current // backtrack\n            No  → Step 8: 呼叫 DFS(index+1, current) // skip element\nEnd\n\nWe should add more details. Provide step numbers. Ensure each line has virtual code step then comment. Use arrow after each step? Format: \"→ Step 1: ... // comment\". Decision lines use indentation.\n\nAlso we need to mention that result should be returned at the end. So after End maybe \"→ Return subsets\". But End is last line. So maybe include \"→ Return subsets // 回傳所有子集\" before End.\n\nLet's produce.\n\nAlso mention that nums are unique. So no duplicates. Good.\n\nLet's produce lines.\n\nNeed to use 虛擬碼箭頭 and structure.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: subsets ← [] // 建立儲存所有子集的列表  \n→ Step 2: DFS(index ← 0, current ← []) // 以索引 0 開始回溯  \n→ Decision: index == len(nums)? // 是否已處理完所有元素  \n    Yes → Step 3: subsets.append(current.copy()) // 把目前子集加入結果  \n    No → Step 4: // 對當前元素進行包含與不包含兩種選擇  \n        → Decision: 包含 nums[index]?  \n            Yes → Step 5: current.append(nums[index]) // 把元素加入子集  \n                     → Step 6: DFS(index+1, current) // 進一步回溯  \n                     → Step 7: current.pop() // 回溯時移除已加入的元素  \n            No  → Step 8: DFS(index+1, current) // 直接跳過該元素  \n→ Step 9: return subsets // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Special Binary String",
      "source_file": "Leetcode/leetcode761.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"11011000\"",
          "expected_output": "\"11100100\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjmykps1q.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmpjmykps1q.py\", line 44, in main\n    result = makeLargestSpecial(s)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjmykps1q.py\", line 29, in makeLargestSpecial\n    return '1' + dfs(0) + '0'\n                 ^^^^^^\n  File \"/tmp/tmpjmykps1q.py\", line 24, in dfs\n    parts.append('1' + dfs(l) + '0')\n                       ^^^^^^\n  File \"/tmp/tmpjmykps1q.py\", line 24, in dfs\n    parts.append('1' + dfs(l) + '0')\n                       ^^^^^^\n  File \"/tmp/tmpjmykps1q.py\", line 24, in dfs\n    parts.append('1' + dfs(l) + '0')\n                       ^^^^^^\n  [Previous line repeated 994 more times]\nRecursionError: maximum recursion depth exceeded"
        },
        {
          "example_index": 1,
          "input": "s = \"10\"",
          "expected_output": "\"10\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjoqxvjrf.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmpjoqxvjrf.py\", line 44, in main\n    result = makeLargestSpecial(s)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjoqxvjrf.py\", line 29, in makeLargestSpecial\n    return '1' + dfs(0) + '0'\n                 ^^^^^^\n  File \"/tmp/tmpjoqxvjrf.py\", line 24, in dfs\n    parts.append('1' + dfs(l) + '0')\n                       ^^^^^^\n  File \"/tmp/tmpjoqxvjrf.py\", line 24, in dfs\n    parts.append('1' + dfs(l) + '0')\n                       ^^^^^^\n  File \"/tmp/tmpjoqxvjrf.py\", line 24, in dfs\n    parts.append('1' + dfs(l) + '0')\n                       ^^^^^^\n  [Previous line repeated 994 more times]\nRecursionError: maximum recursion depth exceeded"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef makeLargestSpecial(s: str) -> str:\n    \"\"\"Return the lexicographically largest special binary string\n    obtainable by swapping consecutive special substrings.\"\"\"\n    # 1. 建立「起始位置 → 子子串清單」的映射\n    stack = []                # 用來配對 '1' 與 '0'\n    children = {}             # children[start] = list of (start, end) 子串\n\n    for i, ch in enumerate(s):\n        if ch == '1':\n            stack.append(i)\n        else:  # ch == '0'\n            j = stack.pop()\n            pair = (j, i)\n            children.setdefault(j, []).append(pair)\n\n    # 2. 以遞迴方式處理子子串，並在每層排序\n    def dfs(start: int) -> str:\n        parts = []\n        for l, r in children.get(start, []):\n            # 先處理子子串，再包上外層的 '1' ... '0'\n            parts.append('1' + dfs(l) + '0')\n        parts.sort(reverse=True)        # 使字串最大\n        return ''.join(parts)\n\n    # 3. 對最外層的子串做包裝\n    return '1' + dfs(0) + '0'\n\n\ndef main() -> None:\n    # 讀取輸入，提取字串內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    match = re.search(r'\"(.*?)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接去除可能的前綴\n        s = data.replace('s =', '').strip().strip('\"')\n\n    result = makeLargestSpecial(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, for algorithm to find lexicographically largest string by swapping consecutive special substrings. This is a known LeetCode problem: 870. Lexicographically Largest Binary String After Swap Adjacent Strings. Approach: parse string into special substrings recursively: each special substring can be decomposed into concatenation of two special substrings, so we can sort the inner parts descending. Use stack to find boundaries. Algorithm: find pairs of matching parentheses like positions of 0 and 1 counts. Use stack to store start indices. Build list of substrings for each special substring: each is a concatenation of child special substrings. Then recursively process each child to sort lexicographically descending. Then build result.\n\nBut we need to produce virtual code in steps. Provide explanation after each line. Must not output actual code but pseudo. So we need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 stack, result list // 等等\n\nWe need to use arrows and Decision: etc.\n\nWe need to show algorithm. We'll produce lines: input, stack, parse loop, build mapping, recursive function, etc.\n\nLet's outline:\n\n1. Input string s.\n2. Create stack to store indices of '1' (open).\n3. Create array children[0..n-1] as list of child substrings for each special substring; can be map from start index to list of pairs (start,end).\n4. For i from 0 to n-1:\n   if s[i]=='1' push i\n   else pop j from stack; substring j..i is special; add this pair to children of j? Actually we need parent mapping: when we find a closing, the substring j..i is a special substring, and its children are all special substrings that were fully inside j..i, i.e., all pairs popped after j and before i? Approach: Use stack to find boundaries, also maintain list of substrings for each start: each time we pop j, we add pair (j,i) to children[j] but need to store children for that pair? Maybe easier: use list of pair objects: for each start index j, store list of child pairs inside it. We can maintain a map from start index to list of child pairs. When we pop j, we create a new substring j..i. The children of this substring are all pairs that were created after j and before i, i.e., those whose start > j and end <= i. But we can handle by using a stack of indices and a list of child lists for each start.\n\nSimpler: Use recursion: parse function parse(l,r): inside find all sub pairs inside (l,r). Use stack again? Instead of complicated, we can parse using stack and store mapping from start to its immediate children (i.e., the sub special substrings directly inside). While iterating, when we pop j, we know that the substring j..i is a special substring. At that moment, we can record that this substring j..i has as its children all the pairs that have been opened after j and closed before i. We can maintain a list of indices on stack: each entry is start index. When we pop j, the current stack contains all starts of outer substrings. We can maintain an array childLists where childLists[j] collects pairs popped after j until just before i. We can use a variable last to track last popped start.\n\nActually known solution: Use stack of indices; maintain list of children: when we pop, we add the pair to the list of its parent (which is now top of stack after pop). But we need immediate children. So after pop j, if stack not empty, the top is parent start p. So we add the pair j..i to children[p] list. Also we add pair j..i to a global list of pairs. After parsing, we have mapping from each start to list of child pairs. Then we recursively sort.\n\nSo steps:\n\n- Stack s\n- Array children (map from index to list of pairs)\n- List allPairs\n\nfor i in 0..n-1:\n  if s[i]=='1': push i\n  else:\n    j = pop()\n    pair = (j,i)\n    allPairs.append(pair)\n    if stack not empty:\n      parentStart = stack[-1]\n      children[parentStart].append(pair)\n\nAfter loop, we have top-level pair is 0..n-1. Now define recursive function process(start,end):\n  get childList = children[start]\n  if childList empty:\n    return s[start:end+1]  // no inner special\n  else:\n    for each child in childList:\n        sortedChild = process(child.start, child.end)\n    sort sortedChildList descending lexicographically\n    return concatenation of sortedChildList\n\nFinally, call process(0,n-1) to get result.\n\nReturn result.\n\nWe'll output virtual code with steps. Use Start, End, Decision etc. Provide explanation per line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Read input string s // 取得要處理的特殊二進位字串\n→ Step 2: n = length of s // 字串長度\n→ Step 3: 初始化空棧 stack // 用於追蹤 '1' 的位置\n→ Step 4: 初始化映射 children[start] → 空列表 // 存放每個特殊子串的直接子子串\n→ Step 5: 初始化列表 allPairs = 空 // 记录所有特殊子串的 (start,end)\n\n→ Decision: 遍歷 i 從 0 到 n-1? // 循環掃描整個字串\n    Yes → Step 6: 如果 s[i] == '1'?\n        Yes → Step 7: stack.push(i) // 發現開啟符號，存入棧\n        No  → Step 8: j = stack.pop() // 找到對應的 '1'，確定一個特殊子串\n        No  → Step 9: pair = (j, i) // 記錄子串範圍\n        No  → Step 10: allPairs.append(pair) // 加入全局列表\n        No  → Step 11: 如果 stack 不是空的?\n            Yes → Step 12: parentStart = stack.top() // 父級子串的起始位置\n            Yes → Step 13: children[parentStart].append(pair) // 把當前子串加入父級的子列表\n            No  → Step 14: // 當前子串為最外層，無父級\n\n→ End of loop // 完成子串分段\n\n→ Step 15: 定義遞迴函式 process(start, end) // 處理指定特殊子串\n    → Decision: children[start] 是否為空？\n        Yes → Step 16: return s[start:end+1] // 無內部特殊子串，直接返回原字串\n        No  → Step 17: childResults = 空列表\n        No  → For each childPair in children[start]？\n            Yes → childResult = process(childPair.start, childPair.end) // 递归处理子子串\n            Yes → childResults.append(childResult)\n        No  → Step 18: sort childResults 以降序字典序 // 使後續拼接得到最大的字串\n        No  → Step 19: return concat(childResults) // 連接排序後的子串\n\n→ Step 20: result = process(0, n-1) // 處理整個字串\n→ Step 21: 輸出 result // 返回最終的字串\n\n→ End // 程式結束\n\nBut we must use arrow syntax precisely as required: \"→\" for steps, \"Decision:\" for conditions. Each line must end with // explanation. Must include \"Start\" and \"End\".\n\nAlso need to show the loop with Decision: maybe using \"Decision: i < n?\" or \"Decision: 遍歷 i 從 0 到 n-1\" is okay. Provide proper indent. Use nested Decision for if else. We need to ensure each line is separate.\n\nWe can also structure the loop as:\n\nDecision: i < n ?\n    Yes → Step ...\n    No  → // loop end\n\nBut to keep simple, we can describe loop as a step: \"Loop i from 0 to n-1\" but the format requires Decision? We can treat the loop itself as a step with an arrow. However the sample uses Decision: for if conditions. For loop maybe we can use Decision: for i=0; i<n; i++? Might be okay to just use a step \"→ Loop i from 0 to n-1\" but not exactly arrow. The specification: \"Use virtual code's arrow (→, Yes →, No →) and structure (Start, End, Decision:)\". So loops can be represented with a Decision and a Yes branch? Alternatively use \"→ Step 6: For i = 0 to n-1 // loop over characters\". That may suffice. But better to mimic typical pseudocode with Decision.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Read input string s // 取得輸入的特殊二進位字串\n→ Step 2: n ← length(s) // 計算字串長度\n→ Step 3: stack ← empty stack // 用於匹配 '1' 與 '0'\n→ Step 4: children ← map from int to list of pairs // 存放每個子串的直接子子串\n→ Step 5: allPairs ← empty list // 记录所有特殊子串\n\n→ Decision: i < n ? // 循環遍歷字串\n    Yes → Step 6: If s[i] == '1' ?\n        Yes → Step 7: stack.push(i) // 發現開頭，入棧\n        No  → Step 8: j ← stack.pop() // 找到匹配的 '1'\n        No  → Step 9: pair ← (j, i) // 建立子串範圍\n        No  → Step 10: allPairs.append(pair) // 加入全局列表\n        No  → Decision: stack is not empty ?\n            Yes → Step 11: parent ← stack.top() // 父級子串起始\n            Yes → Step 12: children[parent].append(pair) // 加入父級的子列表\n            No  → Step 13: // 子串為最外層，無父級\n        No  → // 處理完一個 '0'\n    No  → // i >= n，結束循環\nEnd // 循環結束\n\nBut we need to indicate loop end. Use \"Decision: i < n?\" then No branch goes to after loop. After loop, we proceed.\n\nBetter to structure loop as separate steps:\n\n→ Step 6: For i from 0 to n-1\n    ... but not arrow? Actually we can use arrow for each step inside loop, but the loop itself can be represented by a Decision for condition i < n. However that might be too detailed.\n\nWe can just present as:\n\n→ Step 6: For i = 0 to n-1 // loop over string indices\n    → Step 7: If s[i] == '1' ? // check character\n        Yes → stack.push(i)\n        No → j = stack.pop()\n           pair = (j,i)\n           allPairs.append(pair)\n           If stack not empty ?\n               parent = stack.top()\n               children[parent].append(pair)\n\nSimplify.\n\nBut each line must include // explanation. So each line of step must end with // explanation. For nested lines we can prefix arrow as \"→\". For decision we use \"Decision:\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read input string s // 取得輸入的特殊二進位字串  \n→ Step 2: n ← length(s) // 計算字串長度  \n→ Step 3: stack ← empty stack // 用於追蹤 '1' 的位置  \n→ Step 4: children ← map from int to list of pairs // 存放每個特殊子串的直接子子串  \n→ Step 5: allPairs ← empty list // 记录所有特殊子串的 (start,end)  \n\n→ Decision: i < n? // 循環遍歷字串  \n    Yes → Step 6: For i = 0 to n-1 // 逐位處理字串  \n        → Step 7: If s[i] == '1' ? // 判斷是否為開頭  \n            Yes → Step 8: stack.push(i) // 將開頭位置存入棧  \n            No  → Step 9: j ← stack.pop() // 取得匹配的開頭位置  \n            No  → Step 10: pair ← (j, i) // 確定特殊子串範圍  \n            No  → Step 11: allPairs.append(pair) // 加入全局列表  \n            No  → Decision: stack is not empty? // 是否還有外層子串存在  \n                Yes → Step 12: parent ← stack.top() // 取出父級子串起始位置  \n                Yes → Step 13: children[parent].append(pair) // 把本子串加入父級的子列表  \n                No  → Step 14: // 本子串為最外層，無父級  \n        No  → // 已處理完一個 '0'，繼續循環  \n    No  → // i >= n，循環結束  \n\n→ Step 15: Define recursive function process(start, end) // 處理指定特殊子串  \n    → Decision: children[start] is empty? // 判斷是否有子子串  \n        Yes → Step 16: return s[start : end+1] // 無子子串，直接返回原字串  \n        No  → Step 17: childResults ← empty list // 儲存子子串處理結果  \n        No  → For each childPair in children[start] // 逐一遞迴處理子子串  \n            → Step 18: childResult ← process(childPair.start, childPair.end) // 遞迴呼叫  \n            → Step 19: childResults.append(childResult) // 加入結果列表  \n        No  → Step 20: Sort childResults in descending lexicographic order // 使拼接後最大  \n        No  → Step 21: return Concatenate(childResults) // 連接排序後的子串  \n\n→ Step 22: result ← process(0, n-1) // 處理整個字串  \n→ Step 23: Output result // 回傳最終的字串  \n\nEnd // 程式結束。"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入包裝成一個列表，便於解析\n    ops, args = eval(f'[{data}]')\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)\n        else:\n            results.append(getattr(obj, op)(*arg))\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for pickIndex function that takes array w, precomputes prefix sums, then generate random number between 0 and total weight, find first index with prefix sum > random. Steps: Start, Input w, compute prefix array, store total, function pickIndex: generate random r in [0,total), binary search for first prefix > r. Return index. Provide virtual code lines with explanation comments.\n\nEnsure using virtual arrows and decision etc. Probably multiple lines. Use indentation for decision branches. Provide Start and End. Also need Step 1, Step 2 etc.\n\nLet's create:\n\nStart\n→ Step 1: 初始化前綴和陣列 prefix = [] // 用於存儲累積權重\n→ Step 2: total = 0 // 總權重\n→ Step 3: 對於每個 w[i] 從 0 到 n-1\n    → Step 3.1: total += w[i] // 累加到總權重\n    → Step 3.2: prefix.append(total) // 存儲累積和\n→ End // 初始化完成\n\nThen function pickIndex():\nStart // pickIndex 執行\n→ Step 4: r = 隨機數生成器在 [0,total) // 產生隨機數\n→ Decision: 是否使用線性搜尋？ // 這裡演示線性搜尋\n    Yes → Step 5: for i in 0..n-1\n        → Decision: prefix[i] > r ?\n            Yes → Step 6: 返回 i // 找到符合條件的索引\n            No → // 繼續\n    No → Step 7: binary_search(prefix, r) // 或者二分搜尋\n        → Step 8: 返回該索引\nEnd // pickIndex 結束\n\nBut we need to adhere to formatting: Each line starts with virtual code step followed by // explanation. For decisions, indentation. Use arrows. Eg:\n\nStart // 程式開始執行\n→ Step 1: ...\n→ Decision: ...\n    Yes → ...\n    No  → ...\n\nWe need to show the steps in a clear linear order. For function pickIndex, we may need to include Step labels. Let's design:\n\nStart // 初始化 w\n→ Step 1: prefix = [] // 前綴和陣列\n→ Step 2: total = 0 // 總權重\n→ Step 3: for i from 0 to w.length-1\n    → Step 3.1: total += w[i] // 累加權重\n    → Step 3.2: prefix.append(total) // 儲存累積和\n→ End // 完成前置處理\n\nThen define function pickIndex():\nStart // pickIndex 開始\n→ Step 4: r = random() * total // 隨機數\n→ Decision: 二分搜尋可用？\n    Yes → Step 5: low = 0, high = prefix.length-1\n        → Step 6: while low < high\n            → Step 6.1: mid = (low + high) // 2\n            → Decision: prefix[mid] <= r ?\n                Yes → low = mid + 1\n                No  → high = mid\n        → Step 7: return low // 找到的索引\n    No  → Step 8: for i in 0..prefix.length-1\n        → Decision: prefix[i] > r ?\n            Yes → return i\n            No  → // continue\nEnd // pickIndex 結束\n\nMake sure each line has comment after //.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: prefix = [] // 建立前綴和陣列，用於儲存累積權重\n→ Step 2: total = 0 // 初始化總權重\n→ Step 3: for i from 0 to w.length-1\n    → Step 3.1: total += w[i] // 把第 i 個權重加入總權重\n    → Step 3.2: prefix.append(total) // 將累積和存入前綴和陣列\n→ End // 前置處理完成，prefix 及 total 已準備好\n\n// -------------------- pickIndex 函式 --------------------\nStart // pickIndex 開始執行\n→ Step 4: r = random() * total // 產生一個 [0, total) 的隨機數\n→ Decision: 是否使用二分搜尋？\n    Yes → Step 5: low = 0, high = prefix.length-1 // 初始化二分搜尋範圍\n        → Step 6: while low < high\n            → Step 6.1: mid = (low + high) // 2 // 計算中點\n            → Decision: prefix[mid] <= r ?\n                Yes → low = mid + 1 // 往右半邊搜尋\n                No  → high = mid // 往左半邊搜尋\n        → Step 7: return low // low 位置的前綴和大於 r，回傳索引\n    No  → Step 8: for i in 0 to prefix.length-1\n        → Decision: prefix[i] > r ?\n            Yes → return i // 找到第一個前綴和大於 r 的索引\n            No  → // 繼續檢查下一個\nEnd // pickIndex 結束執行"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      \"'2'\""
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      \"'123'\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Multiply two non-negative integer strings without converting to int.\n        \"\"\"\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        pos = [0] * (m + n)\n\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n                pos[p1] += sum_ // 10\n                pos[p2] = sum_ % 10\n\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result or '0'\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read()\n    # Find all digit sequences in the input\n    numbers = re.findall(r'\\d+', data)\n    if len(numbers) < 2:\n        # If input format is not as expected, treat entire input as one number and multiply by 0\n        num1, num2 = numbers[0], '0' if numbers else ''\n    else:\n        num1, num2 = numbers[0], numbers[1]\n\n    sol = Solution()\n    product = sol.multiply(num1, num2)\n    # Print the result wrapped in single quotes as per the examples\n    print(f\"'{product}'\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for multiplication of two non-negative integers represented as strings, returning product string, without using built-in BigInteger or converting to integer. Standard algorithm: simulate multiplication like manual method, storing partial products.\n\nWe should provide step-by-step algorithm:\n\nStart\n\n- Input num1, num2 strings.\n\n- If either is \"0\", return \"0\".\n\n- Determine lengths n1, n2.\n\n- Create result array of size n1 + n2 initialized to 0.\n\n- Loop i from n1-1 down to 0 (digits of num1):\n\n    - digit1 = int(num1[i])\n\n    - Loop j from n2-1 down to 0:\n\n        - digit2 = int(num2[j])\n\n        - Multiply digit1*digit2 + result[i+j+1] to get sum.\n\n        - result[i+j+1] = sum % 10\n\n        - result[i+j] += sum / 10\n\n- After loops, convert result array to string skipping leading zeros.\n\n- Return string.\n\nAlso need to include decision for zero check.\n\nReturn End.\n\nWe need to present each step as a virtual code line with arrow and explanation comment.\n\nWe must not output actual code; just pseudo-steps.\n\nMake sure each line has \"虛擬碼步驟\" then comment.\n\nAlso need arrow \"→\" or \"Decision:\" etc.\n\nWe should represent loops perhaps as \"Loop i from n1-1 down to 0\".\n\nWe must include decisions for zero check: \"Decision: if num1 == '0' or num2 == '0'?\".\n\nAlso maybe for conversion of digits: \"Convert char to integer\".\n\nBetter produce something like:\n\nStart // 程式開始\n\n→ Step 1: Read num1, num2 strings // 取得輸入字串\n\n→ Decision: If num1 == '0' or num2 == '0'? // 檢查是否任一為零\n\n    Yes → Step 2: Return '0' // 直接回傳零\n\n    No  → Step 3: Compute lengths n1, n2 // 取得字串長度\n\n→ Step 4: Create array result of size n1+n2, initialized 0 // 存儲乘積各位\n\n→ Step 5: Loop i from n1-1 down to 0 // 逐位處理 num1\n\n    → Step 6: digit1 = numeric value of num1[i] // 取 num1 的單位數\n\n    → Step 7: Loop j from n2-1 down to 0 // 逐位處理 num2\n\n        → Step 8: digit2 = numeric value of num2[j] // 取 num2 的單位數\n\n        → Step 9: prod = digit1 * digit2 + result[i+j+1] // 乘積加進已有值\n\n        → Step 10: result[i+j+1] = prod % 10 // 將單位位存回\n\n        → Step 11: result[i+j] += prod / 10 // 將進位加至前一位\n\n→ Step 12: Convert result array to string, skipping leading zeros // 轉成字串\n\n→ Step 13: Return product string // 結果輸出\n\nEnd // 程式結束\n\nMake sure each line includes comment.\n\nWe need to use virtual code arrow and structure. Use \"Decision:\" lines and \"Yes →\" \"No →\".\n\nWe must not use actual code; just pseudo.\n\nWe need to ensure that each line has \"虛擬碼步驟\" (though the example shows just step). The requirement: Each line must contain `虛擬碼步驟` + space + `// 解釋/說明`. But maybe they mean \"虛擬碼步驟\" is the step itself. So we will just write the step then space then comment. Use \"Start\" etc.\n\nWe can incorporate arrow: \"→\". Use \"Decision:\".\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 num1, num2 // 取得兩個非負整數的字串表示  \n→ Decision: 是否 num1 為 '0' 或 num2 為 '0'? // 檢查任一數字是否為零  \n Yes → Step 2: 回傳字串 '0' // 直接返回零的乘積  \n No  → Step 3: 計算 n1 = len(num1), n2 = len(num2) // 獲取字串長度  \n→ Step 4: 建立長度為 n1+n2 的整數陣列 result，初值為 0 // 用於儲存每位乘積  \n→ Step 5: 從 i = n1-1 迭代到 0 // 逐位處理 num1（從最低位開始）  \n  → Step 6: digit1 = 數字(num1[i]) // 取得 num1 的單一位數值  \n  → Step 7: 從 j = n2-1 迭代到 0 // 逐位處理 num2  \n    → Step 8: digit2 = 數字(num2[j]) // 取得 num2 的單一位數值  \n    → Step 9: prod = digit1 * digit2 + result[i+j+1] // 計算乘積並加入先前的進位  \n    → Step 10: result[i+j+1] = prod % 10 // 把單位位存回陣列  \n    → Step 11: result[i+j] += prod / 10 // 把進位加到更高位  \n→ Step 12: 建立空字串 product  \n  → Step 13: 對 result 陣列逐位掃描，跳過前導 0，將每個位數轉為字符並連接到 product // 轉換為最終字串  \n→ Step 14: 回傳 product // 輸出乘積字串  \nEnd // 程式結束執行"
    }
  ]
}