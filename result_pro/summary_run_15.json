{
  "run_index": 15,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 393,
  "generation_or_validation_failure_count": 46,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "def count_lines_in_file(file_path='data.txt'):\n    \"\"\"\n    試著開啟指定的檔案，若成功回傳行數；若找不到檔案回傳 None。\n    \"\"\"\n    try:\n        # 使用 with 語法安全開啟檔案，並以 UTF‑8 讀取\n        with open(file_path, 'r', encoding='utf-8') as f:\n            # 讀取所有行並計算行數\n            lines = f.readlines()\n            return len(lines)\n    except FileNotFoundError:\n        # 檔案不存在時回傳 None\n        return None\n\n\ndef main():\n    \"\"\"\n    主程式區塊，依需求從標準輸入讀取資料（雖然此例中不會使用），\n    然後執行行數統計並輸出結果。\n    \"\"\"\n    import sys\n\n    # 讀取所有 stdin 資料（對此題目而言並不會被使用，但符合題目要求）\n    _ = sys.stdin.read()\n\n    # 取得檔案行數\n    line_count = count_lines_in_file()\n\n    # 根據是否成功取得行數輸出相對應訊息\n    if line_count is None:\n        print('找不到檔案！')\n    else:\n        print(f'檔案共有 {line_count} 行')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Let's list steps:\n\nStart\n→ Step 1: 將檔案路徑設為 \"data.txt\" // 定義要開啟的檔案\n→ Decision: 檔案是否存在? // 先檢查檔案是否存在\nYes → Step 2: 用 with 語法開啟檔案 // 開啟檔案進行讀取\n→ Step 3: 初始化行數計數器 = 0 // 計算行數\n→ Step 4: 逐行讀取檔案，對每行行數加 1 // 逐行處理\n→ Step 5: 輸出「總共有 {行數} 行文字」 // 顯示結果\nNo  → Step 6: 輸出 '找不到檔案！' // 檔案不存在時提示\nEnd\n\nBut also need try/except. So we can incorporate:\n\nStart\n→ Step 1: 設定檔名 = \"data.txt\" // 目標檔案名稱\n→ Decision: 嘗試開啟檔案? // 進入 try/except\nYes → Step 2: with open(檔名, 'r') as file: // 開啟檔案\n→ Step 3: 行數 = 0 // 行數初始化\n→ Step 4: for line in file: 行數 += 1 // 逐行計數\n→ Step 5: 輸出 \"總共有 {行數} 行文字\" // 輸出結果\nNo → Step 6: 輸出 \"找不到檔案！\" // exception處理\nEnd\n\nBut need to show Decision and arrow structure. Let's format as per example: Use \"Decision:\" then Yes→ ... No→ ...\n\nUse indentation to indicate nested. Provide each line with virtual code and comment.\n\nWe need to include try/except. Maybe Decision: \"是否成功開啟檔案?\" is equivalent to try. But we can mimic with Decision: \"檔案存在?\" which is essentially try/except.\n\nBut we can show:\n\nDecision: 是否成功執行 try? Actually we could write:\n\nDecision: 是否能成功開啟檔案? // 試圖開啟\nYes → Step 2: with open(...)\n\nNo  → Step 3: 輸出錯誤訊息\n\nBut then we don't show try/except explicitly. But maybe we can include \"Try\" and \"Except\" virtual steps. Example:\n\n→ Step 1: Set file_path = \"data.txt\" // 設定檔名\n→ Step 2: Try // 進入 try 區塊\n    → Step 3: with open(file_path, 'r') as file: // 開啟檔案\n    → Step 4: 行數 = 0 // 初始化計數\n    → Step 5: for line in file: 行數 += 1 // 逐行計數\n    → Step 6: 輸出 \"總共有 {行數} 行文字\" // 輸出結果\n→ Except FileNotFoundError: // 捕捉檔案未找到\n    → Step 7: 輸出 \"找不到檔案！\" // 錯誤訊息\nEnd\n\nBut the format expects Start, End, Decision:, maybe using Try and Except as steps. Let's follow the example: Use \"Decision:\" for branching. However, we can incorporate Try/Except as separate steps. For example:\n\nStart\n→ Step 1: file_path = \"data.txt\" // 定義檔名\n→ Step 2: Try // 開始嘗試\n    → Step 3: with open(file_path, 'r') as file: // 用 with 開啟\n    → Step 4: 行數 = 0 // 計數器\n    → Step 5: for line in file: 行數 += 1 // 逐行\n    → Step 6: 輸出 \"總共有 {行數} 行文字\" // 顯示結果\n→ Except FileNotFoundError: // 捕捉檔案不存在\n    → Step 7: 輸出 \"找不到檔案！\" // 提示訊息\nEnd\n\nWe need to maintain the arrow syntax. In example, they used \"→\" for next step. For nested steps within Try/Except, they used indentation? The example didn't show nested steps. We can indent for readability but still include arrows.\n\nBetter to maintain same structure: Each line: virtual code step + space + comment.\n\nUse arrow for each step. Use indent for nested steps. For Try, we can write \"→ Step 2: Try\" then indent sub-steps: \"    → Step 3: with ...\". For Except: \"→ Step 8: Except FileNotFoundError\" then indent.\n\nLet's produce final answer.\n\nRemember to not output actual code, just virtual code. Use brackets after step? The sample uses \"Step 1:\" etc. Let's follow that.\n\nMake sure to include \"Start\" and \"End\". Provide each line with comment. Provide no actual code like open(...). But we can still reference conceptually like \"with open(file_path, 'r') as file:\" but not actual code. It's okay because it's virtual.\n\nWe need to comply with \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\". So we should use arrow. Use \"Step X:\" lines. Use \"Decision:\" for branching but we don't have branching here; but we can show try/except as branching. But the sample uses Decision for if statements. We can use Decision to check if file exists? But we use try/except.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: file_path ← \"data.txt\" // 設定要開啟的檔案路徑  \n→ Step 2: Try // 嘗試執行開啟檔案的程式區塊  \n  → Step 3: with open(file_path, 'r') as file: // 用 with 語法安全開啟檔案  \n   → Step 4: line_count ← 0 // 初始化行數計數器  \n   → Step 5: for line in file: line_count ← line_count + 1 // 逐行累加計數  \n   → Step 6: print(\"總共有 \" + line_count + \" 行文字\") // 輸出總行數  \n→ Except FileNotFoundError // 捕捉檔案不存在的例外  \n  → Step 7: print(\"找不到檔案！\") // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,1,3,1,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 1, 3, 1, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳結果列表。\n\n    參數:\n        n (int): 擲骰次數\n    回傳:\n        list[int]: 每次擲骰的結果\n    \"\"\"\n    return [random.randint(1, 6) for _ in range(n)]\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    code = sys.stdin.read()\n    # 直接執行輸入的程式碼\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step, with each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. Include random module. Define function roll_dice(n). Use loop to roll n times, append result to list, return list. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random 模組 // 引入 random 模組以便產生隨機數  \n→ Step 2: 定義函數 roll_dice(n) // 宣告函數，參數 n 為擲骰次數  \n    → Step 2.1: 初始化 results 為空串列 // 用於儲存每一次擲骰的結果  \n    → Step 2.2: Decision: 是否已擲完 n 次？ // 檢查是否還有未完成的擲骰  \n        Yes → End of Loop // 所有擲骰完成  \n        No  → Step 2.3: 產生 random.randint(1, 6) // 擲一次六面骰，得到 1~6  \n            → Step 2.4: 把結果加入 results 串列 // 將擲骰結果儲存  \n            → Step 2.5: 迴圈回到 Decision: 是否已擲完 n 次？ // 繼續下一次擲骰  \n    → Step 2.6: 返回 results 串列 // 回傳所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '約2.0秒'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '約 2.0 秒'"
        }
      ],
      "generated_code": "import sys\nimport time\nimport io\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func 執行所需秒數，回傳四捨五入到小數點 3 位的耗時。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取標準輸入的 Python 程式碼，執行並捕捉輸出，\n    之後將輸出包裝成「約 X 秒」格式輸出。\n    \"\"\"\n    code = sys.stdin.read()          # 取得整個輸入\n    # 用 StringIO 捕捉執行時的輸出\n    old_stdout = sys.stdout\n    sys.stdout = io.StringIO()\n    try:\n        # 執行輸入的程式碼，使用全域字典\n        exec(code, globals())\n        # 取得被捕捉的輸出\n        output = sys.stdout.getvalue()\n    finally:\n        sys.stdout = old_stdout\n\n    # 清理輸出，只取第一行數值\n    result = output.strip().splitlines()[0] if output.strip() else \"0\"\n\n    print(f\"約 {result} 秒\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, each line has \"虛擬碼步驟 [space] // 解釋\". Use arrows. Provide Start, End, Decision. The function measure_time(func, *args) measures time in seconds using time module, returns result rounded to 3 decimals. Provide virtual code.\n\nWe need to use \"虛擬碼\" steps: maybe steps like import time, define function, record start, call func, record end, compute elapsed, round, return. Need to indicate returning the result of func? Wait: The function should measure func execution time and return result (rounded to 3 decimals). The \"result\" likely the time measured, not the function's output. The spec: \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\". So returns elapsed time, not the function result.\n\nWe should include a decision maybe? Not needed. But we can show call. Use arrow lines. Provide each line with explanation. Use \"→\" arrow after Start? Format similar to example. We'll produce something like:\n\nStart // 程式開始\n→ Step 1: 導入 time 模組 // 需要時間測量\n→ Step 2: 定義函數 measure_time(func, *args) // 用來包裝目標函數\n→ Step 3: 在函數內部，記錄 start_time ← time.time() // 開始時間\n→ Step 4: 執行目標函數 func(*args) // 呼叫使用者提供的函數\n→ Step 5: 記錄 end_time ← time.time() // 結束時間\n→ Step 6: 計算 elapsed ← end_time - start_time // 取得耗時\n→ Step 7: 四捨五入 elapsed 到 3 位小數 → rounded ← round(elapsed, 3) // 保留三位小數\n→ Step 8: 回傳 rounded // 將耗時返回給呼叫者\nEnd // 程式執行結束\n\nWe need to use \"→\" before each step. Also can use \"Step\" naming. Ensure explanation is short but intuitive. Use Chinese explanation. No actual code. Use \"虛擬碼步驟\". For each step we need arrow and step description. Provide explanation comment.\n\nWe might include \"→\" preceding steps. Use \"Start\" and \"End\" as separate lines. Should we indent decisions? No decisions needed. So we don't need \"Decision:\".\n\nMake sure each line has \"虛擬碼步驟\" then space then \"// 解釋\".\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 導入 time 模組 // 需要 time.time() 來取得時間  \n→ Step 2: 定義函數 measure_time(func, *args) // 用來包裝目標函數  \n→ Step 3: 記錄 start_time ← time.time() // 紀錄執行前的時間戳  \n→ Step 4: 執行目標函數 func(*args) // 呼叫使用者提供的函式  \n→ Step 5: 記錄 end_time ← time.time() // 紀錄執行後的時間戳  \n→ Step 6: 計算 elapsed ← end_time - start_time // 取得耗時  \n→ Step 7: 四捨五入 elapsed 到 3 位小數 → rounded ← round(elapsed, 3) // 保留三位小數  \n→ Step 8: 回傳 rounded // 回傳測量結果給呼叫者  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"orange\",\"grape\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'orange', 'grape', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取任何輸入，雖然本題不需要，但依規定須讀入\n    sys.stdin.read()\n    \n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n    \n    # 1. 新增 'orange'\n    fruits.add('orange')\n    \n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n    \n    # 3. 移除 'banana'\n    fruits.remove('banana')\n    \n    # 4. 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n    \n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines per the format. We'll write Start, then Step 1: define set, etc. Use arrows. Each line: \"虛擬碼步驟 // 解釋\". Provide step-by-step.\n\nMake sure each line starts with an arrow? The format example shows:\n\nStart // 程式開始執行\n→ Step 1: ... // comment\n\nWe need to use \"→\" for steps, maybe indentation for nested decisions. But here no decisions. Just linear steps.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式結束\n\nEach line with // explanation. Ensure Chinese. Use \"←\" or \"=\"? We'll use ← to denote assignment. Use '//' for comments.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增元素 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'  \n→ Step 6: print(fruits) // 輸出最終集合 fruits  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\n# -----------------------------\n# 取得美元對台幣匯率的函式\n# -----------------------------\ndef fetch_rate():\n    \"\"\"\n    取得 USD -> TWD 匯率\n    返回匯率值 (float)，如果失敗則回傳 None\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        response = requests.get(url, timeout=10)\n        data = response.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\n# -----------------------------\n# 更新 GUI 中顯示匯率的函式\n# -----------------------------\ndef update_gui_rate():\n    \"\"\"\n    取得最新匯率並更新 label 的文字\n    \"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n    else:\n        label.config(text=\"取得匯率失敗，請檢查網路連線\")\n\n# -----------------------------\n# 主程式入口\n# -----------------------------\nif __name__ == \"__main__\":\n    # 讀取標準輸入的內容\n    input_data = sys.stdin.read().strip()\n\n    # 如果輸入中包含「更新匯率」或「按下」，就直接取得匯率並印到 stdout\n    if \"更新匯率\" in input_data or \"按下\" in input_data:\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"取得匯率失敗\")\n\n    # 建立 Tkinter GUI\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    # 標籤顯示匯率資訊\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    # 按鈕點擊時呼叫 update_gui_rate\n    button = tk.Button(win, text=\"更新匯率\", command=update_gui_rate)\n    button.pack(pady=5)\n\n    # 進入 GUI 事件迴圈\n    win.mainloop()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Use Start, End, Decision, arrows. No actual code. Use virtual steps: import modules, create Tk window, label, button, function to fetch rate, update label. Use requests get. parse JSON, get TWD. Update label. Bind button. Provide explanation comments after each line.\n\nLet's produce steps. We'll use pseudo code steps. Use `→` arrows.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 導入 requests 與 tkinter 模組 // 引入需要的庫  \n→ Step 2: 建立 Tk 視窗物件 // 用於顯示匯率資訊  \n→ Step 3: 設定視窗標題為 'USD ↔ TWD 匯率查詢' // 提供使用者識別窗口功能  \n→ Step 4: 建立 Label 佈局並放入預設文字 '匯率將於按鈕點擊後顯示' // 顯示匯率結果的地方  \n→ Step 5: 於視窗中加入 Button，標籤為 '更新匯率' // 觸發 API 呼叫  \n→ Decision: 先定義 fetch_rate() 函式？ // 判斷是否已建立匯率取得函式  \n    Yes → Step 6: 定義 fetch_rate(): 進行 HTTP GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 呼叫匯率 API  \n    → Step 7: 若請求成功，解析 JSON 並取得 'rates.TWD' 值 // 取得美元兌台幣匯率  \n    → Step 8: 更新 Label 文字為 f'1 USD = {rate} TWD' // 顯示最新匯率  \n    → Step 9: 若請求失敗，更新 Label 文字為 '取得匯率失敗' // 錯誤提示  \n    No  → Step 10: 建立空的 fetch_rate() 函式以防止未定義錯誤 // 避免程式崩潰  \n→ Step 11: 將 fetch_rate() 函式綁定至 Button 的 command 參數 // 使按鈕點擊時呼叫該函式  \n→ Step 12: 呼叫 mainloop() 進入 tkinter 事件迴圈 // 顯示視窗並等待使用者互動  \nEnd // 程式執行結束"
    },
    {
      "title": "Top K Frequent Elements",
      "source_file": "Leetcode/leetcode347.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp677j6gp5.py\", line 23, in <module>\n    main()\n  File \"/tmp/tmp677j6gp5.py\", line 16, in main\n    k_part = parts[1].split('=',1)[1].strip()\n             ~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphdgw25su.py\", line 23, in <module>\n    main()\n  File \"/tmp/tmphdgw25su.py\", line 16, in main\n    k_part = parts[1].split('=',1)[1].strip()\n             ~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef top_k_frequent(nums, k):\n    freq = Counter(nums)\n    return [num for num, _ in freq.most_common(k)]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect format: nums = [...], k = ...\n    parts = data.split(',')\n    nums_part = parts[0].split('=',1)[1].strip()\n    k_part = parts[1].split('=',1)[1].strip()\n    nums = ast.literal_eval(nums_part)\n    k = int(k_part)\n    result = top_k_frequent(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code with explanation lines, step by step, no actual code. The user wants virtual code for the problem: given array nums and k, return k most frequent elements. So we need to produce algorithm: count frequencies with hash map, then use min-heap of size k, or sort by freq, etc. We can choose a typical solution: frequency map, min-heap. Use virtual code lines with arrow and decisions.\n\nWe must produce in traditional Chinese. Each line: \"虛擬碼步驟 [空格] // 解釋\". Use Start, End. Use arrows \"→\", \"Yes →\", \"No →\". Provide step names. Provide algorithm steps: Initialize map, count freq, create min-heap, iterate map, maintain size k, then extract results into list, return. Provide explanation.\n\nAlso we may show if k equals number of unique elements etc. Provide decisions? Might not need decisions. But we can show condition: if heap size > k then pop. Use decisions.\n\nWe need to adhere to format.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空哈希表 freqMap // 用來存每個元素的出現次數\n→ Step 2: 對 nums 中的每個值 num 進行\n    → freqMap[num] += 1 // 更新頻率\n→ Step 3: 建立最小堆 minHeap // 儲存前 k 個最高頻率的元素\n→ Step 4: 對 freqMap 中每個 (value, count) 進行\n    → Decision: minHeap.size() < k? // 堆中元素是否已不足 k 個\n        Yes → minHeap.insert((count, value)) // 直接加入\n        No  → Decision: count > minHeap.peek().count? // 目前頻率是否高於堆頂最小頻率\n            Yes → minHeap.pop() // 移除最小頻率\n                  minHeap.insert((count, value)) // 加入更高頻率\n            No  → // 不加入，保留前 k 個\n→ Step 5: 建立空列表 result // 儲存最終答案\n→ Step 6: 當 minHeap 不為空時\n    → Decision: minHeap.pop() // 取出堆頂\n        → Step 7: 把 popped.value 加入 result // 加入答案\n→ Step 8: 回傳 result // 回傳 k 個最頻繁元素\nEnd // 程式執行結束\n\nBut need each line with arrow. We can write as:\n\nStart // 程式開始執行\n→ Step 1: 初始化 freqMap = {} // 建立空的頻率哈希表\n→ Step 2: 對 nums 中每個 num\n    → freqMap[num] = freqMap.get(num, 0) + 1 // 計算頻率\n→ Step 3: 初始化 minHeap = [] // 建立最小堆，用來保留前 k 個頻率最高的元素\n→ Step 4: 對 freqMap 的每個 (num, count)\n    → Decision: minHeap.size < k? // 堆中元素是否不足 k 個\n        Yes → minHeap.insert((count, num)) // 直接加入堆\n        No  → Decision: count > minHeap.peek().count? // 與堆頂最小頻率比較\n            Yes → minHeap.pop()\n                  minHeap.insert((count, num)) // 用更高頻率替換\n            No  → // 什麼也不做\n→ Step 5: 初始化 result = [] // 儲存答案\n→ Step 6: 當 minHeap 不為空時\n    → Decision: minHeap.pop() // 取出堆頂\n        → Step 7: result.append(popped.num) // 加入答案\n→ Step 8: 回傳 result // 返回 k 個最頻繁元素\nEnd // 程式結束\n\nWe must ensure each line has a space after the code and before //. Also use arrow for decisions. Ensure to indent appropriately. Provide step labels with colon? The sample uses \"Step 1: ...\". We'll follow similar.\n\nAlso each decision branch uses \"Yes →\" and \"No →\". Provide code inside the branches with indentation. Might need to represent indent with spaces. In sample, they show:\n\n    Yes → Step 2: ...\n    No  → Decision: ...\n\nSo we can replicate. We'll output:\n\nStart // 程式開始執行\n→ Step 1: 初始化 freqMap = {} // 建立空的頻率哈希表\n→ Step 2: 對 nums 中每個 num\n    → freqMap[num] = freqMap.get(num, 0) + 1 // 計算頻率\n→ Step 3: 初始化 minHeap = [] // 建立最小堆，用來保留前 k 個頻率最高的元素\n→ Step 4: 對 freqMap 的每個 (num, count)\n    → Decision: minHeap.size < k? // 堆中元素是否不足 k 個\n        Yes → minHeap.insert((count, num)) // 直接加入堆\n        No  → Decision: count > minHeap.peek().count? // 與堆頂最小頻率比較\n            Yes → minHeap.pop()\n                  minHeap.insert((count, num)) // 用更高頻率替換\n            No  → // 什麼也不做\n→ Step 5: 初始化 result = [] // 儲存答案\n→ Step 6: 當 minHeap 不為空時\n    → Decision: minHeap.pop() // 取出堆頂\n        → Step 7: result.append(popped.num) // 加入答案\n→ Step 8: 回傳 result // 返回 k 個最頻繁元素\nEnd // 程式結束\n\nBut we need to ensure each line ends with // explanation. Also indentation lines after decision should be nested. Should we indent them with spaces? The sample uses 4 spaces indent for nested lines.\n\nWe should produce each line as separate line, not grouped. For branches we may use two lines per branch. But each line must be a separate line. We need to maintain structure. Example:\n\n→ Decision: minHeap.size < k? // ...\n    Yes → minHeap.insert((count, num)) // ...\n    No  → Decision: count > minHeap.peek().count? // ...\n        Yes → minHeap.pop() // ...\n              minHeap.insert((count, num)) // ...\n        No  → // ...\n\nEach of these lines has to be a line. That might be okay.\n\nAlso after Step 6: \"當 minHeap 不為空時\" and \"Decision: minHeap.pop()\" but we need a loop. The sample doesn't use loops but maybe we can just \"While minHeap not empty\". But we can express as \"While minHeap not empty:\" then inside. Let's keep simple: \"While minHeap not empty\" and inside pop and append. But we might need to express in pseudocode style: \"While minHeap not empty\" is a step.\n\nThus:\n\n→ Step 6: While minHeap not empty // 循環取出所有堆頂元素\n    → Step 7: popped = minHeap.pop() // 取出最小頻率元素\n              result.append(popped.num) // 加入答案\n\nBut we must keep each line separate with explanation.\n\nBetter:\n\n→ Step 6: While minHeap not empty // 只要堆中還有元素，就繼續\n    → Step 7: popped = minHeap.pop() // 取出堆頂\n              // popped 包含 (count, num)\n    → Step 8: result.append(popped.num) // 將元素加入答案\n\nBut we might duplicate Step 8. Let's restructure:\n\n→ Step 6: While minHeap not empty // 只要堆中還有元素，就繼續\n    → Step 7: popped = minHeap.pop() // 取出堆頂\n    → Step 8: result.append(popped.num) // 將元素加入答案\n\nBut we also need to return after loop. So Step 9: return result.\n\nThus we will use steps with numeric labels accordingly. We'll keep uniqueness.\n\nHowever, we earlier used Step 5: initialize result. Step 6: while minHeap not empty. Step 7: popped = minHeap.pop(). Step 8: result.append(popped.num). Step 9: return result.\n\nBut we already had Step 8 as return earlier. So we need to adjust numbering. Let's just number sequentially:\n\nStart\n→ Step 1: 初始化 freqMap = {} // 建立空的頻率哈希表\n→ Step 2: 對 nums 中每個 num\n    → freqMap[num] = freqMap.get(num, 0) + 1 // 計算頻率\n→ Step 3: 初始化 minHeap = [] // 建立最小堆，用來保留前 k 個頻率最高的元素\n→ Step 4: 對 freqMap 的每個 (num, count)\n    → Decision: minHeap.size < k? // 堆中元素是否不足 k 個\n        Yes → minHeap.insert((count, num)) // 直接加入堆\n        No  → Decision: count > minHeap.peek().count? // 與堆頂最小頻率比較\n            Yes → minHeap.pop()\n                  minHeap.insert((count, num)) // 用更高頻率替換\n            No  → // 什麼也不做\n→ Step 5: 初始化 result = [] // 儲存答案\n→ Step 6: While minHeap not empty // 只要堆中還有元素，就繼續\n    → Step 7: popped = minHeap.pop() // 取出堆頂\n              // popped 包含 (count, num)\n    → Step 8: result.append(popped.num) // 將元素加入答案\n→ Step 9: 返回 result // 回傳 k 個最頻繁元素\nEnd\n\nBut we must ensure each line has space between code and //, and each line separate. The \"While minHeap not empty\" line should be a step, but we must keep indentation for nested lines. But we must ensure each line ends with // explanation. For \"While minHeap not empty\" line, we add // 只要堆中還有元素，就繼續. For nested lines, we need to indent with spaces.\n\nAlso note: The \"While\" step may need an arrow? The sample uses \"→\" at the beginning for steps. So use \"→ Step 6: While minHeap not empty // ...\". For nested lines inside the while, we use indentation and a \"→\" again. So:\n\n→ Step 6: While minHeap not empty // 只要堆中還有元素，就繼續\n    → Step 7: popped = minHeap.pop() // 取出堆頂\n    → Step 8: result.append(popped.num) // 將元素加入答案\n\nBut we might have Step 7 and Step 8 inside the while. That should be fine.\n\nWe need to ensure each line ends with // and explanation. Provide Chinese explanation.\n\nThus final answer.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 freqMap = {} // 建立空的頻率哈希表  \n→ Step 2: 對 nums 中每個 num  \n    → freqMap[num] = freqMap.get(num, 0) + 1 // 計算每個元素的出現頻率  \n→ Step 3: 初始化 minHeap = [] // 建立最小堆，用於保留前 k 個最高頻率的元素  \n→ Step 4: 對 freqMap 的每個 (num, count)  \n    → Decision: minHeap.size < k? // 堆中元素是否不足 k 個  \n        Yes → minHeap.insert((count, num)) // 直接加入堆  \n        No  → Decision: count > minHeap.peek().count? // 與堆頂最小頻率比較  \n            Yes → minHeap.pop()  \n                  minHeap.insert((count, num)) // 用更高頻率替換堆頂  \n            No  → // 什麼也不做，保留前 k 個元素  \n→ Step 5: 初始化 result = [] // 儲存最終答案  \n→ Step 6: While minHeap not empty // 只要堆中還有元素，就繼續  \n    → Step 7: popped = minHeap.pop() // 取出堆頂，popped 包含 (count, num)  \n    → Step 8: result.append(popped.num) // 將元素加入答案  \n→ Step 9: 返回 result // 回傳 k 個最頻繁元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[None,[0,0],[2,0],[1,0],None,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[None, [0, 0], [2, 0], [1, 0], None, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    \"\"\"\n    以一維索引映射的方式，實作 O(1) 的 flip 與 O(k) 的空間複雜度。\n    \"\"\"\n    def __init__(self, m: int, n: int) -> None:\n        self.m = m\n        self.n = n\n        self.total = m * n          # 仍可被翻轉的格子數\n        self.mapping = {}           # 索引映射表，記錄已被使用的索引\n\n    def flip(self):\n        # 隨機選取一個剩餘索引\n        r = random.randint(0, self.total - 1)\n        # 實際的索引值\n        idx = self.mapping.get(r, r)\n        # 把 r 位置映射到最後一個剩餘位置\n        last = self.mapping.get(self.total - 1, self.total - 1)\n        self.mapping[r] = last\n        # 减少剩餘格子數\n        self.total -= 1\n        # 轉回 (row, col)\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        # 清空映射表，恢復所有格子為 0\n        self.mapping.clear()\n        self.total = self.m * self.n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 移除換行，方便解析\n    data = data.replace('\\n', ' ')\n    # 將兩個列表用 '],' 分開\n    split_idx = data.find('],')\n    if split_idx == -1:\n        return\n\n    cmd_list_str = data[:split_idx + 1]\n    arg_list_str = data[split_idx + 2:].strip()\n    if not arg_list_str.startswith('['):\n        arg_list_str = '[' + arg_list_str\n\n    commands = ast.literal_eval(cmd_list_str)\n    arguments = ast.literal_eval(arg_list_str)\n\n    outputs = []\n    obj = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == 'Solution':\n            obj = Solution(arg[0], arg[1])\n            outputs.append(None)\n        elif cmd == 'flip':\n            outputs.append(obj.flip())\n        elif cmd == 'reset':\n            obj.reset()\n            outputs.append(None)\n        else:\n            # 若遇到未知指令，略過\n            pass\n\n    print(outputs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. No real code. Must be in Chinese. Provide step-by-step algorithm. Use arrow notation. For this problem, solution: use reservoir sampling? Actually typical solution: Flatten matrix into list of all indices 0..mn-1. Use random selection among remaining indices. Use mapping dictionary to swap used index to end. Approach: maintain list of available indices. Initially available indices 0..mn-1. Keep count of remaining. flip: pick random k in [0, remaining-1]. get actual index = mapping.get(k, k). then mapping[k] = mapping.get(remaining-1, remaining-1) to swap. decrement remaining. convert index to (i, j). reset: clear mapping, remaining=mn. Complexity O(1) expected.\n\nWe need to produce virtual code steps. Could break into initialization, flip, reset. Use Start, Decision, etc. Provide explanation.\n\nLet's produce something like:\n\nStart\n→ Step: 初始化 m, n, total = m*n\n→ Step: 建立 mapping = 空映射\n→ Step: 剩餘 count = total\nEnd\n\nflip:\nStart\n→ Step: 如果 count == 0? // no more zeros\n    No → Throw exception\n    Yes → Decision...\nBut typical algorithm: pick random index r = random(0, count-1)\n→ Step: 取得實際索引 real = mapping.get(r, r)\n→ Step: 取得替代索引 remIndex = mapping.get(count-1, count-1)\n→ Step: mapping[r] = remIndex // 置換\n→ Step: count = count-1\n→ Step: i = real / n, j = real % n\n→ Step: 返回 [i, j]\nEnd\n\nreset:\nStart\n→ Step: 清空 mapping\n→ Step: count = total\nEnd\n\nWe should also mention that we minimize random calls by one per flip. Space: O(number of flipped cells) mapping. Good.\n\nMake sure each line ends with // explanation. Use arrow symbol. For Decision, indent with Yes/No lines. Use spaces. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 初始化變數 m, n 以及 total = m * n // 計算矩陣總格數\n→ Step: 建立空字典 mapping = {} // 用來映射已被翻轉的索引\n→ Step: 剩餘可翻轉格數 remain = total // 初始時所有格子都可被選取\nEnd // 初始化結束\n\nflip() // 隨機翻轉一個尚未翻轉的格子\nStart // flip 函式開始執行\n→ Decision: 若 remain == 0? // 是否已經沒有可翻轉的格子？\n    Yes → Step: 返回空或拋出錯誤 // 沒有格子可選\n    No  → // 進行翻轉操作\n        → Step: 隨機產生 r = random(0, remain - 1) // 一次呼叫 random\n        → Step: realIndex = mapping.get(r, r) // 若 r 已被映射則取其映射值，否則取 r 本身\n        → Step: lastIndex = mapping.get(remain - 1, remain - 1) // 取得剩餘最後一個索引的實際值\n        → Step: mapping[r] = lastIndex // 將 r 的位置映射到最後一個索引，以備後續移除\n        → Step: remain = remain - 1 // 已翻轉一格，剩餘格數減一\n        → Step: i = realIndex / n // 計算行座標\n        → Step: j = realIndex % n // 計算列座標\n        → Step: return [i, j] // 回傳翻轉後的格子座標\nEnd // flip 函式結束\n\nreset() // 重置整個矩陣\nStart // reset 函式開始執行\n→ Step: 清空 mapping = {} // 釋放所有映射\n→ Step: remain = total // 將剩餘格數恢復到初始值\nEnd // reset 函式結束\n\n// 這個設計每次 flip 只呼叫一次 random，時間複雜度 O(1)，空間複雜度 O(k)（k 為已翻轉格子數）"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpky9pdpf7.py\", line 50, in <module>\n    obj.buildDict(arg)\n  File \"/tmp/tmpky9pdpf7.py\", line 12, in buildDict\n    self.word_set = set(dictionary)\n                    ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.word_set = set()\n        self.pattern_map = {}\n\n    def buildDict(self, dictionary):\n        # 建立單詞集合與 pattern map\n        self.word_set = set(dictionary)\n        self.pattern_map = {}\n        for word in dictionary:\n            for i in range(len(word)):\n                pattern = word[:i] + '*' + word[i+1:]\n                self.pattern_map.setdefault(pattern, []).append(word)\n\n    def search(self, searchWord):\n        # 嘗試將每個位置改成 '*', 看是否能匹配到不同的單詞\n        for i in range(len(searchWord)):\n            pattern = searchWord[:i] + '*' + searchWord[i+1:]\n            if pattern in self.pattern_map:\n                for word in self.pattern_map[pattern]:\n                    if word != searchWord:  # 必須改一個字才能匹配\n                        return True\n        return False\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 把兩個 list 包起來成為一個 tuple，方便 literal_eval\n    try:\n        ops, args = ast.literal_eval('[' + data + ']')\n    except Exception:\n        # 如果直接解析失敗，嘗試手動分割\n        parts = data.split('],', 1)\n        ops = ast.literal_eval(parts[0] + ']')\n        args = ast.literal_eval(parts[1])\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            obj = MagicDictionary()\n            result.append(None)\n        elif op == \"buildDict\":\n            obj.buildDict(arg)\n            result.append(None)\n        elif op == \"search\":\n            result.append(obj.search(arg))\n\n    # 輸出符合 LeetCode 風格的 JSON\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with comments. The code will implement MagicDictionary with buildDict and search. Use data structure. We should design algorithm: maybe store words grouped by length, also precompute all variants with one wildcard. For each word, generate all patterns replacing one char with '*' and store mapping pattern->original words. Then search: generate patterns of searchWord by replacing each char with '*', check if any pattern leads to a word that is not exactly the same string. If found, return true. Also if searchWord is not in dict but pattern exists with any word, return true.\n\nImplementation steps: Build: iterate over words; for each word, for each position i, pattern = word[0:i] + '*' + word[i+1:]; add word to map[pattern]. Also store set of words.\n\nSearch: For searchWord, if length not in dictionary, return false. For each position i, pattern = searchWord[0:i] + '*' + searchWord[i+1:]; get list from map; if any word in list not equal to searchWord -> return true. If none, return false.\n\nEdge: We need to ensure exactly one character changed: If searchWord itself is in dictionary, patterns will match itself but we should not count that as a match unless there is another word. So check if word != searchWord. So our algorithm handles.\n\nAlso need to handle empty? Not necessary.\n\nWe produce virtual code lines. Use Start, End, Decision, etc.\n\nWe need to present each line as: \"虛擬碼步驟 // 解釋\".\n\nWe will not produce actual code, only pseudo with arrows.\n\nLet's outline:\n\nStart\n→ Initialize MagicDictionary class // 定義類\n→ Define constructor // 初始化空結構\n→ 內部變數: dictByLen, patternMap, wordSet // 存儲\n\n→ Method buildDict(dictionary) //  建立資料結構\n    → For each word in dictionary\n        → Add word to wordSet\n        → For each index i\n            → pattern = replace char at i with '*'\n            → If pattern not in patternMap, create list\n            → Append word to patternMap[pattern]\n    → End For\n\n→ Method search(searchWord) // 搜尋\n    → If searchWord not in wordSet AND patternMap not contain any pattern? Actually we will generate patterns\n    → For each index i\n        → pattern = replace char at i with '*'\n        → If pattern exists in patternMap\n            → For each word in patternMap[pattern]\n                → If word != searchWord\n                    → Yes → Return true // 找到可改一字的匹配\n    → End For\n    → No → Return false\n\nEnd\n\nBut we need to use Decision and Yes/No arrows. We need to produce more detailed flow. Use Decision: check if pattern exists. Then inside check words.\n\nAlso we need to note that we might want to skip if word length differs. But we can just rely on patternMap.\n\nLet's produce step-by-step lines.\n\nWe'll output lines like:\n\nStart // 程式開始執行\n→ Step: 定義 MagicDictionary 類別 // 初始化類\n...\n\nBetter to keep consistent with example: \"Start // 程式開始執行\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義 MagicDictionary 類別 // 建立類別容器  \n→ Step: 建構子 MagicDictionary() // 初始化空資料結構  \n    → Step: wordSet ← 空集合 // 用於快速判斷字串是否已存在  \n    → Step: patternMap ← 空字典 // key 為 * 形式的字串，value 為包含此 pattern 的所有原始字串列表  \n→ End // 建構子完成  \n\n→ Step: buildDict(dictionary) // 建立資料結構  \n    → Decision: dictionary 是否為空？  \n        Yes → End // 無需建構，直接結束  \n        No  →  \n            → Step: 對 dictionary 中每個 word 進行遍歷  \n                → Step: wordSet.Add(word) // 記錄字串  \n                → Step: 對每個索引 i (0..word.Length-1) 進行遍歷  \n                    → Step: pattern ← word[0..i-1] + '*' + word[i+1..] // 把第 i 個字母替換為 *  \n                    → Decision: patternMap 是否已包含 pattern？  \n                        Yes → Step: patternMap[pattern].Add(word) // 加入同 pattern 的字串  \n                        No  → Step: patternMap[pattern] ← [word] // 新建列表  \n                → End // 完成對單個字串的所有 pattern 生成  \n            → End // 完成整個字典的建構  \n→ End // buildDict 完成  \n\n→ Step: search(searchWord) // 查詢是否能改一個字匹配字典  \n    → Decision: searchWord 是否為空？  \n        Yes → Return false // 空字串無法匹配  \n        No  →  \n            → Step: For i in 0..searchWord.Length-1  \n                → Step: pattern ← searchWord[0..i-1] + '*' + searchWord[i+1..]  \n                → Decision: patternMap.ContainsKey(pattern)？  \n                    Yes →  \n                        → Step: For 每個 word 在 patternMap[pattern]  \n                            → Decision: word ≠ searchWord？  \n                                Yes → Return true // 找到不同的字串，恰好改一個字即可匹配  \n                                No  → Continue // 跳過相同字串  \n                        → End // 完成該 pattern 的檢查  \n                    No  → Continue // 該 pattern 未出現在字典中，檢查下一個位置  \n            → End // 完成所有位置的檢查  \n            → Return false // 沒有任何位置能改一字匹配  \n→ End // search 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Smallest Letter Greater Than Target",
      "source_file": "Leetcode/leetcode744.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"a\"",
          "expected_output": "\"c\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpimck0sv5.py\", line 27, in <module>\n    letters = eval(part.split('=')[1].strip())\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [\"c\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"c\"",
          "expected_output": "\"f\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpce95rjj3.py\", line 27, in <module>\n    letters = eval(part.split('=')[1].strip())\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [\"c\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"",
          "expected_output": "\"x\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6jsif2f1.py\", line 27, in <module>\n    letters = eval(part.split('=')[1].strip())\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [\"x\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass Solution:\n    def nextGreatestLetter(self, letters, target):\n        # 二分搜尋找最小大於 target 的字元\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if letters[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        # 如果 left 趕出範圍，則返回第一個字元\n        return letters[left % len(letters)]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入格式: letters = [\"c\",\"f\",\"j\"], target = \"a\"\n    parts = [p.strip() for p in data.split(',')]\n    letters = []\n    target = ''\n    for part in parts:\n        if part.startswith('letters'):\n            letters = eval(part.split('=')[1].strip())\n        elif part.startswith('target'):\n            target = eval(part.split('=')[1].strip())\n    solution = Solution()\n    result = solution.nextGreatestLetter(letters, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. It's a classic \"next greater letter\" problem. Steps: start, input array letters sorted, input target. Then iterate through array to find first char > target. If found, return that char; else return letters[0]. Use decision.\n\nLet's produce lines accordingly. Use Start, End. Use Decision lines. Provide comments. Each line: `虛擬碼步驟 // 解釋`.\n\nWe need to ensure to cover at least two different characters assumption not used. But we can mention.\n\nUse loop. But maybe simplified: binary search? But step wise, simple linear search.\n\nLet's produce steps: Start, Step 1: input array, Step 2: input target, Step 3: set result = first char, Step 4: for each char in letters, Decision if char > target, Yes -> result = char; break. After loop, Step 5: return result, End.\n\nAdd explanation each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收已排序的字元陣列 letters 與目標字元 target // 取得輸入資料  \n→ Step 2: 初始化變數 result 為 letters[0] // 預設為最小字元（若無更大字元時返回）  \n→ Step 3: 循環遍歷 letters  \n  → Decision: 目前字元 c 是否 > target? // 判斷是否符合條件  \n    Yes → Step 4: 將 result 設為 c 並中斷循環 // 找到第一個比 target 大的字元  \n    No  → 繼續循環 // 若不符合則繼續檢查下一個字元  \n→ Step 5: 回傳 result // 回傳找到的最小比 target 大的字元或回到第一個字元  \nEnd // 程式執行結束"
    },
    {
      "title": "Next Greater Element I",
      "source_file": "Leetcode/leetcode496.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps38xd9wg.py\", line 42, in <module>\n    result = solution.nextGreaterElement(nums1, nums2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmps38xd9wg.py\", line 14, in nextGreaterElement\n    return [next_greater.get(x, -1) for x in nums1]\n            ^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyf7k3ixz.py\", line 42, in <module>\n    result = solution.nextGreaterElement(nums1, nums2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpyf7k3ixz.py\", line 14, in nextGreaterElement\n    return [next_greater.get(x, -1) for x in nums1]\n            ^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextGreaterElement(self, nums1, nums2):\n        stack = []\n        next_greater = {}\n\n        for num in nums2:\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n\n        return [next_greater.get(x, -1) for x in nums1]\n\ndef parse_input(data: str):\n    \"\"\"\n    將類似 'nums1 = [4,1,2], nums2 = [1,3,4,2]' 的字串解析為兩個 list。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n\n    # 分割成 nums1 與 nums2 的部分\n    if 'nums2 =' in data:\n        part1, part2 = data.split('nums2 =', 1)\n    else:\n        raise ValueError(\"輸入格式錯誤，缺少 'nums2 ='\")\n\n    part1 = part1.replace('nums1 =', '').strip()\n    part2 = part2.strip()\n\n    nums1 = ast.literal_eval(part1)\n    nums2 = ast.literal_eval(part2)\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums1, nums2 = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.nextGreaterElement(nums1, nums2)\n\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. This is a classic \"next greater element\" problem. Approach: Preprocess nums2 to find next greater for each element using stack. Then for each element in nums1, lookup. Steps: Start, compute map of next greater for each element in nums2, using stack. Then for each element in nums1: get its next greater from map, store or -1. End. Provide line by line.\n\nNeed to use virtual code arrow format. Each line: \"虛擬碼步驟 // 解釋\". Use arrow lines. Use indentation for decisions maybe. But we just need to produce steps. Should use \"Start\" and \"End\". Use arrow lines: \"→\". Use \"Decision:\" if any. But algorithm is mostly sequential.\n\nWe should produce something like:\n\nStart // 開始執行\n→ Step 1: 建立空的映射 nextGreater // 用於儲存每個元素對應的下一個更大值\n→ Step 2: 初始化空棧 stack // 用於追蹤尚未找到下一個更大值的元素\n→ Decision: 是否有元素剩餘於 nums2? // 循環遍歷 nums2\n    Yes → Step 3: 取出當前元素 curr = nums2[i] // 当前元素\n    → Decision: stack 是否非空且 stack.top() < curr? // 檢查棧頂元素是否小於 curr\n        Yes → Step 4: 取出 top = stack.pop() // 取出棧頂元素\n        → Step 5: 設定 nextGreater[top] = curr // top 的下一個更大值為 curr\n        → Decision: stack 是否還非空且 stack.top() < curr? // 可能還有多個棧頂元素小於 curr\n            Yes → 重複 Step 4-5 // 重複將所有小於 curr 的棧頂元素都映射到 curr\n            No  → 退出迴圈\n        → Decision: 是否還有元素需要處理? // 循環繼續\n            Yes → 進入下一輪\n            No → 退出迴圈\n        No  → 進入下一步\n    No  → 退出迴圈\n→ Step 6: 將 curr 推入 stack // 未找到更大值的 curr 推進棧\n→ Decision: 是否還有元素處理完? // 以上循環結束\n    Yes → 重複 Step 3-6\n    No  → 退出迴圈\n→ Step 7: 對於 stack 中剩餘元素, 設定 nextGreater[elem] = -1 // 沒有更大值\n→ Step 8: 建立結果陣列 ans = 空列表 // 用於儲存答案\n→ Step 9: 遍歷 nums1 的每個元素 val\n    → Step 10: 取得 next = nextGreater.get(val, -1) // 從映射中取值，缺失則為 -1\n    → Step 11: 將 next 加入 ans // 添加到答案中\n→ End // 結束程式\n\nBut need to produce using correct arrow notation. Provide each line with step number and arrow.\n\nLet's craft final answer accordingly. Use \"Start\" and \"End\". Use \"Decision:\" lines with indent and Yes/No arrows. Provide each step. Use line numbering maybe not necessary but helpful. The spec: \"虛擬碼步驟\" + \" // 解釋\". We can include Step labels.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空映射 nextGreater // 用來記錄每個元素在 nums2 中的下一個更大值  \n→ Step 2: 初始化空棧 stack // 用來追蹤尚未找到下一個更大值的元素  \n\n→ Decision: 是否還有元素待處理於 nums2? // 迴圈遍歷 nums2  \n  Yes → Step 3: 取出 nums2[i] 為 curr // 目前處理的元素  \n  → Decision: stack 非空且 stack.top() < curr? // 檢查棧頂元素是否比 curr 小  \n   Yes → Step 4: 取出 top = stack.pop() // 把棧頂元素移出  \n   → Step 5: 設定 nextGreater[top] = curr // top 的下一個更大值為 curr  \n   → Decision: stack 非空且 stack.top() < curr? // 是否還有更多棧頂元素小於 curr  \n    Yes → 回到 Step 4-5（重複處理多個棧頂元素）  \n    No → 退出內層決策  \n   No → 進行下一步  \n  → Step 6: 將 curr 推入 stack // 尚未找到更大值的 curr 暫存於棧中  \n→ Decision: 是否已經處理完 nums2?  \n  Yes → 退出外層迴圈  \n  No → 進入下一輪  \n\n→ Step 7: 對於 stack 中剩餘的每個元素 elem, 設定 nextGreater[elem] = -1 // 沒有更大值的元素其結果為 -1  \n\n→ Step 8: 建立結果陣列 ans = 空列表 // 用來儲存最終答案  \n\n→ Step 9: 遍歷 nums1 的每個元素 val  \n  → Step 10: 取得 next = nextGreater.get(val, -1) // 從映射中取值，若不存在則為 -1  \n  → Step 11: 將 next 加入 ans // 將答案加入結果陣列  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find K Closest Elements",
      "source_file": "Leetcode/leetcode658.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgjqsw0l8.py\", line 30, in <module>\n    main()\n  File \"/tmp/tmpgjqsw0l8.py\", line 21, in main\n    params = eval(f'{{{data}}}', {}, {})\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {arr = [1,2,3,4,5], k = 4, x = 3}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdv17gbxk.py\", line 30, in <module>\n    main()\n  File \"/tmp/tmpdv17gbxk.py\", line 21, in main\n    params = eval(f'{{{data}}}', {}, {})\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {arr = [1,1,2,3,4,5], k = 4, x = -1}\n     ^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        # 使用二分搜尋尋找起始索引\n        left, right = 0, len(arr) - k\n        while left < right:\n            mid = (left + right) // 2\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]\n\ndef main():\n    # 從標準輸入讀取整行資料\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入轉成字典，例如 'arr = [1,2], k = 2, x = 3' 變成 {'arr':[1,2],'k':2,'x':3}\n    params = eval(f'{{{data}}}', {}, {})\n    arr = params['arr']\n    k = params['k']\n    x = params['x']\n    sol = Solution()\n    result = sol.findClosestElements(arr, k, x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem: find k closest integers to x in sorted array arr. Should return sorted ascending. Must use virtual code steps lines with arrow. Provide explanation after each line.\n\nWe need algorithm: typical sliding window binary search. Approach: use binary search to find insertion point of x. Then expand window to include k elements. Steps: Start; find left/right; use two pointers.\n\nLet's produce pseudocode. Each line step as \"Step 1: ...\" and arrows. Provide decision etc. Must avoid actual code.\n\nWe'll produce:\n\nStart // program starts\n\n→ Step 1: 取得 arr、k、x // input\n\n→ Step 2: 進行二分搜尋找 x 的插入位置 idx // locate nearest\n\n→ Decision: if x 直接存在 arr? // if x is in array\n\n    Yes → Step 3: left = right = idx // set pointers\n\n    No  → Step 3: left = idx - 1, right = idx // pointers around\n\n→ Step 4: 初始化空列表 result // result container\n\n→ Step 5: While result size < k:\n\n    → Decision: left >= 0 和 right < len(arr)？ // check bounds\n\n        Yes → Decision: |arr[left] - x| <= |arr[right] - x| ?\n\n            Yes → Step 6: 將 arr[left] 加入 result; left -=1 // take left\n\n            No  → Step 7: 將 arr[right] 加入 result; right +=1 // take right\n\n        No → Decision: left < 0 ?\n\n            Yes → Step 8: 將 arr[right] 加入 result; right +=1 // only right side\n\n            No  → Step 9: 將 arr[left] 加入 result; left -=1 // only left side\n\n→ Step 10: result 排序升序 // ensure ascending\n\n→ End // finished\n\nBut we need each line with arrow and explanation. Use proper indentation for decisions. Use \"→ Decision:\" etc.\n\nLet's produce each step. Ensure each line has virtual code step and // explanation. Format example: \"Start // 程式開始執行\". For decisions we indent sub-steps. Use \"Yes →\" and \"No →\". Provide explanation after each line.\n\nLet's craft lines:\n\n1. Start // 程式開始執行\n2. → Step 1: 取得輸入陣列 arr、整數 k 與目標值 x // 讀取使用者輸入\n3. → Step 2: 進行二分搜尋定位 x 的插入位置 idx // 找到 x 的最近索引\n4. → Decision: x 是否存在於 arr?\n   Yes → Step 3a: left = right = idx // 若 x 存在，兩指標同指該位置\n   No  → Step 3b: left = idx - 1; right = idx // 若不存在，左指向左側元素，右指向右側元素\n5. → Step 4: 建立空清單 result // 用於存放最終答案\n6. → Step 5: 循環 result 長度 < k 時重複\n7. →   Decision: left >= 0 且 right < len(arr) ?\n      Yes →   Decision: |arr[left] - x| <= |arr[right] - x| ?\n          Yes →   Step 6a: 將 arr[left] 加入 result；left -= 1 // 取離 x 更近的左邊元素\n          No  →   Step 6b: 將 arr[right] 加入 result；right += 1 // 取右邊元素\n      No →   Decision: left < 0 ?\n          Yes →   Step 6c: 將 arr[right] 加入 result；right += 1 // 只能取右側\n          No  →   Step 6d: 將 arr[left] 加入 result；left -= 1 // 只能取左側\n8. → Step 7: 將 result 重新排序為升序 // 確保輸出為升序\n9. End // 程式結束\n\nBut we need each line with arrow maybe at each step. For lines inside decisions, use indentation.\n\nMake sure each line ends with \"// 解釋/說明\" in Chinese.\n\nLet's format properly. Use \"→\" arrow for steps. For decisions: \"→ Decision:\" etc. For sub-steps: use \"Yes →\" and \"No →\". Provide explanation after each line.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 arr、整數 k 與目標值 x // 讀取使用者輸入的資料  \n→ Step 2: 進行二分搜尋定位 x 的插入位置 idx // 找到 x 在陣列中的應插入索引  \n→ Decision: x 是否存在於 arr？ // 判斷 x 是否已在陣列中  \n&nbsp;&nbsp;Yes → Step 3a: left = right = idx // 若 x 存在，左指標與右指標同指向該位置  \n&nbsp;&nbsp;No  → Step 3b: left = idx - 1; right = idx // 若不存在，左指標指向左側最近元素，右指標指向右側最近元素  \n→ Step 4: 建立空清單 result // 用於儲存最終的 k 個最近元素  \n→ Step 5: 當 result 長度 < k 時重複以下過程 // 依序挑選最近的元素直到得到 k 個  \n&nbsp;&nbsp;Decision: left >= 0 且 right < len(arr) ? // 檢查雙指標是否同時在陣列範圍內  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: |arr[left] - x| <= |arr[right] - x| ? // 比較左右兩邊離 x 的距離  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6a: 將 arr[left] 加入 result；left -= 1 // 取左邊更近的元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6b: 將 arr[right] 加入 result；right += 1 // 取右邊更近的元素  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: left < 0 ? // 若左指標已越界，則只能取右側  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6c: 將 arr[right] 加入 result；right += 1 // 取右側元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6d: 將 arr[left] 加入 result；left -= 1 // 取左側元素  \n→ Step 7: 將 result 重新排序為升序 // 確保輸出結果為升序排列  \nEnd // 程式結束執行"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2f81_afu.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmp2f81_afu.py\", line 44, in main\n    words = json.loads(words_part)\n            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 11 (char 10)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass WordFilter:\n    def __init__(self, words):\n        # 建立一個映射，鍵為 (前綴, 後綴)，值為單字在 words 中的索引\n        self.lookup = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            # 產生所有可能的前綴\n            for i in range(L + 1):\n                pref = word[:i]\n                # 產生所有可能的後綴\n                for j in range(L + 1):\n                    suff = word[j:]\n                    # 存入映射，後面出現的索引會覆寫舊值，確保取最大索引\n                    self.lookup[(pref, suff)] = idx\n\n    def f(self, prefix, suffix):\n        # 直接查詢映射，如果不存在則回傳 -1\n        return self.lookup.get((prefix, suffix), -1)\n\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read().strip().replace('\\n', '')\n    if not data:\n        return\n\n    # 將兩個 JSON 陣列拆開\n    # 找到第一個 ']'，它結束第一個陣列\n    split_index = data.find(']')\n    if split_index == -1:\n        raise ValueError(\"輸入格式錯誤，無法找到第一個陣列結尾\")\n\n    words_part = data[:split_index + 1]\n    rest = data[split_index + 1:].strip()\n\n    # 如果之後是逗號，去除\n    if rest.startswith(','):\n        rest = rest[1:].strip()\n\n    # 解析兩個陣列\n    words = json.loads(words_part)\n    pref, suff = json.loads(rest)\n\n    # 建立 WordFilter 並查詢\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n\n    # 輸出結果\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for design of WordFilter class with methods. Provide each line with explanation. The code not actual, just virtual steps. Use arrow structure. Provide steps for initialization and query. Likely using Trie for prefixes and suffixes, or combine them. But need to give pseudo code. We'll produce steps like:\n\nStart\n→ Step 1: Build a dictionary of words with their indices\n→ Step 2: For each word, insert all possible prefixes and suffixes into a combined key map mapping prefix#suffix → index\n→ etc. But for efficient queries, maybe use a combined trie of reversed word and normal word.\n\nBut just produce virtual steps.\n\nWe need to show the algorithm for building.\n\nPseudo:\n\nStart\n→ Step 1: Store words array\n→ Step 2: For each word with index i:\n      → Build prefixes list\n      → Build suffixes list\n      → For each prefix in prefixes:\n          → For each suffix in suffixes:\n              → key = prefix + \"#\" + suffix\n              → map[key] = i  // override ensures largest index\n→ Step 3: f(pref, suff):\n      → key = pref + \"#\" + suff\n      → If key exists in map, return map[key] else -1\n\nAlternatively, we can use a trie that stores suffix as reversed and prefix normal. But the above naive approach is simpler. Complexity: O(n * len^2). But okay.\n\nBut we should reflect design of WordFilter: we can use a dictionary.\n\nWe need to produce pseudo code with each line and explanation.\n\nLet's produce lines with arrows and decisions? For query, we check existence.\n\nThe steps:\n\nStart\n→ Step 1: WordFilter constructor receives array words // initialize\n→ Step 2: Create empty map<string, int> keyToIndex // store prefix#suffix mapping\n→ Step 3: For each word in words with index i:\n      → Build all prefixes of word\n      → Build all suffixes of word\n      → For each prefix:\n          → For each suffix:\n              → key = prefix + \"#\" + suffix\n              → keyToIndex[key] = i // store latest index ensures max\n→ End // constructor finished\n\nf method:\nStart // f method starts\n→ Step 1: Construct key = pref + \"#\" + suff // key for lookup\n→ Step 2: If key exists in keyToIndex:\n          → Return keyToIndex[key] // largest index\n        Else:\n          → Return -1\nEnd // f method ends\n\nBut need to follow required output format with arrow and explanation.\n\nWe need to use \"Start\" \"End\" and \"Decision:\" etc.\n\nLet's produce pseudo code with each line:\n\nStart // 程式開始\n→ Step 1: WordFilter(words) // 建構子接收單字列\n→ Step 2: keyToIndex ← {} // 建立空字典映射\n→ Decision: 是否已處理所有單字? // 判斷是否完成\n    No  → Step 3: for each word w with index i in words // 迭代單字\n        → Step 4: prefixes ← all prefixes of w // 產生前綴\n        → Step 5: suffixes ← all suffixes of w // 產生後綴\n        → Decision: 是否處理完所有前綴? // 迴圈\n            No  → Step 6: for each p in prefixes // 前綴迴圈\n                → Decision: 是否處理完所有後綴? // 迴圈\n                    No  → Step 7: for each s in suffixes // 後綴迴圈\n                        → Step 8: key ← p + \"#\" + s // 組合鍵\n                        → Step 9: keyToIndex[key] ← i // 存入索引\n                    Yes → // 針對每個前綴結束\n            Yes → // 針對每個單字結束\n    Yes → // 所有單字完成\nEnd // 建構子結束\n\nThen method f:\n\nStart // 方法 f 開始\n→ Step 1: key ← pref + \"#\" + suff // 組合查詢鍵\n→ Decision: key 是否存在於 keyToIndex? // 判斷\n    Yes → Step 2: return keyToIndex[key] // 回傳最大索引\n    No  → Step 3: return -1 // 無匹配\nEnd // 方法結束\n\nWe can also include \"Decision:\" formatting.\n\nEnsure each line ends with \"// 解釋\". Provide explanation after each.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: WordFilter(words) // 建構子接收單字列\n→ Step 2: keyToIndex ← {} // 建立空字典映射\n→ Decision: 是否已處理所有單字? // 判斷是否完成\n    No  → Step 3: for each word w with index i in words // 迭代單字\n        → Step 4: prefixes ← all prefixes of w // 產生前綴\n        → Step 5: suffixes ← all suffixes of w // 產生後綴\n        → Decision: 是否處理完所有前綴? // 迴圈\n            No  → Step 6: for each p in prefixes // 前綴迴圈\n                → Decision: 是否處理完所有後綴? // 迴圈\n                    No  → Step 7: for each s in suffixes // 後綴迴圈\n                        → Step 8: key ← p + \"#\" + s // 組合鍵\n                        → Step 9: keyToIndex[key] ← i // 存入索引（覆寫可確保最大索引）\n                    Yes → // 針對每個前綴結束\n            Yes → // 針對每個單字結束\n    Yes → // 所有單字完成\nEnd // 建構子結束\n\nStart // 方法 f 開始\n→ Step 1: key ← pref + \"#\" + suff // 組合查詢鍵\n→ Decision: key 是否存在於 keyToIndex? // 判斷是否有匹配\n    Yes → Step 2: return keyToIndex[key] // 回傳最大索引\n    No  → Step 3: return -1 // 無匹配\nEnd // 方法結束\n```"
    },
    {
      "title": "License Key Formatting",
      "source_file": "Leetcode/leetcode482.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5F3Z-2E9W'\nGot (Norm):      '5F3Z2E9W'\n--- (Raw) ---\nRaw Expected: ' \"5F3Z-2E9W\"'\nRaw Got:      '5F3Z2E9W'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        \"\"\"\n        Reformat the license key string S so that each group has exactly K\n        characters except the first group, which may be shorter but not empty.\n        All letters are converted to uppercase and groups are separated by dashes.\n        \"\"\"\n        # Remove all dashes and convert to uppercase\n        cleaned = S.replace('-', '').upper()\n        n = len(cleaned)\n\n        if n == 0:\n            return \"\"\n\n        # Length of the first group: remainder of n divided by K\n        first_len = n % K\n        if first_len == 0:\n            first_len = K\n\n        # Build the result list\n        parts = [cleaned[:first_len]]\n        for i in range(first_len, n, K):\n            parts.append(cleaned[i:i + K])\n\n        return '-'.join(parts)\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that may be in one of the following formats:\n    1. Two separate lines: first line is the string, second line is integer k.\n    2. Single line containing something like: s = \"5F3Z-2e-9-w\", k = 4\n    3. Single line with quoted string and integer.\n    The function returns (s, k).\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return \"\", 0\n\n    lines = data.splitlines()\n    s = \"\"\n    k = 0\n\n    if len(lines) == 1:\n        line = lines[0]\n        # Extract quoted string if present\n        quote_match = re.search(r'\"([^\"]*)\"', line)\n        if quote_match:\n            s = quote_match.group(1)\n        else:\n            # Remove any 's =' prefix or surrounding whitespace\n            s = re.sub(r'^[^\\w]*', '', line).split(',')[0].strip()\n            s = s.strip('\"').strip()\n\n        # Find the first integer after the string\n        int_match = re.search(r'\\b(\\d+)\\b', line)\n        if int_match:\n            k = int(int_match.group(1))\n    else:\n        # Multiple lines: assume first line is the string, second is k\n        first = lines[0].strip()\n        if first.startswith('\"') and first.endswith('\"'):\n            s = first[1:-1]\n        else:\n            # Remove any 's =' prefix\n            s = re.sub(r'^[^\\w]*', '', first).strip('\"').strip()\n        try:\n            k = int(lines[1].strip())\n        except (IndexError, ValueError):\n            # Fallback: search for integer in all lines\n            int_match = re.search(r'\\b(\\d+)\\b', data)\n            k = int(int_match.group(1)) if int_match else 0\n\n    return s, k\n\ndef main():\n    data = sys.stdin.read()\n    s, k = parse_input(data)\n    solution = Solution()\n    result = solution.licenseKeyFormatting(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: reformat license key. Steps: remove dashes, uppercase, then group from end with k, first group may be shorter. So algorithm: clean string: remove '-', uppercase. Then iterate from end, accumulate groups of size k, prepend to result. Use a list to hold groups, then join with '-'. Provide virtual code with steps.\n\nWe must output line by line, with '虛擬碼步驟' and // explanation. Use arrows etc. The steps:\n\nStart\n→ Step 1: s_clean = RemoveAll(s, '-') // delete dashes\n→ Step 2: s_clean = ToUpperCase(s_clean) // convert to uppercase\n→ Step 3: groups = empty list // to store groups\n→ Step 4: index = len(s_clean) // start from end\n→ Decision: index > 0? // while there are characters left\n    Yes → Step 5: end = index\n    → Step 6: start = max(0, end - k)\n    → Step 7: group = Substring(s_clean, start, end) // take last k or fewer\n    → Step 8: Prepend group to groups // first group will be shortest\n    → Step 9: index = start // move pointer left\n    → Decision: index > 0? // loop\n        Yes → repeat\n        No  → Step 10: result = Join(groups, '-') // join with dashes\n→ End\n\nAlso handle when no groups? But license key has at least one char.\n\nAlso maybe use while loop: Decision with Yes -> loop.\n\nWe need to format each line: \"虛擬碼步驟 // 解釋\". Use arrows: →, Yes →, No →.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: s_clean = RemoveAll(s, '-') // 移除所有破折號，留下純文字  \n→ Step 2: s_clean = ToUpperCase(s_clean) // 將所有字母轉為大寫  \n→ Step 3: groups = EmptyList() // 用來存放各組字串  \n→ Step 4: index = Length(s_clean) // 從字串尾端開始處理  \n→ Decision: index > 0? // 是否還有字元未分組？  \n  Yes → Step 5: end = index // 當前分組結束位置  \n  → Step 6: start = Max(0, end - k) // 取前 k 個字元或不足 k 時取到開頭  \n  → Step 7: group = Substring(s_clean, start, end) // 取得本次分組  \n  → Step 8: Prepend(group, groups) // 先放到首位，確保第一組最短  \n  → Step 9: index = start // 將指標移到下一個未處理位置  \n  → Decision: index > 0? // 繼續處理剩餘字元？  \n    Yes → 回到 Step 5  \n    No → Step 10: result = Join(groups, '-') // 把所有組以破折號連接  \nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Parse Lisp Expression",
      "source_file": "Leetcode/leetcode736.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp27b8dksq.py\", line 71, in <module>\n    result = solution.evaluate(expr_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp27b8dksq.py\", line 60, in evaluate\n    return eval_node(ast, {})\n           ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp27b8dksq.py\", line 40, in eval_node\n    return env[node]\n           ~~~^^^^^^\nKeyError: 'expression'"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpybgoyld2.py\", line 71, in <module>\n    result = solution.evaluate(expr_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpybgoyld2.py\", line 60, in evaluate\n    return eval_node(ast, {})\n           ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpybgoyld2.py\", line 40, in eval_node\n    return env[node]\n           ~~~^^^^^^\nKeyError: 'expression'"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpr8i2nlll.py\", line 71, in <module>\n    result = solution.evaluate(expr_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpr8i2nlll.py\", line 60, in evaluate\n    return eval_node(ast, {})\n           ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpr8i2nlll.py\", line 40, in eval_node\n    return env[node]\n           ~~~^^^^^^\nKeyError: 'expression'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        # Tokenize the expression into parentheses, numbers, and identifiers\n        tokens = re.findall(r'\\(|\\)|[^\\s()]+', expression)\n\n        def parse(pos: int):\n            \"\"\"\n            Parse tokens starting at pos and return (node, new_pos).\n            node is either an int, a string (variable or number), or a list representing an expression.\n            \"\"\"\n            token = tokens[pos]\n            if token == '(':\n                pos += 1  # skip '('\n                op = tokens[pos]\n                pos += 1\n                node = [op]\n                while tokens[pos] != ')':\n                    child, pos = parse(pos)\n                    node.append(child)\n                pos += 1  # skip ')'\n                return node, pos\n            else:\n                # atom: number or variable\n                if re.fullmatch(r'-?\\d+', token):\n                    return int(token), pos + 1\n                else:\n                    return token, pos + 1\n\n        def eval_node(node, env):\n            \"\"\"\n            Recursively evaluate a parsed node given the current environment env.\n            env is a dictionary mapping variable names to integer values.\n            \"\"\"\n            if isinstance(node, int):\n                return node\n            if isinstance(node, str):\n                return env[node]\n            # node is a list\n            op = node[0]\n            if op == 'add':\n                return eval_node(node[1], env) + eval_node(node[2], env)\n            if op == 'mult':\n                return eval_node(node[1], env) * eval_node(node[2], env)\n            if op == 'let':\n                new_env = env.copy()\n                i = 1\n                while i < len(node) - 1:\n                    var = node[i]\n                    val = eval_node(node[i + 1], new_env)\n                    new_env[var] = val\n                    i += 2\n                return eval_node(node[-1], new_env)\n            # Should not reach here\n            raise ValueError(f\"Unknown operator: {op}\")\n\n        ast, _ = parse(0)\n        return eval_node(ast, {})\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the expression string if input contains an assignment\n    match = re.search(r'=\"([^\"]*)\"', data) or re.search(r\"='([^']*)'\", data)\n    if match:\n        expr_str = match.group(1)\n    else:\n        expr_str = data\n    solution = Solution()\n    result = solution.evaluate(expr_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for evaluating Lisp-like expressions. The user didn't specify a particular input, just the description. We need to output pseudocode that parses and evaluates such expression. So we produce steps: Start, parse tokens, evaluate recursively, manage environment stack, etc.\n\nWe need to output line by line: \"虛擬碼步驟\" + \" // 解釋\". Use arrow symbols.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: Tokenise input string into list of tokens // 將輸入字串拆分成標記\n→ Step 2: Initialise an empty environment stack // 建立空的環境堆疊\n→ Decision: 第一個標記是 '('? // 檢查是否為複合式\n    Yes → Step 3: 呼叫 EvaluateExpr(tokens, envStack) // 進行遞迴評估\n    No  → Step 4: 直接轉換為整數 // 單純整數輸入\n→ End // 程式執行結束\n\nNow EvaluateExpr procedure: \n→ Step 5: Pop first token // 取得當前表達式開頭\n→ Decision: token 為 'let'? // 判斷是 let 表達式\n    Yes → Step 6: 將當前環境推入堆疊 // 新範圍\n    → Step 7: 迴圈讀取變數和值直到遇到最後一個 expr // 逐對處理\n        → Step 8: 將變數名稱映射到 EvaluateExpr() 的結果 // 設定值\n    → Step 9: 評估最後 expr // 取得 let 的結果\n    → Step 10: 從堆疊移除環境 // 離開範圍\n    → Return 步驟9結果 // 返回值\n    No → Decision: token 為 'add'? // 判斷 add 表達式\n        Yes → Step 11: 解析兩個子表達式 // 讀取 e1, e2\n        → Step 12: 評估 e1 // recursive\n        → Step 13: 評估 e2 // recursive\n        → Step 14: Return e1 + e2 // 返回加法結果\n        No → Decision: token 為 'mult'? // 判斷 mult 表達式\n            Yes → Step 15: 解析兩個子表達式 // 讀取 e1, e2\n            → Step 16: 評估 e1 // recursive\n            → Step 17: 評估 e2 // recursive\n            → Step 18: Return e1 * e2 // 返回乘法結果\n            No → Decision: token 為變數名稱? // 判斷是變數\n                Yes → Step 19: 在環境堆疊中尋找該變數值 // 從最近到最外\n                → Step 20: Return 找到的值 // 返回\n                No  → Step 21: 把 token 轉為整數 // 直接返回\n(plus End of EvaluateExpr)\n\nWe need to produce line by line, but this procedure is multi-level. We need to output each step line by line with arrows and explanations. Should we indent? The format requires arrows for steps, decisions. We can include nested decisions by indenting? Probably we can just indent lines to show hierarchy but keep arrows.\n\nBetter to produce a linear list of steps representing the algorithm. Use arrows for decisions, and indentation to show nested.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Tokenise the input string into a list of tokens // 將輸入字串拆成標記  \n→ Step 2: Initialise an empty environment stack // 建立空的環境堆疊  \n→ Decision: 第一個標記是否為 '('? // 判斷是否為複合表達式  \n&nbsp;&nbsp;&nbsp;Yes → Step 3: Call EvaluateExpr(tokens, envStack) // 進行遞迴評估  \n&nbsp;&nbsp;&nbsp;No  → Step 4: 直接將標記轉為整數並返回 // 單純整數輸入  \nEnd // 程式執行結束  \n\n---\n\nEvaluateExpr(tokens, envStack)  \n→ Step 5: Pop the first token from tokens as current // 取得表達式開頭  \n→ Decision: token 是否為 'let'? // 判斷是 let 表達式  \n&nbsp;&nbsp;&nbsp;Yes → Step 6: Push a new local scope onto envStack // 建立新範圍  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: While next token 不是 ')' // 讀取變數/值對直到 expr  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: Pop variableName from tokens // 取得變數名  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 9: EvaluateExpr(tokens, envStack) 為 value // 評估對應值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: 把 variableName → value 存入 envStack[最新] // 設定值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 11: EvaluateExpr(tokens, envStack) 為 result // 評估最後的 expr  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 12: Pop the local scope from envStack // 離開範圍  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Return result // 回傳 let 的結果  \n&nbsp;&nbsp;&nbsp;No → Decision: token 是否為 'add'? // 判斷是 add 表達式  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 13: EvaluateExpr(tokens, envStack) 為 left // 評估 e1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 14: EvaluateExpr(tokens, envStack) 為 right // 評估 e2  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 15: Return left + right // 回傳加法結果  \n&nbsp;&nbsp;&nbsp;No → Decision: token 是否為 'mult'? // 判斷是 mult 表達式  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 16: EvaluateExpr(tokens, envStack) 為 left // 評估 e1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 17: EvaluateExpr(tokens, envStack) 為 right // 評估 e2  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 18: Return left * right // 回傳乘法結果  \n&nbsp;&nbsp;&nbsp;No → Decision: token 是否為變數名? // 判斷是否為變數引用  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 19: 從 envStack 內部往外尋找 token 的值 // 作用域查找  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 20: Return 找到的值 // 回傳變數值  \n&nbsp;&nbsp;&nbsp;No  → Step 21: 把 token 轉為整數並返回 // 直接數字  \n(Note: 在所有步驟中，tokens 會自動消費已解析的標記)"
    },
    {
      "title": "Unique Substrings in Wraparound String",
      "source_file": "Leetcode/leetcode467.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_unique_substrings(s: str) -> int:\n    # dp[i] 表示以字母 chr(i + ord('a')) 結尾的最大合法子串長度\n    dp = [0] * 26\n    current_len = 0  # 當前連續合法子串長度\n\n    for i, ch in enumerate(s):\n        if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n            current_len += 1\n        else:\n            current_len = 1\n        idx = ord(ch) - ord('a')\n        if current_len > dp[idx]:\n            dp[idx] = current_len\n\n    return sum(dp)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入，並提取字母序列\n    raw_input = sys.stdin.read()\n    # 取第一個連續的小寫字母序列作為 s\n    match = re.findall(r'[a-z]+', raw_input)\n    s = match[0] if match else \"\"\n\n    result = count_unique_substrings(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. Problem: given s, count unique non-empty substrings of s that appear as contiguous substring in infinite wraparound of alphabet. Known solution: iterate through s, maintain max length of substring ending at each char that satisfies consecutive wraparound property. Keep array of 26 lengths, update when consecutive. For each char, current length of valid substring ending at this char. Set array[char] = max(array[char], current length). Sum of array gives answer. Implementation steps.\n\nWe produce virtual code lines with explanation. Need to be detailed step by step.\n\nStructure: Start, set base? Not needed. We'll compute.\n\nLet's craft lines:\n\nStart // Program start\n\n→ Initialize array len[26] to 0 // track max length for each ending char\n\n→ Initialize currentLen = 0 // length of current valid substring\n\n→ For each character ch in s // iterate over input string\n\n    → If ch is first character or difference between ch and previous char modulo 26 == 1 // consecutive in wraparound\n\n        → currentLen = currentLen + 1 // extend current substring\n\n      No → currentLen = 1 // reset for new substring\n\n    → idx = ch - 'a' // index\n\n    → If currentLen > len[idx] // update max length for this ending char\n\n        → len[idx] = currentLen\n\n→ Sum all values in len array // total unique substrings count\n\n→ Return sum // result\n\nEnd\n\nBut need to format lines with virtual code syntax: \"→ Step 1: ...\" and Decision arrow etc. The above includes some if-else. We'll use Decision: If consecutive? Yes → else. Provide explanation.\n\nAlso need to show loop iteration. We can use \"→ For each ch in s:\" then inside maybe Indent.\n\nBetter to use arrow with indentation.\n\nWe need each line with explanation. Provide code steps lines like:\n\nStart // 程式開始\n\n→ Step 1: 建立長度陣列 len[26]，全部設為 0 // 追蹤每個字母結尾的最大合法子字串長度\n\n→ Step 2: currentLen ← 0 // 當前連續合法子字串長度\n\n→ Step 3: For i from 0 to |s|-1 // 遍歷輸入字串 s\n\n    → Step 4: ch ← s[i] // 取出當前字元\n\n    → Decision: 是否與前一字元連續? // 檢查是否為 wraparound 連續\n\n        Yes → currentLen ← currentLen + 1 // 連續則加長\n\n        No  → currentLen ← 1 // 重新開始計算\n\n    → Step 5: idx ← ord(ch) - ord('a') // 取得字母索引\n\n    → Decision: currentLen > len[idx]? // 檢查是否更新最大長度\n\n        Yes → len[idx] ← currentLen // 更新\n\n        No  → // 不更新\n\n→ Step 6: sum ← 0 // 初始化總計\n\n→ Step 7: For each l in len // 求所有最大長度之和\n\n    → sum ← sum + l // 加總\n\n→ Step 8: Return sum // 結果\n\nEnd // 程式結束\n\nWe need to follow formatting: \"→\" arrow, indent spaces? The example shows indent with 4 spaces? They used \"→ Decision: ...\". We'll replicate.\n\nAlso need to include \"Start\", \"End\".\n\nReturn sum maybe as Step 8: Return sum //.\n\nWe also might include a variable prev = s[0] for first char? In algorithm, we need to handle first char. The check uses prev. We can implement as: if i==0 then currentLen=1 else if consecutive. So we can incorporate that.\n\nBut simpler: set prev = None. For each char: if prev and consecutive: currentLen++ else currentLen=1; prev=ch.\n\nAdd step to set prev initially.\n\nLet's produce:\n\nStart\n\n→ Step 1: 建立長度陣列 len[26]，全部設為 0 // 追蹤每個字母結尾的最大合法子字串長度\n\n→ Step 2: currentLen ← 0 // 當前連續合法子字串長度\n\n→ Step 3: prevChar ← null // 追蹤前一個字元\n\n→ Step 4: For i from 0 to |s|-1 // 遍歷輸入字串 s\n\n    → Step 5: ch ← s[i] // 取出當前字元\n\n    → Decision: prevChar 為 null? // 是否為第一個字元\n\n        Yes → currentLen ← 1 // 初始化長度\n\n        No → Decision: (ch - prevChar) mod 26 == 1? // 是否連續\n\n            Yes → currentLen ← currentLen + 1 // 連續則加長\n\n            No  → currentLen ← 1 // 重新開始\n\n    → Step 6: idx ← ord(ch) - ord('a') // 取得字母索引\n\n    → Decision: currentLen > len[idx]? // 檢查是否更新最大長度\n\n        Yes → len[idx] ← currentLen // 更新\n\n        No  → // 無需更新\n\n    → Step 7: prevChar ← ch // 更新前一字元\n\n→ Step 8: sum ← 0 // 初始化總計\n\n→ Step 9: For each l in len // 求所有最大長度之和\n\n    → sum ← sum + l // 加總\n\n→ Step 10: Return sum // 結果\n\nEnd\n\nNow each line ends with // 解釋.\n\nNeed to use \"虛擬碼步驟\" phrase? The format: \"虛擬碼步驟 [space] // 解釋\". So each line we write the step with arrow etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立長度陣列 len[26]，全部設為 0 // 追蹤每個字母結尾的最大合法子字串長度  \n→ Step 2: currentLen ← 0 // 當前連續合法子字串長度  \n→ Step 3: prevChar ← null // 追蹤前一個字元  \n→ Step 4: For i from 0 to |s|-1 // 遍歷輸入字串 s  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: ch ← s[i] // 取出當前字元  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: prevChar 為 null? // 是否為第一個字元  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → currentLen ← 1 // 初始化長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: (ch - prevChar) mod 26 == 1? // 是否連續  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → currentLen ← currentLen + 1 // 連續則加長  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → currentLen ← 1 // 重新開始  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: idx ← ord(ch) - ord('a') // 取得字母索引  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: currentLen > len[idx]? // 檢查是否更新最大長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → len[idx] ← currentLen // 更新  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 無需更新  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: prevChar ← ch // 更新前一字元  \n→ Step 8: sum ← 0 // 初始化總計  \n→ Step 9: For each l in len // 求所有最大長度之和  \n&nbsp;&nbsp;&nbsp;&nbsp;→ sum ← sum + l // 加總  \n→ Step 10: Return sum // 回傳最終答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7eq8s5cq.py\", line 49, in <module>\n    beginWord, endWord, wordList = parse_input(raw_input)\n                                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7eq8s5cq.py\", line 43, in parse_input\n    data = ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7fe3144f7b10>"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmph6h8llxe.py\", line 49, in <module>\n    beginWord, endWord, wordList = parse_input(raw_input)\n                                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmph6h8llxe.py\", line 43, in parse_input\n    data = ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x77c9fe0f7b10>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        \"\"\"Return the length of the shortest transformation sequence from beginWord to endWord.\n        Uses BFS over all one‑letter mutations that exist in wordList.\n        \"\"\"\n        word_set = set(wordList)          # fast lookup & removal\n        if endWord not in word_set:       # endWord must be reachable\n            return 0\n\n        queue = deque([(beginWord, 1)])   # (current_word, path_length)\n\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:          # reached the target\n                return length\n\n            # generate all one‑letter mutations\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        word_set.remove(new_word)   # avoid revisiting\n                        queue.append((new_word, length + 1))\n\n        return 0   # no path found\n\n\ndef parse_input(inp: str):\n    \"\"\"Parse input of the form:\n       beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\"]\n    into a tuple (beginWord, endWord, wordList).\"\"\"\n    inp = inp.strip()\n    if not inp:\n        return None, None, None\n    # convert the assignment string into a Python dict literal\n    dict_str = '{' + inp.replace(' = ', ': ') + '}'\n    data = ast.literal_eval(dict_str)\n    return data['beginWord'], data['endWord'], data['wordList']\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    beginWord, endWord, wordList = parse_input(raw_input)\n    if beginWord is None:\n        sys.exit()\n    solution = Solution()\n    result = solution.ladderLength(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for word ladder shortest path length. Use BFS. Steps: check endWord in wordList, else return 0. Use queue of words with level. Use visited set. For each word, generate all possible one-letter mutations, check if in wordList and not visited. If mutation == endWord return level+1. Else add to queue and mark visited. After BFS return 0. Also we need to include Start and End markers. Provide per-line virtual code with comment. Use arrow format. Let's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 是否將 endWord 加入字典？ // 判斷目標字是否可達  \n    Yes → Decision: 是否存在 endWord？ // 確認字典內有目標  \n        Yes → Step 1: 若 beginWord == endWord → Return 1 // 同字直接回傳長度 1  \n        No  → Step 2: 初始化 Queue 以及 Level 變數 // 建立 BFS 結構  \n        No  → Step 2: 若 endWord 不在字典 → Return 0 // 無法達成  \n    No  → Step 0: Return 0 // 若無法將 endWord 加入字典，直接終止  \n\nStep 2: Queue ← [(beginWord, 1)] // 將起始字與層數 1 入列  \n→ Decision: Queue 是否為空？ // 檢查是否已遍歷完所有可能  \n    No  → Step 3: 取出 (current, level) = Queue.pop() // 取出隊首元素  \n    Yes → End // 若空則結束，回傳 0  \n\nStep 3: Decision: 是否已訪問 current？ // 避免重複處理  \n    No  → Step 4: 記錄 current 為已訪問 // 標記訪問  \n    Yes → Step 3: 迴圈繼續到下一個元素 // 跳過已訪問項  \n\nStep 4: For i in 0..len(current)-1: // 遍歷每個字母位置  \n    → Step 5: For c in 'a'..'z': // 逐個替換字母  \n        → Decision: 若 c == current[i] 則 No → Step 5: 繼續 // 略過相同字母  \n        → Decision: newWord = current[:i] + c + current[i+1:] // 產生新單字  \n            Yes → Step 6: 若 newWord == endWord → Return level+1 // 找到最短路徑  \n            No  → Decision: newWord 是否在字典且未訪問？  \n                Yes → Step 7: Queue.push((newWord, level+1)) // 將新字加入隊列  \n                No  → Step 6: 迴圈繼續 // 不符合條件  \n\nStep 3: 迴圈回到 Decision: Queue 是否為空？ // 繼續 BFS  \n\nEnd // 程式執行結束，若未找到則已回傳 0\n\n（以上步驟完成從 beginWord 到 endWord 的最短字母變換序列長度搜尋。）"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"\n    Store indices for each number so that picking can be done in O(1) time.\n    \"\"\"\n    def __init__(self, nums):\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        Randomly pick an index where nums[i] == target.\n        \"\"\"\n        # random.choice returns an element from the list with equal probability\n        return random.choice(self.indices[target])\n\n\ndef main():\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Wrap the input string in parentheses so that literal_eval sees a tuple\n    data = ast.literal_eval(f\"({raw_input})\")\n    methods, args_list = data\n\n    # Set a deterministic random seed for reproducible results\n    random.seed(0)\n\n    result = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # args[0] is the array of numbers\n            obj = Solution(args[0])\n            result.append(None)\n        elif method == \"pick\":\n            # args[0] is the target number\n            res = obj.pick(args[0])\n            result.append(res)\n        else:\n            # Unknown method; append None\n            result.append(None)\n\n    # Print the result list in Python literal form (e.g., [null, 4, 0, 2])\n    # Replace Python's None with null for JSON-like output\n    out_str = str(result).replace(\"None\", \"null\")\n    print(out_str)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for this problem, line by line, with explanations. Should not produce real code. Just a high-level algorithm. Use Start, End, Decision, etc. Provide steps for initializing and picking. For pick, we can use reservoir sampling: iterate array, count matches, pick random when match found. Or we can pre-store indices map; but requirement is random, equal probability. Provide algorithm. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收參數 nums 並存於物件屬性 // 讓物件能在之後被多次使用  \n→ Decision: 是否需要預先索引每個數值？ // 以決定後續 pick 的實作方式  \n Yes → Step 2: 建立 map<數值, 清單> // 每個數值對應所有出現位置  \n  → Step 3: 逐個遍歷 nums，將索引加入對應數值的清單 // 完成索引索引表  \n  → Step 4: pick 方法直接從清單中隨機抽取一個索引 // 等概率選取  \n  → End  \n No  → Step 5: 直接採用「漏斗抽樣」(Reservoir Sampling) 於 pick 時處理 // 無需額外空間  \n→ Decision: 在 pick 時採用哪種方法？ // 依預先設定決定  \n Yes → Step 6: 取得目標 target 的索引清單 list ← map[target]  \n  → Step 7: 產生隨機整數 r 於 0..(list.size()-1)  \n  → Step 8: 回傳 list[r] // 隨機選擇該索引  \n  → End  \n No  → Step 9: 初始化 count = 0, result = -1  \n  → Step 10: 從頭到尾掃描 nums  \n    → Decision: 如果 nums[i] == target? // 檢查是否為目標  \n     Yes → Step 11: count++  \n      → Decision: 產生隨機整數 r 於 0..(count-1)  \n       Yes → Step 12: result = i // 以 count 為比例更新結果  \n       No → Step 12  // 不更新，保留現有 result  \n       → End  \n     No → Step 10  // 目標不符，直接繼續迴圈  \n  → Step 13: 回傳 result // 完成等概率選取  \n  → End  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        \"\"\"\n        找出所有可形成回文的字串對 (i, j)。\n        維持 O(total 字元長度) 的時間複雜度。\n        \"\"\"\n        # 把每個字串對應到它的索引，方便 O(1) 取得索引\n        index_map = {word: i for i, word in enumerate(words)}\n\n        # 用於判斷字串是否為回文的輔助函式\n        def is_pal(s: str) -> bool:\n            return s == s[::-1]\n\n        res = []\n\n        # 先處理空字串的特殊情況\n        if \"\" in index_map:\n            empty_idx = index_map[\"\"]\n            for i, w in enumerate(words):\n                if i == empty_idx:\n                    continue\n                if is_pal(w):\n                    # 空字串 + 回文字串\n                    res.append([empty_idx, i])\n                    res.append([i, empty_idx])\n\n        # 逐一檢查每個字串\n        for i, word in enumerate(words):\n            rev_word = word[::-1]\n            # 1. 若整個字串的反轉在字典中且不是自己，直接成對\n            if rev_word in index_map and index_map[rev_word] != i:\n                res.append([i, index_map[rev_word]])\n\n            # 2. 檢查所有可能的分割點\n            L = len(word)\n            for cut in range(1, L):  # cut 不為 0 也不為 L，以避免重複\n                prefix = word[:cut]\n                suffix = word[cut:]\n\n                # 若 prefix 是回文，且 suffix 的反轉存在，則 (suffix_rev, i) 成對\n                if is_pal(prefix):\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in index_map and index_map[rev_suffix] != i:\n                        res.append([index_map[rev_suffix], i])\n\n                # 若 suffix 是回文，且 prefix 的反轉存在，則 (i, prefix_rev) 成對\n                if is_pal(suffix):\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in index_map and index_map[rev_prefix] != i:\n                        res.append([i, index_map[rev_prefix]])\n\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n\n    # 如果輸入格式為 words = [...], 先移除前綴\n    if \"words\" in raw_input:\n        raw_input = raw_input.split('=', 1)[1].strip()\n\n    # 解析字串為 list\n    try:\n        words_list = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，直接輸出空列表\n        words_list = []\n\n    solution = Solution()\n    result = solution.palindromePairs(words_list)\n\n    # 以 Python 內建格式輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code with line-by-line explanations, not actual code. Should outline algorithm O(total length). This is typical solution: build hashmap of reversed words. For each word, check prefixes and suffixes. Steps: store index for each word reversed. For each word, for each split pos from 0..len, check prefix is palindrome and reversed suffix exists, etc. Also handle full reversed words. Also handle empty string.\n\nSo produce pseudo-code with steps, using arrows. Provide explanation per line. Need to avoid actual code. Use Start, End, Decision, etc. Let's craft lines.\n\nWe need to output virtual code. Let's enumerate steps. Use indentation for decisions. Provide explanation after //. No actual syntax. Let's produce maybe 30-40 lines.\n\nMake sure each line includes virtual code step and comment.\n\nWe need to include loops, etc. Use arrow \"→\" for next step. Use Decision for condition. Also for loops maybe use \"Loop\" or \"For each\". Should include explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立哈希表 reverseMap 以存放每個字串反轉後的索引 // 方便快速查找對應字串  \n→ Loop over words 以 i 為索引  \n    → Step 2: reverseWord ← 反轉 words[i] // 需要比較正向與反向  \n    → Decision: reverseWord 是否已存在於 reverseMap? // 判斷是否有完全對應的反轉字串  \n        Yes → Step 3: j ← reverseMap[reverseWord]  \n        → Decision: i ≠ j? // 需要排除自我配對  \n            Yes → Step 4: 添加 (i, j) 至結果 // 完全相反字串組成回文  \n            No → No op // 自己不配對  \n        No → No op // 沒有完全反轉字串  \n\n→ Loop over words 以 i 為索引（第二階段：處理前綴與後綴）  \n    → Step 5: word ← words[i]  \n    → Step 6: length ← words[i].length  \n    → Loop 位置 pos 從 0 到 length  \n        → Step 7: 前綴 = word.substring(0, pos)  \n        → Step 8: 後綴 = word.substring(pos)  \n\n        → Decision: 前綴 是否為回文? // 前綴若為回文，則後綴的反轉可配對成回文  \n            Yes → Step 9: reverseSuffix ← 反轉後綴  \n            → Decision: reverseSuffix 是否存在於 reverseMap?  \n                Yes → Step 10: j ← reverseMap[reverseSuffix]  \n                → Decision: i ≠ j?  \n                    Yes → Step 11: 添加 (i, j) 至結果 // i 的前綴回文 + j 的字串完成回文  \n                    No → No op  \n                No → No op  \n            No → No op  \n\n        → Decision: 後綴 是否為回文? // 後綴若為回文，則前綴的反轉可配對成回文  \n            Yes → Step 12: reversePrefix ← 反轉前綴  \n            → Decision: reversePrefix 是否存在於 reverseMap?  \n                Yes → Step 13: j ← reverseMap[reversePrefix]  \n                → Decision: i ≠ j?  \n                    Yes → Step 14: 添加 (j, i) 至結果 // j 的字串 + i 的後綴回文  \n                    No → No op  \n                No → No op  \n            No → No op  \n\n→ Decision: words 是否包含空字串? // 空字串與任何回文字串皆可配對  \n    Yes → Step 15: 空索引 ← reverseMap[\"\"]  \n    → Loop over words 以 k 為索引  \n        → Decision: words[k] 是否為回文?  \n            Yes → Step 16: 添加 (空索引, k) 至結果  \n            No → No op  \n        → Decision: words[k] 是否為回文?  \n            Yes → Step 17: 添加 (k, 空索引) 至結果  \n            No → No op  \n    No → No op  \n\nEnd // 程式執行結束，返回結果陣列"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef find_lus_length(strs):\n    \"\"\"Return length of the longest uncommon subsequence among strs.\"\"\"\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n\n    max_len = -1\n    for s in strs:\n        if freq[s] == 1 and len(s) > max_len:\n            max_len = len(s)\n    return max_len\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        strs = ast.literal_eval(data)\n    except Exception:\n        # Fallback: treat each non‑empty line as a string\n        strs = [line.strip() for line in data.splitlines() if line.strip()]\n    result = find_lus_length(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, step by step. The problem: longest uncommon subsequence (LUS) in array of strings. Known solution: if there is any string that is unique (not equal to any other string), then answer is its length. If all strings equal, return -1. Because LUS is any string that is subsequence of one string but not others; if a string is unique, itself is subsequence of itself and not of others. So longest unique string length.\n\nThus algorithm: compute frequency of each string. For each string, if its count == 1, consider its length, keep max. If max found, return it else -1.\n\nWe need virtual code lines with arrow and explanation. Should use Decision: and Yes → / No → etc.\n\nAlso handle input: array of strings strs.\n\nSo virtual code:\n\nStart\n→ Step 1: Create empty map freq // 用來計數每個字串出現次數\n→ Step 2: For each string s in strs: freq[s] += 1 // 逐一統計\n→ Step 3: Initialize maxLen = -1 // 初始答案為 -1\n→ Decision: 是否存在唯一字串? // 檢查是否有任何字串只出現一次\n    Yes → Step 4: For each string s in strs:\n        → Decision: freq[s] == 1 ?\n            Yes → Step 5: If length(s) > maxLen, maxLen = length(s) // 更新最大長度\n            No  → Step 6: 跳過 // 不是唯一字串\n    No  → Step 7: maxLen remains -1 // 沒有唯一字串，答案已定\n→ End // 輸出 maxLen\n\nBut we should also incorporate the decision after counting: check any freq == 1.\n\nSimplify: iterate and track maxLen during same loop, no need separate decision.\n\nBetter to produce code:\n\nStart\n→ Step 1: freq ← empty map // 存儲每個字串的出現頻率\n→ Step 2: For each s in strs: freq[s] += 1 // 計數\n→ Step 3: maxLen ← -1 // 初始答案\n→ Step 4: For each s in strs:\n    → Decision: freq[s] == 1 ?\n        Yes → Step 5: If length(s) > maxLen, maxLen ← length(s) // 取最大長度\n        No  → Step 6: 跳過\n→ End // 回傳 maxLen\n\nThis covers logic.\n\nAdd explanation after each line.\n\nLet's output accordingly. Use arrow format. Ensure we maintain correct indent for nested decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: freq ← empty map // 建立空字典來統計每個字串出現次數  \n→ Step 2: For each s in strs: freq[s] += 1 // 逐一遍歷 strs，累加每個字串的計數  \n→ Step 3: maxLen ← -1 // 初始答案設定為 -1，代表尚未找到不通用子序列  \n→ Step 4: For each s in strs:  \n  Decision: freq[s] == 1? // 檢查字串 s 是否唯一（只出現一次）  \n   Yes → Step 5: If length(s) > maxLen, maxLen ← length(s) // 若唯一且長度更長，更新最大長度  \n   No  → Step 6: 跳過 // 若非唯一字串，直接跳過  \nEnd // 程式結束，輸出 maxLen（若仍為 -1 表示不存在不通用子序列）"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of the list nums using backtracking.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # If the starting index reaches the length of nums,\n            # we have a complete permutation to add.\n            if start == len(nums):\n                res.append(nums[:])          # store a copy of the current permutation\n                return\n            # Try each number in the remaining positions\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # swap to place nums[i] at position start\n                backtrack(start + 1)                          # recurse for the next position\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack: undo the swap\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list literal after 'nums ='\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n\n    # Safely evaluate the list literal\n    nums = ast.literal_eval(list_part.strip())\n\n    # Compute all permutations\n    solution = Solution()\n    result = solution.permute(nums)\n\n    # Print the result to stdout\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode lines for generating all permutations of array nums of distinct integers. Virtual code with arrows and decisions. Provide explanation for each line. Use Start, End. Need to include recursion/backtracking. Each line: \"虛擬碼步驟 // 解釋\". Use indentation? Example uses spaces indent. We'll produce lines accordingly. Ensure no actual code, just steps. Provide steps: Start, initialize result array, define backtrack function that takes path and used set. If path length equals nums length, add copy of path to result. Else loop through nums: if not used, add to path, mark used, backtrack, unmark, pop. After defining, call backtrack([], set()). Return result. End. Let's produce. Ensure each line uses \"→\" to show next step. Use \"Decision:\" lines where needed. Also note \"Start\" and \"End\". We'll produce as per example.\n\nLet's write: \nStart // 程式開始\n→ Step 1: 設定 result 為空集合 // 儲存所有排列\n→ Step 2: 定義函式 Backtrack(path, used) // 以回溯方式建立排列\n    → Decision: path 長度等於 nums 長度? // 判斷是否已完成一個排列\n        Yes → Step 3: 把 path 的複製加入 result // 完整排列加入結果\n        No  → Step 4: For 每個 數字 num 於 nums\n            → Decision: num 已在 used? // 判斷是否已使用\n                Yes → Step 5: 跳過 // 這個數字已在當前路徑\n                No  → Step 6: 加入 num 至 path // 選擇這個數字\n                → Step 7: 將 num 加入 used // 標記為已使用\n                → Step 8: 呼叫 Backtrack(path, used) // 進一步搜尋\n                → Step 9: 從 used 移除 num // 取消標記\n                → Step 10: 從 path 移除最後一個元素 // 回溯到上一層\n→ Step 11: 呼叫 Backtrack([], 空集合) // 開始回溯\n→ Step 12: 回傳 result // 輸出所有排列\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟\" followed by space then comment. For indented lines, keep indentation? The example shows indentation with spaces before Decision. We'll mimic. Use \"→\" before each step. For lines inside decisions, indent. Use consistent indentation.\n\nMake sure each line starts with \"→\" except Start and End? In example, Start and End no arrow. Step lines start with \"→\". Decision lines start with \"Decision:\" but preceded by \"→\". So we should follow that.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 result 為空集合 // 用來儲存所有排列  \n→ Step 2: 定義函式 Backtrack(path, used) // 以回溯方式建立排列  \n  → Decision: path 長度等於 nums 長度? // 判斷是否已完成一個排列  \n   Yes → Step 3: 把 path 的複製加入 result // 完整排列加入結果  \n   No  → Step 4: For 每個 數字 num 於 nums // 逐一嘗試每個數字  \n     → Decision: num 已在 used? // 判斷該數字是否已被使用  \n      Yes → Step 5: 跳過 // 已使用的數字不再加入  \n      No  → Step 6: 加入 num 至 path // 選擇此數字  \n       → Step 7: 將 num 加入 used // 標記為已使用  \n       → Step 8: 呼叫 Backtrack(path, used) // 進一步搜尋  \n       → Step 9: 從 used 移除 num // 取消標記  \n       → Step 10: 從 path 移除最後一個元素 // 回溯到上一層  \n→ Step 11: 呼叫 Backtrack([], 空集合) // 開始回溯  \n→ Step 12: 回傳 result // 輸出所有排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Remove to Make Valid Parentheses",
      "source_file": "Leetcode/leetcode1249.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"lee(t(c)o)de)\"",
          "expected_output": "\"lee(t(c)o)de\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'lee(t(c)o)de'\nGot (Norm):      'leetc)o)de'\n--- (Raw) ---\nRaw Expected: '\"lee(t(c)o)de\"'\nRaw Got:      'leetc)o)de'"
        },
        {
          "example_index": 1,
          "input": "s = \"a)b(c)d\"",
          "expected_output": "\"ab(c)d\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'ab(c)d'\nGot (Norm):      'abc)d'\n--- (Raw) ---\nRaw Expected: '\"ab(c)d\"'\nRaw Got:      'abc)d'"
        },
        {
          "example_index": 2,
          "input": "s = \"))((\"",
          "expected_output": "\"\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): ''\nGot (Norm):      '(('\n--- (Raw) ---\nRaw Expected: '\"\"'\nRaw Got:      '(('"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \"\"\"\n        Remove the minimum number of parentheses to make the string valid.\n        Uses two passes:\n        1. Left-to-right to remove unmatched ')'.\n        2. Right-to-left to remove unmatched '('.\n        \"\"\"\n        n = len(s)\n        remove = [False] * n          # 標記哪些位置需要被刪除\n        open_cnt = 0                  # 未配對 '(' 的數量\n\n        # 第一遍：處理多餘的 ')'\n        for i, ch in enumerate(s):\n            if ch == '(':\n                open_cnt += 1\n            elif ch == ')':\n                if open_cnt == 0:\n                    remove[i] = True          # 無對應 '('，標記刪除\n                else:\n                    open_cnt -= 1              # 成功配對\n\n        # 第二遍：處理多餘的 '('\n        unmatched_left = open_cnt           # 仍未配對的 '(' 數量\n        for i in range(n - 1, -1, -1):\n            ch = s[i]\n            if ch == '(':\n                if unmatched_left == 0:\n                    remove[i] = True          # 無對應 ')'，標記刪除\n                else:\n                    unmatched_left -= 1        # 成功配對\n\n        # 組建最終結果\n        result = []\n        for i, ch in enumerate(s):\n            if not remove[i]:\n                result.append(ch)\n        return ''.join(result)\n\ndef parse_input(line: str) -> str:\n    \"\"\"\n    解析輸入。允許兩種格式：\n    1. 直接給出字符串，例如: lee(t(c)o)de)\n    2. 帶有前綴的形式: s = \"lee(t(c)o)de)\"\n    只返回字符串內容，不包含引號。\n    \"\"\"\n    line = line.strip()\n    first_quote = line.find('\"')\n    if first_quote != -1:\n        second_quote = line.find('\"', first_quote + 1)\n        if second_quote != -1:\n            return line[first_quote + 1:second_quote]\n    # 若找不到引號，直接返回整行\n    return line\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n    s = parse_input(data)\n    solution = Solution()\n    result = solution.minRemoveToMakeValid(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve: remove minimum parentheses to make valid string. Typical approach: two passes to find unmatched closing and opening, then build result. Or stack. We'll produce pseudo-code lines with arrow.\n\nUse Start, End. Steps:\n\n1. Count unmatched ')'.\n2. Mark removals for unmatched ')'.\n3. Count unmatched '(' from right.\n4. Mark removals for unmatched '('.\n5. Build result string excluding marked removals.\n\nWe need to maintain indices. Let's produce lines.\n\nWe need to show decisions. We'll include Decision: if char is ')', etc. Also for scanning left-to-right and right-to-left.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize an array remove of length s.length to false // 用來標記需要刪除的位置\n→ Step 2: Initialize counter open = 0 // 用於統計當前開括號數\n→ Decision: 遍歷 s 從左到右? // 第一次掃描\n    → For i in 0 to s.length-1:\n        → Decision: s[i] == '('? // 如果是左括號\n            Yes → open += 1 // 開括號數加一\n            No → Decision: s[i] == ')'?\n                Yes → Decision: open == 0? // 若沒有對應開括號\n                    Yes → remove[i] = true // 標記此閉括號刪除\n                    No → open -= 1 // 匹配成功，減少開括號數\n                No → // 不是括號，忽略\n→ Step 3: Initialize counter unmatched = open // 右側還剩下的未匹配左括號\n→ Decision: 遍歷 s 從右到左? // 第二次掃描\n    → For i in s.length-1 down to 0:\n        → Decision: s[i] == ')'?\n            Yes → // 右括號不影響左括號數\n            No → Decision: s[i] == '('?\n                Yes → Decision: unmatched == 0? // 若沒有未匹配右括號\n                    Yes → remove[i] = true // 標記此左括號刪除\n                    No → unmatched -= 1 // 匹配成功，減少未匹配左括號數\n                No → // 不是括號，忽略\n→ Step 4: Initialize result = \"\" // 存放最終字串\n→ Decision: 遍歷 s 的每個字符 i? // 組建結果\n    → For i in 0 to s.length-1:\n        → Decision: remove[i] == true?\n            Yes → // 跳過此字符\n            No → result += s[i] // 保留字符\n→ End // 返回 result\n\nNeed to ensure we include explanations. Provide each line with comment after //.\n\nMake sure each line is \"虛擬碼步驟 // 解釋\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize remove[0..s.length-1] = false // 建立布林陣列標記要刪除的位置\n→ Step 2: Initialize open = 0 // 記錄目前未配對的 '(' 數量\n→ Decision: 從左到右掃描 s? // 第一遍掃描，處理多餘的 ')'\n    → For i = 0 to s.length-1:\n        → Decision: s[i] == '('? // 遇到 '('\n            Yes → open += 1 // 將未配對左括號計數加一\n            No → Decision: s[i] == ')'?\n                Yes → Decision: open == 0? // 若沒有對應的 '('\n                    Yes → remove[i] = true // 標記此 ')' 刪除\n                    No → open -= 1 // 成功配對，減少未配對左括號數\n                No → // 不是括號，保持原樣\n→ Step 3: Initialize unmatched = open // 右側仍有未匹配的 '(' 數量\n→ Decision: 從右到左掃描 s? // 第二遍掃描，處理多餘的 '('\n    → For i = s.length-1 down to 0:\n        → Decision: s[i] == ')'?\n            Yes → // ')' 不影響未匹配左括號\n            No → Decision: s[i] == '('?\n                Yes → Decision: unmatched == 0? // 若沒有對應的 ')'\n                    Yes → remove[i] = true // 標記此 '(' 刪除\n                    No → unmatched -= 1 // 成功配對，減少未匹配左括號數\n                No → // 不是括號，保持原樣\n→ Step 4: Initialize result = \"\" // 用於累積最終字串\n→ Decision: 遍歷 s 的每個索引 i? // 組建結果字串\n    → For i = 0 to s.length-1:\n        → Decision: remove[i] == true?\n            Yes → // 跳過此字符，視為已刪除\n            No → result += s[i] // 將字符加入結果\nEnd // 程式執行結束，返回 result\n\nThis 虛擬碼以兩次掃描確保刪除最少括號，並保持字串中小寫字母不變。"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[None,True,False,True,1,True,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[None, True, False, True, 1, True, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport collections\nimport random\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []  # 存儲所有元素\n        self.idx_map = collections.defaultdict(set)  # val -> set of indices\n\n    def insert(self, val: int) -> bool:\n        \"\"\"將值插入多重集合，返回是否為首次插入。\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"從多重集合中移除一個 val，返回是否成功。\"\"\"\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 覆蓋並更新索引\n        self.data[remove_idx] = last_val\n        if remove_idx != last_idx:\n            self.idx_map[last_val].remove(last_idx)\n            self.idx_map[last_val].add(remove_idx)\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素。\"\"\"\n        return random.choice(self.data)\n\ndef main():\n    # 讀取整個輸入，並解析為兩個列表\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將輸入包裝成元組，以便 literal_eval 解析\n    wrapped = f\"({raw})\"\n    ops, args = ast.literal_eval(wrapped)\n\n    # 執行操作\n    results = []\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            # 建構子，結果為 None（或 null）\n            obj = RandomizedCollection()\n            results.append(None)\n        else:\n            # 取得對應的方法並執行\n            method = getattr(obj, op)\n            if isinstance(arg, list):\n                # 多參數情況（如本題只用一個）\n                res = method(*arg)\n            else:\n                res = method(arg)\n            results.append(res)\n\n    # 輸出結果，將 None 轉換為 None（Python 的表示）\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines for implementation of RandomizedCollection class with methods. Use Start, End, Decision. Provide explanation comment. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. So produce step-by-step pseudo. For methods. Should show initialization: array list, dict of val->set of indices. Insert: add to list, add index to map, return whether first insertion. Remove: if val not in map return false; get index from map set; remove from list via swap with last element; update map for swapped element; remove index from val set; if set empty remove key. getRandom: pick random index in array. Provide steps.\n\nLet's write sequential pseudo code in lines. Use Start/End for class? Probably Start of class definition. We'll do:\n\nStart // 定義 RandomizedCollection 類\n→ Step 1: 定義 list = [] // 存儲所有元素\n→ Step 2: 定義 map = {} // val -> set(indices)\n→ Step 3: 定義 constructor // 初始化\n    → Step 3.1: list = []\n    → Step 3.2: map = {}\nEnd // 結束建構\n\nThen insert:\n\nStart // 插入 val\n→ Step 1: index = list.size // 新元素的索引\n→ Step 2: list.append(val) // 加入列表\n→ Step 3: if val in map:\n    → Step 3.1: map[val].add(index)\n    → Step 3.2: return False // 已存在\n   Else:\n    → Step 3.3: map[val] = {index}\n    → Step 3.4: return True // 第一次插入\nEnd\n\nRemove:\n\nStart // 移除 val\n→ Decision: 如果 val not in map? // 判斷是否存在\n    No → Step 1: return False\n    Yes → Step 1: idx_to_remove = any element from map[val]\n    → Step 2: last_idx = list.size - 1\n    → Step 3: last_val = list[last_idx]\n    → Step 4: list[idx_to_remove] = last_val // 覆蓋\n    → Step 5: list.pop() // 移除最後一個\n    → Step 6: map[val].remove(idx_to_remove) // 更新自身索引\n    → Decision: 如果 map[val] empty? // 判斷是否需要刪除鍵\n        Yes → Step 6.1: delete map[val]\n    → Step 7: if idx_to_remove != last_idx:\n        → Step 7.1: map[last_val].remove(last_idx) // 移除舊索引\n        → Step 7.2: map[last_val].add(idx_to_remove) // 加入新索引\n    → Step 8: return True\nEnd\n\ngetRandom:\n\nStart // 取得隨機元素\n→ Step 1: rand_idx = random_int(0, list.size-1) // 隨機索引\n→ Step 2: return list[rand_idx]\nEnd\n\nWrap with class Start/End maybe.\n\nLet's produce lines with arrows and comments. Ensure each line has comment after //. Provide clear explanation. Use \"Step\" numbers. Provide decision arrows with Yes/No lines.\n\nLet's output.\n...done thinking.\n\nStart // 開始定義 RandomizedCollection 類\n→ Step 1: list ← [] // 用於儲存所有元素，支持隨機訪問\n→ Step 2: map ← {} // 用於儲存 val → 集合(indices)，支持 O(1) 查找與更新\n→ Step 3: Constructor // 初始化構造函數\n    → Step 3.1: list ← [] // 初始化空列表\n    → Step 3.2: map ← {} // 初始化空映射\nEnd // 構造完成\n\nStart // insert(val)：將值加入多重集合\n→ Step 1: index ← list.size // 新元素的索引位置\n→ Step 2: list.append(val) // 把 val 放到末尾\n→ Decision: 如果 val 在 map 中? // 判斷是否已存在\n    Yes → Step 3.1: map[val].add(index) // 加入新索引到集合\n    Yes → Step 3.2: return False // 不是第一次插入，返回 false\n    No  → Step 3.3: map[val] ← {index} // 創建新集合並加入索引\n    No  → Step 3.4: return True // 第一次插入，返回 true\nEnd\n\nStart // remove(val)：從多重集合中刪除一個 val\n→ Decision: 如果 val 不在 map 中? // 判斷是否存在\n    Yes → Step 1: return False // 無法刪除，返回 false\n    No  → Step 2: idx_to_remove ← any(map[val]) // 任意取一個索引\n    No  → Step 3: last_idx ← list.size - 1 // 末尾元素索引\n    No  → Step 4: last_val ← list[last_idx] // 末尾元素值\n    No  → Step 5: list[idx_to_remove] ← last_val // 覆蓋要刪除位置\n    No  → Step 6: list.pop() // 刪除最後一個元素\n    No  → Step 7: map[val].remove(idx_to_remove) // 移除自身索引\n    No  → Decision: 如果 map[val] 為空? // 看看是否需要清除鍵\n        Yes → Step 7.1: delete map[val] // 移除空集合的鍵\n    No  → Decision: 如果 idx_to_remove ≠ last_idx? // 需要更新被覆蓋元素的索引\n        Yes → Step 7.2: map[last_val].remove(last_idx) // 刪除舊索引\n        Yes → Step 7.3: map[last_val].add(idx_to_remove) // 加入新索引\n    No  → Step 8: return True // 成功刪除，返回 true\nEnd\n\nStart // getRandom()：返回一個隨機元素\n→ Step 1: rand_idx ← random_int(0, list.size - 1) // 隨機生成索引\n→ Step 2: return list[rand_idx] // 返回對應值\nEnd // RandomizedCollection 類結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8gd27ohh.py\", line 37, in <module>\n    intervals = eval(intervals_part)\n                ^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv5iy2kvj.py\", line 37, in <module>\n    intervals = eval(intervals_part)\n                ^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        result.append(newInterval)\n\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Normalize input: remove spaces after keywords and split into two parts\n    data = data.replace('intervals =', 'intervals=').replace('newInterval =', 'newInterval=')\n    parts = data.split(',', 1)\n    intervals_part = parts[0].split('=', 1)[1].strip()\n    new_interval_part = parts[1].split('=', 1)[1].strip()\n\n    intervals = eval(intervals_part)\n    newInterval = eval(new_interval_part)\n\n    sol = Solution()\n    result = sol.insert(intervals, newInterval)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for inserting an interval into sorted non-overlapping intervals, merging as needed. Provide step-by-step lines with explanation. Use arrows, Start, End, Decision. Let's craft pseudo algorithm: iterate through intervals, before newInterval.start append non-overlapping before; merge overlapping; after newInterval end, append rest. Provide lines.\n\nWe should avoid actual code, just virtual steps.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 result list // 用於存放合併後的間隔\n→ Step 2: 設置 i = 0 // 計數器，遍歷 intervals\n→ Decision: i < intervals.length? // 是否還有間隔未處理\n    Yes → Step 3: 若 intervals[i].end < newInterval.start // 當前間隔結束在新間隔開始之前\n        → Step 4: 將 intervals[i] 加入 result // 添加不重疊的左側間隔\n        → Step 5: i++ // 移動到下一個間隔\n    No → Step 6: ... Wait we need to consider merging overlapping. Let's restructure.\n\nBetter: Use two phases: add all before newInterval, merge overlapping, add remaining.\n\nSimpler pseudo:\n\n- While i < n and intervals[i].end < new.start: append intervals[i], i++.\n- Determine merged_start = min(new.start, intervals[i].start) if overlap; merged_end = max(new.end, intervals[i].end); while i < n and intervals[i].start <= merged_end: merged_end = max(merged_end, intervals[i].end); i++.\n- Append [merged_start, merged_end] to result.\n- Append remaining intervals[i:] to result.\n\nLet's express step by step.\n\nUse Decision nodes.\n\nWe'll produce lines like:\n\nStart\n→ Step 1: n = intervals.length // 獲取間隔數量\n→ Step 2: i = 0 // 初始化索引\n→ Step 3: result = empty list // 用於儲存最終間隔\n→ Decision: i < n AND intervals[i].end < new.start? // 是否仍有間隔且不重疊於新間隔左側\n    Yes → Step 4: 將 intervals[i] 加入 result // 把左側不重疊的間隔加入\n    → Step 5: i++ // 移動到下一個\n    No → Decision: i < n AND intervals[i].start <= new.end? // 當前間隔是否與新間隔重疊\n        Yes → Step 6: merged_start = min(new.start, intervals[i].start) // 計算合併起點\n        → Step 7: merged_end = max(new.end, intervals[i].end) // 計算合併終點\n        → Step 8: i++ // 移動到下一個\n        → Decision: i < n AND intervals[i].start <= merged_end? // 是否還有重疊\n            Yes → Step 9: merged_end = max(merged_end, intervals[i].end) // 擴大合併終點\n            → Step 10: i++ // 移動\n            No → Step 11: 將 [merged_start, merged_end] 加入 result // 將合併後的間隔加入\n        No → Step 12: // 沒有重疊，直接將新間隔加入\n            → Step 13: 將 [new.start, new.end] 加入 result\n    No → Step 14: // 新間隔已處理完畢，將剩餘間隔直接加入\n        → Step 15: 將 intervals[i:] 加入 result\nEnd\n\nNeed to ensure flow: After finishing adding merged interval, we need to add remaining intervals. Could include a Decision after Step 11 or 13 to add rest.\n\nSimplify: After adding merged interval or new interval, we skip to appending rest: Step 14: 將 intervals[i:] 加入 result.\n\nBut we need to handle scenario where new interval is before all intervals: then i remains 0 and merged part will be new interval only. In that case Step 12/13 add new, then Step 14 add rest.\n\nLet's produce pseudo with clear decisions.\n\nWe'll produce lines accordingly. Ensure each line ends with // explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = intervals.length // 取得原間隔數量  \n→ Step 2: i = 0 // 計數器，指向當前要處理的間隔  \n→ Step 3: result = empty list // 用於儲存插入後的最終間隔  \n\n→ Decision: i < n AND intervals[i].end < newInterval.start? // 是否還有間隔且在新間隔左側不重疊  \n    Yes → Step 4: 將 intervals[i] 加入 result // 加入左側不重疊的間隔  \n    → Step 5: i++ // 移動到下一個  \n    No → Decision: i < n AND intervals[i].start <= newInterval.end? // 當前間隔是否與新間隔重疊  \n        Yes → Step 6: merged_start = min(newInterval.start, intervals[i].start) // 計算合併起點  \n        → Step 7: merged_end = max(newInterval.end, intervals[i].end) // 計算合併終點  \n        → Step 8: i++ // 移動到下一個  \n        → Decision: i < n AND intervals[i].start <= merged_end? // 是否還有重疊間隔  \n            Yes → Step 9: merged_end = max(merged_end, intervals[i].end) // 擴大合併終點  \n            → Step 10: i++ // 移動到下一個  \n            No → Step 11: 將 [merged_start, merged_end] 加入 result // 將合併後的間隔加入  \n        No → Step 12: // 沒有重疊，直接加入新間隔  \n            → Step 13: 將 [newInterval.start, newInterval.end] 加入 result // 加入新間隔  \n\n→ Decision: i < n? // 是否還有剩餘間隔需要加入  \n    Yes → Step 14: 將 intervals[i:] 加入 result // 把剩餘的間隔直接追加  \n    No  → Step 15: // 無剩餘間隔，直接跳至結束  \n\nEnd // 程式執行結束，返回 result  \n\n---  \n以上虛擬碼按行展示了插入並合併間隔的完整流程，並在每行後給出了直觀說明。"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1fwnpimz.py\", line 128, in <module>\n    solve()\n  File \"/tmp/tmp1fwnpimz.py\", line 98, in solve\n    val = token.split('=', 1)[1]\n          ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6agvv_b3.py\", line 128, in <module>\n    solve()\n  File \"/tmp/tmp6agvv_b3.py\", line 98, in solve\n    val = token.split('=', 1)[1]\n          ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp03ko9_a6.py\", line 128, in <module>\n    solve()\n  File \"/tmp/tmp03ko9_a6.py\", line 98, in solve\n    val = token.split('=', 1)[1]\n          ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\n# 顏色映射\nCOLORS = ['R', 'Y', 'B', 'G', 'W']\nCOLOR_IDX = {c: i for i, c in enumerate(COLORS)}\n\n# ---------- 文字串清理 ----------\ndef clean_board(s: str) -> str:\n    \"\"\"\n    移除連續三個以上相同顏色的球，並處理連鎖反應。\n    \"\"\"\n    stack = []          # (顏色, 數量)\n    i = 0\n    while i < len(s):\n        j = i\n        while j < len(s) and s[j] == s[i]:\n            j += 1\n        cnt = j - i\n        if stack and stack[-1][0] == s[i]:\n            stack[-1] = (s[i], stack[-1][1] + cnt)\n        else:\n            stack.append((s[i], cnt))\n        # 若上層元素已達三個以上，直接消除\n        if stack and stack[-1][1] >= 3:\n            stack.pop()\n        i = j\n    return ''.join(ch * num for ch, num in stack)\n\n# ---------- DFS 搜索 ----------\nINF = 10 ** 9\nmemo = {}\n\ndef dfs(board: str, hand_counts: list) -> int:\n    \"\"\"\n    回傳從目前 board 與手牌組合下，清空棋盤所需最少插球數。\n    若無法完成，返回 INF。\n    \"\"\"\n    key = (board, tuple(hand_counts))\n    if key in memo:\n        return memo[key]\n    if not board:\n        return 0\n    if sum(hand_counts) == 0:\n        return INF\n\n    n = len(board)\n    best = INF\n    # 遍歷每個插入位置\n    for pos in range(n + 1):\n        # 對於每種可用顏色\n        for idx, color in enumerate(COLORS):\n            if hand_counts[idx] == 0:\n                continue\n\n            # 計算在 pos 位置左側和右側連續的同色球數\n            left_cnt = 0\n            i = pos - 1\n            while i >= 0 and board[i] == color:\n                left_cnt += 1\n                i -= 1\n            right_cnt = 0\n            i = pos\n            while i < n and board[i] == color:\n                right_cnt += 1\n                i += 1\n            total = left_cnt + right_cnt\n\n            # 嘗試插入 1~3 顆球（依手牌數量）\n            for need in range(1, 4):\n                if hand_counts[idx] < need:\n                    break\n                if total + need < 3:\n                    continue  # 無法立即產生三個以上\n                # 建立新的棋盤\n                new_board = board[:pos] + color * need + board[pos:]\n                cleaned = clean_board(new_board)\n                new_hand = hand_counts.copy()\n                new_hand[idx] -= need\n                sub = dfs(cleaned, new_hand)\n                if sub != INF:\n                    best = min(best, need + sub)\n\n    memo[key] = best\n    return best\n\n# ---------- 主要執行區 ----------\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，允許「board = \"WRRBBW\", hand = \"RB\"」或兩行簡單輸入\n    board = ''\n    hand = ''\n    # 嘗試尋找 board、hand 的關鍵字\n    for token in data.replace('\\n', ' ').split():\n        if token.startswith('board'):\n            val = token.split('=', 1)[1]\n            val = val.strip().strip('\\'\"').strip(',')\n            board = val\n        elif token.startswith('hand'):\n            val = token.split('=', 1)[1]\n            val = val.strip().strip('\\'\"').strip(',')\n            hand = val\n    # 若未解析成功，直接取第一兩個非空 token\n    if not board or not hand:\n        parts = [p.strip('\\'\"') for p in data.replace('\\n', ' ').split() if p.strip('\\'\"')]\n        if len(parts) >= 2:\n            board, hand = parts[0], parts[1]\n        elif len(parts) == 1:\n            board = parts[0]\n            hand = ''\n    # 若手牌仍為空，直接判定是否已經空\n    if not hand:\n        print(0 if not board else -1)\n        return\n\n    # 生成手牌計數\n    hand_counts = [0] * 5\n    for c in hand:\n        if c in COLOR_IDX:\n            hand_counts[COLOR_IDX[c]] += 1\n\n    res = dfs(board, hand_counts)\n    print(-1 if res == INF else res)\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: Zuma game with hand and board. Need minimal insertions. This is typical DFS with backtracking and memoization. We need to provide pseudo code step by step with explanations. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Provide algorithm overview, function definitions, recursive search, pruning, etc. Let's create steps: Start, read input, define DFS function, define helper to remove groups, base cases, loop over hand colors, count usage, etc. Use memoization map key as (board, hand_counts). Provide result. End.\n\nWe must not output real code, just pseudo steps. Use arrows. Ensure each line has explanation. Ok. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 board 與 hand // 取得棋盤與手牌的初始字串  \n→ Step 2: 將 hand 轉為顏色頻率表 handCnt[color] // 方便計算剩餘可用球數  \n\n→ Step 3: 定義函式 RemoveGroups(board) → string // 處理連續三個以上相同顏色的消除  \n    → Decision: 盤面是否存在至少一組相同顏色連續球?  \n        Yes → Step 4: 找到所有連續相同顏色區塊，若長度 ≥ 3 則將其移除，並連續呼叫自己直到無法移除  \n        No  → Step 5: 回傳目前 board // 已無可消除區塊  \nEnd  \n\n→ Step 6: 定義遞迴函式 DFS(currentBoard, handCnt) → int // 回傳最小插入數或 -1  \n    → Decision: currentBoard 為空?  \n        Yes → Step 7: 回傳 0 // 已全部清空  \n        No  → Step 8: 若 handCnt 全為 0?  \n            Yes → Step 9: 回傳 -1 // 手牌耗盡仍有球  \n            No  → Step 10: 建立 memoKey = (currentBoard, handCnt)  \n                → Decision: memoKey 已存在?  \n                    Yes → Step 11: 回傳 memoValue // 直接取之前結果  \n                    No  → Step 12: 設定 minInsert = ∞  \n\n    → Step 13: 對於每種顏色 color 在 handCnt 中  \n        → Decision: handCnt[color] > 0?  \n            Yes →  \n                → Decision: 找到所有可插入位置 pos 於 currentBoard（兩球之間或兩端）  \n                    → Decision: 在 pos 前後已連續 color 球的數量 cnt?  \n                        Yes → 需要插入 count = 3 - cnt 球才能形成消除組  \n                            → Decision: handCnt[color] ≥ count?  \n                                Yes →  \n                                    → Step 14: 創建 newBoard = currentBoard  \n                                        → Step 15: 在 pos 插入 count 個 color 球  \n                                    → Step 16: newBoard = RemoveGroups(newBoard) // 連鎖消除  \n                                    → Step 17: 新 handCnt2 = handCnt，減去 count 個 color  \n                                    → Step 18: subAns = DFS(newBoard, handCnt2)  \n                                    → Decision: subAns ≠ -1?  \n                                        Yes → minInsert = min(minInsert, 1 + subAns) // 插入一球後遞迴  \n                                No → Skip  \n                        No → Skip // 無法形成組，不能插入此位置  \n            No → Skip  \n\n    → Step 19: memoKey = (currentBoard, handCnt)， memoValue = (minInsert == ∞ ? -1 : minInsert)  \n    → Step 20: 回傳 memoValue // 返回計算結果  \n\n→ Step 21: result = DFS(board, handCnt) // 從初始盤面開始遞迴  \n→ Step 22: 輸出 result // 顯示最小插入數或 -1  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\n\nclass RangeModule:\n    def __init__(self):\n        # Store non‑overlapping half‑open intervals [l, r)\n        self.ranges = []\n\n    def addRange(self, left, right):\n        new_ranges = []\n        i = 0\n        # Keep intervals that end before the new interval\n        while i < len(self.ranges) and self.ranges[i][1] < left:\n            new_ranges.append(self.ranges[i])\n            i += 1\n        # Merge all overlapping intervals\n        new_start, new_end = left, right\n        while i < len(self.ranges) and self.ranges[i][0] <= right:\n            new_start = min(new_start, self.ranges[i][0])\n            new_end = max(new_end, self.ranges[i][1])\n            i += 1\n        new_ranges.append([new_start, new_end])\n        # Append the rest of the intervals\n        new_ranges.extend(self.ranges[i:])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        # Find interval that could cover 'left'\n        i = 0\n        while i < len(self.ranges) and self.ranges[i][1] <= left:\n            i += 1\n        if i < len(self.ranges) and self.ranges[i][0] <= left and self.ranges[i][1] >= right:\n            return True\n        return False\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                # No overlap\n                new_ranges.append([l, r])\n            else:\n                # Left part remains\n                if l < left:\n                    new_ranges.append([l, left])\n                # Right part remains\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    lines = data.strip().splitlines()\n    objects = {}\n    results = []\n\n    for line in lines:\n        line = line.strip()\n        if not line:\n            continue\n        # Remove trailing semicolon\n        if line.endswith(';'):\n            line = line[:-1].strip()\n        # Object creation\n        if line.startswith('RangeModule '):\n            # Example: RangeModule rangeModule = new RangeModule();\n            parts = line.split('=', 1)\n            var_name = parts[0].split()[1].strip()\n            objects[var_name] = RangeModule()\n            results.append(None)\n            continue\n        # Method call\n        if '.' in line:\n            obj_part, method_part = line.split('.', 1)\n            obj_name = obj_part.strip()\n            if obj_name not in objects:\n                continue  # unknown object, skip\n            method_name, rest = method_part.split('(', 1)\n            args_str = rest.rstrip(')')\n            args = []\n            if args_str:\n                args = [int(x.strip()) for x in args_str.split(',')]\n            func = getattr(objects[obj_name], method_name)\n            ret = func(*args)\n            if method_name == 'queryRange':\n                results.append(ret)\n            else:\n                results.append(None)\n\n    # Format output like [null, null, true, false]\n    out = []\n    for r in results:\n        if r is None:\n            out.append('null')\n        elif isinstance(r, bool):\n            out.append('true' if r else 'false')\n        else:\n            out.append(str(r))\n    print('[' + ', '.join(out) + ']')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for the design of RangeModule. We need to do it line by line, with virtual code and comments. Use arrows etc. The structure: Start, then maybe initialization, addRange, queryRange, removeRange. Use decision statements. Should design using something like a sorted list of non-overlapping intervals. We'll produce pseudocode showing operations.\n\nWe should describe steps: start, initialize empty interval list. For addRange: find position to insert, merge overlaps. For queryRange: check that the query interval is fully covered by intervals. For removeRange: remove parts of intervals overlapping, adjust boundaries. Provide each line with explanation. Use arrows.\n\nLet's produce something like:\n\nStart\n→ Step: Initialize intervals as empty list // start of program\n→ Step: Define RangeModule() // constructor\n    → Step: intervals = [] // empty list of [l, r)\n→ Step: addRange(left, right)\n    → Step: i = 0 // index\n    → Decision: while i < len(intervals) and intervals[i].end <= left // skip intervals ending before left\n        → i++\n    → Step: new_start = left\n    → Step: new_end = right\n    → Decision: while i < len(intervals) and intervals[i].start <= right // overlapping\n        → new_start = min(new_start, intervals[i].start)\n        → new_end = max(new_end, intervals[i].end)\n        → remove intervals[i]\n    → Step: insert [new_start, new_end] at position i // maintain sorted\n→ Step: queryRange(left, right)\n    → Step: i = 0\n    → Decision: while i < len(intervals) and intervals[i].end <= left\n        → i++\n    → Decision: if i < len(intervals) and intervals[i].start <= left and intervals[i].end >= right\n        → return True\n    → Return False\n→ Step: removeRange(left, right)\n    → Step: i = 0\n    → Decision: while i < len(intervals) and intervals[i].end <= left\n        → i++\n    → Decision: while i < len(intervals) and intervals[i].start < right\n        → if intervals[i].start < left\n            → intervals[i].end = left // shrink end\n            → i++\n        → elif intervals[i].end > right\n            → new_interval = [right, intervals[i].end]\n            → intervals[i].end = left\n            → insert new_interval after i\n            → i += 2\n        → else // fully inside to remove\n            → remove intervals[i]\n    → End\n\nWe need to produce each step line by line. Use \"Start //\". Provide comment after //.\n\nLet's produce pseudocode with arrow lines. Use \"→\" for steps. For decisions, indent inside.\n\nWe must avoid actual code, only pseudo.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step: RangeModule ← 新建物件 // 建構 RangeModule\n    → Step: intervals ← 空清單 // 儲存不重疊區間\n→ Step: addRange(left, right)\n    → Step: i ← 0 // 位置指標\n    → Decision: while i < intervals.size() and intervals[i].end <= left\n        → i ← i + 1\n    → Step: newL ← left\n    → Step: newR ← right\n    → Decision: while i < intervals.size() and intervals[i].start <= right\n        → newL ← min(newL, intervals[i].start)\n        → newR ← max(newR, intervals[i].end)\n        → remove intervals[i]\n    → Step: insert [newL, newR] at index i // 插入並保持排序\n→ Step: queryRange(left, right)\n    → Step: i ← 0\n    → Decision: while i < intervals.size() and intervals[i].end <= left\n        → i ← i + 1\n    → Decision: if i < intervals.size() and intervals[i].start <= left and intervals[i].end >= right\n        → return True // 区间完整覆盖\n    → Return False // 未完全覆盖\n→ Step: removeRange(left, right)\n    → Step: i ← 0\n    → Decision: while i < intervals.size() and intervals[i].end <= left\n        → i ← i + 1\n    → Decision: while i < intervals.size() and intervals[i].start < right\n        → Decision: if intervals[i].start < left\n            → intervals[i].end ← left // 左侧保留\n            → i ← i + 1\n        → Decision: elif intervals[i].end > right\n            → newInterval ← [right, intervals[i].end]\n            → intervals[i].end ← left\n            → insert newInterval after i\n            → i ← i + 2\n        → Decision: else\n            → remove intervals[i]\n    → End // 程式執行結束\n\nWe need to include comments. Let's produce final answer with lines.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: RangeModule ← 新建物件 // 建構 RangeModule 物件\n    → Step: intervals ← 空清單 // 儲存已追蹤的不重疊區間 [l, r)\n→ Step: addRange(left, right) // 新增區間\n    → Step: i ← 0 // 位置指標\n    → Decision: while i < intervals.size() and intervals[i].end <= left\n        → i ← i + 1 // 跳過所有在 left 左側結束的區間\n    → Step: newL ← left\n    → Step: newR ← right\n    → Decision: while i < intervals.size() and intervals[i].start <= right\n        → newL ← min(newL, intervals[i].start) // 合併重疊的左端\n        → newR ← max(newR, intervals[i].end)   // 合併重疊的右端\n        → remove intervals[i]                  // 刪除已合併的區間\n    → Step: insert [newL, newR] at index i // 插入合併後的新區間，保持排序\n→ Step: queryRange(left, right) // 查詢區間是否完全被追蹤\n    → Step: i ← 0\n    → Decision: while i < intervals.size() and intervals[i].end <= left\n        → i ← i + 1 // 跳過所有在 left 左側結束的區間\n    → Decision: if i < intervals.size() and intervals[i].start <= left and intervals[i].end >= right\n        → return True // 区间完全覆盖\n    → Return False // 未完全覆盖\n→ Step: removeRange(left, right) // 移除區間\n    → Step: i ← 0\n    → Decision: while i < intervals.size() and intervals[i].end <= left\n        → i ← i + 1 // 跳過所有在 left 左側結束的區間\n    → Decision: while i < intervals.size() and intervals[i].start < right\n        → Decision: if intervals[i].start < left\n            → intervals[i].end ← left // 保留左侧部分\n            → i ← i + 1\n        → Decision: elif intervals[i].end > right\n            → newInterval ← [right, intervals[i].end] // 右侧剩余部分\n            → intervals[i].end ← left\n            → insert newInterval after i // 插入右侧剩余區間\n            → i ← i + 2\n        → Decision: else\n            → remove intervals[i] // 完全在 [left, right) 內的區間全部移除\n→ End // 程式執行結束\n```"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp351ur0au.py\", line 62, in <module>\n    methods = json.loads(data[0])\n              ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0          # index of the front element\n        self.count = 0         # number of elements currently in the deque\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    methods = json.loads(data[0])\n    args = json.loads(data[1])\n\n    obj = None\n    result = []\n\n    for method_name, method_args in zip(methods, args):\n        if method_name == \"MyCircularDeque\":\n            obj = MyCircularDeque(method_args[0])\n            result.append(None)\n        else:\n            func = getattr(obj, method_name)\n            out = func(*method_args)\n            result.append(out)\n\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step, not actual code. Use arrows, decisions. We need to include all operations: constructor, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Provide logic for circular array. Use size, front, rear indices. Provide explanations. Let's craft virtual code.\n\nStart, Step 1: initialize array of size k, front = 0, rear = 0, count = 0. Use array positions. InsertFront: check if full -> false. else front = (front - 1 + k) % k; array[front] = value; count++; true. InsertLast: similar. DeleteFront: check empty, then front = (front + 1) % k; count--; true. DeleteLast: check empty, rear = (rear - 1 + k) % k; count--; true. getFront: if empty -> -1 else array[front]. getRear: if empty -> -1 else array[(rear - 1 + k) % k]. isEmpty: count==0. isFull: count==k.\n\nLet's structure as virtual code lines.\n\nMake sure to use \"Start\" at top. For each method, start a block.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: MyCircularDeque(k) 初始化陣列 arr[0…k-1] // 產生固定長度的空陣列  \n→ Step 2: front ← 0, rear ← 0, count ← 0 // 追蹤前端、後端指標與元素個數  \n\n→ Step 3: insertFront(value) // 嘗試在前端插入元素  \n    → Decision: 是否已滿? // 判斷是否已達最大容量  \n        Yes → Return false // 無法插入，返回失敗  \n        No  → front ← (front - 1 + k) mod k // 往前移動前端指標，環形處理  \n        → Step 4: arr[front] ← value // 把值放入新前端位置  \n        → Step 5: count ← count + 1 // 元素數量加一  \n        → Return true // 插入成功  \n\n→ Step 6: insertLast(value) // 嘗試在後端插入元素  \n    → Decision: 是否已滿?  \n        Yes → Return false  \n        No  → arr[rear] ← value // 放入現有後端位置  \n        → rear ← (rear + 1) mod k // 後端指標向後移動，環形處理  \n        → count ← count + 1  \n        → Return true  \n\n→ Step 7: deleteFront() // 嘗試刪除前端元素  \n    → Decision: 是否為空? // 判斷是否有元素可刪除  \n        Yes → Return false // 無法刪除，返回失敗  \n        No  → front ← (front + 1) mod k // 前端指標向後移動，環形處理  \n        → count ← count - 1 // 元素數量減一  \n        → Return true // 刪除成功  \n\n→ Step 8: deleteLast() // 嘗試刪除後端元素  \n    → Decision: 是否為空?  \n        Yes → Return false  \n        No  → rear ← (rear - 1 + k) mod k // 後端指標往前移動，環形處理  \n        → count ← count - 1  \n        → Return true  \n\n→ Step 9: getFront() // 取得前端元素  \n    → Decision: 是否為空?  \n        Yes → Return -1 // 空時返回 -1  \n        No  → Return arr[front] // 回傳前端的值  \n\n→ Step 10: getRear() // 取得後端元素  \n    → Decision: 是否為空?  \n        Yes → Return -1  \n        No  → idx ← (rear - 1 + k) mod k // 後端實際位置  \n        → Return arr[idx] // 回傳後端的值  \n\n→ Step 11: isEmpty() // 檢查是否為空  \n    → Return count == 0 // 若元素數量為 0，則為空  \n\n→ Step 12: isFull() // 檢查是否已滿  \n    → Return count == k // 若元素數量等於容量，則已滿  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpop8ltv6i.py\", line 38, in <module>\n    args = ast.literal_eval(arg_match.group(0))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3, [4, 5, 8, 2]\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg594abwo.py\", line 38, in <module>\n    args = ast.literal_eval(arg_match.group(0))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[4, [7, 7, 7, 7, 8, 3]\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport heapq\n\nclass KthLargest:\n    \"\"\"\n    KthLargest 透過最小堆維持 k 大元素。\n    堆大小永遠不超過 k，堆頂即為第 k 大的分數。\n    \"\"\"\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，去除首尾空白\n    raw_input = sys.stdin.read().strip()\n\n    # 找第一個列表（方法名稱）\n    op_match = re.search(r'\\[.*?\\]', raw_input, re.S)\n    if not op_match:\n        sys.exit()\n    ops = ast.literal_eval(op_match.group(0))\n\n    # 找第二個列表（對應的參數）\n    rest = raw_input[op_match.end():]\n    arg_match = re.search(r'\\[.*?\\]', rest, re.S)\n    if not arg_match:\n        sys.exit()\n    args = ast.literal_eval(arg_match.group(0))\n\n    # 逐步執行操作並收集結果\n    result = []\n    obj = None\n    for i, op in enumerate(ops):\n        if op == \"KthLargest\":\n            k_val, nums_val = args[i]\n            obj = KthLargest(k_val, nums_val)\n            result.append(None)  # LeetCode 期望 null，Python 內部用 None\n        else:  # add\n            if obj is not None:\n                res = obj.add(args[i][0])\n                result.append(res)\n            else:\n                result.append(None)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps describing algorithm. It's a class KthLargest with constructor and add method. Use min-heap of size k. Steps: init heap, push initial nums if less than k? Actually typical solution: keep min-heap of size k. In constructor, push first k elements, then for rest push if greater than heap root. For add, push val if heap size < k, else if val > heap root push and pop. Return heap root. Provide virtual code step lines with explanations. Ensure each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Let's outline.\n\nStart: initialize class.\n\n→ Step 1: Store k // keep k value\n→ Step 2: Create min-heap H // to keep k largest elements\n\n→ Decision: If nums array not empty? maybe process loop.\n\nWe can have a loop over nums:\n\n→ For each num in nums:\n    Decision: If H.size < k? // less than k elements\n        Yes → Step: H.push(num) // add to heap\n        No  → Decision: If num > H.min()? // compare to smallest in heap\n            Yes → H.push(num); H.popMin()\n            No → do nothing\n\nAfter loop: // heap ready\n\nConstructor End\n\nMethod add:\n\nStart method add\n→ Step: If H.size < k:\n    Yes → H.push(val)\n    No → Decision: If val > H.min():\n        Yes → H.push(val); H.popMin()\n        No → do nothing\n→ Step: Return H.min() // kth largest\n\nEnd method\n\nWe need to represent each line as separate. Use arrows? They want arrows for steps, decisions. Let's follow sample: \"Start // 程式開始執行\". Use \"→\" for each step. For decisions we indent with spaces then Yes → etc. Provide explanation each line.\n\nWe should also include End. Provide lines for constructor and add. Let's produce.\n\nMake sure each line is separate. We'll not output code, only virtual steps. Use Chinese explanations.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 儲存 k 值為 K // 以便後續比較  \n→ Step 2: 初始化最小堆 H // 用來保存 k 大的元素  \n→ Decision: nums 是否非空？ // 是否有初始分數  \n  Yes → Step 3: 對 nums 逐個遍歷  \n   → For each num in nums: // 逐一處理初始分數  \n    Decision: H.size < K? // 堆還沒滿 k 個  \n     Yes → H.push(num) // 直接加入堆  \n     No → Decision: num > H.min()? // 與堆中最小值比較  \n      Yes → H.push(num); H.popMin() // 加入後移除最小，保持堆大小為 k  \n      No →  // num 不大於堆最小，忽略  \n       // 何無動作  \n       End  \n      End  \n     End  \n    End  \n   End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \n  End  \nEnd // KthLargest 物件建立完成  \n\nStart // add 方法開始執行  \n→ Step 4: 如果 H.size < K? // 堆還沒滿 k 個  \n  Yes → H.push(val) // 新分數直接加入堆  \n  No → Decision: val > H.min()? // 與堆中最小值比較  \n   Yes → H.push(val); H.popMin() // 加入後移除最小，保持堆大小為 k  \n   No → // val 不足以成為 k 大，忽略  \n    // 何無動作  \n    End  \n   End  \n  End  \n→ Step 5: Return H.min() // 堆頂即為第 k 大分數  \nEnd // add 方法結束並返回結果"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    content_map = defaultdict(list)\n    for path in paths:\n        parts = path.split()\n        root = parts[0]\n        for file_info in parts[1:]:\n            name, content = file_info.split('(')\n            content = content[:-1]  # remove trailing ')'\n            full_path = f\"{root}/{name}\"\n            content_map[content].append(full_path)\n    return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Expect input like: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\", ...]\n    if '=' in data:\n        rhs = data.split('=', 1)[1].strip()\n    else:\n        rhs = data\n    try:\n        paths = ast.literal_eval(rhs)\n    except Exception:\n        paths = []\n    result = find_duplicate(paths)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: Find duplicate files by content given directory info strings. We need step-by-step pseudocode. Use Start, End, Decision. Provide explanation after each line. We'll produce step-by-step algorithm: parse each string, split by spaces, first token is path, others are files with content in parentheses. For each file, extract name and content, build mapping content->list of paths. At end, iterate mapping and collect lists with length>1. Output list. Use generic data structures: dictionary, list. No actual code. Provide each step with explanation. Provide arrow \"→\" before each step. Use Decision: for checking content count >1. Provide loops: For each dirInfo, for each file. Use pseudo loop syntax: \"Loop over dirInfo\" etc. Use arrows to show flow. Should be \"逐行\" each line.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize empty map contentToPaths // map content string to list of file paths\n→ Step 2: For each directoryInfo in inputList // iterate over each directory info string\n    → Step 3: Split directoryInfo by spaces into parts // first part is dirPath, rest are files with content\n    → Step 4: Set dirPath = parts[0] // base directory path\n    → Loop over parts from index 1 to end // each part is \"fileName(content)\"\n        → Step 5: Parse fileName and fileContent from part // extract name before '(' and content inside parentheses\n        → Step 6: Construct fullPath = dirPath + \"/\" + fileName // build full file path\n        → Step 7: If fileContent not in contentToPaths then add new list // initialize list\n        → Step 8: Append fullPath to contentToPaths[fileContent] // add path to map\n→ Step 9: Initialize result list // list of duplicate groups\n→ Decision: For each entry (content, paths) in contentToPaths // check if duplicate\n    → Yes → Step 10: If length of paths > 1 then add paths to result // only duplicates\n    → No → Step 11: Skip // not duplicate\n→ End // return result\n\nWe need to include explanation for each line.\n\nLet's ensure each line uses \"虛擬碼步驟\" and comment.\n\nAlso need to use arrow \"→\" before each step, Decision lines with indentation. Provide explanation after comment. The lines inside loops/decision might need indentation.\n\nWe'll format as per example: Start // comment. Then \"→ Step 1: ...\" etc.\n\nOk. Let's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 contentToPaths // 建立內容 → 路徑清單的映射  \n→ Step 2: 對於輸入列表中的每一個 directoryInfo // 逐行處理目錄資訊  \n    → Step 3: 將 directoryInfo 以空格切分為 parts // 第一項為目錄路徑，後面為檔案資訊  \n    → Step 4: 設定 dirPath = parts[0] // 取得基礎目錄路徑  \n    → Loop over parts[1:] // 逐一處理每個檔案(檔名(內容))  \n        → Step 5: 從 part 解析 fileName 與 fileContent // 拆分 '(' 與 ')' 兩側的字串  \n        → Step 6: 組合 fullPath = dirPath + \"/\" + fileName // 建立完整檔案路徑  \n        → Decision: 若 fileContent 不在 contentToPaths 中? // 檢查是否已有此內容的鍵  \n            Yes → Step 7: contentToPaths[fileContent] = [] // 建立新的空清單  \n            No → // 直接跳過  \n        → Step 8: 將 fullPath 加入 contentToPaths[fileContent] // 將檔案路徑加入對應內容清單  \n→ Step 9: 初始化空結果 list result // 用來收集重複檔案群組  \n→ Decision: 遍歷 contentToPaths 中的每一個 (content, paths) // 檢查每個內容對應的路徑清單  \n    Yes → Step 10: 若 len(paths) > 1 則 result.append(paths) // 只加入至少兩個檔案的群組  \n    No → Step 11: // 跳過單一檔案的內容  \nEnd // 程式執行結束，返回 result 這個包含所有重複檔案路徑群組的清單"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[7,9]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[7, 9]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[10,1,1]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[10, 1, 1]'"
        }
      ],
      "generated_code": "import random\nimport sys\nimport re\n\n# 假設已有的 rand7 API\ndef rand7():\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        while True:\n            # 使用兩次 rand7 生成 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入，例如 \"n = 3\"\n    input_text = sys.stdin.read().strip()\n    # 提取數字\n    match = re.search(r'(\\d+)', input_text)\n    n = int(match.group(1)) if match else 0\n\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating rand10() using rand7(). Classic algorithm: use two calls to generate 49 outcomes, map to 1-10 using rejection sampling. Or we can use base 7 to produce a number between 1-49. Approach: roll twice to get 7*prev + current. If number <= 40, map to 1-10 via (num-1)%10+1. Else discard and repeat. Implementation pseudocode with decisions.\n\nWe need to produce virtual code step by step.\n\nMake sure to use Start, End, Decision, etc. And each line: \"虛擬碼步驟 // 解釋\". Provide explanation each line.\n\nLet's craft. Use lines like:\n\nStart // 程式開始\n\n→ Step 1: Initialize result variable // etc.\n\nBut we need function definition: rand10().\n\nSo line: → Step 1: Function rand10() // define function\n\nThen inside loop: use while True: (like Step 2: while True)\n\nBut need to produce decision for mapping.\n\nDetailed steps:\n\n- Call rand7() twice to produce first and second number.\n- Compute num = (first-1)*7 + second // produce number 1-49\n- Decision: if num <= 40? // Acceptable range\n- Yes → compute rand10 = (num-1) mod 10 + 1 // map\n- Return rand10 // output\n- No → repeat loop // discard\n\nBut need to represent return and repeat appropriately. Use Decision block.\n\nAlso must include call to rand7() each iteration. Use \"→ Step 2: first ← rand7() // first random 1-7\".\n\nLet's produce step-by-step.\n\nEdge: Ensure that the code structure is clear.\n\nWe will produce lines:\n\nStart // 程式開始\n\n→ Step 1: Function rand10() // 定義 rand10 函式\n\n→ Step 2: while True // 無窮迴圈，直到得到合法值\n\n→ Step 3: first ← rand7() // 取得第一個隨機數 1~7\n\n→ Step 4: second ← rand7() // 取得第二個隨機數 1~7\n\n→ Step 5: num ← (first - 1) * 7 + second // 轉換成 1~49 的數字\n\n→ Decision: 如果 num <= 40? // 檢查是否在可接受區間\n\n   Yes → Step 6: result ← (num - 1) mod 10 + 1 // 將 1~40 映射為 1~10\n\n   Yes → Step 7: return result // 回傳結果\n\n   No  → // 若不符合條件，重試\n\nEnd // 程式結束\n\nBut we need to represent \"return\" as part of step. Use Step 7.\n\nThe decision block may include the \"Yes\" path returns and the \"No\" path loops again. Represent the No path as just a comment.\n\nAlso we must follow format: each line: \"虛擬碼步驟 // 解釋\". So we need to label each step properly.\n\nAlso incorporate the End after function. But we may need to include End inside function? The End marks program finish. We can show End after function return. Provide End as part of function.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: Function rand10() // 定義 rand10 函式\n\n→ Step 2: while True // 無窮迴圈，直到得到合法值\n\n→ Step 3: first ← rand7() // 取得第一個隨機數 1~7\n\n→ Step 4: second ← rand7() // 取得第二個隨機數 1~7\n\n→ Step 5: num ← (first - 1) * 7 + second // 轉換成 1~49 的數字\n\n→ Decision: 如果 num <= 40? // 檢查是否在可接受區間\n\n  Yes → Step 6: result ← (num - 1) mod 10 + 1 // 將 1~40 映射為 1~10\n\n  Yes → Step 7: return result // 回傳結果\n\n  No  → // 若不符合條件，重試（回到 while 迴圈的開頭）\n\nEnd // 程式結束"
    },
    {
      "title": "Count of Range Sum",
      "source_file": "Leetcode/leetcode327.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpl6drnqsh.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpl6drnqsh.py\", line 37, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    nums = [-2,5,-1], lower = -2, upper = 2\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [0], lower = 0, upper = 0",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqlb1g4mn.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpqlb1g4mn.py\", line 37, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    nums = [0], lower = 0, upper = 0\n    ^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        # 1. 建立前綴和陣列\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        # 2. 以遞迴的方式進行分治與合併排序計數\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:          # 子區間長度 0 或 1 時無法再分\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            # 3. 計算跨區間的有效區間和\n            i = j = mid\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            # 4. 合併排序，使 prefix[lo:hi] 成為升序\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 執行讀入的程式碼，得到 nums, lower, upper 變數\n    exec(data, globals())\n    solution = Solution()\n    result = solution.countRangeSum(nums, lower, upper)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode (not actual code) step-by-step with explanation. The problem is the typical \"count of range sum\" problem. Use prefix sums and divide and conquer (like mergesort counting). We'll produce virtual steps: compute prefix sums array of length n+1. Then call a function count_while_merge_sort on range 0..n to count. Implementation details: use recursive divide, count cross pairs while merging. Each step we need explanation. We'll output each line as \"虛擬碼步驟 // 解釋\". Use arrow, decision, etc. The output must be line by line. Let's craft.\n\nSteps:\n\nStart\n→ Step 1: 建立 prefix sums array pre[0] = 0; for i in 0..n-1: pre[i+1] = pre[i] + nums[i] // 生成前綴和\n→ Step 2: 呼叫 count_while_merge_sort(pre, 0, n, lower, upper) // 進行分治計數\nEnd\n\nDefine count_while_merge_sort(subarray start,end): // 端點 exclusive end\n→ Decision: 如果 start >= end-1? // 只含一個元素，無子區間\n    Yes → Return 0 // 沒有範圍和\n    No  →\n        mid = (start+end)/2 // 分割中點\n        left_count = count_while_merge_sort(pre, start, mid, lower, upper) // 計算左側\n        right_count = count_while_merge_sort(pre, mid, end, lower, upper) // 計算右側\n        cross_count = count_cross(pre, start, mid, end, lower, upper) // 計算跨區間\n        → Merge sorted subarrays pre[start:mid] and pre[mid:end] // 合併保持升序\n        → Return left_count + right_count + cross_count // 合計\n\nDefine count_cross(pre,start,mid,end,lower,upper):\n→ 初始化 count = 0\n→ 初始化 left_ptr = start, right_ptr = start\n→ for each val in pre[mid:end]:\n    → while left_ptr < mid and pre[left_ptr] < val - upper: left_ptr++ // 超過上界\n    → while right_ptr < mid and pre[right_ptr] <= val - lower: right_ptr++ // 仍在下界\n    → count += right_ptr - left_ptr // 這個 val 對應的範圍和個數\n→ Return count\n\nBut need to maintain pseudocode with arrows. Let's produce each step accordingly.\n\nWe need to output in format: each line has virtual code step + space + comment. We'll use arrow '→'. For decisions, use \"Decision:\".\n\nLet's structure. Provide top-level start.\n\nWe'll use steps for main function.\n\nOk. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: pre[0] ← 0 // 初始化前綴和陣列  \n→ Step 2: 對 i 從 0 到 n-1 做  \n  → pre[i+1] ← pre[i] + nums[i] // 逐個累加得到前綴和  \n→ Step 3: result ← count_while_merge_sort(pre, 0, n, lower, upper) // 進行分治計數  \n→ Step 4: 輸出 result // 回傳區間和的個數  \nEnd // 程式執行結束  \n\n---  \n\ncount_while_merge_sort(pre, start, end, lower, upper) // 分治計數  \n→ Decision: 如果 start ≥ end-1? // 只剩一個元素，無子區間  \n  Yes → Return 0 // 無符合區間和  \n  No →  \n   → mid ← (start + end) / 2 // 找中點  \n   → left_count ← count_while_merge_sort(pre, start, mid, lower, upper) // 左半邊  \n   → right_count ← count_while_merge_sort(pre, mid, end, lower, upper) // 右半邊  \n   → cross_count ← count_cross(pre, start, mid, end, lower, upper) // 跨區間  \n   → Merge_sorted(pre, start, mid, end) // 合併保持升序  \n   → Return left_count + right_count + cross_count // 總計數  \n\n---  \n\ncount_cross(pre, start, mid, end, lower, upper) // 計算跨區間的個數  \n→ 輸入 count ← 0 // 初始化計數  \n→ left_ptr ← start // 左側指標  \n→ right_ptr ← start // 右側指標  \n→ 對 val 在 pre[mid:end] 做  \n  → while left_ptr < mid 且 pre[left_ptr] < val - upper: left_ptr++ // 超過上界  \n  → while right_ptr < mid 且 pre[right_ptr] ≤ val - lower: right_ptr++ // 仍在下界  \n  → count ← count + (right_ptr - left_ptr) // 這個 val 對應的區間和數量  \n→ Return count // 回傳跨區間數量  \n\n---  \n\nMerge_sorted(pre, start, mid, end) // 合併兩個已排序的子陣列  \n→ temp ← 空陣列  \n→ i ← start, j ← mid  \n→ while i < mid 且 j < end:  \n  → if pre[i] ≤ pre[j]: temp.append(pre[i]), i++  \n   → else: temp.append(pre[j]), j++  \n→ while i < mid: temp.append(pre[i]), i++  \n→ while j < end: temp.append(pre[j]), j++  \n→ 把 temp 的內容複製回 pre[start:end] // 更新原陣列為升序  \n→ End // 合併完成"
    },
    {
      "title": "My Calendar II",
      "source_file": "Leetcode/leetcode731.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2gxry87w.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmp2gxry87w.py\", line 40, in main\n    args = ast.literal_eval('[' + args_str)  # 加上開頭 '[' 以完成列表\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCalendarTwo:\n    def __init__(self):\n        # 已預約的區間列表\n        self.booked = []\n        # 任何已形成雙重重疊的區間列表\n        self.overlaps = []\n\n    def book(self, start: int, end: int) -> bool:\n        # 檢查本次新事件是否會與已有雙重重疊區間再重疊\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n        # 將新事件與已預約的區間產生的重疊區間加入 overlaps\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n        # 最後把新事件加入已預約列表\n        self.booked.append((start, end))\n        return True\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 分離指令列表與參數列表\n    # 例如：'[\"MyCalendarTwo\",\"book\",\"book\"], [[],[10,20],[50,60]]'\n    # 先找第一個 '],'\n    split_idx = raw.find('],')\n    commands_str = raw[:split_idx+1]            # 包含第一個列表的結束括號\n    args_str = raw[split_idx+2:]               # 後面剩下的參數列表，已去掉 '],'\n\n    # 重新構造合法的 Python 表達式並解析\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval('[' + args_str)  # 加上開頭 '[' 以完成列表\n\n    outputs = []\n    obj = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == 'MyCalendarTwo':\n            obj = MyCalendarTwo()\n            outputs.append(None)\n        elif cmd == 'book':\n            res = obj.book(arg[0], arg[1])\n            outputs.append(res)\n        else:\n            # 若未處理的指令，則忽略\n            pass\n\n    # 使用 json.dumps 以符合 LeetCode 的輸出格式\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation. Should not output real code. Need to design algorithm for MyCalendarTwo: typical solution uses storing intervals and overlapping counts. Approach: keep list of bookings; when booking, check overlaps with existing intervals and second-level overlaps. Use two lists: one for events, one for overlapped intervals. For each new event, count overlaps with existing events. If overlap count >=2 for any segment, reject. Else add new event, and add overlap intervals to overlapped list.\n\nWe need to produce steps. Also we need to show decision structure etc.\n\nWe can provide pseudocode lines like:\n\nStart\n→ Step: Initialize calendar: empty list of bookings\n→ Step: Initialize list of overlapped intervals\n\nFor book(start, end):\n→ Decision: For each existing booking interval (s,e)\n    → Decision: Does (s,e) overlap with [start,end)?\n        Yes → Compute overlap [max(s,start), min(e,end))\n        → Decision: Does overlap intersect any existing overlapped interval? \n            Yes → Reject (return false)\n            No → Add overlap to overlapped list\n→ After checking all, add new interval to bookings list, return true\n\nNeed to produce step lines with arrow.\n\nLet's format accordingly. Use arrow → and Decision:.\n\nAlso need to include comments.\n\nWe'll produce:\n\nStart // 程式開始\n→ Step 1: 初始化 MyCalendarTwo // 建立空事件列表與重疊區間列表\n\nThen book function: We'll treat as separate block.\n\nWe'll output each line accordingly.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 初始化 MyCalendarTwo // 建立兩個空列表：events 用於儲存已預約的區間，overlaps 用於儲存任何已形成雙重重疊的區間\n\n// --- book 方法的虛擬碼 ---\n\n→ Step 2: book(start, end) // 接收新事件的起止時間\n\n→ Decision: 事件區間是否為空？ // 確保 start < end\n    Yes → Return false // 無效區間\n    No  → 進行以下檢查\n\n→ Step 3: 初始化 tempOverlaps 為空列表 // 暫存本次新增事件與現有事件產生的雙重重疊區間\n\n→ For 事件 in events  // 逐一檢查已存在的所有事件\n    → Decision: 事件與 [start, end) 是否重疊？\n        Yes → \n            → Step 4: 計算重疊區間 overlap = [max(事件.start, start), min(事件.end, end))\n            → Decision: overlap 與 overlaps 是否再次重疊？\n                Yes → Return false // 會造成三重重疊，拒絕新增\n                No  → \n                    → Step 5: 把 overlap 加入 tempOverlaps // 記錄本次可能的雙重重疊\n        No → // 不重疊，跳過\n\n→ For 每個 overlap 在 tempOverlaps\n    → Step 6: 把 overlap 加入 overlaps // 將新發現的雙重重疊區間永久保存\n\n→ Step 7: 把 [start, end) 加入 events // 新事件成功加入\n\n→ Step 8: Return true // 事件已成功預約，未造成三重重疊\n\nEnd // 程式執行結束"
    },
    {
      "title": "Subarray Sum Equals K",
      "source_file": "Leetcode/leetcode560.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpi2uingbh.py\", line 28, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo87dg71t.py\", line 28, in <module>\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subarray_sum(nums, k):\n    \"\"\"計算子陣列和等於 k 的個數。\"\"\"\n    count = 0\n    prefix_sum = 0\n    sum_map = {0: 1}          # 前綴和 0 已出現一次\n\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - k in sum_map:\n            count += sum_map[prefix_sum - k]\n        sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n    return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 假設輸入形式為 \"[1,2,3], k = 3\"\n    parts = data.split(',', 1)\n    nums_str = parts[0].strip()\n    k_str = parts[1].strip()\n\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str.split('=')[1].strip())\n\n    result = subarray_sum(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: count subarrays with sum = k. Standard approach: prefix sum + hash map. Steps: iterate over array, keep cumulative sum, count how many times (cumSum - k) seen before. Use dictionary map sum->count. Complexity O(n). We produce line by line steps, with arrows and decisions. We need to follow format: Start, → Step X: ... // explanation. Use Decision lines. We must not output actual code but pseudo steps. Let's craft.\n\nWe can structure:\n\nStart\n→ Initialize hashmap counts with {0:1} // prefix sum 0 seen once\n→ Initialize cumSum=0, result=0\n→ For each element num in nums:\n    → Update cumSum += num\n    → Decision: if (cumSum - k) exists in hashmap?\n        Yes → Increment result by hashmap[cumSum - k] // add number of previous prefixes that make subarray sum k\n        No → // nothing\n    → Update hashmap[cumSum] += 1 // increment count of this cumulative sum\nEnd // return result\n\nWe need to include decisions for existence check. Also we need to decide when to update hashmap. We can use Decision lines for map get.\n\nAlso we may add Step to iterate, Decision to check existence. The final result return. Use End. Provide short comments.\n\nLet's produce lines accordingly.\n\nWe need to produce each line with arrow or indentation? Example: \"→ Step 1:\" etc. Use indentation for decisions? In example, indentation is 4 spaces before Decision and Yes/No branches. We'll mimic.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化 HashMap counts 並設 counts[0] = 1 // 代表前綴和 0 已出現一次\n→ Step 2: 初始化 cumSum = 0, result = 0 // 用於累積和與結果計數\n→ Decision: 迭代 nums? // 判斷是否還有元素待處理\n    Yes → Step 3: 取出 nums 的下一個元素 num\n    → Step 4: cumSum += num // 更新前綴和\n    → Decision: (cumSum - k) 是否在 counts? // 檢查是否存在可產生子陣列和為 k 的前綴\n        Yes → Step 5: result += counts[cumSum - k] // 累加符合條件的子陣列數\n        No → // 無符合條件的前綴，結果不變\n    → Step 6: 更新 counts[cumSum] = counts.get(cumSum,0)+1 // 記錄新的前綴和\n    → Decision: 是否還有下一個元素? // 回到迭代判斷\n        Yes → 回到 Step 3\n        No → // 迭代結束\n→ Step 7: 返回 result // 結果為符合條件的子陣列總數\nEnd // 程式執行結束\n\nBut we need arrow for each step. Use \"→ Step X\". For decisions, use \"Decision:\" with Yes → and No →. Indentation maybe 4 spaces. Provide explanation after //.\n\nWe need to ensure we don't produce actual code, only steps. Ensure we include \"Start\" and \"End\".\n\nWe must also be careful with syntax: After Decision we need nested indentation. We'll mimic example.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 HashMap counts 並設 counts[0] = 1 // 代表前綴和 0 已出現一次\n→ Step 2: 初始化 cumSum = 0, result = 0 // 用於累積和與結果計數\n→ Decision: 迭代 nums? // 判斷是否還有元素待處理\n    Yes → Step 3: 取出 nums 的下一個元素 num // 取得當前元素\n    → Step 4: cumSum += num // 更新前綴和\n    → Decision: (cumSum - k) 是否在 counts? // 檢查是否存在可產生子陣列和為 k 的前綴\n        Yes → Step 5: result += counts[cumSum - k] // 累加符合條件的子陣列數\n        No  → // 無符合條件的前綴，結果不變\n    → Step 6: 更新 counts[cumSum] = counts.get(cumSum,0)+1 // 記錄新的前綴和\n    → Decision: 是否還有下一個元素? // 回到迭代判斷\n        Yes → // 迭代繼續，回到 Step 3\n        No  → // 迭代結束\n→ Step 7: 返回 result // 結果為符合條件的子陣列總數\nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"Reorder nums to satisfy nums[0] < nums[1] > nums[2] < nums[3] …\"\"\"\n        n = len(nums)\n        for i in range(1, n):\n            # odd index should be greater than the previous element\n            if i % 2 == 1:\n                if nums[i] < nums[i - 1]:\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\n            # even index should be less than the previous element\n            else:\n                if nums[i] > nums[i - 1]:\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\n\nif __name__ == \"__main__\":\n    # Read entire input (e.g. 'nums = [1,5,1,1,6,4]')\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the list part after '='\n    try:\n        _, list_str = data.split('=', 1)\n    except ValueError:\n        list_str = data\n    nums = ast.literal_eval(list_str.strip())\n    Solution().wiggleSort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for rearranging array to wiggle pattern. Approach: sort array then swap adjacent pairs from start? Actually typical solution: sort, then swap every pair of elements starting from index 1? Another approach: iterate and if condition fails swap. We'll choose simple: iterate i from 1 to n-1: if i%2==1 (odd index) should be greater than previous: if nums[i] < nums[i-1] swap; else if i%2==0 should be less: if nums[i] > nums[i-1] swap. That ensures wiggle. We'll produce virtual steps accordingly. Each line with arrow. Provide explanation after comment. Let's craft.\n\nStructure: Start, Step 1: read array? Actually array provided. Step 2: For i from 1 to length-1: check parity. Provide decision lines.\n\nLet's produce virtual pseudocode. Use \"For i = 1 to n-1:\" then inside: Decision: If i is odd? Yes→ Check condition; else→ etc. We'll produce lines. Ensure each line ends with // explanation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n // 確定迴圈範圍  \n→ For i = 1 to n-1: // 逐一檢查每個相鄰對  \n  → Decision: i 為奇數? // 判斷索引為奇數 (應該大於前一個)  \n    Yes → Decision: nums[i] < nums[i-1]? // 若未滿足大於前一個則交換  \n        Yes → Step 2: 交換 nums[i] 與 nums[i-1] // 使 nums[i] 成為較大值  \n        No  → No action // 已符合規則  \n    No  → Decision: nums[i] > nums[i-1]? // 若索引為偶數（應小於前一個）  \n        Yes → Step 3: 交換 nums[i] 與 nums[i-1] // 使 nums[i] 成為較小值  \n        No  → No action // 已符合規則  \nEnd // 程式執行結束，陣列已符合 nums[0] < nums[1] > nums[2] < … 的交錯排列"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc2_jc_up.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpc2_jc_up.py\", line 40, in main\n    lists = re.findall(r'(?<=equations\\s*=\\s*)\\[[^\\]]*\\]|(?<=values\\s*=\\s*)\\[[^\\]]*\\]|(?<=queries\\s*=\\s*)\\[[^\\]]*\\]', data)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 217, in findall\n    return _compile(pattern, flags).findall(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 307, in _compile\n    p = _compiler.compile(pattern, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 749, in compile\n    code = _code(p, flags)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 582, in _code\n    _compile(code, p.data, flags)\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 176, in _compile\n    _compile(code, av, flags)\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 155, in _compile\n    raise error(\"look-behind requires fixed-width pattern\")\nre.error: look-behind requires fixed-width pattern"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpapuortgc.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpapuortgc.py\", line 40, in main\n    lists = re.findall(r'(?<=equations\\s*=\\s*)\\[[^\\]]*\\]|(?<=values\\s*=\\s*)\\[[^\\]]*\\]|(?<=queries\\s*=\\s*)\\[[^\\]]*\\]', data)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 217, in findall\n    return _compile(pattern, flags).findall(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 307, in _compile\n    p = _compiler.compile(pattern, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 749, in compile\n    code = _code(p, flags)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 582, in _code\n    _compile(code, p.data, flags)\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 176, in _compile\n    _compile(code, av, flags)\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 155, in _compile\n    raise error(\"look-behind requires fixed-width pattern\")\nre.error: look-behind requires fixed-width pattern"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_32jxzgg.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmp_32jxzgg.py\", line 40, in main\n    lists = re.findall(r'(?<=equations\\s*=\\s*)\\[[^\\]]*\\]|(?<=values\\s*=\\s*)\\[[^\\]]*\\]|(?<=queries\\s*=\\s*)\\[[^\\]]*\\]', data)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 217, in findall\n    return _compile(pattern, flags).findall(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 307, in _compile\n    p = _compiler.compile(pattern, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 749, in compile\n    code = _code(p, flags)\n           ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 582, in _code\n    _compile(code, p.data, flags)\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 176, in _compile\n    _compile(code, av, flags)\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 155, in _compile\n    raise error(\"look-behind requires fixed-width pattern\")\nre.error: look-behind requires fixed-width pattern"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        # 建立圖形結構，使用鄰接表\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        # 深度優先搜尋，用於尋找從 src 到 dst 的乘積路徑\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\ndef main():\n    # 從標準輸入讀取整行資料\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 使用正則表達式抓取等式、值、查詢的列表字串\n    lists = re.findall(r'(?<=equations\\s*=\\s*)\\[[^\\]]*\\]|(?<=values\\s*=\\s*)\\[[^\\]]*\\]|(?<=queries\\s*=\\s*)\\[[^\\]]*\\]', data)\n    equations = ast.literal_eval(lists[0])\n    values = ast.literal_eval(lists[1])\n    queries = ast.literal_eval(lists[2])\n\n    sol = Solution()\n    res = sol.calcEquation(equations, values, queries)\n\n    # 以 5 位小數格式輸出結果\n    output = '[' + ','.join(f'{v:.5f}' for v in res) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem. It's like LeetCode 399 Evaluate Division. We need to provide steps using virtual code with arrows and comments. Should be line by line, each line containing virtual code step and comment. Use structure: Start, End, Decision. Provide steps: build graph, run DFS or Union-Find. Probably Union-Find with weights. Provide steps.\n\nWe'll generate virtual code with simple logic: Build adjacency list, perform DFS for each query. Provide explanation. We'll keep steps linear: Start, Build graph, For each query, check existence, DFS, etc. Use decisions for existence and if path found.\n\nLet's create:\n\nStart\n→ Step 1: Build graph from equations and values // adjacency list\n→ Step 2: For each query in queries // loop queries\n    → Decision: If either variable not in graph? // check existence\n        Yes → Step 3: Append -1.0 to results // undefined variable\n        No  → Step 4: Initialize visited set // for DFS\n              Step 5: Call DFS from C to find product to D // compute ratio\n              → Decision: If DFS returns value? // found\n                  Yes → Step 6: Append value to results\n                  No  → Step 7: Append -1.0 to results\nEnd\n\nAdd explanation lines.\n\nWe need to use \"Start\" and \"End\" and \"Decision:\" and \"Yes →\" etc. So each line should be a step. We'll write each line like:\n\nStart // 程式開始執行\n\n→ Step 1: 建立一個鄰接表 graph，key 為變數，value 為鄰接變數及其比值 // Build graph\n\n→ Step 2: 逐一處理每個查詢 query // Process queries\n\nDecision: 若 query 的任一變數不在 graph? // Check existence\n\n    Yes → Step 3: 將 -1.0 加入答案陣列 // Undefined variable\n\n    No  → Step 4: 建立一個 visited 集合，避免重複訪問 // DFS visited\n\n        Step 5: 執行 DFS(current, target, accum) 以搜尋路徑並計算積分 // DFS to find ratio\n\n        Decision: DFS 是否找到目標? // Found target?\n\n            Yes → Step 6: 將 accum 加入答案陣列 // Found ratio\n\n            No  → Step 7: 將 -1.0 加入答案陣列 // Path not found\n\nEnd // 程式結束\n\nBut we need to ensure each line is \"虛擬碼步驟 [空格] // 解釋/說明\". Also use arrows. So format: \"→ Step 1: ... // ...\"\n\nMake sure to include arrows after decisions? Decision lines like \"Decision: ...\" then indent children with \"Yes →\" \"No →\". Provide each line separately.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立鄰接表 graph，key 為變數，value 為鄰接變數及其比值 // 建立圖形結構  \n→ Step 2: 逐一處理 queries 陣列 // 迴圈逐個查詢  \nDecision: query 內的任一變數是否不在 graph? // 檢查變數是否已知  \n    Yes → Step 3: 把 -1.0 加入結果陣列 // 未定義的變數直接回傳 -1.0  \n    No  → Step 4: 建立 visited 集合，避免重複訪問 // 初始化 DFS 的訪問記錄  \n        Step 5: 呼叫 DFS(C, D, 1.0) 以搜尋路徑並計算積分 // DFS 進行比值計算  \n        Decision: DFS 是否找到目標變數? // 判斷是否成功找到路徑  \n            Yes → Step 6: 把積分值加入結果陣列 // 成功計算出比值  \n            No  → Step 7: 把 -1.0 加入結果陣列 // 無路徑可達，回傳 -1.0  \nEnd // 程式結束執行"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the part after '='\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n    # Safely evaluate the list\n    try:\n        accounts = ast.literal_eval(list_part)\n    except Exception as e:\n        raise ValueError(f\"Invalid input format: {e}\")\n\n    sol = Solution()\n    merged_accounts = sol.accountsMerge(accounts)\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines for merging accounts. Steps: Build graph mapping email to name and adjacency. Use DFS/BFS. For each email not visited, collect component emails, sort, prepend name. End. Need to follow format. Use \"Start\", \"End\", \"Decision:\" etc. Each line: code + \" // explanation\".\n\nWe'll generate lines:\n\nStart\n→ Step 1: Initialize graph map and emailName map\n→ Step 2: For each account in accounts:\n    → Step 2a: name = account[0]\n    → Step 2b: For each email in account[1:]:\n        → Step 2b1: emailName[email] = name\n        → Step 2b2: Add email to graph adjacency set\n        → Step 2b3: If first email, set previous = email else connect previous with current\n→ Step 3: Initialize visited set and result list\n→ Step 4: For each email in graph:\n    → Decision: If email not in visited?\n        Yes → Step 4a: Perform DFS stack to gather component emails\n            → Step 4a1: While stack not empty, pop, add to component, mark visited, push neighbors\n        No → Step 4b: Continue\n→ Step 5: Sort component emails\n→ Step 6: Prepend emailName[component[0]] as name\n→ Step 7: Append to result\nEnd\n\nNeed to format each line exactly: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's craft each line. Use indent for nested. Provide decision blocks with Yes → etc. Use \"Decision:\" label.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize graph map (email → set of connected emails) and emailName map (email → name) // 建立鄰接圖與電子郵件對應姓名的映射  \n→ Step 2: For each account in accounts  \n    → Step 2a: name = account[0] // 取得該帳號的姓名  \n    → Step 2b: For each email in account[1:]  \n        → Step 2b1: emailName[email] = name // 記錄電子郵件對應姓名  \n        → Step 2b2: Add email to graph adjacency set (if not exist) // 初始化圖節點  \n        → Step 2b3: If first email in this account, set prev = email  \n        → Step 2b4: Else, add edge between prev and current email in graph // 連結同一帳號內的電子郵件  \n            → Decision: If graph[prev] exists?  \n                Yes → Add current email to graph[prev] set // 更新前一個節點的鄰居  \n                No  → graph[prev] = {current email} // 新增前一個節點的鄰居集合  \n            → Decision: If graph[current] exists?  \n                Yes → Add prev to graph[current] set // 更新目前節點的鄰居  \n                No  → graph[current] = {prev} // 新增目前節點的鄰居集合  \n        → Step 2b5: prev = current email // 更新為目前電子郵件以備下一輪連結  \n→ Step 3: Initialize visited set and result list // 用於追蹤已處理的電子郵件與儲存最終帳號  \n→ Step 4: For each email in graph keys  \n    → Decision: If email not in visited?  \n        Yes → Step 4a: Perform DFS to collect all connected emails  \n            → Step 4a1: stack = [email] // DFS 使用堆疊  \n            → Step 4a2: component = [] // 存放同一個人的所有電子郵件  \n            → Step 4a3: While stack not empty  \n                → Step 4a3a: curr = stack.pop() // 取出堆疊頂部  \n                → Decision: If curr not in visited?  \n                    Yes → Step 4a3b: visited.add(curr) // 標記已訪問  \n                    → component.append(curr) // 加入同一個人的電子郵件列表  \n                    → stack.extend(graph[curr]) // 將鄰居加入堆疊  \n                    No  → // 已訪問，略過  \n        No  → // 已處理過，略過  \n→ Step 5: Sort component emails in lexicographical order // 依照字典序排序電子郵件  \n→ Step 6: name = emailName[component[0]] // 取得此組合中任意一個電子郵件對應的姓名  \n→ Step 7: result.append([name] + component) // 將姓名與排序後的電子郵件組合成最終帳號  \n→ Step 8: Return result // 傳回合併後的帳號列表  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1yogv2s4.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmp1yogv2s4.py\", line 52, in main\n    res = obj.book(args[0], args[1])\n                   ~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyCalendar:\n    def __init__(self):\n        self.bookings = []\n\n    def book(self, start, end):\n        for s, e in self.bookings:\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef parse_input():\n    \"\"\"Read stdin and parse the operations and their arguments.\"\"\"\n    data = [line.strip() for line in sys.stdin if line.strip()]\n    if not data:\n        return [], []\n    if len(data) == 1:\n        # Both lists may be on a single line separated by a comma\n        line = data[0]\n        # Find the first closing bracket of the first list\n        idx = line.find('],')\n        if idx != -1:\n            first, second = line[:idx+1], line[idx+2:]\n            ops = ast.literal_eval(first.strip())\n            args = ast.literal_eval(second.strip())\n        else:\n            # If no comma, treat whole as operations (unlikely)\n            ops = ast.literal_eval(line)\n            args = []\n    else:\n        ops = ast.literal_eval(data[0])\n        args = ast.literal_eval(data[1])\n    return ops, args\n\ndef main():\n    ops, args_list = parse_input()\n    outputs = []\n    obj = None\n    arg_index = 0\n    for op in ops:\n        if op == \"MyCalendar\":\n            obj = MyCalendar()\n            outputs.append(None)\n        else:\n            args = args_list[arg_index]\n            arg_index += 1\n            if op == \"book\":\n                res = obj.book(args[0], args[1])\n                outputs.append(res)\n            else:\n                # In case other methods are added in the future\n                func = getattr(obj, op)\n                res = func(*args)\n                outputs.append(res)\n    # Convert Python True/False/None to JSON true/false/null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for this problem. We need to write step-by-step pseudocode with explanations after each line. Use arrows. Probably include initialization, book method, storing intervals maybe sorted list. Steps: initialize empty list. Book: iterate list to check overlap. If overlap return false. Else insert. Return true. Also keep list sorted.\n\nLet's produce virtual steps:\n\nStart\n→ Step 1: 定義 MyCalendar 類別 // 建立類別\n→ Step 2: 在 MyCalendar 建構子內部初始化 events 為空集合 // 用來存儲已預約的區間\n→ Decision: book 方法被呼叫 // 開始處理預約請求\n    Yes → Step 3: 針對每個已存在事件檢查與新事件是否重疊 // 檢查重複\n        → Decision: 事件的開始時間 < 新事件結束時間 且 事件結束時間 > 新事件開始時間?\n            Yes → Step 4: 返回 false // 產生雙重預約\n            No  → 繼續檢查下一個事件\n    Yes → Step 5: 新事件不與任何已存在事件重疊 // 可以加入\n        → Step 6: 將新事件加入 events 集合 // 存儲\n        → Step 7: 返回 true // 成功預約\nEnd\n\nWe need to use arrow syntax: Start, Step etc. Use `Yes →` `No →`. We need to be clear.\n\nAlso maintain events sorted? maybe not necessary for pseudocode but mention.\n\nLet's produce final answer with lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCalendar 類別 // 建立日曆類別\n→ Step 2: 在 MyCalendar 建構子內部初始化 events 為空集合 // 用來存儲已預約的區間\n→ Decision: book 方法被呼叫 // 開始處理預約請求\n    Yes → Step 3: 針對每個已存在事件檢查與新事件是否重疊 // 檢查重複\n        → Decision: 事件的開始時間 < 新事件結束時間 且 事件結束時間 > 新事件開始時間?\n            Yes → Step 4: 返回 false // 產生雙重預約\n            No  → 繼續檢查下一個事件\n    Yes → Step 5: 新事件不與任何已存在事件重疊 // 可以加入\n        → Step 6: 將新事件加入 events 集合 // 存儲\n        → Step 7: 返回 true // 成功預約\nEnd // 程式執行結束"
    },
    {
      "title": "Replace Words",
      "source_file": "Leetcode/leetcode648.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"",
          "expected_output": "\"the cat was rat by the bat\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqg8hb2ko.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpqg8hb2ko.py\", line 49, in main\n    sentence = sent_match.group(2) if sent_match.group(2) is not None else sent_match.group(3)\n                                                                           ^^^^^^^^^^^^^^^^^^^\nIndexError: no such group"
        },
        {
          "example_index": 1,
          "input": "dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"",
          "expected_output": "\"a a b c\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1um88uvx.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmp1um88uvx.py\", line 49, in main\n    sentence = sent_match.group(2) if sent_match.group(2) is not None else sent_match.group(3)\n                                                                           ^^^^^^^^^^^^^^^^^^^\nIndexError: no such group"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def replaceWords(self, dictionary, sentence):\n        trie = {}\n        END = True\n\n        # 建立 Trie\n        for root in dictionary:\n            node = trie\n            for char in root:\n                node = node.setdefault(char, {})\n            node[END] = root\n\n        def replace(word):\n            node = trie\n            for char in word:\n                if char not in node:\n                    break\n                node = node[char]\n                if END in node:\n                    return node[END]\n            return word\n\n        return ' '.join(map(replace, sentence.split()))\n\ndef main():\n    data = sys.stdin.read().strip()\n\n    # 取得 dictionary 列表\n    dict_match = re.search(r'dictionary\\s*=\\s*\\[(.*?)\\]', data, re.S)\n    if not dict_match:\n        print(\"\")\n        return\n    roots_str = dict_match.group(1).strip()\n    # 轉成 Python list\n    try:\n        dictionary = ast.literal_eval(f'[{roots_str}]')\n    except Exception:\n        dictionary = []\n\n    # 取得 sentence 字串\n    sent_match = re.search(r'sentence\\s*=\\s*(?:\"(.*?)\"|\\'(.*?)\\')', data, re.S)\n    if not sent_match:\n        sentence = \"\"\n    else:\n        sentence = sent_match.group(2) if sent_match.group(2) is not None else sent_match.group(3)\n\n    solution = Solution()\n    result = solution.replaceWords(dictionary, sentence)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines. The task: Given dictionary of roots, and a sentence, replace words in sentence with shortest root that matches prefix. Standard problem \"replace words\". Approach: build a trie of roots. For each word, traverse trie until mismatch or word ends. If match found, replace with that root. Build result. Steps: Start, build trie, process sentence splitting, for each word get replacement, build output, End.\n\nWe need to output each line with virtual code and explanation. Use arrow notation. Use Decision and loops.\n\nWe need to produce \"逐行\" lines: Start, build trie, etc.\n\nWe'll do:\n\nStart\n→ Step 1: 建立 Trie 節點 // 初始化 Trie\n→ Step 2: 將每個 root 插入 Trie // 構造前綴樹\n→ Decision: 是否還有 root? ...\nBut better to present as loops.\n\nWe can present:\n\nStart\n→ Step 1: 建立空 Trie root node // 初始化根節點\n→ Step 2: For each root in dictionary:\n    → Step 2.1: Set node = Trie root\n    → Step 2.2: For each char in root:\n        → Step 2.2.1: If node 沒有 child char, create\n        → Step 2.2.2: node = child\n    → Step 2.3: node.isEnd = true // 標記字根結束\n→ Step 3: Split sentence into words // 用空格分隔\n→ Step 4: For each word in words:\n    → Step 4.1: Set node = Trie root\n    → Step 4.2: Set prefix = \"\"\n    → Step 4.3: For each char in word with index i:\n        → Decision: node 有 child char?\n            Yes → node = child, prefix += char\n            No → break // 無前綴匹配\n        → Decision: node.isEnd?\n            Yes → break // 找到最短根\n    → Step 4.4: If node.isEnd:\n        → Step 4.5: Replace word with prefix\n    → Step 4.6: Append word to result list\n→ Step 5: Join result list with spaces // 重組句子\n→ End\n\nWe must adhere to the output format: each line like \"虛擬碼步驟 // 解釋\". Use arrows \"→\" inside? According to example, they use \"→ Step 1:\" etc. We'll follow.\n\nWe need to include \"Decision:\" lines with Yes→ and No→.\n\nWe should also maintain indentation.\n\nLet's produce. Use comments with //.\n\nMake sure each line ends with // 解釋/說明. We'll use Chinese. Provide each line accordingly.\n\nLet's craft.\n\nAlso maybe include an End step. Good.\n\nWe'll output in the format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空 Trie 節點 // 初始化 Trie 根節點  \n→ Step 2: For each root in dictionary  \n    → Step 2.1: Set node = Trie root // 重新從根節點開始  \n    → Step 2.2: For each char in root  \n        → Step 2.2.1: If node 沒有 child char, 則建立新節點 // 為字根新增節點  \n        → Step 2.2.2: node = node.child[char] // 移動到子節點  \n    → Step 2.3: node.isEnd = true // 標記字根結束位置  \n→ Step 3: Split sentence into words // 用空格分割句子得到單字列表  \n→ Step 4: For each word in words  \n    → Step 4.1: Set node = Trie root // 從根節點開始搜尋前綴  \n    → Step 4.2: Set prefix = \"\" // 用於收集匹配到的前綴字母  \n    → Step 4.3: For each char in word with index i  \n        → Decision: node 有 child char? // 檢查當前字母是否為前綴  \n            Yes → node = node.child[char] // 移動至對應子節點  \n            No  → break // 無法繼續匹配，終止搜尋  \n        → Decision: node.isEnd? // 判斷是否已經匹配到完整字根  \n            Yes → break // 找到最短字根，停止搜尋  \n        → Step 4.3.1: prefix += char // 收集匹配的字母  \n    → Step 4.4: If node.isEnd  \n        → Step 4.5: Replace word with prefix // 用找到的字根替換原單字  \n    → Step 4.6: Append word to result list // 將處理後的單字加入結果  \n→ Step 5: Join result list with spaces // 用空格重新組成句子  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[None,0,4,4,1,1,4,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[None, 0, 4, 4, 1, 1, 4, 0]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().splitlines()\n    if not data:\n        sys.exit()\n    ops = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1]) if len(data) > 1 else []\n\n    obj = None\n    results = []\n\n    for idx, op in enumerate(ops):\n        if op == \"Solution\":\n            args = args_list[idx]\n            obj = Solution(*args)\n            results.append(None)\n        elif op == \"pick\":\n            results.append(obj.pick())\n        else:\n            results.append(None)\n\n    print(results)",
      "virtual_code": "Thinking...\nWe need produce pseudocode for solution with random pick, mapping. Approach: map blacklisted numbers in [0, n-1] to whitelist in high part [n-B..n-1] that are not blacklisted. Preprocess in constructor.\n\nPseudocode: Start. Step1: store n, blacklist, compute B=blacklist.size. Build set of blacklist. Build mapping: for each b in blacklist where b < n-B: add mapping from b to next available high value not in blacklist. Use pointer from n-1 downwards.\n\nPick: generate random r in [0, n-B-1]. If r in mapping, return mapping[r], else return r.\n\nEnd.\n\nNeed to include random function calls minimal.\n\nNow produce each line as per format.\n\nMake sure to include Start and End.\n\nUse lines like: Start // 程式開始執行\n\n→ Step 1: 將 n 與 blacklist 存入成員變數 // 初始化物件\n\n→ Step 2: 計算 B = blacklist.length // 黑名單長度\n\n→ Step 3: 建立 HashSet blacklistSet 並加入 blacklist 所有元素 // 用於快速查詢\n\n→ Step 4: 建立 Map mapping // 用於將低區域黑名單映射到高區域白名單\n\n→ Step 5: 設置 ptr = n-1 // 高區域指標，從最高值往下尋找可用數字\n\n→ Decision: 是否有黑名單元素? // 只在 B>0 時進行映射\n\n    Yes → For each b in blacklist\n\n        Decision: b < n-B? // 只映射低區域黑名單\n\n            Yes → Decision: 是否已經找到合適的高區域白名單?\n\n                Yes → // 這裡已經完成映射\n\n                No → While ptr in blacklistSet: ptr-- // 跳過黑名單\n\n            → mapping[b] = ptr // 把 b 映射到 ptr\n\n            → ptr-- // 指標往下移\n\n        No → // b 在高區域，已經不需要映射\n\n    No → // B 為 0，無需映射\n\n→ End // 建構完成\n\nPick 函式:\n\n→ Function pick() // 呼叫時返回隨機合法整數\n\n    → Step 1: 產生隨機數 r = random(0, n-B-1) // 只呼叫一次 random\n\n    → Decision: r 在 mapping 中? // 判斷是否需要映射\n\n        Yes → Return mapping[r] // 返回映射值\n\n        No  → Return r // 直接返回 r\n\nEnd\n\nBut we need to produce each line with \"虛擬碼步驟\" + // 解釋.\n\nAlso use arrows. Use \"Decision:\" lines.\n\nWe need to output line by line. Let's craft each line.\n\nWe'll use indent for decisions? In example, indentation shown with spaces. We should replicate similar.\n\nWe must not output real code.\n\nWe'll use \"Step\" or \"Decision\" lines.\n\nBe careful: \"→\" preceding each step except Start? In example, Start line no arrow. Then \"→ Step 1: ...\".\n\nWe'll maintain that.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 將 n 與 blacklist 存入成員變數 // 初始化物件\n→ Step 2: 計算 B = blacklist.length // 黑名單長度\n→ Step 3: 建立 HashSet blacklistSet 並加入 blacklist 所有元素 // 用於快速查詢\n→ Step 4: 建立 Map mapping // 用於將低區域黑名單映射到高區域白名單\n→ Step 5: 設置 ptr = n-1 // 高區域指標，從最高值往下尋找可用數字\n→ Decision: 是否有黑名單元素? // 只在 B>0 時進行映射\n    Yes → For each b in blacklist\n        Decision: b < n-B? // 只映射低區域黑名單\n            Yes → While ptr 在 blacklistSet? // 跳過黑名單\n                Yes → ptr-- // 指標往下移\n                No → // ptr 已是合法白名單\n            → mapping[b] = ptr // 把 b 映射到 ptr\n            → ptr-- // 指標往下移\n            No → // b 在高區域，已經不需要映射\n    No → // B 為 0，無需映射\nEnd // 建構完成\n\nBut we need to ensure each line is single statement. Might need to split loops into separate steps.\n\nBut they requested \"逐行地產生對應的虛擬碼\" - each line is a step. So loops may be represented by iteration over each element. We can keep loop steps as lines with \"→ For each b in blacklist\" then inside indent lines.\n\nNeed to be careful to include \"Decision\" lines.\n\nLet's craft more structured:\n\nStart // 程式開始執行\n→ Step 1: n ← input n; blacklist ← input blacklist // 取得參數\n→ Step 2: B ← blacklist.length // 黑名單長度\n→ Step 3: blacklistSet ← new Set() // 建立黑名單集合\n    → For each x in blacklist\n        → blacklistSet.add(x) // 加入集合\n→ Step 4: mapping ← new Map() // 建立映射表\n→ Step 5: ptr ← n - 1 // 設定高區域指標\n→ Decision: B > 0? // 若有黑名單則進行映射\n    Yes → For each b in blacklist\n        Decision: b < n - B? // 只處理低區域黑名單\n            Yes → Decision: ptr in blacklistSet? // 找到高區域白名單\n                Yes → ptr ← ptr - 1 // 跳過黑名單\n                No  → // ptr 為合法白名單\n            → mapping.set(b, ptr) // 映射 b 到 ptr\n            → ptr ← ptr - 1 // 指標往下移\n            No → // b 在高區域，不需要映射\n    No  → // 無黑名單，跳過映射\nEnd // 建構完成\n\nThen pick function:\n\n→ Function pick() // 定義 pick 方法\n    → r ← randomInt(0, n - B - 1) // 產生隨機數\n    → Decision: mapping.containsKey(r)? // 判斷是否需要映射\n        Yes → Return mapping.get(r) // 返回映射值\n        No  → Return r // 直接返回 r\nEnd // pick 方法結束\n\nBut we need to include \"Start\" for pick function? They didn't ask for a separate Start/End for function. Could use \"→ Function pick()\" then lines.\n\nBut the example shows Start and End for the entire program.\n\nWe can still add \"Start\" and \"End\" for program. We'll keep them as above.\n\nBut we might not need separate Start/End inside pick. Use function definition.\n\nLet's refine lines to follow arrow format exactly.\n\nUse \"→\" for all steps except \"Start\".\n\nAlso use \"Decision:\" lines properly. Use \"Yes →\" and \"No →\".\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n ← input n; blacklist ← input blacklist // 取得參數\n→ Step 2: B ← blacklist.length // 黑名單長度\n→ Step 3: blacklistSet ← new Set() // 建立黑名單集合\n    → For each x in blacklist\n        → blacklistSet.add(x) // 加入集合\n→ Step 4: mapping ← new Map() // 建立映射表\n→ Step 5: ptr ← n - 1 // 設定高區域指標\n→ Decision: B > 0? // 若有黑名單則進行映射\n    Yes → For each b in blacklist\n        Decision: b < n - B? // 只處理低區域黑名單\n            Yes → Decision: ptr in blacklistSet? // 找到高區域白名單\n                Yes → ptr ← ptr - 1 // 跳過黑名單\n                No  → // ptr 為合法白名單\n            → mapping.set(b, ptr) // 映射 b 到 ptr\n            → ptr ← ptr - 1 // 指標往下移\n            No → // b 在高區域，不需要映射\n    No  → // 無黑名單，跳過映射\nEnd // 建構完成\n\n→ Function pick() // 定義 pick 方法\n    → r ← randomInt(0, n - B - 1) // 產生隨機數\n    → Decision: mapping.containsKey(r)? // 判斷是否需要映射\n        Yes → Return mapping.get(r) // 返回映射值\n        No  → Return r // 直接返回 r\nEnd // pick 方法結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp45w7a1_z.py\", line 69, in <module>\n    main()\n  File \"/tmp/tmp45w7a1_z.py\", line 47, in main\n    args = ast.literal_eval('[' + m.group(2) + ']')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass TrieNode:\n    __slots__ = ('children', 'sum')\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_vals = {}\n\n    def insert(self, key: str, val: int) -> None:\n        old_val = self.key_vals.get(key, 0)\n        self.key_vals[key] = val\n        delta = val - old_val\n\n        node = self.root\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the two lists (operations and arguments)\n    m = re.search(r'\\[(.*?)\\]\\s*,\\s*\\[(.*?)\\]', data, re.S)\n    if not m:\n        return\n\n    ops = ast.literal_eval('[' + m.group(1) + ']')\n    args = ast.literal_eval('[' + m.group(2) + ']')\n\n    obj = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == 'MapSum':\n            obj = MapSum()\n            outputs.append('null')\n        elif op == 'insert':\n            key, val = arg\n            obj.insert(key, val)\n            outputs.append('null')\n        elif op == 'sum':\n            # arg can be a list like [\"ap\"] or a single string\n            prefix = arg[0] if isinstance(arg, (list, tuple)) else arg\n            res = obj.sum(prefix)\n            outputs.append(str(res))\n\n    print('[' + ', '.join(outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for MapSum design: typical prefix sum using Trie storing sums. We need step-by-step algorithm, not actual code. Use virtual code lines: Start, steps, Decision, etc. Provide explanation per line.\n\nWe need to describe initialization, insert, sum functions. Also need to mention maintaining a dictionary of keys to values to handle overrides, and trie nodes with sum accumulation. So we produce a pseudocode with lines like:\n\nStart // Program start\n→ Step 1: Define Node with children map and sum // Trie node structure\n→ Step 2: Define MapSum class with root node, key map // Data structures\n\nThen methods:\n\nInsert:\n→ Step: Record old value = keyMap.getOrDefault(key, 0)\n→ Step: keyMap[key] = val\n→ Step: delta = val - oldVal\n→ Step: node = root\n→ Step: for each char in key: if child missing create new node; node = child; node.sum += delta\n\nSum:\n→ Step: node = root\n→ Step: for each char in prefix: if child missing return 0; node = child\n→ Step: return node.sum\n\nWe must adhere to format: Each line: virtual code step + space + // explanation\n\nUse arrows \"→\" and \"Decision:\" where needed. For loops we may show \"For each character\".\n\nWe need to list steps in order of design. Not actual code, but pseudocode steps.\n\nMake sure to include \"Start\" and \"End\". Use \"Decision:\" where conditional. Use indentation maybe not needed, but we can show nested steps.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 定義 TrieNode 類別，包含 children(字典) 與 sum(累計值) // 建立樹結構節點\n\n→ Step 2: 定義 MapSum 類別，內部成員 root(TrieNode) 與 map(key→value) // 初始化資料結構\n\n→ Step 3: MapSum() 初始化 root 為新 TrieNode，map 為空字典 // 建構子\n\nInsert 方法:\n\n→ Step 4: insert(key, val) // 接收 key 與 val\n\n→ Step 5: oldVal = map.getOrDefault(key, 0) // 取得舊值（若不存在則 0） // 供覆寫時計算差值\n\n→ Step 6: map[key] = val // 更新 key 與值\n\n→ Step 7: delta = val - oldVal // 計算值變更量\n\n→ Step 8: node = root // 從根節點開始\n\n→ Step 9: for char in key: // 逐字處理\n\n    → Decision: 如果 node.children 沒有 char? // 判斷子節點是否存在\n\n        Yes → node.children[char] = new TrieNode() // 建立新節點\n\n        No →  // 直接使用已存在的子節點\n\n    → Step 10: node = node.children[char] // 移動至子節點\n\n    → Step 11: node.sum += delta // 更新路徑上所有節點的累計值\n\n→ End // insert 方法完成\n\nSum 方法:\n\n→ Step 12: sum(prefix) // 接收前綴\n\n→ Step 13: node = root // 從根節點開始\n\n→ Step 14: for char in prefix: // 逐字查找前綴\n\n    → Decision: 如果 node.children 沒有 char? // 前綴不存在\n\n        Yes → Return 0 // 沒有符合的 key，總和為 0\n\n        No →  // 仍繼續\n\n    → Step 15: node = node.children[char] // 移動至子節點\n\n→ Step 16: Return node.sum // 前綴下所有 key 的值總和\n\nEnd // 程式結束\n\nWe need to ensure each line has \"虛擬碼步驟\" followed by space and // 解釋.\n\nThus we need to output each line as \"Start // ...\" etc.\n\nWe also need to include \"→\" for steps, \"Decision:\" for decisions.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 類別，包含 children(字典) 與 sum(累計值) // 建立樹結構節點  \n→ Step 2: 定義 MapSum 類別，內部成員 root(TrieNode) 與 map(key→value) // 初始化資料結構  \n→ Step 3: MapSum() 初始化 root 為新 TrieNode，map 為空字典 // 建構子  \n\n→ Step 4: insert(key, val) // 接收 key 與 val  \n→ Step 5: oldVal = map.getOrDefault(key, 0) // 取得舊值（若不存在則 0）  \n→ Step 6: map[key] = val // 更新 key 與值  \n→ Step 7: delta = val - oldVal // 計算值變更量  \n→ Step 8: node = root // 從根節點開始  \n→ Step 9: for char in key: // 逐字處理  \n  Decision: 如果 node.children 沒有 char? // 判斷子節點是否存在  \n   Yes → node.children[char] = new TrieNode() // 建立新節點  \n   No  →  // 直接使用已存在的子節點  \n  Step 10: node = node.children[char] // 移動至子節點  \n  Step 11: node.sum += delta // 更新路徑上所有節點的累計值  \n→ End // insert 方法完成  \n\n→ Step 12: sum(prefix) // 接收前綴  \n→ Step 13: node = root // 從根節點開始  \n→ Step 14: for char in prefix: // 逐字查找前綴  \n  Decision: 如果 node.children 沒有 char? // 前綴不存在  \n   Yes → Return 0 // 沒有符合的 key，總和為 0  \n   No  →  // 仍繼續  \n  Step 15: node = node.children[char] // 移動至子節點  \n→ Step 16: Return node.sum // 前綴下所有 key 的值總和  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.6816215573578108,0.0820336561754027],[-0.6527166496729417,0.3347822259854296],[0.014734478983368982,-0.5444791884611032]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.6816215573578108, 0.0820336561754027], [-0.6527166496729417, 0.3347822259854296], [0.014734478983368982, -0.5444791884611032]]'"
        }
      ],
      "generated_code": "import sys, json, math, random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n    obj = None\n    res = []\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            res.append(None)\n        elif cmd == \"randPoint\":\n            res.append(obj.randPoint())\n        else:\n            res.append(None)\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step-by-step. The requirement: Given radius and center, implement Solution class with constructor and randPoint method. randPoint should return random point inside circle uniformly. Steps: generate random radius sqrt(u)*R, random angle theta uniform [0,2π), convert to x, y add center. Provide pseudo-code lines with explanations. Use Start, End, Decision. Also structure.\n\nWe'll produce lines like:\n\nStart\n→ Step 1: Define class Solution // class definition\n→ Step 2: Constructor(radius, x_center, y_center): store radius and center // store values\n→ Step 3: randPoint(): // method to generate point\n→   Decision: 需要生成隨機角度θ和半徑r\n    Yes → Step 4: 隨機生成 u in [0,1] // uniform random\n    Yes → Step 5: 計算 r = radius * sqrt(u) // adjust radius distribution\n    Yes → Step 6: 隨機生成 θ in [0, 2π] // uniform angle\n    Yes → Step 7: 計算 x = x_center + r * cos(θ) // convert polar to cartesian\n    Yes → Step 8: 計算 y = y_center + r * sin(θ) // same\n    Yes → Step 9: 返回 [x, y] // output point\nEnd\n\nBut need to follow output format exactly: \"Start\" first line. Then lines starting with \"→\" or \"→ Decision:\" etc. Provide explanation comment after space. Should not produce actual code, just pseudocode.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 建構子: Solution(radius, x_center, y_center) // 初始化半徑與中心座標\n→ Step 3: randPoint() 方法 // 生成隨機點\n→   Decision: 需要先生成隨機角度和半徑? // 判斷流程\n        Yes → Step 4: 隨機生成 u ∈ [0,1] // 基本均勻隨機數\n        Yes → Step 5: 計算 r = radius * sqrt(u) // 調整半徑分佈\n        Yes → Step 6: 隨機生成 θ ∈ [0, 2π] // 均勻角度\n        Yes → Step 7: 計算 x = x_center + r * cos(θ) // 從極座標轉到笛卡兒\n        Yes → Step 8: 計算 y = y_center + r * sin(θ) // 同上\n        Yes → Step 9: 返回 [x, y] // 傳回隨機點\nEnd // 程式執行結束\n\nBut also include maybe \"Decision\" block inside method, but we can keep simple. According to format, \"Decision:\" line then indent Yes → and No → lines. We have only Yes path.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 建構子: Solution(radius, x_center, y_center) // 儲存半徑與中心座標\n→ Step 3: 方法 randPoint() // 產生隨機點\n→   Decision: 是否需要先產生隨機角度與半徑? // 確認流程開始\n        Yes → Step 4: 隨機生成 u ∈ [0,1] // 產生均勻隨機數\n        Yes → Step 5: 計算 r = radius * sqrt(u) // 調整半徑分布以保證均勻\n        Yes → Step 6: 隨機生成 θ ∈ [0, 2π] // 產生均勻角度\n        Yes → Step 7: 計算 x = x_center + r * cos(θ) // 從極座標轉回笛卡兒\n        Yes → Step 8: 計算 y = y_center + r * sin(θ) // 同上\n        Yes → Step 9: 返回 [x, y] // 傳回隨機點\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[1,2,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [1, 2, 3], [2, 1, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)  # 原始陣列\n        self.nums = list(nums)      # 目前陣列（可做重置用）\n\n    def reset(self):\n        # 回傳原始陣列\n        return list(self.original)\n\n    def shuffle(self):\n        # Fisher-Yates 洗牌\n        shuffled = list(self.original)\n        n = len(shuffled)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 依照「list1, list2」格式拆分\n    # 第一個 '], ' 表示第一個 list 結束\n    split_index = data.find('],')\n    if split_index == -1:\n        raise ValueError(\"輸入格式錯誤\")\n    first_part = data[:split_index + 1]   # 包含第一個 ']'\n    second_part = data[split_index + 2:]  # 跳過 '],'\n\n    cmds = ast.literal_eval(first_part)\n    args_list = ast.literal_eval(second_part)\n\n    results = []\n    obj = None\n    for cmd, args in zip(cmds, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若有其他方法，可在此處處理\n            results.append(None)\n\n    # 將結果輸出為 JSON 格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for design algorithm: Fisher-Yates shuffle. Provide step-by-step. Virtual code: Start, Step for initialization, store original array copy, Step for reset, Step for shuffle using Fisher-Yates, End. Use Decision? maybe for loop. We'll produce with arrow. Provide comments. Use virtual code. No actual code. Just steps. Ensure each line has \" // \" explanation. Provide step numbering maybe. Use \"Start\" line, then \"→ Step 1\" etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收整數陣列 nums 並複製為原始配置 // 初始化並保存原始順序  \n→ Step 2: 將 nums 存入內部變數 currentArray // 用於之後的重置與打亂  \n→ Step 3: 定義 reset() 方法  \n  → Step 3.1: 將 currentArray 設為原始配置的複製物件 // 重新回到原始順序  \n  → Step 3.2: 回傳 currentArray // 回傳重置後的陣列  \n→ Step 4: 定義 shuffle() 方法  \n  → Step 4.1: 複製 currentArray 為 tempArray // 不改變原始陣列  \n  → Step 4.2: 設定 n 為 tempArray 的長度  \n  → Decision: 迴圈從 i = n - 1 到 1? // 進行 Fisher‑Yates 隨機化  \n   Yes → Step 4.3: 隨機選取 j 介於 0 與 i 之間 // 隨機索引  \n    → Step 4.4: 交換 tempArray[i] 與 tempArray[j] // 進行一次交換  \n    → Decision: i > 0? // 判斷是否還有元素需要處理  \n     Yes → Step 4.5: i ← i - 1 → 回到決策點  \n     No  → Step 4.6: 結束迴圈  \n  → Step 4.7: 回傳 tempArray // 回傳已打亂的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Comments",
      "source_file": "Leetcode/leetcode722.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"ab\"]'\nGot (Norm):      '[\"b\"]'\n--- (Raw) ---\nRaw Expected: '[\"ab\"]'\nRaw Got:      '[\"b\"]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\ndef remove_comments(source):\n    res = []\n    in_block = False\n    for line in source:\n        i = 0\n        new_line = []\n        while i < len(line):\n            # 進入區塊註解\n            if not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '*':\n                in_block = True\n                i += 2\n                continue\n            # 離開區塊註解\n            if in_block and i + 1 < len(line) and line[i] == '*' and line[i + 1] == '/':\n                in_block = False\n                i += 2\n                continue\n            # 行註解，直接跳過整行\n            if not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '/':\n                break\n            # 正常字元\n            if not in_block:\n                new_line.append(line[i])\n            i += 1\n        # 只在非區塊註解結束時，且行有有效內容時才加入結果\n        if new_line and not in_block:\n            res.append(''.join(new_line))\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if data.startswith('source'):\n        data = data[data.find('=') + 1:].strip()\n    try:\n        source = ast.literal_eval(data)\n    except Exception:\n        # 如果解析失敗，嘗試再次評估\n        source = ast.literal_eval(data)\n    result = remove_comments(source)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that solve removing comments from a C++ program given as array of strings source. Need to output algorithm steps. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow, etc.\n\nWe need to provide a step-by-step algorithm. Use a loop over lines, maintain a flag inBlockComment. For each line, iterate characters. When block starts, skip until end. When line comment, skip rest of line. Build output lines, ignoring empty lines.\n\nWe need to output in virtual code, not actual code. Use lines like \"Start // 程式開始執行\". Then \"→ Loop over lines: i from 0 to n-1 // 逐行處理\". Inside loop: \"→ If inBlockComment? // 判斷是否已進入區塊註解\" etc.\n\nWe need to produce step-by-step.\n\nMake sure to include decisions: Decision: if inBlockComment? Yes → skip? Actually when in block comment, we look for end.\n\nBetter: We can process each line char by char. Let's design algorithm:\n\nStart\n→ Initialize result list empty, inBlockComment = False\n→ For each line in source:\n    → If inBlockComment:\n        → Search for '*/' in line\n            → If found:\n                → Set inBlockComment = False\n                → Keep the part after '*/' (starting after it) to process (including rest of line)\n                → Set line to that suffix\n            → Else:\n                → Continue to next line (skip entire line)\n    → Now process line if not inside block:\n        → Initialize empty buffer\n        → Iterate over indices j\n            → If not inBlockComment:\n                → If substring j..j+1 == '//' :\n                    → Break (rest of line ignored)\n                → Else if substring j..j+1 == '/*' :\n                    → Set inBlockComment = True\n                    → Increment j by 1 to skip '*'\n                → Else:\n                    → Append char to buffer\n            → Else (shouldn't happen because we skip block lines)\n        → After loop, if buffer non-empty:\n            → Append buffer to result\n→ End\n\nBut we must also handle case where line comment starts while inside block comment? Actually if we are inside block comment, we ignore until end. So we don't process line comment inside block.\n\nAlso need to handle case where '/*' occurs inside block comment (ignored) and '*/' may appear inside block comment. But we treat only first '*/'.\n\nAlso need to ensure not to output empty lines.\n\nWe also need to handle '/*' that starts in a line that also contains other code after the end '*/', need to resume processing after end.\n\nEdge cases: '*/' might be in the middle of line: e.g., \"int a = 0; /* comment */ int b = 1;\". We skip comment and keep \" int b = 1;\".\n\nImplementation: when inBlockComment and find end, we need to set j index after end and resume scanning rest of line. Also handle case where '*/' might be followed by '//' or another '/*'.\n\nSimpler: In per-character loop, maintain a flag inBlockComment. If inBlockComment: look for '*/', when found set flag false and skip two chars; else skip char. This works.\n\nLet's produce virtual code accordingly.\n\nWe need to produce step-by-step lines, with \"→\" arrow. Use Decision lines for conditions.\n\nOk, produce. Let's start:\n\nStart // 程式開始執行\n→ Initialize result list res ← [] // 用於儲存處理後的程式碼行\n→ Initialize flag inBlock ← False // 是否處於區塊註解中\n→ Loop over each line s in source // 逐行處理原始程式碼\n    → Decision: inBlock? // 檢查目前是否已進入區塊註解\n        Yes → ProcessBlockLine(s) // 處理已進入區塊註解的行\n        No  → ProcessNormalLine(s) // 正常行的處理\n→ Return res // 輸出結果\nEnd // 程式結束\n\nWe need to define ProcessBlockLine and ProcessNormalLine as subroutines. Provide them.\n\nProcessBlockLine(s):\n    → Search for '*/' in s // 找尋區塊註解結束位置\n        If found:\n            → Set inBlock ← False // 離開區塊註解\n            → Set remainder ← substring after '*/' // 取結束後的剩餘字串\n            → ProcessNormalLine(remainder) // 從結束後重新開始處理\n        Else:\n            → Return // 本行全部被註解，跳過\n\nProcessNormalLine(s):\n    → Initialize buffer ← \"\" // 用於組裝該行可執行程式碼\n    → Loop over index i from 0 to length(s)-1\n        → Decision: inBlock? // 這個判斷實際上不會在此子程式中為真，因為已確保不處於區塊註解\n            Yes → (不會發生) \n            No  → ProcessChar(i)\n    → If buffer non-empty:\n        → Append buffer to res // 保存有效程式碼行\n\nProcessChar(i):\n    → Decision: s[i:i+2] == \"//\"? // 檢查是否為行註解開始\n        Yes → Return // 跳過此行剩餘部分\n        No  → Decision: s[i:i+2] == \"/*\"? // 檢查是否為區塊註解開始\n            Yes → Set inBlock ← True // 進入區塊註解\n                → i ← i + 1 // 跳過 '*'\n            No  → Append s[i] to buffer // 正常字元\n\nBut we need to implement incremental i; using while loop. Use i increment.\n\nAlso need to handle case when we encounter '/*' inside normal line but still after some code. After setting inBlock true, we skip '/*', and then continue scanning, but need to skip until end of block. In our per-char loop, once inBlock is true, subsequent characters will be ignored until we find '*/'. But the ProcessChar function only runs when inBlock false; once we set inBlock true, we need to handle the skipping of block comment inside same line. In per-char loop, we can do:\n\nwhile i < len(s):\n    if inBlock:\n        if s[i:i+2] == '*/':\n            inBlock = False\n            i += 2\n            continue\n        i += 1\n        continue\n    else:\n        if s[i:i+2] == '//':\n            break\n        if s[i:i+2] == '/*':\n            inBlock = True\n            i += 2\n            continue\n        buffer += s[i]\n        i += 1\n\nBut the earlier approach splitted lines: ProcessBlockLine and ProcessNormalLine; but maybe simpler to just use one per-char loop with inBlock.\n\nLet's produce algorithm accordingly.\n\nWe can produce subroutine ProcessLine(s):\n\n→ Initialize i ← 0\n→ While i < len(s):\n    → Decision: inBlock? \n        Yes → Decision: s[i:i+2] == '*/'? \n                Yes → Set inBlock ← False\n                     → i ← i + 2\n                No  → i ← i + 1\n        No  → Decision: s[i:i+2] == '//'?\n                Yes → Break // 跳過整行剩餘\n                No  → Decision: s[i:i+2] == '/*'?\n                        Yes → Set inBlock ← True\n                             → i ← i + 2\n                        No  → Append s[i] to buffer\n                             → i ← i + 1\n\nAfter loop, if buffer non-empty: append to res.\n\nThis covers all.\n\nAlso need to handle case where a line is fully within block comment: we skip entire line.\n\nAlso need to handle case where a line after block comment start may contain code after comment end: The loop will continue after setting inBlock false, then treat rest of line.\n\nOk.\n\nWe will produce virtual code accordingly.\n\nMake sure to include start, end, decision lines.\n\nWe can use a function ProcessLine(s) inside the loop. But we can also inline logic. But for readability, better to use subroutine.\n\nWe need to provide explanation for each line.\n\nLet's produce final output.\n\nEnsure each line uses arrow \"→\" at beginning except decisions indent properly. For decisions, show \"Decision:\" then arrow.\n\nBut our lines will be like:\n\nStart // 程式開始執行\n→ Initialize res ← [] // 用於儲存處理後的程式碼行\n→ Initialize inBlock ← False // 是否在區塊註解內\n→ Loop over each line s in source // 逐行處理原始程式碼\n    → ProcessLine(s) // 處理單行並更新結果與標誌\n→ Return res // 回傳無註解的程式碼行\nEnd // 程式結束\n\nThen define ProcessLine:\n\nProcessLine(s):\n    → i ← 0 // 字元索引\n    → buffer ← \"\" // 目前行的有效字元\n    → While i < len(s) // 逐字元檢查\n        → Decision: inBlock? // 目前是否在區塊註解\n            Yes → Decision: s[i:i+2] == '*/'? // 找到區塊結束\n                Yes → inBlock ← False // 離開區塊註解\n                    → i ← i + 2 // 跳過 '*/'\n                No  → i ← i + 1 // 繼續忽略字元\n            No  → Decision: s[i:i+2] == '//'? // 行註解開始\n                Yes → Break // 跳過此行剩餘\n                No  → Decision: s[i:i+2] == '/*'? // 區塊註解開始\n                    Yes → inBlock ← True // 進入區塊註解\n                        → i ← i + 2 // 跳過 '/*'\n                    No  → buffer ← buffer + s[i] // 正常字元加入\n                        → i ← i + 1\n    → Decision: buffer != \"\"? // 行是否有有效程式碼\n        Yes → res.append(buffer) // 加入結果\n        No  → (不操作) // 空行不輸出\n\nWe must ensure that the indentation of decisions etc. is clear.\n\nWe also need to output only virtual code lines; no actual code. So use placeholders like \"←\" assignment.\n\nLet's format accordingly. Use \"→\" arrow.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Initialize res ← [] // 用於儲存處理後的程式碼行\n→ Initialize inBlock ← False // 是否在區塊註解內\n→ Loop over each line s in source // 逐行處理原始程式碼\n    → ProcessLine(s) // 處理單行並更新結果與標誌\n→ Return res // 回傳無註解的程式碼行\nEnd // 程式結束\n\nProcessLine(s):\n    → i ← 0 // 字元索引\n    → buffer ← \"\" // 目前行的有效字元\n    → While i < len(s) // 逐字元檢查\n        → Decision: inBlock? // 目前是否在區塊註解\n            Yes → Decision: s[i:i+2] == '*/'? // 找到區塊結束\n                Yes → inBlock ← False // 離開區塊註解\n                    → i ← i + 2 // 跳過 '*/'\n                No  → i ← i + 1 // 繼續忽略字元\n            No  → Decision: s[i:i+2] == '//'? // 行註解開始\n                Yes → Break // 跳過此行剩餘\n                No  → Decision: s[i:i+2] == '/*'? // 區塊註解開始\n                    Yes → inBlock ← True // 進入區塊註解\n                        → i ← i + 2 // 跳過 '/*'\n                    No  → buffer ← buffer + s[i] // 正常字元加入\n                        → i ← i + 1\n    → Decision: buffer != \"\"? // 行是否有有效程式碼\n        Yes → res.append(buffer) // 加入結果\n        No  → (不操作) // 空行不輸出\n```"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])          # 加入目前的子集\n            for i in range(start, len(nums)):\n                path.append(nums[i])     # 包含 nums[i]\n                backtrack(i + 1, path)   # 進一步遞迴\n                path.pop()               # 回溯，移除 nums[i]\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析形如 \"nums = [1,2,3]\" 的輸入\n    parts = data.split('=', 1)\n    if len(parts) == 2:\n        nums_str = parts[1].strip()\n    else:\n        nums_str = parts[0].strip()\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception as e:\n        raise ValueError(\"輸入格式錯誤\") from e\n\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for generating power set of a unique integer array. Steps: start, input array, maybe sort? unique already. Then recursion or iterative. Virtual code steps with arrow and decision.\n\nWe need to output line by line, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc.\n\nWe'll produce something like:\n\nStart\n→ Step 1: Define function generatePowerSet(nums) // entry\n→ Step 2: Initialize result = [] // store subsets\n→ Step 3: Define recursive helper(index, current) // recursion\n→ Decision: 如果 index == len(nums)?\n    Yes → Step 4: Append current to result // add subset\n    No  → Step 5: // include current element\n        → Step 6: Call helper(index+1, current + [nums[index]]) // include\n        → Step 7: Call helper(index+1, current) // exclude\n→ Step 8: Call helper(0, []) // start recursion\n→ Step 9: Return result // final output\nEnd\n\nWe need each line with arrow or structure. Use \"Decision:\" line with indentation? In example, indentation indicated by spaces maybe. We can do as:\n\nStart // 程式開始執行\n→ Step 1: Define function generatePowerSet(nums) // 進入點\n→ Step 2: Initialize result = [] // 儲存所有子集\n→ Step 3: Define recursive helper(index, current) // 參數: 當前索引、已構造子集\n→ Decision: 如果 index == len(nums)?\n    Yes → Step 4: Append current to result // 完成一個子集\n    No  → Step 5: // 包含或不包含當前元素\n        → Step 6: helper(index+1, current + [nums[index]]) // 包含\n        → Step 7: helper(index+1, current) // 不包含\n→ Step 8: Call helper(0, []) // 開始遞迴\n→ Step 9: Return result // 回傳所有子集\nEnd // 程式結束\n\nEnsure each line includes 虛擬碼步驟 + space + // 解釋. Use the arrow for decisions. Provide indentation with spaces. Ensure we adhere to format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 generatePowerSet(nums) // 進入點  \n→ Step 2: 初始化 result = [] // 用來儲存所有子集  \n→ Step 3: 定義遞迴輔助函式 helper(index, current) // index 為當前處理的索引，current 為已構造的子集  \n→ Decision: 如果 index == len(nums)? // 檢查是否已處理完所有元素  \n  Yes → Step 4: 將 current 加入 result // 完成一個子集  \n  No  → Step 5: // 決定是否包含目前元素  \n    → Step 6: helper(index+1, current + [nums[index]]) // 包含當前元素  \n    → Step 7: helper(index+1, current) // 不包含當前元素  \n→ Step 8: 呼叫 helper(0, []) // 從第一個元素開始遞迴  \n→ Step 9: 回傳 result // 傳回所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj7orftx1.py\", line 27, in <module>\n    ops = json.loads(m.group(1))\n          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 49 (char 48)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # 解析兩個 JSON 陣列 (操作名稱與對應參數)\n    m = re.match(r'\\s*(\\[.*\\])\\s*,\\s*(\\[.*\\])\\s*', raw)\n    if not m:\n        raise ValueError(\"輸入格式錯誤\")\n\n    ops = json.loads(m.group(1))\n    args = json.loads(m.group(2))\n\n    # 逐步執行操作，並收集結果\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            # arg 是 [[-2,0,3,...]]，取第一個元素作為 nums\n            obj = NumArray(arg[0])\n            res.append(None)\n        else:\n            # 其餘方法直接呼叫\n            res.append(getattr(obj, op)(*arg))\n\n    # 轉換結果為 LeetCode 風格輸出\n    out = []\n    for v in res:\n        if v is None:\n            out.append(\"null\")\n        else:\n            out.append(str(v))\n    print(\"[\" + \", \".join(out) + \"]\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: implement a class with constructor and sumRange. This is typical LeetCode problem 303. Need to include steps: build prefix sum array. Provide operations.\n\nWe need to produce lines like:\n\nStart\n→ Step 1: Define class NumArray // class definition\n→ Step 2: Store original array in instance variable // keep nums\n→ Step 3: Create prefix sum array prefix of size n+1 // to answer queries\n→ Step 4: Initialize prefix[0] = 0 // base case\n→ Step 5: For i from 0 to n-1: prefix[i+1] = prefix[i] + nums[i] // build prefix sums\n→ End // initialization complete\n\nSumRange method:\n→ Step 6: Define method sumRange(left, right)\n→ Step 7: Return prefix[right+1] - prefix[left] // sum between left and right\n→ End\n\nWrap inside class. Use arrows.\n\nWe need to ensure format: \"虛擬碼步驟 [space] // 解釋\". Use arrow arrow \"→\" at beginning of each step, with \"Start\" and \"End\".\n\nWe'll produce each line. Probably need to separate constructor and method. Provide decision? Not needed.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 NumArray // 宣告要實作的資料結構  \n→ Step 2: 在類別內部定義屬性 nums // 用來儲存原始整數陣列  \n→ Step 3: 在類別內部定義屬性 prefix // 用於儲存前綴和陣列  \n→ Step 4: 定義建構子 NumArray(nums) // 初始化時會收到整數陣列  \n→ Step 5: 於建構子中將輸入陣列賦值給 this.nums // 保留原始資料  \n→ Step 6: 建立 prefix 陣列，長度為 nums.length + 1 // 前綴和長度多一個位置  \n→ Step 7: 設定 prefix[0] = 0 // 前綴和基底為 0，方便計算  \n→ Step 8: 從 i = 0 到 nums.length-1 逐一執行  \n    → Step 9: 計算 prefix[i+1] = prefix[i] + nums[i] // 累積前綴和  \n→ End // 建構子執行完畢，前綴和已建立  \n→ Step 10: 定義方法 sumRange(left, right) // 供查詢使用  \n→ Step 11: 直接回傳 prefix[right+1] - prefix[left] // 差值即為區間和  \n→ End // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxvwweac_.py\", line 30, in <module>\n    mat = ast.literal_eval(mat_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,0,0]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmuo5_n42.py\", line 30, in <module>\n    mat = ast.literal_eval(mat_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,0,0,0]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    text = sys.stdin.read()\n\n    mat_match = re.search(r'mat\\s*=\\s*(\\[[\\s\\S]*?\\])', text, re.MULTILINE)\n    k_match   = re.search(r'k\\s*=\\s*([0-9]+)', text, re.MULTILINE)\n\n    if mat_match and k_match:\n        mat_str = mat_match.group(1)\n        k_str   = k_match.group(1)\n        mat = ast.literal_eval(mat_str)\n        k   = int(k_str)\n    else:\n        # If the input format differs, fall back to a simple token-based parser.\n        tokens = text.strip().split()\n        # Expect: first two numbers m n, followed by m rows of n numbers, then k.\n        m, n = map(int, tokens[:2])\n        numbers = list(map(int, tokens[2:-1]))\n        k = int(tokens[-1])\n        mat = [numbers[i*n:(i+1)*n] for i in range(m)]\n\n    solution = Solution()\n    result = solution.kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: count soldiers per row, sort rows by (count, index). Then take first k. Virtual code line by line with explanations. Use Start, End, Decision, etc.\n\nLet's outline algorithm:\n\nStart\n→ Step 1: Initialize empty list rowsInfo\n→ Step 2: For each row index i from 0 to m-1:\n    → Step 2a: Count number of 1s in row mat[i] (since all 1s are left, can count until first 0)\n    → Step 2b: Append tuple (count, i) to rowsInfo\n→ Step 3: Sort rowsInfo by count ascending then index ascending\n→ Step 4: Extract first k indices from sorted rowsInfo into result\n→ End\n\nAlso need to handle binary property: all 1s before 0s. Counting could use binary search or linear scan. We'll just linear count until 0.\n\nImplement virtual code lines.\n\nWe must not output actual code, only virtual steps. Use arrows etc.\n\nWe need to use decision arrows? Not many decisions. Maybe inside counting: while j < n and mat[i][j] == 1: j++. That is loop, not decision.\n\nWe can use Decision for checking if j < n and mat[i][j] == 1? but that's part of loop condition.\n\nWe can represent loop as Step: While ... { ... }.\n\nBut the spec didn't mention loops explicitly; but we can show steps.\n\nLet's create:\n\nStart\n→ Step 1: rowsInfo ← empty list // 產生空列表存儲 (soldierCount, rowIndex)\n→ Step 2: For i ← 0 to m-1 // 遍歷每一行\n    → Step 2a: count ← 0 // 初始化此行兵力計數\n    → Step 2b: j ← 0 // 用於遍歷列\n    → Decision: j < n AND mat[i][j] == 1? // 判斷是否還是士兵\n        Yes → Step 2c: count ← count + 1 // 兵力+1\n        Yes → Step 2d: j ← j + 1 // 移到下一列\n        No  → Step 2e: Break // 列舉結束\n    → Step 2f: Append (count, i) to rowsInfo // 保存行資訊\n→ Step 3: Sort rowsInfo by count ascending then index ascending // 排序\n→ Step 4: result ← empty list // 儲存結果\n→ Step 5: For i ← 0 to k-1\n    → Step 5a: Append rowsInfo[i].index to result // 取前k行\n→ End // 完成\n\nBut we need to adhere to format: each line \"虛擬碼步驟 [space] // 解釋\". Also include arrows \"→\" etc. And \"Decision:\" for decision. Let's craft carefully.\n\nWe should maintain indentation? We can use tabs or spaces.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: rowsInfo ← [] // 初始化儲存每行的兵力及索引\n→ For i ← 0 to m-1 // 遍歷每一行\n    → Step 2a: count ← 0 // 兵力計數器\n    → Step 2b: j ← 0 // 列索引\n    → Decision: j < n AND mat[i][j] == 1? // 判斷當前為士兵\n        Yes → Step 2c: count ← count + 1 // 兵力+1\n        Yes → Step 2d: j ← j + 1 // 進行下一列\n        No  → Step 2e: Break // 列已結束，退出循環\n    → Step 2f: rowsInfo.append((count, i)) // 保存此行資訊\n→ Step 3: rowsInfo.sort(key = (count, index)) // 按兵力與索引排序\n→ Step 4: result ← [] // 用於存儲最弱的k行索引\n→ For t ← 0 to k-1 // 取前k項\n    → Step 5a: result.append(rowsInfo[t].index) // 加入結果\nEnd // 程式結束\n\nWe must ensure each line includes \"虛擬碼步驟\" then space then \"// explanation\". But above we had \"Start\" etc. The spec: \"每行必須包含：虛擬碼步驟 [空格] // 解釋/說明\". So each line must have code, space, then comment. For loops and decisions, we need to include arrow or \"Decision:\". Example: \"Decision: ...\" etc. Each line should be separate. Let's produce each line accordingly.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: rowsInfo ← [] // 初始化儲存每行的兵力及索引\n→ For i ← 0 to m-1 // 遍歷每一行\n    → Step 2a: count ← 0 // 兵力計數器\n    → Step 2b: j ← 0 // 列索引\n    → Decision: j < n AND mat[i][j] == 1? // 判斷是否為士兵\n        Yes → Step 2c: count ← count + 1 // 兵力+1\n        Yes → Step 2d: j ← j + 1 // 下一列\n        No  → Step 2e: Break // 離開循環\n    → Step 2f: rowsInfo.append((count, i)) // 保存此行資訊\n→ Step 3: rowsInfo.sort(key = (count, index)) // 按兵力與索引升序排序\n→ Step 4: result ← [] // 用於存儲最弱k行索引\n→ For t ← 0 to k-1 // 取前k項\n    → Step 5a: result.append(rowsInfo[t].index) // 加入結果\nEnd // 程式結束\n\nWe need to ensure each line ends with \"// explanation\". Yes.\n\nLet's double-check formatting: Each line must have \"虛擬碼步驟\" etc. For example \"Start\" is a virtual step. For \"Decision:\" we need \"Decision: ...\" Then nested steps \"Yes →\". In the example they used indentation inside decision.\n\nWe should maintain consistent indentation. The arrow \"→\" indicates next step. For nested, we can indent with spaces.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: rowsInfo ← [] // 初始化儲存每行的兵力及索引  \n→ For i ← 0 to m-1 // 遍歷每一行  \n  → Step 2a: count ← 0 // 兵力計數器  \n  → Step 2b: j ← 0 // 列索引  \n  → Decision: j < n AND mat[i][j] == 1? // 判斷當前為士兵  \n   Yes → Step 2c: count ← count + 1 // 兵力+1  \n   Yes → Step 2d: j ← j + 1 // 移到下一列  \n   No → Step 2e: Break // 列已結束，退出循環  \n  → Step 2f: rowsInfo.append((count, i)) // 保存此行資訊  \n→ Step 3: rowsInfo.sort(key = (count, index)) // 按兵力與索引升序排序  \n→ Step 4: result ← [] // 用於存儲最弱 k 行索引  \n→ For t ← 0 to k-1 // 取前 k 項  \n  → Step 5a: result.append(rowsInfo[t].index) // 加入結果  \nEnd // 程式結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Multiply two non‑negative integers represented as strings and return the product as a string.\n        The algorithm mimics the manual multiplication process and does not use Python's built‑in\n        big integer arithmetic.\n        \"\"\"\n        # Quick return if either operand is zero\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        # Result can be at most m + n digits long\n        pos = [0] * (m + n)\n\n        # Multiply each digit and add to the correct position in pos\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n\n                pos[p1] += sum_ // 10   # carry to the left\n                pos[p2] = sum_ % 10     # store the current digit\n\n        # Convert the result list to a string, skipping leading zeros\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result if result else '0'\n\n\nif __name__ == \"__main__\":\n    import sys\n    import re\n\n    data = sys.stdin.read()\n    # Extract numeric strings from the input, handling formats like:\n    # \"num1 = '2', num2 = '3'\" or simple \"123 456\" or two lines\n    nums = re.findall(r\"\\d+\", data)\n\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # Fallback to line‑by‑line or space‑separated input\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        elif len(parts) == 1:\n            # Only one number provided – second is considered zero\n            num1 = parts[0]\n            num2 = '0'\n        else:\n            # No numbers found – default to zero multiplication\n            num1 = num2 = '0'\n\n    solver = Solution()\n    print(solver.multiply(num1, num2))",
      "virtual_code": "Thinking...\nThe user wants pseudocode for multiplying two non-negative integers represented as strings, returning product as string. Cannot use built-in BigInteger or direct conversion. Provide line-by-line pseudocode with explanations. Use Start, End, Decision, etc. Use \"虛擬碼步驟\" and then comment. We need to follow the format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows. The pseudocode should reflect typical string multiplication algorithm: reverse strings, multiply digits, accumulate results in array of length m+n, handle carry, convert to string ignoring leading zeros. We need to produce steps line by line.\n\nAlso we need to start with Start, End, Decision. Possibly using loops: For each digit of num1 reversed, for each digit of num2 reversed, multiply and add to result array at position i+j. Then after loops, process carry across array. Then build result string. Remove leading zeros. If result is empty, return \"0\". Provide explanation for each line.\n\nWe need to ensure we adhere to format: each line has \"虛擬碼步驟\" plus a space and then comment. The step must include arrow \"→\". For loops, maybe \"→ For i from 0 to len(num1)-1\". For decision, use \"Decision:\".\n\nAlso we should not output actual code, but pseudocode. For readability, we can use bullet-like structure but each line must have code. The pseudocode might include indentation? But we just produce each line.\n\nWe need to produce an explanation for each line. Use concise explanation in Chinese.\n\nWe should show Start, then maybe \"→ Step 1: 將兩個字串倒轉\" etc. Use arrays: \"result ← array of zeros with size m+n\". Then nested loops. Then carry processing. Then building string.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: m ← length of num1 // 取得 num1 的長度\n→ Step 2: n ← length of num2 // 取得 num2 的長度\n→ Step 3: result ← array of zeros with size m+n // 建立結果儲存區\n→ Step 4: 將 num1 逆序存為 array1 // 方便從最低位開始運算\n→ Step 5: 將 num2 逆序存為 array2 // 同上\n→ Decision: 是否有任何一個字串為 \"0\"? // 檢查特殊情況\n    Yes → Step 6: return \"0\" // 任何一個為零，直接回傳零\n    No  → Proceed to multiplication\n→ Step 7: For i from 0 to m-1\n→ Step 8:    For j from 0 to n-1\n→ Step 9:        prod ← (digit(array1[i]) * digit(array2[j])) + result[i+j] // 乘法並加入已存在的累加值\n→ Step 10:       result[i+j] ← prod % 10 // 存下最低位\n→ Step 11:       result[i+j+1] ← result[i+j+1] + (prod // 10) // 把進位加到下一位置\n→ Step 12: End For // 結束內層迴圈\n→ Step 13: End For // 結束外層迴圈\n→ Step 14: Build answer string by traversing result from highest index to 0, skip leading zeros // 轉換為字串\n→ Step 15: If answer string empty then answer ← \"0\" // 若全零\n→ End // 程式執行結束\n\nNeed to ensure each line has comment. Use \"Step 6: return '0'\" etc.\n\nAlso mention \"digit(array1[i])\" etc. Might be too abstract but it's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← length(num1) // 取得 num1 的長度  \n→ Step 2: n ← length(num2) // 取得 num2 的長度  \n→ Step 3: result ← array of zeros with size m+n // 建立長度足夠的儲存區  \n→ Step 4: array1 ← reverse(num1) // 把 num1 逆序以便從最低位開始計算  \n→ Step 5: array2 ← reverse(num2) // 同樣把 num2 逆序  \n→ Decision: 是否存在 \"0\" 為輸入？ // 特殊情況檢查  \n Yes → Step 6: return \"0\" // 任一輸入為 0，直接回傳 0  \n No → Proceed to multiplication  \n→ Step 7: For i from 0 to m-1 // 外層迴圈，遍歷 num1 的每位  \n→ Step 8: For j from 0 to n-1 // 內層迴圈，遍歷 num2 的每位  \n→ Step 9:  prod ← (digit(array1[i]) * digit(array2[j])) + result[i+j] // 乘法結果加上先前累加值  \n→ Step 10:  result[i+j] ← prod % 10 // 取乘法結果的最低位存回同一位置  \n→ Step 11:  result[i+j+1] ← result[i+j+1] + (prod // 10) // 把進位加到下一位置  \n→ Step 12: End For // 結束內層迴圈  \n→ Step 13: End For // 結束外層迴圈  \n→ Step 14: ans ← \"\" // 初始化答案字串  \n→ Step 15: For k from m+n-1 downto 0 // 從最高位往低位遍歷 result  \n  If result[k] ≠ 0 or ans ≠ \"\" // 跳過前置 0，直到首次非 0  \n   ans ← ans + result[k] // 追加當前位  \n→ Step 16: End For // 結束遍歷  \n→ Decision: ans 是否為空？ // 判斷是否全為 0  \n Yes → Step 17: ans ← \"0\" // 若全零，答案為 \"0\"  \n No → Step 18: // ans 已正確構造  \n→ End // 程式執行結束"
    }
  ]
}