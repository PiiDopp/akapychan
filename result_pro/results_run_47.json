[
  {
    "source_file": "900.json",
    "problem_index_in_file": 0,
    "title": "安全除法",
    "description_snippet": "請寫一個程式，讓使用者輸入兩個整數 a 與 b，輸出 a / b 的結果。若輸入的資料非整數或除數為 0，請顯示錯誤提示『輸入錯誤或除數為 0』。程式必須使用 try / except 結構。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code outline: Steps: start, input a, input b, try division, catch exception or zero division, output result or error. Use try / except. Each line: 虛擬碼步驟 // 解釋.\n\nWe should follow format: Start // 程式開始執行\n→ Step 1: 輸入整數 a // ...\n→ Step 2: 輸入整數 b // ...\n→ Step 3: 開始 try // ...\n→ Decision: try success? maybe not. Actually we can have try block lines: 將 a / b 計算 // ...\n→ Decision: if no exception? Then output result, else catch exception: output error.\n\nBut we need to show try / except structure. We can express as: \n→ Step 3: try // 開始嘗試除法\n→   Step 3.1: 計算 a / b // 執行除法\n→   Step 3.2: 輸出結果 // 若成功，顯示結果\n→ except // 捕捉任何例外\n→   Step 3.3: 輸出錯誤訊息 // 若出現錯誤，顯示錯誤\n\nBut the virtual code may need to use Decision: If b == 0? Actually zero division triggers exception anyway. So maybe we can just rely on except.\n\nAlternatively we can show Decision: if a,b 為整數? But we don't check separately, except will capture ValueError.\n\nSimplify: Step 1: 輸入 a\nStep 2: 輸入 b\nStep 3: try\nStep 3.1: result ← a / b\nStep 3.2: 輸出 result\nStep 4: except\nStep 4.1: 輸出 '輸入錯誤或除數為 0'\nEnd\n\nLet's produce each line with arrow, using Start and End.\n\nEnsure each line: \"Start // 程式開始執行\"\n\nThen \"→ Step 1: 輸入整數 a // 從使用者處取得第一個整數\"\n\n\"→ Step 2: 輸入整數 b // 從使用者處取得第二個整數\"\n\n\"→ Step 3: try // 開始嘗試除法操作\"\n\n\"→   Step 3.1: 計算 a / b 并存儲結果 // 執行除法，若成功則進行下一步\"\n\n\"→   Step 3.2: 輸出結果 // 顯示 a 除以 b 的結果\"\n\n\"→ except // 捕捉任何除法相關或輸入錯誤\"\n\n\"→   Step 4: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤提示\"\n\n\"End // 程式執行結束\"\n\nBut need to maintain arrow for nested steps: Use indentation. Use \"→   Step\". That is fine.\n\nMake sure to include explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 a // 從使用者處取得第一個整數\n→ Step 2: 輸入整數 b // 從使用者處取得第二個整數\n→ Step 3: try // 開始嘗試除法操作\n→   Step 3.1: 計算 a / b 並存儲結果 // 執行除法，若成功則執行下一步\n→   Step 3.2: 輸出結果 // 顯示 a 除以 b 的結果\n→ except // 捕捉任何除法相關或輸入錯誤\n→   Step 4: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤提示\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取所有輸入，允許使用者以空格或換行分隔兩個整數\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    try:\n        # 轉成兩個整數\n        a, b = map(int, data.split())\n        # 計算除法並輸出\n        print(a / b)\n    except (ValueError, ZeroDivisionError):\n        # 捕捉輸入錯誤或除以 0 的情況\n        print('輸入錯誤或除數為 0')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "10 0",
          "expected_output": "輸入錯誤或除數為 0",
          "success": true,
          "output": "輸入錯誤或除數為 0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "900.json",
    "problem_index_in_file": 1,
    "title": "統計文字行數",
    "description_snippet": "請寫一個程式，開啟名為 data.txt 的檔案，讀取內容並輸出總共有幾行文字。若檔案不存在，請顯示『找不到檔案！』。請使用 with 語法搭配 try / except。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output line by line Virtual Code with explanations, following specified format: each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\", \"Yes →\", \"No →\" and structure \"Start\", \"End\", \"Decision:\". We need to reflect file reading with with, try/except, counting lines, error handling.\n\nSo produce: Start, then Decision: file exists? But we can try open file with try: open inside with. Then on success count lines. So:\n\nStart\n→ Decision: 是否嘗試開啟 data.txt? // start try block\n    Yes → Step: 用 with open('data.txt', 'r') as f: // open file\n        → Step: 計算行數 = 0 // 初始化行數\n        → Step: For each line in f: 行數++ // 累加\n        → Step: 輸出 行數 // 顯示總行數\n    No → Step: 捕捉 FileNotFoundError // 文件不存在\n        → Step: 輸出 '找不到檔案！'\nEnd\n\nBut we need explicit try/except. Use Decision: 試著開啟? But try/except structure: We can show Decision: 先進入 try block? It's okay. Use decision: try? But better:\n\nStart\n→ Decision: 開始 try? // 進入 try 區塊\n    Yes → Step: with open('data.txt', 'r') as f: // 打開文件\n        → Step: count = 0\n        → Step: for line in f: count += 1\n        → Step: print(count)\n    No → Step: except FileNotFoundError: // 捕捉異常\n        → Step: print('找不到檔案！')\nEnd\n\nBut we need to use arrow for yes and no. Maybe:\n\nStart\n→ Decision: 進入 try 區塊? // 開始嘗試開啟檔案\n    Yes → Step: with open('data.txt', 'r') as f: // 用 with 開啟\n        → Step: count = 0\n        → Step: for line in f: count += 1\n        → Step: print(count)\n    No → Step: except FileNotFoundError: // 檔案不存在\n        → Step: print('找不到檔案！')\nEnd\n\nBut need to include End after except? Probably after printing.\n\nNeed to ensure format. Each line must start with \"虛擬碼步驟\" then space then // 解釋. Use \"Start\" as line. So:\n\nStart // 程式開始執行\n→ Decision: 進入 try 區塊? // 開始嘗試開啟檔案\n    Yes → Step: with open('data.txt', 'r') as f: // 用 with 開啟檔案\n        → Step: count = 0 // 初始化計數\n        → Step: for line in f: count += 1 // 累加行數\n        → Step: print(count) // 輸出總行數\n    No → Step: except FileNotFoundError: // 捕捉檔案不存在異常\n        → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut indentation may be ambiguous; but we can indent lines after decision. Use spaces or newlines? Format example shows indentation using spaces before arrow lines inside decision. Use 4 spaces indent? The example used indentation:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nSo we replicate style: indent Yes / No lines by 4 spaces.\n\nThus:\n\nStart // 程式開始執行\n→ Decision: 進入 try 區塊? // 開始嘗試開啟檔案\n    Yes → Step: with open('data.txt', 'r') as f: // 用 with 開啟檔案\n        → Step: count = 0 // 初始化計數\n        → Step: for line in f: count += 1 // 累加行數\n        → Step: print(count) // 輸出總行數\n    No  → Step: except FileNotFoundError: // 捕捉檔案不存在異常\n        → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut we should indent after No as well.\n\nHowever, the No branch may include multiple lines: the except block. We can indent inside No block similarly.\n\nSo:\n\n    No  → Step: except FileNotFoundError: // 捕捉檔案不存在異常\n        → Step: print('找不到檔案！') // 顯示錯誤訊息\n\nWe must keep alignment. Also we need to ensure that the \"Step:\" part includes colon maybe.\n\nBut each line's arrow or indentation might have trailing spaces but okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 進入 try 區塊? // 開始嘗試開啟檔案  \n  Yes → Step: with open('data.txt', 'r') as f: // 用 with 開啟檔案  \n    → Step: count = 0 // 初始化行數計數  \n    → Step: for line in f: count += 1 // 每讀到一行行數加一  \n    → Step: print(count) // 輸出總行數  \n  No  → Step: except FileNotFoundError: // 捕捉檔案不存在異常  \n    → Step: print('找不到檔案！') // 顯示錯誤訊息  \nEnd // 程式結束",
      "generated_code": "def main():\n    \"\"\"\n    主程式：從檔案 data.txt 讀取內容並統計行數。\n    若檔案不存在，則輸出錯誤訊息。\n    \"\"\"\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 1 行",
          "success": true,
          "output": "檔案共有 1 行"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 0,
    "title": "表達式計算",
    "description_snippet": "請寫一個程式，輸入三個整數 a、b、c，計算並輸出結果：a + b * c 和 (a + b) * c。請觀察兩者的不同。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines following specified format. Provide steps: Start, input a,b,c, compute expr1 = a + b * c, expr2 = (a + b) * c, output both, End. Use arrows.\n\nWe must not output actual code, only virtual steps. Use Start, → Step, Decision etc.\n\nMake sure each line includes `虛擬碼步驟` + space + `// 解釋`. Use arrows: Start, → Step 1: 輸入整數 a、b、c // Get three integers. Then Step 2: 計算 expr1 = a + b * c // compute a + (b*c). Step 3: 計算 expr2 = (a + b) * c // compute (a+b)*c. Step 4: 輸出 expr1 // output result. Step 5: 輸出 expr2 // output result. End.\n\nWe need to produce each line accordingly.\n\nCheck format: Each line \"虛擬碼步驟 // 解釋\" with arrow? Use \"→\". The first line \"Start // 程式開始執行\". Next lines start with \"→\". So:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 a、b、c // 從使用者取得三個整數\n→ Step 2: 計算 expr1 = a + b * c // 先計算 b * c 再加上 a\n→ Step 3: 計算 expr2 = (a + b) * c // 先計算 a + b 再乘以 c\n→ Step 4: 輸出 expr1 // 顯示 a + b * c 的結果\n→ Step 5: 輸出 expr2 // 顯示 (a + b) * c 的結果\nEnd // 程式執行結束\n\nAlso include maybe decision? Not needed. Just simple.\n\nReturn in plain text.\n\nMake sure no extra formatting. Use bullet? No. Just lines.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 a、b、c // 從使用者取得三個整數  \n→ Step 2: 計算 expr1 = a + b * c // 先計算 b * c 再加上 a  \n→ Step 3: 計算 expr2 = (a + b) * c // 先計算 a + b 再乘以 c  \n→ Step 4: 輸出 expr1 // 顯示 a + b * c 的結果  \n→ Step 5: 輸出 expr2 // 顯示 (a + b) * c 的結果  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n\n    a, b, c = map(int, data[:3])\n\n    expr1 = a + b * c\n    expr2 = (a + b) * c\n\n    print(f\"a + b * c = {expr1}\")\n    print(f\"(a + b) * c = {expr2}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2 3 4",
          "expected_output": "a + b * c = 14\n(a + b) * c = 20",
          "success": true,
          "output": "a + b * c = 14\n(a + b) * c = 20"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 1,
    "title": "平均分配",
    "description_snippet": "小明有 n 顆糖果，要平均分給 m 個小朋友。請輸入 n 和 m，輸出每個小朋友分到幾顆糖果，剩下幾顆糖果沒有分完。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with arrow style. Use Start, End, Decision. Steps: input n, input m, compute quotient and remainder. Output.\n\nNeed to ensure each line ends with comment.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n (糖果總數) // 從使用者取得糖果數量\n→ Step 2: 輸入 m (小朋友數量) // 從使用者取得小朋友數量\n→ Step 3: 計算 quotient = n ÷ m // 每個小朋友分到的完整糖果數\n→ Step 4: 計算 remainder = n mod m // 未分完的糖果數\n→ Step 5: 輸出 \"每個小朋友分到 \" + quotient + \" 顆糖果\" // 顯示分配結果\n→ Step 6: 輸出 \"剩下 \" + remainder + \" 顆糖果\" // 顯示剩餘糖果\nEnd // 程式執行結束\n\nMake sure formatting.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n (糖果總數) // 從使用者取得糖果數量  \n→ Step 2: 輸入 m (小朋友數量) // 從使用者取得小朋友數量  \n→ Step 3: 計算 quotient = n ÷ m // 每個小朋友分到的完整糖果數  \n→ Step 4: 計算 remainder = n mod m // 未分完的糖果數  \n→ Step 5: 輸出 \"每個小朋友分到 \" + quotient + \" 顆糖果\" // 顯示分配結果  \n→ Step 6: 輸出 \"剩下 \" + remainder + \" 顆糖果\" // 顯示剩餘糖果  \nEnd // 程式執行結束",
      "generated_code": "def solve():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    per = n // m\n    left = n % m\n    sys.stdout.write(f\"每人={per} 剩下={left}\")\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "20 6",
          "expected_output": "每人=3 剩下=2",
          "success": true,
          "output": "每人=3 剩下=2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 0,
    "title": "模擬擲骰子遊戲",
    "description_snippet": "請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Each line: virtual code step + space + // explanation. Use arrows, Start, End, Decision etc.\n\nTask: function roll_dice(n) that uses random module to simulate n times a six-sided die, return list of results.\n\nWe need to output step by step pseudocode.\n\nWe should include import random.\n\nStructure:\n\nStart\n→ Step: Import random module\n→ Step: Define function roll_dice(n)\n   → Step: Initialize empty list results\n   → Decision: If n <= 0? // maybe check valid\n       Yes → Step: Return empty list // or error\n       No → Step: For i in range(n)\n           → Step: Generate random integer 1-6\n           → Step: Append to results\n   → Step: Return results\nEnd\n\nWe should use arrows for flow.\n\nLet's produce each line accordingly. Use virtual code arrow.\n\nMake sure to include indentation but maybe just use arrow. Eg:\n\nStart // 程式開始\n→ Step: Import random module // 載入 random\n\n→ Step: Define function roll_dice(n) // 建立函式\n\nWithin function, indent? We can use arrow again.\n\nBetter to use:\n\n→ Step: Function roll_dice(n) // 定義函式\n\n    → Step: results ← [] // 初始化結果列表\n\n    → Decision: n <= 0? // 檢查擲骰次數是否為正\n\n        Yes → Step: Return results // 若 n <= 0，直接回傳空列表\n\n        No  → Step: For i in 1..n // 迴圈擲骰\n\n            → Step: die ← random.randint(1,6) // 產生 1~6 隨機數\n\n            → Step: Append die to results // 儲存結果\n\n    → Step: Return results // 回傳所有結果\n\nEnd // 程式結束\n\nWe need each line to contain virtual code step and explanation separated by space.\n\nAlso need to use arrow symbol: →, Decision: If..., Yes →, No →. For loops use maybe \"→ Step: For i in 1..n\". That's okay.\n\nEnsure each line is single line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Import random module // 載入 random 供隨機數產生  \n→ Step: Define function roll_dice(n) // 建立擲骰函式  \n  → Step: results ← [] // 初始化結果列表  \n  → Decision: n <= 0? // 檢查擲骰次數是否為正  \n   Yes → Step: Return results // 若 n <= 0，直接回傳空列表  \n   No  → Step: For i in 1..n // 依次擲 n 次骰子  \n     → Step: die ← random.randint(1,6) // 產生 1 到 6 的隨機整數  \n     → Step: Append die to results // 將本次結果加入列表  \n  → Step: Return results // 回傳所有擲骰結果  \nEnd // 程式結束執行",
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if data:\n        exec(data)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,6,5,1,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 6, 5, 1, 4]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 1,
    "title": "計算程式執行時間",
    "description_snippet": "請使用 time 模組，寫一個函數 measure_time(func, *args)，用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps: Start, Step 1: import time module, Step 2: define function measure_time, Step 3: record start time, Step 4: call func with args, Step 5: record end time, Step 6: compute duration, Step 7: round to 3 decimal places, Step 8: return result. End.\n\nInclude decision? No decision needed. Just straightforward steps. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for sequence. Format: Start, → Step 1: ..., etc. Ensure correct arrow and indent for substeps if any. But no decision.\n\nReturn as per format.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: import time // 匯入 time 模組以取得時間功能\n→ Step 2: define function measure_time(func, *args) // 宣告 measure_time 函式，接收目標函式與任意參數\n→ Step 3: start_time ← time.time() // 記錄開始時刻的秒數\n→ Step 4: result ← func(*args) // 執行目標函式，並將結果存入 result\n→ Step 5: end_time ← time.time() // 記錄結束時刻的秒數\n→ Step 6: duration ← end_time - start_time // 計算執行所需秒數\n→ Step 7: rounded_duration ← round(duration, 3) // 將秒數四捨五入到小數點 3 位\n→ Step 8: return rounded_duration // 回傳四捨五入後的秒數\nEnd // 程式執行結束",
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func(*args) 執行所需的秒數，並回傳四捨五入到小數點 3 位的結果。\n    \"\"\"\n    start = time.time()          # 記錄開始時間\n    result = func(*args)         # 執行目標函式\n    end = time.time()            # 記錄結束時間\n    duration = end - start       # 計算耗時\n    return round(duration, 3)    # 四捨五入到 3 位小數\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    code = sys.stdin.read()\n    # 建立一個執行環境，已經把 time 與 measure_time 放進去\n    exec_namespace = {\n        \"time\": time,\n        \"measure_time\": measure_time\n    }\n    # 執行使用者輸入的程式碼\n    exec(code, exec_namespace)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 0,
    "title": "BMI 計算器\n",
    "description_snippet": "請撰寫一個程式，依序讀入使用者的姓名、身高（公分，float）、體重（公斤，float），計算 BMI = 體重(kg) / (身高(m))^2，並印出「<姓名> 的 BMI 為 <數值>」。數值四捨...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code with explanations in Chinese (Traditional). Each line: virtual step, space, comment. Use Start, End, Decision with arrow etc. Need to read name, height (float), weight (float). Compute BMI = weight / (height/100)^2. Round to one decimal. Print \"<name> 的 BMI 為 <value>\". Probably we need rounding; but no decision structure needed. Just sequence of steps.\n\nWe can use Step 1: Read Name; Step 2: Read Height; Step 3: Read Weight; Step 4: Convert height to meters; Step 5: Compute BMI; Step 6: Round BMI; Step 7: Output.\n\nNo loops or decisions. Just linear flow. Use arrow '→'.\n\nNeed to use Start, End.\n\nWe should ensure we use \"Step 1:\" etc. Provide explanation after //.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 讀入姓名 // 取得使用者輸入的姓名字串\n→ Step 2: 讀入身高（公分） // 取得使用者輸入的身高數值，型別為 float\n→ Step 3: 讀入體重（公斤） // 取得使用者輸入的體重數值，型別為 float\n→ Step 4: 將身高轉換為公尺 // 計算 height_m = height_cm / 100\n→ Step 5: 計算 BMI // BMI = weight / (height_m ^ 2)\n→ Step 6: 四捨五入至小數點後一位 // BMI = round(BMI, 1)\n→ Step 7: 輸出 \"<姓名> 的 BMI 為 <BMI>\" // 將姓名與 BMI 輸出\nEnd // 程式執行結束\n\nWe should use \"Step\" maybe \"Step X:\".\n\nWe need each line with \"虛擬碼步驟\" plus explanation. Ensure each line is one step.\n\nLet's produce that.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入姓名 // 取得使用者輸入的姓名字串  \n→ Step 2: 讀入身高（公分） // 取得使用者輸入的身高數值，型別為 float  \n→ Step 3: 讀入體重（公斤） // 取得使用者輸入的體重數值，型別為 float  \n→ Step 4: 將身高轉換為公尺 // 計算 height_m = height_cm / 100  \n→ Step 5: 計算 BMI // BMI = weight / (height_m ^ 2)  \n→ Step 6: 四捨五入至小數點後一位 // BMI = round(BMI, 1)  \n→ Step 7: 輸出 \"<姓名> 的 BMI 為 <BMI>\" // 將姓名與 BMI 輸出  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    name = input().strip()\n    height_cm = float(input().strip())\n    weight = float(input().strip())\n    height_m = height_cm / 100\n    bmi = weight / (height_m ** 2)\n    print(f\"{name} 的 BMI 為 {bmi:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Alice\n160\n50\n",
          "expected_output": "Alice 的 BMI 為 19.5\n",
          "success": true,
          "output": "Alice 的 BMI 為 19.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 1,
    "title": "兩數計算小工具\n",
    "description_snippet": "請撰寫一個程式，讀入一行包含兩個以空白分隔的整數，將其轉為 int 後，計算並輸出四個結果：和、差（第一個減第二個）、積、平均（保留到小數點後 1 位）。輸出格式固定為：\n和:<和> 差:<差> 積:...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with comments. Follow format: each line \"虛擬碼步驟 // 解釋\". Use Start, → Step..., Decision if needed. In this problem, it's straightforward. But still need to handle reading, conversion, calculation, average rounding. No actual code, just virtual steps.\n\nLet's design steps:\n\nStart\n→ Step 1: 讀取輸入行 // Get the input string\n→ Step 2: 使用空白分隔字串並轉為整數陣列 // Split and parse\n→ Step 3: 將兩個數字分別存為 a, b // assignment\n→ Step 4: 計算 sum = a + b // sum\n→ Step 5: 計算 diff = a - b // difference\n→ Step 6: 計算 prod = a * b // product\n→ Step 7: 計算 avg = (a + b) / 2.0 // average as float\n→ Step 8: 四捨五入 avg 到小數點後 1 位 // round\n→ Step 9: 產生輸出字串 \"和: sum 差: diff 積: prod 平均: avg\" // format\n→ Step 10: 輸出字串 // print\nEnd\n\nAlso we might include decision for rounding? But we can keep simple. Use virtual code with arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入行 // 取得使用者輸入的完整字串  \n→ Step 2: 使用空白分隔字串並轉為整數陣列 // 把字串拆成兩個整數  \n→ Step 3: 將兩個數字分別存為 a, b // 方便後續計算  \n→ Step 4: 計算 sum = a + b // 求兩數之和  \n→ Step 5: 計算 diff = a - b // 求第一個減第二個的差  \n→ Step 6: 計算 prod = a * b // 求兩數之積  \n→ Step 7: 計算 avg = (a + b) / 2.0 // 計算平均值（保留浮點）  \n→ Step 8: 四捨五入 avg 到小數點後 1 位 // 取得符合格式的平均值  \n→ Step 9: 產生輸出字串 \"和: sum 差: diff 積: prod 平均: avg\" // 依規則拼接文字  \n→ Step 10: 輸出字串 // 顯示最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取輸入的整行字串，移除尾端換行符號\n    line = sys.stdin.readline()\n    if not line:\n        return\n    # 用空白拆分成兩個子字串，並轉成整數\n    a_str, b_str = line.strip().split()\n    a = int(a_str)\n    b = int(b_str)\n    # 計算和、差、積\n    sum_val = a + b\n    diff_val = a - b\n    prod_val = a * b\n    # 計算平均值並保留一位小數\n    avg_val = (a + b) / 2\n    # 輸出符合格式的結果\n    print(f\"和:{sum_val} 差:{diff_val} 積:{prod_val} 平均:{avg_val:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 3\n",
          "expected_output": "和:15 差:9 積:36 平均:7.5\n",
          "success": true,
          "output": "和:15 差:9 積:36 平均:7.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 0,
    "title": "學生資料類別設計",
    "description_snippet": "請定義一個 Student 類別，具有屬性 name（姓名）與 score（分數）。\n1. 於 __init__() 建構子中初始化這兩個屬性。\n2. 定義方法 show_info()，輸出『XXX ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with comment. According to example, each line: `虛擬碼步驟 // 解釋`. Use arrow syntax etc. Need to create class definition, constructor, method, objects, method calls. Use virtual code steps. Start and End.\n\nLet's produce:\n\nStart\n→ Step 1: Define class Student // 定義 Student 類別\n→ Step 2: Define __init__() with parameters self, name, score // 建構子初始化屬性\n→ Step 3: Assign self.name = name // 設定姓名屬性\n→ Step 4: Assign self.score = score // 設定分數屬性\n→ Step 5: Define method show_info(self) // 方法顯示資訊\n→ Step 6: Print f\"{self.name} 的分數是 {self.score}\" // 輸出格式\n→ Step 7: Instantiate student1 = Student(\"Alice\", 90) // 建立第一個 Student 物件\n→ Step 8: Call student1.show_info() // 呼叫方法\n→ Step 9: Instantiate student2 = Student(\"Bob\", 85) // 建立第二個 Student 物件\n→ Step 10: Call student2.show_info() // 呼叫方法\nEnd\n\nBut we need to include \"虛擬碼步驟\" with arrow arrow. Example uses \"→ Step 1:\". Let's use that. The arrow symbol at each line is \"→\". Also the initial \"Start\" line no arrow. Then End. Good. Also include the explanation comments.\n\nThus final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class Student // 定義 Student 類別  \n→ Step 2: Define __init__(self, name, score) // 建構子，接收姓名與分數  \n→ Step 3: Assign self.name = name // 設定實例屬性 name  \n→ Step 4: Assign self.score = score // 設定實例屬性 score  \n→ Step 5: Define method show_info(self) // 定義顯示資訊的方法  \n→ Step 6: Print f\"{self.name} 的分數是 {self.score}\" // 輸出『XXX 的分數是 YYY』  \n→ Step 7: Instantiate student1 = Student(\"Alice\", 90) // 建立第一個 Student 物件  \n→ Step 8: Call student1.show_info() // 呼叫 show_info()  \n→ Step 9: Instantiate student2 = Student(\"Bob\", 85) // 建立第二個 Student 物件  \n→ Step 10: Call student2.show_info() // 呼叫 show_info()  \nEnd // 程式執行結束",
      "generated_code": "class Student:\n    def __init__(self, name, score):\n        \"\"\"初始化學生姓名與分數\"\"\"\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        \"\"\"輸出學生資訊\"\"\"\n        print(f'{self.name} 的分數是 {self.score}')\n\n\ndef main():\n    import sys\n\n    # 讀取所有非空白的輸入行\n    raw_lines = [line.strip() for line in sys.stdin if line.strip()]\n\n    # 若沒有輸入，使用預設資料\n    if not raw_lines:\n        students = [\n            Student('Alice', 90),\n            Student('Bob', 80)\n        ]\n    else:\n        students = []\n        # 解析每一行，假設格式為 \"姓名 分數\"\n        for line in raw_lines:\n            parts = line.split()\n            if len(parts) >= 2:\n                name = parts[0]\n                try:\n                    score = int(parts[1])\n                except ValueError:\n                    # 如果分數不是整數，跳過此行\n                    continue\n                students.append(Student(name, score))\n            # 若輸入行不足兩個學生，只處理已解析到的學生\n            if len(students) == 2:\n                break\n        # 若解析後學生數量不足兩個，補足預設值\n        while len(students) < 2:\n            students.append(Student('Alice', 90))\n\n    # 顯示所有學生資訊\n    for student in students:\n        student.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      'Alice的分數是90\\nAlice的分數是90'\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      'Alice 的分數是 90\\nAlice 的分數是 90'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 1,
    "title": "動物類別繼承",
    "description_snippet": "請設計一個父類別 Animal，包含方法 make_sound()，印出『動物發出聲音』。\n建立子類別 Dog 與 Cat：\n1. Dog 覆寫 make_sound()，輸出『汪汪！』。\n2. Ca...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce line-by-line virtual code steps with explanation. Use Start, End, Decision, arrow. No actual code. Use Chinese. Steps: Start, define Animal class with method make_sound, etc. Then define Dog and Cat overriding. Then instantiate objects. Then call methods. End.\n\nMake sure each line: virtual code step + space + // explanation.\n\nUse arrow arrow? The format example uses arrow \"→ Step 1: ...\" with no parentheses? Should follow example. Use \"→\" before each step.\n\nAlso use \"Decision:\" only for decisions. Not needed.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 父類別 Animal // 建立 Animal 類別  \n→ Step 2: Animal → Method: make_sound() // 定義動物發聲方法  \n→ Step 3: make_sound() → Print '動物發出聲音' // 預設動物聲音輸出  \n→ Step 4: 定義 子類別 Dog 繼承 Animal // 建立 Dog 類別  \n→ Step 5: Dog → Override: make_sound() // 覆寫發聲方法  \n→ Step 6: make_sound() → Print '汪汪！' // Dog 的聲音輸出  \n→ Step 7: 定義 子類別 Cat 繼承 Animal // 建立 Cat 類別  \n→ Step 8: Cat → Override: make_sound() // 覆寫發聲方法  \n→ Step 9: make_sound() → Print '喵～' // Cat 的聲音輸出  \n→ Step 10: 建立物件 dog = Dog() // 建立 Dog 物件  \n→ Step 11: 建立物件 cat = Cat() // 建立 Cat 物件  \n→ Step 12: 呼叫 dog.make_sound() // 執行 Dog 的聲音方法  \n→ Step 13: 呼叫 cat.make_sound() // 執行 Cat 的聲音方法  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Animal:\n    def make_sound(self):\n        \"\"\"動物發出聲音的預設實作。\"\"\"\n        print('動物發出聲音')\n\nclass Dog(Animal):\n    def make_sound(self):\n        \"\"\"Dog 覆寫的發聲方法。\"\"\"\n        print('汪汪！')\n\nclass Cat(Animal):\n    def make_sound(self):\n        \"\"\"Cat 覆寫的發聲方法。\"\"\"\n        print('喵～')\n\nif __name__ == \"__main__\":\n    # 讀取並忽略所有標準輸入，保持程式通用性\n    sys.stdin.read()\n\n    # 建立物件並呼叫各自的 make_sound() 方法\n    dog = Dog()\n    cat = Cat()\n    dog.make_sound()\n    cat.make_sound()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "汪汪！\n喵～",
          "success": true,
          "output": "汪汪！\n喵～"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 0,
    "title": "溫度判斷",
    "description_snippet": "請寫一個程式，輸入一個整數代表氣溫，並依下列規則輸出：\n- 小於 0：『冰點以下』\n- 0~29：『正常範圍』\n- 30~39：『炎熱』\n- 大於等於 40：『極端高溫』...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Each line: \"虛擬碼步驟\" space \"// 解釋\". Use Start, End, Decision, arrow etc. The code: Start, input integer (temperature), Decision: if temp<0 then output. Else Decision: if temp <=29 then output. Else Decision: if temp <=39 then output. Else output. Use proper arrow formatting.\n\nMake sure each line uses \"→\" arrow after start of line? Example format: \"→ Step 1: ...\" In example they use \"→ Step 1:\" after Start. Also nested decisions have indentation. We can show indentation using spaces? Use four spaces or tab? We'll show spaces.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入氣溫 // 從使用者取得氣溫值\n→ Decision: 氣溫 < 0? // 檢查是否低於冰點\n    Yes → Step 2: 輸出 '冰點以下' // 氣溫低於 0，輸出對應訊息\n    No  → Decision: 氣溫 <= 29? // 檢查是否在正常範圍\n        Yes → Step 3: 輸出 '正常範圍' // 氣溫在 0~29，輸出對應訊息\n        No  → Decision: 氣溫 <= 39? // 檢查是否炎熱\n            Yes → Step 4: 輸出 '炎熱' // 氣溫在 30~39，輸出對應訊息\n            No  → Step 5: 輸出 '極端高溫' // 氣溫 40 或以上，輸出對應訊息\nEnd // 程式執行結束\n\nCheck formatting: each line has \"→\" only at start of step/decision lines. In example they used \"→ Decision:\" after indentation. We'll keep same.\n\nMake sure to include arrows in each line. Provide explanation after //.\n\nMake sure each line is separate.\n\nReturn in final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入氣溫 // 從使用者取得氣溫值  \n→ Decision: 氣溫 < 0? // 檢查氣溫是否低於冰點  \n    Yes → Step 2: 輸出 '冰點以下' // 氣溫低於 0，輸出對應訊息  \n    No  → Decision: 氣溫 <= 29? // 檢查氣溫是否在正常範圍  \n        Yes → Step 3: 輸出 '正常範圍' // 氣溫在 0~29，輸出對應訊息  \n        No  → Decision: 氣溫 <= 39? // 檢查氣溫是否在炎熱範圍  \n            Yes → Step 4: 輸出 '炎熱' // 氣溫在 30~39，輸出對應訊息  \n            No  → Step 5: 輸出 '極端高溫' // 氣溫 40 或以上，輸出對應訊息  \nEnd // 程式執行結束",
      "generated_code": "def classify_temperature(temp: int) -> str:\n    \"\"\"根據氣溫範圍返回對應的描述文字。\"\"\"\n    if temp < 0:\n        return \"冰點以下\"\n    elif temp < 30:\n        return \"正常範圍\"\n    elif temp < 40:\n        return \"炎熱\"\n    else:\n        return \"極端高溫\"\n\ndef main() -> None:\n    \"\"\"主程序：從標準輸入讀取氣溫，輸出對應的文字。\"\"\"\n    # 讀取一行輸入，並轉換為整數\n    temp_input = input().strip()\n    try:\n        temperature = int(temp_input)\n    except ValueError:\n        # 若輸入不是有效整數，則直接返回\n        return\n    # 取得對應描述並輸出\n    result = classify_temperature(temperature)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "35",
          "expected_output": "炎熱",
          "success": true,
          "output": "炎熱"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 1,
    "title": "三數最大值",
    "description_snippet": "請寫一個程式，輸入三個整數，輸出其中最大的數字。不得使用 Python 內建 max()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants pseudo-code in the specified format. Provide steps line by line. Use Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrows as needed. They input three integers. Output max. No use max().\n\nWe'll write:\n\nStart\n→ Input a\n→ Input b\n→ Input c\n→ Decision: a >= b and a >= c?\n   Yes → Output a\n   No → Decision: b >= c?\n      Yes → Output b\n      No  → Output c\nEnd\n\nAlso maybe include variable names? Provide explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input a // 從使用者處讀取第一個整數  \n→ Input b // 從使用者處讀取第二個整數  \n→ Input c // 從使用者處讀取第三個整數  \n→ Decision: a ≥ b 且 a ≥ c? // 判斷 a 是否同時大於等於 b 和 c  \n    Yes → Output a // a 是最大值，輸出 a  \n    No  → Decision: b ≥ c? // 若 a 不是最大，判斷 b 是否大於等於 c  \n        Yes → Output b // b 是最大值，輸出 b  \n        No  → Output c // 若 b 也不是最大，c 必為最大值，輸出 c  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef find_max(a: int, b: int, c: int) -> int:\n    \"\"\"\n    找出三個整數中的最大值，不使用內建 max()。\n    \"\"\"\n    if a >= b and a >= c:\n        return a\n    elif b >= a and b >= c:\n        return b\n    else:\n        return c\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有數字，允許空白或換行分隔\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        # 若輸入不足三個數，則不進行計算\n        sys.exit(0)\n    a, b, c = map(int, data[:3])\n    result = find_max(a, b, c)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 25 7",
          "expected_output": "25",
          "success": true,
          "output": "25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 0,
    "title": "倍數輸出",
    "description_snippet": "請寫一個程式，輸入一個正整數 n，使用 for 迴圈搭配 range()，輸出 1~50 之間所有能被 n 整除的數字。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line, each line: virtual step + space + // explanation. Use arrows. Structure: Start, End, Decision. We need to use for loop and range. We'll do: Start, input n, maybe parse int. Then decision: n > 0? If yes proceed else error. Then for i in range(1,51): decision if i % n == 0? if yes output i. End. Must use virtual arrows.\n\nNeed to maintain format: \"→ Step 1: ...\" etc. Use arrow for decision. For loop may be \"→ Step: For i from 1 to 50\". We can denote Step. Let's produce.\n\nWe will keep step numbers optional? Use \"Step 1:\" etc. Use \"Decision:\" lines. Use arrow to specify branches: \"Yes →\", \"No →\". For loop no branches. Just iterate.\n\nLet's write.\n\nCheck input: Step 1: 輸入正整數 n // 取得使用者輸入\nDecision: n 大於 0? // 確認是正整數\nYes → Step 2: 建立迴圈 for i in 1..50 // 逐個檢查\n    Decision: i 能被 n 整除? // 判斷是否為倍數\n        Yes → Step 3: 輸出 i // 顯示能被 n 整除的數字\n        No  → // 什麼都不做，繼續迴圈\nEnd // 程式結束\n\nWe need to incorporate arrow indentation for decision branches. Use \"→ Decision:\" then nested \"Yes → Step\". Also for \"No\" maybe just comment.\n\nMake sure each line has explanation after //. Provide Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 n // 從使用者取得一個正整數  \n→ Decision: n 大於 0? // 確認輸入為正整數  \n    Yes → Step 2: 建立迴圈 for i in range(1, 51) // 逐個檢查 1~50 之間的數字  \n        → Decision: i 能被 n 整除? // 判斷 i 是否為 n 的倍數  \n            Yes → Step 3: 輸出 i // 顯示能被 n 整除的數字  \n            No  → // 什麼也不做，繼續迴圈  \n    No  → Step 4: 輸出 \"輸入的數字必須為正整數\" // 提示使用者輸入錯誤  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n\n    # 從標準輸入讀取一行數字\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 轉成整數\n    n = int(data)\n\n    # 產生 1~50 之間能被 n 整除的數字\n    divisible = [str(i) for i in range(1, 51) if i % n == 0]\n\n    # 輸出，數字之間以空格分隔\n    print(' '.join(divisible))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "7",
          "expected_output": "7 14 21 28 35 42 49",
          "success": true,
          "output": "7 14 21 28 35 42 49"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 1,
    "title": "密碼檢查",
    "description_snippet": "請寫一個程式，讓使用者重複輸入密碼，直到輸入正確的密碼 'python123' 為止。每次輸入錯誤都提示『密碼錯誤，請再試一次』，輸入正確時輸出『登入成功』。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with arrow, decision etc. Format: \"虛擬碼步驟 [space] // 解釋\". Use Start, End, Decision etc. Provide loop until correct password. Use while loop concept with decision inside. Each line: \"Start // 程式開始執行\". Then maybe \"→ Step 1: 設定正確密碼 'python123'\". \"→ LoopStart: 輸入密碼\". \"→ Decision: 輸入的密碼是否等於 'python123'?\" Yes -> \"→ Step 2: 輸出 '登入成功'\" \"→ End\". No -> \"→ Step 3: 輸出 '密碼錯誤，請再試一次'\" then \"→ LoopStart\" or back to loop. We need arrow to loop back: maybe \"→ LoopStart\". Use \"Decision:\" block with Yes → and No →. For loop we might label as \"LoopStart: 輸入密碼\". After No, we go back to LoopStart.\n\nLet's produce each line with arrow. Should not output actual code. Use \"→\" at start of each step. Use indentation maybe. Provide arrow for decisions. Use 'Yes →' 'No →' with substeps.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定正確密碼為 'python123' // 定義正確的密碼\n→ LoopStart: 輸入使用者密碼 // 讓使用者輸入一個密碼\n→ Decision: 輸入的密碼等於 'python123'？ // 檢查輸入是否正確\n    Yes → Step 2: 輸出 '登入成功' // 密碼正確，顯示成功訊息\n    No  → Step 3: 輸出 '密碼錯誤，請再試一次' // 密碼錯誤，提示重新輸入\n        → LoopStart // 返回輸入步驟，重複檢查\nEnd // 程式執行結束",
      "generated_code": "def main():\n    correct_password = \"python123\"\n    while True:\n        try:\n            pwd = input()\n        except EOFError:\n            # 如果輸入結束但未輸入正確密碼，直接結束\n            break\n        if pwd == correct_password:\n            print(\"登入成功\")\n            break\n        else:\n            print(\"密碼錯誤，請再試一次\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "abc\n1234\npython123",
          "expected_output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功",
          "success": true,
          "output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 0,
    "title": "串列操作練習",
    "description_snippet": "請建立一個串列，內容包含整數 1 到 5，接著完成以下操作：\n1. 新增一個元素 6 到串列尾端。\n2. 刪除串列中的第 2 個元素（索引 1 的位置）。\n3. 輸出最後的串列結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format: each line: \"虛擬碼步驟 // 解釋\". Use arrow etc. Provide step-by-step.\n\nWe start with Start. Then Step 1: 建立串列 [1..5]. Then Step 2: 新增 6. Then Step 3: 刪除索引 1. Then Step 4: 輸出. End.\n\nAlso we may include Decision? not needed. But follow format.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: List = [1, 2, 3, 4, 5] // 建立包含 1 到 5 的串列\n→ Step 2: List.append(6) // 在串列尾端新增元素 6\n→ Step 3: List.pop(1) // 刪除索引 1 的元素（第 2 個元素）\n→ Step 4: Print(List) // 輸出最終串列\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋. Use arrow before each Step. Provide each line.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: List = [1, 2, 3, 4, 5] // 建立包含 1 到 5 的串列  \n→ Step 2: List.append(6) // 在串列尾端新增元素 6  \n→ Step 3: List.pop(1) // 刪除索引 1 的元素（即第 2 個元素）  \n→ Step 4: Print(List) // 輸出最終串列結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    \"\"\"\n    1. 讀取所有標準輸入（若有提供的話）但不做任何處理，因為此問題本身不需要輸入。\n    2. 建立初始串列 [1, 2, 3, 4, 5]。\n    3. 在串列尾端加入元素 6。\n    4. 刪除索引 1（即第 2 個元素）以得到最終結果。\n    5. 將結果輸出到標準輸出。\n    \"\"\"\n    # 讀取輸入（即使沒有輸入也不會拋出錯誤）\n    _ = sys.stdin.read()\n\n    # 建立包含 1 到 5 的串列\n    nums = [1, 2, 3, 4, 5]\n\n    # 在尾端新增 6\n    nums.append(6)\n\n    # 刪除索引 1 的元素（第 2 個元素）\n    del nums[1]\n\n    # 輸出最終串列\n    print(nums)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[1, 3, 4, 5, 6]",
          "success": true,
          "output": "[1, 3, 4, 5, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 1,
    "title": "集合函數練習",
    "description_snippet": "請建立一個集合 fruits = {'apple', 'banana'}，並完成以下操作：\n1. 使用 add() 新增 'orange'。\n2. 使用 update() 一次新增 'grape' 與...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation per line, following format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow symbols, decision if any. But here we just have straight steps, no decisions. So each line will be \"Start\" then steps, then End.\n\nWe need to simulate set operations: create set, add, update, remove, discard, output.\n\nMake sure to use virtual code structure: maybe \"Start\" then \"→ Step X: ...\". But format example: \"Start // 程式開始執行\". Then \"→ Step 1: ...\" etc.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 設定 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'\n→ Step 6: output fruits // 輸出最終集合\nEnd // 程式執行結束\n\nCheck format: each line has \"虛擬碼步驟 // 解釋\". We must include the arrow '→' at each step except Start and End? Example had \"Start\" then \"→ Step 1\". Yes.\n\nSo final answer: that list.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'\n→ Step 6: output fruits // 輸出最終集合\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（本題不需要實際資料，僅遵守規範）\n    _ = sys.stdin.read()\n\n    # 建立集合並進行各項操作\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')\n    fruits.update(['grape', 'melon'])\n    fruits.remove('banana')\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"melon\",\"apple\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'melon', 'apple', 'grape'}\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 0,
    "title": "質數判斷函數",
    "description_snippet": "請寫一個函數 is_prime(n)，判斷一個整數是否為質數。如果是質數回傳 True，否則回傳 False。\n\n質數定義：大於 1，且除了 1 和自己本身外，沒有其他因數。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step with explanation in Chinese. Provide steps: Start, function definition, check if n<=1 return False, loop from 2 to sqrt(n) inclusive, if n % i == 0 return False, after loop return True, End. Use arrow. Provide decision lines. Let's craft.\n\nStart // 程式開始執行\n→ Step 1: 定義函數 is_prime(n) // 建立判斷質數的函式\n→ Step 2: Decision: n <= 1? // 質數必須大於1\n    Yes → Step 3: 回傳 False // 小於等於1不是質數\n    No  → Decision: n 是 2 或 3? // 2 和 3 為質數\n        Yes → Step 4: 回傳 True // 直接回傳真\n        No  → Step 5: Decision: n 為偶數? // 偶數除2外都不是質數\n            Yes → Step 6: 回傳 False // 不是質數\n            No  → Step 7: 變數 i ← 3 // 開始奇數檢查\n→ Step 8: Decision: i * i <= n? // 只需檢查到平方根\n    Yes → Step 9: Decision: n % i == 0? // 是否被奇數整除\n        Yes → Step 10: 回傳 False // 找到因數，非質數\n        No  → Step 11: i ← i + 2 // 只檢查奇數\n        → 回到 Step 8 // 重新判斷 i 是否仍 <= sqrt(n)\n    No  → Step 12: 回傳 True // 沒有因數，為質數\nEnd // 程式執行結束\n\nWe need to match format exactly: each line \"虛擬碼步驟 // 解釋\". Use arrow arrow etc. Provide correct indent? Use indentation as spaces? They used indent for nested decisions. We'll include indentation with tabs or spaces. Provide code lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函數 is_prime(n) // 建立判斷質數的函式  \n→ Step 2: Decision: n <= 1? // 質數必須大於 1  \n&nbsp;&nbsp;Yes → Step 3: 回傳 False // n 小於等於 1 不是質數  \n&nbsp;&nbsp;No  → Decision: n 是 2 或 3? // 2 和 3 為質數  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: 回傳 True // 直接回傳真  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5: Decision: n 為偶數? // 偶數除 2 之外都不是質數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: 回傳 False // 不是質數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: 變數 i ← 3 // 開始奇數檢查  \n→ Step 8: Decision: i * i <= n? // 只需檢查到平方根  \n&nbsp;&nbsp;Yes → Step 9: Decision: n % i == 0? // 是否被奇數整除  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 10: 回傳 False // 找到因數，非質數  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 11: i ← i + 2 // 只檢查奇數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ 回到 Step 8 // 重新判斷 i 是否仍 <= sqrt(n)  \n&nbsp;&nbsp;No  → Step 12: 回傳 True // 沒有因數，為質數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef is_prime(n):\n    \"\"\"\n    判斷 n 是否為質數。\n    - n <= 1 不是質數。\n    - 從 2 開始檢查到 sqrt(n)，若有因數則非質數。\n    \"\"\"\n    if n <= 1:\n        return False\n    # 若 n 為 2 或 3 是質數，直接回傳 True\n    if n <= 3:\n        return True\n    # 先排除偶數\n    if n % 2 == 0:\n        return False\n    # 從 3 開始檢查奇數因數，步長為 2\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部內容，並執行\n    code = sys.stdin.read()\n    exec(code)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(is_prime(7))\nprint(is_prime(12))",
          "expected_output": "True\nFalse",
          "success": true,
          "output": "True\nFalse"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 1,
    "title": "計算平均分數",
    "description_snippet": "請寫一個函數 calc_avg(*scores)，接收多個分數作為參數，並回傳平均值 (四捨五入到小數點後 2 位)。\n\n限制：不可使用內建函數 sum()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. Must not output actual code. Use virtual code with arrows, Start, End, Decision. Need to implement function calc_avg(*scores) that receives variable number of scores, returns average rounded to 2 decimal places. Cannot use sum(). So we will iterate and sum manually. Use rounding with round(value, 2) but round is built-in; it's fine. We can compute average = total / count, then round.\n\nWe need to use virtual code syntax: Start, Step, Decision, etc. Use arrow →. For variable arguments: Step 1: Initialize total=0 and count=0. Step 2: For each score in scores: add to total, increment count. Step 3: If count>0: avg=total/count; rounded_avg=round(avg,2); return rounded_avg. Else return 0? Maybe average of zero numbers could be 0 or None; we can return 0.\n\nSo produce virtual code accordingly. No actual code. Let's output as described.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 calc_avg(*scores) // 接收任意數量分數參數\n→ Step 2: total ← 0 // 初始化總分為 0\n→ Step 3: count ← 0 // 初始化分數個數為 0\n→ Step 4: Decision: 若 scores 不是空集合? // 檢查是否有傳入分數\n    Yes → For score in scores: // 逐個遍歷所有分數\n        → Step 5: total ← total + score // 將分數累加至總分\n        → Step 6: count ← count + 1 // 分數個數加 1\n    No  → Step 7: return 0 // 若無分數，平均值為 0\n→ Decision: 若 count > 0? // 確保除以零不發生\n    Yes → Step 8: avg ← total / count // 計算平均值\n    → Step 9: rounded_avg ← round(avg, 2) // 四捨五入到小數點後 2 位\n    → Step 10: return rounded_avg // 回傳結果\n    No  → Step 11: return 0 // 當 count 為 0 時回傳 0\nEnd // 程式執行結束",
      "generated_code": "def calc_avg(*scores):\n    \"\"\"計算多個分數的平均值，四捨五入到小數點後兩位。\"\"\"\n    total = 0\n    count = 0\n    for s in scores:\n        total += s\n        count += 1\n    if count == 0:\n        return 0\n    return round(total / count, 2)\n\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取所有輸入\n    code = sys.stdin.read()\n    # 在全域名稱空間中執行輸入的 Python 程式碼\n    exec(code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(calc_avg(80, 90, 100))\nprint(calc_avg(70, 75, 85, 95))",
          "expected_output": "90.0\n81.25",
          "success": true,
          "output": "90.0\n81.25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 0,
    "title": "列表與條件生成式練習",
    "description_snippet": "請寫一個程式，建立一個包含 1 到 20 的整數列表，接著使用列表生成式（List Comprehension）產生一個新列表，只保留偶數並將它們平方後輸出結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, using arrows and decisions. It's straightforward: start, create list, list comprehension, output. No decision needed.\n\nWe must not output actual code. Just virtual steps. Use Start, End. Include arrows. Provide short explanation after space and //.\n\nMake sure each line has \"虛擬碼步驟\" then space then // explanation. The arrow format like \"→ Step 1: ...\" etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立列表 numbers 為 1 到 20 // 創建原始數字列表\n→ Step 2: 建立新列表 squared_even 使用列表生成式，篩選偶數並平方 // 生成偶數平方列表\n→ Step 3: 輸出 squared_even // 顯示結果\nEnd // 程式結束\n\nThat's it.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立列表 numbers 為 1 到 20 // 創建原始數字列表\n→ Step 2: 建立新列表 squared_even 使用列表生成式，篩選偶數並平方 // 生成偶數平方列表\n→ Step 3: 輸出 squared_even // 顯示結果\nEnd // 程式結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（雖然此問題不需要任何輸入，仍依規範進行）\n    _ = sys.stdin.read()\n\n    # 建立 1 到 20 的整數列表\n    nums = list(range(1, 21))\n\n    # 使用列表生成式過濾偶數並平方\n    result = [n * n for n in nums if n % 2 == 0]\n\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]",
          "success": true,
          "output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 1,
    "title": "map() / filter() / lambda 綜合練習",
    "description_snippet": "請寫一個程式，建立一個列表 numbers = [3, 7, 10, 15, 20]。\n1. 使用 filter() 搭配 lambda 篩選出可被 5 整除的數。\n2. 使用 map() 將這些數字...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line. The user wants a program with list numbers = [3, 7, 10, 15, 20], filter with lambda for divisible by 5, map multiply by 10, output result list.\n\nWe need to follow format: Start, → Step 1, etc. Provide explanation after //.\n\nMake sure to use virtual code arrows. Use \"Decision\" if needed? It's simple; can do filtering and mapping. But we might include decision for filter? Actually filter uses lambda: check remainder. But we can do direct.\n\nLet's outline steps:\n\nStart\n→ Step 1: 定義 numbers = [3, 7, 10, 15, 20] // 初始化列表\n→ Step 2: filtered = filter(lambda x: x % 5 == 0, numbers) // 篩選可被 5 整除的數\n→ Step 3: mapped = map(lambda x: x * 10, filtered) // 把篩選結果乘以 10\n→ Step 4: result = list(mapped) // 轉換為列表\n→ Step 5: 輸出 result // 顯示最終結果\nEnd\n\nWe might also include step for printing. That is fine.\n\nCheck format: Each line must be \"虛擬碼步驟 [space] // 解釋\". Use arrows. For list conversion maybe \"→ Step 4: result = list(mapped) // 轉成列表\".\n\nMake sure to start with \"Start // 程式開始執行\" and End.\n\nWe need to maintain arrow formatting: \"→\" for each step.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: numbers = [3, 7, 10, 15, 20] // 初始化列表 numbers  \n→ Step 2: filtered = filter(lambda x: x % 5 == 0, numbers) // 篩選出可被 5 整除的數  \n→ Step 3: mapped = map(lambda x: x * 10, filtered) // 將篩選後的數字乘以 10  \n→ Step 4: result = list(mapped) // 將 map 物件轉成列表  \n→ Step 5: print(result) // 輸出結果列表  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n    # 讀取所有標準輸入，確保程式可接受任何合法輸入\n    sys.stdin.read()\n\n    # 原始需求中預設的列表\n    numbers = [3, 7, 10, 15, 20]\n\n    # 1. 篩選能被 5 整除的數\n    filtered = filter(lambda x: x % 5 == 0, numbers)\n\n    # 2. 把篩選結果每個數字乘以 10\n    result = list(map(lambda x: x * 10, filtered))\n\n    # 輸出最終結果\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[100, 150, 200]",
          "success": true,
          "output": "[100, 150, 200]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 0,
    "title": "JSON 檔案儲存與讀取練習",
    "description_snippet": "請寫一個程式，建立一個字典 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}。\n1. 使用 json.dump() 將其寫入 data.jso...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with arrows, steps, explanation in each line. Must be in Traditional Chinese. Provide each line with `虛擬碼步驟 // 解釋`. Use `Start`, `End`, `Decision:`. It's a simple script, no decision logic but still we can use steps. Provide file open write and load. Use json.dump and json.load. Should show reading name and city. Let's create steps: Start, Step 1 define dictionary, Step 2 open file for writing, Step 3 json.dump, Step 4 close file, Step 5 open file for reading, Step 6 json.load, Step 7 print name and city, End. Include explanations. Use arrows. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立字典資料  \n→ Step 2: 開啟 'data.json' 為寫入模式 // 準備寫入檔案  \n→ Step 3: 使用 json.dump(data, file) 將 data 寫入檔案 // 將字典序列化為 JSON  \n→ Step 4: 關閉檔案 // 釋放資源  \n→ Step 5: 開啟 'data.json' 為讀取模式 // 準備讀取檔案  \n→ Step 6: 使用 json.load(file) 讀取 JSON 並存入 variable loaded_data // 解析 JSON 成字典  \n→ Step 7: 印出 loaded_data['name'] 與 loaded_data['city'] // 顯示 name 與 city 欄位  \nEnd // 程式執行結束",
      "generated_code": "import json\nimport sys\n\ndef main() -> None:\n    # 讀取標準輸入（即使沒有輸入也不會影響程式執行）\n    sys.stdin.read()\n\n    # 建立字典資料\n    data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}\n\n    # 將字典寫入 data.json\n    with open('data.json', 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=2)\n\n    # 從 data.json 讀取資料\n    with open('data.json', 'r', encoding='utf-8') as f:\n        result = json.load(f)\n\n    # 印出 name 與 city\n    print(f'姓名： {result[\"name\"]}')\n    print(f'城市： {result[\"city\"]}')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "姓名： Alice\n城市： Taipei",
          "success": true,
          "output": "姓名： Alice\n城市： Taipei"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 1,
    "title": "即時匯率查詢小工具",
    "description_snippet": "請使用 requests 模組串接匯率 API（https://api.exchangerate-api.com/v4/latest/USD），取得當前美元兌換台幣（TWD）的匯率。\n將結果顯示在 t...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step with explanations, no real code, just pseudocode.\n\nSteps:\n\n- Import modules requests, tkinter.\n- Create function fetch_rate() to GET API and parse JSON to get TWD rate.\n- Create Tk window, label to show rate, button to refresh.\n- Button command triggers fetch_rate and update label.\n\nWe should use Start, End, Decision, etc. Provide arrows. Provide explanation per line.\n\nLet's produce.\n\nUse Start. Then arrow to \"Import modules: requests, tkinter\".\n\nThen define function fetch_rate().\n\nInside, use \"requests.get(api_url)\" -> parse JSON, extract rate.\n\nReturn rate.\n\nIn main, create window.\n\nSet title.\n\nCreate label variable.\n\nCreate button, command lambda: update.\n\nDefine update function: call fetch_rate, set label text.\n\nCall update initially.\n\nRun mainloop.\n\nEnd.\n\nWe need to incorporate Decision if needed? maybe none.\n\nJust simple.\n\nLet's produce virtual code lines.\n\nMake sure each line has arrow, description.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import modules: requests, tkinter // 引入請求網路與 GUI 需要的模組  \n→ Define function fetch_rate() // 定義取得匯率的功能  \n  → Set api_url = \"https://api.exchangerate-api.com/v4/latest/USD\" // API 端點  \n  → Response = requests.get(api_url) // 發送 GET 請求  \n  → Parse json_data = Response.json() // 解析 JSON 回傳  \n  → Rate = json_data[\"rates\"][\"TWD\"] // 取出 TWD 匯率  \n  → Return Rate // 回傳匯率  \n→ Create Tk window root // 建立主視窗  \n  → Set root.title(\"USD to TWD 匯率\") // 設定視窗標題  \n→ Define update_rate() // 定義更新匯率並顯示的功能  \n  → Call rate = fetch_rate() // 取得最新匯率  \n  → Update label_text = f\"1 USD = {rate:.4f} TWD\" // 格式化顯示文字  \n  → Set rate_label.config(text=label_text) // 更新標籤內容  \n→ Create label rate_label = tk.Label(root, text=\"Loading...\") // 初始顯示文字  \n  → Place rate_label in window // 放置標籤  \n→ Create button refresh_button = tk.Button(root, text=\"更新匯率\", command=update_rate) // 建立更新按鈕  \n  → Place refresh_button in window // 放置按鈕  \n→ Call update_rate() // 初始取得並顯示匯率  \n→ root.mainloop() // 啟動事件迴圈，等待使用者互動  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport requests\n\ndef fetch_twd_rate() -> float:\n    \"\"\"\n    取得美元兌台幣的匯率。\n    使用 https://api.exchangerate-api.com/v4/latest/USD 取得最新匯率資料，\n    解析 JSON 並回傳 TWD 的值。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    response = requests.get(url, timeout=10)\n    response.raise_for_status()  # 若非 200 會丟例外\n    data = response.json()\n    return data[\"rates\"][\"TWD\"]\n\ndef main() -> None:\n    \"\"\"\n    主程式入口：\n    1. 從標準輸入讀取一行字串（任何內容皆可）。\n    2. 取得最新匯率。\n    3. 以指定格式輸出結果。\n    \"\"\"\n    # 讀取標準輸入，避免因沒有輸入而阻塞\n    _ = sys.stdin.read()\n\n    try:\n        rate = fetch_twd_rate()\n        print(f\"目前美元匯率：約 {rate:.4f} TWD\")\n    except Exception as exc:\n        # 若發生任何錯誤（網路、JSON 解析等），以錯誤訊息回覆\n        print(f\"更新失敗，請檢查網路連線: {exc}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.7800TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.7800 TWD'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode306.json",
    "problem_index_in_file": 0,
    "title": "Additive Number",
    "description_snippet": "An additive number is a string whose digits can form an additive sequence.\n\nA valid additive sequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for checking additive number. Step-by-step recursion or backtracking. We'll generate virtual code lines: Start, loops for split first two numbers, recursion. Provide explanations. Use virtual code arrows. Must not output actual code. Only pseudo steps. We'll format lines like \"→ Step 1: 將字串長度設定為 n // 設定字串長度\". Need decisions, loops.\n\nLet's design algorithm:\n\n- Start\n- Set n = len(s)\n- For i from 1 to n-1: (split first number)\n  - if s[0] == '0' and i>1: continue (leading zero)\n  - first = int(s[0:i])\n  - For j from i+1 to n: (split second number)\n    - if s[i] == '0' and j-i>1: continue\n    - second = int(s[i:j])\n    - if isValid(first, second, j): return true\n- Return false\n- isValid(a,b, index):\n  - while index < n:\n    - sum = a+b\n    - sumStr = str(sum)\n    - if not s.startswith(sumStr, index): return false\n    - index += len(sumStr)\n    - a, b = b, sum\n  - return true\n\nImplement recursion or while loop. Provide virtual steps.\n\nWe need to produce each line with explanation after //. We'll use \"Step 1:\", \"Decision:\", \"Yes →\", \"No →\". Provide proper arrows.\n\nLet's produce pseudocode:\n\nStart // 程式開始執行\n→ Step 1: 設定 n = s.length // 取得輸入字串長度\n→ Step 2: 循環 i 取第一個數字的結束位置從 1 到 n-2 // 第一個數字至少一位且保留三個數字\n    → Decision: s[0] == '0' 且 i > 1? // 檢查首數字是否有前導零\n        Yes → Continue // 若首數字有前導零且長度>1，跳過此 i\n        No  → Step 3: 計算 first = int(s[0:i]) // 轉換第一個數字\n    → Step 4: 循環 j 取第二個數字的結束位置從 i+1 到 n-1 // 第二個數字至少一位\n        → Decision: s[i] == '0' 且 j-i > 1? // 檢查第二個數字是否有前導零\n            Yes → Continue // 跳過此 j\n            No  → Step 5: 計算 second = int(s[i:j]) // 轉換第二個數字\n        → Decision: isValid(first, second, j)? // 檢查從第三個數字開始是否符合規則\n            Yes → Step 6: 回傳 true // 找到合法序列，返回真\n            No  → Continue // 嘗試另一個 j\n→ Step 7: 回傳 false // 所有分割都失敗，返回假\nEnd // 程式結束\n\nNow need to define isValid pseudo-code steps. Provide separate subroutine:\n\nStep X: 定義函式 isValid(a, b, index) // 檢查剩餘部分是否為合法加法序列\n    → Decision: index == n? // 是否已檢查完所有字符\n        Yes → Step 8: 回傳 true // 完整匹配\n        No  → Step 9: 計算 sum = a + b // 下一個數字\n    → Step 10: sumStr = toString(sum) // 將 sum 轉為字串\n    → Decision: s.startsWith(sumStr, index)? // 前綴是否相符\n        Yes → Step 11: index += len(sumStr) // 移動到下個位置\n            → Step 12: a, b = b, sum // 更新兩個前項\n            → Decision: index == n? // 是否完成\n                Yes → Step 13: 回傳 true // 成功\n                No  → 回到 Step 9 // 迴圈往下\n        No  → Step 14: 回傳 false // 不匹配，失敗\n\nWe need to embed this inside main pseudocode; but we need to keep format. We can include subroutine lines after main. Each line has a number? Not required. But keep structure.\n\nWe need to ensure all lines follow format: \"虛擬碼步驟 [空格] // 解釋\". Use \"→\" arrow before steps inside loops. For decisions, use \"Decision:\" lines with \"Yes →\" and \"No →\". For subroutine, maybe use \"Function isValid(a, b, index):\" etc. We'll incorporate.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n = s.length // 取得輸入字串長度  \n→ Step 2: 循環 i 取第一個數字的結束位置從 1 到 n-2 // 第一個數字至少一位且保留三個數字  \n  → Decision: s[0] == '0' 且 i > 1? // 檢查首數字是否有前導零  \n   Yes → Continue // 若首數字有前導零且長度>1，跳過此 i  \n   No  → Step 3: first = int(s[0:i]) // 轉換第一個數字  \n→ Step 4: 循環 j 取第二個數字的結束位置從 i+1 到 n-1 // 第二個數字至少一位  \n  → Decision: s[i] == '0' 且 j-i > 1? // 檢查第二個數字是否有前導零  \n   Yes → Continue // 跳過此 j  \n   No  → Step 5: second = int(s[i:j]) // 轉換第二個數字  \n  → Decision: isValid(first, second, j)? // 檢查從第三個數字開始是否符合規則  \n   Yes → Step 6: 回傳 true // 找到合法序列，返回真  \n   No  → Continue // 嘗試另一個 j  \n→ Step 7: 回傳 false // 所有分割都失敗，返回假  \nEnd // 程式結束  \n\nFunction isValid(a, b, index): // 檢查剩餘部分是否為合法加法序列  \n → Decision: index == n? // 是否已檢查完所有字符  \n  Yes → Step 8: 回傳 true // 完整匹配  \n  No  → Step 9: sum = a + b // 下一個數字  \n → Step 10: sumStr = toString(sum) // 將 sum 轉為字串  \n → Decision: s.startsWith(sumStr, index)? // 前綴是否相符  \n  Yes → Step 11: index += len(sumStr) // 移動到下個位置  \n   → Step 12: a, b = b, sum // 更新兩個前項  \n   → Decision: index == n? // 是否完成  \n    Yes → Step 13: 回傳 true // 成功  \n    No  → 回到 Step 9 // 迴圈往下  \n  No  → Step 14: 回傳 false // 不匹配，失敗",
      "generated_code": "import sys\n\nclass Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        n = len(num)\n        # 嘗試所有可能的前兩個數字切分\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                num1 = num[:i]\n                num2 = num[i:j]\n                # 避免前導零\n                if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n                    continue\n                k = j\n                while k < n:\n                    sum_str = str(int(num1) + int(num2))\n                    if not num.startswith(sum_str, k):\n                        break\n                    k += len(sum_str)\n                    num1, num2 = num2, sum_str\n                if k == n:\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料，並移除首尾空白與可能的雙引號\n    data = sys.stdin.read()\n    s = data.strip()\n    if s.startswith('\"') and s.endswith('\"'):\n        s = s[1:-1]\n    solution = Solution()\n    result = solution.isAdditiveNumber(s)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"112358\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"199100199\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode739.json",
    "problem_index_in_file": 0,
    "title": "Daily Temperatures",
    "description_snippet": "Given an array of integers temperatures represents the daily temperatures, return an array answer su...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for \"Daily Temperatures\" problem: For each day, find next warmer day. Use stack algorithm: iterate from end or use stack of indices.\n\nWe need to output line by line with \"虛擬碼步驟\" + \" // 解釋\". Must include Start, End, Decision:, arrows, etc. No actual code. Just pseudocode. Should be step-by-step. Each line maybe \"→ Step X: ...\" etc.\n\nLet's produce algorithm: Start, initialize result array zeros, stack empty. Loop i from len-1 down to 0. While stack not empty and temperatures[stack.top] <= temperatures[i], pop. If stack empty, answer[i] = 0 else answer[i] = stack.top - i. Push i onto stack. After loop, End.\n\nWe need to produce each line with explanation. Use arrows for flow.\n\nOk. Let's produce.\n\nFormat:\n\nStart // 程式開始執行\n→ Step 1: 取得溫度陣列長度 n // 獲得陣列長度\n→ Step 2: 建立 answer 陣列，長度 n，全部初始化為 0 // 用於儲存結果\n→ Step 3: 初始化空棧 stack // 用於存儲未匹配的日子索引\n→ Step 4: 設定迴圈變數 i 為 n-1 // 從最後一天開始倒序遍歷\n    Decision: i >= 0? // 判斷是否還有天要處理\n        Yes → Step 5: 重複 Step 6 至 Step 10 // 處理每一天\n        No  → End // 迴圈結束\n→ Step 5: Decision: while stack 不是空 且 temperatures[stack.top] <= temperatures[i]? // 檢查棧頂日子是否比今天低或等\n            Yes → Step 6: pop stack.top // 移除不符合條件的日子\n            No  → Step 7: Decision: stack 是空? // 判斷是否仍有比今天熱的日子\n                Yes → Step 8: answer[i] = 0 // 沒有更熱的日子，結果為 0\n                No  → Step 9: answer[i] = stack.top - i // 計算距離\n            End Decision\n            再次判斷 while 條件 // 繼續檢查\n→ Step 10: push i 到 stack // 把今天索引存回棧，供前面日子參考\n→ Step 11: i = i - 1 // 移動到前一個日子\n→ Step 12: End // 完成全部處理\n\nBut need to maintain the \"Decision:\" format correctly. We need to format like:\n\nDecision: while stack not empty and temperatures[stack.top] <= temperatures[i]? // ...\n\nYes → Step 6: pop stack.top // ...\n\nNo  → Decision: stack empty? // ...\n\nBut this might be too many decisions. Let's keep simple.\n\nSimplify:\n\nStart\n→ Step 1: Let n = length of temperatures // get length\n→ Step 2: answer ← array of n zeros // initialise result\n→ Step 3: stack ← empty // stack for indices\n→ Step 4: i ← n-1 // start from last day\n    Decision: i >= 0? // are there days left?\n        Yes → Step 5: while stack not empty and temperatures[stack.top] <= temperatures[i]? // find next warmer\n                Yes → Step 6: pop stack.top // discard cooler/equal day\n                No  → Decision: stack empty? // no warmer day ahead\n                    Yes → Step 7: answer[i] ← 0 // none\n                    No  → Step 8: answer[i] ← stack.top - i // distance to warmer day\n                End Decision\n                再次判斷 while 條件 // loop\n        No  → End // loop finished\n→ Step 9: push i to stack // store current day\n→ Step 10: i ← i - 1 // move left\n→ End // finished\n\nNeed each line explanation.\n\nWe must keep lines in proper order. Each decision may have nested lines.\n\nLet's produce final answer. Ensure all lines have \"→\" for steps, \"Decision:\" for decisions, \"Yes →\" \"No →\" lines.\n\nAlso we must avoid duplicate lines: for while loop, we need to use Decision: while condition? and then Yes → Step 6, No → Decision: next.\n\nWe might need \"Decision:\" inside while. For clarity we can treat while as Decision.\n\nLet's craft.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(temperatures) // 取得陣列長度\n→ Step 2: answer ← array of n zeros // 建立結果陣列並初始化\n→ Step 3: stack ← empty // 建立棧用於索引\n→ Step 4: i ← n-1 // 從最後一天開始倒序\n    Decision: i >= 0? // 是否還有天要處理？\n        Yes → \n            Decision: while stack not empty and temperatures[stack.top] <= temperatures[i]? // 找下一個更熱的日子\n                Yes → Step 5: pop stack.top // 移除不比今天熱的日子\n                No  → \n                    Decision: stack empty? // 是否還有比今天熱的日子？\n                        Yes → Step 6: answer[i] ← 0 // 沒有更熱的日子\n                        No  → Step 7: answer[i] ← stack.top - i // 計算距離\n                    End Decision\n                End Decision\n            End Decision\n        No  → End // 迴圈結束\n→ Step 8: push i to stack // 把今天索引加入棧\n→ Step 9: i ← i - 1 // 移動到前一個日子\n→ End // 程式執行結束\n\nBut we have to be careful: the decision \"while\" should loop until false; but in pseudocode we use Decision: while condition? then Yes block; No block would be after loop. But we wrote No block inside but that is not correct. Actually while loops: we need to process Yes block until condition false, then exit loop. But we can simplify: use Decision: while stack not empty and ...? \n    Yes → pop stack.top\n    No  → ...\nBut that No branch would exit loop, but then we still need to compute answer after loop. So we need to handle answer after while. So restructure:\n\nStart\n→ Step 1...\n→ Step 2...\n→ Step 3...\n→ Step 4...\n    Decision: i >= 0?\n        Yes →\n            Decision: while stack not empty and temperatures[stack.top] <= temperatures[i]?\n                Yes → Step 5: pop stack.top\n                No  → End Decision // exit while loop\n            End Decision\n            Decision: stack empty?\n                Yes → Step 6: answer[i] ← 0\n                No  → Step 7: answer[i] ← stack.top - i\n            End Decision\n        No → End\n→ Step 8: push i to stack\n→ Step 9: i ← i - 1\n→ End\n\nThat seems clearer. Provide explanation after each line. Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(temperatures) // 取得溫度陣列長度  \n→ Step 2: answer ← array of n zeros // 建立結果陣列並全部初始化為 0  \n→ Step 3: stack ← empty // 建立棧用來存放尚未找到更熱日子的索引  \n→ Step 4: i ← n-1 // 從最後一天開始倒序遍歷  \n Decision: i ≥ 0? // 仍有天要處理嗎？  \n  Yes →  \n   Decision: while stack not empty and temperatures[stack.top] ≤ temperatures[i]? // 找下一個更熱的日子  \n    Yes → Step 5: pop stack.top // 把不比今天熱的日子移除  \n    No  → End Decision // 條件不滿足，結束 while 迴圈  \n   End Decision  \n   Decision: stack empty? // 是否還有比今天熱的日子？  \n    Yes → Step 6: answer[i] ← 0 // 沒有更熱的日子，結果為 0  \n    No  → Step 7: answer[i] ← stack.top - i // 計算距離到下一個更熱的日子  \n   End Decision  \n  No  → End // 迴圈結束  \n→ Step 8: push i to stack // 把今天的索引加入棧，供前面天數參考  \n→ Step 9: i ← i - 1 // 移動到前一個日子  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def dailyTemperatures(self, temperatures):\n        n = len(temperatures)\n        res = [0] * n\n        stack = []\n        for i in range(n):\n            while stack and temperatures[i] > temperatures[stack[-1]]:\n                idx = stack.pop()\n                res[idx] = i - idx\n            stack.append(i)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入字串轉成列表，使用 literal_eval 以避免 eval 風險\n    temperatures = ast.literal_eval(data)\n    sol = Solution()\n    result = sol.dailyTemperatures(temperatures)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[73,74,75,71,69,72,76,73]",
          "expected_output": "[1,1,4,2,1,1,0,0]",
          "success": true,
          "output": "[1, 1, 4, 2, 1, 1, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "[30,40,50,60]",
          "expected_output": "[1,1,1,0]",
          "success": true,
          "output": "[1, 1, 1, 0]"
        },
        {
          "example_index": 2,
          "input": "[30,60,90]",
          "expected_output": "[1,1,0]",
          "success": true,
          "output": "[1, 1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode71.json",
    "problem_index_in_file": 0,
    "title": "Simplify Path",
    "description_snippet": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Y...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for simplifying a Unix path. Need to produce step-by-step pseudocode lines with arrow. Must include explanation after //.\n\nWe should consider algorithm: split by '/', stack, iterate components, ignore empty or '.'; if '..' pop; else push component. After processing, build path: '/' + join stack by '/'; if empty, return '/'. Also ensure no trailing slash. Also treat sequences of periods not matching '.' or '..' as names.\n\nLet's produce virtual steps. We'll include Start, decision, loops. Use arrow formatting. Use \"Step\". Provide explanation after //.\n\nMake sure each line follows format: \"虛擬碼步驟 // 解釋/說明\".\n\nWe'll output line by line. Use arrow arrow. Let's produce:\n\nStart\n→ Step 1: 初始化空堆疊 `stack` // 用於儲存有效目錄名稱\n→ Step 2: 將輸入路徑以 '/' 分割成元件 `components` // 去除連續斜線的影響\n→ Step 3: 循環遍歷 `components` // 逐個處理每個路徑片段\n    → Decision: 是否為空字符串? // 空白片段表示多個 '/' 或路徑首尾 '/'\n        Yes → Continue to next component // 跳過\n        No  → Decision: 是否為 '.'? // 當前目錄符號\n            Yes → Continue to next component // 跳過\n            No  → Decision: 是否為 '..'? // 父目錄符號\n                Yes → Decision: `stack` 是否非空?\n                    Yes → Pop one element from `stack` // 返回上一層目錄\n                    No  → Continue // 位於根目錄，無法上移\n                No  → // 其餘情況為合法目錄/檔名\n                    Push component onto `stack` // 添加到路徑中\n→ Step 4: 建立簡化路徑 `simplified` = '/' + join `stack` with '/' // 重新組裝路徑\n→ Decision: `stack` 是否為空?\n    Yes → `simplified` = '/' // 只有根目錄時保持 '/'\n    No  → // `simplified` 已正確建立\nEnd\n\nNeed ensure \"→\" arrow indent inside loop. Provide each line with appropriate indentation? The format shows indentation in sample: Indent inside Decision blocks uses spaces. We can mimic.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空堆疊 `stack` // 用於儲存有效目錄名稱\n→ Step 2: 將輸入路徑以 '/' 分割成元件 `components` // 去除多餘斜線的影響\n→ Step 3: 循環遍歷 `components` // 逐個處理每個路徑片段\n    → Decision: 是否為空字符串? // 空白片段表示多個 '/' 或首尾 '/'\n        Yes → Continue to next component // 跳過此片段\n        No  → Decision: 是否為 '.'? // 表示當前目錄\n            Yes → Continue to next component // 跳過\n            No  → Decision: 是否為 '..'? // 表示上一層目錄\n                Yes → Decision: `stack` 是否非空?\n                    Yes → Pop one element from `stack` // 返回上一層\n                    No  → Continue // 位於根目錄，無法上移\n                No  → // 其餘為合法目錄或檔名\n                    Push component onto `stack` // 將片段加入堆疊\n→ Step 4: 建立簡化路徑 `simplified` = '/' + join `stack` with '/' // 重新組裝路徑\n→ Decision: `stack` 是否為空?\n    Yes → `simplified` = '/' // 只有根目錄時保持 '/'\n    No  → // `simplified` 已正確建立\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        parts = path.split('/')\n        for part in parts:\n            if part == '' or part == '.':\n                continue\n            elif part == '..':\n                if stack:\n                    stack.pop()\n            else:\n                stack.append(part)\n        return '/' + '/'.join(stack) if stack else '/'\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # Extract the path string enclosed in double quotes, if present\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        path = match.group(1)\n    else:\n        # If no quotes, assume the entire input is the path\n        path = data\n\n    result = Solution().simplifyPath(path)\n    # Print the result surrounded by double quotes as per examples\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "path = \"/home/\"",
          "expected_output": "\"/home\"",
          "success": true,
          "output": "\"/home\""
        },
        {
          "example_index": 1,
          "input": "path = \"/home//foo/\"",
          "expected_output": "\"/home/foo\"",
          "success": true,
          "output": "\"/home/foo\""
        },
        {
          "example_index": 2,
          "input": "path = \"/home/user/Documents/../Pictures\"",
          "expected_output": "\"/home/user/Pictures\"",
          "success": true,
          "output": "\"/home/user/Pictures\""
        },
        {
          "example_index": 3,
          "input": "path = \"/../\"",
          "expected_output": "\"/\"",
          "success": true,
          "output": "\"/\""
        },
        {
          "example_index": 4,
          "input": "path = \"/.../a/../b/c/../d/./\"",
          "expected_output": "\"/.../b/d\"",
          "success": true,
          "output": "\"/.../b/d\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode347.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Elements",
    "description_snippet": "Given an integer array nums and an integer k, return the k most frequent elements. You may return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with arrow syntax and explanations. No actual code, just virtual steps. Steps: input array, input k, build frequency map, convert to list of pairs, sort by frequency descending, pick first k, output list. Or use heap. We'll produce a simple algorithm.\n\nLet's craft steps:\n\nStart\n→ Step 1: 取得輸入陣列 nums // input array\n→ Step 2: 取得輸入整數 k // input k\n→ Step 3: 初始化空字典 freq // frequency map\n→ Step 4: 對於每個元素 num in nums\n    → Step 5: 若 freq 內有 num\n        → Step 6: freq[num] = freq[num] + 1 // 增加計數\n        → Step 7: 否則\n        → Step 8: freq[num] = 1 // 新增計數\n→ Step 9: 初始化空列表 freqList // 轉換為 (num, count) 列表\n→ Step 10: 對於每個鍵值對 key, value in freq\n    → Step 11: Append (key, value) 至 freqList // 形成頻率對\n→ Step 12: 按頻率降序排序 freqList // 由高到低\n→ Step 13: 初始化空列表 result\n→ Step 14: 從 0 到 k-1\n    → Step 15: result.append(freqList[i].key) // 取前 k 個數字\n→ Step 16: 返回 result\nEnd\n\nWe need each line with arrow and explanation.\n\nUse proper syntax: \"→\" arrow preceding step. For nested steps, indent.\n\nLet's format accordingly.\n\nWe also need Decision steps? There is none except loops. We can show loops with Decision? But requirement: use arrows and structure: Decision, Yes→ etc. Not mandatory. But we can include loops. Use \"→\" to indicate each step.\n\nWe need each line: `虛擬碼步驟 // 解釋`. So produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 從使用者取得整數陣列\n...\n\nLet's produce accordingly.\n\nLet's ensure each line has proper indentation but still arrow at start.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 從使用者取得整數陣列  \n→ Step 2: 取得輸入整數 k // 取得想要的前 k 個最常見元素數量  \n→ Step 3: 初始化空字典 freq // 用於儲存每個元素的出現頻率  \n→ Step 4: 對於每個元素 num in nums  \n  → Step 5: 若 freq 內已有 key num  \n    → Step 6: freq[num] = freq[num] + 1 // 既有則頻率加一  \n    → Step 7: 否則  \n      → Step 8: freq[num] = 1 // 新增並設為 1  \n→ Step 9: 初始化空列表 freqList // 用來轉成 (元素,頻率) 形式  \n→ Step 10: 對於每個鍵值對 key, value in freq  \n  → Step 11: Append (key, value) 至 freqList // 形成頻率對  \n→ Step 12: 按頻率降序排序 freqList // 由高頻到低頻排列  \n→ Step 13: 初始化空列表 result // 存放最終答案  \n→ Step 14: 從索引 0 到 k-1  \n  → Step 15: result.append(freqList[i].key) // 取前 k 個頻率最高的元素  \n→ Step 16: 返回 result // 回傳最頻繁的 k 個元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\nimport heapq\n\ndef top_k_frequent(nums, k):\n    \"\"\"回傳前 k 個最常見的元素。\"\"\"\n    freq = Counter(nums)\n    # 取得頻率最高的 k 個項目\n    return [item for item, _ in heapq.nlargest(k, freq.items(), key=lambda x: x[1])]\n\ndef main():\n    \"\"\"從標準輸入讀取資料，處理並輸出結果。\"\"\"\n    data = sys.stdin.read()\n    # 取得 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    # 取得 k 整數\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not k_match:\n        return\n    nums = eval(nums_match.group(1))\n    k = int(k_match.group(1))\n    result = top_k_frequent(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode752.json",
    "problem_index_in_file": 0,
    "title": "Open the Lock",
    "description_snippet": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3',...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to solve lock problem. Likely BFS. Provide steps like Start, Input, Build deadend set, check initial, BFS queue, visited, loop until queue empty or target found, etc.\n\nWe must adhere to format: each line \"虛擬碼步驟 // 解釋\".\n\nUse arrow symbol → for steps.\n\nInclude Decision and branching.\n\nWe should show initialization, BFS, neighbor generation.\n\nLet's craft.\n\nNeed to handle deadends list, target string.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: deadends, target // 取得死端清單與目標碼  \n→ Decision: target 是否為 '0000'? // 檢查是否已開鎖  \n    Yes → Return 0 // 直接已是目標，無需任何轉動  \n    No  →  // 繼續下一步  \n→ Build: deadSet ← Set(deadends) // 方便 O(1) 判斷是否為死端  \n→ Decision: deadSet 包含 '0000'? // 若起始碼為死端則無法移動  \n    Yes → Return -1 // 直接無法開鎖  \n    No  →  // 繼續  \n→ Init: queue ← Queue(('0000', 0)) // 起始碼和步數  \n→ Init: visited ← Set(['0000']) // 已訪問集合  \n→ Loop: while queue not empty // BFS 主迴圈  \n    → Dequeue: (code, steps) ← queue.pop() // 取出最早進入的節點  \n    → Decision: code 等於 target? // 檢查是否到達目標  \n        Yes → Return steps // 找到最短步數  \n        No  →  // 生成鄰居碼  \n    → For each i in [0..3] // 每個位置  \n        → For each d in ['+1', '-1'] // 向前向後轉動  \n            → newDigit ← (int(code[i]) + d) mod 10 // 計算新數位（模 10）  \n            → newCode ← code[0:i] + str(newDigit) + code[i+1:] // 合成新碼  \n            → Decision: deadSet 包含 newCode? 或 visited 包含 newCode?  \n                Yes → Continue // 跳過死端或已訪問的碼  \n                No  →  \n                    → Add: visited.add(newCode) // 標記已訪問  \n                    → Enqueue: queue.append((newCode, steps+1)) // 加入下一層  \n→ End // 若 queue 空了仍未找到目標  \n→ Return -1 // 無法開鎖的情況\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def openLock(self, deadends, target):\n        dead = set(deadends)\n        if '0000' in dead:\n            return -1\n        queue = deque([('0000', 0)])\n        visited = set(['0000'])\n        while queue:\n            state, steps = queue.popleft()\n            if state == target:\n                return steps\n            for i in range(4):\n                digit = int(state[i])\n                for move in (-1, 1):\n                    new_digit = (digit + move) % 10\n                    new_state = state[:i] + str(new_digit) + state[i+1:]\n                    if new_state not in dead and new_state not in visited:\n                        visited.add(new_state)\n                        queue.append((new_state, steps + 1))\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input from stdin which may be given in the form:\n    deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"\n    or simply two lines:\n    [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"]\n    0202\n    \"\"\"\n    data = data.strip()\n    # Try regex extraction\n    dead_match = re.search(r'deadends\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*\"([^\"]+)\"', data)\n    if dead_match and target_match:\n        dead_list = ast.literal_eval(dead_match.group(1))\n        target_str = target_match.group(1)\n        return dead_list, target_str\n    # Fallback: split by lines\n    lines = [line for line in data.splitlines() if line.strip()]\n    if len(lines) == 1:\n        # Might be a single line with both parts separated by comma\n        parts = lines[0].split(',')\n        if len(parts) >= 2:\n            dead_part = parts[0].strip()\n            target_part = parts[1].strip()\n            dead_list = ast.literal_eval(dead_part.split('=')[1].strip())\n            target_str = target_part.split('=')[1].strip().strip('\"')\n            return dead_list, target_str\n    if len(lines) >= 2:\n        dead_list = ast.literal_eval(lines[0].strip())\n        target_str = lines[1].strip().strip('\"')\n        return dead_list, target_str\n    # If still nothing matched, raise error\n    raise ValueError(\"Invalid input format\")\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    try:\n        deadends, target = parse_input(input_data)\n    except Exception:\n        # If parsing fails, output -1\n        print(-1)\n        sys.exit(0)\n    solution = Solution()\n    result = solution.openLock(deadends, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "deadends = [\"8888\"], target = \"0009\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode380.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1)",
    "description_snippet": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool inser...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for RandomizedSet class. Steps: Use hash map for value to index, array for values. Insert, remove, getRandom. We'll produce step-by-step virtual pseudocode with arrows.\n\nWe need to output lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立 RandomizedSet 類別 // 定義類別\n...\n\nWe must produce a logical flow. Use Decision lines for checks.\n\nWe'll describe initialization, insert, remove, getRandom. Each operation.\n\nLet's craft.\n\nWe can write as a single virtual flow with multiple functions.\n\nWe can show each function as a block.\n\nLet's proceed.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 RandomizedSet 類別 // 建立類別\n    → Step 2: 建立空的 ArrayList 數值容器 values // 用於儲存元素，方便索引存取\n    → Step 3: 建立空的 HashMap 位置對應表 indices // key: val, value: 在 values 的索引\n→ Decision: 若需要初始化，執行初始化函式 // 檢查是否有需要執行建構\n    → Yes → Step 4: RandomizedSet() 初始化 // 建構子\n        → Step 5: values 置空 ArrayList // 使容器為空\n        → Step 6: indices 置空 HashMap // 使對應表為空\n        → End // 建構完成\n→ Decision: 若呼叫 insert，執行 insert 函式 // 插入流程\n    → Yes → Step 7: insert(val)\n        → Decision: 若 indices.containsKey(val) 為 true? // 檢查 val 是否已存在\n            → Yes → Step 8: 回傳 false // 已存在，插入失敗\n            → No  → Step 9: values.add(val) // 將 val 加入 ArrayList\n                → Step 10: indices.put(val, values.size()-1) // 在對應表記錄索引\n                → Step 11: 回傳 true // 插入成功\n→ Decision: 若呼叫 remove，執行 remove 函式 // 刪除流程\n    → Yes → Step 12: remove(val)\n        → Decision: 若 !indices.containsKey(val)? // 若 val 不存在\n            → Yes → Step 13: 回傳 false // 刪除失敗\n            → No  → Step 14: index = indices.get(val) // 取得 val 的索引\n                → Step 15: lastVal = values.get(values.size()-1) // 取得陣列最後一個值\n                → Decision: 若 index != values.size()-1? // 若要刪除的不是最後一個\n                    → Yes → Step 16: values.set(index, lastVal) // 用最後一個值覆蓋待刪除位置\n                        → Step 17: indices.put(lastVal, index) // 更新 lastVal 的索引\n                    → No  → Step 18: // 若刪除的是最後一個，無需覆蓋\n                → Step 19: values.remove(values.size()-1) // 刪除最後一個（原本的 val）\n                → Step 20: indices.remove(val) // 移除對應表中的 val\n                → Step 21: 回傳 true // 刪除成功\n→ Decision: 若呼叫 getRandom，執行 getRandom 函式 // 隨機取值流程\n    → Yes → Step 22: getRandom()\n        → Step 23: randomIndex = Random.nextInt(values.size()) // 產生 0~size-1 的隨機索引\n        → Step 24: return values.get(randomIndex) // 取得並回傳對應元素\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    \"\"\"\n    RandomizedSet 允許在平均 O(1) 時間內進行插入、刪除與隨機取值。\n    實作使用兩種資料結構：\n    1. values   : List[int]  用來儲存目前集合的元素，允許以索引存取。\n    2. indices  : Dict[int, int]  將元素值映射到其在 values 中的索引。\n    \"\"\"\n    def __init__(self):\n        self.values = []          # 儲存元素\n        self.indices = {}         # 元素 -> 索引\n\n    def insert(self, val: int) -> bool:\n        \"\"\"將 val 插入集合，若已存在則回傳 False。\"\"\"\n        if val in self.indices:          # 已存在\n            return False\n        self.values.append(val)          # 加到尾端\n        self.indices[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"將 val 從集合移除，若不存在則回傳 False。\"\"\"\n        if val not in self.indices:      # 不存在\n            return False\n\n        idx = self.indices[val]          # 待刪除元素的索引\n        last_val = self.values[-1]       # 取最後一個元素\n\n        # 若待刪除元素不是最後一個，則用最後一個覆蓋它\n        if idx != len(self.values) - 1:\n            self.values[idx] = last_val\n            self.indices[last_val] = idx\n\n        # 刪除最後一個（原本的 val）\n        self.values.pop()\n        del self.indices[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回集合中的一個元素。\"\"\"\n        return random.choice(self.values)\n\n\ndef parse_input() -> tuple[list[str], list[list[int]]]:\n    \"\"\"\n    讀取標準輸入，解析成兩個列表：\n    - ops: operation names\n    - args: 每個 operation 的參數列表\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], []\n\n    # 先嘗試以換行分隔\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        ops_str, args_str = lines[0], lines[1]\n    else:\n        # 只有一行，使用 ',' 分隔兩個 JSON 陣列\n        parts = data.split('],', 1)\n        ops_str = parts[0] + ']'          # 重新加上結尾 ]\n        args_str = ']' + parts[1]          # 重新加上開頭 [\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n    return ops, args\n\n\ndef main():\n    ops, args = parse_input()\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n        else:\n            # 未定義的操作，視作錯誤\n            res.append(None)\n\n    # 使用 json.dumps 讓 None 轉成 null、True/False 轉成 true/false\n    print(json.dumps(res))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpdinubbql.py\", line 95, in <module>\n    main()\n  File \"/tmp/tmpdinubbql.py\", line 72, in main\n    ops, args = parse_input()\n                ^^^^^^^^^^^^^\n  File \"/tmp/tmpdinubbql.py\", line 67, in parse_input\n    args = json.loads(args_str)\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 355, in raw_decode\n    raise JSONDecodeError(\"Expecting value\", s, err.value) from None\njson.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode519.json",
    "problem_index_in_file": 0,
    "title": "Random Flip Matrix",
    "description_snippet": "There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to ran...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: basically reservoir-like mapping using random selection from remaining zeros via mapping dictionary, similar to LeetCode 519. Steps: initialize with m*n, map empty dict, flips left count. flip: choose random k from 0 to left-1; get val = map.get(k, k); decrement left; map[k] = map.get(left, left); return [val // n, val % n]. reset: clear map, left = m*n. Provide explanation. Must produce line-by-line with arrow and comments. Use Start, End. Use Decision if needed. Provide explanation after each line.\n\nLet's produce steps. Use appropriate virtual code style.\n\nProceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 m, n, total = m * n // 記錄矩陣大小和剩餘 0 的數量  \n→ Step 2: 初始化 map 為空字典 // 用來存映射已被翻轉的索引  \n→ Step 3: 初始化 left = total // 剩餘可翻轉的 0 的個數  \n\n→ Decision: 有沒有剩餘 0? // 檢查是否還能翻轉  \n    Yes → Step 4: 隨機產生 k ∈ [0, left-1] // 從剩餘位置隨機挑選  \n    → Step 5: val = map.get(k, k) // 若 k 已映射則取映射值，否則取 k  \n    → Step 6: left -= 1 // 從剩餘數量中扣除一個  \n    → Step 7: map[k] = map.get(left, left) // 把最後一個剩餘位置映射到 k  \n    → Step 8: i = val // n; j = val % n // 將一維索引轉換為二維座標  \n    → Step 9: return [i, j] // 回傳隨機翻轉的座標  \n    No  → Step 10: return [] // 若沒有剩餘 0，返回空（此情況可依實作處理）  \n\n→ Step 11: reset() // 重置所有值為 0  \n    → Step 12: map.clear() // 清空映射表  \n    → Step 13: left = total // 將剩餘數量恢復為全部  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m, self.n = m, n\n        self.total = m * n          # remaining zeros\n        self.mapping = {}           # index mapping for flipped cells\n\n    def flip(self):\n        # 隨機選擇一個剩餘的 0 的位置\n        idx = random.randint(0, self.total - 1)\n        # 若 idx 已被映射，取映射值；否則取 idx 本身\n        val = self.mapping.get(idx, idx)\n        self.total -= 1\n        # 把最後一個剩餘位置映射到 idx\n        self.mapping[idx] = self.mapping.get(self.total, self.total)\n        # 把一維索引轉成二維座標\n        return [val // self.n, val % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.mapping.clear()\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 分割成兩個列表：命令列表和參數列表\n    split_idx = data.find('],')\n    ops_part = data[:split_idx + 1]          # 包含第一個列表的結尾\n    args_part = data[split_idx + 2:].strip()  # 去掉 ', ' 後的第二個列表\n\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    res = []\n    sol = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            sol = Solution(arg[0], arg[1])\n            res.append(None)\n        elif op == \"flip\":\n            res.append(sol.flip())\n        elif op == \"reset\":\n            sol.reset()\n            res.append(None)\n        else:\n            # 任何未知命令視為無返回\n            res.append(None)\n\n    # 輸出結果，None 會被轉為 JSON 的 null\n    print(json.dumps(res))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [2, 0]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode735.json",
    "problem_index_in_file": 0,
    "title": "Asteroid Collision",
    "description_snippet": "We are given an array asteroids of integers representing asteroids in a row. The indices of the aste...",
    "examples_loaded": 4,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the asteroid collision problem. The user request: \"請根據輸出格式要求產生虛擬碼和逐行解釋：\" So we output lines with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows. The problem: We need to process an array of integers representing asteroids. We need to simulate collisions. Standard solution: Use stack. For each asteroid, while stack not empty and top > 0 and current < 0, collision occurs. Determine outcome.\n\nWe need to produce virtual code step by step.\n\nWe can design algorithm:\n\nStart\n→ Step 1: Initialize empty stack\n→ Step 2: Iterate over each asteroid in array\n    → Decision: If asteroid > 0? (moving right)\n        Yes → Step 3: Push onto stack // no collision possible with earlier left-moving\n        No  → // asteroid < 0 moving left\n            → Decision: If stack is empty? // no right-moving before\n                Yes → Step 4: Push onto stack // push left-moving into stack\n                No  → Step 5: Set destroyed = False\n                    → Step 6: While stack not empty and top > 0 and current < 0\n                        → Decision: If |top| == |current|? // same size\n                            Yes → Step 7: Pop stack // both explode\n                                 → Step 8: destroyed = True // current also destroyed\n                                 → Decision: Break loop // no need further\n                            No  → Decision: If |top| > |current|? // right bigger\n                                Yes → Step 9: destroyed = True // current destroyed\n                                     → Decision: Break loop\n                                No  → Step 10: Pop stack // right smaller, pop it\n                                      → Step 11: Continue loop // compare next\n                    → Decision: If destroyed? \n                        Yes → // do nothing\n                        No  → Step 12: Push current onto stack // survived\n→ Step 13: Result = contents of stack as array\nEnd\n\nBut we need to use virtual code lines. We need to use arrows for branching. For loops, maybe \"→ For each asteroid\". Use indentation. Each line: 虛擬碼步驟 + space + // 解釋.\n\nWe need to keep format exactly: Start // ... etc.\n\nLet's craft each step. Use Step numbers? Not required but can include. Provide simple labels.\n\nWe need to keep \"→\" and \"Yes →\" \"No →\" style. For loops, we can use \"→ For each asteroid in asteroids\". Then indent inside.\n\nLet's produce.\n\nWill include decisions.\n\nAlso final output: \"→ Step 13: Result ← stack // asteroid survivors\".\n\nWe also need to produce final end.\n\nOk. Let's write.\n\nRemember to include \"Start // 程式開始執行\" and \"End // 程式執行結束\".\n\nAll lines should be unique.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 stack // 用來儲存目前存活的彈星  \n→ Step 2: 從左到右遍歷每個彈星 asteroid // 按順序處理  \n    → Decision: asteroid 大於 0? // 正值代表向右移動  \n        Yes → Step 3: 將 asteroid 推入 stack // 右移彈星不會立即碰撞  \n        No  → Decision: stack 為空? // 若沒有右移彈星，左移彈星不會碰撞  \n            Yes → Step 4: 將 asteroid 推入 stack // 直接存放  \n            No  → Step 5: 設置 destroyed = False // 用來記錄左移彈星是否被消滅  \n                → Step 6: While stack 不為空 且 stack.top() > 0 且 asteroid < 0 // 碰撞條件  \n                    → Decision: |stack.top()| 等於 |asteroid|? // 相等時雙方相消  \n                        Yes → Step 7: 從 stack 彈出 top // 右移彈星被消滅  \n                                 → Step 8: destroyed = True // 左移彈星也被消滅  \n                                 → Decision: 跳出循環 // 無需再比較  \n                        No  → Decision: |stack.top()| 大於 |asteroid|? // 右移彈星更大  \n                            Yes → Step 9: destroyed = True // 左移彈星被消滅  \n                                 → Decision: 跳出循環  \n                            No  → Step 10: 從 stack 彈出 top // 右移彈星較小被消滅  \n                                 → Decision: 繼續下一次循環 // 仍可能碰撞其他右移彈星  \n                → Decision: destroyed? // 左移彈星是否存活  \n                    Yes → // 不進行任何操作，已被消滅  \n                    No  → Step 11: 將 asteroid 推入 stack // 左移彈星存活  \n→ Step 12: 將 stack 的內容轉成陣列 result // 結果為存活的彈星  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef asteroid_collision(asteroids):\n    stack = []\n    for a in asteroids:\n        # 只要栈顶是向右的且当前是向左的，才会发生碰撞\n        while stack and a < 0 < stack[-1]:\n            if stack[-1] < -a:\n                # 栈顶更小，消失\n                stack.pop()\n                continue\n            elif stack[-1] == -a:\n                # 两者相等，互相消失\n                stack.pop()\n            # 当前左移的已被消灭或与栈顶相消，跳出循环\n            break\n        else:\n            # 当前左移的没有被消灭，或者没有向右的弹星可以碰撞\n            stack.append(a)\n    return stack\n\ndef main():\n    # 读取标准输入，可能的格式为: \"asteroids = [5,10,-5]\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取等号右侧的表达式\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = data.strip()\n    # 解析列表\n    try:\n        asteroids = ast.literal_eval(rhs)\n    except Exception:\n        asteroids = eval(rhs)  # 备用方式\n    result = asteroid_collision(asteroids)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "asteroids = [5,10,-5]",
          "expected_output": "[5,10]",
          "success": true,
          "output": "[5, 10]"
        },
        {
          "example_index": 1,
          "input": "asteroids = [8,-8]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "asteroids = [10,2,-5]",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        },
        {
          "example_index": 3,
          "input": "asteroids = [3,5,-6,2,-1,4]",
          "expected_output": "[-6,2,4]",
          "success": true,
          "output": "[-6, 2, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode45.json",
    "problem_index_in_file": 0,
    "title": "Jump Game II",
    "description_snippet": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at index ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese (繁體). It is a typical Jump Game II problem. The algorithm: Greedy approach: maintain current max reachable and next max reachable, count jumps. Or BFS. Use greedy.\n\nWe must produce line by line: \"Start\", steps with arrows etc. Use the specified format. No real code.\n\nWe need to produce explanation per line in Chinese. Let's produce steps:\n\nStart // 程式開始執行\n→ Step 1: 讀取陣列 nums 與長度 n // 取得輸入資料\n→ Step 2: 初始化變數 currentEnd = 0, farthest = 0, jumps = 0 // 追蹤目前跳到的最遠點\n→ Decision: 是否已到達最後一個索引? // 檢查是否已完成\n    Yes → End // 已到達\n    No → →\n→ Step 3: 遍歷索引 i 從 0 到 n-2 // 只需遍歷到倒數第二個\n→ Step 4: 更新 farthest = max(farthest, i + nums[i]) // 找到能達到的最遠點\n→ Decision: i == currentEnd? // 到達目前跳的邊界\n    Yes → →\n        → Step 5: jumps += 1 // 增加跳數\n        → Step 6: currentEnd = farthest // 以新的最遠點作為下一跳的邊界\n    No →\n→ Decision: i == n-2? // 最後一次迴圈結束時\n    Yes → →\n        → Step 7: 輸出 jumps // 回傳最小跳數\n        → End\n    No → →\n→ End\n\nBut we need arrow syntax: For Decision we need Yes→ and No→ with indentation.\n\nMake sure each line has \"虛擬碼步驟 [space] // 解釋\". For decisions we need to indent. Provide arrow lines. Use → and indentation with tabs or spaces? Use spaces.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 讀取陣列 nums 與長度 n // 取得輸入資料\n→ Step 2: 初始化變數 currentEnd = 0, farthest = 0, jumps = 0 // 追蹤目前跳到的最遠點\n→ Decision: 是否已到達最後一個索引? // 檢查是否已完成\n    Yes → End // 已到達\n    No  → →\n→ Step 3: 遍歷索引 i 從 0 到 n-2 // 只需遍歷到倒數第二個\n→ Step 4: 更新 farthest = max(farthest, i + nums[i]) // 找到能達到的最遠點\n→ Decision: i == currentEnd? // 到達目前跳的邊界\n    Yes → →\n        → Step 5: jumps += 1 // 增加跳數\n        → Step 6: currentEnd = farthest // 以新的最遠點作為下一跳的邊界\n    No  → →\n→ Decision: i == n-2? // 最後一次迴圈結束時\n    Yes → →\n        → Step 7: 輸出 jumps // 回傳最小跳數\n        → End\n    No  → →\nEnd // 程式執行結束\n\nWe should ensure we didn't miss any step. Possibly we need to output jumps after loop ends. The loop goes to n-2; after loop, we need to output. We already have decision inside loop but might not cover case n-2 when no need. Actually we may just output after loop: Step 7: 輸出 jumps. But okay.\n\nMaybe simpler: after loop end, Step 7: 輸出 jumps.\n\nLet's rewrite simpler:\n\nStart\n→ Step 1: 讀取 nums 與 n\n→ Step 2: currentEnd = 0; farthest = 0; jumps = 0\n→ Step 3: for i in 0 .. n-2\n→ Step 4: farthest = max(farthest, i + nums[i])\n→ Decision: i == currentEnd?\n    Yes → →\n        → Step 5: jumps += 1\n        → Step 6: currentEnd = farthest\n    No  → →\n→ Step 7: 輸出 jumps\nEnd\n\nWe need decisions indentation. Provide explanation each line.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取陣列 nums 與長度 n // 取得輸入資料  \n→ Step 2: 初始化變數 currentEnd = 0, farthest = 0, jumps = 0 // 追蹤目前跳到的最遠點  \n→ Step 3: 針對索引 i 從 0 到 n-2 進行迴圈 // 只需遍歷到倒數第二個索引  \n→ Step 4: 更新 farthest = max(farthest, i + nums[i]) // 找到能跳到的最遠點  \n→ Decision: i == currentEnd? // 判斷是否已到達目前跳的邊界  \n  Yes → →  \n    → Step 5: jumps += 1 // 增加跳數  \n    → Step 6: currentEnd = farthest // 以新的最遠點作為下一跳的邊界  \n  No  → →  \n→ Step 7: 輸出 jumps // 回傳最小跳數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_jumps(nums):\n    \"\"\"計算最小跳數（贈品跳躍問題）\"\"\"\n    n = len(nums)\n    if n <= 1:\n        return 0\n\n    jumps = 0          # 已完成的跳數\n    current_end = 0    # 當前跳動區間的最遠邊界\n    farthest = 0       # 在當前區間內可達到的最遠點\n\n    for i in range(n - 1):\n        farthest = max(farthest, i + nums[i])   # 更新能達到的最遠點\n        if i == current_end:                    # 到達目前跳動區間末端\n            jumps += 1\n            current_end = farthest              # 下一個跳動區間\n\n    return jumps\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取整數列表。\n    支援兩種常見格式：\n    1. 直接給列表：\"[2,3,1,1,4]\"\n    2. 帶變量名：\"nums = [2,3,1,1,4]\"\n    \"\"\"\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        return eval(match.group(), {}, {})\n    return []\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    result = min_jumps(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,3,0,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode495.json",
    "problem_index_in_file": 0,
    "title": "Teemo Attacking",
    "description_snippet": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets po...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm. Problem: compute total poisoned time. Input: array timeSeries sorted non-decreasing, duration. We must compute union of intervals [t, t+duration-1]. Approach: iterate over times, accumulate poison time. For each attack i, if next attack time >= current start + duration => no overlap, add duration. Else overlap, add (timeSeries[i+1] - timeSeries[i])? Actually when overlapping: new attack resets timer; poison time contributed from start of this attack until min(next attack, start+duration). But typical solution: total += min(duration, timeSeries[i+1] - timeSeries[i]) for each except last, plus duration for last.\n\nSo we produce virtual code steps: Start, read inputs, if empty return 0, init total = 0, loop i 0 to len-2: add min(duration, timeSeries[i+1] - timeSeries[i]), after loop add duration for last. End.\n\nWe need to follow format. Let's produce each step with explanation.\n\nLet's generate:\n\nStart // 程式開始執行\n→ Step 1: 讀取 timeSeries 與 duration // 取得攻擊時間列與毒藥持續時間\n→ Decision: 如果 timeSeries 為空? // 檢查是否有攻擊\n    Yes → Step 2: 回傳 0 // 無攻擊則毒藥時間為 0\n    No  → Step 3: 設定 total = 0 // 初始化總毒藥時間\n→ Step 4: 取得 n = len(timeSeries) // 獲取攻擊數量\n→ Decision: 如果 n == 1? // 只一次攻擊\n    Yes → Step 5: total += duration // 加上一次毒藥時間\n    No  → Step 6: 迴圈 i 從 0 到 n-2 // 逐一處理相鄰攻擊\n        → Step 7: 計算 diff = timeSeries[i+1] - timeSeries[i] // 相鄰攻擊間隔\n        → Decision: 如果 diff >= duration? // 判斷是否重疊\n            Yes → Step 8: total += duration // 不重疊，完整 duration\n            No  → Step 9: total += diff // 重疊，僅累加間隔時間\n        → Step 10: // 迴圈結束\n    → Step 11: total += duration // 加上最後一次攻擊的完整 duration\n→ Step 12: 回傳 total // 回傳總毒藥時間\nEnd // 程式執行結束\n\nWe need ensure each line uses arrow or decision etc. For loops and condition need representation: Use → Step ... for each step, Decision with Yes→ etc. Provide explanation after //.\n\nMake sure formatting. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取 timeSeries 與 duration // 取得攻擊時間列與毒藥持續時間\n→ Decision: 如果 timeSeries 為空? // 檢查是否有攻擊\n    Yes → Step 2: 回傳 0 // 無攻擊則毒藥時間為 0\n    No  → Step 3: 設定 total = 0 // 初始化總毒藥時間\n→ Step 4: 取得 n = len(timeSeries) // 獲取攻擊數量\n→ Decision: 如果 n == 1? // 只一次攻擊\n    Yes → Step 5: total += duration // 加上一次毒藥時間\n    No  → Step 6: 迴圈 i 從 0 到 n-2 // 逐一處理相鄰攻擊\n        → Step 7: 計算 diff = timeSeries[i+1] - timeSeries[i] // 相鄰攻擊間隔\n        → Decision: 如果 diff >= duration? // 判斷是否重疊\n            Yes → Step 8: total += duration // 不重疊，完整 duration\n            No  → Step 9: total += diff // 重疊，僅累加間隔時間\n        → Step 10: // 迴圈結束\n    → Step 11: total += duration // 加上最後一次攻擊的完整 duration\n→ Step 12: 回傳 total // 回傳總毒藥時間\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        if not timeSeries:\n            return 0\n        total = 0\n        for i in range(len(timeSeries) - 1):\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        total += duration\n        return total\n\ndef parse_input(data: str):\n    # Extract the list of attack times\n    ts_match = re.search(r\"timeSeries\\s*=\\s*(\\[.*?\\])\", data, re.S)\n    # Extract the duration value\n    dur_match = re.search(r\"duration\\s*=\\s*(-?\\d+)\", data)\n    if not ts_match or not dur_match:\n        raise ValueError(\"Input format is incorrect.\")\n    timeSeries = ast.literal_eval(ts_match.group(1))\n    duration = int(dur_match.group(1))\n    return timeSeries, duration\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    timeSeries, duration = parse_input(input_data)\n    solution = Solution()\n    result = solution.findPoisonedDuration(timeSeries, duration)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode424.json",
    "problem_index_in_file": 0,
    "title": "Longest Repeating Character Replacement",
    "description_snippet": "You are given a string s and an integer k. You can choose any character of the string and change it ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for problem: longest repeating character substring after at most k changes. Typical sliding window: maintain window where count of most frequent char; window size - maxCount <= k. Need to output pseudocode with steps. Must follow format: each line: virtual code + \" // 解釋\". Use arrows. Use Start, End. Use Decision: etc. Provide line-by-line. Probably include variable initialization, loop over characters, maintain freq array, maxCount, left pointer, for each right char update freq, update maxCount, while window size - maxCount > k shrink left. Keep result. End. No actual code, just pseudocode.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, maxLen = 0, maxCount = 0, freq[26] = 0 // 初始化指標、長度、頻率\n→ Step 2: 對於 right 在 0 到 s.length-1 進行迴圈 // 循環遍歷字符串\n    → SubStep: let idx = s.charAt(right) - 'A' // 將字符轉換為索引\n    → SubStep: freq[idx]++ // 更新該字符頻率\n    → SubStep: maxCount = max(maxCount, freq[idx]) // 更新窗口內最高頻率字符\n    → Decision: 如果 (right - left + 1 - maxCount) > k? // 檢查需要改動超過 k\n        → Yes → SubDecision: while (right - left + 1 - maxCount) > k // 收縮窗口\n            → SubStep: freq[s.charAt(left) - 'A']-- // 減少左端字符頻率\n            → SubStep: left++ // 左指標右移\n            → SubStep: // 更新 maxCount 可能需要重新計算，這裡假設保留較大值即可\n        → No  // 窗口合法\n    → SubStep: maxLen = max(maxLen, right - left + 1) // 更新最大長度\n→ Step 3: 返回 maxLen // 結果\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟\" and explanation. The above includes substeps, but each line must be separate. Use arrows.\n\nLet's produce each line:\n\n1. Start // 程式開始執行\n2. → left = 0 // 左指標初始為 0\n3. → maxLen = 0 // 目前已知的最大長度\n4. → maxCount = 0 // 窗口中最頻繁字符的數量\n5. → freq[26] = 0 // 每個字母的頻率表\n6. → for right in 0 .. s.length-1 // 遍歷字符串\n7. →     idx = s.charAt(right) - 'A' // 把字符映射到 0-25\n8. →     freq[idx]++ // 增加該字符的頻率\n9. →     if freq[idx] > maxCount then maxCount = freq[idx] // 更新最高頻率\n10. →     if (right - left + 1 - maxCount) > k then // 若需要改動超過 k\n11. →         while (right - left + 1 - maxCount) > k do // 收縮左側\n12. →             freq[s.charAt(left) - 'A']-- // 減少左端字符頻率\n13. →             left++ // 左指標右移\n14. →             // maxCount 仍保持原值或重新計算（此處保留）\n15. →     maxLen = max(maxLen, right - left + 1) // 更新最大長度\n16. → return maxLen // 回傳結果\n17. End // 程式執行結束\n\nNeed to maintain format: each line with code + \" // 解釋\". Use arrows for steps inside loop? Use \"→\" for each line. For decision: use \"Decision:\" maybe. Let's adapt: Use \"Decision:\" before the if. For while, use \"While:\" maybe. The example uses Decision and Yes/No. So we can use Decision: and Yes → etc.\n\nLet's rewrite using the format:\n\nStart // 程式開始執行\n→ left = 0 // 左指標初始為 0\n→ maxLen = 0 // 目前已知的最大長度\n→ maxCount = 0 // 窗口中最頻繁字符的數量\n→ freq[26] = 0 // 每個字母的頻率表\n→ for right = 0 to s.length-1 // 遍歷字符串\n    → Decision: 將 s[right] 轉為索引 idx? // 取得字符索引\n        Yes → idx = s.charAt(right) - 'A' // 將字符映射到 0-25\n    → freq[idx]++ // 增加該字符的頻率\n    → Decision: 是否更新 maxCount? // 判斷是否為窗口中最高頻率\n        Yes → maxCount = freq[idx] // 更新最高頻率\n    → Decision: 窗口大小 - maxCount > k? // 檢查是否需要縮小窗口\n        Yes → While: 窗口大小 - maxCount > k\n            → freq[s.charAt(left) - 'A']-- // 減少左端字符頻率\n            → left++ // 左指標右移\n            → // maxCount 仍保持不變或重新計算（此處保留）\n        No  // 窗口合法\n    → maxLen = max(maxLen, right - left + 1) // 更新最大長度\n→ return maxLen // 回傳結果\nEnd // 程式執行結束\n\nBut \"While:\" line is not specified. Could use \"While:\" as arrow? But we should maintain consistency. Might be simpler to not use Decision lines but just sequential steps. The requirement says use arrows and Decision. We can just use Decision for the if and Yes/No but no else branch. For while, we might use \"While:\" but not required. Let's keep consistent with example.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ left = 0 // 左指標初始為 0  \n→ maxLen = 0 // 目前已知的最大長度  \n→ maxCount = 0 // 窗口中最頻繁字符的數量  \n→ freq[26] = 0 // 每個字母的頻率表  \n→ for right = 0 to s.length-1 // 遍歷字符串  \n  → idx = s.charAt(right) - 'A' // 把字符映射到 0-25  \n  → freq[idx]++ // 增加該字符的頻率  \n  → Decision: 是否更新 maxCount? // 判斷是否為窗口中最高頻率  \n    Yes → maxCount = freq[idx] // 更新最高頻率  \n  → Decision: 窗口大小 - maxCount > k? // 檢查是否需要縮小窗口  \n    Yes → While: 窗口大小 - maxCount > k  \n      → freq[s.charAt(left) - 'A']-- // 減少左端字符頻率  \n      → left++ // 左指標右移  \n      // maxCount 仍保持不變或重新計算（此處保留）  \n    No // 窗口合法  \n  → maxLen = max(maxLen, right - left + 1) // 更新最大長度  \n→ return maxLen // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = [0] * 26\n        max_count = 0\n        left = 0\n        res = 0\n\n        for right in range(len(s)):\n            idx = ord(s[right]) - ord('A')\n            count[idx] += 1\n            max_count = max(max_count, count[idx])\n\n            while (right - left + 1) - max_count > k:\n                left_idx = ord(s[left]) - ord('A')\n                count[left_idx] -= 1\n                left += 1\n\n            res = max(res, right - left + 1)\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    # Try to parse input in the format: s = \"ABAB\", k = 2\n    match = re.search(r's\\s*=\\s*\"([^\"]+)\"\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if match:\n        s = match.group(1)\n        k = int(match.group(2))\n    else:\n        # Fallback: assume the input is two space-separated values, e.g. ABAB 2\n        parts = data.split()\n        if len(parts) >= 2:\n            s = parts[0].strip('\"')\n            k = int(parts[1])\n        else:\n            # If input is not in expected format, exit gracefully\n            print(\"Invalid input format\")\n            sys.exit(1)\n\n    solution = Solution()\n    result = solution.characterReplacement(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode58.json",
    "problem_index_in_file": 0,
    "title": "Length of Last Word",
    "description_snippet": "Given a string s consisting of words and spaces, return the length of the last word in the string.\n\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: given string s, return length of last word. Use steps, decisions. Provide explanation comments. Each line: Virtual code step + space + // explanation. Use arrows and structure.\n\nStart, then iterate from end, skip spaces, count word length until space or start. Or we can split, but virtual. We'll show two possible approaches: iterate from end. Provide decision points: if last character is space, skip. Then count characters until space or beginning.\n\nWe must produce steps line by line. Provide comments.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Set index = length of s - 1 // 從字串末尾開始\n→ Decision: If index < 0? // 判斷字串是否為空\n    Yes → Step 2: Return 0 // 空字串無最後單詞長度\n    No  →\n→ Decision: 如果 s[index] 為空格? // 若末尾為空格，需跳過空格\n    Yes → Step 3: While index >= 0 且 s[index] 為空格: index -= 1 // 跳過所有尾部空格\n    No  →\n→ Step 4: Set count = 0 // 開始計算最後單詞長度\n→ Decision: index < 0? // 若跳完後索引已小於 0，表示字串全為空格\n    Yes → Step 5: Return 0 // 無單詞，返回 0\n    No  →\n→ While index >= 0 且 s[index] 非空格: // 遍歷最後單詞字符\n    count += 1\n    index -= 1\n→ Step 6: Return count // 返回最後單詞長度\nEnd // 程式執行結束\n\nNeed to ensure each line includes arrow or decision etc. Provide \"Decision:\" lines and Yes/No arrows.\n\nMake sure to use \"→\" for steps and decisions, \"Yes →\" and \"No →\" for branches.\n\nAdd comments in Chinese after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set index = length of s - 1 // 從字串末尾開始  \n→ Decision: index < 0? // 判斷字串是否為空  \n  Yes → Step 2: Return 0 // 空字串無最後單詞長度  \n  No  →  \n→ Decision: s[index] 為空格? // 若末尾為空格，需跳過空格  \n  Yes → Step 3: While index >= 0 且 s[index] 為空格: index -= 1 // 跳過所有尾部空格  \n  No  →  \n→ Step 4: Set count = 0 // 開始計算最後單詞長度  \n→ Decision: index < 0? // 若跳完後索引已小於 0，表示字串全為空格  \n  Yes → Step 5: Return 0 // 無單詞，返回 0  \n  No  →  \n→ While index >= 0 且 s[index] 非空格: // 遍歷最後單詞字符  \n  count += 1  \n  index -= 1  \n→ Step 6: Return count // 返回最後單詞長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef length_of_last_word(s: str) -> int:\n    \"\"\"計算字串 s 最後一個單詞的長度。\"\"\"\n    i = len(s) - 1\n\n    # 跳過尾部空格\n    while i >= 0 and s[i] == ' ':\n        i -= 1\n    if i < 0:               # 全是空格或空字串\n        return 0\n\n    # 計算最後一個單詞長度\n    count = 0\n    while i >= 0 and s[i] != ' ':\n        count += 1\n        i -= 1\n    return count\n\ndef main() -> None:\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 兼容輸入格式 \"s = \\\"Hello World\\\"\" 或直接輸入字串\n    if raw_input.lower().startswith('s'):\n        _, _, rest = raw_input.partition('=')\n        raw_input = rest.strip()\n\n    # 去掉外層雙引號或單引號\n    if (raw_input.startswith('\"') and raw_input.endswith('\"')) or \\\n       (raw_input.startswith(\"'\") and raw_input.endswith(\"'\")):\n        raw_input = raw_input[1:-1]\n\n    result = length_of_last_word(raw_input)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello World\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"   fly me   to   the moon  \"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"luffy is still joyboy\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode33.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array",
    "description_snippet": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being pas...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for binary search in rotated sorted array. The algorithm: use binary search with check of sorted side. Steps: Start, low=0, high=nums.length-1, while low <= high: mid=(low+high)/2, if nums[mid]==target return mid. Determine if left half sorted: nums[low] <= nums[mid]. If left sorted: if target in [nums[low], nums[mid]) then high=mid-1 else low=mid+1. Else right half sorted: if target in (nums[mid], nums[high]] then low=mid+1 else high=mid-1. After loop return -1. End.\n\nWe need to produce virtual code lines with arrows and decision blocks. Let's produce something like:\n\nStart // 程式開始執行\n→ Step 1: low ← 0, high ← nums.length - 1 // 初始化左右指標\n→ Decision: 是否存在尚未檢查的元素? // 循環判斷\n    Yes → Step 2: mid ← (low + high) / 2 // 計算中點\n    → Decision: nums[mid] == target? // 檢查中點是否為目標\n        Yes → Step 3: Return mid // 找到目標，返回索引\n        No → Decision: nums[low] <= nums[mid]? // 判斷左半段是否有序\n            Yes → Decision: nums[low] <= target < nums[mid]? // 目標是否在左半段\n                Yes → Step 4: high ← mid - 1 // 將搜尋範圍縮小到左半段\n                No  → Step 5: low ← mid + 1 // 目標在右半段，調整左指標\n            No  → Decision: nums[mid] < target <= nums[high]? // 目標是否在右半段\n                Yes → Step 6: low ← mid + 1 // 目標在右半段，調整左指標\n                No  → Step 7: high ← mid - 1 // 目標在左半段，調整右指標\n    No  → Step 8: Return -1 // 未找到目標\nEnd // 程式結束\n\nBut we need to reflect arrow style: \"→\" after each line. Also decisions: \"Decision:\" lines indent maybe.\n\nLet's format exactly. Use indent with 4 spaces? Example format shows 4 spaces for nested lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: low ← 0, high ← nums.length - 1 // 初始化左右指標\n→ Decision: low ≤ high? // 是否還有未檢查的區間\n    Yes → Step 2: mid ← (low + high) / 2 // 計算中點\n    → Decision: nums[mid] == target? // 判斷是否找到目標\n        Yes → Step 3: Return mid // 找到，返回索引\n        No  → Decision: nums[low] ≤ nums[mid]? // 判斷左半段是否有序\n            Yes → Decision: nums[low] ≤ target < nums[mid]? // 目標是否在左半段\n                Yes → Step 4: high ← mid - 1 // 缩小到左半段\n                No  → Step 5: low ← mid + 1 // 目标在右半段\n            No  → Decision: nums[mid] < target ≤ nums[high]? // 目標是否在右半段\n                Yes → Step 6: low ← mid + 1 // 目标在右半段\n                No  → Step 7: high ← mid - 1 // 目标在左半段\n    No  → Step 8: Return -1 // 循環結束，未找到目標\nEnd // 程式結束\n\nBut we must keep the indentation consistent: use 4 spaces indent for nested lines.\n\nAlso, the \"Decision:\" lines should be in the format like the example.\n\nWe need to use \"→ Decision:\" for each decision. Indentation lines must be preceded by 4 spaces for nested.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0, high ← nums.length - 1 // 初始化左右指標  \n→ Decision: low ≤ high? // 是否還有未檢查的區間  \n  Yes → Step 2: mid ← (low + high) / 2 // 計算中點  \n  → Decision: nums[mid] == target? // 判斷是否找到目標  \n    Yes → Step 3: Return mid // 找到，返回索引  \n    No → Decision: nums[low] ≤ nums[mid]? // 判斷左半段是否有序  \n      Yes → Decision: nums[low] ≤ target < nums[mid]? // 目標是否在左半段  \n        Yes → Step 4: high ← mid - 1 // 缩小到左半段  \n        No  → Step 5: low ← mid + 1 // 目標在右半段  \n      No → Decision: nums[mid] < target ≤ nums[high]? // 目標是否在右半段  \n        Yes → Step 6: low ← mid + 1 // 目標在右半段  \n        No  → Step 7: high ← mid - 1 // 目標在左半段  \n  No → Step 8: Return -1 // 循環結束，未找到目標  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:           # 左半段有序\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:                                 # 右半段有序\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 匹配 \"nums = [...] , target = ...\"\n    pattern = re.compile(r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)', re.S)\n    match = pattern.search(data)\n    if not match:\n        print(-1)\n        sys.exit()\n\n    nums_str, target_str = match.group(1), match.group(2)\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        print(-1)\n        sys.exit()\n\n    target = int(target_str)\n    sol = Solution()\n    print(sol.search(nums, target))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [1], target = 0",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode676.json",
    "problem_index_in_file": 0,
    "title": "Implement Magic Dictionary",
    "description_snippet": "Design a data structure that is initialized with a list of different words. Provided a string, you s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementation of MagicDictionary class. Use the requested format. Each line: virtual code step + space + // explanation.\n\nWe should include Start, End, Decision, etc. Also need to design the algorithm: maybe build a trie or use hashmap of patterns. But we just need pseudocode, not actual code.\n\nSo lines:\n\nStart\n→ Step 1: Initialize empty dictionary set // create storage for words\n→ Step 2: buildDict(dictionary) // store words\n→ Decision: For each word in dictionary // store\n    Yes → Add word to dictionary set // store\nEnd of buildDict\n\nSearch method:\n→ Step: search(searchWord)\n→ For each word in dictionary set\n    → Decision: if length differs? // skip\n        Yes → Continue\n    → For each index i in word length\n        → Generate modifiedWord by replacing searchWord[i] with word[i]\n        → Decision: if modifiedWord equals word and changes count ==1? // Actually we check exactly one change\nBut maybe simpler: count differences between searchWord and each word. If diff==1 return true. If diff==0 skip. So algorithm:\n\nSearch:\n→ Step: For each word in dict\n    → Decision: if length != searchWord length? skip\n    → Initialize diff=0\n    → For each index\n        → If searchWord[i] != word[i] diff++\n        → If diff>1 break\n    → Decision: if diff==1 return true\n→ End // return false\n\nReturn boolean.\n\nOk produce pseudocode lines accordingly.\n\nNeed to include arrow structure.\n\nLet's produce:\n\nStart\n→ MagicDictionary() // constructor, initialize data structure\n→ Step 1: dict ← empty set // store dictionary words\n→ End // constructor end\n\nbuildDict\n→ buildDict(dictionary) // method to build dictionary\n→ Step 2: for each word in dictionary\n    → Step 3: add word to dict // store unique words\n→ End // buildDict finished\n\nsearch\n→ search(searchWord) // method to check if one edit\n→ Step 4: for each word in dict\n    → Decision: if length(word) != length(searchWord) ?\n        Yes → continue // skip words of different length\n    → Step 5: diff ← 0 // count differing positions\n    → Step 6: for i from 0 to length(word)-1\n        → Decision: if word[i] ≠ searchWord[i] ?\n            Yes → diff ← diff + 1\n            No  → // nothing\n        → Decision: if diff > 1 ?\n            Yes → break // no need to continue\n    → Decision: if diff == 1 ?\n        Yes → return true // found one edit match\n    → // else continue loop\n→ End // no match found\n→ Return false // after loop\n\nEnd\n\nMake sure each line has the virtual code and // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ MagicDictionary() // 建構子，初始化資料結構\n→ Step 1: dict ← empty set // 建立一個空集合來儲存字典中的單字\n→ End // 建構子結束\n\n→ buildDict(dictionary) // 建立字典方法\n→ Step 2: for each word in dictionary\n    → Step 3: add word to dict // 將每個不同單字加入集合\n→ End // buildDict 方法結束\n\n→ search(searchWord) // 搜尋方法，判斷是否能改變一個字元符合字典\n→ Step 4: for each word in dict\n    → Decision: if length(word) ≠ length(searchWord) ?\n        Yes → continue // 不同長度的單字直接跳過\n    → Step 5: diff ← 0 // 计数两字符串不同位置的数量\n    → Step 6: for i from 0 to length(word)-1\n        → Decision: if word[i] ≠ searchWord[i] ?\n            Yes → diff ← diff + 1\n            No  → // 位置相同，無需操作\n        → Decision: if diff > 1 ?\n            Yes → break // 超過一個不同字元即不可能符合條件\n    → Decision: if diff == 1 ?\n        Yes → return true // 找到正好一個字元不同的匹配\n→ End // 所有單字都檢查完畢後仍未符合\n→ Return false // 無法僅改變一個字元達到字典中的任何單字\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Find split between method list and argument list\n    split_idx = data.find('], [')\n\n    first_part = data[:split_idx + 1]  # include first closing bracket\n    second_part = data[split_idx + 2:]  # skip '], '\n\n    # Parse the two lists\n    methods = json.loads(first_part)\n    args_list = json.loads('[' + second_part)  # add leading '['\n\n    results = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == 'MagicDictionary':\n            obj = MagicDictionary()\n            results.append(None)\n        elif method == 'buildDict':\n            # args is a list containing the dictionary list\n            obj.buildDict(args[0])\n            results.append(None)\n        elif method == 'search':\n            results.append(obj.search(args[0]))\n        else:\n            results.append(None)\n\n    # Convert Python values to the expected JSON-like output\n    def to_json_like(val):\n        if val is None:\n            return 'null'\n        if isinstance(val, bool):\n            return 'true' if val else 'false'\n        return str(val)\n\n    output = '[' + ', '.join(to_json_like(r) for r in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmphvgz3lb8.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmphvgz3lb8.py\", line 33, in main\n    args_list = json.loads('[' + second_part)  # add leading '['\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 79 (char 78)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode672.json",
    "problem_index_in_file": 0,
    "title": "Bulb Switcher II",
    "description_snippet": "There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code that solves the problem: number of distinct bulb states after exactly presses button presses, given n bulbs initially all on, four buttons with described toggle actions. We need step-by-step virtual code. We must not output actual code, only pseudo-steps. We need to include explanation each line.\n\nWe need to produce algorithm: We know known problem from Leetcode 944 \"Bulb Switcher II\". The result depends only on presses up to 4 and n > something.\n\nGeneral solution: For n = 0 or 1? Actually bulbs labeled from 1 to n, initial all on.\n\nObservations: Buttons operations form group of toggles; due to symmetry, number of distinct states depends on presses and n. Known results: For n==0, 1? Actually n>=1. Cases:\n\nIf presses==0 => 1 state (all on)\nIf n==1:\n- presses==1 => 2 states? Actually only button 1 flips all, button 2 (even) doesn't affect, button 3 (odd) flips 1, button 4 (3k+1) flips 1. So distinct states 2: on or off. Presses>1? The group size limited.\n\nBetter to adopt general known formula: Let m = min(n, 4). Number of distinct states depends on presses: if presses==0 => 1; else if presses==1 => 2; else if presses==2 => 4; else if presses==3 => 7; else (presses>=4) => 8. But for n < 4, reduce accordingly: For n=1: results: if presses==0 =>1; else =>2. For n=2: if presses==0=>1; presses==1=>2; presses>=2=>3? Actually known formula: For n=2: 3 states for presses>=2? Let's recall known results: For n=2: if presses==0 =>1; presses==1 =>2; presses>=2 =>3. For n=3: if presses==0 =>1; presses==1=>2; presses==2=>4; presses>=3=>7? Wait n=3 <4, so max distinct states 7? For n=3 maybe 7 but limited? Actually with 3 bulbs, number of distinct states up to 7? Let's verify: known from Leetcode: answer = min(8, 2^min(n, 4) - something?). Let's derive: For n>=4: if presses==0:1; 1:2; 2:4; 3:7; 4+:8.\n\nFor n=1: max 2 distinct: 1 press -> 2, else 2.\n\nFor n=2: max 3 distinct: presses 0 ->1, 1->2, >=2->3.\n\nFor n=3: max 7 distinct? But with 3 bulbs can't have 8 combos because 8 combos > 2^3=8 so could be 8? Actually all 8 states possible? But initial all on. Buttons operations allow flips. I think for n=3, maximum distinct states is 7 for presses>=3? Let's check: For n=3, there are 8 possible states. But due to operations, maybe all 8 achievable? Let's check quickly: Button1 flips all; Button2 flips 2; Button3 flips 1 and3; Button4 flips 1 only (since 4k+1 only 1). So group generated by these toggles maybe all 8? But known from Leetcode: For n=3, distinct states up to 7 for presses>=3? Wait example: n=3, presses=1: can get states: all on, all off (by button1), off for 1 and3 only (by button3), off for 2 only (by button2), off for 1 only (by button4), off for 3 only? Actually button3 flips 1&3 so off for both; button4 flips 1 so off for 1; so possible states: all on, all off, [off, on, off], [on, off, on], [off, off, on]? Let's check combinations. Might be 5? Let's not dwell. We'll just use known formula from Leetcode: For n=3, answer: if presses==0 =>1; presses==1 =>2; presses==2 =>4; presses>=3 =>7. Wait but 7 > 8? 7 <=8 so okay. So for n=3, answer max 7.\n\nThus algorithm: compute m = min(n, 4). Then use presses mapping: if presses==0 =>1; elif presses==1 =>2; elif presses==2 =>4; elif presses==3 =>7; else =>8. But if m<4 reduce accordingly: Actually mapping depends on m: if m==1: ans= min(2, presses==0?1:2). if m==2: ans = min(3, if presses==0:1 else if presses==1:2 else:3). if m==3: ans = min(7, if presses==0:1 else if presses==1:2 else if presses==2:4 else:7). if m>=4: as above.\n\nLet's produce virtual steps: Input n, presses. Determine minBulbs = min(n,4). Determine maxStates based on presses and minBulbs. Output maxStates.\n\nWe'll produce pseudocode lines with explanations.\n\nNeed to use virtual code steps with arrows, decisions. We'll produce:\n\nStart\n→ Step: Read n, presses // 讀入燈泡數與按壓次數\n→ Step: minBulbs ← min(n,4) // 只需考慮前4個燈泡的排列\n→ Decision: If presses == 0? // 無操作\n    Yes → Step: ans ← 1 // 唯一狀態全亮\n    No → Decision: If minBulbs == 1? // 僅1個燈\n        Yes → Decision: If presses == 1? // 只需一次可切換\n            Yes → Step: ans ← 2 // 亮或滅\n            No  → Step: ans ← 2 // 其餘按壓不影響\n        No  → Decision: If minBulbs == 2? // 兩個燈\n            Yes → Decision: If presses == 1? // 一次可得2種\n                Yes → Step: ans ← 2\n                No  → Step: ans ← 3 // 兩次以上可得3種\n            No  → Decision: If minBulbs == 3? // 三個燈\n                Yes → Decision: If presses == 1? → ans ← 2\n                           If presses == 2? → ans ← 4\n                           Else → ans ← 7\n                No  → // minBulbs >=4\n                    Decision: If presses == 1? → ans ← 2\n                               If presses == 2? → ans ← 4\n                               If presses == 3? → ans ← 7\n                               Else → ans ← 8\nEnd\n\nBut we need to keep each line with virtual code arrow and comment. Ensure each line is separate. We'll produce step-by-step decision tree.\n\nWe need to keep consistent formatting: Start // 程式開始執行\n→ Step: ... // 解釋\n\nLet's produce.\n\nAlso we need to handle the decisions elegantly. Provide nested decisions accordingly.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: n ← input() // 讀入燈泡數\n→ Step 2: presses ← input() // 讀入按壓次數\n→ Step 3: minBulbs ← min(n, 4) // 只需考慮前四個燈泡，因為其餘燈泡對狀態數無影響\n→ Decision: If presses == 0? // 沒有按壓\n    Yes → Step 4: ans ← 1 // 唯一狀態：全部亮\n    No  → Decision: If minBulbs == 1? // 只有一個燈泡\n        Yes → Decision: If presses == 1? // 只需一次按壓即可切換\n            Yes → Step 5: ans ← 2 // 亮或滅\n            No  → Step 6: ans ← 2 // 任意多於一次按壓都不改變可達狀態數\n        No  → Decision: If minBulbs == 2? // 兩個燈泡\n            Yes → Decision: If presses == 1? // 一次按壓可得到兩種\n                Yes → Step 7: ans ← 2\n                No  → Step 8: ans ← 3 // 兩次以上可得到三種\n            No  → Decision: If minBulbs == 3? // 三個燈泡\n                Yes → Decision: If presses == 1? // 只得兩種\n                    Yes → Step 9: ans ← 2\n                    No  → Decision: If presses == 2? // 四種\n                        Yes → Step 10: ans ← 4\n                        No  → Step 11: ans ← 7 // 三次以上可得七種\n                No  → // minBulbs >= 4\n                    Decision: If presses == 1? // 兩種\n                        Yes → Step 12: ans ← 2\n                        No  → Decision: If presses == 2? // 四種\n                            Yes → Step 13: ans ← 4\n                            No  → Decision: If presses == 3? // 七種\n                                Yes → Step 14: ans ← 7\n                                No  → Step 15: ans ← 8 // 四次以上可得八種\nEnd // 程式結束\n\nEnsure each line uses correct syntax. Use `Decision:` lines with indent? We can keep them sequentially. But need to maintain correct indentation? Not necessary, but we can show nested decisions.\n\nLet's output this.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← input() // 讀入燈泡數 n  \n→ Step 2: presses ← input() // 讀入按壓次數 presses  \n→ Step 3: minBulbs ← min(n, 4) // 只需考慮前四個燈泡，因為其餘燈泡對狀態數無影響  \n→ Decision: presses == 0? // 沒有按壓  \n    Yes → Step 4: ans ← 1 // 唯一狀態：全部亮  \n    No → Decision: minBulbs == 1? // 只有一個燈泡  \n        Yes → Decision: presses == 1? // 只需一次按壓即可切換  \n            Yes → Step 5: ans ← 2 // 亮或滅  \n            No → Step 6: ans ← 2 // 任意多於一次按壓都不改變可達狀態數  \n        No → Decision: minBulbs == 2? // 兩個燈泡  \n            Yes → Decision: presses == 1? // 一次按壓可得到兩種  \n                Yes → Step 7: ans ← 2  \n                No → Step 8: ans ← 3 // 兩次以上可得到三種  \n            No → Decision: minBulbs == 3? // 三個燈泡  \n                Yes → Decision: presses == 1? // 只得兩種  \n                    Yes → Step 9: ans ← 2  \n                    No → Decision: presses == 2? // 四種  \n                        Yes → Step 10: ans ← 4  \n                        No → Step 11: ans ← 7 // 三次以上可得七種  \n                No → // minBulbs ≥ 4  \n                    Decision: presses == 1? // 兩種  \n                        Yes → Step 12: ans ← 2  \n                        No → Decision: presses == 2? // 四種  \n                            Yes → Step 13: ans ← 4  \n                            No → Decision: presses == 3? // 七種  \n                                Yes → Step 14: ans ← 7  \n                                No → Step 15: ans ← 8 // 四次以上可得八種  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_states(n: int, presses: int) -> int:\n    \"\"\"計算在 n 個燈泡、exactly presses 次按鈕後可達到的不同燈泡狀態數。\"\"\"\n    m = min(n, 4)            # 只需要考慮前 4 個燈泡，因為其餘燈泡對結果無影響\n    if presses == 0:\n        return 1\n    if m == 1:\n        return 2\n    if m == 2:\n        return 3 if presses == 1 else 4\n    if m == 3:\n        if presses == 1:\n            return 2\n        elif presses == 2:\n            return 4\n        else:\n            return 7\n    # m >= 4\n    if presses == 1:\n        return 2\n    elif presses == 2:\n        return 4\n    elif presses == 3:\n        return 7\n    else:\n        return 8\n\ndef main() -> None:\n    # 從 stdin 讀取所有內容，提取所有整數\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, presses = nums[0], nums[1]\n    result = count_states(n, presses)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, presses = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '2'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode60.json",
    "problem_index_in_file": 0,
    "title": "Permutation Sequence",
    "description_snippet": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\n\nBy listing and labeling all o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line, with explanation. The problem: Given n, k, return k-th permutation of [1..n] in lexicographic order.\n\nWe need to generate steps: compute factorials, find digits by greedy. Provide virtual code with arrows and decisions.\n\nWe need to output in the required format. Each line: \"虛擬碼步驟 // 解釋/說明\".\n\nWe should include Start, End. Use Decision lines with Yes → and No →.\n\nWe must produce the algorithm.\n\nLet's produce:\n\nStart\n→ Step 1: 計算 1..n 的 factorials 0!..n! // 事先計算階乘以便快速查找\n→ Step 2: 建立可用數字列表 list = [1,2,...,n] // 用於選取下一個位元\n→ Step 3: 調整 k ← k-1 // 因為索引從 0 開始\n→ Decision: n 為 0? // 判斷是否已經沒有位元需要處理\n    Yes → End // 所有位元已確定，直接結束\n    No  → Step 4: 計算 blockSize = (n-1)! // 每個首位固定的排列數\n→ Step 5: 計算 index = k / blockSize // 選取第 index 個可用數字作為首位\n→ Step 6: Append list[index] 到結果 // 加入該位元到答案\n→ Step 7: 刪除 list[index]  // 移除已選數字\n→ Step 8: 更新 k ← k mod blockSize // 檢索剩餘的索引\n→ Step 9: n ← n-1 // 減少剩餘位元數\n→ Decision: n 為 0? // 重新檢查\n    Yes → End // 生成完成\n    No  → (回到 Step 4)\n\nEnd // 結束程式\n\nNeed to ensure we show the loop. Use recursion or loop with decision. Use arrows.\n\nLet's produce in order.\n\nAlso need to ensure each line has comment. Should not include actual code.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 0! 到 n! 的階乘表 // 方便快速取得各階段的排列數  \n→ Step 2: 建立可用數字列表 list = [1, 2, …, n] // 用來挑選下一個位元  \n→ Step 3: 調整 k ← k - 1 // 因為計算時以 0 為起始索引  \n→ Decision: n 為 0? // 判斷是否已經沒有位元需要處理  \n  Yes → End // 所有位元已確定，直接結束  \n  No  → Step 4: 計算 blockSize = fact[n-1] // 每個首位固定時剩餘排列數  \n→ Step 5: 計算 index = k / blockSize // 取得當前位元在 list 中的位置  \n→ Step 6: 把 list[index] 加入結果字符串 // 選取並記錄此位元  \n→ Step 7: 從 list 刪除 index 位置的元素 // 防止重複使用  \n→ Step 8: 更新 k ← k % blockSize // 重新定位剩餘排列的索引  \n→ Step 9: n ← n - 1 // 剩餘位元數減一  \n→ Decision: n 為 0? // 檢查是否還有位元需要決定  \n  Yes → End // 已完成所有位元的選擇  \n  No  → (回到 Step 4) // 進行下一輪循環  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef get_permutation(n: int, k: int) -> str:\n    \"\"\"Return the k-th lexicographic permutation of the numbers 1..n.\"\"\"\n    # Prepare list of available numbers\n    numbers = list(range(1, n + 1))\n    # Convert k to 0-indexed\n    k -= 1\n    result = []\n\n    # Build the permutation digit by digit\n    for remaining in range(n, 0, -1):\n        fact = 1\n        # Compute (remaining-1)!\n        for i in range(1, remaining):\n            fact *= i\n        index = k // fact\n        result.append(str(numbers.pop(index)))\n        k %= fact\n\n    return ''.join(result)\n\ndef main() -> None:\n    # Read entire input\n    data = sys.stdin.read().strip()\n    # Extract all integers (works for formats like \"n = 3, k = 3\" or \"3 3\")\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    # Compute and output the permutation\n    print(get_permutation(n, k))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 3",
          "expected_output": "\"213\"",
          "success": true,
          "output": "213"
        },
        {
          "example_index": 1,
          "input": "n = 4, k = 9",
          "expected_output": "\"2314\"",
          "success": true,
          "output": "2314"
        },
        {
          "example_index": 2,
          "input": "n = 3, k = 1",
          "expected_output": "\"123\"",
          "success": true,
          "output": "123"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode744.json",
    "problem_index_in_file": 0,
    "title": "Find Smallest Letter Greater Than Target",
    "description_snippet": "You are given an array of characters letters that is sorted in non-decreasing order, and a character...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for algorithm: given sorted array letters, find smallest char > target, else wrap to first. Use binary search. We should produce virtual code lines with arrow etc. Format: \"Start // ...\", then \"→ Step 1: ...\" etc.\n\nWe need to output step by step: Start, input, binary search, etc. Provide decision steps.\n\nWe should include at least a binary search. Steps:\n\nStart\n→ Input letters array and target\n→ Step 1: 初始化 left=0, right=length(letters)-1\n→ Decision: While left <= right? (binary search loop)\n   Yes → Step 2: mid = (left+right)//2\n   → Decision: letters[mid] <= target?\n       Yes → left = mid+1\n       No  → right = mid-1\n   → (loop back)\nNo → Step 3: Check left index; if left < length => answer = letters[left]; else answer = letters[0]\n→ Step 4: Return answer\nEnd\n\nAlso handle wrap. Provide explanation comments.\n\nLet's craft lines accordingly. Use arrow indentation. The sample uses indentation for nested decisions.\n\nWe'll produce lines: Start, → Input, etc.\n\nMake sure to follow formatting exactly: Each line: \"虛擬碼步驟 // 解釋\" with a space between step and comment.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input letters, target // 取得已排序的字母陣列和目標字元  \n→ Step 1: left ← 0, right ← length(letters) - 1 // 設定二分搜尋範圍  \n→ Decision: left ≤ right? // 是否還有範圍可以搜尋？  \n  Yes → Step 2: mid ← (left + right) // 2 // 計算中間索引  \n   Decision: letters[mid] ≤ target? // 中間字母是否小於或等於目標？  \n    Yes → left ← mid + 1 // 目標在右半邊  \n    No  → right ← mid - 1 // 目標在左半邊  \n       ← 回到 Decision: left ≤ right? // 繼續搜尋  \n  No  → Step 3: Answer ← (left < length(letters)) ? letters[left] : letters[0] // 左索引若在範圍內取該字母，否則回到陣列首  \n→ Step 4: Return Answer // 輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def nextGreatestLetter(self, letters, target):\n        \"\"\"\n        在已排序的字母陣列 letters 中找出最小的大於 target 的字母。\n        若不存在，則回到陣列最前面。\n        \"\"\"\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if letters[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        # left 可能等於 len(letters)，此時取 0\n        return letters[left % len(letters)]\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，支援類似 'letters = [\"c\",\"f\",\"j\"], target = \"a\"' 的格式。\n    \"\"\"\n    letters_match = re.search(r'letters\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(\\'[^\\']*\\'|\"[^\"]*\")', data)\n\n    if letters_match and target_match:\n        letters = ast.literal_eval(letters_match.group(1))\n        target = ast.literal_eval(target_match.group(1))\n        return letters, target\n\n    # 若格式不符合上述，嘗試逐行解析\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        letters = ast.literal_eval(lines[0])\n        target = ast.literal_eval(lines[1])\n        return letters, target\n\n    raise ValueError(\"無法解析輸入格式\")\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    letters, target = parse_input(input_data)\n    solution = Solution()\n    result = solution.nextGreatestLetter(letters, target)\n\n    # 根據範例輸出帶引號的字母\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"a\"",
          "expected_output": "\"c\"",
          "success": true,
          "output": "\"c\""
        },
        {
          "example_index": 1,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"c\"",
          "expected_output": "\"f\"",
          "success": true,
          "output": "\"f\""
        },
        {
          "example_index": 2,
          "input": "letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"",
          "expected_output": "\"x\"",
          "success": true,
          "output": "\"x\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode496.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element I",
    "description_snippet": "The next greater element of some element x in an array is the first greater element that is to the r...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode with explanation. Steps: build stack, iterate nums2 from right to left to compute next greater for each element. Map element to next greater. Then for each in nums1 output mapping or -1. Use virtual code.\n\nLet's craft lines.\n\nStart\n→ Step 1: 初始化空棧 S // 用於存儲候選較大元素\n→ Step 2: 初始化空映射 map // key: element, value: next greater\n\n→ Decision: 迭代 nums2 從右到左? // 需要逆序遍歷\n    Yes → Loop for i from len(nums2)-1 down to 0:\n        → Decision: S 是否為空? // 確定是否存在候選\n            Yes → map[nums2[i]] ← -1 // 沒有更大元素\n            No → \n                → Decision: S.top() > nums2[i]?\n                    Yes → map[nums2[i]] ← S.top() // top 是下一個更大\n                    No →\n                        → Step 3: 循環彈出 S 直至 top > nums2[i] 或 S 空\n                        → Decision: S 空? \n                            Yes → map[nums2[i]] ← -1\n                            No → map[nums2[i]] ← S.top()\n        → Step 4: 推入 nums2[i] 到 S // 將當前元素加入棧供左側使用\n    End Loop\n\n→ Step 5: 初始化結果陣列 ans // 對應 nums1\n\n→ Loop for each value v in nums1:\n    → Step 6: ans.append( map[v] ) // 取映射值\n\n→ End\n\nNeed proper syntax. Use arrow \"→\" per line. Provide explanation after //.\n\nLet's produce lines with each step.\n\nAlso ensure no code, only virtual code.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空棧 S // 用來儲存右側可作為「下一較大」的候選元素  \n→ Step 2: 建立空映射 map // key: 數值, value: 其下一較大元素（若無則 -1）  \n\n→ Decision: 從 nums2 逆向遍歷? // 為了能正確找到右側下一較大  \n    Yes → Loop for i from nums2.length - 1 down to 0:  \n        → Decision: S 是否為空? // 判斷是否還有候選元素  \n            Yes → map[nums2[i]] ← -1 // 無可用的下一較大元素  \n            No →  \n                → Decision: S.top() > nums2[i]? // 最小堆頂是否已經比當前大  \n                    Yes → map[nums2[i]] ← S.top() // 直接使用堆頂作為答案  \n                    No →  \n                        → Step 3: While S 不是空 且 S.top() ≤ nums2[i]  \n                            → 取出 S.top() // 移除不符合條件的元素  \n                        → Decision: S 是否為空?  \n                            Yes → map[nums2[i]] ← -1 // 取完後仍無候選  \n                            No → map[nums2[i]] ← S.top() // 新堆頂即為下一較大  \n        → Step 4: S.push(nums2[i]) // 把目前元素推進棧中，供左側元素使用  \n    End Loop  \n\n→ Step 5: 建立結果陣列 ans // 用於儲存 nums1 的答案  \n\n→ Loop for each element v in nums1:  \n    → Step 6: ans.append(map[v]) // 直接取映射值（若不存在則為 -1）  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def nextGreaterElement(self, nums1, nums2):\n        stack = []\n        nxt = {}\n        for num in nums2:\n            while stack and num > stack[-1]:\n                nxt[stack.pop()] = num\n            stack.append(num)\n        return [nxt.get(x, -1) for x in nums1]\n\ndef parse_input(data: str):\n    # 找出所有方括號內的字串（即 list）\n    lists = re.findall(r'\\[.*?\\]', data, flags=re.DOTALL)\n    if len(lists) >= 2:\n        nums1 = ast.literal_eval(lists[0])\n        nums2 = ast.literal_eval(lists[1])\n    else:\n        # 若兩行各為一個 list\n        lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            nums1 = ast.literal_eval(lines[0])\n            nums2 = ast.literal_eval(lines[1])\n        else:\n            # 其他格式直接回傳空\n            nums1 = []\n            nums2 = []\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    solution = Solution()\n    ans = solution.nextGreaterElement(nums1, nums2)\n    # 印出格式類似 [-1,3,-1]，不包含空格\n    print('[' + ','.join(map(str, ans)) + ']')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "success": true,
          "output": "[-1,3,-1]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "success": true,
          "output": "[3,-1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode658.json",
    "problem_index_in_file": 0,
    "title": "Find K Closest Elements",
    "description_snippet": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the ar...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm to find k closest integers to x in sorted array arr. Return sorted ascending. Classic solution: binary search to find closest index, then expand window left/right. Or use two pointers from mid. Let's produce simple approach: use binary search to find insertion position, then set left and right pointers around that index. Then iterate k times: compare left and right distances, choose closer, etc. After selection, sort result ascending.\n\nWe need step-by-step with arrows, decisions. Provide each line with \"虛擬碼步驟\" then comment.\n\nWe must not output actual code. Just pseudo steps.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 定義 n = length(arr) // 取得陣列長度\n→ Step 2: BinarySearch arr 找到 x 的插入位置 idx // idx 為第一個 > x 的索引\n→ Decision: 如果 idx == 0? // 檢查是否在最左側\n    Yes → Set left = -1, right = 0 // 只考慮右側\n    No  → Decision: 如果 idx == n? // 檢查是否在最右側\n        Yes → Set left = n-1, right = n // 只考慮左側\n        No  → Set left = idx-1, right = idx // 左右兩側均有候選\n→ Step 3: 初始化 result 為空清單 // 儲存選取的 k 個數字\n→ Decision: 迴圈 i 從 1 到 k? // 需要選取 k 個元素\n    Yes → Decision: 如果 left < 0? // 左側已無候選\n        Yes → Add arr[right] 到 result, right++ // 取右側\n        No  → Decision: 如果 right >= n? // 右側已無候選\n            Yes → Add arr[left] 到 result, left-- // 取左側\n            No  → Decision: 如果 |arr[left]-x| <= |arr[right]-x|? // 比較距離\n                Yes → Add arr[left] 到 result, left-- // 左側更近或相等且較小\n                No  → Add arr[right] 到 result, right++ // 右側更近\n    No → // 迴圈結束\n→ Step 4: Sort result 升序 // 確保輸出為升序\n→ End // 程式結束\n\nWe need to format as each line with arrow. Let's produce each step line as separate line with arrow and comment. Use \"→\" for sequence. For decisions we need indentation maybe.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n ← length(arr) // n 為 arr 的元素個數  \n→ Step 2: BinarySearch arr，找到第一個 > x 的索引 idx // idx 為插入位置  \n→ Decision: idx == 0? // x 小於所有元素  \n Yes → left ← -1, right ← 0 // 只考慮右側  \n No → Decision: idx == n? // x 大於所有元素  \n  Yes → left ← n-1, right ← n // 只考慮左側  \n  No → left ← idx-1, right ← idx // 左右兩側均有候選  \n→ Step 3: 初始化 result 為空清單 // 用於儲存 k 個最接近的數  \n→ Decision: i = 1 to k? // 需要選取 k 個元素  \n Yes → Decision: left < 0? // 左側已無候選  \n  Yes → result.append(arr[right]), right ← right+1 // 取右側  \n  No → Decision: right >= n? // 右側已無候選  \n   Yes → result.append(arr[left]), left ← left-1 // 取左側  \n   No → Decision: |arr[left]-x| ≤ |arr[right]-x|? // 比較距離與大小  \n    Yes → result.append(arr[left]), left ← left-1 // 左側更近或相等且更小  \n    No → result.append(arr[right]), right ← right+1 // 右側更近  \n No → // 迴圈結束，已選取 k 個元素  \n→ Step 4: 將 result 按升序排序 // 確保輸出為遞增順序  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        # 用滑動窗口尋找最靠近 x 的 k 個元素\n        left, right = 0, len(arr) - k\n        while left < right:\n            mid = (left + right) // 2\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]\n\ndef main():\n    # 從標準輸入讀取完整內容\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 解析 arr\n    arr_match = re.search(r'arr\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not arr_match:\n        raise ValueError(\"Missing array definition.\")\n    arr_str = arr_match.group(1)\n    arr = ast.literal_eval(arr_str)\n\n    # 解析 k\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not k_match:\n        raise ValueError(\"Missing k definition.\")\n    k = int(k_match.group(1))\n\n    # 解析 x\n    x_match = re.search(r'x\\s*=\\s*(-?\\d+)', data)\n    if not x_match:\n        raise ValueError(\"Missing x definition.\")\n    x = int(x_match.group(1))\n\n    # 呼叫解法\n    sol = Solution()\n    result = sol.findClosestElements(arr, k, x)\n\n    # 輸出結果，保持與範例一致的格式（無空格）\n    output = '[' + ','.join(str(num) for num in result) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "success": true,
          "output": "[1,2,3,4]"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "success": true,
          "output": "[1,1,2,3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode93.json",
    "problem_index_in_file": 0,
    "title": "Restore IP Addresses",
    "description_snippet": "A valid IP address consists of exactly four integers separated by single dots. Each integer is betwe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines with explanations. This is a backtracking problem: generate all splits into 4 parts, each part between 0-255, no leading zeros unless single digit. Input s only digits. Output list of strings.\n\nWe need to output pseudocode lines with arrows. Let's produce start, input s, result list, function to validate segment, recursion, loops, etc.\n\nWe must follow the specified format: Each line: virtual code step + space + // explanation. Use arrow → for next step. Use Decision: lines with Yes → and No →. End for finish.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Initialize result list [] // 儲存合法 IP 位址\n→ Step 2: Define function isValid(part) // 檢查單一段是否符合 0-255 且無前導零\n    → Decision: part長度>3? // 超過 3 位元組無效\n        Yes → Return False // 不合法\n        No  → Decision: part首字元為 '0' 且長度>1? // 前導零檢查\n            Yes → Return False // 不合法\n            No  → Convert part 為整數 num\n                → Decision: num 0-255? \n                    Yes → Return True\n                    No  → Return False\n→ Step 3: 定義遞迴函式 dfs(index, segments, currentIP) // index 目前字串位置，segments 已拆分段數\n    → Decision: segments==4 且 index==len(s)? // 完成四段且用完所有字串\n        Yes → Append currentIP 到 result list // 加入合法 IP\n        No  → Decision: segments==4? // 已有四段但仍有字串，無法繼續\n            Yes → Return // 失敗返回\n            No  → // 仍需分割\n                → For lenPart 1 to 3 // 嘗試長度 1-3\n                    → Decision: index+lenPart <= len(s)? // 確保不越界\n                        Yes → part = s[index : index+lenPart]\n                            → Decision: isValid(part)?\n                                Yes → If segments==0? // 第一次段\n                                    → Call dfs(index+lenPart, segments+1, part)\n                                    No  → // 後續段\n                                        → Call dfs(index+lenPart, segments+1, currentIP + '.' + part)\n                                No  → Continue // 該段無效，嘗試下一長度\n                            No  → Continue\n                        No  → Continue\n→ Step 4: 呼叫 dfs(0, 0, '') // 從頭開始\n→ Step 5: Return result list // 結果輸出\nEnd // 程式執行結束\n\nNeed to ensure each line is separate and includes arrow appropriately. For nested decisions, we indent. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize result list [] // 用於儲存所有合法的 IP 位址  \n→ Step 2: Define function isValid(part) // 檢查單一段是否符合規則  \n    → Decision: part長度 > 3? // 超過 3 位元組即不合法  \n        Yes → Return False // 長度不符合  \n        No  → Decision: part首字元為 '0' 且長度 > 1? // 前導零檢查  \n            Yes → Return False // 前導零不合法  \n            No  → Convert part 為整數 num  \n                → Decision: 0 ≤ num ≤ 255?  \n                    Yes → Return True // 合法段  \n                    No  → Return False // 數值超出範圍  \n→ Step 3: 定義遞迴函式 dfs(index, segments, currentIP) // index: 目前字串位置，segments: 已分段數，currentIP: 已組成的 IP 字串  \n    → Decision: segments == 4 且 index == len(s)? // 四段且用完所有字串  \n        Yes → Append currentIP 到 result list // 加入合法 IP  \n        No  → Decision: segments == 4? // 已有四段但仍有字串，無法繼續  \n            Yes → Return // 回溯  \n            No  → // 仍需分割  \n                → For lenPart in {1, 2, 3} // 嘗試長度 1-3  \n                    → Decision: index + lenPart <= len(s)? // 不超界  \n                        Yes → part = s[index : index+lenPart]  \n                            → Decision: isValid(part)?  \n                                Yes → If segments == 0? // 第一段不加點  \n                                    Yes → Call dfs(index+lenPart, segments+1, part)  \n                                    No  → Call dfs(index+lenPart, segments+1, currentIP + '.' + part) // 後續段加點  \n                                No  → Continue // 該段無效，嘗試下一長度  \n                            No  → Continue  \n                        No  → Continue  \n→ Step 4: 呼叫 dfs(0, 0, '') // 從頭開始遞迴  \n→ Step 5: Return result list // 輸出所有合法 IP 位址  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def restoreIpAddresses(self, s: str):\n        res = []\n\n        def backtrack(start: int, path: list):\n            if start == len(s) and len(path) == 4:\n                res.append(\".\".join(path))\n                return\n            if len(path) >= 4:\n                return\n            for length in range(1, 4):\n                if start + length > len(s):\n                    break\n                part = s[start:start + length]\n                if (part.startswith('0') and len(part) > 1) or int(part) > 255:\n                    continue\n                backtrack(start + length, path + [part])\n\n        backtrack(0, [])\n        return res\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 從輸入中提取字串內容，例如 s = \"25525511135\"\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有找到雙引號中的內容，直接使用整行作為輸入\n        s = data\n\n    solution = Solution()\n    result = solution.restoreIpAddresses(s)\n    # 直接印出結果，Python 的 list 轉字串形式符合題目期望\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"25525511135\"",
          "expected_output": "[\"255.255.11.135\",\"255.255.111.35\"]",
          "success": true,
          "output": "['255.255.11.135', '255.255.111.35']"
        },
        {
          "example_index": 1,
          "input": "s = \"0000\"",
          "expected_output": "[\"0.0.0.0\"]",
          "success": true,
          "output": "['0.0.0.0']"
        },
        {
          "example_index": 2,
          "input": "s = \"101023\"",
          "expected_output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
          "success": true,
          "output": "['1.0.10.23', '1.0.102.3', '10.1.0.23', '10.10.2.3', '101.0.2.3']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode393.json",
    "problem_index_in_file": 0,
    "title": "UTF-8 Validation",
    "description_snippet": "Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step to validate UTF-8 encoding given an array of integers, each representing a byte. The algorithm: iterate over data array, check each byte. For each byte, determine number of leading ones. If 0 -> 1 byte char. If 1, invalid. If between 2-4 -> that many bytes follow must have leading '10'. If not match, return false. After processing, if all satisfied, return true.\n\nNeed to produce virtual code steps with arrow, decision, etc. Provide explanation per line. No actual code.\n\nWe need to produce lines such as:\n\nStart // start\n→ Step 1: Initialize index i = 0 // ...\n→ Decision: i < length? // loop condition\n    Yes → Step 2: currentByte = data[i] & 0xFF // get byte\n    → Step 3: leadingOnes = count leading 1 bits of currentByte // count\n    → Decision: leadingOnes == 0? // 1-byte char\n        Yes → i++ // move to next\n        No → Decision: leadingOnes between 2 and 4? // valid start\n            Yes → Step 4: remaining = leadingOnes - 1\n                 → Step 5: for j from 1 to remaining:\n                         → Decision: i + j < length? // ensure enough bytes\n                             Yes → Step 6: nextByte = data[i + j] & 0xFF\n                                 → Decision: nextByte has bits 10xxxxxx? // check\n                                     Yes → continue\n                                     No  → Step 7: return False\n                             No → Step 7: return False\n                 → i += remaining + 1 // skip processed bytes\n            No → Step 7: return False\n    // loop end\n→ Decision: i >= length? // after loop\n    Yes → Step 8: return True\n    No → Step 1 (loop)\nEnd // end\n\nBut need to adhere to format: each line has \"虛擬碼步驟 [space] // 解釋\". Use arrows and indentations.\n\nNeed to include Step numbers? They used \"Step 1:\" etc. Provide step names.\n\nLet's create a structured pseudocode. Use Start, Decision, Yes→, No→.\n\nMake sure to indent decisions.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 1: i = 0 // 初始化索引\n→ Decision: i < length? // 是否還有未處理的位元組？\n    Yes → Step 2: byte = data[i] & 0xFF // 取得目前位元組\n    → Step 3: leadingOnes = countLeadingOnes(byte) // 計算前導 1 的個數\n    → Decision: leadingOnes == 0? // 1 位元組字符\n        Yes → i = i + 1 // 移動到下一位元組\n        No → Decision: leadingOnes >= 2 AND leadingOnes <= 4? // 有效的多位元組起始位元組\n            Yes → Step 4: remaining = leadingOnes - 1 // 需要檢查的後續位元組數\n                → Step 5: j = 1 // 從第一個後續位元組開始\n                → Decision: j <= remaining? // 是否還有待檢查的位元組？\n                    Yes → Step 6: nextByte = data[i + j] & 0xFF // 取得後續位元組\n                        → Decision: (nextByte >> 6) == 0b10? // 前兩位是否為 10\n                            Yes → j = j + 1 // 進一步檢查下一個後續位元組\n                            No  → Step 7: return False // 不符合 UTF-8 規則\n                    No  → // 所有後續位元組已檢查完成\n            No  → Step 7: return False // 起始位元組不合法\n    // 完成一次位元組序列的檢查\n→ Decision: i < length? // 是否還有剩餘位元組？\n    Yes → (回到 Step 1) // 重新進入循環\n    No  → Step 8: return True // 所有位元組均符合 UTF-8 規則\nEnd // 程式結束\n\nBut the formatting must be lines with arrows. Indentation with tabs? They use \"→\" and then indent decisions with spaces and then Yes→ etc.\n\nWe need to produce each line with step and explanation. Provide arrow for decision lines, and indentation with two spaces? They show indent with 4 spaces? Example:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nSo indent after Decision line.\n\nWe'll produce similar structure.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = 0 // 初始化索引，用於遍歷字節陣列  \n→ Decision: i < data.length? // 判斷是否還有未處理的字節  \n    Yes → Step 2: byte = data[i] & 0xFF // 取得目前字節（只取最低 8 位）  \n    → Step 3: leadingOnes = countLeadingOnes(byte) // 計算連續 1 的個數  \n    → Decision: leadingOnes == 0? // 1 位元組 UTF‑8 字符  \n        Yes → i = i + 1 // 跳過此字節，繼續檢查下一個  \n        No → Decision: leadingOnes >= 2 AND leadingOnes <= 4? // 多位元組起始字節是否合法  \n            Yes → Step 4: remaining = leadingOnes - 1 // 需要檢查的後續字節數  \n                → Step 5: j = 1 // 從第一個後續字節開始檢查  \n                → Decision: j <= remaining? // 是否還有待檢查的字節？  \n                    Yes → Step 6: nextByte = data[i + j] & 0xFF // 取得後續字節  \n                        → Decision: (nextByte >> 6) == 0b10? // 前兩位是否為 10  \n                            Yes → j = j + 1 // 檢查下一個後續字節  \n                            No  → Step 7: return False // 後續字節不符合規則，直接結束  \n                    No  → // 所有後續字節已檢查完成，返回上層  \n            No  → Step 7: return False // 起始字節不在合法範圍內  \n    // 完成一次字節序列的檢查  \n→ Decision: i < data.length? // 是否還有剩餘字節？  \n    Yes → (回到 Step 1) // 重新進入循環，處理下一個字節  \n    No  → Step 8: return True // 所有字節均符合 UTF‑8 規則，返回成功  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def validUtf8(self, data):\n        n_bytes = 0\n        for num in data:\n            # keep only the least significant 8 bits\n            byte = num & 0xFF\n            if n_bytes == 0:\n                # count leading 1s to determine the number of bytes\n                leading = 0\n                mask = 0x80\n                while mask & byte:\n                    leading += 1\n                    mask >>= 1\n                if leading == 0:\n                    continue\n                if leading == 1 or leading > 4:\n                    return False\n                n_bytes = leading - 1\n            else:\n                # following bytes must start with bits '10'\n                if not (byte & 0xC0) == 0x80:\n                    return False\n                n_bytes -= 1\n        return n_bytes == 0\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    # Extract the list from the input, e.g., \"data = [197,130,1]\"\n    try:\n        start = raw.index('[')\n        end = raw.rindex(']')\n        list_str = raw[start:end+1]\n        data = ast.literal_eval(list_str)\n    except Exception:\n        print('false')\n        return\n\n    if not isinstance(data, list) or any(not isinstance(x, int) for x in data):\n        print('false')\n        return\n\n    sol = Solution()\n    print('true' if sol.validUtf8(data) else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "data = [197,130,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "data = [235,140,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode475.json",
    "problem_index_in_file": 0,
    "title": "Heaters",
    "description_snippet": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed war...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. The problem: Given positions of houses and heaters on a horizontal line, find minimum radius such that heaters can cover all houses. We need to produce algorithm in pseudocode. Should be generic. Steps: sort houses, sort heaters. For each house, find nearest heater using binary search or two pointers. Compute distance to nearest heater. Keep max distance. Output that radius. Provide steps. Use Decision nodes, etc. No actual code. Let's write steps accordingly. Use Start, End. Use arrows. Provide explanation after each step. Use proper Chinese. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取兩個陣列 houses 與 heaters // 取得所有房屋和暖氣機的位置  \n→ Step 2: 將 houses 陣列依位置升冪排序 // 方便後續線性遍歷  \n→ Step 3: 將 heaters 陣列依位置升冪排序 // 方便二分搜尋最近暖氣機  \n→ Decision: 檢查 houses 或 heaters 是否為空? // 若任一陣列為空，無法取值  \n    Yes → Step 4: 輸出 -1 // 表示無法覆蓋所有房屋  \n    No  → Step 5: 初始化 maxRadius 為 0 // 追蹤最遠距離  \n→ Step 6: 針對每個 house 進行遍歷 // 逐一確定需要的半徑  \n→ Decision: 對當前 house 使用二分搜尋在 heaters 中找到最接近的位置 // 取得最近暖氣機的索引  \n    Yes → Step 7: 計算 leftDist = house - heaters[low] // 若 low 存在，左側距離  \n    Yes → Step 8: 計算 rightDist = heaters[high] - house // 若 high 存在，右側距離  \n    Yes → Step 9: minDist = min(leftDist, rightDist) // 取最近距離  \n→ Step 10: 更新 maxRadius = max(maxRadius, minDist) // 追蹤所有房屋中最大的最小距離  \n→ Decision: 所有 house 是否已遍歷完?  \n    Yes → Step 11: 輸出 maxRadius // 最小半徑即可覆蓋所有房屋  \n    No  → 回到 Step 6 // 繼續處理下一個 house  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef find_min_radius(houses, heaters):\n    houses.sort()\n    heaters.sort()\n    res = 0\n    i = 0  # 指向目前最靠近的暖氣機（右邊）\n\n    for house in houses:\n        # 移動指標到離 house 最近的暖氣機\n        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        res = max(res, abs(heaters[i] - house))\n    return res\n\ndef parse_input(text):\n    # 取出 houses 與 heaters 的列表字串\n    houses_match = re.search(r'houses\\s*=\\s*(\\[[^\\]]*\\])', text)\n    heaters_match = re.search(r'heaters\\s*=\\s*(\\[[^\\]]*\\])', text)\n    if not houses_match or not heaters_match:\n        raise ValueError(\"輸入格式不符合要求\")\n    houses_str = houses_match.group(1)\n    heaters_str = heaters_match.group(1)\n    # 轉成 Python list\n    houses = eval(houses_str, {})\n    heaters = eval(heaters_str, {})\n    return houses, heaters\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    houses, heaters = parse_input(raw_input)\n    radius = find_min_radius(houses, heaters)\n    print(radius)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode591.json",
    "problem_index_in_file": 0,
    "title": "Tag Validator",
    "description_snippet": "Given a string representing a code snippet, implement a tag validator to parse the code and return w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudocode for the validator. Each line must be virtual code step + comment. Use Start, End, Decision. The content is a validator for XML-like tags with rules. Must handle tag parsing, CDATA, nested tags, unmatched, etc. We need to generate virtual code in a line-by-line format. We must not output actual code, just virtual steps. Let's design algorithm.\n\nWe can do stack for open tags, parse string char by char. We need to detect start tags (<TAG_NAME>), end tags (</TAG_NAME>), cdata (<![CDATA[ ... ]]>). We must ensure entire string is wrapped in a single closed tag. So initial check: string must start with '<' and end with '>' maybe, but more precisely must start with a start tag that matches an end tag covering whole string. Approach: parse outermost tag: find first '<', parse tag name until '>', ensure start tag, then find matching end tag for entire string.\n\nSimplify: We can parse from beginning to end, maintain stack and positions. Also detect if entire string is enclosed by one closed tag: after parsing whole string, stack should be empty and the outermost tag covers full string.\n\nBut pseudocode can be generic.\n\nWe need line-by-line representation. Might be many lines. Let's produce a reasonably detailed algorithm.\n\nUse variables: idx, length, stack, outerTagName, isValid.\n\nWe'll produce steps:\n\nStart\n→ Initialize idx=0, length = len(code)\n→ Decision: 是否以 '<' 开头? (Check if first char is '<') ...\nWe need to parse outer tag: find first '<', parse tag name until '>'. etc.\n\nBetter: We'll parse sequentially, building tokens.\n\nBecause requirement 1: code must be wrapped in a valid closed tag; so after parsing, we must ensure outermost tag covers all and stack empty and outerTagName valid and content valid.\n\nSimplify algorithm: parse entire code, building a parse tree; while parsing, check validity of tags, CDATA, etc. If any rule fails, return invalid.\n\nLet's produce step-by-step.\n\nWill include Decision points for tag type: start, end, cdata, normal character. For CDATA, skip content until ']]>'.\n\nWhen encountering '<', need to check next char: if '!' start of CDATA, if '/' start of end tag, else start tag.\n\nFor start tag: parse tag name until '>'; validate name length [1,9], all uppercase. If invalid, mark invalid. Push onto stack. Also record outermost if stack was empty.\n\nFor end tag: parse tag name until '>'; validate name; check top of stack matches; if not, invalid.\n\nFor normal characters outside tags: just continue.\n\nAt the end: if stack not empty -> invalid.\n\nAlso check entire string is wrapped: outermost tag must start at idx 0 and end at end-1; but our parsing will enforce that since if first char is not start tag or outermost unmatched, invalid.\n\nAlso rule about unmatched '<': if '<' not followed by '>' -> invalid.\n\nEdge: If we encounter '<' inside CDATA, we skip until end of CDATA; so no parse.\n\nImplement algorithm in pseudocode.\n\nLet's write lines with decision and arrows.\n\nWe need to be careful to keep each line concise.\n\nWe should include loops with while idx < length.\n\nUse variable valid = true.\n\nWe need to check for unmatched '<' meaning no '>' after it; we can find next '>' by scanning; if none, invalid.\n\nLet's craft steps.\n\nWe'll output as requested: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ idx ← 0 // 位置指標  \n→ n ← length(code) // 取得程式碼長度  \n→ valid ← true // 初始有效標誌  \n→ stack ← empty stack // 用來追蹤未關閉的開始標籤  \n→ outerTagName ← \"\" // 儲存最外層標籤名稱  \n→ outerTagStart ← 0 // 最外層標籤起始位置  \n→ outerTagEnd ← -1 // 最外層標籤結束位置  \n\n→ Decision: n == 0? // 程式碼是否為空  \n    Yes → valid ← false // 空程式碼無法被包裝  \n    No → // 繼續  \n\n→ Decision: 第 1 個字符是否為 '<'? // 程式碼必須以開始標籤開頭  \n    Yes → // 進行解析  \n    No  → valid ← false // 不以 '<' 開頭，無效  \n\n→ While idx < n and valid: // 逐字符解析  \n    → Decision: code[idx] == '<'? // 遇到 '<'  \n        Yes →  \n            → Decision: idx+1 < n and code[idx+1] == '!'? // 可能是 CDATA  \n                Yes →  \n                    → Decision: 從 idx+2 開始是否有 \\\"[CDATA[\\\"?  \n                        Yes →  \n                            → cdataEnd ← find_next(\\\"]]>\\\", idx+8) // 找尋 CDATA 結束標記  \n                            → Decision: cdataEnd == -1?  \n                                Yes → valid ← false // CDATA 未結束  \n                                No  → idx ← cdataEnd + 3 // 跳過 CDATA 內容，繼續解析  \n                        No  → valid ← false // 非法的 '<![' 開頭  \n                No → // 不是 CDATA，可能是結束標籤或開始標籤  \n                    → Decision: idx+1 < n and code[idx+1] == '/'? // 結束標籤  \n                        Yes →  \n                            → tagStart ← idx + 2 // 結束標籤名稱起點  \n                            → tagEnd ← find_next('>', tagStart) // 找到 '>'  \n                            → Decision: tagEnd == -1?  \n                                Yes → valid ← false // 未找到結束 '>'  \n                                No  →  \n                                    → tagName ← substring(code, tagStart, tagEnd) // 取得標籤名稱  \n                                    → Decision: stack.is_empty()?  \n                                        Yes → valid ← false // 結束標籤沒有對應的開始標籤  \n                                        No  →  \n                                            → topName ← stack.pop() // 取出最新的開始標籤  \n                                            → Decision: topName != tagName?  \n                                                Yes → valid ← false // 名稱不匹配  \n                                                No  → // 正常關閉  \n                                            → Decision: stack.is_empty() and outerTagEnd == -1? // 最外層標籤已關閉  \n                                                Yes → outerTagEnd ← tagEnd // 記錄最外層結束位置  \n                                    → idx ← tagEnd + 1 // 移到下個位置  \n                        No → // 開始標籤  \n                            → tagStart ← idx + 1 // 開始標籤名稱起點  \n                            → tagEnd ← find_next('>', tagStart) // 找到 '>'  \n                            → Decision: tagEnd == -1?  \n                                Yes → valid ← false // 未找到結束 '>'  \n                                No  →  \n                                    → tagName ← substring(code, tagStart, tagEnd) // 取得標籤名稱  \n                                    → Decision: is_valid_tag_name(tagName)? // 檢查大寫且長度 1-9  \n                                        Yes → // 標籤名稱合法  \n                                            → stack.push(tagName) // 將開始標籤入堆疊  \n                                            → Decision: stack.size() == 1? // 第一個開始標籤  \n                                                Yes → outerTagName ← tagName // 記錄最外層名稱  \n                                                No  → // 內部標籤，無需特別處理  \n                                            → Decision: outerTagEnd == -1? // 尚未記錄最外層結束  \n                                                Yes → outerTagStart ← idx // 記錄最外層開始位置  \n                                    No  → valid ← false // 標籤名稱不合法  \n                                    → idx ← tagEnd + 1 // 移到下個位置  \n            No  → // 不是 '<'，為普通字符  \n                → idx ← idx + 1 // 跳過此字符  \n\n→ Decision: stack.is_empty()?  \n    Yes → // 所有開始標籤均已關閉  \n        → Decision: outerTagStart == 0 and outerTagEnd == n-1? // 最外層標籤包覆整個程式碼  \n            Yes → // 包覆成功，valid 已在整個過程保持 true  \n            No  → valid ← false // 最外層標籤未覆蓋完整程式碼  \n    No  → valid ← false // 存在未關閉的開始標籤  \n\n→ Decision: valid?  \n    Yes → Step: 返回 True // 程式碼有效  \n    No  → Step: 返回 False // 程式碼無效  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isValid(self, code: str) -> bool:\n        stack = []\n        i = 0\n        n = len(code)\n        outer_start = -1   # start index of the outermost start tag\n        outer_end = -1     # end index of the outermost end tag\n\n        while i < n:\n            # If we have already closed all tags but are not at the end, invalid\n            if i > 0 and not stack and i < n:\n                return False\n\n            # Detect CDATA section\n            if code.startswith(\"<![CDATA[\", i):\n                j = i + 9\n                end_cdata = code.find(\"]]>\", j)\n                if end_cdata == -1:\n                    return False\n                i = end_cdata + 3\n                continue\n\n            # Detect end tag\n            if code.startswith(\"</\", i):\n                j = i + 2\n                end_tag = code.find(\">\", j)\n                if end_tag == -1:\n                    return False\n                tag_name = code[j:end_tag]\n                if not stack or stack[-1] != tag_name:\n                    return False\n                stack.pop()\n                i = end_tag + 1\n                # Record outermost end if this was the last tag\n                if not stack and outer_end == -1:\n                    outer_end = i - 1\n                continue\n\n            # Detect start tag\n            if code[i] == \"<\":\n                j = i + 1\n                end_tag = code.find(\">\", j)\n                if end_tag == -1 or j == end_tag or end_tag - j > 9:\n                    return False\n                tag_name = code[j:end_tag]\n                if not tag_name.isupper() or not tag_name.isalpha() or not (1 <= len(tag_name) <= 9):\n                    return False\n                stack.append(tag_name)\n                # Record outermost start if this is the first tag\n                if len(stack) == 1 and outer_start == -1:\n                    outer_start = i\n                i = end_tag + 1\n                continue\n\n            # Regular character, just move on\n            i += 1\n\n        # After parsing, all tags must be closed\n        if stack:\n            return False\n        # The outermost tag must cover the entire string\n        if outer_start != 0 or outer_end != n - 1:\n            return False\n        return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n\n    # Try to extract the string inside quotes if present\n    m = re.search(r'[\"\\'](.*)[\"\\']', data)\n    if m:\n        code_str = m.group(1)\n    else:\n        # Fallback: strip surrounding whitespace and quotes\n        code_str = data.strip().strip('\"').strip(\"'\")\n\n    solution = Solution()\n    result = solution.isValid(code_str)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "code = \"<A>  <B> </A>   </B>\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode679.json",
    "problem_index_in_file": 0,
    "title": "24 Game",
    "description_snippet": "You are given an integer array cards of length 4. You have four cards, each containing a number in t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to determine if 24 can be achieved using four numbers and operations. Likely approach: backtracking permutations and operations. We'll produce step-by-step pseudo-code lines with explanation.\n\nWe must output each line with \"虛擬碼步驟 // 解釋\".\n\nWe need Start, End, Decision, etc.\n\nLet's outline:\n\nStart // begin\n→ Step 1: Generate all permutations of cards // all orderings\n→ Step 2: For each permutation, invoke DFS to try all operation combinations and parenthesis placements\n→ Step 3: DFS function(parameters: list of numbers)\n   → Decision: if list size == 1:\n        Yes → Step 4: Check if value close to 24 // return true\n        No → Step 5: return false\n   → Loop over pairs i<j:\n        Step 6: Pick numbers a, b at indices i, j\n        Step 7: Generate list of results for possible operations:\n            op '+': a+b\n            op '-': a-b\n            op '*': a*b\n            op '/': if b !=0 then a/b\n            op 'b-a' etc? Actually we consider both orders for non-commutative.\n        Step 8: For each result r:\n            Step 9: Form new list: replace a,b with r (remove i,j, append r)\n            Step10: Recursively call DFS on new list\n            Step11: If returns true, propagate true\n   → End loop\n→ Decision: if any true found\n    Yes → Step12: Return true\n    No  → Step13: Return false\nEnd\n\nAdd epsilon tolerance for floating errors.\n\nLet's craft the pseudo lines with arrow etc.\n\nWe need use virtual code arrow and indentation? Use spaces for indentation.\n\nWe'll include each line with explanation. Use \"→\" to denote step. Use \"Decision:\" lines. Indentation as spaces.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Permutations ← generate all 24 permutations of cards // 列出所有數字排列順序  \n→ Step 2: For each perm in Permutations do  \n    → Step 3: If DFS(perm) == true then return true // 嘗試每個排列，若能得到 24 就結束  \n→ Step 4: Return false // 所有排列均無法得到 24，結束並返回 false  \nEnd // 程式執行結束  \n\n// 下面定義遞迴函式 DFS  \n→ Step 5: Function DFS(nums) // nums 為目前剩餘的數字清單  \n    → Decision: If length(nums) == 1 then // 只剩一個數字  \n        Yes → Step 6: If abs(nums[0] - 24) < ε then return true // 接近 24（容忍浮點誤差）  \n        No  → Step 7: return false // 不等於 24  \n    → Decision: Else // 至少有兩個數字  \n        Yes → Step 8: For i from 0 to length(nums)-1 do  \n            → Step 9: For j from i+1 to length(nums)-1 do  \n                → Step 10: a ← nums[i] ; b ← nums[j] // 取出兩個數字  \n                → Step 11: Ops ← [] // 用來存放所有合法運算結果  \n                → Step 12: Append(a + b) to Ops // 加法  \n                → Step 13: Append(a - b) to Ops // 減法（a-b）  \n                → Step 14: Append(b - a) to Ops // 減法（b-a）  \n                → Step 15: Append(a * b) to Ops // 乘法  \n                → Step 16: If b != 0 then Append(a / b) to Ops // 除法（a/b）  \n                → Step 17: If a != 0 then Append(b / a) to Ops // 除法（b/a）  \n                → Step 18: For each r in Ops do // 逐個嘗試每個結果  \n                    → Step 19: NewNums ← nums with nums[i] and nums[j] removed, then r appended // 產生新的數字清單  \n                    → Step 20: If DFS(NewNums) == true then return true // 递归成功，回傳 true  \n                → End For r  \n            → End For j  \n        → End For i  \n    → Decision: If none returned true then  \n        Yes → Step 21: return false // 所有組合都失敗  \nEnd Function\n\n// ε 是一個很小的數值，例如 1e-6，用於浮點數比較\n→ Step 22: ε ← 1e-6 // 容忍的誤差界限  \nEnd // 完整流程結束",
      "generated_code": "import sys\nimport re\nfrom itertools import permutations\n\nclass Solution:\n    def judgePoint24(self, nums):\n        EPS = 1e-6\n\n        def dfs(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < EPS\n            n = len(nums)\n            for i in range(n):\n                for j in range(i + 1, n):\n                    a, b = nums[i], nums[j]\n                    remaining = [nums[k] for k in range(n) if k != i and k != j]\n                    # generate all possible results from a and b\n                    results = [a + b, a - b, b - a, a * b]\n                    if abs(b) > EPS:\n                        results.append(a / b)\n                    if abs(a) > EPS:\n                        results.append(b / a)\n                    for r in results:\n                        if dfs(remaining + [r]):\n                            return True\n            return False\n\n        for perm in permutations(nums):\n            if dfs(list(perm)):\n                return True\n        return False\n\n\nif __name__ == \"__main__\":\n    # Read entire input and extract all integers\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    sol = Solution()\n    result = sol.judgePoint24(numbers)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "cards = [4,1,8,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "cards = [1,2,1,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode557.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String III",
    "description_snippet": "Given a string s, reverse the order of characters in each word within a sentence while still preserv...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line explanation. The requirement: reverse each word's characters, keep whitespace and word order. We need to parse string, reverse characters in each word. Use simple approach: split by spaces? But preserving whitespace includes multiple spaces, tabs. Use split by word boundaries but keep delimiters. Maybe iterate characters, build word buffer, when encountering whitespace, flush reversed word, add whitespace. Also handle end of string. So virtual code steps.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化空字串 result, 空字串 wordBuffer // result accumulates final output, wordBuffer accumulates current word characters\n→ Step 2: 對於每個字符 c 在 s 的索引 i\n    → Decision: 如果 c 是非空白字符?\n        Yes → Step 3: 將 c 加到 wordBuffer // 收集單詞字元\n        No  → Decision: wordBuffer 不是空?\n            Yes → Step 4: 將 wordBuffer 反轉並 append 到 result // 完成一個單詞\n                → Step 5: 清空 wordBuffer\n            No  → // 連續空白不需要任何操作\n        → Step 6: 將 c 加到 result // 將空白字符直接加到結果\n→ Decision: 迴圈結束後 wordBuffer 不是空?\n    Yes → Step 7: 將 wordBuffer 反轉並 append 到 result\n    No  → // nothing\n→ End // 結束，結果已在 result\n\nAlso need to mention returning result.\n\nLet's structure each line with \"虛擬碼步驟\" + comment. Use arrow.\n\nUse \"Start\" and \"End\".\n\nLet's produce lines. Each line should be \"虛擬碼步驟 [space] // 解釋\". Use arrow where needed.\n\nWe need \"Step 1:\" etc. Provide arrow indent? Format: \"→ Step 1: ...\" It's okay.\n\nLet's craft.\n\nMake sure each line has \"虛擬碼步驟\" then space then \"// 解釋\". The code uses \"→\" or \"Start\". Provide decisions with \"Decision:\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 result 為空字串，wordBuffer 為空字串 // 用於儲存結果與正在收集的單詞字符  \n→ Step 2: 對 s 的每個字符 c 進行迭代 // 逐字符處理輸入字串  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: c 是否為非空白字符? // 判斷目前字符屬於單詞還是空白符號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: 將 c 附加到 wordBuffer // 收集單詞中的字符  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: wordBuffer 是否非空? // 檢查是否已完成一個單詞  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: 將 wordBuffer 反轉後附加到 result // 完成單詞，加入結果  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: 清空 wordBuffer // 準備收集下一個單詞  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 連續空白，無需處理  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: 將 c 附加到 result // 直接把空白字符加入結果，保持原始空白  \n→ Decision: 迴圈結束後 wordBuffer 是否非空? // 處理輸入結尾處可能未反轉的單詞  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: 將 wordBuffer 反轉後附加到 result // 加入最後一個單詞  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → // 無剩餘單詞  \n→ Step 8: 輸出或返回 result // 最終得到每個單詞字符已反轉、空白保持不變的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"\n        把字串中每個單字的字元順序反轉，同時保持空白字元與單字原本順序。\n        \"\"\"\n        result = []       # 用於儲存最終結果的字串列表\n        word_buffer = []  # 收集單字中的字元\n\n        for c in s:\n            if not c.isspace():          # 如果是非空白字元，加入單字緩衝\n                word_buffer.append(c)\n            else:\n                if word_buffer:          # 以前面收集了字元，則把單字反轉並加入結果\n                    result.append(''.join(reversed(word_buffer)))\n                    word_buffer = []\n                result.append(c)        # 空白字元直接加入結果\n\n        # 迴圈結束後，如果還有未處理的單字，反轉後加入結果\n        if word_buffer:\n            result.append(''.join(reversed(word_buffer)))\n\n        return ''.join(result)\n\ndef extract_string_from_input(input_text: str) -> str:\n    \"\"\"\n    從輸入文字中提取第一個用單引號或雙引號包起來的字串。\n    如果找不到，直接回傳整個輸入（去除首尾空白）。\n    \"\"\"\n    match = re.search(r'[\"\\'](.*?)[\"\\']', input_text, re.S)\n    if match:\n        return match.group(1)\n    return input_text.strip()\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n\n    # 從輸入中提取字串\n    s = extract_string_from_input(raw_input)\n\n    # 執行反轉單字功能\n    solution = Solution()\n    reversed_s = solution.reverseWords(s)\n\n    # 輸出結果\n    print(reversed_s)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Let's take LeetCode contest\"",
          "expected_output": "\"s'teL ekat edoCteeL tsetnoc\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 's\"teLekatedoCteeLtsetnoc'\nGot (Norm):      'teL'\n--- (Raw) ---\nRaw Expected: '\"s\\'teL ekat edoCteeL tsetnoc\"'\nRaw Got:      'teL'"
        },
        {
          "example_index": 1,
          "input": "s = \"Mr Ding\"",
          "expected_output": "\"rM gniD\"",
          "success": true,
          "output": "rM gniD"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode491.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Subsequences",
    "description_snippet": "Given an integer array nums, return all the different possible non-decreasing subsequences of the gi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find all non-decreasing subsequences length >=2 from an array. Approach: backtracking/DFS. Use set to avoid duplicates due to duplicates in array. Complexity: O(2^n * n). Steps: Start, read input, define result list, define backtrack(current index, current subsequence). At each step, iterate i from index+1 to n-1; if nums[i] >= last element of subsequence (or subsequence empty), add to subsequence, call backtrack(i, subsequence), then pop. After exploring, if length >=2 add copy to result. Use set to avoid duplicates: maybe store subsequence as string joined or tuple to track unique. But we produce virtual code, no actual code. Need to include decisions and loops.\n\nWe need each line with \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Also use \"Start\", \"End\". Use \"Decision:\" for if conditions. Use \"Yes →\", \"No →\" for branches.\n\nWe produce line by line. Let's structure:\n\nStart\n→ Read input array nums\n→ Initialize result list res\n→ Initialize visited set seen\n→ Define function backtrack(index, current)\n→ Decision: if index == length of nums? (But typical backtrack: loop)\nActually easier: backtrack(index, current)\n→ For i from index+1 to len(nums)-1\n   → Decision: if nums[i] >= (last element of current if any) ?\n      Yes → Append nums[i] to current\n          → Decision: if len(current) >= 2 ?\n              Yes → Create key = tuple(current)\n                  → Decision: if key not in seen ?\n                      Yes → Add key to seen\n                         → Add copy of current to res\n                      No → Do nothing\n          → Call backtrack(i, current)\n          → Remove last element from current\n      No → Continue\n\nEnd\n\nBut need to start recursion from each index? Another approach: For each start position, call backtrack(start, empty). That yields duplicates avoided.\n\nLet's produce virtual code accordingly.\n\nMake sure each line ends with // explanation. Use correct arrow syntax.\n\nAlso include comments for clarity.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Read input array nums // 取得使用者傳入的整數陣列\n→ Initialize res ← [] // 儲存符合條件的所有子序列\n→ Initialize seen ← {} // 以集合防止重複子序列\n→ Define function backtrack(start, current) // 從索引 start 開始搜尋子序列\n    → Decision: if start == len(nums)? // 若已達到陣列結尾\n        Yes → Return // 結束此分支\n        No → Continue\n    → For i in range(start, len(nums)) // 逐一考慮每個位置\n        → Decision: if current is empty or nums[i] >= current[-1]? // 子序列需保持非遞減\n            Yes →\n                → Append nums[i] to current // 加入目前候選元素\n                → Decision: if len(current) >= 2? // 至少兩個元素才可加入結果\n                    Yes →\n                        → key ← tuple(current) // 轉成不可變結構作為唯一鍵\n                        → Decision: if key not in seen? // 檢查是否已存在\n                            Yes →\n                                → Add key to seen // 記錄已加入的子序列\n                                → Append copy of current to res // 存入最終結果\n                            No → No action // 已存在，跳過\n                    No → No action // 長度不足，暫不加入結果\n                → Call backtrack(i+1, current) // 以下一個索引繼續搜尋\n                → Remove last element from current // 回溯，移除最近加入的元素\n            No → No action // 元素遞減，跳過\n→ For each index idx in range(len(nums)) // 從每個起點開始搜尋\n    → Call backtrack(idx, []) // 以空子序列啟動回溯\n→ Output res // 傳回所有不同的非遞減子序列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findSubsequences(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            if len(path) > 1:\n                res.append(path[:])\n            used = set()\n            for i in range(start, len(nums)):\n                if (not path or nums[i] >= path[-1]) and nums[i] not in used:\n                    used.add(nums[i])\n                    path.append(nums[i])\n                    backtrack(i + 1, path)\n                    path.pop()\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 將輸入字串中第一個 '[' 到最後一個 ']' 之間的部分解析為列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1:\n        nums_str = data[start:end+1]\n        try:\n            nums = ast.literal_eval(nums_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    solution = Solution()\n    result = solution.findSubsequences(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,6,7,7]",
          "expected_output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
          "success": true,
          "output": "[[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]"
        },
        {
          "example_index": 1,
          "input": "nums = [4,4,3,2,1]",
          "expected_output": "[[4,4]]",
          "success": true,
          "output": "[[4, 4]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode535.json",
    "problem_index_in_file": 0,
    "title": "Encode and Decode TinyURL",
    "description_snippet": "Note: This is a companion problem to the System Design problem: Design TinyURL.\nTinyURL is a URL sho...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, no actual code. Use Start, End, Decision etc. The user wants a design solution class. We produce steps for initialization, encode, decode, using a map of short to long, generating short via counter or random. Let's produce a sequence of steps: Start, Step 1: initialize counter, map, domain. Step 2: encode: convert counter to base62 string, construct short URL, store mapping, increment counter, return short. Step 3: decode: lookup map, return long. Use decisions for check existence maybe. Provide comments. Ensure each line has `虛擬碼步驟` space `// 解釋`. Use arrows. We'll use indentation.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 初始化 counter 0 // 以唯一 ID 產生短碼\n\n→ Step 2: 初始化 map 短碼->長網址 // 儲存對應\n\n→ Step 3: 初始化域名 base = \"http://tinyurl.com/\" // 生成短 URL 基底\n\nThen encode method:\n\n→ Step 4: 轉換 counter 為 base62 文字 // 生成唯一短碼\n\n→ Step 5: short = base + shortCode // 組合完整短網址\n\n→ Step 6: 存入 map: map[short] = longUrl // 記錄映射\n\n→ Step 7: counter++ // 使下一個短碼不同\n\n→ Step 8: 回傳 short // 給使用者\n\ndecode method:\n\n→ Step 9: 查找 map[shortUrl] // 找回長網址\n\n→ Decision: 如果存在? // 可靠性\n\n    Yes → Step 10: 回傳長網址 // 完成\n\n    No → Step 11: 回傳空字符串或錯誤 // 未映射\n\nEnd // 程式結束\n\nNeed to keep each line separate. Provide all lines. Use proper indentation after Decision lines. Provide arrow arrows. Ensure each line ends with comment. Use the format: \"→ Step X: ... // 說明\". For Decision block, \"→ Decision: ...\" and then indent lines for Yes and No.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 counter 為 0 // 用於產生唯一短碼  \n→ Step 2: 初始化 map 為空字典 // 用於存儲短碼到長網址的映射  \n→ Step 3: 設定 baseURL 為 \"http://tinyurl.com/\" // 短網址的域名基底  \n\n→ Step 4: encode(longUrl)  \n    → Step 5: 將 counter 轉換為 base62 文字 shortCode // 產生短碼  \n    → Step 6: 將 baseURL 與 shortCode 組合成 shortURL // 完整短網址  \n    → Step 7: 存入 map: map[shortURL] = longUrl // 記錄映射  \n    → Step 8: counter++ // 讓下一次編碼得到不同短碼  \n    → Step 9: 回傳 shortURL // 給使用者  \n\n→ Step 10: decode(shortUrl)  \n    → Decision: shortUrl 是否存在於 map? // 確認有對應長網址  \n        Yes → Step 11: 回傳 map[shortUrl] // 回復原始網址  \n        No  → Step 12: 回傳空字串或錯誤訊息 // 失敗處理  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\nimport string\n\nclass Codec:\n    def __init__(self):\n        # 用於儲存短碼到長網址的對應表\n        self.url_map = {}\n        self.base_url = \"http://tinyurl.com/\"\n\n    def encode(self, longUrl: str) -> str:\n        \"\"\"將長網址編碼為短網址\"\"\"\n        # 產生一個隨機 6 個字元的 key（允許字母和數字）\n        key = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))\n        # 保證 key 唯一\n        while key in self.url_map:\n            key = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))\n        # 記錄映射\n        self.url_map[key] = longUrl\n        return self.base_url + key\n\n    def decode(self, shortUrl: str) -> str:\n        \"\"\"根據短網址還原長網址\"\"\"\n        # 取出 key，刪除 base_url\n        key = shortUrl.replace(self.base_url, '')\n        return self.url_map.get(key, '')\n\ndef main():\n    # 從標準輸入讀取整個內容，並去除首尾空白與可選的雙引號\n    raw_input = sys.stdin.read().strip()\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n\n    # 建立 Codec 物件\n    codec = Codec()\n\n    # 先編碼再解碼，最後輸出還原的長網址\n    encoded = codec.encode(raw_input)\n    decoded = codec.decode(encoded)\n\n    print(decoded)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"https://leetcode.com/problems/design-tinyurl\"",
          "expected_output": "\"https://leetcode.com/problems/design-tinyurl\"",
          "success": true,
          "output": "https://leetcode.com/problems/design-tinyurl"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode745.json",
    "problem_index_in_file": 0,
    "title": "Prefix and Suffix Search",
    "description_snippet": "Design a special dictionary that searches the words in it by a prefix and a suffix.\n\nImplement the W...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code (flowchart-like). For each line, include explanation. Provide steps for building WordFilter class with a dictionary that supports prefix and suffix search. Implementation likely uses Trie or hash maps. But we just need pseudo steps, not actual code.\n\nLet's design algorithm:\n\n- Initialize with words array. For each word, assign its index.\n- Build two tries: prefix trie and suffix trie? But we need to find words that have both prefix and suffix. Approach: For each word, generate all possible (prefix, suffix) pairs? Too large.\n\nBetter approach: Use a combined trie keyed by prefix + \"#\" + suffix. Standard solution for LeetCode 745 uses prefix + \"#\" + suffix reversed, but virtual steps.\n\nSimplify: We'll outline approach:\n\n1. Start WordFilter initialization.\n2. For each word with index i:\n   - For each prefix length p from 0 to len(word):\n     - prefix = word[0:p]\n     - For each suffix length s from 0 to len(word):\n       - suffix = word[len-s:]\n       - store mapping key (prefix, suffix) → max index i.\n   - But complexity huge. Instead use a combined trie: insert all combinations of prefix and suffix with # separator.\n\nSimplify virtual steps: Build a trie where each node holds the max index of words passing through that node. For each word with index i:\n- For each possible suffix starting index j (0 to len):\n  - key = word[j:] + \"#\" + word\n  - Insert key into trie, updating node indices with i.\nDuring query pref, suff:\n- key = suff + \"#\" + pref (but depending on building).\n- Search trie for key, return node index.\n\nSimpler: Use dictionary of keys: prefix + \"#\" + suffix to index. Insert for each word: for each prefix and suffix combination? Too heavy.\n\nLet's keep a simpler design: For each word, insert all suffixes into a suffix trie mapping to list of indices, and prefix trie mapping to indices. Then intersection.\n\nPseudo:\n\n- Build prefix trie: each node stores list of indices (or max index).\n- Build suffix trie: each node stores list of indices (or max index).\n- Query: traverse prefix trie with pref to get list of indices, traverse suffix trie with suff to get list of indices, find max index present in both lists.\n\nBut still we need intersection; we can store indices sets, but we can just store max index per node; but intersection needed to find max common. We can instead store list of indices sorted. Intersection can be done by two pointers. Or we can store mapping from prefix node to set of indices and from suffix node to set; then find intersection. Complexity okay for virtual.\n\nLet's produce steps:\n\n- Start WordFilter init\n- Store words array\n- Build prefix trie:\n  - Root node\n  - For each word with index i:\n    - Node = root\n    - For each character c in word:\n      - Move/create child c\n      - Add index i to node's index list (or update max)\n- Build suffix trie:\n  - Root\n  - For each word with index i:\n    - Node = root\n    - For each character c in reversed word:\n      - Move/create child c\n      - Add index i to node's index list\n- End init\n\n- f(pref, suff):\n  - Start\n  - Node = prefix root\n  - For each c in pref:\n    - If child c missing: return -1\n    - Node = child\n  - PrefixIndices = node.indexList\n  - Node = suffix root\n  - For each c in reversed suff:\n    - If child c missing: return -1\n    - Node = child\n  - SuffixIndices = node.indexList\n  - Compute max index common to both lists\n    - Use two pointers since lists sorted by insertion order maybe ascending\n    - Return found max or -1\n  - End\n\nProvide steps.\n\nLet's produce pseudo with arrows.\n\nWe'll present like:\n\nStart // 初始化\n→ Step 1: 记录 words 数组 // 储存原始单词\n→ Step 2: 初始化前缀 Trie // 用于根据前缀检索单词索引\n→ Step 3: 初始化后缀 Trie // 用于根据后缀检索单词索引\n→ Decision: 处理每个单词? // 逐个单词插入 Trie\n    → Step 4: 对单词 i 取前缀遍历并在前缀 Trie 每个节点加入索引 i // 记录该前缀对应的单词索引\n    → Step 5: 对单词 i 取后缀遍历（倒序）并在后缀 Trie 每个节点加入索引 i // 记录该后缀对应的单词索引\nEnd // 完成初始化\n\nThen for query f(pref, suff):\n\nStart // f 函数开始\n→ Step 6: 在前缀 Trie 根据 pref 查找对应节点 // 获得所有以 pref 开头的单词索引列表\n    → Decision: 节点存在? // 前缀是否匹配\n        Yes → Step 7: 取节点的索引列表为 PrefixList // 记录可能的索引\n        No  → Step 8: 返回 -1 // 无匹配前缀\n→ Step 9: 在后缀 Trie 根据 suff（倒序）查找对应节点 // 获得所有以 suff 结尾的单词索引列表\n    → Decision: 节点存在? // 后缀是否匹配\n        Yes → Step 10: 取节点的索引列表为 SuffixList // 记录可能的索引\n        No  → Step 11: 返回 -1 // 无匹配后缀\n→ Step 12: 计算 PrefixList 与 SuffixList 的交集并取最大索引 // 找到同时满足前缀和后缀的最大索引\n    → Decision: 交集为空? // 是否存在满足条件的单词\n        Yes → Step 13: 返回 -1 // 没有匹配\n        No  → Step 14: 返回最大索引 // 最终结果\nEnd // f 函数结束\n\nMake sure each line follows format: `虛擬碼步驟 // 解釋`.\n\nWe need to include arrow `→` and decision indentation.\n\nAlso need to include Start, End for init and f.\n\nLet's craft.\n\n...done thinking.\n\nStart // WordFilter 建構子開始執行  \n→ Step 1: 記錄 words 陣列 // 儲存所有單字及其索引  \n→ Step 2: 初始化前綴 Trie  // 用於根據前綴查找單字索引  \n→ Step 3: 初始化後綴 Trie  // 用於根據後綴查找單字索引  \n\nDecision: 逐一處理每個單字? // 逐個單字插入 Trie  \n Yes → Step 4: 以單字 i 為索引，從根節點開始，逐字符往前插入前綴 Trie，並於每個節點的索引列表加入 i // 讓前綴節點知道有此單字  \n Yes → Step 5: 以單字 i 為索引，將單字反向迭代，逐字符往後插入後綴 Trie，並於每個節點的索引列表加入 i // 讓後綴節點知道有此單字  \nEnd // WordFilter 建構完成  \n\n---  \n\nStart // f 函式開始執行  \n→ Step 6: 在前綴 Trie 上按 pref 字符逐層搜尋節點 // 找到所有以 pref 開頭的單字索引  \n Decision: 前綴節點存在?  \n  Yes → Step 7: 取得該節點的索引列表 PrefixList // 可能符合前綴的索引  \n  No  → Step 8: 回傳 -1 // 無符合前綴的單字  \n→ Step 9: 在後綴 Trie 上按 suff 逆序字符逐層搜尋節點 // 找到所有以 suff 結尾的單字索引  \n Decision: 後綴節點存在?  \n  Yes → Step 10: 取得該節點的索引列表 SuffixList // 可能符合後綴的索引  \n  No  → Step 11: 回傳 -1 // 無符合後綴的單字  \n→ Step 12: 交叉比對 PrefixList 與 SuffixList，取最大公共索引 MaxIdx // 同時符合前綴與後綴的最大索引  \n Decision: MaxIdx 是否存在?  \n  Yes → Step 13: 回傳 MaxIdx // 找到的最大索引  \n  No  → Step 14: 回傳 -1 // 沒有同時符合前後綴的單字  \nEnd // f 函式結束  \n\n---  \n\n此虛擬碼展示 WordFilter 建構時建立前綴與後綴 Trie 的流程，及 f() 時從兩棵 Trie 分別取得前後綴索引，最後交叉比對取得符合條件的最大索引。",
      "generated_code": "import sys\nimport json\nimport re\n\nclass WordFilter:\n    def __init__(self, words):\n        # 建立一個字典，鍵為 (前綴, 後綴) 的元組，值為對應單字的最大索引\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # 對每個可能的前綴長度和後綴起始位置建立鍵\n            for i in range(L + 1):\n                prefix = word[:i]\n                for j in range(L + 1):\n                    suffix = word[j:]\n                    self.lookup[(prefix, suffix)] = weight\n\n    def f(self, prefix, suffix):\n        # 直接查表，若不存在則回傳 -1\n        return self.lookup.get((prefix, suffix), -1)\n\ndef parse_input(data):\n    \"\"\"\n    解析輸入資料，支援以下兩種格式：\n    1) 兩個 JSON 陣列以逗號分隔，例如 '[[\"apple\"]], [\"a\", \"e\"]'\n    2) 每行一個 JSON 陣列，例如\n        [[\"apple\"]]\n        [\"a\",\"e\"]\n    \"\"\"\n    data = data.strip()\n    # 先嘗試從整段文字中抓取兩個方括號包裹的 JSON\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) >= 2:\n        words = json.loads(lists[0])\n        query = json.loads(lists[1])\n        return words, query[0], query[1]\n    # 如果只抓到一個方括號，可能是分行輸入\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        words = json.loads(lines[0])\n        query = json.loads(lines[1])\n        return words, query[0], query[1]\n    # 最後回退到逗號分隔\n    parts = [p.strip() for p in data.split(',', 1)]\n    if len(parts) == 2:\n        words = json.loads(parts[0])\n        query = json.loads(parts[1])\n        return words, query[0], query[1]\n    raise ValueError(\"無法解析輸入資料\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    words, pref, suff = parse_input(raw_input)\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpwxrrm__b.py\", line 53, in <module>\n    words, pref, suff = parse_input(raw_input)\n                        ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwxrrm__b.py\", line 34, in parse_input\n    words = json.loads(lists[0])\n            ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 11 (char 10)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode409.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindrome",
    "description_snippet": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find longest palindrome length from given string s, case sensitive. Approach: count frequency of each letter. For each char with even count, add full count to length; for odd counts, add count-1, and remember that there is at least one odd to allow center. If any odd, length +1. So virtual code.\n\nWe output lines with arrows and explanations. Must follow format: Start, → Step etc. Use Decision. Let's produce.\n\nNeed to be careful: Provide each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nLet's produce step by step:\n\nStart\n\n→ Step 1: Initialize frequency_map ← empty map // 建立字母頻率表\n\n→ Step 2: For each char c in s: frequency_map[c] ← frequency_map.get(c,0)+1 // 計算每個字母出現次數\n\n→ Step 3: length ← 0 // 儲存可組成的回文長度\n\n→ Decision: 是否存在奇數頻率的字母? // 檢查是否有至少一個字母的出現次數為奇數\n\nWe need to compute length within loop. Maybe simpler: loop over counts.\n\nBetter:\n\n→ Step 4: odd_exists ← False // 標記是否有奇數頻率\n\n→ Step 5: For each count in frequency_map.values(): // 逐個處理每個字母的頻率\n\n    → Decision: count mod 2 == 0? // 頻率為偶數?\n\n        Yes → length ← length + count // 直接加入\n\n        No  → length ← length + (count - 1) // 加入最大偶數部分\n\n        No  → odd_exists ← True // 記錄有奇數\n\n→ Decision: odd_exists? // 是否可以在中心放一個字母\n\n    Yes → length ← length + 1 // 加入中心字母\n\n    No  → // 什麼都不做\n\nEnd\n\nBut we need to maintain arrow structure: Indent decisions.\n\nAlso need to reflect the loop.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: frequency_map ← empty map // 建立字母頻率表  \n→ Step 2: For each character c in s: frequency_map[c] ← frequency_map.get(c, 0) + 1 // 計算每個字母的出現次數  \n→ Step 3: length ← 0 // 儲存可組成的回文長度  \n→ Step 4: odd_exists ← False // 標記是否有奇數頻率字母  \n→ Step 5: For each count in frequency_map.values(): // 逐個處理每個字母的頻率  \n  → Decision: count mod 2 == 0? // 該字母的頻率是否為偶數？  \n   Yes → length ← length + count // 偶數，完整加入長度  \n   No  → length ← length + (count - 1) // 奇數，僅加入最大的偶數部分  \n   No  → odd_exists ← True // 記錄存在奇數頻率  \n→ Decision: odd_exists? // 是否可以在中心放一個字母？  \n  Yes → length ← length + 1 // 加入中心字母，完整構成回文  \n  No  → // 沒有奇數頻率，長度已完整  \nEnd // 程式執行結束，返回 length 之值",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef longest_palindrome_length(s: str) -> int:\n    \"\"\"\n    計算可以由字串 s 中的字母組成的最大回文長度。\n    \"\"\"\n    count = Counter(s)          # 先統計每個字母出現次數\n    length = 0                  # 可組成的回文長度\n    odd_found = False           # 是否存在奇數頻率字母\n\n    for freq in count.values():\n        if freq % 2 == 0:       # 偶數頻率，全部可用\n            length += freq\n        else:                   # 奇數頻率，只能使用 freq-1 個\n            length += freq - 1\n            odd_found = True\n\n    if odd_found:               # 若有奇數頻率，可在中心放一個字母\n        length += 1\n\n    return length\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    從 stdin 讀取的資料中擷取字串值。\n    允許「s = \"abc\"」或僅輸入字串本身。\n    \"\"\"\n    # 先尋找第一個雙引號中的內容\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        return m.group(1)\n    # 若沒有雙引號，直接去除首尾空白\n    return data.strip()\n\ndef main() -> None:\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    s = parse_input(raw)\n    result = longest_palindrome_length(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abccccdd\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode502.json",
    "problem_index_in_file": 0,
    "title": "IPO",
    "description_snippet": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Cap...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm. Problem known as IPO: choose up to k projects maximizing capital. Standard solution: use min-heap for capital, max-heap for profits. Steps: sort projects by capital, push into min-heap. For k times, move all projects with capital <= current capital into max-heap of profits. If max-heap empty break. Pop max profit, add to capital. Return capital. We'll produce pseudocode line by line with comments. Use \"Start\", \"End\", \"Decision:\" and arrows. Provide each line with explanation. No actual code.\n\nLet's craft steps.\n\n1. Start\n2. Initialize list of projects as pairs (capital[i], profit[i]) // combine arrays\n3. Sort list ascending by capital // ensures we can push eligible projects\n4. Initialize index idx = 0 // tracks next project to consider\n5. Initialize maxProfitHeap // max-heap for profits\n6. For iteration 1 to k:\n   a. Decision: while idx < n and projects[idx].capital <= currentCapital? // add eligible projects\n        Yes -> push projects[idx].profit into maxProfitHeap; idx++\n        No -> exit while\n   b. Decision: if maxProfitHeap is empty? // no available project\n        Yes -> break loop; No -> continue\n   c. Pop maxProfit from maxProfitHeap // choose best\n   d. currentCapital += maxProfit // add profit\n7. End // return currentCapital\n\nWe need to output each line with explanation. Each line may have nested decision lines. Use indentation maybe? Format: \"→ Decision:\" lines. We can include indentation by spaces? Use tabs? The example uses spaces before lines after Decision. We'll replicate.\n\nWe'll produce lines:\n\nStart // start\n→ Step 1: Combine profits and capital into projectPairs // create list of (capital, profit)\n→ Step 2: Sort projectPairs by capital ascending // order by required capital\n→ Step 3: idx ← 0 // next project index\n→ Step 4: currentCapital ← w // initial capital\n→ Step 5: Initialize maxProfitHeap // heap to select largest profit\n→ Step 6: For i from 1 to k: // at most k projects\n    → Decision: while idx < n AND projectPairs[idx].capital ≤ currentCapital? // add all affordable projects\n        Yes → Step 6a: Push projectPairs[idx].profit into maxProfitHeap\n        No  → Step 6b: Exit while loop\n    → Decision: If maxProfitHeap is empty? // no available project\n        Yes → Step 6c: Break the for loop // cannot pick more\n        No  → Step 6d: Pop maxProfit ← Pop from maxProfitHeap // select best\n    → Step 6e: currentCapital ← currentCapital + maxProfit // update capital\n→ End // return currentCapital\n\nWe need to ensure each line includes \"虛擬碼步驟\" + space + comment. So each line will be something like:\n\nStart // 程式開始執行\n\nBut the step line might have arrow \"→ Step 1:\" etc.\n\nLet's produce.\n\nNeed to make sure each line ends with comment. Use // and explanation. Use Traditional Chinese. Provide explanation in Traditional Chinese.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: projectPairs ← Zip(capital, profits) // 將資本與利潤配對成 (資本, 利潤) 清單  \n→ Step 2: Sort(projectPairs, key = capital) // 按資本需求升序排序，方便後續挑選  \n→ Step 3: idx ← 0 // 追蹤尚未考慮的專案索引  \n→ Step 4: currentCapital ← w // 初始資本  \n→ Step 5: maxProfitHeap ← EmptyMaxHeap() // 用來快速取得最高利潤的最大堆  \n→ Step 6: For i ← 1 to k Do // 最多執行 k 次專案  \n  → Decision: While idx < n AND projectPairs[idx].capital ≤ currentCapital? // 將所有可負擔的專案推進最大堆  \n    Yes → Step 6a: Push(maxProfitHeap, projectPairs[idx].profit) // 把利潤加入堆中  \n      idx ← idx + 1 // 移至下一個專案  \n    No  → Step 6b: BreakWhile // 沒有更多可負擔的專案，跳出 while  \n  → Decision: If IsEmpty(maxProfitHeap)? // 堆內無可選擇專案  \n    Yes → Step 6c: Break // 無法再挑選專案，結束迴圈  \n    No  → Step 6d: maxProfit ← Pop(maxProfitHeap) // 取出最高利潤  \n  → Step 6e: currentCapital ← currentCapital + maxProfit // 加入利潤到資本  \n→ End // 程式執行結束，返回 currentCapital 〈最終資本〉",
      "generated_code": "import sys\nimport heapq\nimport re\n\ndef findMaximizedCapital(k, W, profits, capital):\n    # 把每個專案按資本需求排序\n    projects = sorted(zip(capital, profits))\n    max_heap = []\n    i = 0\n    n = len(profits)\n\n    for _ in range(k):\n        # 把所有目前可負擔的專案放進最大堆\n        while i < n and projects[i][0] <= W:\n            heapq.heappush(max_heap, -projects[i][1])  # 取負數做最大堆\n            i += 1\n        if not max_heap:\n            break  # 沒有可選專案\n        # 取利潤最高的專案\n        W += -heapq.heappop(max_heap)\n    return W\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 4:\n        return\n    k = nums[0]\n    w = nums[1]\n    remaining = nums[2:]\n    n = len(remaining) // 2\n    profits = remaining[:n]\n    capital = remaining[n:]\n    result = findMaximizedCapital(k, w, profits, capital)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode242.json",
    "problem_index_in_file": 0,
    "title": "Valid Anagram",
    "description_snippet": "Given two strings s and t, return true if t is an anagram of s, and false otherwise....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code line by line with explanation. Need to cover algorithm for checking anagram. Likely steps: Start, Check lengths equal, sort both strings or count frequencies, compare. Let's produce simple algorithm: if lengths not equal -> false; else count characters. Use array of 26 or dictionary. Then compare counts. Provide End. Use decision arrow. Ensure each line format: `虛擬碼步驟 // 解釋/說明`. Use `→` arrow and decisions. Let's produce:\n\nStart\n→ Step 1: 取得字串 s 和 t // Input strings\n→ Decision: 如果 s 長度不等於 t 長度? // Length check\n    Yes → Step 2: 回傳 false // Not same length, cannot be anagram\n    No  → Step 3: 建立頻率表 freq[26] 初始化為0 // Frequency array\n→ Step 4: 對 s 中每個字符 c: freq[索引(c)]++ // Count s chars\n→ Step 5: 對 t 中每個字符 c: freq[索引(c)]-- // Decrement with t chars\n→ Decision: 如果 freq 陣列任何元素非0? // Check for mismatches\n    Yes → Step 6: 回傳 false // Counts differ, not anagram\n    No  → Step 7: 回傳 true // All counts zero, is anagram\nEnd\n\nWe need to include arrows for each step. Should we prefix each line with arrow? The example uses \"→ Step 1:\" for each. For decisions, use \"Decision:\" lines with nested Yes/No arrows. Use \"Start\" and \"End\". Let's produce accordingly. Also include explanation in Chinese. Provide each line with `//` comment.\n\nMake sure each line ends with comment. Provide the code in one block. Ensure proper indentation maybe optional. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得字串 s 和 t // 取得輸入的兩個字串  \n→ Decision: s 的長度是否等於 t 的長度? // 若長度不同，無法為字母異位詞  \n Yes → Step 2: 回傳 false // 長度不等，直接返回 false  \n No  → Step 3: 初始化 freq[26] 為 0 // 建立 26 個整數的頻率表  \n→ Step 4: 對 s 中每個字符 c: freq[索引(c)]++ // 統計 s 的字符頻率  \n→ Step 5: 對 t 中每個字符 c: freq[索引(c)]-- // 從頻率表減去 t 的字符頻率  \n→ Decision: freq 陣列中是否存在非 0 的元素? // 檢查頻率是否平衡  \n Yes → Step 6: 回傳 false // 有不平衡，兩字串不是異位詞  \n No  → Step 7: 回傳 true // 所有頻率為 0，兩字串為字母異位詞  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef is_anagram(s: str, t: str) -> bool:\n    \"\"\"\n    判斷兩個字串是否為字母異位詞。\n    透過 Counter 計算兩個字串各字母出現次數，若相等即為異位詞。\n    \"\"\"\n    return Counter(s) == Counter(t)\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析出 s 與 t，輸出 'true' 或 'false'。\n    \"\"\"\n    # 取得整個輸入字串\n    raw = sys.stdin.read()\n\n    # 先嘗試從雙引號中抓取兩個字串\n    matches = re.findall(r'\"([^\"]*)\"', raw)\n    if len(matches) >= 2:\n        s, t = matches[0], matches[1]\n    else:\n        # 若無雙引號，嘗試直接以空白分割\n        parts = raw.strip().split()\n        if len(parts) >= 2:\n            s, t = parts[0], parts[1]\n        else:\n            # 無法解析，視為空字串\n            s, t = \"\", \"\"\n\n    # 判斷並輸出結果\n    print(\"true\" if is_anagram(s, t) else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"anagram\", t = \"nagaram\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"rat\", t = \"car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode301.json",
    "problem_index_in_file": 0,
    "title": "Remove Invalid Parentheses",
    "description_snippet": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parenth...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: remove minimum invalid parentheses to generate all valid strings. Classic Leetcode 301. Use BFS to find all valid strings with minimal removal. Steps: compute number of left to remove and right to remove. Then DFS/Backtracking with pruning or BFS. Since need minimal removals, BFS level by level ensures minimal. But to avoid duplicates, use set. Steps: generate queue, visited. While queue not empty: for each string, check valid. If found valid, add to results and set flag; after processing level, break if found. Else generate neighbors by removing one char at each position if char is '(' or ')', produce new string; if not visited add to next level. Finally output results.\n\nWe'll produce virtual code line-by-line.\n\nInclude Start, End. Decision, Steps.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 IsValid(s) → // 檢查字串 s 是否為合法括號串\n    → Step 2: 設定 counter = 0 // 追蹤左括號剩餘數\n    → Step 3: 逐字符遍歷 s\n        → Decision: 如果 char 為 '('? // 遇到左括號\n            Yes → counter += 1 // 右移\n            No  → Decision: 如果 char 為 ')'?\n                Yes → counter -= 1 // 右括號扣減\n                No  → continue // 其他字符忽略\n        → Decision: 如果 counter < 0? // 右括號多於左括號\n            Yes → return False // 立即失敗\n    → Decision: counter == 0? // 最後左右相等\n        Yes → return True\n        No  → return False\n→ Step 4: 定義主函式 RemoveInvalidParentheses(s)\n    → Step 5: 初始化 queue = [s] // BFS 循環起始字串\n    → Step 6: 初始化 visited = {s} // 避免重複處理\n    → Step 7: 初始化結果列表 results = [] // 儲存符合條件的字串\n    → Step 8: 初始化 found = False // 判斷是否已找到最小級別合法字串\n    → Decision: queue 是否空? // 若沒有待處理字串\n        Yes → End // 直接結束，返回空結果\n        No  → continue\n    → Step 9: 處理當前層級（一次完整 BFS 探索）\n        → Step 10: 取出並遍歷 queue 中所有字串 (size 為當前層級長度)\n            → Step 11: 對於每個字串 curr\n                → Decision: IsValid(curr)? // 檢查是否合法\n                    Yes →\n                        → Step 12: 將 curr 加入 results\n                        → Step 13: 設定 found = True // 已找到合法字串\n                    No  → continue // 若尚未合法，將其分支加入下一層\n                → Decision: found? // 已找到合法字串，無需產生更多子串\n                    Yes → continue // 直接跳過子串生成\n                    No  → // 產生子串\n                        → Step 14: 逐位 i 於 curr\n                            → Decision: curr[i] 為 '(' 或 ')'?\n                                Yes →\n                                    → Step 15: newStr = curr[:i] + curr[i+1:] // 移除第 i 個括號\n                                    → Decision: newStr 是否在 visited? \n                                        Yes → continue // 已處理過，忽略\n                                        No  →\n                                            → Step 16: 將 newStr 加入 visited\n                                            → Step 17: 將 newStr 加入下一層的 queue (tempQueue)\n                                No  → continue // 非括號字符不處理\n        → Decision: found? // 當層級是否已找到合法字串\n            Yes → End // 最小級別已完成，結束\n            No  → // 從 tempQueue 準備下一層\n                → Step 18: queue = tempQueue\n                → Step 19: tempQueue = [] // 清空暫存\n                → Decision: queue 是否空? // 若無剩餘字串\n                    Yes → End // 所有可能已檢查完畢\n                    No  → 轉至 Step 9 處理下一層\n→ End // 程式執行結束，返回 results\n\n(Note: 虛擬碼僅作示例，實際實作可使用適當資料結構與迴圈控制。)",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        使用 BFS 逐層刪除括號，直到找到最少刪除後的合法字串。\n        \"\"\"\n        def isValid(st: str) -> bool:\n            cnt = 0\n            for ch in st:\n                if ch == '(':\n                    cnt += 1\n                elif ch == ')':\n                    cnt -= 1\n                    if cnt < 0:\n                        return False\n            return cnt == 0\n\n        level = {s}\n        while level:\n            # 先檢查本層是否已有合法字串\n            valid = [x for x in level if isValid(x)]\n            if valid:\n                return valid\n\n            # 生成下一層的字串：對每個括號刪除一個\n            next_level = set()\n            for item in level:\n                for i, ch in enumerate(item):\n                    if ch in ('(', ')'):\n                        nxt = item[:i] + item[i + 1:]\n                        if nxt not in next_level:\n                            next_level.add(nxt)\n            level = next_level\n        return []\n\n\ndef main() -> None:\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 如果輸入包含「s =」的前綴，去除前綴與雙/單引號\n    if '=' in raw_input:\n        _, rest = raw_input.split('=', 1)\n        s = rest.strip()\n        if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n            s = s[1:-1]\n    else:\n        s = raw_input\n\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n\n    # 輸出為 JSON 陣列，符合範例格式\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        },
        {
          "example_index": 2,
          "input": "s = \")(\"",
          "expected_output": "[\"\"]",
          "success": true,
          "output": "[\"\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode482.json",
    "problem_index_in_file": 0,
    "title": "License Key Formatting",
    "description_snippet": "You are given a license key represented as a string s that consists of only alphanumeric characters ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that reformats license key. Steps: start, remove dashes, convert to upper, group from end, build groups, join with dashes.\n\nWe need line by line, with virtual code + comment. Use arrows, decision, loops.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: s ← Remove all '-' from s // 先把字串中的破折號全部去除  \n→ Step 2: s ← Convert s to uppercase // 把所有小寫字母轉成大寫  \n→ Step 3: len ← Length of s // 取得處理後字串的長度  \n→ Step 4: groupCount ← ceil(len / k) // 計算需要的群組數量（最後一群可能不足 k）  \n→ Step 5: result ← Empty string // 用來儲存重新排版後的結果  \n→ Step 6: i ← 0 // 指標指向字串起始位置  \n→ Decision: If i < len? // 是否還有字元未處理？  \n    Yes → Step 7: remaining ← len - i // 從指標到字串結束剩餘字元數  \n    → Step 8: currentGroupSize ← min(k, remaining) // 本群的字元數（最後一群可能不足 k）  \n    → Step 9: result ← Append substring(s, i, currentGroupSize) to result // 把本群字元加入結果  \n    → Decision: If i + currentGroupSize < len? // 是否還有下一群？  \n        Yes → result ← Append '-' to result // 追加破折號以分隔群組  \n        No → // 最後一群，不需要再追加破折號  \n    → Step 10: i ← i + currentGroupSize // 移動指標到下一群的起始位置  \n    → Go back to Decision  \n    No → End // 所有字元已處理，結束  \nEnd // 程式執行結束，result 為重新排版後的 license key",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def licenseKeyFormatting(self, S: str, K: int) -> str:\n        \"\"\"\n        先把字串中的破折號全部去除並轉成大寫，再從左到右分組。\n        第一組長度可能小於 K，其他組必定長度為 K，最後一組也可能短。\n        \"\"\"\n        # 1. 去除破折號，轉成大寫\n        S = S.replace('-', '').upper()\n        n = len(S)\n\n        # 2. 第一組長度\n        first_len = n % K or K\n\n        # 3. 依序收集各組\n        groups = [S[:first_len]]\n        for i in range(first_len, n, K):\n            groups.append(S[i:i+K])\n\n        # 4. 以破折號連結回傳\n        return '-'.join(groups)\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中抽取 s 與 k 的值。\n    支援兩種常見格式：\n        1. s = \"xxxx\", k = 4\n        2. 第一行是字串，第二行是整數\n    \"\"\"\n    # 嘗試使用正則表達式抓取\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', text)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', text)\n\n    if s_match and k_match:\n        s = s_match.group(1)\n        k = int(k_match.group(1))\n    else:\n        # 若找不到，直接按行拆分\n        lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            s = lines[0].strip('\"')\n            k = int(lines[1])\n        else:\n            # 失敗時回傳空值\n            s = \"\"\n            k = 0\n    return s, k\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    s, k = parse_input(raw_input)\n\n    # 產生結果並輸出\n    sol = Solution()\n    result = sol.licenseKeyFormatting(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "success": true,
          "output": "5F3Z-2E9W"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "success": true,
          "output": "2-5G-3J"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode373.json",
    "problem_index_in_file": 0,
    "title": "Find K Pairs with Smallest Sums",
    "description_snippet": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nD...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm: find k smallest sum pairs from two sorted arrays. Standard solution: use min-heap of size up to k, start with (0,0) pair, push neighbors (i+1,j) and (i,j+1). Use visited set to avoid duplicates. Return first k popped. Virtual code line-by-line. Use \"Start\", \"End\". Use arrows. Each line: \"→ Step: ... // explanation\". Provide decision structures.\n\nLet's craft step-by-step:\n\nStart\n→ Initialize minHeap // min-heap priority queue\n→ Initialize visited set // to avoid duplicates\n→ Push (0,0, sum=nums1[0]+nums2[0]) to heap // first pair\n→ visited add (0,0)\n→ Initialize result list // to store k pairs\n→ While heap not empty AND result size < k // loop\n    → Pop top from heap // get smallest sum pair\n    → Append (i,j) to result // record indices or values\n    → If i+1 < len(nums1) and (i+1,j) not visited\n        → Add (i+1,j) to heap with sum // push neighbor from nums1\n        → Mark visited\n    → If j+1 < len(nums2) and (i,j+1) not visited\n        → Add (i,j+1) to heap with sum // push neighbor from nums2\n        → Mark visited\n→ End // done\n\nBut we need to include explanation after each line. Also need to mention using sum of values. Virtual code format: \"Step\" or \"Decision\". Use \"Yes→\" etc. For if statements: Decision: If condition? Yes→ then step, No→ etc. For loops: \"While ...\". We'll use \"Decision:\" for while condition? But it's typical loop not decision. But we can express as \"Decision: heap not empty AND result size < k?\" Yes → continue. Might use \"Decision:\".\n\nWe need to produce each line as separate line. Use arrow \"→\" for next line. Also include indentation for nested steps? Provide indentation to show nested decisions. Use indentation spaces for clarity.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: 初始化最小堆 minHeap // 用於取得最小總和的對\n→ Step: 初始化訪問集合 visited // 追蹤已加入堆的索引對\n→ Step: 若 nums1, nums2 非空，將 (0,0, sum=nums1[0]+nums2[0]) 插入 minHeap // 第一個可能的對\n→ Step: visited.add((0,0)) // 標記已加入\n→ Step: 初始化結果列表 result // 存放 k 個最小和的對\n→ Decision: minHeap 非空且 len(result) < k? // 判斷是否還需要繼續\n    Yes →\n        → Step: pop = minHeap.pop() // 取得當前最小總和的對\n        → Step: i, j = pop.indices // 取得索引\n        → Step: result.append((nums1[i], nums2[j])) // 記錄對\n        → Decision: i+1 < len(nums1) 且 (i+1, j) 未訪問? // 檢查左鄰\n            Yes →\n                → Step: push (i+1, j, sum=nums1[i+1]+nums2[j]) 到 minHeap // 加入左鄰\n                → Step: visited.add((i+1, j))\n            No →\n        → Decision: j+1 < len(nums2) 且 (i, j+1) 未訪問? // 檢查右鄰\n            Yes →\n                → Step: push (i, j+1, sum=nums1[i]+nums2[j+1]) 到 minHeap // 加入右鄰\n                → Step: visited.add((i, j+1))\n            No →\n        → Decision: minHeap 非空且 len(result) < k? // 重複迴圈\n            Yes →（回到上一 Decision） // 這裡可用回圈符號\n            No  →\n→ End // 程式執行結束\n\nBut we need to adhere to arrow formatting: \"→\" per line. Indentation with spaces for nested lines. For decisions, show \"Decision:\" and \"Yes →\" lines etc.\n\nAlso need to show line after while condition? We can write \"While minHeap 非空且 len(result) < k:\" but we need to follow format \"Decision:\"? The example uses Decision: If condition? Then Yes→, No→. We can do that. But the example used \"Decision:\" for if, and \"→\" for step.\n\nAlso we need to provide \"Yes →\" indentation for each nested.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step: 初始化最小堆 minHeap // 用於取得最小總和的對\n→ Step: 初始化訪問集合 visited // 追蹤已加入堆的索引對\n→ Decision: nums1 及 nums2 是否非空? // 確認陣列有元素\n    Yes →\n        → Step: minHeap.push((0, 0, nums1[0]+nums2[0])) // 插入第一個對\n        → Step: visited.add((0, 0)) // 標記已加入\n    No →\n→ Step: 初始化結果列表 result // 存放 k 個最小和的對\n→ Decision: minHeap 非空且 len(result) < k? // 需要進一步處理\n    Yes →\n        → Step: pop = minHeap.pop() // 取出總和最小的對\n        → Step: i, j = pop.indices // 取得對應索引\n        → Step: result.append((nums1[i], nums2[j])) // 儲存結果\n        → Decision: i+1 < len(nums1) 且 (i+1, j) 未訪問? // 檢查左鄰\n            Yes →\n                → Step: minHeap.push((i+1, j, nums1[i+1]+nums2[j])) // 加入左鄰\n                → Step: visited.add((i+1, j))\n            No →\n        → Decision: j+1 < len(nums2) 且 (i, j+1) 未訪問? // 檢查右鄰\n            Yes →\n                → Step: minHeap.push((i, j+1, nums1[i]+nums2[j+1])) // 加入右鄰\n                → Step: visited.add((i, j+1))\n            No →\n        → Decision: minHeap 非空且 len(result) < k? // 是否繼續\n            Yes →\n                → （回到上一步的 Decision） // 迴圈\n            No →\n→ End // 程式執行結束\n\nBut need to be \"逐行\" lines. Provide each line separate. Indentation may show nested. Use consistent style.\n\nWe also need to include line numbers? Not necessary.\n\nAlso maybe we can use \"While\" instead of Decision loops. But example uses Decision. Use Decision.\n\nAlso after \"Yes →\" we might need to close indentation? But we can simply keep indent spaces.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化最小堆 minHeap // 用於取得最小總和的對  \n→ Step: 初始化訪問集合 visited // 追蹤已加入堆的索引對  \n→ Decision: nums1 與 nums2 是否非空? // 確認兩個陣列都有元素  \n Yes →  \n  → Step: minHeap.push((0, 0, nums1[0]+nums2[0])) // 插入第一個對 (0,0)  \n  → Step: visited.add((0, 0)) // 標記此索引對已加入  \n No →  \n→ Step: 初始化結果列表 result // 用於儲存 k 個最小和的對  \n→ Decision: minHeap 非空且 len(result) < k? // 是否還需要再取出對  \n Yes →  \n  → Step: pop = minHeap.pop() // 取出目前最小總和的對  \n  → Step: i, j = pop.indices // 取得對應索引  \n  → Step: result.append((nums1[i], nums2[j])) // 加入結果  \n  → Decision: i+1 < len(nums1) 且 (i+1, j) 未訪問? // 檢查左鄰  \n   Yes →  \n    → Step: minHeap.push((i+1, j, nums1[i+1]+nums2[j])) // 加入左鄰  \n    → Step: visited.add((i+1, j))  \n   No →  \n  → Decision: j+1 < len(nums2) 且 (i, j+1) 未訪問? // 檢查右鄰  \n   Yes →  \n    → Step: minHeap.push((i, j+1, nums1[i]+nums2[j+1])) // 加入右鄰  \n    → Step: visited.add((i, j+1))  \n   No →  \n  → Decision: minHeap 非空且 len(result) < k? // 是否要繼續迴圈  \n   Yes →  \n    → （回到上一步的 Decision） // 重複迴圈  \n   No →  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        if not nums1 or not nums2 or k <= 0:\n            return []\n\n        heap = []\n        res = []\n\n        # 初始化堆：對於 nums1 的前 min(k, len(nums1)) 個元素，配上 nums2 的第一個元素\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n\n        # 取出 k 個最小總和的對\n        while heap and len(res) < k:\n            total, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n        return res\n\ndef parse_input() -> tuple[list[int], list[int], int]:\n    \"\"\"\n    從標準輸入讀取資料，支援格式：\n        nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n    或多行輸入，若輸入不符合則回傳空值。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], [], 0\n\n    # 轉成字典字串，方便使用 ast.literal_eval 解析\n    dict_str = '{' + data.replace(' = ', ':') + '}'\n    try:\n        parsed = ast.literal_eval(dict_str)\n    except Exception:\n        # 若字串格式異常，直接嘗試 eval\n        parsed = eval(dict_str, {})\n\n    nums1 = parsed.get('nums1', [])\n    nums2 = parsed.get('nums2', [])\n    k = parsed.get('k', 0)\n    return nums1, nums2, k\n\nif __name__ == \"__main__\":\n    nums1, nums2, k = parse_input()\n    solution = Solution()\n    result = solution.kSmallestPairs(nums1, nums2, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpry21s4l9.py\", line 39, in parse_input\n    parsed = ast.literal_eval(dict_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x79e94232a910>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpry21s4l9.py\", line 50, in <module>\n    nums1, nums2, k = parse_input()\n                      ^^^^^^^^^^^^^\n  File \"/tmp/tmpry21s4l9.py\", line 42, in parse_input\n    parsed = eval(dict_str, {})\n             ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums1' is not defined"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpheunxs_s.py\", line 39, in parse_input\n    parsed = ast.literal_eval(dict_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x764bd432a910>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpheunxs_s.py\", line 50, in <module>\n    nums1, nums2, k = parse_input()\n                      ^^^^^^^^^^^^^\n  File \"/tmp/tmpheunxs_s.py\", line 42, in parse_input\n    parsed = eval(dict_str, {})\n             ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums1' is not defined"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode732.json",
    "problem_index_in_file": 0,
    "title": "My Calendar III",
    "description_snippet": "A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, not actual code, but explanation. We need to handle MyCalendarThree with events [startTime, endTime). We need to maintain max number of concurrent events. Typically use sweep line: add +1 at start, -1 at end. Or segment tree with lazy propagation for range add and max query. Virtual code should represent operations, not actual language.\n\nWe'll produce steps:\n\nStart: initialize data structures: maybe a list of intervals. For each book call: add event, update data structure, compute max overlap.\n\nWe can outline:\n\n- Initialize an empty list or map for events.\n\n- For book(start, end):\n\n    - Add start to map with +1, end with -1.\n\n    - Sort keys or maintain sorted map.\n\n    - Iterate through sorted keys, accumulate running sum, track max.\n\n- Return max.\n\nSimplify: Use sorted list of points.\n\nBut we can also propose using a binary indexed tree after coordinate compression.\n\nLet's produce generic steps: each book: add event to list, then compute max overlapping via sweep.\n\nWe need to output each step line with explanation.\n\nWe should maintain internal structure: e.g., \"timeline map\".\n\nLet's produce:\n\nStart // 初始化 MyCalendarThree 对象\n\n→ Step 1: 初始化 空的时间线映射 // 用于记录每个时间点的变更\n\n→ End // 初始化完成\n\nThen for book:\n\nStart // 调用 book 方法\n\n→ Step 2: 在时间线映射中，时间点 startTime 增加 +1 // 记录事件开始\n\n→ Step 3: 在时间线映射中，时间点 endTime 减少 -1 // 记录事件结束\n\n→ Decision: 需要重新计算最大并发次数? // 评估是否要遍历时间线以找最大重叠\n\n    Yes → Step 4: 将时间线映射的所有时间点按升序排列 // 为扫描做准备\n\n        → Step 5: 初始化 running = 0, maxConcurrent = 0\n\n        → Step 6: 对于每个时间点 in sorted order:\n\n            → Step 7: running += 时间线映射[时间点] // 更新当前并发数\n\n            → Decision: running > maxConcurrent? // 检查是否更新最大值\n\n                Yes → Step 8: maxConcurrent = running // 记录新的最大并发数\n\n                No → Step 9: 继续\n\n        → Step 10: 结束遍历\n\n    No → Step 11: 跳过重新计算 // 若不需要更新\n\n→ Step 12: 返回 maxConcurrent // 输出当前最大 k-booking\n\nEnd // book 方法结束\n\nWe might need to show that we compute each time. But if we use more efficient segment tree, we can update and query max in O(log N). However we can keep simpler.\n\nBut the requirement: generate virtual code line by line and explanation. Let's produce as above.\n\nWe might also include an example of storing events list and compute via sweep each time.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 初始化 MyCalendarThree 對象  \n→ Step 1: 初始化 空的時間線映射 // 用於記錄每個時間點的變更量 (開始 +1, 結束 -1)  \nEnd // 初始化完成  \n\n---\n\nStart // 調用 book(startTime, endTime)  \n→ Step 2: 在時間線映射中，將時間點 startTime 的值 +1 // 事件開始  \n→ Step 3: 在時間線映射中，將時間點 endTime 的值 -1 // 事件結束  \n\n→ Decision: 是否需要重新計算最大同時重疊數? // 每次 book 後都重新掃描一次時間線  \n    Yes → Step 4: 取時間線映射的所有時間點並按升序排序 // 為掃描做準備  \n        → Step 5: 初始化 running = 0, maxConcurrent = 0 // running 為當前重疊事件數  \n        → Step 6: 遍歷每個排序後的時間點 t  \n            → Step 7: running += 時間線映射[t] // 更新當前重疊數  \n            → Decision: running > maxConcurrent? // 檢查是否有新的最大值  \n                Yes → Step 8: maxConcurrent = running // 記錄新的最大重疊數  \n                No  → Step 9: 直接進入下一個時間點  \n        → Step 10: 完成遍歷  \n    No  → Step 11: 跳過重新計算（不會發生，因為每次 book 都要更新）  \n\n→ Step 12: 返回 maxConcurrent // 目前最大 k‑booking 數量  \nEnd // book 方法執行結束",
      "generated_code": "import sys\nimport bisect\nimport ast\n\nclass MyCalendarThree:\n    def __init__(self):\n        # timeline stores tuples (time, delta), sorted by time\n        self.timeline = []\n\n    def book(self, start: int, end: int) -> int:\n        # insert start with +1 and end with -1 into timeline\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n\n        active = 0\n        max_active = 0\n        # sweep line to find maximum overlap\n        for _, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\nif __name__ == \"__main__\":\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # The input consists of two lists separated by a comma, e.g.\n    # [\"MyCalendarThree\", \"book\", ...], [[], [10,20], ...]\n    # Wrap the input in parentheses to parse as a tuple of two lists.\n    raw_input = '(' + raw_input + ')'\n    try:\n        ops, args = ast.literal_eval(raw_input)\n    except Exception as e:\n        # If parsing fails, exit gracefully\n        sys.exit(1)\n\n    instance = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == 'MyCalendarThree':\n            instance = MyCalendarThree()\n            results.append('null')\n        elif op == 'book':\n            if instance is None:\n                # No instance created yet; skip or handle error\n                results.append(None)\n            else:\n                res = instance.book(*arg)\n                results.append(res)\n        else:\n            # Unsupported operation\n            results.append(None)\n\n    # Print results in the required format: [null, 1, 2, ...]\n    formatted = '[' + ', '.join(str(r) if r != 'null' else 'null' for r in results) + ']'\n    print(formatted)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "success": true,
          "output": "[null, 1, 1, 2, 3, 3, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode162.json",
    "problem_index_in_file": 0,
    "title": "Find Peak Element",
    "description_snippet": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for binary search to find peak. Each line with \"虛擬碼步驟 // 解釋\". Use arrows. Format similar to sample. Use Start, End, Decision. Provide step by step.\n\nWe need lines:\n\nStart\n→ Step 1: 定義 low=0, high=n-1 // 初始化搜尋範圍\n→ Decision: low==high? // 如果只有一個元素\n    Yes → Step 2: 回傳 low // 直接返回\n    No → Step 3: 進入 while 迴圈\n→ While low < high:\n    ← Step 4: mid = (low + high) // 2 // 計算中間索引\n    ← Decision: nums[mid] < nums[mid+1]? // 判斷右邊是否更大\n        Yes → Step 5: low = mid + 1 // 峰在右側\n        No  → Step 6: high = mid // 峰在左側或是 mid\n→ Step 7: 回傳 low // low==high 時為峰索引\nEnd\n\nMake sure arrows: → for sequential, Decision with Yes →, No →. Use Start, End. Each line: code + space + // 解釋. Use Chinese.\n\nLet's write accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0, high = n-1 // 初始化搜尋範圍為整個陣列  \n→ Decision: low == high? // 檢查是否只剩一個元素  \n    Yes → Step 2: return low // 若只有一個元素，直接回傳其索引作為峰  \n    No  → Step 3: // 進入搜尋迴圈  \n→ While low < high:  \n    → Step 4: mid = (low + high) // 2 // 取中間索引  \n    → Decision: nums[mid] < nums[mid+1]? // 判斷右邊是否更大  \n        Yes → Step 5: low = mid + 1 // 峰一定在右側，將搜尋範圍移到右半部  \n        No  → Step 6: high = mid // 峰在左側或是 mid，將搜尋範圍移到左半部  \n→ Step 7: return low // 迴圈結束時 low==high，該索引即為峰  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findPeakElement(self, nums):\n        \"\"\"\n        二分搜尋，時間複雜度 O(log n)\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[mid + 1]:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整行輸入，例如: \"nums = [1,2,3,1]\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 找出陣列字串並轉成 Python list\n    try:\n        start = raw_input.index('[')\n        end = raw_input.rindex(']')\n        nums_str = raw_input[start:end + 1]\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # 若解析失敗，則直接終止\n        sys.exit(0)\n\n    sol = Solution()\n    peak_index = sol.findPeakElement(nums)\n    print(peak_index)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,3,5,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode736.json",
    "problem_index_in_file": 0,
    "title": "Parse Lisp Expression",
    "description_snippet": "You are given a string expression representing a Lisp-like expression to return the integer value of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for evaluating a Lisp-like expression string. The user wants pseudocode that explains logic. We must output line by line: \"虛擬碼步驟 // 解釋\". Use arrows and structure. Should cover overall algorithm: parse string, evaluate recursively, manage scopes with stack or hashmap. Let's craft steps.\n\nStart, then parse expression, then decision: if starts with '(' then parse operator. Else if integer parse. Else variable lookup. For let: loop assignments. etc. Use stack of environments.\n\nWe need step by step. I'll produce something like:\n\nStart\n→ Step 1: Initialize global environment stack // 用堆疊維護作用域\n→ Step 2: Call Evaluate(expr, envStack) // 解析整個表達式\n→ Decision: expr starts with '('? // 判斷是否為複合表達式\n  Yes → Step 3: Tokenize contents inside parentheses // 拆解子表達式\n  → Decision: first token is 'add'? // 加法\n    Yes → Step 4: Evaluate first operand\n    → Step 5: Evaluate second operand\n    → Step 6: Return sum\n    No ...\n  etc.\n\nAlso need handling of let: create new scope push onto stack; assign variables sequentially; evaluate final expr; pop scope.\n\nAlso variable lookup: search from top of stack downwards.\n\nAlso integer: parse to int.\n\nAlso need to handle negative numbers.\n\nLet's output each step with brief explanation.\n\nLet's produce around 20-25 lines.\n\nUse arrows. Use 'Decision:' lines with indentation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Create envStack ← new stack of dictionaries // 用堆疊維護多層作用域\n→ Step 2: Push an empty dictionary onto envStack // 初始化最外層作用域\n→ Step 3: Call Evaluate(expression, envStack) // 開始遞迴評估整個輸入式子\n→ Decision: expression starts with '('? // 判斷是複合式還是簡單值\n    Yes → Step 4: Remove outermost parentheses and split by spaces // 去除括號並分割為 tokens\n    → Step 5: operator ← first token // 取得運算符\n    → Decision: operator = 'add'? // 加法表達式\n        Yes → Step 6: leftVal ← Evaluate(tokens[1], envStack) // 評估左子式\n        → Step 7: rightVal ← Evaluate(tokens[2], envStack) // 評估右子式\n        → Step 8: Return leftVal + rightVal // 回傳加總結果\n        No →\n    → Decision: operator = 'mult'? // 乘法表達式\n        Yes → Step 9: leftVal ← Evaluate(tokens[1], envStack)\n        → Step 10: rightVal ← Evaluate(tokens[2], envStack)\n        → Step 11: Return leftVal * rightVal // 回傳乘積結果\n        No →\n    → Decision: operator = 'let'? // let 表達式\n        Yes → Step 12: Push new dictionary onto envStack // 建立新作用域\n        → Step 13: i ← 1 // 設定索引指向第一個變數\n        → Decision: i < tokens.length - 1? // 有沒有變數-表達式對\n            Yes →\n                → Step 14: varName ← tokens[i] // 取得變數名稱\n                → Step 15: varVal ← Evaluate(tokens[i+1], envStack) // 評估對應表達式\n                → Step 16: envStack.top()[varName] ← varVal // 在最內層作用域存值\n                → Step 17: i ← i + 2 // 前往下一個變數-表達式對\n                → Repeat Step 13–17\n            No → // 所有變數-表達式對已處理\n        → Step 18: result ← Evaluate(tokens[tokens.length-1], envStack) // 評估 let 最後的 expr\n        → Step 19: Pop envStack.top() // 清除新作用域\n        → Step 20: Return result // 回傳 let 的最終值\n        No →\n    → Decision: operator is a variable name? // 變數使用\n        Yes → Step 21: Return LookupVar(operator, envStack) // 從最內層往外尋找值\n        No → // 其他情況不會發生（輸入合法）\n→ Decision: expression is a number? // 整數或負整數\n    Yes → Step 22: Return ParseInt(expression) // 直接回傳整數\n    No → // 變數已於上一層處理\n→ End // 程式執行結束\n\nFunction LookupVar(name, envStack) // 變數查找函式\n→ Step 23: For each scope in envStack from top to bottom\n    → Decision: name in scope?\n        Yes → Step 24: Return scope[name] // 找到即回傳\n        No → Continue\n→ Step 25: Throw error // 理論上不會發生，因輸入合法\n\nFunction ParseInt(str) // 將字串轉為整數\n→ Step 26: Return integer value of str // 包含負號支援\n\nEnd // 虛擬碼結束",
      "generated_code": "import sys\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        def eval_expr(expr: str, env: dict) -> int:\n            # If expr is a plain number or variable\n            if expr[0] != '(':\n                if expr[0].isalpha():\n                    return env[expr]\n                return int(expr)\n\n            # Remove outer parentheses and tokenize\n            inner = expr[1:-1]\n            tokens = []\n            balance = 0\n            start = 0\n            for i, ch in enumerate(inner):\n                if ch == '(':\n                    balance += 1\n                elif ch == ')':\n                    balance -= 1\n                elif ch == ' ' and balance == 0:\n                    tokens.append(inner[start:i])\n                    start = i + 1\n            tokens.append(inner[start:])  # last token\n\n            op = tokens[0]\n            if op == 'add':\n                return eval_expr(tokens[1], env) + eval_expr(tokens[2], env)\n            elif op == 'mult':\n                return eval_expr(tokens[1], env) * eval_expr(tokens[2], env)\n            elif op == 'let':\n                # Create a new environment for the let block\n                new_env = env.copy()\n                i = 1\n                # Process variable assignments\n                while i < len(tokens) - 1:\n                    var = tokens[i]\n                    val = eval_expr(tokens[i + 1], new_env)\n                    new_env[var] = val\n                    i += 2\n                # Evaluate the final expression in the let block\n                return eval_expr(tokens[-1], new_env)\n            else:\n                # Should not reach here for a legal input\n                raise ValueError(f\"Unknown operator: {op}\")\n\n        return eval_expr(expression, {})\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Handle possible \"expression = ...\" format\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # Remove surrounding quotes if present\n    if (expr.startswith('\"') and expr.endswith('\"')) or (expr.startswith(\"'\") and expr.endswith(\"'\")):\n        expr = expr[1:-1]\n\n    solver = Solution()\n    result = solver.evaluate(expr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "success": true,
          "output": "14"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode87.json",
    "problem_index_in_file": 0,
    "title": "Scramble String",
    "description_snippet": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the st...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm: check if s2 is a scramble of s1. This is typical LeetCode 87 Scramble String. We need to produce a step-by-step pseudo code with explanation per line.\n\nWe need to use Start, End, Decision, arrow.\n\nWe can implement recursion with memoization. Each step: check if strings equal, if same characters counts, then try splits and recursive.\n\nWe produce steps:\n\nStart\n→ Step 1: Function IsScramble(s1, s2)\n→ Decision: If s1 == s2? // base case if identical\n...\nBut we need to produce line by line. For clarity, produce pseudo code lines.\n\nWe can treat each function call as step. We may need loops over split positions.\n\nWe also need memoization dictionary: memo[(s1,s2)] = bool.\n\nLet's produce:\n\nStart\n→ Step 1: Define function IsScramble(s1, s2)\n→ Decision: If s1 == s2? // identical strings\n    Yes → Step 2: Return True\n    No  → Decision: If sorted(s1) != sorted(s2)? // quick prune by character counts\n        Yes → Step 3: Return False\n        No  → Step 4: If (s1, s2) in memo? // memo check\n            Yes → Step 5: Return memo[(s1,s2)]\n            No  → Step 6: For i in 1 to len(s1)-1 // try split positions\n                → Decision: If (IsScramble(s1[:i], s2[:i]) and IsScramble(s1[i:], s2[i:])) or (IsScramble(s1[:i], s2[-i:]) and IsScramble(s1[i:], s2[:-i]))? // check both possibilities\n                    Yes → Step 7: memo[(s1,s2)] = True; Return True\n                    No  → Step 8: Continue // try next i\n            → Step 9: memo[(s1,s2)] = False; Return False\nEnd\n\nBut we need to format each line with arrow, maybe nested decisions. We need to show structure. We'll produce like:\n\nStart // 程式開始\n→ Step 1: Define function IsScramble(s1, s2) // 入口函式\n    → Decision: s1 == s2? // 相等直接成功\n        Yes → Step 2: Return True // 完成\n        No  → Decision: sorted(s1) != sorted(s2)? // 字符統計不匹配直接失敗\n            Yes → Step 3: Return False\n            No  → Decision: (s1, s2) in memo? // memo 已計算\n                Yes → Step 4: Return memo[(s1,s2)]\n                No  → Step 5: For i from 1 to len(s1)-1 // 嘗試所有切分\n                    → Decision: IsScramble(s1[:i], s2[:i]) and IsScramble(s1[i:], s2[i:]) or IsScramble(s1[:i], s2[-i:]) and IsScramble(s1[i:], s2[:-i])? // 兩種排列方式\n                        Yes → Step 6: memo[(s1,s2)] = True; Return True\n                        No  → Step 7: Continue // 下一個 i\n                → Step 8: memo[(s1,s2)] = False; Return False\nEnd // 程式結束\n\nBut need each line with arrow and comment. For steps inside loops, we may indent but use arrow and indentation.\n\nBetter to produce each logical step as separate line with arrow, but for loops we can show decision within. We need to maintain proper indentation and arrows.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Define function IsScramble(s1, s2) // 入口函式\n    → Decision: s1 == s2? // 若兩字串相等即為合法\n        Yes → Step 2: Return True // 結束此呼叫\n        No  → Decision: sorted(s1) != sorted(s2)? // 先檢查字母頻次是否相同\n            Yes → Step 3: Return False // 不相同則不可能是 scramble\n            No  → Decision: (s1, s2) in memo? // 檢查是否已經計算過\n                Yes → Step 4: Return memo[(s1, s2)] // 直接回傳緩存結果\n                No  → Step 5: For i from 1 to len(s1)-1 // 嘗試所有切分位置\n                    → Decision: IsScramble(s1[:i], s2[:i]) and IsScramble(s1[i:], s2[i:]) or IsScramble(s1[:i], s2[-i:]) and IsScramble(s1[i:], s2[:-i])? // 兩種可能的排列方式\n                        Yes → Step 6: memo[(s1, s2)] = True; Return True // 找到合法切分，記錄並返回\n                        No  → Step 7: Continue // 嘗試下一個 i\n                → Step 8: memo[(s1, s2)] = False; Return False // 所有切分皆失敗\nEnd // 程式結束執行\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        memo = {}\n\n        def dfs(x: str, y: str) -> bool:\n            if (x, y) in memo:\n                return memo[(x, y)]\n            if x == y:\n                memo[(x, y)] = True\n                return True\n            if sorted(x) != sorted(y):\n                memo[(x, y)] = False\n                return False\n\n            n = len(x)\n            for i in range(1, n):\n                if dfs(x[:i], y[:i]) and dfs(x[i:], y[i:]):\n                    memo[(x, y)] = True\n                    return True\n                if dfs(x[:i], y[-i:]) and dfs(x[i:], y[:-i]):\n                    memo[(x, y)] = True\n                    return True\n\n            memo[(x, y)] = False\n            return False\n\n        return dfs(s1, s2)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 尋找所有被雙引號包圍的字串\n    strs = re.findall(r'\"([^\"]*)\"', data)\n    if len(strs) >= 2:\n        s1, s2 = strs[0], strs[1]\n    else:\n        # 若未找到雙引號，嘗試直接讀取兩個單字串\n        parts = data.split()\n        if len(parts) >= 2:\n            s1, s2 = parts[0], parts[1]\n        else:\n            s1 = s2 = \"\"\n\n    solution = Solution()\n    result = solution.isScramble(s1, s2)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"great\", s2 = \"rgeat\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"abcde\", s2 = \"caebd\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s1 = \"a\", s2 = \"a\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode34.json",
    "problem_index_in_file": 0,
    "title": "Find First and Last Position of Element in Sorted Array",
    "description_snippet": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending positio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search to find first and last occurrence. Each line with explanation. Use Start, End, Decision, arrow. Provide steps: Input array, target. Find first: left search. Find last: right search. Use while left <= right, compute mid, adjust left/right based on comparison. If found, record index, adjust search. Provide final result array. Also handle not found.\n\nWe need to output in Chinese. Provide virtual code lines.\n\nWe must not output actual code, just virtual steps. Use arrow \"→\". Use indentation for nested decision.\n\nWe need to maintain O(log n). So two binary searches. We can combine but separate.\n\nLet's produce:\n\nStart\n→ Step 1: 接收 nums, target // 輸入參數\n→ Step 2: 定義 left = 0, right = length(nums)-1 // 初始化指標\n→ Step 3: 定義 first = -1, last = -1 // 結果初始值\n→ Decision: if left > right? // 若數組為空\n    Yes → Step 4: 回傳 [first, last] // [-1,-1]\n    No  → Continue\n→ Step 5: // 找到第一個 target\n    → Step 5a: while left <= right\n        → Step 5a1: mid = (left + right) // 2\n        → Decision: nums[mid] == target?\n            Yes → Step 5a2: first = mid // 記錄位置\n                 → Step 5a3: right = mid - 1 // 繼續搜尋左側\n            No  → Decision: nums[mid] < target?\n                Yes → Step 5a4: left = mid + 1 // target 在右側\n                No  → Step 5a5: right = mid - 1 // target 在左側\n→ Step 6: // 重設 left, right 以搜尋最後一個 target\n    → Step 6a: left = 0; right = length(nums)-1\n→ Step 7: // 找到最後一個 target\n    → Step 7a: while left <= right\n        → Step 7a1: mid = (left + right) // 2\n        → Decision: nums[mid] == target?\n            Yes → Step 7a2: last = mid // 記錄位置\n                 → Step 7a3: left = mid + 1 // 繼續搜尋右側\n            No  → Decision: nums[mid] < target?\n                Yes → Step 7a4: left = mid + 1 // target 在右側\n                No  → Step 7a5: right = mid - 1 // target 在左側\n→ Step 8: // 返回結果\n    → Step 8a: 回傳 [first, last]\n\nEnsure each line has // explanation. Use arrow for nested decision. Use indentation like \"    Yes →\". For each step line after indentation should have arrow. Also maintain format: `虛擬碼步驟 // 解釋`. So we need to ensure each line is one step. For decisions, we need to include the decision and Yes/No branches lines. So each branch line is its own step with arrow. Let's produce lines accordingly.\n\nWe also need to include Start, End. At end add End. So add End after Step 8a? Actually Step 8a is returning. Then End. So:\n\nStart\n→ Step 1: ...\n...\n→ Step 8a: 回傳 [first, last]\nEnd\n\nWe need to ensure each line has the format. Let's craft.\n\nFor decision lines, format: `Decision: if left > right?` then indentation.\n\nUse arrow for decisions: `Decision: if ...?`. Then Yes → Step 4. etc.\n\nLet's produce.\n\nCheck each line:\n\nStart // 程式開始執行\n→ Step 1: 接收 nums, target // 輸入參數\n→ Step 2: 定義 left = 0, right = length(nums)-1 // 初始化左右指標\n→ Step 3: 定義 first = -1, last = -1 // 結果初始值\n→ Decision: if nums 為空? // 檢查數組是否為空\n    Yes → Step 4: 回傳 [first, last] // [-1,-1]\n    No  → // 進行搜尋\n→ Step 5: // 找到第一個 target\n    → Step 5a: while left <= right\n        → Step 5a1: mid = (left + right) // 2 // 取中點\n        → Decision: nums[mid] == target?\n            Yes → Step 5a2: first = mid // 記錄第一次出現\n                 → Step 5a3: right = mid - 1 // 仍搜尋左側\n            No  → Decision: nums[mid] < target?\n                Yes → Step 5a4: left = mid + 1 // target 在右側\n                No  → Step 5a5: right = mid - 1 // target 在左側\n→ Step 6: // 重設左右指標以搜尋最後一個 target\n    → Step 6a: left = 0; right = length(nums)-1\n→ Step 7: // 找到最後一個 target\n    → Step 7a: while left <= right\n        → Step 7a1: mid = (left + right) // 2\n        → Decision: nums[mid] == target?\n            Yes → Step 7a2: last = mid // 記錄最後一次出現\n                 → Step 7a3: left = mid + 1 // 仍搜尋右側\n            No  → Decision: nums[mid] < target?\n                Yes → Step 7a4: left = mid + 1 // target 在右側\n                No  → Step 7a5: right = mid - 1 // target 在左側\n→ Step 8: // 返回結果\n    → Step 8a: 回傳 [first, last]\nEnd // 程式執行結束\n\nWe need each line to start with \"→\" except Start and End. For lines inside decisions, we indent with 4 spaces then Yes → etc. The formatting shows lines after indentation may start with \"Yes →\" or \"No →\" plus Step line. Good.\n\nMake sure each line has comment after //. Provide explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收 nums, target // 輸入參數  \n→ Step 2: 定義 left = 0, right = length(nums)-1 // 初始化左右指標  \n→ Step 3: 定義 first = -1, last = -1 // 結果初始值  \n→ Decision: 如果 nums 為空? // 檢查數組是否為空  \n    Yes → Step 4: 回傳 [first, last] // [-1,-1]，結束搜尋  \n    No  → // 進行搜尋  \n→ Step 5: // 找到第一個 target  \n    → Step 5a: while left <= right // 進行二分搜尋  \n        → Step 5a1: mid = (left + right) // 2 // 取中點  \n        → Decision: nums[mid] == target? // 檢查是否找到目標  \n            Yes → Step 5a2: first = mid // 記錄第一次出現  \n                 → Step 5a3: right = mid - 1 // 繼續搜尋左側  \n            No  → Decision: nums[mid] < target? // 判斷目標位置  \n                Yes → Step 5a4: left = mid + 1 // target 在右側  \n                No  → Step 5a5: right = mid - 1 // target 在左側  \n→ Step 6: // 重設左右指標以搜尋最後一個 target  \n    → Step 6a: left = 0; right = length(nums)-1  \n→ Step 7: // 找到最後一個 target  \n    → Step 7a: while left <= right // 進行二分搜尋  \n        → Step 7a1: mid = (left + right) // 2  \n        → Decision: nums[mid] == target? // 檢查是否找到目標  \n            Yes → Step 7a2: last = mid // 記錄最後一次出現  \n                 → Step 7a3: left = mid + 1 // 繼續搜尋右側  \n            No  → Decision: nums[mid] < target? // 判斷目標位置  \n                Yes → Step 7a4: left = mid + 1 // target 在右側  \n                No  → Step 7a5: right = mid - 1 // target 在左側  \n→ Step 8: // 返回結果  \n    → Step 8a: 回傳 [first, last] // 結果陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def searchRange(self, nums, target):\n        \"\"\"Return the first and last positions of target in nums using binary search.\"\"\"\n        def findLeft(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        def findRight(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        return [findLeft(nums, target), findRight(nums, target)]\n\ndef parse_input(data):\n    \"\"\"Parse the input string to extract nums list and target integer.\"\"\"\n    # Find the list representation\n    nums_match = re.search(r'\\[.*?\\]', data)\n    nums = []\n    if nums_match:\n        nums_str = nums_match.group()\n        try:\n            nums = ast.literal_eval(nums_str)\n        except Exception:\n            nums = []\n    # Find the target value\n    target_match = re.search(r'target\\s*=\\s*([-\\d]+)', data)\n    target = 0\n    if target_match:\n        try:\n            target = int(target_match.group(1))\n        except Exception:\n            target = 0\n    return nums, target\n\ndef main():\n    # Read entire stdin content\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        return\n\n    nums, target = parse_input(data)\n    sol = Solution()\n    result = sol.searchRange(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,7,7,8,8,10], target = 8",
          "expected_output": "[3,4]",
          "success": true,
          "output": "[3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [5,7,7,8,8,10], target = 6",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        },
        {
          "example_index": 2,
          "input": "nums = [], target = 0",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode771.json",
    "problem_index_in_file": 0,
    "title": "Jewels and Stones",
    "description_snippet": "You're given strings jewels representing the types of stones that are jewels, and stones representin...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code in lines: Start, steps, decisions, etc. We must handle input: jewels string, stones string, count how many stones are jewels. Straight algorithm: iterate over stones, check if char in jewels set, increment count. Virtual code steps accordingly.\n\nWe should produce line-by-line. Use \"Start\", \"→ Step ...\", \"→ Decision ...\" etc. Provide short explanation after comment.\n\nWe need to not output actual code. So we output virtual steps, not actual code.\n\nLet's design steps:\n\nStart\n→ Input jewels string // 取得珠寶字串\n→ Input stones string // 取得石頭字串\n→ Step 1: 初始化 counter to 0 // 設定計數器\n→ Step 2: 將 jewels 字串轉成集合 // 建立快速查詢集合\n→ Decision: 遍歷每個字元 in stones? Actually a loop. Represent loop: maybe \"→ Step 3: For each stone in stones:\" with substeps.\nBut we need arrow representation. Let's do:\n\n→ Step 3: For each character c in stones:\n   → Decision: c 是否在 jewels 集合中?\n        Yes → Step 4: 增加 counter\n        No → Step 5: 跳過\n\nAfter loop:\n→ Step 6: 輸出 counter // 顯示結果\nEnd\n\nWe must ensure each line has comment after //.\n\nAlso we might include decision inside loop. We need to reflect that.\n\nWe must use \"Yes →\" \"No →\" for decisions. Use indentation for nested decisions? Format in example uses indentation.\n\nLet's produce accordingly.\n\nMake sure each line includes \"虛擬碼步驟\" plus space then comment.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: 讀取珠寶字串 jewels // 從輸入取得珠寶類型\n→ Step 2: 讀取石頭字串 stones // 從輸入取得所有石頭\n→ Step 3: 初始化計數器 count = 0 // 設置計算珠寶石頭數量\n→ Step 4: 建立珠寶集合 jewelSet = Set(jewels) // 方便查詢\n→ Step 5: 遍歷 stones 中每個字元 c\n    → Decision: c 是否存在於 jewelSet?\n        Yes → Step 6: count += 1 // 這顆石頭是珠寶，計數加一\n        No  → Step 7: 跳過 // 不是珠寶，繼續下一顆\n→ Step 8: 輸出 count // 顯示珠寶石頭總數\nEnd // 程式執行結束\n\nWe need to maintain line format: each line must start with \"虛擬碼步驟\". Eg \"Start\" or \"→ Step\". Then space then comment. Provide indentation? We can indent nested steps with spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取珠寶字串 jewels // 從輸入取得珠寶類型  \n→ Step 2: 讀取石頭字串 stones // 從輸入取得所有石頭  \n→ Step 3: 初始化計數器 count = 0 // 設置計算珠寶石頭數量  \n→ Step 4: 建立珠寶集合 jewelSet = Set(jewels) // 方便查詢  \n→ Step 5: 遍歷 stones 中每個字元 c  \n  → Decision: c 是否存在於 jewelSet? // 判斷這顆石頭是否為珠寶  \n   Yes → Step 6: count += 1 // 這顆石頭是珠寶，計數加一  \n   No  → Step 7: 跳過 // 不是珠寶，繼續下一顆  \n→ Step 8: 輸出 count // 顯示珠寶石頭總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numJewelsInStones(self, J: str, S: str) -> int:\n        jewels = set(J)\n        return sum(ch in jewels for ch in S)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 嘗試從雙引號中擷取字串\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        jewels, stones = parts[0], parts[1]\n    else:\n        # 退而求其次：以空白或換行分隔\n        tokens = data.split()\n        if len(tokens) >= 2:\n            jewels, stones = tokens[0], tokens[1]\n        else:\n            # 無法判定輸入格式，直接結束\n            return\n    sol = Solution()\n    result = sol.numJewelsInStones(jewels, stones)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "jewels = \"aA\", stones = \"aAAbbbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "jewels = \"z\", stones = \"ZZ\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode594.json",
    "problem_index_in_file": 0,
    "title": "Longest Harmonious Subsequence",
    "description_snippet": "We define a harmonious array as an array where the difference between its maximum value and its mini...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: find length of longest harmonious subsequence (difference max-min=1). We should outline algorithm: use hash map frequency counts; iterate over keys; if key+1 exists, candidate length = freq[key]+freq[key+1]; keep max. Output max length.\n\nWe must output step by step with arrows etc.\n\nLet's craft steps: Start, Step 1: Build frequency map; Step 2: Initialize maxLen=0; Step 3: For each num in map: if num+1 in map, candidate = freq[num]+freq[num+1]; update maxLen. Step 4: return maxLen. End.\n\nMake sure each line: virtual code step + // explanation. Use arrows. Use Decision maybe but not necessary. Provide Step 3 with Decision: if num+1 exists? Yes → compute candidate, update; No → continue.\n\nAlso maybe early return if array empty: Decision: if nums empty? Yes → Step 4: return 0; No → continue.\n\nLet's write accordingly. Ensure each line has virtual code + explanation. Use Start, End. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 如果 nums 為空? // 檢查輸入是否為空陣列\n    Yes → Step 1: 回傳 0 // 空陣列沒有子序列，直接回傳長度 0\n    No  → Step 2: 建立頻率映射 freq // 用哈希表統計每個數字出現的次數\n→ Step 3: 初始化 maxLen 為 0 // 用來追蹤目前找到的最長和諧子序列長度\n→ Step 4: 對於每個 key 在 freq 中執行\n    → Decision: 如果 key + 1 存在於 freq? // 檢查是否存在相差 1 的數字\n        Yes → Step 5: 計算 candidate = freq[key] + freq[key + 1] // 兩個相鄰數字的總頻次即為和諧子序列長度\n        → Step 6: 更新 maxLen 為 max(maxLen, candidate) // 保持目前最大的長度\n        No  → Step 7: 跳過此 key // 若沒有相鄰數字，無法形成和諧子序列\n→ Step 8: 回傳 maxLen // 所有鍵遍歷完畢後回傳最大的長度\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findLHS(self, nums):\n        \"\"\"\n        計算最長和諧子序列長度。\n        思路：使用頻率表，對於每個元素 x，若 x+1 存在，則候選長度為\n        freq[x] + freq[x+1]。最後返回最大的長度。\n        \"\"\"\n        if not nums:\n            return 0\n        freq = Counter(nums)\n        max_len = 0\n        for num in freq:\n            if num + 1 in freq:\n                max_len = max(max_len, freq[num] + freq[num + 1])\n        return max_len\n\ndef parse_input(input_str: str):\n    \"\"\"\n    解析形如 'nums = [1, 2, 3]' 的輸入，返回對應的列表。\n    \"\"\"\n    # 找到第一個 '[' 與最後一個 ']' 的位置\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # 如果找不到有效的列表，返回空列表\n        return []\n    list_str = input_str[start:end+1]\n    # 使用 ast.literal_eval 安全解析列表字面量\n    try:\n        return ast.literal_eval(list_str)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findLHS(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,2,5,2,3,7]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1.json",
    "problem_index_in_file": 0,
    "title": "Two Sum",
    "description_snippet": "Given an array of integers nums and an integer target, return indices of the two numbers such that t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the two sum problem. The virtual code should be line by line with arrow symbols etc. Use Start, Decision etc. Also cannot output real code. So we must produce algorithm steps: iterate, use hash map, etc.\n\nLet's produce:\n\nStart\n→ Step 1: 建立空的哈希表 `hashMap` // 用於儲存數值與其索引\n→ Step 2: 循環遍歷陣列 `nums`，索引為 `i` // 對每個元素進行處理\n→ Decision: 若 `target - nums[i]` 已存在於 `hashMap`? // 檢查是否找到對應的數\n    Yes → Step 3: 取得 `hashMap[target - nums[i]]` 為 `j` // 對應索引\n        → Step 4: 輸出 `[j, i]` // 返回兩個索引\n        → End // 結束\n    No  → Step 5: 將 `nums[i]` 與 `i` 存入 `hashMap` // 儲存供未來查找\n→ End // 若循環結束仍未返回，表示無解（理論上不可能） \n\nNeed to keep formatting exactly: each line \"→ Step ...\" with // explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的哈希表 `hashMap` // 用於儲存數值與其索引  \n→ Step 2: 循環遍歷陣列 `nums`，索引為 `i` // 對每個元素進行處理  \n→ Decision: 若 `target - nums[i]` 已存在於 `hashMap`? // 檢查是否找到對應的數  \n Yes → Step 3: 取得 `hashMap[target - nums[i]]` 為 `j` // 對應索引  \n  → Step 4: 輸出 `[j, i]` // 返回兩個索引  \n  → End // 程式結束  \n No → Step 5: 將 `nums[i]` 與 `i` 存入 `hashMap` // 儲存供未來查找  \nEnd // 若循環結束仍未返回，表示無解（理論上不可能）",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef two_sum(nums, target):\n    \"\"\"找出兩個數字的索引，使它們相加等於 target。\"\"\"\n    lookup = {}\n    for i, val in enumerate(nums):\n        comp = target - val\n        if comp in lookup:\n            return [lookup[comp], i]\n        lookup[val] = i\n    return []  # 理論上不會執行到這裡\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入字串，例如: 'nums = [2,7,11,15], target = 9'\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        return\n\n    nums = ast.literal_eval(nums_match.group(1))\n    target = int(target_match.group(1))\n\n    result = two_sum(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode354.json",
    "problem_index_in_file": 0,
    "title": "Russian Doll Envelopes",
    "description_snippet": "You are given a 2D array of integers envelopes where envelopes[i] = [w_i, h_i] represents the width ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code, step by step. No actual code, just structure.\n\nUser requirement: typical Russian Doll Envelopes problem. We need to produce algorithm: sort by width asc, height desc to avoid equal widths. Then LIS on heights. Provide steps. Also need to handle LIS.\n\nWe need to output lines like:\n\nStart // ...\n→ Step 1: Sort envelopes by width ascending and height descending //...\n→ Step 2: Initialize an empty list tails //...\n→ Step 3: For each envelope in sorted list: get height //...\n→ Decision: Does height > last element in tails? //...\n    Yes → Append height //...\n    No → Find position to replace using binary search //...\n→ End // ...\n\nAlso need explanation comments.\n\nMake sure each line has virtual code step plus comment.\n\nWe must not output actual code. Just the structure. So no variable names like envelopes, tails? We can still use variable names; it's virtual code.\n\nWe need to output step lines. Could have substeps inside Decision. Use indentation.\n\nLet's produce a comprehensive pseudocode.\n\nAlso we need to incorporate binary search step. We'll describe it.\n\nLet's write:\n\nStart // Start of algorithm\n→ Step 1: Sort envelopes by ascending width and descending height // To ensure no duplicate widths in LIS\n→ Step 2: Create empty list tails // tails[i] will be the smallest possible tail of an increasing subsequence of length i+1\n→ Step 3: For each envelope in sorted envelopes // Iterate through sorted envelopes\n    → Step 3a: Let h = envelope.height // extract height\n    → Decision: Is h greater than the last element in tails? // check if it can extend the longest subsequence\n        Yes → Step 3b: Append h to tails // extend sequence\n        No  → Step 3c: Find the index idx in tails where tails[idx] >= h using binary search // replace to maintain minimal tail\n            → Step 3d: Set tails[idx] = h // update tail value\n→ End // Result is length of tails\n\nMake sure each line has the format: \"虛擬碼步驟 // 解釋\". Use indentation maybe with spaces. Each line should be separate. Use arrow symbol and Decision block with indentation. Each Decision branch line must be separate lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort envelopes by ascending width and descending height // 先將包覆按寬度升序、相同寬度時高度降序排列，避免相同寬度被錯誤計算\n→ Step 2: Create empty list tails // tails 用來存放各長度遞增子序列的最小尾端高度\n→ Step 3: For each envelope in sorted envelopes // 逐一處理已排序的包覆\n    → Step 3a: Let h = envelope.height // 取得目前包覆的高度\n    → Decision: Is h greater than the last element in tails? // 判斷是否能延長目前最長的遞增子序列\n        Yes → Step 3b: Append h to tails // 若能延長，直接將高度加入尾端\n        No  → Step 3c: Find the index idx in tails where tails[idx] >= h using binary search // 若不能延長，找到第一個大於或等於 h 的位置以更新尾端\n            → Step 3d: Set tails[idx] = h // 用較小的高度替換，維持子序列最小尾端\n→ End // 程式執行結束，tails 的長度即為可裝進的最大包覆數量",
      "generated_code": "import sys\nimport ast\nimport bisect\n\ndef max_envelopes(envelopes):\n    if not envelopes:\n        return 0\n    # 先按寬度升序，寬度相同時按高度降序\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []\n    for _, h in envelopes:\n        idx = bisect.bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n    return len(dp)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 只取等號右側的數組\n    if '=' in data:\n        parts = data.split('=', 1)\n        arr_str = parts[1].strip()\n    else:\n        arr_str = data\n    try:\n        envelopes = ast.literal_eval(arr_str)\n    except Exception:\n        envelopes = []\n    result = max_envelopes(envelopes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "envelopes = [[5,4],[6,4],[6,7],[2,3]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "envelopes = [[1,1],[1,1],[1,1]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode746.json",
    "problem_index_in_file": 0,
    "title": "Min Cost Climbing Stairs",
    "description_snippet": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for dynamic programming: min cost to climb to top. Classic Leetcode 746. We need to produce step-by-step pseudocode lines with explanation. Must be in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision, Start, End. Provide each line.\n\nLet's produce steps: Start, Determine n, set dp array size n+1, dp[0]=0, dp[1]=0. For i from 2 to n: dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]). Return dp[n]. Or we can avoid dp array: two variables. But pseudocode with array is fine.\n\nLet's produce lines: Start, Determine n = length of cost, Initialize dp array size n+1 with zeros, Set dp[0] = 0, dp[1] = 0, For i=2 to n: compute cost1 = dp[i-1] + cost[i-1]; cost2 = dp[i-2] + cost[i-2]; dp[i] = min(cost1, cost2); End For, Return dp[n], End.\n\nNeed Decision? Might include decision inside loop: decide min. But maybe not necessary. But we can show Decision: If cost1 < cost2? Then dp[i] = cost1 else cost2.\n\nOk. Provide lines.\n\nLet's craft each line with explanation.\n\nAlso maybe we should add comment about starting at 0 or 1 step. Represent that we consider top as step n. Starting from step 0 or 1 means we can consider dp[0] and dp[1] as zero cost (since we don't pay to stand there). Then the dp recurrence uses cost array indices.\n\nOk produce lines:\n\nStart // 程式開始執行\n→ Step 1: n ← length(cost) // 取得台階總數\n→ Step 2: dp ← array[0…n] // 建立 dp 陣列，dp[i] 為走到第 i 步所需最低費用\n→ Step 3: dp[0] ← 0 // 從第 0 步開始，無需支付費用\n→ Step 4: dp[1] ← 0 // 從第 1 步開始，亦無需支付費用\n→ For i ← 2 to n: // 依次計算到頂樓的最小費用\n    → Decision: If dp[i-1] + cost[i-1] < dp[i-2] + cost[i-2] ?\n        Yes → dp[i] ← dp[i-1] + cost[i-1] // 走一步的費用較低\n        No  → dp[i] ← dp[i-2] + cost[i-2] // 走兩步的費用較低\n→ Step 5: result ← dp[n] // dp[n] 即為抵達頂樓的最小費用\n→ Step 6: return result // 回傳答案\nEnd // 程式執行結束\n\nBut maybe we need to use arrows properly: For i loop arrow. The format: \"→ For i ← 2 to n:\" then indent lines.\n\nWe must produce each line as a separate line. Let's produce with indentation. Provide each line exactly. Use Traditional Chinese. Ensure each line ends with explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(cost) // 取得台階總數  \n→ Step 2: dp ← array[0…n] // 建立 dp 陣列，dp[i] 為走到第 i 步所需最低費用  \n→ Step 3: dp[0] ← 0 // 從第 0 步開始，無需支付費用  \n→ Step 4: dp[1] ← 0 // 從第 1 步開始，亦無需支付費用  \n→ For i ← 2 to n: // 依次計算到頂樓的最小費用  \n  → Decision: If dp[i-1] + cost[i-1] < dp[i-2] + cost[i-2] ? // 比較走一步與走兩步的費用  \n    Yes → dp[i] ← dp[i-1] + cost[i-1] // 走一步的費用較低  \n    No  → dp[i] ← dp[i-2] + cost[i-2] // 走兩步的費用較低  \n→ Step 5: result ← dp[n] // dp[n] 即為抵達頂樓的最小費用  \n→ Step 6: return result // 回傳答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef min_cost(cost):\n    n = len(cost)\n    if n == 0:\n        return 0\n    if n == 1:\n        return cost[0]\n    dp0, dp1 = cost[0], cost[1]\n    for i in range(2, n):\n        dp_i = cost[i] + min(dp0, dp1)\n        dp0, dp1 = dp1, dp_i\n    return min(dp0, dp1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        cost = ast.literal_eval(data)\n        print(min_cost(cost))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[10,15,20]",
          "expected_output": "15",
          "success": true,
          "output": "15"
        },
        {
          "example_index": 1,
          "input": "[1,100,1,1,1,100,1,1,100,1]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode630.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule III",
    "description_snippet": "There are n different online courses numbered from 1 to n. You are given an array courses where cour...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving \"Maximum number of courses you can take\" problem. We need to generate steps, not actual code. Should be structured like Start, steps, decisions, End. Provide each line: virtual code step + \" // 解釋\". We should think about algorithm: typical greedy with priority queue: sort courses by lastDay, iterate, maintain max heap of durations, add duration, if sum > lastDay, pop largest duration. Count of heap size gives answer.\n\nWe need to express steps in pseudocode with arrows and decisions. So lines like:\n\nStart // 程式開始執行\n→ Step 1: Sort courses by lastDay ascending // ...\n\n→ Step 2: Initialize max-heap H, currentTime = 0 // ...\n\n→ Step 3: For each course in sorted list: // ...\n\n→ Decision: Add course.duration to currentTime // ...\n\n... Actually we need decision if currentTime > course.lastDay: pop largest.\n\nThus produce lines accordingly. Should also have step for result.\n\nWe must use 虛擬碼步驟 + \" // 解釋\" each line. Use arrows. Let's produce about 20-25 lines.\n\nWe need to keep each line as \"Step X:\" or \"Decision:\". Use \"Yes →\", \"No →\" branches.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort courses array by lastDay ascending // 先依截止日排序\n→ Step 2: Create empty max-heap H // 用來存已選課程的時長\n→ Step 3: Set currentTime = 0 // 目前已經使用的天數\n→ Step 4: For each course in sorted courses: // 逐一考慮課程\n    → Decision: Can we add this course without exceeding its lastDay? // 判斷是否可加入\n        Yes → Step 5: Push course.duration into H // 把時長放進堆\n            → Step 6: currentTime += course.duration // 更新已使用天數\n            → Decision: currentTime > course.lastDay? // 檢查是否超時\n                Yes → Step 7: Remove max duration from H // 把最長課程刪除\n                    → Step 8: currentTime -= removedDuration // 調整時間\n                No  → Step 9: // 留下已加入的課程\n        No  → Step 10: // 直接跳過這門課程\n→ Step 11: Return size of H // 堆中的課程數即為最大可修課程數\nEnd // 程式執行結束\n\nBut we need arrow lines, so each line uses \"→\" at start. But inside branches, we might indent. The example uses indentation but still \"→\". We'll replicate. Each line must start with \"→\" (unless Start/End). Indentation with spaces. We'll include indent for branches maybe two spaces.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort courses by lastDay ascending // 先依截止日排序\n→ Step 2: Create empty max‑heap H // 用來存已選課程的時長\n→ Step 3: Set currentTime = 0 // 目前已經使用的天數\n→ Step 4: For each course in sorted courses: // 逐一考慮課程\n  → Decision: currentTime + course.duration ≤ course.lastDay? // 判斷加入後是否不超過截止日\n    Yes → Step 5: Push course.duration into H // 把時長放進堆\n        → Step 6: currentTime += course.duration // 更新已使用天數\n        → Decision: currentTime > course.lastDay? // 檢查是否超時\n          Yes → Step 7: removed = PopMax(H) // 移除最長時長的課程\n              → Step 8: currentTime -= removed // 調整時間\n          No  → // 留下已加入的課程\n    No  → Step 9: // 跳過此課程，保持原狀\n→ Step 10: Return size of H // 堆中課程數即為最大可修課程數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def scheduleCourse(self, courses):\n        # 依照結束日升序排序\n        courses.sort(key=lambda x: x[1])\n        total_time = 0\n        max_heap = []  # 儲存已選課程的時長，使用負值作為最大堆\n\n        for duration, last_day in courses:\n            if total_time + duration <= last_day:\n                # 可以直接加入此課程\n                heapq.heappush(max_heap, -duration)\n                total_time += duration\n            elif max_heap and -max_heap[0] > duration:\n                # 若已選課程中最長的時長超過此課程時長，則換掉\n                total_time += duration + heapq.heappop(max_heap)\n                heapq.heappush(max_heap, -duration)\n\n        return len(max_heap)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    # 解析輸入，期望形如 'courses = [[1,2],[3,4]]'\n    if raw_input.startswith(\"courses\"):\n        _, courses_str = raw_input.split(\"=\", 1)\n        courses_str = courses_str.strip()\n        courses = eval(courses_str)  # 直接 eval 解析列表\n    else:\n        # 若輸入格式不同，直接嘗試 eval\n        courses = eval(raw_input)\n\n    sol = Solution()\n    result = sol.scheduleCourse(courses)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "courses = [[1,2]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "courses = [[3,2],[4,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode233.json",
    "problem_index_in_file": 0,
    "title": "Number of Digit One",
    "description_snippet": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: counting number of digit '1' in all numbers from 0 to n inclusive. Classic problem: count number of ones in numbers up to n. We produce step-by-step algorithm: input n, if n<0 return 0. Initialize count=0, factor=1. While factor <= n: lower = n - (n // factor) * factor; current = (n // factor) % 10; higher = n // (factor*10). Then use cases: if current == 0: count += higher * factor. If current ==1: count += higher * factor + lower +1. Else: count += (higher+1)*factor. factor *=10. After loop output count.\n\nWe produce virtual code lines accordingly.\n\nWe need to output step-by-step in virtual code, each line with comment. Use Start, End, Decision. Use arrow. Let's produce:\n\nStart // 程式開始\n→ Step 1: 輸入整數 n // 從使用者取得輸入\n→ Decision: n < 0? // 檢查是否為負數\n    Yes → Step 2: 輸出 0 // 負數時返回 0\n    No → Step 3: 初始化 count = 0 // 記錄 1 的個數\n    No → Step 4: 初始化 factor = 1 // 進位係數\n    No → Step 5: 開始 while factor <= n // 循環處理每位數\n        → Decision: factor <= n? // 判斷是否還有更高位\n            Yes → Step 6: lower = n - (n // factor) * factor // 低位數\n            Yes → Step 7: current = (n // factor) % 10 // 本位數\n            Yes → Step 8: higher = n // (factor * 10) // 高位數\n            Yes → Decision: current == 0? // 判斷本位數\n                Yes → Step 9: count += higher * factor // 0 時加 higher*factor\n                No → Decision: current == 1? // 判斷本位數為 1\n                    Yes → Step 10: count += higher * factor + lower + 1 // 1 時加 higher*factor + lower +1\n                    No → Step 11: count += (higher + 1) * factor // 大於 1 時加 (higher+1)*factor\n            Yes → Step 12: factor *= 10 // 移到下一位\n            Yes → Go back to Step 5\n        No → Step 13: 輸出 count // 完成計算輸出結果\nEnd // 程式結束\n\nMake sure each line has `虛擬碼步驟 // 解釋`. Use arrows and decisions properly. Provide as per requirement.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者取得輸入  \n→ Decision: n < 0? // 檢查是否為負數  \n Yes → Step 2: 輸出 0 // 負數時直接返回 0  \n No  → Step 3: 初始化 count = 0 // 記錄 1 的個數  \n No  → Step 4: 初始化 factor = 1 // 進位係數，從最低位開始  \n→ Step 5: 開始 while factor <= n // 處理每一位數  \n → Decision: factor <= n? // 判斷是否還有更高位需要處理  \n  Yes → Step 6: lower = n - (n // factor) * factor // 低位部分  \n  Yes → Step 7: current = (n // factor) % 10 // 本位數字  \n  Yes → Step 8: higher = n // (factor * 10) // 高位部分  \n  Yes → Decision: current == 0? // 本位數字是否為 0  \n   Yes → Step 9: count += higher * factor // 0 時加 higher*factor  \n   No  → Decision: current == 1? // 本位數字是否為 1  \n    Yes → Step 10: count += higher * factor + lower + 1 // 1 時加 higher*factor + lower + 1  \n    No  → Step 11: count += (higher + 1) * factor // 大於 1 時加 (higher+1)*factor  \n  Yes → Step 12: factor *= 10 // 移至下一位  \n  Go back to Step 5  \n No  → Step 13: 輸出 count // 所有位數處理完畢，輸出結果  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\ndef count_digit_one(n: int) -> int:\n    \"\"\"\n    Count how many times digit '1' appears in all numbers from 0 to n inclusive.\n    \"\"\"\n    if n <= 0:\n        return 0\n\n    count = 0\n    factor = 1  # 1, 10, 100, ...\n    while factor <= n:\n        lower = n - (n // factor) * factor        # digits to the right of current position\n        current = (n // factor) % 10              # digit at current position\n        higher = n // (factor * 10)               # digits to the left of current position\n\n        if current == 0:\n            count += higher * factor\n        elif current == 1:\n            count += higher * factor + lower + 1\n        else:\n            count += (higher + 1) * factor\n\n        factor *= 10\n\n    return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if match:\n        n = int(match.group())\n    else:\n        n = 0\n    result = count_digit_one(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode299.json",
    "problem_index_in_file": 0,
    "title": "Bulls and Cows",
    "description_snippet": "You are playing the Bulls and Cows game with your friend.\n\nYou write down a secret number and ask yo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Must include Start, End, Decision, etc. Need to implement Bulls and Cows logic. Steps: Start, initialize count bulls, cows, arrays for freq, iterate through secret and guess indices: if same digit => bulls, else record frequencies. Then compute cows by min counts. Or sum of min for each digit. Provide virtual code. Provide short explanation. Use arrows. Use Yes/No. Provide decision maybe for each comparison? Could structure: for i in range(len): Decision: secret[i] == guess[i]? Yes -> bull++ else record counts. Then after loop: for digit in 0-9: cows += min(secret_counts[d], guess_counts[d]). End. Provide. Ensure line per step. Include arrows. Use Decision: and Yes / No.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 `bulls = 0`, `cows = 0` // 用來計算牛和母牛的數量  \n→ Step 2: 建立兩個長度為 10 的整數陣列 `secretCount[10] = {0}`, `guessCount[10] = {0}` // 用來統計非牛數字的頻率  \n→ Step 3: 取長度 `n = secret.length` // 兩個字串長度相同  \n→ Step 4: For i 從 0 到 n-1  \n  → Decision: secret[i] == guess[i]? // 判斷是否為牛  \n    Yes → Step 5: `bulls++` // 同位數字為牛  \n    No  → Step 6: `secretCount[secret[i]-'0']++` // 統計秘密數字的頻率  \n      → Step 7: `guessCount[guess[i]-'0']++` // 統計猜測數字的頻率  \n→ Step 8: For d 從 0 到 9  \n  → Step 9: `cows += min(secretCount[d], guessCount[d])` // 對每個數字取較小頻率即母牛數量  \n→ Step 10: `hint = bulls + \"A\" + cows + \"B\"` // 組成提示字串  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef get_hint(secret: str, guess: str) -> str:\n    \"\"\"計算牛（bull）和母牛（cow）的數量並回傳提示字串。\"\"\"\n    bulls = 0\n    # 用 Counter 記錄非牛的數字頻率\n    secret_count = Counter()\n    guess_count = Counter()\n\n    # 同時遍歷兩個字串\n    for s, g in zip(secret, guess):\n        if s == g:\n            bulls += 1                 # 同位數字為牛\n        else:\n            secret_count[s] += 1       # 不是牛，統計頻率\n            guess_count[g] += 1\n\n    # 計算母牛：對每個數字取兩個頻率中較小的值\n    cows = sum(min(secret_count[d], guess_count.get(d, 0))\n               for d in secret_count)\n\n    return f\"{bulls}A{cows}B\"\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，支援以下兩種格式：\n    1. 例如: 'secret = \"1807\", guess = \"7810\"'\n    2. 兩行分別為 secret 和 guess\n    \"\"\"\n    # 先嘗試抓取引號中的內容\n    matches = re.findall(r'\"(.*?)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n\n    # 若沒有引號，嘗試分行\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n\n    # 最後，嘗試以空白分隔\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # 失敗回傳空字串\n    return \"\", \"\"\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    secret, guess = parse_input(raw_input)\n    if secret == \"\" or guess == \"\":\n        # 無法解析輸入\n        return\n    hint = get_hint(secret, guess)\n    print(hint)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "success": true,
          "output": "1A3B"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "success": true,
          "output": "1A1B"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode486.json",
    "problem_index_in_file": 0,
    "title": "Predict the Winner",
    "description_snippet": "You are given an integer array nums. Two players are playing a game with this array: player 1 and pl...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode line by line, using arrows etc. The problem: given integer array nums, two players take turns, each picks from either end, add to score. They play optimally. Determine if player1 can win or tie. This is a classic DP problem: compute maximum score difference or something. We need to output pseudocode for solving this. Should be line by line with explanation after each line.\n\nWe can design algorithm: DP[i][j] = max score difference current player can achieve over opponent from subarray i..j. Then at start DP[0][n-1] >= 0 means player1 can win. Recurrence: DP[i][j] = max(nums[i] - DP[i+1][j], nums[j] - DP[i][j-1]). Base: DP[i][i] = nums[i]. After computing, if DP[0][n-1] >= 0 then true else false.\n\nWe can also use recursion with memoization. But pseudocode: Steps: Start, read nums length n, create DP table n x n, loop i from 0 to n-1 set DP[i][i] = nums[i], then for len 2 to n loop i start, j = i+len-1, compute DP[i][j] = max(nums[i]-DP[i+1][j], nums[j]-DP[i][j-1]), after loops check DP[0][n-1] >= 0. Output true/false.\n\nWe need to follow format: Each line: \"虛擬碼步驟 // 解釋\".\n\nAlso need arrows: \"→ Step: ...\". Use \"Start\", \"End\", \"Decision:\".\n\nLet's construct:\n\nStart // 開始程式\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Decision: 如果 n = 0? // 檢查陣列是否為空\n    Yes → Step 2: Return true // 空陣列視為平手，玩家1勝\n    No  → Step 3: Initialize DP[n][n] // 建立 n x n 表格以儲存子問題解\n→ Step 4: for i from 0 to n-1 do DP[i][i] ← nums[i] // 單一元素時差值即為該值\n→ Step 5: for len from 2 to n do // 逐段長度填表\n        → Step 6: for i from 0 to n-len do\n            → Step 7: j ← i + len - 1 // 子陣列結束指標\n            → Step 8: takeLeft ← nums[i] - DP[i+1][j] // 選左邊的得分差\n            → Step 9: takeRight ← nums[j] - DP[i][j-1] // 選右邊的得分差\n            → Step 10: DP[i][j] ← max(takeLeft, takeRight) // 取能讓目前玩家最大化差值的選擇\n→ Step 11: if DP[0][n-1] ≥ 0 then Return true else Return false // 判斷玩家1能否勝利或平手\nEnd // 程式結束\n\nWe need to maintain the format: Each line must have \"虛擬碼步驟 // 解釋\". For decisions we need \"Decision:\" etc.\n\nBut we also have nested loops, indentations maybe. In sample, they used indentation with spaces after Decision: block.\n\nLet's produce with same style:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Decision: 如果 n = 0? // 檢查陣列是否為空\n    Yes → Step 2: Return true // 空陣列視為平手，玩家1勝\n    No  → Step 3: Initialize DP[n][n] // 建立 n x n 表格以儲存子問題解\n→ Step 4: for i from 0 to n-1 do // 初始化單元素子陣列的差值\n    → Step 5: DP[i][i] ← nums[i] // 差值即為該元素\n→ Step 6: for len from 2 to n do // 從長度 2 開始填表\n    → Step 7: for i from 0 to n - len do // 子陣列起點\n        → Step 8: j ← i + len - 1 // 子陣列結束指標\n        → Step 9: takeLeft ← nums[i] - DP[i+1][j] // 若選左端，得分差\n        → Step 10: takeRight ← nums[j] - DP[i][j-1] // 若選右端，得分差\n        → Step 11: DP[i][j] ← max(takeLeft, takeRight) // 取使差值最大的選擇\n→ Step 12: if DP[0][n-1] ≥ 0 then // 判斷玩家1是否能贏或平手\n    → Step 13: Return true // 玩家1勝或平手\n    → Step 14: Return false // 玩家1輸\nEnd // 程式執行結束\n\nNeed to ensure we use \"Decision:\" only where appropriate. We used one Decision. The others are steps.\n\nAlso use \"→\" arrow at beginning of each line.\n\nDouble-check formatting: sample uses \"Start\" then arrow lines. They used \"Decision:\" line with indent block for Yes/No. For if statements, they use indentation.\n\nOur lines: \"Step 4: for i from 0 to n-1 do // 初始化單元素子陣列的差值\" then indentation for body. But maybe we should separate body steps.\n\nLet's match sample style: For loops, they used:\n\n→ Step 1: 輸入使用者數字 // ...\n→ Decision: ... \n    Yes → Step 2: ...\n    No  → Decision: ...\n        Yes → Step 3: ...\n        No  → Step 4: ...\n\nThey used indent for nested Decision block. For loops, we might just put steps and then indent for inner steps. They didn't show loops but we can replicate: use arrow for loop line and inner steps indented with a space. For example:\n\n→ Step 4: for i from 0 to n-1 do // 初始化單元素子陣列的差值\n    → Step 5: DP[i][i] ← nums[i] // 差值即為該元素\n\nSo indent inner steps with 4 spaces? The sample uses 4 spaces? In sample, they indent 4 spaces before \"Yes → Step 2:\" and \"No  → Decision:\" etc. We can use 4 spaces indent for inner steps.\n\nLet's adopt 4 spaces indentation for inner steps.\n\nAlso need to include \"Decision:\" for if statement at Step 12.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: 如果 n = 0? // 檢查陣列是否為空  \n Yes → Step 2: Return true // 空陣列視為平手，玩家1勝  \n No  → Step 3: Initialize DP[n][n] // 建立 n x n 表格以儲存子問題解  \n→ Step 4: for i from 0 to n-1 do // 初始化單元素子陣列的差值  \n → Step 5: DP[i][i] ← nums[i] // 差值即為該元素  \n→ Step 6: for len from 2 to n do // 從長度 2 開始填表  \n → Step 7: for i from 0 to n - len do // 子陣列起點  \n  → Step 8: j ← i + len - 1 // 子陣列結束指標  \n  → Step 9: takeLeft ← nums[i] - DP[i+1][j] // 若選左端，得分差  \n  → Step 10: takeRight ← nums[j] - DP[i][j-1] // 若選右端，得分差  \n  → Step 11: DP[i][j] ← max(takeLeft, takeRight) // 取使差值最大的選擇  \n→ Step 12: if DP[0][n-1] ≥ 0 then // 判斷玩家1是否能贏或平手  \n → Step 13: Return true // 玩家1勝或平手  \n → Step 14: Return false // 玩家1輸  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def predictTheWinner(self, nums):\n        n = len(nums)\n        if n == 0:\n            return True\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n        return dp[0][n - 1] >= 0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n        arr_str = arr_str.strip()\n    else:\n        arr_str = data.strip()\n    nums = ast.literal_eval(arr_str)\n    solution = Solution()\n    result = solution.predictTheWinner(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,233,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode338.json",
    "problem_index_in_file": 0,
    "title": "Counting Bits",
    "description_snippet": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code step by step. It's counting bits. We will design algorithm maybe DP: ans[0]=0; for i 1..n: ans[i] = ans[i>>1]+(i&1). We'll produce pseudocode with Start, End, Step, Decision. Also need explanation each line.\n\nLet's produce lines:\n\nStart\n→ Step 1: 初始化 ans 為長度 n+1 的陣列 // 建立結果陣列\n→ Step 2: 設定 ans[0] = 0 // 0 的位元數為 0\n→ Decision: i 變數是否已經達到 n? // 判斷是否完成所有 i\n    No  → Step 3: i = 1 // 設定起始 i\n    Yes → End // 完成\n→ Step 4: while i <= n: // 迭代 1 到 n\n    → Step 5: ans[i] = ans[i >> 1] + (i & 1) // 右移一位加上最低位\n    → Step 6: i = i + 1 // 移動到下一個數\n    → Decision: i <= n? // 判斷是否還有數\n        Yes → 回到 Step 5\n        No  → End\nEnd\n\nBut maybe better to incorporate decision in while loop. Use structured pseudocode.\n\nLet's output with each line with explanation after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 ans 為長度 n+1 的陣列 // 建立結果陣列  \n→ Step 2: 設定 ans[0] = 0 // 0 的位元數為 0  \n→ Decision: i 變數是否已經達到 n? // 判斷是否已完成所有 i  \n    Yes → End // 已完成，結束程式  \n    No  → Step 3: i = 1 // 設定起始 i  \n→ Step 4: while i ≤ n: // 迭代 1 到 n  \n    → Step 5: ans[i] = ans[i >> 1] + (i & 1) // 右移一位後加上最低位得到 1 的數量  \n    → Step 6: i = i + 1 // 移至下一個整數  \n→ Decision: i ≤ n? // 是否還有未處理的數字  \n    Yes → 回到 Step 4 // 繼續迭代  \n    No  → End // 完成所有計算，程式結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countBits(self, n: int):\n        # 建立長度為 n+1 的陣列\n        res = [0] * (n + 1)\n        # 迭代 1 到 n，計算每個數的 1 的個數\n        for i in range(1, n + 1):\n            # 右移一位後加上最低位 (i & 1)\n            res[i] = res[i >> 1] + (i & 1)\n        return res\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中找出第一個數字\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    # 計算結果並輸出\n    result = Solution().countBits(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,1]",
          "success": true,
          "output": "[0, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[0,1,1,2,1,2]",
          "success": true,
          "output": "[0, 1, 1, 2, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode757.json",
    "problem_index_in_file": 0,
    "title": "Set Intersection Size At Least Two",
    "description_snippet": "You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving the minimum containing set size problem. Approach: sort intervals by end, iterate, maintain last chosen two numbers. Classic greedy: choose last two numbers at end of interval if not already covered. Implementation: sort by end ascending. For each interval [l, r]: count numbers already chosen within [l, r] (0,1,2). If count == 0: choose r-1, r. If count ==1: choose r. Need to store chosen numbers in a set. But for pseudocode, we can maintain two latest chosen numbers: a, b (the last two). Use decision.\n\nReturn size of set.\n\nLet's produce step-by-step pseudocode. Use virtual code arrows.\n\nLet's output each line with explanation.\n\nWe should include Start, End, Decision, Step lines.\n\nLet's write.\n\nUse variable intervalsSorted, chosenSet, count, etc.\n\nBe careful to include each step.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort intervals by their end value in ascending order // 先將區間按結束值排序，方便貪心選取  \n→ Step 2: Initialize chosenSet ← empty set // 用來存已選取的整數  \n→ Step 3: Initialize last1 ← -∞, last2 ← -∞ // 追蹤已選取的最後兩個數字（若不存在則為負無限）  \n→ Decision: For each interval [l, r] in sorted intervals? // 逐一處理每個區間  \n  Yes → Step 4: count ← 0 // 先統計區間內已選取的數字個數  \n  → Decision: last1 ∈ [l, r]? // 判斷最近兩個選取的數字是否落在區間內  \n   Yes → count ← count + 1, set lastA ← last1  \n   No  → // last1 不在區間內，保持 count  \n  → Decision: last2 ∈ [l, r]? // 判斷第二最近的選取數字是否落在區間內  \n   Yes → count ← count + 1, set lastB ← last2  \n   No  → // last2 不在區間內，保持 count  \n  → Decision: count == 2? // 已足夠兩個數字覆蓋該區間  \n   Yes → // 不做任何操作，進入下一個區間  \n   No → Decision: count == 1? // 只剩一個數字覆蓋  \n    Yes → Step 5: Choose num ← r // 選取結束值本身，補足第二個  \n     → Add num to chosenSet  \n     → Update last2 ← last1, last1 ← num // 更新最後兩個選取的數字  \n     → // 這樣區間現在有兩個數字  \n     → Continue to next interval  \n     No → Decision: count == 0? // 兩個都不在區間內  \n      Yes → Step 6: Choose num1 ← r-1, num2 ← r // 取結束值及其前一個  \n       → Add num1, num2 to chosenSet  \n       → Update last2 ← num1, last1 ← num2 // 更新最後兩個選取的數字  \n       → // 區間現在有兩個數字  \n       → Continue to next interval  \n       No → // 理論上不會發生，因為 count 只能是 0,1,2  \n→ Step 7: Return size of chosenSet // 最終答案即所選數字的最小個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def intersectionSizeTwo(self, intervals):\n        # 先按結束值遞增排序，若結束值相同則按起始值遞減\n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        res = []            # 记录已选择的整数\n        last, second_last = -1, -1  # 最近两个已选整数\n\n        for start, end in intervals:\n            count = 0\n            if start <= second_last <= end:\n                count += 1\n            if start <= last <= end:\n                count += 1\n\n            if count >= 2:\n                # 当前区间已经至少有两个整数，跳过\n                continue\n            elif count == 1:\n                # 只缺一个整数，选择区间结束点\n                res.append(end)\n                second_last, last = last, end\n            else:\n                # 两个都不在区间内，选择 end-1 与 end\n                res.extend([end - 1, end])\n                second_last, last = end - 1, end\n\n        return len(res)\n\ndef main():\n    # 读取完整输入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 去除可能的前缀 \"intervals =\"\n    if data.lower().startswith(\"intervals\"):\n        idx = data.find(\"=\")\n        if idx != -1:\n            data = data[idx + 1:].strip()\n    # 解析为列表\n    try:\n        intervals = ast.literal_eval(data)\n    except Exception as e:\n        # 如果解析失败，直接输出 0\n        print(0)\n        return\n    # 计算并输出结果\n    solution = Solution()\n    result = solution.intersectionSizeTwo(intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[3,7],[8,9]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,3],[1,4],[2,5],[3,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3],[2,4],[4,5]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode647.json",
    "problem_index_in_file": 0,
    "title": "Palindromic Substrings",
    "description_snippet": "Given a string s, return the number of palindromic substrings in it.\n\nA string is a palindrome when ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to count palindromic substrings. Use expanding around center approach. Steps: Start, input s, initialize count 0, loop i over each index, expand odd and even. Use while loops. Provide comments. Each line with arrow.\n\nWe need to format exactly: each line: 虛擬碼步驟 + space + // 解釋/說明. Use Start, End, Decision. Provide arrows → for steps.\n\nWe need to produce virtual code lines. No actual code. Use arrow arrow? It said use arrow \"→\". Use indentation for nested steps.\n\nWe need to produce steps with decisions for while loops.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input: s // 取得輸入字串\n→ Initialize: count = 0 // 初始化計數器\n→ Loop i from 0 to length(s)-1 // 遍歷每個中心位置\n    → Decision: Expand odd palindrome? // 開始奇數長度中心擴展\n        → While left>=0 AND right < n AND s[left]==s[right] // 當前子字串為回文時\n            → Increment count // 這個子字串是一個回文，計數加一\n            → left-- // 左指標左移\n            → right++ // 右指標右移\n    → Decision: Expand even palindrome? // 開始偶數長度中心擴展\n        → While left>=0 AND right < n AND s[left]==s[right] // 當前子字串為回文時\n            → Increment count // 這個子字串是一個回文，計數加一\n            → left-- // 左指標左移\n            → right++ // 右指標右移\n→ Output: count // 回傳回文子字串總數\nEnd // 程式執行結束\n\nBut need to use \"Yes →\" \"No →\" for decision. For while, we can use Decision: while condition? maybe.\n\nBetter:\n\nStart // 程式開始執行\n→ Input: s // 取得輸入字串\n→ Initialize: count = 0 // 初始化計數器\n→ For i from 0 to length(s)-1 // 遍歷每個字符作為中心\n    → Decision: 是否擴展奇數回文? // 檢查奇數中心\n        Yes → ExpandOdd(i)\n        No  → ...\nBut we want to show each step, not function call. Maybe we can show the while loop.\n\nWe need each line as virtual code step. So we can write:\n\n→ Decision: while left>=0 AND right<n AND s[left]==s[right]? // 檢查是否還能擴展回文\n    Yes → Increment count // 計數\n    Yes → left-- // 左移\n    Yes → right++ // 右移\n    No →  // 退出循環\n\nWe can combine lines. Let's produce simpler:\n\nUse arrow for each step, including Decision and sub-steps.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: s // 取得輸入字串  \n→ Initialize: count = 0 // 初始化計數器  \n→ For i = 0 to length(s)-1 // 循環每個字符作為中心  \n    → Decision: 擴展奇數長度中心? // 檢查奇數長度的回文  \n        Yes → Set left = i, right = i // 左右指標指向中心  \n        Yes → While left >= 0 AND right < length(s) AND s[left] == s[right] // 只要子字串為回文就繼續  \n            → Increment count // 計數這個回文子字串  \n            → left-- // 左移左指標  \n            → right++ // 右移右指標  \n    → Decision: 擴展偶數長度中心? // 檢查偶數長度的回文  \n        Yes → Set left = i, right = i + 1 // 左右指標指向相鄰兩個字符  \n        Yes → While left >= 0 AND right < length(s) AND s[left] == s[right] // 同樣只要子字串為回文就繼續  \n            → Increment count // 計數這個回文子字串  \n            → left-- // 左移左指標  \n            → right++ // 右移右指標  \n→ Output: count // 回傳總計數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        count = 0\n\n        def expand(left: int, right: int) -> None:\n            nonlocal count\n            while left >= 0 and right < n and s[left] == s[right]:\n                count += 1\n                left -= 1\n                right += 1\n\n        for i in range(n):\n            expand(i, i)       # odd length palindromes\n            expand(i, i + 1)   # even length palindromes\n\n        return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    # Try to parse input of form: s = \"abc\"\n    if data.startswith(\"s =\"):\n        first_quote = data.find('\"')\n        last_quote = data.rfind('\"')\n        if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n            s = data[first_quote + 1:last_quote]\n        else:\n            s = \"\"\n    else:\n        # Assume raw string without assignment\n        s = data\n\n    solution = Solution()\n    result = solution.countSubstrings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"aaa\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode846.json",
    "problem_index_in_file": 0,
    "title": "leetcode846_problem_1",
    "description_snippet": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm: \"Alice can rearrange cards into groups of size groupSize with consecutive values\". Classic problem: Hands of Straights. Approach: Count frequencies, sort keys. For each card value in ascending order, while freq > 0, attempt to form group starting from this value, decrement counts for next groupSize consecutive values. If any value missing, return false. At end true.\n\nWe output step-by-step pseudocode with arrows. Each line: \"虛擬碼步驟 // 解釋\". Must start with \"Start\". Use arrow '→' and Decision. Provide line-by-line.\n\nWe need to include all steps: Build frequency map, sort keys, iterate, attempt group formation, check missing or insufficient counts, return.\n\nWe should produce pseudocode in Chinese (繁體). Use typical flow: Start, Step 1, Step 2 etc. Use Decision blocks.\n\nLet's craft lines:\n\n1. Start // 程式開始執行\n2. → Step 1: 建立空頻率表 freq // 用來統計每張牌的數量\n3. → Step 2: 逐個 card in hand:\n4.   → Update freq[card] += 1 // 增加該牌數量\n5. → Step 3: 取得所有牌值並排序 ascendingKeys = sort(freq.keys()) // 方便從小到大處理\n6. → Step 4: 依序遍歷每個 key in ascendingKeys:\n7.   → Decision: 如果 freq[key] == 0? // 已經被消耗完，跳過\n8.      Yes → Continue // 跳過此值\n9.      No  → Step 5: 取出 count = freq[key] // 需要以此值開始的 count 組\n10. → Step 6: 對於 i in 0 ..< groupSize:\n11.     → Decision: 如果 key + i 不在 freq? // 無此牌\n12.        Yes → Return false // 不能組成連續組\n13.        No  → Decision: 如果 freq[key + i] < count? // 數量不足\n14.           Yes → Return false // 不能使用足夠數量\n15.           No  → freq[key + i] -= count // 消耗該牌的 count 張\n16. → Step 7: 若所有 key 都處理完畢，Return true // 成功組合\n17. End // 程式執行結束\n\nWe need to ensure each line uses '→' or 'Decision:' etc. Use arrow for nested decisions.\n\nThe above seems fine. Ensure each line is separate, with \"→\" at beginning for steps, but indentation maybe with tabs? They didn't specify indentation but used example with spaces. Use tab or indentation to show nested blocks. We'll use 4 spaces indentation for nested lines. Use \"Decision:\" for conditional.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 建立空頻率表 freq // 用來統計每張牌的數量\n→ Step 2: 逐個 card in hand:\n    → Update freq[card] += 1 // 增加該牌數量\n→ Step 3: 取得所有牌值並排序 ascendingKeys = sort(freq.keys()) // 方便從小到大處理\n→ Step 4: 依序遍歷每個 key in ascendingKeys:\n    → Decision: 如果 freq[key] == 0? // 已經被消耗完，跳過\n        Yes → Continue // 跳過此值\n        No  → Step 5: 取出 count = freq[key] // 需要以此值開始的 count 組\n→ Step 6: 對於 i in 0 ..< groupSize:\n    → Decision: 如果 key + i 不在 freq? // 無此牌\n        Yes → Return false // 不能組成連續組\n        No  → Decision: 如果 freq[key + i] < count? // 數量不足\n            Yes → Return false // 不能使用足夠數量\n            No  → freq[key + i] -= count // 消耗該牌的 count 張\n→ Step 7: 若所有 key 都處理完畢，Return true // 成功組合\nEnd // 程式執行結束\n\nCheck that each line has \"虛擬碼步驟\" + space + comment. Yes.\n\nReturn final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空頻率表 freq // 用來統計每張牌的數量  \n→ Step 2: 逐個 card in hand:  \n → Update freq[card] += 1 // 增加該牌數量  \n→ Step 3: 取得所有牌值並排序 ascendingKeys = sort(freq.keys()) // 方便從小到大處理  \n→ Step 4: 依序遍歷每個 key in ascendingKeys:  \n → Decision: 如果 freq[key] == 0? // 已經被消耗完，跳過  \n  Yes → Continue // 跳過此值  \n  No → Step 5: 取出 count = freq[key] // 需要以此值開始的 count 組  \n→ Step 6: 對於 i in 0 ..< groupSize:  \n → Decision: 如果 key + i 不在 freq? // 無此牌  \n  Yes → Return false // 不能組成連續組  \n  No → Decision: 如果 freq[key + i] < count? // 數量不足  \n   Yes → Return false // 不能使用足夠數量  \n   No → freq[key + i] -= count // 消耗該牌的 count 張  \n→ Step 7: 若所有 key 都處理完畢，Return true // 成功組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        # 必須能被 groupSize 整除\n        if len(hand) % groupSize != 0:\n            return False\n\n        count = Counter(hand)\n        for card in sorted(count):\n            freq = count[card]\n            if freq > 0:\n                # 嘗試從 card 開始組成連續組\n                for i in range(card, card + groupSize):\n                    if count[i] < freq:\n                        return False\n                    count[i] -= freq\n        return True\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入字串中抽取 hand 與 groupSize\n    pattern = r'hand\\s*=\\s*(\\[.*?\\])\\s*,\\s*groupSize\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        return\n    hand_str, groupSize_str = match.groups()\n    hand = eval(hand_str, {})\n    groupSize = int(groupSize_str)\n\n    result = Solution().isNStraightHand(hand, groupSize)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode88.json",
    "problem_index_in_file": 0,
    "title": "Merge Sorted Array",
    "description_snippet": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode with explanations in Chinese. Use Start, End, Decision, etc. The algorithm: merge two sorted arrays into nums1 with extra space at end. We can use two pointers from end to front.\n\nLet's produce lines:\n\nStart\n→ Set i = m-1 // last index of actual elements in nums1\n→ Set j = n-1 // last index of nums2\n→ Set k = m+n-1 // last index of merged array in nums1\n→ Decision: 如果 i >= 0 或 j >= 0? // while there are elements left\nYes → Decision: 如果 j < 0? // if nums2 exhausted\nYes → Step: nums1[k] = nums1[i] ; i--; k-- ; // copy remaining nums1 elements\nNo → Decision: 如果 nums1[i] > nums2[j]? // compare current elements\nYes → Step: nums1[k] = nums1[i] ; i--; k--; // place larger into nums1\nNo  → Step: nums1[k] = nums2[j] ; j--; k--; // place from nums2\nNo → End\n\nWe need to write each line with explanation after //. Also need to handle loop? The decision above covers loop condition: i>=0 or j>=0. Might want to use loop construct. But using Decision repeated. We'll just express as decision with Yes/No branch and inside recursion? Probably fine.\n\nLet's produce structured pseudocode lines. Ensure each line ends with // 解釋. Provide arrow for decisions.\n\nWe need to start with Start and End. Provide indent? Not necessary but arrow.\n\nLet's craft:\n\nStart // 程式開始\n→ Step: i ← m - 1 // 設定 nums1 最後一個有效元素索引\n→ Step: j ← n - 1 // 設定 nums2 最後一個元素索引\n→ Step: k ← m + n - 1 // 設定 nums1 最後一個可用位置索引\n→ Decision: i ≥ 0 或 j ≥ 0? // 若仍有未處理元素\n    Yes → Decision: j < 0? // 先檢查 nums2 是否已經全部合併\n        Yes → Step: nums1[k] ← nums1[i] ; i ← i - 1 ; k ← k - 1 ; // 把剩下的 nums1 元素拷到最後\n        No  → Decision: nums1[i] > nums2[j]? // 比較兩個當前元素\n            Yes → Step: nums1[k] ← nums1[i] ; i ← i - 1 ; k ← k - 1 ; // 把較大者放到 nums1[k]\n            No  → Step: nums1[k] ← nums2[j] ; j ← j - 1 ; k ← k - 1 ; // 把 nums2 當前元素放到 nums1[k]\n    No  → End // 合併完成\n\nWe must have each line with \"虛擬碼步驟\" and explanation. We need to use arrow arrow for nested decisions. The lines for decisions contain indented sub-steps. The format: \"Decision:\" line then indent sub-steps. Use indentation or maybe separate lines with \"Yes →\" etc.\n\nMake sure each line after step has explanation after //. We'll keep each as separate line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: i ← m - 1 // 設定 nums1 最後一個有效元素的索引  \n→ Step: j ← n - 1 // 設定 nums2 最後一個元素的索引  \n→ Step: k ← m + n - 1 // 設定 nums1 最後一個可用位置的索引  \n→ Decision: i ≥ 0 或 j ≥ 0? // 若仍有未處理元素  \n Yes → Decision: j < 0? // 判斷 nums2 是否已經全部合併  \n  Yes → Step: nums1[k] ← nums1[i] ; i ← i - 1 ; k ← k - 1 ; // 把剩下的 nums1 元素拷到最後  \n  No → Decision: nums1[i] > nums2[j]? // 比較兩個當前元素的大小  \n   Yes → Step: nums1[k] ← nums1[i] ; i ← i - 1 ; k ← k - 1 ; // 把較大者放到 nums1[k]  \n   No → Step: nums1[k] ← nums2[j] ; j ← j - 1 ; k ← k - 1 ; // 把 nums2 當前元素放到 nums1[k]  \n No → End // 合併完成，程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        i = m - 1          # index of last element in original nums1\n        j = n - 1          # index of last element in nums2\n        k = m + n - 1      # index of last position in nums1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        # If any elements remain in nums2, copy them\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中抽取 nums1, m, nums2, n。\"\"\"\n    nums1_str = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', data)\n    m_str     = re.search(r'm\\s*=\\s*(-?\\d+)', data)\n    nums2_str = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', data)\n    n_str     = re.search(r'n\\s*=\\s*(-?\\d+)', data)\n\n    if not (nums1_str and m_str and nums2_str and n_str):\n        raise ValueError(\"輸入格式錯誤\")\n\n    nums1 = eval(nums1_str.group(1))\n    m     = int(m_str.group(1))\n    nums2 = eval(nums2_str.group(1))\n    n     = int(n_str.group(1))\n    return nums1, m, nums2, n\n\ndef main():\n    data = sys.stdin.read()\n    nums1, m, nums2, n = parse_input(data)\n    Solution().merge(nums1, m, nums2, n)\n    print(nums1)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "success": true,
          "output": "[1, 2, 2, 3, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1009.json",
    "problem_index_in_file": 0,
    "title": "Complement of Base 10 Integer",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. Task: Given integer n, compute its binary complement. Approach: find number of bits in n, then compute mask of ones of that length, then XOR with n, or compute bitwise not & mask. Steps: input n, if n == 0 return 1? But complement of 0? 0 in binary \"0\", complement \"1\" => 1. We'll handle that. Steps: determine bit length: while n>0: count bits. Build mask: (1 << bitCount) - 1. Return n XOR mask.\n\nLet's produce steps. Use Start, End, Decision. No need loops? we can express loop with Decision: while? We'll show while loop with Decision: n>0? etc.\n\nLet's produce:\n\nStart\n→ Step 1: 取得輸入整數 n\n→ Decision: 如果 n 等於 0?\n    Yes → Step 2: 回傳 1 // 0 的補數是 1\n    No  → Step 3: 初始化 bitCount 為 0\n    → Step 4: temp ← n // 用於計算位數\n    → Decision: temp 大於 0?\n        Yes → Step 5: bitCount ← bitCount + 1\n              → Step 6: temp ← temp >> 1 // 右移一位\n              → Decision: temp 大於 0? → repeat Step 5-6\n    → Step 7: mask ← (1 << bitCount) - 1 // 產生全 1 的位掩碼\n    → Step 8: result ← n XOR mask // 取反\n    → Step 9: 回傳 result\nEnd\n\nAdd comments. Ensure format. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入整數 n // 從使用者處取得整數  \n→ Decision: 如果 n 等於 0? // 判斷是否為特殊情況  \n  Yes → Step 2: 回傳 1 // 0 的二進位為 '0'，取反後為 '1'  \n  No → Step 3: 初始化 bitCount 為 0 // 用於計算 n 的位數  \n  → Step 4: temp ← n // 用於計算位數的暫存變數  \n  → Decision: temp 大於 0? // 循環計算位數  \n   Yes → Step 5: bitCount ← bitCount + 1 // 進位數加一  \n     → Step 6: temp ← temp >> 1 // 右移一位  \n     → Decision: temp 大於 0? → 重複 Step 5-6  \n  → Step 7: mask ← (1 << bitCount) - 1 // 產生全 1 的位掩碼  \n  → Step 8: result ← n XOR mask // 取反得到補數  \n  → Step 9: 回傳 result // 將結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef bitwise_complement(n: int) -> int:\n    \"\"\"\n    計算 n 的二進位補數\n    - 若 n 為 0，補數為 1\n    - 否則先取得 n 的位數，產生全 1 的掩碼，然後 XOR\n    \"\"\"\n    if n == 0:\n        return 1\n    bit_length = n.bit_length()\n    mask = (1 << bit_length) - 1\n    return n ^ mask\n\ndef main() -> None:\n    \"\"\"\n    主函式\n    1. 讀取標準輸入\n    2. 取出第一個出現的整數 n\n    3. 計算補數並輸出\n    \"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    print(bitwise_complement(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 10",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode712.json",
    "problem_index_in_file": 0,
    "title": "Minimum ASCII Delete Sum for Two Strings",
    "description_snippet": "Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find minimal ASCII delete sum to make two strings equal. Classic dynamic programming: dp[i][j] minimal cost to make s1[0:i] and s2[0:j] equal. Base: dp[0][j] = sum of ascii of s2[0:j], dp[i][0] = sum of ascii of s1[0:i]. Recurrence: if s1[i-1] == s2[j-1], dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i-1][j] + ascii(s1[i-1]), dp[i][j-1] + ascii(s2[j-1])). At end answer dp[m][n]. Provide virtual steps. Need to output in lines with arrow etc. We'll produce step lines: Start, calculate lengths, init dp array, loops, etc.\n\nWe'll not output actual code. Provide line-by-line pseudo with explanation. Use \"Step\" etc.\n\nWe need to ensure to use arrow →. For loops, we can use Decision or loops. We'll represent loops: \"Loop i from 1 to m\" etc.\n\nLet's produce.\n\nPossible steps:\n\nStart\n→ Step 1: 定義 m = length of s1, n = length of s2 // 獲取兩字串長度\n→ Step 2: 建立 (m+1)×(n+1) dp 二維表 // 存儲子問題結果\n→ Step 3: 初始化 dp[0][0] = 0 // 空字串相等成本為 0\n→ Step 4: 初始化 dp[0][j] for j in 1..n // 將 s2 的前 j 字元全部刪除\n   → Step 4a: dp[0][j] = dp[0][j-1] + ASCII(s2[j-1]) // 每一步加上刪除成本\n→ Step 5: 初始化 dp[i][0] for i in 1..m // 將 s1 的前 i 字元全部刪除\n   → Step 5a: dp[i][0] = dp[i-1][0] + ASCII(s1[i-1]) // 每一步加上刪除成本\n→ Decision: 是否已經完成初始化? // 檢查初始化是否結束\n    Yes → Proceed to DP computation\n→ Step 6: 外層循環 i from 1 to m\n   → Step 6a: 內層循環 j from 1 to n\n        → Decision: s1[i-1] == s2[j-1] ?\n            Yes → dp[i][j] = dp[i-1][j-1] // 字元相同不需要刪除\n            No → \n                → Step 6b1: cost1 = dp[i-1][j] + ASCII(s1[i-1]) // 刪除 s1 的字元\n                → Step 6b2: cost2 = dp[i][j-1] + ASCII(s2[j-1]) // 刪除 s2 的字元\n                → Step 6b3: dp[i][j] = min(cost1, cost2) // 選擇較小成本\n→ Step 7: 回傳 dp[m][n] // 最終最小刪除成本\nEnd\n\nWe need to format each line with arrow? Use \"→\" before each step. But for decisions, we need indent or separate. Use arrow as per example: For Decision: if something?; Yes → ; No →. So we should produce like:\n\nStart // 程式開始執行\n→ Step 1: ... // explanation\n\nThen for decisions: \n→ Decision: ... // explanation\n    Yes → Step ... // explanation\n    No → ... // explanation\n\nFor loops we can just show as steps but maybe use nested. Provide indentation with spaces.\n\nWe must not output actual code. Just pseudo.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 m = s1 的長度, n = s2 的長度 // 取得兩字串長度\n→ Step 2: 建立 (m+1)×(n+1) 的 dp 二維表 // 用來儲存子問題最小成本\n→ Step 3: 初始化 dp[0][0] = 0 // 空字串相等成本為 0\n→ Step 4: 初始化 dp[0][j]，j 從 1 到 n\n    → Step 4a: dp[0][j] = dp[0][j-1] + ASCII(s2[j-1]) // 刪除 s2 的第 j 個字元\n→ Step 5: 初始化 dp[i][0]，i 從 1 到 m\n    → Step 5a: dp[i][0] = dp[i-1][0] + ASCII(s1[i-1]) // 刪除 s1 的第 i 個字元\n→ Decision: 初始化完成嗎? // 確認所有 dp 基本情況已設置\n    Yes → Proceed to DP 計算\n→ Step 6: 外層迴圈 i 從 1 到 m\n    → Step 6a: 內層迴圈 j 從 1 到 n\n        → Decision: s1[i-1] == s2[j-1] ? // 字元相同時不需要刪除\n            Yes → dp[i][j] = dp[i-1][j-1] // 直接沿用上一狀態\n            No  → \n                → Step 6b1: cost1 = dp[i-1][j] + ASCII(s1[i-1]) // 刪除 s1 的字元\n                → Step 6b2: cost2 = dp[i][j-1] + ASCII(s2[j-1]) // 刪除 s2 的字元\n                → Step 6b3: dp[i][j] = min(cost1, cost2) // 選擇較小的成本\n→ Step 7: 回傳 dp[m][n] // 兩字串相等所需的最低 ASCII 刪除總和\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # 初始化第一行和第一列（刪除所有字元）\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n\n        # DP 填表\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(\n                        dp[i - 1][j] + ord(s1[i - 1]),\n                        dp[i][j - 1] + ord(s2[j - 1])\n                    )\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入中擷取兩個字串。支援以下格式：\n    1. s1 = \"sea\", s2 = \"eat\"\n    2. 兩行分別為字串\n    3. 空格分隔的兩個字串\n    \"\"\"\n    # 先嘗試找 quoted 字串\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n\n    # 沒有引號，則按行或空格切割\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    raise ValueError(\"無法解析輸入，請提供兩個字串\")\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n    s1, s2 = parse_input(raw)\n    solution = Solution()\n    result = solution.minimumDeleteSum(s1, s2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"sea\", s2 = \"eat\"",
          "expected_output": "231",
          "success": true,
          "output": "231"
        },
        {
          "example_index": 1,
          "input": "s1 = \"delete\", s2 = \"leet\"",
          "expected_output": "403",
          "success": true,
          "output": "403"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode640.json",
    "problem_index_in_file": 0,
    "title": "Solve the Equation",
    "description_snippet": "Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps to solve linear equation of form ax + b = 0? Actually general equation with +, - operations, variable x and its coefficient. Eg \"2x+3=5x-7\". We need find solution. Steps: parse equation, collect coefficients of x and constants, bring to one side: (a - c)x + (b - d) = 0? Solve.\n\nPseudo steps: Start, input equation string, split by '=', left and right. For each side, parse terms with regex maybe, accumulate coeff_x and const. After parsing, compute total coeff_x = left_coeff_x - right_coeff_x; const = left_const - right_const. Then if coeff_x==0: if const==0 => infinite; else no solution. Else x = -const / coeff_x. Ensure integer. Output string.\n\nImplement decision structure.\n\nWe need virtual code lines.\n\nLet's produce:\n\nStart // start\n→ Step 1: 讀取方程式字串 // Get equation\n→ Step 2: 將字串以 '=' 分割成 leftPart 和 rightPart // split\n→ Step 3: 初始化 leftCoeff=0, leftConst=0, rightCoeff=0, rightConst=0 // init\n→ Step 4: 定義函式 parseSide(side) // helper\n    → Step 4.1: 使用正則表達式找到所有項目 // parse terms\n    → Step 4.2: 對每個項目:\n        → Decision: 是否包含 'x'? // check variable\n            Yes → Step 4.2.1: 取得係數, 加到對應係數變數 // add coeff\n            No  → Step 4.2.2: 取得數值, 加到對應常數變數 // add const\n→ Step 5: 呼叫 parseSide(leftPart) 並更新 leftCoeff,leftConst // parse left\n→ Step 6: 呼叫 parseSide(rightPart) 並更新 rightCoeff,rightConst // parse right\n→ Step 7: 計算 totalCoeff = leftCoeff - rightCoeff // bring all x to left\n→ Step 8: 計算 totalConst = leftConst - rightConst // bring all constants to left\n→ Decision: 是否 totalCoeff == 0? // check coefficient zero\n    Yes → Decision: 是否 totalConst == 0? // check constant zero\n        Yes → Step 9: 輸出 \"Infinite solutions\" // infinite\n        No  → Step 10: 輸出 \"No solution\" // none\n    No  → Step 11: 計算 x = -totalConst / totalCoeff // solve\n        → Decision: 是否整數? // ensure integer\n            Yes → Step 12: 輸出 \"x=\" + x // output\n            No  → Step 13: 輸出 \"No solution\" // but spec says integer guaranteed, still handle\n→ End // end\n\nMake sure each line has virtual code step plus comment. Use arrow style.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取方程式字串 // 從使用者取得方程式\n→ Step 2: 將字串以 '=' 分割成 leftPart 和 rightPart // 分離左右兩側\n→ Step 3: 初始化 leftCoeff = 0, leftConst = 0, rightCoeff = 0, rightConst = 0 // 用於累加係數與常數\n→ Step 4: 定義函式 parseSide(side, coeff, const) // 解析單側字串\n    → Step 4.1: 用正則表達式找到所有項目 // 如 '+3x', '-5', '+x'\n    → Step 4.2: 對每個項目進行處理\n        → Decision: 這個項目是否含 'x'? // 判斷是否為變數項\n            Yes → Step 4.2.1: 取得係數值並加到 coeff // 累加變數係數\n            No  → Step 4.2.2: 取得數值並加到 const // 累加常數\n→ Step 5: 呼叫 parseSide(leftPart, leftCoeff, leftConst) // 解析左側\n→ Step 6: 呼叫 parseSide(rightPart, rightCoeff, rightConst) // 解析右側\n→ Step 7: 計算 totalCoeff = leftCoeff - rightCoeff // 把所有 x 移到左邊\n→ Step 8: 計算 totalConst = leftConst - rightConst // 把所有常數移到左邊\n→ Decision: totalCoeff == 0? // 判斷 x 的係數是否為零\n    Yes → Decision: totalConst == 0? // 判斷常數是否也為零\n        Yes → Step 9: 輸出 \"Infinite solutions\" // 無限多解\n        No  → Step 10: 輸出 \"No solution\" // 無解\n    No  → Step 11: 計算 x = -totalConst / totalCoeff // 求解唯一解\n        → Decision: x 為整數? // 確認結果為整數\n            Yes → Step 12: 輸出 \"x=\" + x // 輸出解\n            No  → Step 13: 輸出 \"No solution\" // 防止非整數情形\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef parse_side(s: str):\n    \"\"\"Parse one side of the equation and return (x_coefficient, constant).\"\"\"\n    x_coeff, const = 0, 0\n    i, n = 0, len(s)\n    sign = 1  # current sign for the upcoming term\n    while i < n:\n        ch = s[i]\n        if ch == '+':\n            sign = 1\n            i += 1\n        elif ch == '-':\n            sign = -1\n            i += 1\n        else:\n            # find the end of the current term\n            j = i\n            while j < n and s[j] not in '+-':\n                j += 1\n            token = s[i:j]\n            if 'x' in token:\n                coeff_str = token[:-1]  # everything except the trailing 'x'\n                if coeff_str == '' or coeff_str == '+':\n                    coeff = 1\n                elif coeff_str == '-':\n                    coeff = -1\n                else:\n                    coeff = int(coeff_str)\n                x_coeff += sign * coeff\n            else:\n                const += sign * int(token)\n            i = j\n    return x_coeff, const\n\ndef solve_equation(equation: str) -> str:\n    left, right = equation.split('=', 1)\n    left_x, left_const = parse_side(left)\n    right_x, right_const = parse_side(right)\n\n    coeff = left_x - right_x          # coefficient of x after moving all x terms to left\n    const = left_const - right_const  # constant term after moving all constants to left\n\n    if coeff == 0:\n        if const == 0:\n            return \"Infinite solutions\"\n        else:\n            return \"No solution\"\n    else:\n        x_val = -const // coeff\n        return f\"x={x_val}\"\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit()\n    # Expect input like: equation = \"x+5-3+x=6+x-2\"\n    parts = input_data.split('=', 1)\n    if len(parts) == 2:\n        eq_str = parts[1].strip()\n        # Remove surrounding quotes if present\n        if (eq_str.startswith('\"') and eq_str.endswith('\"')) or \\\n           (eq_str.startswith(\"'\") and eq_str.endswith(\"'\")):\n            eq_str = eq_str[1:-1]\n        result = solve_equation(eq_str)\n        print(result)\n    else:\n        # If input is just the equation string without assignment\n        result = solve_equation(input_data)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equation = \"x+5-3+x=6+x-2\"",
          "expected_output": "x=2",
          "success": true,
          "output": "x=2"
        },
        {
          "example_index": 1,
          "input": "equation = \"x=x\"",
          "expected_output": "Infinite solutions",
          "success": true,
          "output": "Infinite solutions"
        },
        {
          "example_index": 2,
          "input": "equation = \"2x=x\"",
          "expected_output": "x=0",
          "success": true,
          "output": "x=0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode128.json",
    "problem_index_in_file": 0,
    "title": "Longest Consecutive Sequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, line by line with explanations. The task: Given unsorted array, find longest consecutive sequence length, O(n). Standard algorithm: use hash set to store numbers. Iterate numbers, if number-1 not in set, it's sequence start; iterate forward counting consecutive. Keep max. Need virtual steps with arrow and decision blocks.\n\nWe need to produce virtual code steps: Start, create set, iterate, decision whether element is start of sequence, loop while next in set, update max. End.\n\nWe need to ensure formatting exactly: Each line: \"虛擬碼步驟 [space] // 解釋\". Use arrow symbols: →, Yes →, No →. Use Decision: ... with Yes/No branches. Also indentation? Example shows indentation: Decision block lines indented. We'll mimic.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 numberSet // 用於快速查找元素\n→ Step 2: 將 nums 中所有數字加入 numberSet // O(n) 時間\n→ Step 3: 初始化 maxLength 為 0 // 儲存目前已知的最大連續序列長度\n→ Step 4: 對 numberSet 中每個 num 進行迭代 // 遍歷所有元素\n    → Decision: 如果 num - 1 不在 numberSet? // 判斷 num 是否為序列起點\n        Yes → Step 5: 設定 currentNum 為 num, currentLen 為 1 // 開始新的序列\n        → Decision: 如果 currentNum + 1 在 numberSet? // 檢查後續是否連續\n            Yes → Step 6: currentNum ← currentNum + 1, currentLen ← currentLen + 1 // 走到下一個連續數\n            No  → Step 7: 更新 maxLength 為 max(maxLength, currentLen) // 結束此序列\n            // 循環回到 Decision: 檢查 currentNum + 1 在 numberSet?\n        No  → // 若 num - 1 在 set，則已由先前起點處理，跳過\n→ Step 8: 返回 maxLength // 最長連續序列長度\nEnd // 程式結束\n\nBut we need to reflect loop for consecutive sequence. The decision \"while currentNum+1 in set\" loop, but using virtual code we can represent as Decision block with Yes → Step 6 and then repeat. But we need a loop indicator. Maybe use \"Decision: If next exists? Yes → Step 6\" then loop back to the same decision. We need to show that. Use arrow to show loop: Step 6 ends with → Decision: ... ; we need to connect.\n\nBetter: after Step 6, we go back to the decision to check next. So we show: Step 6: currentNum ← currentNum + 1, currentLen ← currentLen + 1 // Move to next\n→ Decision: If currentNum + 1 在 numberSet? // check further consecutive\nYes → Step 6 ... (loop)\nNo → Step 7.\n\nBut we can't refer to Step 6 again; maybe we show \"Step 6\" but repeated. We'll just represent as loop. Let's structure:\n\nStart\n→ Step 1: 建立 numberSet ← 空集合 // ...\n→ Step 2: 將 nums 中所有數字加入 numberSet // O(n)\n→ Step 3: maxLen ← 0 // 初始化最大長度\n→ Step 4: 對 numberSet 中每個 num 做迭代\n    → Decision: 若 num - 1 不在 numberSet?\n        Yes → currentNum ← num, currentLen ← 1 // 開始新序列\n        → Decision: 若 currentNum + 1 在 numberSet?\n            Yes → currentNum ← currentNum + 1, currentLen ← currentLen + 1 // 繼續序列\n            // 循環回到 Decision: 若 currentNum + 1 在 numberSet?\n            No  → maxLen ← max(maxLen, currentLen) // 更新最大值\n        No → // 不是序列起點，跳過\n→ Step 5: 回傳 maxLen\nEnd\n\nWe need to show loop back. Use arrow to show back to decision. We'll add a line \"→ Decision: 若 currentNum + 1 在 numberSet?\" after Step 6 but with a comment \"回到此決策檢查下一個\". Actually we can show as Step 6 ends with a comment that loops back.\n\nAlternatively, we can model as:\n\n→ Decision: 若 currentNum + 1 在 numberSet?\n    Yes → Step 6: currentNum ← currentNum + 1, currentLen ← currentLen + 1 // 走到下一個\n    No  → Step 7: maxLen ← max(maxLen, currentLen) // 更新最大值\n\nAnd then Step 6 should go back to Decision. But we can use a \"Loop\" arrow: \"→ Step 6: ...\" then \"→ Decision: ...\" repeated. But the format expects each line preceded by → or Decision. We can show:\n\n→ Decision: 若 currentNum + 1 在 numberSet?\n    Yes → Step 6: currentNum ← currentNum + 1, currentLen ← currentLen + 1 // 走到下一個\n    No  → Step 7: maxLen ← max(maxLen, currentLen) // 更新最大值\n\nBut that would not explicitly show loop back to Decision after Step 6. But we can note \"循環回到 Decision: 若 currentNum + 1 在 numberSet?\" as comment. However, we must adhere to format. Could add another Decision after Step 6: \"→ Decision: 若 currentNum + 1 在 numberSet?\" and show Yes → Step 6 again. But that's repetitive.\n\nMaybe we can present as:\n\n→ Decision: 若 currentNum + 1 在 numberSet?\n    Yes → Step 6: currentNum ← currentNum + 1, currentLen ← currentLen + 1 // 走到下一個\n    No  → Step 7: maxLen ← max(maxLen, currentLen) // 更新最大值\n\nAnd include a comment after Step 6: \"// 回到此決策檢查是否還有連續數\" which indicates loop. That might satisfy.\n\nLet's produce final output with correct format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 numberSet ← 空集合 // 用來儲存所有數字，方便 O(1) 查找  \n→ Step 2: 將 nums 中的每個數字加入 numberSet // O(n) 時間  \n→ Step 3: maxLen ← 0 // 儲存目前已知的最大連續序列長度  \n→ Step 4: 對 numberSet 中每個 num 做迭代 // 遍歷所有元素  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 若 num - 1 不在 numberSet? // 判斷 num 是否為序列起點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → currentNum ← num, currentLen ← 1 // 開始新的序列  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 若 currentNum + 1 在 numberSet? // 檢查是否有下一個連續數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → currentNum ← currentNum + 1, currentLen ← currentLen + 1 // 走到下一個連續數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 回到「若 currentNum + 1 在 numberSet?」決策檢查是否還有連續數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → maxLen ← max(maxLen, currentLen) // 結束此序列，更新最大值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // num 不是序列起點，已由前面的起點處理，直接跳過  \n→ Step 5: 回傳 maxLen // 回傳最長連續序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def longestConsecutive(self, nums):\n        \"\"\"Return the length of the longest consecutive elements sequence.\"\"\"\n        if not nums:\n            return 0\n\n        num_set = set(nums)\n        longest = 0\n\n        for num in num_set:\n            # Only start counting when num is the beginning of a sequence\n            if num - 1 not in num_set:\n                current_num = num\n                length = 1\n\n                # Count consecutive numbers forward\n                while current_num + 1 in num_set:\n                    current_num += 1\n                    length += 1\n\n                longest = max(longest, length)\n\n        return longest\n\ndef parse_input():\n    \"\"\"Parse a line like 'nums = [1, 2, 3]' from stdin into a list of ints.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return []\n\n    try:\n        # Extract the part inside the brackets and evaluate safely\n        start = data.index('[')\n        end = data.rindex(']')\n        nums_str = data[start:end + 1]\n        nums = ast.literal_eval(nums_str)\n        if isinstance(nums, list):\n            return nums\n    except (ValueError, SyntaxError):\n        pass\n\n    # Fallback: split by non-digit characters\n    parts = [int(part) for part in re.findall(r'-?\\d+', data)]\n    return parts\n\nif __name__ == \"__main__\":\n    nums = parse_input()\n    solution = Solution()\n    result = solution.longestConsecutive(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [100,4,200,1,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "nums = [1,0,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode56.json",
    "problem_index_in_file": 0,
    "title": "Merge Intervals",
    "description_snippet": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for merging intervals. Provide step-by-step pseudocode. Use Start, End, Decision, arrow. Provide explanation comments.\n\nSteps: Start, Sort intervals by start. Initialize result list. Iterate through sorted intervals, keep track of current interval. If next start <= current end then merge (update end to max). Else push current interval, set current = next. After loop push last. Return result.\n\nLet's produce lines:\n\nStart\n→ Step 1: Sort intervals by ascending start // 排序\n→ Step 2: Initialize merged list empty // 用於儲存結果\n→ Step 3: Set current_interval = first interval // 開始合併\n→ For each interval in sorted intervals starting from second\n    → Decision: If interval.start <= current_interval.end?\n        Yes → Step 4: Update current_interval.end = max(current_interval.end, interval.end) // 合併\n        No → Step 5: Append current_interval to merged // 輸出已合併區間\n            → Step 6: Set current_interval = interval // 開始新的區間\n→ After loop: Step 7: Append current_interval to merged // 加入最後一個區間\n→ Step 8: Return merged // 結果\n\nAdd Start and End.\n\nNeed each line with arrow and comment.\n\nAlso maybe include comment at decision.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort intervals by ascending start // 先依起始點排序，方便後續合併\n→ Step 2: Initialize merged list empty // 用來存放合併後的區間\n→ Step 3: Set current_interval = first interval // 用於跟已經處理的區間做比較\n→ Decision: 迭代 sorted intervals 從第二個開始 // 準備遍歷每個區間\n    → Yes → Step 4: If next.start <= current_interval.end\n        → Yes → Step 5: Update current_interval.end = max(current_interval.end, next.end) // 合併重疊區間\n        → No  → Step 6: Append current_interval to merged // 把已完成的區間加入結果\n            → Step 7: Set current_interval = next // 重新開始新的合併區間\n→ Decision: 迴圈結束後 // 處理最後一個區間\n    → Yes → Step 8: Append current_interval to merged // 加入最後一段\n→ Step 9: Return merged // 將所有非重疊區間回傳\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\ndef merge_intervals(intervals):\n    \"\"\"合併重疊的區間，返回非重疊的區間列表。\"\"\"\n    if not intervals:\n        return []\n\n    # 先依起始點排序，方便後續合併\n    intervals.sort(key=lambda x: x[0])\n\n    merged = [intervals[0]]  # 已合併好的區間列表，先把第一個加入\n\n    for current in intervals[1:]:\n        prev = merged[-1]\n        if current[0] <= prev[1]:  # 有重疊，更新終點為兩者最大的終點\n            prev[1] = max(prev[1], current[1])\n        else:  # 無重疊，將上一個區間保存，開始新的區間\n            merged.append(current)\n\n    return merged\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行內容\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit()\n\n    # 解析輸入：預期形如 \"intervals = [[1,3],[2,6],[8,10],[15,18]]\"\n    # 先找 '='，取右邊作為區間列表\n    if '=' in input_data:\n        _, expr = input_data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = input_data\n\n    # 使用 ast.literal_eval 以安全方式解析列表\n    intervals = ast.literal_eval(expr)\n\n    # 執行合併邏輯\n    result = merge_intervals(intervals)\n\n    # 以無空格的 JSON 形式輸出，符合範例輸出格式\n    print(json.dumps(result, separators=(',', ':')))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "expected_output": "[[1,6],[8,10],[15,18]]",
          "success": true,
          "output": "[[1,6],[8,10],[15,18]]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,4],[4,5]]",
          "expected_output": "[[1,5]]",
          "success": true,
          "output": "[[1,5]]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[4,7],[1,4]]",
          "expected_output": "[[1,7]]",
          "success": true,
          "output": "[[1,7]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode395.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring with At Least K Repeating Characters",
    "description_snippet": "Given a string s and an integer k, return the length of the longest substring of s such that the fre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: longest substring with each char freq >= k. Known solution: divide and conquer recursively split on characters with freq < k. Use recursion.\n\nWe must output step-by-step virtual code with comments. Use arrow \"→\" and Decision. Use Start End. Each line virtual code + comment. No actual code.\n\nWe produce lines: Start, Step 1: define function longestSubstring(s, k). Step 2: if s empty return 0. Step 3: compute char frequency. Step 4: identify invalid chars. Step 5: if none invalid, return len(s). Step 6: split s by invalid chars. Step 7: for each part, recursively call longestSubstring. Step 8: keep max. Step 9: return max. End.\n\nInclude decision structure: Decision: If there are no invalid chars? Yes -> Step 4. No -> Step 5. Provide indentation lines. Use arrow for nested steps.\n\nLet's craft.\n\nWe must follow output format: Each line: \"虛擬碼步驟 // 解釋\". For decision, include indentation? In example, indentation shows decisions within.\n\nWe produce like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 longestSubstring(s, k) // 開始計算\n→ Decision: s 是否為空? // 檢查字串是否為空\n    Yes → Step 2: 回傳 0 // 空字串長度為 0\n    No  → Step 3: 建立頻率表 freq  // 先計算字元出現次數\n    ...\nBut we need to maintain step numbers? Not required.\n\nLet's craft final output.\n\nUse Chinese comments. Each line virtual code plus comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 longestSubstring(s, k) // 開始計算  \n→ Decision: s 是否為空? // 檢查字串是否為空  \n  Yes → Step 2: 回傳 0 // 空字串長度為 0  \n  No  → Step 3: 初始化字元頻率表 freq // 用於統計每個字元在 s 中的出現次數  \n    → Step 4: 為每個字元 c in s 執行 freq[c] += 1 // 逐字元累加頻率  \n→ Decision: 是否存在頻率小於 k 的字元? // 檢查是否有「不合格」字元  \n  Yes → Step 5: 建立「不合格」字元列表 badChars = {c | freq[c] < k} // 收集所有低頻字元  \n    → Step 6: 按 badChars 分割 s 成若干子字串 parts // 將字串以不合格字元切分  \n    → Step 7: 初始化 maxLen = 0 // 用於記錄最大符合條件的子字串長度  \n    → Decision: parts 是否為空? // 檢查切分後是否還有子字串  \n      Yes → Step 8: 回傳 0 // 無剩餘子字串，返回 0  \n      No → 迴圈遍歷每個 part in parts  \n       → Step 9: 取子串長度 lenPart = longestSubstring(part, k) // 递归计算子串  \n       → Step 10: 若 lenPart > maxLen，則 maxLen = lenPart // 更新最大長度  \n       → Step 11: 迴圈結束後，回傳 maxLen // 返回此段的最大長度  \n  No  → Step 12: 回傳 len(s) // 所有字元頻率都 >= k，整段即為最大長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef longestSubstring(s: str, k: int) -> int:\n    \"\"\"回傳長度至少 k 的子字串中，所有字元頻率都至少 k 的最大長度。\"\"\"\n    if not s:\n        return 0\n    if len(s) < k:\n        return 0\n\n    # 1. 計算頻率表\n    freq = {}\n    for ch in s:\n        freq[ch] = freq.get(ch, 0) + 1\n\n    # 2. 找出「不合格」字元（頻率 < k）\n    bad_chars = [ch for ch, cnt in freq.items() if cnt < k]\n\n    # 3. 若沒有不合格字元，整段即為答案\n    if not bad_chars:\n        return len(s)\n\n    # 4. 以所有不合格字元為分隔，分割成若干子字串\n    split_pattern = '|'.join(map(re.escape, bad_chars))\n    parts = re.split(split_pattern, s)\n\n    # 5. 針對每個子字串遞迴求解，取最大長度\n    max_len = 0\n    for part in parts:\n        if part:  # 只對非空子字串進行遞迴\n            cur_len = longestSubstring(part, k)\n            if cur_len > max_len:\n                max_len = cur_len\n    return max_len\n\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n\n    # 解析輸入，假設格式為類似 's = \"aaabb\", k = 3'\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n\n    s = s_match.group(1) if s_match else \"\"\n    k = int(k_match.group(1)) if k_match else 0\n\n    result = longestSubstring(s, k)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabb\", k = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"ababbc\", k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode231.json",
    "problem_index_in_file": 0,
    "title": "Power of Two",
    "description_snippet": "Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nAn integer n is a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: Given integer n, return true if power of two. Use typical bit trick: n>0 && (n & (n-1)) == 0.\n\nWe produce steps: Start, Step1: Input n, Step2: If n <=0 -> return false. Step3: If (n & (n-1)) == 0 then return true else false. End. Use Decision. Provide arrow structure.\n\nFollow format: Each line: 虛擬碼步驟 [space] // 解釋.\n\nInclude arrows: →. Decision lines with Yes→, No→. Indentation maybe using spaces or indent.\n\nWe need to produce final output exactly. Let's craft:\n\nStart // 程式開始執行\n→ Step 1: Input integer n // 取得使用者輸入的整數\n→ Decision: 如果 n <= 0? // 檢查 n 是否小於或等於零\n    Yes → Step 2: Return false // 小於或等於零不是 2 的冪\n    No  → Decision: 檢查 (n & (n-1)) == 0? // 只要 n 與 n-1 位元相與為 0 就是 2 的冪\n        Yes → Step 3: Return true // 是 2 的冪，回傳 true\n        No  → Step 4: Return false // 不是 2 的冪，回傳 false\nEnd // 程式執行結束\n\nCheck format: Each line must contain虛擬碼步驟 + space + // 解釋. Indentation maybe not necessary but we can indent the nested decisions with spaces.\n\nAlso Decision lines: \"Decision:\" then the condition. Then indent with Yes→ etc. Provide each with space before //.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input integer n // 取得使用者輸入的整數  \n→ Decision: n <= 0? // 檢查 n 是否小於或等於零  \n    Yes → Step 2: Return false // 小於或等於零不是 2 的冪，回傳 false  \n    No  → Decision: (n & (n-1)) == 0? // 檢查 n 與 n-1 位元相與是否為 0  \n        Yes → Step 3: Return true // 是 2 的冪，回傳 true  \n        No  → Step 4: Return false // 不是 2 的冪，回傳 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        \"\"\"Return True if n is a power of two, else False.\"\"\"\n        if n <= 0:\n            return False\n        # A power of two has exactly one bit set: n & (n-1) == 0\n        return (n & (n - 1)) == 0\n\ndef main() -> None:\n    \"\"\"Read input, evaluate, and print result.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the first integer from the input (handles formats like 'n = 16')\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n\n    n = int(numbers[0])\n    solution = Solution()\n    result = solution.isPowerOfTwo(n)\n\n    # Output 'true' or 'false' in lowercase, as expected by the examples\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode455.json",
    "problem_index_in_file": 0,
    "title": "Assign Cookies",
    "description_snippet": "Assume you are an awesome parent and want to give your children some cookies. But, you should give e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step for algorithm: greedy: sort both arrays ascending, two pointers. Count matches.\n\nOutput format: each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols. Need Start End, Decision.\n\nLet's craft.\n\nStart // 程式開始執行\n\n→ Step 1: Sort greed array ascending // 先將孩子的慾望值排序\n\n→ Step 2: Sort cookie sizes ascending // 先將餅乾大小排序\n\n→ Step 3: 初始化 i = 0, j = 0, count = 0 // 指標與計數\n\n→ Decision: 是否已經遍歷完所有孩子或餅乾? // 判斷是否結束\n\n   Yes → End // 所有孩子或餅乾已處理完\n\n   No  → Decision: s[j] >= g[i]? // 判斷餅乾是否足夠\n\n      Yes → Step 4: count++ ; i++ ; j++ // 內容孩子 + 指標移動\n\n      No  → Step 5: j++ // 餅乾太小，移動到下一顆\n\n回到 Decision: 是否已經遍歷完? 循環\n\nAfter loop:\n\n→ Step 6: Output count // 輸出最大內容孩子數\n\nEnd // 程式結束\n\nMake sure to include arrow arrows \"→\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort g ascending // 將孩子的慾望值由小到大排序  \n→ Step 2: Sort s ascending // 將餅乾大小由小到大排序  \n→ Step 3: i = 0; j = 0; count = 0 // 初始化孩子、餅乾指標與匹配計數  \n→ Decision: i ≥ len(g) OR j ≥ len(s)? // 判斷是否已遍歷完所有孩子或餅乾  \n    Yes → End // 兩個序列都已處理完，結束循環  \n    No  → Decision: s[j] ≥ g[i]? // 判斷目前餅乾是否足夠給目前孩子  \n        Yes → Step 4: count++; i++; j++ // 成功匹配，計數+1，兩指標同時向後移  \n        No  → Step 5: j++ // 餅乾太小，僅移動餅乾指標  \n回到 Decision: i ≥ len(g) OR j ≥ len(s)? // 重複循環直到結束  \n→ Step 6: Output count // 輸出最大內容孩子數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef find_content_children(g, s):\n    g.sort()\n    s.sort()\n    i = j = 0\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n        j += 1\n    return i\n\ndef main():\n    data = sys.stdin.read()\n    g_match = re.search(r'g\\s*=\\s*(\\[[^\\]]*\\])', data)\n    s_match = re.search(r's\\s*=\\s*(\\[[^\\]]*\\])', data)\n    g_list = ast.literal_eval(g_match.group(1)) if g_match else []\n    s_list = ast.literal_eval(s_match.group(1)) if s_match else []\n    result = find_content_children(g_list, s_list)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "g = [1,2], s = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode155.json",
    "problem_index_in_file": 0,
    "title": "Min Stack",
    "description_snippet": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nI...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for implementing MinStack with O(1). Use structure. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe need to cover initialization, push, pop, top, getMin. Use two stacks: main stack and min stack. Or store pairs. Let's produce virtual code.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化兩個空堆疊 mainStack, minStack\n→ Step 2: 定義 MinStack 類別 // 封裝功能\n→ Decision: 在方法 push(val)\n   Yes → Step 3: 將 val 推入 mainStack\n   Yes → Decision: 若 minStack 為空 或 val <= minStack.top()\n      Yes → Step 4: 將 val 推入 minStack\n      No  → Step 5: 直接推入 minStack 同樣的值? Actually if we push val into main only, minStack unchanged? We push to minStack only when val <= current min. But we also might store duplicate. Use same val.\n→ Step 6: 定義 pop()\n   Yes → Decision: 若 mainStack 非空\n      Yes → Step 7: 取出 topVal = mainStack.pop()\n      Yes → Decision: 若 topVal == minStack.top()\n         Yes → Step 8: minStack.pop()\n      No  → Step 9: // nothing\n→ Step 10: 定義 top()\n   Yes → Step 11: 回傳 mainStack.top()\n→ Step 12: 定義 getMin()\n   Yes → Step 13: 回傳 minStack.top()\nEnd\n\nNeed to use arrow syntax with Start, End, Decision. Let's produce each line.\n\nAlso need to ensure proper indentation maybe not necessary. Use arrow for each step. Use Decision. Each line: \"虛擬碼步驟 // 解釋\".\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個空堆疊 mainStack, minStack // 建立主堆疊與最小值堆疊  \n→ Step 2: 定義 MinStack 類別 // 封裝所有功能  \n→ Decision: 在方法 push(val)  \n    Yes → Step 3: mainStack.push(val) // 把值塞進主堆疊  \n    Yes → Decision: 若 minStack 為空 或 val <= minStack.top() // 檢查是否成為新的最小值  \n        Yes → Step 4: minStack.push(val) // 把新的最小值塞進最小堆疊  \n        No  → Step 5: // 不更新最小堆疊，保持目前最小值不變  \n→ Step 6: 定義 pop() // 移除堆疊頂部元素  \n    Yes → Decision: 若 mainStack 非空  \n        Yes → Step 7: topVal = mainStack.pop() // 取出並移除主堆疊頂部  \n        Yes → Decision: 若 topVal == minStack.top() // 若剛剔除的也是最小值  \n            Yes → Step 8: minStack.pop() // 同時移除最小堆疊頂部  \n            No  → Step 9: // 若不是最小值，最小堆疊保持不變  \n        No  → Step 10: // 主堆疊為空時不做任何事  \n→ Step 11: 定義 top() // 回傳主堆疊頂部元素  \n    Yes → Step 12: return mainStack.top() // 直接返回頂部值  \n→ Step 13: 定義 getMin() // 取得當前最小值  \n    Yes → Step 14: return minStack.top() // 最小堆疊頂部即為最小值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    \"\"\"堆疊類別，支援取得最小值（O(1) 時間）\"\"\"\n\n    def __init__(self):\n        self.stack = []        # 主堆疊\n        self.min_stack = []    # 儲存最小值的堆疊\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        # 若 min_stack 為空或 val 為新的最小值，則同步推入 min_stack\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        # 若剛剛被 pop 的值是目前最小值，亦同步 pop min_stack\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -> int:\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\n\ndef main() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將兩個列表包裝成外層列表，方便 json 解析\n    ops, args = json.loads(f'[{data}]')\n\n    output = []\n    stack = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack = MinStack()\n            output.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            output.append(None)\n        elif op == \"pop\":\n            stack.pop()\n            output.append(None)\n        elif op == \"top\":\n            res = stack.top()\n            output.append(res)\n        elif op == \"getMin\":\n            res = stack.getMin()\n            output.append(res)\n\n    # 用 json 輸出，None 會被轉成 null\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "success": true,
          "output": "[null, null, null, null, -3, null, 0, -2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode12.json",
    "problem_index_in_file": 0,
    "title": "Integer to Roman",
    "description_snippet": "Seven different symbols represent Roman numerals with the following values:\n\nSymbol\tValue\nI\t1\nV\t5\nX\t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines. Steps: Start, input integer n. Then we can have mapping arrays values and symbols. We need to iterate over pairs. Could use loop from high to low value. Use decision for subtractive cases. Let's produce generic algorithm.\n\nPseudo:\n\nStart\n→ Input integer num\n→ Initialize result string\n→ Define arrays values=[1000,900,500,400,100,90,50,40,10,9,5,4,1]\n→ Define symbols=[\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"]\n→ Loop i from 0 to len(values)-1:\n   Decision: if num >= values[i]?\n      Yes → Step: Append symbols[i] to result\n      → Subtract values[i] from num\n      → Repeat decision again (back to check same i)\n      No → Next i\n→ End\n\nExplain each line. Need arrow format.\n\nAlso maybe include decision inside loop using while. But using pseudocode with Decision inside loop.\n\nLet's produce lines.\n\nMake sure each line with virtual code step and comment.\n\nWe'll keep indentation. Use \"Decision:\" and \"Yes →\" \"No →\". Ensure structure. Use Start and End. Provide all.\n...done thinking.\n\nStart // 程式開始執行\n→ Input integer num // 取得要轉換的整數\n→ Initialize result = \"\" // 用於儲存組成的羅馬數字字串\n→ Define values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] // 所有需要檢查的數值\n→ Define symbols = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"] // 對應的羅馬符號\n→ For i from 0 to length(values)-1 // 從最高位到最低位逐項處理\n    Decision: num >= values[i]? // 檢查是否仍能使用此數值\n        Yes → While num >= values[i]? // 只要還能用此符號就繼續\n            → Append symbols[i] to result // 將符號加入結果\n            → Subtract values[i] from num // 減去已轉換的數值\n        No → Continue to next i // 該數值不適用，移到下一個\nEnd // 程式執行結束，result 為最終羅馬數字表示",
      "generated_code": "import sys\nimport re\n\nclass RomanConverter:\n    \"\"\"將整數轉換成羅馬數字的工具類別。\"\"\"\n\n    def __init__(self):\n        # 依照題目定義的數值與符號對應表，從大到小排列\n        self.values = [1000, 900, 500, 400,\n                       100, 90, 50, 40,\n                       10, 9, 5, 4, 1]\n        self.symbols = [\"M\", \"CM\", \"D\", \"CD\",\n                        \"C\", \"XC\", \"L\", \"XL\",\n                        \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    def int_to_roman(self, num: int) -> str:\n        \"\"\"把給定的正整數轉成羅馬數字。\"\"\"\n        result = []\n        for value, symbol in zip(self.values, self.symbols):\n            # 計算能重複使用此符號的次數\n            count = num // value\n            if count:\n                result.append(symbol * count)\n                num -= value * count\n        return \"\".join(result)\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 從輸入中提取第一個整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    num = int(match.group())\n\n    converter = RomanConverter()\n    roman = converter.int_to_roman(num)\n    print(roman)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 3749",
          "expected_output": "\"MMMDCCXLIX\"",
          "success": true,
          "output": "MMMDCCXLIX"
        },
        {
          "example_index": 1,
          "input": "num = 58",
          "expected_output": "\"LVIII\"",
          "success": true,
          "output": "LVIII"
        },
        {
          "example_index": 2,
          "input": "num = 1994",
          "expected_output": "\"MCMXCIV\"",
          "success": true,
          "output": "MCMXCIV"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode165.json",
    "problem_index_in_file": 0,
    "title": "Compare Version Numbers",
    "description_snippet": "Given two version strings, version1 and version2, compare them. A version string consists of revisio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line with explanation. The code describes comparing two version strings. Provide steps like splitting, looping, comparing, handle missing revision as 0. Use arrows and structure. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 version1, version2 // 取得兩個版本字串  \n→ Step 2: 切割 version1 為 list1 以 '.' 為分隔符 // 轉換為修訂版列表  \n→ Step 3: 切割 version2 為 list2 以 '.' 為分隔符 // 轉換為修訂版列表  \n→ Step 4: 計算 maxLen = max(長度(list1), 長度(list2)) // 取較長列表長度  \n→ Decision: 是否存在未比較完的修訂版? // 進行迴圈比較  \n    Yes → Step 5: For i from 0 to maxLen-1  \n        → Step 5.1: 取 val1 = int( list1[i] 若 i < 長度(list1) 否則 0 ) // 取第 i 個修訂值，若缺失則 0  \n        → Step 5.2: 取 val2 = int( list2[i] 若 i < 長度(list2) 否則 0 ) // 同上  \n        → Decision: val1 與 val2 相等? // 判斷兩修訂值  \n            Yes → Continue // 進入下一個修訂版  \n            No → Decision: val1 < val2?  \n                Yes → Step 6: 回傳 -1 // version1 小於 version2  \n                No → Step 7: 回傳 1 // version1 大於 version2  \n    No → Step 8: 回傳 0 // 所有修訂版相等，版本相同  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    \"\"\"\n    比較兩個版本字串。把每個修訂版拆成整數後逐段比較，\n    若一方缺少修訂版則視為 0。返回 -1、1 或 0。\n    \"\"\"\n    def compareVersion(self, version1: str, version2: str) -> int:\n        # 把每個修訂版轉成整數，忽略前導零\n        v1 = [int(part) for part in version1.split('.')]\n        v2 = [int(part) for part in version2.split('.')]\n        # 取兩個列表的最大長度，保證所有段都會被比較\n        max_len = max(len(v1), len(v2))\n        for i in range(max_len):\n            num1 = v1[i] if i < len(v1) else 0\n            num2 = v2[i] if i < len(v2) else 0\n            if num1 < num2:\n                return -1\n            elif num1 > num2:\n                return 1\n        # 所有段都相等\n        return 0\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析兩個版本字串，並輸出比較結果。\n    假設輸入中包含形如 version1 = \"1.2\", version2 = \"1.10\" 的字串。\n    \"\"\"\n    data = sys.stdin.read()\n    # 找出所有被雙引號包住的字串，第一個是 version1，第二個是 version2\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        v1, v2 = parts[0], parts[1]\n    else:\n        # 若輸入格式不符，直接退出\n        return\n    sol = Solution()\n    result = sol.compareVersion(v1, v2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "version1 = \"1.2\", version2 = \"1.10\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "version1 = \"1.0\", version2 = \"1.0.0.0\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode692.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Words",
    "description_snippet": "Given an array of strings words and an integer k, return the k most frequent strings.\n\nReturn the an...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. For problem: given array of strings words and integer k, return k most frequent strings sorted by frequency descending, lexicographically ascending for ties.\n\nWe should produce steps: Count frequencies, create list of pairs, sort by freq desc and lex asc, take top k, return list.\n\nWe need to produce virtual code line by line with arrows.\n\nSo:\n\nStart\n→ Step 1: 建立空字典 freq // 以存放每個字串出現頻率\n→ Step 2: 對每個字串 w in words → freq[w] = freq.get(w,0)+1 // 計算頻率\n→ Step 3: 建立空列表 items // 用於儲存 (word, freq) 組\n→ Step 4: 對每個 key, val in freq → items.append((key, val)) // 轉換為列表\n→ Step 5: Sort items 使用自訂鍵 (-freq, word) // 先按頻率降序，再字典序升序\n→ Step 6: 建立空列表 result // 儲存前 k 個字串\n→ Step 7: 從 i=0 到 min(k, len(items))-1 → result.append(items[i].word) // 取前 k\n→ End // 回傳 result\n\nWe need to include decision arrows maybe not necessary, but we can use loops etc.\n\nWe need each line with virtual code and comment.\n\nMake sure each line has arrow and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freq // 用來儲存每個字串的出現次數  \n→ Step 2: 對每個字串 w in words → freq[w] = freq.get(w, 0) + 1 // 計算頻率  \n→ Step 3: 建立空列表 items // 用於儲存 (word, freq) 的組合  \n→ Step 4: 對每個 key, val in freq → items.append((key, val)) // 將字典轉為列表  \n→ Step 5: Sort items // 依頻率降序，頻率相同時依字典序升序  \n    → Decision: 使用自訂鍵 (-val, key) // 先排序頻率的反向值，再按字典序  \n        Yes → items.sort(key=lambda x: (-x[1], x[0])) // 執行排序  \n→ Step 6: 建立空列表 result // 用來儲存最常見的 k 個字串  \n→ Step 7: 從 i = 0 到 min(k, len(items)) - 1 → result.append(items[i][0]) // 取前 k 個字串  \nEnd // 程式執行結束並回傳 result",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        \"\"\"\n        找出最常見的 k 個字串，先依頻率從高到低排序，\n        若頻率相同則按字典序升序。\n        \"\"\"\n        # 1. 計算每個字串出現的頻率\n        count = Counter(words)\n        # 2. 依頻率降序、字典序升序排序\n        sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0]))\n        # 3. 取前 k 個字串\n        return [word for word, freq in sorted_words[:k]]\n\ndef main():\n    \"\"\"\n    讀取標準輸入並解析成 words 與 k。\n    輸入範例：\n        words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入切成 words 與 k 的兩部分\n    parts = data.split(', k =')\n    words_part = parts[0].strip()\n    k_part = parts[1].strip() if len(parts) > 1 else ''\n\n    # 去除前面的 words = 標記\n    if words_part.startswith('words'):\n        words_part = words_part[words_part.find('=') + 1:].strip()\n\n    # 轉成 Python 物件\n    words = ast.literal_eval(words_part)\n    k = int(k_part)\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.topKFrequent(words, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "success": true,
          "output": "['i', 'love']"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "success": true,
          "output": "['the', 'is', 'sunny', 'day']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode728.json",
    "problem_index_in_file": 0,
    "title": "Self Dividing Numbers",
    "description_snippet": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps per line. Provide structure: Start, Decision, etc. We need to process range left to right, check each number for self-dividing property: no zero digits and divisible by each digit. Collect in list. Return list. So steps: Start, initialize result list, loop from left to right, set num = current, flag selfDividing = True, temp = num, while temp > 0: digit = temp % 10, if digit==0 or num % digit !=0: selfDividing = False; break; temp //=10; after loop if selfDividing: append to list; after loop return list; End.\n\nProvide each line with explanation. Use arrow lines. Let's craft. Use \"→\" arrow after Start. Use Decision: etc. For loops we might use \"→ Loop: for i from left to right\" or similar. Use consistent style.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化空列表 Result ← [] // 用於儲存所有自除數  \n→ 循環 i 從 left 到 right // 逐個檢查每個數字  \n  → 設定 flag ← True // 初始假設 i 是自除數  \n  → temp ← i // 副本用於逐位判斷  \n  → Decision: temp 是否為 0? // 判斷是否已遍歷完所有位數  \n    Yes → // 若 temp 為 0，表示已檢查完所有位  \n     → 循環結束 // 返回上一層 Loop  \n    No → // 還有位數未處理  \n     → digit ← temp % 10 // 取得最低位數字  \n     → Decision: digit 是否為 0? // 零不允許出現  \n       Yes → flag ← False // 設置為非自除數  \n       No  → Decision: i % digit 是否為 0? // 檢查可整除性  \n        Yes → // 可整除，繼續檢查下一位  \n        No  → flag ← False // 不是自除數  \n       → temp ← temp // 取餘數，移除最低位  \n       → temp ← temp // 重新取餘數，並重複 Decision  \n       → temp ← temp // 繼續循環直到 temp 為 0  \n  → Decision: flag 是否為 True? // 判斷整個數字是否自除  \n    Yes → Result ← Result ∪ {i} // 將自除數加入結果集  \n    No → // 不是自除數，直接跳過  \n→ End // 所有數字檢查完畢  \n→ 返回 Result // 回傳自除數列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int):\n        \"\"\"\n        找出區間 [left, right] 內所有自除數，並回傳為 list。\n        \"\"\"\n        res = []\n        for num in range(left, right + 1):\n            temp = num\n            divisible = True\n            while temp > 0:\n                digit = temp % 10\n                if digit == 0 or num % digit != 0:\n                    divisible = False\n                    break\n                temp //= 10\n            if divisible:\n                res.append(num)\n        return res\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入字串中抽取兩個整數，假設格式為『left = a, right = b』或相似形式。\n    \"\"\"\n    nums = list(map(int, re.findall(r'\\d+', text)))\n    if len(nums) >= 2:\n        return nums[0], nums[1]\n    raise ValueError(\"輸入格式不正確，應包含兩個整數\")\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    left, right = parse_input(data)\n    sol = Solution()\n    result = sol.selfDividingNumbers(left, right)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 1, right = 22",
          "expected_output": "[1,2,3,4,5,6,7,8,9,11,12,15,22]",
          "success": true,
          "output": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"
        },
        {
          "example_index": 1,
          "input": "left = 47, right = 85",
          "expected_output": "[48,55,66,77]",
          "success": true,
          "output": "[48, 55, 66, 77]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1296.json",
    "problem_index_in_file": 0,
    "title": "Divide Array in Sets of K Consecutive Numbers",
    "description_snippet": "Given an array of integers nums and a positive integer k, check whether it is possible to divide thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: Given array nums and integer k, check if can partition into sets of k consecutive numbers. This is Leetcode 1296. Approach: Count frequency using map, sort keys. For each number, try to use its count to create sequences. For each x in sorted keys: while freq[x] > 0: for i in range(k): if freq[x+i]==0 => fail; else decrement. Complexity O(n log n). We'll produce virtual code steps accordingly. Use virtual code syntax: Start, → Step, Decision, etc.\n\nLet's produce line-by-line virtual code with explanations. Ensure no actual code, just steps. Use arrow arrow.\n\nWe'll produce:\n\nStart // 開始\n→ Step 1: 建立字典 count 以儲存每個數字的出現次數 // 建立頻率表\n→ Step 2: 對 nums 中每個數字 x，count[x]++ // 填充頻率\n→ Step 3: 將 count 的鍵值按升序排序為 sorted_nums // 需要依序處理\n→ Decision: 如果 k > len(nums) 或 len(nums) % k != 0? // 檢查基本條件\n    Yes → Step 4: 回傳 False // 無法分組\n    No  → Decision: 是否所有鍵值相同? // 檢查全是相同數字\n        Yes → Step 5: 回傳 len(nums) == k // 全部相同時只能一組\n        No  → Step 6: 開始處理每個數字 // 進入主迴圈\n→ For each x in sorted_nums: // 逐個檢查\n    → Decision: 若 count[x] == 0? // 已被消耗\n        Yes → Next // 跳過\n        No  → Decision: 若 count[x] > 0? // 需要建立新序列\n            Yes → Step 7: 為 i in 0..k-1: // 建立長度 k 的序列\n                → Decision: 若 count[x+i] == 0? // 缺少連續數字\n                    Yes → Step 8: 回傳 False // 無法完成\n                    No  → Step 9: count[x+i]-- // 消耗\n            → Next // 完成此序列\n    → Next\n→ Step 10: 回傳 True // 所有序列完成\n\nBut need arrow syntax. We can use → Step, Decision:..., Yes→, No→. For loops we can use \"→ Loop: x in sorted_nums\". But example uses simple arrow.\n\nLet's craft each line.\n\nMake sure to not use actual code but pseudocode style. We'll still show operations but not actual code.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 count 以儲存每個數字的出現次數 // 建立頻率表  \n→ Step 2: 對 nums 中每個數字 x，執行 count[x]++ // 填充頻率表  \n→ Step 3: 取得 count 的鍵值並按升序排序為 sorted_nums // 方便依序處理  \n→ Decision: 是否符合基本條件？  // 檢查 k 是否超過數列長度或長度不能被 k 整除  \n    Yes → Step 4: 回傳 False // 無法分組  \n    No  → Decision: 是否所有鍵值相同？ // 檢查全為同一數字的特殊情況  \n        Yes → Step 5: 回傳 len(nums) == k // 全部相同時只能成為一組  \n        No  → Step 6: 進入主處理流程 // 開始處理每個數字  \n→ Loop: x 在 sorted_nums 之中 // 逐個檢查每個起始數字  \n    → Decision: 若 count[x] == 0? // 已被消耗完畢  \n        Yes → Next // 跳過此數字  \n        No  → Decision: count[x] > 0? // 需要用此數字開始新序列  \n            Yes → Step 7: 為 i 從 0 到 k-1 執行  \n                → Decision: 若 count[x+i] == 0? // 缺少連續數字  \n                    Yes → Step 8: 回傳 False // 無法完成分組  \n                    No  → Step 9: count[x+i]-- // 消耗一次  \n            → Next // 完成此序列的所有減少  \n    → Next // 移至下個 x  \n→ Step 10: 回傳 True // 所有序列均已成功建立，符合要求  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isPossibleDivide(self, nums, k):\n        # 先檢查總長度能否被 k 整除\n        if len(nums) % k != 0:\n            return False\n\n        count = Counter(nums)\n        # 依照數字大小排序處理\n        for num in sorted(count):\n            if count[num] > 0:\n                need = count[num]\n                # 嘗試建立從 num 開始長度為 k 的序列\n                for val in range(num, num + k):\n                    if count[val] < need:\n                        return False\n                    count[val] -= need\n        return True\n\ndef parse_input(inp: str):\n    \"\"\"\n    從輸入字串中提取 nums 列表和 k 整數。\n    假設輸入格式為 'nums = [1,2,3], k = 4' 或類似形式。\n    \"\"\"\n    # 取得 nums 中的所有整數\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', inp)\n    if not nums_match:\n        raise ValueError(\"Cannot find nums list in input\")\n    nums_str = nums_match.group(1)\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n\n    # 取得 k 整數\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', inp)\n    if not k_match:\n        raise ValueError(\"Cannot find k value in input\")\n    k = int(k_match.group(1))\n\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    try:\n        nums, k = parse_input(input_data)\n    except ValueError as e:\n        print(\"false\")\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.isPossibleDivide(nums, k)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,3,4,4,5,6], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode238.json",
    "problem_index_in_file": 0,
    "title": "Product of Array Except Self",
    "description_snippet": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step, no actual code, using Start, End, Decision, arrows, etc. Steps: input array, compute left products, right products, result. Need O(n). Without division. So algorithm: first compute left product array where left[i] = product of nums[0..i-1], with left[0]=1. Then compute right product on the fly: maintain right=1 and answer[i] = left[i] * right. After each iteration update right*=nums[i]. So produce steps. Provide explanation after each line. Also handle array length n. Use variables: n, left array, answer array, right. Provide decision maybe none.\n\nLet's produce step lines.\n\nUse Start // start.\n\n→ Step 1: Input array nums and determine its length n // read data.\n\n→ Step 2: Initialize array left of size n // to store left products\n\n→ Step 3: Set left[0] = 1 // product of elements before first\n\n→ Decision: For i from 1 to n-1? // iterate to fill left\n\n    Yes → Step 4: left[i] = left[i-1] * nums[i-1] // product of all elements before i\n\n    No → continue // end loop\n\n→ Step 5: Initialize array answer of size n // final result\n\n→ Step 6: Set right = 1 // product of elements after current index\n\n→ Decision: For i from 0 to n-1? // iterate over array\n\n    Yes → Step 7: answer[i] = left[i] * right // multiply left product and right product\n\n    Yes → Step 8: right = right * nums[i] // update right for next index\n\n    No → continue // end loop\n\n→ End // return answer\n\nBut we need step numbering with \"Step\" maybe. Use arrow \"→\". Use indentation. Provide explanation after //.\n\nNeed each line includes virtual code step and explanation.\n\nEnsure each line includes arrow? The example shows each line starts with \"→\". For Start and End no arrow? In example Start had no arrow. Decision lines had arrow for Yes/No lines. We'll follow same style.\n\nAlso we might want to mention that left array may be reused to save space? But they want algorithm; it's okay.\n\nLet's produce final answer.\n\nEnsure each line is single line. Use step labels accordingly.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums and determine its length n // 取得輸入陣列及其長度  \n→ Step 2: Initialize array left of size n // 用來存放左側積的暫存陣列  \n→ Step 3: Set left[0] = 1 // 第一個元素前面沒有數字，積為 1  \n→ Decision: i from 1 to n-1? // 逐個填充左側積  \n  Yes → Step 4: left[i] = left[i-1] * nums[i-1] // 左側所有元素的積  \n  No  → // 結束左側積計算  \n→ Step 5: Initialize array answer of size n // 用來儲存最終答案  \n→ Step 6: Set right = 1 // 右側積初始值，起始為 1  \n→ Decision: i from 0 to n-1? // 逐個計算答案並更新右側積  \n  Yes → Step 7: answer[i] = left[i] * right // 左乘右得到答案  \n  Yes → Step 8: right = right * nums[i] // 更新右側積為前一個積再乘以 nums[i]  \n  No  → // 結束答案計算  \nEnd // 程式執行結束，返回 answer",
      "generated_code": "import sys\nimport ast\n\ndef product_except_self(nums):\n    \"\"\"Return product of all elements except self for each position.\"\"\"\n    n = len(nums)\n    res = [1] * n\n\n    # left-to-right pass: store left products\n    left = 1\n    for i in range(n):\n        res[i] = left\n        left *= nums[i]\n\n    # right-to-left pass: multiply by right products\n    right = 1\n    for i in range(n - 1, -1, -1):\n        res[i] *= right\n        right *= nums[i]\n\n    return res\n\ndef parse_input(line):\n    \"\"\"Extract list of integers from a string like 'nums = [1,2,3]'.\"\"\"\n    line = line.strip()\n    start = line.find('[')\n    if start == -1:\n        return []\n    arr_str = line[start:]\n    return ast.literal_eval(arr_str)\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    nums = parse_input(data)\n    result = product_except_self(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "[24,12,8,6]",
          "success": true,
          "output": "[24, 12, 8, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,1,0,-3,3]",
          "expected_output": "[0,0,9,0,0]",
          "success": true,
          "output": "[0, 0, 9, 0, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode321.json",
    "problem_index_in_file": 0,
    "title": "Create Maximum Number",
    "description_snippet": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 re...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for this algorithm: create maximum number of length k from two arrays with relative order preserved. Classic problem: \"Create Maximum Number\". Steps: use helper function to pick max subsequence of length t from array, then merge two subsequences, then iterate over possible splits of k between nums1 and nums2: i from max(0, k-n) to min(k, m). For each split, pick subsequence of length i from nums1, subsequence of length k-i from nums2, merge, and keep best by lex compare.\n\nWe need to produce virtual code lines with comments. Each line: \"虛擬碼步驟 // 解釋\".\n\nNeed to use arrows etc. Let's structure: Start, Step 1: define function maxSubsequence(array, t), etc.\n\nWe need to produce the algorithm, not actual code but steps. Let's write in order.\n\nInclude decisions, loops, merges.\n\nMake sure each line includes arrow \"→\" before step.\n\nWe need to respect format: each line: \"虛擬碼步驟 // 解釋\". So we can have \"Start // 程式開始\". Then \"→ Step 1: 取得 nums1、nums2、k // 讀入輸入\". etc.\n\nWe should show loops and decisions with indentation. We can show \"→ Decision:\" lines.\n\nMake sure to use arrow for sub-steps: maybe we can indent by spaces but maintain arrow. For nested, maybe use spaces. Eg:\n\n→ Decision: i in [max(0, k-n) .. min(k, m)]? But we can express as loop.\n\nLet's produce something like:\n\nStart\n→ Step 1: 定義 helper maxSubsequence(array, t) // 取得最大子序列\n    → Step 1.1: 初始化堆疊 stack // 用來保存選取的位子\n    → Step 1.2: for each index idx in array\n        → Decision: stack not empty AND stack.last < array[idx] AND remaining elements allow removal? // 判斷是否可以丟棄較小數字\n            Yes → Pop stack // 移除\n        → Decision: stack.size < t? // 是否還需要補位\n            Yes → Push array[idx] onto stack // 取入\n    → Step 1.3: 返回 stack 的前 t 個元素 // 得到子序列\n...\n\nBut we need to use \"→\" for each step. Indentation not necessary but can use spaces for clarity. Provide short explanation.\n\nAlso need a merge function.\n\nLet's craft.\n\nWe will produce steps sequentially:\n\nStart\n→ Step 1: 讀入 nums1, nums2, k\n→ Step 2: 定義 function maxSubsequence(arr, length) //...\n→ Step 3: 定義 function merge(sub1, sub2) //...\n→ Step 4: 初始化 best = empty array\n→ Step 5: for i from max(0, k - len(nums2)) to min(k, len(nums1))\n    → Step 5.1: sub1 = maxSubsequence(nums1, i)\n    → Step 5.2: sub2 = maxSubsequence(nums2, k - i)\n    → Step 5.3: candidate = merge(sub1, sub2)\n    → Decision: candidate > best? // 比較字典序\n        Yes → best = candidate\n→ End // 回傳 best\n\nNeed to show lexicographic comparison in merge? The merge function uses greedy to pick bigger next digit, tie-break using remaining digits comparison.\n\nAdd details inside merge: While sub1 or sub2 not empty, decide which next digit to pick: if sub1 > sub2 lexicographically, pick sub1[0], else sub2[0].\n\nWe need to show that.\n\nWe should produce each step of merge as part of function.\n\nBut the instruction says: \"逐行地產生對應的虛擬碼\". So we need to produce step by step.\n\nWe may present functions as blocks with sub-steps.\n\nLet's do:\n\n→ Step 2: 定義 function maxSubsequence(arr, length)\n    → Step 2.1: 初始化 stack = []\n    → Step 2.2: for idx, digit in enumerate(arr)\n        → Decision: stack not empty AND stack[-1] < digit AND (len(stack) -1 + len(arr)-idx) >= length\n            Yes → Pop stack\n        → Decision: len(stack) < length\n            Yes → Push digit\n    → Step 2.3: 返回 stack\n\n→ Step 3: 定義 function merge(sub1, sub2)\n    → Step 3.1: 初始化 result = []\n    → Step 3.2: while sub1 not empty OR sub2 not empty\n        → Decision: sub1 > sub2? // lex compare\n            Yes → Append sub1[0] to result; remove first from sub1\n            No  → Append sub2[0] to result; remove first from sub2\n    → Step 3.3: 返回 result\n\nBut to compare sub1 > sub2 lexicographically, we might need to use remaining lists. That can be done by comparing slices: sub1 > sub2. Represent as decision.\n\nOk.\n\nFinally loop over splits.\n\nWe need to show the decision to update best.\n\nComparison best < candidate.\n\nWe need to produce each line.\n\nLet's write in Chinese explanation.\n\nMake sure to include Start and End.\n\nNow produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入 nums1, nums2, k // 取得輸入的兩個數字陣列與目標長度  \n\n→ Step 2: 定義函式 maxSubsequence(arr, length) // 取得長度為 length 的最大子序列  \n    → Step 2.1: 初始化 stack = [] // 用來儲存已選擇的位子  \n    → Step 2.2: 逐個遍歷 arr 中的每個 digit  \n        → Decision: stack 非空 且 stack[-1] < digit 且 (len(stack)-1 + len(arr)-idx) >= length // 可以刪除較小數字且仍能填滿長度  \n            Yes → Pop stack // 移除較小數字  \n        → Decision: len(stack) < length // 仍需要補位  \n            Yes → Append digit to stack // 取入新數字  \n    → Step 2.3: 回傳 stack // 取得最大子序列  \n\n→ Step 3: 定義函式 merge(sub1, sub2) // 合併兩個子序列得到最大的排列  \n    → Step 3.1: 初始化 result = [] // 合併結果  \n    → Step 3.2: 直到 sub1 與 sub2 都為空  \n        → Decision: sub1 lexicographically 大於 sub2? // 比較剩餘序列的字典序  \n            Yes → Append sub1[0] to result；從 sub1 刪除首項  \n            No  → Append sub2[0] to result；從 sub2 刪除首項  \n    → Step 3.3: 回傳 result // 合併完成  \n\n→ Step 4: 初始化 best = [] // 儲存目前為止最優的結果  \n\n→ Step 5: 對 i 從 max(0, k - len(nums2)) 到 min(k, len(nums1)) 逐一迭代  \n    → Step 5.1: sub1 = maxSubsequence(nums1, i) // 從 nums1 取 i 個數字  \n    → Step 5.2: sub2 = maxSubsequence(nums2, k - i) // 從 nums2 取 k-i 個數字  \n    → Step 5.3: candidate = merge(sub1, sub2) // 合併得到長度 k 的排列  \n    → Decision: candidate lexicographically 大於 best? // 判斷是否為新的最佳答案  \n        Yes → best = candidate // 更新最佳結果  \n\nEnd // 程式執行結束，返回 best 作為答案",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxNumber(self, nums1, nums2, k):\n        def pick_max(nums, t):\n            drop = len(nums) - t\n            stack = []\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:t]\n\n        def merge(a, b):\n            a = a[:]\n            b = b[:]\n            res = []\n            while a or b:\n                if a > b:\n                    res.append(a.pop(0))\n                else:\n                    res.append(b.pop(0))\n            return res\n\n        best = []\n        m, n = len(nums1), len(nums2)\n        for i in range(max(0, k - n), min(k, m) + 1):\n            sub1 = pick_max(nums1, i)\n            sub2 = pick_max(nums2, k - i)\n            candidate = merge(sub1, sub2)\n            if candidate > best:\n                best = candidate\n        return best\n\ndef parse_input(input_str):\n    # Replace assignments with dictionary syntax\n    input_str = input_str.replace('nums1 =', 'nums1:')\n    input_str = input_str.replace('nums2 =', 'nums2:')\n    input_str = input_str.replace('k =', 'k:')\n    # Wrap with braces to form a dict literal\n    input_str = '{' + input_str + '}'\n    # Safely evaluate the dictionary\n    data = eval(input_str, {})\n    return data['nums1'], data['nums2'], data['k']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    nums1, nums2, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.maxNumber(nums1, nums2, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5",
          "expected_output": "[9,8,6,5,3]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpcuijr8vg.py\", line 50, in <module>\n    nums1, nums2, k = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpcuijr8vg.py\", line 45, in parse_input\n    data = eval(input_str, {})\n           ^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums1' is not defined"
        },
        {
          "example_index": 1,
          "input": "nums1 = [6,7], nums2 = [6,0,4], k = 5",
          "expected_output": "[6,7,6,0,4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpjvq_d6k8.py\", line 50, in <module>\n    nums1, nums2, k = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjvq_d6k8.py\", line 45, in parse_input\n    data = eval(input_str, {})\n           ^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums1' is not defined"
        },
        {
          "example_index": 2,
          "input": "nums1 = [3,9], nums2 = [8,9], k = 3",
          "expected_output": "[9,8,9]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpoycr0oz5.py\", line 50, in <module>\n    nums1, nums2, k = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpoycr0oz5.py\", line 45, in parse_input\n    data = eval(input_str, {})\n           ^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums1' is not defined"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode343.json",
    "problem_index_in_file": 0,
    "title": "Integer Break",
    "description_snippet": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the pro...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: given integer n, break into sum of k positive integers (k >= 2) maximize product. Classic integer break problem. Approach: dynamic programming or greedy: for n >= 4, optimal product is 3^(a) * 4^(b) where we use as many 3's as possible except remainder 1 => replace 3+1 with 2+2.\n\nWe'll produce steps: Start → Check n <= 3? → Return 0 or n-1? Actually integer break: if n <= 3 return 0? Wait typical problem returns 0? But in many LeetCode, integerBreak returns max product of at least two positive integers; For n=2 =>1, n=3=>2, n=4=>4. So algorithm: if n <= 3 return n-1.\n\nThen compute count3 = n / 3. If n % 3 == 1, reduce one 3 and add 4: count3 -=1; count4 =1 else count4 =0. If n % 3 ==2: count4=0; remainder 2. Then product = 3^count3 * 4^count4 * remainder.\n\nBut we may produce product by repeated multiplication.\n\nLet's write virtual steps. Use decision branches. Provide explanation comments.\n\nLet's produce:\n\nStart\n→ Decision: If n <= 3? // n small special case\n    Yes → Step 1: Return n-1 // product for 2->1,3->2\n    No  → Step 2: Initialize count3 = n / 3 // integer division\n    → Decision: If n % 3 == 1? // remainder 1\n        Yes → Step 3: count3 -= 1; // replace 3+1 with 2+2\n        Step 4: count4 = 1; // one group of 4\n        No → Decision: If n % 3 == 2? // remainder 2\n            Yes → Step 5: count4 = 0; // no 4\n            Step 6: remainder = 2;\n            No → Step 7: count4 = 0; remainder = 1? Actually if remainder 0, no extra factor\n    → Step 8: product = 1 // initialize product\n    → Decision: While count3 > 0? // multiply by 3\n        Yes → product *= 3; count3 -= 1; \n        No → \n    → Decision: While count4 > 0? // multiply by 4\n        Yes → product *= 4; count4 -= 1;\n        No →\n    → Decision: If remainder > 0?\n        Yes → product *= remainder;\n    → Step 9: Return product\n\nBut need to output each line with //.\n\nLet's produce with arrow structure.\n\nWe need to ensure the format: each line: \"虛擬碼步驟 // 解釋\".\n\nAlso using arrow for decisions. Example: \"→ Decision: If n <= 3? //\"\n\nWe also need to use Yes →, No → for branches. Use indentation for nested decisions? In sample they indent. We can mimic.\n\nLet's generate steps.\n\nAlso, we must avoid actual code; but we can express pseudocode.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: n <= 3? // 對於極小的 n，只能直接返回已知最大值  \n  Yes → Step 1: Return n-1 // n=2 時返回 1，n=3 時返回 2  \n  No  → Step 2: count3 = n / 3 // 以 3 為基礎，計算能分成多少個 3  \n   → Decision: n % 3 == 1? // 檢查餘數是否為 1  \n     Yes → Step 3: count3 -= 1 // 把一個 3 與餘數 1 合成 4，避免 3+1  \n       → Step 4: count4 = 1 // 只需要一個 4  \n     No  → Decision: n % 3 == 2? // 檢查餘數是否為 2  \n       Yes → Step 5: count4 = 0; remainder = 2 // 直接使用餘數 2  \n       No  → Step 6: count4 = 0; remainder = 0 // 沒餘數，僅使用 3  \n           \n    → Step 7: product = 1 // 初始化乘積  \n    → Decision: count3 > 0? // 把所有 3 相乘  \n      Yes → product *= 3; count3 -= 1;  \n      No →  \n    → Decision: count4 > 0? // 把所有 4 相乘  \n      Yes → product *= 4; count4 -= 1;  \n      No →  \n    → Decision: remainder > 0? // 若有餘數，乘上它  \n      Yes → product *= remainder;  \n      No →  \n    → Step 8: Return product // 回傳最大乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef integer_break(n: int) -> int:\n    \"\"\"\n    將整數 n 斷裂為至少兩個正整數之和，並使乘積最大。\n    \"\"\"\n    if n <= 3:\n        # n = 2 -> 1,  n = 3 -> 2\n        return n - 1\n    product = 1\n    # 盡量多用 3，除非剩餘 4 或 2\n    while n > 4:\n        product *= 3\n        n -= 3\n    return product * n\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，支援 \"n = 10\" 或純數字格式\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 若包含 '='，則取等號右側作為數字\n    if '=' in data:\n        _, value = data.split('=', 1)\n        n_str = value.strip()\n    else:\n        n_str = data.strip()\n    try:\n        n = int(n_str)\n    except ValueError:\n        # 若轉換失敗，直接結束\n        sys.exit(1)\n    result = integer_break(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 10",
          "expected_output": "36",
          "success": true,
          "output": "36"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode438.json",
    "problem_index_in_file": 0,
    "title": "Find All Anagrams in a String",
    "description_snippet": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for sliding window. Outline: compute freq of p, window freq, iterate i over s, add char, if window size > p length remove left, compare freq, record start index. Use dictionary or array of size 26. Virtual code lines with arrows and explanations. Provide step-by-step. Ensure we include Start and End. Use Decision. Use Yes→ and No→ where needed. Provide explanation after each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 p 的字元頻率表 freqP，並計算 p 的長度 lenP // 先統計 p 的每個字母出現次數  \n→ Step 2: 初始化 s 的滑動窗口字元頻率表 windowFreq，並設置左指標 left = 0 // 用於滑動窗口的字頻  \n→ Step 3: 建立答案陣列 result = [] // 用於儲存所有符合條件的起始索引  \n→ Decision: 若 s 的長度 < lenP? // 檢查 s 是否足夠長以容納 p 的任何排列  \n    Yes → Step 4: End // 如果 s 太短，直接結束，無結果  \n    No  → // 繼續往下處理  \n→ Step 5: 逐個索引 i 從 0 到 s.length - 1 進行迭代 // 對 s 的每個字符進行滑動窗口更新  \n    → Step 6: 在 windowFreq 中增加 s[i] 的計數 // 將新進入窗口的字符加入頻率表  \n    → Decision: 如果 i - left + 1 > lenP? // 檢查窗口是否已超過 p 的長度  \n        Yes →  \n            → Step 7: 在 windowFreq 中減少 s[left] 的計數 // 移除最左邊的字符，縮小窗口  \n            → Step 8: left = left + 1 // 左指標右移，維持窗口大小  \n        No → // 窗口大小未超過，保持不變  \n    → Decision: 如果窗口大小等於 lenP? // 確保窗口已達到 p 的長度，才進行比較  \n        Yes →  \n            → Step 9: 如果 windowFreq 與 freqP 相等? // 判斷兩個頻率表是否完全一致  \n                Yes → Step 10: result.append(left) // 將左指標作為有效起始位置加入結果  \n                No → // 不相等，無需任何操作  \n        No → // 窗口尚未到達完整長度，等待進一步字符  \n→ Step 11: End // 程式執行結束  \n→ Step 12: 返回 result // 輸出所有符合條件的起始索引集合",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str):\n        ns, np = len(s), len(p)\n        if ns < np:\n            return []\n\n        p_count = Counter(p)\n        s_count = Counter(s[:np])\n        res = []\n\n        if s_count == p_count:\n            res.append(0)\n\n        for i in range(1, ns - np + 1):\n            left_char = s[i - 1]\n            right_char = s[i + np - 1]\n\n            # Remove left_char from window\n            s_count[left_char] -= 1\n            if s_count[left_char] == 0:\n                del s_count[left_char]\n\n            # Add right_char to window\n            s_count[right_char] += 1\n\n            if s_count == p_count:\n                res.append(i)\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 尋找所有雙引號中的字串，預期會得到兩個元素：s 和 p\n    strs = re.findall(r'\"(.*?)\"', data)\n    if len(strs) >= 2:\n        s, p = strs[0], strs[1]\n    else:\n        # 若沒有雙引號，嘗試用空白或逗號分隔\n        parts = re.split(r',|\\s+', data)\n        s = parts[0]\n        p = parts[1] if len(parts) > 1 else ''\n    solution = Solution()\n    result = solution.findAnagrams(s, p)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"cbaebabacd\", p = \"abc\"",
          "expected_output": "[0,6]",
          "success": true,
          "output": "[0, 6]"
        },
        {
          "example_index": 1,
          "input": "s = \"abab\", p = \"ab\"",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode467.json",
    "problem_index_in_file": 0,
    "title": "Unique Substrings in Wraparound String",
    "description_snippet": "We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so b...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem: count unique non-empty substrings of s that are present in infinite wraparound string base. Known solution: for each letter, track max length of substring ending at that letter that appears in base. Then answer is sum of max lengths.\n\nWe need to produce algorithm in pseudocode. Steps:\n\n- Initialize array maxLen[26] = 0.\n- prevLen = 0\n- For i from 0 to len(s)-1:\n    - if i>0 and (s[i] - s[i-1] == 1 mod 26):\n        prevLen += 1\n      else:\n        prevLen = 1\n    - idx = s[i] - 'a'\n    - if prevLen > maxLen[idx]: maxLen[idx] = prevLen\n- After loop, sum all maxLen values.\n- Return sum.\n\nWe should produce virtual code line by line, with explanation. Use arrows. Start, End.\n\nLet's produce. Use each step on separate line. Provide comments after space. Use arrow formatting.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立陣列 maxLen[26] = 0 // 每個字母對應的最大連續子串長度  \n→ Step 2: prevLen ← 0 // 追蹤目前符合條件的子串長度  \n→ Decision: s 是否為空? // 檢查輸入字串是否為空  \n    Yes → Step 3: 回傳 0 // 空字串不含子串，直接回傳結果  \n    No → Step 4: For i from 0 to len(s)-1 // 逐字遍歷字串  \n        → Step 5: If i>0 AND (s[i] - s[i-1] == 1 OR s[i]== 'a' AND s[i-1]=='z')  \n            Yes → prevLen ← prevLen + 1 // 連續字母，長度加 1  \n            No  → prevLen ← 1 // 不連續，重置為 1  \n        → Step 6: idx ← ord(s[i]) - ord('a') // 取得字母索引  \n        → Decision: prevLen > maxLen[idx]? // 比較是否更新最大長度  \n            Yes → maxLen[idx] ← prevLen // 更新最大長度  \n            No → // 保持舊值  \n        → Step 7: // 迴圈結束  \n→ Step 8: result ← sum(maxLen) // 所有字母最大長度相加即為答案  \n→ Step 9: 回傳 result // 回傳唯一子串數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findSubstringInWraproundString(self, s: str) -> int:\n        # dp[i] 表示以字母 chr(i + ord('a')) 結尾的最大子串長度\n        dp = [0] * 26\n        k = 0  # 目前連續子串長度\n\n        for i in range(len(s)):\n            if i > 0 and (ord(s[i]) - ord(s[i-1])) % 26 == 1:\n                k += 1\n            else:\n                k = 1\n            idx = ord(s[i]) - ord('a')\n            if k > dp[idx]:\n                dp[idx] = k\n\n        return sum(dp)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，並從中提取字串內容\n    data = sys.stdin.read().strip()\n    # 尋找第一個雙引號之間的內容\n    match = re.search(r'\"(.*?)\"', data)\n    s = match.group(1) if match else \"\"\n\n    sol = Solution()\n    result = sol.findSubstringInWraproundString(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode219.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate II",
    "description_snippet": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. Must not output actual code, just virtual steps. Use Start, Decision, arrows. Use \"→\" after Start? In example, Start line has no arrow, then \"→ Step\". Use Step for steps. Use Decision for if conditions. Use Yes → / No → branches. Use End. Must include explanation after //.\n\nWe need to implement algorithm: sliding window or hash set. We can propose algorithm: iterate array, maintain hash set of last k elements. For each element, check if present in set. If yes return true. After processing, add to set. If set size > k, remove oldest element. At end return false.\n\nWe produce virtual steps: Start, Step 1: Initialize empty set. Step 2: Iterate index from 0 to len-1. Decision: if element exists in set? Yes -> return true. No -> continue. Add element to set. Decision: if set size > k? Yes -> remove element at index - k. No -> nothing. Continue. End with return false.\n\nLet's produce with virtual code:\n\nStart // 程式開始執行\n→ Step 1: 初始化空集合 seen // 用來儲存最近 k 個元素\n→ Step 2: 從索引 0 開始遍歷陣列 nums // 逐個檢查每個元素\n    → Decision: nums[i] 是否已存在於 seen? // 判斷是否已出現過\n        Yes → Step 3: 回傳 true // 找到符合條件的重複元素，直接返回\n        No  → Step 4: 將 nums[i] 加入 seen // 把當前元素加入集合\n    → Decision: seen 的大小是否大於 k? // 檢查集合是否超過窗口大小\n        Yes → Step 5: 移除 nums[i - k] 從 seen // 刪除最舊的元素以維持窗口\n        No  → // 不需要移除，集合長度仍在限制內\n    → Step 6: 繼續到下一個索引 // 進入下一輪迴圈\n→ Step 7: 所有元素已檢查完畢，未發現符合條件 // 循環結束\n→ Step 8: 回傳 false // 沒有符合條件的索引對\nEnd // 程式執行結束\n\nBut we must follow format: Each line: virtual code step, space, // explanation.\n\nWe also need to use Decision indentation. Use tab? In example they indent inside decision: Yes → Step, No → Step. So we need to replicate that. We need to use arrows '→', 'Yes →', 'No →'. Use spaces accordingly.\n\nLet's craft output lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化空集合 seen // 用於儲存最近 k 個元素\n→ Step 2: 從索引 0 開始遍歷陣列 nums // 逐個檢查每個元素\n    → Decision: nums[i] 是否已存在於 seen? // 判斷是否已出現過\n        Yes → Step 3: 回傳 true // 找到符合條件的重複元素，直接返回\n        No  → Step 4: 將 nums[i] 加入 seen // 把當前元素加入集合\n    → Decision: seen 的大小是否大於 k? // 檢查集合是否超過窗口大小\n        Yes → Step 5: 移除 nums[i - k] 從 seen // 刪除最舊的元素以維持窗口\n        No  → // 不需要移除，集合長度仍在限制內\n    → Step 6: 繼續到下一個索引 // 進入下一輪迴圈\n→ Step 7: 所有元素已檢查完畢，未發現符合條件 // 循環結束\n→ Step 8: 回傳 false // 沒有符合條件的索引對\nEnd // 程式執行結束\n\nEnsure each line ends with //. Provide the explanation. The arrow for Step 6 is fine.\n\nMake sure we don't output actual code. Use \"Step 1:\" etc. Good. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空集合 seen // 用於儲存最近 k 個元素  \n→ Step 2: 從索引 0 開始遍歷陣列 nums // 逐個檢查每個元素  \n  → Decision: nums[i] 是否已存在於 seen? // 判斷是否已出現過  \n    Yes → Step 3: 回傳 true // 找到符合條件的重複元素，直接返回  \n    No  → Step 4: 將 nums[i] 加入 seen // 把當前元素加入集合  \n  → Decision: seen 的大小是否大於 k? // 檢查集合是否超過窗口大小  \n    Yes → Step 5: 移除 nums[i - k] 從 seen // 刪除最舊的元素以維持窗口  \n    No  → // 不需要移除，集合長度仍在限制內  \n  → Step 6: 繼續到下一個索引 // 進入下一輪迴圈  \n→ Step 7: 所有元素已檢查完畢，未發現符合條件 // 循環結束  \n→ Step 8: 回傳 false // 沒有符合條件的索引對  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        last_pos = {}\n        for i, num in enumerate(nums):\n            if num in last_pos and i - last_pos[num] <= k:\n                return True\n            last_pos[num] = i\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to parse input like: nums = [1,2,3,1], k = 3\n    m = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)', data)\n    if m:\n        nums_str = m.group(1)\n        k = int(m.group(2))\n        try:\n            nums = eval(nums_str, {\"__builtins__\": None}, {})\n        except Exception:\n            # Fallback if eval fails\n            nums = [int(x) for x in re.findall(r'-?\\d+', nums_str)]\n    else:\n        # Fallback: assume all numbers except last one are array, last is k\n        parts = re.findall(r'-?\\d+', data)\n        if not parts:\n            return\n        nums = list(map(int, parts[:-1]))\n        k = int(parts[-1])\n\n    sol = Solution()\n    result = sol.containsNearbyDuplicate(nums, k)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1], k = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode135.json",
    "problem_index_in_file": 0,
    "title": "Candy",
    "description_snippet": "There are n children standing in a line. Each child is assigned a rating value given in the integer ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the candy distribution problem. The problem: given ratings array, assign candies with constraints: each at least one, higher rating neighbor gets more. Min candies. Standard solution: two-pass or one-pass? We'll produce algorithm steps: 1) initialize candies array to 1 each. 2) left-to-right pass: if rating[i]>rating[i-1], candies[i]=candies[i-1]+1. 3) right-to-left pass: if rating[i]>rating[i+1] and candies[i] <= candies[i+1], candies[i]=candies[i+1]+1. 4) sum candies. Return sum.\n\nWe need to produce virtual code lines following format. Use Start, Decision, etc. Provide explanation comment after each line.\n\nNeed to ensure each line: `虛擬碼步驟 [space] // 解釋`.\n\nWe must not output actual code, just virtual steps.\n\nLet's produce:\n\nStart // 開始程式\n→ Step 1: 設定 candies 陣列長度與 ratings 相同，並全部初始化為 1 // 每個孩子至少得到一顆糖果\n→ Step 2: 確定 n = ratings 的長度 // 取得孩子數量\n→ Decision: 是否存在至少 2 個孩子? // 檢查是否需要進行比較\n    Yes → Step 3: 從 i = 1 到 n-1 進行左到右遍歷 // 準備第一遍掃描\n        → Step 4: 如果 ratings[i] > ratings[i-1] → candies[i] = candies[i-1] + 1 // 右邊孩子評分更高，給更多糖果\n    No  → Step 5: 跳過左到右遍歷 // 只有一個孩子不需要比較\n→ Decision: 是否需要進行右到左遍歷? // 第二遍掃描以修正右邊評分更高的情況\n    Yes → Step 6: 從 i = n-2 到 0 進行右到左遍歷 // 準備第二遍掃描\n        → Step 7: 如果 ratings[i] > ratings[i+1] 且 candies[i] <= candies[i+1] → candies[i] = candies[i+1] + 1 // 右邊孩子評分更高且糖果不夠，調整\n    No  → Step 8: 跳過右到左遍歷 // n≤1 不需要第二遍\n→ Step 9: 計算 candies 陣列所有元素之和 total = sum(candies) // 求最小糖果總數\n→ Step 10: 回傳 total // 回傳答案\nEnd // 程式結束\n\nWe need to include arrow formatting. Each line with a step, with `→` arrow. Decision block: use indentation? In example, they used indentation for nested. We need to indent substeps. For indentation, maybe use two spaces. Provide indentation to show hierarchy.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 candies 陣列長度與 ratings 相同，並全部設為 1 // 每位孩子至少拿一顆糖  \n→ Step 2: 設定 n = ratings 的長度 // 取得孩子數量  \n→ Decision: n 是否至少為 2? // 判斷是否需要進行比較  \n    Yes → Step 3: 從 i = 1 開始進行左到右遍歷直到 n-1 // 準備第一遍掃描  \n        → Step 4: 如果 ratings[i] > ratings[i-1] → candies[i] = candies[i-1] + 1 // 右邊孩子評分更高，給更多糖  \n    No  → Step 5: 跳過左到右遍歷 // 只有一個孩子時不需要比較  \n→ Decision: 是否要進行右到左遍歷? // 第二遍掃描以修正右邊評分更高的情況  \n    Yes → Step 6: 從 i = n-2 開始進行右到左遍歷直到 0 // 準備第二遍掃描  \n        → Step 7: 如果 ratings[i] > ratings[i+1] 且 candies[i] <= candies[i+1] → candies[i] = candies[i+1] + 1 // 右邊孩子評分更高且糖果不足時調整  \n    No  → Step 8: 跳過右到左遍歷 // n≤1 時不需要第二遍  \n→ Step 9: 計算 candies 陣列所有元素之和 total = sum(candies) // 求最小糖果總數  \n→ Step 10: 回傳 total // 將答案回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        if n == 0:\n            return 0\n        candies = [1] * n\n\n        # Left to right: if right child has higher rating, give one more candy\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # Right to left: if left child has higher rating, ensure it has more candies\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part from the input, e.g. \"ratings = [1,0,2]\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1 and start < end:\n        ratings_str = data[start:end + 1]\n    else:\n        ratings_str = data  # assume the whole input is the list\n\n    try:\n        ratings = ast.literal_eval(ratings_str)\n    except (ValueError, SyntaxError):\n        # If evaluation fails, default to empty list\n        ratings = []\n\n    result = Solution().candy(ratings)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ratings = [1,0,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "ratings = [1,2,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode127.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the word ladder problem: find shortest transformation sequence length, else 0. Use BFS. Steps: start, check if endWord in wordList, else return 0. Initialize queue with beginWord and level 1. Use visited set. While queue not empty: pop word, level. For each position, change letter a-z, if new word equals endWord return level+1, if in wordList and not visited, add to queue and visited. After BFS, return 0.\n\nWe must format each line: 虛擬碼步驟 [space] // 解釋\n\nUse arrows. Let's write.\n\nWe'll use pseudo-code with arrows.\n\nStart // 開始執行\n→ Decision: 是否 endWord 在 wordList? // 確認終點字存在字典中\n    Yes → Step 1: 初始化 queue 為 [(beginWord, 1)] // 存放單詞及其層數\n    No  → End: 回傳 0 // 沒有終點字，無法轉換\n→ Step 2: 建立 visited 集合並加入 beginWord // 標記已訪問的單詞\n→ Step 3: 建立 charList = ['a'..'z'] // 所有可能字母\n→ Decision: queue 是否為空? // 判斷是否還有單詞可探索\n    Yes → End: 回傳 0 // 所有路徑探索完畢但未找到終點\n    No  → → Step 4: 取出 queue 前端的 word, level // 取得目前處理的單詞與其層數\n→ Step 5: 循環 i 從 0 到 len(word)-1 // 對每個字母位置進行嘗試\n    → Step 6: 迴圈 j 在 charList 中 // 對每個可能的新字母\n        → Decision: word[i] 是否等於 j? // 避免把同字母產生相同單詞\n            Yes → Continue // 跳過此次迴圈\n            No  → → Step 7: 產生 newWord = word 前段 + j + word 後段 // 替換第 i 個字母\n→ Decision: newWord 是否等於 endWord? // 檢查是否達到終點\n    Yes → End: 回傳 level + 1 // 找到最短路徑長度\n    No  → → Decision: newWord 是否在 wordList 且 未被 visited? // 確認新單詞合法且未被處理\n        Yes → → Step 8: 加入 queue (newWord, level+1) // 放入下一層\n        No  → Continue // 跳過\n→ Step 9: 重複 Step 4 直到 queue 為空 // 繼續 BFS\n→ End: 回傳 0 // 未找到終點\n\nWe need to format properly with arrows and indent for decisions. Use \"Yes →\" \"No →\".\n\nWe must not output actual code. Let's produce lines accordingly.\n\nMake sure each line has \"虛擬碼步驟\" and then space and comment.\n\nWe need to use proper formatting. Let's produce.\n\nWe also need to include Start and End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: endWord 是否存在於 wordList? // 確認終點字在字典中  \n Yes → Step 1: queue ← [(beginWord, 1)] // 初始化佇列，存入起始單詞與層級 1  \n No → End: 回傳 0 // 若終點字不在字典，無法轉換  \n→ Step 2: visited ← {beginWord} // 建立已訪問集合並加入起始單詞  \n→ Step 3: chars ← ['a', …, 'z'] // 所有可能替換的字母  \n→ Decision: queue 是否為空? // 判斷是否還有單詞可探索  \n Yes → End: 回傳 0 // 所有路徑探索完畢仍未找到終點  \n No → → Step 4: word, level ← queue.pop_front() // 取出佇列前端單詞及其層級  \n→ Step 5: 循環 i 取值 0 到 len(word)-1 // 逐個位置嘗試替換  \n → Step 6: 循環 j 取值 chars 中的每個字母 // 逐個字母嘗試  \n  → Decision: word[i] 是否等於 j? // 避免重複產生相同單詞  \n   Yes → Continue // 跳過此字母  \n   No → → Step 7: newWord ← word[:i] + j + word[i+1:] // 替換第 i 個字母產生新單詞  \n→ Decision: newWord 是否等於 endWord? // 檢查是否達到終點  \n Yes → End: 回傳 level + 1 // 找到最短路徑長度  \n No → → Decision: newWord ∈ wordList 且 newWord ∉ visited? // 新單詞合法且未訪問  \n  Yes → → Step 8: queue.append((newWord, level+1)) // 加入佇列作下一層  \n  No → Continue // 跳過  \n→ Step 9: 回到 Step 4 循環直到 queue 為空 // 繼續 BFS 探索  \n→ End: 回傳 0 // 未找到任何合法的轉換序列",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord, endWord, wordList):\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (current_word, current_length)\n\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i + 1 :]\n                    if new_word in word_set:\n                        word_set.remove(new_word)\n                        queue.append((new_word, length + 1))\n        return 0\n\ndef parse_input(text):\n    \"\"\"\n    Parses input of the form:\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    \"\"\"\n    pattern = r'beginWord\\s*=\\s*\"([^\"]+)\"\\s*,\\s*endWord\\s*=\\s*\"([^\"]+)\"\\s*,\\s*wordList\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, text)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    begin = match.group(1)\n    end = match.group(2)\n    word_list = ast.literal_eval(match.group(3))\n    return begin, end, word_list\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    try:\n        beginWord, endWord, wordList = parse_input(raw_input)\n    except Exception as e:\n        print(0)\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.ladderLength(beginWord, endWord, wordList)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode76.json",
    "problem_index_in_file": 0,
    "title": "Minimum Window Substring",
    "description_snippet": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. The algorithm: sliding window, two pointers, frequency map for t, count matched. Standard minimum window substring. We'll produce step-by-step virtual code. Include Start, End, Decision, loops, etc.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Using arrow →. Use Decision: and Yes/No lines. Ensure each step line includes the arrow.\n\nWe'll design like:\n\nStart\n→ Step 1: 建立 t 的字元頻率表 targetFreq // 统计 t 中每个字符出现次数\n→ Step 2: 初始化 windowFreq, left=0, matched=0, minLen=∞, startIdx=-1 // 窗口频率表及指针\n→ Decision: s 是否为空? // 检查边界情况\n    Yes → Step 3: 返回 \"\" // 为空直接返回\n    No  → ...\n→ Step 4: for right in 0..n-1 // 右指针遍历 s\n    → Update windowFreq with s[right]\n    → Decision: s[right] 是否在 targetFreq 并且 windowFreq[s[right]] <= targetFreq[s[right]]? // 只计入需要的字符\n        Yes → matched++\n    → Decision: matched 是否等于 t 的总字符数? // 目标是否已满足\n        Yes → Step 5: 尝试收缩窗口\n            → while left <= right:\n                → Decision: s[left] 是否在 targetFreq 并且 windowFreq[s[left]] > targetFreq[s[left]]? // 多余字符可移除\n                    Yes → Decrease windowFreq[s[left]]; left++; // 收缩\n                    No → Break // 收缩停止\n            → Step 6: 若当前窗口长度 < minLen\n                → Update minLen, startIdx = left\n        No  → Continue\n→ Decision: minLen 是否仍为 ∞? // 是否找到窗口\n    Yes → Step 7: 返回 \"\" // 未找到\n    No  → Step 8: 返回 s[startIdx : startIdx+minLen] // 返回最小窗口\n\nEnd\n\nNeed to ensure each line includes arrow or Decision lines. Let's format each line accordingly.\n\nWe need to be careful: each line with 虛擬碼步驟 + space + // 解釋. Use arrows.\n\nAlso, the arrow \"→\" indicates a new step. The Decision line has \"Decision:\" and indent with yes/no lines starting with \"Yes →\" and \"No →\".\n\nWe'll create lines:\n\nStart // 程式開始執行\n→ Step 1: 建立 t 的字元頻率表 targetFreq // 统计 t 中每个字符出现次数\n→ Step 2: 初始化 windowFreq, left=0, matched=0, minLen=∞, startIdx=-1 // 初始化滑动窗口所需变量\n→ Decision: s 是否为空? // 检查边界情况\n    Yes → Step 3: 返回 \"\" // s 为空时直接返回空字符串\n    No  → // 继续执行后续步骤\n→ Step 4: 对 s 进行右指针遍历，right 从 0 到 n-1 // 开始滑动窗口扫描\n    → 更新 windowFreq，加入 s[right] // 将右指针字符计入窗口频率表\n    → Decision: s[right] 是否在 targetFreq 且 windowFreq[s[right]] <= targetFreq[s[right]]? // 判断该字符是否是目标字符且未超过所需数量\n        Yes → matched++ // 目标字符匹配计数加一\n        No  → // 不计入匹配\n    → Decision: matched 是否等于 t 的总字符数? // 判断是否已满足所有目标字符\n        Yes → // 开始尝试收缩左指针\n            → while left <= right:\n                → Decision: s[left] 是否在 targetFreq 且 windowFreq[s[left]] > targetFreq[s[left]]? // 判断左指针字符是否多余\n                    Yes → windowFreq[s[left]]-- ; left++ // 移除多余字符并移动左指针\n                    No  → Break // 左指针字符不可再移除\n            → Decision: 当前窗口长度 (right-left+1) 是否小于 minLen? // 记录更短的窗口\n                Yes → minLen = right-left+1 ; startIdx = left // 更新最小窗口\n                No  → // 保持原值\n        No  → // 未满足匹配，继续右指针移动\n→ Decision: minLen 是否仍为 ∞? // 判断是否找到合法窗口\n    Yes → Step 5: 返回 \"\" // 未找到时返回空字符串\n    No  → Step 6: 返回 s[startIdx : startIdx+minLen] // 返回最小窗口子串\nEnd // 程式執行結束\n\nBut need each line separate; Indent lines under Decision maybe separate lines.\n\nWe need to be careful: Use \"→\" before each step line. For nested steps inside Decision, we can indent with spaces but keep arrow? Usually arrow before each line: \"    Yes → ...\" etc. That seems fine.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 t 的字元頻率表 targetFreq // 统计 t 中每个字符出现次数  \n→ Step 2: 初始化 windowFreq, left = 0, matched = 0, minLen = ∞, startIdx = -1 // 初始化滑动窗口所需变量  \n→ Decision: s 是否为空? // 检查边界情况  \n Yes → Step 3: 返回 \"\" // s 为空时直接返回空字符串  \n No  → // 继续执行后续步骤  \n→ Step 4: 对 s 进行右指针遍历，right 从 0 到 n-1 // 开始滑动窗口扫描  \n → 更新 windowFreq，加入 s[right] // 将右指针字符计入窗口频率表  \n → Decision: s[right] 是否在 targetFreq 且 windowFreq[s[right]] <= targetFreq[s[right]]? // 判断该字符是否是目标字符且未超过所需数量  \n  Yes → matched++ // 目标字符匹配计数加一  \n  No  → // 不计入匹配  \n → Decision: matched 是否等于 t 的总字符数? // 判断是否已满足所有目标字符  \n  Yes → // 开始尝试收缩左指针  \n   → while left <= right:  \n    → Decision: s[left] 是否在 targetFreq 且 windowFreq[s[left]] > targetFreq[s[left]]? // 判断左指针字符是否多余  \n     Yes → windowFreq[s[left]]--; left++ // 移除多余字符并移动左指针  \n     No  → Break // 左指针字符不可再移除  \n   → Decision: 当前窗口长度 (right-left+1) 是否小于 minLen? // 记录更短的窗口  \n    Yes → minLen = right-left+1; startIdx = left // 更新最小窗口  \n    No  → // 保持原值  \n  No  → // 未满足匹配，继续右指针移动  \n→ Decision: minLen 是否仍为 ∞? // 判断是否找到合法窗口  \n Yes → Step 5: 返回 \"\" // 未找到时返回空字符串  \n No  → Step 6: 返回 s[startIdx : startIdx+minLen] // 返回最小窗口子串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n        dict_t = Counter(t)\n        required = len(dict_t)\n        l, r = 0, 0\n        formed = 0\n        window_counts = {}\n        ans = float(\"inf\"), None, None  # (window length, left, right)\n\n        while r < len(s):\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n\n            while l <= r and formed == required:\n                character = s[l]\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n                l += 1\n            r += 1\n\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2] + 1]\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses input of the form:\n        s = \"string1\", t = \"string2\"\n    or any arrangement that contains two quoted strings.\n    Returns the first and second quoted strings as s and t.\n    \"\"\"\n    quotes = re.findall(r'\"(.*?)\"', data)\n    if len(quotes) >= 2:\n        return quotes[0], quotes[1]\n    # Fallback: try single quotes\n    quotes = re.findall(r\"'(.*?)'\", data)\n    if len(quotes) >= 2:\n        return quotes[0], quotes[1]\n    return \"\", \"\"\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s, t = parse_input(data)\n    solution = Solution()\n    result = solution.minWindow(s, t)\n    # Output the result surrounded by double quotes as per examples\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
          "expected_output": "\"BANC\"",
          "success": true,
          "output": "\"BANC\""
        },
        {
          "example_index": 1,
          "input": "s = \"a\", t = \"a\"",
          "expected_output": "\"a\"",
          "success": true,
          "output": "\"a\""
        },
        {
          "example_index": 2,
          "input": "s = \"a\", t = \"aa\"",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode420.json",
    "problem_index_in_file": 0,
    "title": "Strong Password Checker",
    "description_snippet": "A password is considered strong if the below conditions are all met:\n\nIt has at least 6 characters a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that outlines algorithm for LeetCode 420 Strong Password Checker. We need step-by-step explanation. Provide each line: virtual code step and comment.\n\nLet's design algorithm:\n\n- Input password string.\n- Count length n.\n- Determine missing types: lowercase, uppercase, digit.\n- Find sequences of repeated characters length >=3.\n- Compute number of replacements needed for those repeats: sum of len//3.\n\nCase 1: n < 6: need insertions. Steps needed = max(missingTypes, 6 - n). Also replacements may reduce but inserted char can fix missing types and replace repeats? In algorithm: result = max(missingTypes, 6 - n). Because insertions can handle repeats.\n\nCase 2: n between 6 and 20: no delete needed. Replacements needed = max(missingTypes, totalReplacements). Because we can replace repeated characters to fix missing types simultaneously.\n\nCase 3: n > 20: need deletions. Let overLen = n - 20. We can reduce replacements by deleting characters in sequences.\n\nWe categorize repeats by mod 3: len%3==0,1,2. Prefer delete in mod0 first to reduce replacement count by 1 per deletion. Then mod1, then mod2.\n\nAfter performing deletions, compute new replacements needed.\n\nResult = overLen + max(missingTypes, newReplacements).\n\nWe need to produce virtual steps line by line. Let's craft.\n\nWe should not output actual code, only virtual pseudocode.\n\nWe should be mindful of format: each line `虛擬碼步驟 // 解釋`. Use arrow and decision.\n\nLet's produce.\n\nWill produce:\n\nStart\n\n→ Step: 取得輸入字串 password // Input\n\n→ Step: n ← length(password) // 取得長度\n\n→ Step: missing ← 3 // Assume all types missing\n\n→ Decision: 若 password 含小寫字母? // 檢查小寫\n\n    Yes → missing ← missing -1 // 移除一種缺失類型\n\n...\n\nAlternatively use bitmask, but simpler: maintain bools.\n\nBut we need line-by-line. We need to cover detection of repeated sequences.\n\nWe need to collect lengths of runs: iterate over password.\n\nLet's produce.\n\nAfter counting missing types, find repeats.\n\nCompute replaceCount = sum(len//3 for each run).\n\nIf n < 6: result = max(missing, 6 - n)\n\nElse if n <=20: result = max(missing, replaceCount)\n\nElse: overLen = n-20\n\nWe need to reduce replaceCount by deletions.\n\nLet deletionsNeeded = overLen\n\nWe process runs sorted by len%3.\n\nWe can produce loop.\n\nThen final result.\n\nLet's produce as virtual steps.\n\nBe careful: Provide decisions and loops using pseudo.\n\nWe'll produce:\n\n→ Step: missingTypes ← 0 // count missing categories\n\n→ Step: lower ← False ; upper ← False ; digit ← False\n\n→ Step: for each char c in password: // iterate\n\n    → Decision: if c is lower? // etc\n\nBut we may produce simpler lines summarizing.\n\nWe can produce like:\n\n→ Step: missingTypes ← count of missing char types // summarise\n\n→ Step: repeats ← list of lengths of each group of identical chars // compute\n\n→ Step: replaceNeeded ← sum(len // 3 for len in repeats) // compute\n\nThen branch based on length.\n\nOk.\n\nLet's write.\n\nNeed to include arrow lines for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: password ← input string // 取得待檢查密碼\n→ Step: n ← length(password) // 計算密碼長度\n\n// ---------- 1. 檢查缺少的字符類型 ----------\n→ Step: hasLower ← False ; hasUpper ← False ; hasDigit ← False // 初始化標記\n→ Decision: 迭代每個字符 c in password? // 檢查每個字符\n    → Step: 若 c 為小寫字母? → hasLower ← True\n    → Step: 若 c 為大寫字母? → hasUpper ← True\n    → Step: 若 c 為數字? → hasDigit ← True\n→ Step: missingTypes ← (hasLower?0:1) + (hasUpper?0:1) + (hasDigit?0:1) // 計算還缺少多少類型\n\n// ---------- 2. 找出連續重複字符組 ----------\n→ Step: repeats ← empty list // 存儲每個重複組的長度\n→ Step: i ← 0\n→ Decision: i < n? // 逐個字符遍歷\n    → Step: j ← i\n    → Decision: j < n AND password[j] == password[i]? // 判斷同一個組\n        → Step: j ← j + 1\n        → Step: 回到上一步\n    → Step: repeatLen ← j - i\n    → Decision: repeatLen >= 3? // 只有長度 >=3 才需要修正\n        → Step: repeats.append(repeatLen)\n    → Step: i ← j\n    → Step: 回到上一步\n→ Step: replaceNeeded ← sum(len // 3 for len in repeats) // 初始需要替換的次數\n\n// ---------- 3. 根據長度分情況 ----------\n→ Decision: n < 6? // 密碼太短\n    → Step: insertNeeded ← 6 - n\n    → Step: result ← max(missingTypes, insertNeeded) // 插入可同時解決重複\n→ Decision: n <= 20? // 長度合適\n    → Step: result ← max(missingTypes, replaceNeeded) // 只需替換\n→ Decision: n > 20? // 密碼太長\n    → Step: overLen ← n - 20 // 需要刪除的字符數\n    → Step: deletionsRemaining ← overLen\n\n    // ---------- 3a. 優先在重複組中刪除以減少替換需求 ----------\n    → Step: sort repeats by (len % 3) ascending // 先處理模 0、1、2 的組\n    → Decision: for each len in repeats? // 處理每個重複組\n        → Decision: deletionsRemaining == 0? // 沒有剩餘刪除\n            → Step: 跳出循環\n        → Step: toDelete ← min(deletionsRemaining, len - 2) // 至少保留兩個字符\n        → Step: len ← len - toDelete\n        → Step: deletionsRemaining ← deletionsRemaining - toDelete\n        → Step: replaceNeeded ← replaceNeeded - ( (len + toDelete) // 3 - len // 3 ) // 更新需要的替換次數\n        → Step: 跳回循環\n\n    → Step: result ← overLen + max(missingTypes, replaceNeeded) // 刪除 + 替換\n\nEnd // 程式執行結束，result 為最小步驟數\n\n// 若需要直接輸出答案，則可在 End 之前加\n→ Step: return result // 回傳最小步驟數",
      "generated_code": "import sys\nimport re\n\ndef strongPasswordChecker(s: str) -> int:\n    n = len(s)\n\n    # 1. check missing character types\n    has_lower = has_upper = has_digit = 0\n    for c in s:\n        if c.islower():\n            has_lower = 1\n        elif c.isupper():\n            has_upper = 1\n        elif c.isdigit():\n            has_digit = 1\n    missing_types = 3 - (has_lower + has_upper + has_digit)\n\n    # 2. find repeating sequences\n    replace = 0          # total replacements needed for repeats\n    one_mod = two_mod = 0  # counts of repeats with len%3 == 0 or 1\n    i = 0\n    while i < n:\n        j = i\n        while j < n and s[j] == s[i]:\n            j += 1\n        length = j - i\n        if length >= 3:\n            replace += length // 3\n            if length % 3 == 0:\n                one_mod += 1\n            elif length % 3 == 1:\n                two_mod += 1\n        i = j\n\n    # 3. decide based on length\n    if n < 6:\n        return max(6 - n, missing_types)\n\n    if n <= 20:\n        return max(replace, missing_types)\n\n    # n > 20: need deletions\n    delete = n - 20\n\n    # use deletions to reduce replacements\n    reduce = min(delete, one_mod)\n    replace -= reduce\n    delete -= reduce\n\n    reduce = min(delete, two_mod * 2) // 2\n    replace -= reduce\n    delete -= reduce * 2\n\n    replace -= delete // 3\n\n    return (n - 20) + max(missing_types, replace)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Try to extract the password from a line like: password = \"a\"\n    m = re.search(r'password\\s*=\\s*\"([^\"]*)\"', data)\n    if m:\n        pwd = m.group(1)\n    else:\n        # If no pattern matched, assume the whole input is the password\n        pwd = data.strip()\n    result = strongPasswordChecker(pwd)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "password = \"a\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "password = \"aA1\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "password = \"1337C0d3\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode643.json",
    "problem_index_in_file": 0,
    "title": "Maximum Average Subarray I",
    "description_snippet": "You are given an integer array nums consisting of n elements, and an integer k.\n\nFind a contiguous s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for the algorithm: find maximum average of subarray length k in array nums. Approach: sliding window sum of size k. Keep max sum, compute average. Complexity O(n). Output virtual code lines with explanations.\n\nWe must include Start, End, Decision lines.\n\nSo produce lines:\n\nStart\n→ Step 1: If n < k? ...\nBut typical algorithm: compute sum of first k elements, set maxSum. Then iterate i from k to n-1, update sum by adding nums[i] and subtract nums[i-k]. Keep maxSum. At end average = maxSum / k.\n\nAlso handle edge cases: k == 0? but problem might not have.\n\nInclude Decision: If n < k? maybe skip? But can assume n >= k. But we might add check.\n\nOk produce lines.\n\nUse arrow: `→`.\n\nStructure: Start, End, Decision, Step.\n\nLet's craft.\n\nWe also need to maintain variable types: sum, maxSum, i, n.\n\nAdd comments.\n\nLet's produce virtual code lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 計算陣列長度 n = nums.length // 取得輸入陣列長度\n→ Decision: 如果 n < k? // 檢查是否能取長度為 k 的子陣列\n    Yes → Step 2: 返回 -1 // 若無法，回傳 -1 或其他錯誤值\n    No  → Step 3: 初始化 sum = 0, maxSum = 0 // 初始化滑動窗口總和及最大總和\n→ Step 4: 為 i 從 0 到 k-1 執行 sum += nums[i] // 計算前 k 個元素的總和\n→ Step 5: maxSum = sum // 第一個窗口的總和作為初始最大值\n→ Step 6: 為 i 從 k 到 n-1 執行\n    → Step 7: sum += nums[i] - nums[i-k] // 加入新元素並移除最舊元素，更新窗口總和\n    → Decision: 如果 sum > maxSum? // 檢查是否有更大的總和\n        Yes → Step 8: maxSum = sum // 更新最大總和\n        No  →  // 何不更新，保持原值\n→ Step 9: 計算 maxAvg = maxSum / k // 將最大總和轉為平均值\n→ Step 10: 返回 maxAvg // 回傳最大平均值\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def findMaxAverage(self, nums: List[int], k: int) -> float:\n        \"\"\"\n        使用滑動窗口求取長度為 k 的子陣列的最大平均值。\n        \"\"\"\n        window_sum = sum(nums[:k])          # 第一個窗口的總和\n        max_sum = window_sum                 # 最大總和初始為第一個窗口\n\n        for i in range(k, len(nums)):\n            window_sum += nums[i] - nums[i - k]  # 更新窗口總和\n            if window_sum > max_sum:\n                max_sum = window_sum            # 更新最大總和\n\n        return max_sum / k\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取 nums 清單與 k 整數。\n    支援類似 'nums = [1,12,-5,-6,50,3], k = 4' 的格式。\n    \"\"\"\n    # 抓取列表\n    list_match = re.search(r'\\[([^\\]]+)\\]', data)\n    if not list_match:\n        raise ValueError(\"無法找到陣列資料\")\n    nums_str = list_match.group(1)\n    # 以逗號分割，並去除空白，轉成 int\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n\n    # 抓取 k\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not k_match:\n        raise ValueError(\"無法找到 k 值\")\n    k = int(k_match.group(1))\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_data = sys.stdin.read()\n    if not raw_data.strip():\n        sys.exit(0)  # 空輸入直接結束\n\n    nums, k = parse_input(raw_data)\n    solution = Solution()\n    result = solution.findMaxAverage(nums, k)\n    # 輸出結果，保留五位小數\n    print(f\"{result:.5f}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,12,-5,-6,50,3], k = 4",
          "expected_output": "12.75000",
          "success": true,
          "output": "12.75000"
        },
        {
          "example_index": 1,
          "input": "nums = [5], k = 1",
          "expected_output": "5.00000",
          "success": true,
          "output": "5.00000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode258.json",
    "problem_index_in_file": 0,
    "title": "Add Digits",
    "description_snippet": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese (traditional). Each line: \"虛擬碼步驟\" + \" // 解釋/說明\". Use arrows, decisions. Format like the example. So we need to create steps for the digit root algorithm. Steps: Start, Input num, While num has more than one digit: Sum digits, set num = sum, End. Return num. Also handle positive int. Should be straightforward.\n\nLet's output lines. Ensure each line has arrow '→' except Start and End. For loops, we can use Decision with Yes/No. Maybe: Decision: If num > 9? Yes → compute sum of digits. No → End. We can do Step: Sum digits. After sum, loop again.\n\nWe need to produce step-by-step. Use typical structure.\n\nLet's produce: \nStart // 程式開始執行\n→ Input num // 從使用者處取得整數\n→ Decision: num > 9? // 判斷 num 是否還是兩位以上\n    Yes → Step: sumDigits = 0 // 初始化累加器\n    Yes → Step: temp = num // 用於遍歷 num 的位數\n    Yes → Step: While temp > 0? // 循環取出每一位數字\n        Yes → Step: sumDigits += temp % 10 // 加上最低位\n        Yes → Step: temp = temp / 10 // 去掉最低位\n        No  → Step: num = sumDigits // 把和設為新的 num\n        No  → Decision: num > 9? // 再次檢查是否需要繼續\n            Yes → [loop back] // 回到 While\n            No  → Step: result = num // 獲得一位數結果\nEnd // 程式執行結束\n\nBut we need to maintain format: each line with arrow and comment.\n\nAlso we must show decision branches. For loops, we can use Decision: While temp > 0? or Decision: num > 9? etc.\n\nNeed to ensure we output exactly one line per step with comment.\n\nMaybe we produce more readable. Provide Step labels like Step 1, Step 2 etc.\n\nLet's produce a linear structure.\n\nStart // 程式開始執行\n→ Step 1: Input num // 從使用者取得整數\n→ Decision: num > 9? // 檢查 num 是否還有多於一位\n    Yes → Step 2: sumDigits = 0 // 初始化累加器\n    Yes → Step 3: temp = num // 複製 num 以便拆位\n    Yes → Decision: temp > 0? // 循環取出每位數字\n        Yes → Step 4: sumDigits += temp % 10 // 加入最低位\n        Yes → Step 5: temp = temp / 10 // 去掉最低位\n        No  → Step 6: num = sumDigits // 把總和設為新的 num\n        No  → Decision: num > 9? // 再次檢查是否需要重複\n            Yes → [loop back to Step 2] // 重複求和\n            No  → Step 7: result = num // 得到最終一位數\nEnd // 程式執行結束\n\nBut we need arrow at each line. For nested decisions, we can indent. The example uses indentation. We'll follow that.\n\nLet's write accordingly. Ensure each line after arrow includes comment.\n\nAlso we need to mention \"Yes →\" and \"No →\" lines.\n\nThe line \"Yes → [loop back to Step 2]\" might be ambiguous; we can write \"Yes → Go to Step 2\" or \"Yes → Repeat Step 2\". Provide a comment.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input num // 從使用者取得整數  \n→ Decision: num > 9? // 判斷 num 是否還有多於一位數  \n Yes → Step 2: sumDigits = 0 // 初始化位數累加器  \n Yes → Step 3: temp = num // 將 num 複製到 temp 以便拆位  \n Yes → Decision: temp > 0? // 逐位取出 temp 的數字  \n  Yes → Step 4: sumDigits += temp % 10 // 加入最低位數字  \n  Yes → Step 5: temp = temp / 10 // 去掉最低位  \n  No  → Step 6: num = sumDigits // 把總和設為新的 num  \n  No  → Decision: num > 9? // 再次檢查是否仍需要重複  \n   Yes → Go to Step 2 // 重新開始求和，重複整個過程  \n   No  → Step 7: result = num // 獲得最終的一位數結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        \"\"\"Repeatedly add digits until a single digit remains.\"\"\"\n        while num >= 10:\n            # Convert number to string, sum its digits, and assign back to num\n            num = sum(int(digit) for digit in str(num))\n        return num\n\ndef parse_input(text: str) -> int:\n    \"\"\"\n    將輸入文字中找到第一個整數並返回。\n    支援格式如 'num = 38' 或直接輸入 '38'。\n    \"\"\"\n    match = re.search(r'-?\\d+', text)\n    if not match:\n        raise ValueError(\"No integer found in input\")\n    return int(match.group())\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    if not data.strip():\n        return  # 空輸入直接結束\n    # 解析整數\n    num = parse_input(data)\n    # 計算結果\n    solution = Solution()\n    result = solution.addDigits(num)\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 38",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode696.json",
    "problem_index_in_file": 0,
    "title": "Count Binary Substrings",
    "description_snippet": "Given a binary string s, return the number of non-empty substrings that have the same number of 0's ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code algorithm for this problem. Steps: iterate over string, group consecutive identical chars and count lengths. Then for each adjacent group pair, min(len1,len2) gives count of substrings. Sum. Also handle non-empty.\n\nVirtual code lines: Start, Step 1: Initialize variables, Step 2: Iterate over s to build list of run lengths, Step 3: Sum min for consecutive runs, End. Provide explanation.\n\nEnsure arrow formatting. Use \"Decision:\" for loops maybe? but loops can be \"Step: Iterate\" no need decision. Could use \"Decision:\" for if len>0? but simple.\n\nWe need line-by-line. Provide each line with arrow \"→\". Format: \"→ Step 1: ... // ...\" etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空串列表 runs = []，計數器 count = 0 // 用來存放連續相同字符的長度  \n→ Step 2: 迭代字串 s 的每個字符 c  \n  → Decision: 是否為第一個字符或 c 與前一字符不同？  \n    Yes → Step 3: 若 runs 不是空則將 count 加入 runs；將 count 設為 1 // 新的字符區段開始  \n    No  → Step 4: count += 1 // 同一區段持續  \n→ Step 5: 迭代結束後將最後的 count 加入 runs // 處理最後一段  \n→ Step 6: 初始化總數 total = 0  \n→ Step 7: 迭代 runs 的索引 i 從 0 到 len(runs)-2  \n  → Step 8: 計算 min_len = min(runs[i], runs[i+1]) // 相鄰區段中可形成的合法子字串數  \n  → Step 9: total += min_len // 累加到總數  \n→ End // 程式執行結束，返回 total\n\n(Note: 以上虛擬碼使用「→」箭頭表示流程流，並在每行後面以「//」提供簡短說明。)",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        if not s:\n            return 0\n        groups = []\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                count += 1\n            else:\n                groups.append(count)\n                count = 1\n        groups.append(count)\n\n        result = 0\n        for i in range(1, len(groups)):\n            result += min(groups[i], groups[i - 1])\n        return result\n\ndef main() -> None:\n    raw_input = sys.stdin.read().strip()\n    # Extract the string value from formats like `s = \"00110011\"` or just `\"00110011\"`\n    if '=' in raw_input:\n        _, val = raw_input.split('=', 1)\n        s = val.strip()\n    else:\n        s = raw_input\n\n    # Remove surrounding quotes if present\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n\n    solution = Solution()\n    result = solution.countBinarySubstrings(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"00110011\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "s = \"10101\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode205.json",
    "problem_index_in_file": 0,
    "title": "Isomorphic Strings",
    "description_snippet": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps to determine if two strings s and t are isomorphic. We need to output line by line, with virtual code and explanation. Use arrows, Start, End, Decision.\n\nWe must not output actual code, just pseudocode steps. Each line: \"虛擬碼步驟 // 解釋\". The steps: check length equal, map from s to t, map from t to s, iterate each char. Use Decision steps.\n\nLet's craft lines:\n\nStart // start\n→ Decision: s.length == t.length? // if lengths differ, not isomorphic\n    No → End // return false\n    Yes → Step 1: initialize empty mapS2T // mapping from s char to t char\n→ Step 2: initialize empty mapT2S // mapping from t char to s char\n→ Step 3: for i from 0 to s.length-1 // iterate through characters\n    → Step 4: let cS = s[i] // current char in s\n    → Step 5: let cT = t[i] // current char in t\n    → Decision: mapS2T contains key cS? // check existing mapping from s to t\n        Yes → Decision: mapS2T[cS] == cT? // does it match expected\n            Yes → Continue // mapping consistent, continue loop\n            No  → End // mismatch, not isomorphic\n        No → Step 6: mapS2T[cS] = cT // record mapping\n    → Decision: mapT2S contains key cT? // check mapping from t to s\n        Yes → Decision: mapT2S[cT] == cS? // should match\n            Yes → Continue // consistent\n            No  → End // conflict, not isomorphic\n        No → Step 7: mapT2S[cT] = cS // record reverse mapping\n→ End // all checks passed, strings are isomorphic\n\nBut we need to keep virtual code lines. Each line separated. Use arrow \"→\". For nested decisions, indent lines? In example, they indent. We'll indent appropriately.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: s.length == t.length? // 若長度不同，兩字串不可能同構  \n  No  → End // 結束，回傳 False  \n  Yes → Step 1: 初始化空映射 mapS2T // 用來記錄 s 的字元對應到 t 的字元  \n→ Step 2: 初始化空映射 mapT2S // 用來記錄 t 的字元對應到 s 的字元  \n→ Step 3: 循環 i 從 0 到 s.length-1 // 逐個比對每個位置的字元  \n  → Step 4: cS = s[i] // 取得 s 的當前字元  \n  → Step 5: cT = t[i] // 取得 t 的當前字元  \n  → Decision: mapS2T 是否已有 key cS? // s 的字元是否已被映射  \n    Yes → Decision: mapS2T[cS] == cT? // 映射是否與目前字元相符  \n      Yes → Continue // 符合，繼續下一個字元  \n      No  → End // 映射不符，結束，回傳 False  \n    No  → Step 6: mapS2T[cS] = cT // 記錄新的映射  \n  → Decision: mapT2S 是否已有 key cT? // t 的字元是否已被映射回 s  \n    Yes → Decision: mapT2S[cT] == cS? // 映射是否與目前字元相符  \n      Yes → Continue // 符合，繼續下一個字元  \n      No  → End // 映射不符，結束，回傳 False  \n    No  → Step 7: mapT2S[cT] = cS // 記錄新的反向映射  \n→ End // 所有字元都符合映射規則，兩字串同構，結束程式。",
      "generated_code": "import sys\nimport re\n\ndef is_isomorphic(s: str, t: str) -> bool:\n    \"\"\"檢查兩個字串是否同構。\"\"\"\n    if len(s) != len(t):\n        return False\n    map_s_t = {}\n    map_t_s = {}\n    for c1, c2 in zip(s, t):\n        if c1 in map_s_t and map_s_t[c1] != c2:\n            return False\n        if c2 in map_t_s and map_t_s[c2] != c1:\n            return False\n        map_s_t[c1] = c2\n        map_t_s[c2] = c1\n    return True\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取兩個字串，輸出是否同構。\"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 從輸入中尋找第一個雙引號內的字串\n    strings = re.findall(r'\"([^\"]*)\"', data)\n    if len(strings) >= 2:\n        s, t = strings[0], strings[1]\n    else:\n        # 若輸入格式不包含引號，直接按空白分割\n        parts = data.strip().split()\n        s = parts[0] if parts else \"\"\n        t = parts[1] if len(parts) > 1 else \"\"\n\n    result = is_isomorphic(s, t)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"egg\", t = \"add\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"foo\", t = \"bar\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"paper\", t = \"title\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode412.json",
    "problem_index_in_file": 0,
    "title": "Fizz Buzz",
    "description_snippet": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with \"→\" or \"Decision:\" etc. Provide explanation after //.\n\nWe need to process integer n, produce array answer of length n, 1-indexed. Use loop i from 1 to n. For each, check divisibility by 3 and 5. Add string accordingly. Then output End. Ensure each line has virtual code and explanation.\n\nLet's craft step-by-step:\n\nStart\n→ Declare array answer of size n // 1-indexed array\n→ For i from 1 to n // iterate through numbers\n   → Decision: if i divisible by 3 and 5? // check both\n       Yes → answer[i] = \"FizzBuzz\" // set string\n       No  → Decision: if i divisible by 3? // check 3\n            Yes → answer[i] = \"Fizz\" // set\n            No  → Decision: if i divisible by 5? // check 5\n                 Yes → answer[i] = \"Buzz\" // set\n                 No  → answer[i] = string(i) // set number as string\nEnd // end program\n\nNeed to use arrow formatting. For loops, maybe \"→ For i = 1 to n\" etc. We can use \"→\" for loop.\n\nLet's produce each line with arrow.\n\nNote: each line after \"→\" includes a space then the step and explanation after //. Need to ensure indentation? The sample shows indentation by spaces for decisions inside. We should follow same style.\n\nSo output:\n\nStart // 程式開始執行\n→ Declare array answer of size n // 建立一個長度為 n 的陣列，1-indexed\n→ For i = 1 to n // 逐一處理 1 到 n 的數字\n   → Decision: if i divisible by 3 and 5? // 檢查是否同時能被 3 和 5 整除\n        Yes → answer[i] = \"FizzBuzz\" // 將 \"FizzBuzz\" 存入答案\n        No  → Decision: if i divisible by 3? // 檢查是否能被 3 整除\n             Yes → answer[i] = \"Fizz\" // 存入 \"Fizz\"\n             No  → Decision: if i divisible by 5? // 檢查是否能被 5 整除\n                  Yes → answer[i] = \"Buzz\" // 存入 \"Buzz\"\n                  No  → answer[i] = string(i) // 存入數字本身的字串表示\nEnd // 程式執行結束\n\nBut each line must be separate line. Indentation may be represented by spaces. We'll output exactly as lines. Ensure each line ends with comment.\n\nLet's format with each line starting with either Start, →, Decision:, End. Use spaces. We'll produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Declare array answer of size n // 建立一個長度為 n 的陣列，1-indexed  \n→ For i = 1 to n // 逐一處理 1 到 n 的數字  \n   → Decision: if i divisible by 3 and 5? // 檢查是否同時能被 3 和 5 整除  \n        Yes → answer[i] = \"FizzBuzz\" // 將 \"FizzBuzz\" 存入答案  \n        No  → Decision: if i divisible by 3? // 檢查是否能被 3 整除  \n             Yes → answer[i] = \"Fizz\" // 存入 \"Fizz\"  \n             No  → Decision: if i divisible by 5? // 檢查是否能被 5 整除  \n                  Yes → answer[i] = \"Buzz\" // 存入 \"Buzz\"  \n                  No  → answer[i] = string(i) // 存入數字本身的字串表示  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\ndef fizzbuzz(n: int):\n    \"\"\"Return the FizzBuzz list for numbers 1..n.\"\"\"\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n\ndef main():\n    # 讀取標準輸入，允許格式為「n = 3」或僅為「3」\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        n_str = data.split('=', 1)[1].strip()\n    else:\n        n_str = data\n    try:\n        n = int(n_str)\n    except ValueError:\n        n = 0\n\n    answer = fizzbuzz(n)\n    # 輸出符合範例的 JSON 字串\n    print(json.dumps(answer))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"1\",\"2\",\"Fizz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\"]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode150.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Reverse Polish Notation",
    "description_snippet": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polis...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line explaining evaluation of RPN. No actual code. Use virtual arrows. Provide steps: Start, initialize stack, iterate tokens, if token is number push, else operator pop two, compute, push result. After loop pop result, End. Also handle division trunc toward zero. Provide explanation comments. Use decision for operator. Provide integer parse. Let's produce.\n\nWe must use arrow '→' etc. Use proper indentation for decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空 stack // 用來儲存中間計算結果\n→ Step 2: For each token in tokens // 逐一處理 RPN 內的每個項目\n    → Decision: 如果 token 是數字? // 判斷目前項目是操作數還是運算符\n        Yes → Step 3: 將數字轉為整數並 push 到 stack // 存入 stack 以備後續運算\n        No  → Decision: token 為 '+', '-', '*', '/'? // 必須是合法運算符\n            Yes → Step 4: pop operand2 from stack // 第二個操作數（右側）\n            → Step 5: pop operand1 from stack // 第一個操作數（左側）\n            → Decision: operator 為 '+'? // 根據不同運算符進行計算\n                Yes → Step 6: result = operand1 + operand2 // 加法\n                No  → Decision: operator 為 '-'? \n                    Yes → Step 7: result = operand1 - operand2 // 減法\n                    No  → Decision: operator 為 '*'? \n                        Yes → Step 8: result = operand1 * operand2 // 乘法\n                        No  → Decision: operator 為 '/'? \n                            Yes → Step 9: result = truncate_toward_zero(operand1 / operand2) // 除法，向零截斷\n                            No  → Step 10: throw Error // 未知運算符（理論上不會發生）\n            → Step 11: push result 到 stack // 將計算結果重新存回 stack\n→ Step 12: pop final_result from stack // RPN 完成後剩下的唯一值即為答案\n→ End // 程式執行結束\n\n// truncate_toward_zero(x, y) 代表兩數整除，結果向零截斷，符合題目要求",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                elif token == '/':\n                    # 向零取整\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack[0]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入，允許「tokens = [...]」或直接 \"[...]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    tokens = ast.literal_eval(expr)\n    result = Solution().evalRPN(tokens)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "expected_output": "22",
          "success": true,
          "output": "22"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode90.json",
    "problem_index_in_file": 0,
    "title": "Subsets II",
    "description_snippet": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output a virtual code for generating all subsets of an array that may contain duplicates, avoiding duplicate subsets. The classic approach: sort array, backtrack, skip duplicates. Output all subsets.\n\nWe need to produce each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. We need to be \"逐行\" meaning each line of virtual code. So we produce like:\n\nStart // program starts\n→ Step 1: Sort nums // sorts the array to group duplicates\n→ Step 2: Initialize result as empty list // store subsets\n→ Step 3: Call backtrack(index=0, current=[]) // start recursion\n→ Step 4: return result // after backtracking, return result\nEnd // program ends\n\nInside backtrack:\nWe need to produce decisions: at each call, add current subset to result, iterate over i from index to len(nums)-1, skip duplicates if i > index and nums[i] == nums[i-1], choose include, backtrack(i+1,...), then backtrack after removing.\n\nSo we need to produce lines for backtrack function. Use indentation or arrow lines? We can show as:\n\n→ Function backtrack(start, path)\n    → Step: Append copy of path to result // store current subset\n    → Decision: for i from start to len(nums)-1?\n        → Step: If i > start and nums[i] == nums[i-1] → Continue // skip duplicate\n        → Decision: Include nums[i]?\n            Yes → Step: Append nums[i] to path // choose element\n            Yes → Call backtrack(i+1, path) // recurse\n            Yes → Step: Remove last element from path // backtrack\n\nBut we need to format with arrows properly. We can use nested decisions.\n\nLet's craft.\n\nMake sure each line has the pattern: \"虛擬碼步驟 // 解釋\". We'll include arrow or decision. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums // 將陣列排序，方便後續排除重複子集  \n→ Step 2: Initialize result as empty list // 用於存放所有子集  \n→ Step 3: Call backtrack(start = 0, path = []) // 開始遞迴生成子集  \n→ Step 4: Return result // 回傳最終的子集列表  \nEnd // 程式執行結束  \n\n→ Function backtrack(start, path) // 定義遞迴函式  \n → Step: Append copy of path to result // 把目前的子集加入結果  \n → Decision: For i from start to len(nums)-1? // 循環遍歷可選元素  \n  Yes → Step: If i > start AND nums[i] == nums[i-1] → Continue // 跳過重複元素  \n  Yes → Decision: 是否選擇 nums[i]? // 決定是否把當前元素加入子集  \n   Yes → Step: Append nums[i] to path // 把元素加入目前子集  \n   Yes → Call backtrack(i+1, path) // 進行下一層遞迴  \n   Yes → Step: Remove last element from path // 回溯，移除剛才加入的元素  \n  No  → // i 循環結束，返回上一層遞迴  \nEnd // backtrack 函式結束  \n\n---  \n此虛擬碼描述了如何利用排序與遞迴，配合跳過重複元素，生成所有不重複的子集。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        # 先排序，方便後面去除重複子集\n        nums.sort()\n        res = [[]]  # 先放空集合\n        for num in nums:\n            # 將目前已經存在的子集都複製一次，再加上現在的元素\n            new_subsets = [subset + [num] for subset in res]\n            res += new_subsets\n        # 去除重複的子集\n        seen = set()\n        unique_res = []\n        for subset in res:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique_res.append(subset)\n        return unique_res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得輸入中第一個 '[' 到最後一個 ']' 的子字串，再轉成 list\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        nums_str = data[start:end+1]\n        nums = ast.literal_eval(nums_str)\n    except (ValueError, SyntaxError):\n        # 若解析失敗，直接視整個輸入為列表\n        nums = ast.literal_eval(data)\n    sol = Solution()\n    result = sol.subsetsWithDup(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode415.json",
    "problem_index_in_file": 0,
    "title": "Add Strings",
    "description_snippet": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for adding two non-negative integer strings without using big integer libraries or converting to integers. We must output step by step in specified format. The code logic: initialize carry 0, iterate from end of both strings, sum digits + carry, compute new digit and carry, prepend to result string. After loop, if carry>0 prepend. Output result.\n\nNeed to produce each line with virtual code and explanation. Use Start, End, Decision, etc. So each line: \"Start // 程式開始執行\" etc. Provide each step. Use arrow for steps. Use Decision: if. We need to output step-by-step pseudocode with explanation.\n\nWe must ensure no actual code, just pseudocode. Provide each step line with // explanation.\n\nWe need to list lines:\n\nStart\n→ Step 1: 初始化 i = len(num1)-1, j = len(num2)-1, carry = 0, result = \"\" // 定義索引和攜帶位\n→ Step 2: 初始化 empty string result // 儲存計算過程\n→ Decision: 是否 i >=0 或 j >=0 或 carry > 0? // 判斷是否還有數字需要加\n    Yes → Step 3: 計算 digit1 = i>=0 ? num1[i]-'0' : 0 // 取得 num1 的數位\n    → Step 4: 計算 digit2 = j>=0 ? num2[j]-'0' : 0 // 取得 num2 的數位\n    → Step 5: sum = digit1 + digit2 + carry // 總和\n    → Step 6: result = (sum % 10) + result // 將最低位加到結果前面\n    → Step 7: carry = sum / 10 // 更新攜帶位\n    → Step 8: i-- // 移動 num1 指標\n    → Step 9: j-- // 移動 num2 指標\n    → Go back to Decision\n    No → End // 完成加法\nBut must be sequential. Might use \"Loop\" maybe.\n\nBetter to use loop:\n\n→ Step 2: Loop start while i >=0 or j >=0 or carry > 0\n   inside loop: compute digits, sum, etc.\nBut we need to keep arrow style.\n\nWe can structure:\n\n→ Decision: i >= 0 or j >= 0 or carry > 0? // 是否還有位數\n    Yes → Step: compute digits, sum, result, carry, decrement i/j\n    No → End\n\nBut each step after Yes could be multiple lines. But requirement: each line must contain one step. So we can break into multiple steps after Yes. But the decision leads to a block of multiple steps. We need to represent that structure.\n\nCould do:\n\n→ Decision: i >= 0 or j >= 0 or carry > 0? \n    Yes → Step 3: digit1 = i >= 0 ? num1[i] - '0' : 0 // ...\n    Yes → Step 4: digit2 = j >= 0 ? num2[j] - '0' : 0 // ...\n    Yes → Step 5: sum = digit1 + digit2 + carry // ...\n    Yes → Step 6: result = (sum % 10) + result // ...\n    Yes → Step 7: carry = sum / 10 // ...\n    Yes → Step 8: i = i - 1 // ...\n    Yes → Step 9: j = j - 1 // ...\n    No → End // ...\n\nBut this uses multiple \"Yes\" lines. But each line still \"Yes → Step X\". That is okay.\n\nLet's produce lines.\n\nAlso need End line.\n\nLet's count lines.\n\n1 Start\n2 → Step 1: 初始化 i = len(num1)-1, j = len(num2)-1, carry = 0, result = \"\" // ...\n3 → Decision: i >= 0 or j >= 0 or carry > 0? // ...\n4    Yes → Step 2: digit1 = i >= 0 ? num1[i] - '0' : 0 // ...\n5    Yes → Step 3: digit2 = j >= 0 ? num2[j] - '0' : 0 // ...\n6    Yes → Step 4: sum = digit1 + digit2 + carry // ...\n7    Yes → Step 5: result = (sum % 10) + result // ...\n8    Yes → Step 6: carry = sum / 10 // ...\n9    Yes → Step 7: i = i - 1 // ...\n10   Yes → Step 8: j = j - 1 // ...\n11    No → End // 完成加法\n\nNeed to output \"End // 程式執行結束\". Actually after the Decision, we need to End. But End must come after loop ends. But we have the No branch ends with End. This is fine.\n\nWe also might want to add comment about loop. But maybe fine.\n\nWe must ensure each line follows format: \"虛擬碼步驟 [空格] // 解釋/說明\". For decision branches, we can prefix with \"Decision:\".\n\nFor the branch lines, we use \"Yes → Step X: ...\" or \"No → End // ...\".\n\nWe should include \"Start // 程式開始執行\" as first line.\n\nMake sure to use \"→\" for arrow. For branch lines, \"Yes →\". That's per example.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 i = len(num1)-1, j = len(num2)-1, carry = 0, result = \"\" // 設定索引、攜帶位及結果字串  \n→ Decision: i >= 0 或 j >= 0 或 carry > 0? // 判斷是否還有位數需要處理  \n Yes → Step 2: digit1 = i >= 0 ? num1[i] - '0' : 0 // 取得 num1 的數位，若已經超出範圍則視為 0  \n Yes → Step 3: digit2 = j >= 0 ? num2[j] - '0' : 0 // 取得 num2 的數位，若已經超出範圍則視為 0  \n Yes → Step 4: sum = digit1 + digit2 + carry // 將兩個數位與攜帶位相加  \n Yes → Step 5: result = (sum % 10) + result // 將最低位加到結果前面  \n Yes → Step 6: carry = sum / 10 // 更新攜帶位（整除 10）  \n Yes → Step 7: i = i - 1 // 移動 num1 指標到更高位  \n Yes → Step 8: j = j - 1 // 移動 num2 指標到更高位  \n No  → End // 所有位數處理完畢，程式結束並回傳結果\n\n(Note: 每行最後的 `//` 後面附有對應步驟的簡短解釋。)",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            # 取得 num1 與 num2 的對應位數，若索引越界則視為 0\n            x = ord(num1[i]) - 48 if i >= 0 else 0\n            y = ord(num2[j]) - 48 if j >= 0 else 0\n\n            total = x + y + carry\n            # 把最低位的結果追加到 res\n            res.append(chr(total % 10 + 48))\n            # 更新攜帶位\n            carry = total // 10\n\n            i -= 1\n            j -= 1\n\n        # 反轉並合併為最終字串\n        return ''.join(reversed(res))\n\ndef main() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read()\n\n    # 先嘗試從雙引號中擷取兩個數字字串\n    nums = re.findall(r'\"(\\d+)\"', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # 若沒有引號，嘗試以空格或換行分隔\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            return  # 無法取得足夠輸入，直接返回\n\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "success": true,
          "output": "134"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "success": true,
          "output": "533"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode440.json",
    "problem_index_in_file": 0,
    "title": "K-th Smallest in Lexicographical Order",
    "description_snippet": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n]....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm: Given n and k, return kth lexicographically smallest integer in [1,n]. The typical solution: count nodes in lexicographical tree (kth number). We need to produce steps.\n\nWe need step-by-step virtual code lines with arrow → and Decision lines.\n\nWe need to produce explanation after each line.\n\nWe need to not produce real code, just pseudo steps. Provide steps like:\n\nStart\n→ Step 1: Initialize current = 1, count = 1 // start at 1\n→ Decision: If k == 1? // check if k is 1\n   Yes → Step 2: Return current // return 1\n   No  → Step 3: while count < k:\n            → Step 4: If current * 10 <= n: // go deeper\n                 current = current * 10\n                 count++\n            → Decision: else if current % 10 < 9 and current +1 <= n:\n                 current = current + 1\n                 count++\n            → Decision: else:\n                 while current % 10 == 9 or current +1 > n:\n                      current = current / 10\n                 current = current + 1\n                 count++\n   Step 5: Return current\n\nWe need to ensure we use the arrow notation. Also incorporate Decision lines with Yes →, No →.\n\nLet's construct step-by-step.\n\nWe might use more clear approach: While k > 1, compute steps between current and next prefix.\n\nBut easier: Use the common algorithm: count steps between curr and curr+1. Use while loop: while steps < k: compute steps = countSteps(curr, curr+1, n). If steps <= k: curr++ and k -= steps else: curr *=10 and k--.\n\nBut let's produce a simpler approach that matches typical algorithm.\n\nLet's produce steps:\n\nStart\n→ Step 1: Set current = 1, k = k - 1 // since we start at 1 as first lexicographic number\n→ Decision: If k == 0? // if we want first number\n    Yes → Step 2: Return current\n    No → Step 3: While k > 0:\n              → Decision: If current * 10 <= n? // can go deeper\n                  Yes → current = current * 10\n                      k = k - 1\n                  No  → Decision: If current % 10 < 9 and current + 1 <= n? // can move to next sibling\n                      Yes → current = current + 1\n                          k = k - 1\n                      No  → Step 4: While current % 10 == 9 or current + 1 > n:\n                              current = current / 10\n                            current = current + 1\n                            k = k - 1\n→ Step 5: Return current\n\nBut we need to be careful: The typical algorithm uses step count approach to reduce operations. But this is fine for pseudo code. Provide explanation.\n\nLet's write lines accordingly.\n\nWe need to include arrow for each line, start, decision, etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: current = 1; k = k - 1 // 從第一個字典序數字開始，減去已經計算的 1\n→ Decision: 如果 k == 0? // 判斷是否已找到目標\n    Yes → Step 2: Return current // 回傳第一個字典序數字\n    No  → Step 3: While k > 0: // 尚未找到目標，進入迴圈\n              → Decision: 如果 current * 10 <= n? // 可以往下層擴充\n                  Yes → current = current * 10\n                       k = k - 1 // 向下層移動，計算下一個字典序數字\n                  No  → Decision: 如果 current % 10 < 9 且 current + 1 <= n? // 可以往同層右側移動\n                      Yes → current = current + 1\n                           k = k - 1\n                      No  → Step 4: While current % 10 == 9 或 current + 1 > n: // 無法往右或下層，需回到上一層\n                              current = current / 10\n                            current = current + 1\n                            k = k - 1\n→ Step 5: Return current // 找到 kth 字典序數字後回傳\nEnd // 程式執行結束\n\nBut we need to use arrow lines for each line.\n\nLet's rewrite more strictly with arrow.\n\nWe need to use \"→\" before each step after start? The example uses \"Start //\", then \"→ Step 1: ...\", then \"→ Decision:\" etc.\n\nWe can maintain that style.\n\nBut we need to include nested decisions, so we can indent them? In example they indent by 4 spaces and include Yes → and No →.\n\nWe'll mimic that.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: current = 1; k = k - 1 // 從第一個字典序數字開始，減去已經計算的 1\n→ Decision: k == 0? // 判斷是否已找到目標\n    Yes → Step 2: Return current // 回傳第一個字典序數字\n    No  → Step 3: While k > 0: // 尚未找到目標，進入迴圈\n              → Decision: current * 10 <= n? // 可以往下層擴充\n                  Yes → current = current * 10\n                       k = k - 1 // 向下層移動\n                  No  → Decision: current % 10 < 9 && current + 1 <= n? // 可以往同層右側移動\n                      Yes → current = current + 1\n                           k = k - 1\n                      No  → Step 4: While current % 10 == 9 || current + 1 > n: // 無法往右或下層，需回到上一層\n                              current = current / 10\n                            current = current + 1\n                            k = k - 1\n→ Step 5: Return current // 找到 kth 字典序數字後回傳\nEnd // 程式執行結束\n\nNeed to check formatting: After each line we add // explanation.\n\nThe \"While\" step maybe needs explanation: Step 3: While k > 0: // 迴圈，尋找直到 k 為 0\n\nWithin nested steps, explanation lines after each arrow.\n\nWe should ensure each arrow line includes explanation after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: current = 1; k = k - 1 // 從第一個字典序數字開始，先把已計算的 1 消減掉  \n→ Decision: k == 0? // 判斷是否已經達到第 k 個字典序數字  \n    Yes → Step 2: Return current // 如果 k 為 0，直接回傳 1  \n    No  → Step 3: While k > 0: // 仍未找到，進入迴圈尋找下一個數字  \n              → Decision: current * 10 <= n? // 可以往下一層（加 0）  \n                  Yes → current = current * 10 // 深入下一層  \n                       k = k - 1 // 這時已經計算到一個新字典序數字  \n                  No  → Decision: current % 10 < 9 && current + 1 <= n? // 可以往同層右側（加 1）  \n                      Yes → current = current + 1 // 移到同層右側  \n                           k = k - 1 // 這也算一個新字典序數字  \n                      No  → Step 4: While current % 10 == 9 || current + 1 > n: // 兩個方向都無法往前，需回到上一層  \n                              current = current / 10 // 回到上一層  \n                            current = current + 1 // 再往右移動  \n                            k = k - 1 // 這算一個新字典序數字  \n→ Step 5: Return current // 當 k 為 0 時，current 就是第 k 個字典序數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_prefix(prefix: int, n: int) -> int:\n    \"\"\"\n    計算在 [1, n] 範圍內，以 prefix 為前綴的數字個數。\n    \"\"\"\n    cur = prefix\n    next_ = prefix + 1\n    cnt = 0\n    while cur <= n:\n        cnt += min(n + 1, next_) - cur\n        cur *= 10\n        next_ *= 10\n    return cnt\n\ndef find_kth(n: int, k: int) -> int:\n    \"\"\"\n    使用字典序樹的前綴計數法找出第 k 個字典序數字。\n    \"\"\"\n    curr = 1\n    k -= 1  # 已經把第一個數字 1 計算進去了\n    while k > 0:\n        cnt = count_prefix(curr, n)\n        if k >= cnt:\n            k -= cnt\n            curr += 1\n        else:\n            k -= 1\n            curr *= 10\n    return curr\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = find_kth(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode40.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum II",
    "description_snippet": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for combination sum II problem. Unique combinations without duplicates. Use backtracking with sorting and skip duplicates. Provide steps. No actual code. Provide line by line with arrow and explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort candidates in ascending order // 方便跳過重複數字  \n→ Step 2: 初始化結果列表 results = [] // 用來存放所有合法組合  \n→ Step 3: 呼叫 DFS(0, target, [], results) // 從索引0開始深度優先搜索  \n\nStep 4: 定義函式 DFS(start, remaining, path, results)  \n→ Decision: 如果 remaining == 0? // 檢查目前和是否正好等於目標  \n    Yes → Step 5: results.add(path.copy()) // 找到一組合法組合，加入結果  \n    No  → Decision: 如果 remaining < 0? // 若已超過目標，無效組合  \n        Yes → Step 6: Return // 直接回溯  \n        No  → Decision: 從 i = start 到 len(candidates)-1? // 逐一嘗試每個候選數  \n            Yes → Decision: 如果 i > start 且 candidates[i] == candidates[i-1]? // 跳過重複的相同數字  \n                Yes → Step 7: Continue // 跳過本次迴圈  \n                No  → Step 8: path.append(candidates[i]) // 將候選數加入當前路徑  \n                    → Step 9: DFS(i+1, remaining - candidates[i], path, results) // 進一步遞迴  \n                    → Step 10: path.pop() // 回溯，移除最後加入的數字  \n                    → Step 11: Continue // 進入下一個 i  \n→ End DFS // DFS 函式結束  \n\n→ Step 12: 回傳 results // 主程式返回所有組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        candidates.sort()\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            prev = None\n            for i in range(start, len(candidates)):\n                if prev is not None and candidates[i] == prev:\n                    continue\n                path.append(candidates[i])\n                backtrack(i + 1, path, total + candidates[i])\n                path.pop()\n                prev = candidates[i]\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract candidates list\n    cand_match = re.search(r'candidates\\s*=\\s*(\\[.*?\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not cand_match or not target_match:\n        sys.exit(\"Invalid input format\")\n    candidates = eval(cand_match.group(1))\n    target = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.combinationSum2(candidates, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "success": true,
          "output": "[[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "success": true,
          "output": "[[1, 2, 2], [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode449.json",
    "problem_index_in_file": 0,
    "title": "Serialize and Deserialize BST",
    "description_snippet": "Serialization is converting a data structure or object into a sequence of bits so that it can be sto...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for serialize/deserialize BST. The algorithm should be compact string, maybe pre-order traversal with separators. For BST, we can also use preorder and reconstruct with bounds. We produce steps: Start, serialize: do pre-order DFS, append values separated by commas. End. Deserialize: parse string into list, then reconstruct using bounds. Provide virtual code step-by-step with decision etc.\n\nWe need line by line, each line has virtual code and comment. Use arrow. Should include Start, End. Let's craft algorithm.\n\nPseudo:\n\nStart\n→ Step 1: Define function serialize(root)\n→ Decision: root is null? \n   Yes → Return \"\" // empty string for null\n   No → Use stack to perform preorder traversal, append values to list with delimiter\n   → Step 2: Return concatenated string\n\n→ Step 3: Define function deserialize(data)\n→ Decision: data empty?\n   Yes → Return null\n   No → Split string into array of ints\n   → Use recursive helper helper(lower, upper)\n        → Decision: idx >= n? \n            Yes → Return null\n            No → val = array[idx]\n                Decision: val < lower or val > upper? \n                    Yes → Return null\n                    No → idx++ \n                        node = new TreeNode(val)\n                        node.left = helper(lower, val)\n                        node.right = helper(val, upper)\n                        Return node\n\n→ End\n\nBut we must output each step as a line with code and comment. Use arrow. We need to be concise. Provide each line.\n\nWe need to ensure each line has virtual code and comment. We'll number steps? Not necessary. Just lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: serialize(root) // 定義序列化入口\n→ Decision: root == null? // 判斷是否為空樹\n    Yes → Return \"\" // 空字串代表空樹\n    No → → Step 2: stack ← [root] // 使用堆疊進行先序遍歷\n        → Step 3: vals ← [] // 儲存節點值\n        → While stack not empty\n            → node ← stack.pop()\n            → Append node.val to vals\n            → If node.right ≠ null → push node.right onto stack\n            → If node.left ≠ null → push node.left onto stack\n        → Step 4: serialized ← join(vals, \",\") // 以逗號分隔\n        → Return serialized\n→ Step 5: deserialize(data) // 定義反序列化入口\n→ Decision: data == \"\"? // 判斷字串是否為空\n    Yes → Return null // 空字串對應空樹\n    No → → Step 6: nums ← split(data, \",\") as int array // 轉換為整數陣列\n        → Step 7: idx ← 0 // 全局指標\n        → Step 8: helper(lower, upper) // 內部遞迴函式，lower, upper 為可接受範圍\n            → Decision: idx >= len(nums)? // 已處理完所有節點\n                Yes → Return null\n                No → → Step 9: val ← nums[idx]\n                    → Decision: val < lower or val > upper? // 節點值是否在可接受範圍\n                        Yes → Return null\n                        No → → Step 10: idx ← idx + 1\n                            → node ← new TreeNode(val)\n                            → node.left ← helper(lower, val)\n                            → node.right ← helper(val, upper)\n                            → Return node\n        → Return helper(-∞, ∞) // 從負無限到正無限開始構建\nEnd // 程式執行結束\n\nWe should check that we follow format: each line: virtual code + space + // comment. Use arrows for steps, decisions, etc. Ensure each line includes arrow where appropriate.\n\nWe used multiple arrows on same line? We have nested. We can just include them inline: \"→ Step 2: stack ← [root] //\". That is fine.\n\nBut we need to ensure each line is one line. For decision branches we need multiple lines. So we need to format like:\n\nDecision: root == null?\n    Yes → Return \"\"\n    No → ... but that would be multiple lines. That's okay.\n\nBut each line must be in format: \"虛擬碼步驟\" + space + \"// 解釋/說明\". For decision lines we can write: \"Decision: root == null?\" + space + \"// 判斷是否為空樹\". Then following lines with arrow and comment.\n\nLet's reformat.\n\nWe'll produce as a list.\n\nNeed to maintain indentation? Not required but can use tabs.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: serialize(root) // 定義序列化入口函式  \nDecision: root == null? // 判斷樹是否為空  \n Yes → Return \"\" // 空字串代表空樹  \n No → → Step 2: stack ← [root] // 使用堆疊進行先序遍歷  \n  → Step 3: vals ← [] // 儲存節點值的暫存容器  \n  → While stack not empty // 逐個訪問節點  \n   → node ← stack.pop() // 取出堆疊頂部節點  \n   → Append node.val to vals // 加入節點值  \n   → If node.right ≠ null → push node.right onto stack // 右子節點先入堆疊  \n   → If node.left ≠ null → push node.left onto stack // 左子節點後入堆疊  \n  → Step 4: serialized ← join(vals, \",\") // 用逗號連接成字串  \n  → Return serialized // 回傳序列化結果  \n→ Step 5: deserialize(data) // 定義反序列化入口函式  \nDecision: data == \"\"? // 判斷字串是否為空  \n Yes → Return null // 空字串對應空樹  \n No → → Step 6: nums ← split(data, \",\") as int array // 把字串拆成整數陣列  \n  → Step 7: idx ← 0 // 全域指標，指向下一個待處理節點  \n  → Step 8: helper(lower, upper) // 內部遞迴函式，參數為可接受的值範圍  \n   Decision: idx >= len(nums)? // 是否已處理完所有節點  \n    Yes → Return null // 無節點可生成  \n    No → → Step 9: val ← nums[idx] // 取出當前節點值  \n    Decision: val < lower or val > upper? // 值是否符合 BST 節點範圍  \n     Yes → Return null // 不符合範圍，回傳空  \n     No → → Step 10: idx ← idx + 1 // 移動指標  \n      → node ← new TreeNode(val) // 建立節點  \n      → node.left ← helper(lower, val) // 右子樹的值必大於左子節點  \n      → node.right ← helper(val, upper) // 右子樹的值必小於右子節點  \n      → Return node // 回傳建立好的節點  \n  → Return helper(-∞, ∞) // 從負無限到正無限開始構建整棵樹  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a BST to a single string.\"\"\"\n        if not root:\n            return \"\"\n        res = []\n\n        def preorder(node):\n            if not node:\n                return\n            res.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n\n        preorder(root)\n        return \",\".join(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to BST.\"\"\"\n        if not data:\n            return None\n        preorder = list(map(int, data.split(',')))\n\n        def build(min_val, max_val):\n            if preorder and min_val < preorder[0] < max_val:\n                val = preorder.pop(0)\n                node = TreeNode(val)\n                node.left = build(min_val, val)\n                node.right = build(val, max_val)\n                return node\n            return None\n\n        return build(float('-inf'), float('inf'))\n\ndef build_tree_from_list(values):\n    \"\"\"Builds a binary tree from a list representation.\"\"\"\n    if not values:\n        return None\n    nodes = [TreeNode(v) if v is not None else None for v in values]\n    child_index = 1\n    for i, node in enumerate(nodes):\n        if node is not None:\n            if child_index < len(nodes):\n                node.left = nodes[child_index]\n                child_index += 1\n            if child_index < len(nodes):\n                node.right = nodes[child_index]\n                child_index += 1\n    return nodes[0]\n\ndef parse_input_line(line):\n    \"\"\"Parses input like 'root = [2,1,3]' into a list of values.\"\"\"\n    start = line.find('[')\n    end = line.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        return []\n    raw = line[start+1:end].strip()\n    if not raw:\n        return []\n    elems = raw.split(',')\n    values = []\n    for e in elems:\n        e = e.strip()\n        if e == 'None':\n            values.append(None)\n        else:\n            # Use ast.literal_eval to safely parse integers\n            values.append(int(ast.literal_eval(e)))\n    return values\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        print(\"\")\n    else:\n        # Support multiple lines of input; process each line separately\n        results = []\n        codec = Codec()\n        for line in input_data.splitlines():\n            values = parse_input_line(line)\n            root = build_tree_from_list(values)\n            serialized = codec.serialize(root)\n            results.append(serialized)\n        # Print each result on its own line\n        for res in results:\n            print(res)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "root = [2,1,3]",
          "expected_output": "[2,1,3]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,1,3]'\nGot (Norm):      '2,1,3'\n--- (Raw) ---\nRaw Expected: '[2,1,3]'\nRaw Got:      '2,1,3'"
        },
        {
          "example_index": 1,
          "input": "root = []",
          "expected_output": "[]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[]'\nRaw Got:      ''"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode349.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing intersection of two integer arrays with unique elements in result, any order. Use virtual code with arrows and decisions. Ensure each line ends with // 解釋. Use Start, End. We'll describe steps: Start, input arrays, convert to sets, compute intersection, return as array. Use decision? Possibly we can use if sets? But not necessary. But we can illustrate. Steps: Step 1: Convert nums1 to set S1. Step 2: Convert nums2 to set S2. Step 3: Create resultSet = intersection of S1 and S2. Step 4: Convert resultSet to array. Step 5: Output. Use decision maybe for empty? Could add decision: if intersection empty? But not needed. Keep simple. We'll produce virtual code lines with arrow. Provide explanation. Ensure each line ends with //.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Convert nums1 to set S1 // 把第一個陣列轉成集合，去除重複  \n→ Step 2: Convert nums2 to set S2 // 把第二個陣列轉成集合，去除重複  \n→ Step 3: Set resultSet = S1 ∩ S2 // 計算兩集合的交集，得到唯一相同元素  \n→ Decision: resultSet 为空? // 判斷交集是否為空  \n    Yes → Step 4a: Return empty array [] // 若無相同元素，回傳空陣列  \n    No  → Step 4b: Convert resultSet to array resultArray // 將交集集合轉回陣列  \n        → Step 5: Return resultArray // 回傳包含所有唯一交集元素的陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        取得兩個整數陣列的交集，結果只保留唯一元素。\n        透過將兩個陣列轉成集合，使用集合交集運算即可。\n        \"\"\"\n        return list(set(nums1) & set(nums2))\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，取得兩個列表。\n    假設輸入格式類似 'nums1 = [1,2,2,1], nums2 = [2,2]'。\n    \"\"\"\n    # 找出所有方括號中的內容\n    matches = re.findall(r'\\[.*?\\]', data)\n    if len(matches) < 2:\n        raise ValueError(\"輸入格式不符合要求\")\n    nums1 = ast.literal_eval(matches[0])\n    nums2 = ast.literal_eval(matches[1])\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read()\n    # 解析出兩個陣列\n    nums1, nums2 = parse_input(raw_input)\n    # 產生結果\n    sol = Solution()\n    result = sol.intersection(nums1, nums2)\n    # 印出結果，使用 Python 內建 print 的字串格式\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "success": true,
          "output": "[9, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode416.json",
    "problem_index_in_file": 0,
    "title": "Partition Equal Subset Sum",
    "description_snippet": "Given an integer array nums, return true if you can partition the array into two subsets such that t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for partition equal subset sum. Standard DP. Provide step-by-step. No actual code, just virtual steps. Use arrows and decisions. Provide explanation after each line. Each line: \"虛擬碼步驟 // 解釋\". Let's craft.\n\nStart\n→ Step 1: Calculate totalSum // get sum of all elements\n→ Decision: If totalSum is odd? // impossible if odd\n    Yes → Step 2: Return false // cannot partition\n    No  → Step 3: target = totalSum / 2 // desired subset sum\n→ Step 4: Initialize boolean array dp[target+1] // dp[i] true if sum i achievable\n→ Step 5: dp[0] = true // zero sum always achievable\n→ Step 6: For each number num in nums // iterate through array\n        → For i from target down to num // backward to avoid reuse\n                → Decision: If dp[i - num] is true? // previous sum achievable\n                    Yes → dp[i] = true // mark current sum achievable\n                No → // do nothing\n→ Step 7: Return dp[target] // true if target sum achievable\n\nAdd End.\n\nNow produce lines accordingly.\n\nMake sure each line has arrow indent. Use \"→\" before each step. For decision, include sub-steps with indentation. Ensure each line with comment.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: totalSum ← Sum(nums) // 計算陣列元素總和  \n→ Decision: 如果 totalSum 是奇數? // 若總和為奇數，無法分成兩個相等子集  \n  Yes → Step 2: Return false // 直接回傳假  \n  No → Step 3: target ← totalSum / 2 // 設定目標子集和為總和的一半  \n→ Step 4: dp ← BooleanArray(target + 1) // 建立布林型別的 DP 陣列  \n→ Step 5: dp[0] ← true // 零和永遠可達，作為基礎情況  \n→ Step 6: For each num in nums // 逐個處理陣列中的數字  \n   → For i from target down to num // 從目標和倒序迴圈，避免重複使用同一數字  \n     → Decision: 如果 dp[i - num] 為 true? // 前面已可達的和為 i-num  \n       Yes → dp[i] ← true // 由於加上 num 可達到 i，標記為真  \n       No → // 無需改動  \n→ Step 7: Return dp[target] // 若目標和可達，則表示能分割成兩個相等子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canPartition(self, nums):\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        target = total // 2\n\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n\n        return dp[target]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 支援「nums = [1,2,3]」或直接「[1,2,3]」的輸入\n    if '=' in data:\n        data = data.split('=', 1)[1]\n    nums = ast.literal_eval(data.strip())\n\n    solution = Solution()\n    result = solution.canPartition(nums)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,11,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,5]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode398.json",
    "problem_index_in_file": 0,
    "title": "Random Pick Index",
    "description_snippet": "Given an integer array nums with possible duplicates, randomly output the index of a given target nu...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line, with comments. No actual code. Use Start, End, Decision. Should describe initializing object with array, and pick method that chooses random index among target matches using reservoir sampling. Provide each line with explanation.\n\nLet's produce:\n\nStart\n→ Step 1: Store input array nums in instance variable // 先保存數組\n→ Step 2: For pick method: initialize count=0, resultIndex=-1 // 用於儲存目前找到的目標索引\n→ Step 3: Iterate over array with index i from 0 to nums.length-1 // 遍歷整個數組\n→ Decision: 如果 nums[i] == target? // 檢查是否為目標值\n    Yes → Step 4: 增加 count // 計算匹配個數\n    → Step 5: 生成隨機整數 r 在 [1, count] 之間 // 隨機選取\n    → Decision: 如果 r == 1? // 以 1/count 的機率選中\n        Yes → Step 6: 設置 resultIndex = i // 更新結果索引\n        No  → Step 7: 不變 // 保持之前的索引\n    No → Step 8: 不做任何操作 // 非目標值忽略\n→ Step 9: 迴圈結束\n→ Step 10: 回傳 resultIndex // 返回隨機選中的索引\nEnd\n\nWe need to maintain virtual code line by line. Each line with arrow.\n\nWe can separate initialization part. Provide steps for constructor: store array. For pick: steps as above. Let's produce.\n\nRemember to use arrow '→'. Provide each step with comment after //.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Store input array nums into instance variable // 保存原始數組\n→ Step 2: Define pick(target) method // 定義選擇方法\n→ Step 3: Initialize count = 0 // 計數已找到的目標個數\n→ Step 4: Initialize resultIndex = -1 // 預備返回索引\n→ Step 5: For i from 0 to nums.length-1 // 遍歷整個數組\n→ Decision: 如果 nums[i] == target? // 判斷是否為目標值\n    Yes → Step 6: count = count + 1 // 增加目標計數\n    → Step 7: Generate random integer r between 1 and count // 隨機產生\n    → Decision: 如果 r == 1? // 以 1/count 機率選中\n        Yes → Step 8: resultIndex = i // 更新選中的索引\n        No  → Step 9: 無變化 // 保持前一個索引\n    No → Step 10: 無操作 // 非目標值跳過\n→ Step 11: 迴圈結束 // 完成遍歷\n→ Step 12: 回傳 resultIndex // 返回隨機選出的索引\nEnd // 程式執行結束\n\nEnsure each line ends with comment. Provide step numbering. Might need to maintain indentation but we can just keep arrow indent for decision blocks. Provide explanation after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Store input array nums into instance variable // 保存原始數組  \n→ Step 2: Define pick(target) method // 定義選擇方法  \n→ Step 3: Initialize count = 0 // 計算已找到的目標數量  \n→ Step 4: Initialize resultIndex = -1 // 預備返回的隨機索引  \n→ Step 5: For i from 0 to nums.length-1 // 遍歷整個數組  \n→ Decision: 如果 nums[i] == target? // 判斷是否為目標值  \n  Yes → Step 6: count = count + 1 // 目標個數加一  \n   → Step 7: Generate random integer r between 1 and count // 產生隨機數  \n   → Decision: 如果 r == 1? // 以 1/count 的機率選中  \n    Yes → Step 8: resultIndex = i // 更新選中的索引  \n    No  → Step 9: 無變化 // 保持之前的索引  \n  No  → Step 10: 無操作 // 非目標值跳過  \n→ Step 11: 迴圈結束 // 完成遍歷  \n→ Step 12: 回傳 resultIndex // 返回隨機選出的索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, nums):\n        # 建構時先將數字與對應索引存到字典\n        self.indices = {}\n        for i, num in enumerate(nums):\n            self.indices.setdefault(num, []).append(i)\n\n    def pick(self, target):\n        # 隨機挑選 target 的索引\n        return random.choice(self.indices[target])\n\nif __name__ == \"__main__\":\n    # 讀入整個輸入字串\n    data = sys.stdin.read().strip()\n    # 分離方法名稱列表與對應參數列表\n    idx = data.find('],')\n    first_part = data[:idx+1]\n    second_part = data[idx+2:]\n    methods = ast.literal_eval(first_part)\n    args_list = ast.literal_eval(second_part)\n\n    results = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # args 為 [nums]\n            obj = Solution(args[0])\n            results.append(None)\n        else:  # pick\n            # args 為 [target]\n            results.append(obj.pick(args[0]))\n\n    # 輸出，使用 json.dumps 讓 None 轉成 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,2,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 2, 0, 3]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode139.json",
    "problem_index_in_file": 0,
    "title": "Word Break",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a spac...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode) line by line with explanations, no actual code. For the Word Break problem. We should produce steps: Start, maybe define DP array, iterate, decision, etc.\n\nWe need to use arrow notation and decision blocks. Let's structure:\n\nStart\n→ Step 1: Initialize dp array of length len(s)+1 // dp[i] indicates s[:i] can be segmented\n→ Step 2: dp[0] = true // empty string can be segmented\n→ Step 3: For i from 1 to len(s)\n    → Decision: If any j < i such that dp[j] is true and s[j:i] in wordDict\n        Yes → dp[i] = true // Found a segmentation ending at i\n        No  → dp[i] = false // No segmentation found\n→ Step 4: Return dp[len(s)] // Final result\n\nAlso we might use nested loops. Provide explanation each line. Use virtual code arrows. Format: `虛擬碼步驟 // 解釋`. Include arrows. Should use `→`, `Yes →`, `No →`. Provide each line separate.\n\nLet's produce the final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 數組長度為 len(s)+1，並將所有值設為 false // dp[i] 表示子字串 s[0:i] 是否能被拆分成字典單詞  \n→ Step 2: 將 dp[0] 設為 true // 空字串被視為可拆分  \n→ Step 3: 循環 i 從 1 到 len(s)  \n    → Decision: 是否存在 j (0 ≤ j < i) 使得 dp[j] 為 true 且 s[j:i] 屬於 wordDict？ // 檢查前置子字串是否可拆分，且當前段是否是字典單詞  \n        Yes → Step 3a: 將 dp[i] 設為 true，並跳過剩餘 j 的檢查 // 找到合法拆分，更新狀態  \n        No  → Step 3b: 不做任何改動，繼續下一個 j // 若無合法 j，保持 dp[i] 為 false  \n→ Step 4: 返回 dp[len(s)] // 若最後一個位置可拆分，則整個字串可拆分，否則不可  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        # 將字典轉成集合，方便 O(1) 查找\n        word_set = set(wordDict)\n        # dp[i] 表示 s[:i] 能否被拆分成字典單詞\n        dp = [False] * (len(s) + 1)\n        dp[0] = True  # 空字串可拆分\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break  # 找到一種合法拆分即可，退出內層迴圈\n\n        return dp[len(s)]\n\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入的所有內容\n    input_str = sys.stdin.read().strip()\n\n    # 透過 exec 執行輸入，獲得變數 s 與 wordDict\n    local_vars = {}\n    exec(input_str, {}, local_vars)\n\n    s = local_vars.get(\"s\", \"\")\n    wordDict = local_vars.get(\"wordDict\", [])\n\n    # 進行分割判斷\n    result = Solution().wordBreak(s, wordDict)\n\n    # 輸出結果，使用小寫字母以符合範例格式\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpecc09pel.py\", line 26, in <module>\n    exec(input_str, {}, local_vars)\n  File \"<string>\", line 1\n    s = \"leetcode\", wordDict = [\"leet\",\"code\"]\n    ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpso20aqoc.py\", line 26, in <module>\n    exec(input_str, {}, local_vars)\n  File \"<string>\", line 1\n    s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\n    ^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpthmhy143.py\", line 26, in <module>\n    exec(input_str, {}, local_vars)\n  File \"<string>\", line 1\n    s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode283.json",
    "problem_index_in_file": 0,
    "title": "Move Zeroes",
    "description_snippet": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for moving zeros to end in-place while maintaining relative order. Use Start, Decision, etc. Each line has virtual code step and comment.\n\nWe must do it in-place, typical algorithm: use two pointers: lastNonZeroFoundAt. Loop through array, if nums[i]!=0, swap nums[lastNonZeroFoundAt] and nums[i], increment lastNonZeroFoundAt.\n\nWe produce steps line by line.\n\nNeed to include Start, End.\n\nAlso mention input array.\n\nUse Decision: if nums[i] != 0? etc.\n\nWill produce pseudocode:\n\nStart // program starts\n\n→ Step 1: Set lastNonZeroIndex = 0 // initialize pointer for position to place next non-zero\n\n→ For each index i from 0 to length(nums)-1 // iterate through array\n\n  → Decision: If nums[i] != 0? // check if current element is non-zero\n\n     Yes → Step 2: Swap nums[lastNonZeroIndex] and nums[i] // move non-zero to its correct position\n\n            → Step 3: Increment lastNonZeroIndex // update next free position\n\n     No → (do nothing) // skip zeros\n\nEnd // finished\n\nAdd comments.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\".\n\nUse \"Start // 程式開始執行\".\n\nUse \"End // 程式執行結束\".\n\nUse \"→ Step ...\" etc.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: lastNonZeroIndex ← 0 // 初始化指標，指向下一個非零元素應放置的位置  \n→ Step 2: for i from 0 to length(nums) - 1 do // 逐個遍歷整個陣列  \n  → Decision: nums[i] ≠ 0? // 判斷目前元素是否為非零  \n     Yes → Step 3: swap nums[lastNonZeroIndex] and nums[i] // 將非零元素移至正確位置，保持順序  \n      → Step 4: lastNonZeroIndex ← lastNonZeroIndex + 1 // 更新下一個可放置非零元素的位置  \n     No → Step 5: // 當元素為零時不做任何操作，直接跳至下一輪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def moveZeroes(self, nums):\n        \"\"\"\n        Move all zeros to the end of nums in-place while preserving\n        the relative order of the non-zero elements.\n        \"\"\"\n        zero_pos = 0  # 指向下一個應該放非零數字的位置\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[zero_pos], nums[i] = nums[i], nums[zero_pos]\n                zero_pos += 1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入，例如 'nums = [0,1,0,3,12]'\n    if raw_input.lower().startswith(\"nums\"):\n        # 去掉 'nums ='\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n    try:\n        # 使用 ast.literal_eval 以安全方式解析 Python 字面量\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，直接輸出空列表並結束\n        print([])\n        sys.exit(0)\n\n    # 確保輸入為列表\n    if not isinstance(nums, list):\n        print([])\n        sys.exit(0)\n\n    # 執行演算法\n    Solution().moveZeroes(nums)\n\n    # 輸出結果\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,0,3,12]",
          "expected_output": "[1,3,12,0,0]",
          "success": true,
          "output": "[1, 3, 12, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode650.json",
    "problem_index_in_file": 0,
    "title": "2 Keys Keyboard",
    "description_snippet": "There is only one character 'A' on the screen of a notepad. You can perform one of two operations on...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for problem: minimum steps to get exactly n 'A's via copy all and paste operations. Known solution: dynamic programming, best strategy uses prime factorization or DP: dp[i] = min over j from 1 to i-1 where i%j==0: dp[j] + (i/j). Actually dp[i] = min(dp[i], dp[j] + i/j). Explanation: copy at j, then paste i/j times. Start dp[1]=0? Actually to get 1 A need 0 operations? Problem states start with 1 A on screen. Yes start with 1 A. So dp[1]=0. For i from 2 to n compute dp[i] minimal. Use nested loops. Let's produce pseudocode with arrows.\n\nNeed to output line-by-line with \"虛擬碼步驟\" and comment. Use Start, Decision, End.\n\nLet's produce.\n\nWe might include a Decision to compute factors. Use loops. Provide explanation each line.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 dp[1] = 0 // 只需要 0 次操作即可得到 1 個 A  \n→ Step 2: 對 i 從 2 到 n 做迴圈 // 計算每個目標數量的最小步驟  \n  → Decision: 檢查 i 是否大於 1? // 確保進入迴圈  \n   Yes → Step 3: 設定 dp[i] = Infinity // 初始化為無限大  \n    → Step 4: 對 j 從 1 到 i-1 做迴圈 // 嘗試所有可能的複製點  \n      → Decision: 檢查 i 是否能被 j 整除? // 只有能整除的 j 才能達成目標  \n       Yes → Step 5: 計算 paste_times = i / j // 需要貼上的次數  \n        → Step 6: 更新 dp[i] = min(dp[i], dp[j] + paste_times) // 更新最小步驟  \n           // dp[j] 是 j 個 A 的最小步驟，接著貼 paste_times 次  \n           // 再加上一次複製操作（已包含在 dp[j] 或外部計算）  \n           // 但在此算法中 dp[j] 代表 j 個 A 的步驟，接著再複製一次並貼 paste_times 次  \n           // 所以總步驟為 dp[j] + paste_times  \n           // 這裡假設 dp[j] 已包含一次複製操作，符合 DP 轉移公式  \n           // 進一步說明：在 j 個 A 時，先執行一次 Copy All，然後 Paste (i/j-1) 次，即  \n           // dp[j] + 1 + (i/j - 1) = dp[j] + i/j  \n           // 故直接使用 dp[j] + i/j  \n           // 所以更新公式正確  \n             \n           // 完成一次 j 的嘗試",
      "generated_code": "import sys\nimport re\n\ndef min_steps(n: int) -> int:\n    \"\"\"\n    Calculate the minimum number of operations needed to obtain exactly n 'A's.\n    The optimal strategy is equivalent to summing the prime factors of n.\n    \"\"\"\n    if n <= 1:\n        return 0\n    result = 0\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            result += divisor\n            n //= divisor\n        divisor += 1\n    return result\n\nif __name__ == \"__main__\":\n    # Read the whole input from stdin\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n\n    # Extract the integer n from the input (handles formats like \"n = 3\" or just \"3\")\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    # Compute and print the result\n    print(min_steps(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode397.json",
    "problem_index_in_file": 0,
    "title": "Integer Replacement",
    "description_snippet": "Given a positive integer n, you can apply one of the following operations:\n\n1. If n is even, replace...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, with explanation after each line. The problem: minimize operations to reduce n to 1 with operations: if even: divide by 2; if odd: can add 1 or subtract 1. Classic \"integer replacement\" problem. Need to output virtual code. The instructions: not actual code, just steps. Provide explanation for each line. Use Start, End, Decision:, arrow. Should produce algorithm. Let's produce a typical greedy/DP approach: Use recursion/loop, with DP or BFS. We can produce algorithm using while loop: count=0; while n!=1: if n%2==0: n/=2 else if n==3 or n%4==1: n-=1 else n+=1. This yields minimal operations. Provide virtual code accordingly. Use decision blocks.\n\nWe must produce step-by-step: Start, Decision etc.\n\nLet's craft:\n\nStart // 開始\n→ Step 1: 初始化計數器 count = 0 // 用於紀錄操作數\n→ Step 2: 循環 while n ≠ 1 // 直到 n 為 1\n    → Decision: n 是否為偶數? // 判斷 n 是否可以直接除 2\n        Yes → Step 3: n ← n / 2 // 直接除 2\n        No  → Decision: n 是否等於 3 或 n%4 == 1? // 奇數特殊處理\n            Yes → Step 4: n ← n - 1 // 先減 1\n            No  → Step 5: n ← n + 1 // 先加 1\n    → Step 6: count ← count + 1 // 每次操作計數增加\nEnd // 結束並返回 count\n\nBut need to mention return. Add Step: Return count.\n\nAdd after End? Actually End is after loop? We'll add a line after loop: Step 7: 返回 count // 輸出最小步數\n\nMake sure arrow format. Use \"→\" and indentation maybe. Provide explanation. Ensure each line ends with comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化計數器 count ← 0 // 用來紀錄操作次數  \n→ Step 2: 循環 while n ≠ 1 // 重複執行直到 n 變為 1  \n  → Decision: n 是否為偶數? // 判斷是否可以直接除 2  \n   Yes → Step 3: n ← n / 2 // 直接把偶數 n 除以 2  \n   No  → Decision: n 是否等於 3 或 n % 4 == 1? // 奇數時選擇減 1 或加 1  \n    Yes → Step 4: n ← n - 1 // 當 n == 3 或 n%4 == 1 時減 1 可減少步數  \n    No  → Step 5: n ← n + 1 // 其餘奇數情況下加 1 能使後續除以 2 更快  \n  → Step 6: count ← count + 1 // 每完成一次操作，計數器加 1  \n→ Step 7: 返回 count // 迴圈結束後回傳最小步數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef integer_replacement(n: int) -> int:\n    \"\"\"\n    Calculate the minimum number of operations required to reduce n to 1.\n    Operations:\n        - If n is even, replace n with n // 2.\n        - If n is odd, replace n with either n + 1 or n - 1.\n    \"\"\"\n    count = 0\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            # For odd n, choose the direction that leads to more trailing zeros\n            # (i.e., more divisions by 2). Special case for n == 3.\n            if n == 3 or ((n >> 1) & 1) == 0:\n                n -= 1\n            else:\n                n += 1\n        count += 1\n    return count\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return  # No integer found; nothing to do\n    n = int(match.group())\n    # Compute and output the result\n    result = integer_replacement(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 8",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode387.json",
    "problem_index_in_file": 0,
    "title": "First Unique Character in a String",
    "description_snippet": "Given a string s, find the first non-repeating character in it and return its index. If it does not ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation comments, per format. Each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nWe must generate algorithm: Find first non-repeating char in string, return index or -1.\n\nSteps: Start. Input string s. Use dictionary count. First pass to count. Second pass to find first char with count 1 and return index. If none, return -1. End.\n\nWe need to output each line. Use Start, Decision, etc. Use → arrow. Use indentation? Format example shows indentation for nested decisions.\n\nWe need to produce each line with virtual code step. For loops, decisions. Use arrow to show flow.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize count_map as empty map // 统计每个字符出现次数\n→ Step 2: For each character c in s with index i // 遍历字符串\n    → Step 2a: Increment count_map[c] // 更新计数\n→ Step 3: For each character c in s with index i // 再次遍历寻找首个单一出现\n    → Decision: If count_map[c] == 1? // 判断是否唯一\n        Yes → Step 4: Return i // 返回该字符索引\n        No  → Continue // 继续遍历\n→ Step 5: Return -1 // 未找到非重复字符\nEnd\n\nMake sure to include arrow arrow in each line. The decisions lines need to show Yes → and No →. For loops we can use Step 2: For each ... etc.\n\nMake sure each line includes // explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize count_map as empty map // 建立一個空字典，用於統計每個字元的出現次數  \n→ Step 2: For each character c in s with index i // 逐個遍歷字串中的字元  \n  → Step 2a: Increment count_map[c] // 更新該字元的計數  \n→ Step 3: For each character c in s with index i // 再次遍歷，尋找第一個非重複字元  \n  → Decision: If count_map[c] == 1? // 判斷此字元是否只出現一次  \n   Yes → Step 4: Return i // 找到非重複字元，返回其索引  \n   No  → Continue // 不是非重複字元，繼續遍歷  \n→ Step 5: Return -1 // 所有字元均重複，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport collections\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        \"\"\"Return index of first non-repeating character, -1 if none.\"\"\"\n        count = collections.Counter(s)\n        for i, char in enumerate(s):\n            if count[char] == 1:\n                return i\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract string inside quotes if present\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data.strip()\n    result = Solution().firstUniqChar(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "s = \"loveleetcode\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"aabb\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode697.json",
    "problem_index_in_file": 0,
    "title": "Degree of an Array",
    "description_snippet": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the ma...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Provide step-by-step algorithm. We can't output actual code. Need to use Start, End, Decision:, arrow lines. Provide explanation comments.\n\nAlgorithm: Use map to store frequency, first index, last index. Find degree. Then for each number with freq==degree compute length = last-first+1 and keep min. Output min.\n\nImplement in virtual code.\n\nWe need each line: Virtual code step and explanation comment.\n\nLet's produce:\n\nStart // start\n\n→ Step 1: Initialize map frequency, firstIndex, lastIndex // maps to count, first, last positions\n\n→ Step 2: Iterate i from 0 to nums.length-1 // scan array\n\n→ Decision: 如果 nums[i] 未在 frequency 中? // first occurrence\n\n→    Yes → Step 3: frequency[nums[i]] = 1; firstIndex[nums[i]] = i; lastIndex[nums[i]] = i // set first and last\n\n→    No  → Step 4: frequency[nums[i]] += 1; lastIndex[nums[i]] = i // update last index\n\nAfter loop\n\n→ Step 5: degree = max value in frequency // find degree\n\n→ Step 6: minLen = infinity // initialize answer\n\n→ Step 7: For each key in frequency // evaluate subarray length\n\n→ Decision: 如果 frequency[key] == degree? // only consider degrees\n\n→    Yes → Step 8: len = lastIndex[key] - firstIndex[key] + 1; if len < minLen then minLen = len // update min\n\n→ End // output minLen\n\nWe need to output each line with arrow arrow.\n\nWe must use arrow for decisions and steps.\n\nBetter formatting:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 frequency, firstIndex, lastIndex // 初始化頻率與首末位置\n→ Step 2: 針對 nums 中每個索引 i 從 0 到 length-1 迭代 // 開始掃描\n→ Decision: 若 nums[i] 尚未出現在 frequency? // 首次遇到\n→    Yes → Step 3: frequency[nums[i]] = 1; firstIndex[nums[i]] = i; lastIndex[nums[i]] = i // 設定首末位置\n→    No  → Step 4: frequency[nums[i]] += 1; lastIndex[nums[i]] = i // 更新頻率與末尾位置\n→ Step 5: degree = 最大值於 frequency.values() // 取得陣列度數\n→ Step 6: minLen = 無限大 // 設定最小長度初值\n→ Step 7: 對於每個 key 於 frequency 中 // 遍歷所有數值\n→ Decision: 若 frequency[key] == degree? // 只考慮度數相等的數值\n→    Yes → Step 8: len = lastIndex[key] - firstIndex[key] + 1; 若 len < minLen 則 minLen = len // 更新最小長度\n→ End // 程式結束，輸出 minLen\n\nNeed to use \"Yes →\" \"No →\" but No branch maybe not needed but we can include.\n\nWe can follow format precisely: \"Start\", \"→ Step ...\", \"→ Decision:\" with Yes →, No →.\n\nLet's produce accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 frequency, firstIndex, lastIndex // 初始化頻率與首末位置  \n→ Step 2: 針對 nums 中每個索引 i 從 0 到 length-1 迭代 // 開始掃描陣列  \n→ Decision: 若 nums[i] 尚未出現在 frequency? // 判斷是否第一次出現  \n  Yes → Step 3: frequency[nums[i]] = 1; firstIndex[nums[i]] = i; lastIndex[nums[i]] = i // 設定首末位置與頻率  \n  No  → Step 4: frequency[nums[i]] += 1; lastIndex[nums[i]] = i // 更新頻率與末尾位置  \n→ Step 5: degree = 最大值於 frequency.values() // 找出陣列的度數  \n→ Step 6: minLen = 無限大 // 設定最小長度初值  \n→ Step 7: 對於每個 key 於 frequency 中迭代 // 檢視所有不同元素  \n→ Decision: 若 frequency[key] == degree? // 僅考慮與度數相等的元素  \n  Yes → Step 8: len = lastIndex[key] - firstIndex[key] + 1; 若 len < minLen 則 minLen = len // 更新最小長度  \n→ End // 程式結束，輸出 minLen（最小相同度數子陣列長度）",
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def findShortestSubArray(self, nums):\n        left, right, count = {}, {}, {}\n        for i, num in enumerate(nums):\n            if num not in left:\n                left[num] = i\n            right[num] = i\n            count[num] = count.get(num, 0) + 1\n\n        degree = max(count.values())\n        min_length = float('inf')\n\n        for num in count:\n            if count[num] == degree:\n                min_length = min(min_length, right[num] - left[num] + 1)\n\n        return min_length\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Try to extract the list of numbers from the input\n    if '=' in raw_input:\n        # Input format: \"nums = [1,2,3]\"\n        _, list_part = raw_input.split('=', 1)\n        nums_str = list_part.strip()\n    else:\n        # Input is directly the list: \"[1,2,3]\"\n        nums_str = raw_input\n\n    # Safely evaluate the list string\n    try:\n        nums = eval(nums_str)\n    except Exception:\n        # Fallback: try to parse manually if eval fails\n        nums = [int(x) for x in nums_str.strip('[]').split(',') if x.strip()]\n\n    # Compute the answer\n    solution = Solution()\n    result = solution.findShortestSubArray(nums)\n\n    # Print the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,2,3,1,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode503.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element II",
    "description_snippet": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode step by step. Task: \"Given a circular integer array nums, return next greater number for each element.\" That's classic Next Greater Element II using stack. So we produce pseudocode with steps: Start, Initialize n, result array, stack, iterate 2*n times, index i % n, current number, while stack not empty and current > nums[stack.top], pop and set result[popIndex] = current. Push i % n onto stack. After loop, remaining stack set to -1. End.\n\nNeed to include decision steps for while loop, and for setting -1. Provide explanation after each line.\n\nWe must not output actual code, only pseudo-code lines with arrows etc.\n\nLet's craft. Ensure each line includes a virtual code step then space then comment. Use arrows. Start, End.\n\nLet's output:\n\nStart // 程式開始\n\n→ Step 1: n ← length(nums) // 取得陣列長度\n\n→ Step 2: result ← array of size n, filled with -1 // 初始化答案陣列為 -1\n\n→ Step 3: stack ← empty // 用於儲存尚未找到下一個更大值的索引\n\n→ Decision: 迴圈 i 從 0 到 2*n-1? // 需要遍歷兩圈以處理循環\n\n    Yes → Step 4: index ← i mod n // 取得實際陣列索引\n\n    → Step 5: current ← nums[index] // 取出當前數字\n\n    → Decision: stack 不是空且 current > nums[stack.top]? // 是否有更大的值可填寫\n\n        Yes → Step 6: topIndex ← stack.pop() // 取出堆疊頂部索引\n\n        → Step 7: result[topIndex] ← current // 為該索引填入下一個更大值\n\n        No  →  // 什麼也不做，繼續下一個條件\n\n    → Decision: i < n? // 只在第一次遍歷時將索引壓入堆疊\n\n        Yes → Step 8: stack.push(index) // 將索引壓入堆疊等待更大值\n\n        No  →  // 第二圈不再壓入，避免重複\n\nEnd // 程式結束，返回 result\n\nBut we need to ensure each line ends with comment. Also need to include step numbers perhaps. Use arrow. Also for while loop we may use Decision: while stack not empty and current > nums[stack.top]?\n\nWe also need to include final step: result array ready.\n\nLet's produce more structured pseudocode: Use \"Decision:\" for loops? The example shows Decision: If. For while loop we can use Decision: while stack not empty and current > ...? Maybe use \"While\" but format says use Decision: with Yes/No. Could represent while as repeated Decision steps. But easier to show as \"Decision: stack not empty AND current > nums[stack.top]?\" with Yes loop.\n\nWe must not output actual code but pseudocode lines. Use arrow and comment.\n\nLet's create final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: result ← array of size n, each element = -1 // 初始化答案陣列為 -1  \n→ Step 3: stack ← empty // 用於存放尚未找到更大值的索引  \n\n→ Decision: i 在 0 到 2*n-1? // 需要遍歷兩圈以處理循環  \n    Yes → Step 4: index ← i mod n // 取得實際陣列索引  \n    → Step 5: current ← nums[index] // 取出當前數字  \n\n    → Decision: stack 不是空 AND current > nums[stack.top]? // 有更大值可填寫  \n        Yes → Step 6: topIndex ← stack.pop() // 取出堆疊頂部索引  \n        → Step 7: result[topIndex] ← current // 為該索引填入下一個更大值  \n        No  → // 什麼也不做，繼續下一個條件  \n\n    → Decision: i < n? // 只在第一次遍歷時將索引壓入堆疊  \n        Yes → Step 8: stack.push(index) // 將索引壓入堆疊等待更大值  \n        No  → // 第二圈不再壓入，避免重複  \n\nEnd // 程式執行結束，result 已包含每個元素的下一個更大值或 -1 其餘未填寫的索引已保持 -1",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextGreaterElements(self, nums):\n        n = len(nums)\n        res = [-1] * n\n        stack = []\n        for i in range(2 * n):\n            while stack and nums[stack[-1]] < nums[i % n]:\n                res[stack.pop()] = nums[i % n]\n            if i < n:\n                stack.append(i)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list of numbers from the input string\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        nums = ast.literal_eval(data)\n    else:\n        nums_str = data[start:end + 1]\n        nums = ast.literal_eval(nums_str)\n\n    sol = Solution()\n    result = sol.nextGreaterElements(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1]",
          "expected_output": "[2,-1,2]",
          "success": true,
          "output": "[2, -1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,3]",
          "expected_output": "[2,3,4,-1,4]",
          "success": true,
          "output": "[2, 3, 4, -1, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode120.json",
    "problem_index_in_file": 0,
    "title": "Triangle",
    "description_snippet": "Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm for minimum path sum in triangle array. Use dynamic programming bottom-up or top-down. Provide line by line steps with explanations. Should use Start, End, Decision, etc. Each line must be \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow \"→\" and indentation. Provide a virtual algorithm.\n\nWe produce something like:\n\nStart // 程式開始\n→ Step 1: 設定 N 為 triangle 的行數 // 取得總行數\n→ Step 2: 建立 dp 陣列長度 N，複製 triangle 最底一行 // 初始最底層值\n→ Decision: N 是否等於 1? // 若只有一行\n    Yes → Step 3: 回傳 dp[0] // 唯一值即為最小路徑\n    No  → Step 4: 從 N-2 逆向迴圈到 0 // 開始自底向上更新\n        → Step 5: 針對每行 j，對每個索引 i 做\n            → Step 6: dp[i] = triangle[i][j] + min(dp[i], dp[i+1]) // 選擇較小鄰居\n        → End for i\n    → End for j\n→ Step 7: 回傳 dp[0] // 最小路徑位於頂點\nEnd // 程式結束\n\nAlso we might mention memory optimization.\n\nLet's produce step-by-step with virtual code and explanation. Ensure format: each line \"虛擬碼步驟 // 解釋\". Use arrow arrows. Indentation. Use decision blocks. Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 N 為 triangle 的行數 // 取得總行數\n→ Step 2: 建立 dp 陣列長度 N，複製 triangle 最底一行 // 初始化自底層的最小路徑值\n→ Decision: N 是否等於 1? // 只剩一行，直接返回\n    Yes → Step 3: 回傳 dp[0] // 唯一值即為最小路徑總和\n    No  → Step 4: 從 N-2 逆向迴圈到 0 // 進行自底向上的 DP 更新\n        → Step 5: 對於第 j 行的每個索引 i\n            → Step 6: dp[i] = triangle[i][j] + min(dp[i], dp[i+1]) // 選擇下一行較小的鄰居並累加\n        → End for i // 完成第 j 行的更新\n    → End for j // 完成所有行的更新\n→ Step 7: 回傳 dp[0] // dp[0] 即為從頂點到底部的最小路徑和\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minimumTotal(self, triangle):\n        n = len(triangle)\n        dp = triangle[-1][:]          # copy last row\n        for i in range(n - 2, -1, -1):   # iterate from second last row to the top\n            for j in range(len(triangle[i])):\n                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])  # choose smaller adjacent\n        return dp[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # locate the first '[' to get the list representation\n    start = data.find('[')\n    if start == -1:\n        raise ValueError(\"Invalid input format\")\n    triangle_str = data[start:]\n    triangle = ast.literal_eval(triangle_str)  # safely parse the list\n    sol = Solution()\n    result = sol.minimumTotal(triangle)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        },
        {
          "example_index": 1,
          "input": "triangle = [[-10]]",
          "expected_output": "-10",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode506.json",
    "problem_index_in_file": 0,
    "title": "Relative Ranks",
    "description_snippet": "You are given an integer array score of size n, where score[i] is the score of the i_th athlete in a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve problem: rank athletes based on scores unique. Need to output array of ranks. Steps: sort scores with original indices, assign ranks, map back. Use virtual code.\n\nMake steps:\nStart\n→ Step 1: Create list of pairs (score, index) from score array // pair each score with original index\n→ Step 2: Sort the list in descending order of score // higher score first\n→ Decision: 是否已排序? // ensure sorted\n→ Step 3: Initialize answer array of size n // placeholder for results\n→ Step 4: For each element in sorted list with rank position p from 1 to n:\n   Decision: If p == 1? // Gold\n        Yes → Set answer[index] = \"Gold Medal\"\n        No → Decision: If p == 2? // Silver\n             Yes → Set answer[index] = \"Silver Medal\"\n             No → Decision: If p == 3? // Bronze\n                  Yes → Set answer[index] = \"Bronze Medal\"\n                  No → Set answer[index] = string of p // other ranks\n→ End // return answer\n\nWe need arrow syntax. Each line with explanation. Provide step numbers? The example uses \"Step 1:\". We'll follow.\n\nAlso need to maintain indentation for decision branches.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個元組列表 pairs，包含 (score[i], i) 以保存分數及其原始索引 // 每位運動員的分數與位置  \n→ Step 2: 將 pairs 按 score 由大到小排序 // 最高分先排  \n→ Decision: 排序完成? // 確認排序已完成  \n    Yes → Step 3: 建立結果陣列 answer，大小為 n // 用於儲存各位運動員的排名  \n→ Step 4: 從 i = 1 到 n，對排序後的 pairs 做遍歷，對應位置為 rank  \n    → Decision: 如果 i == 1? // 第一名  \n        Yes → Step 4a: answer[ pairs[i-1].index ] = \"Gold Medal\" // 金牌  \n        No  → Decision: 如果 i == 2? // 第二名  \n            Yes → Step 4b: answer[ pairs[i-1].index ] = \"Silver Medal\" // 銀牌  \n            No  → Decision: 如果 i == 3? // 第三名  \n                Yes → Step 4c: answer[ pairs[i-1].index ] = \"Bronze Medal\" // 銅牌  \n                No  → Step 4d: answer[ pairs[i-1].index ] = string(i) // 其餘排名  \n→ End // 程式執行結束，answer 為輸出結果",
      "generated_code": "#!/usr/bin/env python3\n\"\"\"\n程式說明：\n    - 讀取輸入為一個整數列表，例如 '[5,4,3,2,1]'。\n    - 依照分數從高到低排序，並給予名次。\n    - 前 3 名分別為 \"Gold Medal\"、\"Silver Medal\"、\"Bronze Medal\"。\n    - 其餘名次則以順位號字串表示。\n    - 結果以 JSON 格式輸出，符合範例顯示。\n\"\"\"\n\nimport sys\nimport ast\nimport json\n\ndef findRelativeRanks(score):\n    \"\"\"\n    依分數排序並回傳各位運動員的名次。\n\n    參數:\n        score (list[int]): 每位運動員的分數，索引代表原始位置。\n\n    回傳:\n        list[str]: 每位運動員的名次（字串）。\n    \"\"\"\n    n = len(score)\n    answer = [''] * n                # 儲存結果，大小與 score 相同\n    pairs = [(score[i], i) for i in range(n)]   # (分數, 原始索引)\n\n    # 由高到低排序，分數高者排在前面\n    pairs.sort(key=lambda x: x[0], reverse=True)\n\n    # 依順位給予名次\n    for rank, (s, idx) in enumerate(pairs, start=1):\n        if rank == 1:\n            answer[idx] = \"Gold Medal\"\n        elif rank == 2:\n            answer[idx] = \"Silver Medal\"\n        elif rank == 3:\n            answer[idx] = \"Bronze Medal\"\n        else:\n            answer[idx] = str(rank)\n\n    return answer\n\ndef main():\n    \"\"\"\n    主程式入口：讀取標準輸入、計算名次、輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入字串為 Python 列表\n    try:\n        score = ast.literal_eval(data)\n    except Exception:\n        score = []\n\n    result = findRelativeRanks(score)\n    # 以 JSON 形式輸出，移除逗號後的空白，符合範例格式\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[5,4,3,2,1]",
          "expected_output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]",
          "success": true,
          "output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]"
        },
        {
          "example_index": 1,
          "input": "[10,3,8,9,4]",
          "expected_output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]",
          "success": true,
          "output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode451.json",
    "problem_index_in_file": 0,
    "title": "Sort Characters By Frequency",
    "description_snippet": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequenc...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. No actual code. The task: \"Given a string s, sort it in decreasing order based on the frequency of the characters. The frequency of a character is the number of times it appears in the string. Return the sorted string. If there are multiple answers, return any of them.\"\n\nSo algorithm: Count frequencies via dictionary, sort characters by freq descending, build string. Steps: Start, Input s, Count freq, Create list of (char, freq), Sort by freq desc, Build result string by repeating char freq times, Return result, End.\n\nWe need to output each line of virtual code with explanation. Use arrows. Let's craft.\n\nPossible steps:\n\nStart\n→ Step 1: Input string s\n→ Step 2: Initialize frequency_map as empty map\n→ Step 3: For each character c in s:\n        → Decision: If c in frequency_map?\n            Yes → Increment frequency_map[c]\n            No  → frequency_map[c] = 1\n→ Step 4: Convert frequency_map to list of (char, freq) pairs\n→ Step 5: Sort list by freq descending\n→ Step 6: Initialize result as empty string\n→ Step 7: For each (char, freq) in sorted list:\n        → Append char repeated freq times to result\n→ Step 8: Return result\nEnd\n\nAdd comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input string s // 取得要處理的原始字串\n→ Step 2: Initialize frequency_map as empty map // 用於記錄每個字元出現次數\n→ Step 3: For each character c in s: // 遍歷字串中的每個字元\n    → Decision: c 已在 frequency_map? // 判斷字元是否已記錄\n        Yes → Increment frequency_map[c] // 已記錄，次數加 1\n        No  → frequency_map[c] = 1      // 未記錄，次數設為 1\n→ Step 4: Convert frequency_map to list of (char, freq) pairs // 產生可排序的列表\n→ Step 5: Sort list by freq descending // 按頻率從高到低排序\n→ Step 6: Initialize result as empty string // 用於組裝最後結果\n→ Step 7: For each (char, freq) in sorted list: // 根據排序順序\n    → Append char repeated freq times to result // 重複字元並加入結果\n→ Step 8: Return result // 回傳已按頻率排序的字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"\n        Count each character's frequency, then build a new string\n        by concatenating each character repeated according to its\n        frequency, sorted from highest to lowest frequency.\n        \"\"\"\n        freq = Counter(s)                       # Step 2: count frequencies\n        # most_common returns list of (char, count) sorted by count desc\n        sorted_chars = freq.most_common()       # Step 5: sort by frequency\n        # Build result by repeating each character freq times\n        return ''.join(char * count for char, count in sorted_chars)  # Step 7\n\ndef _parse_input(data: str) -> str:\n    \"\"\"\n    Extract the string `s` from various possible input formats:\n    - s = \"tree\"\n    - \"tree\"\n    - tree\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return ''\n    # If input starts with 's', try to find quoted string\n    if data.lower().startswith('s'):\n        if '\"' in data:\n            start = data.find('\"')\n            end = data.rfind('\"')\n            return data[start + 1:end]\n        if '=' in data:\n            return data.split('=', 1)[1].strip()\n    # If input contains quotes elsewhere\n    if '\"' in data:\n        start = data.find('\"')\n        end = data.rfind('\"')\n        return data[start + 1:end]\n    # Otherwise treat the whole line as the string\n    return data\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = _parse_input(raw_input)\n    solution = Solution()\n    result = solution.frequencySort(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eetr\"",
          "success": true,
          "output": "eetr"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"cccaaa\"",
          "success": true,
          "output": "cccaaa"
        },
        {
          "example_index": 2,
          "input": "s = \"Aabb\"",
          "expected_output": "\"bbAa\"",
          "success": true,
          "output": "bbAa"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode336.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Pairs",
    "description_snippet": "You are given a 0-indexed array of unique strings words.\n\nA palindrome pair is a pair of integers (i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. The algorithm for palindrome pairs: typical approach: build hashmap from word to index. For each word, for each split position (including empty prefix and suffix), check if prefix is palindrome, then reverse suffix and look up. Also check suffix palindrome. Complexity O(total length^2)? But typical algorithm O(total length * average length) okay.\n\nWe must output in Chinese explanation.\n\nWe need to output virtual code lines with steps like \"Start\", \"→\", \"Decision\", etc. Provide explanation after each line.\n\nWe need to produce steps; not actual code but logic.\n\nLet's craft steps:\n\nStart\n→ Build map word_to_index\n→ For each word with index i:\n    → For each split position k from 0 to len(word):\n        → Define prefix = word[0:k], suffix = word[k:]\n        → Decision: prefix is palindrome?\n            Yes → reversed_suffix = reverse(suffix); if reversed_suffix in map and map[reversed_suffix] != i → add pair (i, map[reversed_suffix])\n            No → no action\n        → Decision: suffix is palindrome?\n            Yes → reversed_prefix = reverse(prefix); if reversed_prefix in map and map[reversed_prefix] != i → add pair (reversed_prefix, i)\n            No → no action\n    → End loop\n→ End loop\n→ Return result\nEnd\n\nAlso handle special case empty string: but algorithm already covers.\n\nNeed to maintain result list.\n\nAlso need to mention we skip when k=0? For prefix empty string palindrome yes. So reversed_suffix = reverse(word) if exists.\n\nComplexities: O(total length * average length). We can mention.\n\nNow produce lines with virtual code steps and comments. Use arrow \"→\" after Start? In example, \"Start // 程式開始執行\" then \"→ Step 1: ...\". We'll mimic.\n\nLet's produce.\n\nAlso we need to use \"Decision:\" lines with indentation.\n\nWe need to include \"End\" at end.\n\nLet's craft each line.\n\nRemember each line: \"虛擬碼步驟 [space] // 解釋\".\n\nWe must not output code. So we need to use natural language but with placeholders like Step X.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ BuildMap: 建立哈希表 word_to_index，將每個字串映射至其索引 // 用於快速查找逆序字串\n→ ForEachWord: 遍歷 words，索引為 i // 逐個處理每個字串\n    → ForEachSplit: 對當前字串進行所有切分，k 從 0 到 len(word) // 包含空前綴與空後綴\n        → Decision: 前綴 prefix 是否為回文？ // 判斷是否可以與後綴逆序配對\n            Yes → CheckReverseSuffix: 取 suffix 的逆序 reversed_suffix，查找於 word_to_index // 逆序字串是否存在\n                Yes → AddPair: 將 (i, reversed_suffix_index) 加入結果 // 成功找到回文對\n                No  → NoAction\n            No  → NoAction\n        → Decision: 後綴 suffix 是否為回文？ // 判斷是否可以與前綴逆序配對\n            Yes → CheckReversePrefix: 取 prefix 的逆序 reversed_prefix，查找於 word_to_index\n                Yes → AddPair: 將 (reversed_prefix_index, i) 加入結果\n                No  → NoAction\n            No  → NoAction\n    → EndForEachSplit\n→ EndForEachWord\n→ ReturnResult: 輸出所有收集到的 (i, j) 對 // 回傳結果\nEnd // 程式執行結束\n\nNeed to use indentation for decisions. In example, they used spaces.\n\nWe'll use consistent indentation.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ BuildMap: 建立哈希表 word_to_index，將每個字串映射至其索引 // 用於快速查找逆序字串  \n→ ForEachWord: 遍歷 words，索引為 i // 逐個處理每個字串  \n    → ForEachSplit: 對當前字串進行所有切分，k 從 0 到 len(word) // 包含空前綴與空後綴  \n        → Decision: 前綴 prefix 是否為回文？ // 判斷是否可以與後綴逆序配對  \n            Yes → CheckReverseSuffix: 取 suffix 的逆序 reversed_suffix，查找於 word_to_index // 逆序字串是否存在  \n                Yes → AddPair: 將 (i, reversed_suffix_index) 加入結果 // 成功找到回文對  \n                No → NoAction  \n            No → NoAction  \n        → Decision: 後綴 suffix 是否為回文？ // 判斷是否可以與前綴逆序配對  \n            Yes → CheckReversePrefix: 取 prefix 的逆序 reversed_prefix，查找於 word_to_index  \n                Yes → AddPair: 將 (reversed_prefix_index, i) 加入結果  \n                No → NoAction  \n            No → NoAction  \n    → EndForEachSplit  \n→ EndForEachWord  \n→ ReturnResult: 輸出所有收集到的 (i, j) 對 // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字串到索引的映射\n        word_to_index = {w: i for i, w in enumerate(words)}\n        res = []\n\n        # 若存在空字串，特殊處理：任何回文字串都可以和空字串組成回文對\n        empty_index = word_to_index.get(\"\", None)\n        if empty_index is not None:\n            for i, word in enumerate(words):\n                if i == empty_index:\n                    continue\n                if word == word[::-1]:\n                    res.append([empty_index, i])\n                    res.append([i, empty_index])\n\n        # 針對每個字串，檢查所有切分點\n        for i, word in enumerate(words):\n            n = len(word)\n            for j in range(n + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # 若前綴是回文，則後綴的逆序字串可以放在前面\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in word_to_index:\n                        idx = word_to_index[rev_suffix]\n                        if idx != i:\n                            res.append([idx, i])\n\n                # 若後綴是回文，則前綴的逆序字串可以放在後面\n                if j != n and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in word_to_index:\n                        idx = word_to_index[rev_prefix]\n                        if idx != i:\n                            res.append([i, idx])\n\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料\n    raw_input = sys.stdin.read().strip()\n    # 若輸入格式為 \"words = [...]\"，去除前綴並解析成 Python 列表\n    if raw_input.startswith(\"words\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n    words = ast.literal_eval(raw_input)\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[1,0],[0,1],[3,2],[2,4]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[1, 0], [0, 1], [3, 2], [2, 4]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1],[0,1],[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1], [0, 1], [1, 0]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode386.json",
    "problem_index_in_file": 0,
    "title": "Lexicographical Numbers",
    "description_snippet": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines that implement algorithm to return all numbers 1..n sorted lexicographically, O(n) time, O(1) extra space. This is classic lexical order algorithm: iterate using DFS traversal of prefix tree, but we can compute next lexicographic number by incrementing, with conditions: next = curr*10 if curr*10 <= n, else if curr%10 !=9 and curr+1 <= n, curr +=1 else curr/=10; while curr%10==0: curr/=10. This uses constant space. Provide virtual code.\n\nWe need to output step lines: Start, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow notation. Provide step for reading n, initializing current=1, list array? But O(1) space extra aside from output list? Usually output list can be returned, but we count extra internal variables. So we use while loop.\n\nLet's produce: \nStart\n→ Input n\n→ Init current =1\n→ Initialize result array (size n) maybe not counted? But we will mention that output array not counted as extra space? In algorithm, we need output container. But maybe allowed.\n\nWe'll then loop until result length == n:\n   → Append current to result\n   → If current*10 <= n: current = current*10\n   → Else if current%10 !=9 and current+1 <= n: current = current+1\n   → Else: \n        → current = current /10\n        → While current %10 ==0: current = current/10\nWe need to incorporate decisions.\n\nWe'll format with Decision lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Input n // 取得欲排序的整數上限\n→ Init current = 1 // 設定初始數字為 1，開始按字典序遍歷\n→ Init result = [] // 儲存字典序排列結果（不算作額外空間）\n→ Decision: 是否已完成 n 個數字? // 檢查是否已將所有數字加入結果\n    Yes → End // 所有數字已排序完成，結束程式\n    No  → \n        → Append current to result // 將目前的數字加入結果\n        → Decision: 是否能往前進到更小位數? // 判斷是否能乘 10 進入下一層\n            Yes → current = current * 10 // 進入下一個十位數字，保持字典序\n            No  → Decision: 是否可以遞增至下一個同位數? // 檢查能否直接 +1\n                Yes → current = current + 1 // 直接遞增到下一個字典序數字\n                No  → \n                    → current = current / 10 // 從最低位向上回溯\n                    → Decision: 是否仍是 0? // 若目前數字以 0 結尾，需要繼續回溯\n                        Yes → \n                            → While current % 10 == 0: current = current / 10 // 去掉所有結尾 0，保持正確回溯\n                        No  → // 回溯結束，進入下一輪判斷\nEnd // 程式執行結束（result 已包含 1~n 的字典序排列）",
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    \"\"\"\n    產生 1 ~ n 的字典序排列。\n    時間複雜度 O(n)，額外空間 O(1)（輸出結果除外）。\n    \"\"\"\n    result = []\n    curr = 1\n    for _ in range(n):\n        result.append(curr)\n        # 若可以往下進到更小位數，直接乘 10\n        if curr * 10 <= n:\n            curr *= 10\n        else:\n            # 不能往下時，往上回溯直到可以遞增\n            while curr % 10 == 9 or curr + 1 > n:\n                curr //= 10\n            curr += 1\n    return result\n\ndef main():\n    \"\"\"\n    讀取標準輸入，輸出字典序排列結果。\n    支援類似「n = 13」或「13」的輸入格式。\n    \"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    ans = lexical_order(n)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "success": true,
          "output": "[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode10.json",
    "problem_index_in_file": 0,
    "title": "Regular Expression Matching",
    "description_snippet": "Given an input string s and a pattern p, implement regular expression matching with support for '.' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for regex matching with '.' and '*', similar to LeetCode 10. Need to produce line-by-line steps with explanation. Not actual code. Use Start, End, Decision. Should cover algorithm: DP with 2D array or recursion with memo. We'll produce generic pseudocode. Let's produce DP approach: dp[i][j] bool. Use loops. Also recursion? We'll produce DP with 2D loops. Provide steps.\n\nLet's generate steps: Start; Step 1: define m,n lengths; Step 2: initialize dp 2D array size (m+1)x(n+1) all false; Step 3: dp[0][0] = true; Step 4: handle patterns that can match empty string (like a*, a*b*, etc.) loops over j; Decision: if pattern[j-1]=='*' then dp[0][j] = dp[0][j-2]; Step 5: nested loops over i from 1 to m; j from 1 to n; Decision: if pattern[j-1]==s[i-1] or pattern[j-1]=='.': dp[i][j] = dp[i-1][j-1]; Else if pattern[j-1]=='*': then first part: if pattern[j-2]==s[i-1] or pattern[j-2]=='.' then dp[i][j] = dp[i-1][j] OR dp[i][j-2]; else dp[i][j] = dp[i][j-2]; After loops, return dp[m][n]; End.\n\nWe need to include virtual code lines and explanations. Use arrow notation. Use Decision lines indenting. Ensure each line ends with // explanation. Use \"→\" arrow before each step.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 取得輸入字串 s 與 pattern p // 取得要匹配的字串與模式\n→ Step 2: m ← s.length, n ← p.length // 計算字串與模式長度\n→ Step 3: 建立 2D 布林陣列 dp[m+1][n+1] 並全設為 False // dp[i][j] 代表 s 的前 i 個字與 p 的前 j 個字能否匹配\n→ Step 4: dp[0][0] ← True // 空字串與空模式相匹配\n→ Decision: 是否有能以空字串匹配的前置模式? // 檢查如 a*, a*b* 等能匹配空字串\n    Yes → Step 5: 對 j = 1 .. n\n        → Decision: p[j-1] == '*'? // 若是 * 則前面兩個字符能消掉\n            Yes → dp[0][j] ← dp[0][j-2] // 前兩個字符匹配空字串即可\n            No  → // 不用任何操作\nEnd? Wait we need nested. Use correct indentation.\n\nBetter to produce lines with indentation. Use \"→\" for each line. For decisions use indentation lines inside.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: m ← length(s), n ← length(p) // 計算字串與模式長度\n→ Step 2: 建立 dp[m+1][n+1] 並初始化為 False // DP 表格\n→ Step 3: dp[0][0] ← True // 空字串與空模式相符\n→ Step 4: // 初始化能匹配空字串的模式\n    → Decision: j從1到n? // 逐個檢查模式位置\n        → Step 5: if p[j-1] == '*': dp[0][j] ← dp[0][j-2] // '*' 前兩個字符能消掉\n→ Step 6: // 主循環檢查每個字元\n    → Decision: i從1到m? // 逐個字元\n        → Decision: j從1到n? // 逐個模式\n            → Decision: p[j-1] == s[i-1] 或 p[j-1] == '.'? // 直接匹配\n                Yes → dp[i][j] ← dp[i-1][j-1] // 前一個也相符\n                No  → // 不直接匹配\n            → Decision: p[j-1] == '*'? // '*' 處理\n                Yes →\n                    → Decision: p[j-2] == s[i-1] 或 p[j-2] == '.'? // 前一字符可匹配\n                        Yes → dp[i][j] ← dp[i-1][j] OR dp[i][j-2] // 兩種情況\n                        No  → dp[i][j] ← dp[i][j-2] // '*' 只消掉前一字符\n                No  → // 其它情況不變\n→ Step 7: return dp[m][n] // 整體是否匹配\nEnd // 程式結束\n\nBut we must keep format strictly: each line \"→ Step X\" etc. For decision lines we should indent. We can use \"Decision:\" with indent.\n\nLet's format exactly:\n\nStart // 程式開始\n→ Step 1: m ← length(s), n ← length(p) // 取得字串與模式長度\n→ Step 2: 建立 dp[m+1][n+1] 並全部設為 False // DP 表格\n→ Step 3: dp[0][0] ← True // 空字串與空模式匹配\n→ Step 4: // 初始化能匹配空字串的模式\n    → Decision: j 取 1 到 n? // 逐一檢查模式\n        → Step 5: if p[j-1] == '*': dp[0][j] ← dp[0][j-2] // '*' 使前面兩個字符消失\n→ Step 6: // 逐行遍歷字串與模式\n    → Decision: i 取 1 到 m? // 逐個字元\n        → Decision: j 取 1 到 n? // 逐個模式\n            → Decision: p[j-1] == s[i-1] 或 p[j-1] == '.'? // 直接匹配\n                Yes → dp[i][j] ← dp[i-1][j-1] // 以前一字符為基礎\n                No  → // 跳過\n            → Decision: p[j-1] == '*'? // '*' 處理\n                Yes →\n                    → Decision: p[j-2] == s[i-1] 或 p[j-2] == '.'? // 前一字符可匹配\n                        Yes → dp[i][j] ← dp[i-1][j] OR dp[i][j-2] // 兩種情況\n                        No  → dp[i][j] ← dp[i][j-2] // 只消掉前一字符\n                No  → // 其它情況保持 False\n→ Step 7: return dp[m][n] // 判斷整個字串是否完全匹配\nEnd // 程式結束\n\nNeed to ensure each line ends with // explanation. Also include arrow \"→\" before each step. For decision lines, also \"→ Decision:\".\n\nWe must keep \"Step\" numbering but not necessary for decisions. The example uses \"Decision:\" and then indent lines with \"Yes →\" \"No →\". Use that style.\n\nThus produce final output.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: m ← length(s), n ← length(p) // 取得字串與模式長度  \n→ Step 2: 建立 dp[m+1][n+1] 並全部設為 False // 初始化 DP 表格  \n→ Step 3: dp[0][0] ← True // 空字串與空模式匹配  \n→ Step 4: // 初始化能匹配空字串的模式  \n  → Decision: j 取 1 到 n? // 逐一檢查模式位置  \n   Yes → Step 5: if p[j-1] == '*': dp[0][j] ← dp[0][j-2] // '*' 使前面兩個字符消失  \n\n→ Step 6: // 逐行遍歷字串與模式  \n  → Decision: i 取 1 到 m? // 逐個字元  \n   → Decision: j 取 1 到 n? // 逐個模式  \n    → Decision: p[j-1] == s[i-1] 或 p[j-1] == '.'? // 直接匹配  \n     Yes → dp[i][j] ← dp[i-1][j-1] // 以前一字符為基礎  \n     No → // 不直接匹配  \n    → Decision: p[j-1] == '*'? // '*' 處理  \n     Yes →  \n      → Decision: p[j-2] == s[i-1] 或 p[j-2] == '.'? // 前一字符可匹配  \n       Yes → dp[i][j] ← dp[i-1][j] OR dp[i][j-2] // 兩種情況  \n       No  → dp[i][j] ← dp[i][j-2] // 只消掉前一字符  \n     No → // 其它情況保持 False  \n\n→ Step 7: return dp[m][n] // 判斷整個字串是否完全匹配  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    尝试解析两种常见输入格式：\n    1. 单行形式：s = \"aa\", p = \"a\"\n    2. 两行形式：第一行为 s，第二行为 p\n    \"\"\"\n    # 先去除多余空格与换行\n    data = data.strip()\n    # 试试单行模式\n    m = re.search(r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*p\\s*=\\s*\"([^\"]*)\"', data)\n    if m:\n        return m.group(1), m.group(2)\n\n    # 试试两行模式\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        # 第一行可能含有 's = \"...\"'\n        s = re.search(r'\"([^\"]*)\"', lines[0])\n        p = re.search(r'\"([^\"]*)\"', lines[1])\n        if s and p:\n            return s.group(1), p.group(1)\n        # 直接取整行\n        return lines[0], lines[1]\n    # 失败则返回空字符串\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, p = parse_input(raw_input)\n    sol = Solution()\n    result = sol.isMatch(s, p)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"a*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\", p = \".*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode518.json",
    "problem_index_in_file": 0,
    "title": "Coin Change II",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for coin change combinations. Should be DP. Steps: Start, input array coins, amount. DP array size amount+1, initialize dp[0]=1. Loop over coins: for each coin, for amt from coin to amount: dp[amt] += dp[amt-coin]. Finally output dp[amount]. Use virtual code with arrow. Also include explanation after each line.\n\nWe need to ensure to use the formatting style with Start, End, Decision, etc. This is straightforward algorithm.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Input: coins, amount // 讀取硬幣面額與目標金額\n→ Declare array dp[amount+1] // 建立動態規劃陣列\n→ Initialize dp[0] = 1 // 只有一種方式組成金額0\n→ For each coin in coins: // 逐一處理每個硬幣\n    → For amt from coin to amount: // 對每個可能的金額進行更新\n        → dp[amt] = dp[amt] + dp[amt - coin] // 加入使用該硬幣的新組合\n→ Output dp[amount] // 結果即為總組合數\nEnd // 程式結束\n\nNeed arrow arrows? Use →. For loops, we can denote Decision? Not needed. But the example used Decision for if. For loops, just Step lines. Maybe use \"Loop:\". Let's just use \"Step:\". The instructions didn't forbid loops. But the format requires arrow.\n\nSo each line: \"Start //\". Then \"→ Step: Input...\" etc.\n\nBetter to use \"→ Step 1:\" etc. Let's produce.\n\nWe need to add explanation after each line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 讀取 coins 與 amount // 取得硬幣面額陣列與目標金額\n→ Step 2: 建立 dp 陣列長度 amount+1，並全部設為 0 // 初始化動態規劃表\n→ Step 3: 設定 dp[0] = 1 // 金額 0 只有一種組合（不取任何硬幣）\n→ Step 4: 對每個 coin 進行迴圈 // 開始計算各面額對結果的貢獻\n    → Step 4.1: 對 amt 由 coin 到 amount 進行迴圈 // 逐步累加可組成的組合數\n        → Step 4.1.1: dp[amt] = dp[amt] + dp[amt - coin] // 加上使用此硬幣後的組合數\n→ Step 5: 輸出 dp[amount] // 回傳總組合數\nEnd // 程式結束執行\n\nBut we need arrow after Step 4? Let's keep arrow indentation with nested lines maybe using spaces.\n\nNeed to ensure each line is separate. Provide arrow lines for nested loops.\n\nLet's produce exactly as:\n\nStart // 程式開始執行\n→ Step 1: 讀取 coins 與 amount // 取得硬幣面額陣列與目標金額\n→ Step 2: 建立 dp 陣列長度 amount+1 並全部設為 0 // 初始化動態規劃表\n→ Step 3: 設定 dp[0] = 1 // 金額 0 只有一種組合（不取任何硬幣）\n→ Step 4: 對每個 coin 進行迴圈 // 開始計算各面額對結果的貢獻\n    → Step 4.1: 對 amt 由 coin 到 amount 進行迴圈 // 逐步累加可組成的組合數\n        → Step 4.1.1: dp[amt] = dp[amt] + dp[amt - coin] // 加上使用此硬幣後的組合數\n→ Step 5: 輸出 dp[amount] // 回傳總組合數\nEnd // 程式結束執行\n\nThis meets requirement.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 coins 與 amount // 取得硬幣面額陣列與目標金額  \n→ Step 2: 建立 dp 陣列長度 amount+1 並全部設為 0 // 初始化動態規劃表  \n→ Step 3: 設定 dp[0] = 1 // 金額 0 只有一種組合（不取任何硬幣）  \n→ Step 4: 對每個 coin 進行迴圈 // 開始計算各面額對結果的貢獻  \n  → Step 4.1: 對 amt 由 coin 到 amount 進行迴圈 // 逐步累加可組成的組合數  \n    → Step 4.1.1: dp[amt] = dp[amt] + dp[amt - coin] // 加上使用此硬幣後的組合數  \n→ Step 5: 輸出 dp[amount] // 回傳總組合數  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def change(self, amount: int, coins: list[int]) -> int:\n        # DP table: dp[i] 表示組成金額 i 的方式數\n        dp = [0] * (amount + 1)\n        dp[0] = 1  # 金額 0 只有一種組合（不取任何硬幣）\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n        return dp[amount]\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入格式：\n    1) 兩行：第一行是 amount，第二行是硬幣清單\n    2) 一行：amount, [coin1, coin2, ...]\n    \"\"\"\n    data = data.strip()\n    if not data:\n        raise ValueError(\"Empty input\")\n\n    # 若包含換行符，按行解析\n    if '\\n' in data:\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            amount = int(lines[0].strip())\n            coins = ast.literal_eval(lines[1].strip())\n            return amount, coins\n\n    # 其它情況，假設格式為「amount, [coins]」\n    parts = data.split(',', 1)\n    if len(parts) != 2:\n        raise ValueError(\"Invalid input format\")\n    amount = int(parts[0].strip())\n    coins = ast.literal_eval(parts[1].strip())\n    return amount, coins\n\ndef main():\n    raw_input = sys.stdin.read()\n    amount, coins = parse_input(raw_input)\n    solution = Solution()\n    result = solution.change(amount, coins)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "5, [1,2,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "3, [2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "10, [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode434.json",
    "problem_index_in_file": 0,
    "title": "Number of Segments in a String",
    "description_snippet": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contigu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode lines following format: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. Provide step-by-step for given problem: count segments in string s. So steps: Start, initialize count=0, flag inSegment=false, iterate each char, if char != ' ' and !inSegment => count++, inSegment=true; else if char == ' ' => inSegment=false; after loop End.\n\nNeed to produce each line with arrow for flow. Use \"→\" before each step. Decision lines: \"Decision: ...\" etc. Provide explanation. Let's craft.\n\nEnsure each line ends with // Explanation. Use Chinese. Provide only virtual code and explanation. Use \"Start // 程式開始執行\". Then \"→ Step 1: 初始化計數器 count ← 0 和狀態 flag ← false // 設置初始值\". Then \"→ Step 2: 取得輸入字串 s // 讀取使用者提供的字串\". Then \"→ Step 3: 迴圈遍歷 s 的每個字符 // 檢查每個字符\". Then decision inside loop: \"Decision: 字符 c 是否為空格?\" then Yes/No. For No: \"→ Step 4: 如果 flag 為 false，則 count++ 並將 flag 設為 true // 新段落開始\" else \"→ Step 5: 設置 flag 為 true // 已在段落中\". For Yes: \"→ Step 6: 將 flag 設為 false // 退出段落\". Then after loop End: \"End // 輸出 count\". But we also need to output count: \"→ Step 7: 輸出 count // 結果\". Use appropriate arrow. Ensure we include arrows for each step.\n\nWe need to keep consistent naming. We'll use Step 1, Step 2... Decision lines with Yes and No.\n\nMake sure each line uses \"→\" arrow. Use \"Decision:\" lines. Use indentation for nested lines? Format example shows indentation for nested lines: \"    Yes →\". We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化計數器 count ← 0 及狀態 flag ← false // 設置初始值\n→ Step 2: 取得輸入字串 s // 讀取使用者提供的字串\n→ Step 3: 迴圈遍歷 s 的每個字符 // 檢查每個字符\n    Decision: 字符 c 是否為空格? // 判斷是否為空白\n        Yes → Step 4: 將 flag 設為 false // 退出段落\n        No  → Decision: flag 為 false? // 判斷是否已處於段落\n            Yes → Step 5: count ← count + 1  // 新段落開始，計數器加一\n                    → Step 6: flag ← true   // 設置為已進入段落\n            No  → Step 7: flag ← true   // 已在段落中，保持 flag 為 true\n→ Step 8: 輸出 count // 顯示段落數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_segments(s: str) -> int:\n    \"\"\"\n    計算字串 s 中由空白分隔的段落數量。\n    s.split() 會把所有空白（空格、換行、制表符等）視為分隔符，\n    且忽略連續空白與首尾空白，因而直接返回段落數量。\n    \"\"\"\n    return len(s.split())\n\ndef main() -> None:\n    \"\"\"\n    1. 從標準輸入讀取整段文字（可能包含「s = \"...\"」等格式）。\n    2. 解析出真正的字串內容。\n    3. 呼叫 count_segments() 計算段落數。\n    4. 將結果輸出到標準輸出。\n    \"\"\"\n    # 讀取全部輸入\n    data = sys.stdin.read()\n\n    # 先嘗試從雙引號中擷取字串\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 如果沒有雙引號，嘗試取等號後面的內容\n        if '=' in data:\n            _, after_eq = data.split('=', 1)\n            s = after_eq.strip()\n        else:\n            s = data.strip()\n\n    # 計算段落數並輸出\n    result = count_segments(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello, my name is John\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"Hello\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode483.json",
    "problem_index_in_file": 0,
    "title": "Smallest Good Base",
    "description_snippet": "Given an integer n represented as a string, return the smallest good base of n.\n\nWe call k >= 2 a go...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: Given string n, find smallest good base. We need algorithm: find smallest base k such that representation of n in base k consists of all 1s. For n up to large number, string length maybe up to 64 bits? Usually n <= 10^18. Approach: n = k^m + k^(m-1)+...+1 = (k^{m+1}-1)/(k-1). For each m from log2(n) down to 2, compute k by integer root. We need check. Also consider base n-1 gives representation \"11\"? Wait n as string.\n\nSo virtual code: parse n to integer maybe big integer? Use big integer library? But in pseudocode.\n\nWe produce steps: Start, parse n, compute nInt (big integer). Determine max m: floor(log2(nInt)). For m from max_m down to 2: compute approximate k = round(nInt^(1/m)). Then adjust to check using big integer multiplication. If match, output k. If none found, output nInt-1 (since n in base n-1 is \"11\"). Provide explanation.\n\nLet's craft line-by-line pseudocode:\n\nStart // Begin\n\n→ Step 1: Convert string n to big integer N // Parse input\n\n→ Step 2: If N == 2 then return 1? Actually for n=2 representation \"10\" base? But smallest good base for n=2 is 2? Wait n=2 is \"10\" base2, not all ones. Good base definition requires all digits 1's. For n=2, representation \"11\" base? 2 in base 1? not allowed. So maybe output N-1? But anyway algorithm handles.\n\n→ Step 3: Compute max_m = floor(log2(N)) // maximum exponent\n\n→ Step 4: For m from max_m down to 2: // iterate possible lengths of 1's\n\n    → Step 4.1: Approximate k = floor(N^(1/m)) // candidate base\n\n    → Step 4.2: While k^m + ... +1 > N: decrement k // adjust\n\n    → Step 4.3: While k^m + ... +1 < N: increment k // adjust\n\n    → Step 4.4: If k^m + ... +1 == N: return k // found\n\n→ Step 5: Return N-1 // fallback base gives \"11\"\n\nNeed to compute geometric series sum without overflow. Use big integer.\n\nBetter: compute using power and division: sum = (k^{m+1}-1)/(k-1). Compare to N.\n\nWe'll use big integer operations.\n\nSimplify: For each m, binary search for k between 2 and N^(1/m)+1.\n\nImplement binary search.\n\nBut pseudocode: for m loop, perform binary search.\n\nLet's produce virtual code accordingly.\n\nAlso include explanation lines.\n\nLet's output step by step.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 n 並轉成大整數 N // 取得欲轉換的數值  \n→ Step 2: 若 N 為 2，直接回傳 2 // 特殊情況，最小良好基底為 2  \n→ Step 3: 計算 max_m = ⌊log₂(N)⌋ // 最高可能的「1」數量  \n→ Step 4: 從 m = max_m 逐步遞減到 2  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.1: 用二分搜尋找基底 k  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 低值 low ← 2，高值 high ← N^(1/m)+1 // k 的範圍  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ While low ≤ high  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Mid ← (low + high) / 2 // 取中點作為候選 k  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.1.1: 計算 S = (Mid^(m+1) - 1) / (Mid - 1) // 等比級數總和  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: S 與 N 的大小比較  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → 若 S == N，則回傳 Mid 作為答案  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → 若 S < N，則 low ← Mid + 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → 若 S > N，則 high ← Mid - 1  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.2: 若本次 m 沒有找到匹配，繼續下一個 m  \n→ Step 5: 若所有 m 都未找到，回傳 N - 1 // N 在基底 N-1 時表示為「11」  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef smallest_good_base(n: str) -> str:\n    \"\"\"Return the smallest base k such that n's representation in base k consists only of '1's.\"\"\"\n    N = int(n)\n    # 最大可能的 1 的個數 (m+1)，即二進位位長\n    max_m = N.bit_length()\n    # 只需要從 max_m 到 2 逐漸遞減\n    for m in range(max_m, 1, -1):\n        # k 的範圍：至少 2，最多 N-1（若 m=1 時的情況）\n        left, right = 2, N - 1\n        while left <= right:\n            k = (left + right) // 2\n            # 等比級數 1 + k + k^2 + ... + k^(m-1) 的和\n            s = (k ** m - 1) // (k - 1)\n            if s == N:\n                return str(k)\n            elif s < N:\n                left = k + 1\n            else:\n                right = k - 1\n    # 若所有 m 都找不到，最小良好基底為 N-1（n 在基底 N-1 時表示為「11」）\n    return str(N - 1)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入中擷取第一個整數 (可處理類似 'n = \"13\"' 的格式)\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    n_str = numbers[0]\n    result = smallest_good_base(n_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"13\"",
          "expected_output": "\"3\"",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = \"4681\"",
          "expected_output": "\"8\"",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 2,
          "input": "n = \"1000000000000000000\"",
          "expected_output": "\"999999999999999999\"",
          "success": true,
          "output": "999999999999999999"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode326.json",
    "problem_index_in_file": 0,
    "title": "Power of Three",
    "description_snippet": "Given an integer n, return true if it is a power of three. Otherwise, return false.\n\nAn integer n is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, each line with explanation. The requirement: Start, End, Decision, arrow usage. For given integer n, check if it's power of three.\n\nWe can do iterative division by 3 until n <=1 or not divisible. Or we can use mathematical property: 3^k <= 2^31-1, the maximum n for 32-bit int, and check if 3^19 = 1162261467, so if n > 0 and 1162261467 % n == 0 then true. But maybe simplest is iterative.\n\nLet's produce steps:\n\nStart\n\n→ Step 1: Input n\n\n→ Decision: n <= 0? // check negative or zero\n\n   No → Continue\n\n   Yes → Step 2: return False\n\n→ Step 3: While n mod 3 == 0\n\n   → Step 4: n = n / 3\n\n→ Decision: n == 1? // after loop\n\n   Yes → Step 5: return True\n\n   No  → Step 6: return False\n\nEnd\n\nBut need to use virtual code with arrow. Use Yes/No arrows. Let's incorporate loops: Use Decision with condition inside while loop? Might need to denote loop explicitly.\n\nWe can show loop as:\n\n→ Decision: n mod 3 == 0? // Check divisibility\n\n   Yes → Step 4: n = n / 3 → Goto Decision (loop)\n\n   No  → Continue to next step\n\nOk.\n\nNow produce lines accordingly. Ensure each line with `// 解釋`. Use `Start`, `End`, `Decision:`. Use arrow `→`. Use `Yes →`, `No →`. Provide short explanation.\n\nLet's draft:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入整數 n // 取得使用者輸入\n\n→ Decision: n <= 0? // 檢查 n 是否為非正整數\n\n    Yes → Step 2: 回傳 False // 非正整數不能是 3 的冪\n\n    No  → // 進入下一步\n\n→ Decision: n mod 3 == 0? // 檢查 n 是否能被 3 整除\n\n    Yes → Step 3: n = n / 3 → Goto Decision // 迭代除以 3，重複檢查\n\n    No  → // 離開迴圈\n\n→ Decision: n == 1? // 迴圈結束後檢查是否為 1\n\n    Yes → Step 4: 回傳 True // n 為 3 的冪\n\n    No  → Step 5: 回傳 False // n 不是 3 的冪\n\nEnd // 程式執行結束\n\nBut need to keep each line distinct. For loops, we need to show step of goto Decision. But we can show arrow to go back.\n\nSimplify: Use while loop concept but we must stay with the required format. We can use Decision: n mod 3 == 0? Yes → Step 3: n = n / 3 → Goto Decision No → Step 4: (continue). But arrow syntax might be confusing. But acceptable.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得使用者輸入  \n→ Decision: n <= 0? // 檢查 n 是否為非正整數  \n    Yes → Step 2: 回傳 False // 非正整數不能是 3 的冪  \n    No  → // 進一步檢查  \n→ Decision: n mod 3 == 0? // 判斷 n 是否能被 3 整除  \n    Yes → Step 3: n = n / 3 → Goto Decision // 迭代除以 3，重複檢查  \n    No  → // 退出迴圈  \n→ Decision: n == 1? // 迴圈結束後檢查是否為 1  \n    Yes → Step 4: 回傳 True // n 為 3 的冪  \n    No  → Step 5: 回傳 False // n 不是 3 的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n //= 3\n        return n == 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 尋找第一個整數（可能包含負號）\n    match = re.search(r'-?\\d+', data)\n    n = int(match.group()) if match else 0\n\n    result = Solution().isPowerOfThree(n)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 27",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = -1",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode179.json",
    "problem_index_in_file": 0,
    "title": "Largest Number",
    "description_snippet": "Given a list of non-negative integers nums, arrange them such that they form the largest number and ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for solving largest number by arranging list. We must produce step-by-step with explanation comments. Use arrow. Use Start End. Should be in Traditional Chinese. Ensure each line has \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision. We'll produce algorithm: convert numbers to strings, sort with custom comparator (a+b > b+a), join, handle leading zeros. Provide steps. No actual code. Use lines. We'll produce maybe around 20 lines. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 nums 轉成字串陣列 strs // 把數字轉為字串，方便後續字串比較  \n→ Step 2: 定義比較函式 cmp(a, b) // 用來決定兩個字串的排序順序  \n  Decision: a + b 大於 b + a? // 比較 a+b 與 b+a 的字串大小  \n   Yes → Return -1 // 若 a+b 更大，a 應排在前，返回負值（升序）  \n   No  → Return 1  // 否則 b 排在前，返回正值  \n→ Step 3: 使用自訂比較函式將 strs 陣列排序 // 以 cmp 決定順序，得到最大組合的字串順序  \n→ Step 4: 將排序後的 strs 用空字串連接成 resultStr // 合併所有字串得到最長數字  \n→ Decision: resultStr 開頭是否為 '0'? // 檢查是否所有數字都是 0，避免返回 \"000…\"\n  Yes → Return \"0\" // 若首字為 0，整個結果都為 0，直接返回 \"0\"\n  No  → Return resultStr // 否則返回完整拼接的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom functools import cmp_to_key\n\nclass Solution:\n    def largestNumber(self, nums):\n        \"\"\"Arrange numbers to form the largest possible number.\"\"\"\n        # Convert all numbers to strings for easy concatenation and comparison.\n        nums_str = list(map(str, nums))\n\n        # Comparator: decide order based on which concatenation yields a larger number.\n        def compare(x, y):\n            if x + y > y + x:\n                return -1  # x should come before y\n            elif x + y < y + x:\n                return 1   # y should come before x\n            else:\n                return 0   # equal, order doesn't matter\n\n        # Sort the string list using the custom comparator.\n        nums_str.sort(key=cmp_to_key(compare))\n\n        # Join the sorted strings to form the final number.\n        result = ''.join(nums_str)\n\n        # If the highest number is '0', the whole result is '0'.\n        return '0' if result[0] == '0' else result\n\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract the list of numbers from the input.\n    # The input format may be like: 'nums = [10,2]' or just '[10,2]'.\n    nums = []\n    match = re.search(r'\\[([^\\]]*)\\]', data)\n    if match:\n        # Evaluate the extracted list safely.\n        # Using eval on a controlled pattern is acceptable here because the input\n        # is expected to be a simple list of integers.\n        try:\n            nums = eval(match.group(0))\n        except Exception:\n            nums = []\n\n    # Compute the largest number.\n    solution = Solution()\n    largest_num = solution.largestNumber(nums)\n\n    # Print the result enclosed in double quotes, as shown in the examples.\n    print(f'\"{largest_num}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,2]",
          "expected_output": "\"210\"",
          "success": true,
          "output": "\"210\""
        },
        {
          "example_index": 1,
          "input": "nums = [3,30,34,5,9]",
          "expected_output": "\"9534330\"",
          "success": true,
          "output": "\"9534330\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode232.json",
    "problem_index_in_file": 0,
    "title": "Implement Queue using Stacks",
    "description_snippet": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should supp...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code with each line containing step and comment. Use Start, End, Decision:, arrows. Need to cover MyQueue class with two stacks. Use operations push, pop, peek, empty. Provide pseudo-code line by line. Ensure each line has explanation after //.\n\nWe need to design algorithm: For push, push onto stack1. For pop/peek, if stack2 empty, move all from stack1 to stack2, then pop/peek from stack2. Empty returns true if both stacks empty.\n\nWe'll produce pseudo-code as structure with class and methods? We can present each method's steps sequentially. Use pseudo-code steps within each method.\n\nWe should show steps for constructor, push, pop, peek, empty.\n\nLet's craft:\n\nStart MyQueue // init\n\n→ Step 1: 初始化 stack_in ← empty // stack_in 用於入隊\n→ Step 2: 初始化 stack_out ← empty // stack_out 用於出隊\nEnd MyQueue // 初始化完成\n\nStart push(x) // 入隊\n→ Step 1: stack_in.push(x) // 把新元素放到 stack_in\nEnd push\n\nStart pop() // 出隊\n→ Decision: stack_out.isEmpty()? // 若 stack_out 為空，需轉移\n    Yes → Step 1: 從 stack_in 逐一彈出元素，push 到 stack_out // 轉移元素\n        Decision: stack_in.isEmpty()? // 轉移完後 stack_in 可能空\n            No → No // 若還有元素，繼續轉移\n            Yes → No // 轉移完畢\n→ Step 2: return stack_out.pop() // 從 stack_out 弹出最舊元素\nEnd pop\n\nBut we need line-by-line pseudo-code; maybe we need to represent loop to transfer. We'll use while.\n\nSo for pop:\n\n→ Decision: stack_out.isEmpty()?\n    Yes → While stack_in.notEmpty()\n            → Step 1: temp ← stack_in.pop()\n            → Step 2: stack_out.push(temp)\n→ Step 3: return stack_out.pop()\n\nSimilarly for peek: similar but peek top.\n\nImplement empty: return stack_in.isEmpty() && stack_out.isEmpty()\n\nNow produce final answer with each line. Use indentation? The example uses arrow and indentation. We'll produce each line as separate line with // explanation.\n\nLet's craft final.\n...done thinking.\n\nStart MyQueue // 建立 MyQueue 類別的初始化流程  \n→ Step 1: 初始化 stack_in ← empty // 用於儲存進隊元素  \n→ Step 2: 初始化 stack_out ← empty // 用於儲存出隊元素  \nEnd MyQueue // 初始化結束  \n\nStart push(x) // 將元素 x 入隊  \n→ Step 1: stack_in.push(x) // 直接把元素推到 stack_in 上方  \nEnd push // 入隊結束  \n\nStart pop() // 取得並移除隊首元素  \n→ Decision: stack_out.isEmpty()? // 判斷出隊棧是否為空  \n    Yes → While stack_in.notEmpty() // 若為空，將所有進隊棧元素轉移至出隊棧  \n        → Step 1: temp ← stack_in.pop() // 取出進隊棧頂元素  \n        → Step 2: stack_out.push(temp) // 推入出隊棧  \n    No  → No // 若已不空，直接使用出隊棧  \n→ Step 3: return stack_out.pop() // 從出隊棧頂移除並返回元素  \nEnd pop // 出隊結束  \n\nStart peek() // 查看隊首元素但不移除  \n→ Decision: stack_out.isEmpty()? // 判斷出隊棧是否為空  \n    Yes → While stack_in.notEmpty() // 若為空，先轉移元素  \n        → Step 1: temp ← stack_in.pop() // 取出進隊棧頂元素  \n        → Step 2: stack_out.push(temp) // 推入出隊棧  \n    No  → No // 若已不空，直接使用  \n→ Step 3: return stack_out.peek() // 回傳出隊棧頂元素  \nEnd peek // 查看結束  \n\nStart empty() // 判斷隊列是否為空  \n→ Step 1: return stack_in.isEmpty() AND stack_out.isEmpty() // 兩棧皆空即為空  \nEnd empty // 判斷結束  \n\nEnd // MyQueue 類別實作結束",
      "generated_code": "import sys\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        # Ensure elements are in stack_out\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\n\ndef main():\n    # Read all input lines\n    raw = sys.stdin.read().strip().splitlines()\n    if not raw:\n        return\n    # Skip a possible header like \"Input\"\n    lines = [line for line in raw if line.strip() != \"\"]\n    if lines[0].strip().lower() == \"input\":\n        lines = lines[1:]\n\n    # Parse operations and arguments\n    ops = json.loads(lines[0])\n    args_list = json.loads(lines[1])\n\n    result = []\n    obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"MyQueue\":\n            obj = MyQueue()\n            result.append(None)\n        elif op == \"push\":\n            obj.push(*args)\n            result.append(None)\n        elif op == \"pop\":\n            result.append(obj.pop())\n        elif op == \"peek\":\n            result.append(obj.peek())\n        elif op == \"empty\":\n            result.append(obj.empty())\n\n    # Convert Python values to the expected output format\n    out_str = []\n    for val in result:\n        if val is None:\n            out_str.append(\"null\")\n        elif isinstance(val, bool):\n            out_str.append(\"true\" if val else \"false\")\n        else:\n            out_str.append(str(val))\n    print(\"[\" + \", \".join(out_str) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "success": true,
          "output": "[null, null, null, 1, 1, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode718.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Repeated Subarray",
    "description_snippet": "Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in bo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for algorithm that given two integer arrays returns maximum length of common subarray. This is classic longest common subarray (Longest Common Substring). Use DP O(n*m). Or sliding window. Use DP: dp[i][j] length of common suffix ending at i-1 in nums1 and j-1 in nums2. maxLen.\n\nWe'll produce virtual code with steps: Start, input arrays, set m,n, initialize dp matrix of size (m+1)*(n+1) zeros, maxLen=0. Loop i from 1 to m: loop j from 1 to n: if nums1[i-1]==nums2[j-1] then dp[i][j]=dp[i-1][j-1]+1, update maxLen. else dp[i][j]=0. After loops, End return maxLen.\n\nWill produce step-by-step with explanation after each line. Use arrow for each step. Use decision maybe for if equality. Ok.\n\nLet's craft.\n\nNote: we need to use arrow \"→\" for each step. Start, End.\n\nWe may include variable assignments.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: 取得兩個整數陣列 nums1, nums2 // 讀取輸入資料\n→ Step 2: 取得 nums1 長度 m, nums2 長度 n // 計算陣列長度\n→ Step 3: 建立 dp 矩陣 (m+1) x (n+1)，所有值初始化為 0 // 用來存儲子陣列相同結尾長度\n→ Step 4: 初始化 maxLen 為 0 // 用來記錄目前最大長度\n\n→ Decision: i 由 1 到 m 逐步遞增? // 開始遍歷 nums1\n    Yes →\n        → Step 5: i = 1 // 設定 i 初值\n        → Decision: i <= m? // 檢查是否還有元素\n            Yes →\n                → Step 6: j 由 1 到 n 逐步遞增? // 遍歷 nums2\n                    Yes →\n                        → Step 7: j = 1 // 設定 j 初值\n                        → Decision: j <= n? // 檢查是否還有元素\n                            Yes →\n                                → Decision: nums1[i-1] == nums2[j-1]? // 檢查當前元素是否相等\n                                    Yes →\n                                        → Step 8: dp[i][j] = dp[i-1][j-1] + 1 // 更新 dp\n                                        → Step 9: maxLen = max(maxLen, dp[i][j]) // 更新最大長度\n                                    No  →\n                                        → Step 10: dp[i][j] = 0 // 兩個元素不相等，子陣列結尾長度為 0\n                                → Step 11: j = j + 1 // 移動至下一個 j\n                            No  →\n                                → Step 12: // 結束 j 的迴圈\n                        → Step 13: i = i + 1 // 移動至下一個 i\n                    No  →\n                        → Step 14: // 結束 i 的迴圈\n\n→ End // 程式結束，回傳 maxLen\n\nBut the requirement: Use arrow lines, not too nested. But we can keep decision structure. We must produce simple lines. Use decision lines to indicate if statements.\n\nWe can compress loops into steps.\n\nLet's produce a more concise but still line-by-line with decisions.\n\nWill produce something like:\n\nStart\n→ Step 1: Input nums1, nums2\n→ Step 2: m = length(nums1), n = length(nums2)\n→ Step 3: dp = matrix of size (m+1) x (n+1) initialized to 0\n→ Step 4: maxLen = 0\n→ Decision: i from 1 to m? \n    Yes →\n        → Step 5: i = 1\n        → Decision: i <= m? \n            Yes →\n                → Decision: j from 1 to n? \n                    Yes →\n                        → Step 6: j = 1\n                        → Decision: j <= n? \n                            Yes →\n                                → Decision: nums1[i-1] == nums2[j-1]? \n                                    Yes →\n                                        → Step 7: dp[i][j] = dp[i-1][j-1] + 1\n                                        → Step 8: maxLen = max(maxLen, dp[i][j])\n                                    No →\n                                        → Step 9: dp[i][j] = 0\n                                → Step 10: j = j + 1\n                            No →\n                                → Step 11: // end j loop\n                        → Step 12: i = i + 1\n                    No →\n                        → Step 13: // end i loop\n→ End // return maxLen\n\nBut we need to include \"return\" maybe separate step.\n\nLet's add Step 14: return maxLen.\n\nWill produce.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取兩個整數陣列 nums1 與 nums2 // 取得輸入資料  \n→ Step 2: m ← length(nums1), n ← length(nums2) // 計算陣列長度  \n→ Step 3: dp ← 建立 (m+1)×(n+1) 的矩陣，全部初始化為 0 // 用於存放子陣列相同結尾長度  \n→ Step 4: maxLen ← 0 // 用來記錄目前發現的最大長度  \n\n→ Decision: i 從 1 到 m ？ // 開始遍歷 nums1  \n    Yes →  \n        → Step 5: i ← 1  \n        → Decision: i ≤ m ？  \n            Yes →  \n                → Decision: j 從 1 到 n ？  \n                    Yes →  \n                        → Step 6: j ← 1  \n                        → Decision: j ≤ n ？  \n                            Yes →  \n                                → Decision: nums1[i‑1] == nums2[j‑1] ？ // 比較當前元素  \n                                    Yes →  \n                                        → Step 7: dp[i][j] ← dp[i‑1][j‑1] + 1 // 更新 dp  \n                                        → Step 8: maxLen ← max(maxLen, dp[i][j]) // 更新最大長度  \n                                    No →  \n                                        → Step 9: dp[i][j] ← 0 // 不相等，長度重置  \n                                → Step 10: j ← j + 1 // 移動到下一個 j  \n                            No →  \n                                → Step 11: // j 迴圈結束  \n                        → Step 12: i ← i + 1 // 移動到下一個 i  \n                    No →  \n                        → Step 13: // i 迴圈結束  \n            No →  \n                → Step 14: // 所有元素已遍歷完  \n\n→ Step 15: return maxLen // 回傳最大子陣列長度  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findLength(self, nums1, nums2):\n        m, n = len(nums1), len(nums2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        max_len = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    if dp[i][j] > max_len:\n                        max_len = dp[i][j]\n        return max_len\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出所有方括號中的內容，應該是兩個列表\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) != 2:\n        # 若輸入格式不符，直接終止\n        sys.exit(1)\n    nums1 = ast.literal_eval(lists[0])\n    nums2 = ast.literal_eval(lists[1])\n    result = Solution().findLength(nums1, nums2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode493.json",
    "problem_index_in_file": 0,
    "title": "Reverse Pairs",
    "description_snippet": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for counting reverse pairs in array. Use virtual code with arrows and explanations. No actual code, just structured steps. Probably use divide and conquer merge sort approach. Steps: Start, input array, define function countAndMergeSort, recursion, base case length 1 return 0, merge counts, count reverse pairs across left and right, merge sorted arrays, return total count. We'll output line by line. Use Decision, etc.\n\nLet's craft.\n\nWe need to output with each line \"虛擬碼步驟 // 解釋\". Use arrows \"→\". Format: Start // 程式開始執行. Next: → Step 1: Initialize variables, etc.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 countReversePairs(nums) // 主入口\n→ Step 2: 呼叫 countAndMergeSort(nums, 0, length-1) // 進行分治\n→ Decision: 子陣列長度 <=1? // 若僅一個元素\n    Yes → Return 0 // 無反轉對\n    No → ... etc\n\nBut must be line by line, with arrows at start maybe. We need to maintain indentation for decisions. Use \"Decision:\" line, then indent Yes / No branches. Provide explanations each line. Let's write. Ensure no real code.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義主函式 countReversePairs(nums) // 用於外部呼叫\n→ Step 2: 在主函式中呼叫 countAndMergeSort(nums, 0, len(nums)-1) // 開始分治\n→ Step 3: 定義遞迴函式 countAndMergeSort(nums, left, right) // 分治核心\n→ Decision: 若 left >= right? // 子陣列長度 <=1\n    Yes → Return 0 // 只有一個或零個元素，無反轉對\n    No  → 進行下一步\n→ Step 4: 計算 mid = (left + right) // 取得中點\n→ Step 5: leftCount = countAndMergeSort(nums, left, mid) // 先處理左半\n→ Step 6: rightCount = countAndMergeSort(nums, mid+1, right) // 再處理右半\n→ Step 7: 初始化 crossCount = 0, j = mid+1 // 用於計算跨左右的反轉對\n→ Decision: j <= right? // 只要右邊還有元素\n    Yes → \n        → Step 8: 若 nums[left] > 2 * nums[j]? // 判斷左邊元素是否超過右邊兩倍\n            → Decision: 若條件成立?\n                Yes →\n                    → Step 9: crossCount += (mid - left + 1) // 所有左邊元素皆符合\n                    → Step 10: j += 1 // 移動右邊指標\n                No  →\n                    → Step 11: left += 1 // 移動左邊指標\n        → Step 12: 回到 Decision: j <= right? // 迴圈結束判斷\n    No  → 跳出循環\n→ Step 13: 合併已排序的兩個子陣列 // 標準 merge\n    → Step 14: 建立 temp = [] // 暫存合併結果\n    → Step 15: i = left, j = mid+1 // 重新設置指標\n    → Decision: i <= mid and j <= right? // 同時兩邊有元素\n        Yes →\n            → Step 16: 若 nums[i] <= nums[j]? // 小者放入 temp\n                → Decision: 若條件成立?\n                    Yes → Append nums[i] to temp; i += 1\n                    No  → Append nums[j] to temp; j += 1\n            → 回到 Decision: i <= mid and j <= right? // 迴圈持續\n        No  → \n            → Step 17: 若 i <= mid? // 左邊剩餘\n                → Append remaining nums[i] to temp; i += 1\n            → 若 j <= right? // 右邊剩餘\n                → Append remaining nums[j] to temp; j += 1\n    → Step 18: 將 temp 複製回 nums[left:right+1] // 完成合併\n→ Step 19: 返回 leftCount + rightCount + crossCount // 合計此區域的反轉對數\n→ Step 20: 主函式接收返回值並返回給使用者 // 結果輸出\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reversePairs(self, nums):\n        def merge_sort(start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\n            # Count reverse pairs across the two halves\n            j = mid + 1\n            for i in range(start, mid + 1):\n                while j <= end and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n            # Merge the two sorted halves\n            temp = []\n            left, right = start, mid + 1\n            while left <= mid and right <= end:\n                if nums[left] <= nums[right]:\n                    temp.append(nums[left])\n                    left += 1\n                else:\n                    temp.append(nums[right])\n                    right += 1\n            while left <= mid:\n                temp.append(nums[left])\n                left += 1\n            while right <= end:\n                temp.append(nums[right])\n                right += 1\n            nums[start:end + 1] = temp\n            return count\n        return merge_sort(0, len(nums) - 1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Attempt to parse the input as a list expression\n    nums = None\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        # Try extracting a slice that looks like a list\n        try:\n            start = data.find('[')\n            end = data.rfind(']')\n            if start != -1 and end != -1:\n                nums = ast.literal_eval(data[start:end+1])\n        except Exception:\n            pass\n    if nums is None:\n        # Fallback: treat the input as space-separated integers\n        try:\n            nums = list(map(int, data.split()))\n        except Exception:\n            nums = []\n\n    solution = Solution()\n    result = solution.reversePairs(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,4,3,5,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode443.json",
    "problem_index_in_file": 0,
    "title": "String Compression",
    "description_snippet": "Given an array of characters chars, compress it using the following algorithm:\n\nBegin with an empty ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. It's algorithm for array compression with constant extra space. We'll produce steps: Start, initialize write pointer, read pointer, iterate, count consecutive, write char, if count>1, write digits of count. Return write pointer. End. Each line must be virtual code with explanation. We'll output as per format.\n\nWe must keep lines simple, with arrow lines. Use virtual arrow '→' to denote next step. Use Decision: for conditions. Provide explanation after //.\n\nWe'll not produce actual code but pseudo steps. Use constant space. We'll produce steps like:\n\nStart\n→ Step 1: Initialize writeIndex = 0, readIndex = 0 // read/write pointers\n→ Step 2: While readIndex < len(chars) // iterate over array\n→ Decision: group length > 1? // need to count\n    Yes/No path. But easier: count loop.\n\nLet's craft:\n\nStart\n→ Step 1: Set writeIndex = 0, readIndex = 0 // 初始化讀寫指標\n→ Step 2: While readIndex < len(chars) // 遍歷整個字符陣列\n→ Step 3: Set currentChar = chars[readIndex] // 取得當前字符\n→ Step 4: Set count = 0 // 初始化計數\n→ Step 5: While readIndex < len(chars) AND chars[readIndex] == currentChar\n    → Step 5a: Increment count\n    → Step 5b: Increment readIndex\n→ Step 6: chars[writeIndex] = currentChar // 寫入字符\n→ Step 7: Increment writeIndex\n→ Decision: count > 1? // 是否需要寫入長度\n    Yes → Step 8: Convert count to string representation\n    → Step 9: For each digit d in countStr\n        → Step 9a: chars[writeIndex] = d // 寫入每一位數字\n        → Step 9b: Increment writeIndex\n    No → (do nothing)\n→ End of while loop\n→ Return writeIndex // 新長度\nEnd\n\nWe should include arrows for each step. We need each line with virtual code and explanation. Use arrow before step lines. Let's format:\n\nStart // 程式開始\n→ Step 1: Set writeIndex = 0, readIndex = 0 // 初始化寫入指標與讀取指標\n→ Step 2: While readIndex < len(chars) // 逐個讀取陣列\n→ Step 3: Set currentChar = chars[readIndex] // 取出當前字符\n→ Step 4: Set count = 0 // 初始化重複數量計數\n→ Step 5: While readIndex < len(chars) AND chars[readIndex] == currentChar\n    → Step 5a: Increment count\n    → Step 5b: Increment readIndex\n→ Step 6: chars[writeIndex] = currentChar // 把字符寫入結果位置\n→ Step 7: Increment writeIndex // 移動寫入指標\n→ Decision: count > 1? // 判斷是否需要寫入數字\n    Yes → Step 8: Convert count to string countStr // 把數字轉成字串\n    → Step 9: For each digit d in countStr\n        → Step 9a: chars[writeIndex] = d // 把每位數字寫入\n        → Step 9b: Increment writeIndex\n    No → // 不寫入任何數字\n→ End of while loop\n→ Step 10: Return writeIndex // 回傳壓縮後的新長度\nEnd // 程式結束\n\nWe need each line as separate. Indentation maybe not necessary but arrow lines.\n\nWe'll need to ensure each line ends with comment. Provide each line.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set writeIndex = 0, readIndex = 0 // 初始化寫入指標與讀取指標  \n→ Step 2: While readIndex < len(chars) // 逐一讀取整個字元陣列  \n→ Step 3: Set currentChar = chars[readIndex] // 取得目前要處理的字元  \n→ Step 4: Set count = 0 // 初始化重複次數計算  \n→ Step 5: While readIndex < len(chars) AND chars[readIndex] == currentChar  \n    → Step 5a: Increment count // 每遇到同字元就計數  \n    → Step 5b: Increment readIndex // 移到下一個字元  \n→ Step 6: chars[writeIndex] = currentChar // 把字元寫回結果位置  \n→ Step 7: Increment writeIndex // 移動寫入指標至下一位置  \n→ Decision: count > 1? // 判斷是否需要寫入長度  \n    Yes → Step 8: Convert count to string countStr // 把整數長度轉成字串  \n    → Step 9: For each digit d in countStr  \n        → Step 9a: chars[writeIndex] = d // 把每個數字字元寫回  \n        → Step 9b: Increment writeIndex // 移動寫入指標  \n    No → // 長度為1時不寫入任何數字  \n→ End of while loop // 完成所有字元的壓縮  \n→ Step 10: Return writeIndex // 回傳壓縮後的新長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def compress(self, chars):\n        write = 0\n        left = 0\n        n = len(chars)\n\n        while left < n:\n            right = left\n            while right < n and chars[right] == chars[left]:\n                right += 1\n            chars[write] = chars[left]\n            write += 1\n            count = right - left\n            if count > 1:\n                for c in str(count):\n                    chars[write] = c\n                    write += 1\n            left = right\n\n        return write\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 支援 'chars = [...]' 或直接 '[...]' 的輸入格式\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    try:\n        chars = ast.literal_eval(expr)\n    except Exception:\n        # 若解析失敗，視作空列表\n        chars = []\n    sol = Solution()\n    new_len = sol.compress(chars)\n    print(new_len)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "chars = [\"a\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode674.json",
    "problem_index_in_file": 0,
    "title": "Longest Continuous Increasing Subsequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest continuous increasing sub...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines step by step. Problem: longest continuous increasing subsequence in unsorted array. Approach: iterate, keep current length and max length. If nums[i] > nums[i-1] then increment current else reset to 1. Update max.\n\nWe need to output virtual code lines using arrows and structure. Must be in Traditional Chinese. Provide explanation after each line. Use structure: Start, Decision, Yes →, No →, etc. We need to show algorithm. Let's produce lines:\n\nStart // start\n→ Input nums // read array\n→ Initialize currLen = 1 // current subsequence length\n→ Initialize maxLen = 1 // maximum length found\n→ For i from 1 to nums.length-1: // iterate through array\n    → Decision: if nums[i] > nums[i-1]?\n        Yes → currLen = currLen + 1 // increase current length\n        No  → currLen = 1 // reset to 1\n    → Decision: if currLen > maxLen?\n        Yes → maxLen = currLen // update max\n        No  → // no change\n→ Output maxLen // result\nEnd // end\n\nNeed to include comments.\n\nWe should include \"→\" for each step. Use \"Decision:\" for branching.\n\nMake sure each line has virtual code step and comment after space and //.\n\nWe must ensure each line is separate. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得輸入的整數陣列  \n→ Set currLen = 1 // 目前連續遞增子序列長度初始化為 1  \n→ Set maxLen = 1 // 目前找到的最大長度初始化為 1  \n→ For i from 1 to nums.length-1: // 從第二個元素開始遍歷陣列  \n    → Decision: 如果 nums[i] > nums[i-1]? // 判斷是否遞增  \n        Yes → currLen = currLen + 1 // 如果遞增，延長目前子序列長度  \n        No  → currLen = 1 // 否則重置為 1  \n    → Decision: 如果 currLen > maxLen? // 檢查是否更新最大長度  \n        Yes → maxLen = currLen // 更新最大長度為目前子序列長度  \n        No  → // 不變，保留舊的最大長度  \n→ Output maxLen // 回傳最長連續遞增子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLengthOfLCIS(self, nums):\n        \"\"\"Return length of longest continuous increasing subsequence.\"\"\"\n        if not nums:\n            return 0\n        max_len = 1\n        cur_len = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                cur_len += 1\n                if cur_len > max_len:\n                    max_len = cur_len\n            else:\n                cur_len = 1\n        return max_len\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    # Accept input format like: \"nums = [1,3,5,4,7]\"\n    if data.startswith(\"nums\"):\n        try:\n            # Split on '=' and evaluate the list part safely\n            nums_part = data.split('=', 1)[1].strip()\n            nums = ast.literal_eval(nums_part)\n        except Exception:\n            # Fallback: try to evaluate the whole string\n            nums = ast.literal_eval(data)\n    else:\n        # If the input is just the list literal\n        nums = ast.literal_eval(data)\n    # Compute result\n    solution = Solution()\n    result = solution.findLengthOfLCIS(nums)\n    # Output the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode541.json",
    "problem_index_in_file": 0,
    "title": "Reverse String II",
    "description_snippet": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The user provides a problem statement: given string s and integer k, reverse first k characters for every 2k characters. If less than k left, reverse all; if between k and 2k, reverse first k, keep rest.\n\nWe need to produce a step-by-step pseudocode, line by line, with explanation. Should include Start, End, Decision, etc.\n\nWe should include variables: s, k, n, result string, index i.\n\nWe need to produce code: Start, initialize result as empty, i = 0, n = length(s). While i < n: determine end = min(i + k, n), reverse substring s[i:end], append to result. Then append the next segment s[end:end+k] unchanged. Increment i by 2*k.\n\nBut also need to handle cases: if end < i + k etc. But easier: while i < n: reverse part = substring from i to min(i+k, n). Append reversed. i = min(i + k, n). Then skip next part: j = min(i + k, n). Append s[i:j]. i = j. But we need to handle when remaining < k: reverse all; if remaining between k and 2k: reverse first k, leave rest. The algorithm above covers that.\n\nLet's produce virtual steps: Start, set result, set i = 0, n = length(s). Decision: if i >= n? but while loop: Decision: i < n? Yes → process. Steps: Step 1: reverse_start = i; reverse_end = min(i + k, n). Step 2: reverse_segment = reverse substring s[reverse_start:reverse_end]. Append to result. Step 3: i = reverse_end. Step 4: skip_start = i; skip_end = min(i + k, n). Append original substring s[skip_start:skip_end] to result. Step 5: i = skip_end. Back to Decision: i < n? loop. End.\n\nWe need to produce each step line with explanation. Use arrow, decision, yes/no. Provide each step on separate line. Provide explanation after //.\n\nLet's do it. Use Chinese comments. Use \"虛擬碼步驟\" and explanation.\n\nWe need to start with \"Start // 程式開始執行\". Then \"→ 設定 result 為空字串 // 用來累積結果\". \"→ 設定 i 為 0 // 當前處理位置\". \"→ 設定 n 為 s 的長度 // 字串總長\". Then \"→ Decision: i < n? // 是否還有未處理的字元\". \"    Yes → Step 1: reverse_start = i // 取要反轉的起點\". \"    Yes → Step 2: reverse_end = min(i + k, n) // 取要反轉的終點，保證不超出字串\". \"    Yes → Step 3: reverse_segment = reverse(substring(s, reverse_start, reverse_end)) // 反轉這段子字串\". \"    Yes → Step 4: result += reverse_segment // 加到結果\". \"    Yes → Step 5: i = reverse_end // 移動到未處理段的起點\". \"    Yes → Step 6: skip_start = i // 取接下來的正向段起點\". \"    Yes → Step 7: skip_end = min(i + k, n) // 正向段終點\". \"    Yes → Step 8: result += substring(s, skip_start, skip_end) // 加入原始段\". \"    Yes → Step 9: i = skip_end // 移動到下一個 2k 區塊起點\". \"    Yes → 回到 Decision: i < n? // 檢查是否還有剩餘\". \"    No → End // 所有字元已處理，程式結束\".\n\nBut we need to format with \"Yes →\" and indent? Provide indentation as in example. Use spaces? We'll use indentation of 4 spaces for nested lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ result ← \"\" // 初始化結果字串  \n→ i ← 0 // 當前處理位置  \n→ n ← length(s) // 字串總長度  \n\n→ Decision: i < n? // 是否還有未處理的字元  \n    Yes → reverse_start ← i // 取要反轉的起點  \n    Yes → reverse_end ← min(i + k, n) // 取要反轉的終點，避免超出字串  \n    Yes → reverse_segment ← reverse(substring(s, reverse_start, reverse_end)) // 反轉這段子字串  \n    Yes → result ← result + reverse_segment // 加到結果  \n    Yes → i ← reverse_end // 移動到未處理段的起點  \n    Yes → skip_start ← i // 取接下來的正向段起點  \n    Yes → skip_end ← min(i + k, n) // 正向段終點  \n    Yes → result ← result + substring(s, skip_start, skip_end) // 加入原始段  \n    Yes → i ← skip_end // 移動到下一個 2k 區塊起點  \n    Yes → 回到 Decision: i < n? // 檢查是否還有剩餘  \n    No → End // 所有字元已處理，程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reverseStr(self, s: str, k: int) -> str:\n        # 將字串轉成 list，方便就地修改\n        lst = list(s)\n        # 每 2k 個字元為一個區塊\n        for i in range(0, len(lst), 2 * k):\n            # 只反轉前 k 個字元\n            lst[i:i + k] = reversed(lst[i:i + k])\n        return \"\".join(lst)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 依照輸入格式分離字串與 k\n    if ',' in data:\n        s_part, k_part = data.split(',', 1)\n        s_part = s_part.strip()\n        k_part = k_part.strip()\n    else:\n        # 可能是多行輸入\n        parts = data.splitlines()\n        s_part = parts[0].strip()\n        k_part = parts[1].strip() if len(parts) > 1 else \"\"\n\n    # 解析字串（帶引號）與整數\n    s = ast.literal_eval(s_part)\n    k = int(k_part)\n\n    solution = Solution()\n    result = solution.reverseStr(s, k)\n\n    # 按題目範例輸出加上引號\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abcdefg\", 2",
          "expected_output": "\"bacdfeg\"",
          "success": true,
          "output": "\"bacdfeg\""
        },
        {
          "example_index": 1,
          "input": "\"abcd\", 2",
          "expected_output": "\"bacd\"",
          "success": true,
          "output": "\"bacd\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode188.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock IV",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find max profit with at most k transactions. We should produce step-by-step. It's a dynamic programming: dp[t][d] max profit up to day d with at most t transactions. Or we can optimize using bestDiff. Provide pseudo steps.\n\nWe need to respond in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to use Start, End, Decision, arrow. We'll present algorithm: iterate days, maintain dp[transaction][day], use bestDiff. We need explanation.\n\nLet's produce a simple outline:\n\nStart\n→ Read input: prices array and integer k\n→ If k >= n/2: // unlimited transactions\n    → Compute max profit by summing positive differences // greedily buy low sell high\n    → Output profit\n    → End\n→ Initialize dp array of size (k+1) with zeros // dp[t] is max profit after t transactions until current day\n→ Initialize best array of size (k+1) with negative infinity // best[t] max of dp[t-1] - price\n→ For each day i from 0 to n-1:\n    → For t from 1 to k:\n        → Update best[t] = max(best[t], dp[t-1] - prices[i]) // best price to buy for transaction t\n        → Update dp[t] = max(dp[t], best[t] + prices[i]) // sell today\n→ Output dp[k] // maximum profit after at most k transactions\nEnd\n\nWe need to include Decision sections for the k >= n/2 case.\n\nLet's craft the lines.\n\nWe need to include indentation? The sample uses spaces for indent. We can produce lines with arrow and indent.\n\nOk. Let's craft:\n\nStart // 程式開始\n→ Step 1: 讀取輸入 prices 與 k // 取得股價序列與交易次數上限\n→ Decision: 如果 k >= len(prices)/2? // 判斷是否可視為無限交易\n    Yes → Step 2: 透過遍歷價格，累加正向差值以獲得最大利潤 // 無限交易時使用貪心法\n    → Step 3: 輸出累加利潤\n    → End // 完成無限交易情況\n    No → Step 4: 初始化 dp[0..k] 為 0 // dp[t] 代表 t 次交易至目前日的最大利潤\n    → Step 5: 初始化 best[0..k] 為 -∞ // best[t] 代表在第 t 次交易中最佳買入時機\n    → For i in 0..len(prices)-1: // 遍歷每一天\n        → For t in 1..k: // 逐次交易\n            → Decision: 更新 best[t] 為 max(best[t], dp[t-1] - prices[i])? // 決定是否在今天買入\n                Yes → Step 6: best[t] = max(best[t], dp[t-1] - prices[i]) // 更新最佳買入差值\n            → Decision: 更新 dp[t] 為 max(dp[t], best[t] + prices[i])? // 決定是否在今天賣出\n                Yes → Step 7: dp[t] = max(dp[t], best[t] + prices[i]) // 更新至目前日最大利潤\n    → Step 8: 輸出 dp[k] // 最大可得利潤\nEnd // 程式執行結束\n\nBut we need each line separated, with the arrow for each step. For decision we need sub-indentation.\n\nBut format expects each line: \"虛擬碼步驟 // 解釋\". So for decision, we need:\n\n→ Decision: ...? // explanation\n    Yes → Step ...\n    No → Step ...\n\nWe need each line separate. Let's write it carefully.\n\nWe also need to keep arrow alignment.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: 讀取價格陣列 prices 與交易上限 k // 取得輸入資料\n→ Decision: 如果 k >= len(prices)/2? // 判斷是否能視為無限次交易\n    Yes → Step 2: 初始化 profit = 0 // 用於累加正向差值\n    → For i in 1 .. len(prices)-1: // 遍歷相鄰天數\n        → Decision: 如果 prices[i] > prices[i-1]? // 判斷今天是否有利潤可賣\n            Yes → Step 3: profit += prices[i] - prices[i-1] // 累加利潤\n    → Step 4: 輸出 profit // 結束無限交易情況\n    → End // 完成\n    No → Step 5: 初始化 dp[0..k] 為 0 // dp[t] 代表 t 次交易至本日的最大利潤\n    → Step 6: 初始化 best[0..k] 為 -∞ // best[t] 儲存在第 t 次交易中最佳買入時機\n    → For i in 0 .. len(prices)-1: // 遍歷每一天\n        → For t in 1 .. k: // 逐次處理交易\n            → Decision: 更新 best[t] 為 max(best[t], dp[t-1] - prices[i])? // 判斷是否在今天買入\n                Yes → Step 7: best[t] = max(best[t], dp[t-1] - prices[i]) // 更新最佳買入差值\n            → Decision: 更新 dp[t] 為 max(dp[t], best[t] + prices[i])? // 判斷是否在今天賣出\n                Yes → Step 8: dp[t] = max(dp[t], best[t] + prices[i]) // 更新至目前日最大利潤\n    → Step 9: 輸出 dp[k] // 最大可得利潤\nEnd // 程式執行結束\n\nBut we need to ensure each line uses \"→\" only for steps and decisions. For nested lines, we can indent but each line still uses \"→\".\n\nLet's format each line:\n\nStart // 程式開始\n→ Step 1: 讀取價格陣列 prices 與交易上限 k // 取得輸入資料\n→ Decision: 如果 k >= len(prices)/2? // 判斷是否能視為無限次交易\n    Yes → Step 2: 初始化 profit = 0 // 用於累加正向差值\n    → For i in 1 .. len(prices)-1: // 遍歷相鄰天數\n        → Decision: 如果 prices[i] > prices[i-1]? // 判斷今天是否有利潤可賣\n            Yes → Step 3: profit += prices[i] - prices[i-1] // 累加利潤\n    → Step 4: 輸出 profit // 結束無限交易情況\n    → End // 完成\n    No → Step 5: 初始化 dp[0..k] 為 0 // dp[t] 代表 t 次交易至本日的最大利潤\n    → Step 6: 初始化 best[0..k] 為 -∞ // best[t] 儲存在第 t 次交易中最佳買入時機\n    → For i in 0 .. len(prices)-1: // 遍歷每一天\n        → For t in 1 .. k: // 逐次處理交易\n            → Decision: 更新 best[t] 為 max(best[t], dp[t-1] - prices[i])? // 判斷是否在今天買入\n                Yes → Step 7: best[t] = max(best[t], dp[t-1] - prices[i]) // 更新最佳買入差值\n            → Decision: 更新 dp[t] 為 max(dp[t], best[t] + prices[i])? // 判斷是否在今天賣出\n                Yes → Step 8: dp[t] = max(dp[t], best[t] + prices[i]) // 更新至目前日最大利潤\n    → Step 9: 輸出 dp[k] // 最大可得利潤\nEnd // 程式執行結束\n\nThis seems fine. Ensure each line ends with // explanation.\n\nWe must avoid actual code; use pseudocode. Use variables like profit, dp[t], best[t].\n\nAlso mention decision lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 讀取價格陣列 prices 與交易上限 k // 取得輸入資料\n→ Decision: 如果 k >= len(prices)/2? // 判斷是否能視為無限次交易\n    Yes → Step 2: 初始化 profit = 0 // 用於累加正向差值\n    → For i in 1 .. len(prices)-1: // 遍歷相鄰天數\n        → Decision: 如果 prices[i] > prices[i-1]? // 判斷今天是否有利潤可賣\n            Yes → Step 3: profit += prices[i] - prices[i-1] // 累加利潤\n    → Step 4: 輸出 profit // 結束無限交易情況\n    → End // 完成\n    No → Step 5: 初始化 dp[0..k] 為 0 // dp[t] 代表 t 次交易至本日的最大利潤\n    → Step 6: 初始化 best[0..k] 為 -∞ // best[t] 儲存在第 t 次交易中最佳買入時機\n    → For i in 0 .. len(prices)-1: // 遍歷每一天\n        → For t in 1 .. k: // 逐次處理交易\n            → Decision: 更新 best[t] 為 max(best[t], dp[t-1] - prices[i])? // 判斷是否在今天買入\n                Yes → Step 7: best[t] = max(best[t], dp[t-1] - prices[i]) // 更新最佳買入差值\n            → Decision: 更新 dp[t] 為 max(dp[t], best[t] + prices[i])? // 判斷是否在今天賣出\n                Yes → Step 8: dp[t] = max(dp[t], best[t] + prices[i]) // 更新至目前日最大利潤\n    → Step 9: 輸出 dp[k] // 最大可得利潤\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, k, prices):\n        n = len(prices)\n        if n == 0:\n            return 0\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        dp = [[0] * n for _ in range(k + 1)]\n        for t in range(1, k + 1):\n            max_diff = -prices[0]\n            for d in range(1, n):\n                dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff)\n                max_diff = max(max_diff, dp[t - 1][d] - prices[d])\n        return dp[k][n - 1]\n\ndef parse_input(data: str):\n    \"\"\"Parse input string to extract k and prices.\"\"\"\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    prices_match = re.search(r'prices\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if k_match:\n        k = int(k_match.group(1))\n    else:\n        # fallback: first line is k\n        parts = data.strip().splitlines()\n        k = int(parts[0].strip())\n        prices_match = re.search(r'^\\[([^\\]]*)\\]', parts[1].strip()) if len(parts) > 1 else None\n\n    if prices_match:\n        nums_str = prices_match.group(1).strip()\n        if nums_str:\n            prices = list(map(int, nums_str.split(',')))\n        else:\n            prices = []\n    else:\n        # fallback: second line is list of ints\n        parts = data.strip().splitlines()\n        if len(parts) > 1:\n            prices = list(map(int, parts[1].strip().split()))\n        else:\n            prices = []\n    return k, prices\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    k, prices = parse_input(raw)\n    result = Solution().maxProfit(k, prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode522.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence II",
    "description_snippet": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps. The algorithm: longest uncommon subsequence length between strings. Known solution: if any string unique (not repeated) then answer length of that string; else -1. Because longest uncommon subsequence must be entire string if it's unique; any shorter subsequence would also be subsequence of all duplicates? Actually if no unique string, all strings appear at least twice, so no uncommon subsequence exists. So algorithm: count frequency of each string. For each string, if its count == 1 return its length; else continue. If none unique return -1.\n\nWe need to output step-by-step pseudocode with arrows and explanation comments. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe must use arrow symbols and Decision: etc. The algorithm has Start, Steps, Decision. We'll implement:\n\nStart\n→ Step 1: 建立哈希表 freq // 記錄每個字串出現次數\n→ Step 2: 逐個遍歷 strs 更新 freq\n→ Decision: 是否存在頻率為 1 的字串?\n    Yes → Step 3: 找出頻率為 1 的字串並回傳其長度 // 最長不通用子序列長度\n    No  → Step 4: 回傳 -1 // 無不通用子序列\nEnd\n\nBut we might also need to iterate to find one unique string: we could find first unique string. So Step 3: 找第一個頻率為1的字串，返回其長度.\n\nLet's produce each line with explanation. Use arrow '→', 'Decision:' etc.\n\nNeed each line includes \"虛擬碼步驟\" and comment after space. We can include arrow as part of step.\n\nLet's produce.\n\nAlso we might want to mention that if multiple unique strings, any works; but we return length of any. But to be precise, we should return max length among unique strings? Actually algorithm returns length of longest uncommon subsequence: if there are multiple unique strings, we want the maximum length. But if we just return first unique string's length, might not be longest. But typical LeetCode solution: return length of any unique string (since all unique strings are unique; the longest among them is just the length of the longest unique string). But to guarantee, we should iterate to find maximum length among unique strings. Let's do that.\n\nSo Step 3: 計算所有頻率為1的字串的長度最大值，並回傳。\n\nBut easier: loop again to find max.\n\nThus pseudocode:\n\nStart\n→ Step 1: freq ← empty map // 记录每个字符串出现次数\n→ Step 2: For each s in strs: freq[s] ← freq.get(s,0)+1 // 计数\n→ Decision: 是否存在 freq[s] == 1 的字符串?\n    Yes → Step 3: maxLen ← 0\n        → For each s in strs:\n            → Decision: 如果 freq[s] == 1 且 len(s) > maxLen?\n                Yes → maxLen ← len(s) // 更新最长长度\n        → Step 4: 返回 maxLen // 最长不通用子序列长度\n    No  → Step 5: 返回 -1 // 无不通用子序列\nEnd\n\nWe can format each line accordingly. Let's produce each line:\n\nStart // 程式開始執行\n→ Step 1: freq ← {} // 初始化空字典用於計數\n→ Step 2: for each s in strs: freq[s] ← freq.get(s,0)+1 // 累加出現次數\n→ Decision: 是否存在 freq[s] == 1 的字串？ // 判斷是否有唯一字串\n    Yes → Step 3: maxLen ← 0 // 儲存目前已發現的唯一字串最大長度\n        → Step 4: for each s in strs:\n            → Decision: freq[s] == 1 且 len(s) > maxLen ?\n                Yes → maxLen ← len(s) // 更新最大長度\n    Yes → Step 5: 返回 maxLen // 返回最長不通用子序列長度\n    No  → Step 6: 返回 -1 // 無不通用子序列\nEnd // 程式結束\n\nBut indentation? We can keep structure.\n\nWe need each line with comment. So produce each line individually. Let's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: freq ← {} // 建立一個空字典，用於記錄每個字串的出現次數  \n→ Step 2: for each s in strs: freq[s] ← freq.get(s,0)+1 // 逐個字串累加頻率  \n→ Decision: 是否存在 freq[s] == 1 的字串？ // 判斷是否有唯一出現的字串  \n Yes → Step 3: maxLen ← 0 // 初始化最大長度變數  \n  → Step 4: for each s in strs:  \n   → Decision: freq[s] == 1 且 len(s) > maxLen ? // 檢查字串是否唯一且長度更長  \n    Yes → maxLen ← len(s) // 更新最大長度  \n Yes → Step 5: 返回 maxLen // 回傳最長不通用子序列的長度  \n No → Step 6: 返回 -1 // 無不通用子序列，回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLUSlength(self, strs):\n        # Sort strings by length descending to try longer strings first\n        strs.sort(key=lambda x: -len(x))\n        for i, s in enumerate(strs):\n            # Check if s is a subsequence of any other string\n            if all(not self.is_subsequence(s, t) for j, t in enumerate(strs) if i != j):\n                return len(s)\n        return -1\n\n    def is_subsequence(self, s, t):\n        # Returns True if s is a subsequence of t\n        it = iter(t)\n        return all(c in it for c in s)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(-1)\n    else:\n        # Parse input string into a list of strings\n        strs = ast.literal_eval(data)\n        result = Solution().findLUSlength(strs)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"aba\",\"cdc\",\"eae\"]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode413.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices",
    "description_snippet": "An integer array is called arithmetic if it consists of at least three elements and if the differenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: count number of arithmetic subarrays of length >=3. Approach: iterate and track length of current arithmetic segment. Count contributions: if current length >=3, add length-2. Standard solution. Use dynamic programming.\n\nWe output each line with arrow and explanation. We'll write a pseudo algorithm: Start, initialize count, current_length=2. Loop i from 2 to n-1, if nums[i]-nums[i-1]==nums[i-1]-nums[i-2], current_length++; else current_length=2. If current_length>=3, count+=current_length-2. End.\n\nWe'll output with steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果陣列長度小於 3? // 判斷是否能形成長度至少 3 的子陣列  \n    Yes → Step 1: 回傳 0 // 若元素不足 3 個，直接回傳 0  \n    No  → Step 2: 初始化 count = 0, currentLen = 2 // count 記錄結果，currentLen 追蹤目前連續等差段長度  \n→ Step 3: 從索引 2 開始迭代到陣列結尾 // 只需要從第三個元素開始比較  \n→ Decision: nums[i] - nums[i-1] 是否等於 nums[i-1] - nums[i-2]? // 檢查當前三個元素是否為等差  \n    Yes → Step 4: currentLen = currentLen + 1 // 若等差，長度加 1  \n    No  → Step 5: currentLen = 2 // 若不等差，重置為 2（因為新的子序列至少需要兩個元素來開始判斷）  \n→ Decision: currentLen 是否大於等於 3? // 判斷是否已形成合法等差子陣列  \n    Yes → Step 6: count = count + (currentLen - 2) // 每多一個元素可產生一個新的等差子陣列，累加  \n    No  → No action // 長度不足 3 時不做任何累加  \n→ End of loop // 迭代結束  \n→ Step 7: 回傳 count // 最終結果是所有等差子陣列的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"Count arithmetic subarrays of length at least 3.\"\"\"\n        n = len(nums)\n        if n < 3:\n            return 0\n\n        total = 0   # total number of arithmetic subarrays found\n        curr = 0    # number of arithmetic subarrays ending at the current index\n\n        for i in range(2, n):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                curr += 1            # extend the previous arithmetic sequence\n                total += curr        # each extension adds curr new subarrays\n            else:\n                curr = 0              # reset when the sequence breaks\n\n        return total\n\ndef parse_input(input_str):\n    \"\"\"\n    Extract a list of integers from a string that may contain\n    something like 'nums = [1, 2, 3]' or just '[1, 2, 3]'.\n    \"\"\"\n    # Find the first '[' and the matching ']' (simple assumption: only one list)\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []  # no list found, return empty list\n\n    list_str = input_str[start:end + 1]\n    try:\n        # Safely evaluate the list; assume it contains only integers\n        return eval(list_str, {\"__builtins__\": None}, {})\n    except Exception:\n        # If eval fails, fall back to regex extraction\n        numbers = re.findall(r'-?\\d+', list_str)\n        return [int(x) for x in numbers]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    nums = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.numberOfArithmeticSlices(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode345.json",
    "problem_index_in_file": 0,
    "title": "Reverse Vowels of a String",
    "description_snippet": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e',...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The task: reverse only all vowels in the string. Need to describe algorithm: two pointers i,j scanning from both ends, swapping when vowels. Use vowel set.\n\nWe produce lines: Start, Step to read string, define vowel set, initialize pointers, Decision if s[i] is vowel? etc. Use arrow structure.\n\nNeed to use \"虛擬碼步驟 // 解釋\". Let's produce lines accordingly. Use indentation or arrows? We can mimic example: \"→ Step 1: ...\" with arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入字串 s // 取得需要處理的字串\n→ Step 2: 定義集合 V = {a, e, i, o, u, A, E, I, O, U} // 紀錄所有元音\n→ Step 3: 初始化兩個指標 left = 0, right = length(s)-1 // 從兩端開始掃描\n→ Decision: left < right? // 是否還有字元未比較\n    Yes → Step 4: 判斷 s[left] 是否為元音\n        Yes → Step 5: 判斷 s[right] 是否為元音\n            Yes → Step 6: 交換 s[left] 與 s[right] // 兩個元音交換位置\n                → Step 7: left = left + 1, right = right - 1 // 移動指標\n            No  → Step 8: left = left + 1 // 右端非元音，左端已為元音但無交換\n        No  → Step 9: 判斷 s[right] 是否為元音\n            Yes → Step 10: right = right - 1 // 右端元音，左端非元音\n            No  → Step 11: left = left + 1, right = right - 1 // 兩端皆非元音，均移動\n    No  → Step 12: 輸出字串 s // 處理完畢，回傳結果\nEnd // 程式執行結束\n\nWe might need to reflect while loop with decision. That is fine.\n\nMake sure to keep arrow lines as in example.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 s // 取得需要處理的字串  \n→ Step 2: 定義集合 V = {a, e, i, o, u, A, E, I, O, U} // 紀錄所有元音  \n→ Step 3: 初始化兩個指標 left = 0, right = length(s)-1 // 從兩端開始掃描  \n→ Decision: left < right? // 是否還有字元未比較  \n Yes → Step 4: 判斷 s[left] 是否為元音  \n  Yes → Step 5: 判斷 s[right] 是否為元音  \n   Yes → Step 6: 交換 s[left] 與 s[right] // 兩個元音交換位置  \n    → Step 7: left = left + 1, right = right - 1 // 移動指標  \n   No  → Step 8: left = left + 1 // 右端非元音，左端已為元音但無交換  \n  No  → Step 9: 判斷 s[right] 是否為元音  \n   Yes → Step 10: right = right - 1 // 右端元音，左端非元音  \n   No  → Step 11: left = left + 1, right = right - 1 // 兩端皆非元音，均移動  \nNo  → Step 12: 輸出字串 s // 處理完畢，回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        \"\"\"Reverse only the vowels in the given string.\"\"\"\n        vowels = set(\"aeiouAEIOU\")\n        s_list = list(s)\n        left, right = 0, len(s_list) - 1\n        while left < right:\n            # Move left pointer to next vowel\n            while left < right and s_list[left] not in vowels:\n                left += 1\n            # Move right pointer to previous vowel\n            while left < right and s_list[right] not in vowels:\n                right -= 1\n            # Swap the vowels\n            if left < right:\n                s_list[left], s_list[right] = s_list[right], s_list[left]\n                left += 1\n                right -= 1\n        return \"\".join(s_list)\n\ndef parse_input(line: str) -> str:\n    \"\"\"\n    Parse a line that may be in the form:\n    s = \"some string\"\n    or just:\n    some string\n    \"\"\"\n    line = line.strip()\n    if not line:\n        return \"\"\n    if \"=\" in line:\n        # take the part after '='\n        _, value = line.split(\"=\", 1)\n        value = value.strip()\n        # strip surrounding quotes if present\n        if (value.startswith('\"') and value.endswith('\"')) or \\\n           (value.startswith(\"'\") and value.endswith(\"'\")):\n            value = value[1:-1]\n        return value\n    return line\n\nif __name__ == \"__main__\":\n    # Read the whole input; for simplicity, only the first non-empty line matters\n    raw_input = \"\"\n    for l in sys.stdin:\n        if l.strip():\n            raw_input = l.strip()\n            break\n\n    input_str = parse_input(raw_input)\n    solution = Solution()\n    result = solution.reverseVowels(input_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"IceCreAm\"",
          "expected_output": "\"AceCreIm\"",
          "success": true,
          "output": "AceCreIm"
        },
        {
          "example_index": 1,
          "input": "s = \"leetcode\"",
          "expected_output": "\"leotcede\"",
          "success": true,
          "output": "leotcede"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode464.json",
    "problem_index_in_file": 0,
    "title": "Can I Win",
    "description_snippet": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The p...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines. Must cover algorithm: recursion with memoization using bitmask to track used numbers. If sum of all numbers less than desiredTotal -> false. Use DFS: if any number leads opponent losing, return true. Else false. Need to check base cases. Provide explanation comments.\n\nLet's craft steps: Start, check trivial. Decision: sum < desiredTotal -> false. Decision: maxChoosableInteger==1? etc. Use memo array size 1<<maxChoosableInteger. Then define function canWin(usedMask, currentSum). For each i from 1 to maxChoosableInteger: if not used bit: if currentSum + i >= desiredTotal -> true; else if !canWin(newMask, currentSum+i) -> true. After loop set memo to false. Use recursion. At top call canWin(0,0). Provide pseudocode.\n\nWe need use arrows. Each line with explanation. Provide Start etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算可用數字總和 sum = maxChoosableInteger * (maxChoosableInteger + 1) / 2 // 先算所有數字之和  \n→ Decision: 如果 sum < desiredTotal? // 若所有數字加起來還不到目標，無法勝利  \n    Yes → Step 2: 回傳 false // 第一玩家必定輸  \n    No  → Decision: 如果 maxChoosableInteger == 1? // 單一數字情況簡化  \n        Yes → Step 3: 回傳 1 >= desiredTotal ? true : false // 直接比較  \n        No  → Step 4: 初始化 memo 數組長度 1 << maxChoosableInteger，值為 -1 // -1 表示尚未計算  \n        → Step 5: 呼叫 CanWin(usedMask = 0, currentSum = 0) // 從空盤開始遞迴判斷  \nEnd // 程式執行結束  \n\nDecision: CanWin(usedMask, currentSum) // 主要遞迴函式  \n    Yes → Step 6: 如果 memo[usedMask] != -1? // 有記錄  \n        Yes → Step 7: 回傳 memo[usedMask] == 1 ? true : false // 轉換布林  \n        No  → Step 8: 循環 i 從 1 到 maxChoosableInteger // 嘗試每個可選數字  \n            → Decision: 如果 bit i-1 在 usedMask 未設? // 該數字未被使用  \n                Yes → Step 9: newMask = usedMask | (1 << (i - 1)) // 標記為已使用  \n                → Decision: 如果 currentSum + i >= desiredTotal? // 本次選擇能直接達標  \n                    Yes → Step 10: memo[usedMask] = 1 // 記錄勝利  \n                    → Step 11: 回傳 true // 第一玩家贏  \n                    No  → Step 12: 如果 !CanWin(newMask, currentSum + i)? // 對手無法勝利  \n                        Yes → Step 13: memo[usedMask] = 1 // 記錄勝利  \n                        → Step 14: 回傳 true // 第一玩家贏  \n                        No  → Step 15: 繼續迴圈，嘗試下一個數字  \n            No  → Step 16: 繼續迴圈，數字已被使用  \n        → Step 17: memo[usedMask] = 0 // 所有選擇都無法贏，記錄失敗  \n        → Step 18: 回傳 false // 第一玩家輸  \nEnd // 遞迴函式結束",
      "generated_code": "import sys\nimport re\nfrom typing import Dict\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        # 若目標已達或以下，第一玩家即勝\n        if desiredTotal <= 0:\n            return True\n\n        # 所有數字加起來若還不夠目標，無法勝利\n        total_sum = maxChoosableInteger * (maxChoosableInteger + 1) // 2\n        if total_sum < desiredTotal:\n            return False\n\n        memo: Dict[int, bool] = {}\n\n        def dfs(mask: int, remaining: int) -> bool:\n            \"\"\"\n            mask : 1 << (i-1) 代表數字 i 已被使用\n            remaining : 尚需達到的總和\n            \"\"\"\n            if mask in memo:\n                return memo[mask]\n\n            for i in range(1, maxChoosableInteger + 1):\n                bit = 1 << (i - 1)\n                if mask & bit:          # 已經用過，跳過\n                    continue\n                # 若直接達標或對手無法勝利，則此玩家勝\n                if remaining <= i or not dfs(mask | bit, remaining - i):\n                    memo[mask] = True\n                    return True\n\n            memo[mask] = False\n            return False\n\n        return dfs(0, desiredTotal)\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並擷取數字\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        sys.exit(0)  # 不足兩個數字時不做處理\n\n    maxChoosableInteger, desiredTotal = nums[0], nums[1]\n    sol = Solution()\n    result = sol.canIWin(maxChoosableInteger, desiredTotal)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "maxChoosableInteger = 10, desiredTotal = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "maxChoosableInteger = 10, desiredTotal = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "maxChoosableInteger = 10, desiredTotal = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode122.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock II",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: max profit with unlimited transactions, multiple buys/sells same day but at most one share. This is classic: sum of all positive differences.\n\nWe'll produce steps: Start, initialize profit, iterate days 1..n-1, if price[i] > price[i-1] add diff to profit. End. Also could handle empty array.\n\nWe need to output line by line with arrow arrows and decision steps. Use \"Start\", \"Decision:\", \"Yes →\", \"No →\". The steps: Input prices array, if length <=1 then profit 0. Else iterate.\n\nWe need each line: virtual code step + comment.\n\nLet's craft:\n\nStart\n→ Input prices // 取得股價陣列\n→ Decision: prices.length <= 1? // 若陣列長度小於等於1\n    Yes → Step: 返回 0 // 沒有交易可行，利潤為0\n    No  → Step: 初始化 profit = 0 // 準備累積利潤\n    → Step: 設定 i = 1 // 從第二天開始迭代\n    → Decision: i < prices.length? // 是否還有天數\n        Yes → Step: 如果 prices[i] > prices[i-1]？ // 判斷是否能獲利\n            Yes → Step: profit += prices[i] - prices[i-1] // 加總利潤\n            No  → // 不加\n        No  → // 迴圈結束\n        → Step: i += 1 // 前進到下一天\n        → Decision: i < prices.length? // 重複迴圈\n            (loop back)\n→ Step: 返回 profit // 結果輸出\nEnd\n\nBut we must use arrows for decisions and steps. Use \"Decision:\" lines. For loop, we might structure using Decision and Yes/No arrows.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 輸入價格陣列 prices // 從使用者取得股價資料  \n→ Decision: prices.length <= 1? // 若只有 0 或 1 天，無法交易  \n Yes → Step: 返回 0 // 利潤為 0，程式結束  \n No  → Step: profit ← 0 // 初始化利潤累計值  \n → Step: i ← 1 // 設定迴圈起點為第二天（索引 1）  \n → Decision: i < prices.length? // 判斷是否還有天可處理  \n  Yes → Step: priceDiff ← prices[i] - prices[i-1] // 當天與前一天的價格差  \n   → Decision: priceDiff > 0? // 只在價格上漲時買入賣出  \n    Yes → Step: profit ← profit + priceDiff // 累加利潤  \n    No  → // 無利潤，跳過累加  \n  → Step: i ← i + 1 // 前進到下一天  \n  → Decision: i < prices.length? // 重新判斷迴圈結束條件  \n   Yes → // 回到上一個 Decision，繼續迴圈  \n   No  → // 迴圈結束  \n→ Step: 返回 profit // 回傳最終最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices):\n        \"\"\"計算最多利潤。\"\"\"\n        if not prices:\n            return 0\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit\n\ndef main():\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 允許輸入形如 \"prices = [1,2,3]\"\n    if '=' in raw_input:\n        _, list_part = raw_input.split('=', 1)\n    else:\n        list_part = raw_input\n\n    try:\n        prices = ast.literal_eval(list_part.strip())\n    except Exception as e:\n        print(\"Invalid input format\")\n        return\n\n    sol = Solution()\n    result = sol.maxProfit(prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode214.json",
    "problem_index_in_file": 0,
    "title": "Shortest Palindrome",
    "description_snippet": "You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n\nRe...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for shortest palindrome by adding characters to front. Classic algorithm: find longest palindromic prefix, then add reverse of suffix to front. Or use KMP to compute longest prefix which is also suffix of s + \"#\" + reverse(s). Steps: compute lps array. Then compute suffix to add. Let's produce pseudo-code.\n\nWe should output line by line: Start, then steps, decisions. Provide explanation after each line. No actual code, just virtual code. Use arrows, etc. Let's produce.\n\nWe need to consider input string s. Steps: compute reversed string r. Compute combined = s + \"#\" + r. Compute lps array for combined using KMP. Let longest = lps[last]. Then suffix = r.substring(0, len(r)-longest). Actually we want to add reverse of suffix of s that is not part of palindrome: add reversed of suffix of s? Wait algorithm: shortest palindrome by adding to front: find longest palindromic prefix of s. Let add = reverse(s.substr(longest)). So reversed of suffix after longest. So suffix = s.substr(longest). Then reverse it and add in front.\n\nThus pseudo-code:\n\n1. Input s.\n2. r = reverse(s)\n3. combined = s + \"#\" + r\n4. lps = computeLPS(combined) // KMP lps\n5. longest = lps[combined.length - 1]\n6. suffix = s.substring(longest)\n7. reverseSuffix = reverse(suffix)\n8. result = reverseSuffix + s\n9. Output result.\n\nBut we might incorporate decisions: e.g., if longest == s.length -> already palindrome. But not needed. Provide decisions.\n\nLet's output with arrow style. Each line: virtual code step + // explanation.\n\nWe can also include functions: computeLPS.\n\nLet's produce. Use \"Start\", \"End\".\n\nLet's produce line by line. Use indentation? Not necessary. Just arrow.\n\nLet's craft.\n\nAlso mention \"→ Decision: If s is palindrome?\" maybe.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者取得待轉換之字串  \n→ Step 2: r ← Reverse(s) // 取得 s 的反轉字串  \n→ Step 3: combined ← s + \"#\" + r // 建立用於 KMP 的串合，# 作為分隔符  \n→ Step 4: lps ← ComputeLPS(combined) // 用 KMP 計算 longest prefix suffix 陣列  \n→ Step 5: longest ← lps[combined.Length - 1] // 取得能成為回文前綴的最大長度  \n→ Decision: 若 longest = s.Length? // 檢查 s 是否已是回文  \n    Yes → Step 6: result ← s // 若已是回文，直接回傳 s  \n    No  → Step 7: suffix ← s.Substring(longest) // 取得非回文部分的字串  \n→ Step 8: reverseSuffix ← Reverse(suffix) // 反轉該非回文部分  \n→ Step 9: result ← reverseSuffix + s // 把反轉後的字串加到前面得到最短回文  \n→ Step 10: 輸出 result // 將最短回文字串輸出  \nEnd // 程式執行結束\n\n// ComputeLPS: 用 KMP 算法計算 longest prefix suffix 陣列  \nStart ComputeLPS // 開始計算 lps  \n→ Step 1: 初始化 lps[0] ← 0  \n→ Step 2: i ← 1, length ← 0  \n→ Decision: i < combined.Length? // 迴圈遍歷整個串  \n    Yes → Step 3: 若 combined[i] = combined[length]?  \n        Yes → length ← length + 1; lps[i] ← length; i ← i + 1  \n        No → Decision: length > 0?  \n            Yes → length ← lps[length - 1] // 回退到前一個長度  \n            No → lps[i] ← 0; i ← i + 1  \n    No  → End ComputeLPS // 完成 lps 計算  \nEnd ComputeLPS // 返回 lps 陣列",
      "generated_code": "#!/usr/bin/env python3\nimport sys\nimport re\n\ndef shortest_palindrome(s: str) -> str:\n    \"\"\"\n    將字串 s 轉為最短回文，只允許在前面新增字元。\n    方案：\n        1. 計算 s 與其反轉 r 的 KMP LPS (Longest Prefix Suffix) 陣列\n        2. 取得可作為回文前綴的最大長度 longest\n        3. 取出不在前綴內的後綴 suffix，反轉後接在前面即可\n    \"\"\"\n    if not s:\n        return \"\"\n\n    r = s[::-1]\n    combined = s + \"#\" + r\n    n = len(combined)\n    lps = [0] * n\n\n    for i in range(1, n):\n        length = lps[i - 1]\n        while length > 0 and combined[i] != combined[length]:\n            length = lps[length - 1]\n        if combined[i] == combined[length]:\n            length += 1\n        lps[i] = length\n\n    # lps[-1] 為可作為回文前綴的最大長度\n    to_add = s[lps[-1]:][::-1]\n    return to_add + s\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從 stdin 讀取的字串可能是:\n        1. 直接給字串，例如 aacecaaa\n        2. 形式 s = 'aacecaaa'\n        3. 形式 s = \"abcd\"\n    這裡嘗試抽取單引號或雙引號內的內容，若無則直接回傳\n    整個輸入（去除首尾空白）。\n    \"\"\"\n    raw = raw.strip()\n    # 匹配 '...' 或 \"...\"\n    m = re.search(r\"['\\\"](.*?)['\\\"]\", raw)\n    if m:\n        return m.group(1)\n    # 匹配 s = ... 形式（去除等號及空白）\n    if raw.lower().startswith(\"s\"):\n        parts = raw.split(\"=\", 1)\n        if len(parts) == 2:\n            return parts[1].strip().strip(\"'\\\"\")\n    return raw\n\ndef main() -> None:\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    result = shortest_palindrome(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'aacecaaa'",
          "expected_output": "'aaacecaaa'",
          "success": true,
          "output": "aaacecaaa"
        },
        {
          "example_index": 1,
          "input": "s = 'abcd'",
          "expected_output": "'dcbabcd'",
          "success": true,
          "output": "dcbabcd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode713.json",
    "problem_index_in_file": 0,
    "title": "Subarray Product Less Than K",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with comments. The problem: count subarrays with product < k. Standard sliding window.\n\nWe produce steps: Start, input array, input k, if k <= 1 return 0, initialize left=0, prod=1, count=0, iterate right over indices, multiply prod by nums[right], while prod >= k and left <= right, divide prod by nums[left], left++ ; after that, count += right-left+1; End.\n\nWe need to output each step with arrow and comment.\n\nLet's generate. Use `Start // ...`, `→ Step X: ... // ...`, etc. We need to use arrow lines for decisions.\n\nLet's produce a list:\n\n1. Start\n2. Input array nums and integer k // get data\n3. Decision: If k <= 1? // if threshold too low no subarray\n    Yes → Step 3a: Return 0 // no subarray satisfies\n    No  → Continue\n4. Step 4: Initialize left = 0, prod = 1, count = 0 // sliding window pointers and counters\n5. Step 5: For each right from 0 to len(nums)-1 // iterate over array\n    -> Step 5a: prod = prod * nums[right] // multiply by new element\n    -> Decision: While prod >= k and left <= right? // shrink window if product too large\n        Yes → Step 5b: prod = prod / nums[left] // divide out leftmost element\n        Yes → Step 5c: left = left + 1 // move left pointer\n        (loop continues)\n    -> Step 5d: count = count + (right - left + 1) // all subarrays ending at right are valid\n6. End // return count\n\nMake sure each line has `虛擬碼步驟` then `// 解釋`. We also use indentation for decisions and loops. Use \"→\" for steps.\n\nLet's format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input array nums and integer k // 取得輸入的整數陣列與閾值 k  \n→ Decision: If k <= 1? // 若 k 小於等於 1，則不可能有乘積小於 k 的子陣列  \n Yes → Return 0 // 直接返回 0，程式結束  \n No →  // 繼續執行  \n→ Initialize left = 0, prod = 1, count = 0 // 設定滑動窗口左指標、產品以及計數器  \n→ For each right from 0 to len(nums)-1 // 逐一遍歷陣列  \n → prod = prod * nums[right] // 將當前元素加入產品  \n → Decision: While prod >= k and left <= right? // 產品太大時收縮窗口  \n  Yes → prod = prod / nums[left] // 將左指標指向的元素移除產品  \n  Yes → left = left + 1 // 左指標右移  \n → count = count + (right - left + 1) // 所有以 right 結束的子陣列皆符合條件  \nEnd // 程式執行結束，返回 count",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums, k):\n        if k <= 1:\n            return 0\n        prod = 1\n        left = 0\n        count = 0\n        for right, val in enumerate(nums):\n            prod *= val\n            while prod >= k and left <= right:\n                prod //= nums[left]\n                left += 1\n            count += right - left + 1\n        return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse input like: nums = [10,5,2,6], k = 100\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        # Try a simpler split if format is different\n        parts = data.split(',')\n        nums_part = next((p for p in parts if 'nums' in p), '')\n        k_part = next((p for p in parts if 'k' in p), '')\n        nums_str = nums_part.split('=')[1].strip() if '=' in nums_part else '[]'\n        k_str = k_part.split('=')[1].strip() if '=' in k_part else '0'\n    else:\n        nums_str, k_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n\n    sol = Solution()\n    result = sol.numSubarrayProductLessThanK(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,5,2,6], k = 100",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3], k = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode187.json",
    "problem_index_in_file": 0,
    "title": "Repeated DNA Sequences",
    "description_snippet": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. For e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the described problem: find all 10-letter substrings that occur more than once. So algorithm: sliding window, use hash map count. At the end, output list of substrings with count>1.\n\nWe must output line by line with virtual code and comment. Use arrows, decision, etc.\n\nWe should structure: Start, input string, initialize map, set result set, iterate i from 0 to len-10, get substring, update count, if count==2 add to result, else ignore. After loop, output result. End.\n\nWe need to produce \"虛擬碼步驟\" + \" // 解釋/說明\" each line. Use arrows like → Step etc. Use Start, End.\n\nMake sure each line uses the format: `虛擬碼步驟 // 解釋/說明`.\n\nExample: `Start // 程式開始執行`.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得 DNA 序列\n→ Step 2: 建立空哈希表 countMap // 用於計數子字串\n→ Step 3: 建立空集合 result // 存儲重複子字串\n→ Decision: 如果 len(s) < 10? // 無法形成 10 字母子字串\n    Yes → Step 4: 回傳空列表 // 返回空結果\n    No → Step 5: for i from 0 to len(s)-10 // 遍歷所有起點\n        → Step 6: sub = s.substring(i, i+10) // 取得 10 字母子字串\n        → Step 7: count = countMap.get(sub, 0) + 1 // 更新計數\n        → Step 8: countMap.set(sub, count) // 存回哈希表\n        → Decision: 如果 count == 2? // 第一次重複\n            Yes → Step 9: result.add(sub) // 加入結果\n            No  → // 不需要任何操作\n→ Step 10: 回傳 result // 返回所有重複子字串\nEnd // 程式執行結束\n\nMake sure each line ends with `//` comment. Use arrow arrow? They ask to use virtual code arrow `→`, `Yes →`, `No →` and structure `Start`, `End`, `Decision:`. So we should use those.\n\nLet's format.\n\nAlso ensure each line has the comment after space. Use \" // \" as separator. Provide Chinese explanation.\n\nWe should maybe put the step lines with indentation? Not necessary but we can include indent for decisions.\n\nThey didn't specify indentation but example shows indent.\n\nWe produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 取得 DNA 序列\n→ Step 2: 建立空哈希表 countMap // 用於記錄每個 10 字母子字串的出現次數\n→ Step 3: 建立空集合 result // 存儲重複出現的子字串\n→ Decision: 如果 s.length < 10? // 若字串不足 10 個字母，無法產生 10 字母子字串\n    Yes → Step 4: 回傳空列表 // 直接返回空結果\n    No  → Step 5: for i = 0 to s.length - 10 // 逐個位置滑動窗口\n        → Step 6: sub = s.substring(i, i+10) // 取得從 i 開始的 10 字母子字串\n        → Step 7: count = countMap.get(sub, 0) + 1 // 取得當前計數並遞增\n        → Step 8: countMap.set(sub, count) // 更新哈希表\n        → Decision: 如果 count == 2? // 第一次遇到第二次相同子字串\n            Yes → Step 9: result.add(sub) // 將子字串加入結果集合\n            No  → // 無需額外處理\n→ Step 10: 回傳 result // 回傳所有重複的 10 字母子字串\nEnd // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". We used // comment. Good.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得 DNA 序列  \n→ Step 2: 建立空哈希表 countMap // 用於記錄每個 10 字母子字串的出現次數  \n→ Step 3: 建立空集合 result // 存儲重複出現的子字串  \n→ Decision: 如果 s.length < 10? // 若字串不足 10 個字母，無法產生 10 字母子字串  \n&nbsp;&nbsp;&nbsp;Yes → Step 4: 回傳空列表 // 直接返回空結果  \n&nbsp;&nbsp;&nbsp;No  → Step 5: for i = 0 to s.length - 10 // 逐個位置滑動窗口  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: sub = s.substring(i, i+10) // 取得從 i 開始的 10 字母子字串  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: count = countMap.get(sub, 0) + 1 // 取得當前計數並遞增  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: countMap.set(sub, count) // 更新哈希表  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 如果 count == 2? // 第一次遇到第二次相同子字串  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 9: result.add(sub) // 將子字串加入結果集合  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 無需額外處理  \n→ Step 10: 回傳 result // 回傳所有重複的 10 字母子字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> list:\n        \"\"\"找出所有長度為10且重複出現的 DNA 子字串。\"\"\"\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i + 10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 嘗試從輸入中提取單引號或雙引號包住的字串\n    match = re.search(r'([\\'\"])(.*?)(?<!\\\\)\\1', data)\n    if match:\n        dna_seq = match.group(2)\n    else:\n        dna_seq = data\n\n    solver = Solution()\n    result = solver.findRepeatedDnaSequences(dna_seq)\n\n    # 以 JSON 格式輸出，符合範例的雙引號風格\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        },
        {
          "example_index": 1,
          "input": "s = 'AAAAAAAAAAAAA'",
          "expected_output": "[\"AAAAAAAAAA\"]",
          "success": true,
          "output": "[\"AAAAAAAAAA\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode300.json",
    "problem_index_in_file": 0,
    "title": "Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the length of the longest strictly increasing subsequence....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, not actual code. The algorithm: dynamic programming O(n^2) or LIS via patience sorting O(n log n). Provide steps. Each line: \"Step X: description // explanation\". Use arrows and decisions. Provide Start, End. Use \"Decision:\" lines for if conditions. Provide iterative loops.\n\nWe need to produce steps: read array, initialize dp array, loop i, loop j, update dp[i], compute max, return result. Provide pseudocode steps.\n\nMake sure to include \"→\" arrows. Use \"Decision:\" etc. Each line: virtual step + \" // \" explanation.\n\nLet's craft.\n\nWe'll start:\n\nStart // 程式開始\n\n→ Step 1: 獲取輸入陣列 nums // 取得整數序列\n\n→ Step 2: 定義變數 n = nums.length // 長度\n\n→ Step 3: 建立 dp 陣列長度 n，初值 1 // 每個位置至少為 1\n\n→ Decision: 如果 n == 0? // 空陣列特殊處理\n\n    Yes → Step 4: 返回 0 // 沒有子序列\n\n    No  → proceed to next\n\n→ Step 5: 從 i = 1 到 n-1 進行迴圈 // 外層\n\n    → Step 6: 從 j = 0 到 i-1 進行迴圈 // 內層\n\n        → Decision: 如果 nums[j] < nums[i]? // 是否可以擴展\n\n            Yes → Step 7: dp[i] = max(dp[i], dp[j] + 1) // 更新長度\n\n            No  → 什麼也不做\n\n→ Step 8: 找出 dp 陣列中的最大值 maxLen // 取最大\n\n→ Step 9: 返回 maxLen // 結果\n\nEnd // 程式結束\n\nWe need to include \"→\" for each step line, indent decision branches. Use \"Decision:\" with arrow.\n\nMake sure to include all lines as per format.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 從使用者取得整數序列  \n→ Step 2: 定義變數 n = nums.length // 取得陣列長度  \n→ Step 3: 建立 dp 陣列長度 n，初值皆為 1 // 每個位置至少為 1  \n→ Decision: 如果 n 等於 0? // 判斷是否為空陣列  \n  Yes → Step 4: 返回 0 // 空陣列長度為 0  \n  No  → (繼續後續步驟)  \n→ Step 5: 針對 i 從 1 到 n-1 進行迴圈 // 外層迴圈  \n  → Step 6: 針對 j 從 0 到 i-1 進行迴圈 // 內層迴圈  \n    → Decision: 如果 nums[j] 小於 nums[i]? // 可否延伸子序列  \n      Yes → Step 7: dp[i] = max(dp[i], dp[j] + 1) // 更新 dp[i] 為更長的長度  \n      No  → (不做任何操作)  \n→ Step 8: 計算 dp 陣列中的最大值 maxLen // 取得最長子序列長度  \n→ Step 9: 返回 maxLen // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport bisect\n\nclass Solution:\n    def lengthOfLIS(self, nums):\n        # tails[i] 代表長度為 i+1 的遞增子序列的最小尾端元素\n        tails = []\n        for num in nums:\n            idx = bisect.bisect_left(tails, num)\n            if idx == len(tails):\n                tails.append(num)\n            else:\n                tails[idx] = num\n        return len(tails)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支援如下格式：\n    - \"nums = [1, 2, 3]\"\n    - \"[1, 2, 3]\"\n    \"\"\"\n    data = data.strip()\n    if '=' in data:\n        _, val = data.split('=', 1)\n        data = val.strip()\n    try:\n        return ast.literal_eval(data)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    result = Solution().lengthOfLIS(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,9,2,5,3,7,101,18]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,3,2,3]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [7,7,7,7,7,7,7]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode46.json",
    "problem_index_in_file": 0,
    "title": "Permutations",
    "description_snippet": "Given an array nums of distinct integers, return all the possible permutations. You can return the a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines for generating all permutations of distinct integers array. Use recursive backtracking. Output steps. Provide explanation after each line. Use virtual code arrow. Use \"Start\", \"End\". Use Decision lines for conditions. For recursion, we might use a stack or call.\n\nWe need to adhere to format exactly: each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows like \"→\" after Start. For decision, indent? The example uses indentation and nested arrows. We'll follow same style: Start line, then arrows. Use \"→\" before each step. Use \"Decision:\" lines with indent. Use \"Yes →\" and \"No →\". The example uses indentation of 4 spaces for nested. We'll follow that.\n\nWe need to produce a virtual code of algorithm: Start, Step 1: Initialize result list, Step 2: Define backtrack function, Step 3: If current permutation length equals nums length, add copy to result, return. Step 4: For each index i in nums, if not used, mark used, add to current, backtrack, unmark, pop.\n\nWe need to show steps sequentially.\n\nAlso need to mention input array. Step: \"Step 1: Initialize result = [] // store permutations\". Step: \"Step 2: Initialize current = [] // temporary list\". Step: \"Step 3: Initialize used array of booleans of length n\". Step: \"Step 4: Define backtrack function\". Inside function, decisions: if len(current)==len(nums): add copy to result.\n\nAlso for loop, for i in 0..n-1, Decision: if used[i] is false? Yes: proceed.\n\nReturn result.\n\nAdd End.\n\nOk produce. Ensure each line has \"虛擬碼步驟\" meaning actual step description. Use \"Start\", \"→ Step X: ...\" lines. After each line, explanation.\n\nLet's produce. Use the same indentation style: After Start, next line has arrow. For Decision, indent 4 spaces. For Yes/No arrows also indent.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums = [input array] // 取得輸入的整數陣列  \n→ Step 2: result = [] // 用來儲存所有排列結果  \n→ Step 3: current = [] // 用來儲存目前正在構造的排列  \n→ Step 4: used = [False] * len(nums) // 標記每個數字是否已被使用  \n\n→ Step 5: Define backtrack() // 定義遞迴回溯函式  \n\n    → Decision: 如果 len(current) == len(nums) ? // 判斷是否已形成完整排列  \n        Yes → Step 6: result.append(current.copy()) // 將完成的排列加入結果  \n        No  → Step 7: For i in range(len(nums)) // 遍歷所有位置  \n            → Decision: 如果 not used[i] ? // 檢查此位置的數字是否已使用  \n                Yes → Step 8: used[i] = True // 標記為已使用  \n                      → Step 9: current.append(nums[i]) // 加入排列  \n                      → Step 10: backtrack() // 進一步遞迴  \n                      → Step 11: current.pop() // 回溯時移除最後加入的數字  \n                      → Step 12: used[i] = False // 解除使用標記  \n                No  → // 若已使用，直接跳過此位置  \n\n→ Step 13: backtrack() // 開始回溯過程  \n→ Step 14: return result // 回傳所有排列結果  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef permute(nums):\n    \"\"\"Return all permutations of the list `nums`.\"\"\"\n    res = []\n\n    def backtrack(start):\n        # Decision: 是否已經到達最後一個位置\n        if start == len(nums):\n            res.append(nums[:])  # 加入目前排列的拷貝\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]  # 交換\n            backtrack(start + 1)                        # 進一步遞迴\n            nums[start], nums[i] = nums[i], nums[start]  # 回溯\n\n    backtrack(0)\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入字串中尋找方括號內的列表\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        try:\n            nums = ast.literal_eval(match.group())\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    # 計算所有排列\n    result = permute(nums)\n\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode829.json",
    "problem_index_in_file": 0,
    "title": "Consecutive Numbers Sum",
    "description_snippet": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive int...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code. Task: Given integer n, return number of ways to write n as sum of consecutive positive integers. We need to produce step-by-step pseudocode lines with explanations. Use virtual code with arrows. Need to use Start, End, Decision: etc. We need to produce algorithm: Count number of ways n can be expressed as sum of consecutive positive integers. Classic approach: For each length k (>=1) such that n/k is something, find if k*(k+1)/2 <= n? Actually condition: n can be expressed as sum of k consecutive integers starting at a: n = k*a + k*(k-1)/2 => a = (n - k*(k-1)/2)/k. Need a integer >0. So count k such that (n - k*(k-1)/2) % k == 0 and result >0. k can go from 1 up to while k*(k+1)/2 <= n. Also note that k=1 always works (single number). But may also consider odd/even factorization? But we just need algorithm.\n\nWe'll produce pseudocode: Start, Step 1: Read n, initialize count=0, k=1. Step 2: While k*(k+1)/2 <= n: compute numerator = n - k*(k-1)/2. Check if numerator%k==0 and numerator/k > 0: increment count. k++. End. Step 3: Output count.\n\nWe'll use Decision for while loop: Decision: k*(k+1)/2 <= n? Yes → proceed else exit.\n\nAlso for each iteration, Decision for numerator%k==0? Yes and numerator/k >0? Yes.\n\nWe need to show \"虛擬碼步驟\" and comment.\n\nLet's generate lines:\n\nStart\n→ Step 1: 讀取整數 n // 取得輸入\n→ Step 2: 設定 count = 0, k = 1 // 初始化計數器和長度\n→ Decision: k*(k+1)/2 <= n? // 判斷是否還能嘗試更長的序列\n    Yes → Step 3: 計算 numerator = n - k*(k-1)/2 // 計算剩餘和\n    → Decision: numerator % k == 0 AND numerator / k > 0? // 檢查起始數是否正整數\n        Yes → Step 4: count = count + 1 // 找到一個合法寫法\n        No  → Step 5: // 跳過此 k\n    → Step 6: k = k + 1 // 進行下一個長度\n    No  → Step 7: 輸出 count // 所有可能已檢查完\nEnd\n\nBut we need to ensure arrow format: We need \"→\" for steps, \"Decision:\" with Yes → and No →.\n\nWe might also include nested decision for numerator%k etc. Use \"Decision:\" lines. Might need to structure indentation. Use spaces indentation for clarity but not necessary.\n\nAlso each line must have the virtual code and explanation after //.\n\nWe should include \"Step 1:\" etc. Use arrow to denote transitions.\n\nWe need to follow output format: each line \"虛擬碼步驟 [space] // 解釋/說明\". They used \"→\" arrow. The example uses \"→ Step 1:\" etc. We'll replicate.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得使用者輸入的目標數字\n→ Step 2: 設定 count = 0, k = 1 // 初始化計數器與序列長度\n→ Decision: k*(k+1)/2 <= n? // 判斷是否還有足夠的總和可嘗試\n    Yes → Step 3: 計算 numerator = n - k*(k-1)/2 // 計算剩餘和以判斷起始值\n    → Decision: numerator % k == 0 AND numerator / k > 0? // 檢查起始值是否正整數\n        Yes → Step 4: count = count + 1 // 有效寫法，計數加一\n        No  → Step 5: // 無效寫法，忽略\n    → Step 6: k = k + 1 // 將序列長度加一，繼續檢查\n    No  → Step 7: 輸出 count // 所有序列已檢查完畢，輸出結果\nEnd // 程式執行結束\n\nBut we need to keep each line separate. But the \"Decision\" lines with nested steps may be on multiple lines. Example shows indentation. We should produce as above, each line separate. The arrow used \"→ Decision:\" etc. So we will replicate.\n\nWe also need to keep \"Yes →\" and \"No →\" lines.\n\nMake sure to maintain \"虛擬碼步驟\" (i.e., each line contains the arrow, step label, etc.) and comment.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得使用者輸入的目標數字  \n→ Step 2: 設定 count = 0, k = 1 // 初始化計數器與序列長度  \n→ Decision: k*(k+1)/2 <= n? // 判斷是否還有足夠的總和可嘗試  \n&nbsp;&nbsp;Yes → Step 3: 計算 numerator = n - k*(k-1)/2 // 計算剩餘和以判斷起始值  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: numerator % k == 0 AND numerator / k > 0? // 檢查起始值是否正整數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: count = count + 1 // 有效寫法，計數加一  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5: // 無效寫法，忽略  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 6: k = k + 1 // 將序列長度加一，繼續檢查  \n&nbsp;&nbsp;No  → Step 7: 輸出 count // 所有序列已檢查完畢，輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef consecutive_numbers_sum(n: int) -> int:\n    \"\"\"Return the number of ways to write n as a sum of consecutive positive integers.\"\"\"\n    count = 0\n    k = 1\n    # While the sum of the first k-1 positive integers is less than n\n    while k * (k - 1) // 2 < n:\n        # Check if n can be expressed as a sum of k consecutive numbers\n        if (n - k * (k - 1) // 2) % k == 0:\n            count += 1\n        k += 1\n    return count\n\ndef main() -> None:\n    # Read the entire input from stdin\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    # Compute and print the result\n    print(consecutive_numbers_sum(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 9",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode202.json",
    "problem_index_in_file": 0,
    "title": "Happy Number",
    "description_snippet": "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. For happy number algorithm: check if n == 1 true; else if n in seen set cycle false; else compute sum of squares of digits and repeat. We'll produce steps with Start, Step, Decision, loops.\n\nLet's produce a linear step list:\n\nStart\n→ Step 1: 定義空集合 visited // 用來記錄已出現過的數\n→ Step 2: 設 current = n // 初始化當前數\n→ Decision: current 等於 1? // 檢查是否已經是 1\n    Yes → Step 3: 回傳 true // 成功\n    No  → Decision: current 是否在 visited? // 檢查是否重複\n        Yes → Step 4: 回傳 false // 循環，不是 happy\n        No  → Step 5: 把 current 加入 visited // 記錄\n→ Step 6: 計算 next = sum_of_squares_of_digits(current) // 新的數\n→ Step 7: 設 current = next // 更新\n→ Step 8: 回到 Decision: current 等於 1? // 迴圈\n\nEnd.\n\nBut we need virtual code lines with arrow and explanation. We might need to include while loop. Use a loop label maybe.\n\nLet's structure:\n\nStart\n→ Step 1: 初始化 visited = {} // 追蹤已出現的數\n→ Step 2: current = n // 開始數字\n→ Decision: current == 1? // 是否已達 1\n    Yes → Step 3: 回傳 true\n    No  → Decision: current 在 visited? // 是否重複\n        Yes → Step 4: 回傳 false\n        No  → Step 5: visited 加 current\n→ Step 6: current = sum_of_squares_of_digits(current) // 計算下一個\n→ Step 7: 回到 Decision: current == 1? // 重複\n\nEnd\n\nMake sure each line ends with // explanation. Use arrow symbol for flow.\n\nAlso need to indicate \"→\" before each step. For decisions, include nested indentation. Use proper formatting as example: \"Decision: ...\" then Yes → etc.\n\nWe must not output real code, just pseudocode lines. Provide each line.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 初始化 visited = {} // 用來記錄已出現的數\n→ Step 2: current = n // 設定當前數\n→ Decision: current 等於 1? // 檢查是否已經是 1\n    Yes → Step 3: 回傳 true // 成功\n    No  → Decision: current 是否在 visited? // 檢查是否重複\n        Yes → Step 4: 回傳 false // 出現循環\n        No  → Step 5: visited 加 current // 記錄\n→ Step 6: current = sum_of_squares_of_digits(current) // 取各位平方和\n→ Step 7: 回到 Decision: current 等於 1? // 重複循環\nEnd // 程式結束\n\nEnsure each line has \"虛擬碼步驟\" followed by space and comment. For decisions indent lines with 4 spaces maybe.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 初始化 visited = {} // 用來記錄已出現的數  \n→ Step 2: current = n // 設定當前數  \n→ Decision: current 等於 1? // 檢查是否已經是 1  \n  Yes → Step 3: 回傳 true // 成功  \n  No  → Decision: current 是否在 visited? // 檢查是否重複  \n   Yes → Step 4: 回傳 false // 出現循環  \n   No  → Step 5: visited 加 current // 記錄  \n→ Step 6: current = sum_of_squares_of_digits(current) // 取各位平方和  \n→ Step 7: 回到 Decision: current 等於 1? // 重複循環  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isHappy(self, n: int) -> bool:\n        def get_next(number: int) -> int:\n            total = 0\n            while number > 0:\n                digit = number % 10\n                total += digit * digit\n                number //= 10\n            return total\n\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1\n\ndef main() -> None:\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    solution = Solution()\n    result = solution.isHappy(n)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 19",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode189.json",
    "problem_index_in_file": 0,
    "title": "Rotate Array",
    "description_snippet": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for rotating an array right by k steps. Should handle k >= 0, maybe k > n. Steps: compute n, k mod n. Then reverse entire array, reverse first k elements, reverse remaining. Provide virtual code lines with comments.\n\nWe must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow symbols. Use Start, End, Decision. Provide line-by-line steps.\n\nLet's outline:\n\nStart\n→ Step 1: Read nums array and integer k\n→ Step 2: Set n = length(nums)\n→ Decision: If n == 0? // if empty array, nothing to do\n   Yes → End // exit\n   No  → \n→ Step 3: k = k mod n // adjust steps\n→ Step 4: Reverse entire array\n→ Step 5: Reverse first k elements\n→ Step 6: Reverse elements from k to n-1\n→ End\n\nAlso maybe include Decision: If k == 0? then nothing. But we can skip or add.\n\nBetter to include Decision: If k == 0? Yes → End. No → proceed.\n\nAlso handle k >= n maybe adjust.\n\nLet's produce virtual code:\n\nStart // 程式開始執行\n→ Step 1: nums ← 輸入整數陣列 // 取得待旋轉的陣列\n→ Step 2: k ← 輸入旋轉步數 // 取得旋轉步數\n→ Step 3: n ← length(nums) // 陣列長度\n→ Decision: n == 0? // 空陣列無需處理\n    Yes → End // 結束程式\n    No  →\n→ Decision: k == 0? // 步數為零不需旋轉\n    Yes → End\n    No  →\n→ Step 4: k ← k mod n // 只保留對陣列長度有意義的步數\n→ Step 5: Reverse(nums, 0, n-1) // 先將整個陣列倒轉\n→ Step 6: Reverse(nums, 0, k-1) // 再將前 k 個元素倒轉\n→ Step 7: Reverse(nums, k, n-1) // 最後將剩餘元素倒轉\n→ End // 程式執行結束\n\nBut need arrow arrow for decisions. For each decision, we have Yes and No branches. Provide indent maybe. In sample, they used indentation. We can replicate.\n\nAlso need to include virtual code for Reverse function? Might mention as subroutine.\n\nLet's write each line with arrow and comments.\n\nUse \"→\" before each step.\n\nIn decision block, we write \"Decision: ...\" line, then indent with spaces maybe 4? And then \"Yes →\" etc.\n\nWe should maintain consistent format: \"Decision:\" line, indent.\n\nOk. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← 輸入整數陣列 // 取得待旋轉的陣列  \n→ Step 2: k ← 輸入旋轉步數 // 取得旋轉步數  \n→ Step 3: n ← length(nums) // 陣列長度  \n→ Decision: n == 0? // 空陣列無需處理  \n    Yes → End // 程式結束  \n    No  →  \n→ Decision: k == 0? // 步數為零不需旋轉  \n    Yes → End  \n    No  →  \n→ Step 4: k ← k mod n // 只保留對陣列長度有意義的步數  \n→ Step 5: Reverse(nums, 0, n-1) // 先將整個陣列倒轉  \n→ Step 6: Reverse(nums, 0, k-1) // 再將前 k 個元素倒轉  \n→ Step 7: Reverse(nums, k, n-1) // 最後將剩餘元素倒轉  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def rotate(self, nums, k):\n        \"\"\"\n        Rotate the list `nums` to the right by `k` steps in-place.\n        \"\"\"\n        n = len(nums)\n        if n == 0 or k % n == 0:\n            return\n        k %= n\n        # Reverse the whole list, then the first k elements, and finally the rest.\n        nums[:] = nums[-k:] + nums[:-k]\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract the list of numbers and the rotation value using regular expressions\n    list_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*([-\\d]+)', data)\n\n    if not list_match or not k_match:\n        raise ValueError(\"Input format incorrect. Expected 'nums = [...] , k = ...'.\")\n\n    # Safely evaluate the list string into a Python list\n    nums_str = list_match.group(1)\n    try:\n        nums = eval(nums_str, {}, {})\n    except Exception as e:\n        raise ValueError(f\"Failed to parse list: {e}\")\n\n    k = int(k_match.group(1))\n\n    # Perform the rotation\n    solution = Solution()\n    solution.rotate(nums, k)\n\n    # Output the rotated list\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "success": true,
          "output": "[5, 6, 7, 1, 2, 3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "success": true,
          "output": "[3, 99, -1, -100]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode492.json",
    "problem_index_in_file": 0,
    "title": "Construct the Rectangle",
    "description_snippet": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve the problem: given area A, find integer L, W such that L*W=A, L>=W, minimize L-W. Return [L,W].\n\nWe need step-by-step pseudo code lines with explanation. Use arrows, decisions, etc.\n\nWe will produce Start, step lines, decisions, loops. Approach: iterate from sqrt(A) down to 1 to find divisor W, then set L=A/W. Because we want minimal difference, start from sqrt downward ensures first divisor gives minimal difference.\n\nEdge case: perfect square.\n\nWe'll produce pseudocode accordingly.\n\nAlso must ensure each line: Virtual code step + space + // explanation.\n\nWe'll not produce actual code but pseudo steps. Use arrow \"→\". Use indentation with decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 targetArea ← 輸入的面積值 // 取得使用者提供的目標面積  \n→ Step 2: 計算 sqrtArea ← 整數向下取整(√targetArea) // 找到面積平方根的下限  \n→ Decision: 如果 sqrtArea * sqrtArea = targetArea? // 檢查是否為完全平方數  \n  Yes → Step 3a: 設定 L ← sqrtArea, W ← sqrtArea // 完全平方，長寬相等  \n  No  → Step 3b: 設定 divisor ← sqrtArea // 從平方根開始尋找因子  \n   → Loop:  While divisor >= 1  \n      Decision: 如果 targetArea % divisor = 0? // 判斷 divisor 是否為因子  \n        Yes → Step 4a: 設定 W ← divisor, L ← targetArea / divisor // 找到長寬  \n            → Break // 找到第一個因子即差距最小  \n        No  → Step 4b: 設定 divisor ← divisor - 1 // 將 divisor 減一繼續尋找  \n            → Continue  \n→ Step 5: 回傳 [L, W] // 回傳長與寬的陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\nimport re\n\nclass Solution:\n    def constructRectangle(self, area: int):\n        w = int(math.isqrt(area))  # 整數平方根\n        while area % w != 0:\n            w -= 1\n        return [area // w, w]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 從輸入中擷取第一個整數\n    match = re.search(r\"-?\\d+\", data)\n    if not match:\n        raise ValueError(\"未找到有效的面積值\")\n    area = int(match.group(0))\n\n    solution = Solution()\n    result = solution.constructRectangle(area)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "area = 4",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "area = 37",
          "expected_output": "[37,1]",
          "success": true,
          "output": "[37, 1]"
        },
        {
          "example_index": 2,
          "input": "area = 122122",
          "expected_output": "[427,286]",
          "success": true,
          "output": "[427, 286]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode383.json",
    "problem_index_in_file": 0,
    "title": "Ransom Note",
    "description_snippet": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, with \"虛擬碼步驟\" and comment. Use arrow symbols and structure. Each line: \"虛擬碼步驟 // 解釋\". Need to output in Traditional Chinese. Use Start, End, Decision: etc. We'll produce steps: Start; compute counts; iterate ransomNote; if letter missing return false; else decrement; after loop return true; End.\n\nWe need to show decision arrows, e.g., Decision: letter count >0? Yes → decrement; No → return false. Use Yes →, No →. Use arrows for steps: \"→ Step ...\". Let's produce lines.\n\nThe output should be like:\n\nStart // 程式開始\n→ Step 1: 初始化字母頻率表 counts 為空 // 建立一個映射字母->頻次\n→ Step 2: 對 magazine 中每個字母 c: 若 counts 中不存在 c 則設定為 1，否則遞增 counts[c] 1 // 計算每個字母在雜誌中的出現次數\n→ Decision: 遍歷 ransomNote 中每個字母 c? // 開始檢查是否能拼寫\n    Yes → Decision: counts[c] 是否大於 0? // 查看該字母是否還有剩餘可用\n        Yes → Step 3: 減少 counts[c] 1 // 使用該字母一次\n        No  → Step 4: 回傳 false // 無法使用，直接失敗\n    No  → Step 5: 回傳 true // 所有字母都已檢查完畢且足夠\nEnd // 程式結束\n\nBut we need each line as \"虛擬碼步驟 // 解釋\". Ensure each line with arrow. Also need to indent decision branches. We can use indentation spaces.\n\nLet's craft.\n\nWe need to ensure each line is separate; no code blocks. Let's output.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 建立字母頻率表 counts 為空映射 // 初始化雜誌中字母計數\n→ Step 2: 遍歷 magazine 的每個字母 c\n    → Decision: counts 中是否已有 c? // 判斷字母是否已記錄\n        Yes → counts[c] ← counts[c] + 1 // 既有則遞增\n        No  → counts[c] ← 1 // 新字母設為 1\n→ Step 3: 遍歷 ransomNote 的每個字母 c\n    → Decision: counts[c] 是否大於 0? // 檢查字母是否可用\n        Yes → counts[c] ← counts[c] - 1 // 使用一次\n        No  → Step 4: 回傳 false // 字母不足，結束\n→ Step 5: 回傳 true // 所有字母都可使用\nEnd // 程式結束\n\nNeed to ensure the format: each line \"虛擬碼步驟 // 解釋\". The decision lines must be separate lines with indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 建立字母頻率表 counts 為空映射 // 初始化雜誌中字母計數  \n→ Step 2: 遍歷 magazine 的每個字母 c  \n  Decision: counts 中是否已有 c? // 判斷字母是否已記錄  \n   Yes → counts[c] ← counts[c] + 1 // 既有則遞增  \n   No  → counts[c] ← 1 // 新字母設為 1  \n→ Step 3: 遍歷 ransomNote 的每個字母 c  \n  Decision: counts[c] 是否大於 0? // 檢查字母是否可用  \n   Yes → counts[c] ← counts[c] - 1 // 使用一次  \n   No  → Step 4: 回傳 false // 字母不足，結束  \n→ Step 5: 回傳 true // 所有字母都可使用  \nEnd // 程式結束",
      "generated_code": "import sys\nimport collections\nimport re\n\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        \"\"\"Return True if ransomNote can be formed from letters in magazine.\"\"\"\n        ransom_count = collections.Counter(ransomNote)\n        magazine_count = collections.Counter(magazine)\n\n        for char, need in ransom_count.items():\n            if need > magazine_count.get(char, 0):\n                return False\n        return True\n\ndef parse_input() -> tuple[str, str]:\n    \"\"\"Parse stdin to extract ransomNote and magazine strings.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return \"\", \"\"\n\n    # Try to find quoted strings first\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n\n    # If no quotes, split by whitespace or commas\n    parts = re.split(r',|\\s+', data)\n    parts = [p for p in parts if p]  # remove empty strings\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # Fallback: if only one token, treat as both strings identical\n    return parts[0] if parts else \"\", \"\"\n\nif __name__ == \"__main__\":\n    ransomNote, magazine = parse_input()\n    sol = Solution()\n    result = sol.canConstruct(ransomNote, magazine)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ransomNote = \"a\", magazine = \"b\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "ransomNote = \"aa\", magazine = \"ab\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode376.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Subsequence",
    "description_snippet": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for algorithm to compute longest wiggle subsequence length. Standard DP: up[i] length ending at i with last difference positive, down[i] with last negative. Or use O(n) greedy: count peaks/troughs. We'll produce step-by-step pseudo-code: Start, input array, handle edge cases, iterate, update up/down, final answer. Use arrow structure.\n\nLet's craft.\n\nWe'll produce steps like:\n\nStart\n→ Input nums // receive array\n→ Decision: If length <= 1? // trivial case\n    Yes → Output length // return\n    No → ...\nUse two variables up, down =1\n→ Loop i from 1 to n-1\n    → Decision: If nums[i] > nums[i-1]?\n        Yes → up = down + 1 // extend negative->positive\n        No →\n            Decision: If nums[i] < nums[i-1]?\n                Yes → down = up + 1\n                No → // equal, ignore\nEnd loop\n→ Output max(up, down) // longest wiggle length\n\nNeed to include explanation comments. Use arrows and decisions.\n\nMake sure to match format: each line \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe can also use nested decisions indent style. Provide appropriate indentation with tabs/spaces? Use indentation with spaces or tabs? In sample, they use spaces and indent with two spaces. We'll mimic.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得輸入的整數陣列  \n→ Decision: 如果 nums 的長度 <= 1? // 一個或零個元素自動是 Wiggle  \n Yes → Output nums.length // 回傳長度  \n No → // 進行長度計算  \n\n→ Set up = 1 // 以正差結束的 Wiggle 長度  \n→ Set down = 1 // 以負差結束的 Wiggle 長度  \n\n→ Loop i from 1 to nums.length - 1 // 遍歷陣列的每個相鄰對  \n  Decision: 如果 nums[i] > nums[i-1]? // 當前差為正  \n   Yes → up = down + 1 // 由負差延伸成正差  \n   No →  \n    Decision: 如果 nums[i] < nums[i-1]? // 當前差為負  \n     Yes → down = up + 1 // 由正差延伸成負差  \n     No → // 差為零，忽略不變  \n\n→ Output max(up, down) // 兩種結尾情形的最大值即為答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef wiggle_max_length(nums):\n    if not nums:\n        return 0\n    up = down = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 找到第一個 '['，取其後面作為列表字串\n    start = data.find('[')\n    list_str = data[start:] if start != -1 else data\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        nums = []\n    result = wiggle_max_length(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,4,9,2,5]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,17,5,10,13,15,10,5,16,8]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4,5,6,7,8,9]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1249.json",
    "problem_index_in_file": 0,
    "title": "Minimum Remove to Make Valid Parentheses",
    "description_snippet": "Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: Given string s, remove min parentheses to make valid. Classic solution: first pass to remove invalid ')', second pass to remove invalid '(' from end.\n\nAlternatively stack indices. Provide steps. Each line with virtual code and comment. Use Start, Decision, End.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize empty result list\n→ Step 2: Initialize stack for indices of '('\n→ Decision: iterate over characters with index i\n    Yes → Step 3: If char == '('\n        Yes → Step 4: push i onto stack\n    No → Step 5: If char == ')'\n        Yes → Step 6: If stack not empty\n            Yes → Step 7: pop from stack (matched '(')\n            No  → Step 8: mark index i for removal (unmatched ')')\n    No → Step 9: If char is lowercase, continue\n→ Decision: after loop, remaining indices in stack are unmatched '('\n    Yes → Step 10: mark each index in stack for removal\n→ Step 11: Build new string from s excluding marked indices\nEnd\n\nBut need each line with virtual code and comment. Use arrows for decision and branches.\n\nLet's structure with indentation for Decision: and Yes/No. Provide comments.\n\nUse \"→\" before each step. For decisions, we write \"→ Decision: ...\". Then indented lines under with \"Yes →\" and \"No →\".\n\nWe need to include each step line. Let's produce.\n\nMake sure to show removal markers: maybe use a boolean array or set. Use \"→ Step 8: Add i to remove set // mark ')' for removal\" etc.\n\nOk produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空串 // 用於儲存最終結果\n→ Step 2: 初始化 stack 為空堆疊 // 用於記錄 '(' 的索引\n→ Step 3: 初始化 removeSet 為空集合 // 用於標記需要刪除的括號索引\n→ Decision: 對於 s 的每個字符 c 與其索引 i 進行迭代\n    Yes → Step 4: 如果 c 為 '('\n        Yes → Step 5: 把 i 推入 stack // 以待匹配\n    No  → Step 6: 如果 c 為 ')'\n        Yes → Decision: 若 stack 非空\n            Yes → Step 7: 從 stack 彈出一個索引 // 成功配對\n            No  → Step 8: 把 i 加入 removeSet // 無法配對，標記刪除\n    No  → Step 9: 如果 c 為小寫字母\n        Yes → Step 10: 繼續 // 直接忽略，因為字母不影響合法性\n→ Decision: 迴圈結束後 stack 是否還有剩餘索引\n    Yes → Step 11: 對於 stack 中的每個索引 j\n        Yes → Step 12: 把 j 加入 removeSet // 未配對的 '(' 刪除\n    No  → Step 13: // 無剩餘 '('，跳過\n→ Step 14: 建構 finalStr 為空串\n→ Decision: 對於 s 的每個字符 c 與其索引 i 進行迭代\n    Yes → Step 15: 如果 i 不在 removeSet\n        Yes → Step 16: 將 c 加入 finalStr // 保留合法字符\n    No  → Step 17: // i 在 removeSet，跳過\n→ Step 18: 回傳 finalStr // 最終合法字符串\nEnd // 程式執行結束\n```\n\n此虛擬碼示範了先利用堆疊去配對左括號，將無法配對的右括號標記；再將剩餘未配對的左括號也標記；最後組合未被標記的字符即得到最小刪除後的合法括號字串。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \"\"\"移除最少括號使字串合法\"\"\"\n        s_list = list(s)\n        stack = []\n\n        # 第一次遍歷：匹配右括號，未匹配的右括號直接清空\n        for i, c in enumerate(s_list):\n            if c == '(':\n                stack.append(i)          # 記錄左括號索引\n            elif c == ')':\n                if stack:\n                    stack.pop()        # 成功配對\n                else:\n                    s_list[i] = ''     # 無法配對的右括號剔除\n\n        # 第二次遍歷：剩餘未匹配的左括號剔除\n        for i in stack:\n            s_list[i] = ''\n\n        return ''.join(s_list)\n\ndef extract_string(input_text: str) -> str:\n    \"\"\"\n    從輸入文字中提取第一個被雙引號包圍的字串。\n    若找不到雙引號，則直接返回整個輸入（去除前後空白）。\n    \"\"\"\n    match = re.search(r'\"([^\"]*)\"', input_text)\n    if match:\n        return match.group(1)\n    return input_text.strip()\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 從輸入中提取字串\n    s = extract_string(raw_input)\n    # 產生答案\n    result = Solution().minRemoveToMakeValid(s)\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"lee(t(c)o)de)\"",
          "expected_output": "\"lee(t(c)o)de\"",
          "success": true,
          "output": "lee(t(c)o)de"
        },
        {
          "example_index": 1,
          "input": "s = \"a)b(c)d\"",
          "expected_output": "\"ab(c)d\"",
          "success": true,
          "output": "ab(c)d"
        },
        {
          "example_index": 2,
          "input": "s = \"))((\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode239.json",
    "problem_index_in_file": 0,
    "title": "Sliding Window Maximum",
    "description_snippet": "You are given an array of integers nums, there is a sliding window of size k which is moving from th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm to compute sliding window maximum. Use deque or similar. Provide line by line with explanation. Should follow output format: each line with \"虛擬碼步驟 // 解釋\". Use arrow characters. Let's craft a flow:\n\nStart\n→ Step 1: 初始化空雙端佇列 Q // 用於儲存索引\n→ Step 2: 初始化結果陣列 res = []\n→ Step 3: 從 i = 0 到 i < nums.length\n    → Decision: i >= k - 1? // 是否已形成完整窗口\n        Yes → Step 4: res.append(nums[Q.front()]) // 將當前窗口最大值加入結果\n    → Step 5: 去除 Q 中索引小於 i-k+1 的元素 // 讓佇列只包含當前窗口\n    → Step 6: 去除 Q 中索引對應值小於 nums[i] 的元素 // 以維持降序\n    → Step 7: Q.append(i) // 加入當前索引\nEnd\n\nNeed to include arrow indentations.\n\nWe should also maybe add Step 1: Check if k==0 return empty. But maybe not needed.\n\nFollow requirement of using \"Decision:\" and \"Yes →\", \"No →\". For loops we can express as Step.\n\nWe can produce a pseudo code structure.\n\nLet's produce each line.\n\nAlso mention if k == 1 case trivial.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 若 k == 0 則回傳空陣列 // 處理特殊情況\n→ Decision: k == 0? // 判斷 k 是否為 0\n    Yes → End // 程式結束\n    No  → Step 2: 初始化空雙端佇列 Q // 用於存放可能為最大值的索引，保持值的降序\n→ Step 3: 初始化結果陣列 res = [] // 儲存每個滑動窗口的最大值\n→ Step 4: 從 i = 0 到 i < nums.length 執行以下步驟 // 遍歷整個陣列\n    → Decision: i >= k - 1? // 判斷已形成完整窗口\n        Yes → Step 5: res.append(nums[Q.front()]) // 取出佇列前端的索引對應值作為窗口最大值\n        No  → // 尚未形成窗口，無需加入結果\n    → Step 6: 若 Q.front() <= i - k 则 Q.popleft() // 移除已離開窗口的索引\n    → Step 7: 當 Q 不是空且 nums[Q.back()] < nums[i] 時，執行 Q.pop() // 移除小於當前元素的索引，保持降序\n        → Decision: Q 非空 且 nums[Q.back()] < nums[i]? // 判斷是否需要移除\n            Yes → Step 8: Q.pop() // 移除尾端索引\n            No  → // 不需要移除\n    → Step 9: Q.append(i) // 把當前索引加入佇列\nEnd // 程式執行結束，返回結果 res (此處省略實際返回語句)",
      "generated_code": "import sys\nfrom collections import deque\n\ndef max_sliding_window(nums, k):\n    \"\"\"Return list of maximums in each sliding window of size k.\"\"\"\n    if not nums or k == 0:\n        return []\n\n    deq = deque()  # stores indices of useful elements in current window\n    res = []\n\n    for i, num in enumerate(nums):\n        # Remove indices that are out of the current window\n        while deq and deq[0] < i - k + 1:\n            deq.popleft()\n\n        # Remove indices whose corresponding values are smaller than current value\n        while deq and nums[deq[-1]] < num:\n            deq.pop()\n\n        deq.append(i)\n\n        # Starting from the first complete window, append the maximum\n        if i >= k - 1:\n            res.append(nums[deq[0]])\n\n    return res\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Execute the input string in a clean namespace to extract nums and k\n    local_vars = {}\n    try:\n        exec(data, {}, local_vars)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    nums = local_vars.get('nums')\n    k = local_vars.get('k')\n\n    if nums is None or k is None:\n        print(\"Input must contain 'nums' and 'k' variables.\", file=sys.stderr)\n        sys.exit(1)\n\n    # Compute and print the result\n    result = max_sliding_window(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "success": false,
          "output": "Error parsing input: invalid syntax. Maybe you meant '==' or ':=' instead of '='? (<string>, line 1)"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": false,
          "output": "Error parsing input: invalid syntax. Maybe you meant '==' or ':=' instead of '='? (<string>, line 1)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode628.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Three Numbers",
    "description_snippet": "Given an integer array nums, find three numbers whose product is maximum and return the maximum prod...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to find maximum product of three numbers in array. Use logic: sort array; consider max product of top three or product of two smallest (most negative) and largest positive. So steps: input array, sort ascending, compute candidate1 = a[n-1]*a[n-2]*a[n-3], candidate2 = a[0]*a[1]*a[n-1], max = max(candidate1,candidate2). Output max. Provide steps line by line with explanation. Also include Start, End. Use Decision etc. Should be step by step. Use \"Start\", \"End\". Include arrows. Provide virtual code. Ensure no actual code. Provide each line: e.g., \"Start // 程式開始執行\". Then \"→ Step 1: 輸入數組 nums // 取得輸入數組\". etc. Use Decision to check array length maybe >2. Provide decision. So produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 取得輸入的數組  \n→ Decision: nums 的長度是否大於等於 3? // 確認足夠數量進行三數乘積  \n  Yes → Step 2: 將 nums 以升序排序 // 方便後續取最大/最小值  \n  No  → Step 3: 輸出錯誤訊息 '輸入長度不足' // 不能計算三數乘積  \n    → End // 結束程式  \n→ Step 4: 取得最大值 aMax1 = nums[-1] // 最大數  \n→ Step 5: 取得第二大值 aMax2 = nums[-2] // 第二大數  \n→ Step 6: 取得第三大值 aMax3 = nums[-3] // 第三大數  \n→ Step 7: 取得最小值 aMin1 = nums[0] // 最小數  \n→ Step 8: 取得第二小值 aMin2 = nums[1] // 第二小數  \n→ Step 9: 計算候選乘積1 = aMax1 * aMax2 * aMax3 // 可能的最大乘積  \n→ Step 10: 計算候選乘積2 = aMin1 * aMin2 * aMax1 // 兩個負數與最大正數組合  \n→ Decision: 候選乘積1 大於 候選乘積2? // 比較兩種組合  \n  Yes → Step 11: 設定 maxProduct = 候選乘積1 // 選擇較大者  \n  No  → Step 12: 設定 maxProduct = 候選乘積2 // 選擇較大者  \n→ Step 13: 輸出 maxProduct // 回傳最終最大乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maximumProduct(self, nums):\n        # 將數組從小到大排序\n        nums.sort()\n        # 兩種可能的最大乘積\n        prod1 = nums[-1] * nums[-2] * nums[-3]     # 最高三個正數\n        prod2 = nums[0] * nums[1] * nums[-1]       # 兩個最小（可能為負）與最大正數\n        return max(prod1, prod2)\n\ndef parse_input(input_str: str):\n    \"\"\"\n    解析形如 'nums = [1, 2, -3]' 的輸入字串，回傳對應的列表。\n    \"\"\"\n    input_str = input_str.strip()\n    if input_str.startswith(\"nums\"):\n        # 找到等號右邊的部分\n        _, list_part = input_str.split(\"=\", 1)\n        list_part = list_part.strip()\n        # 使用 ast.literal_eval 來安全解析列表\n        return ast.literal_eval(list_part)\n    else:\n        # 若輸入直接是列表字串\n        return ast.literal_eval(input_str)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    sol = Solution()\n    result = sol.maximumProduct(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "24",
          "success": true,
          "output": "24"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-2,-3]",
          "expected_output": "-6",
          "success": true,
          "output": "-6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode68.json",
    "problem_index_in_file": 0,
    "title": "Text Justification",
    "description_snippet": "Given an array of strings words and a width maxWidth, format the text such that each line has exactl...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code lines with comments. Provide algorithm for full justify. Use Start, Decision, Steps. Use arrows.\n\nWe must produce each line with \"虛擬碼步驟 // 解釋\". We need to include arrows: →, Yes →, No →. The code steps are descriptive.\n\nLet's outline steps: Start, Initialize result list, index=0, n=words length.\n\nLoop while index < n:\n  start = index\n  sumLen = 0\n  while index < n and sumLen + len(words[index]) + (index-start) <= maxWidth:\n    sumLen += len(words[index])\n    index += 1\n  # words from start to index-1\n  lineWords = words[start:index]\n  numberWords = index - start\n  isLastLine = (index == n)\n  if isLastLine or numberWords == 1:\n    line = join words with single space then pad spaces to right\n  else:\n    totalSpaces = maxWidth - sumLen\n    spaceBetween = totalSpaces // (numberWords-1)\n    extraSpaces = totalSpaces % (numberWords-1)\n    line = \"\"\n    for i in range(numberWords-1):\n       line += lineWords[i] + ' ' * (spaceBetween + (1 if i < extraSpaces else 0))\n    line += lineWords[-1]\n  append line to result\n\nAfter loop, return result.\n\nWe'll represent each of these as virtual code steps.\n\nWe need to produce each step with explanatory comment. Let's produce.\n\nWe'll use indentation? Just lines with arrow.\n\nLet's write:\n\nStart // 開始\n→ Step 1: Initialize result list, index = 0, n = words length // 設定初始參數\n→ Decision: index < n? // 判斷是否還有未處理的單詞\n    Yes → Step 2: start = index, sumLen = 0 // 開始新一行\n    → Step 3: Decision: index < n AND sumLen + len(words[index]) + (index-start) <= maxWidth? // 判斷是否可以放進下一個單詞\n        Yes → Step 4: sumLen += len(words[index]) // 加入單詞長度\n        → Step 5: index += 1 // 移動到下一個單詞\n        → Decision: index < n AND sumLen + len(words[index]) + (index-start) <= maxWidth? // 重複直到不符合\n            Yes → ... (loop back)\n            No  → Step 6: numberWords = index - start // 計算行內單詞數\n            → Step 7: isLastLine = (index == n) // 判斷是否為最後一行\n            → Decision: isLastLine OR numberWords == 1? // 特殊情況\n                Yes → Step 8: line = join(lineWords, ' ') // 左對齊\n                → Step 9: line = line + ' ' * (maxWidth - len(line)) // 右填充空格\n                No  → Step 10: totalSpaces = maxWidth - sumLen // 計算總空格數\n                → Step 11: spaceBetween = totalSpaces // (numberWords - 1) // 每兩個單詞之間最少空格\n                → Step 12: extraSpaces = totalSpaces % (numberWords - 1) // 多餘空格數\n                → Step 13: line = \"\" // 初始化行字串\n                → Decision: i from 0 to numberWords-2? // 逐個單詞添加空格\n                    Yes → Step 14: line += lineWords[i] // 加入單詞\n                    → Step 15: spacesToAdd = spaceBetween + (1 if i < extraSpaces else 0) // 確定空格數\n                    → Step 16: line += ' ' * spacesToAdd // 加入空格\n                    → Decision: i < numberWords-2? // 是否還有下一個空格槽\n                        Yes → ... (loop)\n                        No  → Step 17: line += lineWords[numberWords-1] // 加入最後一個單詞\n                → Step 18: Append line to result // 將行加入結果\n                → Step 19: Return result // 完成\nEnd // 程式結束\n\nNeed to ensure each line ends with comment. Provide all lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize result list, index = 0, n = words length // 設定初始參數  \n→ Decision: index < n? // 判斷是否還有未處理的單詞  \n    Yes → Step 2: start = index, sumLen = 0 // 開始新一行的計算  \n    → Step 3: Decision: index < n AND sumLen + len(words[index]) + (index - start) <= maxWidth? // 判斷是否可以把下一個單詞放進當前行  \n        Yes → Step 4: sumLen += len(words[index]) // 加入單詞長度  \n        → Step 5: index += 1 // 移動到下一個單詞  \n        → Decision: index < n AND sumLen + len(words[index]) + (index - start) <= maxWidth? // 重新檢查是否還能再放  \n            Yes → … // 仍在同一行，重複 Step 3–5  \n            No  → Step 6: numberWords = index - start // 計算此行的單詞數  \n            → Step 7: isLastLine = (index == n) // 判斷是否為最後一行  \n            → Decision: isLastLine OR numberWords == 1? // 特殊情況：最後一行或單個單詞  \n                Yes → Step 8: line = join(lineWords, ' ') // 用單個空格連接所有單詞  \n                → Step 9: line = line + ' ' * (maxWidth - len(line)) // 右邊填充空格，使行長正好為 maxWidth  \n                No  → Step 10: totalSpaces = maxWidth - sumLen // 計算整行需要的空格總數  \n                → Step 11: spaceBetween = totalSpaces // (numberWords - 1) // 每兩個單詞之間最少空格數  \n                → Step 12: extraSpaces = totalSpaces % (numberWords - 1) // 多餘空格需要分配給左側空格槽  \n                → Step 13: line = \"\" // 初始化行字串  \n                → Decision: i from 0 to numberWords-2? // 逐個單詞處理空格槽  \n                    Yes → Step 14: line += lineWords[i] // 加入單詞  \n                    → Step 15: spacesToAdd = spaceBetween + (1 if i < extraSpaces else 0) // 這個槽要加多少空格  \n                    → Step 16: line += ' ' * spacesToAdd // 加入空格  \n                    → Decision: i < numberWords-2? // 是否還有下一個空格槽  \n                        Yes → … // 繼續處理下一個槽  \n                        No  → Step 17: line += lineWords[numberWords-1] // 加入最後一個單詞  \n                → Step 18: Append line to result // 將已組裝好的行加入結果列表  \n                → Step 19: Return result // 程式結束，返回完整格式化文本  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\nimport ast\nimport json\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # determine how many words can fit in the line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            # build the line\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(word) for word in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # left-justify for last line or single word\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                # fully justify\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k] + ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses the input format:\n        words = [...], maxWidth = ...\n    \"\"\"\n    pattern = r'words\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*maxWidth\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        return [], 0\n    words_str = match.group(1)\n    max_width = int(match.group(2))\n    words = ast.literal_eval(words_str)\n    return words, max_width\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    words, max_width = parse_input(raw)\n    solution = Solution()\n    result = solution.fullJustify(words, max_width)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "success": true,
          "output": "[\"This    is    an\", \"example  of text\", \"justification.  \"]"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "success": true,
          "output": "[\"What   must   be\", \"acknowledgment  \", \"shall be        \"]"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "success": true,
          "output": "[\"Science  is  what we\", \"understand      well\", \"enough to explain to\", \"a  computer.  Art is\", \"everything  else  we\", \"do                  \"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode38.json",
    "problem_index_in_file": 0,
    "title": "Count and Say",
    "description_snippet": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step for the count-and-say algorithm, with explanations. Not actual code. Use structure. Should output in lines, each line with virtual code step and comment. Use arrow and decision. Let's produce.\n\nWe need steps: Start, Step 1: initialize result = \"1\" if n==1 else loop from 2 to n generating next term using run-length encoding. Inside loop: set current = result, result=\"\"? Actually algorithm: nextTerm = \"\", count =1, iterate over current string's chars, if same as next char, increment count else append count and char, reset count, continue. After loop, append last run. Continue. Finally, output result.\n\nWe'll produce lines. Use indentation with arrow? The example shows indentation for decision branches.\n\nWe should use steps with Step numbers or description. Provide explanation after //.\n\nLet's produce something like:\n\nStart // 開始\n→ Step 1: Set n_input = n // 取得輸入 n\n→ Decision: If n_input == 1? // 檢查是否只需要第一項\n    Yes → Step 2: Return \"1\" // 直接回傳第一項\n    No  → Step 3: Initialize current = \"1\" // 從第一項開始\n→ Step 4: For i from 2 to n_input: // 迭代生成第 i 項\n    → Step 5: Initialize next = \"\" // 儲存下一項\n    → Step 6: Initialize count = 1 // 目前連續相同字元的計數\n    → Step 7: For j from 1 to length(current)-1: // 逐字元比較\n        → Decision: If current[j] == current[j+1]? // 檢查相鄰是否相同\n            Yes → Step 8: Increment count // 同字元則計數+1\n            No  → Step 9: Append count + current[j] to next // 不同則寫入 RLE\n                  → Step 10: Set count = 1 // 重置計數\n    → Step 11: Append count + current[last] to next // 處理最後一段\n    → Step 12: Set current = next // 用新字串做下一輪\n→ Step 13: Return current // 回傳第 n 項\nEnd // 結束\n\nWe need to include arrow for Decision branches. In example they indent with \"Yes →\", \"No →\". We'll replicate. Also indentation inside loops? Use indentation to indicate nested steps. Let's produce.\n\nAlso include comments in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set n_input = n // 取得使用者輸入的正整數 n  \n→ Decision: n_input == 1? // 檢查是否只需要第一項  \n  Yes → Step 2: Return \"1\" // 若 n 為 1，直接回傳第一項  \n  No  → Step 3: Initialize current = \"1\" // 從第一項開始，作為基礎字串  \n→ Step 4: For i from 2 to n_input: // 逐步產生第 i 項，直到第 n 項  \n  → Step 5: Initialize next = \"\" // 用於存放第 i 項的結果  \n  → Step 6: Initialize count = 1 // 目前相同字元的連續數量  \n  → Step 7: For j from 1 to length(current)-1: // 從第二個字元開始遍歷  \n    → Decision: current[j] == current[j+1]? // 判斷相鄰字元是否相同  \n      Yes → Step 8: Increment count // 相同則累計數量  \n      No  → Step 9: Append count + current[j] to next // 不同則寫入 RLE  \n        → Step 10: Set count = 1 // 重置計數，準備處理下一段  \n  → Step 11: Append count + current[last] to next // 處理最後一段的字元與計數  \n  → Step 12: Set current = next // 更新 current 為新產生的字串，進入下一迴圈  \n→ Step 13: Return current // 迴圈結束後，current 即為第 n 項  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_and_say(n: int) -> str:\n    \"\"\"Return the n-th term of the count-and-say sequence.\"\"\"\n    if n <= 0:\n        return \"\"\n    current = \"1\"\n    for _ in range(1, n):\n        next_seq = []\n        count = 1\n        for i in range(1, len(current)):\n            if current[i] == current[i - 1]:\n                count += 1\n            else:\n                next_seq.append(str(count))\n                next_seq.append(current[i - 1])\n                count = 1\n        # Append the last run\n        next_seq.append(str(count))\n        next_seq.append(current[-1])\n        current = \"\".join(next_seq)\n    return current\n\ndef main() -> None:\n    \"\"\"Read input, compute count-and-say, and print the result with quotes.\"\"\"\n    data = sys.stdin.read().strip()\n    # Extract the first integer found in the input\n    match = re.search(r\"-?\\d+\", data)\n    if not match:\n        print('\"\"')\n        return\n    n = int(match.group(0))\n    result = count_and_say(n)\n    # Output the result surrounded by double quotes\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "\"1211\"",
          "success": true,
          "output": "\"1211\""
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "\"1\"",
          "success": true,
          "output": "\"1\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode287.json",
    "problem_index_in_file": 0,
    "title": "Find the Duplicate Number",
    "description_snippet": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. We must adhere to the format. The problem: find duplicate in array without modifying and using constant space. Classic Floyd's Tortoise and Hare (cycle detection). Steps:\n\n1. Start\n2. Initialize slow and fast pointers to first element\n3. Move slow = nums[slow], fast = nums[nums[fast]] until they meet\n4. Find entry: set ptr1 = first element, ptr2 = meeting point\n5. Move both one step until they meet; that value is duplicate\n6. Return duplicate\n7. End\n\nWe need each line with `→` etc. Use decision only if needed. The algorithm doesn't need decisions beyond loop condition.\n\nBut need to show loop? Use Decision: while slow != fast? Use arrow.\n\nSo lines:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 初始化慢指針為第一個元素\n→ Step 2: fast ← nums[0] // 初始化快指針為第一個元素\n→ Decision: slow ≠ fast? // 判斷慢快指針是否相遇\n    Yes → Step 3: slow ← nums[slow] // 慢指針移動一步\n    Yes → Step 4: fast ← nums[nums[fast]] // 快指針移動兩步\n    No  → Step 5: entry ← nums[0] // 設置入口指針\n    No  → Step 6: ptr2 ← slow // 第二個指針指向相遇點\n    No  → Decision: entry ≠ ptr2? // 判斷兩指針是否相遇\n        Yes → Step 7: entry ← nums[entry] // 入口指針移動一步\n        Yes → Step 8: ptr2 ← nums[ptr2] // 第二指針移動一步\n        No  → Step 9: duplicate ← entry // 找到重複數字\n        No  → Step 10: return duplicate // 返回結果\nEnd // 程式執行結束\n\nBut need to be careful about loops and decisions. We might need nested decisions.\n\nHowever, the formatting uses indentation to show nested decisions. For each decision we can use Yes → and No → lines inside. The steps 5-6 after the loop might need to be inside No block of first decision. Then second decision inside.\n\nBut the pseudocode lines may not have correct indentation. We can use indentation with spaces. The example shows indentation for nested steps. Use 4 spaces indentation per level.\n\nLet's design:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 初始化慢指針\n→ Step 2: fast ← nums[0] // 初始化快指針\n→ Decision: slow ≠ fast? // 判斷是否相遇\n    Yes → Step 3: slow ← nums[slow] // 慢指針移動一步\n    Yes → Step 4: fast ← nums[nums[fast]] // 快指針移動兩步\n    No  → Step 5: ptr1 ← nums[0] // 第一個指針指向頭\n    No  → Step 6: ptr2 ← slow // 第二個指針指向相遇點\n    No  → Decision: ptr1 ≠ ptr2? // 判斷是否相遇\n        Yes → Step 7: ptr1 ← nums[ptr1] // ptr1 移動一步\n        Yes → Step 8: ptr2 ← nums[ptr2] // ptr2 移動一步\n        No  → Step 9: duplicate ← ptr1 // 找到重複數字\n        No  → Step 10: return duplicate // 返回結果\nEnd // 程式執行結束\n\nBut we should include \"End\" after return? Actually after return we end. We can just place End after return.\n\nWe need to make sure each line ends with //.\n\nOk. Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始化慢指針指向第一個元素  \n→ Step 2: fast ← nums[0] // 初始化快指針指向第一個元素  \n→ Decision: slow ≠ fast? // 判斷慢快指針是否已相遇  \n Yes → Step 3: slow ← nums[slow] // 慢指針移動一步  \n Yes → Step 4: fast ← nums[nums[fast]] // 快指針移動兩步  \n No  → Step 5: ptr1 ← nums[0] // 第一個指針從頭開始  \n No  → Step 6: ptr2 ← slow // 第二個指針從相遇點開始  \n No  → Decision: ptr1 ≠ ptr2? // 判斷兩指針是否相遇  \n  Yes → Step 7: ptr1 ← nums[ptr1] // ptr1 移動一步  \n  Yes → Step 8: ptr2 ← nums[ptr2] // ptr2 移動一步  \n  No  → Step 9: duplicate ← ptr1 // 找到重複數字  \n  No  → Step 10: return duplicate // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        slow = fast = nums[0]\n\n        # 第一階段: 找到相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        # 第二階段: 找到入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    data = sys.stdin.read().strip()\n\n    # 處理輸入，支援「nums = [1,2,3,3]」或僅提供陣列\n    if \"=\" in data:\n        _, arr_str = data.split(\"=\", 1)\n    else:\n        arr_str = data\n    arr_str = arr_str.strip()\n    # 使用 literal_eval 以避免 eval 的安全風險\n    nums = ast.literal_eval(arr_str)\n\n    solution = Solution()\n    duplicate = solution.findDuplicate(nums)\n    print(duplicate)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,4,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3,3,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode714.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Transaction Fee",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for maximum profit with transaction fee, using DP or greedy. We'll present virtual code line by line, each with explanation. Format: \"虛擬碼步驟 // 解釋\".\n\nWe must not output actual code. Just steps. Use Start, End, Decision, etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize 變數 hold = -prices[0] - fee  // 代表持有股票時的成本（含手續費）  \n→ Initialize 變數 cash = 0  // 代表不持股時的現金  \n→ 迴圈 i 從 1 到 prices.length - 1  // 逐日處理價格  \n  → Decision: 如果 prices[i] + cash > hold? // 判斷賣出是否更利潤  \n    Yes → hold = cash - prices[i] - fee  // 賣出後再次買入，更新持股成本  \n    No  → Decision: 如果 prices[i] - hold > cash? // 判斷買入是否更利潤  \n      Yes → cash = hold + prices[i]  // 買入並更新現金  \n      No →  // 無需變更，保持現有狀態  \n  → // 以上決策保證每一步都在做最優選擇  \n→ End // 程式執行結束，cash 即為最大利潤",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef maxProfit(prices, fee):\n    if not prices:\n        return 0\n    # hold: maximum profit when holding a stock\n    # cash: maximum profit when not holding a stock\n    hold = -prices[0] - fee\n    cash = 0\n    for price in prices[1:]:\n        # If we sell today, we add the price to the profit we had while holding\n        cash = max(cash, hold + price)\n        # If we buy today, we subtract the price and the fee from the profit we had while not holding\n        hold = max(hold, cash - price - fee)\n    return cash\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form 'prices = [1,2,3], fee = 2'.\"\"\"\n    prices_match = re.search(r'prices\\s*=\\s*(\\[[^\\]]*\\])', data)\n    fee_match = re.search(r'fee\\s*=\\s*(-?\\d+)', data)\n    if not prices_match or not fee_match:\n        raise ValueError(\"Input format is incorrect.\")\n    prices = ast.literal_eval(prices_match.group(1))\n    fee = int(fee_match.group(1))\n    return prices, fee\n\ndef main():\n    data = sys.stdin.read()\n    prices, fee = parse_input(data)\n    result = maxProfit(prices, fee)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,3,2,8,4,9], fee = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "prices = [1,3,7,5,10,3], fee = 3",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode406.json",
    "problem_index_in_file": 0,
    "title": "Queue Reconstruction by Height",
    "description_snippet": "You are given an array of people, people, which are the attributes of some people in a queue (not ne...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the queue reconstruction problem. Use typical algorithm: sort by height descending, k ascending. Then insert into result at index k. We'll output virtual code lines.\n\nNeed to start with Start, End, Decision, etc. Each line with \"→\" arrow. Provide explanation. Use virtual code.\n\nLet's craft steps:\n\nStart\n→ Step 1: Input people array // get array\n→ Step 2: Sort people by descending height, ascending k // sorting key\n→ Step 3: Initialize empty queue // result list\n→ Decision: For each person in sorted list? // loop\n    Yes → Step 4: Insert person at index person.k in queue // insertion\n    No  → ...\n→ Step 5: Return queue // output\nEnd\n\nBut need line-by-line with arrow and explanation.\n\nWe might need to handle loop via Decision: \"While i < n\" style. Use Decision for iteration. Provide steps inside loop.\n\nLet's produce:\n\nStart // start program\n→ Step 1: Input people // receive array\n→ Step 2: Sort people by (-height, k) // descending height, ascending k\n→ Step 3: Initialize empty result // queue\n→ Decision: i < n? // loop condition\n    Yes → Step 4: person ← people[i] // get next person\n    → Step 5: Insert person at index person.k in result // place person\n    → Step 6: i ← i + 1 // move to next\n    No  → Step 7: Output result // finish\nEnd // end program\n\nEnsure each line has explanation. Use arrow \"→\" before each step. Use Decision block with Yes/No. Provide proper indentation maybe with tabs? but keep simple.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input people // 取得輸入的 people 陣列\n→ Step 2: Sort people by (-height, k) // 先按身高降序，再按 k 升序排序\n→ Step 3: Initialize empty result // 建立一個空的結果陣列 queue\n→ Decision: i < n? // 迴圈條件，若仍有未處理的人\n    Yes → Step 4: person ← people[i] // 取出排序後的第 i 位人\n    → Step 5: Insert person at index person.k in result // 在結果陣列中依 k 位置插入\n    → Step 6: i ← i + 1 // 移動到下一個人\n    No  → Step 7: Output result // 迴圈結束，輸出重建好的 queue\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef reconstructQueue(people):\n    \"\"\"\n    根據高度遞減、k 升序排序後，依照 k 的位置插入即可重建隊列。\n    \"\"\"\n    people.sort(key=lambda x: (-x[0], x[1]))\n    res = []\n    for p in people:\n        res.insert(p[1], p)\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中抽取代表 people 的列表\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        list_str = data[start:end+1]\n        people = ast.literal_eval(list_str)\n    except Exception:\n        # 若輸入本身就是一個可直接 eval 的列表\n        people = ast.literal_eval(data)\n\n    result = reconstructQueue(people)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
          "expected_output": "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]",
          "success": true,
          "output": "[[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]"
        },
        {
          "example_index": 1,
          "input": "people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]",
          "expected_output": "[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]",
          "success": true,
          "output": "[[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode381.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "description_snippet": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: maintain vector/list of values; maintain dict mapping value to set of indices positions. For insert: append to list, add index to set, return true if first time. For remove: if val not present return false. Else get an arbitrary index from set; find last element in list; swap removal: replace index with last element, update its set. Remove last element from list, remove index from val's set. If after removal set empty, delete entry. For getRandom: random index in list, return element.\n\nWe need to produce step-by-step pseudo-code with arrows, decisions, etc. Provide each step with explanation. Not actual code. Use Chinese simplified? Actually use Traditional Chinese. Use lines like:\n\nStart // 程式開始\n\n→ Step 1: 初始化 empty list L // 代表元素集合\n\n→ Step 2: 初始化空映射 M: val → set(indices) // 追蹤各值所在的位置\n\nThen insert method:\n\nStart insert(val) // 開始插入\n\n→ Step 1: 若 val 在 M 中? // 檢查是否已存在\n\n… etc.\n\nNeed to produce all methods: constructor, insert, remove, getRandom. Show decision branching.\n\nAlso show average O(1) explanation maybe. Provide in virtual code lines.\n\nWe'll produce something like:\n\nStart // 程式開始\n\n→ Step 1: 建立 vector L = [] // 儲存所有元素\n\n→ Step 2: 建立 map M = {} // val → set of indices\n\nEnd // 完成初始化\n\nThen method insert:\n\n→ Step 1: Append val to L // 新元素加入末尾\n\n→ Step 2: idx = length(L)-1 // 取得新元素索引\n\n→ Step 3: 若 M.contains(val) ? // 判斷 val 是否已存在\n\n    Yes → M[val].add(idx) // 加入索引\n\n    No  → M[val] = {idx} // 創建新集合\n\n→ Step 4: Return (M[val].size == 1) // 若此時集合只有一個，表示第一次插入\n\nBut return logic: true if item not present before, false otherwise. So we need to know before insertion if val existed. So we can capture existFlag before. Use flag = M.contains(val). After insertion, return !flag.\n\nBetter:\n\n→ Step 1: flag = M.contains(val) // 是否已存在\n\n→ Step 2: Append val to L\n\n→ Step 3: idx = L.size-1\n\n→ Step 4: M[val].add(idx) // create if not exist\n\n→ Step 5: Return !flag\n\nRemove:\n\n→ Step 1: 若 !M.contains(val) return false // 不存在\n\n→ Step 2: 取任意 idx from M[val] // 隨機取得一個索引\n\n→ Step 3: 取 lastIdx = L.size-1\n\n→ Step 4: lastVal = L[lastIdx]\n\n→ Step 5: L[idx] = lastVal // 覆蓋被刪除位置\n\n→ Step 6: 更新 M[lastVal]: remove lastIdx, add idx\n\n→ Step 7: Remove idx from M[val]\n\n→ Step 8: L.pop() // 刪除最後一個\n\n→ Step 9: 若 M[val] 空則 delete M[val] // 清空\n\n→ Step 10: Return true\n\nGetRandom:\n\n→ Step 1: randIdx = random(0, L.size-1)\n\n→ Step 2: Return L[randIdx]\n\nNeed to show decision for random.\n\nAlso mention probability property due to uniform random over indices.\n\nWe also need to show the complexity: each operation O(1) average.\n\nWe need to follow output format: each line with \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe need to show \"Start\" etc.\n\nLet's produce.\n\nWe need to list steps for class definition? We'll treat each method separately.\n\nWe might have:\n\nStart // 程式開始\n\n→ Step 1: 建立空列表 Elements = [] // 存放所有元素\n\n→ Step 2: 建立空映射 IndexMap = {} // val → set(indices)\n\nEnd // 初始化完成\n\nThen define methods: but the problem likely expects pseudocode for each method.\n\nWe may produce separate blocks starting with \"Method: insert(val)\" etc.\n\nBut the format example didn't include method names, but we can include them as steps.\n\nWe need to maintain \"Start\" and \"End\" for each method? We can do.\n\nOk produce:\n\nStart // RandomizedCollection 初始化\n\n→ Step 1: Elements = [] // 儲存所有插入值\n\n→ Step 2: IndexMap = {} // val → set of indices\n\nEnd // 初始化完成\n\nMethod: insert(val) // 插入元素\n\nStart // 進入 insert 方法\n\n→ Step 1: exists = IndexMap.containsKey(val) // 判斷 val 是否已存在\n\n→ Step 2: Append val to Elements // 新元素加入尾端\n\n→ Step 3: idx = Elements.size - 1 // 取得新元素索引\n\n→ Step 4: 若 !IndexMap.containsKey(val) → IndexMap[val] = new Set() // 若無此鍵，創建集合\n\n→ Step 5: IndexMap[val].add(idx) // 加入索引\n\n→ Step 6: Return !exists // 若之前不存在則回傳 true，否則 false\n\nEnd // 結束 insert\n\nSimilarly for remove.\n\nLet's produce each line accordingly.\n\nAlso include \"Decision:\" lines.\n\nOk.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // RandomizedCollection 初始化\n→ Step 1: Elements = [] // 建立一個空列表存放所有元素\n→ Step 2: IndexMap = {} // 建立一個映射 val → 設集合，追蹤各值所在的索引\nEnd // 初始化完成\n\nMethod: insert(val) // 插入元素\nStart // 進入 insert 方法\n→ Step 1: exists = IndexMap.containsKey(val) // 判斷 val 是否已存在\n→ Step 2: Append val to Elements // 將 val 加到列表尾端\n→ Step 3: idx = Elements.size - 1 // 取得新插入元素的索引\n→ Decision: 如果 IndexMap 不包含 val?\n    Yes → IndexMap[val] = new Set() // 若沒建立集合，先建立\n    No  →  // 已有集合，直接使用\n→ Step 4: IndexMap[val].add(idx) // 把新索引加入對應集合\n→ Step 5: Return !exists // 若之前不存在則回傳 true，否則 false\nEnd // 結束 insert\n\nMethod: remove(val) // 刪除元素\nStart // 進入 remove 方法\n→ Decision: 如果 IndexMap 不包含 val?\n    Yes → Return false // 無此值，無法刪除\n    No  → // 進一步執行\n→ Step 1: idx = any element from IndexMap[val] // 隨機取得一個索引\n→ Step 2: lastIdx = Elements.size - 1 // 取得列表最後一個元素索引\n→ Step 3: lastVal = Elements[lastIdx] // 取得最後一個元素值\n→ Step 4: Elements[idx] = lastVal // 用最後一個元素覆蓋被刪除的位置\n→ Step 5: IndexMap[lastVal].remove(lastIdx) // 移除 lastVal 原來的最後一個索引\n→ Decision: 如果 idx ≠ lastIdx?\n    Yes → IndexMap[lastVal].add(idx) // 把新索引加入 lastVal 的集合\n    No  → // idx 與 lastIdx 相同，無需再加\n→ Step 6: IndexMap[val].remove(idx) // 移除被刪除值的索引\n→ Decision: 如果 IndexMap[val] 為空集合?\n    Yes → delete IndexMap[val] // 若集合已空，移除鍵\n    No  → // 留存\n→ Step 7: Elements.pop() // 刪除列表最後一個元素\n→ Step 8: Return true // 成功刪除\nEnd // 結束 remove\n\nMethod: getRandom() // 取得隨機元素\nStart // 進入 getRandom 方法\n→ Step 1: randIdx = random(0, Elements.size - 1) // 產生 0~size-1 的隨機整數\n→ Step 2: Return Elements[randIdx] // 回傳對應索引的元素\nEnd // 結束 getRandom\n```\n\n這些虛擬碼步驟以 `→` 表示順序流程，`Decision:` 表示分支決策，並在每行後提供簡短直觀的中文說明，符合「逐行、即時解釋」的輸出要求。",
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val):\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self):\n        return random.choice(self.data)\n\ndef parse_input(s):\n    \"\"\"Parse the two lists from the input string.\"\"\"\n    # Handle multiline input\n    if '\\n' in s:\n        lines = [line.strip() for line in s.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            cmds_str, args_str = lines[0], lines[1]\n        else:\n            # fallback to comma split\n            parts = s.split('],', 1)\n            cmds_str = parts[0] + ']'\n            args_str = '[' + parts[1]\n    else:\n        parts = s.split('],', 1)\n        cmds_str = parts[0] + ']'\n        args_str = '[' + parts[1]\n    cmds = ast.literal_eval(cmds_str)\n    args = ast.literal_eval(args_str)\n    return cmds, args\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    cmds, args = parse_input(raw)\n    res = []\n    obj = None\n    for cmd, arg in zip(cmds, args):\n        if cmd == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            res.append(None)\n        elif cmd == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif cmd == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif cmd == \"getRandom\":\n            res.append(obj.getRandom())\n    # Format output like LeetCode expects\n    out_parts = []\n    for val in res:\n        if val is None:\n            out_parts.append(\"null\")\n        elif isinstance(val, bool):\n            out_parts.append(\"true\" if val else \"false\")\n        else:\n            out_parts.append(str(val))\n    print(f\"[{', '.join(out_parts)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpzz7s_6o9.py\", line 79, in <module>\n    main()\n  File \"/tmp/tmpzz7s_6o9.py\", line 54, in main\n    cmds, args = parse_input(raw)\n                 ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzz7s_6o9.py\", line 47, in parse_input\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[], [1], [1], [2], [], [1], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode132.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning II",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation line by line. The problem: given string s, partition into palindromes minimize cuts. It's classic DP. We need algorithm: precompute palindrome table, then DP for min cuts.\n\nWe need to produce steps like:\n\nStart\n→ Step 1: 初始化 s 的長度 n\n→ Step 2: 建立布林陣列 dpPal[n][n] 用於判斷子字串是否為回文\n→ Decision: If i==j? // single char\n...\n\nWe should produce stepwise algorithm in natural language, not code but steps.\n\nWe'll use virtual code arrows. Each line has the virtual code step and // explanation.\n\nWe need to cover algorithm: Precompute palindrome table; DP for cuts; output min cuts.\n\nWe should also mention initial DP array cuts[n] (min cuts for substring starting at i). Actually min cuts for whole string.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 取得字串長度 n = s.length() // 取得輸入字串長度\n→ Step 2: 建立布林陣列 pal[n][n] 初始化為 false // 用來記錄每個子字串是否為回文\n→ Decision: 逐一檢查所有子字串以填寫 pal\n    → For i from n-1 downto 0\n        → For j from i to n-1\n            → Condition: s[i] == s[j] AND (j - i < 2 OR pal[i+1][j-1]) // 判斷是否為回文\n                → Yes → pal[i][j] = true // 設定為回文\n                → No  → pal[i][j] = false // 非回文\n→ Step 3: 建立整數陣列 cuts[n+1] 並設定 cuts[n] = -1 // cuts[i] 表示從 i 到末尾最少切割數\n→ Step 4: 迭代 i 從 n-1 downto 0\n    → Step 4.1: 設定 minCuts = ∞\n    → Step 4.2: 迭代 j 從 i 到 n-1\n        → Decision: 如果 pal[i][j] 為 true\n            → Yes → minCuts = min(minCuts, 1 + cuts[j+1]) // 若子字串為回文，計算切割數\n            → No → 跳過\n    → Step 4.3: 設定 cuts[i] = minCuts // 儲存從 i 開始的最少切割\n→ Step 5: 回傳 cuts[0] // 整個字串最少切割數\nEnd // 程式執行結束\n\nBut we need to use arrow \"→\" and decision with Yes → and No →. The lines must be single statements. Might need multiple lines per iteration but we cannot use loops as code? It's virtual steps, can use pseudo loops. We should show loops as step lines like \"→ For i from n-1 downto 0\" etc. Use indent.\n\nWe must ensure each line ends with // explanation. Also arrow lines with decisions.\n\nLet's format properly:\n\nStart // 程式開始執行\n→ Step 1: n ← length(s) // 取得字串長度\n→ Step 2: pal ← boolean[n][n] all false // 建立回文判斷表\n→ Step 3: For i ← n-1 downto 0 // 從尾到頭遍歷開始索引\n    → For j ← i to n-1 // 遍歷結束索引\n        → Decision: s[i] == s[j] AND (j-i<2 OR pal[i+1][j-1]) // 判斷子字串是否回文\n            Yes → pal[i][j] ← true // 設定為回文\n            No  → pal[i][j] ← false // 設定為非回文\n→ Step 4: cuts ← int[n+1] // 形成最少切割陣列\n→ Step 5: cuts[n] ← -1 // 基本情況，空字串不需要切割\n→ Step 6: For i ← n-1 downto 0 // 從尾到頭計算最少切割\n    → minCuts ← ∞\n    → For j ← i to n-1\n        → Decision: pal[i][j] == true // 子字串為回文?\n            Yes → minCuts ← min(minCuts, 1 + cuts[j+1]) // 更新切割數\n            No  → 跳過\n    → cuts[i] ← minCuts // 儲存結果\n→ Step 7: Return cuts[0] // 整個字串最少切割數\nEnd // 程式執行結束\n\nWe need to ensure each line has the format: virtual code step [space] // 解釋\n\nThe lines with loops and decisions are multi-lines; we need each line individually. For loops, we need separate line for loop start, and nested lines indent. Use indent? The example uses indentation with spaces. We should follow same style.\n\nThus produce lines as above. Ensure no actual code, just pseudo. Provide all lines. Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(s) // 取得輸入字串長度  \n→ Step 2: pal ← boolean[n][n] all false // 建立回文判斷表  \n→ Step 3: For i ← n-1 downto 0 // 從尾到頭遍歷開始索引  \n    → For j ← i to n-1 // 遍歷結束索引  \n        → Decision: s[i] == s[j] AND (j-i<2 OR pal[i+1][j-1]) // 判斷子字串是否為回文  \n            Yes → pal[i][j] ← true // 設定為回文  \n            No  → pal[i][j] ← false // 設定為非回文  \n→ Step 4: cuts ← int[n+1] // 建立最少切割陣列  \n→ Step 5: cuts[n] ← -1 // 基本情況，空字串不需要切割  \n→ Step 6: For i ← n-1 downto 0 // 從尾到頭計算最少切割  \n    → minCuts ← ∞  \n    → For j ← i to n-1  \n        → Decision: pal[i][j] == true // 子字串為回文?  \n            Yes → minCuts ← min(minCuts, 1 + cuts[j+1]) // 更新切割數  \n            No  → 跳過  \n    → cuts[i] ← minCuts // 儲存結果  \n→ Step 7: Return cuts[0] // 整個字串最少切割數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [0] * n  # dp[i] = minimum cuts for s[:i+1]\n        pal = [[False] * n for _ in range(n)]  # pal[j][i] = True if s[j:i+1] is palindrome\n\n        for i in range(n):\n            min_cut = i  # worst case: cut each character\n            for j in range(i + 1):\n                if s[j] == s[i] and (i - j <= 1 or pal[j + 1][i - 1]):\n                    pal[j][i] = True\n                    if j == 0:\n                        min_cut = 0  # whole prefix is palindrome\n                    else:\n                        min_cut = min(min_cut, dp[j - 1] + 1)\n            dp[i] = min_cut\n        return dp[-1]\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the string value from input like 's = \"aab\"' or just 'aab'.\"\"\"\n    raw = raw.strip()\n    # Find first and last quote\n    first_quote = raw.find('\"')\n    last_quote = raw.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and first_quote < last_quote:\n        return raw[first_quote + 1:last_quote]\n    # If no quotes, return stripped string\n    return raw\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = Solution().minCut(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode521.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence I",
    "description_snippet": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanation. Task: Given two strings a and b, return length of longest uncommon subsequence (LUS). If none, return -1. The known solution: if a == b return -1 else return max(len(a), len(b)). Provide steps. We'll output virtual code lines like:\n\nStart\n→ Step 1: Input strings a and b\n→ Decision: if a equals b?\n    Yes → Step 2: Return -1 // no uncommon subsequence\n    No  → Step 3: Compute length of a\n    → Step 4: Compute length of b\n    → Step 5: Return max of lengths // longest uncommon subsequence is the longer string itself\nEnd\n\nNeed to use arrow format as required.\n\nMake sure each line ends with // explanation. Use arrow for steps and decisions. Use Start and End. Use Decision lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 a 與 b // 從使用者處讀取兩個字串  \n→ Decision: 是否 a 與 b 完全相同？ // 檢查兩個字串是否相等  \n  Yes → Step 2: 回傳 -1 // 若相同則不存在不相同的子序列  \n  No → Step 3: 計算 len(a) // 取得 a 的長度  \n  → Step 4: 計算 len(b) // 取得 b 的長度  \n  → Step 5: 回傳 max(len(a), len(b)) // 兩者中較長者即為最長不相同子序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        \"\"\"\n        找出兩字串之間最長的不相同子序列長度。\n        如果兩字串完全相同，則不存在不相同子序列，回傳 -1。\n        \"\"\"\n        if a == b:\n            return -1\n        return max(len(a), len(b))\n\ndef parse_input() -> tuple[str, str]:\n    \"\"\"\n    從標準輸入讀取兩個字串。\n    支援兩種輸入格式：\n      1. 以逗號分隔並用雙引號包住，例如：\"aba\", \"cdc\"\n      2. 直接輸入兩個字串，中間以空白或換行分隔\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 先嘗試抓取雙引號中的內容\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n\n    # 若無雙引號，則以空白、逗號、換行分隔\n    parts = re.split(r'[\\s,]+', data)\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # 若無法取得兩個字串，回傳空字串以避免例外\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    a, b = parse_input()\n    solution = Solution()\n    result = solution.findLUSlength(a, b)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"aba\", \"cdc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "\"aaa\", \"bbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "\"aaa\", \"aaa\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode322.json",
    "problem_index_in_file": 0,
    "title": "Coin Change",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for coin change DP problem. Use Start, End, Decision. Use arrows. Each line: \"虛擬碼步驟 // 解釋\". The user wants code but no actual code. Must produce structured steps. We need to produce iterative DP approach. We'll show initialization of dp array of length amount+1 with large value, dp[0] = 0. Then loop for each coin, inner loop amount from coin to amount. Update dp. Finally, if dp[amount] == large, return -1 else return dp[amount]. Use Start and End. Also include decisions like if amount < 0 etc? They didn't ask for negative check. We'll produce steps.\n\nMake sure each line has a step and comment. Use arrows appropriately.\n\nWe need to ensure each line is a separate line with the virtual code. Use Start, End. Use arrow: \"→\". Use Decision lines.\n\nWe need to produce step-by-step algorithm. We'll produce maybe ~15 lines. Each step with comment.\n\nLet's craft:\n\nStart // 開始\n→ Step 1: 設定 max = amount + 1 // 初始化最大值\n→ Step 2: 建立 dp 陣列長度 max，全部設為 max // dp[i] 表示最少硬幣數\n→ Step 3: dp[0] = 0 // 零金額不需要硬幣\n→ Decision: 是否有硬幣？ // 檢查 coins 是否空\n    Yes → Step 4: 針對每枚硬幣 coin in coins // 外層循環\n        → Step 5: 對每個金額 i 從 coin 到 amount // 內層循環\n            → Step 6: 更新 dp[i] = min(dp[i], dp[i - coin] + 1) // 選擇更少硬幣\n→ Decision: dp[amount] 是否等於 max? // 判斷是否可組成金額\n    Yes → Step 7: 回傳 -1 // 無法達成\n    No  → Step 8: 回傳 dp[amount] // 最少硬幣數\nEnd // 結束\n\nWe need arrow formatting: maybe include spaces. For each Decision block, indent. Use \"Yes →\" and \"No →\" lines inside block. Ensure each line has arrow before step or decision. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 max = amount + 1 // 最大值作為無限大表示  \n→ Step 2: 建立 dp 陣列長度 max，全部設為 max // dp[i] 代表最少硬幣數  \n→ Step 3: dp[0] = 0 // 金額 0 不需要任何硬幣  \n→ Decision: 是否有硬幣? // 檢查 coins 是否為空  \n  Yes → Step 4: 針對每枚硬幣 coin in coins // 外層循環處理硬幣種類  \n   → Step 5: 對每個金額 i 從 coin 到 amount // 內層循環計算可達金額  \n    → Step 6: 更新 dp[i] = min(dp[i], dp[i - coin] + 1) // 取較小硬幣數  \n→ Decision: dp[amount] 是否等於 max? // 判斷是否能組成目標金額  \n  Yes → Step 7: 回傳 -1 // 無法達成  \n  No  → Step 8: 回傳 dp[amount] // 最少硬幣數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom math import inf\n\ndef coin_change(coins, amount):\n    \"\"\"最少硬幣數 DP 演算法\"\"\"\n    dp = [inf] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != inf else -1\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，支援形式：\n    coins = [1,2,5], amount = 11\n    \"\"\"\n    pattern = r'coins\\s*=\\s*(\\[.*?\\])\\s*,\\s*amount\\s*=\\s*(\\d+)'\n    m = re.search(pattern, data)\n    if m:\n        coins_str, amount_str = m.group(1), m.group(2)\n        coins = eval(coins_str)          # 轉成 list\n        amount = int(amount_str)\n        return coins, amount\n    # 若格式不符，直接嘗試評估整個輸入\n    parts = data.split()\n    if len(parts) >= 2:\n        try:\n            coins = eval(parts[0])\n            amount = int(parts[1])\n            return coins, amount\n        except Exception:\n            pass\n    raise ValueError(\"輸入格式不符合要求\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        coins, amount = parse_input(raw_input)\n        result = coin_change(coins, amount)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "coins = [1], amount = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode213.json",
    "problem_index_in_file": 0,
    "title": "House Robber II",
    "description_snippet": "You are a professional robber planning to rob houses along a street. Each house has a certain amount...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps. Problem: house robber II (circular). We need to compute max of two linear DP: excluding first house or excluding last house. Use DP approach: dp[i] = max(dp[i-1], dp[i-2]+nums[i]). Provide steps.\n\nWe need each line: virtual code step plus explanation. Use arrow and decision.\n\nLet's structure: Start. Step: Get nums length n. If n==0 return 0. If n==1 return nums[0]. Then compute helper function maxRobLinear(start, end). Then compute two results: result1 = helper(0, n-2); result2 = helper(1, n-1); result = max(result1, result2). End.\n\nProvide steps with explanation. Use Decision: If n==1 etc.\n\nAlso show helper logic.\n\nLet's craft.\n\nBe careful: each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 取得 nums 數組長度 n // 獲取房屋數量\n→ Decision: n == 0? // 檢查是否無房屋\n    Yes → Step 2: 輸出 0 // 無房屋可盜\n    No  → Decision: n == 1? // 檢查是否只有一座房屋\n        Yes → Step 3: 輸出 nums[0] // 只能盜第一座\n        No  → Step 4: 定義函式 MaxRobLinear(start, end) // 處理線性序列的盜竊\n            // MaxRobLinear 內部\n            → Step 5: 初始化 prev1 = 0, prev2 = 0 // 前兩個房屋的最大收益\n            → Step 6: 從 i = start 到 end 逐步迭代\n                → Decision: i == start? // 第一個房屋\n                    Yes → prev2 = nums[i] // 只考慮第一個\n                    No  → Decision: i == start+1? // 第二個房屋\n                        Yes → prev1 = max(prev2, nums[i]) // 比較前兩個\n                        No  → Step 7: temp = max(prev1, prev2 + nums[i]) // 更新最大收益\n                            prev2 = prev1\n                            prev1 = temp\n            → Step 8: 返回 prev1 // 最終最大收益\n→ Step 9: 計算 result1 = MaxRobLinear(0, n-2) // 排除最後一座\n→ Step 10: 計算 result2 = MaxRobLinear(1, n-1) // 排除第一座\n→ Step 11: 計算 answer = max(result1, result2) // 選擇更大收益\n→ Step 12: 輸出 answer // 結束並返回結果\nEnd // 程式執行結束\n\nNeed each line format: \"虛擬碼步驟 // 解釋\". For lines with indent? Use indentation maybe but not necessary. Use arrow.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 nums 數組長度 n // 獲取房屋數量  \n→ Decision: n == 0? // 檢查是否無房屋  \n    Yes → Step 2: 輸出 0 // 無房屋可盜  \n    No  → Decision: n == 1? // 檢查是否只有一座房屋  \n        Yes → Step 3: 輸出 nums[0] // 只能盜第一座  \n        No  → Step 4: 定義函式 MaxRobLinear(start, end) // 處理線性序列的盜竊  \n            // MaxRobLinear 內部  \n            → Step 5: 初始化 prev1 = 0, prev2 = 0 // 前兩個房屋的最大收益  \n            → Step 6: 從 i = start 到 end 逐步迭代  \n                → Decision: i == start? // 第一個房屋  \n                    Yes → prev2 = nums[i] // 只考慮第一個  \n                    No  → Decision: i == start+1? // 第二個房屋  \n                        Yes → prev1 = max(prev2, nums[i]) // 比較前兩個  \n                        No  → Step 7: temp = max(prev1, prev2 + nums[i]) // 更新最大收益  \n                            prev2 = prev1  \n                            prev1 = temp  \n            → Step 8: 返回 prev1 // 最終最大收益  \n→ Step 9: 計算 result1 = MaxRobLinear(0, n-2) // 排除最後一座  \n→ Step 10: 計算 result2 = MaxRobLinear(1, n-1) // 排除第一座  \n→ Step 11: 計算 answer = max(result1, result2) // 選擇更大收益  \n→ Step 12: 輸出 answer // 結束並返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def rob(self, nums):\n        \"\"\"Return the maximum amount that can be robbed from a circular list of houses.\"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n\n        def rob_linear(houses):\n            \"\"\"Helper that solves the linear house‑robber problem.\"\"\"\n            prev, curr = 0, 0\n            for num in houses:\n                prev, curr = curr, max(curr, prev + num)\n            return curr\n\n        # Two cases: exclude first house or exclude last house\n        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))\n\ndef parse_nums(text: str):\n    \"\"\"Parse the input string to extract a list of integers.\"\"\"\n    # Remove any leading variable assignment\n    if '=' in text:\n        _, list_part = text.split('=', 1)\n    else:\n        list_part = text\n    list_part = list_part.strip()\n    try:\n        # Safely evaluate the list literal\n        return ast.literal_eval(list_part)\n    except Exception:\n        # Fallback: extract integers using regex\n        import re\n        return list(map(int, re.findall(r'-?\\d+', list_part)))\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    nums = parse_nums(data)\n    result = Solution().rob(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode402.json",
    "problem_index_in_file": 0,
    "title": "Remove K Digits",
    "description_snippet": "Given string num representing a non-negative integer num, and an integer k, return the smallest poss...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation, per the format. The problem: remove k digits from num to get smallest possible integer. Standard algorithm using stack/greeedy: iterate digits, while stack not empty, top > current digit and k>0, pop and decrement k. Then push current. After loop, if k>0 remove from end. Then build string, remove leading zeros. If empty, return \"0\".\n\nWe need virtual code steps. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow, decisions, etc.\n\nLet's outline steps:\n\nStart\n→ Step 1: 取得輸入 num, k // get inputs\n→ Step 2: 初始化空棧 resultStack // stack to hold digits\n→ Step 3: 對 num 中每個字符 digit 進行迭代 // loop over digits\n    → Decision: 是否需要刪除前面更大數字並且 k>0? // check if pop needed\n        Yes → Step 4: 從 resultStack 彈出最後一位 // pop\n            → Step 5: k ← k - 1 // reduce k\n            → Step 6: 回到 Decision 以繼續檢查 // loop decision\n        No  → Step 7: 推入 current digit 到 resultStack // push\n→ Step 8: 如果 k > 0 則從結果棧尾部刪除多餘 k 位 // remove remaining\n→ Step 9: 建立結果字符串 from stack // build string\n→ Step 10: 移除前導零 // trim leading zeros\n→ Step 11: 如果結果為空則返回 \"0\" 否則返回結果 // final return\nEnd\n\nWe must express each step in virtual code with arrow or decision lines. Use \"Start\", \"End\", \"Decision:\" lines. Provide each line with explanation after //.\n\nMake sure each line is separate. Use appropriate indentation? The sample shows indent for nested decisions. We'll do same.\n\nWe need to use virtual code style: \"Start // 程式開始執行\" etc.\n\nWe'll produce line-by-line. Let's craft each line.\n\n1. Start // 程式開始執行\n2. → Step 1: num, k ← 讀取輸入 // 取得輸入字符串 num 與整數 k\n3. → Step 2: resultStack ← 空堆疊 // 用於儲存選取的位元\n4. → Step 3: 對 num 中每個字符 digit 進行迭代 // 遍歷原始數字\n5.     → Decision: resultStack 非空 且 top(resultStack) > digit 且 k > 0? // 判斷是否需要刪除更大的前一位\n6.         Yes → Step 4: resultStack.pop() // 移除堆疊頂端的較大位元\n7.             → Step 5: k ← k - 1 // 刪除計數減一\n8.             → Step 6: 回到 Decision: resultStack 非空 且 top(resultStack) > digit 且 k > 0? // 重新檢查條件\n9.         No  → Step 7: resultStack.push(digit) // 把當前位元推入堆疊\n10. → Step 8: 如果 k > 0? // 檢查是否還有位元需要刪除\n11.     Yes → Step 9: 從 resultStack 末尾刪除 k 個位元 // 移除多餘位元\n12. → Step 10: resultStr ← 空字符串 // 用於組裝結果\n13. → Step 11: 對 resultStack 中的每個位元進行排序並連接成 resultStr // 建立結果字串\n14. → Step 12: resultStr ← 移除前導零(resultStr) // 去除不必要的零\n15. → Step 13: 如果 resultStr 為空? // 判斷結果是否為空\n16.     Yes → Return \"0\" // 若結果空，回傳 0\n17.     No  → Return resultStr // 否則回傳最小化後的數字\n18. End // 程式結束執行\n\nNeed to adjust some lines: Step 11: building string from stack: we might need to pop all to string. But we can mention building string by iterating stack.\n\nAlso step 13: sorting? Actually stack order is preserved, no sorting. Should say \"連接堆疊內容\". So adjust.\n\nLet's rewrite steps 10-17 properly.\n\nWe must maintain order of steps and maintain nested decisions.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: num, k ← 讀取輸入 // 取得輸入字符串 num 與整數 k  \n→ Step 2: resultStack ← 空堆疊 // 用於儲存選取的位元  \n→ Step 3: 對 num 中每個字符 digit 進行迭代 // 遍歷原始數字  \n  → Decision: resultStack 非空 且 top(resultStack) > digit 且 k > 0? // 判斷是否需要刪除更大的前一位  \n   Yes → Step 4: resultStack.pop() // 移除堆疊頂端的較大位元  \n    → Step 5: k ← k - 1 // 刪除計數減一  \n    → Step 6: 回到 Decision: resultStack 非空 且 top(resultStack) > digit 且 k > 0? // 重新檢查條件  \n   No  → Step 7: resultStack.push(digit) // 把當前位元推入堆疊  \n→ Step 8: 如果 k > 0? // 檢查是否還有位元需要刪除  \n  Yes → Step 9: 從 resultStack 末尾刪除 k 個位元 // 移除多餘位元  \n→ Step 10: resultStr ← 空字符串 // 用於組裝結果  \n→ Step 11: 對 resultStack 中的每個位元依序連接到 resultStr // 建立結果字串  \n→ Step 12: resultStr ← 移除前導零(resultStr) // 去除不必要的零  \n→ Step 13: 如果 resultStr 為空? // 判斷結果是否為空  \n  Yes → Return \"0\" // 若結果空，回傳 0  \n  No  → Return resultStr // 否則回傳最小化後的數字  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\ndef remove_k_digits(num: str, k: int) -> str:\n    \"\"\"Return the smallest number after removing k digits from num.\"\"\"\n    stack = []\n    for digit in num:\n        while k > 0 and stack and stack[-1] > digit:\n            stack.pop()\n            k -= 1\n        stack.append(digit)\n\n    # If still have to remove digits, pop from the end\n    while k > 0:\n        stack.pop()\n        k -= 1\n\n    # Build result and strip leading zeros\n    result = ''.join(stack).lstrip('0')\n    return result if result else \"0\"\n\ndef parse_input(text: str):\n    \"\"\"Parse input like 'num = \\\"1432219\\\", k = 3' or 'num = 1432219, k = 3'.\"\"\"\n    # Try pattern with quoted number\n    m = re.search(r'num\\s*=\\s*\"([^\"]+)\"\\s*,\\s*k\\s*=\\s*(\\d+)', text)\n    if m:\n        return m.group(1), int(m.group(2))\n    # Try pattern without quotes\n    m = re.search(r'num\\s*=\\s*(\\d+)\\s*,\\s*k\\s*=\\s*(\\d+)', text)\n    if m:\n        return m.group(1), int(m.group(2))\n    raise ValueError(\"Input format not recognized\")\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    num_str, k_val = parse_input(data)\n    result = remove_k_digits(num_str, k_val)\n    # Output with surrounding double quotes as per examples\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"1432219\", k = 3",
          "expected_output": "\"1219\"",
          "success": true,
          "output": "\"1219\""
        },
        {
          "example_index": 1,
          "input": "num = \"10200\", k = 1",
          "expected_output": "\"200\"",
          "success": true,
          "output": "\"200\""
        },
        {
          "example_index": 2,
          "input": "num = \"10\", k = 2",
          "expected_output": "\"0\"",
          "success": true,
          "output": "\"0\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode125.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome",
    "description_snippet": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and remov...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step for palindrome check. Must be in Chinese Traditional. Use the format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Include arrow. So produce lines like:\n\nStart // 程式開始\n→ Step 1: 初始化指標 left = 0, right = s.length - 1 // 設定兩端指標\n→ Step 2: 將 s 轉為字元陣列 // 方便索引\n→ Decision: 左右指標未交叉? // 判斷是否完成\n    Yes → Step 3: 取得左字符 leftChar = s[left]\n    Step 4: 取得右字符 rightChar = s[right]\n    Step 5: 將 leftChar 轉小寫並檢查是否字母數字 // ...\n    Step 6: 若左字符非字母數字，左 +=1, 從新 Decision\n    Step 7: 同理右字符\n    Step 8: 若兩字符均有效，將兩者轉小寫並比較\n    Step 9: 若不相等 → False\n    Step 10: 左+=1, 右-=1, 從新 Decision\n    No → Step 11: All matched → True\nEnd\n\nNeed to maintain structure with arrows. Provide explanation after each line. Let's craft.\n\nWe can condense steps but keep clarity. Use \"→ Decision:\" for branching. Use indentation with arrow inside? In example, they used indentation like:\n\nDecision: If X\n    Yes → ...\n    No  → ...\n\nWe'll follow same.\n\nLet's write lines:\n\nStart // 程式開始\n→ Step 1: left ← 0, right ← length(s) - 1 // 初始化兩端指標\n→ Decision: left < right? // 判斷是否還有未比對的字符\n    Yes → Step 2: charLeft ← s[left], charRight ← s[right] // 取兩端字符\n    → Step 3: if charLeft is not alphanumeric then left ← left + 1, jump to Decision // 忽略非字母數字\n    → Step 4: if charRight is not alphanumeric then right ← right - 1, jump to Decision // 同理右端\n    → Step 5: charLeft ← toLowerCase(charLeft), charRight ← toLowerCase(charRight) // 轉小寫\n    → Decision: charLeft ≠ charRight? // 比較\n        Yes → Step 6: return False // 不相等不是迴文\n        No  → Step 7: left ← left + 1, right ← right - 1, jump to Decision // 繼續\n    No  → Step 8: return True // 所有字符相等，為迴文\nEnd // 程式結束\n\nBut we need \"→\" before each step; but the \"jump to Decision\" we can represent as just go back to Decision. It's okay.\n\nBut we also need to show arrow for decision branches. For each decision we list Yes/No arrows.\n\nMake sure each line ends with // explanation.\n\nAlso keep consistent arrow usage. Example: \"→ Decision: 左右指標未交叉?\" etc.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始\n→ Step 1: left ← 0, right ← length(s) - 1 // 初始化左右兩端指標\n→ Decision: left < right? // 判斷是否還有未比較的字符\n    Yes → Step 2: charLeft ← s[left], charRight ← s[right] // 取左、右兩側字符\n    → Decision: charLeft 不是字母或數字? // 檢查左字符是否有效\n        Yes → Step 3: left ← left + 1, 重新進入 Decision // 左字符無效，跳過\n        No  → // 進一步處理右字符\n    → Decision: charRight 不是字母或數字? // 檢查右字符是否有效\n        Yes → Step 4: right ← right - 1, 重新進入 Decision // 右字符無效，跳過\n        No  → // 兩字符均有效，進行比較\n    → Step 5: charLeft ← toLowerCase(charLeft), charRight ← toLowerCase(charRight) // 轉為小寫\n    → Decision: charLeft ≠ charRight? // 比較兩字符\n        Yes → Step 6: return False // 不相等，非迴文\n        No  → Step 7: left ← left + 1, right ← right - 1, 重新進入 Decision // 兩字符相等，繼續\n    No  → Step 8: return True // left ≥ right，所有字符已匹配，為迴文\nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        # 過濾掉非字母數字，並轉成小寫\n        filtered = [c.lower() for c in s if c.isalnum()]\n        # 檢查過濾後的序列是否為回文\n        return filtered == filtered[::-1]\n\ndef parse_input(raw: str) -> str:\n    \"\"\"將原始輸入轉成純粹的字符串。\n    支援「s = \"文字\"」或直接輸入文字的格式。\"\"\"\n    raw = raw.strip()\n    if raw.lower().startswith('s ='):\n        raw = raw[3:].strip()          # 移除前面的 s =\n        if (raw.startswith('\"') and raw.endswith('\"')) or \\\n           (raw.startswith(\"'\") and raw.endswith(\"'\")):\n            raw = raw[1:-1]            # 移除外層引號\n    return raw\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    s = parse_input(raw_input)\n    sol = Solution()\n    result = sol.isPalindrome(s)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"race a car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \" \"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode169.json",
    "problem_index_in_file": 0,
    "title": "Majority Element",
    "description_snippet": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for majority element problem, using Boyer-Moore majority vote algorithm. Use steps: Start, Step 1: initialize candidate and count, iterate array, update candidate and count, finally return candidate. Must be line by line with \"→\". Provide explanation after each line. Also use Decision for loops maybe? Use Decision to check array boundaries? We can use Decision: if count==0? But typical algorithm: iterate over nums. For each num: if count==0 then candidate = num; count=1; else if num==candidate then count++ else count--. At end return candidate.\n\nWe can express in virtual code lines.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize candidate = None, count = 0 // 設定初始候選元素與計數\n→ Decision: for each num in nums? We can represent loop: Decision: 有沒有下一個元素? // 檢查是否還有元素未處理\n    Yes → Step 2: 若 count == 0? // 判斷是否需要重新設定候選元素\n        Yes → Step 3: candidate = num // 選擇當前元素為候選\n        No → Decision: num == candidate? // 判斷是否為同一候選\n            Yes → Step 4: count = count + 1 // 同一候選數量加一\n            No → Step 5: count = count - 1 // 不同元素則減少計數\n    No → Step 6: return candidate // 所有元素已處理，返回多數元素\nEnd\n\nBut we need \"→\" for each step. Use indentation? Use \"→\" and spaces. Format must be like example: Start // ... ; each line: \"→ Step ...\" etc. For decision, use \"Decision:\" lines, with indented branches: \"Yes → ...\" \"No → ...\".\n\nLet's create accordingly.\n\nMake sure to include Step numbers maybe, but not necessary. Provide brief explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: candidate ← None, count ← 0 // 初始化候選元素與計數  \n→ Decision: 仍有未處理的元素？ // 檢查是否還有元素可迭代  \n  Yes → Step 2: 若 count == 0? // 判斷是否需要重新設定候選元素  \n    Yes → Step 3: candidate ← num // 選擇當前元素作為候選  \n    No  → Decision: num == candidate? // 判斷當前元素是否與候選相同  \n      Yes → Step 4: count ← count + 1 // 相同，計數加一  \n      No  → Step 5: count ← count - 1 // 不同，計數減一  \n  No  → Step 6: return candidate // 所有元素已處理，輸出多數元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def majorityElement(self, nums):\n        count = 0\n        candidate = None\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        return candidate\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Try to extract the list after 'nums ='\n    if '=' in data:\n        _, after_eq = data.split('=', 1)\n        nums_str = after_eq.strip()\n    else:\n        nums_str = data.strip()\n\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # Fallback: assume space-separated numbers\n        nums = list(map(int, nums_str.split()))\n\n    result = Solution().majorityElement(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,1,1,1,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode468.json",
    "problem_index_in_file": 0,
    "title": "Validate IP Address",
    "description_snippet": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 ad...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. No real code. Need to handle input string queryIP, check if IPv4 or IPv6, else Neither. Provide virtual steps. Use arrows. Let's design steps:\n\nStart\n→ Step 1: Split queryIP by '.' and ':' // Determine delimiter\n→ Decision: Contains '.'? // Check if string contains dot\n    Yes → Step 2: Validate IPv4 // Validate each part\n    No → Decision: Contains ':'? // Check colon\n        Yes → Step 3: Validate IPv6\n        No  → Step 4: Return \"Neither\"\n\nWithin Validate IPv4: Steps\n→ Step 5: If number of parts != 4 -> return \"Neither\"\n→ Decision: For each part i\n    If part empty -> return \"Neither\"\n    If part length >1 and startswith '0' -> return \"Neither\"\n    If part not all digits -> return \"Neither\"\n    If int(part) not in 0-255 -> return \"Neither\"\n→ Step 6: Return \"IPv4\"\n\nSimilarly IPv6:\n→ Step 7: Split by ':'\n→ Decision: If number of parts !=8 -> return \"Neither\"\n→ Decision: For each part\n    If part empty -> return \"Neither\"\n    If length <1 or >4 -> return \"Neither\"\n    If any char not hex digit -> return \"Neither\"\n→ Step 8: Return \"IPv6\"\n\nFinally End.\n\nWe need to produce each line as virtual code line with explanation. Use the arrow syntax.\n\nLet's produce.\n\nWe need to use \"Start\", \"End\", \"Decision:\" lines.\n\nAlso each line after virtual code must have \"// 解釋\".\n\nLet's write accordingly.\n\nWe must ensure each line is a separate line. Provide step numbers. Use arrow for steps.\n\nLet's craft.\n\nAlso incorporate loops concept? Use Decision: For each part maybe use a loop arrow. Use \"For each part:\". It's fine.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Split queryIP by '.' 和 ':'，並記錄分隔符 // 先找出 IP 可能使用的分隔符  \n→ Decision: queryIP 是否包含 '.'？ // 判斷是否為 IPv4 格式  \n Yes → Step 2: 開始驗證 IPv4 // 如果有 '.'，進入 IPv4 驗證流程  \n No  → Decision: queryIP 是否包含 ':'？ // 否則判斷是否為 IPv6  \n  Yes → Step 3: 開始驗證 IPv6 // 有 ':'，進入 IPv6 驗證流程  \n  No  → Step 4: 返回 \"Neither\" // 既不含 '.' 也不含 ':'，直接返回  \nStep 2: // IPv4 驗證流程  \n→ Step 5: 如果 '.' 分割後的段數不等於 4，返回 \"Neither\" // 應為四段  \n→ Decision: 逐段檢查每個 part  \n For each part: // 對每一段進行驗證  \n  If part 為空，返回 \"Neither\" // 不能有空段  \n  If part 長度 > 1 且以 '0' 開頭，返回 \"Neither\" // 禁止前導零  \n  If part 不是全數字，返回 \"Neither\" // 必須是數字  \n  如果 int(part) 不在 0-255，返回 \"Neither\" // 數值範圍檢查  \n→ Step 6: 返回 \"IPv4\" // 所有檢查通過，為合法 IPv4  \nStep 3: // IPv6 驗證流程  \n→ Step 7: 如果 ':' 分割後的段數不等於 8，返回 \"Neither\" // 應為八段  \n→ Decision: 逐段檢查每個 part  \n For each part: // 對每一段進行驗證  \n  如果 part 為空，返回 \"Neither\" // 不能有空段  \n  如果 part 長度 <1 或 >4，返回 \"Neither\" // 長度限制  \n  如果 part 含非十六進制字符（0-9、a-f、A-F），返回 \"Neither\" // 字符限制  \n→ Step 8: 返回 \"IPv6\" // 所有檢查通過，為合法 IPv6  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        def isIPv4(s: str) -> bool:\n            parts = s.split('.')\n            if len(parts) != 4:\n                return False\n            for part in parts:\n                if not part.isdigit():\n                    return False\n                if part[0] == '0' and len(part) != 1:  # leading zeros not allowed\n                    return False\n                num = int(part)\n                if num < 0 or num > 255:\n                    return False\n            return True\n\n        def isIPv6(s: str) -> bool:\n            parts = s.split(':')\n            if len(parts) != 8:\n                return False\n            hexdigits = \"0123456789abcdefABCDEF\"\n            for part in parts:\n                if len(part) < 1 or len(part) > 4:\n                    return False\n                for c in part:\n                    if c not in hexdigits:\n                        return False\n            return True\n\n        if queryIP.count('.') == 3 and isIPv4(queryIP):\n            return \"IPv4\"\n        if queryIP.count(':') == 7 and isIPv6(queryIP):\n            return \"IPv6\"\n        return \"Neither\"\n\ndef main():\n    line = sys.stdin.readline().strip()\n    # Extract the IP string that may be inside quotes\n    first_quote = line.find('\"')\n    last_quote = line.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        queryIP = line[first_quote + 1:last_quote]\n    else:\n        # If no quotes are present, assume the whole line is the IP\n        queryIP = line\n\n    solution = Solution()\n    print(solution.validIPAddress(queryIP))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "queryIP = \"172.16.254.1\"",
          "expected_output": "IPv4",
          "success": true,
          "output": "IPv4"
        },
        {
          "example_index": 1,
          "input": "queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"",
          "expected_output": "IPv6",
          "success": true,
          "output": "IPv6"
        },
        {
          "example_index": 2,
          "input": "queryIP = \"256.256.256.256\"",
          "expected_output": "Neither",
          "success": true,
          "output": "Neither"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode433.json",
    "problem_index_in_file": 0,
    "title": "Minimum Genetic Mutation",
    "description_snippet": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. It's a BFS problem. We'll produce steps: Start, check if endGene in bank, BFS queue, visited set, step count. Use queue, process neighbors by changing each position to each of 4 letters, if in bank and not visited, add to queue. Return steps when we reach endGene. If BFS completes without, return -1. Use virtual arrows. We must not output actual code. Just steps. Provide one line per step. Each line: \"虛擬碼步驟 // 解釋\". Use structure: Start, Decision, Steps, End. We'll produce enough lines. Use indent? Not required but structure indicated by arrows. We'll use \"→\" for next steps. Use \"Decision:\" lines with Yes and No arrows.\n\nLet's craft. Probably around 15 lines.\n\nWe'll output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 endGene 不在 bank? // 確認終點基因是否有效  \n    Yes → Step 1: 返回 -1 // 沒有效基因，直接結束  \n    No  → Step 2: 初始化 queue ← [startGene] // 把起點放進 BFS 隊列  \n→ Step 3: 初始化 visited ← {startGene} // 記錄已探索的基因  \n→ Step 4: 初始化 mutationCount ← 0 // 記錄已完成的突變步數  \n→ Step 5: 開始 BFS 循環 // 逐層探索所有相鄰基因  \n    → Decision: queue 是否空? // 判斷是否還有基因可探索  \n        Yes → Step 6: 返回 -1 // 未找到終點，結束  \n        No  → Step 7: mutationCount ← mutationCount + 1 // 步數加一，進入新層  \n            → Step 8: 計算當前層大小 layerSize ← queue.size() // 確定本層節點數  \n            → Step 9: 循環 layerSize 次 // 逐個處理本層節點  \n                → Step 10: currentGene ← queue.pop() // 取出前一層節點  \n                → Step 11: 對於每個位置 i 從 0 到 7 // 逐個字元位置  \n                    → Step 12: 對於每個字母 c 從 ['A','C','G','T'] // 可能的變化  \n                        → Decision: c 與 currentGene[i] 是否相同? // 若相同則跳過  \n                            Yes → Skip // 不做任何動作  \n                            No  → Step 13: newGene ← 替換 currentGene[i] 為 c // 產生新基因  \n                                → Decision: newGene 是否等於 endGene? // 判斷是否達到終點  \n                                    Yes → Step 14: 返回 mutationCount // 找到最小突變步數  \n                                    No  → Decision: newGene 是否在 bank 且未被 visited?  \n                                        Yes → Step 15: queue.push(newGene) // 加入隊列  \n                                            → Step 16: visited.add(newGene) // 標記已訪問  \n                                        No  → Skip // 無效或已訪問，忽略  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list[str]) -> int:\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n            for i in range(len(current)):\n                for g in genes:\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入格式：startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    pattern = re.compile(\n        r'startGene\\s*=\\s*\"(?P<start>[^\"]*)\"\\s*,\\s*'\n        r'endGene\\s*=\\s*\"(?P<end>[^\"]*)\"\\s*,\\s*'\n        r'bank\\s*=\\s*\\[(?P<bank>.*)\\]',\n        re.S\n    )\n    match = pattern.search(data)\n    if not match:\n        # 若輸入格式不同，可自行調整解析邏輯\n        sys.exit()\n\n    start_gene = match.group('start')\n    end_gene = match.group('end')\n    bank_str = match.group('bank').strip()\n\n    if bank_str:\n        bank_list = re.findall(r'\"([^\"]*)\"', bank_str)\n    else:\n        bank_list = []\n\n    sol = Solution()\n    result = sol.minMutation(start_gene, end_gene, bank_list)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode168.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Title",
    "description_snippet": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. The requirement: for given integer columnNumber, return column title as in Excel (like Excel column numbering). So we need algorithm: while columnNumber > 0: columnNumber--, get remainder  columnNumber % 26, char = 'A'+rem, prepend, columnNumber/=26. Output string.\n\nSo produce virtual code step by step: Start, Input, Initialize result, While loop, decrement, compute remainder, convert to char, prepend, update columnNumber, End, Output result. Use virtual code arrows. Use Chinese explanation. Provide step per line.\n\nBe careful not to output actual code. Use pseudocode style with arrows. Each line ends with // explanation. Use the format: Step description → etc.\n\nLet's produce.\n\nWe need to use \"虛擬碼步驟\" with arrow. Eg \"Start // 程式開始\". \"→ Step 1: 輸入 columnNumber // 從使用者取得數值\". etc.\n\nWe should include Decision for loop condition? We can use While loop: \"→ Decision: columnNumber > 0? // 判斷是否還有數字需要處理\". \"Yes → ...\" \"No → End\".\n\nAlso inside loop we have decrement, remainder, char, prepend, division. Provide explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 columnNumber // 從使用者處取得一個整數  \n→ Step 2: 初始化 result 為空字串 // 用來累積最終的列標題  \n→ Decision: columnNumber > 0? // 判斷是否還有數字需要轉換  \n  Yes → Step 3: columnNumber ← columnNumber - 1 // 先減 1 以符合 0~25 的索引  \n    → Step 4: remainder ← columnNumber mod 26 // 取得目前位數對 26 的餘數  \n    → Step 5: char ← 'A' + remainder // 將餘數轉為對應的大寫字母  \n    → Step 6: result ← char + result // 把新字母加到結果前面  \n    → Step 7: columnNumber ← floor(columnNumber / 26) // 更新列號為下一位的數值  \n    → Decision: columnNumber > 0? // 是否還有更高位需要處理？  \n      Yes → 返回 Step 3 迴圈  \n      No → Step 8: 輸出 result // 最終結果為 Excel 列標題  \n  No → End // 若初始列號為 0 或負數，直接結束 (可視情況處理錯誤)  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        \"\"\"將整數轉換為 Excel 的列標題。\"\"\"\n        res = ''\n        while columnNumber > 0:\n            columnNumber -= 1  # 先減 1 以對應 0~25 的索引\n            res = chr(columnNumber % 26 + ord('A')) + res  # 取得對應字母\n            columnNumber //= 26  # 更新列號\n        return res\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 'columnNumber = X' 的格式，輸出對應的列標題。\"\"\"\n    data = sys.stdin.read().strip()\n    # 從輸入中抓取第一個整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        return  # 若無數字，直接結束\n    column_number = int(match.group())\n    # 計算列標題\n    title = Solution().convertToTitle(column_number)\n    # 輸出結果，使用雙引號包住（符合範例要求）\n    print(f'\"{title}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnNumber = 1",
          "expected_output": "\"A\"",
          "success": true,
          "output": "\"A\""
        },
        {
          "example_index": 1,
          "input": "columnNumber = 28",
          "expected_output": "\"AB\"",
          "success": true,
          "output": "\"AB\""
        },
        {
          "example_index": 2,
          "input": "columnNumber = 701",
          "expected_output": "\"ZY\"",
          "success": true,
          "output": "\"ZY\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode23.json",
    "problem_index_in_file": 0,
    "title": "Merge k Sorted Lists",
    "description_snippet": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerg...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for merging k sorted linked lists. Typical algorithm: use min-heap or priority queue. Or iterative merging two lists repeatedly. We need to output virtual code lines with arrows, decision etc. No actual code.\n\nLet's produce steps:\n\nStart\n→ Step 1: Initialize a min-heap // create priority queue\n→ Step 2: For each linked list, if head not null, insert node into heap // push first nodes\n→ Decision: If heap empty? // no nodes left\n    Yes → Step 3: End // done\n    No → Step 4: Extract min node from heap // get smallest node\n→ Step 5: Append extracted node to result list // build merged list\n→ Step 6: If extracted node has next, insert next node into heap // maintain nodes\n→ Step 7: Repeat Step 4 to 6 until heap empty\nEnd\n\nBut we need to ensure arrow representation for loops etc.\n\nWe can show loop with Decision: if heap empty? with Yes/No.\n\nWe need to produce line by line with explanation.\n\nAlso include a temporary pointer for result tail.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化最小堆 // 建立優先佇列以取得最小值\n→ Step 2: 針對每個連結串列，若 head 不為 null，將 head 插入最小堆 // 把每個序列的第一個節點放入堆\n→ Step 3: 初始化結果頭指標 dummy 和尾指標 tail // 用 dummy 方便最後回傳\n→ Decision: 堆是否為空? // 檢查是否還有節點待合併\n    Yes → End // 所有節點已處理，結束\n    No  → Step 4: 從最小堆取出最小節點 minNode // 獲得目前最小值\n→ Step 5: tail.next = minNode // 將 minNode 加入結果鏈表\n→ Step 6: tail = minNode // 更新尾指標\n→ Step 7: 若 minNode.next 存在，將 minNode.next 插入最小堆 // 讓下一個節點可被選取\n→ Decision: 堆是否為空? // 判斷是否還有剩餘節點\n    Yes → End // 所有節點已合併\n    No  → Go back to Step 4 // 連續取下一個最小節點\nEnd // 程式執行結束\n\nBut we need arrows and structure like →. Need to maintain indentation. The sample shows indentation inside decision.\n\nWe should keep consistent.\n\nAlso mention \"Go back to Step 4\" but maybe just loop: Decision: 堆是否為空? with No → Step 4.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化最小堆 // 建立優先佇列\n→ Step 2: 對每個鏈表，若 head 不為 null，將 head 插入最小堆 // 放入第一個節點\n→ Step 3: 創建 dummy 頭節點並設置 tail = dummy // 方便結果鏈表連結\n→ Decision: 最小堆是否為空? // 檢查是否還有節點\n    Yes → End // 合併完成\n    No  → Step 4: 取出堆頂節點 minNode // 取得最小節點\n→ Step 5: tail.next = minNode // 將 minNode 加入結果\n→ Step 6: tail = minNode // 更新尾指標\n→ Step 7: 若 minNode.next 存在，將 minNode.next 插入最小堆 // 讓下一個節點可被選取\n→ Decision: 最小堆是否為空? // 再次檢查\n    Yes → End // 所有節點已處理\n    No  → Step 4 // 重複取下一個最小節點\nEnd // 程式執行結束\n\nWe need to show arrow for loop: maybe after Step 7 we go back to Decision. But sample uses \"Yes → Step 4\" and \"No → Decision\". That loops.\n\nOk.\n\nMake sure each line ends with comment. Use [space] after code.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化最小堆 // 建立優先佇列以取得最小值\n→ Step 2: 對每個鏈表，若 head 不為 null，將 head 插入最小堆 // 把每個序列的第一個節點放入堆\n→ Step 3: 創建 dummy 頭節點並設置 tail = dummy // 方便結果鏈表連結\n→ Decision: 最小堆是否為空? // 檢查是否還有節點\n    Yes → End // 合併完成\n    No  → Step 4: 取出堆頂節點 minNode // 取得目前最小節點\n→ Step 5: tail.next = minNode // 將 minNode 加入結果鏈表\n→ Step 6: tail = minNode // 更新尾指標\n→ Step 7: 若 minNode.next 存在，將 minNode.next 插入最小堆 // 讓下一個節點可被選取\n→ Decision: 最小堆是否為空? // 再次檢查\n    Yes → End // 所有節點已處理\n    No  → Step 4 // 重複取下一個最小節點\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\nfrom typing import List, Optional\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val: int = 0, next: Optional['ListNode'] = None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists:\n            return None\n        return self.mergeRange(lists, 0, len(lists) - 1)\n\n    def mergeRange(self, lists: List[Optional[ListNode]], left: int, right: int) -> Optional[ListNode]:\n        if left == right:\n            return lists[left]\n        mid = (left + right) // 2\n        l1 = self.mergeRange(lists, left, mid)\n        l2 = self.mergeRange(lists, mid + 1, right)\n        return self.mergeTwoLists(l1, l2)\n\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        curr = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        curr.next = l1 or l2\n        return dummy.next\n\ndef build_linked_list(nums: List[int]) -> Optional[ListNode]:\n    \"\"\"Convert a Python list of ints to a linked list.\"\"\"\n    head = None\n    tail = None\n    for num in nums:\n        node = ListNode(num)\n        if not head:\n            head = tail = node\n        else:\n            tail.next = node\n            tail = node\n    return head\n\ndef linked_list_to_list(head: Optional[ListNode]) -> List[int]:\n    \"\"\"Convert a linked list back to a Python list of ints.\"\"\"\n    res = []\n    while head:\n        res.append(head.val)\n        head = head.next\n    return res\n\nif __name__ == \"__main__\":\n    # Read entire input\n    raw = sys.stdin.read().strip()\n    if not raw:\n        data = []\n    else:\n        # If the input contains an assignment like \"lists = [...]\"\n        if '=' in raw:\n            _, expr = raw.split('=', 1)\n            raw_expr = expr.strip()\n        else:\n            raw_expr = raw\n        # Safely evaluate the expression to get the list of lists\n        try:\n            data = ast.literal_eval(raw_expr)\n        except Exception:\n            data = []\n\n    # Build list of linked lists\n    linked_lists = []\n    for sub in data:\n        if isinstance(sub, list) and sub:\n            linked_lists.append(build_linked_list(sub))\n        else:\n            linked_lists.append(None)\n\n    # Merge k sorted linked lists\n    sol = Solution()\n    merged_head = sol.mergeKLists(linked_lists)\n\n    # Convert result back to Python list and print\n    result = linked_list_to_list(merged_head)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "success": true,
          "output": "[1, 1, 2, 3, 4, 4, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "lists = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "lists = [[]]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode295.json",
    "problem_index_in_file": 0,
    "title": "Find Median from Data Stream",
    "description_snippet": "The median is the middle value in an ordered integer list. If the size of the list is even, there is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step-by-step. The algorithm: maintain two heaps: max-heap for lower half, min-heap for upper half. AddNum: add to appropriate heap, rebalance. findMedian: if size equal, return average; else return top of heap with more elements.\n\nWe need to produce virtual code with steps, each line preceded by virtual code step and comment. Use arrows, decisions, etc.\n\nWe need to produce \"逐行\" code.\n\nSo start with Start, then step to initialize two heaps. Then addNum procedure: Step1: add to maxheap if empty or num <= maxheap.peek, else to minheap. Then rebalance: if maxheap.size > minheap.size+1 then move top to minheap, etc. Then findMedian: decision if sizes equal? return avg else return top of larger heap.\n\nAlso maybe implement a helper to get size. Use pseudocode constructs. Must not output actual code.\n\nWe'll output something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxHeap, minHeap // 建立兩個堆疊\n→ Function: addNum(num) // 新增數字\n    → Decision: maxHeap 為空 OR num <= maxHeap.peek()? // 判斷放入哪個堆\n        Yes → maxHeap.insert(num) // 放入下半數堆\n        No  → minHeap.insert(num) // 放入上半數堆\n    → Decision: maxHeap.size > minHeap.size + 1? // 是否需要平衡\n        Yes → minHeap.insert(maxHeap.extractMax()) // 移動最大值到 minHeap\n    → Decision: minHeap.size > maxHeap.size + 1? // 另一方\n        Yes → maxHeap.insert(minHeap.extractMin()) // 移動最小值到 maxHeap\n→ Function: findMedian() // 取得中位數\n    → Decision: maxHeap.size == minHeap.size? // 同樣數量\n        Yes → return (maxHeap.peek() + minHeap.peek()) / 2.0 // 平均\n        No  → Decision: maxHeap.size > minHeap.size? // 大的堆\n            Yes → return maxHeap.peek() // 最大堆頂\n            No  → return minHeap.peek() // 最小堆頂\nEnd // 程式結束\n\nBut each line must be a single line: \"Step 1: ... // ...\"\n\nWe must include arrow and structure. They want each line with virtual code step + comment.\n\nUse \"→ Step 1: ...\" etc. Indentation for decisions maybe use spaces.\n\nWe can structure like:\n\nStart // 程式開始執行\n→ Step 1: 建立兩個堆: maxHeap, minHeap // 用於儲存下半和上半數據\n\n→ Function: addNum(num) // 新增數字\n    → Decision: maxHeap 為空 OR num <= maxHeap.peek()? // 判斷放入哪個堆\n        Yes → maxHeap.insert(num) // 放入下半堆\n        No  → minHeap.insert(num) // 放入上半堆\n    → Decision: maxHeap.size > minHeap.size + 1? // 是否需要調整大小\n        Yes → minHeap.insert(maxHeap.extractMax()) // 移動最大值至 minHeap\n    → Decision: minHeap.size > maxHeap.size + 1?\n        Yes → maxHeap.insert(minHeap.extractMin()) // 移動最小值至 maxHeap\n\n→ Function: findMedian() // 取得中位數\n    → Decision: maxHeap.size == minHeap.size?\n        Yes → return (maxHeap.peek() + minHeap.peek()) / 2.0 // 平均\n        No  → Decision: maxHeap.size > minHeap.size?\n            Yes → return maxHeap.peek() // maxHeap 為多數\n            No  → return minHeap.peek() // minHeap 為多數\n\nEnd // 程式結束\n\nMake sure each line is separated. Each line must start with virtual code step, like \"Start\", \"→ Step 1: ...\" etc.\n\nWe should use \"→\" for steps, \"Decision:\" for decision lines, \"Yes →\" and \"No →\" for branches.\n\nSo produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxHeap, minHeap // 建立兩個堆，用於儲存下半與上半數據  \n\n→ Function: addNum(num) // 新增數字至資料結構  \n    → Decision: maxHeap 為空 OR num <= maxHeap.peek()? // 判斷該數字放入哪一堆  \n        Yes → maxHeap.insert(num) // 放入下半堆（大頂堆）  \n        No  → minHeap.insert(num) // 放入上半堆（小頂堆）  \n    → Decision: maxHeap.size > minHeap.size + 1? // 判斷是否需要平衡大小  \n        Yes → minHeap.insert(maxHeap.extractMax()) // 移動最大值到上半堆  \n    → Decision: minHeap.size > maxHeap.size + 1? // 另一種平衡情況  \n        Yes → maxHeap.insert(minHeap.extractMin()) // 移動最小值到下半堆  \n\n→ Function: findMedian() // 回傳目前所有元素的中位數  \n    → Decision: maxHeap.size == minHeap.size? // 兩堆大小相同，需計算平均值  \n        Yes → return (maxHeap.peek() + minHeap.peek()) / 2.0 // 兩個堆頂平均作為中位數  \n        No  → Decision: maxHeap.size > minHeap.size? // 哪個堆多一個元素  \n            Yes → return maxHeap.peek() // 下半堆多，返回其堆頂  \n            No  → return minHeap.peek() // 上半堆多，返回其堆頂  \n\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass MedianFinder:\n    \"\"\"兩個堆疊：small 為大頂堆（負值）儲存下半數；large 為小頂堆儲存上半數。\"\"\"\n    def __init__(self):\n        self.small = []  # 大頂堆，實際上存負值\n        self.large = []  # 小頂堆\n\n    def addNum(self, num):\n        \"\"\"將新數字加入資料結構，並保持兩堆大小平衡。\"\"\"\n        heapq.heappush(self.small, -num)  # 先放入下半堆\n        # 若兩堆不相交，將較大值移至上半堆\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 平衡堆大小：小頂堆最多比大頂堆多 1 個\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self):\n        \"\"\"回傳目前所有元素的中位數。\"\"\"\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入：方法列表與參數列表\n    if '\\n' in raw_input:\n        lines = raw_input.splitlines()\n        methods = ast.literal_eval(lines[0].strip())\n        args = ast.literal_eval(lines[1].strip())\n    else:\n        # 單行輸入，分割成兩個列表\n        idx = raw_input.find('],')\n        if idx != -1:\n            methods_str = raw_input[:idx + 1]\n            args_str = raw_input[idx + 2:]\n            methods = ast.literal_eval(methods_str.strip())\n            args = ast.literal_eval(args_str.strip())\n        else:\n            # 直接解譯為元組\n            try:\n                methods, args = ast.literal_eval(raw_input)\n            except Exception:\n                methods, args = [], []\n\n    result = []\n    obj = None\n\n    for cmd, arg in zip(methods, args):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            # arg 可能是單一數字或 [num]\n            val = arg[0] if isinstance(arg, list) else arg\n            obj.addNum(val)\n            result.append(None)\n        elif cmd == \"findMedian\":\n            median = obj.findMedian()\n            result.append(median)\n        else:\n            result.append(None)\n\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[None,None,None,1.5,None,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[None, None, None, 1.5, None, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode352.json",
    "problem_index_in_file": 0,
    "title": "Data Stream as Disjoint Intervals",
    "description_snippet": "Given a data stream input of non-negative integers a_1, a_2, ..., a_n, summarize the numbers seen so...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the SummaryRanges class with addNum and getIntervals. We need to explain each line. Virtual code style: Use Start, Decision, Step etc. We need to avoid actual code. Just structure. Let's design steps:\n\n- Start\n- Initialize data structure: list of intervals\n- addNum:\n   - Find position to insert/merge: binary search to find interval that might contain or be adjacent.\n   - If value already present, return.\n   - Determine new interval boundaries: left and right.\n   - Merge with neighboring intervals: remove them, add new merged interval.\n- getIntervals:\n   - Return copy of intervals list.\n\nWe need to express algorithmic steps in virtual code.\n\nWe must produce each line with \"虛擬碼步驟\" and comment. Use arrow symbol \"→\" at each step.\n\nWe also need Decision nodes for binary search, merging decisions.\n\nWe'll write like:\n\nStart\n→ Step 1: Initialize intervals list // 空列表\n→ Function addNum(value):\n    → Step 2: Binary search intervals to find insert position // 找出可能位置\n    → Decision: 是否存在相同 value? // 檢查重複\n        Yes → End // 已存在，無需改變\n        No → \n            → Step 3: 找到左側鄰近 interval 若 end+1 == value 或 end >= value // leftBound\n            → Step 4: 找到右側鄰近 interval 若 start-1 == value 或 start <= value // rightBound\n            → Step 5: Determine newStart, newEnd\n            → Decision: 是否需要合併左側 interval? // 取 leftBound\n                Yes → Step 6: 新 start = leftBound.start\n                No  → Step 6: 新 start = value\n            → Decision: 是否需要合併右側 interval? // 取 rightBound\n                Yes → Step 7: 新 end = rightBound.end\n                No  → Step 7: 新 end = value\n            → Step 8: 刪除被合併 interval（左、右）\n            → Step 9: 插入 new interval [newStart, newEnd]\n→ Function getIntervals:\n    → Step 10: Return copy of intervals list // sorted by start\n\nNeed to also include End at the end of each function? We can show End for main flow.\n\nLet's produce lines accordingly.\n\nWe'll use \"SummaryRanges() // 初始化空結構\" etc.\n\nUse arrows for steps inside function. Provide explanation comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: intervals ← [] // 建立一個空的區間列表  \n→ Function addNum(value): // 新增一個數字到資料流  \n    → Step 2: idx ← binarySearch(intervals, value) // 在區間列表中找到插入位置  \n    → Decision: intervals[idx] exists and intervals[idx].start ≤ value ≤ intervals[idx].end? // 判斷 value 是否已在某區間內  \n        Yes → End // 已存在，無需處理  \n        No →  \n            → Step 3: leftIdx ← idx - 1 // 右側前一個區間的索引  \n            → Step 4: rightIdx ← idx // 右側第一個區間的索引  \n            → Decision: leftIdx ≥ 0 and intervals[leftIdx].end + 1 ≥ value? // 判斷左側區間是否相鄰或覆蓋  \n                Yes → leftMerge ← true  \n                No  → leftMerge ← false  \n            → Decision: rightIdx < intervals.length and intervals[rightIdx].start - 1 ≤ value? // 判斷右側區間是否相鄰或覆蓋  \n                Yes → rightMerge ← true  \n                No  → rightMerge ← false  \n            → Step 5: newStart ← leftMerge ? intervals[leftIdx].start : value // 設定合併後的起始點  \n            → Step 6: newEnd   ← rightMerge ? intervals[rightIdx].end : value // 設定合併後的結束點  \n            → Decision: leftMerge? →  \n                Yes → Step 7: remove intervals[leftIdx] // 刪除左側被合併的區間  \n                No  → NoOp  \n            → Decision: rightMerge? →  \n                Yes → Step 8: remove intervals[rightIdx] // 刪除右側被合併的區間  \n                No  → NoOp  \n            → Step 9: insert [newStart, newEnd] at position leftIdx (or idx if leftMerge false) // 插入新的合併區間  \n→ Function getIntervals(): // 取得目前所有區間  \n    → Step 10: return copy(intervals) // 以排序好的區間列表回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass SummaryRanges:\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        new_interval = [val, val]\n        res = []\n        placed = False\n        for start, end in self.intervals:\n            if end + 1 < val:\n                res.append([start, end])\n            elif val + 1 < start:\n                if not placed:\n                    res.append(new_interval)\n                    placed = True\n                res.append([start, end])\n            else:\n                # 合併區間\n                new_interval[0] = min(start, new_interval[0])\n                new_interval[1] = max(end, new_interval[1])\n        if not placed:\n            res.append(new_interval)\n        self.intervals = res\n\n    def getIntervals(self):\n        return self.intervals\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    funcs = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    result = []\n    obj = None\n\n    for func, arg in zip(funcs, args):\n        if func == \"SummaryRanges\":\n            obj = SummaryRanges()\n            result.append(None)\n        elif func == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif func == \"getIntervals\":\n            result.append(obj.getIntervals())\n\n    # JSON 轉換，None 會被轉成 null\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "success": true,
          "output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode717.json",
    "problem_index_in_file": 0,
    "title": "1-bit and 2-bit Characters",
    "description_snippet": "We have two special characters:\\n- The first character can be represented by one bit 0.\\n- The secon...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the problem: Determine if last character must be a one-bit character given bits array ending with 0. Virtual code steps: Start, read array, iterate over array until second last element? Explanation typical algorithm: iterate i=0; while i < len(bits)-1: if bits[i]==1: i+=2 else i+=1. After loop, return true because last char is one-bit. But we need to produce explanation. Use virtual code lines. We'll output each step line with // explanation. Use arrow \"→\". Use Decision for condition. Use Start and End. Must produce line by line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 設定 i = 0 // 初始化索引指向陣列開頭\n→ Step 2: 取得 bits 長度 len // 方便比較邊界\n→ Decision: i < len - 1? // 確定還有更多位元可讀\n    Yes → Decision: bits[i] == 1? // 檢查目前位元\n        Yes → Step 3: i += 2 // 若為 1，代表二位元字符，跳過兩個位置\n        No  → Step 4: i += 1 // 若為 0，代表單位元字符，跳過一個位置\n    No  → Step 5: 回傳 true // 當 i 已到 len-1，表示最後一個字符必為單位元\nEnd // 程式執行結束\n\nWe must maintain arrow formatting. Let's include \"→\" at start of each step line. Use Step numbering or just \"Step 1\". The example shows \"Step 1:\" etc. We'll follow same style.\n\nAlso note that we need \"Yes →\" and \"No →\" for Decision branches.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化索引指向陣列開頭\n→ Step 2: len ← bits.length // 取得陣列長度\n→ Decision: i < len - 1? // 判斷是否還有多餘的位元可處理\n    Yes → Decision: bits[i] == 1? // 檢查目前位元\n        Yes → Step 3: i ← i + 2 // 位元為 1，代表二位元字符，跳過兩個位置\n        No  → Step 4: i ← i + 1 // 位元為 0，代表單位元字符，跳過一個位置\n    No  → Step 5: Return true // i 已到達 len-1，最後一個字符必為單位元\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def isOneBitCharacter(self, bits):\n        i = 0\n        n = len(bits)\n        while i < n - 1:\n            if bits[i] == 1:\n                i += 2\n            else:\n                i += 1\n        return i == n - 1\n\ndef parse_input(raw):\n    raw = raw.strip()\n    if raw.startswith('bits'):\n        _, expr = raw.split('=', 1)\n        raw = expr.strip()\n    # 使用 literal_eval 以避免 eval 風險\n    return ast.literal_eval(raw)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    bits = parse_input(data)\n    result = Solution().isOneBitCharacter(bits)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "bits = [1,0,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "bits = [1,1,1,0]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode47.json",
    "problem_index_in_file": 0,
    "title": "Permutations II",
    "description_snippet": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for generating unique permutations of a list that may contain duplicates. So typical algorithm: backtracking with used array, sort numbers, skip duplicates when same number and previous not used. Steps: Start, input nums, sort, initialize result list, call backtrack(current permutation, used bool array). In backtrack: if length equals nums length then add copy to result. Else loop i from 0 to n-1: if used[i] skip; if i>0 && nums[i]==nums[i-1] && !used[i-1] skip (to avoid duplicate). else set used[i]=true, append nums[i] to current, backtrack, pop, used[i]=false. Finally return result.\n\nWe need to output step-by-step virtual code lines with explanations. Use arrow syntax. Let's produce as requested. We'll use Start, End, Decision, Step etc.\n\nBe careful: each line contains virtual code step then space then // explanation. Use arrow '→' for steps. Decision uses \"Decision:\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Input list nums // 取得可能含重複的數字列表\n→ Step 2: Sort nums // 先排序，方便後續跳過重複\n→ Step 3: Initialize result = [] // 存放所有唯一排列\n→ Step 4: Initialize used = [False]*len(nums) // 標記每個數字是否已使用\n→ Step 5: Call Backtrack(current=[]) // 開始遞迴排列\n\nNow define Backtrack procedure:\n\nBacktrack(current):\n    → Decision: 如果 len(current) == len(nums)? // 檢查是否已排列完\n        Yes → Step 6: Append copy of current to result // 完整排列加入結果\n        No  → Step 7: For i in range(len(nums)) // 迭代每個位置\n                → Decision: 是否已使用 nums[i]? // 檢查是否已被佔用\n                    Yes → Step 8: Continue // 跳過已使用的\n                    No  → Decision: i>0 AND nums[i]==nums[i-1] AND NOT used[i-1]? // 判斷是否應跳過重複\n                        Yes → Step 9: Continue // 跳過重複元素\n                        No  → Step 10: Mark used[i] = True // 標記使用\n                                → Step 11: Append nums[i] to current // 加入當前排列\n                                → Step 12: Call Backtrack(current) // 進一步遞迴\n                                → Step 13: Remove last element from current // 回溯\n                                → Step 14: Mark used[i] = False // 取消使用標記\nEnd // 程式執行結束\n\nMake sure each line is separate and includes // explanation. We'll format exactly.\n\nLet's craft output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input list nums // 取得可能含重複的數字列表\n→ Step 2: Sort nums // 先排序，方便後續跳過重複\n→ Step 3: Initialize result = [] // 存放所有唯一排列\n→ Step 4: Initialize used = [False] * len(nums) // 標記每個數字是否已使用\n→ Step 5: Call Backtrack(current = []) // 開始遞迴排列\n\nBacktrack(current) // 進行排列的遞迴函式\n    → Decision: If len(current) == len(nums)? // 檢查是否已排列完\n        Yes → Step 6: Append a copy of current to result // 完整排列加入結果\n        No  → Step 7: For i in range(len(nums)) // 迭代每個位置\n                → Decision: If used[i]? // 檢查是否已被佔用\n                    Yes → Step 8: Continue // 跳過已使用的\n                    No  → Decision: i > 0 AND nums[i] == nums[i-1] AND NOT used[i-1]? // 判斷是否應跳過重複\n                        Yes → Step 9: Continue // 跳過重複元素\n                        No  → Step 10: Set used[i] = True // 標記使用\n                                → Step 11: Append nums[i] to current // 加入當前排列\n                                → Step 12: Call Backtrack(current) // 進一步遞迴\n                                → Step 13: Remove last element from current // 回溯\n                                → Step 14: Set used[i] = False // 取消使用標記\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\nimport json\n\nclass Solution:\n    def permuteUnique(self, nums):\n        res = []\n        nums.sort()  # 先排序方便去重\n        used = [False] * len(nums)\n\n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(path[:])\n                return\n            for i in range(len(nums)):\n                if used[i]:\n                    continue\n                if i > 0 and nums[i] == nums[i-1] and not used[i-1]:\n                    continue  # 避免重複排列\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n\n        backtrack([])\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析出列表，例如 \"nums = [1,1,2]\" 或僅 \"[1,1,2]\"\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        nums = ast.literal_eval(match.group(0))\n    else:\n        nums = ast.literal_eval(data)\n\n    solution = Solution()\n    result = solution.permuteUnique(nums)\n\n    # 輸出結果，無空格\n    print(json.dumps(result, separators=(',', ':')))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "[[1,1,2],[1,2,1],[2,1,1]]",
          "success": true,
          "output": "[[1,1,2],[1,2,1],[2,1,1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": true,
          "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode719.json",
    "problem_index_in_file": 0,
    "title": "Find K-th Smallest Pair Distance",
    "description_snippet": "The distance of a pair of integers a and b is defined as the absolute difference between a and b.\\nG...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the problem: given array nums and integer k, return the k-th smallest pair distance. Classic solution: sort array, use binary search on distance d, count pairs with distance <= d using two-pointer sliding window. Return minimal d that has at least k pairs.\n\nSo we produce step-by-step pseudocode lines with explanations.\n\nWe must output each line with virtual code step and comment. Use arrow \"→\" to show flow, and Decision: with Yes/No arrows. Include Start, End. Need to cover main steps: sort, define count function, binary search low/high, while loop, count pairs, adjust low/high, final return.\n\nLet's write line by line.\n\nStart\n→ Step 1: Sort nums in ascending order // 先把陣列排序，方便後續計數\n→ Step 2: Set low = 0 // 最小距離\n→ Step 3: Set high = nums[-1] - nums[0] // 最大距離\n→ Decision: while low < high? // 進行二分搜尋\n    Yes →\n        → Step 4: mid = (low + high) // 2 // 取中間距離\n        → Step 5: count = CountPairsWithDistanceLE(nums, mid) // 計算距離 <= mid 的對數\n        → Decision: if count >= k? // 是否足夠多對\n            Yes →\n                → Step 6: high = mid // 目標距離可能更小，縮小上界\n            No →\n                → Step 7: low = mid + 1 // 目標距離更大，調整下界\n    No → End // 當 low == high 時找到答案\n→ Step 8: Return low // low 為 k-th 最小距離\n\nWe need also to define CountPairsWithDistanceLE function.\n\nAdd separate virtual code block for that function, maybe nested. But we should maintain format. Use Start/End for function.\n\nStart // CountPairsWithDistanceLE definition\n→ Step 1: Set count = 0\n→ Step 2: Set left = 0\n→ Decision: while left < len(nums)? // 遍歷左指針\n    Yes →\n        → Step 3: While left < len(nums) and nums[right] - nums[left] <= target: // 右指針移動\n            → Step 4: right += 1\n        → Step 5: count += right - left - 1 // 右指針左邊的元素形成距離 <= target 的對\n        → Step 6: left += 1 // 移動左指針\n    No → End\n→ Step 7: Return count\n\nBut we need to output each line separately. Also ensure each line includes the comment. We must keep indent? Not required. Use arrows and decisions. We need to use \"→\" for lines, and indent decisions inside.\n\nLet's produce final answer accordingly.\n\nMake sure no actual code, only virtual code. Let's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums in ascending order // 先把陣列排序，方便後續計數  \n→ Step 2: Set low = 0 // 最小可能距離  \n→ Step 3: Set high = nums[-1] - nums[0] // 最大可能距離  \n→ Decision: while low < high? // 進行二分搜尋  \n    Yes →  \n        → Step 4: mid = (low + high) // 2 // 取中間距離作為檢查值  \n        → Step 5: count = CountPairsWithDistanceLE(nums, mid) // 計算距離 ≤ mid 的對數  \n        → Decision: if count >= k? // 對數是否足夠  \n            Yes →  \n                → Step 6: high = mid // 目標距離可能更小，縮小上界  \n            No →  \n                → Step 7: low = mid + 1 // 目標距離更大，調整下界  \n    No → End // low == high 時找到答案  \n→ Step 8: Return low // low 為第 k 小距離  \n\nStart // CountPairsWithDistanceLE 函式定義  \n→ Step 1: Set count = 0 // 初始化對數  \n→ Step 2: Set left = 0 // 左指針初始位置  \n→ Step 3: Set right = 1 // 右指針初始位置  \n→ Decision: while left < len(nums)? // 迭代左指針  \n    Yes →  \n        → Decision: while right < len(nums) and nums[right] - nums[left] <= target? // 右指針向右擴展  \n            Yes →  \n                → Step 4: right += 1 // 右指針右移  \n            No →  \n                → Step 5: count += right - left - 1 // 計算左指針與右指針左側元素的對數  \n                → Step 6: left += 1 // 左指針右移  \n    No → End  \n→ Step 7: Return count // 回傳距離 ≤ target 的對數  \nEnd // 函式結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def smallestDistancePair(self, nums, k):\n        nums.sort()\n\n        def count_pairs(mid):\n            count = 0\n            left = 0\n            for right in range(len(nums)):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            return count\n\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            if count_pairs(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input():\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], 0\n\n    # Extract list\n    m_list = re.search(r'\\[.*?\\]', data)\n    if m_list:\n        nums = ast.literal_eval(m_list.group(0))\n    else:\n        nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # Extract k\n    m_k = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if m_k:\n        k = int(m_k.group(1))\n    else:\n        # Assume last integer is k if not explicitly given\n        nums_ints = list(map(int, re.findall(r'-?\\d+', data)))\n        if nums_ints:\n            k = nums_ints[-1]\n            if isinstance(nums, list) and len(nums) > 1:\n                nums = nums_ints[:-1]\n            else:\n                nums = nums_ints[:-1]\n        else:\n            k = 0\n    return nums, k\n\nif __name__ == \"__main__\":\n    nums, k = parse_input()\n    solution = Solution()\n    result = solution.smallestDistancePair(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,1], k = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1], k = 2",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1,6,1], k = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode452.json",
    "problem_index_in_file": 0,
    "title": "Minimum Number of Arrows to Burst Balloons",
    "description_snippet": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving min arrows to burst balloons. This is classic Leetcode 452. We will produce stepwise pseudocode. Provide each line with explanation. Use arrow structures.\n\nWe need to start, sort points by end, iterate, count arrows, etc.\n\nLet's craft.\n\nStart // start\n→ Step 1: Sort the array points based on x_end in ascending order // ordering balloons by rightmost point\n\n→ Step 2: Initialize arrow_count = 0 // counter for arrows\n→ Step 3: Initialize current_arrow_x = null // position of last arrow shot\n\n→ Decision: If points is empty? // handle empty case\n    Yes → End // no arrows needed\n    No  →\n\n→ For each balloon in points: // iterate through sorted balloons\n    → Decision: If current_arrow_x is null OR balloon.x_start > current_arrow_x? // balloon not covered by current arrow\n        Yes → Step 4: Increment arrow_count // new arrow needed\n        → Step 5: Set current_arrow_x = balloon.x_end // shoot arrow at this balloon's right end\n        No  → // current arrow already covers this balloon, do nothing\n\n→ End // return arrow_count\n\nAdd explanations after each line. Ensure proper formatting. Use \"→\" before steps. Include decision lines. Should be fine.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort points by x_end ascending // 先依右端座標由小到大排序，方便後續統計  \n→ Step 2: Initialize arrow_count = 0 // 記錄發射箭的數量  \n→ Step 3: Initialize current_arrow_x = null // 目前最後一次射出的箭所經過的 x 座標  \n→ Decision: points 是否為空? // 先處理無氣球的特殊情況  \n Yes → End // 空陣列不需要箭，直接結束  \n No  → // 繼續執行下面的迴圈  \n→ For each balloon in points: // 依序遍歷已排序的氣球  \n → Decision: current_arrow_x 為 null 或 balloon.x_start > current_arrow_x? // 目前箭無法覆蓋此氣球？  \n  Yes → Step 4: arrow_count++ // 需要新增箭  \n   → Step 5: current_arrow_x = balloon.x_end // 射箭於此氣球的右端（最大覆蓋）  \n  No  → // 目前箭已覆蓋此氣球，無需新增箭  \n→ End // 程式結束，返回 arrow_count（已在外部返回）",
      "generated_code": "import sys\nimport ast\n\ndef find_min_arrows(points):\n    \"\"\"\n    以右端點排序後掃描，統計最少射箭數量。\n    \"\"\"\n    if not points:\n        return 0\n\n    # 依右端座標遞增排序\n    points.sort(key=lambda x: x[1])\n\n    arrows = 1\n    current_end = points[0][1]\n\n    # 遍歷剩餘氣球\n    for start, end in points[1:]:\n        # 若右端已超過目前箭的覆蓋範圍，需要新箭\n        if start > current_end:\n            arrows += 1\n            current_end = end\n\n    return arrows\n\ndef main():\n    \"\"\"\n    從 stdin 讀取 'points = [[...]]' 或直接 '[...]' 的字串，\n    解析成 list of lists，計算並輸出最少射箭數量。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 可能含有 \"points =\"，去除之\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # 用安全方式評估字串為 Python 物件\n    points = ast.literal_eval(expr)\n\n    result = find_min_arrows(points)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode123.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock III",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\n\nFind t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve problem: maximum profit with at most two transactions. Use DP or track best profits.\n\nWe need to output in the required format, each line: \"虛擬碼步驟 // 解釋/說明\"\n\nUse Start, Decision etc.\n\nWe need to structure algorithm:\n\n1. If array empty or length < 2, profit 0.\n\n2. Initialize four variables: firstBuy = -∞, firstSell = 0, secondBuy = -∞, secondSell = 0.\n\n3. Iterate over prices:\n\n- firstBuy = max(firstBuy, -price) // max profit after first buy (loss)\n- firstSell = max(firstSell, firstBuy + price) // profit after first sell\n- secondBuy = max(secondBuy, firstSell - price) // profit after second buy using profit from first sell\n- secondSell = max(secondSell, secondBuy + price) // final profit after second sell\n\n4. Result is secondSell.\n\nWe need to output steps with arrow etc. Each step is a line. Could use Decision for array empty.\n\nLet's produce:\n\nStart\n→ Decision: 若 prices 为空或長度<2? // 判斷是否需要返回0\n    Yes → Step: return 0 // 沒有足夠天數進行交易\n    No → Step: 初始化變量 firstBuy, firstSell, secondBuy, secondSell // 設定初始狀態\n\n→ For each price in prices: // 遍歷每日價格\n    → Step: firstBuy = max(firstBuy, -price) // 以第一筆買進為基礎\n    → Step: firstSell = max(firstSell, firstBuy + price) // 以第一筆賣出計算利潤\n    → Step: secondBuy = max(secondBuy, firstSell - price) // 以第二筆買進並利用前一次賣出利潤\n    → Step: secondSell = max(secondSell, secondBuy + price) // 以第二筆賣出完成交易\n\n→ Step: return secondSell // 最終最大利潤\n\nEnd\n\nBut need each line with virtual code and explanation. Use arrow symbol. For loops, we might use \"→ For each price in prices:\". But need to maintain the structure. Use \"→ Step:\" lines.\n\nLet's write:\n\nStart // 程式開始執行\n→ Decision: 如果 prices 為空或長度 < 2? // 檢查是否能進行交易\n    Yes → Step: return 0 // 無法交易，利潤為 0\n    No  → Step: 初始化 firstBuy = -∞, firstSell = 0, secondBuy = -∞, secondSell = 0 // 設定初始變數\n→ For each price in prices: // 遍歷每日價格\n    → Step: firstBuy = max(firstBuy, -price) // 以第一筆買進更新最大虧損\n    → Step: firstSell = max(firstSell, firstBuy + price) // 以第一筆賣出更新最大利潤\n    → Step: secondBuy = max(secondBuy, firstSell - price) // 以第二筆買進更新最大虧損\n    → Step: secondSell = max(secondSell, secondBuy + price) // 以第二筆賣出更新最大利潤\n→ Step: return secondSell // 最終最大利潤\nEnd // 程式執行結束\n\nBut note: Use \"Yes →\" and \"No →\" indent. But the requirement: Use虛擬碼的箭頭 (`→`, `Yes →`, `No →`) and結構(`Start`, `End`, `Decision:`). So we should follow that.\n\nWe should also include \"Step:\" with the arrow and explanation. Let's align:\n\nStart // 程式開始執行\n→ Decision: 如果 prices 為空或長度 < 2? // 判斷是否能進行交易\n    Yes → Step: return 0 // 沒有足夠天數，利潤為 0\n    No  → Step: firstBuy = -∞, firstSell = 0, secondBuy = -∞, secondSell = 0 // 初始化四個狀態變數\n→ For each price in prices: // 遍歷每日價格\n    → Step: firstBuy = max(firstBuy, -price) // 更新第一筆買入後的最大虧損\n    → Step: firstSell = max(firstSell, firstBuy + price) // 更新第一筆賣出後的最大利潤\n    → Step: secondBuy = max(secondBuy, firstSell - price) // 更新第二筆買入後的最大虧損\n    → Step: secondSell = max(secondSell, secondBuy + price) // 更新第二筆賣出後的最大利潤\n→ Step: return secondSell // 輸出最終最大利潤\nEnd // 程式執行結束\n\nEnsure formatting: Each line begins with arrow if part of decision. The start and end lines no arrow.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 prices 為空或長度 < 2? // 判斷是否能進行交易  \n Yes → Step: return 0 // 沒有足夠天數，利潤為 0  \n No  → Step: firstBuy = -∞, firstSell = 0, secondBuy = -∞, secondSell = 0 // 初始化四個狀態變數  \n→ For each price in prices: // 遍歷每日價格  \n → Step: firstBuy = max(firstBuy, -price) // 更新第一筆買入後的最大虧損  \n → Step: firstSell = max(firstSell, firstBuy + price) // 更新第一筆賣出後的最大利潤  \n → Step: secondBuy = max(secondBuy, firstSell - price) // 更新第二筆買入後的最大虧損  \n → Step: secondSell = max(secondSell, secondBuy + price) // 更新第二筆賣出後的最大利潤  \n→ Step: return secondSell // 輸出最終最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_profit(prices):\n    if not prices:\n        return 0\n    buy1 = float('-inf')\n    sell1 = 0\n    buy2 = float('-inf')\n    sell2 = 0\n    for price in prices:\n        buy1 = max(buy1, -price)\n        sell1 = max(sell1, buy1 + price)\n        buy2 = max(buy2, sell1 - price)\n        sell2 = max(sell2, buy2 + price)\n    return sell2\n\ndef parse_input(text):\n    text = text.strip()\n    if text.startswith(\"prices\"):\n        _, _, rest = text.partition(\"=\")\n        text = rest.strip()\n    return ast.literal_eval(text)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    prices = parse_input(data)\n    result = max_profit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode57.json",
    "problem_index_in_file": 0,
    "title": "Insert Interval",
    "description_snippet": "You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for inserting an interval. Use Start, Decision, etc. Need to output line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrows → etc.\n\nLet's craft algorithm: Input intervals sorted. newInterval.\n\nWe need to iterate through intervals, building result. Three cases: interval end < new start -> add to result; interval start > new end -> add new interval if not added then add current; else overlap -> merge newInterval's start=min, end=max.\n\nAfter loop, if newInterval not added, append. Return result.\n\nWe'll produce pseudocode lines accordingly.\n\nMake sure each line includes arrow.\n\nLet's output something like:\n\nStart // 程式開始\n\n→ Step 1: 初始化 result = [] // 建立結果陣列\n\n→ Step 2: 初始化 inserted = False // 標記 newInterval 是否已插入\n\n→ Step 3: 對於每個 interval in intervals 迴圈 // 遍歷所有間隔\n\n→ Decision: 如果 interval.end < newInterval.start? // 檢查是否完全在新間隔前面\n\n→ Yes → Step 4: 把 interval 加入 result // 添加不重疊的舊間隔\n\n→ No → Decision: 如果 interval.start > newInterval.end? // 檢查是否完全在新間隔後面\n\n→ Yes → Step 5: 如果 inserted 為 False → Step 6: 把 newInterval 加入 result // 插入 newInterval\n\n→ Yes → Step 7: 把 interval 加入 result // 添加舊間隔\n\n→ No → Step 8: newInterval.start = min(newInterval.start, interval.start) // 合併起始點\n\n→ No → Step 9: newInterval.end = max(newInterval.end, interval.end) // 合併結束點\n\nAfter loop, check if inserted false -> add newInterval.\n\n→ Decision: 如果 inserted 為 False? // 判斷是否還沒加入\n\n→ Yes → Step 10: 把 newInterval 加入 result // 將未加入的 newInterval 添加\n\n→ End // 返回 result\n\nWe need to use arrow formatting. Also mention return.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result = [] // 建立一個空的結果陣列  \n→ Step 2: 初始化 inserted = False // 標記 newInterval 是否已插入  \n→ Step 3: 對於每個 interval 在 intervals 中進行迴圈 // 遍歷所有已排序的區間  \n→ Decision: interval.end < newInterval.start? // 檢查該區間是否完全在新區間之前  \n Yes → Step 4: 把 interval 加入 result // 直接加入不重疊的舊區間  \n No → Decision: interval.start > newInterval.end? // 檢查該區間是否完全在新區間之後  \n  Yes → Decision: inserted 為 False? // 判斷 newInterval 是否已插入  \n   Yes → Step 5: 把 newInterval 加入 result // 插入 newInterval  \n    → Step 6: 把 interval 加入 result // 再加入該區間  \n   No → Step 7: 把 interval 加入 result // 新區間已插入，直接加入舊區間  \n  No → Step 8: newInterval.start = min(newInterval.start, interval.start) // 合併區間起點  \n   → Step 9: newInterval.end = max(newInterval.end, interval.end) // 合併區間終點  \n→ Decision: inserted 為 False? // 循環結束後檢查 newInterval 是否還未加入  \n Yes → Step 10: 把 newInterval 加入 result // 將未插入的 newInterval 加入  \n No → // 已經插入，無需額外動作  \nEnd // 程式結束，返回 result 這個合併後的區間列表",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals.\n        Merge any overlapping intervals.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 1. Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 2. Merge all intervals that overlap with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        result.append(newInterval)\n\n        # 3. Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(text):\n    \"\"\"\n    Parse input of the form:\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    Returns a tuple (intervals, newInterval).\n    \"\"\"\n    pattern = r'intervals\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*newInterval\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, text, re.S)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    intervals_str, new_str = match.groups()\n    intervals = ast.literal_eval(intervals_str)\n    new_interval = ast.literal_eval(new_str)\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        sys.exit(0)\n\n    # Parse the input\n    intervals, new_interval = parse_input(input_text)\n\n    # Compute the result\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n\n    # Output the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpby1lto9h.py\", line 56, in <module>\n    intervals, new_interval = parse_input(input_text)\n                              ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpby1lto9h.py\", line 43, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp__875il0.py\", line 56, in <module>\n    intervals, new_interval = parse_input(input_text)\n                              ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp__875il0.py\", line 43, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode592.json",
    "problem_index_in_file": 0,
    "title": "Fraction Addition and Subtraction",
    "description_snippet": "Given a string expression representing an expression of fraction addition and subtraction, return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this algorithm: parse expression of fractions addition/subtraction, compute result as reduced fraction, output as string with denominator 1 if integer. Provide step by step virtual code with explanations. Use arrows, decisions, etc.\n\nWe should show steps: Start, Input expression, Initialize numerator=0, denominator=1, parse tokens, for each token parse fraction, compute lcm or use formula: a/b + c/d = (a*d + b*c)/(b*d) then reduce using gcd. Similarly for subtraction. We maintain current fraction. Then after processing all tokens, reduce final fraction, format string. Output. End.\n\nWe need to include decision for parsing token signs. Provide example: token may start with '+' or '-'. We parse numerator and denominator. Then update current fraction accordingly. Use gcd for reduction after each operation maybe. Finally output.\n\nAlso handle negative results.\n\nUse virtual code lines with comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字符串 `expr` // 取得用戶輸入的分式加減式  \n→ Step 2: 初始化 `num = 0`, `den = 1` // 設定累積結果為 0/1  \n→ Step 3: 將 `expr` 以空白分割為 `tokens` // 取得每個分式或符號  \n→ Decision: 若第一個 token 為 '+' 或 '-'? // 判斷第一個符號  \n  Yes → Step 4: 設 `sign = 1` if '+' else `-1` // 記錄符號  \n  No → Step 4: 設 `sign = 1` // 預設正號  \n→ Step 5: 將第一個 token 轉為數字或分式並乘以 `sign` // 處理首項  \n  If token 為分式 'a/b' → 計算 `num = a * den + sign * num * b`, `den = den * b` // 加法/減法公式  \n  若 token 為純數字 'c' → treat as `c/1` 同上  \n→ Step 6: 重新化簡 `num/den` 用 `gcd` // 把分數約簡到最簡  \n→ Step 7: 將 `tokens` 從第二項開始循環  \n  → Decision: 取 token 為符號 '+' 或 '-'?  \n   Yes → 設 `sign = 1` if '+' else `-1` // 記號  \n   No → 直接為分式或數字  \n  → Step 8: 取下一個 token 為分式或數字，計算 `a/b` (若為數字，b=1)  \n  → Step 9: 更新 `num = num * b + sign * a * den`, `den = den * b` // 加/減  \n  → Step 10: 重新化簡 `num/den` 用 `gcd` // 逐步約簡  \n→ Step 11: 取得最終 `num`, `den` // 完成所有計算  \n→ Step 12: 若 `den < 0` → 取 `num = -num`, `den = -den` // 保證分母正數  \n→ Step 13: 用 `gcd` 再次化簡 `num/den` // 最終約簡  \n→ Step 14: 構造輸出字串 `result = f\"{num}/{den}\"` // 將結果轉為字串  \n→ End // 程式執行結束\n\n---  \n**說明**  \n- 以上步驟使用逐行虛擬碼，包含決策節點與算式更新。  \n- `gcd` 為最大公因數函式，確保分數永遠保持最簡。  \n- 任何負數結果都會在分子中保留符號，分母保持正數。  \n- 整數結果如 `2` 會以 `2/1` 形式輸出，因為 `den` 為 1。",
      "generated_code": "import sys\nimport re\nfrom fractions import Fraction\n\ndef fraction_addition(expression: str) -> str:\n    \"\"\"\n    計算由分式加減組成的表達式，並將結果轉換為最簡分式字串。\n    \"\"\"\n    # 取出所有形如 [+/-]a/b 的分式\n    fractions = re.findall(r'[+-]?\\d+/\\d+', expression)\n    # 用 Fraction 進行精確計算\n    total = sum(Fraction(frac) for frac in fractions)\n    return f\"{total.numerator}/{total.denominator}\"\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 先嘗試從字串中尋找「expression = \"...\"」格式\n    match = re.search(r'\\\"([^\\\"]+)\\\"', raw_input)\n    if match:\n        expr = match.group(1)\n    else:\n        # 若沒有引號，直接把輸入視為表達式\n        expr = raw_input\n\n    result = fraction_addition(expr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"-1/2+1/2\"",
          "expected_output": "0/1",
          "success": true,
          "output": "0/1"
        },
        {
          "example_index": 1,
          "input": "expression = \"-1/2+1/2+1/3\"",
          "expected_output": "1/3",
          "success": true,
          "output": "1/3"
        },
        {
          "example_index": 2,
          "input": "expression = \"1/3-1/2\"",
          "expected_output": "-1/6",
          "success": true,
          "output": "-1/6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode624.json",
    "problem_index_in_file": 0,
    "title": "Maximum Distance in Arrays",
    "description_snippet": "You are given m arrays, where each array is sorted in ascending order.\nYou can pick up two integers ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for the problem: Given m sorted arrays, pick one integer from each of two different arrays to maximize absolute difference |a-b|. Equivalent: find maximum value in one array and minimum in another array across all pairs of arrays? Actually max distance occurs between a max from one array and min from another. But careful: we can pick any two arrays, so we want the maximum difference between any number in array i and any number in array j (i != j). Since arrays sorted ascending, each array has min and max. The maximum absolute difference among all pairs is max over all pairs (max_i - min_j) or (max_j - min_i). Which simplifies to overall max element minus overall min element but ensure they come from different arrays. If overall max and overall min are from the same array, we cannot pick both from same array. Then we need second best. So algorithm: compute global max value and its array index, global min value and its array index. If indices differ, answer = global max - global min. Else we need consider alternatives: either max from that array and min from any other array, or min from that array and max from any other array. So we compute candidate1 = max_value - second_min_value (where second_min is min from different array), candidate2 = second_max_value - min_value. Take max.\n\nWe need produce virtual code line by line with comments. Provide Start, End, Decision etc. Also maybe loops. Use Decision lines. We don't produce actual code but structure.\n\nLet's write pseudocode.\n\nStart\n\n→ Step 1: Initialize variables globalMax = -∞, globalMaxIdx = -1, globalMin = +∞, globalMinIdx = -1\n\n→ Step 2: For each array i from 0 to m-1: // iterate over arrays\n\n→ Decision: Is array i empty? // skip empty\n\n    Yes → Continue // or skip\n\n    No → Step 3: Let localMax = last element of array i, localMin = first element\n\n→ Decision: localMax > globalMax? // update global max\n\n    Yes → Step 4: globalMax = localMax; globalMaxIdx = i\n\n→ Decision: localMin < globalMin? // update global min\n\n    Yes → Step 5: globalMin = localMin; globalMinIdx = i\n\nEnd of for loop.\n\n→ Decision: globalMaxIdx != globalMinIdx? // they are from different arrays\n\n    Yes → Step 6: answer = globalMax - globalMin; goto End\n\n    No → Step 7: // need to find second extremes\n\n→ Step 8: Initialize secondMax = -∞, secondMaxIdx = -1, secondMin = +∞, secondMinIdx = -1\n\n→ Step 9: For each array i from 0 to m-1:\n\n→ Decision: i == globalMaxIdx? // skip the array containing global max\n\n    Yes → Continue\n\n    No → Decision: array i not empty? // to avoid empty\n\n        Yes → Step 10: localMax = last element; if localMax > secondMax → update secondMax, secondMaxIdx\n\n→ Step 11: For each array i from 0 to m-1:\n\n→ Decision: i == globalMinIdx? // skip array containing global min\n\n    Yes → Continue\n\n    No → Decision: array i not empty?\n\n        Yes → Step 12: localMin = first element; if localMin < secondMin → update secondMin, secondMinIdx\n\nAfter loops\n\n→ Step 13: candidate1 = globalMax - secondMin // max minus min from other array\n\n→ Step 14: candidate2 = secondMax - globalMin // min minus max from other array\n\n→ Step 15: answer = max(candidate1, candidate2)\n\nEnd\n\nWe need to adhere to format: Each line with virtual code plus comment. Use arrows and indent.\n\nUse decision blocks with Yes → and No → lines. Indentation maybe 4 spaces.\n\nLet's craft.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: globalMax = -∞; globalMaxIdx = -1; globalMin = +∞; globalMinIdx = -1 // 初始化全局最大、最小值及其陣列索引\n→ Step 2: For each array i from 0 to m-1 // 遍歷所有陣列\n    → Decision: 是否為空陣列? // 檢查是否有元素\n        Yes → Continue // 空陣列直接跳過\n        No → Step 3: localMax = last element of array i; localMin = first element of array i // 取本陣列的最大與最小值\n    → Decision: localMax > globalMax? // 更新全局最大\n        Yes → Step 4: globalMax = localMax; globalMaxIdx = i\n    → Decision: localMin < globalMin? // 更新全局最小\n        Yes → Step 5: globalMin = localMin; globalMinIdx = i\n→ Decision: globalMaxIdx != globalMinIdx? // 全局最大與最小來自不同陣列？\n    Yes → Step 6: answer = globalMax - globalMin // 直接取全局最大與最小之差作為答案\n    No → Step 7: // 全局最大與最小來自同一個陣列，需要找第二極值\n→ Step 8: secondMax = -∞; secondMaxIdx = -1; secondMin = +∞; secondMinIdx = -1 // 初始化第二大與第二小\n→ Step 9: For each array i from 0 to m-1 // 再次遍歷陣列尋找第二大值\n    → Decision: i == globalMaxIdx? // 跳過全局最大所在陣列\n        Yes → Continue\n        No → Decision: 是否為空陣列?\n            Yes → Continue\n            No → Step 10: localMax = last element of array i\n            → Decision: localMax > secondMax?\n                Yes → Step 11: secondMax = localMax; secondMaxIdx = i\n→ Step 12: For each array i from 0 to m-1 // 再次遍歷陣列尋找第二小值\n    → Decision: i == globalMinIdx? // 跳過全局最小所在陣列\n        Yes → Continue\n        No → Decision: 是否為空陣列?\n            Yes → Continue\n            No → Step 13: localMin = first element of array i\n            → Decision: localMin < secondMin?\n                Yes → Step 14: secondMin = localMin; secondMinIdx = i\n→ Step 15: candidate1 = globalMax - secondMin // 全局最大與第二小之差\n→ Step 16: candidate2 = secondMax - globalMin // 第二大與全局最小之差\n→ Step 17: answer = max(candidate1, candidate2) // 取兩種方案中的最大距離\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxDistance(self, arrays):\n        # Initialize with first non‑empty array\n        i = 0\n        while i < len(arrays) and not arrays[i]:\n            i += 1\n        if i == len(arrays):\n            return 0  # all arrays empty\n\n        min_val = arrays[i][0]\n        max_val = arrays[i][-1]\n        res = 0\n\n        for arr in arrays[i+1:]:\n            if not arr:\n                continue\n            # consider extremes with current global extremes\n            res = max(res, abs(arr[-1] - min_val), abs(max_val - arr[0]))\n            # update global extremes\n            min_val = min(min_val, arr[0])\n            max_val = max(max_val, arr[-1])\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the part after 'arrays ='\n    match = re.search(r'arrays\\s*=\\s*(.+)', data, re.S)\n    if match:\n        arr_str = match.group(1)\n    else:\n        arr_str = data\n\n    # Safely evaluate the list of lists\n    try:\n        arrays = eval(arr_str, {\"__builtins__\": None}, {})\n    except Exception:\n        print(0)\n        return\n\n    result = Solution().maxDistance(arrays)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arrays = [[1,2,3],[4,5],[1,2,3]]",
          "expected_output": " 4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": " arrays = [[1],[1]]",
          "expected_output": " 0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode20.json",
    "problem_index_in_file": 0,
    "title": "Valid Parentheses",
    "description_snippet": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the in...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line steps, each line: \"虛擬碼步驟 // 解釋\". Use arrow '→', 'Yes →', 'No →', 'Decision:' etc.\n\nWe should produce algorithm: Use stack to push opening brackets, when encounter closing bracket, check top matches. If mismatch or empty, invalid. At end, stack empty then valid.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化空棧 stack // 用於儲存開括號\n→ Step 2: 對於字串 s 中的每個字符 c // 逐字處理\n    → Decision: 如果 c 是 '(' 或 '[' 或 '{'? // 判斷是否為開括號\n        Yes → Step 3: 將 c 推入 stack // 記錄開括號\n        No  → Decision: c 是 ')' 或 ']' 或 '}'? // 判斷是否為關括號\n            Yes → Decision: stack 是否為空? // 若無開括號可配對\n                No  → Step 4: top = stack.pop() // 取出最上層開括號\n                Yes → Step 5: 返回 False // 關括號無匹配\n            No  → Step 6: 返回 False // 遇到非括號字符\n→ Step 7: Decision: stack 是否為空? // 仍有未閉合的開括號\n    Yes → Step 8: 返回 True // 字串有效\n    No  → Step 9: 返回 False // 有未閉合的開括號\nEnd\n\nBut we need to use arrow formatting properly: \"Start // 程式開始執行\". Use \"→\" for steps, indent for decisions and branches. Provide concise explanation. Let's produce final output.\n\nAlso we need to include \"Decision:\" lines with appropriate formatting.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 stack // 用於儲存開括號  \n→ Step 2: 對於字串 s 中的每個字符 c // 逐字處理  \n → Decision: c 是否為 '('、'['、'{'? // 判斷是否為開括號  \n  Yes → Step 3: 將 c 推入 stack // 記錄開括號  \n  No → Decision: c 是否為 ')'、']'、'}'? // 判斷是否為關括號  \n   Yes → Decision: stack 為空? // 是否有可配對的開括號  \n    No → Step 4: top = stack.pop() // 取出最上層開括號  \n     Decision: top 與 c 對應? // 檢查類型是否匹配  \n      Yes → Step 5: 繼續處理下一個字符 // 匹配成功  \n      No → Step 6: 返回 False // 類型不匹配，字串無效  \n    Yes → Step 7: 返回 False // 關括號但棧空，無匹配  \n  No → Step 8: 返回 False // 遇到非括號字符，字串無效  \n→ Step 9: Decision: stack 是否為空? // 確認所有開括號已閉合  \n Yes → Step 10: 返回 True // 字串有效  \n No  → Step 11: 返回 False // 有未閉合的開括號  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef is_valid(s: str) -> bool:\n    \"\"\"\n    使用棧判斷括號是否匹配。\n    \"\"\"\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for ch in s:\n        if ch in mapping:          # 遇到閉括號\n            if not stack or stack[-1] != mapping[ch]:\n                return False      # 無對應開括號或類型不符\n            stack.pop()\n        else:                       # 遇到開括號\n            if ch in '([{':\n                stack.append(ch)\n            # 其他字符忽略\n    return not stack                # 若棧空則所有括號均已閉合\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    data = sys.stdin.read()\n    if not data:\n        sys.exit()\n\n    # 從輸入中提取括號字串\n    # 先找第一個雙引號和最後一個雙引號之間的內容\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        s = data[start + 1:end]\n    else:\n        # 若沒有雙引號，嘗試去掉前面的「s =」與空白\n        s = data.strip()\n        if s.lower().startswith('s ='):\n            s = s[3:].strip()\n\n    # 判斷是否有效並輸出結果\n    print('true' if is_valid(s) else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 3,
          "input": "s = \"([])\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 4,
          "input": "s = \"([)]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode204.json",
    "problem_index_in_file": 0,
    "title": "Count Primes",
    "description_snippet": "Given an integer n, return the number of prime numbers that are strictly less than n....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo-code for: given integer n, return count of primes less than n. Use steps: start, input n, generate primes less than n (Sieve of Eratosthenes). Count. Return. End. Must include arrows, Decision: etc. Provide explanation after each line. Should not output actual code, just virtual code. Let's produce each line. Ensure format: \"Start // ...\" etc.\n\nLet's write: Start. Input n. Decision: if n <=2? Because primes less than n count 0 for n<=2. Yes branch. Then Step: Initialize array isPrime[0..n-1] set true, then mark 0,1 false. Loop i from 2 to sqrt(n-1) if isPrime[i] then mark multiples. Count primes by iterating array. Return count. End.\n\nLet's produce line by line. Use arrow lines. Provide short explanation.\n\nLet's produce maybe: \n\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得輸入值\n→ Decision: n <= 2? // 若 n 小於或等於 2，則無小於 n 的素數\n    Yes → Step 2: 回傳 0 // 直接回傳 0\n    No  → Step 3: 建立布林陣列 isPrime[0…n-1]，並設定所有值為 true // 為所有小於 n 的數字預設為可能素數\n→ Step 4: 設定 isPrime[0] = false, isPrime[1] = false // 0 和 1 不是素數\n→ Step 5: 計算上限 = floor(sqrt(n-1)) // 只需檢查到 sqrt(n-1)\n→ Decision: 上限 < 2? // 如果上限小於 2，則不需要進一步標記\n    Yes → Step 6: 跳過標記\n    No  → Loop i from 2 to 上限\n        → Decision: isPrime[i] 為 true? // 只對仍被視為素數的 i 進行標記\n            Yes → Loop j from i*i to n-1 step i\n                → Step 7: 設定 isPrime[j] = false // 標記 i 的倍數為非素數\n→ Step 8: 初始化 count = 0 // 累計素數個數\n→ Loop k from 2 to n-1\n    → Decision: isPrime[k] 為 true? // 若 k 為素數\n        Yes → Step 9: count = count + 1 // 累加\n→ Step 10: 回傳 count // 輸出結果\nEnd // 程式執行結束\n\nCheck formatting: each line start with arrow maybe? Use \"→\" before each step except decisions? Provide indentation. Use \"Decision:\" lines with branches.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得輸入值  \n→ Decision: n <= 2? // 若 n 小於或等於 2，則無小於 n 的素數  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2: 回傳 0 // 直接回傳 0  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 3: 建立布林陣列 isPrime[0…n-1]，並設定所有值為 true // 為所有小於 n 的數字預設為可能素數  \n→ Step 4: 設定 isPrime[0] = false, isPrime[1] = false // 0 和 1 不是素數  \n→ Step 5: 計算上限 = floor(sqrt(n-1)) // 只需檢查到 sqrt(n-1)  \n→ Decision: 上限 < 2? // 如果上限小於 2，則不需要進一步標記  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: 跳過標記  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Loop i from 2 to 上限  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: isPrime[i] 為 true? // 只對仍被視為素數的 i 進行標記  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Loop j from i*i to n-1 step i  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: 設定 isPrime[j] = false // 標記 i 的倍數為非素數  \n→ Step 8: 初始化 count = 0 // 累計素數個數  \n→ Loop k from 2 to n-1  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: isPrime[k] 為 true? // 若 k 為素數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 9: count = count + 1 // 累加  \n→ Step 10: 回傳 count // 輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_primes(n: int) -> int:\n    \"\"\"\n    Return the number of prime numbers strictly less than n.\n    Uses the Sieve of Eratosthenes.\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    limit = int(n ** 0.5) + 1\n    for i in range(2, limit):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n\n    return sum(is_prime)\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract the first integer found in the input\n    match = re.search(r'-?\\d+', data)\n    if match:\n        n = int(match.group())\n    else:\n        # If no integer is found, default to 0\n        n = 0\n\n    result = count_primes(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode264.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number II",
    "description_snippet": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. \n\nGiven an inte...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode) line by line with explanations. The problem: find nth ugly number (numbers whose prime factors only 2,3,5). Classic problem: Use DP with three pointers.\n\nWe output lines with virtual code steps and explanation, using arrow \"→\". Need to follow output format: each line includes \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow \"→\" as step. Use Start, End, Decision: etc.\n\nWe need to produce a clear algorithm: initialize array ugly[1..n] = [1], pointers i2,i3,i5 = 1. For each k from 2 to n, compute next = min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5). Set ugly[k] = next. Then increment any pointer whose multiple equals next. After loop, return ugly[n]. That’s algorithm.\n\nWe need to output line by line. Should we include loops etc. Provide pseudo-code with comments.\n\nLet's create virtual code:\n\nStart // 程式開始執行\n→ Step 1: 初始化 ugly[1] = 1 // 設定第一個醜數為 1\n→ Step 2: 初始化指標 i2 = 1, i3 = 1, i5 = 1 // 用於追蹤 2,3,5 的下一個乘法來源\n→ Step 3: 如果 n == 1, 返回 ugly[1] // 直接回傳第一個醜數\n→ Step 4: 循環 k 從 2 到 n // 生成剩餘醜數\n    → Decision: 計算 next = min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5) // 找出三個候選的最小值\n        Yes → Step 5: ugly[k] = next // 存入第 k 個醜數\n    → Decision: 如果 ugly[i2]*2 == next? // 若 2 的候選等於 next\n        Yes → Step 6: i2 = i2 + 1 // 移動 2 的指標\n    → Decision: 如果 ugly[i3]*3 == next? // 若 3 的候選等於 next\n        Yes → Step 7: i3 = i3 + 1 // 移動 3 的指標\n    → Decision: 如果 ugly[i5]*5 == next? // 若 5 的候選等於 next\n        Yes → Step 8: i5 = i5 + 1 // 移動 5 的指標\n→ Step 9: 返回 ugly[n] // 完成後回傳第 n 個醜數\nEnd // 程式執行結束\n\nBut need to adhere to format: each line \"虛擬碼步驟\" + \" // 解釋\". The arrow \"→\" used to indicate step. For decisions, use \"Decision: ...\". The indentation maybe optional.\n\nWe must not output actual code. Just virtual steps. We can include indentation but keep format same.\n\nLet's produce final output. Use \"Start\" and \"End\". Use \"Decision:\" for decisions. Use \"Yes →\", \"No →\" maybe but we only have one path each time.\n\nWe need to include steps like \"Step 1:\" etc. Use \"→\" for each step. For decision steps we also use \"Decision:\" line then \"Yes →\" lines.\n\nLet's output exactly as per example format.\n\nMake sure each line contains arrow \"→\" or \"Start\" or \"End\" etc. Provide explanation after \"//\".\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 ugly[1] = 1 // 第一個醜數一定是 1  \n→ Step 2: 初始化指標 i2 = 1, i3 = 1, i5 = 1 // 追蹤 2、3、5 的下一個候選位置  \n→ Step 3: Decision: 如果 n == 1? // 若要求的是第一個醜數  \n  Yes → Step 4: 返回 ugly[1] // 直接輸出結果  \n  No  → Decision: 循環 k 從 2 到 n? // 從第二個醜數開始生成  \n    Yes → Step 5: 循環開始 (k 取值 2~n) // 生成剩餘醜數  \n     → Decision: 計算 next = min(ugly[i2]*2, ugly[i3]*3, ugly[i5]*5) // 找出三個候選最小值  \n       Yes → Step 6: ugly[k] = next // 存入第 k 個醜數  \n         → Decision: 如果 ugly[i2]*2 == next? // 判斷 2 的候選是否為 next  \n           Yes → Step 7: i2 = i2 + 1 // 移動 2 的指標  \n           No  →  \n           → Decision: 如果 ugly[i3]*3 == next? // 判斷 3 的候選是否為 next  \n            Yes → Step 8: i3 = i3 + 1 // 移動 3 的指標  \n            No  →  \n            → Decision: 如果 ugly[i5]*5 == next? // 判斷 5 的候選是否為 next  \n             Yes → Step 9: i5 = i5 + 1 // 移動 5 的指標  \n             No  →  \n            → Step 10: 重複循環至 k == n  \n            → Step 11: 返回 ugly[n] // 最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        ugly: List[int] = [1]\n        i2 = i3 = i5 = 0\n\n        while len(ugly) < n:\n            next2 = ugly[i2] * 2\n            next3 = ugly[i3] * 3\n            next5 = ugly[i5] * 5\n            next_ugly = min(next2, next3, next5)\n            ugly.append(next_ugly)\n\n            if next_ugly == next2:\n                i2 += 1\n            if next_ugly == next3:\n                i3 += 1\n            if next_ugly == next5:\n                i5 += 1\n\n        return ugly[-1]\n\ndef main() -> None:\n    data = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n    solution = Solution()\n    print(solution.nthUglyNumber(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "12",
          "success": true,
          "output": "12"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode316.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicate Letters",
    "description_snippet": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: remove duplicate letters to get smallest lexicographical order. Classic Leetcode 316. Steps: compute last occurrence index for each char; use stack and visited set; iterate; maintain stack; while stack not empty and top > current char and last occurrence of top > current index, pop. Add current if not visited. At end join stack.\n\nWe need to produce line-by-line pseudo-code with explanations. Use Start, End, Decision. Provide each step line with arrow and comment. Let's outline:\n\nStart\n→ Step 1: Initialize lastIndex map for each char to its last occurrence index\n→ Step 2: Initialize empty stack (list) and visited set\n→ Step 3: For each character ch at index i in s\n    → Decision: Is ch already visited?\n        Yes → Continue to next char\n        No → Decision: While stack not empty AND top > ch AND lastIndex[top] > i?\n            Yes → Pop top from stack and mark visited false\n            No  → Break loop\n        → Push ch onto stack and mark visited true\n→ Step 4: Concatenate stack elements into result string\nEnd\n\nNeed each line with virtual code and comment. Use arrow notation.\n\nAlso include mapping of lastIndex, visited. We can represent Step 1 etc. Provide explanation after //. Use arrow. For loops maybe Step 3: For i, ch in enumerate(s). Use Decision with indentation.\n\nLet's craft. Ensure each line includes comment.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Create lastIndex map: for each character c in s, store its last occurrence index // 計算每個字母最後出現的位置\n→ Step 2: Initialize empty stack S and empty visited set V // 用來保存結果字元和已加入的字元標記\n→ Step 3: For each index i and character ch in s\n    → Decision: 如果 ch 已在 V 裡？ // 判斷字元是否已被使用\n        Yes → Continue // 若已存在，跳過本次迴圈\n        No  → Decision: 若 S 不是空且 S.top > ch 且 lastIndex[S.top] > i？\n            Yes → Pop top from S and remove it from V // 若後續仍會出現更大的字元，先放回\n            No  → Break // 不需要再進行 pop\n        → Push ch onto S and add ch to V // 把新字元加入堆疊並標記已使用\n→ Step 4: 將堆疊 S 的元素連接成字符串 result // 將結果轉成最終輸出\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef remove_duplicate_letters(s: str) -> str:\n    \"\"\"\n    Remove duplicate letters so that every letter appears once and only once,\n    and the result is the smallest lexicographical string possible.\n    \"\"\"\n    # 1. Record the last occurrence index of each character.\n    last_occurrence = {c: i for i, c in enumerate(s)}\n    stack = []          # 用來保存結果字元的堆疊\n    seen = set()        # 記錄已經放進堆疊的字元\n\n    # 2. 遍歷原字串\n    for i, c in enumerate(s):\n        if c in seen:\n            continue  # 若已經使用過，直接跳過\n\n        # 3. 保證堆疊頂部字元比當前字元大且後面還會再出現，則將其移除\n        while stack and c < stack[-1] and i < last_occurrence[stack[-1]]:\n            removed = stack.pop()\n            seen.discard(removed)\n\n        # 4. 把當前字元加入堆疊\n        stack.append(c)\n        seen.add(c)\n\n    # 5. 把堆疊裡的字元拼成結果字串\n    return ''.join(stack)\n\n\ndef main():\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 嘗試從形如 s = \"abc\" 的輸入中抽取字串\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接使用整行作為字串\n        s = raw_input\n\n    result = remove_duplicate_letters(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bcabc\"",
          "expected_output": "\"abc\"",
          "success": true,
          "output": "abc"
        },
        {
          "example_index": 1,
          "input": "s = \"cbacdcbc\"",
          "expected_output": "\"acdb\"",
          "success": true,
          "output": "acdb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode432.json",
    "problem_index_in_file": 0,
    "title": "All O`one Data Structure",
    "description_snippet": "Design a data structure to store the strings' count with the ability to return the strings with mini...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for design of AllOne data structure with O(1) operations. We must use virtual code lines with arrows, Start, End, Decision, etc. Provide brief explanation each line. The output should be structured lines. Each line: virtual code step + space + // explanation. Use arrows and structure. Let's design algorithm: Use doubly linked list of count nodes, each node holds count and set of keys. Use hashmap key->node. On inc: if key exists, move to next count node (if next node has count+1 else create). Remove from current set; if set empty remove node. Add key to next node's set. Update key map. If key new: add to count node 1: if head node with count1 else create new node at head. On dec: similar but move to prev node or remove if count becomes 0. For getMaxKey: return any key from tail node set. getMinKey: return any key from head node set.\n\nNeed to produce virtual code lines step by step for AllOne class. Provide initialization, inc, dec, getMaxKey, getMinKey. Also internal operations: addNodeAfter, removeNode, etc.\n\nWill produce line by line pseudo-code. Provide explanation after each.\n\nLet's craft.\n\nStart: AllOne class initialization. Then define structures: Node, keyMap, head, tail.\n\nWe'll produce steps: Start → Initialize data structures. Decision? No.\n\nBut we need each function's steps.\n\nWe should maybe produce pseudo code for entire class with separate methods. Use Start for class, End for class. But spec: use Start, End, Decision. Provide per method.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step: Define Node struct with count, set of keys, prev, next // 設定節點結構\n→ Step: Create hash map key->Node // 用於快速定位鍵所在節點\n→ Step: Initialize head and tail as dummy nodes with count 0 // 兩個哨兵節點\n→ Step: Link head.next = tail; tail.prev = head // 設定雙向鏈表初始結構\nEnd // AllOne 初始化完成\n\nBut we need each function. So:\n\n→ Function AllOne() // 初始化方法\n    → Step: (Same as above) // 設定資料結構\n\nBut we might combine.\n\nBetter produce high-level pseudo-code for AllOne class.\n\nWe should produce:\n\nStart // AllOne class definition\n→ Step: Define Node struct\n...\nEnd // End of class definition\n\nBut we might separate initialization inside constructor.\n\nMaybe we produce:\n\nStart // AllOne class definition\n→ Step: Define Node struct // Node包含 count、keySet、prev、next\n→ Step: Define map keyToNode // key到Node的映射\n→ Step: Define head, tail dummy nodes // head.count = 0, tail.count = 0\n→ Step: Link head.next = tail; tail.prev = head // 初始化雙向鏈表\nEnd // AllOne class definition\n\nThen each method: inc, dec, getMaxKey, getMinKey.\n\nFor inc:\n\n→ Function inc(key) // 處理鍵遞增\n    → Decision: key in keyToNode? // 判斷鍵是否存在\n        Yes → Step: current = keyToNode[key] // 取得當前節點\n            → Step: nextCount = current.count + 1 // 計算新計數\n            → Decision: current.next.count == nextCount? // 是否已存在下一節點\n                Yes → Step: nextNode = current.next\n                No  → Step: nextNode = new Node(nextCount); // 建立新節點\n                    → Step: Insert nextNode after current // 將新節點插入鏈表\n            → Step: Remove key from current.keySet\n            → Decision: current.keySet empty? // 若此節點無鍵\n                Yes → Step: Remove current from list // 刪除空節點\n            → Step: Add key to nextNode.keySet\n            → Step: keyToNode[key] = nextNode // 更新映射\n        No  → Step: current = head // 若鍵不存在，從head起始\n            → Decision: head.next.count == 1? // 是否已有計數1節點\n                Yes → Step: node = head.next\n                No  → Step: node = new Node(1); Insert node after head\n            → Step: Add key to node.keySet\n            → Step: keyToNode[key] = node\nEnd // inc function\n\nSimilarly for dec:\n\n→ Function dec(key)\n    → Step: current = keyToNode[key]\n    → Step: newCount = current.count - 1\n    → Decision: newCount == 0? // 如果減至0\n        Yes → Step: Remove key from current.keySet\n            → Step: Delete keyToNode[key] // 移除映射\n            → Decision: current.keySet empty? // 若節點無鍵\n                Yes → Step: Remove current from list\n        No  → Decision: current.prev.count == newCount? // 是否存在前節點\n            Yes → Step: prevNode = current.prev\n            No  → Step: prevNode = new Node(newCount); Insert before current\n        → Step: Remove key from current.keySet\n        → Decision: current.keySet empty?\n            Yes → Step: Remove current from list\n        → Step: Add key to prevNode.keySet\n        → Step: keyToNode[key] = prevNode\n\ngetMaxKey:\n\n→ Function getMaxKey()\n    → Decision: tail.prev == head? // 若列表空\n        Yes → Step: return \"\" // 無元素\n        No  → Step: node = tail.prev\n            → Step: return any key from node.keySet // 任意鍵\n\ngetMinKey similarly with head.next.\n\nWe'll also need helper functions for InsertNodeAfter, InsertNodeBefore, RemoveNode.\n\nWe can include as steps inside methods inline.\n\nNow produce final answer: Each line with arrow \"→\" except Start/End. Ensure each line includes // explanation. Use spaces.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step: Define Node struct { int count; Set<string> keys; Node* prev; Node* next; } // 節點結構存儲計數與鍵集合  \n→ Step: Define unordered_map<string, Node*> keyToNode // 快速查找鍵所在節點  \n→ Step: Define Node* head = new Node(0); Node* tail = new Node(0); // 兩個哨兵節點，count 皆為 0  \n→ Step: head->next = tail; tail->prev = head; // 初始化雙向鏈表結構  \n\nEnd // AllOne 初始化完成  \n\n---  \n\nFunction inc(string key) // 對鍵進行遞增  \n    → Decision: keyToNode.count(key) > 0? // 判斷鍵是否已存在  \n        Yes →  \n            → Step: Node* curr = keyToNode[key]; // 取得當前節點  \n            → Step: int newCnt = curr->count + 1; // 計算新計數  \n            → Decision: curr->next->count == newCnt? // 是否已有下一節點  \n                Yes → Step: Node* nextNode = curr->next; // 使用現有節點  \n                No →  \n                    → Step: Node* nextNode = new Node(newCnt); // 建立新節點  \n                    → Step: InsertAfter(curr, nextNode); // 插入鏈表  \n            → Step: curr->keys.erase(key); // 從舊節點移除鍵  \n            → Decision: curr->keys.empty()? // 若舊節點無鍵  \n                Yes → Step: RemoveNode(curr); // 刪除空節點  \n            → Step: nextNode->keys.insert(key); // 加入新節點  \n            → Step: keyToNode[key] = nextNode; // 更新映射  \n        No →  \n            → Step: int newCnt = 1; // 新鍵初始計數為 1  \n            → Decision: head->next->count == 1? // 是否已有計數 1 的節點  \n                Yes → Step: Node* node = head->next;  \n                No →  \n                    → Step: Node* node = new Node(newCnt); // 建立計數 1 節點  \n                    → Step: InsertAfter(head, node); // 插入鏈表  \n            → Step: node->keys.insert(key); // 加入鍵  \n            → Step: keyToNode[key] = node; // 更新映射  \n\nEnd // inc 函式結束  \n\n---  \n\nFunction dec(string key) // 對鍵進行遞減  \n    → Step: Node* curr = keyToNode[key]; // 取得當前節點（已保證存在）  \n    → Step: int newCnt = curr->count - 1; // 計算新計數  \n    → Decision: newCnt == 0? // 是否要移除鍵  \n        Yes →  \n            → Step: curr->keys.erase(key); // 從節點移除鍵  \n            → Step: keyToNode.erase(key); // 移除映射  \n            → Decision: curr->keys.empty()? // 若節點無鍵  \n                Yes → Step: RemoveNode(curr); // 刪除空節點  \n        No →  \n            → Decision: curr->prev->count == newCnt? // 是否已有前節點  \n                Yes → Step: Node* prevNode = curr->prev;  \n                No →  \n                    → Step: Node* prevNode = new Node(newCnt); // 建立新節點  \n                    → Step: InsertBefore(curr, prevNode); // 插入鏈表  \n            → Step: curr->keys.erase(key); // 從舊節點移除鍵  \n            → Decision: curr->keys.empty()? // 若舊節點無鍵  \n                Yes → Step: RemoveNode(curr); // 刪除空節點  \n            → Step: prevNode->keys.insert(key); // 加入新節點  \n            → Step: keyToNode[key] = prevNode; // 更新映射  \n\nEnd // dec 函式結束  \n\n---  \n\nFunction getMaxKey() // 取得計數最大鍵  \n    → Decision: tail->prev == head? // 判斷鏈表是否空  \n        Yes → Step: return \"\"; // 無元素，返回空字符串  \n        No →  \n            → Step: Node* node = tail->prev; // 最大計數節點  \n            → Step: return *node->keys.begin(); // 任意返回一個鍵  \n\nEnd // getMaxKey 結束  \n\n---  \n\nFunction getMinKey() // 取得計數最小鍵  \n    → Decision: head->next == tail? // 判斷鏈表是否空  \n        Yes → Step: return \"\"; // 無元素，返回空字符串  \n        No →  \n            → Step: Node* node = head->next; // 最小計數節點  \n            → Step: return *node->keys.begin(); // 任意返回一個鍵  \n\nEnd // getMinKey 結束  \n\n---  \n\nHelper Function InsertAfter(Node* prev, Node* newNode)  \n    → Step: newNode->prev = prev; newNode->next = prev->next;  \n    → Step: prev->next->prev = newNode; prev->next = newNode; // 插入到 prev 之後  \n\nEnd // InsertAfter  \n\n---  \n\nHelper Function InsertBefore(Node* next, Node* newNode)  \n    → Step: newNode->next = next; newNode->prev = next->prev;  \n    → Step: next->prev->next = newNode; next->prev = newNode; // 插入到 next 之前  \n\nEnd // InsertBefore  \n\n---  \n\nHelper Function RemoveNode(Node* node)  \n    → Step: node->prev->next = node->next;  \n    → Step: node->next->prev = node->prev;  \n    → Step: delete node; // 釋放節點  \n\nEnd // RemoveNode  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Node:\n    def __init__(self, count=0):\n        self.count = count          # 此節點代表的計數\n        self.keys = set()           # 存放擁有該計數的所有鍵\n        self.prev = None            # 前一節點\n        self.next = None            # 後一節點\n\nclass AllOne:\n    def __init__(self):\n        # 兩個哨兵節點，分別位於最小與最大位置\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}       # key -> 所屬節點\n\n    def _insert_after(self, prev_node, count):\n        \"\"\"在 prev_node 後插入一個新的節點，並返回該節點\"\"\"\n        new_node = Node(count)\n        new_node.prev = prev_node\n        new_node.next = prev_node.next\n        prev_node.next.prev = new_node\n        prev_node.next = new_node\n        return new_node\n\n    def _remove(self, node):\n        \"\"\"將節點從雙向鏈表中移除\"\"\"\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        \"\"\"把 key 的計數 +1\"\"\"\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            # 如果後面沒有計數為 next_count 的節點，則新建一個\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            # 新鍵，計數為 1\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        \"\"\"把 key 的計數 -1，若計數降為 0 則移除\"\"\"\n        if key not in self.key_to_node:\n            return\n        node = self.key_to_node[key]\n        prev_count = node.count - 1\n        node.keys.remove(key)\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        \"\"\"取得任意計數最大的 key，若無則回傳空字串\"\"\"\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        \"\"\"取得任意計數最小的 key，若無則回傳空字串\"\"\"\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    # 讀取所有輸入行，並移除空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not lines:\n        return\n\n    # 若輸入以 \"Input\" 為首行，則跳過\n    if lines[0] == \"Input\":\n        ops_line = lines[1]\n        args_line = lines[2]\n    else:\n        ops_line = lines[0]\n        args_line = lines[1]\n\n    ops = json.loads(ops_line)\n    args = json.loads(args_line)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"AllOne\":\n            obj = AllOne()\n            results.append(None)\n        elif op == \"inc\":\n            obj.inc(arg[0])\n            results.append(None)\n        elif op == \"dec\":\n            obj.dec(arg[0])\n            results.append(None)\n        elif op == \"getMaxKey\":\n            results.append(obj.getMaxKey())\n        elif op == \"getMinKey\":\n            results.append(obj.getMinKey())\n        else:\n            results.append(None)\n\n    # 輸出結果\n    print(\"Output\")\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "success": true,
          "output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode344.json",
    "problem_index_in_file": 0,
    "title": "Reverse String",
    "description_snippet": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line, each line with virtual code step + space + comment. Format example uses Start, End, Decision etc. We'll need to create algorithm for reversing string in-place. Use two-pointer approach: left, right indices. Steps: start, initialize left=0, right=len-1, loop while left < right: swap s[left] and s[right], left++, right--. End. Also function wrapper. Let's produce code lines:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 reverseString(s) // 定義倒序函式，參數為字元陣列\n→ Step 2: left = 0 // 左指標起始於陣列開頭\n→ Step 3: right = len(s) - 1 // 右指標起始於陣列結尾\n→ Decision: 是否 left < right? // 檢查是否還需交換\n    Yes → Step 4: temp = s[left] // 暫存左邊字元\n    → Step 5: s[left] = s[right] // 交換左字元為右字元\n    → Step 6: s[right] = temp // 右字元設回左字元\n    → Step 7: left = left + 1 // 移動左指標向右\n    → Step 8: right = right - 1 // 移動右指標向左\n    No  → Step 9: End of loop // 交換完成\n→ End // 函式執行結束\n\nBut we need to use Start and End to denote start and end of program, maybe include Step 0? We'll produce as per format. Use virtual code arrow for steps. The format requires \"虛擬碼步驟\" followed by space and comment. Use arrow \"→\" at start of each line. For decisions, we need \"Decision:\" etc. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 reverseString(s) // 建立倒序函式，參數為字元陣列  \n→ Step 2: left = 0 // 設定左指標於陣列首  \n→ Step 3: right = len(s) - 1 // 設定右指標於陣列尾  \n→ Decision: 左指標是否小於右指標? // 判斷是否還有字元需要交換  \n  Yes → Step 4: temp = s[left] // 暫存左邊字元  \n   → Step 5: s[left] = s[right] // 把右邊字元放到左邊  \n   → Step 6: s[right] = temp // 把暫存的左邊字元放到右邊  \n   → Step 7: left = left + 1 // 左指標右移  \n   → Step 8: right = right - 1 // 右指標左移  \n   → Step 9: Decision: 左指標是否小於右指標? // 回到判斷，繼續交換  \n  No → Step 10: End // 交換完成，結束程式  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reverseString(self, s):\n        \"\"\"In‑place reverse of the list of characters.\"\"\"\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把輸入字串轉成 list，例如:  's = [\"h\",\"e\",\"l\",\"l\",\"o\"]'\n    # 先找等號右側的內容\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    # 使用 ast.literal_eval 解析成 Python list\n    try:\n        s = ast.literal_eval(list_part.strip())\n    except Exception as e:\n        # 若解析失敗則直接輸出錯誤訊息\n        print(f\"Error parsing input: {e}\")\n        return\n\n    # 呼叫解法\n    sol = Solution()\n    sol.reverseString(s)\n\n    # 輸出結果，使用 print 可以得到符合範例的格式\n    print(s)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
          "expected_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
          "success": true,
          "output": "['o', 'l', 'l', 'e', 'h']"
        },
        {
          "example_index": 1,
          "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
          "expected_output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
          "success": true,
          "output": "['h', 'a', 'n', 'n', 'a', 'H']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2220.json",
    "problem_index_in_file": 0,
    "title": "Minimum Bit Flips to Convert Number",
    "description_snippet": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from ei...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm to compute min bit flips to convert start to goal. Problem is: We can flip any bit (including leading zeros). Essentially, we need to transform binary representation of start to goal via bit flips; each flip toggles one bit position. Minimum flips equals number of bits where start and goal differ. Because flipping each differing bit once changes that bit; no cross interactions. But leading zeros: we can choose any bit beyond representation; but we need to consider bits up to max bits needed to represent either number? Since leading zeros all zeros, if goal has a 1 at a higher position than start's length, we need to flip that bit from 0 to 1. Similarly, if start has 1 where goal has 0 beyond goal's length? Actually goal's leading zeros beyond its length. But we need to consider all bits that differ up to max bit length of either number. Equivalent to XOR of start and goal: count set bits. So algorithm: compute XOR, count bits set.\n\nReturn count.\n\nBut we need pseudocode lines with arrows and explanations. Provide step-by-step:\n\nStart\n→ Step 1: Calculate diff = start XOR goal // difference bits\n→ Step 2: Initialize count = 0\n→ Step 3: While diff > 0\n    → Decision: If diff LSB == 1? // check lowest bit\n        Yes → Increment count\n    → Step 4: Right shift diff by 1 // move to next bit\n→ Step 5: Return count\n\nAlternatively use built-in popcount if available.\n\nReturn minimal flips.\n\nAlso could handle negative numbers? Assume non-negative integers.\n\nLet's output virtual code line by line.\n\nNeed arrow syntax: `→` after Start. Indent for Decision lines? Example: In sample, they used `Decision:` on separate line with indent for Yes and No lines. We'll follow same.\n\nWe'll use `Decision: diff == 0?`? Might use simpler.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: diff = start XOR goal // 取得兩數不同位元的掩碼\n→ Step 2: count = 0 // 初始翻轉次數\n→ Decision: diff == 0? // 若沒有不同位元則直接返回\n    Yes → Step 3: Return count // 0 次翻轉\n    No  → Step 4: While diff > 0 // 逐位檢查\n        → Decision: (diff AND 1) == 1? // 最低有效位是否為 1\n            Yes → Step 5: count = count + 1 // 需要翻轉此位\n            No  → Step 6: No operation // 這位相同不變\n        → Step 7: diff = diff >> 1 // 移除已檢查位\n    → Step 8: Return count // 所有位檢查完畢，返回翻轉次數\nEnd // 程式結束\n\nBut the While loop lines maybe need to be nested. Use indentation as sample: after Step 4: While diff > 0 // loop start\n    → Decision: ...\n        Yes ...\n        No ...\n    → Step 7: diff = diff >> 1\nThis implies that diff >> 1 occurs each iteration.\n\nAlternatively we can use popcount function.\n\nSimplify: Step 4: count = popcount(diff) // built-in\n\nBut maybe they expect manual bit count.\n\nWe'll produce manual as above.\n\nNeed to ensure each line includes the arrow and comment.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: diff = start XOR goal // 取得兩數不同位元的掩碼  \n→ Step 2: count = 0 // 初始翻轉次數  \n→ Decision: diff == 0? // 若沒有不同位元則直接返回  \n    Yes → Step 3: Return count // 0 次翻轉  \n    No → Step 4: While diff > 0 // 逐位檢查不同位元  \n        → Decision: (diff AND 1) == 1? // 最低有效位是否為 1  \n            Yes → Step 5: count = count + 1 // 需要翻轉此位  \n            No → Step 6: No operation // 這位相同不變  \n        → Step 7: diff = diff >> 1 // 移除已檢查位，進入下一位  \n→ Step 8: Return count // 所有位檢查完畢，返回翻轉次數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minBitFlips(self, start, goal):\n        xor = start ^ goal\n        flips = 0\n        while xor:\n            flips += xor & 1\n            xor >>= 1\n        return flips\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) >= 2:\n        start, goal = int(nums[0]), int(nums[1])\n        result = Solution().minBitFlips(start, goal)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "start = 10, goal = 7",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "start = 3, goal = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode767.json",
    "problem_index_in_file": 0,
    "title": "Reorganize String",
    "description_snippet": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, each line with explanation comment. Use Start, End, Decision, arrow. We must not output actual code. So algorithm: Count frequencies. Check if any freq > (n+1)/2 then impossible. Use max heap or sorted list to pick two most frequent characters. Build result by repeatedly selecting two highest freq chars, appending them, reducing count, reinsert if still >0. For simplicity, use priority queue. Virtual steps: Count, check impossible, build priority queue, loop while queue not empty: pop top two, append, decrease counts, reinsert if >0. If leftover one char, append. End. Provide explanation. Ensure each line is like \"Start // ...\". Use arrow for steps. Use Decision for impossible check. Use indentation for nested decisions. Provide step lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字元頻率表 `freq`，計算每個字元在字串 `s` 中出現的次數 // 先統計各字元出現頻率  \n→ Decision: 若任何字元頻率 > (len(s)+1)/2? // 檢查是否有字元太多，無法重排  \n    Yes → Step 2: 回傳空字串 \"\" // 直接返回無法重排的結果  \n    No  → Step 3: 建立最大堆 `maxHeap`，將所有 (字元, 頻率) 插入堆中，根據頻率從大到小排序 // 準備按頻率取字元  \n→ Step 4: 初始化空串 `result` 用於儲存重排後的字元序列 // 用於累積最終答案  \n→ Decision: `maxHeap` 仍有兩個或以上元素? // 判斷是否還能取兩個字元同時放入  \n    Yes → Step 5: 從堆中彈出頻率最高的字元 `c1` 與次高頻的字元 `c2` // 取兩個最常見字元  \n    → Step 6: 將 `c1` 與 `c2` 分別追加到 `result` // 保證相鄰不同  \n    → Step 7: 將 `c1`、`c2` 的頻率各減 1，若仍 >0 再重新插回堆中 // 更新剩餘數量  \n    → Step 8: 回到 Decision: `maxHeap` 仍有兩個或以上元素? // 重新檢查堆狀態  \n    No  → Decision: `maxHeap` 只剩一個元素? // 檢查是否還有單個字元可放  \n        Yes → Step 9: 將最後剩餘字元 `c` 加入 `result` // 放入最後一個字元  \n        No  → Step 10: 迴圈結束 // 堆已空，重排完成  \n→ Step 11: 回傳 `result` 為重排後的字串 // 完整輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        # Count frequency of each character\n        count = Counter(s)\n        # Max-heap: use negative frequency for max-heap behavior\n        max_heap = [(-freq, char) for char, freq in count.items()]\n        heapq.heapify(max_heap)\n\n        prev_freq, prev_char = 0, ''  # store the previous character that was appended\n        res = []\n\n        while max_heap:\n            freq, char = heapq.heappop(max_heap)  # most frequent remaining char\n            res.append(char)  # append current char\n\n            # If there is a previous char pending to reinsert (its freq still > 0)\n            if prev_freq < 0:\n                heapq.heappush(max_heap, (prev_freq, prev_char))\n\n            # Set current char as previous for next iteration\n            # Increase freq by 1 because we used one occurrence (freq is negative)\n            prev_freq, prev_char = freq + 1, char\n\n        result = ''.join(res)\n        # If we were able to use all characters, return result; otherwise return empty string\n        return result if len(result) == len(s) else \"\"\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Parse the raw input which might be in the form:\n    - 's = \"aab\"'\n    - 'aab'\n    - ' \"aab\" '\n    Return the string value without surrounding quotes or leading/trailing spaces.\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return ''\n    # Handle format 's = \"aab\"'\n    if '=' in raw:\n        _, value = raw.split('=', 1)\n        raw = value.strip()\n    # Remove surrounding quotes if present\n    if (raw.startswith('\"') and raw.endswith('\"')) or (raw.startswith(\"'\") and raw.endswith(\"'\")):\n        raw = raw[1:-1]\n    return raw\n\nif __name__ == \"__main__\":\n    # Read entire stdin (could be multi-line, but we consider first non-empty line)\n    data = sys.stdin.read()\n    # Split into lines and take the first non-empty line as input\n    lines = [line for line in data.splitlines() if line.strip()]\n    if not lines:\n        s_input = ''\n    else:\n        s_input = parse_input(lines[0])\n\n    solution = Solution()\n    result = solution.reorganizeString(s_input)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "\"aba\"",
          "success": true,
          "output": "aba"
        },
        {
          "example_index": 1,
          "input": "s = \"aaab\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode312.json",
    "problem_index_in_file": 0,
    "title": "Burst Balloons",
    "description_snippet": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it repre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line with comments. We should design DP solution for balloon burst problem (optimal coin). Virtual code with arrows. Should be stepwise. No actual code. Just structure. Let's produce explanation lines. Ensure \"Start\", \"End\". Use Decision nodes. We'll incorporate DP over subarrays.\n\nLet's craft:\n\nStart\n→ Pad nums with 1 at both ends // add virtual balloons\n→ n ← length of original nums\n→ Initialize DP 2D array of size (n+2) x (n+2) with zeros // DP[i][j] maximum coins between i and j\n→ For length from 1 to n:\n    → For left from 1 to n - length + 1:\n        right ← left + length - 1\n        → For k from left to right:\n            coins ← nums[left-1] * nums[k] * nums[right+1]\n            total ← DP[left][k-1] + coins + DP[k+1][right]\n            → Decision: total > DP[left][right]?\n                Yes → DP[left][right] ← total\n                No  → (do nothing)\n→ Return DP[1][n] // maximum coins\n\nNeed to ensure each line has \"虛擬碼步驟 // 解釋\". Use arrows appropriately.\n\nAlso Decision lines must show Yes → and No →.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Pad the input array nums with a 1 at both ends to handle edge balloons // 在陣列兩端加 1，避免越界\n→ Let m ← length of original nums // m 為原始氣球數量\n→ Create a 2D DP table DP[0..m+1][0..m+1] initialized to 0 // DP[i][j] 代表在 i 到 j 之間（不含 i、j）爆破得到的最大硬幣\n→ For subLen from 1 to m: // 遍歷子陣列長度\n    → For left from 1 to m - subLen + 1: // 子陣列左端索引\n        right ← left + subLen - 1 // 子陣列右端索引\n        → For k from left to right: // 以 k 為最後爆破的氣球\n            coins ← nums[left-1] * nums[k] * nums[right+1] // 爆破 k 時得到的硬幣\n            total ← DP[left][k-1] + coins + DP[k+1][right] // 左右子問題加上本次爆破\n            → Decision: total > DP[left][right]? // 判斷是否更新 DP\n                Yes → DP[left][right] ← total // 若更大則更新\n                No  → // 保持原值\n→ Return DP[1][m] // 回傳整個陣列最優的硬幣總額\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxCoins(self, nums):\n        # 在前後加 1 方便計算\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        # 遍歷所有長度（以左邊界為基準）\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                # i 為最後一個被戳破的氣球\n                for i in range(left + 1, right):\n                    dp[left][right] = max(\n                        dp[left][right],\n                        nums[left] * nums[i] * nums[right]\n                        + dp[left][i]\n                        + dp[i][right]\n                    )\n        return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析可能的「nums = [...]」格式\n    try:\n        if raw_input.lower().startswith(\"nums\"):\n            _, arr_part = raw_input.split(\"=\", 1)\n            nums_list = ast.literal_eval(arr_part.strip())\n        else:\n            nums_list = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，視為空列表\n        nums_list = []\n\n    result = Solution().maxCoins(nums_list)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,1,5,8]",
          "expected_output": "167",
          "success": true,
          "output": "167"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode166.json",
    "problem_index_in_file": 0,
    "title": "Fraction to Recurring Decimal",
    "description_snippet": "Given two integers representing the numerator and denominator of a fraction, return the fraction in ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line, with comments, following format. Should not output actual code. We produce steps: start, get numerator, denominator, handle sign, integer part, remainder, map remainders to positions, loop division, detect repeat, build string with parentheses, return string. Use decision and loops.\n\nLet's craft lines:\n\nStart\n→ Step 1: Read numerator, denominator\n→ Decision: 如果分母為 0? // handle division by zero\n    Yes → Step 2: Return 'Infinity' // placeholder\n    No → ...\n\nBut might not need division by zero case.\n\nWe then handle sign: determine negative flag.\n\nCompute absolute values.\n\nCompute integer part: integer = num // den\n\nCompute remainder = num % den\n\nIf remainder == 0 → return integer as string.\n\nElse → build result string with integer part and decimal point.\n\nThen map = {} // remainder to position in decimal part.\n\nLoop while remainder != 0:\n  if remainder in map:\n    set repeat_start = map[remainder]\n    break\n  map[remainder] = current length of decimal part\n  remainder *= 10\n  digit = remainder // den\n  append digit to decimal part\n  remainder = remainder % den\n\nAfter loop:\n  if remainder == 0: no repeating\n    result = integer part + '.' + decimal part\n  else:\n    result = integer part + '.' + decimal part[0:repeat_start] + '(' + decimal part[repeat_start:] + ')'\n\nAdd sign if negative and integer part not zero? Actually if negative and integer part zero still include '-' at start.\n\nReturn result.\n\nLet's produce each step as line with comment. Ensure each line ends with comment.\n\nWe need to use arrow syntax. Provide decision arrows with Yes → and No →. Use indentation. Use \"Start\" and \"End\".\n\nLet's craft.\n\nUse \"Step 1:\" etc.\n\nAlso use \"Decision:\" for branches.\n\nAlso loops: use \"Loop\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read numerator, denominator // 取得輸入的分子與分母  \n→ Decision: 如果分母為 0? // 檢查除數是否為零  \n Yes → Step 2: Return 'Infinity' // 零除輸出特殊值  \n No  → Step 3: Continue // 正常流程  \n→ Step 4: 計算符號 flag = (numerator < 0) XOR (denominator < 0) // 判斷結果是否為負數  \n→ Step 5: 取分子分母絕對值 num = abs(numerator), den = abs(denominator) // 以正整數做後續計算  \n→ Step 6: 取得整數部分 integer = num // den // 整數商  \n→ Step 7: remainder = num % den // 取得初始餘數  \n→ Decision: 如果 remainder == 0? // 檢查是否為整數  \n Yes → Step 8: result = str(integer) // 直接回傳整數結果  \n No  → Step 9: result = str(integer) + '.' // 開始小數部分，加入小數點  \n→ Step 10: 建立字典 map = {} // 用於追蹤餘數位置，檢測循環  \n→ Step 11: 建立字串 decimal = '' // 儲存小數位數  \n→ Loop // 進行長除以取得小數位  \n → Decision: 如果 remainder == 0? // 無循環小數  \n  Yes → Exit Loop // 結束迴圈  \n  No  → Decision: 如果 remainder 已在 map? // 檢測餘數是否重複  \n   Yes → repeat_start = map[remainder] // 記錄循環開始位置  \n    Break Loop // 找到循環後跳出迴圈  \n   No  → map[remainder] = len(decimal) // 記錄餘數位置  \n    remainder *= 10 // 乘以 10 以進行下一位除法  \n    digit = remainder // den // 取得下一個小數位數  \n    decimal += str(digit) // 加入小數字串  \n    remainder = remainder % den // 更新餘數  \n→ Decision: 如果 remainder == 0? // 迴圈結束後檢查是否有循環  \n Yes → result += decimal // 無循環，直接加入全部小數位  \n No  → result += decimal[0:repeat_start] + '(' + decimal[repeat_start:] + ')' // 插入括號標示循環部分  \n→ Decision: 如果 flag 為 True? // 檢查是否需要加負號  \n Yes → result = '-' + result // 前面加負號  \n No  → // 直接使用 result  \n→ Step 12: Return result // 回傳最終字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        \"\"\"\n        Convert a fraction to its decimal representation.\n        Repeating parts are enclosed in parentheses.\n        \"\"\"\n        if numerator == 0:\n            return \"0\"\n\n        result = []\n\n        # Determine the sign of the result\n        if (numerator < 0) ^ (denominator < 0):\n            result.append(\"-\")\n\n        # Work with absolute values to simplify the logic\n        numerator, denominator = abs(numerator), abs(denominator)\n\n        # Integer part\n        integer_part = numerator // denominator\n        result.append(str(integer_part))\n\n        # Remainder after extracting the integer part\n        remainder = numerator % denominator\n        if remainder == 0:\n            # No fractional part\n            return \"\".join(result)\n\n        # Fractional part starts with a decimal point\n        result.append(\".\")\n        seen_remainders = {}\n        decimal_part = []\n\n        while remainder != 0:\n            # If we have seen this remainder before, a repeating cycle is detected\n            if remainder in seen_remainders:\n                cycle_start = seen_remainders[remainder]\n                # Insert '(' at the start of the repeating part\n                result.insert(len(result) - len(decimal_part) + cycle_start, \"(\")\n                result.append(\")\")\n                break\n\n            # Record the position of this remainder\n            seen_remainders[remainder] = len(decimal_part)\n            remainder *= 10\n            digit = remainder // denominator\n            decimal_part.append(str(digit))\n            remainder %= denominator\n\n        # Append the collected decimal digits\n        result.extend(decimal_part)\n\n        return \"\".join(result)\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parse an input string of the form 'numerator = X, denominator = Y'\n    and return the two integers.\n    \"\"\"\n    numbers = re.findall(r'-?\\d+', input_str)\n    if len(numbers) != 2:\n        raise ValueError(\"Input must contain two integers for numerator and denominator.\")\n    return int(numbers[0]), int(numbers[1])\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    numerator, denominator = parse_input(raw_input)\n\n    solution = Solution()\n    output = solution.fractionToDecimal(numerator, denominator)\n\n    # Print the result to stdout\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numerator = 1, denominator = 2",
          "expected_output": "\"0.5\"",
          "success": true,
          "output": "0.5"
        },
        {
          "example_index": 1,
          "input": "numerator = 2, denominator = 1",
          "expected_output": "\"2\"",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "numerator = 4, denominator = 333",
          "expected_output": "\"0.(012)\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '0.(012)'\nGot (Norm):      '0(.)012'\n--- (Raw) ---\nRaw Expected: '\"0.(012)\"'\nRaw Got:      '0(.)012'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode30.json",
    "problem_index_in_file": 0,
    "title": "Substring with Concatenation of All Words",
    "description_snippet": "You are given a string s and an array of strings words. All the strings of words are of the same len...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for solution to LeetCode problem 30? Actually \"Substring with Concatenation of All Words\" problem 30. We must produce step-by-step virtual code lines with explanation. Should not output actual code. Should use arrows and decision structures.\n\nWe need to produce virtual code for algorithm: sliding window with hash map counts. Steps: compute word length, number of words, total length. If total length > s length return empty. Build word count map. For each offset 0 to wordLen-1: use sliding window with left index and matched count. Use currentCount map, count of words matched, while right < n: extract word, update counts, adjust left if overcount, when matched==wordsCount then record left. At end return result list.\n\nWe need to produce lines accordingly. Each line like \"Start // ...\". Use arrow → for next step. Include decision points. We need to be careful to keep lines not too long. Provide step by step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 計算 wordLen ← words[0].length // 每個單詞長度\n→ Step 2: 計算 numWords ← words.length // 單詞數量\n→ Step 3: 計算 totalLen ← wordLen * numWords // 所有單詞連接後的總長度\n→ Decision: 如果 totalLen > s.length? // 檢查 s 是否足夠長\n    Yes → Step 4: 回傳空陣列 // 沒有符合的子字串\n    No  → Step 5: 建立 wordCountMap ← {word: 出現次數} // 用來比較字串\n→ Step 6: 建立 resultList ← [] // 儲存起始索引\n→ Decision: 對 offset 0 到 wordLen-1 做循環? // 每個偏移量都要滑動窗口\n    Yes → Step 7: left ← offset // 視窗左邊界\n        → Step 8: currentCountMap ← {} // 當前窗口字典\n        → Step 9: matched ← 0 // 匹配到的有效單詞數\n        → Decision: 右指標 right ← offset; while right + wordLen <= s.length? // 逐個單詞滑動\n            Yes → Step 10: word ← s.substring(right, right+wordLen) // 取得當前單詞\n                → Decision: word 是否在 wordCountMap? // 只關心給定的單詞\n                    Yes → Step 11: currentCountMap[word]++ // 更新當前計數\n                        → Decision: currentCountMap[word] <= wordCountMap[word]? // 是否還在允許範圍內\n                            Yes → Step 12: matched++ // 有效單詞匹配數增加\n                            No  → Step 13: while currentCountMap[word] > wordCountMap[word]? // 超過需要收縮左邊\n                                → Step 14: leftWord ← s.substring(left, left+wordLen)\n                                    → Decision: leftWord == word? // 如果剛剛刪除的單詞是同一個\n                                        Yes → Step 15: currentCountMap[word]-- // 數量減一\n                                            → Step 16: matched-- // 匹配數減一\n                                            → Step 17: left += wordLen // 左指標右移一個單詞長度\n                                            → Decision: currentCountMap[word] <= wordCountMap[word]? // 重新檢查\n                                                Yes → Step 18: Exit loop // 循環結束\n                                                No  → Step 19: Continue loop // 仍需調整\n                                    No  → Step 20: left += wordLen // 刪除左邊不同單詞\n                                    → Step 21: Continue loop // 繼續收縮\n                    No → Step 22: // word 不在目標集合，直接重置窗口\n                        → Step 23: currentCountMap.clear()\n                        → Step 24: matched ← 0\n                        → Step 25: left ← right + wordLen\n            No  → Step 26: // 右邊已到結束\n        → Decision: matched == numWords? // 完整匹配\n            Yes → Step 27: resultList.append(left) // 記錄起始位置\n            No  → Step 28: // 不做事\n→ Step 29: Return resultList // 回傳所有起始索引\n\nWe need to keep lines with arrow, but our structure may need nested indentation. We'll use indentation via spaces. But in the example, indentation is inside the Decision block. We should follow that style.\n\nSimplify: use \"Decision:\" with indentation lines. We'll produce consistent.\n\nMake sure to avoid actual code. Use placeholders. Provide short explanation each line. Should we produce lines with \"→\" preceding each step? Yes.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 計算 wordLen ← words[0].length // 每個單詞長度\n→ Step 2: 計算 numWords ← words.length // 單詞數量\n→ Step 3: 計算 totalLen ← wordLen * numWords // 所有單詞連接後的總長度\n→ Decision: 如果 totalLen > s.length? // 檢查 s 是否足夠長\n    Yes → Step 4: 回傳空陣列 // 沒有符合的子字串\n    No  → Step 5: 建立 wordCountMap ← {word: 出現次數} // 用來比較字串\n→ Step 6: 建立 resultList ← [] // 儲存起始索引\n→ Decision: 對 offset 0 到 wordLen-1 做循環? // 每個偏移量都要滑動窗口\n    Yes → Step 7: left ← offset // 視窗左邊界\n        → Step 8: currentCountMap ← {} // 當前窗口字典\n        → Step 9: matched ← 0 // 匹配到的有效單詞數\n        → Decision: 右指標 right ← offset; while right + wordLen <= s.length? // 逐個單詞滑動\n            Yes → Step 10: word ← s.substring(right, right+wordLen) // 取得當前單詞\n                → Decision: word 是否在 wordCountMap? // 只關心給定的單詞\n                    Yes → Step 11: currentCountMap[word]++ // 更新當前計數\n                        → Decision: currentCountMap[word] <= wordCountMap[word]? // 是否還在允許範圍內\n                            Yes → Step 12: matched++ // 有效單詞匹配數增加\n                            No  → Step 13: while currentCountMap[word] > wordCountMap[word]? // 超過需要收縮左邊\n                                → Step 14: leftWord ← s.substring(left, left+wordLen)\n                                    → Decision: leftWord == word? // 如果剛剛刪除的單詞是同一個\n                                        Yes → Step 15: currentCountMap[word]-- // 數量減一\n                                            → Step 16: matched-- // 匹配數減一\n                                            → Step 17: left += wordLen // 左指標右移一個單詞長度\n                                            → Decision: currentCountMap[word] <= wordCountMap[word]? // 重新檢查\n                                                Yes → Step 18: Exit loop // 循環結束\n                                                No  → Step 19: Continue loop // 仍需調整\n                                    No  → Step 20: left += wordLen // 刪除左邊不同單詞\n                                    → Step 21: Continue loop // 繼續收縮\n                    No → Step 22: // word 不在目標集合，直接重置窗口\n                        → Step 23: currentCountMap.clear()\n                        → Step 24: matched ← 0\n                        → Step 25: left ← right + wordLen\n            No  → Step 26: // 右邊已到結束\n        → Decision: matched == numWords? // 完整匹配\n            Yes → Step 27: resultList.append(left) // 記錄起始位置\n            No  → Step 28: // 不做事\n→ Step 29: Return resultList // 回傳所有起始索引",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findSubstring(self, s, words):\n        \"\"\"\n        找出 s 中所有連接所有 words 的子字串的起始索引\n        \"\"\"\n        if not words or not s:\n            return []\n\n        word_len = len(words[0])\n        k = len(words)\n        total_len = word_len * k\n        if len(s) < total_len:\n            return []\n\n        # 建立單詞頻率表\n        word_count = {}\n        for w in words:\n            word_count[w] = word_count.get(w, 0) + 1\n\n        res = []\n\n        # 每個 offset 進行滑動窗口搜尋\n        for offset in range(word_len):\n            left = offset\n            cur_count = {}\n            matched = 0\n\n            # 右指標以 word_len 為步長向右滑動\n            for right in range(offset, len(s) - word_len + 1, word_len):\n                word = s[right:right + word_len]\n\n                if word in word_count:\n                    cur_count[word] = cur_count.get(word, 0) + 1\n\n                    if cur_count[word] <= word_count[word]:\n                        matched += 1\n                    else:\n                        # 超過允許數量，收縮左邊\n                        while cur_count[word] > word_count[word]:\n                            left_word = s[left:left + word_len]\n                            cur_count[left_word] -= 1\n                            if cur_count[left_word] < word_count[left_word]:\n                                matched -= 1\n                            left += word_len\n\n                    # 找到完整匹配，紀錄起始位置\n                    if matched == k:\n                        res.append(left)\n                        # 將左邊單詞移出窗口\n                        left_word = s[left:left + word_len]\n                        cur_count[left_word] -= 1\n                        matched -= 1\n                        left += word_len\n                else:\n                    # 單詞不在 words 裡，重置窗口\n                    cur_count.clear()\n                    matched = 0\n                    left = right + word_len\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 解析輸入\n    s_match = re.search(r's\\s*=\\s*(\"(?:\\\\.|[^\"])*\")', data)\n    words_match = re.search(r'words\\s*=\\s*(\\[.*\\])', data, re.S)\n\n    if s_match:\n        s = ast.literal_eval(s_match.group(1))\n    else:\n        # 如果沒有找到 s=，嘗試從第一行取得\n        lines = data.splitlines()\n        s = lines[0].strip() if lines else \"\"\n\n    if words_match:\n        words = ast.literal_eval(words_match.group(1))\n    else:\n        # 如果沒有找到 words=，嘗試從第二行取得\n        lines = data.splitlines()\n        words = ast.literal_eval(lines[1].strip()) if len(lines) > 1 else []\n\n    solution = Solution()\n    result = solution.findSubstring(s, words)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "success": true,
          "output": "[0, 9]"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "success": true,
          "output": "[6, 9, 12]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode553.json",
    "problem_index_in_file": 0,
    "title": "Optimal Division",
    "description_snippet": "You are given an integer array nums. The adjacent integers in nums will perform the float division.\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the algorithm. Not actual code. Must be line by line with \"虛擬碼步驟 // 解釋\". We need to generate algorithm for maximizing expression value with division by adding parentheses. Classic problem: maximize by placing parentheses after first number as (a/(b/c/d/...)). The optimal is to divide first number by product of rest, so parentheses: a/(b/c/d/...)? Wait, known solution: For maximizing division expression, put parentheses after first number: a/(b/(c/(d/...))). Actually for maximize, put parentheses like a/(b/(c/d...)). Let's analyze: For 2/3/4: Without parentheses it's (2/3)/4 = 0.1667. If we put parentheses 2/(3/4) = 2/(0.75)=2.6667. That's max. So algorithm: if len(nums)==1 return str(nums[0]); if len==2 return f\"{nums[0]}/{nums[1]}\"; else return f\"{nums[0]}/({nums[1]}/{...})\". Build recursively. Steps: Input array, handle base cases, build string recursively. Use recursion to create parentheses. Avoid redundant parentheses: Only add parentheses around rest when length>2. Implementation steps: define function build(nums, start, end). If start==end: return str(nums[start]); If start+1==end: return f\"{nums[start]}/{nums[start+1]}\"; else: return f\"{nums[start]}/({build(nums, start+1, end)})\". That is.\n\nNow produce virtual code line by line. We'll have start, decision branches.\n\nLet's craft virtual steps:\n\nStart // begin\n→ Step 1: Input array nums // get input\n→ Decision: length of nums <=2? // handle short arrays\n    Yes → Step 2: If length==1 return string of nums[0] // single number\n    No  → Step 3: If length==2 return \"nums[0]/nums[1]\" // two numbers\n        No → Step 4: Call helper function Build(nums, 0, len(nums)-1) // compute expression for longer\n→ Function Build(nums, start, end) // recursive\n    → Decision: start==end? // single element\n        Yes → Return string of nums[start] // leaf\n        No  → Decision: start+1==end? // two elements\n            Yes → Return \"nums[start]/nums[start+1]\" // base two\n            No  → Return \"nums[start]/(\" + Build(nums, start+1, end) + \")\" // wrap rest in parentheses\nEnd // finish\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". We need to format exactly: \"Start // 程式開始執行\" etc.\n\nLet's produce. We'll maintain indentation for decisions with spaces.\n\nAlso we must ensure \"虛擬碼步驟\" maybe include \"→\" etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 取得輸入數值  \n→ Decision: nums 長度 <= 2? // 判斷是否為短陣列  \n  Yes → Step 2: 如果長度為 1，回傳 nums[0] 的字串表示 // 只有一個數，只需回傳其值  \n  No  → Step 3: 如果長度為 2，回傳 \"nums[0]/nums[1]\" 的字串表示 // 兩個數直接相除  \n  No  → Step 4: 呼叫 Helper(nums, 0, len(nums)-1) 以處理長陣列 // 進一步建構表達式  \n→ Function Helper(nums, start, end) // 以遞迴方式構造表達式  \n  → Decision: start == end? // 只剩一個數  \n    Yes → Return str(nums[start]) // 回傳該數字的字串  \n    No  → Decision: start + 1 == end? // 只剩兩個數  \n      Yes → Return str(nums[start]) + \"/\" + str(nums[start+1]) // 直接相除  \n      No  → Return str(nums[start]) + \"/(\" + Helper(nums, start+1, end) + \")\" // 把後面部分包成括號  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def optimalDivision(self, nums):\n        \"\"\"\n        Construct the maximum value division expression from the list of integers.\n        For more than two numbers, wrap all numbers after the first inside a\n        single set of parentheses: a/(b/c/d/...).\n        \"\"\"\n        if len(nums) == 1:\n            return str(nums[0])\n        if len(nums) == 2:\n            return f\"{nums[0]}/{nums[1]}\"\n        # For 3 or more numbers: a/(b/c/d/...)\n        rest = \"/\".join(map(str, nums[1:]))\n        return f\"{nums[0]}/({rest})\"\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin (e.g., \"[1000,100,10,2]\")\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Safely parse the list of integers\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception as e:\n        raise ValueError(f\"Invalid input format: {raw_input}\") from e\n\n    # Compute the optimal division expression\n    solution = Solution()\n    result = solution.optimalDivision(nums)\n\n    # Print the result surrounded by double quotes as required by the specification\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1000,100,10,2]",
          "expected_output": "\"1000/(100/10/2)\"",
          "success": true,
          "output": "\"1000/(100/10/2)\""
        },
        {
          "example_index": 1,
          "input": "[2,3,4]",
          "expected_output": "\"2/(3/4)\"",
          "success": true,
          "output": "\"2/(3/4)\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode368.json",
    "problem_index_in_file": 0,
    "title": "Largest Divisible Subset",
    "description_snippet": "Given a set of distinct positive integers nums, return the largest subset answer such that every pai...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode) for the problem: find largest divisible subset from a set of distinct positive integers. Provide line by line virtual code with explanation.\n\nWe need to use structure: Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow \"→\". For decisions use \"Decision: ...\". Indentation with 4 spaces or as in example.\n\nWe need to produce algorithm steps: sort nums, DP array size, backtrack to reconstruct subset, etc.\n\nAlso consider ties.\n\nLet's produce pseudocode:\n\nStart\n→ Step 1: Sort nums ascending // 排序以便遞增比較\n→ Step 2: Initialize DP array of length n, each DP[i] = 1 // 每個位置最長子集長度\n→ Step 3: Initialize Parent array of length n, each Parent[i] = -1 // 用於回溯子集\n→ Decision: For each i from 0 to n-1\n    → Step 4: For each j from 0 to i-1\n        → Decision: If nums[i] % nums[j] == 0\n            → Step 5: If DP[j] + 1 > DP[i]\n                → Step 6: Set DP[i] = DP[j] + 1\n                → Step 7: Set Parent[i] = j\n→ Step 8: Find index maxIdx with maximum DP value // 最大子集長度所在位置\n→ Step 9: Initialize empty list result // 用於儲存最終子集\n→ Decision: While maxIdx != -1\n    → Step 10: Add nums[maxIdx] to result // 添加當前元素\n    → Step 11: Set maxIdx = Parent[maxIdx] // 移到父節點\n→ Step 12: Reverse result // 由小到大排序\n→ End\n\nAdd explanation comments.\n\nLet's format each line accordingly.\n\nNeed to include arrows for decision blocks. Provide indentations.\n\nWill produce:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 排序以便後續比較\n→ Step 2: Initialize DP array of length n, each DP[i] = 1 // 每個位置最長可達子集長度\n→ Step 3: Initialize Parent array of length n, each Parent[i] = -1 // 追蹤前一個能連接的索引\n→ Decision: 遍歷 i 從 0 到 n-1\n    → Step 4: 遍歷 j 從 0 到 i-1\n        → Decision: 如果 nums[i] % nums[j] == 0\n            → Step 5: 如果 DP[j] + 1 > DP[i]\n                → Step 6: DP[i] = DP[j] + 1 // 更新更長子集長度\n                → Step 7: Parent[i] = j // 記錄連接節點\n→ Step 8: 找到最大 DP[i] 的索引 maxIdx // 最大子集所在位置\n→ Step 9: 初始化空列表 result // 儲存答案\n→ Decision: 將 maxIdx 追蹤回 Parent\n    → Step 10: 添加 nums[maxIdx] 至 result // 加入子集\n    → Step 11: maxIdx = Parent[maxIdx] // 移到前一節點\n→ Step 12: 反轉 result // 使順序為遞增\n→ End // 程式執行結束\n\nNeed to ensure formatting: arrow lines start with \"→\". Decision block indentations use 4 spaces. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 將數字按大小排序，以便比較可整除關係  \n→ Step 2: Initialize DP array of length n, each DP[i] = 1 // DP[i] 代表到 i 為止能得到的最大可整除子集長度  \n→ Step 3: Initialize Parent array of length n, each Parent[i] = -1 // Parent[i] 用來追蹤 DP[i] 的前一個索引  \n→ Decision: 遍歷 i 從 0 到 n-1  \n    → Step 4: 遍歷 j 從 0 到 i-1  \n        → Decision: 如果 nums[i] % nums[j] == 0  \n            → Step 5: 如果 DP[j] + 1 > DP[i]  \n                → Step 6: DP[i] = DP[j] + 1 // 更新更長子集長度  \n                → Step 7: Parent[i] = j // 記錄連接節點  \n→ Step 8: 找到最大 DP[i] 的索引 maxIdx // 最大子集所在位置  \n→ Step 9: 初始化空列表 result // 用於儲存答案  \n→ Decision: 將 maxIdx 追蹤回 Parent  \n    → Step 10: 添加 nums[maxIdx] 至 result // 加入子集  \n    → Step 11: maxIdx = Parent[maxIdx] // 移到前一節點  \n→ Step 12: 反轉 result // 使順序為遞增  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def largestDivisibleSubset(self, nums):\n        if not nums:\n            return []\n        nums.sort()\n        n = len(nums)\n        dp = [1] * n\n        prev = [-1] * n\n        max_index = 0\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n            if dp[i] > dp[max_index]:\n                max_index = i\n\n        res = []\n        while max_index >= 0:\n            res.append(nums[max_index])\n            max_index = prev[max_index]\n        return res[::-1]\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串轉成整數列表。\n    支援形如 'nums = [1,2,3]' 或僅為列表字面量 '[1,2,3]'。\n    若無括號，則直接從字串中擷取所有整數。\n    \"\"\"\n    # 先嘗試找到括號中的列表\n    match = re.search(r'\\[.*?\\]', data, flags=re.S)\n    if match:\n        list_str = match.group()\n        try:\n            return ast.literal_eval(list_str)\n        except Exception:\n            pass\n    # 沒有找到括號，直接抓取所有整數\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    return nums\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    sol = Solution()\n    result = sol.largestDivisibleSubset(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,4,8]",
          "expected_output": "[1,2,4,8]",
          "success": true,
          "output": "[1, 2, 4, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode705.json",
    "problem_index_in_file": 0,
    "title": "Design HashSet",
    "description_snippet": "Design a HashSet without using any built-in hash table libraries.\n\nImplement MyHashSet class:\n\nvoid ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for designing a HashSet without built-in hash table libraries. Provide step-by-step virtual code with explanations.\n\nThe instructions: output format with each line: \"虛擬碼步驟 // 解釋\". Use arrow markers: Start, End, Decision, etc.\n\nWe need to design a MyHashSet class with add, contains, remove. We need to show virtual code step by step. Use maybe separate lines for initialization of buckets, hash function, etc.\n\nWe need to design algorithm: use an array of linked lists or dynamic arrays to handle collisions. For simplicity, use a simple hash table with buckets of arrays or lists. Each key hashed to index modulo number of buckets.\n\nWe need to show initialization: set bucket count, maybe prime. Provide virtual code steps: Initialize buckets array, each bucket as empty list.\n\nAdd: compute index, check if key already in bucket, if not push.\n\nContains: compute index, iterate bucket.\n\nRemove: compute index, find key, remove.\n\nAlso need to handle resizing? Not necessary.\n\nWe need to output virtual code with lines starting with \"Start\", \"→ Step ...\", \"→ Decision ...\", \"Yes → ...\", \"No → ...\", \"End\".\n\nAlso include methods inside class maybe.\n\nLet's design:\n\nStart // 程式開始\n→ Step 1: Define class MyHashSet // 定義 HashSet 類別\n→ Step 2: Set constant NUM_BUCKETS = 769 // 初始化桶數量（素數以減少碰撞）\n→ Step 3: Create buckets array of size NUM_BUCKETS, each bucket is empty list // 建立桶陣列\n→ Decision: 是否需要初始化? // 確保桶已初始化\n    Yes → End // 如果已初始化則結束初始化\n    No  → Step 4: For i in 0..NUM_BUCKETS-1: buckets[i] = empty list // 為每個桶分配空列表\n\n→ Step 5: Define hash(key): return key mod NUM_BUCKETS // 哈希函式\n\n→ Step 6: Define add(key): // 加入 key\n    → Compute idx = hash(key) // 先哈希\n    → Step 7: For each element e in buckets[idx]:\n        → Decision: 如果 e == key? // 是否已存在\n            Yes → Return // 已存在，終止\n            No → Continue\n    → Step 8: Append key to buckets[idx] // 新增到桶\n    → Return\n\n→ Step 9: Define contains(key): // 檢查 key\n    → Compute idx = hash(key)\n    → Step 10: For each element e in buckets[idx]:\n        → Decision: e == key?\n            Yes → Return True\n            No → Continue\n    → Return False\n\n→ Step 11: Define remove(key): // 移除 key\n    → Compute idx = hash(key)\n    → Step 12: For each element e in buckets[idx] with index j:\n        → Decision: e == key?\n            Yes → Remove buckets[idx][j] // 從列表中移除\n            No → Continue\n    → Return\n\nEnd // 程式結束\n\nBut we need to use arrow and format. Must include \"→\" each step line. Also use \"Decision:\" lines with Yes → and No →.\n\nLet's create the virtual code accordingly.\n\nLet's produce each line:\n\nStart // 程式開始執行\n→ Step 1: Define class MyHashSet // 建立 HashSet 類別\n→ Step 2: Set NUM_BUCKETS = 769 // 定義桶數量，使用素數以降低碰撞\n→ Step 3: Create array buckets[NUM_BUCKETS] // 初始化桶陣列\n→ Decision: buckets 已空? // 檢查桶是否已經被初始化\n    Yes → End // 若已初始化則不再進行初始化\n    No  → Step 4: For i = 0 to NUM_BUCKETS-1: buckets[i] = empty list // 為每個桶建立空列表\n→ Step 5: Define function hash(key): return key mod NUM_BUCKETS // 哈希函式\n→ Step 6: Define method add(key): // 加入元素\n    → Step 6.1: idx = hash(key) // 計算鍵的桶索引\n    → Step 6.2: For each element e in buckets[idx]:\n        → Decision: e == key? // 檢查鍵是否已存在\n            Yes → Return // 已存在，無需再次加入\n            No  → Continue\n    → Step 6.3: Append key to buckets[idx] // 將鍵加入對應桶\n    → Return\n→ Step 7: Define method contains(key): // 判斷是否包含元素\n    → Step 7.1: idx = hash(key)\n    → Step 7.2: For each element e in buckets[idx]:\n        → Decision: e == key?\n            Yes → Return True // 找到，返回真\n            No  → Continue\n    → Return False // 未找到，返回假\n→ Step 8: Define method remove(key): // 刪除元素\n    → Step 8.1: idx = hash(key)\n    → Step 8.2: For each element e in buckets[idx] with index j:\n        → Decision: e == key?\n            Yes → Remove buckets[idx][j] // 從列表中刪除\n            No  → Continue\n    → Return\nEnd // 程式結束執行\n\nBut we need each line separate. Ensure \"→\" prefix. The \"Decision:\" line should indent the Yes/No lines.\n\nWe must follow format exactly: each line \"虛擬碼步驟 // 解釋\".\n\nMake sure no code, just virtual.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Define class MyHashSet // 建立 HashSet 類別\n→ Step 2: Set NUM_BUCKETS = 769 // 定義桶數量，使用素數以降低碰撞\n→ Step 3: Create array buckets[NUM_BUCKETS] // 初始化桶陣列\n→ Decision: buckets 已空? // 檢查桶是否已經被初始化\n    Yes → End // 若已初始化則不再進行初始化\n    No  → Step 4: For i = 0 to NUM_BUCKETS-1: buckets[i] = empty list // 為每個桶建立空列表\n→ Step 5: Define function hash(key): return key mod NUM_BUCKETS // 哈希函式\n→ Step 6: Define method add(key): // 加入元素\n    → Step 6.1: idx = hash(key) // 計算鍵的桶索引\n    → Step 6.2: For each element e in buckets[idx]:\n        → Decision: e == key? // 檢查鍵是否已存在\n            Yes → Return // 已存在，無需再次加入\n            No  → Continue\n    → Step 6.3: Append key to buckets[idx] // 將鍵加入對應桶\n    → Return\n→ Step 7: Define method contains(key): // 判斷是否包含元素\n    → Step 7.1: idx = hash(key)\n    → Step 7.2: For each element e in buckets[idx]:\n        → Decision: e == key?\n            Yes → Return True // 找到，返回真\n            No  → Continue\n    → Return False // 未找到，返回假\n→ Step 8: Define method remove(key): // 刪除元素\n    → Step 8.1: idx = hash(key)\n    → Step 8.2: For each element e in buckets[idx] with index j:\n        → Decision: e == key?\n            Yes → Remove buckets[idx][j] // 從列表中刪除\n            No  → Continue\n    → Return\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport json\n\nclass MyHashSet:\n    def __init__(self):\n        self.size = 769  # 使用素數作為桶數，以降低碰撞\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        h = self._hash(key)\n        if key not in self.buckets[h]:\n            self.buckets[h].append(key)\n\n    def remove(self, key: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        try:\n            bucket.remove(key)\n        except ValueError:\n            pass  # 若鍵不存在，直接忽略\n\n    def contains(self, key: int) -> bool:\n        h = self._hash(key)\n        return key in self.buckets[h]\n\ndef main() -> None:\n    raw_input = sys.stdin.read().strip().splitlines()\n    if not raw_input:\n        return\n\n    ops = json.loads(raw_input[0])           # 讀取操作列表\n    args = json.loads(raw_input[1]) if len(raw_input) > 1 else []  # 讀取參數列表\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyHashSet\":\n            obj = MyHashSet()\n            result.append(None)  # 返回 null\n        elif op == \"add\":\n            obj.add(arg[0])\n            result.append(None)\n        elif op == \"remove\":\n            obj.remove(arg[0])\n            result.append(None)\n        elif op == \"contains\":\n            result.append(obj.contains(arg[0]))\n\n    print(json.dumps(result))  # 直接使用 json.dumps 轉換為符合 LeetCode 風格的輸出\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]",
          "expected_output": "[null, null, null, true, false, null, true, null, false]",
          "success": true,
          "output": "[null, null, null, true, false, null, true, null, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode645.json",
    "problem_index_in_file": 0,
    "title": "Set Mismatch",
    "description_snippet": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanation comments, in Traditional Chinese. Use arrow syntax. Problem: find duplicate and missing number. Approach: use frequency array or set. Virtual steps: start, initialize count array of size n+1 zero, iterate nums, find duplicate when count[x] >0, increment. Then find missing as i with count[i]==0. Return [duplicate, missing]. Or use XOR. We'll write simple. Need to reflect input: nums array length n, values 1..n with one duplicate. Steps. Let's produce virtual code.\n\nLet's ensure format: each line \"虛擬碼步驟 // 解釋\". Use arrows. Let's do Start, → Step etc.\n\nWe need to mention n = length of nums. Use array count. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度，代表 1~n\n→ Step 2: Create array count[1..n] initialized to 0 // 用於統計每個數字出現次數\n→ Step 3: duplicate ← -1 // 佔位符，預設沒有重複值\n→ Decision: 遍歷 nums? // 準備遍歷\n    → Step 4: for each num in nums // 逐個檢查\n        → Decision: 如果 count[num] == 0? // 這個數字第一次出現\n            → Step 5: count[num] ← 1 // 記錄出現\n            No  → Step 6: duplicate ← num // 第二次出現，記下重複數\n→ Step 7: missing ← -1 // 佔位符，預設沒有遺漏值\n→ Decision: 檢查 count 1~n? // 查找缺失的數字\n    → Step 8: for i from 1 to n\n        → Decision: 如果 count[i] == 0? // 這個位置沒有任何數字\n            → Step 9: missing ← i // 記下遺漏數\n→ Step 10: return [duplicate, missing] // 將結果放入陣列輸出\nEnd // 程式執行結束\n\nMake sure each line ends with // explanation. Provide arrow formatting. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度，代表 1~n  \n→ Step 2: count[1..n] ← array of zeros // 用於統計每個數字出現次數  \n→ Step 3: duplicate ← -1 // 佔位符，預設沒有重複值  \n→ Step 4: missing ← -1 // 佔位符，預設沒有遺漏值  \n→ Decision: 遍歷 nums? // 準備遍歷整個陣列  \n  Yes → Step 5: for each num in nums // 逐個檢查每個數字  \n     Decision: 如果 count[num] == 0? // 這個數字第一次出現  \n      Yes → Step 6: count[num] ← 1 // 記錄第一次出現  \n      No → Step 7: duplicate ← num // 第二次出現，記下重複數  \n→ Decision: 查找缺失數字? // 在 count 陣列中找值為 0 的位置  \n  Yes → Step 8: for i from 1 to n // 逐個檢查 1~n  \n     Decision: 如果 count[i] == 0? // 這個位置沒有任何數字  \n      Yes → Step 9: missing ← i // 記下遺漏數  \n→ Step 10: return [duplicate, missing] // 將結果放入陣列輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\n\nclass Solution:\n    def findErrorNums(self, nums):\n        \"\"\"\n        找出重複的數字與遺失的數字。\n        使用集合計算重複值以及遺失值。\n        \"\"\"\n        n = len(nums)\n        num_set = set(nums)\n\n        # 重複數字：總和減去唯一值的總和\n        duplicate = sum(nums) - sum(num_set)\n\n        # 遺失數字：1~n 的總和減去唯一值的總和\n        missing = n * (n + 1) // 2 - sum(num_set)\n\n        return [duplicate, missing]\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串解析為 nums 列表。\n    支援兩種格式：\n    1. 'nums = [1,2,2,4]'\n    2. '[1,2,2,4]'\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n\n    # 如果包含等號，取等號後面的部分\n    if '=' in data:\n        _, nums_part = data.split('=', 1)\n        nums_part = nums_part.strip()\n    else:\n        nums_part = data\n\n    # 使用 eval 解析 Python 列表字面量\n    try:\n        nums = eval(nums_part, {\"__builtins__\": None}, {})\n    except Exception:\n        # 若 eval 失敗，嘗試手動解析\n        nums = [int(x.strip()) for x in nums_part.strip('[]').split(',') if x.strip()]\n    return nums\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有資料\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n\n    # 解題\n    solution = Solution()\n    result = solution.findErrorNums(nums)\n\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,4]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode458.json",
    "problem_index_in_file": 0,
    "title": "Poor Pigs",
    "description_snippet": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out wh...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: classic problem. We need to produce steps. We'll output each line with \"虛擬碼步驟 // 解釋\".\n\nWe need to design algorithm: compute number of tests rounds = minutesToTest / minutesToDie (integer division). In each round we can encode base (rounds+1) digits? Actually classic solution: number of states each pig can represent is rounds+1 (alive after each round until dies). So need pigs = ceil(log_buckets / log(rounds+1)). Because each pig can be in (rounds+1) states. Equivalent: compute pigs as smallest integer p such that (rounds+1)^p >= buckets. So we iterate.\n\nThus produce virtual code:\n\nStart\n→ Compute rounds = minutesToTest / minutesToDie // integer division\n→ If rounds <= 0 → return 0 // no rounds?\n→ Set base = rounds + 1 // number of states per pig\n→ Set pigs = 0\n→ Set power = 1 // base^pigs\n→ While power < buckets:\n      → Increment pigs\n      → power = power * base\n→ Return pigs\nEnd\n\nAlso we need to handle case buckets <= 0 -> 0.\n\nLet's produce as virtual code lines.\n\nAlso we might include explanation of logic.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 是否有任何可用時間? // 檢查 minutesToTest 是否足以進行一次測試\n    Yes → Step 1: 計算可進行的完整測試回合 = minutesToTest / minutesToDie // 每回合需要 minutesToDie 分鐘\n    No  → Step 2: 回傳 0 // 沒有時間，無法測試，需 0 隻豬\n→ Decision: 若 buckets <= 0? // 檢查桶的數量是否有效\n    Yes → Step 3: 回傳 0 // 無桶不需要豬\n    No  →\n→ Step 4: 設定 base = rounds + 1 // 每隻豬在每回合可呈現 (alive or die at specific round)\n→ Step 5: 初始化 pigs = 0 // 目前已計算的豬數\n→ Step 6: 初始化 power = 1 // base^pigs，代表目前可識別的桶數\n→ Decision: 是否已足夠識別所有桶? // 判斷 power 是否達到 buckets\n    Yes → Step 7: 回傳 pigs // 已足夠，返回所需的豬數\n    No →\n        → Step 8: pigs = pigs + 1 // 增加一隻豬\n        → Step 9: power = power * base // 更新可識別的桶數\n        → 跳回 Decision: 是否已足夠識別所有桶? // 重複直到足夠\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport math\n\ndef min_pigs(buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n    \"\"\"\n    依照題目邏輯計算最少需要的豬數。\n    每隻豬在每個測試回合可以分為 2 種狀態：\n    1. 死於第 k 回合\n    2. 在所有回合都存活\n    也就是每隻豬可以呈現 (rounds + 1) 種不同的結果。\n    \"\"\"\n    if buckets <= 0:\n        return 0\n\n    rounds = minutesToTest // minutesToDie  # 可以進行的完整測試回合數\n    if rounds <= 0:\n        return 0\n\n    base = rounds + 1  # 每隻豬的不同結果數\n    pigs = 0\n    power = 1  # base^pigs，代表目前可辨識的桶數\n\n    while power < buckets:\n        pigs += 1\n        power *= base\n\n    return pigs\n\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取所有輸入，預期格式類似：\n    # 'buckets = 4, minutesToDie = 15, minutesToTest = 15'\n    data = sys.stdin.read()\n    # 找出所有整數\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) >= 3:\n        buckets, minutesToDie, minutesToTest = nums[:3]\n        result = min_pigs(buckets, minutesToDie, minutesToTest)\n        print(result)\n    else:\n        # 若輸入格式不符，輸出 0\n        print(0)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 15",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 30",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode49.json",
    "problem_index_in_file": 0,
    "title": "Group Anagrams",
    "description_snippet": "Given an array of strings strs, group the anagrams together. You can return the answer in any order....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for grouping anagrams. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrows, decision, start, end.\n\nLet's outline algorithm: Start, initialize map from signature to list. For each string, sort its characters to get signature. Add to map. After loop, collect values into list of lists. Return result.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: 定義字典 hashMap<signature, list<string>> // 建立哈希表以分組\n→ Decision: 是否有輸入陣列 strs? // 確認陣列存在\n    Yes → Step 2: 迴圈遍歷 strs 中每個 str\n        → Step 3: 取得 str 的字母排序後的 signature // 轉換為鍵\n        → Decision: signature 是否在 hashMap? \n            Yes → Step 4: 將 str 加入對應的列表\n            No  → Step 5: 建立新列表並加入 str，存回 hashMap\n    No  → Step 6: 返回空列表 // 若無輸入則直接回傳空\n→ Step 7: 定義結果列表 res\n→ Step 8: 迭代 hashMap 的值，將每個列表加入 res\n→ Step 9: 返回 res\nEnd\n\nNeed to include arrows and indentation accordingly. Ensure each line includes virtual code and comment.\n\nWe must not output actual code; just virtual steps.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 hashMap<signature, list<string>> groups // 建立哈希表分組\n→ Decision: 如果 strs 非空? // 檢查輸入陣列\n    Yes → Step 2: 對 strs 中每個字串 str 進行迴圈 // 遍歷輸入\n        → Step 3: 計算 str 的字母排序 signature // 產生鍵\n        → Decision: signature 是否已存在於 groups? \n            Yes → Step 4: groups[signature].append(str) // 加入已有分組\n            No  → Step 5: groups[signature] = [str] // 新建分組並加入\n    No  → Step 6: 返回空列表 [] // 無輸入直接回傳\n→ Step 7: 初始化結果列表 result = [] // 用於存放所有分組\n→ Step 8: 對 groups 的每個值 list 進行迴圈\n        → Step 9: result.append(list) // 將分組加入結果\n→ Step 10: 返回 result // 結果回傳\nEnd // 程式結束\n\nMake sure indentation for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 hashMap<signature, list<string>> groups // 建立哈希表以分組  \n→ Decision: 如果 strs 非空? // 檢查輸入陣列  \n Yes → Step 2: 對 strs 中每個字串 str 進行迴圈 // 遍歷輸入  \n  → Step 3: 計算 str 的字母排序 signature // 產生鍵  \n  → Decision: signature 是否已存在於 groups?  \n   Yes → Step 4: groups[signature].append(str) // 加入已有分組  \n   No  → Step 5: groups[signature] = [str] // 新建分組並加入  \n No  → Step 6: 返回空列表 [] // 無輸入直接回傳  \n→ Step 7: 初始化結果列表 result = [] // 用於存放所有分組  \n→ Step 8: 對 groups 的每個值 list 進行迴圈  \n  → Step 9: result.append(list) // 將分組加入結果  \n→ Step 10: 返回 result // 結果回傳  \nEnd // 程式結束",
      "generated_code": "import sys\nfrom collections import defaultdict\nimport json\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"Group anagrams from the input list of strings.\"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))          # Use sorted tuple as the signature\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\ndef main():\n    # Read all input from stdin and execute it to obtain the variable `strs`\n    code = sys.stdin.read()\n    local_vars = {}\n    exec(code, {}, local_vars)            # Execute the assignment safely\n    strs = local_vars.get('strs', [])     # Default to empty list if not defined\n\n    solution = Solution()\n    result = solution.groupAnagrams(strs)\n    # Output in JSON format to match the example representations\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
          "success": true,
          "output": "[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]"
        },
        {
          "example_index": 1,
          "input": "strs = [\"\"]",
          "expected_output": "[[\"\"]]",
          "success": true,
          "output": "[[\"\"]]"
        },
        {
          "example_index": 2,
          "input": "strs = [\"a\"]",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[[\"a\"]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode546.json",
    "problem_index_in_file": 0,
    "title": "Remove Boxes",
    "description_snippet": "You are given several boxes with different colors represented by different positive numbers.\n\nYou ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for the \"Remove Boxes\" problem (Leetcode 546). It's a DP with memoization: dp[l][r][k] = max points for boxes[l..r] with k same-colored boxes contiguous to the left of l that can be merged. Recurrence: Option 1: remove boxes[l] with its k, then dp[l+1][r][0] + (k+1)^2. Option 2: find i in l+1..r where boxes[i]==boxes[l], then combine: dp[l+1][i-1][0] + dp[i][r][k+1]. Max of all. Need to output pseudocode steps.\n\nWe produce line-by-line pseudocode with explanations. We must use Start, End, Decision etc. Use arrow for steps.\n\nWe'll outline high-level: function removeBoxes(boxes). Use memo 3D map. Recursion solve(l,r,k). Steps: if l>r return 0; if memo exists return; // else compute.\n\nIn recursion: // Option 1: remove group at l.\n\nThen loop i from l+1 to r, if boxes[i]==boxes[l], // combine.\n\nReturn memo.\n\nReturn solve(0,n-1,0). We'll produce pseudocode.\n\nLet's produce each line with explanation. We must follow format: \"虛擬碼步驟 // 解釋\".\n\nWe need to include arrows for decisions: \"Decision: ...\".\n\nWe need Start, End. We will produce algorithm steps.\n\nWe need to include function definitions: \"Function: removeBoxes(boxes) // ...\" etc.\n\nWe need to produce loops, recursion. Use \"→\" for next step.\n\nLet's produce.\n\nWe need to produce maybe indentations but each line separate.\n\nLet's write.\n\nStart // 程式開始執行\n→ Function removeBoxes(boxes) // 入口函數，接收盒子顏色序列\n    → Variable n ← length(boxes) // 盒子總數\n    → Variable memo ← empty 3D map // 用於存儲子問題結果\n    → Return solve(0, n-1, 0) // 以起始索引0、終點n-1、左邊相同顏色數量0開始遞歸\n\n    → Function solve(l, r, k) // 主要遞歸函數\n        → Decision: 如果 l > r? // 判斷子陣列是否為空\n            Yes → Return 0 // 空陣列分數為0\n        → End Decision\n        → Decision: 如果 memo[l][r][k] 已存在? // 檢查是否已計算\n            Yes → Return memo[l][r][k] // 直接返回結果\n        → End Decision\n        → Variable res ← (k+1) * (k+1) + solve(l+1, r, 0) // 選項1：立即刪除 l 及其連續 k 個相同顏色盒子\n        → For i from l+1 to r // 循環檢查後續相同顏色盒子\n            → Decision: 如果 boxes[i] == boxes[l]? // 找到可合併的盒子\n                Yes →\n                    → Variable temp ← solve(l+1, i-1, 0) + solve(i, r, k+1) // 選項2：先刪除中間區域，後合併 l 與 i\n                    → Decision: 如果 temp > res? // 更新最佳分數\n                        Yes → res ← temp\n                    → End Decision\n                No → // 盒子不同，跳過\n            → End Decision\n        → End For\n        → memo[l][r][k] ← res // 記錄結果\n        → Return res // 返回本次子問題分數\n    → End Function solve\n\nEnd // 程式執行結束\n\nBut we need to ensure each line separate. Also we may need arrow indentation.\n\nWe can produce lines like:\n\nStart // 程式開始執行\n→ Function removeBoxes(boxes) // ...\n\nBut we must also include the nested functions with indentation? But each line separate. We can indicate function scopes by indentation but still each line separate. Provide explanation after each line.\n\nWe need to produce lines with arrow \"→\". But the outermost \"Start\" line uses no arrow. For nested lines, we use \"→\" again, but need to indicate indentation. Use spaces maybe. But each line still \"虛擬碼步驟 // 解釋\".\n\nOk.\n\nWe can produce something like:\n\nStart // 程式開始執行\n→ Function removeBoxes(boxes) // 入口函數\n    → Variable n ← length(boxes) // 取得盒子總數\n    → Variable memo ← empty map // 初始化記憶表\n    → Return solve(0, n-1, 0) // 呼叫遞歸解法\n\n    → Function solve(l, r, k) // 定義遞歸子函數\n        → Decision: if l > r? // 判斷區間是否為空\n            Yes → Return 0 // 空區間分數為0\n        → End Decision\n        → Decision: if memo[l][r][k] 已存在? // 檢查記憶表\n            Yes → Return memo[l][r][k] // 直接返回已計算結果\n        → End Decision\n        → Variable res ← (k+1)*(k+1) + solve(l+1, r, 0) // 選項1：立即刪除 l 及其連續 k 個相同顏色盒子\n        → For i from l+1 to r // 迭代後續相同顏色盒子\n            → Decision: if boxes[i] == boxes[l]? // 可合併\n                Yes →\n                    → Variable temp ← solve(l+1, i-1, 0) + solve(i, r, k+1) // 選項2：先刪除中間，後合併\n                    → Decision: if temp > res? // 更新最佳分數\n                        Yes → res ← temp\n                    → End Decision\n                No → // 盒子不同，跳過\n            → End Decision\n        → End For\n        → memo[l][r][k] ← res // 存入記憶表\n        → Return res // 返回結果\n    → End Function solve\n\nEnd // 程式結束\n\nBut we need to ensure each line is separate. The indentation is optional but we need separate lines.\n\nThe lines with arrows inside loops maybe have nested arrows, but each line should still be a separate line.\n\nWe also need to include the \"End Function\" lines with explanation.\n\nLet's write it more clearly.\n\nBut we need to keep \"虛擬碼步驟\" and \" // 解釋\". Use arrow for steps: \"→\" or \"Decision:\" lines.\n\nOk.\n\nLet's craft final output.\n\nAlso we may add some decision for memoization.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Function removeBoxes(boxes) // 入口函數，接收盒子顏色序列\n    → Variable n ← length(boxes) // 取得盒子總數\n    → Variable memo ← empty map // 初始化 3D 記憶表\n    → Return solve(0, n-1, 0) // 從索引 0 開始遞歸計算，左邊無相同顏色盒子\n\n    → Function solve(l, r, k) // 主要遞歸子函數：計算區間 [l,r] 內，左側有 k 個與 boxes[l] 顏色相同的盒子可合併\n        → Decision: if l > r? // 判斷區間是否為空\n            Yes → Return 0 // 空區間分數為 0\n        → End Decision\n        → Decision: if memo[l][r][k] 已存在? // 檢查是否已計算\n            Yes → Return memo[l][r][k] // 直接返回已記錄結果\n        → End Decision\n        → Variable res ← (k+1) * (k+1) + solve(l+1, r, 0) // 選項 1：立即刪除 l 以及其連續的 k 個相同顏色盒子\n        → For i from l+1 to r // 迭代後續可能與 boxes[l] 同色的盒子\n            → Decision: if boxes[i] == boxes[l]? // 找到可合併的盒子\n                Yes →\n                    → Variable temp ← solve(l+1, i-1, 0) + solve(i, r, k+1) // 選項 2：先刪除中間區間，再將 i 與 l 合併\n                    → Decision: if temp > res? // 若此策略分數更高則更新\n                        Yes → res ← temp\n                    → End Decision\n                No → // boxes[i] 與 boxes[l] 不同，跳過\n            → End Decision\n        → End For\n        → memo[l][r][k] ← res // 記錄子問題結果\n        → Return res // 返回本次子問題分數\n    → End Function solve\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nsys.setrecursionlimit(10000)\n\nclass Solution:\n    def removeBoxes(self, boxes):\n        memo = {}\n        n = len(boxes)\n        def dp(l, r, k):\n            if l > r:\n                return 0\n            if (l, r, k) in memo:\n                return memo[(l, r, k)]\n            # 合併右邊相同顏色盒子到 k\n            while r > l and boxes[r] == boxes[r - 1]:\n                r -= 1\n                k += 1\n            # 選項 1：直接刪除右端盒子\n            res = dp(l, r - 1, 0) + (k + 1) ** 2\n            # 選項 2：嘗試與左側相同顏色盒子合併\n            for i in range(l, r):\n                if boxes[i] == boxes[r]:\n                    res = max(res, dp(l, i, k + 1) + dp(i + 1, r - 1, 0))\n            memo[(l, r, k)] = res\n            return res\n        return dp(0, n - 1, 0)\n\ndef parse_input(data):\n    # 取出方括號內的內容並評估為列表\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        # 直接以空列表作為預設\n        return []\n    list_str = match.group(0)\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    boxes = parse_input(data)\n    sol = Solution()\n    result = sol.removeBoxes(boxes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "boxes = [1,3,2,2,2,3,4,3,1]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        },
        {
          "example_index": 1,
          "input": "boxes = [1,1,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "boxes = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode488.json",
    "problem_index_in_file": 0,
    "title": "Zuma Game",
    "description_snippet": "You are playing a variation of the game Zuma. \nIn this variation of Zuma, there is a single row of c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line with explanations. We need algorithm for Zuma game: BFS/DFS search with state board+hand count. Use backtracking or BFS to find min steps. Typical solution uses DFS with memo and recursion; but pseudo-code can outline approach: use recursion to try insert positions, remove groups, count steps, prune with memo. We'll produce steps: define function dfs(board, handCounts, steps) return min steps. If board empty return steps. If steps >= best found or steps >= len(hand) return INF. Use memo key string board+handCounts to avoid recomputation. For each position i from 0 to len(board) inclusive: pick color c in handCounts>0; if inserting at position results same as previous insertion (skip). simulate insertion: newBoard = board[:i] + c + board[i:]; then while possible, compress: find group of >=3 same color and remove; repeat until no more. Then call dfs(newBoard, updated handCounts, steps+1). Keep min. Return min else INF. If INF return -1. Provide pseudo-code.\n\nAlso need to parse hand string into counts map. Use recursion.\n\nWe need line-by-line pseudo-code with explanation. Let's produce.\n\nWe'll use steps:\n\nStart\n→ Step: Parse hand into color counts\n→ Step: Initialize global best = INF\n→ Decision: If board empty? Yes → End return 0\n→ Decision: Else call DFS(board, handCounts, 0)\n→ End\n\nDefine DFS:\nStart\n→ Step: If board empty? Yes → Return steps // 已清空\n→ Step: Build memoKey = board + '#' + handCounts as string\n→ Decision: If memo contains memoKey? Yes → Return memo[memoKey] // 已計算\n→ Step: minSteps = INF\n→ For each i from 0 to len(board): // 位置\n    → For each color c with handCount>0:\n        → Decision: If i>0 and board[i-1]==c and board[i]==c? No skip? // avoid redundant\n        → Step: newHand = handCounts copy; decrement newHand[c]\n        → Step: newBoard = insert c at position i in board\n        → Step: newBoard = compress(newBoard) // remove groups iteratively\n        → Step: res = DFS(newBoard, newHand, steps+1)\n        → Decision: If res < minSteps? Yes → minSteps = res\n→ Step: memo[memoKey] = minSteps\n→ End Return minSteps\n\ncompress:\nStart\n→ Step: While true:\n    → Step: find any group of >=3 same color in board\n    → Decision: If none? Yes → Break\n    → Step: remove that group\n→ End Return board\n\nAfter DFS, if result == INF → return -1 else result.\n\nNeed to handle INF sentinel.\n\nOk produce each line with comment. Use arrow lines.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: handCounts ← CountColors(hand) // 將手牌字串轉為顏色計數表  \n→ Step 2: memo ← EmptyMap() // 用於記錄已計算的 (board, handCounts) 狀態  \n→ Decision: 如果 board 為空？ // 檢查起始棋盤是否已清空  \n    Yes → End 0 // 若棋盤已空，返回 0 步即可  \n→ Step 3: result ← DFS(board, handCounts, 0, memo) // 開始遞迴搜索最小步數  \n→ Decision: 如果 result = INF？  \n    Yes → End -1 // 無法清空，返回 -1  \n    No  → End result // 返回找到的最小步數  \n\n**DFS 函式**  \nStart // DFS 函式開始  \n→ Step 1: If board 為空？  \n    Yes → Return steps // 已成功清空，返回目前已使用的步數  \n→ Step 2: key ← board + \"#\" + Encode(handCounts) // 為 memo 建立鍵值  \n→ Decision: 如果 key 存於 memo？  \n    Yes → Return memo[key] // 若已計算，直接回傳結果  \n→ Step 3: minSteps ← INF // 初始化最小步數  \n→ For i in 0 … len(board) // 循環所有可能插入位置  \n    → For each color c where handCounts[c] > 0 // 只考慮手牌中存在的顏色  \n        → Decision: 如果 i > 0 且 board[i-1] == c 且 board[i] == c？  \n            Yes → Continue // 跳過重複插入相同顏色的情況，避免冗餘  \n        → Step 4: newHand ← Copy(handCounts) // 生成新手牌計數表  \n        → Step 5: newHand[c] ← newHand[c] - 1 // 使用一顆球  \n        → Step 6: newBoard ← Insert(board, i, c) // 在位置 i 插入顏色 c  \n        → Step 7: newBoard ← Compress(newBoard) // 迭代移除連續三個以上同色球  \n        → Step 8: res ← DFS(newBoard, newHand, steps + 1, memo) // 進一步遞迴  \n        → Decision: 如果 res < minSteps？  \n            Yes → minSteps ← res // 更新最小步數  \n→ Step 9: memo[key] ← minSteps // 記錄當前狀態的最小步數  \n→ End Return minSteps  \n\n**Compress 函式**  \nStart // Compress 函式開始  \n→ While True: // 連續重複直到無可移除的組  \n    → Step 1: group ← FindFirstGroup(board, length ≥ 3) // 找第一個可移除組  \n    → Decision: 如果 group 為空？  \n        Yes → Break // 無組可移除，結束迴圈  \n    → Step 2: board ← RemoveGroup(board, group) // 刪除該組  \n→ End Return board  \n\n**輔助函式說明**  \n- CountColors(s): 讀取字串 s，統計各顏色 'R','Y','B','G','W' 的個數，回傳字典。  \n- Encode(counts): 把顏色計數表轉為字串，例如 \"R2Y1B0G3W0\"。  \n- Insert(b, i, c): 在字串 b 的第 i 個位置插入字元 c。  \n- FindFirstGroup(b, len≥3): 在字串 b 中尋找第一個連續同色球長度≥3 的區段，回傳其起止索引。  \n- RemoveGroup(b, g): 刪除字串 b 中索引範圍 g 的子串。  \n\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nCOLORS = ('R', 'Y', 'B', 'G', 'W')\nINF = 10 ** 9\n\ndef compress(s: str) -> str:\n    \"\"\"Iteratively remove groups of 3 or more consecutive same-colored balls.\"\"\"\n    while True:\n        i = 0\n        removed = False\n        while i < len(s):\n            j = i\n            while j + 1 < len(s) and s[j + 1] == s[i]:\n                j += 1\n            if j - i + 1 >= 3:\n                s = s[:i] + s[j + 1:]\n                removed = True\n                break  # restart scanning from the beginning\n            i = j + 1\n        if not removed:\n            break\n    return s\n\ndef find_min_steps(board: str, hand: str) -> int:\n    \"\"\"Return the minimal number of insertions to clear the board, or -1.\"\"\"\n    # Count how many balls of each color we have in hand\n    hand_counts = [0] * 5\n    for ch in hand:\n        hand_counts[COLORS.index(ch)] += 1\n    hand_counts = tuple(hand_counts)\n\n    memo = {}\n\n    def dfs(cur_board: str, cur_counts: tuple) -> int:\n        if not cur_board:\n            return 0\n        key = (cur_board, cur_counts)\n        if key in memo:\n            return memo[key]\n\n        best = INF\n        n = len(cur_board)\n\n        # Try inserting at every possible position\n        for pos in range(n + 1):\n            for idx, cnt in enumerate(cur_counts):\n                if cnt == 0:\n                    continue\n                color = COLORS[idx]\n                # Skip unnecessary duplicates: if left neighbor is the same color, inserting here would not help\n                if pos > 0 and cur_board[pos - 1] == color:\n                    continue\n\n                new_counts = list(cur_counts)\n                new_counts[idx] -= 1\n                new_board = cur_board[:pos] + color + cur_board[pos:]\n                new_board = compress(new_board)\n\n                res = dfs(new_board, tuple(new_counts))\n                if res != -1:\n                    best = min(best, 1 + res)\n\n        memo[key] = -1 if best == INF else best\n        return memo[key]\n\n    return dfs(board, hand_counts)\n\ndef parse_input() -> tuple:\n    \"\"\"Read stdin and extract board and hand strings.\"\"\"\n    data = sys.stdin.read()\n    # Try to match the pattern: board = \"....\", hand = \"....\"\n    m = re.search(r'board\\s*=\\s*\"([^\"]*)\"\\s*,\\s*hand\\s*=\\s*\"([^\"]*)\"', data)\n    if m:\n        return m.group(1), m.group(2)\n    # Fallback: assume two separate lines\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # If only one line, split by whitespace\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # Default empty strings if parsing fails\n    return '', ''\n\nif __name__ == \"__main__\":\n    board, hand = parse_input()\n    result = find_min_steps(board, hand)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode564.json",
    "problem_index_in_file": 0,
    "title": "Find the Closest Palindrome",
    "description_snippet": "Given a string n representing an integer, return the closest integer (not including itself), which i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step algorithm in virtual code, line by line with comments. The algorithm: input string n, return nearest palindrome not equal. Classic LeetCode 564 problem. We need to outline steps: compute length, consider candidate palindromes: mirror left to right, consider adjusting middle digits etc. Outline decision tree: check if n is palindrome? But we exclude itself. So we consider candidates: lower palindrome by decrementing prefix, upper palindrome by incrementing prefix. For even/odd length. Also consider edge cases: 10...01 etc. We produce list of candidates and choose closest.\n\nWe need to produce steps with arrows. Use Start, End. Use Decision lines. Provide explanatory comments after //.\n\nLet's write:\n\nStart\n→ Input n // string representing integer\n→ Let len = length of n\n→ Define candidates list // to store palindrome candidates\n→ Decision: if len == 1? // single digit\n    Yes → Candidate: (n as int) +/- 1? but need not itself\n    No → proceed\n\nWe might need more structure: generate prefix = first (len+1)/2 digits. For even, prefixLen = len/2; for odd, prefixLen = len/2+1.\n\nThen for each offset in [-1,0,1] we generate palindrome by adjusting prefix.\n\nAlso consider edge cases: 1000 -> 999 etc.\n\nLet's produce algorithm:\n\nGenerate function makePal(prefix, len) // produce palindrome string of given length.\n\nWe'll include steps.\n\nOk produce lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 n // 取得要處理的數字字串\n→ Step 2: 計算長度 len = n.length() // 取得 n 的位數\n→ Step 3: 建立空清單 candidates // 存放所有可能的回文候選\n→ Decision: len == 1? // 單一位數\n    Yes → Step 4a: 將 n-1 與 n+1 加入 candidates // 除自己外最鄰近的兩個回文\n    No  → Step 4b: 進行後續處理 // 多位數\n→ Step 4b1: 計算 prefixLen = (len+1)/2 // 取左半部分（含中位）長度\n→ Step 4b2: 取得 prefix = n.substring(0, prefixLen) // 左半部分字串\n→ Decision: prefix 為全 9? // 例如 99, 999\n    Yes → Step 4b3a: 加入 \"9\" repeated (len-1) 次  // 例如 99 -> 9, 999 -> 99\n    No  → Step 4b3b: 進行一般處理 // 取前後變化的回文\n→ Step 4b3b1: 將 prefix 轉為整數 p\n→ Decision: p 為 0? // 情況 like 1000\n    Yes → Step 4b3b2a: 加入 \"9\" repeated (len-1) 次 // 999\n    No  → Step 4b3b2b: 針對偏移 -1,0,+1 生成候選\n        → For offset in [-1, 0, 1]:\n            → Step 4b3b2b1: 計算 newP = p + offset\n            → Step 4b3b2b2: 將 newP 轉為字串 newPref\n            → Step 4b3b2b3: 依據 len 是否偶數產生 palindrome newPal\n                → If len even: newPal = newPref + reverse(newPref)\n                → If len odd:  newPal = newPref + reverse(newPref.substring(0, newPref.length()-1))\n            → Step 4b3b2b4: 將 newPal 加入 candidates\n→ Step 5: 移除 n 本身若出現在 candidates // 不允許自己\n→ Step 6: 從 candidates 中尋找最小 abs差值且若相同差值選較小的值\n→ End // 結束\n\nBut need to maintain arrow style. Let's format each line with arrow \"→\" and indentation.\n\nUse \"Decision:\" lines for decisions.\n\nWe need to include explanation after //.\n\nMake sure each line has single step.\n\nLet's produce.\n\nUse \"Start\" line.\n\nWe need to ensure each line's virtual code.\n\nWe'll use \"→\" and indent for substeps. Use spaces to indent.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Input n // 取得輸入的數字字串\n→ Let len = n.length() // 計算字串長度\n→ Create empty list candidates // 用於儲存所有可能的回文候選\n→ Decision: len == 1? // 單一位數特殊處理\n    Yes → candidates.add(String.valueOf(nInt-1)) // 除自己外最鄰近的較小回文\n    Yes → candidates.add(String.valueOf(nInt+1)) // 除自己外最鄰近的較大回文\n    No  → Proceed // 多位數\n→ Let prefixLen = (len + 1) / 2 // 取左半（含中位）長度\n→ Let prefix = n.substring(0, prefixLen) // 取得左半字串\n→ Decision: isAll9(prefix)? // 如 9,99,999\n    Yes → candidates.add(\"9\".repeat(len - 1)) // 例如 99 -> 9, 999 -> 99\n    No  → Proceed // 常規情況\n→ Let p = Integer.parseInt(prefix) // 把左半轉成整數\n→ Decision: p == 0? // 情況如 1000\n    Yes → candidates.add(\"9\".repeat(len - 1)) // 產生 999\n    No  → Proceed // 生成偏移候選\n→ For offset in [-1, 0, 1]: // 產生前後變化的前綴\n    → Let newP = p + offset\n    → Let newPref = String.valueOf(newP)\n    → Decision: len even?\n        Yes → Let newPal = newPref + reverse(newPref) // 對稱\n        No  → Let newPal = newPref + reverse(newPref.substring(0, newPref.length() - 1)) // 刪除中位重複\n    → candidates.add(newPal) // 加入候選\n→ Remove n from candidates if present // 不能返回自己\n→ Step: best = null\n→ For each cand in candidates:\n    → Let diff = abs(candInt - nInt)\n    → If best is null or diff < bestDiff or (diff == bestDiff and candInt < bestInt):\n        → best = cand\n        → bestDiff = diff\n        → bestInt = candInt\n→ Return best // 最接近的回文\nEnd // 程式結束\n\nBut we need to use \"→\" for each step and \"Decision:\" etc. Need to match required format: Use \"Start\", \"End\", \"Decision:\" lines, and \"Yes →\", \"No →\". So for loops need \"→\" but loops may not be needed; we can just describe as steps. But they requested arrows and structure. Loops may be represented with \"→\" inside block? They didn't forbid loops. We can include \"→ For offset in [-1,0,1]:\" but no arrow inside? We can treat \"→ For offset in [-1, 0, 1]:\" as a step with substeps using indentation.\n\nLet's produce with indentation for clarity.\n\nImportant: Each line must be \"虛擬碼步驟 [空格] // 解釋/說明\". So each line includes exactly one virtual code step, then space, then comment. For substeps, we can indent with spaces before the arrow.\n\nLet's write final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得輸入的數字字串  \n→ Let len = n.length() // 計算字串長度  \n→ Create empty list candidates // 用於儲存所有可能的回文候選  \n→ Decision: len == 1? // 單一位數特殊處理  \n  Yes → Let nInt = Integer.parseInt(n) // 轉成整數  \n  Yes → candidates.add(String.valueOf(nInt - 1)) // 除自己外最鄰近的較小回文  \n  Yes → candidates.add(String.valueOf(nInt + 1)) // 除自己外最鄰近的較大回文  \n  No  → // 多位數繼續處理  \n→ Let prefixLen = (len + 1) / 2 // 取左半（含中位）長度  \n→ Let prefix = n.substring(0, prefixLen) // 取得左半字串  \n→ Decision: isAll9(prefix)? // 如 9,99,999  \n  Yes → candidates.add(\"9\".repeat(len - 1)) // 例如 99 -> 9, 999 -> 99  \n  No  → // 常規情況  \n→ Let p = Integer.parseInt(prefix) // 把左半轉成整數  \n→ Decision: p == 0? // 情況如 1000  \n  Yes → candidates.add(\"9\".repeat(len - 1)) // 產生 999  \n  No  → // 生成偏移候選  \n→ For offset in [-1, 0, 1]: // 產生前後變化的前綴  \n  → Let newP = p + offset // 新的前綴數值  \n  → Let newPref = String.valueOf(newP) // 轉成字串  \n  → Decision: len % 2 == 0? // 是否為偶數位  \n    Yes → Let newPal = newPref + reverse(newPref) // 對稱組成回文  \n    No  → Let newPal = newPref + reverse(newPref.substring(0, newPref.length() - 1)) // 刪除中位重複  \n  → candidates.add(newPal) // 加入候選  \n→ Remove n from candidates if present // 不能返回自己  \n→ Let best = null // 儲存最佳回文  \n→ Let bestDiff = Infinity  \n→ For each cand in candidates: // 遍歷所有候選  \n  → Let candInt = Integer.parseInt(cand) // 轉成整數  \n  → Let diff = abs(candInt - Integer.parseInt(n)) // 絕對差值  \n  → Decision: diff < bestDiff OR (diff == bestDiff AND candInt < Integer.parseInt(best))? // 選擇更近或更小  \n    Yes → best = cand // 更新最佳  \n    Yes → bestDiff = diff // 更新差值  \n    No  → // 不更新  \n→ Return best // 最接近的回文  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        length = len(n)\n        num = int(n)\n        candidates = set()\n\n        # 特殊情況：長度為 len 的所有 9 以及 10^len+1\n        candidates.add(str(10 ** length + 1))\n        candidates.add(str(10 ** (length - 1) - 1))\n\n        # 取得左半部分的數字（含中位）\n        prefix = int(n[:(length + 1) // 2])\n\n        # 產生前綴 +/-1、0、+1 的回文\n        for i in (-1, 0, 1):\n            new_prefix = str(prefix + i)\n            if length % 2 == 0:\n                palin = new_prefix + new_prefix[::-1]\n            else:\n                palin = new_prefix + new_prefix[:-1][::-1]\n            candidates.add(palin)\n\n        # 刪除自身\n        candidates.discard(n)\n\n        # 取最接近的回文，若相同距離則取較小的數字\n        best = None\n        for cand in candidates:\n            cand_int = int(cand)\n            if best is None:\n                best = cand\n                continue\n            best_int = int(best)\n            if abs(cand_int - num) < abs(best_int - num) or \\\n               (abs(cand_int - num) == abs(best_int - num) and cand_int < best_int):\n                best = cand\n\n        return best\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中找出第一組數字（忽略引號與等號）\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = match.group()\n    sol = Solution()\n    ans = sol.nearestPalindromic(n)\n    # 輸出時加上引號，符合題目範例格式\n    print(f'\"{ans}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"123\"",
          "expected_output": "\"121\"",
          "success": true,
          "output": "\"121\""
        },
        {
          "example_index": 1,
          "input": "n = \"1\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "\"0\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode442.json",
    "problem_index_in_file": 0,
    "title": "Find All Duplicates in an Array",
    "description_snippet": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for finding duplicates in array where numbers 1..n appear at most twice. Use O(n) time, O(1) space except output. Approach: iterate array, for each number x, compute index = abs(x)-1, if nums[index] > 0, set nums[index] = -nums[index]; else duplicate, add index+1 to result. This modifies array. After loop, optionally restore array if needed, but not necessary. Provide steps.\n\nWe must output line by line: Start, then each step: Step 1: ... etc. Use arrows. Use Decision. Provide explanations in Chinese. Ensure no actual code, just pseudocode steps. Use virtual arrows →. Ensure each line ends with // 解釋.\n\nLet's craft steps:\n\nStart // 程式開始\n→ Step 1: Initialize empty list result // 用於儲存重複的數字\n→ Step 2: For i from 0 to n-1 // 遍歷整個陣列\n    → Decision: 是否已遍歷完? // 判斷迴圈結束\n        Yes → End // 完成\n        No  → Step 3: current = nums[i] // 取得當前元素\n        → Step 4: index = abs(current) - 1 // 對應索引\n        → Decision: nums[index] > 0? // 判斷是否第一次遇到\n            Yes → Step 5: nums[index] = -nums[index] // 標記為已見\n            No  → Step 6: Append index+1 to result // 已見過，加入結果\n        → Step 7: Continue // 進行下一個 i\nEnd // 程式結束\n\nBut need more precise pseudocode: We should include loops and decisions. Use appropriate indentation. Ensure each line has arrow and explanation. Use Start/End markers.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: result ← empty list // 建立結果儲存空白列表\n→ Step 2: for i from 0 to length(nums)-1 // 遍歷陣列\n    → Decision: i < length(nums)? // 判斷是否還有元素\n        Yes → Step 3: val ← nums[i] // 取得第 i 個元素\n        → Step 4: idx ← abs(val) - 1 // 對應索引，處理已負數\n        → Decision: nums[idx] > 0? // 第一次遇到此數字\n            Yes → Step 5: nums[idx] ← -nums[idx] // 將對應位置標記為負\n            No  → Step 6: result.append(idx + 1) // 已負數，表示重複，加入結果\n        → Step 7: Continue // 繼續下一個 i\n        No  → End // 已遍歷完，結束\nEnd // 程式結束\n\nWe must ensure each line is separated. Provide \"→\" arrow. Use indentation for decisions. Each line has explanation.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← empty list // 建立結果儲存空白列表  \n→ Step 2: for i from 0 to length(nums)-1 // 遍歷陣列  \n&nbsp;&nbsp;&nbsp;→ Decision: i < length(nums)? // 判斷是否還有元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: val ← nums[i] // 取得第 i 個元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: idx ← abs(val) - 1 // 對應索引，處理已負數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: nums[idx] > 0? // 第一次遇到此數字  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: nums[idx] ← -nums[idx] // 將對應位置標記為負  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: result.append(idx + 1) // 已負數，表示重複，加入結果  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: Continue // 繼續下一個 i  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → End // 已遍歷完，結束  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDuplicates(self, nums):\n        res = []\n        for num in nums:\n            index = abs(num) - 1\n            if nums[index] < 0:\n                res.append(abs(num))\n            else:\n                nums[index] = -nums[index]\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n    else:\n        # Extract the list from the input, handling \"nums = [...]\" or just \"[...]\"\n        list_start = data.find('[')\n        if list_start != -1:\n            nums_str = data[list_start:]\n            try:\n                nums = eval(nums_str)\n            except:\n                nums = []\n        else:\n            nums = []\n        result = Solution().findDuplicates(nums)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,2]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode146.json",
    "problem_index_in_file": 0,
    "title": "LRU Cache",
    "description_snippet": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplemen...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation for LRU cache design. Steps should be line by line. Use virtual arrows. Must not output actual code. Use \"Start\", \"End\", \"Decision:\".\n\nWe need to describe initialization, get, put operations.\n\nWe need to explain data structure: doubly linked list + hash map. Steps: Node structure, Cache initialization, get operation steps: check map, if not found return -1; else move node to front; return value. Put operation: if key exists update and move to front; else create new node; add to map and front; if size > capacity, remove tail; delete from map.\n\nWe produce pseudocode steps with explanation. Ensure each line ends with // explanation.\n\nWe also include necessary helper functions: moveToFront, addToFront, removeNode, removeTail.\n\nLet's output.\n\nMake sure each line includes arrow arrow. Example: \"Start // 程式開始執行\".\n\nUse \"→\" arrows. For decision: \"Decision: key 在 map 中?\".\n\nAdd indent for nested steps maybe.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Node // 建立節點結構，儲存 key、value、前驅、後繼指標  \n→ Define LRUCache class // 建立 LRUCache 類別，包含容量、映射表、頭尾指標  \n→ Constructor(capacity)  \n    → Set this.capacity ← capacity // 儲存緩存容量  \n    → Initialize this.map ← empty map // key → Node 的哈希表  \n    → Initialize this.head ← null // 連結串列頭（最近使用）  \n    → Initialize this.tail ← null // 連結串列尾（最久未使用）  \n→ Method get(key)  \n    → Decision: key 存於 map? // 檢查鍵是否存在  \n        Yes →  \n            → node ← map[key] // 取得對應節點  \n            → Call moveToFront(node) // 把節點移到頭部，標記為最近使用  \n            → Return node.value // 回傳值  \n        No →  \n            → Return -1 // 未找到，返回 -1  \n→ Method put(key, value)  \n    → Decision: key 存於 map? // 檢查是否已存在  \n        Yes →  \n            → node ← map[key] // 取得節點  \n            → node.value ← value // 更新值  \n            → Call moveToFront(node) // 移到頭部  \n        No →  \n            → Create newNode with key, value // 新增節點  \n            → Call addToFront(newNode) // 把新節點加到頭部  \n            → map[key] ← newNode // 更新映射表  \n            → Decision: map.size > capacity? // 檢查是否超過容量  \n                Yes →  \n                    → Call removeTail() // 移除最久未使用節點  \n                    → Delete map[tail.key] // 從映射表刪除  \n                No →  \n                    → // 不需處理  \n→ Helper: moveToFront(node)  \n    → Decision: node 是 head? // 已是最近使用，不需移動  \n        No →  \n            → If node.prev ≠ null → node.prev.next ← node.next // 斷開前驅指標  \n            → If node.next ≠ null → node.next.prev ← node.prev // 斷開後繼指標  \n            → If node = tail → tail ← node.prev // 更新尾部  \n            → node.prev ← null // 置為新頭部的前驅  \n            → node.next ← head // 連接至舊頭部  \n            → If head ≠ null → head.prev ← node // 更新舊頭部的前驅  \n            → head ← node // 設置新頭部  \n            → If tail = null → tail ← node // 若為唯一節點，尾部也設為此節點  \n→ Helper: addToFront(node)  \n    → node.prev ← null  \n    → node.next ← head  \n    → If head ≠ null → head.prev ← node  \n    → head ← node  \n    → If tail = null → tail ← node // 第一個節點  \n→ Helper: removeTail()  \n    → If tail = null → return // 無節點  \n    → removed ← tail // 記錄即將刪除的節點  \n    → tail ← tail.prev // 移動尾部指標  \n    → If tail ≠ null → tail.next ← null // 刪除指標  \n    → Else → head ← null // 若已空，頭部也置空  \n    → // 釋放 removed 節點（由語言 GC 處理）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # move to the end (most recently used)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # remove least recently used\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Separate the two lists: operations and arguments\n    close_bracket_idx = data.find(']')\n    ops_str = data[:close_bracket_idx + 1]\n    rest = data[close_bracket_idx + 1:].strip()\n    if rest.startswith(','):\n        rest = rest[1:].strip()\n    args_str = rest\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    outputs = []\n\n    # The first operation is always \"LRUCache\" with its capacity argument\n    capacity = args[0][0]\n    cache = LRUCache(capacity)\n    outputs.append(None)  # constructor returns null\n\n    # Process remaining operations\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == \"put\":\n            cache.put(arg[0], arg[1])\n            outputs.append(None)\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            outputs.append(val)\n        else:\n            # Unsupported operation (should not happen with valid input)\n            outputs.append(None)\n\n    # Print results in JSON format so that None becomes null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "success": true,
          "output": "[null, null, null, 1, null, -1, null, -1, 3, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode9.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Number",
    "description_snippet": "Given an integer x, return true if x is a palindrome, and false otherwise....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code steps line by line. The requirement: Use Start, Decision, etc. Need to produce steps for palindrome check integer x. Steps: convert to string or reverse digits? Approach: convert to string and compare with reverse. Or numeric approach. Use string for simplicity. Steps: convert x to string s. If s equals reverse(s) -> true else false. Provide virtual code lines.\n\nMake sure each line has `虛擬碼步驟` then a space then `// 解釋`. Use arrow for flow: Start, →, Decision, Yes →, No →, End.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 將整數 x 轉為字串 s // 將輸入轉為字串以方便比較\n→ Step 2: 取得字串 s 的反轉 r // 取得 s 的倒序\n→ Decision: s 是否等於 r? // 判斷是否為回文\n    Yes → Step 3: 回傳 true // 回文，返回真\n    No  → Step 4: 回傳 false // 非回文，返回假\nEnd // 程式執行結束\n\nMake sure each line has the format `虛擬碼步驟 // 解釋`. Ensure line breaks. Use arrow lines with spaces. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將整數 x 轉為字串 s // 將輸入轉為字串以方便比較  \n→ Step 2: 取得字串 s 的反轉 r // 取得 s 的倒序  \n→ Decision: s 是否等於 r? // 判斷是否為回文  \n  Yes → Step 3: 回傳 true // 回文，返回真  \n  No  → Step 4: 回傳 false // 非回文，返回假  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        檢查整數 x 是否為回文數。負數直接返回 False，\n        其餘數字轉成字串後與反轉字串比較。\n        \"\"\"\n        if x < 0:\n            return False\n        s = str(x)\n        return s == s[::-1]\n\ndef main():\n    \"\"\"\n    從標準輸入讀取資料，尋找第一個整數並判斷其是否為回文。\n    輸出結果為 'true' 或 'false'（全小寫）。\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 只取第一個符合整數模式的數字\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    x = int(match.group())\n    sol = Solution()\n    result = sol.isPalindrome(x)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 121",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = -121",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 10",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode421.json",
    "problem_index_in_file": 0,
    "title": "Maximum XOR of Two Numbers in an Array",
    "description_snippet": "Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for maximum XOR of two numbers in array. Standard algorithm: build binary trie, for each number find max XOR counterpart. So steps: Start, read array, build trie, for each number, query, track max, return. Provide explanation each line. Use decision structure for insertion and query. Also loops. Use \"→\" arrow. Provide Start/End. Each line include code + comment. Let's do.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: input array nums // 取得整數陣列\n→ Step 2: 建立空的二進位 trie root // 建構前綴樹的根節點\n→ Step 3: 針對每個 number in nums 執行插入 // 將所有數字加入 trie\n    → Step 3a: 將 number 轉為 32 位二進位串 // 確保長度一致\n    → Step 3b: 針對每個 bit（從最高位到最低位）進行插入\n        → Decision: 若 bit 為 0? // 判斷當前位\n            Yes → Step 3c: 若 current.left 為 null, 創建新節點 // 建立子節點\n            No  → Step 3d: 若 current.right 為 null, 創建新節點 // 建立子節點\n        → Step 3e: 更新 current 為對應子節點 // 走向下一層\n→ Step 4: 初始化 maxXOR 為 0 // 用來存最大 XOR 結果\n→ Step 5: 再次針對每個 number in nums 執行查詢以獲取最大 XOR\n    → Step 5a: 將 number 轉為 32 位二進位串\n    → Step 5b: 初始化 current 為 trie root，currentXOR 為 0\n    → Step 5c: 針對每個 bit（從最高位到最低位）進行查詢\n        → Decision: 若 bit 為 0?\n            Yes → Step 5d: 若 current.right 存在, currentXOR = (currentXOR << 1) | 1, current = current.right\n            No  → Step 5e: 若 current.right 不存在, currentXOR = (currentXOR << 1), current = current.left\n        → Decision: 若 bit 為 1?\n            Yes → Step 5f: 若 current.left 存在, currentXOR = (currentXOR << 1) | 1, current = current.left\n            No  → Step 5g: 若 current.left 不存在, currentXOR = (currentXOR << 1), current = current.right\n    → Step 5h: 若 currentXOR > maxXOR, 更新 maxXOR = currentXOR // 取得更大的 XOR\n→ Step 6: 輸出 maxXOR // 回傳最終結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMaximumXOR(self, nums):\n        \"\"\"\n        找到數組中任意兩個數的 XOR 最大值。\n        使用位掩碼方法，時間複雜度 O(32 * n)。\n        \"\"\"\n        if not nums:\n            return 0\n\n        max_xor = 0\n        mask = 0\n        # 逐位從最高位到最低位進行判斷\n        for i in range(31, -1, -1):\n            mask |= (1 << i)                     # 將第 i 位加入掩碼\n            prefixes = {num & mask for num in nums}   # 取前 i+1 位的前綴\n            candidate = max_xor | (1 << i)          # 試圖把第 i 位設為 1\n            # 檢查是否存在兩個前綴的 XOR 等於 candidate\n            found = False\n            for p in prefixes:\n                if (candidate ^ p) in prefixes:\n                    found = True\n                    break\n            if found:\n                max_xor = candidate\n        return max_xor\n\ndef main():\n    \"\"\"\n    從標準輸入讀取資料，格式類似於：\n        nums = [3,10,5,25,2,8]\n    或者僅僅是一個列表文字：\n        [3,10,5,25,2,8]\n    \"\"\"\n    data = sys.stdin.read()\n    # 把所有整數提取出來，假設輸入中只包含待處理的整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    solution = Solution()\n    result = solution.findMaximumXOR(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,10,5,25,2,8]",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 1,
          "input": "nums = [14,70,53,83,49,91,36,80,92,51,66,70]",
          "expected_output": "127",
          "success": true,
          "output": "127"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode524.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary through Deleting",
    "description_snippet": "Given a string s and a string array dictionary, return the longest string in the dictionary that can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing the algorithm for finding the longest word in dictionary that can be formed by deleting some characters from string s. Must adhere to format: each line has \"虛擬碼步驟 // 解釋/說明\". Use arrows, Start, End, Decision. Also need to include handling of dictionary sorted etc. Provide step-by-step virtual pseudocode. No actual code. Provide lines with indentation maybe.\n\nWe need to produce an algorithm: iterate through dictionary words, check if word is subsequence of s. Keep track of best word based on length then lexicographical order.\n\nSteps: Start, load input, sort dictionary by length descending then lex ascending? Actually to ensure lexicographic order only when same length, we can sort by length descending, lex ascending. Then iterate and pick first that is subsequence. Alternatively iterate all and compare.\n\nWe'll produce virtual code: Start, read s, dictionary, sort dictionary, set result empty, for each word in dictionary, check subsequence via two pointers, if yes, result = word, break (since sorted). Then End. Also we can explain decision if subsequence.\n\nLet's craft lines:\n\nStart\n→ Read s, dictionary\n→ Decision: dictionary non-empty? \n    Yes → Step 1: Sort dictionary by (-len(word), word) // length descending, lex ascending\n    No  → Step 2: Return empty string\n→ Step 2: Initialize bestWord = \"\" // placeholder\n→ For each word in dictionary:\n        → Decision: isSubsequence(word, s)? // check if word can be formed\n            Yes → Step 3: bestWord = word ; Break // first match is best\n            No  → continue\n→ Step 4: Return bestWord // may be empty\nEnd\n\nAlso we need to define isSubsequence procedure: we can include Step: isSubsequence function with two pointers.\n\nLet's add those lines.\n\nWe must use virtual code arrow syntax.\n\nWe may include substeps.\n\nWe must keep lines in order, each with explanation.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s 與字典 array dictionary // 從使用者取得資料  \n→ Decision: dictionary 是否非空? // 檢查字典是否有單詞  \n    Yes → Step 2: 依字長降序、字典順升序排序 dictionary // 先長後字典順  \n    No  → Step 3: 回傳空字串 \"\" // 無單詞可比對  \n→ Step 4: 設定 bestWord = \"\" // 儲存目前最佳答案  \n→ Step 5: 定義函式 isSubsequence(word, s)  \n    → 虛擬碼：設兩指標 i = 0, j = 0 // 分別指向 word 與 s  \n    → Decision: i < len(word) 且 j < len(s)?  \n        Yes → Decision: word[i] == s[j]?  \n            Yes → i += 1 ; j += 1 // 兩字母相符，往下尋找  \n            No  → j += 1 // 只移動 s 指標  \n        No  → Return i == len(word) // 判斷是否已匹配完 word  \n→ For each word in dictionary: // 逐一檢查每個單詞  \n        → Decision: isSubsequence(word, s)? // 能否由 s 刪字得到 word？  \n            Yes → Step 6: bestWord = word ; Break // 第一個符合即為最佳  \n            No  → Continue // 試下一個單詞  \n→ Step 7: 回傳 bestWord // 可能為空字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_longest_word(s: str, dictionary: list[str]) -> str:\n    \"\"\"\n    Find the longest word in `dictionary` that can be formed by deleting some\n    characters from `s`. If there are ties in length, return the lexicographically\n    smallest one.\n    \"\"\"\n    # Sort by decreasing length, then lexicographical order\n    dictionary.sort(key=lambda x: (-len(x), x))\n\n    for word in dictionary:\n        it = iter(s)\n        if all(char in it for char in word):\n            return word\n    return \"\"\n\ndef main() -> None:\n    \"\"\"\n    Reads input from stdin and prints the answer to stdout.\n    Input format (two possible):\n      1. One line: \"s\", [dict]\n      2. Two lines: s on the first, [dict] on the second\n    \"\"\"\n    content = sys.stdin.read().strip()\n    if not content:\n        return\n\n    # Case 1: Two separate lines\n    if \"\\n\" in content:\n        lines = content.splitlines()\n        s_line = lines[0].strip()\n        dict_line = lines[1].strip()\n        s = ast.literal_eval(s_line)\n        dictionary = ast.literal_eval(dict_line)\n    else:\n        # Case 2: Single line, combine into a tuple for literal_eval\n        wrapped = f\"({content})\"\n        s, dictionary = ast.literal_eval(wrapped)\n\n    result = find_longest_word(s, dictionary)\n    # Print with surrounding double quotes as per the examples\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"]",
          "expected_output": "\"apple\"",
          "success": true,
          "output": "\"apple\""
        },
        {
          "example_index": 1,
          "input": "\"abpcplea\", [\"a\",\"b\",\"c\"]",
          "expected_output": "\"a\"",
          "success": true,
          "output": "\"a\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode599.json",
    "problem_index_in_file": 0,
    "title": "Minimum Index Sum of Two Lists",
    "description_snippet": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\n\nA co...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. Use Start, Decision, etc. We must not output actual code, just steps. So we create step-by-step algorithm for this problem. Use dictionary mapping string to index for list1, iterate list2, compute sums, track min sum and results.\n\nLet's produce step-by-step virtual code with arrows, decisions, etc.\n\nLet's produce maybe:\n\nStart\n→ Step 1: Initialize map1 as empty dictionary // store string to index from list1\n→ Step 2: For each index i and string s in list1 // populate map1\n    → Step 2a: map1[s] = i // record index\n\n→ Step 3: Initialize minSum to Infinity // track smallest index sum\n→ Step 4: Initialize resultList as empty list // store common strings with min sum\n\n→ Step 5: For each index j and string s in list2 // iterate over second list\n    → Decision: 是否存在 s in map1? // check if common\n        Yes →\n            → Step 5a: Compute sum = map1[s] + j // index sum\n            → Decision: sum < minSum? // new smaller sum\n                Yes →\n                    → Step 5a1: Set minSum = sum // update min\n                    → Step 5a2: Clear resultList // remove previous\n                    → Step 5a3: Append s to resultList // add current\n                No →\n                    → Decision: sum == minSum? // same min\n                        Yes →\n                            → Step 5a4: Append s to resultList // add current\n                        No →\n                            → Step 5a5: Do nothing // ignore\n        No → Step 5b: Continue // not common, skip\n\n→ End // return resultList\n\nWe need to produce as virtual code lines with // explanation. Use proper arrow. Use \"Yes →\" \"No →\" etc.\n\nLet's produce each line.\n\nProbably we need to include indentation? Not required, but can.\n\nWe will use the arrow at each step.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 map1 // 用來儲存 list1 中每個字串的索引\n→ Step 2: 對 list1 進行迭代，取得索引 i 與字串 s\n    → Step 2a: map1[s] = i // 把字串 s 與其索引 i 存進字典\n→ Step 3: 設定 minSum 為無限大 // 用來追蹤最小的索引和\n→ Step 4: 設定 resultList 為空列表 // 存放所有最小索引和的字串\n→ Step 5: 對 list2 進行迭代，取得索引 j 與字串 s\n    → Decision: s 是否存在於 map1? // 判斷是否為公共字串\n        Yes →\n            → Step 5a: 計算 sum = map1[s] + j // 兩個索引之和\n            → Decision: sum < minSum? // 是否比目前最小值還小\n                Yes →\n                    → Step 5a1: minSum = sum // 更新最小索引和\n                    → Step 5a2: 清空 resultList // 移除之前的結果\n                    → Step 5a3: 把 s 加入 resultList // 加入新的最小索引和字串\n                No →\n                    → Decision: sum == minSum? // 是否等於目前最小值\n                        Yes →\n                            → Step 5a4: 把 s 加入 resultList // 加入相同最小索引和的字串\n                        No →\n                            → Step 5a5: 不做任何事 // 索引和更大，忽略\n        No →\n            → Step 5b: 繼續迭代 // 跳過非公共字串\nEnd // 程式執行結束\n\nCheck that each line has format \"虛擬碼步驟 [space] // 解釋/說明\". Use correct Chinese characters.\n\nAlso note we used indentation lines with indentation; but still each line must be a single line. The indentation lines may contain spaces before the code, but that might still be considered a separate line; the requirement says \"逐行輸出\" each line must contain step and explanation. So each line should be a separate line; if we include sublines with indentation, each must be separate line. In example, they used indentation with spaces before arrow. That's okay. So we should produce lines accordingly.\n\nLet's output final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 map1 // 用來儲存 list1 中每個字串的索引  \n→ Step 2: 對 list1 進行迭代，取得索引 i 與字串 s  \n    → Step 2a: map1[s] = i // 把字串 s 與其索引 i 存進字典  \n→ Step 3: 設定 minSum 為無限大 // 用來追蹤最小的索引和  \n→ Step 4: 設定 resultList 為空列表 // 存放所有最小索引和的字串  \n→ Step 5: 對 list2 進行迭代，取得索引 j 與字串 s  \n    → Decision: s 是否存在於 map1? // 判斷是否為公共字串  \n        Yes →  \n            → Step 5a: 計算 sum = map1[s] + j // 兩個索引之和  \n            → Decision: sum < minSum? // 是否比目前最小值還小  \n                Yes →  \n                    → Step 5a1: minSum = sum // 更新最小索引和  \n                    → Step 5a2: 清空 resultList // 移除之前的結果  \n                    → Step 5a3: 把 s 加入 resultList // 加入新的最小索引和字串  \n                No →  \n                    → Decision: sum == minSum? // 是否等於目前最小值  \n                        Yes →  \n                            → Step 5a4: 把 s 加入 resultList // 加入相同最小索引和的字串  \n                        No →  \n                            → Step 5a5: 不做任何事 // 索引和更大，忽略  \n        No →  \n            → Step 5b: 繼續迭代 // 跳過非公共字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nimport json\n\nclass Solution:\n    def findRestaurant(self, list1, list2):\n        # 建立字典：每個餐廳名稱對應在 list1 的索引\n        index_map = {name: i for i, name in enumerate(list1)}\n        min_sum = float('inf')\n        res = []\n\n        # 逐一遍歷 list2\n        for j, name in enumerate(list2):\n            if name in index_map:\n                total_index = j + index_map[name]\n                if total_index < min_sum:\n                    min_sum = total_index\n                    res = [name]          # 找到更小的和，重設結果\n                elif total_index == min_sum:\n                    res.append(name)       # 和相同，加入結果\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得 list1 與 list2 的字串\n    pattern = r'list1\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*list2\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, data)\n    if not match:\n        print(json.dumps([]))\n        return\n\n    list1_str, list2_str = match.groups()\n    # 使用安全的 literal_eval 解析 Python 列表字面量\n    list1 = ast.literal_eval(list1_str)\n    list2 = ast.literal_eval(list2_str)\n\n    solution = Solution()\n    result = solution.findRestaurant(list1, list2)\n    # 用 JSON 格式輸出，符合範例中的雙引號風格\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "[\"Shogun\"]"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "[\"Shogun\"]"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "success": true,
          "output": "[\"sad\", \"happy\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode629.json",
    "problem_index_in_file": 0,
    "title": "K Inverse Pairs Array",
    "description_snippet": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.leng...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code algorithm for counting number of permutations of 1..n with exactly k inversion pairs. Classic DP: dp[i][j] = number of permutations of size i with j inversions. recurrence: dp[i][j] = sum_{t=0}^{min(j,i-1)} dp[i-1][j-t]. Use prefix sums to optimize to O(nk). Then output dp[n][k] mod M.\n\nWe need to produce step-by-step pseudo-code lines with arrows etc. We'll produce algorithm: Start, Initialize dp array size (n+1)*(k+1) zero, dp[0][0]=1. For i from 1 to n: for j from 0 to k: compute dp[i][j] = (dp[i][j-1] + dp[i-1][j] - (j-i>=0? dp[i-1][j-i] : 0)) mod M. After loops, output dp[n][k]. End.\n\nWe need to express pseudocode lines: Start, Initialize dp, for loops, decisions, modular addition, etc. Use virtual code arrows. Let's produce each line with comment.\n\nWe must produce \"逐行\" with each line containing pseudo-code step and comment. Use arrow for step lines. Provide decisions for loops and conditions. We should not output actual code but pseudo-code.\n\nWe need to produce a list of lines. Let's craft them.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → M ← 1000000007 // 定義模數\n\nLine 3: → dp ← 2D array (n+1)×(k+1) initialised to 0 // dp[i][j] 代表長度 i 的排列有 j 個逆序對\n\nLine 4: → dp[0][0] ← 1 // 空排列只有一種且沒有逆序對\n\nLine 5: → For i from 1 to n: // 逐個加入新元素\n\nLine 6:     → For j from 0 to k: // 計算長度 i 時的所有逆序數\n\nLine 7:         → Decision: j==0? // 特殊處理 j=0，無前一個 j-1\n\nLine 8:             Yes → temp ← dp[i-1][0] // 只可能把新元素放在最前面，無新增逆序\n\nLine 9:             No  → Decision: j-i >= 0? // 檢查是否需要減去超過 i-1 的情況\n\nLine 10:                 Yes → temp ← (dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i]) mod M\n\nLine 11:                 No  → temp ← (dp[i][j-1] + dp[i-1][j]) mod M\n\nLine 12:         → dp[i][j] ← (temp + M) mod M // 保證非負\n\nLine 13: → Answer ← dp[n][k] // 需要的排列數\n\nLine 14: → Output Answer\n\nLine 15: End // 程式結束\n\nBut need to align with requirement: each line \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow as in example. Must include decision and Yes/No lines.\n\nWe must maintain indentation. But just write lines sequentially, maybe with indentation using spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ M ← 1000000007 // 定義模數  \n→ dp ← 2D array (n+1)×(k+1) initialised to 0 // dp[i][j] 代表長度 i 的排列有 j 個逆序對  \n→ dp[0][0] ← 1 // 空排列只有一種且沒有逆序對  \n→ For i from 1 to n: // 逐個加入新元素  \n  → For j from 0 to k: // 計算長度 i 時的所有逆序數  \n    → Decision: j == 0? // 特殊處理 j=0，無前一個 j-1  \n      Yes → temp ← dp[i-1][0] // 只可能把新元素放在最前面，無新增逆序  \n      No  → Decision: j-i >= 0? // 檢查是否需要減去超過 i-1 的情況  \n        Yes → temp ← (dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i]) mod M // 加上前一個 j-1，再減去越界的項  \n        No  → temp ← (dp[i][j-1] + dp[i-1][j]) mod M // 直接加上 dp[i-1][j]  \n    → dp[i][j] ← (temp + M) mod M // 取模並保證非負  \n→ Answer ← dp[n][k] // 需要的排列數  \n→ Output Answer // 輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef solve() -> None:\n    # 讀取整個輸入，從中擷取所有整數\n    raw = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', raw)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n\n    MOD = 10**9 + 7\n    # 若 k 超過可能的最大逆序對數，直接回傳 0\n    max_inv = n * (n - 1) // 2\n    if k > max_inv:\n        print(0)\n        return\n\n    # dp[i][j] = 逆序對數為 j 的長度為 i 的排列個數\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        dp[i][0] = 1  # 只有一種排列：把新數字放在最前面\n        for j in range(1, k + 1):\n            val = dp[i][j - 1] + dp[i - 1][j]\n            if j >= i:\n                val -= dp[i - 1][j - i]\n            dp[i][j] = val % MOD\n\n    print(dp[n][k] % MOD)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode693.json",
    "problem_index_in_file": 0,
    "title": "Binary Number with Alternating Bits",
    "description_snippet": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The task: Given a positive integer, check if its binary representation has alternating bits (adjacent bits differ). We'll produce steps: input integer, maybe get binary representation, or compute bit by bit. Use virtual code arrow.\n\nWe need to use \"虛擬碼步驟\" and explanation. Use arrows and Decision. Steps: Start, Input number, maybe store in variable N. Get least significant bit, store previous bit. While N > 0: get current bit, compare with previous. If same => No. Else set previous to current, shift N. End loop. After loop, output Yes. Use Decision nodes. Let's produce line by line. Use \"Decision:\" for each condition. Use \"Yes →\" and \"No →\".\n\nWe also need to ensure no actual code; just steps. Use Chinese comments.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 輸入正整數 N // 取得要檢查的數字\n→ Step 2: 取得 N 的最低位元 B = N & 1 // 找出最後一位\n→ Step 3: 設定前一位 prev = B // 初始化前一位\n→ Step 4: 將 N 右移一位 N = N >> 1 // 移除已處理的最低位\n→ Decision: N 是否為 0? // 判斷是否已經處理完所有位元\n    Yes → Step 5: 輸出 '有交替位元' // 全部位元都交替\n    No  → Decision: N 的最低位元 cur = N & 1 與 prev 是否相同? // 檢查新位元與前一位元是否相同\n        Yes → Step 6: 輸出 '無交替位元' // 發現相同，結束\n        No  → Step 7: 更新 prev = cur // 更新前一位元\n               Step 8: 右移 N = N >> 1 // 移除已處理的最低位\n               Step 9: 跳回 Decision: N 是否為 0? // 重新檢查剩餘位元\nEnd // 程式執行結束\n\nBut we need to maintain proper indentation. Also use arrow notation. Provide each line with explanation. Ensure the steps align. Use \"→\" for steps. Decision lines use \"Decision:\" then indent with 4 spaces? Not necessary but we can show indentation for readability.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 N // 取得要檢查的數字  \n→ Step 2: 取得 N 的最低位元 B = N & 1 // 找出最後一位  \n→ Step 3: 設定前一位 prev = B // 初始化前一位  \n→ Step 4: 將 N 右移一位 N = N >> 1 // 移除已處理的最低位  \n→ Decision: N 是否為 0? // 判斷是否已經處理完所有位元  \n  Yes → Step 5: 輸出 '有交替位元' // 全部位元都交替  \n  No  → Decision: N 的最低位元 cur = N & 1 與 prev 是否相同? // 檢查新位元與前一位元是否相同  \n   Yes → Step 6: 輸出 '無交替位元' // 發現相同，結束  \n   No  → Step 7: 更新 prev = cur // 更新前一位元  \n    Step 8: 右移 N = N >> 1 // 移除已處理的最低位  \n    Step 9: 跳回 Decision: N 是否為 0? // 重新檢查剩餘位元  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef has_alternating_bits(n: int) -> bool:\n    \"\"\"\n    檢查正整數 n 的二進位表示是否交替出現 0 與 1。\n    若相鄰兩位皆相同，回傳 False；若全部相互不同，回傳 True。\n    \"\"\"\n    # 取最低位元作為前一位元\n    prev_bit = n & 1\n    n >>= 1\n    while n:\n        # 取得目前最低位元\n        curr_bit = n & 1\n        # 若與前一位元相同，直接判定為 False\n        if curr_bit == prev_bit:\n            return False\n        # 更新前一位元，繼續檢查\n        prev_bit = curr_bit\n        n >>= 1\n    return True\n\ndef main() -> None:\n    \"\"\"\n    主程式入口：\n    1. 讀取整個 stdin。\n    2. 從文字中擷取第一個數字作為 n。\n    3. 呼叫 has_alternating_bits 判斷結果。\n    4. 以小寫字串輸出 'true' 或 'false'。\n    \"\"\"\n    data = sys.stdin.read()\n    # 只取第一個正整數，忽略其他文字\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = has_alternating_bits(n)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode13.json",
    "problem_index_in_file": 0,
    "title": "Roman to Integer",
    "description_snippet": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Val...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation for converting Roman numeral to integer. Steps: map values, iterate string, handle subtraction: if current value < next value subtract else add. Also need to handle final char.\n\nWe'll produce start, mapping, loop, decision, add/subtract, accumulate, output, end. Ensure each line has format: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 建立字典 mapping = { 'I':1, 'V':5, ... } // 定義羅馬字母對應數值\n→ Step 2: 取得輸入字串 s // 取得欲轉換的羅馬數字\n→ Step 3: 初始化 total = 0 // 用來累加結果\n→ Step 4: 初始化 i = 0 // 索引指向字串起始位置\n→ Decision: 是否 i < len(s) ? // 判斷是否還有字母未處理\n    Yes → Step 5: current = mapping[s[i]] // 取得目前字母數值\n    Yes → Decision: i+1 < len(s) AND current < mapping[s[i+1]] ? // 判斷是否需要減法\n        Yes → Step 6: total = total - current // 用減法處理\n        No  → Step 7: total = total + current // 正常加總\n    Yes → Step 8: i = i + 1 // 前進索引\n    Yes → Decision: 回到 Step 4\n    No  → Step 9: 輸出 total // 結果輸出\nEnd // 程式執行結束\n\nNeed to format each line. Also add comments after //.\n\nMake sure each line includes arrow \"→\" except Start and End. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 mapping = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000} // 定義羅馬字母對應數值  \n→ Step 2: 取得輸入字串 s // 取得欲轉換的羅馬數字  \n→ Step 3: 初始化 total = 0 // 用來累加最終整數值  \n→ Step 4: 初始化 i = 0 // 索引指向字串起始位置  \n→ Decision: i < len(s) ? // 判斷是否還有字母未處理  \n  Yes → Step 5: current = mapping[s[i]] // 取得目前字母對應數值  \n  Yes → Decision: i+1 < len(s) AND current < mapping[s[i+1]] ? // 判斷是否需要進行減法規則  \n    Yes → Step 6: total = total - current // 進行減法（例如 IV）  \n    No → Step 7: total = total + current // 正常加總（例如 VI）  \n  Yes → Step 8: i = i + 1 // 前進索引  \n  Yes → Decision: 回到 Step 4  \n  No → Step 9: 輸出 total // 輸出最終整數結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"將羅馬數字字串轉換為整數。\"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev_value = 0\n    # 由右往左遍歷，若當前數值小於前一個數值則減去，否則加上\n    for char in reversed(s):\n        value = roman_map[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total\n\ndef extract_roman_input(raw: str) -> str:\n    \"\"\"從原始輸入中提取羅馬數字字串。\"\"\"\n    # 先嘗試找字串中的引號內容\n    match = re.search(r'[\"\\']([^\"\\']+)[\"\\']', raw)\n    if match:\n        return match.group(1).strip()\n    # 若沒有引號，直接去掉可能的 s = 前綴\n    if raw.lower().startswith('s'):\n        parts = raw.split('=', 1)\n        if len(parts) == 2:\n            return parts[1].strip()\n    # 否則直接返回 trimmed 字串\n    return raw.strip()\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    roman_str = extract_roman_input(raw_input)\n    result = roman_to_int(roman_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"III\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"LVIII\"",
          "expected_output": "58",
          "success": true,
          "output": "58"
        },
        {
          "example_index": 2,
          "input": "s = \"MCMXCIV\"",
          "expected_output": "1994",
          "success": true,
          "output": "1994"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode134.json",
    "problem_index_in_file": 0,
    "title": "Gas Station",
    "description_snippet": "There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudocode) line by line with comments. The requirement: not actual code but a structured step by step explanation. Use arrow, decision etc. Provide explanation after each line. Use Start, End, Decision. The solution: classic gas station problem. Steps: Initialize total=0, curr=0, start=0. Iterate i 0..n-1: total += gas[i] - cost[i]; curr += gas[i] - cost[i]; if curr<0: start=i+1; curr=0. After loop, if total>=0 return start else -1. Also handle n zero? But given arrays same length >0.\n\nWe need to produce in Traditional Chinese.\n\nAlso need to keep format: each line \"虛擬碼步驟 [space] // 解釋/說明\"\n\nWe must use arrow \"→\" and decisions.\n\nLet's produce steps:\n\nStart\n\n→ Step 1: 設定 total, curr, start = 0, 0, 0 // 初始化總剩餘氣量、目前區段剩餘氣量及起點\n\n→ Decision: 是否已經處理完所有站? // 循環條件\n\n    Yes → End // 所有站已處理，跳出循環\n\n    No  → Step 2: 取得 gas[i] 與 cost[i]，計算差值 diff = gas[i] - cost[i] // 取得每站的純油量\n\n    → Step 3: total += diff // 更新總剩餘氣量\n\n    → Step 4: curr += diff // 更新目前區段剩餘氣量\n\n    → Decision: curr < 0? // 檢查目前區段是否不足以通過下一站\n\n        Yes → Step 5: start = i + 1 // 重新設定起點為下一站\n\n        → Step 6: curr = 0 // 重置目前區段剩餘氣量\n\n        No  → // 目前區段仍能通過，繼續\n\n    → Step 7: i++ // 前往下一站\n\n→ Decision: total >= 0? // 總剩餘氣量是否非負\n\n    Yes → Step 8: 回傳 start // 有解，返回起點\n\n    No  → Step 9: 回傳 -1 // 無解，返回 -1\n\nEnd\n\nBut we need proper arrow formatting with indent etc. Provide arrow lines like:\n\n→ Step 1: ...\n\nThe decision lines need indentation as in example.\n\nLet's craft.\n\nWe must ensure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: total ← 0, curr ← 0, start ← 0, i ← 0 // 初始化總剩餘氣量、目前區段剩餘氣量、起點及索引\n→ Decision: i < n? // 檢查是否已經處理完所有車站\n    Yes → Step 2: diff ← gas[i] - cost[i] // 計算第 i 個車站的純氣量\n    → Step 3: total ← total + diff // 累加總剩餘氣量\n    → Step 4: curr ← curr + diff // 累加目前區段剩餘氣量\n    → Decision: curr < 0? // 判斷目前區段是否不足以抵達下一站\n        Yes → Step 5: start ← i + 1 // 重新設定起點為下一個車站\n        → Step 6: curr ← 0 // 重置目前區段剩餘氣量\n        No  → // 目前區段仍能通過，保持現有起點\n    → Step 7: i ← i + 1 // 前往下一個車站\n    → Decision: i < n? // 重複處理剩餘車站\n        Yes → Go to Step 2\n        No  → // 已完成遍歷\n→ Decision: total >= 0? // 判斷總剩餘氣量是否足夠完成整個圓形\n    Yes → Step 8: return start // 有解，返回起點索引\n    No  → Step 9: return -1 // 無解，返回 -1\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canCompleteCircuit(self, gas, cost):\n        # 先快速判斷總油量是否足夠\n        if sum(gas) < sum(cost):\n            return -1\n        start = 0\n        tank = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start\n\ndef parse_input(data: str):\n    # 從字串中擷取兩個括號內的列表\n    lists = re.findall(r'\\[(.*?)\\]', data)\n    if len(lists) < 2:\n        raise ValueError(\"輸入格式不正確\")\n    # 轉成整數列表\n    gas = [int(x.strip()) for x in lists[0].split(',') if x.strip() != '']\n    cost = [int(x.strip()) for x in lists[1].split(',') if x.strip() != '']\n    return gas, cost\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    gas, cost = parse_input(raw_input)\n    sol = Solution()\n    result = sol.canCompleteCircuit(gas, cost)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode540.json",
    "problem_index_in_file": 0,
    "title": "Single Element in a Sorted Array",
    "description_snippet": "You are given a sorted array consisting of only integers where every element appears exactly twice, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, no actual code. Use Start, End, Decision: etc. For this problem: find single element in sorted array with pairs except one. Use binary search on pairs. Steps: Start, read array, low=0, high=len-1. While low<high: mid = low + (high-low)/2. Ensure mid even: if mid%2==1: mid--. If array[mid]==array[mid+1], low=mid+2 else high=mid. After loop low is answer. Return arr[low]. End.\n\nAdd explanation each line. Ensure no actual code. Provide virtual code with arrows. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 A // 獲取已排序且只含兩兩相同元素的陣列  \n→ Step 2: 初始化 low = 0, high = A.length - 1 // 設定二分搜尋範圍  \n→ Decision: 是否 low < high? // 檢查是否還有多於一個元素可搜尋  \n    Yes → Step 3: 計算 mid = low + (high - low) / 2 // 找到中點索引  \n    → Decision: mid 是否為奇數? // 確保 mid 指向第一個成對索引  \n        Yes → Step 4: mid = mid - 1 // 若奇數，往左移動到偶數索引  \n        No  → // mid 已是偶數，保持不變  \n    → Decision: A[mid] == A[mid + 1]? // 判斷 mid 與其右鄰是否成對  \n        Yes → Step 5: low = mid + 2 // 成對，單一元素必在右側，調整 low  \n        No  → Step 6: high = mid // 未成對，單一元素必在左側，調整 high  \n    → Jump back to Decision: 是否 low < high? // 重複二分搜尋  \n→ Decision: low == high? // 搜尋結束，唯一元素位置已確定  \n    Yes → Step 7: 結果 = A[low] // 取得唯一元素  \n    No  → // 不應發生，因為條件保證唯一元素存在  \n→ Step 8: 輸出結果 // 將唯一元素傳回使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef single_non_duplicate(nums):\n    \"\"\"\n    Binary search to find the unique element in a sorted array where every element\n    appears exactly twice except one.\n    \"\"\"\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        # Ensure mid points to the first element of a pair\n        if mid % 2 == 1:\n            mid -= 1\n        # If the pair is intact, the unique element is on the right side\n        if nums[mid] == nums[mid + 1]:\n            left = mid + 2\n        else:\n            # Otherwise, the unique element is on the left side (including mid)\n            right = mid\n    return nums[left]\n\nif __name__ == \"__main__\":\n    # Read the entire input, strip whitespace, and parse it into a list of integers\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)  # No input provided\n    # Use literal_eval for safe evaluation of the list representation\n    try:\n        nums = ast.literal_eval(raw_input)\n        if not isinstance(nums, list):\n            raise ValueError\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    result = single_non_duplicate(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,2,3,3,4,4,8,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[3,3,7,7,10,11,11]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode622.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Queue",
    "description_snippet": "Design your implementation of the circular queue. The circular queue is a linear data structure in w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode line-by-line, with comments. Should describe MyCircularQueue implementation: array, front, rear pointers, size. Methods: constructor, Front, Rear, enQueue, deQueue, isEmpty, isFull. Provide step-by-step pseudocode.\n\nEnsure each line ends with comment. Use arrows. Let's design:\n\nStart\n→ Step: 初始化数组大小 k, front = 0, rear = -1, count = 0\nDecision? etc.\n\nWe'll write methods separately.\n\nBetter to produce entire class skeleton with methods.\n\nNeed \"Start\" at beginning? Might treat each method as separate.\n\nBut example had Start at program level. For class, maybe start at class definition.\n\nWe'll do:\n\nStart // 程式開始執行\n→ Class MyCircularQueue // 定義環形佇列類別\n    → Init(k) // 建構子，設定大小\n        → Array = new array of size k // 佇列儲存空間\n        → FrontIndex = 0 // 前端指標\n        → RearIndex = -1 // 後端指標，初始為-1表示空\n        → Count = 0 // 目前元素個數\n    → Front() // 取得前端元素\n        → Decision: Count == 0? // 佇列是否空\n            Yes → Return -1 // 空時回傳 -1\n            No  → Return Array[FrontIndex] // 否則回傳前端值\n    → Rear() // 取得後端元素\n        → Decision: Count == 0?\n            Yes → Return -1\n            No  → Return Array[RearIndex]\n    → enQueue(value)\n        → Decision: Count == k? // 佇列是否已滿\n            Yes → Return False // 插入失敗\n            No  →\n                → RearIndex = (RearIndex + 1) mod k // 後端指標往後移\n                → Array[RearIndex] = value // 存值\n                → Count = Count + 1 // 元素數增一\n                → Return True // 插入成功\n    → deQueue()\n        → Decision: Count == 0?\n            Yes → Return False // 刪除失敗\n            No  →\n                → FrontIndex = (FrontIndex + 1) mod k // 前端指標往後移\n                → Count = Count - 1 // 元素數減一\n                → Return True // 刪除成功\n    → isEmpty()\n        → Return Count == 0 // 判斷是否為空\n    → isFull()\n        → Return Count == k // 判斷是否已滿\nEnd // 程式執行結束\n\nNeed arrow syntax: →. For Decision: use Yes → ... No → ... nested.\n\nLet's produce each line accordingly. Ensure comments start with //.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MyCircularQueue // 定義環形佇列類別  \n  → Init(k) // 建構子，設定大小  \n   → Array = new array of size k // 佇列儲存空間  \n   → FrontIndex = 0 // 前端指標  \n   → RearIndex = -1 // 後端指標，初始為-1表示空  \n   → Count = 0 // 目前元素個數  \n  → Front() // 取得前端元素  \n   → Decision: Count == 0? // 佇列是否空  \n    Yes → Return -1 // 空時回傳 -1  \n    No  → Return Array[FrontIndex] // 否則回傳前端值  \n  → Rear() // 取得後端元素  \n   → Decision: Count == 0?  \n    Yes → Return -1 // 空時回傳 -1  \n    No  → Return Array[RearIndex] // 否則回傳後端值  \n  → enQueue(value) // 插入元素  \n   → Decision: Count == k? // 佇列是否已滿  \n    Yes → Return False // 插入失敗  \n    No  →  \n     → RearIndex = (RearIndex + 1) mod k // 後端指標往後移  \n     → Array[RearIndex] = value // 存值  \n     → Count = Count + 1 // 元素數增一  \n     → Return True // 插入成功  \n  → deQueue() // 刪除元素  \n   → Decision: Count == 0? // 佇列是否為空  \n    Yes → Return False // 刪除失敗  \n    No  →  \n     → FrontIndex = (FrontIndex + 1) mod k // 前端指標往後移  \n     → Count = Count - 1 // 元素數減一  \n     → Return True // 刪除成功  \n  → isEmpty() // 檢查是否為空  \n   → Return Count == 0 // 判斷是否為空  \n  → isFull() // 檢查是否已滿  \n   → Return Count == k // 判斷是否已滿  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyCircularQueue:\n    \"\"\"環形佇列（循環佇列）實作\"\"\"\n\n    def __init__(self, k: int):\n        self.size = k                     # 佇列容量\n        self.queue = [0] * k              # 儲存空間\n        self.head = self.tail = -1        # 前端、後端指標\n\n    def isEmpty(self) -> bool:\n        return self.head == -1\n\n    def isFull(self) -> bool:\n        return (self.tail + 1) % self.size == self.head\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        if self.isEmpty():\n            self.head = 0\n        self.tail = (self.tail + 1) % self.size\n        self.queue[self.tail] = value\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        if self.head == self.tail:\n            self.head = self.tail = -1\n        else:\n            self.head = (self.head + 1) % self.size\n        return True\n\n    def Front(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit(0)\n    ops = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip())\n\n    res = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"MyCircularQueue\":\n            obj = MyCircularQueue(args[0])\n            res.append(None)          # constructor 產生 null\n        else:\n            method = getattr(obj, op)\n            res.append(method(*args))\n\n    # 使用 JSON 輸出，能將 None、True、False 等轉成 null、true、false\n    print(json.dumps(res))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"Rear\", \"isFull\", \"deQueue\", \"enQueue\", \"Rear\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 3, true, true, true, 4]",
          "success": true,
          "output": "[null, true, true, true, false, 3, true, true, true, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode22.json",
    "problem_index_in_file": 0,
    "title": "Generate Parentheses",
    "description_snippet": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parenthes...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for generating all combinations of well-formed parentheses given n pairs. Should use virtual code format: Start, arrows, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Should be structured steps. We need recursion/backtracking.\n\nWe'll produce something like:\n\nStart\n→ Step 1: 定義遞迴函式 generate(current, open, close) // current是目前字串，open已加入的括號數，close已關閉的數\n→ Decision: open < n? // 是否還能加入左括號\n    Yes → Step 2: generate(current + '(', open+1, close) // 加左括號\n    No → ...\n→ Decision: close < open? // 是否還能加入右括號\n    Yes → Step 3: generate(current + ')', open, close+1) // 加右括號\n    No → ...\n→ Decision: open == n and close == n? // 完整組合\n    Yes → Step 4: 將 current 加入結果清單\n    No → ...\n...\nCall generate(\"\",0,0)\nReturn results\n\nWe need to output each step line-by-line, with explanation.\n\nWe should use arrow indentation for nested steps maybe.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 宣告結果 list results = [] // 用於儲存所有合法字串\n→ Step 2: 定義遞迴函式 backtrack(current, open, close) // current: 當前字串，open: 左括號數，close: 右括號數\n→ Decision: open < n? // 還可以加入左括號\n    Yes → Step 3: backtrack(current + '(', open+1, close) // 加左括號\n    No → \n→ Decision: close < open? // 還可以加入右括號\n    Yes → Step 4: backtrack(current + ')', open, close+1) // 加右括號\n    No → \n→ Decision: open == n and close == n? // 生成完成\n    Yes → Step 5: results.append(current) // 把合法字串加入結果\n    No → \n→ Step 6: 呼叫 backtrack(\"\",0,0) // 開始遞迴\n→ Step 7: 回傳 results // 輸出所有字串\nEnd // 程式結束\n\nWe need to use \"Decision:\" lines for each decision. Use indentation to show nested decision steps. Also each line after arrow includes comment.\n\nWe'll follow format exactly.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告結果清單 results = [] // 用來儲存所有合法的括號組合  \n→ Step 2: 定義遞迴函式 backtrack(current, open, close) // current: 當前字串，open: 已加入左括號數，close: 已加入右括號數  \n  Decision: open < n? // 還可以加入左括號嗎？  \n   Yes → Step 3: backtrack(current + '(', open+1, close) // 加左括號並遞迴  \n   No →  \n  Decision: close < open? // 還可以加入右括號嗎？  \n   Yes → Step 4: backtrack(current + ')', open, close+1) // 加右括號並遞迴  \n   No →  \n  Decision: open == n and close == n? // 字串已完整組成？  \n   Yes → Step 5: results.append(current) // 將合法字串加入結果清單  \n   No →  \n→ Step 6: 呼叫 backtrack(\"\", 0, 0) // 開始遞迴生成  \n→ Step 7: 回傳 results // 輸出所有合法組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\ndef generate_parentheses(n: int):\n    \"\"\"回傳所有符合括號配對的字串列表\"\"\"\n    res = []\n\n    def backtrack(current: str, left: int, right: int):\n        # 當字串長度達到 2 * n 時，已組成完整合法字串\n        if len(current) == 2 * n:\n            res.append(current)\n            return\n        # 若還可以加左括號，遞迴\n        if left < n:\n            backtrack(current + '(', left + 1, right)\n        # 若右括號數少於左括號數，可加右括號\n        if right < left:\n            backtrack(current + ')', left, right + 1)\n\n    backtrack(\"\", 0, 0)\n    return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取內容，並擷取第一個整數作為 n\n    data = sys.stdin.read()\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        sys.exit(0)\n    n = int(match.group(1))\n\n    result = generate_parentheses(n)\n    # 使用 json.dumps 以符合範例的輸出格式（無空格）\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
          "success": true,
          "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[\"()\"]",
          "success": true,
          "output": "[\"()\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode217.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate",
    "description_snippet": "Given an integer array nums, return true if any value appears at least twice in the array, and retur...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, following format. No actual code, just steps with arrows. Must include \"Start\", \"End\". Use Decision, Yes →, No → etc. The algorithm: input array nums, check duplicates. Use set or sort. Use simple approach: create empty set, iterate array, if element in set, return true, else add to set. After loop return false. So steps: Start, Step 1: initialize empty set, Step 2: for each num in nums, Step 3: Decision: if num in set? Yes → return true, No → add to set, Step 4: after loop return false. Then End. Provide comments.\n\nMake sure each line ends with \"// 解釋\". Use correct format: \"虛擬碼步驟 [space] // 解釋\". Use arrow with \"→\". For decisions: \"Decision:\" lines. Provide Yes/No substeps. Indentation maybe not necessary but we can use spaces. Should keep within format.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空集合 duplicateSet // 用於儲存已見過的數值  \n→ Step 2: 針對 nums 中每一個元素 current 進行迭代 // 逐個檢查  \n→ Decision: current 是否已存在於 duplicateSet? // 判斷是否重複  \n  Yes → Step 3: 返回 true // 找到重複，立即結束並回傳真  \n  No  → Step 4: 將 current 加入 duplicateSet // 記錄此數值，繼續往後  \n→ Step 5: 迴圈結束後，返回 false // 所有元素皆唯一  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef containsDuplicate(nums):\n    \"\"\"Return True if any value appears at least twice, else False.\"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\ndef main():\n    \"\"\"Read input, parse the list, and print the result.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part from inputs like \"nums = [1,2,3,1]\"\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        nums = []\n\n    result = containsDuplicate(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode389.json",
    "problem_index_in_file": 0,
    "title": "Find the Difference",
    "description_snippet": "You are given two strings s and t.\n\nString t is generated by random shuffling string s and then add ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that solve: given strings s and t, where t is s shuffled plus one extra letter. Find added letter. Approach: frequency count or XOR. Let's produce algorithm: iterate characters, use dictionary or XOR. We'll use XOR method: XOR all chars of s and t. Output result.\n\nWe need virtual code steps in required format: Start, arrow, decision, etc.\n\nWe need to produce lines: \"Start // 程式開始執行\" etc.\n\nWe need to show steps: Input s and t, initialize result char=0 (or null), loop over s and XOR to result, loop over t XOR result, output result, End.\n\nWe can use decision: check if t length == s length+1? maybe not needed. Just XOR.\n\nLet's produce simple pseudo.\n\nLet's adhere to format: each line: virtual code step + space + comment.\n\nUse arrow \"→\" to indent subsequent steps? We can just indent with spaces.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input s, t // 取得兩個字串\n→ Declare result = 0 // 初始化 XOR 結果\n→ For each char c in s: result = result XOR c // 依序 XOR s 的字元\n→ For each char c in t: result = result XOR c // 依序 XOR t 的字元\n→ Output result // 得到多出來的字元\nEnd // 程式執行結束\n\nThis is fine.\n\nWe could add decision to confirm t length > s length.\n\nBut not necessary.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Input s, t // 取得兩個字串\n→ Declare result = 0 // 初始化 XOR 結果\n→ For each char c in s: result = result XOR c // 依序 XOR s 的字元\n→ For each char c in t: result = result XOR c // 依序 XOR t 的字元\n→ Output result // 得到多出來的字元\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        \"\"\"返回多出來的字元，使用 XOR 方式計算\"\"\"\n        res = 0\n        for ch in s:\n            res ^= ord(ch)\n        for ch in t:\n            res ^= ord(ch)\n        return chr(res)\n\ndef parse_input() -> tuple[str, str]:\n    \"\"\"從 stdin 讀取並解析 s 與 t，支援多種輸入格式\"\"\"\n    data = sys.stdin.read()\n\n    # 1. 先嘗試從雙引號中抓取字串\n    matches = re.findall(r'\"(.*?)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n\n    # 2. 若沒有雙引號，嘗試按空白或換行分隔\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n\n    raise ValueError(\"無法解析輸入，請確認輸入格式\")\n\nif __name__ == \"__main__\":\n    s, t = parse_input()\n    solution = Solution()\n    diff_char = solution.findTheDifference(s, t)\n    # 依題目範例輸出帶雙引號的字元\n    print(f'\"{diff_char}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "success": true,
          "output": "\"e\""
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "success": true,
          "output": "\"y\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode75.json",
    "problem_index_in_file": 0,
    "title": "Sort Colors",
    "description_snippet": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for Dutch National Flag problem. Use three pointers: low, mid, high. Iterate mid <= high. Swap accordingly. We must not use sort function. Provide explanation after each line. Use Start, End, Decision: etc. Each line: \"虛擬碼步驟 // 解釋\". Provide step by step. Use arrows? In sample they use \"→ Step 1:\" etc. We'll output lines starting with \"Start\", then arrow \"→\". But each line should include \"虛擬碼步驟\" and comment. Eg \"Start // 程式開始執行\". Next \"→ Step 1: Initialize low, mid, high // 指定三個指標\". We need to maintain format: each line has \"虛擬碼步驟\" and comment. Provide decision arrows.\n\nWe need to output code only. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0, mid ← 0, high ← n − 1 // 建立三個指標，分別指向低值、中值與高值位置  \n→ Decision: 是否已經完成遍歷? // 檢查 mid 是否已超過 high  \n  Yes → End // 當 mid > high 時，排序完成，結束程式  \n  No  → Decision: nums[mid] 是否等於 0? // 判斷當前元素為紅色  \n    Yes → Step 2: swap(nums[low], nums[mid]), low ← low + 1, mid ← mid + 1 // 把紅色移到前面，更新 low 與 mid  \n    No  → Decision: nums[mid] 是否等於 1? // 判斷當前元素為白色  \n      Yes → Step 3: mid ← mid + 1 // 白色保持在中間位置，僅更新 mid  \n      No  → Step 4: swap(nums[mid], nums[high]), high ← high − 1 // 把藍色移到後面，更新 high，mid 不變  \n→ Goto Decision: 是否已經完成遍歷? // 回到判斷條件，繼續循環  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def sortColors(self, nums):\n        \"\"\"\n        In-place Dutch National Flag sorting.\n        :type nums: List[int]\n        :rtype: None\n        \"\"\"\n        low, mid, high = 0, 0, len(nums) - 1\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:  # nums[mid] == 2\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the list of numbers from input.\n    if \"=\" in data:\n        _, list_part = data.split(\"=\", 1)\n    else:\n        list_part = data\n    try:\n        nums = eval(list_part.strip())\n    except Exception:\n        # Fallback: extract integers manually\n        import re\n        nums = list(map(int, re.findall(r'-?\\d+', list_part)))\n    solution = Solution()\n    solution.sortColors(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,0,2,1,1,0]",
          "expected_output": "[0,0,1,1,2,2]",
          "success": true,
          "output": "[0, 0, 1, 1, 2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,0,1]",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode378.json",
    "problem_index_in_file": 0,
    "title": "K^th Smallest Element in a Sorted Matrix",
    "description_snippet": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm to find kth smallest element in sorted matrix, using better than O(n^2) memory. Standard solution: binary search on value range with count of <= mid. Complexity O(n^2 log(max-min)). Or use min-heap O(k log n). But memory better than O(n^2) means we can't store entire matrix? But we have matrix input. We just need algorithm memory not O(n^2) - so either binary search or min-heap. Provide step-by-step pseudocode with arrows and comments.\n\nLet's produce pseudocode: Start, read matrix size n, read k. Determine minVal=matrix[0][0], maxVal=matrix[n-1][n-1]. Binary search between min and max. While min<max: mid=(min+max)//2. Count elements <= mid: for each row use binary search or pointer. If count>=k: max=mid else min=mid+1. End. Return min.\n\nWe also may need to explain the count function: iterate each row, find number of elements <=mid using binary search. That is O(n log n) per count.\n\nAlternatively min-heap approach: push first element of each row into min-heap with (value, row, col). Pop k times. Memory O(n). We'll provide pseudocode for that too. But requirement just one algorithm. Provide pseudocode lines.\n\nLet's produce step-by-step pseudocode:\n\nStart\n→ Step 1: 讀取 n、k、矩陣 matrix // 獲取輸入\n→ Decision: 矩陣是否非空? // 先檢查\n    Yes → Step 2: 設定 minVal=matrix[0][0]，maxVal=matrix[n-1][n-1] // 取範圍\n    No  → Step 3: 返回 null // 空矩陣\n→ Step 4: While minVal < maxVal: // 進行二分搜尋\n    → Step 5: mid = (minVal + maxVal) // 2 // 中間值\n    → Step 6: count = CountLessEqual(matrix, n, mid) // 計算小於等於 mid 的個數\n    → Decision: count >= k? // 判斷是否足夠\n        Yes → Step 7: maxVal = mid // 將上界移到 mid\n        No  → Step 8: minVal = mid + 1 // 下界往上移\n→ Step 9: Return minVal // 這就是第 k 小元素\nEnd\n\nDefine function CountLessEqual(matrix, n, val)\n→ Step 10: count = 0\n→ Step 11: for i from 0 to n-1:\n    → Step 12: j = n-1 // start from last column\n    → Decision: while j >= 0 and matrix[i][j] > val:\n        → Step 13: j = j - 1 // move left\n    → Step 14: count = count + (j + 1) // all columns <= val\n→ Step 15: return count\n\nAlternatively binary search on each row? But we use pointer approach O(n^2) worst-case? But each count loops O(n^2) if naive; but pointer method loops at most 2n. Actually using j from n-1 for each row ensures overall O(n^2) worst-case? But each row starts j at n-1; but if we don't reset j each row? Actually for each row we start at n-1, so worst-case n^2. But it's okay? It's still O(n^2). But we could use binary search per row O(n log n). But we need better memory not time. Memory is fine.\n\nWe can explain that.\n\nNow produce final answer with virtual code lines and comments. Use arrow symbols. Let's produce final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取 n、k、矩陣 matrix // 取得輸入的矩陣大小、k 值以及實際矩陣\n→ Decision: 矩陣是否非空? // 先檢查是否有元素\n    Yes → Step 2: 設定 minVal = matrix[0][0], maxVal = matrix[n-1][n-1] // 矩陣已排好序，取最小與最大作為搜尋範圍\n    No  → Step 3: 回傳 null // 空矩陣直接結束\n→ Step 4: While minVal < maxVal: // 進行二分搜尋，直到範圍縮為單一值\n    → Step 5: mid = (minVal + maxVal) // 2 // 取目前範圍中點作為判斷基準\n    → Step 6: count = CountLessEqual(matrix, n, mid) // 計算不大於 mid 的元素個數\n    → Decision: count >= k? // 判斷此 mid 位置是否已包含至少 k 個小於等於的元素\n        Yes → Step 7: maxVal = mid // 若足夠，將上界收縮至 mid\n        No  → Step 8: minVal = mid + 1 // 若不足，將下界往上移\n→ Step 9: Return minVal // minVal 即為第 k 小的元素\nEnd // 程式執行結束\n\n// 下面為輔助函式，計算不大於 val 的元素個數\nFunction CountLessEqual(matrix, n, val):\n    → Step 10: count = 0\n    → Step 11: For i = 0 to n-1:\n        → Step 12: j = n-1 // 從每行最右邊開始\n        → Decision: while j >= 0 AND matrix[i][j] > val: // 移到第一個不大於 val 的列\n            → Step 13: j = j - 1\n        → Step 14: count = count + (j + 1) // 所有列 0..j 的元素都 <= val\n    → Step 15: Return count\n```",
      "generated_code": "import sys\nimport re\nimport ast\nimport heapq\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        \"\"\"\n        使用最小堆求第 k 小元素。\n        heap 儲存三元組 (值, 行, 列)，初始時將每一行的第一個元素放入堆。\n        依次彈出最小元素，並將其所在行的下一個元素加入堆，重複 k-1 次。\n        最後堆頂即為第 k 小元素。\n        \"\"\"\n        n = len(matrix)\n        if n == 0:\n            return None\n        # 初始化堆\n        heap = [(matrix[i][0], i, 0) for i in range(n)]\n        heapq.heapify(heap)\n        # 取 k-1 次最小元素\n        for _ in range(k - 1):\n            val, r, c = heapq.heappop(heap)\n            if c + 1 < n:\n                heapq.heappush(heap, (matrix[r][c + 1], r, c + 1))\n        # 堆頂即為第 k 小元素\n        return heapq.heappop(heap)[0]\n\ndef parse_input(text):\n    \"\"\"\n    從輸入文字中解析出 matrix (list of lists) 與 k (int)。\n    支援類似 'matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8' 的格式。\n    \"\"\"\n    # 取得矩陣字串\n    matrix_match = re.search(r'\\[.*\\]', text, re.S)\n    if not matrix_match:\n        raise ValueError(\"Cannot find matrix in input.\")\n    matrix_str = matrix_match.group()\n    matrix = ast.literal_eval(matrix_str)\n\n    # 取得 k 值\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', text)\n    if not k_match:\n        raise ValueError(\"Cannot find k in input.\")\n    k = int(k_match.group(1))\n\n    return matrix, k\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    try:\n        matrix, k = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.kthSmallest(matrix, k)\n    if result is None:\n        print(\"Invalid input matrix.\")\n    else:\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "success": true,
          "output": "13"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "success": true,
          "output": "-5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode164.json",
    "problem_index_in_file": 0,
    "title": "Maximum Gap",
    "description_snippet": "Given an integer array nums, return the maximum difference between two successive elements in its so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The requirement: linear time, linear extra space. It's essentially the maximum adjacent difference problem, using bucket sort / Pigeonhole. Steps: handle size <2 return 0. Compute min, max. If min==max return 0. Determine bucket size: ceil((max-min)/(n-1)). Create arrays for bucket min and max of size n-1. Initialize bucket mins to inf, bucket maxs to -inf. Iterate through nums: compute bucket index: (num - min) / bucketSize. Update bucket mins and maxs. Then iterate over buckets to find max gap: previous max = min of first non-empty bucket. For each bucket: if non-empty, gap = bucket.min - previous max; update maxGap; previous max = bucket.max. Return maxGap.\n\nWe need to write virtual code lines with explanations. Use Start, End, Decision, arrow syntax.\n\nLet's produce step-by-step. Each line: \"Start // 程式開始執行\". Then \"→ Step 1: n ← length(nums) // 取得陣列長度\". etc. Provide decision steps for n<2. Use Decision: \"如果 n < 2?\" etc.\n\nWe must use arrows. We'll produce a linear sequence. Use \"→ Step X:\" style. We'll keep numbering optional but can do \"Step 1:\". Let's keep consistent.\n\nWe need to keep each line with explanation. Use // comments in Traditional Chinese.\n\nLet's craft.\n\nWe'll need to compute min, max: \"→ Step 2: minVal ← nums[0] // 初始化最小值\", \"→ Step 3: maxVal ← nums[0] // 初始化最大值\". Then loop through array to find min and max: maybe combine with one loop. We can do \"→ Step 4: For each num in nums: ...\" but each line should be separate step. Might need loops but we can use \"→ Step 4: For i from 1 to n-1: // 循環更新 minVal、maxVal\". Inside we can add nested steps: \"→ Decision: if nums[i] < minVal? // 判斷是否為更小值\". etc. However the spec says use decision arrow \"Yes →\", \"No →\" with indentation. So we can show decision inside the loop.\n\nBut we need to maintain linear time. The algorithm is linear anyway.\n\nWe need to show bucket size calculation: \"→ Step 6: bucketSize ← ceil((maxVal - minVal) / (n - 1)) // 計算每個桶的寬度\". Then bucket count: \"→ Step 7: bucketCount ← n - 1 // 桶的數量\".\n\nInitialize bucketMin, bucketMax arrays of length bucketCount. Set bucketMin to +∞, bucketMax to -∞. We'll do steps 8-9.\n\nThen iterate through nums to fill buckets: Step 10: For each num: index ← (num - minVal) / bucketSize; // compute bucket index. Then update bucketMin[index] and bucketMax[index] using decision.\n\nFinally compute maxGap: previousMax ← minVal; maxGap ← 0. For each bucket i: if bucketMin[i] != ∞: gap ← bucketMin[i] - previousMax; if gap > maxGap: maxGap ← gap; previousMax ← bucketMax[i].\n\nReturn maxGap.\n\nLet's produce this with each line explanation.\n\nWe need to use \"→ Decision:\" for condition checks, with Yes→ and No→ lines. Indentation for nested steps.\n\nAlso include loops with arrow? The example didn't show loops explicitly; but we can use \"→ Step: For each ...\". Let's keep simple.\n\nNow produce final virtual code.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: 如果 n < 2? // 檢查是否不足兩個元素  \n  Yes → Step 2: return 0 // 直接返回 0  \n  No  → // 繼續往下做  \n→ Step 3: minVal ← nums[0] // 初始最小值  \n→ Step 4: maxVal ← nums[0] // 初始最大值  \n→ Step 5: For i from 1 to n-1: // 循環找最小與最大  \n  → Decision: 如果 nums[i] < minVal? // 判斷是否更小  \n    Yes → minVal ← nums[i] // 更新最小值  \n    No  → // 仍保持原值  \n  → Decision: 如果 nums[i] > maxVal? // 判斷是否更大  \n    Yes → maxVal ← nums[i] // 更新最大值  \n    No  → // 仍保持原值  \n→ Decision: 如果 minVal = maxVal? // 全部相同  \n  Yes → Step 6: return 0 // 差距為 0  \n  No  → // 繼續  \n→ Step 7: bucketSize ← ceil((maxVal - minVal) / (n - 1)) // 計算桶寬度  \n→ Step 8: bucketCount ← n - 1 // 桶的數量  \n→ Step 9: bucketMin ← array of size bucketCount, initialized to +∞ // 每桶最小值  \n→ Step 10: bucketMax ← array of size bucketCount, initialized to -∞ // 每桶最大值  \n→ Step 11: For each num in nums: // 將元素放入對應桶  \n  → index ← (num - minVal) / bucketSize // 計算桶索引  \n  → Decision: 如果 bucketMin[index] = +∞? // 桶是否首次填入  \n    Yes → bucketMin[index] ← num // 設定桶最小值  \n    No  → // 已有最小值，保持不變  \n  → Decision: 如果 num > bucketMax[index]? // 更新桶最大值  \n    Yes → bucketMax[index] ← num // 設定桶最大值  \n    No  → // 仍保持舊值  \n→ Step 12: prevMax ← minVal // 用於計算相鄰差距的前一個最大值  \n→ Step 13: maxGap ← 0 // 最大差距初始值  \n→ Step 14: For i from 0 to bucketCount-1: // 遍歷所有桶  \n  → Decision: 如果 bucketMin[i] ≠ +∞? // 桶非空  \n    Yes → gap ← bucketMin[i] - prevMax // 兩桶間差距  \n      → Decision: 如果 gap > maxGap? // 更新最大差距  \n        Yes → maxGap ← gap // 設定新最大差距  \n        No  → // 無變化  \n      prevMax ← bucketMax[i] // 更新前一最大值到當前桶最大值  \n    No  → // 空桶，跳過  \n→ Step 15: return maxGap // 返回最終計算的最大相鄰差距  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\n\nclass Solution:\n    def maximumGap(self, nums):\n        n = len(nums)\n        if n < 2:\n            return 0\n\n        # 找到最小值與最大值\n        min_val = nums[0]\n        max_val = nums[0]\n        for num in nums[1:]:\n            if num < min_val:\n                min_val = num\n            if num > max_val:\n                max_val = num\n\n        if min_val == max_val:\n            return 0\n\n        # 建立桶\n        bucket_count = n - 1\n        bucket_size = (max_val - min_val + bucket_count - 1) // bucket_count  # ceil\n        bucket_min = [math.inf] * bucket_count\n        bucket_max = [-math.inf] * bucket_count\n\n        # 將數字放入桶中\n        for num in nums:\n            if num == min_val or num == max_val:\n                continue\n            idx = (num - min_val) // bucket_size\n            if idx >= bucket_count:  # 防止因為 ceil 造成的越界\n                idx = bucket_count - 1\n            if num < bucket_min[idx]:\n                bucket_min[idx] = num\n            if num > bucket_max[idx]:\n                bucket_max[idx] = num\n\n        # 計算相鄰桶之間的最大差距\n        max_gap = 0\n        prev_max = min_val\n        for i in range(bucket_count):\n            if bucket_min[i] == math.inf:  # 空桶\n                continue\n            max_gap = max(max_gap, bucket_min[i] - prev_max)\n            prev_max = bucket_max[i]\n\n        # 考慮最大值與最後一個桶的差距\n        max_gap = max(max_gap, max_val - prev_max)\n        return max_gap\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取整數列表。\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # 支援形如 \"nums = [1, 2, 3]\" 或僅 \"[1, 2, 3]\"\n    if '=' in data:\n        _, value = data.split('=', 1)\n        data = value.strip()\n    try:\n        nums = eval(data, {\"__builtins__\": None}, {})\n    except Exception:\n        # 若 eval 失敗，嘗試手動解析\n        nums = []\n        num_str = ''\n        for ch in data:\n            if ch.isdigit() or ch in '-':\n                num_str += ch\n            elif num_str:\n                nums.append(int(num_str))\n                num_str = ''\n        if num_str:\n            nums.append(int(num_str))\n    if isinstance(nums, list):\n        return nums\n    return []\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    sol = Solution()\n    result = sol.maximumGap(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [10]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode350.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays II",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for intersection of two integer arrays. We need to produce step-by-step with virtual code and explanation in Chinese (繁體). Each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use Start, End, Decision: with arrows.\n\nWe need to think of algorithm: Count frequencies in a hash map, then iterate over second array, find intersection count.\n\nWe need to produce steps line by line. Should be clear. Let's produce something like:\n\nStart // Start\n→ Step 1: 初始化哈希表 map // 用於記錄 nums1 的頻率\n→ Step 2: 對 nums1 進行迴圈，將每個元素的頻率存入 map // 填充哈希表\n→ Step 3: 初始化空陣列 result // 儲存交集\n→ Step 4: 對 nums2 進行迴圈\n    → Decision: map 中是否包含 nums2[i] 且頻率 > 0? // 判斷是否可加入交集\n        Yes → Step 5: 將 nums2[i] 加入 result // 加入交集\n        Yes → Step 6: 將 map[nums2[i]] 減 1 // 依次消耗頻率\n        No  → Step 7: 跳過 // 不符合條件不加入\n→ End // 返回 result\n\nBut need to ensure arrow syntax: \"→ Decision: ...\", \"Yes → ...\", \"No → ...\". Indent? Example format had indentation of 4 spaces. We'll follow similar.\n\nAlso mention Start and End.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立空哈希表 freq // 用於紀錄 nums1 每個元素的出現次數\n→ Step 2: 對 nums1 逐個元素 x 迴圈\n    → freq[x] = (freq[x] ?? 0) + 1 // 更新頻率\n→ Step 3: 建立空陣列 result // 儲存最終交集\n→ Step 4: 對 nums2 逐個元素 y 迴圈\n    → Decision: freq 是否包含 y 且 freq[y] > 0? // 判斷 y 是否仍可加入\n        Yes → result.append(y) // 加入交集\n        Yes → freq[y] = freq[y] - 1 // 消耗一個頻率\n        No  → // 什麼也不做，直接跳過\n→ End // 程式執行結束，返回 result\n\nWe need to keep line numbering? Not required. Just each line.\n\nWe need to be careful with arrow usage: In example, they used \"→ Decision:\" then inside indentation \"Yes → Step\". We'll mimic that.\n\nWe also need to ensure no actual code; just virtual steps.\n\nWe should mention that result array is the output. We'll have a final step \"→ Step 5: 回傳 result // 回傳交集結果\".\n\nLet's refine.\n\nComplete list:\n\nStart // 程式開始執行\n→ Step 1: 初始化空哈希表 freq // 用於記錄 nums1 中每個元素的頻率\n→ Step 2: 對 nums1 中每個元素 num 進行迴圈\n    → freq[num] = (freq[num] ?? 0) + 1 // 更新 num 的頻率\n→ Step 3: 初始化空陣列 result // 儲存交集\n→ Step 4: 對 nums2 中每個元素 val 進行迴圈\n    → Decision: freq 中是否存在 val 且 freq[val] > 0? // 判斷 val 是否還可加入\n        Yes → result.append(val) // 將 val 加入 result\n        Yes → freq[val] = freq[val] - 1 // 消耗一次頻率\n        No  → // val 不在 freq 或頻率已用完，跳過\n→ Step 5: 回傳 result // 輸出交集陣列\nEnd // 程式執行結束\n\nMake sure each line ends with \"// 解釋/說明\". For the nested lines, we keep indentation with 4 spaces.\n\nWe'll produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 freq // 用於記錄 nums1 中每個元素的頻率  \n→ Step 2: 對 nums1 中每個元素 num 進行迴圈  \n    → freq[num] = (freq[num] ?? 0) + 1 // 更新 num 的頻率  \n→ Step 3: 初始化空陣列 result // 儲存交集  \n→ Step 4: 對 nums2 中每個元素 val 進行迴圈  \n    → Decision: freq 中是否存在 val 且 freq[val] > 0? // 判斷 val 是否還可加入  \n        Yes → result.append(val) // 將 val 加入 result  \n        Yes → freq[val] = freq[val] - 1 // 消耗一次頻率  \n        No  → // val 不在 freq 或頻率已用完，跳過  \n→ Step 5: 回傳 result // 輸出交集陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        # Count occurrences in both lists\n        c1, c2 = Counter(nums1), Counter(nums2)\n        res = []\n        # For each number in nums1, add min(count in nums1, count in nums2) copies to result\n        for num in c1:\n            if num in c2:\n                res.extend([num] * min(c1[num], c2[num]))\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串轉成兩個整數列表。\n    支援格式類似：\n        nums1 = [1,2,2,1], nums2 = [2,2]\n    或者兩行分別為列表。\n    \"\"\"\n    # 嘗試用正則找出兩個方括號內的內容\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) >= 2:\n        nums1 = ast.literal_eval(lists[0])\n        nums2 = ast.literal_eval(lists[1])\n    else:\n        # 若正則找不到，假設輸入為兩行列表\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            nums1 = ast.literal_eval(lines[0].strip())\n            nums2 = ast.literal_eval(lines[1].strip())\n        else:\n            # 失敗，回傳空列表\n            nums1, nums2 = [], []\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    nums1, nums2 = parse_input(raw_data)\n    solution = Solution()\n    result = solution.intersect(nums1, nums2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "success": true,
          "output": "[4, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode691.json",
    "problem_index_in_file": 0,
    "title": "Stickers to Spell Word",
    "description_snippet": "We are given n different types of stickers. Each sticker has a lowercase English word on it.\nYou wou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to solve min stickers problem. We'll outline steps: Build letter frequency for stickers; DP over subsets? Or BFS on string states? Typical solution: DP over bitmask for target string length up to 15? But target is concatenation of two random words; length maybe moderate up to maybe 20. Use DP over subsets of target characters? Classic: DP over bitmask of length of target characters. But we need generic algorithm: use memo recursion with pruning: For each sticker, subtract its letters from target's count; recurse; return min+1. Use caching of target string counts.\n\nWe need to output virtual code line-by-line. Let's propose steps:\n\nStart\n→ Prepare frequency map for each sticker\n→ Define recursive function solve(currentTargetCounts) // target remaining\n→ If currentTargetCounts all zero: return 0\n→ Memoize key from counts string\n→ Initialize minAns = INF\n→ For each sticker in stickers:\n    → If sticker contains at least one letter present in currentTargetCounts:\n        → newCounts = currentTargetCounts - min(count, stickerCount) for each letter\n        → subAns = solve(newCounts)\n        → If subAns != -1: minAns = min(minAns, subAns + 1)\n→ Return -1 if minAns == INF else minAns\n→ Main: convert target string to counts\n→ res = solve(targetCounts)\n→ Return res\n\nAlso handle impossible: if sum of sticker letters not covering target letters.\n\nLet's produce step-by-step virtual code.\n\nWe must ensure each line includes arrow etc.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 建立 stickersCountList // 為每張貼紙建立字母頻率表\n→ Step 2: 定義 function solve(remainingCounts) // 目前還未拼出的字母頻率\n→     Decision: remainingCounts 全為 0? // 檢查是否已經拼完\n→         Yes → Return 0 // 無需額外貼紙\n→         No  → Decision: key 為 remainingCounts? // 用頻率作為快取鍵\n→             Yes → Return memo[key] // 已計算過的結果\n→             No  → \n→                 Step 3: 初始化 minAns = ∞ // 目前最佳貼紙數\n→                 For each sticker in stickersCountList:\n→                     Decision: sticker 中有剩餘字母? // 若貼紙無法幫忙則跳過\n→                         Yes →\n→                             Step 4: newCounts = remainingCounts - min(stickerCount, remainingCount) // 用貼紙減去字母\n→                             subAns = solve(newCounts) // 递归求解剩餘部分\n→                             Decision: subAns ≠ -1? // 是否可行\n→                                 Yes → minAns = min(minAns, subAns + 1) // 更新最佳\n→                                 No  → Continue\n→                 Decision: minAns 為 ∞? // 若仍無法完成\n→                     Yes → memo[key] = -1\n→                     No  → memo[key] = minAns\n→                 Return memo[key]\n→ Step 5: 先檢查所有貼紙字母總和是否覆蓋 target 之字母 // 先行判斷不可行\n→ Decision: 有缺口? // 若有字母無法由貼紙提供\n→     Yes → Return -1 // 直接不可完成\n→     No  →\n→ Step 6: targetCounts = 目標字串的字母頻率\n→ Step 7: memo = 空字典 // 快取\n→ Step 8: result = solve(targetCounts) // 開始遞歸計算\n→ End // 程式結束並回傳 result\n\nWe must format each line as \"虛擬碼步驟 // 解釋\".\n\nWe must use arrow arrow, Decision etc. Use indentation maybe with spaces. Keep consistent.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: stickersCountList ← 取得每張貼紙的字母頻率表 // 為每張貼紙建立 26 個字母的計數  \n→ Step 2: solve ← 定義遞迴函式，參數為剩餘字母頻率 remainingCounts  \n  Decision: remainingCounts 全為 0? // 判斷是否已拼完所有字母  \n   Yes → Return 0 // 無需再貼紙  \n   No  → Decision: memo.containsKey(key(remainingCounts))? // 以頻率作為快取鍵  \n    Yes → Return memo[key] // 已計算過的結果  \n    No  →  \n     Step 3: minAns ← ∞ // 目前最佳貼紙數  \n     For sticker in stickersCountList: // 遍歷所有貼紙  \n      Decision: sticker 能減去剩餘字母? // 若貼紙中無剩餘字母則跳過  \n       Yes →  \n        Step 4: newCounts ← remainingCounts – min(stickerCount, remainingCount) for each letter // 用貼紙減去字母  \n        subAns ← solve(newCounts) // 递归求解剩餘部分  \n        Decision: subAns ≠ -1? // 是否可行  \n         Yes → minAns ← min(minAns, subAns + 1) // 更新最佳貼紙數  \n         No  → Continue // 無法完成，繼續嘗試其他貼紙  \n        End  \n       End  \n     End  \n     Decision: minAns = ∞? // 若仍無法完成  \n      Yes → memo[key] ← -1  \n      No  → memo[key] ← minAns  \n     Return memo[key]  \n→ Step 5: totalStickerCounts ← 合併所有貼紙的字母頻率 // 先檢查是否能覆蓋目標字母  \n  Decision: target 字母是否完全被 totalStickerCounts 包含?  \n   Yes → // 可以繼續  \n   No  → Return -1 // 直接不可完成  \n→ Step 6: targetCounts ← 目標字串的字母頻率表 // 轉換成 26 個字母的計數  \n→ Step 7: memo ← 空字典 // 用於快取已計算過的子問題結果  \n→ Step 8: result ← solve(targetCounts) // 開始遞迴計算最少貼紙數  \n→ End // 程式結束，輸出 result (若無解則為 -1)",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def minStickers(self, stickers, target):\n        sticker_count = [Counter(s) for s in stickers]\n        memo = {}\n\n        def dp(t: str) -> int:\n            if t == \"\":\n                return 0\n            if t in memo:\n                return memo[t]\n\n            t_count = Counter(t)\n            ans = float('inf')\n            for s in sticker_count:\n                # 快速過濾：如果貼紙不含目標中首字母，跳過\n                if t[0] not in s:\n                    continue\n                # 用貼紙減去目標字母後的新字串\n                new_t = \"\".join(\n                    c * max(0, t_count[c] - s.get(c, 0))\n                    for c in t_count\n                )\n                sub = dp(new_t)\n                if sub != -1:\n                    ans = min(ans, 1 + sub)\n\n            memo[t] = -1 if ans == float('inf') else ans\n            return memo[t]\n\n        return dp(target)\n\ndef parse_input(data: str):\n    # 提取 stickers 列表\n    stickers_match = re.search(r'stickers\\s*=\\s*(\\[[^\\]]*\\])', data)\n    # 提取 target 字串\n    target_match = re.search(r'target\\s*=\\s*\"([^\"]*)\"', data)\n    if not stickers_match or not target_match:\n        raise ValueError(\"Invalid input format\")\n    stickers = ast.literal_eval(stickers_match.group(1))\n    target = target_match.group(1)\n    return stickers, target\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    stickers, target = parse_input(data)\n    sol = Solution()\n    result = sol.minStickers(stickers, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "stickers = [\"notice\",\"possible\"], target = \"basicbasic\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode583.json",
    "problem_index_in_file": 0,
    "title": "Delete Operation for Two Strings",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and wor...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for computing minimum deletions to make two strings equal by deleting characters. This is classic problem: find longest common subsequence (LCS) length, then deletions = len(word1)+len(word2)-2*LCS.\n\nWe need virtual code steps line by line with arrow and decision etc. No actual code. Provide explanation after each line.\n\nWe must produce Start, steps, decisions. Probably we can show nested loops for DP. Let's produce a high-level algorithm:\n\nStart\n→ Input word1, word2\n→ Initialize dp matrix of size (len1+1) x (len2+1) with zeros // DP for LCS\n→ For i from 1 to len1\n    → For j from 1 to len2\n        → Decision: if word1[i-1]==word2[j-1] ?\n            Yes → dp[i][j] = dp[i-1][j-1] + 1 // chars match\n            No → dp[i][j] = max(dp[i-1][j], dp[i][j-1]) // take best\n→ LCS = dp[len1][len2]\n→ steps = len1 + len2 - 2 * LCS\n→ Output steps\nEnd\n\nAdd explanation comments.\n\nEnsure each line includes \"虛擬碼步驟 // 解釋\".\n\nUse arrow \"→\" before each step. Use indentation? In example, they use indent for nested decisions. We'll mimic.\n\nWe need no actual code, just pseudo steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 word1, word2 // 取得兩個待處理字串  \n→ Step 2: 令 n = word1 長度, m = word2 長度 // 方便之後索引  \n→ Step 3: 建立 dp 矩陣，尺寸為 (n+1) × (m+1)，並全部設為 0 // dp[i][j] 代表 word1[0..i-1] 與 word2[0..j-1] 的 LCS 長度  \n→ Decision: 迴圈 i 從 1 到 n? // 逐行填充 dp  \n  Yes → Step 4: 迴圈 j 從 1 到 m? // 逐列填充 dp  \n    Yes → Decision: word1[i-1] == word2[j-1]? // 判斷兩字元是否相同  \n     Yes → Step 5: dp[i][j] = dp[i-1][j-1] + 1 // 匹配時長度 +1  \n     No → Step 6: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) // 不匹配時取較大值  \n    No → End of j 迴圈  \n  No → End of i 迴圈  \n→ Step 7: 令 lcs = dp[n][m] // 取得整個字串的 LCS 長度  \n→ Step 8: 計算最小刪除步驟 steps = n + m - 2 * lcs // 公式推導  \n→ Step 9: 輸出 steps // 顯示最小步驟數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        \"\"\"\n        透過動態規劃計算兩字串相同所需的最小刪除步驟。\n        這裡實作的是 LeetCode 583 的標準 DP 方法。\n        \"\"\"\n        m, n = len(word1), len(word2)\n        # dp[i][j] 代表 word1[:i] 與 word2[:j] 變成相同所需的最小刪除數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # 初始化第一行和第一列，表示一方全刪除時的步驟\n        for i in range(1, m + 1):\n            dp[i][0] = i\n        for j in range(1, n + 1):\n            dp[0][j] = j\n\n        # 填表\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    # 字元相同，步驟不變\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    # 字元不同，刪除一個字元後取最小步驟再加 1\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，允許以下兩種格式：\n    1. word1 = \"sea\", word2 = \"eat\"\n    2. 兩行分別為字串\n    \"\"\"\n    # 嘗試從雙引號中抽取字串\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n    # 若無雙引號，則以空白或換行分隔\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # 若只有一個字串，假設另一個為空字串\n    return parts[0], \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    w1, w2 = parse_input(raw_input)\n    solution = Solution()\n    result = solution.minDistance(w1, w2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"sea\", word2 = \"eat\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "word1 = \"leetcode\", word2 = \"etco\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode28.json",
    "problem_index_in_file": 0,
    "title": "Implement strStr()",
    "description_snippet": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with arrow, Start, Decision, etc. Each line: \"虛擬碼步驟 [space] // 解釋\". Provide lines for algorithm to find index of needle in haystack, or -1. Use simple brute force or KMP? Simpler brute force. Steps: Start, input haystack, needle, check edge cases, loop i from 0 to len(haystack)-len(needle), inner loop j to check substring equality. If match, output i and end. After loop, output -1. Use Decision. Let's produce lines.\n\nWe must not output real code. Just virtual steps. Let's produce lines with arrows. Format: \"Start // 程式開始執行\". Then \"→ Step 1: 取得 haystack 與 needle // 讀取兩個字串\". And so on.\n\nWe need decision steps: check if needle length > haystack length => return -1. Then loop.\n\nLet's draft.\n\nAlso we must include \"End\" at end.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 haystack 與 needle // 讀取兩個字串  \n→ Decision: 如果 needle 為空? // 檢查空字串情況  \n  Yes → Step 2: 輸出 0 // 空字串視為在首位置  \n  No  → Decision: 如果 needle 長度 > haystack 長度? // 無法匹配  \n    Yes → Step 3: 輸出 -1 // 直接返回 -1  \n    No  → Step 4: 設定 maxIndex = haystack.length - needle.length // 最後可能起始位置  \n→ Step 5: 設定 i = 0 // 從頭開始搜尋  \n→ Decision: 是否 i <= maxIndex? // 是否還有可能位置  \n  Yes → Step 6: 設定 j = 0 // 內層比對指標  \n    → Decision: 是否 j < needle.length? // 尚未比對完所有字符  \n     Yes → Decision: 是否 haystack[i + j] == needle[j]? // 字符是否相等  \n       Yes → Step 7: 增加 j by 1 // 進行下一個字符比對  \n       No  → Step 8: i = i + 1 // 匹配失敗，移到下一起點  \n        → 返回 Decision: j < needle.length? // 重新評估  \n       No → Step 9: 輸出 i // 找到匹配，輸出起始索引  \n       → End // 程式結束  \n  No  → Step 10: 輸出 -1 // 全部位置檢查完仍未匹配  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"Return the index of the first occurrence of needle in haystack, or -1.\"\"\"\n        if not needle:               # 空字串直接回傳 0\n            return 0\n        n, m = len(haystack), len(needle)\n        # 從 0 到 n-m 進行滑動比對\n        for i in range(n - m + 1):\n            if haystack[i:i + m] == needle:  # 子字串相等即找到\n                return i\n        return -1  # 全部比對後仍未找到\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中抽取 haystack 與 needle。\n    期望的格式類似：haystack = \"sadbutsad\", needle = \"sad\"\n    \"\"\"\n    # 找出所有雙引號內的字串\n    parts = re.findall(r'\"([^\"]*)\"', text)\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # 若無雙引號，嘗試以空格分隔\n    tokens = text.strip().split()\n    if len(tokens) >= 2:\n        return tokens[0], tokens[1]\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    # 讀取所有標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    haystack, needle = parse_input(raw)\n    sol = Solution()\n    result = sol.strStr(haystack, needle)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "haystack = \"sadbutsad\", needle = \"sad\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "haystack = \"leetcode\", needle = \"leeto\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode605.json",
    "problem_index_in_file": 0,
    "title": "Can Place Flowers",
    "description_snippet": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines, with each line containing \"虛擬碼步驟\" then a space then comment. Use arrow symbols and structure Start, End, Decision. Provide logic for checking adjacency, counting. Let's create steps: Start, Step 1: initialize count=0, iterate over array index i from 0 to len-1, Decision: if flowerbed[i]==0 and (i==0 or flowerbed[i-1]==0) and (i==len-1 or flowerbed[i+1]==0)? Then plant -> increment count, set flowerbed[i]=1 maybe. After loop check if count>=n -> return true else false. Use Decision for each check. End. Use Yes/No arrows.\n\nMake sure each line includes arrow? The example uses \"→ Step 1:\" etc. We'll follow similar. For loop we might use \"→ Loop: i in 0..len-1\". But we can do \"→ Decision: current plot empty and neighbors empty?\" etc.\n\nWe need to include each step. Provide comments.\n\nLet's draft.\n\nStart // 程式開始執行\n→ Step 1: Set plantedCount = 0 // 初始化已種植的新花數量\n→ Step 2: Set i = 0 // 初始化索引\n→ Loop: i < len(flowerbed) // 循環遍歷所有花床格子\n    → Decision: flowerbed[i] == 0? // 當前格子是否為空\n        Yes →\n            → Decision: (i == 0 OR flowerbed[i-1] == 0) AND (i == len-1 OR flowerbed[i+1] == 0)? // 是否兩側都空\n                Yes →\n                    → Step 3: plant a flower: flowerbed[i] = 1 // 種植花朵\n                    → Step 4: plantedCount = plantedCount + 1 // 新花計數加一\n                No →\n                    → Step 5: // 無法種植，保持原狀\n        No →\n            → Step 6: // 格子已被佔用，跳過\n    → Step 7: i = i + 1 // 移動到下一格\n→ Decision: plantedCount >= n? // 是否已種植足夠新花\n    Yes → Return true // 可以種植 n 顆新花\n    No  → Return false // 無法種植足夠\nEnd // 程式執行結束\n\nWe need each line separate. Use arrows for decisions, but indentation maybe? We'll keep each line separate as in example. Ensure each line ends with comment. Provide explanation. That should satisfy. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set plantedCount = 0 // 初始化已種植的新花數量  \n→ Step 2: Set i = 0 // 初始化索引  \n→ Loop: i < len(flowerbed) // 循環遍歷所有花床格子  \n → Decision: flowerbed[i] == 0? // 當前格子是否為空  \n  Yes →  \n   → Decision: (i == 0 OR flowerbed[i-1] == 0) AND (i == len-1 OR flowerbed[i+1] == 0)? // 是否兩側都空  \n    Yes →  \n     → Step 3: plant a flower: flowerbed[i] = 1 // 種植花朵  \n     → Step 4: plantedCount = plantedCount + 1 // 新花計數加一  \n    No →  \n     → Step 5: // 無法種植，保持原狀  \n  No →  \n   → Step 6: // 格子已被佔用，跳過  \n → Step 7: i = i + 1 // 移動到下一格  \n→ Decision: plantedCount >= n? // 是否已種植足夠新花  \n Yes → Return true // 可以種植 n 顆新花  \n No  → Return false // 無法種植足夠  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canPlaceFlowers(self, flowerbed, n):\n        count = 0\n        length = len(flowerbed)\n        i = 0\n        while i < length:\n            if flowerbed[i] == 0:\n                empty_prev = (i == 0) or (flowerbed[i-1] == 0)\n                empty_next = (i == length-1) or (flowerbed[i+1] == 0)\n                if empty_prev and empty_next:\n                    flowerbed[i] = 1\n                    count += 1\n                    if count >= n:\n                        return True\n                    i += 1  # skip next slot because it cannot be planted\n            i += 1\n        return count >= n\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract flowerbed list\n    list_match = re.search(r'\\[.*?\\]', data)\n    if list_match:\n        flowerbed = eval(list_match.group(0))\n    else:\n        flowerbed = []\n\n    # Extract n value\n    n_match = re.search(r'n\\s*=\\s*(\\d+)', data)\n    n = int(n_match.group(1)) if n_match else 0\n\n    result = Solution().canPlaceFlowers(flowerbed, n)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "flowerbed = [1,0,0,0,1], n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "flowerbed = [1,0,0,0,1], n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode768.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted II",
    "description_snippet": "You are given an integer array arr.\n\nWe split arr into some number of chunks (i.e., partitions), and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line, with explanation. No actual code. Must reflect algorithm: largest number of chunks to sort. Known Leetcode problem 768. Approach: track max of left prefix; compare to sorted array or track max of original and min of sorted suffix. But we can just compute sorted arr and compare prefix max. Steps: sort copy; iterate, maintain maxPrefix; if maxPrefix==sorted[i], increment count. Return count.\n\nWe need to write virtual code lines: Start, Step, Decision etc.\n\nWe need to follow output format: Each line \"虛擬碼步驟 [space] // 解釋\".\n\nLet's produce lines:\n\nStart\n\n→ Step 1: 計算 n = length of arr // 取得陣列長度\n\n→ Step 2: 建立 sortedArr = copy of arr 並排序 // 取得完整排序後的陣列\n\n→ Step 3: 初始化 count = 0 // 用來計算可分割區塊數量\n\n→ Step 4: 初始化 maxLeft = -∞ // 追蹤左側子陣列最大值\n\n→ Decision: For i in 0..n-1? // 逐個索引遍歷\n\n    Yes → Step 5: maxLeft = max(maxLeft, arr[i]) // 更新左側最大值\n\n    Yes → Decision: 如果 maxLeft == sortedArr[i]? // 若左側最大值等於排序後對應位置\n\n        Yes → Step 6: count = count + 1 // 可形成一個區塊，遞增計數\n\n        No  → // 不做任何事，等待更大 maxLeft\n\n→ End // 回傳 count\n\nBut we need proper format: Step 5 inside loop? We should use \"Decision:\" and indent? The example shows indentation lines for nested decisions. We can use indentation with 4 spaces before nested lines maybe.\n\nWe should not produce any actual code. Use 虛擬碼.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n ← len(arr) // 取得輸入陣列的長度  \n→ Step 2: 產生 sortedArr ← arr 的排序副本 // 用於與原陣列對比  \n→ Step 3: 初始化 count ← 0 // 可分割區塊的計數  \n→ Step 4: 初始化 maxLeft ← -∞ // 追蹤左側子陣列的最大值  \n→ Decision: 針對每個索引 i 從 0 到 n-1? // 開始逐個遍歷陣列  \n  Yes → Step 5: maxLeft ← max(maxLeft, arr[i]) // 更新左側最大值  \n  Yes → Decision: maxLeft 是否等於 sortedArr[i]? // 檢查是否可形成區塊  \n    Yes → Step 6: count ← count + 1 // 形成一個區塊，計數加一  \n    No → // 不做任何事，等到更大的 maxLeft 以符合條件  \nEnd // 程式執行結束，返回 count 為最大區塊數目",
      "generated_code": "import sys\nimport ast\n\ndef max_chunks_to_sorted(arr):\n    \"\"\"Return the largest number of chunks that can be sorted independently\n    so that concatenating them yields the fully sorted array.\"\"\"\n    n = len(arr)\n    # 取得完整排序後的陣列\n    sorted_arr = sorted(arr)\n    count = 0\n    max_left = -float('inf')\n    for i in range(n):\n        # 更新左側子陣列的最大值\n        if arr[i] > max_left:\n            max_left = arr[i]\n        # 若左側最大值等於排序後對應位置，則可形成一個區塊\n        if max_left == sorted_arr[i]:\n            count += 1\n    return count\n\ndef parse_input(data: str):\n    \"\"\"將輸入字串轉成 list。支援 'arr = [...]' 或直接 '[...]' 兩種格式。\"\"\"\n    data = data.strip()\n    if 'arr' in data:\n        # 取等號右側作為 list\n        data = data.split('=', 1)[1].strip()\n    # 使用 ast.literal_eval 以避免 eval 的安全問題\n    return ast.literal_eval(data)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw = sys.stdin.read()\n    if not raw:\n        sys.exit()\n    arr = parse_input(raw)\n    result = max_chunks_to_sorted(arr)\n    # 將答案輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [5,4,3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [2,1,3,4,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode664.json",
    "problem_index_in_file": 0,
    "title": "Strange Printer",
    "description_snippet": "There is a strange printer with the following two special properties:\n\nThe printer can only print a ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Task: given string s, min turns for strange printer. This is classic DP problem. We produce algorithm: compute dp[i][j] minimal turns for substring i..j. Recurrence: dp[i][j] = dp[i][j-1] + 1; for k in [i, j-1] if s[k]==s[j], dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1]). Or other recurrence: dp[i][j] = min_{k} dp[i][k] + dp[k+1][j] - (s[i]==s[k+1]?1:0). Standard solution: DP O(n^3). But we produce virtual code, not actual code, but algorithm steps. We need to output each line of pseudo-code with explanation.\n\nWe must follow the output format: Each line \"虛擬碼步驟 // 解釋\". Use arrows. Should be start, decisions, loops.\n\nWe need to produce step-by-step algorithm. It's not actual code but steps.\n\nLet's design pseudocode:\n\nStart\n→ Input string s // get string\n→ Let n = length(s) // number of characters\n→ Initialize dp array n x n with 0 // dp[i][j] minimal turns for s[i..j]\n→ For i from 0 to n-1: dp[i][i] = 1 // single char requires one turn\n→ For len from 2 to n: // length of substring\n    → For i from 0 to n-len: // start index\n        → Let j = i + len - 1 // end index\n        → Set dp[i][j] = dp[i][j-1] + 1 // worst case: print s[j] separately\n        → For k from i to j-1:\n            → If s[k] == s[j]: // same character at position k and j\n                → temp = dp[i][k] + (k+1 <= j-1 ? dp[k+1][j-1] : 0) // combine prints\n                → If temp < dp[i][j]: dp[i][j] = temp\n→ Return dp[0][n-1] // answer\nEnd\n\nNeed to show decisions, loops, etc. Provide comments.\n\nWe must use the arrow format: \"→ Step 1: ...\" For loops, use \"→ For i from 0 to n-1:\" then inside lines maybe indent with spaces or \"→\" again. The example shows nested arrow and indent. We'll do similar.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s // 取得要列印的字串  \n→ Let n = length(s) // 取得字串長度  \n→ Initialize dp[n][n] = 0 // dp[i][j] 代表列印 s[i..j] 的最小回合數  \n\n→ For i from 0 to n-1: // 單一字元的情況  \n    → dp[i][i] = 1 // 只要一次即可列印  \n\n→ For len from 2 to n: // 逐段長度遞增  \n    → For i from 0 to n-len: // 子字串起始位置  \n        → Let j = i + len - 1 // 子字串結束位置  \n        → dp[i][j] = dp[i][j-1] + 1 // 先假設最後一個字元單獨列印  \n\n        → For k from i to j-1: // 檢查是否有相同字元可合併  \n            → Decision: s[k] == s[j]? // 是否相同  \n                Yes → temp = dp[i][k] + (k+1 <= j-1 ? dp[k+1][j-1] : 0) // 合併列印  \n                Yes → If temp < dp[i][j]: dp[i][j] = temp // 取較小值  \n                No  → Continue // 不相同，跳過  \n\n→ Return dp[0][n-1] // 回傳整個字串的最小回合數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef strange_printer(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    dp = [[0] * n for _ in range(n)]\n\n    # Compute for substrings of increasing length\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            # Worst case: print s[i] separately, then the rest\n            dp[i][j] = 1 + dp[i + 1][j]\n            # Try to merge printing of s[i] with later same characters\n            for k in range(i + 1, j + 1):\n                if s[k] == s[i]:\n                    if k + 1 <= j:\n                        dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j])\n                    else:\n                        dp[i][j] = min(dp[i][j], dp[i][k - 1])\n    return dp[0][n - 1]\n\ndef main() -> None:\n    # Read entire input; it may contain a statement like `s = \"aaabbb\"`\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # Extract the string value\n    if '=' in raw:\n        _, value = raw.split('=', 1)\n        s = value.strip()\n    else:\n        s = raw\n\n    # Remove possible surrounding quotes\n    s = s.strip('\"').strip(\"'\")\n\n    result = strange_printer(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabbb\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode377.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum IV",
    "description_snippet": "Given an array of distinct integers nums and a target integer target, return the number of possible ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for the problem: count number of combinations from distinct ints array that sum to target, where order matters? The problem is typical \"Combination Sum IV\" from Leetcode: given array of distinct integers nums and integer target, return number of possible combinations that add up to target. Order matters: e.g., [1,2] target 3: combinations: [1,1,1], [1,2], [2,1]. So we need to produce DP algorithm.\n\nWe produce virtual code line by line. Use Start, End, Decision, etc. Steps:\n\n1. Initialize dp array of length target+1 with 0.\n2. dp[0] = 1.\n3. For i from 1 to target:\n    For each num in nums:\n        if i >= num:\n            dp[i] += dp[i-num]\n4. Return dp[target]\n\nWe need to produce explanation after each line. Use arrow. We'll produce each line with \"→\" or \"Decision:\" etc.\n\nWe'll also include loops: \"Loop: i 1 to target\". But we need arrow and explanation.\n\nWe can write:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長 target+1 並全部設為 0 // 用於儲存各子目標的組合數\n→ Step 2: 設定 dp[0] = 1 // 基本情況：0 的組合只有一種（空組合）\n→ Loop: i from 1 to target // 遍歷所有目標值\n    → Decision: 是否進入內部迴圈? // 直接進入，處理所有 nums\n        → Loop: num in nums // 對每個可用數字\n            → Decision: i >= num? // 只有能減去 num 時才更新\n                Yes → Step 3: dp[i] = dp[i] + dp[i-num] // 加上把 num 加到子目標的組合數\n                No  → // 跳過不合法的數字\n→ Step 4: 回傳 dp[target] // 目標值的組合總數\nEnd // 程式執行結束\n\nBut we need to reflect arrow indentation properly.\n\nThe format: each line includes \"虛擬碼步驟\" and explanation.\n\nWe should maintain indent for loops and decisions. Use spaces. Example format in prompt shows indentation by 4 spaces for nested lines.\n\nWe'll replicate: start with \"Start\", then \"→ Step 1:\", etc.\n\nLet's produce.\n\nAlso need to mention that dp is int array.\n\nWe need \"Step 1: 建立 dp 陣列\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 陣列長 target+1 並全部設為 0 // 用於儲存各子目標的組合數  \n→ Step 2: 設定 dp[0] = 1 // 基本情況：0 的組合只有一種（空組合）  \n→ Loop: i 1 to target // 遍歷所有目標值  \n → Decision: 進入內部迴圈? // 直接處理所有可用數字  \n  → Loop: num in nums // 對每個可用數字  \n   → Decision: i >= num? // 只有能減去 num 時才更新  \n    Yes → Step 3: dp[i] = dp[i] + dp[i-num] // 加上把 num 加到子目標的組合數  \n    No  → // 跳過不合法的數字  \n→ Step 4: 回傳 dp[target] // 目標值的組合總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        # 建立 dp 陣列長 target+1 並全部設為 0\n        dp = [0] * (target + 1)\n        # 基本情況：dp[0] = 1\n        dp[0] = 1\n\n        # 遍歷所有目標值\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：nums = [1,2,3], target = 4\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    nums = eval(nums_match.group(1)) if nums_match else []\n    target = int(target_match.group(1)) if target_match else 0\n\n    solution = Solution()\n    result = solution.combinationSum4(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode726.json",
    "problem_index_in_file": 0,
    "title": "Number of Atoms",
    "description_snippet": "Given a string formula representing a chemical formula, return the count of each atom.\n\nThe atomic e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for parsing chemical formula, with stack etc. Provide line-by-line. Ensure format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Each line with \"→\". Provide steps: initialize stack, iterate from end to start or using stack. Let's design algorithm: use stack of maps. When encounter ')', push new map. When '(' encountered, pop map, multiply by following number, merge into previous map. For elements: parse element name, parse number. Add to current map.\n\nSimplify: iterate i from 0 to len-1, but need lookahead digits. Could use stack of maps. Let's produce pseudocode lines accordingly.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化公式字串 formula, 長度 n, 堆疊 stack, current map = 空 // 初始化資料\n→ Step 2: 設置指標 i = 0 // 從左到右掃描\n→ Decision: i < n? // 是否還有字符待處理\n    Yes → Step 3: 若 formula[i] == '('? // 進入括號\n        Yes → Step 4: 推入空 map 到 stack, current = 空 // 開始新子公式\n        No → Decision: formula[i] == ')' ? // 關閉括號\n            Yes → Step 5: 讀取位於 ')' 之後的數字 count (若無則 1) // 取得乘數\n            → Step 6: 從 stack 弹出子公式 map\n            → Step 7: 對子公式中的每個元素, 乘以 count, 並合併到 current map // 合併\n            No → Step 8: 解析元素名 starting from i: 大寫字母 + 隨後小寫字母\n            → Step 9: 讀取後續數字 (若無則 1) 為 count\n            → Step 10: current[元素] += count // 更新計數\n        No → Step 11: i++ // 移動到下一字符\n    No → End // 處理完成\nEnd // 程式結束\n\nBut we need more detailed for number parsing. Also after loop, produce sorted output string.\n\nAdd step after loop to build result.\n\nAlso need step for while loop with decision and i increment. Use loop representation: Decision: i < n? inside.\n\nAlso manage index increment within each branch.\n\nLet's produce final output lines accordingly. Ensure each line with arrow and comment.\n\nAlso include steps for reading numbers: maybe function ReadNumber(i) returns number and new i.\n\nLet's include substeps. Ensure arrow usage consistent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定公式字串 formula, 公式長度 n, 初始化空堆疊 stack, 設 current 為空字典 // 用於存放目前層級的原子計數  \n→ Step 2: 設指標 i = 0 // 從左至右掃描字串  \n→ Decision: i < n? // 是否還有字符待處理  \n    Yes → Step 3: 若 formula[i] == '('? // 遇到左括號，開始新子公式  \n        Yes → Step 4: 推入空字典至 stack, 設 current 為空字典 // 進入新層級  \n        No → Decision: formula[i] == ')' ? // 遇到右括號，結束子公式  \n            Yes → Step 5: 呼叫 ReadNumber(i+1) 取得乘數 count (預設 1) 並更新 i 為數字結束位置 // 讀取括號後的乘數  \n            → Step 6: 從 stack 弹出子字典 sub // 取得剛結束的子公式計數  \n            → Step 7: 對 sub 中每個 (atom, num) 做  \n                → current[atom] += num * count // 乘以乘數並合併至上一層  \n            → Step 8: i = i + 1 // 跳過 ')'，繼續掃描  \n            No → Step 9: 解析原子名稱 starting from i  \n                → Step 10: 設 element = formula[i] // 大寫字母  \n                → Step 11: 當 i+1 < n 且 formula[i+1] 為小寫字母時 i++ 並加到 element // 收集後續小寫字母  \n            → Step 12: 呼叫 ReadNumber(i+1) 取得 count (預設 1) 並更新 i 為數字結束位置 // 讀取後續數字  \n            → Step 13: current[element] += count // 更新目前層級計數  \n    No → Step 14: i = i + 1 // 移至下一字符  \nNo → Step 15: // 迴圈結束，所有層級已合併至 current  \n→ Step 16: 將 current 中的原子名稱按字典序排序得到 sorted_atoms // 排序  \n→ Step 17: 初始化空字串 result // 用於組裝輸出  \n→ Step 18: 對每個 atom in sorted_atoms 做  \n        → Step 19: 若 current[atom] > 1?  \n            Yes → result += atom + current[atom] // 加上原子與數量  \n            No → result += atom // 只加原子名  \n→ Step 20: 返回 result // 完成輸出  \nEnd // 程式執行結束  \n\n// ReadNumber: 讀取指標 pos 後的數字並回傳 (num, new_pos)  \n→ Step 21: 設 num = 0, pos = pos  \n→ Decision: pos < n 且 formula[pos] 為數字?  \n    Yes → num = num * 10 + (formula[pos] - '0')  \n    → pos = pos + 1  \n    No → Return (num > 0 ? num : 1, pos) // 若無數字則為 1, 並回傳新位置",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def countOfAtoms(self, formula: str) -> str:\n        n = len(formula)\n        self.i = 0\n\n        def parse() -> Counter:\n            cnt = Counter()\n            while self.i < n and formula[self.i] != ')':\n                if formula[self.i] == '(':\n                    self.i += 1\n                    inner = parse()\n                    self.i += 1  # skip ')'\n                    mult = 0\n                    while self.i < n and formula[self.i].isdigit():\n                        mult = mult * 10 + int(formula[self.i])\n                        self.i += 1\n                    if mult == 0:\n                        mult = 1\n                    for k, v in inner.items():\n                        cnt[k] += v * mult\n                else:\n                    start = self.i\n                    self.i += 1\n                    while self.i < n and formula[self.i].islower():\n                        self.i += 1\n                    name = formula[start:self.i]\n                    num = 0\n                    while self.i < n and formula[self.i].isdigit():\n                        num = num * 10 + int(formula[self.i])\n                        self.i += 1\n                    if num == 0:\n                        num = 1\n                    cnt[name] += num\n            return cnt\n\n        counts = parse()\n        parts = []\n        for atom in sorted(counts):\n            parts.append(atom + (str(counts[atom]) if counts[atom] > 1 else \"\"))\n        return \"\".join(parts)\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract formula string between quotes\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        formula = match.group(1)\n    else:\n        # Fallback: take the entire line if no quotes found\n        formula = data\n\n    sol = Solution()\n    result = sol.countOfAtoms(formula)\n\n    # Print the result surrounded by double quotes as per examples\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "formula = \"H2O\"",
          "expected_output": "\"H2O\"",
          "success": true,
          "output": "\"H2O\""
        },
        {
          "example_index": 1,
          "input": "formula = \"Mg(OH)2\"",
          "expected_output": "\"H2MgO2\"",
          "success": true,
          "output": "\"H2MgO2\""
        },
        {
          "example_index": 2,
          "input": "formula = \"K4(ON(SO3)2)2\"",
          "expected_output": "\"K4N2O14S4\"",
          "success": true,
          "output": "\"K4N2O14S4\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode575.json",
    "problem_index_in_file": 0,
    "title": "Distribute Candies",
    "description_snippet": "Alice has n candies, where the i^th candy is of type candyType[i]. Alice noticed that she started to...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps that solve the problem: given array candyType of length n even, maximize number of distinct types Alice can eat by choosing n/2 candies. The answer is min(number of distinct types, n/2). So algorithm: count distinct types using set or hash set. Then answer = min(distinct_count, n/2). So virtual code steps: Start, Step 1: Initialize empty set, Step 2: For each candy type, add to set. Step 3: distinct_count = size of set. Step 4: half = n / 2. Step 5: answer = min(distinct_count, half). Step 6: return answer. End.\n\nWe must output line by line with arrow. Format: \"Start // ...\" then \"→ Step ...\". Decision not needed. Provide comments. Use arrows. Let's produce. Ensure to include arrow for each step. Use arrow for each step. Provide explanation after space.\n\nMake sure each line has virtual code step and // explanation. Use \"→\" for step lines. Use \"Start\" and \"End\". No actual code. Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空集合 distinctTypes // 用來存放不同種類的糖果  \n→ Step 2: 從陣列 candyType 中逐個取值 type，並將 type 加入 distinctTypes // 逐一加入集合，重複值自動忽略  \n→ Step 3: distinctCount ← distinctTypes 的大小 // 取得不同種類的總數  \n→ Step 4: half ← n / 2 // 計算醫生允許吃的糖果數量  \n→ Step 5: answer ← 若 distinctCount > half，則 half；否則 distinctCount // 取較小者，即能吃到的最大不同種類數  \n→ Step 6: 回傳 answer // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_different_candies(candyType):\n    \"\"\"\n    依照醫生建議，Alice 只能吃 n/2 顆糖果。\n    目標是吃到最多不同種類的糖果。\n    答案是不同種類數量和 n/2 的較小值。\n    \"\"\"\n    return min(len(set(candyType)), len(candyType) // 2)\n\ndef main():\n    # 從標準輸入讀取全部內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入形式為 \"candyType = [1,1,2,2,3,3]\"\n    # 就提取等號右側的陣列字串；否則直接使用整個輸入\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n        arr_str = arr_str.strip()\n    else:\n        arr_str = data\n\n    # 使用 ast.literal_eval 安全地將字串轉成 Python 物件\n    try:\n        candy_type_list = ast.literal_eval(arr_str)\n    except Exception:\n        # 若解析失敗，視為空列表\n        candy_type_list = []\n\n    # 計算並輸出答案\n    result = max_different_candies(candy_type_list)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candyType = [1,1,2,2,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "candyType = [1,1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "candyType = [6,6,6,6]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode532.json",
    "problem_index_in_file": 0,
    "title": "K-diff Pairs in an Array",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the ar...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: Count unique k-diff pairs. Approach: use set for seen numbers; count unique pairs. Common solution: Use hash map counts or set of unique numbers. For each number x, if k==0 then count unique numbers with freq >1. Else for each x, if x+k in set -> count++ unique. Ensure not double count by using set. Steps:\n\nStart\n→ Build frequency map\n→ If k<0: return 0 // difference negative invalid\n→ If k==0: count numbers with freq>1\n→ Else: for each unique number, if num + k exists -> count++\nEnd\n\nAlso handle negative k same as positive due to absolute difference.\n\nLet's produce virtual code lines:\n\nStart // 程式開始\n→ Decision: 如果 k < 0? // 差值不能為負\n    Yes → Step 1: Return 0 // 無效差值\n    No  → Step 2: 建立數字頻率映射 // 統計每個數字出現次數\n→ Decision: k == 0? // 特殊情況\n    Yes → Step 3: 計算頻率>1 的數量 // 只算重複數字一次\n    No  → Step 4: 建立唯一數字集合 // 方便查找\n        → Step 5: 迭代每個數字 num\n            → Decision: 如果 num + k 在集合中? // 是否存在匹配\n                Yes → Step 6: count++ // 計入一個唯一對\n                No  → Step 7: 什麼都不做 // 無對\n→ End\n\nBut need to provide explanation for each line. Ensure each line ends with //.\n\nLet's produce lines accordingly. We'll use \"Step X\" labeling. Use \"Decision:\" lines with nested lines. Ensure arrow indentations but format: \"→ Step X: ... // 說明\" and \"→ Decision: ... // 說明\" then indented lines with arrows maybe \"    Yes → Step ...\" but we need to preserve formatting. Let's follow sample: they used indentation with spaces. We'll mimic.\n\nLet's craft.\n\nAlso include \"End // 程式執行結束\"\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: k 是否小於 0? // 差值若為負則無合法對  \n    Yes → Step 1: Return 0 // 差值非法，直接回傳 0  \n    No  → Step 2: 建立頻率映射 freq[數字] = 次數 // 計算每個數字在陣列中出現的次數  \n→ Decision: k 是否等於 0? // k 為 0 時，對應的是相同數字的重複對  \n    Yes → Step 3: count ← 0  \n         → 迭代 freq 中每個 (數字, 次數)  \n             → Decision: 次數 > 1? // 需要至少兩個相同數字才能形成對  \n                 Yes → count ← count + 1 // 每個重複數字算一次對  \n                 No  → 什麼都不做  \n         → End 迭代  \n         → End // 計算完畢，count 為 k‑diff 對的數量  \n    No  → Step 4: uniqueSet ← Set(所有 nums 的元素) // 取得唯一數字集合  \n         → Step 5: count ← 0  \n         → 迭代 uniqueSet 中每個 num  \n             → Decision: num + k 在 uniqueSet 中? // 是否存在匹配的另一數字  \n                 Yes → count ← count + 1 // 計入一個唯一對  \n                 No  → 什麼都不做  \n         → End 迭代  \n         → End // 計算完畢，count 為 k‑diff 對的數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findPairs(self, nums, k):\n        # 差值若為負，無合法對\n        if k < 0:\n            return 0\n\n        # 統計每個數字出現的次數\n        freq = Counter(nums)\n\n        if k == 0:\n            # k = 0 時，只要同一個數字至少出現兩次即可\n            return sum(v > 1 for v in freq.values())\n\n        # k > 0 時，檢查每個數字是否存在 +k 的配對\n        return sum(1 for n in freq if n + k in freq)\n\ndef main():\n    # 讀取整個輸入，並利用 ast.literal_eval 解析為 (list, int)\n    raw_input = sys.stdin.read().strip()\n    try:\n        data = ast.literal_eval(raw_input)\n        # 解析成列表和整數\n        nums, k = data\n    except Exception:\n        # 若輸入分兩行，先分行再解析\n        lines = raw_input.splitlines()\n        nums = ast.literal_eval(lines[0].strip())\n        k = int(lines[1].strip())\n\n    solution = Solution()\n    result = solution.findPairs(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode611.json",
    "problem_index_in_file": 0,
    "title": "Valid Triangle Number",
    "description_snippet": "Given an integer array nums, return the number of triplets chosen from the array that can make trian...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for counting triangle triplets from array. Must use the specified format: each line includes virtual code step and comment. Use arrows, Start, End, Decision. Provide step-by-step. No actual code. Just steps. Also need to not output actual code, only structure. Let's produce algorithm: sort array, for each i from len-1 down to 2, set left=0, right=i-1, while left<right: if nums[left]+nums[right]>nums[i] then count += right-left; right--; else left++. This is typical.\n\nWe need to produce each step line by line. Use arrow \"→\" to indicate progress. Each step: Step description with \"→ Step X:\" etc.\n\nNeed to follow formatting: Start, Step 1, Decision, Yes →, No →, End. Should be hierarchical.\n\nWe need to maintain structure.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數陣列 nums // 取得輸入\n→ Step 2: 取得陣列長度 n // 確認元素數量\n→ Decision: n 是否小於 3? // 檢查是否足夠成三角形\n    Yes → Step 3: 返回 0 // 元素不足，無三角形\n    No  → Step 4: 對陣列 nums 進行升序排序 // 為兩指針準備\n→ Step 5: 初始化計數器 count 為 0 // 用於累計符合條件的三元組數\n→ Step 6: 對 i 從 n-1 下降至 2 進行迴圈 // 固定最大的邊\n    → Step 7: 設定 left 為 0, right 為 i-1 // 初始化左右指標\n    → Decision: left 是否小於 right? // 判斷是否還有可比對的兩個邊\n        Yes → Step 8: 檢查 nums[left] + nums[right] 是否大於 nums[i] // 判斷能否形成三角形\n            Yes → Step 9: 將 count 加上 (right - left) // 所有 left~right-1 與 i 能組三角形\n                → Step 10: right 減 1 // 移動右指標向左\n                → Decision: left 是否小於 right? // 重新檢查\n                    Yes → 回到 Step 8\n                    No  → 轉到 Step 11\n            No  → Step 11: left 加 1 // 左指標向右移動，嘗試更大的左邊\n                → Decision: left 是否小於 right? // 重新檢查\n                    Yes → 回到 Step 8\n                    No  → 轉到 Step 12\n        No  → Step 12: 完成對 i 的處理，返回外層迴圈\n→ Step 13: 返回計數器 count // 輸出結果\nEnd // 程式執行結束\n\nNeed to ensure each line follows format: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" at beginning for lines after Start? Example format: \"→ Step 1: ... // ...\". For decisions: \"Decision:\" lines and Yes/No sub-lines with arrow. Example: \"Decision: n 是否小於 3? // ...\" then indent? But we need to keep same pattern: \"Decision:\" line, then \"Yes →\" etc. The sample uses indentation: spaces before Yes →? In example they used four spaces before Yes →? Actually:\n\n```\nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n```\n\nThey used 4 spaces indent. So we should follow same indentation: 4 spaces before Yes/No lines and further nested ones. We'll produce accordingly.\n\nWe need to ensure the \"虛擬碼步驟\" is before comment, with a space between them. Use colon after Step numbers. For arrow lines, use \"→\" then Step description. For decision lines, \"Decision:\".\n\nAlso need to keep the steps logically correct. Use appropriate variable names in Chinese? Could use `nums`, `n`, `i`, `left`, `right`, `count`. Provide brief comments in Chinese.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入整數陣列 nums // 取得輸入\n→ Step 2: 取得陣列長度 n // 確認元素數量\n→ Decision: n 是否小於 3? // 檢查是否足夠成三角形\n    Yes → Step 3: 返回 0 // 元素不足，無三角形\n    No  → Step 4: 對陣列 nums 進行升序排序 // 為兩指針準備\n→ Step 5: 初始化計數器 count 為 0 // 用於累計符合條件的三元組數\n→ Step 6: 對 i 從 n-1 下降至 2 進行迴圈 // 固定最大的邊\n    → Step 7: 設定 left 為 0, right 為 i-1 // 初始化左右指標\n    → Decision: left 是否小於 right? // 判斷是否還有可比對的兩個邊\n        Yes → Step 8: 檢查 nums[left] + nums[right] 是否大於 nums[i] // 判斷能否形成三角形\n            Yes → Step 9: 將 count 加上 (right - left) // 所有 left~right-1 與 i 能組三角形\n                → Step 10: right 減 1 // 移動右指標向左\n                → Decision: left 是否小於 right? // 重新檢查\n                    Yes → 回到 Step 8\n                    No  → 轉到 Step 11\n            No  → Step 11: left 加 1 // 左指標向右移動，嘗試更大的左邊\n                → Decision: left 是否小於 right? // 重新檢查\n                    Yes → 回到 Step 8\n                    No  → 轉到 Step 12\n        No  → Step 12: 完成對 i 的處理，返回外層迴圈\n→ Step 13: 返回計數器 count // 輸出結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def triangleNumber(self, nums):\n        nums.sort()\n        count = 0\n        n = len(nums)\n        for k in range(n - 1, 1, -1):\n            i, j = 0, k - 1\n            while i < j:\n                if nums[i] + nums[j] > nums[k]:\n                    count += j - i\n                    j -= 1\n                else:\n                    i += 1\n        return count\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中擷取整數陣列。\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # 如果輸入包含 'nums ='，則從 '[' 開始切取\n    start = data.find('[')\n    if start != -1:\n        data = data[start:]\n    try:\n        nums = ast.literal_eval(data)\n        if isinstance(nums, list):\n            return nums\n    except Exception:\n        pass\n    return []\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    solution = Solution()\n    result = solution.triangleNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode3.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring Without Repeating Characters",
    "description_snippet": "Given a string s, find the length of the longest substring without duplicate characters....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanations. Virtual code lines use arrows →, Start, End, Decision, etc. We must not output actual code. Provide a line for each step. We'll create algorithm: sliding window. Steps: Initialize start, maxLen, dict/ map of char to index. For each char with index end. If char seen and index>=start, move start to last index+1. Update maxLen = max(maxLen, end-start+1). After loop, output maxLen.\n\nLet's produce pseudocode lines. Provide explanation comments. Use arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s // 從使用者取得要處理的字串\n→ Step 2: 初始化 start = 0, maxLen = 0, charIndexMap = 空字典 // 用於記錄字符最後出現的位置\n→ Step 3: 針對 s 的每個字符 c 以及其索引 i 進行迭代 // 遍歷字串\n    → Decision: c 是否已存在於 charIndexMap 且 charIndexMap[c] >= start? // 檢查重複字符且仍在窗口內\n        Yes → Step 4: start = charIndexMap[c] + 1 // 移動窗口起始位置至重複字符之後\n        No  → // 不做任何操作，窗口保持不變\n    → Step 5: 更新 charIndexMap[c] = i // 記錄字符最新出現的位置\n    → Step 6: 更新 maxLen = max(maxLen, i - start + 1) // 計算當前窗口長度並更新最大值\n→ Step 7: 輸出 maxLen // 顯示最長不重複子字串長度\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef longest_substring_without_duplicates(s: str) -> int:\n    \"\"\"\n    計算字串 s 中不重複字元的最長子字串長度。\n    使用滑動窗口 + 字典記錄每個字元最後出現的位置。\n    \"\"\"\n    last_seen = {}           # char -> last index\n    start = 0                # 窗口左端\n    max_len = 0\n\n    for i, ch in enumerate(s):\n        if ch in last_seen and last_seen[ch] >= start:\n            # 遇到重複字元且在目前窗口內，將左端移到重複字元之後\n            start = last_seen[ch] + 1\n        # 更新字元最後出現位置\n        last_seen[ch] = i\n        # 更新目前窗口長度\n        curr_len = i - start + 1\n        if curr_len > max_len:\n            max_len = curr_len\n\n    return max_len\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取字串，計算並輸出答案。\n    支援輸入形如：s = \"abcabcbb\" 或僅字串本身。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試從雙引號中取出字串\n    if '\"' in data:\n        parts = data.split('\"')\n        s = parts[1] if len(parts) > 1 else ''\n    else:\n        s = data\n\n    result = longest_substring_without_duplicates(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcabcbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"bbbbb\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \"pwwkew\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode715.json",
    "problem_index_in_file": 0,
    "title": "Range Module",
    "description_snippet": "A Range Module is a module that tracks ranges of numbers. Design a data structure to track the range...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output a virtual code algorithm for a Range Module class. The virtual code steps should be line-by-line, with arrow indicators and explanation comments. We need to design data structure: likely use sorted list of intervals or an interval tree. For simplicity, we can describe using an ordered set of non-overlapping intervals. Steps: Initialize empty list. addRange merges overlapping intervals. queryRange checks that [l,r) is fully covered. removeRange splits intervals. We need to describe pseudo code. Use \"Start\" \"End\" etc. Provide per line explanation. Use Chinese simplified? Use Traditional Chinese. Provide explanation after space and //.\n\nLet's craft steps. Might need to show high-level algorithm: addRange: find first interval that intersects, merge, remove old, add new. queryRange: find interval containing left, check continuous to right. removeRange: find overlapping intervals, adjust or split.\n\nWe need to produce \"逐行虛擬碼\" with each line like \"Start // 程式開始執行\". Use arrows and indentation. Use \"Decision:\" lines. Ensure we don't output real code, just pseudo.\n\nWe'll create the virtual steps. Maybe we can structure as methods: constructor, addRange, queryRange, removeRange. Each method as separate block. Provide pseudo code. Use arrow for each step.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行\n→ RangeModule() 初始化空的區間列表 // 建立一個空的有序區間集合\n→ End\n\n→ addRange(left, right) // 開始新增區間\n→ Decision: 檢查 left 是否大於 right? // 確認輸入合法\n    Yes → Return // 若左大於右，直接返回\n    No  →\n→ Find 位置 idxL = 第一個區間 r_i > left 的索引 // 找到左側可能重疊的起點\n→ Find 位置 idxR = 第一個區間 l_i >= right 的索引 // 找到右側第一個不重疊的區間\n→ 若 idxL > 0 且 intervals[idxL-1].right >= left\n        idxL ← idxL - 1 // 左側的上一個區間也可能重疊，包含進來\n→ 計算 newLeft = min(left, intervals[idxL].left) // 取最左側已經存在的區間左邊界\n→ 計算 newRight = max(right, intervals[idxR-1].right) // 取最右側已經存在的區間右邊界\n→ 刪除 intervals[idxL … idxR-1] // 移除所有與新區間重疊的舊區間\n→ 插入 intervals[idxL] = [newLeft, newRight] // 插入合併後的新區間\n→ End\n\n→ queryRange(left, right) // 開始查詢區間\n→ Decision: 找到 idx = 第一個區間 l_i <= left 且 r_i >= left 的索引 // 檢查左端是否被覆蓋\n    Yes →\n        Decision: 右端 r_i >= right?\n            Yes → Return true // 完全覆蓋\n            No  → Return false // 右端未覆蓋\n    No  → Return false // 左端不在任何區間內\n\n→ removeRange(left, right) // 開始移除區間\n→ Decision: 檢查 left 是否大於 right? // 輸入合法性\n    Yes → Return\n    No  →\n→ Find idxL = 第一個區間 r_i > left 的索引 // 左側可能重疊的起點\n→ Find idxR = 第一個區間 l_i >= right 的索引 // 右側第一個不重疊的區間\n→ 若 idxL > 0 且 intervals[idxL-1].right > left\n        // 左側上一個區間部分被覆蓋，需要保留左半部分\n        rightPart = intervals[idxL-1]\n        intervals[idxL-1] = [rightPart.left, left] // 截斷左側區間\n→ 若 idxR > idxL 且 intervals[idxR-1].left < right\n        // 右側上一個區間部分被覆蓋，需要保留右半部分\n        leftPart = intervals[idxR-1]\n        intervals[idxR-1] = [right, leftPart.right] // 截斷右側區間\n→ 刪除 intervals[idxL+1 … idxR-2] // 刪除所有完全被覆蓋的中間區間\n→ End\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport bisect\nimport json\n\nclass RangeModule:\n    def __init__(self):\n        # list of non-overlapping intervals, sorted by start\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                # overlapping, merge\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        # find interval whose start is <= left\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        l, r = self.ranges[i-1]\n        return l <= left and right <= r\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                # no overlap\n                new_ranges.append([l, r])\n            else:\n                # overlap exists, trim or split\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    outputs = []\n    # Assume one RangeModule instance per input\n    module = None\n\n    for line in lines:\n        if line.startswith(\"RangeModule\"):\n            # initialization line, e.g. \"RangeModule rangeModule = new RangeModule();\"\n            module = RangeModule()\n            outputs.append(None)\n        elif line.startswith(\"rangeModule.addRange\"):\n            start = line.find('(')\n            end = line.find(')')\n            args = line[start+1:end].split(',')\n            left, right = int(args[0].strip()), int(args[1].strip())\n            module.addRange(left, right)\n            outputs.append(None)\n        elif line.startswith(\"rangeModule.removeRange\"):\n            start = line.find('(')\n            end = line.find(')')\n            args = line[start+1:end].split(',')\n            left, right = int(args[0].strip()), int(args[1].strip())\n            module.removeRange(left, right)\n            outputs.append(None)\n        elif line.startswith(\"rangeModule.queryRange\"):\n            start = line.find('(')\n            end = line.find(')')\n            args = line[start+1:end].split(',')\n            left, right = int(args[0].strip()), int(args[1].strip())\n            result = module.queryRange(left, right)\n            outputs.append(result)\n        else:\n            # ignore unknown lines\n            continue\n\n    # Convert Python None/True/False to JSON format\n    print(json.dumps(outputs))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode641.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Deque",
    "description_snippet": "Design your implementation of the circular double-ended queue (deque).\n\nImplement the MyCircularDequ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line with comments, following the arrow syntax. Provide steps for implementing the circular deque class with methods. We need to include class initialization and each method. Each line should be a virtual code step and a comment.\n\nWe should structure like:\n\nStart\n→ Step 1: Define class MyCircularDeque with capacity, array, front, rear, size\n→ Step 2: Constructor MyCircularDeque(k) // Initialize array size k, front, rear, size\n... etc.\n\nWe need to include logic for insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull.\n\nAlso need to handle circular behavior: front index points to current front, rear points to current rear.\n\nCommon implementation: Use array of size k. Maintain front and rear indices. For empty, size=0. For full, size==k.\n\nInsertFront: if full return false. Else front = (front - 1 + k) % k; array[front] = value; size++; return true.\n\nInsertLast: if full return false. Else rear = (rear + 1) % k; array[rear] = value; size++; return true.\n\nDeleteFront: if empty return false. Else front = (front + 1) % k; size--; return true.\n\nDeleteLast: if empty return false. Else rear = (rear - 1 + k) % k; size--; return true.\n\nGetFront: if empty return -1 else array[front].\n\nGetRear: if empty return -1 else array[rear].\n\nisEmpty: size==0.\n\nisFull: size==k.\n\nLet's produce virtual code line by line. Should we break each method into separate steps? Yes, each method separate steps. Provide lines accordingly.\n\nWe can label Step 1: Start, Step 2: define class, Step 3: constructor, etc. For each method we can do steps: Step N: insertFront method definition, Step N+1: if full? etc.\n\nLet's produce. Ensure each line ends with // explanation.\n\nAlso need to include Start and End.\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCircularDeque 類別 // 建立類別結構\n→ Step 2: 成員變數: capacity, data[], front, rear, size // 存儲容量、資料陣列、前後指標與當前大小\n→ Step 3: Constructor MyCircularDeque(k) // 初始化\n    → Step 3.1: capacity ← k // 設定最大容量\n    → Step 3.2: data ← new int[capacity] // 建立固定大小陣列\n    → Step 3.3: front ← 0 // 前指標起始位置\n    → Step 3.4: rear ← k - 1 // 後指標起始位置，為了讓後插入時能正確環繞\n    → Step 3.5: size ← 0 // 初始時沒有元素\n... etc.\n\nThen methods.\n\nUse arrow indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類別 // 建立類別結構  \n→ Step 2: 成員變數: capacity, data[], front, rear, size // 存儲容量、資料陣列、前後指標與當前大小  \n\n→ Step 3: Constructor MyCircularDeque(k) // 初始化  \n  → Step 3.1: capacity ← k // 設定最大容量  \n  → Step 3.2: data ← new int[capacity] // 建立固定大小陣列  \n  → Step 3.3: front ← 0 // 前指標起始位置  \n  → Step 3.4: rear ← k - 1 // 後指標起始位置，方便後插入時環繞  \n  → Step 3.5: size ← 0 // 初始時沒有元素  \n\n→ Step 4: insertFront(value) // 在前端插入元素  \n  → Decision: 如果 isFull()? // 檢查是否已滿  \n    Yes → Return false // 不能插入  \n    No  →  \n     → front ← (front - 1 + capacity) % capacity // 前指標向前環繞  \n     → data[front] ← value // 放入資料  \n     → size ← size + 1 // 元素數量增加  \n     → Return true // 成功插入  \n\n→ Step 5: insertLast(value) // 在後端插入元素  \n  → Decision: 如果 isFull()? // 檢查是否已滿  \n    Yes → Return false // 不能插入  \n    No  →  \n     → rear ← (rear + 1) % capacity // 後指標向後環繞  \n     → data[rear] ← value // 放入資料  \n     → size ← size + 1 // 元素數量增加  \n     → Return true // 成功插入  \n\n→ Step 6: deleteFront() // 從前端刪除元素  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return false // 不能刪除  \n    No  →  \n     → front ← (front + 1) % capacity // 前指標向後移動  \n     → size ← size - 1 // 元素數量減少  \n     → Return true // 成功刪除  \n\n→ Step 7: deleteLast() // 從後端刪除元素  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return false // 不能刪除  \n    No  →  \n     → rear ← (rear - 1 + capacity) % capacity // 後指標向前移動  \n     → size ← size - 1 // 元素數量減少  \n     → Return true // 成功刪除  \n\n→ Step 8: getFront() // 取得前端元素  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return -1 // 空陣列時返回 -1  \n    No  → Return data[front] // 回傳前端資料  \n\n→ Step 9: getRear() // 取得後端元素  \n  → Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Return -1 // 空陣列時返回 -1  \n    No  → Return data[rear] // 回傳後端資料  \n\n→ Step 10: isEmpty() // 判斷是否為空  \n  → Return size == 0 // 空時返回 true  \n\n→ Step 11: isFull() // 判斷是否已滿  \n  → Return size == capacity // 滿時返回 true  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k                  # 最大容量\n        self.buf = [0] * k          # 儲存資料的固定大小陣列\n        self.head = 0               # front 指標\n        self.count = 0              # 目前元素個數\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:    # 判斷是否已滿\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n\n    commands = json.loads(data[0])\n    params = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for cmd, param in zip(commands, params):\n        if cmd == \"MyCircularDeque\":\n            obj = MyCircularDeque(param[0])\n            results.append(None)           # constructor returns null\n        else:\n            method = getattr(obj, cmd)\n            if param:\n                res = method(*param)\n            else:\n                res = method()\n            results.append(res)\n\n    # 使用 json.dumps 以符合範例輸出的 JSON 格式\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpe4gljufl.py\", line 63, in <module>\n    commands = json.loads(data[0])\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode410.json",
    "problem_index_in_file": 0,
    "title": "Split Array Largest Sum",
    "description_snippet": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the la...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for a typical LeetCode problem: split array into k subarrays minimizing largest sum. Approach: binary search on possible sums, with a greedy check.\n\nWe need to produce step-by-step virtual code lines, each with explanation. Use arrows. Provide Start, End, Decision etc.\n\nWe should not output real code, just pseudocode steps.\n\nLet's design:\n\nStart\n\n→ Input: nums array, k\n\n→ Initialize low = max(nums), high = sum(nums)\n\n→ While low < high:\n\n→ Decision: if canSplit(low): high = low else low = low+1\n\n→ After loop, low is answer\n\n→ Output low\n\nWe need to implement canSplit(mid): count subarrays <= k, using greedy accumulate.\n\nSo inside while, we call a decision function.\n\nWe need to provide virtual code for canSplit? Probably include in the flow.\n\nSo we will include sub-procedure: canSplit(mid):\n\n→ Initialize count=1, currentSum=0\n\n→ For each num in nums:\n\n→ Decision: if currentSum + num <= mid: currentSum += num else: count++ ; currentSum = num\n\n→ Decision: if count <= k return true else false\n\nBut we need to output step-by-step, maybe as separate block.\n\nBetter: inside while loop: → Decision: if canSplit(low): high = low else low = low + 1\n\nWe need to show canSplit steps maybe as subroutine.\n\nLet's produce.\n\nMake sure each line has \"→\" and a comment.\n\nUse \"Decision:\" for decisions.\n\nUse \"Yes →\", \"No →\" accordingly.\n\nMake sure to use proper arrow.\n\nLet's produce lines.\n\nWe need to be careful to maintain indentation for decisions.\n\nWe also need to keep Start, End markers.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums, k // 取得輸入的整數陣列和分割數量  \n→ Decision: 設定搜尋範圍  \n  → low ← max(nums) // 最小可能最大子陣列和，至少要大於等於最大元素  \n  → high ← sum(nums) // 最大可能最大子陣列和，等於整個陣列和  \n\n→ Decision: while low < high? // 進行二分搜尋  \n  Yes → Decision: canSplit(low) 為真? // 判斷能否用 low 為上限分割為 k 個子陣列  \n    Yes → high ← low // 若可行，將高端縮小到 low  \n    No  → low ← low + 1 // 若不可行，將低端提升到 low+1  \n  No  → // 迴圈結束，low 即為最小化的最大子陣列和  \n\n→ Output low // 回傳結果  \n\nEnd // 程式執行結束  \n\n// ----------------- canSplit 函式 (偽程式) -----------------  \n// 用於判斷是否能以 maxSum 為上限將 nums 分割成不超過 k 個子陣列  \nStart // canSplit 開始執行  \n→ maxSum ← input parameter  \n→ count ← 1 // 初始化子陣列數量  \n→ currentSum ← 0 // 當前子陣列累計和  \n\n→ For each num in nums: // 逐一遍歷陣列  \n  Decision: currentSum + num <= maxSum? // 檢查加入此元素後是否仍在上限內  \n    Yes → currentSum ← currentSum + num // 若在上限內，累加  \n    No  → count ← count + 1 // 否則開始新子陣列  \n       currentSum ← num // 新子陣列的累計和為此元素  \n\n→ Decision: count <= k? // 判斷子陣列數量是否不超過 k  \n  Yes → Return true // 可行  \n  No  → Return false // 不可行  \n\nEnd // canSplit 結束執行",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def splitArray(self, nums, m):\n        # Helper function to check if we can split with max sum <= mid\n        def can_split(mid):\n            count, curr_sum = 1, 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= m\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if can_split(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n\n    # Extract the list of numbers inside brackets\n    nums_match = re.search(r'\\[(.*?)\\]', data)\n    if not nums_match:\n        raise ValueError(\"Input format error: cannot find list of numbers.\")\n    nums_str = nums_match.group(0)  # includes brackets\n    nums = ast.literal_eval(nums_str)\n\n    # Extract k value (integer after 'k' or the last integer not in the list)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if k_match:\n        k = int(k_match.group(1))\n    else:\n        # fallback: take the last integer from the input that is not part of the list\n        all_ints = list(map(int, re.findall(r'-?\\d+', data)))\n        # remove all ints that belong to nums\n        k = all_ints[-1]\n    solution = Solution()\n    result = solution.splitArray(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [7,2,5,10,8], k = 2",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,5], k = 2",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode274.json",
    "problem_index_in_file": 0,
    "title": "H-Index",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for computing h-index given an array of citations. We'll produce step-by-step pseudocode lines with explanations. Must follow the format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow arrow (→). Use Decision: if etc. Need to handle input array, sort descending, iterate, find maximum h. We'll output Start, End. Use Steps like: Start, → Step 1: Sort citations descending, etc. Decision: if i+1 <= citations[i] etc. Provide explanation. Should not output actual code. Provide step lines only. Use Chinese explanation. Let's produce. Ensure each line has arrow only at start? Format example shows \"→ Step 1: ...\" after Start. We'll mimic that. For decisions, indent maybe. Use spaces. We'll produce like:\n\nStart // 程式開始執行\n→ Step 1: 獲取 citations 陣列 // 取得輸入資料\n→ Step 2: 將 citations 陣列按降序排列 // 方便後續判斷\n→ Step 3: 初始化 h_index 為 0 // 用於存儲最終結果\n→ Decision: 是否存在 i 使得 i+1 ≤ citations[i]? // 檢查每個位置的條件\n   Yes → Step 4: 更新 h_index 為 i+1 // 發現更大的 h 值\n   No  → Decision: 是否已檢查完所有索引? // 若已完成則結束\n       Yes → End // 程式結束，返回 h_index\n       No  → 回到前一個未檢查的索引 // 繼續循環\n\nBut need to loop. Use for loop. Provide pseudo steps.\n\nLet's produce proper step lines.\n\nWe should include lines for loop: For i from 0 to n-1. Then inside Decision. We'll produce structure.\n\nOk. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 citations 陣列 // 從使用者或資料來源取得原始引用數字  \n→ Step 2: 計算陣列長度 n = citations 的元素數量 // 用於迴圈範圍  \n→ Step 3: 將 citations 陣列按降序排序 // 使較高引用數排列在前面  \n→ Step 4: 初始化 h_index 為 0 // 用於儲存目前已找到的最大 h 值  \n→ Step 5: 從 i = 0 開始，迴圈至 i < n  \n   → Decision: 是否符合 i+1 ≤ citations[i]? // 判斷第 i+1 篇論文是否至少被引用 i+1 次  \n        Yes → Step 6: 將 h_index 設為 i+1 // 更新最大 h 值  \n        No  → Step 7: 進行下一個 i // 繼續檢查後續論文  \n→ Step 8: 迴圈結束後，輸出 h_index // 回傳最終 h-index  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef h_index(citations):\n    # 按降序排序\n    citations.sort(reverse=True)\n    h = 0\n    for i, c in enumerate(citations):\n        if c >= i + 1:      # 第 i+1 篇論文至少被引用 i+1 次\n            h = i + 1\n        else:\n            break\n    return h\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 若輸入格式為 \"citations = [3,0,6,1,5]\"\n    if '=' in data:\n        _, part = data.split('=', 1)\n        part = part.strip()\n    else:\n        part = data\n    try:\n        citations = ast.literal_eval(part)\n    except Exception:\n        # 若無法解析，試著把數字提取出來\n        citations = [int(x) for x in part.replace(',', ' ').split()]\n    print(h_index(citations))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [3,0,6,1,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode462.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements II",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for solving this problem: minimize moves to equalize array elements by +1/-1. Classic: choose median; sum of abs differences. Steps: sort array; find median; compute sum absolute difference. Virtual code. Also mention handling even n: any median between two middle works; we can pick middle floor. So steps: Start; input array; compute n; sort array; median = arr[n/2]; total=0; for each x: total += abs(x - median); output total; End.\n\nAlso need to follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe must include decision nodes? Not many decisions. Just loop. So we can use → Step etc.\n\nLet's produce lines.\n\nWe should incorporate Start, End. Use arrows.\n\nPossible steps:\n\nStart // 程式開始執行\n\n→ Step 1: 讀取整數陣列 nums // 取得輸入陣列\n\n→ Step 2: n ← length(nums) // 計算陣列長度\n\n→ Step 3: 排序(nums) // 為了找中位數，先將陣列排序\n\n→ Step 4: median ← nums[n // 2] // 取中位數（n 為奇數時即中間元素，偶數時取上半部第一個）\n\n→ Step 5: total ← 0 // 初始化移動次數總和\n\n→ Step 6: for each x in nums // 逐一遍歷陣列\n\n    → Step 6.1: total ← total + abs(x - median) // 加上與中位數的差值\n\n→ Step 7: 輸出 total // 將最小移動次數回傳\n\nEnd // 程式執行結束\n\nNeed to format with arrows properly: Use → Step 1, etc. For inner loop use indentation? The example uses indentation for nested steps. We'll use spaces.\n\nAlso use \"→ Decision:\"? No decision except maybe if n%2==0? But we can omit.\n\nWe should maintain single spaces after arrows. Each line ends with // explanation.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 nums // 取得輸入陣列\n→ Step 2: n ← length(nums) // 計算陣列長度\n→ Step 3: 排序(nums) // 為了找中位數，先將陣列排序\n→ Step 4: median ← nums[n // 2] // 取中位數（n 為奇數時即中間元素，偶數時取上半部第一個）\n→ Step 5: total ← 0 // 初始化移動次數總和\n→ Step 6: for each x in nums // 逐一遍歷陣列\n    → Step 6.1: total ← total + abs(x - median) // 加上與中位數的差值\n→ Step 7: 輸出 total // 將最小移動次數回傳\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef min_moves_to_equal(nums):\n    \"\"\"計算將所有數字移動到中位數所需的最小步數。\"\"\"\n    nums.sort()\n    median = nums[len(nums) // 2]          # 中位數\n    total = 0\n    for num in nums:\n        total += abs(num - median)         # 累加與中位數的差值\n    return total\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容，並解析出 nums 列表\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 找到第一個 '[' 與最後一個 ']' 之間的字串，並安全地解析成 list\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        raise ValueError(\"輸入格式不正確，無法找到數字列表。\")\n    nums_str = data[start:end + 1]\n    nums = ast.literal_eval(nums_str)       # 只允許安全字面量解析\n    if not isinstance(nums, list):\n        raise ValueError(\"解析結果不是列表。\")\n    # 計算並輸出答案\n    result = min_moves_to_equal(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,10,2,9]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode209.json",
    "problem_index_in_file": 0,
    "title": "Minimum Size Subarray Sum",
    "description_snippet": "Given an array of positive integers nums and a positive integer target, return the minimal length of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, with explanation. It's the classic sliding window problem: minimal length subarray sum >= target. Steps: Start, input array, target, initialize left=0, sum=0, minLen=∞. Iterate right from 0 to n-1: add nums[right] to sum. While sum >= target: update minLen = min(minLen, right-left+1). Subtract nums[left] from sum, left++. After loop, if minLen is still ∞, return 0 else minLen. Use decision steps accordingly.\n\nWe need to output each line with \"→\" and explanation comment after //.\n\nWe should include \"Start\" and \"End\". Use Decision: for while sum>=target? yes no.\n\nAlso need to handle no subarray case: Decision: if minLen == ∞? Yes → Step: return 0, No → Step: return minLen.\n\nLet's produce.\n\nMake sure each line has virtual code step then space then // explanation.\n\nWe must not output actual code, just virtual code.\n\nLet's produce lines.\n\nStart // 程式開始執行\n→ Input nums, target // 取得輸入陣列與目標值\n→ Initialize left = 0, sum = 0, minLen = ∞ // 設定滑動窗口指標與初始最小長度\n→ For right = 0 to nums.length-1: // 逐個擴展右指標\n    → Add nums[right] to sum // 讓目前子陣列總和包含新元素\n    → Decision: sum >= target? // 判斷目前子陣列是否達到目標\n        Yes → Decision: minLen > (right-left+1)? // 檢查是否更新最小長度\n            Yes → Update minLen = right-left+1 // 若更短，更新 minLen\n            No → No operation // 若不更短，保持不變\n        No → No operation // 若尚未達到目標，繼續擴張\n    → Decision: sum >= target? // 再次判斷是否需要收縮左指標\n        Yes → While sum >= target: // 只要總和滿足條件，就縮小窗口\n            → Update minLen = min(minLen, right-left+1) // 更新最短長度\n            → Subtract nums[left] from sum // 從總和移除左端元素\n            → Increment left // 左指標右移\n        No → No operation // 總和不滿足，跳過收縮\nEnd // 程式執行結束\n\nBut this might not be perfect because we used Decision twice. We need to structure properly: For each right, we add, then while sum>=target we update and shrink. Then after loop.\n\nLet's restructure.\n\nStart\n→ Input nums, target\n→ Initialize left = 0, sum = 0, minLen = ∞\n→ For right = 0 to nums.length-1:\n    → sum = sum + nums[right]\n    → While sum >= target:\n        → minLen = min(minLen, right-left+1)\n        → sum = sum - nums[left]\n        → left = left + 1\nEnd loop\n→ Decision: minLen == ∞? // 若仍為無限大表示不存在子陣列\n    Yes → Return 0\n    No → Return minLen\n\nBut need arrow for decision. Use \"Decision: minLen == ∞?\".\n\nOk.\n\nLet's produce final answer.\n\nAlso each line must include virtual code step plus explanation comment. Use \"→\" at each step except Start, End. But Start also? In sample, Start is line with no arrow. But we can use \"Start\" no arrow.\n\nFollow pattern.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Input nums, target // 取得陣列與目標值\n→ Initialize left = 0, sum = 0, minLen = ∞ // 設定滑動窗口左指標、總和與最短長度\n→ For right = 0 to nums.length-1: // 逐一擴張右指標\n    → sum = sum + nums[right] // 將新元素加入總和\n    → While sum >= target: // 當總和達到或超過目標時收縮左側\n        → minLen = min(minLen, right-left+1) // 更新最短子陣列長度\n        → sum = sum - nums[left] // 移除左端元素的值\n        → left = left + 1 // 左指標右移\nEnd // 跳出 for 迴圈，完成所有右指標的處理\n→ Decision: minLen == ∞? // 判斷是否存在符合條件的子陣列\n    Yes → Return 0 // 若不存在，回傳 0\n    No  → Return minLen // 若存在，回傳最短長度\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minSubArrayLen(self, target, nums):\n        left = 0\n        total = 0\n        min_len = float('inf')\n        \n        for right in range(len(nums)):\n            total += nums[right]\n            \n            while total >= target:\n                min_len = min(min_len, right - left + 1)\n                total -= nums[left]\n                left += 1\n                \n        return 0 if min_len == float('inf') else min_len\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 提取所有整數，第一個為 target，其餘為 nums\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if not numbers:\n        print(0)\n    else:\n        target = numbers[0]\n        nums = numbers[1:]\n        sol = Solution()\n        result = sol.minSubArrayLen(target, nums)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode633.json",
    "problem_index_in_file": 0,
    "title": "Sum of Square Numbers",
    "description_snippet": "Given a non-negative integer c, decide whether there're two integers a and b such that a^2 + b^2 = c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that determines if c can be expressed as sum of two squares. This is classic number theory. We can iterate over a from 0 to sqrt(c) and check if c - a^2 is a perfect square. But we need virtual code.\n\nWe need each line: virtual step + // explanation. Use arrows and Decision. So something like:\n\nStart\n→ Step 1: Calculate maxA = floor(sqrt(c)) // maximum possible a\n→ Decision: If maxA < 0? // check if c negative? But c is non-negative given. Could skip.\nWe can loop from a=0 to maxA:\n→ Step 2: For a = 0 to maxA // iterate a\n    → Step 3: Compute b2 = c - a^2 // remainder\n    → Decision: If b2 < 0? // but a <= sqrt(c), so non-negative.\n        No → Step 4: Compute b = floor(sqrt(b2)) // potential b\n        → Decision: If b^2 == b2? // check perfect square\n            Yes → Step 5: Output true // found representation\n            No → Step 6: Continue loop\n→ Step 7: Output false // no representation found\nEnd\n\nWe also might include an early exit if found. But this structure is fine. We need to adhere to format: Each line \"虛擬碼步驟 [space] // 解釋\". Use arrows \"→\" at each step. Use \"Decision:\" etc. Indent? Format sample uses indentation with spaces for sub-steps. We'll follow that style.\n\nWe should produce step names: Step 1, Step 2 etc. The arrow may be \"→ Step 1:\" etc. But in sample, \"→ Step 1: 輸入使用者數字\". So \"→ Step 1: ...\" Then indent decisions with two spaces? They used 4 spaces? The sample shows:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\nEnd // 程式執行結束\n\nSo indentation: Decision line no indent, the Yes/No lines are indented 4 spaces? Actually sample: After Decision line, next line starts with 4 spaces then Yes. Then inside that, No block indent 4 spaces? Let's replicate similar style.\n\nThus our output:\n\nStart // 程式開始執行\n→ Step 1: 計算 maxA = floor(sqrt(c)) // 取得 a 的最大可能值\n→ Decision: 若 c < 0? // 檢查輸入是否為負數\n    Yes → Step 2: 輸出 False // c 為負數時不可能表示\n    No  → Step 3: for a = 0 to maxA // 循環嘗試每個 a\n        → Step 4: 計算 b2 = c - a^2 // 取得剩餘值\n        → Decision: 若 b2 < 0? // 理論上不會發生\n            Yes → Step 5: 繼續 // 跳過\n            No  → Step 6: 計算 b = floor(sqrt(b2)) // 可能的 b\n                → Decision: 若 b^2 == b2? // 判斷是否為平方數\n                    Yes → Step 7: 輸出 True // 找到 a, b\n                    No  → Step 8: 繼續 // 继续循环\n→ Step 9: 輸出 False // 未找到符合條件的 a, b\nEnd // 程式執行結束\n\nBut note indentation: after Step 3: for a = 0 to maxA we need to indent inner steps. In sample, after for loop, they indent inner steps? They used indent of 4 spaces for lines inside for. But we should maintain readability.\n\nBetter approach: Use Decision structure for loop? But for loops not shown. We'll just indent steps inside loop.\n\nLet's produce final answer with proper indentation and comments.\n\nAlso note that we should not output actual code, just virtual code. Good.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 maxA = floor(sqrt(c)) // 取得 a 的最大可能值  \n→ Decision: 若 c < 0? // 檢查輸入是否為負數  \n    Yes → Step 2: 輸出 False // c 為負數時不可能表示  \n    No  → Step 3: for a = 0 to maxA // 循環嘗試每個 a  \n        → Step 4: 計算 b2 = c - a^2 // 取得剩餘值  \n        → Decision: 若 b2 < 0? // 理論上不會發生  \n            Yes → Step 5: 繼續 // 跳過此 a  \n            No  → Step 6: 計算 b = floor(sqrt(b2)) // 可能的 b  \n                → Decision: 若 b^2 == b2? // 判斷是否為平方數  \n                    Yes → Step 7: 輸出 True // 找到 a, b  \n                    No  → Step 8: 繼續 // 继续循环  \n→ Step 9: 輸出 False // 未找到符合條件的 a, b  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\n\nclass Solution:\n    def judgeSquareSum(self, c: int) -> bool:\n        if c < 0:\n            return False\n        left, right = 0, int(math.isqrt(c))\n        while left <= right:\n            total = left * left + right * right\n            if total == c:\n                return True\n            elif total < c:\n                left += 1\n            else:\n                right -= 1\n        return False\n\ndef parse_input(data: str) -> int:\n    # Extract integer from input, e.g. \"c = 5\" or just \"5\"\n    data = data.strip()\n    if '=' in data:\n        _, value = data.split('=', 1)\n        data = value.strip()\n    return int(data)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n    c = parse_input(raw_input)\n    solution = Solution()\n    result = solution.judgeSquareSum(c)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "c = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "c = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode667.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement II",
    "description_snippet": "Given two integers n and k, construct a list answer that contains n different positive integers rang...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudocode to solve the problem. Provide lines with arrows and comments. Must not produce real code.\n\nWe need algorithm: Given n, k. Need list answer of n distinct integers from 1..n such that the absolute differences between consecutive elements produce exactly k distinct values. Return any.\n\nWe can think of constructing sequence with k distinct differences: We can use zigzag pattern: start at 1, then n, then 2, then n-1, etc. This yields differences of large values. But we need exactly k distinct differences. Approach: we can create first k+1 elements to produce k distinct differences, then remaining elements arbitrary while preserving distinct differences count.\n\nCommon known solution: For k distinct differences, we can produce sequence by taking left=1, right=n, alternate to produce differences: 1->n, n->2, 2->n-1,... This will produce differences that are decreasing but may produce many distinct differences. But we need exactly k. Known Codeforces problem: \"Construct the Array\" (#1473A?). Actually there is problem \"Construct a sequence with k distinct differences\". Approach: Build first k+1 numbers by alternating low and high: l=1,r=n; for i in 1..k+1: if i%2==1 choose l, else r, then adjust l++ or r-- accordingly. Then remaining numbers fill the rest in increasing order (or decreasing). That ensures exactly k distinct differences. So we can produce pseudocode.\n\nLet's craft steps:\n\nStart: input n, k.\n\nCheck constraints: k < n.\n\nInitialize answer list.\n\nSet low=1, high=n.\n\nFor i from 1 to k+1:\n  if i%2==1:\n    append low to answer; low+=1\n  else:\n    append high to answer; high-=1\n\nAfter loop, we have k+1 elements. Now we need remaining n-(k+1) elements. They should not introduce new difference values. Use the remaining numbers in increasing order if last element is low? Let's think: Suppose last element after loop is high or low depending on parity. We need to fill rest such that new differences are among the already existing k differences. The typical solution: After constructing alternating part, if we finish with low (when k+1 is odd), we can append remaining numbers from low to high ascending. That will produce differences of 1 only which might already be among the differences? Let's analyze.\n\nExample n=5,k=2. We get sequence: 1,5,2. Differences: 4,3. k distinct =2. Remaining numbers: 3,4. Last element is 2, then append 3,4. Differences: 1,1. So new differences are 1 which is new, increasing distinct count to 3 >k. Not allowed.\n\nSo we need to choose order such that remaining differences are among existing ones (i.e., 3 or 4). Typical solution uses filling with numbers in between in such a way that differences are small? Actually known solution: After the alternating part, you can continue filling with remaining numbers either ascending or descending but starting from the side that ensures differences are <= current max difference. But typical approach: After building first k+1 numbers, then append remaining numbers sequentially from low to high or high to low such that new differences are small, but may introduce new differences.\n\nBut the standard accepted solution for Codeforces problem (Construct a permutation with k distinct differences) is:\n\n- Build first k+1 numbers by alternating low and high.\n- Then for remaining numbers from low to high (if last appended was low? Actually after the loop, low > high? For n large, after k+1 steps low has increased k+1/2 times, high decreased k+1/2 times. Remaining numbers are the unused middle ones: low to high inclusive. If last appended was low (i.e., k is even, so k+1 odd), last element is low. Then you can append the remaining numbers in ascending order from low to high. That will produce differences of 1 each time, which may be new. But if k even, the set of differences already includes 1? Let's check: For k even, the alternating part ends with low. Let's test n=5,k=2 (even). Alternating part: i=1->1, i=2->5, i=3->2. So differences 4,3. Set does not contain 1. If we append 3,4 ascending: differences 1,1. This introduces new difference 1 -> not allowed. So that fails.\n\nSo typical solution uses filling with remaining numbers in a specific order: After alternating part, if k is even, we need to append remaining numbers in decreasing order from high to low? Let's test: n=5,k=2. Remaining numbers after using 1,5,2: left over 3,4. If last element is 2, high=4, low=3. Append descending: 4,3. Differences: 2,1. 2 new? differences are 2,1 new. Not good.\n\nHmm.\n\nLet's analyze known solution: Suppose we generate permutation such that first k+1 numbers produce k distinct differences, and the rest are numbers that are consecutive so differences are 1, which may or may not be new. We need to ensure 1 is already among the distinct differences from first part. So we must guarantee that 1 is already in the set. That is, the differences from first part must include 1. So we need to design first part accordingly.\n\nObservation: The alternating pattern yields differences that are large descending: n-1, n-3, n-5,... So it may not include 1 unless n small. But we can tweak pattern: Instead of using extremes, we can start with 1, then n, then 2, then n-1, etc. The differences are: n-1, n-2, n-3, ... Not 1 unless k large. For n=5,k=2, differences: 4,3. Not 1.\n\nThus we need another approach.\n\nAlternative approach: Build list of numbers from 1 to n. Then adjust first k+1 numbers such that differences are 1,2,...,k maybe. Known approach: For k distinct differences, we can construct as: For i from 1 to k+1: if i <= (k+1)/2: put i else: put n - (i - (k+1)/2 - 1). Actually we can produce sequence that yields differences 1,2,...,k. Example: n=5,k=2: we want differences 1 and 2. Sequence: 1,3,2,4,5? Let's compute: 1->3 diff 2; 3->2 diff 1; 2->4 diff 2; 4->5 diff 1. Distinct differences {1,2}. Works. General pattern: Use start low=1, high=n; produce k+1 numbers alternating low/high. That yields differences big, but maybe we can reorder.\n\nLet's derive known CF solution: For k distinct differences, we can generate answer as:\n- Start with 1.\n- For i from 1 to k:\n    if i is odd: append i+1 (?), no.\nBetter approach: Use low=1, high= k+1. For i from 1 to k+1:\n  if i odd: ans.append(low); low+=1\n  else: ans.append(high); high-=1\n\nThis uses numbers 1..k+1 only, not up to n. Differences will be high-low etc. For k=2: numbers 1,3,2. Differences 2,1. Distinct 2. Then fill remaining numbers from k+2 to n in increasing order. That ensures differences of 1 with last element? Let's test: n=5,k=2: initial seq: 1,3,2. remaining numbers: 4,5. Append 4,5. Differences: 1 (2->4 diff 2), 1 (4->5 diff 1). Wait 2->4 diff=2 which is already in set, fine. 4->5 diff=1 already in set. Good. Distinct differences remain {1,2}. So this works! The pattern uses first k+1 numbers from 1..k+1 alternating extremes. This ensures differences are the set of 1..k? Let's test k=3: n=7,k=3. First part: numbers 1..4. Alternating: 1,4,2,3. Differences: 3,2,1. Distinct {1,2,3}. Then remaining numbers 5..7 ascending: 4->5 diff1, 5->6 diff1,6->7 diff1. All diff1 already present. Works. So algorithm:\n\n- Use low=1, high=k+1.\n- Build first part of length k+1 alternating low/high.\n- Then append remaining numbers from k+2 to n in ascending order.\n\nEdge case: n may be equal to k+1. Then only first part needed. Works.\n\nThus pseudocode lines:\n\nStart\n→ Input n, k\n→ Decision: 如果 k >= n? // invalid but given constraints assume k<n\n    No → proceed\n→ Initialize empty answer list\n→ Set low = 1, high = k + 1 // 低端和高端界定\n→ Decision: 用於構造前 k+1 個數\n    For i from 1 to k+1\n        Decision: 如果 i 是奇數?\n            Yes → Append low to answer // 把最小值加入\n                low += 1\n            No  → Append high to answer // 把最大值加入\n                high -= 1\n→ Decision: 是否還有剩餘數? // 檢查 n 是否 > k+1\n    Yes → For num from k+2 to n\n            Append num to answer // 按升序加入剩餘\n→ End\n\nNow add explanation after each line.\n\nNeed to use arrow syntax. Provide each line as \"Start // ...\" etc. Also need Decision lines with indentation.\n\nLet's format:\n\nStart // 程式開始執行\n→ Input n, k // 讀取兩個整數 n 與 k\n→ Decision: 如果 k >= n? // 確認 k 小於 n，否則無效\n    No → // 若 k < n，繼續\n→ Set low = 1, high = k + 1 // 定義最小與最大可用數字\n→ For i = 1 到 k + 1\n    → Decision: i 是奇數? // 判斷奇偶以決定取哪一邊\n        Yes → Append low to answer // 把目前最小值加入答案\n            low += 1 // 更新最小值\n        No  → Append high to answer // 把目前最大值加入答案\n            high -= 1 // 更新最大值\n→ Decision: 是否有剩餘數字? // 若 n > k+1\n    Yes → For num = k + 2 到 n\n            Append num to answer // 以升序把剩餘數字加入\n→ End // 程式結束\n\nWe need to adhere to format: \"Start // ...\" \"→ Step\" lines.\n\nWe need each line with `虛擬碼步驟` + space + `// 解釋`. Use arrow \"→\". For decision, use \"Decision:\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n, k // 讀取兩個整數 n 與 k  \n→ Decision: 如果 k ≥ n? // 檢查 k 必須小於 n，否則無解  \n  No → // 若 k < n，繼續執行  \n→ Set low = 1, high = k + 1 // 設定可使用的最小與最大數值  \n→ For i = 1 到 k + 1  \n  → Decision: i 是奇數? // 判斷當前步驟是取最小值還是最大值  \n   Yes → Append low to answer // 把目前最小值加入答案  \n    low += 1 // 更新最小值為下一個可用數字  \n   No  → Append high to answer // 把目前最大值加入答案  \n    high -= 1 // 更新最大值為上一個可用數字  \n→ Decision: 是否還有剩餘數字? // 若 n > k + 1，還有未使用的數字  \n  Yes → For num = k + 2 到 n  \n    Append num to answer // 以升序把剩餘數字加入答案  \n→ End // 程式結束執行",
      "generated_code": "import sys\nimport re\n\ndef constructArray(n: int, k: int):\n    res = []\n    left, right = 1, k + 1\n    for i in range(k + 1):\n        if i % 2 == 0:\n            res.append(left)\n            left += 1\n        else:\n            res.append(right)\n            right -= 1\n    for num in range(k + 2, n + 1):\n        res.append(num)\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n        answer = constructArray(n, k)\n        print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 1",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 2",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode69.json",
    "problem_index_in_file": 0,
    "title": "Sqrt(x)",
    "description_snippet": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for integer square root without using exponent. So binary search approach: low=0, high=x, while low <= high: mid=(low+high)//2, if mid*mid == x: return mid; if mid*mid < x: low=mid+1; else high=mid-1; return high. Also handle x=0. Provide step-by-step with explanation after each line.\n\nUse Start, End, Decision. Provide each line as \"虛擬碼步驟 // 解釋\". We need to ensure each line has arrow? They used arrow for steps: \"→ Step 1: ...\". But arrow for decision: \"→ Decision:\".\n\nWe produce lines: Start, then arrow lines. For loops, need to use Decision for while condition. Use \"Decision: while low <= high?\" then Yes arrow leads to inner code, No leads to End.\n\nInside loop: Step to compute mid; Decision: mid*mid == x? Yes → Return mid; No → Decision: mid*mid < x? Yes → low=mid+1; No → high=mid-1. After loop, return high.\n\nAlso initial handling: maybe step to set low, high.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 low = 0, high = x // 初始搜尋範圍\n→ Decision: low <= high? // 判斷是否還有範圍可搜尋\n    Yes → Step 2: 計算 mid = (low + high) // 2 // 找中點\n    Yes → Decision: mid * mid == x? // 判斷是否找到精確平方根\n        Yes → Step 3: 返回 mid // 找到平方根，結束\n        No  → Decision: mid * mid < x? // 判斷 mid 是否太小\n            Yes → Step 4: 設定 low = mid + 1 // 讓 low 右移\n            No  → Step 5: 設定 high = mid - 1 // 讓 high 左移\n    No  → Step 6: 返回 high // loop 結束時 high 為 floor(sqrt(x))\nEnd // 程式執行結束\n\nNeed to maintain arrow for each. Let's format each line with \"→\" before step or decision. For nested decisions, we might indent with spaces. Keep arrow lines with \"→\". Each line with explanation.\n\nWe must ensure no code output, only virtual code. Provide each line accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 low = 0, high = x // 初始搜尋範圍  \n→ Decision: low <= high? // 判斷是否還有範圍可搜尋  \n  Yes → Step 2: 計算 mid = (low + high) // 2 // 找中點  \n  Yes → Decision: mid * mid == x? // 判斷是否找到精確平方根  \n    Yes → Step 3: 返回 mid // 找到平方根，結束  \n    No → Decision: mid * mid < x? // 判斷 mid 是否太小  \n      Yes → Step 4: 設定 low = mid + 1 // 讓 low 右移  \n      No → Step 5: 設定 high = mid - 1 // 讓 high 左移  \n  No → Step 6: 返回 high // loop 結束時 high 為 floor(sqrt(x))  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        \"\"\"\n        Return the floor of the square root of a non-negative integer x.\n        Uses binary search without any exponentiation operators.\n        \"\"\"\n        if x < 2:          # 0 and 1 are their own square roots\n            return x\n\n        left, right = 1, x // 2\n        while left <= right:\n            mid = (left + right) // 2\n            prod = mid * mid\n            if prod == x:\n                return mid\n            elif prod < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right  # right is the largest mid with mid*mid <= x\n\n\nif __name__ == \"__main__\":\n    # Read the entire input (handles single line or multiple lines)\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Attempt to extract an integer from the input.\n    # Handles formats like \"x = 4\" or just \"4\".\n    match = re.search(r\"(\\d+)\", data)\n    if not match:\n        raise ValueError(\"No integer found in input\")\n\n    x = int(match.group(1))\n\n    solution = Solution()\n    result = solution.mySqrt(x)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 8",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode385.json",
    "problem_index_in_file": 0,
    "title": "Mini Parser",
    "description_snippet": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for deserialization of nested integer list. We should output line by line with \"Start\", \"End\", \"Decision\", steps. We should produce the algorithm steps: parse string char by char, use stack, create NestedInteger objects, push/pop.\n\nWe must not output actual code, just virtual steps.\n\nWe need to use the format: \"虛擬碼步驟 // 解釋\". Each line. Use arrow symbols: \"→\", \"Yes →\", \"No →\". Use \"Start\", \"End\". We need to produce a clear algorithm.\n\nWe should include initialization: stack, index.\n\nSteps:\n\nStart\n\n→ Initialize stack as empty list of NestedInteger // 用於存放正在建立的列表\n\n→ Initialize result as None // 從頭開始\n\n→ Initialize i = 0 // 字符索引\n\n→ While i < len(s): // 遍歷字符串\n\n→ Decision: 是否為 '['? // 判斷開始新列表\n\n→ Yes → Step: Create new NestedInteger as list, push onto stack // 新列表\n\n→ No  → Decision: 是否為 ']'? // 判斷結束列表\n\n→ Yes → Step: Pop top NestedInteger from stack // 完成一個列表\n\n→ Decision: If stack not empty? // 是否還有外層列表\n\n→ Yes → Step: Append popped to new top // 把完成的列表加到外層\n\n→ No  → Step: Set result to popped // 最外層列表完成，保存結果\n\n→ No  → Decision: 是否為 ','? // 分隔符，忽略\n\n→ Yes → Step: i += 1 // 跳過逗號\n\n→ No  → Decision: 是否為 '-' 或數字? // 整數開始\n\n→ Yes → Step: Parse完整整數直到非數字\n\n→ Step: Convert到 int\n\n→ Step: Create NestedInteger with int\n\n→ Decision: 是否在stack? // 內部或根\n\n→ Yes → Step: Append integer to top of stack\n\n→ No  → Step: Set result to integer // 整個序列為單個整數\n\n→ End\n\nWe need to be careful with indexes increments. Add steps for moving index.\n\nLet's produce in the required format. Ensure each line has `虛擬碼步驟 // 解釋`. Use arrow indentations. Probably need to show indentation with spaces? Use tabs? Just spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize stack as empty list of NestedInteger // 用於存放正在建立的列表  \n→ Initialize result as None // 用來保存整個反序列化結果  \n→ Initialize i = 0 // 字符索引  \n\n→ Decision: i < len(s)? // 檢查是否還有字符需要處理  \n    Yes →  \n        → Decision: s[i] == '['? // 判斷是否開始新列表  \n            Yes →  \n                → Step: Create new NestedInteger as list // 新列表開始  \n                → Step: Push it onto stack // 將新列表入棧  \n                → Step: i += 1 // 移到下一個字符  \n            No →  \n                → Decision: s[i] == ']'? // 判斷是否結束列表  \n                    Yes →  \n                        → Step: Pop top NestedInteger from stack // 完成一個子列表  \n                        → Decision: stack is not empty? // 是否還有外層列表  \n                            Yes →  \n                                → Step: Append popped to new top of stack // 把子列表加到外層  \n                            No →  \n                                → Step: Set result to popped // 最外層列表完成，保存結果  \n                        → Step: i += 1 // 移到下一個字符  \n                    No →  \n                        → Decision: s[i] == ','? // 判斷是否為分隔符  \n                            Yes →  \n                                → Step: i += 1 // 跳過逗號  \n                            No →  \n                                → Decision: s[i] == '-' or isdigit(s[i])? // 判斷是否開始一個整數  \n                                    Yes →  \n                                        → Step: Parse number starting at i until non-digit // 取得完整數字字串  \n                                        → Step: Convert parsed string to integer value  \n                                        → Step: Create NestedInteger with this integer // 建立整數節點  \n                                        → Decision: stack is not empty? // 整數是否屬於某個列表  \n                                            Yes →  \n                                                → Step: Append integer NestedInteger to top of stack // 加到當前列表  \n                                            No →  \n                                                → Step: Set result to integer NestedInteger // 整個序列為單一整數  \n                                        → Step: Move i past the parsed number // 更新索引  \n                                    No →  \n                                        → Step: i += 1 // 任何其他字符，直接跳過  \n        → End Decision  \n    No → End // 字符處理完畢  \nEnd // 程式執行結束，返回 result\n\n(Note: 在實際實現中，需要適當處理數字解析與索引更新，以上虛擬碼為邏輯流程概覽。)",
      "generated_code": "import sys\nimport re\n\nclass NestedInteger:\n    \"\"\"\n    Simple implementation of the NestedInteger interface.\n    \"\"\"\n    def __init__(self, value=None):\n        if value is None:\n            self._list = []\n            self._int = None\n        else:\n            self._int = value\n            self._list = None\n\n    def isInteger(self):\n        return self._int is not None\n\n    def add(self, elem):\n        if self._list is None:\n            self._list = []\n        self._list.append(elem)\n\n    def setInteger(self, value):\n        self._int = value\n        self._list = None\n\n    def getInteger(self):\n        return self._int\n\n    def getList(self):\n        return self._list if self._list is not None else []\n\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        # Handle single integer case\n        if not s or s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack = []\n        num = ''\n        negative = False\n\n        for c in s:\n            if c == '-':\n                negative = True\n            elif c.isdigit():\n                num += c\n            elif c == '[':\n                stack.append(NestedInteger())\n            elif c in ',]':\n                if num:\n                    value = int(num) if not negative else -int(num)\n                    stack[-1].add(NestedInteger(value))\n                    num = ''\n                    negative = False\n                if c == ']' and len(stack) > 1:\n                    ni = stack.pop()\n                    stack[-1].add(ni)\n\n        return stack[0]\n\n\ndef nested_to_str(ni: NestedInteger) -> str:\n    if ni.isInteger():\n        return str(ni.getInteger())\n    return '[' + ','.join(nested_to_str(x) for x in ni.getList()) + ']'\n\n\ndef parse_input_line(line: str) -> str:\n    \"\"\"\n    Extract the string value from input like: s = \"324\" or \"324\".\n    \"\"\"\n    # Find the first quoted substring\n    m = re.search(r'[\"\\'](.*)[\"\\']', line)\n    if m:\n        return m.group(1)\n    # If no quotes, assume the whole line is the string\n    return line.strip()\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input_line(raw_input)\n    sol = Solution()\n    result = sol.deserialize(s)\n    print(nested_to_str(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"324\"",
          "expected_output": "324",
          "success": true,
          "output": "324"
        },
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "success": true,
          "output": "[123,[456,[789]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode477.json",
    "problem_index_in_file": 0,
    "title": "Total Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code line by line with explanation. The algorithm: sum of Hamming distances over all pairs. Known trick: for each bit position, count ones and zeros, contribution = ones*zeros*2? Actually each pair counted once, but contribution per bit is ones*zeros*2? Wait Hamming distance for pair includes 1 if bits differ. For each bit position, number of pairs with differing bits is ones * zeros. Since each pair counted once, total distance sum over all pairs is sum over bits of ones*zeros. But pairs unordered; we sum over all pairs (i<j). That's it. But if you want sum over all unordered pairs, contribution = ones*zeros. If consider ordered pairs maybe *2. The problem likely expects unordered pairs. In LeetCode problem \"Sum of All Pairwise Hamming Distances\". Usually answer: for each bit, ones*zeros*2 because they consider all pairs (i,j) where i != j; but the problem says pairs of integers in nums. Usually pair means unordered. However examples? Let's recall: Example: nums = [4,14,2] binary 100,1110,010. Bits positions up to 3 bits? Let's compute. For bit0: values: 4->0, 14->0, 2->0 => ones=0 zeros=3 => contribution 0. bit1: 4->0, 14->1, 2->1 => ones=2 zeros=1 => contribution 2. bit2: 4->1, 14->1, 2->0 => ones=2 zeros=1 => 2. bit3: 4->0,14->1,2->0 => ones=1 zeros=2 => 2. sum=6. Example result maybe 6. That matches unordered. So we use ones*zeros.\n\nThus algorithm: initialize sum=0. For bit 0..31, count ones among nums. zeros = n-ones. sum += ones * zeros.\n\nReturn sum.\n\nNow produce virtual code lines.\n\nNeed to use Start, End, Decision.\n\nLet's craft steps: Start. Step1: read nums. Step2: set n = length. Step3: sum=0. Step4: for bit in 0..31: count ones. Step5: zeros = n-ones. Step6: sum += ones*zeros. Step7: return sum. End.\n\nAdd decision? maybe not necessary but can add Decision to iterate bits. But requirement to use Decision structure. So maybe Decision: if bit < 32? Use loop with Decision.\n\nLet's produce a step-by-step with arrow lines.\n\nWill produce:\n\nStart // 程式開始執行\n→ Step 1: nums ← input array // 取得輸入數字陣列\n→ Step 2: n ← length(nums) // 數組長度\n→ Step 3: total ← 0 // 初始總 Hamming 距離\n→ Decision: bit從0到31? // 判斷是否還有位元要處理\n    Yes → Step 4: ones ← 0 // 本位元 1 的個數\n        → Step 5: for each num in nums // 逐個數字\n            → Decision: bit 在 num 中為1? // 檢查該位元是否為1\n                Yes → ones ← ones + 1 // 1 的個數加一\n                No  → No action // 若為0不變\n        → Step 6: zeros ← n - ones // 本位元 0 的個數\n        → Step 7: total ← total + ones * zeros // 更新總距離\n        → Decision: 下一位元? // 從 bit+1 進行下一次迴圈\n            Yes → bit ← bit + 1 // 進行下一位元\n            No  → Exit loop // 迴圈結束\n    No → No action // 位元已處理完\n→ Step 8: return total // 回傳總 Hamming 距離\nEnd // 程式執行結束\n\nBut we need to keep structure with arrow lines. The arrow arrow should be `→`. For decisions use `Decision:` and indentation.\n\nLet's craft properly.\n\nNeed to ensure each line includes explanation after `//`.\n\nWe need to ensure each line is one statement.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: nums ← input array // 取得輸入數字陣列\n→ Step 2: n ← length(nums) // 取得陣列長度\n→ Step 3: total ← 0 // 初始總 Hamming 距離\n→ Decision: bit 為 0? // 判斷是否開始第一個位元\n    Yes → Step 4: ones ← 0 // 本位元 1 的個數初始化為 0\n        → Step 5: for each num in nums // 逐一遍歷每個數字\n            → Decision: bit 在 num 為 1? // 檢查該位元是否為 1\n                Yes → ones ← ones + 1 // 1 的個數加一\n                No  → No action // 若為 0 則不變\n        → Step 6: zeros ← n - ones // 本位元 0 的個數\n        → Step 7: total ← total + ones * zeros // 加入本位元對總距離的貢獻\n        → Decision: bit 為 31? // 檢查是否已處理完所有位元\n            Yes → Exit loop // 所有位元已處理完，跳出迴圈\n            No  → bit ← bit + 1 // 移至下一位元，回到 Step 4\n    No → No action // 沒有數字時不進行任何操作\n→ Step 8: return total // 回傳所有數字對之間 Hamming 距離的總和\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def totalHammingDistance(self, nums):\n        total = 0\n        n = len(nums)\n        for i in range(32):  # 32 位整數\n            count_ones = sum((num >> i) & 1 for num in nums)\n            count_zeros = n - count_ones\n            total += count_ones * count_zeros\n        return total\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入中抽取數字列表\n    match = re.search(r'\\[(.*?)\\]', data)\n    if match:\n        nums = ast.literal_eval(match.group(0))\n    else:\n        # 若輸入本身就是列表字串\n        nums = ast.literal_eval(data)\n\n    solution = Solution()\n    result = solution.totalHammingDistance(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,14,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [4,14,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode115.json",
    "problem_index_in_file": 0,
    "title": "Distinct Subsequences",
    "description_snippet": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\n\nThe test...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: count distinct subsequences of s that equal t. Standard DP: dp[i][j] = number of ways s[0..i-1] to form t[0..j-1]. Or 1D dp: iterate over s, for each char update dp[j] backwards.\n\nWe should produce step-by-step virtual code.\n\nWe need to output line by line with \"虛擬碼步驟 // 解釋\".\n\nUse Start, Decision etc.\n\nMake clear steps:\n\nStart // program start\n\nStep: initialize variables: n= len(s), m = len(t)\n\nDecision: if m == 0? // empty t\n\n    Yes -> Step: return 1 // empty string is subsequence of any string\n\n    No -> Continue\n\nDecision: if n < m? // s shorter than t\n\n    Yes -> Step: return 0 // impossible\n\n    No -> Continue\n\nInitialize dp array of size m+1 with zeros // dp[j] ways for first j chars of t\n\nSet dp[0] = 1 // empty t\n\nLoop over i from 1 to n: // each char of s\n\n    char = s[i-1]\n\n    Loop over j from m down to 1: // backwards to avoid overwrite\n\n        Decision: if char == t[j-1]?\n\n            Yes -> Step: dp[j] = dp[j] + dp[j-1] // add ways where char used\n\n            No -> Step: dp[j] remains same\n\nAfter loops, Step: return dp[m]\n\nEnd\n\nBut we need to express with \"虛擬碼步驟\" etc. Use arrow arrow? Use \"→\".\n\nLet's create each step line.\n\nWe need to format exactly: \"虛擬碼步驟 // 解釋\". We'll use Chinese explanation.\n\nAlso use \"Decision:\" lines.\n\nWe also might include variable names. Use simple naming: i, j, n, m, dp, s, t.\n\nBe careful about virtual code style: e.g., \"Start // 程式開始執行\"\n\n\"→ Step 1: 計算 n = len(s), m = len(t) // 取得字串長度\"\n\n\"→ Decision: 如果 m = 0? // t 為空串\"\n\n\"    Yes → Step 2: 返回 1 // 空字串是任何字串的子序列\"\n\n\"    No  →\" etc.\n\nWe'll maintain indentation.\n\nAlso maybe include comments after arrow.\n\nWe need to provide lines sequentially. Let's craft.\n\nAlso need to avoid using actual code, just pseudocode with arrows. Provide variable assignments.\n\nOk.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 n = len(s), m = len(t) // 取得兩個字串的長度  \n→ Decision: 如果 m = 0? // t 為空串，空字串是任何字串的子序列  \n  Yes → Step 2: 返回 1 // 只要有任何 s，都能得到 1 個空子序列  \n  No →  \n→ Decision: 如果 n < m? // s 長度不足以匹配 t  \n  Yes → Step 3: 返回 0 // 無法得到任何子序列  \n  No →  \n→ Step 4: 初始化 dp[0…m] 為 0 // dp[j] 代表前 i 個 s 生成 t[0…j-1] 的方法數  \n  dp[0] = 1 // 空 t 的子序列數為 1（不選任何字元）  \n→ Step 5: 循環 i = 1 到 n // 逐一處理 s 的每個字元  \n  → Step 5a: 取 cur = s[i-1] // 取得當前字元  \n  → 循環 j = m 到 1 // 從後往前更新，避免覆蓋 dp[j-1]  \n    → Decision: 如果 cur = t[j-1]? // 字元匹配  \n      Yes → Step 5b: dp[j] = dp[j] + dp[j-1] // 加上使用該字元的方式  \n      No  → Step 5c: dp[j] 保持不變 // 字元不匹配，僅保留之前的計數  \n→ Step 6: 返回 dp[m] // 最後 dp[m] 即為完整 t 的子序列數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_distinct(s: str, t: str) -> int:\n    \"\"\"Return the number of distinct subsequences of s which equal t.\"\"\"\n    m, n = len(s), len(t)\n    if n == 0:\n        return 1          # empty t is a subsequence of any s\n    if m < n:\n        return 0          # impossible if s is shorter than t\n\n    # 1‑D DP: dp[j] = number of ways to form t[:j] from processed part of s\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for ch in s:\n        # Update backwards to avoid overwriting dp[j‑1] that is still needed\n        for j in range(n, 0, -1):\n            if ch == t[j - 1]:\n                dp[j] += dp[j - 1]\n    return dp[n]\n\ndef parse_input() -> tuple[str, str]:\n    \"\"\"\n    Parse the standard input to obtain the two strings s and t.\n    Handles inputs like:\n        s = \"rabbbit\", t = \"rabbit\"\n    or simple two‑line inputs:\n        rabbbit\n        rabbit\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return \"\", \"\"\n\n    # Find all quoted substrings\n    quoted = re.findall(r'\"(.*?)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n\n    # Fallback: split by whitespace or newlines\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # If only one part, treat it as s and t as empty\n    return parts[0], \"\"\n\nif __name__ == \"__main__\":\n    s, t = parse_input()\n    result = num_distinct(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode211.json",
    "problem_index_in_file": 0,
    "title": "Design Add and Search Words Data Structure",
    "description_snippet": "Design a data structure that supports adding new words and finding if a string matches any previousl...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for implementing WordDictionary class with addWord and search supporting '.' wildcard. Typical solution: Trie with recursion for search. Provide pseudocode line by line. Must use arrows etc. Provide virtual code steps.\n\nWe must produce \"逐行\" output. Each line: \"虛擬碼步驟 // 解釋\". Use arrow, Decision etc. Format similar to example.\n\nWe need to design data structure. So steps: Define Node struct: children[26], isEnd. WordDictionary has root Node. Methods: addWord, search. For search with dot, recursion function searchInNode(node, word, index). Provide high-level pseudo steps.\n\nWe should also include class initialization.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode // 建立 Trie 節點資料結構\n→ Decision: 需要字母映射? // 判斷是否要為每個字母設置指針\n    Yes → Step 2: 在 TrieNode 中加入 children[26] // 儲存子節點指針\n    No  → Step 3: 在 TrieNode 中加入 children dict // 交替使用映射\n→ Step 4: 在 TrieNode 中加入 isEnd // 標記單詞結尾\n→ Step 5: WordDictionary() → 初始化 root = new TrieNode // 建構函式\n→ Step 6: addWord(word) → node = root // 開始從根節點\n    → For 每個字符 c in word:\n        → Decision: 子節點 c 是否存在? // 檢查是否已經有該字母的子節點\n            Yes → node = node.children[c] // 移動到現有子節點\n            No  → node.children[c] = new TrieNode // 新增子節點\n    → Step 7: node.isEnd = true // 標記單詞結束\n→ Step 8: search(word) → 返回 searchRecursive(root, word, 0) // 啟動遞歸搜尋\n→ Step 9: searchRecursive(node, word, index):\n    → Decision: index == len(word)? // 是否已經遍歷完字串\n        Yes → 返回 node.isEnd // 若結尾則表示匹配成功\n        No  → char = word[index]\n        → Decision: char == '.'? // 遇到通配符\n            Yes → \n                → For 每個 child in node.children:\n                    → Decision: child != null?\n                        Yes → 若 searchRecursive(child, word, index+1) 成功，則返回 true\n                → 返回 false // 若所有子節點都失敗\n            No  →\n                → Decision: node.children[char] exists?\n                    Yes → 返回 searchRecursive(node.children[char], word, index+1)\n                    No  → 返回 false // 字母不存在，匹配失敗\nEnd // 程式執行結束\n\nWe need to ensure each line has one virtual step. The example shows arrow lines with indent. We'll replicate similar style.\n\nAlso use \"→\" arrow. Let's format.\n\nMake sure each line starts with \"→\" except Start and End. The decision lines should be indented? The example uses indent and then \"Yes →\" \"No →\" on same line. We'll mimic that.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode // 建立 Trie 節點資料結構  \n→ Decision: 需要字母映射? // 判斷是否要為每個字母設置指針  \n  Yes → Step 2: 在 TrieNode 中加入 children[26] // 儲存子節點指針  \n  No  → Step 3: 在 TrieNode 中加入 children dict // 交替使用映射  \n→ Step 4: 在 TrieNode 中加入 isEnd // 標記單詞結尾  \n→ Step 5: WordDictionary() → 初始化 root = new TrieNode // 建構函式  \n→ Step 6: addWord(word) → node = root // 開始從根節點  \n  → For 每個字符 c in word:  \n    Decision: 子節點 c 是否存在? // 檢查是否已經有該字母的子節點  \n     Yes → node = node.children[c] // 移動到現有子節點  \n     No  → node.children[c] = new TrieNode // 新增子節點  \n  → Step 7: node.isEnd = true // 標記單詞結束  \n→ Step 8: search(word) → 返回 searchRecursive(root, word, 0) // 啟動遞歸搜尋  \n→ Step 9: searchRecursive(node, word, index):  \n  Decision: index == len(word)? // 是否已經遍歷完字串  \n    Yes → 返回 node.isEnd // 若結尾則表示匹配成功  \n    No  → char = word[index]  \n    Decision: char == '.'? // 遇到通配符  \n     Yes →  \n      → For 每個 child in node.children:  \n        Decision: child != null?  \n         Yes → 若 searchRecursive(child, word, index+1) 成功，則返回 true  \n         No  → 繼續迴圈  \n        返回 false // 若所有子節點都失敗  \n     No  →  \n      Decision: node.children[char] exists?  \n       Yes → 返回 searchRecursive(node.children[char], word, index+1)  \n       No  → 返回 false // 字母不存在，匹配失敗  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            ch = word[i]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], i + 1)\n        return dfs(self.root, 0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap input in brackets to parse as a list of two elements\n    data = '[' + data + ']'\n    try:\n        ops, args = ast.literal_eval(data)\n    except Exception as e:\n        raise ValueError(\"Invalid input format\") from e\n\n    results = []\n    wd = None\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            wd = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            wd.addWord(arg[0] if isinstance(arg, list) else arg)\n            results.append(None)\n        elif op == \"search\":\n            res = wd.search(arg[0] if isinstance(arg, list) else arg)\n            results.append(res)\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n    # Output results in JSON format (None -> null, bool -> true/false)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "success": true,
          "output": "[null, null, null, null, false, true, true, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode556.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element III",
    "description_snippet": "Given a positive integer n, find the smallest integer which has exactly the same digits existing in ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve next greater element with same digits. Steps: convert to list of digits, find pivot where digit < next, if none -> -1. Find rightmost successor > pivot, swap, sort suffix ascending. Convert back to int, check overflow 32-bit. Return int or -1.\n\nWe must output line by line with arrow etc. Use Start, End. Use Decision nodes. Provide explanation after //.\n\nLet's write:\n\nStart\n→ Step 1: Convert n to list of digits // ...\n→ Decision: If digits sorted descending? // no greater\n   Yes → Step 2: Return -1\n   No  → Step 3: Find pivot index from right where digits[i] < digits[i+1]\n→ Step 4: Find successor index j > pivot where digits[j] > digits[pivot] and minimal\n→ Step 5: Swap digits[pivot], digits[j]\n→ Step 6: Sort digits from pivot+1 to end ascending // minimal suffix\n→ Step 7: Convert digit list back to integer value\n→ Decision: If value > 2^31-1? // overflow\n    Yes → Step 8: Return -1\n    No  → Step 9: Return value\nEnd\n\nWe need to include arrow and \"→\" each step.\n\nLet's produce.\n\nAlso include \"Decision:\" lines with Yes → and No → lines.\n\nWe must use virtual code arrow and explanation after //. Also include Start, End.\n\nMake sure each line has virtual code + space + // explanation.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Convert n to list of digits // 先將整數 n 轉成數字陣列方便操作  \n→ Decision: 數字陣列是否完全降序排列？ // 若是則沒有更大的排列  \n  Yes → Step 2: Return -1 // 直接返回 -1，因為無更大數字  \n  No  → Step 3: 從右往左尋找 pivot，第一個數字小於其右邊相鄰數字的位置 // 找到可提升的最右側位置  \n→ Step 4: 在 pivot 右邊找 successor，最小的大於 pivot 的數字 // 使交換後的數字最小但大於原數  \n→ Step 5: Swap digits[pivot] 與 digits[successor] // 交換 pivot 與 successor  \n→ Step 6: 將 pivot 右側的子陣列升序排列 // 使剩餘部分為最小可能順序  \n→ Step 7: 將數字陣列重新組成整數 result // 轉回整數形式  \n→ Decision: result 是否超出 32 位整數上限（> 2^31-1）？ // 檢查 32 位整數溢出  \n  Yes → Step 8: Return -1 // 超出範圍，返回 -1  \n  No  → Step 9: Return result // 正常返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef next_greater_element(n: int) -> int:\n    \"\"\"\n    找出與 n 擁有相同位數且比 n 大的最小正整數。\n    若不存在或結果超過 32‑bit 限制，回傳 -1。\n    \"\"\"\n    digits = list(str(n))\n    # 從右往左尋找第一個可提升的位元\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    if i == -1:                     # 數字已是降序，無更大排列\n        return -1\n    # 在右側尋找最小的大於 digits[i] 的數字\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    # 交換\n    digits[i], digits[j] = digits[j], digits[i]\n    # 將右側子序列重新排列為升序\n    digits[i + 1:] = reversed(digits[i + 1:])\n    result = int(''.join(digits))\n    return result if result < 2 ** 31 else -1\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，輸出結果至標準輸出。\n    任何合法的正整數輸入皆可處理。\n    \"\"\"\n    data = sys.stdin.read()\n    # 取出第一個出現的正整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        # 若無數字輸入，直接輸出 -1\n        print(-1)\n        return\n    n = int(match.group())\n    result = next_greater_element(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "21",
          "success": true,
          "output": "21"
        },
        {
          "example_index": 1,
          "input": "n = 21",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode507.json",
    "problem_index_in_file": 0,
    "title": "Perfect Number",
    "description_snippet": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with explanation lines, step-by-step, no actual code. The task: given integer n, return true if perfect number. So steps: check if n <=0? maybe negative not perfect. Then compute sum of divisors excluding n. For each i from 1 to sqrt(n). If i divides n, add i and n/i if distinct and not equal to n. Finally compare sum to n. Return true if equal else false.\n\nWe need virtual code lines. Use Start, End. Use Decision, Step.\n\nWe should include steps: Input n, if n <= 1? 1 is not perfect, but handle n>1. Then sum=0. For i=1 to sqrt(n) maybe but we can say for i from 1 to n/2. But typical optimization. I'll use 1 to sqrt(n). For each divisor, add both.\n\nWe also need to handle adding divisor only once if square.\n\nThen after loop, compare sum with n, return true else false.\n\nAlso need to handle case n=1 return false.\n\nLet's produce virtual code.\n\nLet's consider:\n\nStart // Program start\n\n→ Step 1: 接收整數 n // 取得輸入\n\n→ Decision: n <= 1? // 確認 n 是否為 1 或負數\n\n    Yes → Step 2: 回傳 false // 1 或負數不是完全數\n\n    No  → Step 3: 初始化 sum = 0 // 準備計算因數總和\n\n→ Step 4: 設定 i = 1 // 初始化迴圈索引\n\n→ Decision: i <= sqrt(n)? // 迴圈條件\n\n    Yes → Step 5: 如果 n mod i == 0? // 檢查 i 是否為 n 的因數\n\n        Yes → Step 6: sum += i // 加入 i\n\n        Yes → Decision: i != 1 AND i != n/i? // 確保不加 n 本身且避免平方重複\n\n            Yes → Step 7: sum += n / i // 加入對應因數\n\n        End\n\n    No → Step 8: 跳至 Step 9 // 迴圈結束\n\n    No → Step 8: i++ // 迴圈遞增\n\n    // Actually need loop structure properly: We'll use while loop.\n\nLet's restructure: Use Step 4: 初始化 i=1; Step 5: Decision: i <= sqrt(n)? Yes: Step 6: if n % i ==0? Yes: Step 7: sum += i; Yes: Decision: i != n / i? Yes: sum += n / i; End; Step 8: i++ ; End; No: proceed.\n\nBut we need to use virtual code format.\n\nLet's produce simpler: Use for i =1 to n/2.\n\nOk.\n\n→ Step 4: For i = 1 to n/2\n\n    → Decision: n mod i == 0? // 判斷 i 是否為因數\n\n        Yes → Step 5: sum += i // 加入因數\n\n        No  → // nothing\n\n→ Step 6: Decision: sum == n? // 判斷是否完全數\n\n    Yes → Step 7: 回傳 true\n\n    No  → Step 8: 回傳 false\n\nEnd\n\nBut we also need to handle n <=1 earlier. Let's incorporate.\n\nLet's produce:\n\nStart\n\n→ Step 1: 接收 n\n\n→ Decision: n <= 1? // 若 n 為 1 或負數\n\n    Yes → Step 2: 回傳 false\n\n    No  → Step 3: 初始化 sum = 0\n\n→ Step 4: For i = 1 to floor(sqrt(n))\n\n    → Decision: n mod i == 0? // i 是因數\n\n        Yes → Step 5: sum += i\n\n        Yes → Decision: i != n / i AND i != n? // 避免重複與加 n 本身\n\n            Yes → Step 6: sum += n / i\n\n→ Step 7: Decision: sum == n? // 完全數判斷\n\n    Yes → Step 8: 回傳 true\n\n    No  → Step 9: 回傳 false\n\nEnd\n\nMake sure the format uses arrows and indentation.\n\nAlso we need to mark Step 4: For i = 1 to sqrt(n) as \"Step 4: For i = 1 to floor(sqrt(n))\" but we can use \"Step 4: 對 i = 1 到 floor(sqrt(n)) 進行迴圈\" but maintain structure.\n\nBetter to use: \"Step 4: 迴圈 i 從 1 開始到 floor(sqrt(n))\".\n\nWe also need to include arrow after \"Decision:\" lines.\n\nThe formatting: \"→ Decision: ...\" with indent lines.\n\nExample format: \"→ Decision: If n <= 1? // ...\".\n\nYes.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收整數 n // 取得使用者輸入的數值  \n→ Decision: n <= 1? // 檢查 n 是否為 1 或負數，完全數必須大於 1  \n  Yes → Step 2: 回傳 false // 1 或負數不是完全數  \n  No  → Step 3: 初始化 sum = 0 // 開始累加因數總和  \n→ Step 4: 迴圈 i 從 1 開始到 floor(sqrt(n)) // 只需檢查到平方根即可  \n  → Decision: n mod i == 0? // 判斷 i 是否為 n 的因數  \n    Yes → Step 5: sum += i // 加入 i 作為因數  \n    Yes → Decision: i != n / i AND i != n? // 避免把 n 本身及平方根重複加入  \n      Yes → Step 6: sum += n / i // 加入對應的另一個因數  \n→ Step 7: Decision: sum == n? // 判斷累加的因數總和是否等於 n  \n  Yes → Step 8: 回傳 true // n 是完全數  \n  No  → Step 9: 回傳 false // n 不是完全數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        \"\"\"Return True if num is a perfect number, otherwise False.\"\"\"\n        if num < 2:\n            return False\n        s = 1  # 1 is always a proper divisor for num >= 2\n        i = 2\n        while i * i <= num:\n            if num % i == 0:\n                s += i\n                if i != num // i:   # avoid adding sqrt twice when num is a perfect square\n                    s += num // i\n            i += 1\n        return s == num\n\ndef main() -> None:\n    \"\"\"Read an integer from stdin, check if it is perfect, and print 'true' or 'false'.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    n = int(data)\n    solution = Solution()\n    result = solution.checkPerfectNumber(n)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "28",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode476.json",
    "problem_index_in_file": 0,
    "title": "Number Complement",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode lines with explanations. The problem: find complement of integer by flipping bits of binary representation. But note: typically problem includes ignoring leading zeros: complement of 5 (101) -> 010 => 2. So algorithm: find binary representation, flip each bit. Implementation: compute bit length (without leading zeros). Then for each bit, invert. Or compute complement by using mask with ones equal to bit length: mask = (1 << bitLength) - 1; return mask ^ num. We can produce pseudocode with decision: get number of bits. We'll produce step-by-step.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize variable num // input integer\n→ Decision: If num == 0? // special case\n   Yes → Step 2: Return 1 // complement of 0 is 1\n   No → Step 3: Compute bitLength = floor(log2(num)) + 1 // number of bits\n→ Step 4: Compute mask = (1 << bitLength) - 1 // all 1s of that length\n→ Step 5: Return num XOR mask // flip bits\n\nAdd explanations.\n\nWe need each line with \"虛擬碼步驟\" and comment. We'll include \"Start\", \"End\". Ensure we use arrows and indent decisions.\n\nAlso we should ensure to use \"→\" at start of each line.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入變數 num // 取得要進行補碼的整數  \n→ Decision: 如果 num 為 0? // 0 的二進位為 0，補碼為 1  \n Yes → Step 2: 返回 1 // 補碼完成，直接回傳  \n No  → Step 3: 計算 bitLength = floor(log₂(num)) + 1 // 找出 num 的位數  \n→ Step 4: 計算 mask = (1 << bitLength) - 1 // 產生全部位為 1 的遮罩  \n→ Step 5: 返回 num XOR mask // 以遮罩取反得到補碼  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        \"\"\"\n        Return the binary complement of a non‑negative integer.\n        The complement is computed by flipping all bits in the\n        binary representation of `num` up to its most significant 1.\n        For num == 0 the complement is defined as 1.\n        \"\"\"\n        # Special case: 0 has no 1 bits, its complement is 1.\n        if num == 0:\n            return 1\n\n        # Number of bits needed to represent `num` (no leading zeros).\n        bit_length = num.bit_length()\n\n        # Create a mask with `bit_length` ones: 111...1\n        mask = (1 << bit_length) - 1\n\n        # Flip bits of `num` by XOR with the mask.\n        return num ^ mask\n\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, extract an integer, compute its complement\n    using the Solution class, and print the result.\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # Find the first integer in the input (handles formats like 'num = 5').\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n\n    num = int(match.group())\n    sol = Solution()\n    result = sol.findComplement(num)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode703.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in a Stream",
    "description_snippet": "You are part of a university admissions office and need to keep track of the kth highest test score ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for KthLargest class. Use virtual steps. Should not output real code. Just steps. Must be line-by-line with \"虛擬碼步驟 // 解釋\".\n\nImplement class with constructor that builds min-heap of size k, add method pushes val then ensures size k by popping smallest if larger. Return root of heap.\n\nWe produce steps:\n\nStart\n→ Step: Define class KthLargest\n→ Step: Constructor receives k and nums\n→ Step: Initialize min-heap empty\n→ Decision: If nums length >0? etc.\n\nBetter to produce high-level algorithm steps.\n\nNeed to be in Traditional Chinese. Use 虛擬碼步驟. Eg \"Step 1: 初始化最小堆 // 建立一個大小不超過 k 的最小堆\".\n\nWe must use arrows: Start, →, Decision.\n\nLet's craft.\n\nLines:\n\nStart // 程式開始執行\n\n→ Step 1: 宣告類別 KthLargest // 定義主類別\n\n→ Step 2: 定義建構子 KthLargest(k, nums) // 初始化\n\n→ Step 3: 儲存 k 於實例變數 // 方便後續使用\n\n→ Step 4: 建立空的最小堆 // 用來保持前 k 大的元素\n\n→ Decision: 若 nums 非空? // 若有初始分數\n\n  Yes → Step 5: 將 nums 中每個分數加入堆 // 逐一插入\n\n  → Step 6: 若堆大小 > k，則移除最小元素 // 保持堆大小\n\n  No → // 無初始分數，跳過\n\n→ Step 7: 定義 add(val) 方法 // 新增分數\n\n→ Step 8: 將 val 插入堆 // 將新分數放入堆\n\n→ Decision: 若堆大小 > k? // 檢查堆是否超過 k\n\n  Yes → Step 9: 移除堆頂最小元素 // 只保留 k 大的\n\n  No → // 堆大小未超過 k，保留\n\n→ Step 10: 回傳堆頂元素 // 堆頂即為第 k 大\n\nEnd // 程式結束\n\nAlso could add Decision for if k=1 etc but not needed.\n\nMake sure each line uses arrow or Start/End. Provide explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告類別 KthLargest // 定義主要類別  \n→ Step 2: 定義建構子 KthLargest(k, nums) // 接收 k 與初始分數陣列  \n→ Step 3: 儲存 k 至實例變數 // 方便後續使用  \n→ Step 4: 建立空的最小堆 // 用於保持前 k 大的元素  \n→ Decision: nums 是否非空？ // 檢查是否有初始分數  \n&nbsp;&nbsp;Yes → Step 5: 對 nums 逐個元素執行 insert(heap, val) // 插入堆  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: 若堆大小 > k，執行 removeMin(heap) // 保持堆大小不超過 k  \n&nbsp;&nbsp;No  → // 無初始分數，直接跳過  \n→ Step 7: 定義方法 add(val) // 新增一個分數  \n→ Step 8: 插入 val 至堆 // 把新分數放入堆  \n→ Decision: 堆大小 > k？ // 檢查堆是否超過 k  \n&nbsp;&nbsp;Yes → Step 9: 移除堆頂最小元素 // 只保留 k 大的元素  \n&nbsp;&nbsp;No  → // 堆大小未超過 k，保持不變  \n→ Step 10: 回傳堆頂元素 // 堆頂即為目前第 k 大分數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Split the two top‑level lists (methods and arguments)\n    # Handles both single line and two line input formats.\n    if '],[' in data:\n        # Remove any outer quotes or spaces\n        data = data.strip(\"'\\\" \")\n        parts = data.split('],[')\n        methods_str = parts[0] + ']'\n        args_str = '[' + parts[1]\n    else:\n        # Try to find the comma separating the two lists\n        idx = data.find('],')\n        if idx != -1:\n            methods_str = data[:idx+1]\n            args_str = data[idx+2:]\n        else:\n            # Assume two separate lines\n            lines = data.splitlines()\n            methods_str = lines[0].strip()\n            args_str = lines[1].strip() if len(lines) > 1 else '[]'\n\n    methods = ast.literal_eval(methods_str)\n    args = ast.literal_eval(args_str)\n\n    results = []\n    obj = None\n    for method, arg in zip(methods, args):\n        if method == \"KthLargest\":\n            obj = KthLargest(arg[0], arg[1])\n            results.append(None)\n        elif method == \"add\":\n            res = obj.add(arg[0])\n            results.append(res)\n        else:\n            # Unknown method name; skip\n            pass\n\n    # Output results in LeetCode JSON style\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "success": true,
          "output": "[null, 4, 5, 5, 8, 8]"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "success": true,
          "output": "[null, 7, 7, 7, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode315.json",
    "problem_index_in_file": 0,
    "title": "Count of Smaller Numbers After Self",
    "description_snippet": "Given an integer array nums, return an integer array counts where counts[i] is the number of smaller...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for counting smaller elements to the right, i.e., for each element, count how many elements to its right are smaller. This is classic problem \"Count of Smaller Numbers After Self\". We can use a Binary Indexed Tree (Fenwick) or BST or merge sort approach. Provide virtual code step-by-step.\n\nWe'll create steps: Start, compress values, iterate from right to left, update BIT, query counts, store result, End.\n\nUse virtual code with arrows and decision.\n\nLet's produce steps:\n\nStart // begin\n→ Step 1: Copy nums to arr // get array\n→ Step 2: Find sorted unique values of arr // for compression\n→ Step 3: Build mapping value->rank // rank starting 1\n→ Step 4: Initialize BIT of size len(unique) // tree\n→ Step 5: Initialize counts array same size as arr // result\n→ Step 6: For i from len(arr)-1 downto 0: // iterate right to left\n    → Step 7: rank = mapping[arr[i]] // get rank\n    → Step 8: counts[i] = Query BIT for prefix(rank-1) // count smaller\n    → Step 9: Update BIT at rank by +1 // add current element\n→ Step 10: Return counts // output\nEnd // finish\n\nInclude decision? Not needed. But can show simple for loop.\n\nAdd explanatory comments after each step.\n\nAlso we may need to show BIT operations: query and update.\n\nAdd Step 11: Function Query(index): sum up to index // returns cumulative count\n→ Step 12: Function Update(index, delta): add delta to tree nodes\nBut maybe we can keep within step.\n\nLet's output in required format.\n\nLet's produce each line with virtual code step and comment.\n\nWe'll use '→' arrows, and indent decisions? We can just produce simple.\n\nMake sure each line ends with // comment.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Copy nums to arr // 取得輸入陣列的複本  \n→ Step 2: Find sorted unique values of arr // 用於離散化壓縮  \n→ Step 3: Build mapping value → rank // 建立值到序號（從 1 開始）的對應表  \n→ Step 4: Initialize BIT of size len(unique) // 建立樹狀結構來維護頻率  \n→ Step 5: Initialize counts array same size as arr // 準備存放結果  \n→ Step 6: For i from len(arr)-1 downto 0: // 從右往左遍歷每個元素  \n    → Step 7: rank = mapping[arr[i]] // 取得目前元素的壓縮序號  \n    → Step 8: counts[i] = Query BIT for prefix(rank-1) // 取得比它小的元素數量  \n    → Step 9: Update BIT at rank by +1 // 把目前元素加入樹中  \n→ Step 10: Return counts // 回傳完成的計數陣列  \nEnd // 程式執行結束  \n\n// --------------------- BIT 相關虛擬程式 ---------------------  \n→ Function Query(index): // 計算前綴和  \n    → result = 0  \n    → While index > 0:  \n        → result += tree[index]  \n        → index -= index & -index  \n    → Return result  \n→ Function Update(index, delta): // 更新頻率  \n    → While index <= size:  \n        → tree[index] += delta  \n        → index += index & -index",
      "generated_code": "class BIT:\n    def __init__(self, size):\n        # 初始化長度為 size 的 Binary Indexed Tree\n        self.tree = [0] * (size + 1)\n        self.size = size\n\n    def update(self, index, delta):\n        # 在 index 位置加上 delta\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index):\n        # 取得前綴和（1 ~ index）\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\n\nclass Solution:\n    def countSmaller(self, nums):\n        # 先壓縮座標：對不同值排序，給每個值一個序號\n        sorted_unique = sorted(set(nums))\n        ranks = {num: i + 1 for i, num in enumerate(sorted_unique)}\n\n        bit = BIT(len(ranks))\n        res = []\n\n        # 從右往左遍歷\n        for num in reversed(nums):\n            rank = ranks[num]\n            # 取得比該元素小的已處理元素數量\n            res.append(bit.query(rank - 1))\n            # 把該元素加入 BIT\n            bit.update(rank, 1)\n\n        return res[::-1]  # 逆序回傳\n\n\nimport sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，允許 \"nums = [...]\" 或僅為 \"[...]\"\n    if '=' in data:\n        nums_part = data.split('=', 1)[1].strip()\n    else:\n        nums_part = data.strip()\n\n    # 保證是合法的 Python 列表字串\n    if not nums_part.startswith('['):\n        nums_part = '[' + nums_part\n    if not nums_part.endswith(']'):\n        nums_part += ']'\n\n    try:\n        nums = eval(nums_part)\n    except:\n        nums = []\n\n    sol = Solution()\n    res = sol.countSmaller(nums)\n    # 以無空格的列表格式輸出\n    print('[' + ','.join(map(str, res)) + ']')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,2,6,1]",
          "expected_output": "[2,1,1,0]",
          "success": true,
          "output": "[2,1,1,0]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-1]",
          "expected_output": "[0,0]",
          "success": true,
          "output": "[0,0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode537.json",
    "problem_index_in_file": 0,
    "title": "Complex Number Multiplication",
    "description_snippet": "A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\nreal is the re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for multiplying two complex numbers given as strings \"real+imaginaryi\". Steps: parse, multiply, format.\n\nNeed to output step by step with explanations, each line: 虛擬碼步驟 + ' // ' + explanation. Use arrows, Start, End, Decision.\n\nWe need to parse strings into real and imaginary parts. Steps:\n\nStart\n→ Step: Parse num1 into real1 and imag1 // Convert string to integers\n→ Step: Parse num2 into real2 and imag2 // Convert string to integers\n→ Step: Compute product: real = real1*real2 - imag1*imag2 // since (a+bi)(c+di)= (ac - bd) + (ad+bc)i\n→ Step: Compute imag = real1*imag2 + imag1*real2 // ad+bc\n→ Step: Format output string: result = real + \"+\" + imag + \"i\" // build string\nEnd\n\nNeed maybe decisions: check if imag negative? but format should still be like \"a+-bi\"? The specification maybe \"real+imaginaryi\" with real integer, imaginary integer, but if negative imag, maybe \"-5-3i\"? Usually format \"a+bi\" where b could be negative, so \"a-3i\". But given they use \"+\", we need to preserve sign. But we can still output real + \"+\" + imag + \"i\" and imag may be negative giving \"real+-3i\". That's okay.\n\nAdd decision for sign? Not required.\n\nLet's produce.\n\nWe need to show parsing steps: maybe use Split? So we can parse:\n\nStep: Extract real1 = int(substring before '+') // first part\nStep: Extract imag1 = int(substring between '+' and 'i') // second part\n\nSimilarly for num2.\n\nWe might include decision if string contains '-'? but it's okay.\n\nLet's produce virtual code accordingly.\n\nAlso use \"Decision:\" maybe not necessary.\n\nBut we can include decision to handle sign of imaginary part? For output, if imag<0 then we want \"-\" sign and absolute value. But we can keep simple.\n\nI'll include a Decision: If imag <0? to format properly. That demonstrates decision structure.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 解析 num1 的實部 real1 // 從字串前半部取整數\n→ Step: 解析 num1 的虛部 imag1 // 從字串中 '+' 與 'i' 之間取整數\n→ Step: 解析 num2 的實部 real2 // 從字串前半部取整數\n→ Step: 解析 num2 的虛部 imag2 // 從字串中 '+' 與 'i' 之間取整數\n→ Step: 計算乘積的實部 real = real1 * real2 - imag1 * imag2 // (a+bi)(c+di)=ac−bd\n→ Step: 計算乘積的虛部 imag = real1 * imag2 + imag1 * real2 // ad+bc\n→ Decision: 如果 imag < 0? // 判斷虛部符號以便格式化\n    Yes → Step: 虛部字串 imagStr = imag + \"i\" // 直接使用負數字串\n    No  → Step: 虛部字串 imagStr = \"+\" + imag + \"i\" // 正數前加 '+'\n→ Step: 組成結果字串 result = real + imagStr // 形成 \"real+imaginaryi\" 或 \"real-imaginaryi\"\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"\n        將複數字串轉成實部與虛部的整數，然後按 (a+bi)(c+di)=ac-bd + (ad+bc)i\n        計算結果並回傳符合「real+imaginaryi」格式的字串。\n        \"\"\"\n        def parse(s: str):\n            # 把 \"real+imaginaryi\" 轉成 (real, imaginary)\n            real_str, imag_str = s.split('+')\n            real = int(real_str)\n            imag = int(imag_str[:-1])  # 去掉最後的 'i'\n            return real, imag\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    \"\"\"\n    讀取標準輸入，格式假設為：\n        \"num1\", \"num2\"\n    例如：\n        \"1+1i\", \"1+1i\"\n    處理後輸出乘積的複數字串。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 以第一個逗號分開兩個複數字串\n    parts = data.split(',', 1)\n    if len(parts) != 2:\n        # 如果格式不符，直接退出\n        return\n\n    num1 = parts[0].strip().strip('\"').strip()\n    num2 = parts[1].strip().strip('\"').strip()\n\n    solution = Solution()\n    result = solution.complexNumberMultiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"1+1i\", \"1+1i\"",
          "expected_output": "\"0+2i\"",
          "success": true,
          "output": "0+2i"
        },
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "success": true,
          "output": "0+-2i"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode609.json",
    "problem_index_in_file": 0,
    "title": "Find Duplicate File in System",
    "description_snippet": "Given a list paths of directory info, including the directory path, and all the files with contents ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem. Must be line by line, with arrow structure. Use virtual code style as example. Provide steps: Start, parse input list, iterate each directory string, split by space to get dir path and file entries, for each file entry parse name and content inside parentheses, build a map content->list of full paths. After processing all, iterate map to collect lists with size>1, append to result. End.\n\nWe should write in Chinese (Traditional). Provide brief explanation per line. Use virtual code arrows. Use \"→\" for steps. Use \"Decision:\" for decisions.\n\nLet's craft. Use Start, End.\n\nLet's produce code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告 result 為空列表 // 用於儲存重複檔案組  \n→ Step 2: 宣告 map 為空字典，鍵為檔案內容，值為檔案路徑列表 // 用於分組相同內容的檔案  \n→ Step 3: 從輸入 list of strings（paths）逐一處理每個 directory info // 讀取所有目錄資訊  \n    → Decision: 是否為空字串? // 防止無效輸入  \n        Yes → Continue // 空字串直接跳過  \n        No  → Step 4: 用空格分割該字串，第一項為 dirPath，後面為 fileInfo 列表 // 取得目錄路徑與檔案資訊  \n            → Step 5: 針對 fileInfo 中每個檔案項目進行處理  \n                → Step 6: 取檔名和內容：檔名為 '(' 前的子字串，內容為 '(' 與 ')' 之間的子字串 // 解析檔案名稱與內容  \n                → Step 7: 建立 fullPath = dirPath + \"/\" + fileName // 組成完整路徑  \n                → Step 8: 若 content 不在 map 中，則 map[content] = 空列表 // 初始化分組  \n                → Step 9: 將 fullPath 加入 map[content] 列表 // 將檔案加入對應內容的分組  \n→ Step 10: 遍歷 map，對於每個 content 的 list，若 list 長度大於 1，則將該 list 加入 result // 只保留重複檔案組  \nEnd // 程式執行結束，返回 result",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"\n        Find all groups of duplicate files based on their content.\n        Each path string is formatted as:\n        \"dir_path file1(content1) file2(content2) ...\"\n        \"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            # Split the directory part from the file infos\n            parts = path.split()\n            if not parts:\n                continue\n            root = parts[0]\n            for file_info in parts[1:]:\n                # Extract file name and content\n                name, content = file_info.split('(')\n                content = content[:-1]  # remove trailing ')'\n                # Build full file path and store it by content\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # Only keep groups that have more than one file (duplicates)\n        return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # The input is expected to be something like:\n    # paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\", ...]\n    # Extract the right-hand side of the assignment and evaluate it safely\n    try:\n        _, expr = data.split('=', 1)\n    except ValueError:\n        # If there is no '=' simply treat the whole data as the list literal\n        expr = data\n    expr = expr.strip()\n    paths = ast.literal_eval(expr)\n\n    solution = Solution()\n    duplicate_groups = solution.findDuplicate(paths)\n    print(duplicate_groups)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode208.json",
    "problem_index_in_file": 0,
    "title": "Implement Trie (Prefix Tree)",
    "description_snippet": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and r...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines for implementing Trie class with methods: constructor, insert, search, startsWith. Provide each line with explanation. Use virtual code with arrows etc. Each line: \"虛擬碼步驟 // 解釋\". Use structure: Start, End, Decision: etc. Must be line-by-line. Use Start at top, End at bottom. We'll include class definition and methods. Provide steps inside methods: create node structure, insert loops, search loops, startsWith loops. Use decisions for checking null or end-of-word. Provide concise explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Class Trie // 定義 Trie 類別\n    → Node: 構造一個子節點字典 + 是否為單詞結束標誌 // 節點結構\n→ Method Trie() // 建構子\n    → root ← New Node // 初始化根節點\n    → End // 建構子結束\n→ Method insert(word) // 插入單詞\n    → current ← root // 從根節點開始\n    → For 每個 char in word // 遍歷字元\n        → Decision: 如果 current.children 沒有 char? // 字元節點不存在\n            Yes → current.children[char] ← New Node // 建立新節點\n        → current ← current.children[char] // 移動到該子節點\n    → current.isEnd ← True // 標記單詞結束\n    → End // 插入結束\n→ Method search(word) // 查找單詞\n    → current ← root\n    → For 每個 char in word\n        → Decision: 如果 current.children 沒有 char? // 字元節點不存在\n            Yes → Return False // 直接回傳 false\n        → current ← current.children[char]\n    → Decision: current.isEnd? // 是否為單詞結束\n        Yes → Return True // 找到完整單詞\n        No  → Return False // 只作為前綴\n→ Method startsWith(prefix) // 檢查前綴\n    → current ← root\n    → For 每個 char in prefix\n        → Decision: 如果 current.children 沒有 char? // 字元節點不存在\n            Yes → Return False // 前綴不存在\n        → current ← current.children[char]\n    → Return True // 前綴存在\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    \"\"\"Trie 節點，包含子節點字典與是否為單詞結束的標誌\"\"\"\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    \"\"\"前綴樹實作\"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把輸入字串包成一個 tuple，方便 literal_eval 解析成兩個 list\n    try:\n        ops, args = ast.literal_eval(f\"({data})\")\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        return\n\n    results = []\n    trie = None\n    for op, arg in zip(ops, args):\n        if op == 'Trie':\n            trie = Trie()\n            results.append(None)\n        elif op == 'insert':\n            trie.insert(arg[0])\n            results.append(None)\n        elif op == 'search':\n            results.append(trie.search(arg[0]))\n        elif op == 'startsWith':\n            results.append(trie.startsWith(arg[0]))\n        else:\n            # 未知操作，略過\n            results.append(None)\n\n    # 將結果轉成 LeetCode 風格的字串輸出\n    def fmt(v):\n        if v is None:\n            return 'null'\n        if isinstance(v, bool):\n            return 'true' if v else 'false'\n        return str(v)\n\n    output = '[' + ', '.join(fmt(r) for r in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "success": true,
          "output": "[null, null, true, false, true, null, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode268.json",
    "problem_index_in_file": 0,
    "title": "Missing Number",
    "description_snippet": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for given problem: array nums containing n distinct numbers in [0, n], return missing number. Typical solution: use XOR or sum formula. We'll choose XOR method: missing = 0..n XOR all elements. Provide step by step virtual code.\n\nNeed to produce in Traditional Chinese. Provide each line: \"Start\", \"→ Step ...\", \"→ Decision ...\", \"End\". Each line has comment after // explanation.\n\nLet's produce code:\n\nStart\n→ Step 1: Initialize missing = 0 // start missing value 0\n→ Step 2: Set index = 0 // index for array\n→ Decision: 如果 index < n? // loop over array\n    Yes → Step 3: missing = missing XOR nums[index] // XOR current element\n    Yes → Step 4: index = index + 1 // increment\n    Yes → Decision: 從 Step 2 迴圈繼續? // but we used decision earlier. Actually better to embed loop: Use while. But virtual code may represent loop by Decision. We'll use loop: after Step 4 go back to Step 2? But we need explicit loop.\n\nAlternate approach: Use for loop: for i from 0 to n: missing = missing XOR i XOR nums[i]. But we need to iterate over numbers and indices simultaneously.\n\nSimplify: missing = 0; For i in 0..n: missing = missing XOR i; For each element x in nums: missing = missing XOR x. But we can combine.\n\nWe'll produce two loops: first XOR all numbers 0..n, second XOR all array elements.\n\nLet's design:\n\nStart\n→ Step 1: Initialize missing = 0 // 設定缺失值為 0\n→ Step 2: Set i = 0 // 迴圈變數\n→ Decision: i <= n? // 檢查是否還有整數 0..n\n    Yes → Step 3: missing = missing XOR i // 將 i 加入 XOR\n    Yes → Step 4: i = i + 1 // 進一步\n    Yes → 回到 Step 2\n    No → Step 5: Set j = 0 // 迴圈索引對應陣列\n    No → Decision: j < n? // 檢查陣列長度\n        Yes → Step 6: missing = missing XOR nums[j] // XOR 陣列元素\n        Yes → Step 7: j = j + 1 // 下一個\n        Yes → 回到 Step 5\n        No → Step 8: Return missing // 回傳缺失值\nEnd\n\nNeed to include arrows for back to Step 2 etc.\n\nBut we must ensure each line uses \"→\". We'll include explicit step numbering.\n\nAlso use \"Yes →\" and \"No →\" properly.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: missing ← 0 // 初始化缺失值為 0\n→ Step 2: i ← 0 // 迴圈變數 i\n→ Decision: i ≤ n? // 判斷是否還有整數 0..n\n    Yes → Step 3: missing ← missing XOR i // 將 i 與缺失值 XOR\n    Yes → Step 4: i ← i + 1 // i 加 1\n    Yes → 回到 Step 2 // 繼續迴圈\n    No → Step 5: j ← 0 // 迴圈索引 j\n    No → Decision: j < n? // 判斷是否還有陣列元素\n        Yes → Step 6: missing ← missing XOR nums[j] // XOR 陣列元素\n        Yes → Step 7: j ← j + 1 // j 加 1\n        Yes → 回到 Step 5 // 繼續迴圈\n        No → Step 8: Return missing // 回傳缺失值\nEnd // 程式執行結束\n\nBut we need each line to contain step with \"→\" at start except Start and End maybe. Format requires each line to contain \"虛擬碼步驟\" + \" // 解釋\". Start and End lines are also lines.\n\nSo we need to start with \"Start // 程式開始執行\". Good.\n\nBut for \"回到 Step 2\" we need to produce a line: \"→ 回到 Step 2 // 迴圈回到步驟 2\". But \"回到\" may not be standard but okay.\n\nAlternatively use \"→ Step 2\" again? But to avoid duplication, we can just mention \"→ Step 2\". So produce \"→ Step 2 // 迴圈回到步驟 2\".\n\nSimilarly for Step 5 loop.\n\nAlso after Decision No branch we need step 5; but we need to maintain line numbering.\n\nLet's restructure:\n\nStart // 程式開始執行\n→ Step 1: missing ← 0 // 初始化缺失值為 0\n→ Step 2: i ← 0 // 迴圈變數 i\n→ Decision: i ≤ n? // 判斷是否還有整數 0..n\n    Yes → Step 3: missing ← missing XOR i // 將 i 與缺失值 XOR\n    Yes → Step 4: i ← i + 1 // i 加 1\n    Yes → Step 2 // 迴圈回到 Step 2\n    No → Step 5: j ← 0 // 迴圈索引 j\n    No → Decision: j < n? // 判斷是否還有陣列元素\n        Yes → Step 6: missing ← missing XOR nums[j] // XOR 陣列元素\n        Yes → Step 7: j ← j + 1 // j 加 1\n        Yes → Step 5 // 迴圈回到 Step 5\n        No → Step 8: Return missing // 回傳缺失值\nEnd // 程式執行結束\n\nWe need to maintain indentation for Decision branches. Provide proper indentation.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: missing ← 0 // 初始化缺失值為 0  \n→ Step 2: i ← 0 // 迴圈變數 i  \n→ Decision: i ≤ n? // 判斷是否還有整數 0..n  \n Yes → Step 3: missing ← missing XOR i // 將 i 與缺失值 XOR  \n Yes → Step 4: i ← i + 1 // i 加 1  \n Yes → Step 2 // 迴圈回到 Step 2  \n No → Step 5: j ← 0 // 迴圈索引 j  \n No → Decision: j < n? // 判斷是否還有陣列元素  \n  Yes → Step 6: missing ← missing XOR nums[j] // XOR 陣列元素  \n  Yes → Step 7: j ← j + 1 // j 加 1  \n  Yes → Step 5 // 迴圈回到 Step 5  \n  No → Step 8: Return missing // 回傳缺失值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def missingNumber(self, nums):\n        \"\"\"\n        找出缺失的數字。\n        使用數學公式：n*(n+1)//2 - sum(nums)。\n        \"\"\"\n        n = len(nums)\n        total = n * (n + 1) // 2\n        return total - sum(nums)\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得陣列字串，支援 'nums = [..]' 或僅 [..]\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums_str = data[start:end + 1]\n        nums = ast.literal_eval(nums_str)  # 轉成 list\n\n    # 計算缺失的數字並輸出\n    sol = Solution()\n    result = sol.missingNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [9,6,4,2,3,5,7,0,1]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode470.json",
    "problem_index_in_file": 0,
    "title": "Implement Rand10() Using Rand7()",
    "description_snippet": "Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for rand10 using rand7. We need to use only rand7 and no other random. Standard solution: generate 2 rand7 to produce 49 possibilities, reject if >40, then map 1-40 to 1-10 by dividing by 4. Or use 3 calls for 343 space. Simpler 2 call approach.\n\nSo virtual code: Start -> generate x = rand7() -> y = rand7() -> num = (x-1)*7 + y  // 1-49. Decision: if num <= 40? Yes -> rand10 = (num-1)%10 +1, else repeat. End.\n\nWe need iterative loop. Use while true. Represent loop as Decision maybe.\n\nLet's produce stepwise. Use \"Repeat\" maybe.\n\nWe can use Decision: If num <=40? Yes → compute rand10; break; No → repeat.\n\nWill produce virtual code line by line.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Repeat // 重複直到成功  \n  → Step 1: x ← rand7() // 產生第一個隨機數 1~7  \n  → Step 2: y ← rand7() // 產生第二個隨機數 1~7  \n  → Step 3: num ← (x - 1) * 7 + y // 將兩個數映射到 1~49  \n  → Decision: 如果 num ≤ 40? // 只保留前 40 個等可能的結果  \n    Yes → Step 4: result ← ((num - 1) % 10) + 1 // 1~10 的均勻映射  \n     → End // 完成一次 rand10() 呼叫  \n    No → Continue // 重新進入 Repeat，丟棄不符合的結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# 假設外部已提供 rand7() API，以下為測試用的簡易實作\n# 在正式測試環境中，請自行使用真實的 rand7() 函式，切勿呼叫任何隨機 API\n# def rand7():\n#     from random import randint\n#     return randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        產生 1~10 的均勻隨機數。使用兩次 rand7() 產生 1~49 的等可能分布，\n        若結果 > 40 則重試，直到得到 1~40 為止，最後映射到 1~10。\n        \"\"\"\n        while True:\n            # 兩次 rand7() 組合成 1~49 的等可能值\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    # 讀取整個輸入字串，並從中提取整數 n\n    data = sys.stdin.read().strip()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpjwu5mt5a.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpjwu5mt5a.py\", line 29, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmpjwu5mt5a.py\", line 18, in rand10\n    num = (rand7() - 1) * 7 + rand7()\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp91tyv_yf.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmp91tyv_yf.py\", line 29, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmp91tyv_yf.py\", line 18, in rand10\n    num = (rand7() - 1) * 7 + rand7()\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpt5gyufcs.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpt5gyufcs.py\", line 29, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmpt5gyufcs.py\", line 18, in rand10\n    num = (rand7() - 1) * 7 + rand7()\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode7.json",
    "problem_index_in_file": 0,
    "title": "Reverse Integer",
    "description_snippet": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for reversing integer digits, with overflow detection, no 64-bit. So we must simulate 32-bit overflow by checking before multiplication/addition. Steps: start, determine sign, abs value, loop while >0: pop digit = x %10, check overflow: if result> (INT_MAX - digit)/10 then overflow. Build reversed. Then apply sign, return. Use decision. Also need 0 handling. Use step names. Output each line with // explanation.\n\nNeed to not use 64-bit. So using 32-bit int operations only. The check uses INT_MAX=2147483647. For negative sign, use INT_MIN=-2147483648 but we can check using abs? Use condition for sign separately: we can compute reversed with sign at the end. But we need to handle INT_MIN case: abs(INT_MIN) is 2147483648 cannot fit in 32-bit positive int. So better process sign separately: let sign = 1 if x>=0 else -1. Use y=abs(x) but cannot compute abs(INT_MIN). So we can use long long? Not allowed. Instead we can treat x negative: we can store x as negative and use modulo with negative? In C, -123%10 = -3? Actually remainder has same sign as dividend. So we can handle negative numbers by using positive logic by converting to negative? Actually easier: use while x!=0: digit = x % 10; x /=10; but for negative, digit negative too. But we need reversed positive? We can accumulate result as negative too. For simplicity, we can convert to positive using -x? But INT_MIN cannot be negated. So maybe handle sign separately: if x<0: use negative logic: keep building reversed negative; but still need to check overflow. For negative, reversed must be >= INT_MIN. The algorithm with result negative: start rev=0; while x!=0: digit = x%10; x/=10; check overflow: if rev < (INT_MIN + digit)/10? Wait rev negative, digit negative. Hard.\n\nAlternate: we can compute using positive logic by converting to positive with 64-bit? Not allowed.\n\nBut we can use sign logic: Use variable rev=0; While x!=0: digit = x%10; x /=10; if rev > (INT_MAX - digit)/10 then overflow. But this works for positive rev and digit. For negative numbers, we can use rev as negative and digit negative. So we can use same logic with rev and digit as negative numbers: Since rev negative, (INT_MIN - digit)/10? It's messy.\n\nMaybe simpler: We can use the approach: Let sign=1 if x>=0 else -1; Let temp = x; If x<0: temp = 0 - x? cannot for INT_MIN. So we can't.\n\nBetter: Use loop with negative numbers: Since rev starts 0, digit = x % 10 yields negative digit. For example x=-123: first digit=-3. rev=0. After check: rev > (INT_MAX - digit)/10? But rev=0, digit=-3 => INT_MAX - (-3)=INT_MAX+3, >0; division yields huge. So check passes. rev= rev*10 + digit => 0*10 + (-3) = -3. Next x=-12: digit=-2; rev=-3; Check overflow: rev > (INT_MAX - digit)/10? rev=-3 > something? No. This logic fails.\n\nThus need alternative: Use positive logic by taking absolute but using special handling for INT_MIN: we can treat x as negative, but compute rev as negative: at each step, digit = -(x % 10) positive? Wait for negative x, x%10 negative. Example x=-123: x%10 = -3. Then digit = -(x%10) = 3. Then rev = rev*10 + digit? rev starts 0; rev=0*10+3=3; x/=10 => -12. Continue. At end rev=321; then apply sign = -1, result = -rev = -321. But need overflow check for negative result: when rev becomes > INT_MAX? We need to check before final sign. We can check if rev > INT_MAX/10 or (rev==INT_MAX/10 and digit>INT_MAX%10) then overflow.\n\nSo use same as positive but apply sign at end.\n\nThus algorithm:\n\nStart\n→ Decision: 是否為負數? // Determine sign\n    Yes → Step 1: 設 sign = -1 // Set sign\n    No  → Step 1: 設 sign = 1\n→ Step 2: 設 rev = 0 // 逆序暫存\n→ Step 3: 設 temp = x // 用於迴圈\n→ Decision: temp != 0? // 進行迴圈\n    Yes → Step 4: digit = abs(temp % 10) // 取得正數位\n    Yes → Step 5: temp = temp / 10 // 去掉已處理的位\n    Yes → Decision: rev > INT_MAX/10 或 (rev == INT_MAX/10 AND digit > INT_MAX%10)? // 檢查溢位\n        Yes → Step 6: return 0 // 溢位，返回 0\n        No  → Step 7: rev = rev * 10 + digit // 更新逆序\n        No  → Decision: temp != 0? // 循環\n            ... repeat ...\n    No → Step 8: result = sign * rev // 給正負號\n    No → Step 9: return result\nEnd\n\nBut we need to handle the loop properly: Use while loop with decision repeated.\n\nWe'll produce step lines accordingly.\n\nMake sure each line has arrow, step label, comment. Use '→' for flow. Use 'Decision:' for if.\n\nAlso include Start and End.\n\nLet's produce.\n\nNeed to use 虛擬碼步驟: e.g., \"Start\" no arrow. Then arrow for next.\n\nMake sure to reference variables: x, rev, temp, digit, sign, result.\n\nMake use of INT_MAX=2147483647, INT_MIN irrelevant.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: x < 0? // 判斷輸入是否為負數  \n    Yes → Step 1: sign = -1 // 設定符號為負  \n    No  → Step 1: sign = 1  // 設定符號為正  \n→ Step 2: rev = 0        // 初始化逆序暫存器  \n→ Step 3: temp = x       // 用 temp 進行迴圈操作  \n→ Decision: temp ≠ 0?    // 進入迴圈直到 temp 為 0  \n    Yes → Step 4: digit = abs(temp % 10) // 取得目前最低位的正數位  \n    Yes → Step 5: temp = temp / 10       // 去掉已處理的位  \n    Yes → Decision: rev > INT_MAX/10 OR (rev == INT_MAX/10 AND digit > INT_MAX%10)? // 檢查是否會溢位  \n        Yes → Step 6: return 0 // 溢位，直接回傳 0  \n        No  → Step 7: rev = rev * 10 + digit // 更新逆序數字  \n        No  → Decision: temp ≠ 0? // 若還有位數，繼續迴圈  \n            … (重複上述 4-7 步) …  \n    No → Step 8: result = sign * rev // 將符號應用於逆序結果  \n    No → Step 9: return result // 回傳最終結果  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def reverse(self, x):\n        \"\"\"\n        逆轉 32-bit 有號整數的位數，若溢位則返回 0。\n        \"\"\"\n        INT_MAX = 2**31 - 1\n        # 確定正負號\n        sign = -1 if x < 0 else 1\n        temp = x          # 用於迴圈的暫存變數\n        rev = 0           # 逆序數字暫存\n\n        while temp != 0:\n            digit = abs(temp % 10)  # 取得最低位的正數位\n            temp //= 10             # 去掉已處理的位\n\n            # 檢查是否會因為乘 10 或加 digit 而溢位\n            if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and digit > INT_MAX % 10):\n                return 0\n\n            rev = rev * 10 + digit\n\n        return sign * rev  # 重新套上符號\n\n\nif __name__ == \"__main__\":\n    import sys, re\n    # 從 stdin 讀取所有資料，擷取第一個出現的整數\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    x = int(nums[0]) if nums else 0\n\n    solution = Solution()\n    result = solution.reverse(x)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 123",
          "expected_output": "321",
          "success": true,
          "output": "321"
        },
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        },
        {
          "example_index": 2,
          "input": "x = 120",
          "expected_output": "21",
          "success": true,
          "output": "21"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode67.json",
    "problem_index_in_file": 0,
    "title": "Add Binary",
    "description_snippet": "Given two binary strings a and b, return their sum as a binary string....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrows and explanation. Use binary addition of strings. Use algorithm: start from end of each string, carry=0, result builder. Loop while i>=0 or j>=0 or carry>0. Compute sum of bits plus carry, new bit = sum % 2, carry = sum / 2. Prepend bit to result. After loop, return result. Use Start, Decision, etc. Provide explanation comments. Should not output actual code, only virtual steps. Use arrows as specified. Also include decision blocks for loop and condition. Provide step labels like Step 1, Step 2, etc.\n\nLet's produce. Ensure each line has \"虛擬碼步驟 [space] // 解釋\". Use Start, End. Indent decisions with spaces.\n\nWe need to maintain the structure. Let's craft.\n\nProbably something like:\n\nStart // 程式開始\n\n→ Step 1: 初始化指標 i = a.length - 1, j = b.length - 1, carry = 0, result = empty string // 設定起始位置和變數\n\n→ Decision: 是否還有未處理位或有進位? // 檢查是否需要繼續加法\n\n    Yes → Step 2: 取 bitA = (i >= 0) ? a[i] : '0' // 取 a 的當前位，若已經處理完則視為 0\n\n    → Step 3: 取 bitB = (j >= 0) ? b[j] : '0' // 取 b 的當前位，若已經處理完則視為 0\n\n    → Step 4: sum = (bitA - '0') + (bitB - '0') + carry // 計算兩位與進位的總和\n\n    → Step 5: newBit = sum % 2 // 取得本次結果位\n\n    → Step 6: carry = sum / 2 // 更新進位\n\n    → Step 7: result = newBit + result // 將新位加到結果前面\n\n    → Decision: i >= 0 ? i-- : no change // 更新 a 的指標\n\n    → Decision: j >= 0 ? j-- : no change // 更新 b 的指標\n\n    → Decision: (i >= 0 or j >= 0 or carry > 0)? loop again : exit // 判斷是否再次進入迴圈\n\n    Yes → repeat from Step 2\n\n    No  → ...\n\nBut we need to format exactly: each line with \"虛擬碼步驟 // 解釋\". Use arrows and indentation. Let's produce.\n\nWe need to maintain decision blocks like:\n\nDecision: <condition> ?\n\nYes → <step>\n\nNo → <step>\n\nBut we might need nested decisions inside the loop.\n\nBetter to produce a loop structure:\n\n→ Decision: i>=0 or j>=0 or carry>0? // 需要進一步加法？\n\n    Yes → Step: compute sum...\n\n    No → Step: return result\n\nBut we need to include the loop step.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step 1: 設定 i = a.length-1, j = b.length-1, carry=0, result='' // 初始化變數\n\n→ Decision: i>=0 或 j>=0 或 carry>0? // 是否還有位需要處理\n\n    Yes → Step 2: bitA = (i>=0) ? a[i] : '0' // 取得 a 的當前位\n\n    → Step 3: bitB = (j>=0) ? b[j] : '0' // 取得 b 的當前位\n\n    → Step 4: sum = (bitA-'0') + (bitB-'0') + carry // 計算總和\n\n    → Step 5: result = (sum%2)+' '+result? Wait no spaces. Use newBit = sum%2\n\n    → Step 6: carry = sum/2 // 更新進位\n\n    → Step 7: result = newBit + result // 將位加入結果\n\n    → Decision: i>=0? i-- : no change // 移動指標\n\n    → Decision: j>=0? j-- : no change\n\n    → Decision: i>=0 or j>=0 or carry>0? // 再次迴圈\n\n        Yes → 回到 Step 2\n\n        No  → Step 8: return result // 結束加法\n\nBut we need to avoid actual code, so we use pseudocode steps.\n\nLet's produce final answer with each line following format.\n\nWe need to include arrows like \"→\" and \"Yes →\", \"No →\". Each line should have explanation after //.\n\nLet's craft.\n\nWe need to maintain indentation of decisions: using spaces. Use \"Decision:\" lines.\n\nMake sure we don't output actual code, just pseudo.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← a.length - 1, j ← b.length - 1, carry ← 0, result ← \"\" // 初始化指標、進位與結果串  \n→ Decision: i ≥ 0 或 j ≥ 0 或 carry > 0? // 判斷是否還有位需要處理  \n Yes → Step 2: bitA ← (i ≥ 0) ? a[i] : '0' // 取得 a 的當前位，若已處理完則視為 0  \n  → Step 3: bitB ← (j ≥ 0) ? b[j] : '0' // 取得 b 的當前位，若已處理完則視為 0  \n  → Step 4: sum ← (bitA - '0') + (bitB - '0') + carry // 計算兩位與進位的總和  \n  → Step 5: newBit ← sum % 2 // 取得本次結果位  \n  → Step 6: carry ← sum / 2 // 更新進位  \n  → Step 7: result ← newBit + result // 將新位加到結果前面  \n  → Decision: i ≥ 0? i ← i - 1 : 無變化 // 移動 a 的指標  \n  → Decision: j ≥ 0? j ← j - 1 : 無變化 // 移動 b 的指標  \n  → Decision: i ≥ 0 或 j ≥ 0 或 carry > 0? // 判斷是否再次迴圈  \n   Yes → 回到 Step 2 // 重複處理下一位  \n   No → Step 8: 返回 result // 所有位已加完，返回結果  \n No → Step 9: 返回 result // 初始條件即已滿足，直接返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef add_binary(a: str, b: str) -> str:\n    \"\"\"Return the binary sum of strings a and b.\"\"\"\n    i, j = len(a) - 1, len(b) - 1\n    carry = 0\n    result = []\n\n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        result.append(str(total % 2))\n        carry = total // 2\n\n    return ''.join(reversed(result))\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read()\n    # Extract all binary strings (containing only 0 and 1)\n    binaries = re.findall(r'[01]+', data)\n    if len(binaries) < 2:\n        # If input was given line by line, split by whitespace\n        lines = data.strip().split()\n        if len(lines) >= 2:\n            a, b = lines[0], lines[1]\n        else:\n            raise ValueError(\"Input must contain two binary strings.\")\n    else:\n        a, b = binaries[0], binaries[1]\n    # Compute and output the result\n    print(add_binary(a, b))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"11\", b = \"1\"",
          "expected_output": "\"100\"",
          "success": true,
          "output": "100"
        },
        {
          "example_index": 1,
          "input": "a = \"1010\", b = \"1011\"",
          "expected_output": "\"10101\"",
          "success": true,
          "output": "10101"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode371.json",
    "problem_index_in_file": 0,
    "title": "Sum of Two Integers",
    "description_snippet": "Given two integers a and b, return the sum of the two integers without using the operators + and -....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code steps: cannot use + or -. Typically use bitwise XOR and AND shift. Steps: Start, input a,b, compute sum via bitwise operations until carry zero. Loop: temp = a XOR b; carry = (a AND b) << 1; a = temp; b = carry; loop until carry==0; return a. So produce steps. Each line with explanation. Use arrow syntax. We'll produce Start, then Step 1: read a,b. Step 2: initialize carry loop. Use Decision: carry==0? If Yes exit loop. Need to represent loop. Perhaps:\n\nStart\n→ Step 1: Read a, b // 取得兩個整數\n→ Step 2: Initialize temp = a XOR b // 先計算不進位和\n→ Step 3: Initialize carry = (a AND b) << 1 // 進位\n→ Decision: carry == 0? // 判斷是否還有進位\n    Yes → Step 4: Result = temp // 無進位時即為總和\n    No  → Step 5: a = temp // 將 temp 作為新的 a\n           Step 6: b = carry // 將 carry 作為新的 b\n           → Go back to Decision? Actually we need loop. Use → Step 2 again? Maybe use arrow to loop.\n\nBetter: Use a While loop concept: Decision: carry != 0? -> if Yes go to Step 2, else go to Step 4. That would repeat.\n\nLet's produce:\n\nStart\n→ Step 1: Read a, b // 取得兩個整數\n→ Step 2: temp = a XOR b // 計算不進位的和\n→ Step 3: carry = (a AND b) << 1 // 計算進位\n→ Decision: carry == 0? // 是否還有進位需要處理\n    Yes → Step 4: result = temp // 沒有進位，temp 即為最終和\n    No  → Step 5: a = temp // 進入下一輪，使用 temp 作為新的 a\n           Step 6: b = carry // 進位作為新的 b\n           → Go back to Step 2 // 重新計算\nEnd // 程式結束\n\nBut we need arrow from Step 6 back to Step 2. Use \"→\" line to show loop. The last step might be \"→ Step 2\". Provide explanation.\n\nLet's format each line with comment. Use Chinese explanation.\n\nNeed to ensure each line \"虛擬碼步驟 [空格] // 解釋\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read a, b // 取得兩個整數  \n→ Step 2: temp = a XOR b // 計算不進位的和  \n→ Step 3: carry = (a AND b) << 1 // 計算進位  \n→ Decision: carry == 0? // 判斷是否還有進位需要處理  \n  Yes → Step 4: result = temp // 沒有進位，temp 即為最終和  \n  No → Step 5: a = temp // 進入下一輪，使用 temp 作為新的 a  \n    Step 6: b = carry // 進位作為新的 b  \n    → Step 2 // 重新計算，繼續迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getSum(self, a: int, b: int) -> int:\n        \"\"\"不使用 +、-，利用位運算求兩數之和。\"\"\"\n        MASK = 0xFFFFFFFF          # 32 位全 1\n        MAX_INT = 0x7FFFFFFF       # 最大正整數 (2^31-1)\n\n        while b != 0:              # 只要還有進位就繼續\n            carry = (a & b) & MASK             # 先算進位\n            a = (a ^ b) & MASK                 # 計算不進位的和\n            b = (carry << 1) & MASK            # 進位左移一位作為新 b\n\n        # 若結果在 32 位正整數範圍內直接回傳，否則轉為負數\n        return a if a <= MAX_INT else ~(a ^ MASK)\n\ndef parse_input(text: str):\n    \"\"\"從輸入文字中擷取兩個整數。\"\"\"\n    nums = re.findall(r'-?\\d+', text)\n    if len(nums) < 2:\n        raise ValueError(\"輸入中缺少兩個整數。\")\n    return int(nums[0]), int(nums[1])\n\ndef main():\n    data = sys.stdin.read()\n    a, b = parse_input(data)\n    solution = Solution()\n    result = solution.getSum(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 1, b = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode593.json",
    "problem_index_in_file": 0,
    "title": "Valid Square",
    "description_snippet": "Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code that checks if four given points form a square. Provide step-by-step algorithm.\n\nWe will use virtual code: Start, compute pairwise distances, sort distances, check conditions: there are 4 equal smaller distances (sides) and 2 equal larger distances (diagonals). And smaller>0. Also diagonals = side*sqrt(2). But we can avoid sqrt by comparing squares.\n\nWe need to produce each line with \"→\" etc. Let's produce algorithm:\n\nStart\n→ Step 1: Input points p1,p2,p3,p4 // Get coordinates\n→ Step 2: Create list of all 6 pairwise distances squared // squared distances avoid sqrt\n→ Step 3: Sort distances ascending // easier to identify sides and diagonals\n→ Decision: If first 4 distances equal and >0? // check sides\n    Yes →\n        Decision: If last 2 distances equal? // diagonals\n            Yes →\n                Decision: If last distance == first distance * 2? // diagonal^2 = side^2*2\n                    Yes → Step X: Return true // Square\n                    No → Step Y: Return false // Not a square\n            No → Step Y: Return false\n    No → Step Y: Return false\nEnd\n\nNeed to include steps to compute squared distance.\n\nAlso need to compute distances: for each pair of points, compute dx^2+dy^2.\n\nWe'll add Step 2.1: For each pair of points, compute squared distance and add to list.\n\nLet's structure virtual code:\n\nStart\n→ Step 1: Initialize empty list D // distances\n→ Step 2: For each pair (pi,pj) with i<j\n    → Step 2.1: Compute dx = pi.x - pj.x\n    → Step 2.2: Compute dy = pi.y - pj.y\n    → Step 2.3: Append dx*dx + dy*dy to D\n→ Step 3: Sort D ascending\n→ Decision: If D[0]==D[1]==D[2]==D[3] and D[0]>0? // sides equal and positive\n    Yes →\n        Decision: If D[4]==D[5]? // diagonals equal\n            Yes →\n                Decision: If D[4]==D[0]*2? // diagonal^2 == side^2*2\n                    Yes → Step 4: Return true // square\n                    No → Step 4: Return false // not square\n            No → Step 4: Return false\n    No → Step 4: Return false\nEnd\n\nLet's produce with arrows.\n\nAlso mention that \"Start // 程式開始執行\" etc.\n\nWe need to use \"→\" after each step line. For decisions, we need indentation.\n\nWe'll produce accordingly. Use 4 spaces indentation for nested lines? They didn't specify but examples use 4 spaces indent. Use same.\n\nEnsure each line has \"虛擬碼步驟\" then space then comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 D // 用於儲存所有六個距離平方值  \n→ Step 2: 針對每一對不同的點 (pi, pj)（i < j）  \n  → Step 2.1: 計算 dx = pi.x - pj.x // x 軸差值  \n  → Step 2.2: 計算 dy = pi.y - pj.y // y 軸差值  \n  → Step 2.3: 把 dx*dx + dy*dy 加入 D // 距離平方  \n→ Step 3: 將列表 D 以升序排序 // 方便後續判斷  \n→ Decision: 如果 D[0]==D[1] 且 D[1]==D[2] 且 D[2]==D[3] 且 D[0]>0? // 四條邊相等且長度正  \n  Yes → Decision: 如果 D[4]==D[5]? // 兩條對角線相等  \n    Yes → Decision: 如果 D[4]==D[0]*2? // 對角線平方等於邊平方的兩倍（45°）  \n      Yes → Step 4: 返回 true // 四點構成正方形  \n      No → Step 4: 返回 false // 對角線不符合正方形比例  \n    No → Step 4: 返回 false // 對角線不相等  \n  No → Step 4: 返回 false // 四條邊不相等或長度為零  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n\n        return (\n            dists[0] > 0\n            and dists[0] == dists[1] == dists[2] == dists[3]\n            and dists[4] == dists[5]\n            and dists[4] == 2 * dists[0]\n        )\n\ndef main():\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) < 8:\n        print(\"false\")\n        return\n\n    p1 = [numbers[0], numbers[1]]\n    p2 = [numbers[2], numbers[3]]\n    p3 = [numbers[4], numbers[5]]\n    p4 = [numbers[6], numbers[7]]\n\n    sol = Solution()\n    result = sol.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 1,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode35.json",
    "problem_index_in_file": 0,
    "title": "Search Insert Position",
    "description_snippet": "Given a sorted array of distinct integers and a target value, return the index if the target is foun...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search insertion index. Format: each line \"虛擬碼步驟 // 解釋\". Use arrow lines. Start, End. Need to produce step by step. We'll output in Traditional Chinese. Provide explanation. Use decision arrows. Should not produce actual code. Let's produce lines:\n\nStart\n→ Initialize left = 0 // 左指標起始\n→ Initialize right = len(array) - 1 // 右指標起始\n→ Decision: while left <= right? // 迴圈條件\n    Yes → Compute mid = (left + right) // 2 // 中間索引\n    → Decision: if array[mid] == target? // 找到目標\n        Yes → Return mid // 返回索引\n        No  → Decision: if array[mid] < target? // 目標在右半邊\n            Yes → left = mid + 1 // 調整左指標\n            No  → right = mid - 1 // 調整右指標\n← 回到 Decision: while left <= right? // 重複\n← End of loop when left > right\n→ Return left // 插入位置\nEnd\n\nWe must format exactly: each line must include \"虛擬碼步驟\" and then a space and comment.\n\nUse \"Decision:\" lines with indent for branches. Use arrow for each branch: \"Yes →\" and \"No →\".\n\nWe need to keep line formatting. For branches we indent lines. For clarity use indentation with 4 spaces? Not specified. Use tab maybe? We'll just indent with 4 spaces. Each branch line: \"    Yes → ...\" etc.\n\nWe need to keep arrow formatting. Let's produce.\n\nAlso need to add \"Start // 程式開始執行\" line.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 left = 0 // 左指標設為陣列起始位置  \n→ 初始化 right = len(array) - 1 // 右指標設為陣列結尾位置  \n→ Decision: 左指標 <= 右指標? // 判斷是否還有區間可以搜尋  \n    Yes → 計算 mid = (left + right) // 2 // 找到中間索引  \n    → Decision: array[mid] == target? // 判斷中間值是否為目標  \n        Yes → 回傳 mid // 找到目標，返回其索引  \n        No  → Decision: array[mid] < target? // 目標在右半邊？  \n            Yes → left = mid + 1 // 將左指標移到 mid 之後  \n            No  → right = mid - 1 // 將右指標移到 mid 之前  \n← 回到 Decision: 左指標 <= 右指標? // 重複搜尋  \n← 迴圈結束（左指標 > 右指標）  \n→ 回傳 left // left 為目標應插入的位置  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    \"\"\"\n    二分搜尋插入位置\n    \"\"\"\n    def searchInsert(self, nums, target):\n        \"\"\"\n        在已排序的不同整數陣列中搜尋 target。\n        若找到返回其索引；否則返回其應插入的位置。\n\n        時間複雜度：O(log n)\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef main():\n    \"\"\"\n    讀取輸入格式類似：\n        nums = [1,3,5,6], target = 5\n    解析後計算並輸出插入位置。\n    \"\"\"\n    data = sys.stdin.read()\n    # 取得 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    # 取得 target 整數\n    target_match = re.search(r'target\\s*=\\s*([-\\d]+)', data)\n\n    if not nums_match or not target_match:\n        raise ValueError(\"輸入格式不正確，請提供 nums 和 target。\")\n\n    nums = eval(nums_match.group(1))\n    target = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.searchInsert(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode154.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array II",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode lines, each with \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Must produce steps for algorithm to find min in rotated sorted array with duplicates, minimizing steps. Probably use modified binary search with duplicates. Steps: start, set low=0 high=n-1, while low<high, mid=(low+high)//2, if nums[mid]>nums[high] low=mid+1, elif nums[mid]<nums[high] high=mid, else high--. After loop min=nums[low]. Then end.\n\nWe'll provide each step. Format: \"Start // 程式開始執行\". Then \"→ Step 1: ...\". Need to include arrows. Use \"→ Step 1: 初始化 low = 0, high = n - 1 // 設定搜尋範圍\". \"→ Step 2: 進入迴圈 while low < high // 持續搜尋直到範圍縮小\". Inside loop: \"→ Step 3: 計算 mid = (low + high) // 2 // 取中點\". Then decision: \"→ Decision: 如果 nums[mid] > nums[high]?\". \"Yes → Step 4: low = mid + 1 // min 在右半邊\". \"No → Decision: 如果 nums[mid] < nums[high]?\". \"Yes → Step 5: high = mid // min 在左半邊包含 mid\". \"No → Step 6: high = high - 1 // 無法確定，縮小右邊\". After loop, \"→ Step 7: min_val = nums[low] // 找到最小值\". \"→ Step 8: 輸出 min_val // 回傳結果\". \"End // 程式結束\".\n\nWe need to output each line with arrow or indentation. Use indent for decision sub-branches maybe with indentation. Example: \"→ Decision: ...\". Indent Yes/No lines with space before \"Yes →\". Use spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0, high = n - 1 // 初始化搜尋範圍  \n→ Step 2: while low < high // 只要範圍還未縮小到單一元素就繼續  \n    → Step 3: mid = (low + high) // 2 // 取中點位置  \n    → Decision: 如果 nums[mid] > nums[high]? // 比較中點與右端值  \n        Yes → Step 4: low = mid + 1 // 最小值必定在右半邊  \n        No  → Decision: 如果 nums[mid] < nums[high]? // 若中點小於右端  \n            Yes → Step 5: high = mid // 最小值在左半邊（含 mid）  \n            No  → Step 6: high = high - 1 // 無法確定，右端元素可能相同，縮小右端  \n→ Step 7: min_val = nums[low] // 循環結束時 low 指向最小值  \n→ Step 8: return min_val // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findMin(self, nums):\n        \"\"\"Return the minimum element in a rotated sorted array that may contain duplicates.\"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                # Minimum must be in the right half (mid+1..right)\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                # Minimum is in the left half including mid\n                right = mid\n            else:\n                # nums[mid] == nums[right], cannot determine, shrink the right bound\n                right -= 1\n        return nums[left]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse a string like 'nums = [1,3,5]' or just '[1,3,5]'\n    and return the list of numbers.\n    \"\"\"\n    # Search for a list literal\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        raise ValueError(\"Input does not contain a list literal.\")\n    list_str = match.group(0)\n    try:\n        # Use ast.literal_eval for safe evaluation\n        return ast.literal_eval(list_str)\n    except Exception as e:\n        raise ValueError(f\"Unable to parse list: {e}\")\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    nums = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findMin(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode638.json",
    "problem_index_in_file": 0,
    "title": "Shopping Offers",
    "description_snippet": "In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: find minimum cost given price array, needs array, special offers array. It's LeetCode 638. Approach: DFS with memoization/backtracking or DP using recursion. We'll produce pseudocode that shows steps: define function dfs(remaining). If key in memo return. If no specials possible: sum price*remaining. Else try each offer that fits, reduce remaining and recurse, compute min. Use memo. Also base case when remaining all zero. That's the typical solution.\n\nWe need to produce step-by-step pseudocode, each line with explanation. We'll use arrows.\n\nLet's generate. We'll include initialization. Provide step for building memo key.\n\nLet's produce.\n\nEnsure we comply with \"逐行輸出\" and \"虛擬碼步驟 [空格] // 解釋\".\n\nWe should also include Start and End. We'll use \"Start\" line, then arrow lines, etc.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義全域變數 price, needs, special // 讀取題目給的價格、需求與優惠\n→ Step 2: 建立 memo 佇列 // 用於記錄已計算的剩餘需求組合對應的最小花費\n→ Step 3: 定義函式 dfs(remaining) // 以遞迴方式計算給定剩餘需求時的最小成本\n    → Decision: 是否存在已計算的 memo[鍵]? // 若鍵已存在直接回傳\n        Yes → Return memo[鍵] // 從 memo 取得已計算結果\n        No  → Continue\n    → Decision: 需求是否全為 0? // 若全部需求已滿足，成本為 0\n        Yes → memo[鍵] ← 0\n        No  → Continue\n    → Step 4: baseCost ← Σ (remaining[i] * price[i]) // 若不使用任何優惠，直接購買剩餘需求的成本\n    → Step 5: minCost ← baseCost // 初始最小成本為直接購買的成本\n    → Step 6: 對於每個優惠 offer in special\n        → Decision: offer 能否應用於 current remaining? // 所有項目需求 >= 需要的數量\n            Yes →\n                → Step 7: newRemaining ← remaining - offer 的各項目數量\n                → Step 8: costAfterOffer ← offer 價格 + dfs(newRemaining) // 遞迴計算剩餘需求的成本\n                → Decision: costAfterOffer < minCost?\n                    Yes → minCost ← costAfterOffer // 更新更低成本\n                    No  → 何也不做\n            No  → 何也不做\n    → Step 9: memo[鍵] ← minCost // 將計算結果存入 memo\n    → Step 10: Return minCost // 回傳目前剩餘需求的最小成本\n→ Step 11: Call result ← dfs(needs) // 從原始需求開始遞迴\n→ Step 12: Return result // 輸出最小總花費\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List, Tuple\n\nclass Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs: Tuple[int]) -> int:\n            if curr_needs in memo:\n                return memo[curr_needs]\n            # base cost: buy remaining items at regular price\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # try each special offer\n            for offer in special:\n                # check if offer can be applied\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    # offer fits, recurse for the remaining needs\n                    offer_cost = offer[-1] + dfs(tuple(temp))\n                    if offer_cost < res:\n                        res = offer_cost\n            memo[curr_needs] = res\n            return res\n\n        return dfs(tuple(needs))\n\ndef parse_input(raw: str) -> Tuple[List[int], List[List[int]], List[int]]:\n    \"\"\"\n    Parse input like:\n    price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\n    \"\"\"\n    # Turn assignments into dict entries\n    s = re.sub(r'(\\w+)\\s*=', r\"'\\1': \", raw.strip())\n    s = '{' + s + '}'\n    try:\n        data = ast.literal_eval(s)\n        price = data.get('price', [])\n        special = data.get('special', [])\n        needs = data.get('needs', [])\n    except Exception:\n        price = special = needs = []\n    return price, special, needs\n\ndef main() -> None:\n    raw = sys.stdin.read()\n    if not raw.strip():\n        return\n    price, special, needs = parse_input(raw)\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "success": true,
          "output": "14"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode709.json",
    "problem_index_in_file": 0,
    "title": "To Lower Case",
    "description_snippet": "Given a string s, return the string after replacing every uppercase letter with the same lowercase l...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Use arrow '→', 'Yes →', 'No →'. For string transformation: input string s, produce output string result. For each character, if uppercase, convert to lowercase else keep. Need to produce algorithm.\n\nPseudo-code: Start. Step 1: Read input string s. Step 2: Initialize result = empty string. Step 3: For each character c in s. Decision: Is c uppercase? Yes → Append lowercase of c to result. No → Append c. After loop, Step 4: Output result. End.\n\nWe need each step in one line? The instructions: \"逐行輸出\". We can have multi-step lines. For loops, we might use \"For each char in s:\". Decision block with Yes/No arrow.\n\nLet's produce:\n\nStart // 程式開始執行  \n→ Step 1: 輸入字符串 s // 從使用者取得輸入  \n→ Step 2: 初始化結果 result 為空字符串 // 用於儲存轉換後的字串  \n→ Step 3: For each 字元 c 在 s 中  \n    → Decision: 是否為大寫字母? // 判斷字元是否需要轉換  \n        Yes → Step 4: 把 c 轉成小寫後加入 result // 大寫轉小寫  \n        No  → Step 5: 把 c 直接加入 result // 非大寫保持不變  \n→ Step 6: 輸出 result // 顯示最終字串  \nEnd // 程式執行結束\n\nBut we must keep each line as a separate output line. The loop and decision blocks need indentation? The example shows indentation using spaces. We can maintain same format.\n\nEnsure each line ends with // explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字符串 s // 從使用者取得輸入  \n→ Step 2: 初始化結果 result 為空字符串 // 用於儲存轉換後的字串  \n→ Step 3: For each 字元 c 在 s 中  \n    → Decision: 是否為大寫字母? // 判斷字元是否需要轉換  \n        Yes → Step 4: 把 c 轉成小寫後加入 result // 大寫轉小寫  \n        No  → Step 5: 把 c 直接加入 result // 非大寫保持不變  \n→ Step 6: 輸出 result // 顯示最終字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef to_lowercase(s: str) -> str:\n    \"\"\"將字串中的大寫字母轉成小寫，其他字元保持不變。\"\"\"\n    result = []\n    for c in s:\n        if 'A' <= c <= 'Z':            # 判斷是否為大寫字母\n            result.append(chr(ord(c) + 32))  # 大寫轉小寫\n        else:\n            result.append(c)          # 非大寫保持不變\n    return ''.join(result)\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取資料，輸出轉換後的字串。\"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 取第一行，並尋找字串中的引號內容\n    line = data.strip()\n    match = re.search(r'\"([^\"]*)\"', line)\n    if match:\n        s = match.group(1)  # 取得引號內的內容\n    else:\n        s = line           # 若沒有引號，直接使用整行\n\n    result = to_lowercase(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello\"",
          "expected_output": "\"hello\"",
          "success": true,
          "output": "hello"
        },
        {
          "example_index": 1,
          "input": "s = \"here\"",
          "expected_output": "\"here\"",
          "success": true,
          "output": "here"
        },
        {
          "example_index": 2,
          "input": "s = \"LOVELY\"",
          "expected_output": "\"lovely\"",
          "success": true,
          "output": "lovely"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode153.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode lines describing algorithm for finding minimum in rotated sorted array using binary search O(log n). Provide each line with // explanation.\n\nWe need start, decision, etc.\n\nLet's craft.\n\nLine 1: Start // Program start\n\nLine 2: → Initialize left = 0, right = n-1 // Define search boundaries\n\nLine 3: → While left < right: // Continue narrowing until one element remains\n\nThen within loop:\n\nLine 4: →   mid = (left + right) // 2 // Calculate mid index\n\nLine 5: →   Decision: nums[mid] > nums[right]? // Determine which side contains min\n\nCase Yes: (mid element greater than rightmost, min in right half)\n\nLine 6: →       Yes → left = mid + 1 // Shift left bound beyond mid\n\nCase No: (mid <= right, min in left half including mid)\n\nLine 7: →       No  → right = mid // Keep mid as potential min, shrink right\n\nAfter loop:\n\nLine 8: → Result = nums[left] // left == right, point to minimum\n\nLine 9: → End // End program\n\nNeed include comments. Use \"Decision:\" with Yes → and No → lines.\n\nEnsure each line has virtual code step + space + // explanation. Use arrows accordingly.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ left = 0, right = n - 1 // 初始化搜尋範圍，左端點為 0，右端點為 n-1  \n→ While left < right: // 只要左右不相等就持續縮小搜尋區間  \n → mid = (left + right) // 2 // 計算中間索引  \n → Decision: nums[mid] > nums[right]? // 判斷中間元素是否比右端點大  \n  Yes → left = mid + 1 // 若 mid > right，則最小值必在右半區間，左端點移至 mid+1  \n  No  → right = mid // 若 mid ≤ right，則最小值在左半區間（包含 mid），右端點移至 mid  \n→ Result = nums[left] // 循環結束時 left == right，指向最小元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMin(self, nums):\n        \"\"\"\n        利用二分搜尋在 O(log n) 時間內找到旋轉排序陣列中的最小值。\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        # 若陣列未被旋轉，最左邊即為最小值\n        if nums[left] <= nums[right]:\n            return nums[left]\n\n        # 二分搜尋過程：縮小搜尋區間至單一元素\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                # 最小值必在右半區\n                left = mid + 1\n            else:\n                # 最小值在左半區（包含 mid）\n                right = mid\n        # left == right 時指向最小值\n        return nums[left]\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析陣列，輸出最小值。\n    支援輸入格式如 'nums = [3,4,5,1,2]' 或直接 '[3,4,5,1,2]'。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 嘗試解析「關鍵字 = 列表」格式\n    try:\n        _, list_part = data.split('=', 1)\n        nums = ast.literal_eval(list_part.strip())\n    except Exception:\n        # 若無「=」符號，直接解析整段為列表\n        nums = ast.literal_eval(data)\n\n    solution = Solution()\n    min_value = solution.findMin(nums)\n    print(min_value)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,4,5,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [11,13,15,17]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode552.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record II",
    "description_snippet": "An attendance record for a student can be represented as a string where each character signifies whe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing number of attendance records length n satisfying constraints. We should explain dynamic programming approach: states: number of As used (0 or 1), consecutive L count (0,1,2). DP[i][a][l] = count after i days. Transition add P, A, L with checks. Use mod. Complexity O(n). Provide steps. Use Start, Decision, etc. Each line is one step of algorithm: initialization, loop, inner decisions, updates, sum result. Should be line-by-line steps. Use arrow notation. We'll produce around maybe 30 lines. Provide short explanation after //.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize MOD ← 10^9 + 7 // 取模數  \n→ Initialize DP[0][0][0] ← 1 // 第 0 天，未缺席、無連續遲到的組合數為 1  \n→ Decision: 是否需要初始化其他 DP 位置? // 只需要初始化合法起始狀態  \n    Yes → End // 結束初始化  \n\n→ For i ← 1 to n: // 逐天迭代  \n    → For a ← 0 to 1: // 已缺席天數（最多 1 天）  \n        → For l ← 0 to 2: // 已連續遲到天數（最多 2 天）  \n            → Decision: 是否有合法組合 DP[i-1][a][l] > 0? // 檢查前一日狀態是否存在  \n                Yes →  \n                    → Decision: 是否可加 'P'? // 加上 Present  \n                        Yes → DP[i][a][0] ← (DP[i][a][0] + DP[i-1][a][l]) mod MOD // 連續遲到重置  \n                    → Decision: 是否可加 'A'? // 加上 Absent，只在 a < 1 時允許  \n                        Yes → DP[i][a+1][0] ← (DP[i][a+1][0] + DP[i-1][a][l]) mod MOD // 連續遲到重置  \n                    → Decision: 是否可加 'L'? // 加上 Late，只在 l < 2 時允許  \n                        Yes → DP[i][a][l+1] ← (DP[i][a][l+1] + DP[i-1][a][l]) mod MOD // 連續遲到累加  \n                No → No action // 沒有合法前置組合，跳過  \n\n→ Initialize result ← 0 // 累加所有合法結束狀態  \n→ For a ← 0 to 1:  \n    → For l ← 0 to 2:  \n        → result ← (result + DP[n][a][l]) mod MOD // 合併所有結束組合  \n\n→ Return result // 回傳符合條件的總數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\ndef count_attendance_records(n: int) -> int:\n    # dp[a][l] : number of valid sequences of current length\n    #            with a 'A's used (0 or 1) and ending with l consecutive 'L's (0..2)\n    dp = [[0] * 3 for _ in range(2)]\n    dp[0][0] = 1  # empty sequence\n\n    for _ in range(n):\n        new_dp = [[0] * 3 for _ in range(2)]\n        for a in range(2):\n            for l in range(3):\n                val = dp[a][l]\n                if val == 0:\n                    continue\n                # Add 'P' (Present) -> reset consecutive L count\n                new_dp[a][0] = (new_dp[a][0] + val) % MOD\n\n                # Add 'A' (Absent) -> only allowed if a == 0\n                if a == 0:\n                    new_dp[1][0] = (new_dp[1][0] + val) % MOD\n\n                # Add 'L' (Late) -> only allowed if l < 2\n                if l < 2:\n                    new_dp[a][l + 1] = (new_dp[a][l + 1] + val) % MOD\n\n        dp = new_dp\n\n    # Sum all valid end states\n    return sum(dp[a][l] for a in range(2) for l in range(3)) % MOD\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        n = int(data)\n        print(count_attendance_records(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "10101",
          "expected_output": "183236316",
          "success": true,
          "output": "183236316"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode334.json",
    "problem_index_in_file": 0,
    "title": "Increasing Triplet Subsequence",
    "description_snippet": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i <...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: given integer array nums, return true if there's an increasing triple subsequence.\n\nWe need to produce line-by-line virtual code with explanation. Use Start, End, Decision: etc.\n\nWe should produce algorithm, perhaps O(n) using two variables left and right: left = min value so far; right = min value of a number that is bigger than some earlier element? Actually known solution: keep a variable first = inf, second = inf. Iterate nums: if num <= first: first = num; else if num <= second: second = num; else return true. This uses two trackers.\n\nAlternatively use a stack or O(n^2). But we will implement O(n) algorithm.\n\nWe need virtual code: Start → Step 1: 初始化 first 和 second 为正无穷 // ...\n\nThen iterate each number in nums. For each: Decision: if num <= first? Then first = num. Else Decision: if num <= second? then second = num. Else return true. After loop return false.\n\nWe need to produce lines for each step. Use arrows. Each line with comment.\n\nWe must not output actual code; only virtual steps.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化 first, second 為正無限大 // 記錄到目前為止最小的第一個和第二個元素\n→ Step 2: 對 nums 中每個 num 進行迭代 // 遍歷整個陣列\n    → Decision: 如果 num <= first? // 若比第一小或相等\n        Yes → Step 3: first = num // 更新第一個元素為更小值\n        No  → Decision: 如果 num <= second? // 檢查是否比第二小\n            Yes → Step 4: second = num // 更新第二個元素為更小值\n            No  → Step 5: return true // 找到三元遞增子序列，直接返回真\n→ Step 6: return false // 完整遍歷後仍未找到，返回假\nEnd // 程式執行結束\n\nMake sure arrow usage and indentation consistent. Use \"Decision:\" lines. Indentation may need spaces to indicate sub-steps. Provide each line separated. Use '→' before each step. Provide explanation after comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 first, second 為正無限大 // 記錄到目前為止最小的第一個和第二個元素  \n→ Step 2: 對 nums 中每個 num 進行迭代 // 遍歷整個陣列  \n  → Decision: 如果 num <= first? // 檢查 num 是否比目前最小的第一個元素小  \n   Yes → Step 3: first = num // 更新第一個元素為更小值  \n   No → Decision: 如果 num <= second? // 檢查 num 是否比目前最小的第二個元素小  \n    Yes → Step 4: second = num // 更新第二個元素為更小值  \n    No → Step 5: return true // 找到 nums[i] < nums[j] < nums[k] 的三元遞增子序列，直接返回真  \n→ Step 6: return false // 完整遍歷後仍未找到，返回假  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef increasing_triplet(nums):\n    \"\"\"\n    檢查 nums 是否存在遞增三元子序列。\n    使用兩個變數 first 與 second 追蹤最小的兩個值。\n    \"\"\"\n    first = second = float('inf')\n    for num in nums:\n        if num <= first:\n            first = num          # 更新第一個最小值\n        elif num <= second:\n            second = num         # 更新第二個最小值\n        else:\n            return True          # 找到遞增三元子序列\n    return False\n\ndef main():\n    # 讀取整個 stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，例如 \"nums = [1,2,3]\"\n    if '=' in data:\n        _, arr_part = data.split('=', 1)\n    else:\n        arr_part = data\n    arr_part = arr_part.strip()\n\n    try:\n        nums = ast.literal_eval(arr_part)\n    except Exception:\n        nums = []\n\n    result = increasing_triplet(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [5,4,3,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,5,0,4,6]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode390.json",
    "problem_index_in_file": 0,
    "title": "Elimination Game",
    "description_snippet": "You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: basically Josephus problem with step=2 alternating direction each round. Equivalent to the classic problem. The solution known: last remaining is 2 * (n - 2^{floor(log2 n)}). But they want step-by-step algorithm? They want virtual code lines describing algorithm and explanation. We need to produce virtual code that implements described algorithm? We can produce algorithmic pseudo-code following the description. Use Start, Decision etc. Use arrow lines.\n\nWe need to process n, generate arr [1..n]. Then simulate elimination until one left. That is heavy but okay.\n\nBut we can also produce a more efficient algorithm. But likely want simple simulation as described. Provide virtual code steps accordingly.\n\nWe will produce: \nStart\n→ Step 1: Initialize arr as list [1..n] // create array\n→ Step 2: Set direction = leftToRight // initial direction\n→ Step 3: While length(arr) > 1 // continue until one number\n   → Decision: direction == leftToRight? // choose removal direction\n       Yes → Step 4: Remove elements starting from index 0, then every other element: // simulate\n            → Step 5: Set newArr = []\n            → Step 6: For i from 0 to length(arr)-1\n                → Decision: (i == 0) OR (i%2==0)? // keep or remove\n                    Yes → Step 7: newArr.append(arr[i]) // keep\n                    No  → // skip\n            → Step 8: arr = newArr // update\n            → Step 9: direction = rightToLeft // flip direction\n       No  → Step 10: Remove elements starting from rightmost, then every other element:\n            → Step 11: newArr = []\n            → Step 12: For i from length(arr)-1 down to 0\n                → Decision: (i == length(arr)-1) OR ((length(arr)-1 - i)%2==0)? // keep\n                    Yes → Step 13: newArr.prepend(arr[i]) // keep in correct order\n                    No  →\n            → Step 14: arr = newArr\n            → Step 15: direction = leftToRight\n→ Step 16: Return arr[0] // last number\nEnd\n\nBut we need to use virtual code with arrows. The syntax: Start, → Step: ... // comment. For loops, use Decision etc. We can simplify: Use \"Decision:\" lines. Provide nested decisions.\n\nWe must produce step-by-step with arrows. Use Start and End. Use indentation with spaces. Use `Decision:` with Yes → and No → lines.\n\nLet's craft.\n\nWe can include \"Decision: length(arr) == 1?\" etc.\n\nBetter: Outer while loop: Decision: length(arr) > 1? If Yes → proceed, No → return.\n\nInside we decide direction.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: arr ← [1, 2, ..., n] // 初始化包含 1~n 的有序陣列\n→ Step 2: direction ← leftToRight // 初始方向為左到右\n→ Decision: length(arr) == 1? // 是否已經只剩一個數字\n    Yes → Step 3: Return arr[0] // 返回唯一剩下的數字\n    No  → // 需要進行刪除循環\n        → Step 4: While true // 進行重複刪除直到只剩一個\n            → Decision: direction == leftToRight? // 判斷目前方向\n                Yes → Step 5: newArr ← [] // 建立新的陣列存放保留的數字\n                    → Step 6: For i from 0 to length(arr)-1\n                        → Decision: i == 0 OR i%2 == 0? // 第一個及每隔一個索引保留\n                            Yes → Step 7: newArr.append(arr[i]) // 加入保留數字\n                            No  → // 跳過\n                    → Step 8: arr ← newArr // 更新為保留後的陣列\n                    → Step 9: direction ← rightToLeft // 方向切換為右到左\n                No  → Step 10: newArr ← [] // 右到左方向的刪除\n                    → Step 11: For i from length(arr)-1 down to 0\n                        → Decision: i == length(arr)-1 OR (length(arr)-1 - i)%2 == 0? // 最右邊及每隔一個索引保留\n                            Yes → Step 12: newArr.prepend(arr[i]) // 加入保留數字到前面以保持順序\n                            No  → // 跳過\n                    → Step 13: arr ← newArr // 更新為保留後的陣列\n                    → Step 14: direction ← leftToRight // 方向切換為左到右\n            → Decision: length(arr) == 1? // 檢查是否已經剩下一個\n                Yes → Step 15: Break // 退出循環\n                No  → // 繼續下一輪\n→ Step 16: Return arr[0] // 最後剩下的唯一數字\nEnd // 程式結束\n\nBut we used `While true` and Break. Could use outer while condition: Decision: length(arr) > 1? -> loop. But they want `Decision:` with Yes / No. We'll use `Decision: length(arr) > 1?` Yes → continue; No → return. That might be simpler.\n\nLet's craft final version.\n\nWe need to keep indentation. Provide each line preceded by `→` or start with `Start`. For loops we can use `Decision:` as per spec. For `For` we can treat as \"Decision: i < length(arr)?\". But can keep as simple.\n\nWe need to abide by format: each line: virtual code step + space + // explanation. Use arrow and indentation spaces. Indentation can be 4 spaces? The example uses 4 spaces indentation after Decision? They used:\n\n```\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2...\n    No  → Decision: 如果數字等於 0? // ...\n        Yes → Step 3...\n```\n\nSo we need to indent Yes and No lines by 4 spaces. We'll follow that.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: arr ← [1, 2, ..., n] // 初始化陣列\n→ Step 2: direction ← leftToRight // 初始方向為左到右\n→ Decision: length(arr) == 1? // 是否只剩一個數字\n    Yes → Step 3: Return arr[0] // 回傳唯一剩下的數字\n    No  → // 開始迴圈\n        → Decision: length(arr) > 1? // 需要繼續刪除\n            Yes → // 方向判斷\n                → Decision: direction == leftToRight? // 判斷方向\n                    Yes → // 左到右刪除\n                        → Step 4: newArr ← [] // 建立新陣列\n                        → Step 5: For i from 0 to length(arr)-1\n                            → Decision: i == 0 OR i%2 == 0? // 保留第一個及每隔一個\n                                Yes → Step 6: newArr.append(arr[i]) // 加入保留\n                                No  → // 跳過\n                        → Step 7: arr ← newArr // 更新\n                        → Step 8: direction ← rightToLeft // 方向切換\n                    No  → // 右到左刪除\n                        → Step 9: newArr ← []\n                        → Step 10: For i from length(arr)-1 down to 0\n                            → Decision: i == length(arr)-1 OR (length(arr)-1 - i)%2 == 0? // 保留最右及每隔一個\n                                Yes → Step 11: newArr.prepend(arr[i]) // 加入保留\n                                No  → // 跳過\n                        → Step 12: arr ← newArr // 更新\n                        → Step 13: direction ← leftToRight // 方向切換\n                → Decision: length(arr) == 1? // 判斷是否已經只剩一個\n                    Yes → Step 14: Return arr[0] // 回傳最後一個數字\n                    No  → // 繼續下一輪\n→ End // 程式結束\n\nBut we need to maintain the structure: Start, → steps, Decision with Yes →, No →. We also need indentation of nested. For loops we treat as Decision but we can simplify.\n\nLet's produce final virtual code with consistent indentation. We'll use 4 spaces for each nested level.\n\nImportant: Each line must have the virtual code step + space + comment. The comment should be brief. So we need to keep the code step minimal.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: arr ← [1, 2, ..., n] // 初始化數組\n→ Step 2: direction ← leftToRight // 初始方向\n→ Decision: length(arr) == 1? // 是否已經只剩一個\n    Yes → Step 3: Return arr[0] // 回傳結果\n    No  → // 進入刪除循環\n        → Decision: length(arr) > 1? // 仍需繼續\n            Yes → // 判斷方向\n                → Decision: direction == leftToRight? // 左→右\n                    Yes → // 左→右刪除\n                        → Step 4: newArr ← [] // 建新陣列\n                        → Step 5: For i = 0 to length(arr)-1\n                            → Decision: i == 0 OR i%2 == 0? // 保留第一個或偶數索引\n                                Yes → Step 6: newArr.append(arr[i]) // 加入\n                                No  → // 跳過\n                        → Step 7: arr ← newArr // 更新陣列\n                        → Step 8: direction ← rightToLeft // 切換方向\n                    No  → // 右→左刪除\n                        → Step 9: newArr ← [] // 建新陣列\n                        → Step 10: For i = length(arr)-1 downto 0\n                            → Decision: i == length(arr)-1 OR (length(arr)-1 - i)%2 == 0? // 保留最右或偶距離\n                                Yes → Step 11: newArr.prepend(arr[i]) // 加入前面\n                                No  → // 跳過\n                        → Step 12: arr ← newArr // 更新陣列\n                        → Step 13: direction ← leftToRight // 切換方向\n                → Decision: length(arr) == 1? // 判斷是否只剩一個\n                    Yes → Step 14: Return arr[0] // 回傳結果\n                    No  → // 繼續循環\n→ End // 程式結束\n\nThis uses some loops but we are allowed to use For loops? They didn't specify that loops cannot be used. But we used For loops. However they used Step lines but not loops. But we can keep them as Steps.\n\nWe need to keep each line consistent: start with \"→\" then Step X: or Decision or other.\n\nAlso we need to maintain nested indentation: The Yes and No lines inside Decision are indented by 4 spaces.\n\nLet's format accordingly.\n\nWe might need to include the \"→\" before Step 4 etc. Also maintain 4 spaces indent before Yes/No lines. Example:\n\n```\n→ Decision: direction == leftToRight? // ...\n    Yes → Step 4: ...\n    No  → Step 9: ...\n```\n\nYes.\n\nAlso for loops: For i = 0 to length(arr)-1 we need to indent inside the Yes block? It will be part of the block. But we can treat For as Step too. But we need indentation inside the Yes block. Use 8 spaces indent maybe.\n\nBut we don't need to go too deep; we can keep loops at same indentation as steps in block. For readability, we can indent for loops 8 spaces relative to Decision.\n\nLet's produce final.\n\nAlso we can mention that `newArr.prepend` means add at beginning to preserve order when iterating from right. Good.\n\nLet's craft final virtual code block.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: arr ← [1, 2, …, n] // 初始化包含 1~n 的有序陣列  \n→ Step 2: direction ← leftToRight // 初始方向為左到右  \n\n→ Decision: length(arr) == 1? // 只剩一個數字了嗎？  \n    Yes → Step 3: Return arr[0] // 回傳唯一剩下的數字  \n    No  → // 進入刪除循環  \n\n        → Decision: length(arr) > 1? // 還需要繼續刪除嗎？  \n            Yes → // 根據方向決定刪除方式  \n                → Decision: direction == leftToRight? // 左 → 右？  \n                    Yes → // 左 → 右刪除  \n                        → Step 4: newArr ← [] // 建立新陣列  \n                        → Step 5: For i = 0 to length(arr)-1  \n                            → Decision: i == 0 OR i%2 == 0? // 保留第一個或每隔一個  \n                                Yes → Step 6: newArr.append(arr[i]) // 加入保留的數字  \n                                No  → // 跳過  \n                        → Step 7: arr ← newArr // 更新陣列  \n                        → Step 8: direction ← rightToLeft // 方向切換  \n                    No  → // 右 → 左刪除  \n                        → Step 9: newArr ← [] // 建立新陣列  \n                        → Step 10: For i = length(arr)-1 downto 0  \n                            → Decision: i == length(arr)-1 OR (length(arr)-1 - i)%2 == 0? // 保留最右或每隔一個  \n                                Yes → Step 11: newArr.prepend(arr[i]) // 加入前面以保持順序  \n                                No  → // 跳過  \n                        → Step 12: arr ← newArr // 更新陣列  \n                        → Step 13: direction ← leftToRight // 方向切換  \n\n                → Decision: length(arr) == 1? // 現在只剩一個數字了嗎？  \n                    Yes → Step 14: Return arr[0] // 回傳最後剩下的數字  \n                    No  → // 繼續下一輪循環  \n\n→ End // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef last_remaining(n: int) -> int:\n    \"\"\"\n    Efficiently compute the last remaining number after alternating\n    left-to-right and right-to-left deletions with step size 2.\n    \"\"\"\n    head = 1          # current head of the list\n    step = 1          # distance between remaining numbers\n    remaining = n     # numbers still in the list\n    left = True       # direction of current round\n\n    while remaining > 1:\n        # If we are going left-to-right, or we are going right-to-left\n        # and the count of remaining numbers is odd, the head moves.\n        if left or remaining % 2 == 1:\n            head += step\n        remaining //= 2\n        step *= 2\n        left = not left\n\n    return head\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        sys.exit(0)  # no integer found, nothing to do\n    n = int(match.group())\n    result = last_remaining(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 9",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode456.json",
    "problem_index_in_file": 0,
    "title": "132 Pattern",
    "description_snippet": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j]...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for 132 pattern detection. Use stack-based algorithm: traverse from right to left, keep track of possible 3rd element (max stack) and maintain current second element. Approach:\n\nInitialize second = -inf\nInitialize empty stack\nFor i from n-1 downto 0:\n if nums[i] < second: return true\n while stack not empty and stack.top() < nums[i]:\n    second = stack.pop()\n push nums[i]\nend loop\nreturn false\n\nNeed to produce virtual code steps line by line with explanations. Use Start, End, Decision, Step, etc. Must not output actual code. Provide arrow for flow. Use \"→\" after Step, etc. Each line must have \"虛擬碼步驟\" plus space then \"// 解釋\".\n\nWe should output steps:\n\nStart // start\n→ Step 1: 初始化 second = -∞ // set second element placeholder\n→ Step 2: 初始化空棧 stack // stack to store candidate 3rd elements\n→ Step 3: 從 nums 末尾到頭開始遍歷 i = n-1 downto 0 // reverse iteration\n    → Decision: nums[i] < second? // if current < second => pattern found\n        Yes → Step 4: 返回 true // pattern exists\n        No → Decision: stack 非空且 stack.top < nums[i]? // if stack top less than current, update second\n            Yes → Step 5: second = stack.pop() // update second with popped value\n            No → // nothing\n        // after potential updates\n    → Step 6: 把 nums[i] 入棧 // push current as potential third element\n// loop continues\n→ Step 7: 所有元素遍歷完畢後，返回 false // no pattern found\nEnd // 程式結束\n\nBut need proper arrow structure. For loops and decisions need indentation. Use \"→\" before each step. Use indentation: maybe spaces or tabs.\n\nWe must follow example format: \"→ Step 1: ... // ...\" and nested indent. The example uses tab indentation for nested decision. We'll replicate similar.\n\nAlso \"Decision:\" lines need to be indented. Use \"Decision:\" with a question.\n\nLet's produce lines accordingly.\n\nMake sure each line has \"虛擬碼步驟\" plus space then explanation. Example: \"Start // 程式開始執行\". So each line's code part is \"Start\" or \"→ Step 1: ...\". Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 second = -∞ // 設定 132 模式中「第二個元素」的初始值\n→ Step 2: 初始化空棧 stack // 用來保存可能成為「第三個元素」的值\n→ Step 3: 從 nums 末尾往前遍歷 i = n-1 直到 0 // 逆向掃描以便先確定後面的候選\n    → Decision: nums[i] < second? // 若當前數字小於已知的「第二個元素」，即形成 132 模式\n        Yes → Step 4: 返回 true // 找到符合條件，直接回傳真\n        No  → Decision: stack 非空且 stack.top() < nums[i]? // 若沒有即時符合，檢查棧頂是否小於當前數字\n            Yes → Step 5: second = stack.pop() // 更新「第二個元素」為棧中較大的值\n            No  → // 不更新，繼續往前\n        // 從此處回到循環主體\n    → Step 6: 把 nums[i] 入棧 // 將當前數字作為新的候選「第三個元素」推入棧中\n// 迴圈結束\n→ Step 7: 所有元素遍歷完畢後，返回 false // 未發現任何 132 模式\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def find132pattern(self, nums):\n        stack = []\n        s3 = float('-inf')\n        for num in reversed(nums):\n            if num < s3:\n                return True\n            while stack and stack[-1] < num:\n                s3 = stack.pop()\n            stack.append(num)\n        return False\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，去除前後空白\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 從輸入中擷取方括號內的列表字串\n    start = data.find('[')\n    end = data.find(']', start)\n    if start != -1 and end != -1:\n        list_str = data[start:end+1]\n    else:\n        # 若找不到列表，預設為空列表\n        list_str = '[]'\n\n    # 轉成 Python 列表\n    try:\n        nums = ast.literal_eval(list_str)\n        if not isinstance(nums, list):\n            nums = []\n    except Exception:\n        nums = []\n\n    # 呼叫解法並輸出結果\n    result = Solution().find132pattern(nums)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,3,2,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode6.json",
    "problem_index_in_file": 0,
    "title": "ZigZag Conversion",
    "description_snippet": "Convert a string to a zigzag pattern and read line by line....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nUser wants virtual code to convert a string to zigzag pattern and read line by line. This is the classic LeetCode \"ZigZag Conversion\". Need to produce step-by-step virtual code with explanations. We output line by line. Use Start, End, Decision, arrows. We should cover: if numRows <=1 return s. Create array of rows strings. Iterate over characters, determine current row and direction. Append char to appropriate row. At end, concatenate rows. Let's produce virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 若 numRows <= 1 或字串長度 <= 1，直接回傳原字串 // 針對特殊情況快速返回  \n→ Decision: 若需進行 zigzag 轉換? // 判斷是否需要繼續執行  \n    Yes → Step 2: 建立 rows[0 … numRows-1] 為空字串 // 用於存放每一行的字元  \n    → Step 3: 設定 currentRow = 0, direction = 1 // 方向：1 向下，-1 向上  \n    → Step 4: 對於字串中的每一個字元 ch  \n        → Step 5: rows[currentRow] += ch // 把字元加入對應行  \n        → Decision: currentRow == 0 或 currentRow == numRows-1? // 判斷是否需要改變方向  \n            Yes → Step 6: direction = -direction // 反轉方向  \n        → Step 7: currentRow += direction // 移動到下一行  \n    → Step 8: 初始化 result = 空字串 // 用於合併所有行  \n    → Step 9: 對於每一行 row in rows  \n        → Step 10: result += row // 將行串接到結果  \n    → Step 11: 回傳 result // 完成 zigzag 轉換  \n    No → Step 12: 回傳 s // 不需要轉換，直接回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    \"\"\"\n    將字串轉換成 zigzag（之字形）排列，然後逐行讀取。\n    \"\"\"\n    def convert(self, s: str, numRows: int) -> str:\n        # 若只需要一行，或行數超過字串長度，直接回傳原字串\n        if numRows <= 1 or numRows >= len(s):\n            return s\n\n        # 用於存放每一行的字元\n        rows = [''] * numRows\n        current_row, step = 0, 1  # step = 1 向下，-1 向上\n\n        for ch in s:\n            rows[current_row] += ch\n            # 需要改變方向時，翻轉 step\n            if current_row == 0:\n                step = 1\n            elif current_row == numRows - 1:\n                step = -1\n            current_row += step\n\n        # 把所有行串接起來即可得到最終結果\n        return ''.join(rows)\n\n\ndef parse_input(data: str):\n    \"\"\"\n    解析 stdin 內容，支援兩種常見格式：\n    1. \"s = 'PAYPALISHIRING', numRows = 3\"\n    2. 兩行：第一行為字串，第二行為整數\n    \"\"\"\n    s = None\n    numRows = None\n\n    # 嘗試第一種格式，先以逗號分段\n    parts = [p.strip() for p in data.split(',')]\n    for part in parts:\n        if part.lower().startswith('s'):\n            # 抓取引號內的字串\n            m = re.search(r\"['\\\"]([^'\\\"]*)['\\\"]\", part)\n            if m:\n                s = m.group(1)\n            else:\n                # 沒有引號，直接取等號後的部分\n                if '=' in part:\n                    s = part.split('=', 1)[1].strip()\n        elif part.lower().startswith('numrows'):\n            m = re.search(r\"(\\d+)\", part)\n            if m:\n                numRows = int(m.group(1))\n\n    # 若第一種格式解析失敗，嘗試第二種格式（兩行）\n    if s is None or numRows is None:\n        lines = [ln.strip() for ln in data.splitlines() if ln.strip()]\n        if len(lines) >= 2:\n            if s is None:\n                s = lines[0]\n            if numRows is None:\n                try:\n                    numRows = int(lines[1])\n                except ValueError:\n                    pass\n\n    # 仍未解析成功時，回傳 None\n    return s, numRows\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    s, numRows = parse_input(raw_input)\n\n    if s is None or numRows is None:\n        # 無法解析輸入，直接退出\n        sys.exit(\"Invalid input format\")\n\n    result = Solution().convert(s, numRows)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "success": true,
          "output": "PAHNAPLSIIGYIR"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode140.json",
    "problem_index_in_file": 0,
    "title": "Word Break II",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Word Break II problem. Must be line by line, each line: virtual code step + space + // explanation. Use Start, End, Decision: etc. No actual code. Just structure. Probably recursion with memoization. Provide steps: Start, preprocess wordDict to set, define helper function, etc. Use recursion with memo. Also iterate over possible splits. Use Decision to check if word in dict and recursion. Provide lines.\n\nLet's produce:\n\nStart // start\n→ Step 1: 轉換 wordDict 為集合 dictSet // 提供 O(1) 查詢\n→ Step 2: 建立 memo map // 缓存子串到句子列表\n→ Decision: 是否定義遞迴函式 helper(startIndex) // 函式分割子串\n    Yes → Step 3: 如果 startIndex == len(s) return list [''] // 基本情況，空句子\n    Yes → Decision: 如果 memo 已存在 startIndex? // 檢查緩存\n        Yes → Step 4: return memo[startIndex] // 直接回傳\n        No  → Step 5: 初始化 sentences 為空列表\n    Yes → Step 6: For end in range(startIndex+1, len(s)+1): // 嘗試所有切分\n        Decision: s[startIndex:end] 是否在 dictSet? // 判斷單詞合法\n            Yes → Step 7: recursiveList = helper(end) // 繼續分割\n            Yes → Step 8: For each subSentence in recursiveList:\n                Decision: subSentence 是否為空? // 判斷是否是最後一個單詞\n                    Yes → Step 9: sentences.append(s[startIndex:end]) // 直接加單詞\n                    No  → Step 10: sentences.append(s[startIndex:end] + ' ' + subSentence) // 加空格分隔\n            No → Step 11: continue // 該切分不合法，跳過\n    Yes → Step 12: memo[startIndex] = sentences // 缓存結果\n    Yes → Step 13: return sentences // 返回所有句子\n→ Step 14: result = helper(0) // 開始遞迴從索引0\n→ End // 程式結束並返回 result\n\nNeed to adhere to format: each line includes virtual code step + space + // explanation. Use Start, End, Decision: etc.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 轉換 wordDict 為集合 dictSet // 以 O(1) 速度檢查單詞有效性  \n→ Step 2: 建立 memo map // 用於儲存已計算的子串結果，避免重複計算  \n→ Decision: 定義遞迴函式 helper(startIndex) // 以 startIndex 為起點分割子串  \n  Yes → Step 3: 如果 startIndex == len(s) return list [''] // 基本情況，完整分割結束  \n  Yes → Decision: memo 中已存在 startIndex? // 檢查是否已計算過  \n   Yes → Step 4: return memo[startIndex] // 直接回傳緩存結果  \n   No → Step 5: 初始化 sentences 為空列表 // 用於儲存從此起點得到的所有句子  \n  Yes → Step 6: For end in range(startIndex+1, len(s)+1): // 嘗試所有可能的切分位置  \n   Decision: s[startIndex:end] 是否在 dictSet? // 判斷切出的子串是否為合法單詞  \n    Yes → Step 7: recursiveList = helper(end) // 針對剩餘子串遞迴求解  \n    Yes → Step 8: For each subSentence in recursiveList: // 合併子句與當前單詞  \n     Decision: subSentence 是否為空? // 判斷是否為最後一個單詞  \n      Yes → Step 9: sentences.append(s[startIndex:end]) // 直接加入單詞，無空格  \n      No  → Step 10: sentences.append(s[startIndex:end] + ' ' + subSentence) // 加空格連接子句  \n     No → Step 11: continue // 切分位置無效，跳過  \n  Yes → Step 12: memo[startIndex] = sentences // 將結果緩存  \n  Yes → Step 13: return sentences // 回傳此起點得到的所有句子  \n→ Step 14: result = helper(0) // 從字符串起點開始遞迴求解  \nEnd // 程式執行結束並返回 result",
      "generated_code": "import sys\nfrom typing import List, Dict\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        word_set = set(wordDict)\n        memo: Dict[int, List[str]] = {}\n\n        def backtrack(start: int) -> List[str]:\n            if start in memo:\n                return memo[start]\n\n            if start == len(s):\n                return [\"\"]\n\n            res: List[str] = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub_sentence in backtrack(end):\n                        if sub_sentence:\n                            res.append(word + \" \" + sub_sentence)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Prepare a dictionary representation from the input\n    # Example input: \"s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']\"\n    # Transform it into a Python dictionary literal.\n    transformed = raw_input.replace(\"s =\", \"s:\").replace(\"wordDict =\", \"wordDict:\")\n    if not transformed.startswith(\"{\"):\n        transformed = \"{\" + transformed + \"}\"\n    # Evaluate the transformed string safely\n    data = eval(transformed)\n\n    s: str = data[\"s\"]\n    wordDict: List[str] = data[\"wordDict\"]\n\n    solution = Solution()\n    result = solution.wordBreak(s, wordDict)\n\n    # Print the result list\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpx9n65xq7.py\", line 41, in <module>\n    data = eval(transformed)\n           ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 's' is not defined"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmphcptvyh_.py\", line 41, in <module>\n    data = eval(transformed)\n           ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 's' is not defined"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpwt3wflqh.py\", line 41, in <module>\n    data = eval(transformed)\n           ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 's' is not defined"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode396.json",
    "problem_index_in_file": 0,
    "title": "Rotate Function",
    "description_snippet": "You are given an integer array nums of length n.\n\nAssume arrk to be an array obtained by rotating nu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for computing maximum rotation function value. Provide step-by-step algorithm. Use virtual code with arrows and decision blocks. Provide explanation after each line. No actual code. Need to handle array rotation efficiently. Standard solution: compute sum of all elements S, compute initial rotation function F(0). Then iterate k from 1 to n-1 updating F(k) = F(k-1) + S - n * arr[n-k] (or similar). Keep max. Provide steps.\n\nMake sure each line has: \"虛擬碼步驟\" then space then comment. Use arrows. For loops, use \"→ For i from 1 to n-1:\". Also decision blocks for max update.\n\nLet's construct.\n\nStart // program starts\n→ Step 1: Input array nums of length n // obtain input\n→ Step 2: Compute totalSum = sum(nums[0..n-1]) // sum of all elements\n→ Step 3: Compute currentValue = sum(i * nums[i]) for i=0..n-1 // F(0)\n→ Step 4: Set maxValue = currentValue // initialize max\n→ For k from 1 to n-1:\n    → Step 5: Update currentValue = currentValue + totalSum - n * nums[n-k] // rotate effect\n    → Step 6: Decision: If currentValue > maxValue? // compare\n        Yes → Set maxValue = currentValue // update max\n        No  → No action // keep previous max\n→ End // output maxValue\n\nNeed explanation after each. Use \"→\" at each line. Provide indentation maybe. Ensure syntax. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums of length n // 從使用者處取得整數陣列  \n→ Step 2: Compute totalSum = sum(nums[0..n-1]) // 計算所有元素的總和  \n→ Step 3: Compute currentValue = sum(i * nums[i]) for i = 0 to n-1 // 計算 F(0)  \n→ Step 4: Set maxValue = currentValue // 初始化最大值為 F(0)  \n→ For k from 1 to n-1: // 依次計算 F(1)…F(n-1)  \n    → Step 5: Update currentValue = currentValue + totalSum - n * nums[n-k] // 根據旋轉公式更新 F(k)  \n    → Step 6: Decision: If currentValue > maxValue? // 判斷是否為新的最大值  \n        Yes → Set maxValue = currentValue // 更新最大值  \n        No  → No action // 保持原有最大值  \n→ End // 程式執行結束，maxValue 為答案",
      "generated_code": "import sys\nimport ast\n\ndef max_rotate_function(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    total = sum(nums)\n    current = sum(i * num for i, num in enumerate(nums))\n    max_val = current\n    # 遍歷 k = 1..n-1\n    for i in range(n - 1, 0, -1):\n        current += total - n * nums[i]\n        if current > max_val:\n            max_val = current\n    return max_val\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 可能的輸入格式：'nums = [4,3,2,6]' 或直接 '[4,3,2,6]'\n    if '=' in raw_input:\n        raw_input = raw_input.split('=', 1)[1].strip()\n    nums = ast.literal_eval(raw_input)\n    result = max_rotate_function(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "success": true,
          "output": "26"
        },
        {
          "example_index": 1,
          "input": "nums = [100]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode307.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Mutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following types:\n\nUpdate the value of an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code steps for implementing a NumArray class with update and sumRange using a data structure. We need to produce step-by-step virtual pseudocode with explanation for each line. Format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows →, Decision: etc.\n\nWe need to cover: initialization, build segment tree or Fenwick tree. Likely use Binary Indexed Tree. Provide steps: Build BIT, update operation, prefix sum, sumRange via prefix difference. Provide also class structure.\n\nThus produce:\n\nStart\n\n→ Step 1: Class NumArray // Define class\n\n→ Step 2: Property nums // store original array\n\n→ Step 3: Property bit // Binary Indexed Tree array\n\n→ Decision: If array length > 0? // check for empty\n\nYes → Step 4: Initialize bit with zeros length+1\n\n→ Step 5: For each i in nums: UpdateBIT(i+1, nums[i]) // build BIT\n\nEnd of constructor\n\n→ Step 6: Function update(index, val)\n\n→ Step 7: diff = val - nums[index] // compute difference\n\n→ Step 8: nums[index] = val // update stored array\n\n→ Step 9: UpdateBIT(index+1, diff) // update BIT\n\n→ Step 10: Function sumRange(left, right)\n\n→ Step 11: return PrefixSum(right+1) - PrefixSum(left) // inclusive sum\n\n→ Step 12: Function PrefixSum(i)\n\n→ Step 13: sum = 0\n\n→ Step 14: while i > 0: sum += bit[i]; i -= i & -i\n\n→ Step 15: return sum\n\n→ End // end of class\n\nBut must output each line with // explanation. Let's format. Use arrow lines as per format.\n\nAlso may include decision nodes: Decision: if length>0. Maybe skip. Let's produce minimal.\n\nWe must produce \"逐行\" with arrow and explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Class NumArray // 定義 NumArray 類別  \n→ Step 2: Property nums // 儲存原始陣列  \n→ Step 3: Property bit // Binary Indexed Tree (BIT) 用於快速區間和更新  \n→ Step 4: Constructor(nums) // 初始化物件  \n→ Step 5: Set this.nums = nums // 把傳入的陣列存到物件中  \n→ Step 6: Initialize this.bit = new int[nums.length + 1] // BIT 長度比陣列多 1，因為 BIT 以 1 為起點  \n→ Step 7: For i from 0 to nums.length - 1 // 逐個插入數值到 BIT，建構初始樹  \n→ Step 8:   Call UpdateBIT(i + 1, nums[i]) // BIT 位置使用 i+1 以配合 1‑index  \n→ Step 9: End For // 建樹完成  \n→ Step 10: End Constructor // 建構子結束  \n→ Step 11: Function update(index, val) // 公開更新方法  \n→ Step 12:   diff = val - this.nums[index] // 計算值差，用於 BIT 更新  \n→ Step 13:   this.nums[index] = val // 更新原始陣列  \n→ Step 14:   Call UpdateBIT(index + 1, diff) // 在 BIT 中累加差值  \n→ Step 15: End Function // update 完成  \n→ Step 16: Function sumRange(left, right) // 公開區間和方法  \n→ Step 17:   return PrefixSum(right + 1) - PrefixSum(left) // 包含左端點，右端點 +1 後求前綴和差  \n→ Step 18: End Function // sumRange 完成  \n→ Step 19: Private Function PrefixSum(i) // 計算前綴和，參數為 BIT 索引  \n→ Step 20:   sum = 0 // 初始和  \n→ Step 21:   While i > 0 // BIT 迴圈，從 i 向上走  \n→ Step 22:     sum += this.bit[i] // 加入目前節點值  \n→ Step 23:     i = i - (i & -i) // 移動到上一個影響節點  \n→ Step 24:   End While  \n→ Step 25:   Return sum // 返回前綴和  \n→ Step 26: End Function // PrefixSum 完成  \n→ Step 27: Private Function UpdateBIT(i, delta) // BIT 的更新子程式  \n→ Step 28:   While i <= this.bit.length - 1 // 只更新有效範圍內節點  \n→ Step 29:     this.bit[i] += delta // 累加差值  \n→ Step 30:     i = i + (i & -i) // 移動到下一個影響節點  \n→ Step 31:   End While  \n→ Step 32: End Function // UpdateBIT 完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]  # keep a copy of the original array\n        # Binary Indexed Tree (Fenwick Tree) of size n+1 (1-indexed)\n        self.tree = [0] * (self.n + 1)\n        for i, val in enumerate(nums):\n            self._update_tree(i + 1, val)\n\n    def _update_tree(self, i, val):\n        \"\"\"Internal helper to add `val` to index `i` in the BIT.\"\"\"\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        \"\"\"Update nums[index] to new value `val`.\"\"\"\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        \"\"\"Return sum of nums[left:right+1].\"\"\"\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        \"\"\"Internal helper to compute prefix sum up to index `i` (1-indexed).\"\"\"\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap the two lists into a single JSON array for easy parsing\n    wrapped = '[' + data + ']'\n    ops, args = json.loads(wrapped)\n\n    obj = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == 'NumArray':\n            # arg is a list like [[1, 3, 5]] – take its first element\n            obj = NumArray(arg[0])\n            results.append(None)\n        elif op == 'update':\n            obj.update(arg[0], arg[1])\n            results.append(None)\n        elif op == 'sumRange':\n            results.append(obj.sumRange(arg[0], arg[1]))\n        else:\n            # ignore unknown operations\n            results.append(None)\n\n    # Print results as JSON so `None` becomes `null`\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "success": true,
          "output": "[null, 9, null, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode342.json",
    "problem_index_in_file": 0,
    "title": "Power of Four",
    "description_snippet": "Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanations. The requirement: output should be step by step. Use virtual code arrow. The problem: given integer n, return true if power of four else false.\n\nSo algorithm: check if n > 0 and (n & (n-1)) == 0 (only one bit set), and also check that the bit is in positions that are multiples of 2 (i.e., 1 << k where k mod 2 == 0). Since 4^x = 1 << (2x). So we can check if n > 0, n is power of two, and bit position is even. Implementation: we can get bit position with log2(n). Alternatively, we can check using mask: n & 0x55555555 (binary pattern of 0101...). So if n > 0 and n & (n-1) == 0 and n & 0x55555555 != 0. Or simpler: use while loop dividing by 4: while n % 4 == 0 n /= 4. But virtual code can use simple logic.\n\nWe'll produce virtual code lines:\n\nStart\n→ Decision: n > 0? \nYes → Step: if (n & (n-1)) == 0? \nYes → Decision: n & 0x55555555 != 0? \nYes → Step: return true\nNo → Step: return false\nNo (previous) → Step: return false\nEnd\n\nAlternatively we can include steps to compute bit mask.\n\nWe'll produce virtual code step by step. Provide explanation after each line.\n\nWe need to ensure to use arrow style: \"→ Step 1: ...\". Use \"Decision:\" lines. Provide indentation.\n\nLet's craft.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Decision: n 是否大於 0? // 檢查是否為正整數\n    Yes → Decision: n 是否為 2 的冪? // 只需檢查是否僅有一個位元為 1\n        Yes → Decision: n 的位元位置是否為偶數? // 4 的冪位於 2x 位置\n            Yes → Step: return true // 是 4 的冪\n            No  → Step: return false // 位元位置為奇數，不是 4 的冪\n        No  → Step: return false // 不是 2 的冪，無法為 4 的冪\n    No  → Step: return false // n 為非正數，直接 false\nEnd // 程式執行結束\n\nBut we need to mention using mask 0x55555555. So we can express bit position check as n & 0x55555555 != 0.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: n > 0? // 檢查輸入是否正整數\n    Yes → Decision: (n & (n-1)) == 0? // 判斷是否為 2 的冪\n        Yes → Decision: (n & 0x55555555) != 0? // 檢查位元是否在偶數位置\n            Yes → Step: return true // n 為 4 的冪\n            No  → Step: return false // 不是 4 的冪\n        No  → Step: return false // 不是 2 的冪，故不是 4 的冪\n    No  → Step: return false // n 為非正數\nEnd // 程式結束\n\nAlso we could include \"Step: compute mask\" but not necessary.\n\nThe requirement: each line includes code and explanation. Use the arrow. Use indentation for decisions. Good.\n\nReturn lines accordingly.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: n > 0? // 檢查輸入是否為正整數\n    Yes → Decision: (n & (n-1)) == 0? // 判斷 n 是否為 2 的冪（只有一個位元為 1）\n        Yes → Decision: (n & 0x55555555) != 0? // 檢查該位元是否位於偶數位置（4 的冪位於 2x 位）\n            Yes → Step: return true // n 為 4 的冪，回傳 true\n            No  → Step: return false // 位元位置為奇數，不是 4 的冪，回傳 false\n        No  → Step: return false // n 不是 2 的冪，直接回傳 false\n    No  → Step: return false // n 為非正數，回傳 false\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        # n must be positive\n        if n <= 0:\n            return False\n        # n must be power of two (only one bit set)\n        if n & (n - 1):\n            return False\n        # for powers of four, the single set bit must be in an even position\n        # equivalently, n-1 is divisible by 3\n        return (n - 1) % 3 == 0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Attempt to extract integer from input\n    if '=' in data:\n        try:\n            n = int(data.split('=')[-1].strip())\n        except ValueError:\n            # fallback: find first integer in the string\n            import re\n            match = re.search(r'-?\\d+', data)\n            n = int(match.group()) if match else 0\n    else:\n        try:\n            n = int(data)\n        except ValueError:\n            import re\n            match = re.search(r'-?\\d+', data)\n            n = int(match.group()) if match else 0\n\n    solution = Solution()\n    result = solution.isPowerOfFour(n)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode327.json",
    "problem_index_in_file": 0,
    "title": "Count of Range Sum",
    "description_snippet": "Given an integer array nums and two integers lower and upper, return the number of range sums that l...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: count range sums within [lower, upper] in an integer array. Typical solution: prefix sums + divide and conquer or BIT. Use prefix sums and merge sort counting. So we output virtual code line by line with explanation.\n\nWe must output in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrows →, Decision etc.\n\nWe need to produce the steps of algorithm: compute prefix sums, count via merge sort. Let's produce pseudocode lines.\n\nWe start: Start. Compute prefix array of size n+1. Then define recursive function countAndMerge(l, r). In base case l==r return 0. Else mid = (l+r)/2. Count left, count right. Then count cross. Use two pointers. Then merge. Return total.\n\nLet's produce lines accordingly.\n\nMake sure each line uses \"→\" etc. We'll produce the structure.\n\nWe'll provide pseudocode lines with Chinese comments.\n\nLet's craft: \n\nStart // 程式開始執行\n→ Step 1: 計算前綴和 pref[0] = 0 // 初始化前綴和\n→ Decision: 迭代 i 0..n-1 // 逐一計算前綴和\n    Yes → Step 2: pref[i+1] = pref[i] + nums[i] // 前綴和遞增\n\nThen define recursive function:\n\n→ Step 3: 定義函式 count(l, r) // 計算區間 [l, r) 的符合範圍數量\n\nInside function:\n\n→ Step 4: 若 l + 1 == r // 只有一個元素\n    → Decision: 是否 pref[r] - pref[l] 在 [lower, upper]?\n        Yes → Step 5: return 1 // 只要符合即返回 1\n        No  → Step 6: return 0 // 不符合則返回 0\n\nElse: mid = (l+r)/2\n\n→ Step 7: leftCount = count(l, mid) // 計算左半區域\n→ Step 8: rightCount = count(mid, r) // 計算右半區域\n\nThen count cross ranges. Use two pointers j1, j2 for each k in [mid, r):\n\n→ Step 9: 初始化 j1 = j2 = mid // 指標用於尋找界限\n→ Step 10: cross = 0 // 交叉區間計數\n→ Decision: 對 k 從 mid 到 r-1\n    Yes → Step 11: while j1 < r 且 pref[j1] - pref[k] < lower: j1++ // 移動到最低合法\n    Yes → Step 12: while j2 < r 且 pref[j2] - pref[k] <= upper: j2++ // 移動到最高合法\n    Yes → Step 13: cross += j2 - j1 // 加上符合 k 的個數\n\nThen merge sorted pref[l:r] by merge sort:\n\n→ Step 14: merge pref[l:mid] 與 pref[mid:r] 為升序 // 為後續計算保持排序\n\nReturn total = leftCount + rightCount + cross\n\nFinally:\n\n→ Step 15: total = count(0, n+1) // 從全域前綴和區間計算\n→ Step 16: 輸出 total // 結果\n\nEnd.\n\nMake sure each line includes arrow or Decision. Use the format: \"虛擬碼步驟 // 解釋\".\n\nAlso use \"Yes →\" \"No →\". For loops maybe use Decision for loop? Might just use \"Decision: 對 k 從 mid 到 r-1\". Might need to break into steps.\n\nLet's produce accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: pref[0] ← 0 // 初始化前綴和陣列  \n→ Decision: 迭代 i 0..n-1 // 逐一計算前綴和  \n    Yes → Step 2: pref[i+1] ← pref[i] + nums[i] // 前綴和遞增  \n\n→ Step 3: 定義函式 count(l, r) // 計算區間 [l, r) 的符合範圍數量  \n\n→ Step 4: 如果 l + 1 == r // 只有一個元素  \n    Yes → Decision: 是否 pref[r] - pref[l] 在 [lower, upper]?  \n        Yes → Step 5: return 1 // 只要符合即返回 1  \n        No → Step 6: return 0 // 不符合則返回 0  \n\n→ Step 7: mid ← (l + r) / 2 // 取中點  \n→ Step 8: leftCount ← count(l, mid) // 計算左半區域  \n→ Step 9: rightCount ← count(mid, r) // 計算右半區域  \n\n→ Step 10: j1 ← mid // 指標用於尋找 lower 邊界  \n→ Step 11: j2 ← mid // 指標用於尋找 upper 邊界  \n→ Step 12: cross ← 0 // 交叉區間計數器  \n\n→ Decision: 對 k 從 mid 到 r-1  \n    Yes → Step 13: while j1 < r 且 pref[j1] - pref[k] < lower: j1++ // 移動到最低合法  \n    Yes → Step 14: while j2 < r 且 pref[j2] - pref[k] ≤ upper: j2++ // 移動到最高合法  \n    Yes → Step 15: cross ← cross + (j2 - j1) // 加上符合 k 的個數  \n\n→ Step 16: merge pref[l:mid] 與 pref[mid:r] 為升序 // 以維持後續計算的前綴和排序  \n\n→ Step 17: return leftCount + rightCount + cross // 回傳本區間總數  \n\n→ Step 18: total ← count(0, n+1) // 從全域前綴和區間計算  \n→ Step 19: 輸出 total // 結果  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n            i = j = mid\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 使用正則表達式擷取 nums、lower、upper\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*lower\\s*=\\s*(-?\\d+)\\s*,\\s*upper\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        # 如果格式不符合，直接輸出 0\n        print(0)\n        sys.exit()\n\n    nums_str, lower_str, upper_str = match.groups()\n    nums = ast.literal_eval(nums_str)\n    lower = int(lower_str)\n    upper = int(upper_str)\n\n    sol = Solution()\n    result = sol.countRangeSum(nums, lower, upper)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0], lower = 0, upper = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode228.json",
    "problem_index_in_file": 0,
    "title": "Summary Ranges",
    "description_snippet": "You are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm. Steps: start, init, iterate through array, keep start and prev. When next is not prev+1 start new range, output previous range. At end output last. Output format string. Use Decision, etc.\n\nLet's write lines:\n\nStart // 程式開始執行\n→ Step 1: If nums is empty, output empty list // 空陣列處理\n→ Decision: nums 是否為空? // 判斷是否需要返回空列表\n    Yes → Step 2: 輸出空列表 // 空輸出\n    No  → Step 3: 初始化 start = nums[0], prev = nums[0] // 設定起始點\n→ For i from 1 to length(nums)-1: // 逐個遍歷陣列\n    → Step 4: current = nums[i] // 取得當前數字\n    → Decision: current 是否等於 prev + 1? // 判斷是否連續\n        Yes → Step 5: 將 prev 設為 current // 連續，更新 prev\n        No  → Decision: start 是否等於 prev? // 判斷範圍是否單一\n            Yes → Step 6: 輸出 str(start) // 單一數字輸出\n            No  → Step 7: 輸出 str(start) + \"->\" + str(prev) // 輸出範圍\n        No → Step 8: start = current, prev = current // 開始新範圍\n→ End For\n→ Step 9: Decision: start 是否等於 prev? // 最後一個範圍判斷\n    Yes → Step 10: 輸出 str(start) // 單一數字輸出\n    No  → Step 11: 輸出 str(start) + \"->\" + str(prev) // 輸出範圍\nEnd // 程式執行結束\n\nNeed to use arrow formatting. Ensure each line has explanation. Use \"Step\" etc. Provide in order. Ok.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 如果 nums 為空，輸出空列表 // 空陣列直接返回空結果\n→ Decision: nums 是否為空? // 判斷是否需要跳過後續邏輯\n    Yes → Step 2: 輸出 [] // 空列表輸出\n    No  → Step 3: 初始化 start = nums[0], prev = nums[0] // 設定第一個元素為起始點與前一個元素\n→ For i from 1 to length(nums)-1: // 遍歷陣列中剩餘的元素\n    → Step 4: current = nums[i] // 取得目前迭代的數字\n    → Decision: current 是否等於 prev + 1? // 檢查是否連續\n        Yes → Step 5: 將 prev 設為 current // 連續，更新前一個元素為目前元素\n        No  → Decision: start 是否等於 prev? // 判斷目前區間是否只包含單一數字\n            Yes → Step 6: 輸出 str(start) // 單一數字直接輸出\n            No  → Step 7: 輸出 str(start) + \"->\" + str(prev) // 輸出區間範圍\n        No → Step 8: start = current, prev = current // 開始新的區間，重置起點與前一個元素\n→ End For\n→ Step 9: Decision: start 是否等於 prev? // 最後一個區間的判斷\n    Yes → Step 10: 輸出 str(start) // 最後區間為單一數字輸出\n    No  → Step 11: 輸出 str(start) + \"->\" + str(prev) // 最後區間為範圍輸出\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def summaryRanges(self, nums):\n        if not nums:\n            return []\n        res = []\n        start = end = nums[0]\n        for n in nums[1:]:\n            if n == end + 1:\n                end = n\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(f\"{start}->{end}\")\n                start = end = n\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(f\"{start}->{end}\")\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # Extract the list part from input like 'nums = [0,1,2,4,5,7]'\n    try:\n        left = data.index('[')\n        right = data.rindex(']')\n        list_str = data[left:right+1]\n        nums = ast.literal_eval(list_str)\n    except (ValueError, SyntaxError):\n        # If parsing fails, treat entire input as a list\n        nums = ast.literal_eval(data.strip())\n    solution = Solution()\n    ranges = solution.summaryRanges(nums)\n    print(json.dumps(ranges))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,2,4,5,7]",
          "expected_output": "[\"0->2\",\"4->5\",\"7\"]",
          "success": true,
          "output": "[\"0->2\", \"4->5\", \"7\"]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,2,3,4,6,8,9]",
          "expected_output": "[\"0\",\"2->4\",\"6\",\"8->9\"]",
          "success": true,
          "output": "[\"0\", \"2->4\", \"6\", \"8->9\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode731.json",
    "problem_index_in_file": 0,
    "title": "My Calendar II",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, for the described functionality: MyCalendarTwo with booking that allows at most double booking. Typical solution uses two arrays of intervals: one for single bookings, one for double bookings. For each new event, check against double bookings; if overlaps any double -> reject. Then for overlaps with single bookings, add overlap to double bookings. Then add event to single bookings. This is typical. We need to output step-by-step pseudo-code.\n\nWe need to start with Start, then implement constructor, book method, etc. Use arrow formatting.\n\nLet's produce pseudo-code:\n\nStart\n→ Step 1: Define class MyCalendarTwo\n→ Step 2: Initialize list singleBookings // stores all accepted events\n→ Step 3: Initialize list doubleBookings // stores all intervals that are double booked\n→ End\n\nThen define method book(start, end):\n→ Step 4: For each interval in doubleBookings:\n    → Decision: if overlap(start,end,interval) ?\n        Yes → Return false // triple booking\n        No  → continue\n→ Step 5: For each interval in singleBookings:\n    → Decision: if overlap(start,end,interval) ?\n        Yes → Add overlap to doubleBookings // create new double interval\n        No  → continue\n→ Step 6: Add [start,end] to singleBookings\n→ Step 7: Return true\n\nNeed to define overlap function: overlap(a,b,c,d) = max(a,c) < min(b,d). We'll implement inline.\n\nWe need to use arrow style for decisions. We'll format each line accordingly.\n\nMake sure to include comments.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Define class MyCalendarTwo // 建立日曆類別\n→ Step 2: 在建構子中初始化 singleBookings 為空列表 // 儲存所有已加入的事件\n→ Step 3: 在建構子中初始化 doubleBookings 為空列表 // 儲存所有雙重重疊的時間區間\n→ End // 建構子結束\n\n→ Step 4: 定義方法 book(start, end) // 嘗試加入新事件\n    → Decision: 是否有 triple booking ？ // 檢查與現有雙重區間的重疊\n        Yes → Return false // 與任何雙重區間重疊，會成為 triple booking\n        No  → 繼續\n\n    → Step 5: 依序檢查每個單一區間是否與新區間重疊\n        → Decision: 是否重疊？ // 若重疊，則新增一個雙重區間\n            Yes → Step 6: 計算 overlap = [max(start, s), min(end, e)] // 取得重疊區間\n                  → Step 7: 將 overlap 加入 doubleBookings // 紀錄新的雙重區間\n            No  → 繼續\n\n    → Step 8: 將 [start, end] 加入 singleBookings // 成功加入事件\n    → Step 9: Return true // 事件加入成功\n\nEnd // 程式結束\n\nBut we need each line to be a separate line with arrow and comment. But our lines above contain nested arrows. Might need to format properly.\n\nWe need to use arrow lines for decisions: `Decision: ...` with Yes/No branches.\n\nLet's produce each line as separate. Eg:\n\nStart // 程式開始執行\n→ Step 1: Define class MyCalendarTwo // 建立日曆類別\n→ Step 2: MyCalendarTwo() { // 建構子\n→ Step 3:     singleBookings ← empty list // 儲存已加入事件\n→ Step 4:     doubleBookings ← empty list // 儲存雙重重疊區間\n→ Step 5: } // 建構子結束\n→ Step 6: boolean book(start, end) { // 嘗試加入新事件\n→ Step 7:     for each (s, e) in doubleBookings { // 檢查 triple booking\n→ Step 8:         if max(start, s) < min(end, e) { // 有重疊\n→ Step 9:             return false // 會成 triple booking\n→ Step 10:        }\n→ Step 11:    }\n→ Step 12:    for each (s, e) in singleBookings { // 檢查 double booking\n→ Step 13:        if max(start, s) < min(end, e) { // 有重疊\n→ Step 14:            overlapStart ← max(start, s)\n→ Step 15:            overlapEnd ← min(end, e)\n→ Step 16:            doubleBookings.add(overlapStart, overlapEnd)\n→ Step 17:        }\n→ Step 18:    }\n→ Step 19:    singleBookings.add(start, end)\n→ Step 20:    return true\n→ Step 21: } // 方法結束\nEnd // 程式結束\n\nBut we must include arrows and decisions as guidelines: Use `Decision:` lines with Yes/No. But the example uses indentation with Yes/No arrows. They want to use `Decision:` lines.\n\nWe can incorporate decision lines:\n\n→ Step 7: Decision: 任何 doubleBookings 與 [start,end] 重疊? // 檢查是否 triple booking\n    Yes → Step 8: Return false // 有 triple booking\n    No  → Step 9: 進一步檢查 singleBookings\n\nBut we need to produce each line separately. For the decisions we can embed in the same line? The example shows:\n\nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nSo we can mimic this structure. For each decision, we need separate lines for the decision line and the Yes/No branches with arrows.\n\nLet's craft accordingly.\n\nWe need to include lines for constructing the class and methods.\n\nLet's produce pseudo-code:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 MyCalendarTwo // 建立日曆類別\n→ Step 2: MyCalendarTwo() { // 建構子\n→ Step 3:     singleBookings ← [] // 儲存已加入事件\n→ Step 4:     doubleBookings ← [] // 儲存雙重重疊區間\n→ Step 5: } // 建構子結束\n→ Step 6: boolean book(int start, int end) { // 嘗試加入新事件\n→ Step 7:     Decision: 是否存在 doubleBookings 與 [start,end] 重疊? // 檢查 triple booking\n        Yes → Step 8: Return false // 會形成 triple booking\n        No  → Step 9: 進行單一區間檢查\n→ Step 10:    for each (s, e) in singleBookings { // 檢查雙重重疊\n→ Step 11:        Decision: [start,end] 與 (s,e) 重疊? // 是否產生 double booking\n            Yes → Step 12: overlapStart ← max(start, s) // 計算重疊起點\n                Step 13: overlapEnd ← min(end, e) // 計算重疊終點\n                Step 14: doubleBookings.add(overlapStart, overlapEnd) // 加入雙重區間\n            No  → Step 15: // 無重疊，繼續\n→ Step 16:    } // 迴圈結束\n→ Step 17:    singleBookings.add(start, end) // 加入新事件\n→ Step 18:    Return true // 成功加入\n→ Step 19: } // 方法結束\nEnd // 程式結束\n\nMake sure each line has arrow, comment after //. Ensure indentation for decisions. The example uses indentation with Yes → and No → lines. We need to include indentation for Yes/No branches after the Decision line.\n\nAlso, each line must start with either Start/End or arrow. For step lines: `→ Step X:`. For decisions: `Decision:`. For Yes/No branches: `Yes → Step X:` etc.\n\nMake sure no actual code. Use pseudo names.\n\nNow output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MyCalendarTwo // 建立日曆類別  \n→ Step 2: MyCalendarTwo() { // 建構子  \n→ Step 3:     singleBookings ← [] // 儲存已加入事件的區間  \n→ Step 4:     doubleBookings ← [] // 儲存已發生雙重重疊的區間  \n→ Step 5: } // 建構子結束  \n→ Step 6: boolean book(int start, int end) { // 嘗試加入新事件  \n→ Step 7:     Decision: 是否存在 doubleBookings 與 [start,end] 重疊? // 檢查是否會形成 triple booking  \n        Yes → Step 8: Return false // 會造成 triple booking，拒絕加入  \n        No  → Step 9: 進行單一區間檢查  \n→ Step 10:    for each (s, e) in singleBookings { // 遍歷已加入的事件  \n→ Step 11:        Decision: [start,end] 與 (s,e) 重疊? // 是否會產生 double booking  \n            Yes → Step 12: overlapStart ← max(start, s) // 計算重疊起點  \n                Step 13: overlapEnd ← min(end, e) // 計算重疊終點  \n                Step 14: doubleBookings.add(overlapStart, overlapEnd) // 將重疊區間加入 doubleBookings  \n            No  → Step 15: // 無重疊，繼續下一個事件  \n→ Step 16:    } // 迴圈結束  \n→ Step 17:    singleBookings.add(start, end) // 將新事件加入 singleBookings  \n→ Step 18:    Return true // 成功加入事件  \n→ Step 19: } // 方法結束  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass MyCalendarTwo:\n    def __init__(self):\n        # 所有已成功加入的事件\n        self.booked = []\n        # 產生雙重重疊的區間\n        self.overlaps = []\n\n    def book(self, start: int, end: int) -> bool:\n        # 先檢查是否會形成 triple booking\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n        # 再檢查與單一事件的重疊，產生雙重重疊區間\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n        # 最後把新事件加入\n        self.booked.append((start, end))\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將兩個頂層列表分開：方法列表和參數列表\n    parts = data.split('],', 1)\n    methods = ast.literal_eval(parts[0] + ']')\n    args = ast.literal_eval(parts[1])\n\n    results = []\n    calendar = None\n    for method, arg in zip(methods, args):\n        if method == 'MyCalendarTwo':\n            calendar = MyCalendarTwo()\n            results.append(None)\n        elif method == 'book':\n            results.append(calendar.book(arg[0], arg[1]))\n    # 印出結果\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,true,true]'\nGot (Norm):      '[None,True,True,True,False,True,True]'\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, true, true]'\nRaw Got:      '[None, True, True, True, False, True, True]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode560.json",
    "problem_index_in_file": 0,
    "title": "Subarray Sum Equals K",
    "description_snippet": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that compute number of subarrays with sum k. Use prefix sums and hash map approach. Steps: initialize count = 0, prefixSum=0, hashmap with 0:1. Iterate array, add element to prefixSum, compute needed=prefixSum-k, if hashmap contains needed add its value to count, then increment hashmap for prefixSum. Finally return count.\n\nWe must output line by line with \"→ Step\" etc. Provide explanation comment. Use arrow, Decision. For loops. Provide Start, End.\n\nLet's design.\n\nStart\n→ Step 1: 初始化 count = 0, prefixSum = 0, hashMap = {0:1} // 初始化計數、前綴和與哈希表\n→ Step 2: 遍歷 nums 中的每個元素 num // 逐個處理數組元素\n    → Step 3: prefixSum = prefixSum + num // 更新前綴和\n    → Step 4: needed = prefixSum - k // 計算目標子陣列的前綴和差值\n    → Decision: hashMap 中是否包含 needed? // 判斷是否存在已經出現的前綴和能完成子陣列和為 k\n        Yes → Step 5: count = count + hashMap[needed] // 將符合子陣列數量累加\n        No  → // 沒有匹配，直接跳過\n    → Step 6: hashMap[prefixSum] = hashMap.get(prefixSum, 0) + 1 // 更新哈希表，記錄新的前綴和\n→ Step 7: return count // 輸出總數量\nEnd\n\nBut we need to include decisions lines with Yes → and No →, but also the lines under each. Ensure proper indentation. In sample they used indentation spaces.\n\nWe will produce accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 count = 0, prefixSum = 0, hashMap = {0:1} // 設定計數器、前綴和與哈希表（key: 前綴和, value: 出現次數）  \n→ Step 2: 遍歷 nums 中的每個元素 num // 逐個處理數組元素  \n    → Step 3: prefixSum = prefixSum + num // 累加前綴和  \n    → Step 4: needed = prefixSum - k // 計算可滿足子陣列和為 k 的前綴和差值  \n    → Decision: hashMap 中是否包含 needed? // 檢查是否已存在可完成子陣列和的前綴和  \n        Yes → Step 5: count = count + hashMap[needed] // 若存在，將符合子陣列數量累加到 count  \n        No  → // 若不存在，跳過此步  \n    → Step 6: hashMap[prefixSum] = hashMap.get(prefixSum, 0) + 1 // 更新哈希表，記錄新前綴和的出現次數  \n→ Step 7: return count // 輸出總計數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef subarray_sum(nums, k):\n    \"\"\"Return the number of subarrays whose sum equals k.\"\"\"\n    count = 0\n    prefix_sum = 0\n    sum_map = {0: 1}  # prefix sum 0 occurs once\n\n    for num in nums:\n        prefix_sum += num\n        needed = prefix_sum - k\n        if needed in sum_map:\n            count += sum_map[needed]\n        sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n    return count\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Example input format: \"[1,1,1], k = 2\"\n    parts = raw_input.split(',', 1)\n    list_part = parts[0].strip()\n    k_part = parts[1] if len(parts) > 1 else ''\n\n    # Parse the list of numbers safely\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        print(\"0\")\n        sys.exit()\n\n    # Extract integer k from the second part\n    if '=' in k_part:\n        k_str = k_part.split('=')[1].strip()\n        try:\n            k = int(k_str)\n        except ValueError:\n            k = 0\n    else:\n        k = 0\n\n    result = subarray_sum(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode600.json",
    "problem_index_in_file": 0,
    "title": "Non-negative Integers without Consecutive Ones",
    "description_snippet": "Given a positive integer n, return the number of the integers in the range [0, n] whose binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. For this problem, typical solution uses Fibonacci DP. We need steps: read n, compute binary length, DP arrays, iterate bits, accumulate count. Steps: determine bits, set dp[0]=1 dp[1]=2? Let's think. For length L bits, count of strings without consecutive ones of length L is fib(L+2). But we need to count numbers <= n. Standard algorithm: iterate bits from MSB to LSB, maintain prev bit. When encountering bit=1, add dp[pos] where pos is remaining bits count. At end if no consecutive ones in n, add 1. Also handle zero.\n\nLet's produce pseudo code lines:\n\nStart // 程式開始執行\n→ Step 1: Input integer n // 取得輸入\n→ Decision: If n == 0? // 特殊情況\n    Yes → Step 2: Output 1 // 0 本身不含連續 1\n    No  → Step 3: Compute binary string bits of n // 取得 n 的二進位表示\n→ Step 4: Let L = length of bits // 位元長度\n→ Step 5: Initialize dp[0] = 1, dp[1] = 2 // dp[i] 表示長度 i 的合法字串數\n→ Step 6: For i from 2 to L: dp[i] = dp[i-1] + dp[i-2] // Fibonacci recurrence\n→ Step 7: Set count = 0 // 結果累計\n→ Step 8: Set prev = 0 // 前一個位元\n→ Step 9: For pos from 0 to L-1: // 逐位檢查\n    → Decision: If bits[pos] == '1'? // 現位元為 1\n        Yes → Step 10: count += dp[L - pos - 1] // 加上在此位置為 0 的合法組合\n        Yes → Step 11: If prev == 1? // 前一位也是 1，會有連續 1\n            Yes → Step 12: Output count // 結束，因為超過 n\n            No  → Step 13: prev = 1 // 更新前一位為 1\n        No  → Step 14: prev = 0 // 位元為 0，更新\n→ Step 15: Output count + 1 // 加上 n 本身 (若沒有連續 1)\nEnd // 程式結束\n\nNeed to ensure that we add final 1 only if no consecutive ones. The loop will break if we output count early. We need a flag or return. We'll produce lines accordingly.\n\nLet's produce final output with each line. Ensure proper formatting.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input integer n // 從使用者取得正整數  \n→ Decision: 如果 n 等於 0? // 特殊情況  \n Yes → Step 2: Output 1 // 0 本身不含連續 1，直接回傳  \n No  → Step 3: 取得 n 的二進位字串 bits // 以便逐位處理  \n→ Step 4: Let L = length(bits) // 取得位元長度  \n→ Step 5: 初始化 dp[0] = 1, dp[1] = 2 // dp[i] 為長度 i 的合法字串數  \n→ Step 6: For i 從 2 到 L: dp[i] = dp[i-1] + dp[i-2] // Fibonacci 迭代  \n→ Step 7: 設 count = 0 // 累計符合條件的數量  \n→ Step 8: 設 prev = 0 // 前一位元初始為 0  \n→ Step 9: For pos 從 0 到 L-1: // 逐位檢查  \n  Decision: 如果 bits[pos] 為 '1'? // 目前位元為 1  \n   Yes → Step 10: count += dp[L - pos - 1] // 若此位設 0，剩餘位可任意合法排列  \n   Yes → Decision: 如果 prev == 1? // 前一位也是 1，形成連續 1  \n    Yes → Step 11: Output count // 超過 n，直接回傳結果  \n    No  → Step 12: prev = 1 // 更新前一位為 1  \n   No  → Step 13: prev = 0 // 位元為 0，更新前一位為 0  \n→ Step 14: Output count + 1 // 若整個 n 沒有連續 1，將 n 本身計入  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findIntegers(self, n: int) -> int:\n        \"\"\"\n        Return the count of integers in [0, n] whose binary representations\n        do not contain consecutive ones.\n        \"\"\"\n        # dp[i] = number of binary strings of length i that contain no consecutive 1s\n        dp = [0] * 32\n        dp[0] = 1\n        dp[1] = 2  # \"0\" and \"1\"\n        for i in range(2, 32):\n            dp[i] = dp[i - 1] + dp[i - 2]  # Fibonacci recurrence\n\n        ans = 0\n        prev_bit = 0\n        # Iterate over bit positions from 30 down to 0 (since n <= 2^31-1)\n        for i in reversed(range(31)):\n            if n & (1 << i):\n                ans += dp[i]          # Count numbers with this bit 0\n                if prev_bit:          # Two consecutive 1s would appear\n                    return ans        # n itself not counted\n                prev_bit = 1\n            else:\n                prev_bit = 0\n\n        return ans + 1  # Include n itself if it has no consecutive 1s\n\ndef main():\n    # Read entire input; allow formats like \"n = 5\" or just \"5\"\n    data = sys.stdin.read().strip()\n    # Extract the first integer found in the input\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n\n    sol = Solution()\n    result = sol.findIntegers(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode282.json",
    "problem_index_in_file": 0,
    "title": "Expression Add Operators",
    "description_snippet": "Given a string num that contains only digits and an integer target, return all possibilities to inse...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm: generate all expressions by inserting + - * between digits such that expression evaluates to target. Must handle no leading zeros for operands. Use backtracking, track current value, last operand for multiplication. We'll produce pseudocode line by line with explanation. Use Start, End, Decision, etc. We'll generate steps. Provide each line with arrow, step, etc. Ensure each line ends with // explanation. Provide all lines. Let's craft.\n\nWe should cover: initialize result list; define backtrack function with parameters index, path, eval, multed. We'll start at index 0, path empty, eval 0, multed 0. Then loop over end index to choose next operand substring. Check leading zero. Convert to integer. If at start, set eval = cur, multed = cur, path=cur; else, try +, -, *.\n\nAt end if index==len(num) and eval==target add path to results.\n\nReturn results.\n\nNow produce virtual code lines.\n\nLet's outline.\n\nStart // program start\n\n→ Step 1: Define list results ← empty // 存儲符合條件的表達式\n\n→ Step 2: Define function backtrack(index, path, eval, multed) // 回溯函數\n\n→ Decision: 如果 index == len(num) ? // 到達字符串尾\n\n    Yes → Decision: 如果 eval == target? // 數值是否符合目標\n\n        Yes → Step 3: Append path to results // 收集有效表達式\n\n        No  → Step 4: Return // 不符合，回溯\n\n    No  → Step 5: For end from index to len(num)-1 // 選擇下一個數字子串\n\n        → Step 6: Substring ← num[index:end+1] // 當前操作數\n\n        → Decision: 如果 Substring starts with '0' and length > 1? // 領導零檢查\n\n            Yes → Step 7: Break // 跳過帶領導零的數字\n\n        No  → Step 8: cur ← integer(SubString) // 轉換為數值\n\n        → Decision: 如果 index == 0? // 第一個數字\n\n            Yes → Step 9: backtrack(end+1, SubString, cur, cur) // 設置初始 eval、multed\n\n        No  → Step 10: backtrack(end+1, path + '+' + SubString, eval + cur, cur) // 加號\n\n        → Step 11: backtrack(end+1, path + '-' + SubString, eval - cur, -cur) // 減號\n\n        → Step 12: backtrack(end+1, path + '*' + SubString, eval - multed + multed * cur, multed * cur) // 乘號，調整 eval 和 multed\n\n→ End // 程序結束\n\nBut we also need to output results after calling backtrack. So maybe Step 13: Call backtrack(0, \"\", 0, 0) // start recursion\n\n→ Step 14: Return results // 返回所有表達式\n\nNeed to incorporate all lines. Also we should handle variable definitions earlier.\n\nLet's produce final output with each line.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: results ← [] // 存儲符合條件的表達式\n→ Step 2: Function backtrack(index, path, eval, multed) // 回溯函數，index: 當前處理位置，path: 已構造的表達式，eval: 表達式當前值，multed: 最近一次乘法的操作數\n    → Decision: 如果 index == len(num) ? // 是否已處理完所有數字\n        Yes → Decision: 如果 eval == target ? // 計算結果是否符合目標\n            Yes → Step 3: Append path to results // 收集有效表達式\n            No  → Step 4: Return // 不符合目標，回溯\n        No  → Step 5: For end from index to len(num)-1 // 選擇下一個操作數子串\n            → Step 6: sub ← num[index : end+1] // 當前操作數子串\n            → Decision: 如果 sub starts with '0' and len(sub) > 1 ? // 檢查前導零\n                Yes → Step 7: Break // 跳過帶領導零的子串\n            No  → Step 8: cur ← int(sub) // 轉換為整數\n            → Decision: 如果 index == 0 ? // 第一個操作數\n                Yes → Step 9: backtrack(end+1, sub, cur, cur) // 設置初始 eval 與 multed\n            No  → Step 10: backtrack(end+1, path + '+' + sub, eval + cur, cur) // 加號操作\n            → Step 11: backtrack(end+1, path + '-' + sub, eval - cur, -cur) // 減號操作\n            → Step 12: backtrack(end+1, path + '*' + sub, eval - multed + multed * cur, multed * cur) // 乘號操作，調整 eval 與 multed\n→ Step 13: backtrack(0, \"\", 0, 0) // 啟動回溯\n→ Step 14: Return results // 返回所有符合條件的表達式\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def addOperators(self, num: str, target: int) -> list[str]:\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int) -> None:\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                # 忽略領先零的多位數\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(\n                        i,\n                        path + '*' + temp,\n                        value - last + last * curr,\n                        last * curr,\n                    )\n\n        backtrack(0, \"\", 0, 0)\n        return res\n\n\ndef parse_input(data: str):\n    \"\"\"從輸入文字中提取 num 和 target。\"\"\"\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]*)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not num_match or not target_match:\n        raise ValueError(\"輸入格式錯誤\")\n    return num_match.group(1), int(target_match.group(1))\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    num_str, target_val = parse_input(raw_input)\n    solution = Solution()\n    result = solution.addOperators(num_str, target_val)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1+2+3\",\"1*2*3\"]",
          "success": true,
          "output": "[\"1+2+3\", \"1*2*3\"]"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2+3*2\",\"2*3+2\"]",
          "success": true,
          "output": "[\"2+3*2\", \"2*3+2\"]"
        },
        {
          "example_index": 2,
          "input": "num = \"3456237490\", target = 9191",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode167.json",
    "problem_index_in_file": 0,
    "title": "Two Sum II - Input Array Is Sorted",
    "description_snippet": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for two-sum with sorted array, returning 1-indexed indices, constant space. Likely two-pointer approach. So output steps:\n\nStart\n→ Step: Set left = 1, right = numbers.length // pointers\n→ Decision: while left < right?\n    Yes → Step: sum = numbers[left] + numbers[right]\n    → Decision: sum == target?\n        Yes → Return [left, right]\n        No → Decision: sum < target?\n            Yes → left = left + 1\n            No → right = right - 1\n    No → End\n\nBut need to adapt to 1-indexing. Since array is 1-indexed, but code often 0-indexed. We'll treat indices accordingly. We'll say left starts at 1, right = length. Use 1-indexed arithmetic.\n\nWe must provide step-by-step with arrow lines. Use \"→\" indentation. Let's produce each line as required. We'll include explanatory comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left ← 1, right ← numbers.length // 初始化左指標為 1，右指標為陣列長度  \n→ Decision: while left < right? // 檢查兩指標是否相遇  \n    Yes → Step 2: sum ← numbers[left] + numbers[right] // 計算左右兩數之和  \n    → Decision: sum == target? // 是否已找到目標和  \n        Yes → Step 3: return [left, right] // 回傳 1‑索引的兩個位置，結束程式  \n        No → Decision: sum < target? // 和太小，需左移左指標  \n            Yes → Step 4: left ← left + 1 // 將左指標往右移動  \n            No → Step 5: right ← right - 1 // 和太大，右指標往左移動  \n    No → End // 若無解（實際上不會發生，因題目保證有解）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        \"\"\"找出兩個數字之和等於 target，返回 1-indexed 的索引。\"\"\"\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            s = numbers[left] + numbers[right]\n            if s == target:\n                return [left + 1, right + 1]          # 轉成 1-indexed\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整段輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 找出 numbers 列表\n    list_match = re.search(r'\\[.*?\\]', raw_input)\n    if not list_match:\n        raise ValueError(\"無法找到數字列表\")\n    numbers = ast.literal_eval(list_match.group())\n\n    # 找出 target 整數\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', raw_input)\n    if not target_match:\n        raise ValueError(\"無法找到 target\")\n    target = int(target_match.group(1))\n\n    # 呼叫解法並輸出結果\n    sol = Solution()\n    result = sol.twoSum(numbers, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "success": true,
          "output": "[1, 3]"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode682.json",
    "problem_index_in_file": 0,
    "title": "Baseball Game",
    "description_snippet": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation for the baseball game scoring algorithm. Provide steps: Start, iterate over operations, handle each case. Use stack to store scores. After processing, sum stack.\n\nWe must follow formatting: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow characters.\n\nExample: Start // 程式開始執行\n\nUse \"→\" for steps.\n\nUse Decision with Yes →, No →.\n\nWe'll produce algorithm steps.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Initialize stack // 建立空堆疊存儲分數\n→ Initialize sum = 0 // 用於計算最終總分（可選）\n→ For each op in operations // 逐一處理每個操作\n    → Decision: op is '+'? // 判斷是否為加號\n        Yes → Compute newScore = stack[top] + stack[top-1] // 取前兩分數相加\n            → Push newScore onto stack // 新分數入堆疊\n            → Add newScore to sum // 更新總分\n        No  → Decision: op is 'D'? // 判斷是否為乘二\n            Yes → newScore = 2 * stack[top] // 取前一分數翻倍\n                → Push newScore onto stack\n                → Add newScore to sum\n            No  → Decision: op is 'C'? // 判斷是否為刪除\n                Yes → oldScore = stack.pop() // 移除最近一次分數\n                    → Subtract oldScore from sum // 更新總分\n                No  → // 其他情況，應為整數\n                    → Convert op to integer val\n                    → Push val onto stack\n                    → Add val to sum\n→ End // 所有操作完成，返回 sum\n\nBut we need to show sum calculation at end or just return sum. Provide final step.\n\nLet's include a final line: → Return sum // 結果回傳\n\nMake sure each line is a single statement: include arrow and step description.\n\nAlso include Start and End.\n\nLet's produce.\n\nBe careful: each line must have exactly one step. For nested decisions, we need to indent? Not necessary but we can indent for readability but not required.\n\nWe should produce like:\n\nStart // 程式開始執行\n→ Step 1: Initialize an empty stack // 用於儲存每個有效的分數\n→ Step 2: Initialize sum = 0 // 用於計算所有分數的總和\n→ Step 3: For each op in operations // 逐個處理操作\n    → Decision: op == \"+\" ? // 判斷是否為加號\n        Yes → Step 4: newScore = stack[top] + stack[top-1] // 取前兩個分數相加\n            → Step 5: Push newScore onto stack // 新分數入堆疊\n            → Step 6: sum += newScore // 更新總分\n        No  → Decision: op == \"D\" ? // 判斷是否為乘二\n            Yes → Step 7: newScore = 2 * stack[top] // 取前一個分數翻倍\n                → Step 8: Push newScore onto stack\n                → Step 9: sum += newScore\n            No  → Decision: op == \"C\" ? // 判斷是否為刪除\n                Yes → Step 10: oldScore = stack.pop() // 移除最近一次分數\n                    → Step 11: sum -= oldScore // 更新總分\n                No  → // 整數\n                    → Step 12: val = int(op) // 轉成整數\n                    → Step 13: Push val onto stack\n                    → Step 14: sum += val\n→ Step 15: Return sum // 回傳所有有效分數的總和\nEnd // 程式結束\n\nWe should maintain each line with arrow and step. But the nested decisions lines also need arrow? Use \"Decision:\" lines.\n\nThe format: `Decision: if ...?` then `Yes →`, `No →` lines.\n\nBut we must keep each line with \"虛擬碼步驟\" plus comment. So each line like:\n\nDecision: op == \"+\"? // 判斷是否為加號\n    Yes → ...\n\nSo we can produce.\n\nAlso we should have \"Start\" and \"End\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize an empty stack // 用於儲存每個有效的分數\n→ Step 2: Initialize sum = 0 // 用於計算所有分數的總和\n→ Step 3: For each op in operations // 逐個處理操作\n    → Decision: op == \"+\"? // 判斷是否為加號\n        Yes → Step 4: newScore = stack[top] + stack[top-1] // 取前兩個分數相加\n            → Step 5: Push newScore onto stack // 新分數入堆疊\n            → Step 6: sum += newScore // 更新總分\n        No  → Decision: op == \"D\"? // 判斷是否為乘二\n            Yes → Step 7: newScore = 2 * stack[top] // 取前一個分數翻倍\n                → Step 8: Push newScore onto stack\n                → Step 9: sum += newScore // 更新總分\n            No  → Decision: op == \"C\"? // 判斷是否為刪除\n                Yes → Step 10: oldScore = stack.pop() // 移除最近一次分數\n                    → Step 11: sum -= oldScore // 更新總分\n                No  → // 為整數值\n                    → Step 12: val = int(op) // 轉成整數\n                    → Step 13: Push val onto stack\n                    → Step 14: sum += val // 更新總分\n→ Step 15: Return sum // 回傳所有有效分數的總和\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def calPoints(self, ops):\n        stack = []\n        for op in ops:\n            if op == \"C\":\n                stack.pop()\n            elif op == \"D\":\n                stack.append(2 * stack[-1])\n            elif op == \"+\":\n                stack.append(stack[-1] + stack[-2])\n            else:\n                stack.append(int(op))\n        return sum(stack)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    try:\n        ops = ast.literal_eval(expr)\n    except Exception:\n        ops = []\n    result = Solution().calPoints(ops)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]",
          "expected_output": "30",
          "success": true,
          "output": "30"
        },
        {
          "example_index": 1,
          "input": "ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
          "expected_output": "27",
          "success": true,
          "output": "27"
        },
        {
          "example_index": 2,
          "input": "ops = [\"1\",\"C\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode981.json",
    "problem_index_in_file": 0,
    "title": "Time Based Key-Value Store",
    "description_snippet": "Design a time-based key-value data structure that can store multiple values for the same key at diff...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanation. Provide structure. Provide algorithm steps for the TimeMap class with set and get. Use Start, Decision, etc. Ensure each line is \"虛擬碼步驟 // 解釋\".\n\nWe need to design data structure: dictionary mapping key to list of (timestamp, value) sorted. On set, append. On get, binary search.\n\nLet's produce pseudo-code. Include initialization, set, get.\n\nMake sure each line includes \"虛擬碼步驟\" like \"Start\", \"→ Step 1: ...\" etc.\n\nWe need to produce line-by-line explanation. Use arrow.\n\nWe'll do like:\n\nStart // Start of algorithm\n→ Step 1: Create empty map K2List // Map key to list\n…\n\nBut we should produce a flowchart like start, set, get functions. Use decision steps.\n\nWe need to produce the entire virtual code with each line labelled. Let's design:\n\nStart // Start program\n→ Step 1: Define class TimeMap // class definition\n→ Step 2: Initialize map // inside constructor\n\nBut better to show methods.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 TimeMap 類別 // 建立類別框架\n→ Step 2: 建立空字典 dict // 存放 key → (timestamp, value) 列表\n...\n\nBut we need to produce pseudocode for methods.\n\nI think we can produce pseudo-code for each method, but the request: \"逐行地產生對應的虛擬碼\". So each line is a step. Provide explanation. So we should show all steps: initialization, set, get.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 定義 TimeMap 類別 // 建立資料結構\n→ Step 2: 在建構子中初始化 dict // 以 key 為索引\n\nThen separate sections for set and get:\n\n→ Step 3: 定義 set 方法 // 接收 key, value, timestamp\n    → Step 4: 若 dict 不含 key, 則建立空列表 // 新 key\n    → Step 5: 將 (timestamp, value) 加入該 key 列表 // 按時間遞增\n→ Step 6: 定義 get 方法 // 接收 key, timestamp\n    → Step 7: 若 dict 不含 key, 返回 \"\" // 無該 key\n    → Step 8: 取得該 key 的列表 list // 可能多筆\n    → Step 9: 使用二分搜尋尋找最大 timestamp <= query // O(log n)\n        → Decision: timestamp_at_idx <= query?\n            Yes → Return value_at_idx // 找到符合\n            No → Search left // 否則移動\n    → Step 10: 若未找到, 返回 \"\" // 無符合條件\n\nBut we need to output each line with \"虛擬碼步驟\" and explanation.\n\nUse arrow \"→\" before each step except Start? The example uses \"Start\" then \"→ Step 1\". So we follow.\n\nWe'll produce pseudo-code like:\n\nStart // 程式開始執行\n→ Step 1: 定義 TimeMap 類別 // 建立類別結構\n→ Step 2: 在建構子中初始化 dict // 以 key 為索引，存放時間戳和值的列表\n→ Step 3: 定義 set 方法 // 接收 key, value, timestamp\n    → Step 4: 若 dict 不包含 key，則建立空列表 // 新增 key\n    → Step 5: 將 (timestamp, value) 追加到 key 的列表 // 保持時間遞增\n→ Step 6: 定義 get 方法 // 接收 key, timestamp\n    → Step 7: 若 dict 不包含 key，返回空字串 // 無此 key\n    → Step 8: 取得 key 的列表 list // 可能多筆\n    → Step 9: 使用二分搜尋找最大 timestamp <= query\n        → Decision: timestamp_at_mid <= query?\n            Yes → 記錄此位置並往右搜尋 // 仍可有更大的符合\n            No  → 往左搜尋 // 無法再右邊\n    → Step 10: 若找到符合，返回相應 value\n    → Step 11: 否則返回空字串\nEnd // 程式結束\n\nBut we need to ensure each line is separate and includes explanation after comment.\n\nAlso use \"→\" for decisions. Provide indentation or bullet maybe.\n\nMake sure each line has \"虛擬碼步驟\" and comment.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TimeMap 類別 // 建立類別結構  \n→ Step 2: 在建構子中初始化 dict // 以 key 為索引，存放時間戳與值的列表  \n→ Step 3: 定義 set 方法 // 接收 key、value、timestamp  \n  → Step 4: 若 dict 不包含 key，則建立空列表 // 新增該 key 的存儲空間  \n  → Step 5: 將 (timestamp, value) 追加到 key 的列表 // 保持時間遞增，方便搜尋  \n→ Step 6: 定義 get 方法 // 接收 key、timestamp  \n  → Step 7: 若 dict 不包含 key，返回空字串 // 無此 key 時直接回傳  \n  → Step 8: 取得 key 的列表 list // 可能存在多筆 (timestamp, value)  \n  → Step 9: 使用二分搜尋尋找最大 timestamp <= query  \n    → Decision: list[mid].timestamp <= query? // 檢查中點是否符合時間條件  \n      Yes → 記錄 mid 為候選並往右搜尋 // 可能還有更大的符合  \n      No  → 往左搜尋 // 無法再右邊，縮小搜尋範圍  \n  → Step 10: 若找到符合的 timestamp，返回相應 value // 取得最大符合時間的值  \n  → Step 11: 若未找到，返回空字串 // 沒有 timestamp_prev <= timestamp 的情況  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\nimport bisect\n\nclass TimeMap:\n    def __init__(self):\n        self.store = defaultdict(list)\n\n    def set(self, key, value, timestamp):\n        self.store[key].append((timestamp, value))\n\n    def get(self, key, timestamp):\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # 找到最右邊 <= timestamp 的位置\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i - 1][1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 把兩個列表包在一對方括號內，方便解析\n    ops, args = ast.literal_eval(f\"[{data}]\")\n    output = []\n\n    tm = None\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            tm = TimeMap()\n            output.append(None)\n        elif op == \"set\":\n            tm.set(*arg)\n            output.append(None)\n        elif op == \"get\":\n            result = tm.get(*arg)\n            output.append(result)\n    print(json.dumps(output))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "success": true,
          "output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode31.json",
    "problem_index_in_file": 0,
    "title": "Next Permutation",
    "description_snippet": "A permutation of an array of integers is an arrangement of its members into a sequence or linear ord...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for next permutation algorithm. Use Start, End, Decision, arrow, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce the algorithm: find first index i from right where nums[i-1] < nums[i], etc.\n\nWe must provide detailed lines: Start, then maybe Step 1: find pivot, etc.\n\nAlso ensure using arrow \"→\" and decisions with Yes →, No → etc.\n\nWe must not output actual code. Just pseudo steps. Use Chinese.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize n = length of nums // 得到陣列長度\n→ Step 2: 將 i = n-1 // 從最後一個元素開始尋找\n→ Decision: 是否存在 j such that nums[j] < nums[j+1]? // 判斷是否能找到上升點\n    Yes → Step 3: 從右往左找到第一個 i，使 nums[i-1] < nums[i] // 確定 pivot\n    No  → Step 4: 反轉整個 nums 並返回 // 若無上升點，返回升序排列\n→ Step 5: 將 pivotIndex = i-1 // pivot 的索引\n→ Step 6: 將 j = n-1 // 重新從末尾開始尋找交換目標\n→ Decision: 是否存在 nums[j] > nums[pivotIndex]? // 找到比 pivot 大的最小元素\n    Yes → Step 7: 交換 nums[pivotIndex] 與 nums[j] // 交換\n    No  → (此情況不應該發生，因為 pivot 已確定) // 留作備份\n→ Step 8: 反轉子陣列從 pivotIndex+1 到 n-1 // 使尾部升序\n→ End\n\nWe need each line includes comment.\n\nBut need to ensure \"Decision:\" line also includes arrow? In example: \"Decision: 如果數字大於 0?\" then Yes → Step ... No → etc. So we need to format accordingly.\n\nMake sure each line has \"虛擬碼步驟\" and comment after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n ← length(nums) // 取得陣列長度  \n→ Step 2: 設定 i ← n - 1 // 從最後一個元素開始尋找上升點  \n→ Decision: 是否存在 index i 使 nums[i-1] < nums[i]? // 判斷是否能得到更大的排列  \n  Yes → Step 3: 從 i = n-1 開始向左尋找，找到第一個 i 使 nums[i-1] < nums[i] // 確定 pivot 索引 pivotIndex = i - 1  \n  No  → Step 4: 反轉整個 nums，並返回 // 沒有更大的排列，重新排成升序  \n→ Step 5: 設定 pivotIndex ← i - 1 // pivot 的索引  \n→ Step 6: 設定 j ← n - 1 // 從尾部尋找交換目標  \n→ Decision: 是否存在 j 使 nums[j] > nums[pivotIndex]? // 找到比 pivot 大的最小元素  \n  Yes → Step 7: 交換 nums[pivotIndex] 與 nums[j] // 交換兩個元素  \n  No  → // 理論上不會發生，pivot 已確定  \n→ Step 8: 反轉子陣列 nums[pivotIndex+1 … n-1] // 讓尾部升序，完成下個排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextPermutation(self, nums):\n        \"\"\"\n        Modify nums in-place to its next lexicographical permutation.\n        If it is the highest permutation, rearrange to the lowest (ascending).\n        \"\"\"\n        n = len(nums)\n        i = n - 2\n\n        # 找到第一個遞減點\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n\n        if i >= 0:\n            # 在右側找到比 nums[i] 大的最小值\n            j = n - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n\n        # 反轉右側子陣列，得到升序\n        left, right = i + 1, n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 支援格式 \"nums = [1,2,3]\" 或僅 \"[1,2,3]\"\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n        arr_str = arr_str.strip()\n    else:\n        arr_str = data\n\n    nums = ast.literal_eval(arr_str)\n\n    sol = Solution()\n    sol.nextPermutation(nums)\n\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1]",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,5]",
          "expected_output": "[1,5,1]",
          "success": true,
          "output": "[1, 5, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode678.json",
    "problem_index_in_file": 0,
    "title": "Valid Parenthesis String",
    "description_snippet": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is va...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to validate parentheses with '*' wildcard. Common solution: track min and max possible open count. Iterate string; for '(' increment min and max; for ')' decrement; for '*' decrement min, increment max. min can't go below zero. At end if min==0 valid. So produce steps with Start, Decision etc. Use \"Step 1: Initialize minOpen and maxOpen to 0\". etc.\n\nWe need each line with virtual code step and comment. Use arrows. Provide decision branches. Also need to indicate loops. Use Start, → Loop: for each char in s. Inside loop, decide char type.\n\nWe need to be careful not to output real code but virtual pseudocode. Use \"Start //\".\n\nLet's design steps:\n\nStart\n→ Step 1: Initialize minOpen = 0 //最小可能開括號數\n→ Step 2: Initialize maxOpen = 0 //最大可能開括號數\n→ Step 3: For each character c in s //遍歷字串\n    → Decision: If c == '(' ?\n        Yes → Step 4: minOpen += 1 //增加最小開數\n               → Step 5: maxOpen += 1 //增加最大開數\n        No  → Decision: If c == ')' ?\n            Yes → Step 6: minOpen -= 1 //減少最小開數\n                   → Step 7: maxOpen -= 1 //減少最大開數\n            No  → Decision: If c == '*' ?\n                Yes → Step 8: minOpen -= 1 //'*'可作右括號，減最小\n                       → Step 9: maxOpen += 1 //'*'可作左括號，增最大\n                No → // 其他字符忽略\n    → Decision: If minOpen < 0 ?\n        Yes → Step 10: minOpen = 0 //不允許負值\n        No  → // 保持\n→ Decision: If maxOpen < 0 ?\n    Yes → Step 11: Return False //超過閉括號，無效\n    No  → // 继续\n→ Step 12: Return minOpen == 0 //若最小开括号为0，则合法\nEnd\n\nNeed to reflect each line exactly. Use arrows as per format. Provide each line with comment. Should not output actual code, but pseudocode. Let's craft lines with \"Step X:\".\n\nAlso we need to include decision block with indent. Use arrow \"Decision:\" and Yes/No.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 minOpen = 0 // 最小可能開括號數  \n→ Step 2: 初始化 maxOpen = 0 // 最大可能開括號數  \n→ Step 3: 循環遍歷字串 s 中的每個字符 c // 逐字符處理  \n  → Decision: c 為 '('?  \n   Yes → Step 4: minOpen += 1 // 加一個左括號，更新最小開數  \n      Step 5: maxOpen += 1 // 同時加一個左括號，更新最大開數  \n   No  → Decision: c 為 ')'？  \n    Yes → Step 6: minOpen -= 1 // 減去一個左括號，更新最小開數  \n      Step 7: maxOpen -= 1 // 減去一個左括號，更新最大開數  \n    No  → Decision: c 為 '*'？  \n     Yes → Step 8: minOpen -= 1 // '*' 可視為右括號，減一個左括號  \n      Step 9: maxOpen += 1 // '*' 可視為左括號，增一個左括號  \n     No → // 非法字符，忽略處理  \n  → Decision: minOpen < 0？  \n   Yes → Step 10: minOpen = 0 // 避免負數，表示至少為空字符串  \n   No  → // 保持現值  \n  → Decision: maxOpen < 0？  \n   Yes → Step 11: 返回 False // 超過右括號數量，無效  \n   No  → // 允許進一步處理  \n→ Step 12: 返回 minOpen == 0 // 若最小開括號數為 0，則字串有效  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def checkValidString(self, s: str) -> bool:\n        low = 0   # 最小可能未匹配的 '(' 數\n        high = 0  # 最大可能未匹配的 '(' 數\n\n        for c in s:\n            if c == '(':\n                low += 1\n                high += 1\n            elif c == ')':\n                if low > 0:\n                    low -= 1\n                high -= 1\n            else:  # c == '*'\n                if low > 0:\n                    low -= 1\n                high += 1\n\n            if high < 0:\n                return False\n\n        return low == 0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，預期格式為: s = \"...\"\n    if '=' in data:\n        s = data.split('=', 1)[1].strip()\n    else:\n        s = data\n\n    # 去除前後的引號（單引號或雙引號）\n    if (s.startswith(\"'\") and s.endswith(\"'\")) or (s.startswith('\"') and s.endswith('\"')):\n        s = s[1:-1]\n\n    sol = Solution()\n    result = sol.checkValidString(s)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"(*)\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(*))\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode70.json",
    "problem_index_in_file": 0,
    "title": "Climbing Stairs",
    "description_snippet": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation per line. Use steps like Start, Decision, etc. For the problem: climbing stairs with steps 1 or 2. We need algorithm: compute number of distinct ways to reach top n steps. Classic DP: ways[0] = 1, ways[1] = 1, for i from 2 to n: ways[i] = ways[i-1]+ways[i-2]. So we need virtual code lines accordingly.\n\nWe should output each line with \"虛擬碼步驟\" then space then comment. Must use arrow and structure.\n\nProbably like:\n\nStart\n→ Input n // 讀取步數\n→ Decision: n==0? // 若為 0 步\n    Yes → Output 1 // 只有一種方式：不動\n    No  → Decision: n==1?\n        Yes → Output 1 // 只有一步\n        No  → Step 1: 初始化 DP[0]=1, DP[1]=1 // 設定基礎\n        → For i from 2 to n: DP[i]=DP[i-1]+DP[i-2] // DP 推算\n        → Output DP[n] // 顯示結果\nEnd\n\nBut we need arrow for decision. Use \"Decision:\" lines with arrow indent. Use Yes → and No → accordingly.\n\nMake sure to use virtual code arrow →. Use indentation.\n\nWe need to adhere to format: each line: \"虛擬碼步驟 // 解釋\" e.g. \"Start // 程式開始執行\".\n\nSo we produce lines like:\n\nStart // 程式開始執行\n→ Input n // 讀取目標階梯數\n→ Decision: n == 0? // 檢查是否為 0 階\n    Yes → Output 1 // 只有一種方式：不走\n    No  → Decision: n == 1? // 檢查是否為 1 階\n        Yes → Output 1 // 只有一步可走\n        No  → Step 1: 初始化 DP[0] = 1, DP[1] = 1 // 設定基礎狀態\n        → Step 2: For i from 2 to n: DP[i] = DP[i-1] + DP[i-2] // 逐步累加\n        → Step 3: Output DP[n] // 輸出結果\nEnd // 程式結束\n\nBut we need to ensure each line is separate and arrow indentation accordingly.\n\nAlso note that \"Step 1:\" etc. maybe \"Step 1: 初始化 DP\". Use arrow.\n\nLet's craft final output with lines exactly as requested. Use \"Start\" and \"End\". Use arrow for transitions. Use \"Decision:\" with indent.\n\nWill produce:\n\nStart // 程式開始執行\n→ Input n // 讀取階梯數\n→ Decision: n == 0? // 檢查是否為 0 階\n    Yes → Output 1 // 只有一種方式：不走\n    No  → Decision: n == 1? // 檢查是否為 1 階\n        Yes → Output 1 // 只有一步可走\n        No  → Step 1: 初始化 DP[0] = 1, DP[1] = 1 // 設定基礎\n        → Step 2: For i = 2 to n: DP[i] = DP[i-1] + DP[i-2] // 逐步計算\n        → Step 3: Output DP[n] // 輸出總方式數\nEnd // 程式結束\n\nBut we need each line exactly one step, so the \"Decision: n == 1?\" line should be separate; the following Yes → and No → lines as separate.\n\nLet's format:\n\nStart // 程式開始執行\n→ Input n // 讀取階梯數\n→ Decision: n == 0? // 檢查是否為 0 階\n    Yes → Output 1 // 只有一種方式：不走\n    No  → Decision: n == 1? // 檢查是否為 1 階\n        Yes → Output 1 // 只有一步可走\n        No  → Step 1: 初始化 DP[0] = 1, DP[1] = 1 // 設定基礎\n        → Step 2: For i = 2 to n: DP[i] = DP[i-1] + DP[i-2] // 逐步計算\n        → Step 3: Output DP[n] // 輸出總方式數\nEnd // 程式結束\n\nBut ensure each line ends with // comment. The \"Decision:\" lines are separate. The \"Yes →\" lines are separate. The \"No →\" lines are separate.\n\nWe need to ensure indentation maybe with spaces. Provide exactly lines.\n\nAlso we must use \"虛擬碼步驟\" as the actual code part. So for each line we provide the step phrase like \"Start\", \"Input n\", etc.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 讀取要爬的階梯數  \n→ Decision: n == 0? // 檢查是否為 0 階  \n    Yes → Output 1 // 只有一種方式：不走  \n    No → Decision: n == 1? // 檢查是否為 1 階  \n        Yes → Output 1 // 只有一步可走  \n        No → Step 1: 初始化 DP[0] = 1, DP[1] = 1 // 設定基礎  \n        → Step 2: For i = 2 to n: DP[i] = DP[i-1] + DP[i-2] // 逐步累加  \n        → Step 3: Output DP[n] // 輸出總方式數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入，計算並輸出爬階梯的總方法數。\n    支援「n = 2」或「2」等形式的輸入。\n    \"\"\"\n    # 取得所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出第一個整數（允許前後有空白或文字）\n    match = re.search(r\"-?\\d+\", data)\n    if not match:\n        return\n    n = int(match.group())\n\n    # 計算方法數（考慮 n = 0 的情況）\n    if n <= 0:\n        ans = 1\n    elif n == 1:\n        ans = 1\n    elif n == 2:\n        ans = 2\n    else:\n        first, second = 1, 2  # 分別代表 f(i-2)，f(i-1)\n        for _ in range(3, n + 1):\n            first, second = second, first + second\n        ans = second\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode372.json",
    "problem_index_in_file": 0,
    "title": "Super Pow",
    "description_snippet": "Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large pos...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing a^b mod 1337, where a positive integer a, b is extremely large given as array of digits? Usually large exponent given as array of digits representing the exponent in decimal. We need to compute modular exponent with exponent being huge represented as array of digits. Standard approach: use modular exponent by repeated squaring with exponent in decimal digits: we can use algorithm that for each digit d in b array: compute result = (result^10 * a^d) mod 1337. Or use powmod by iterating over digits. So virtual code: Start -> Step: read a, read b array -> Step: set mod = 1337, set result = 1, precompute a_mod = a mod mod -> Step: iterate over each digit d in b -> compute result = powmod(result,10,mod) * powmod(a_mod,d,mod) mod mod -> End -> output result. Need to include decision nodes? maybe not. Provide step by step with arrow. Also need virtual code for powmod maybe function. Provide subroutine.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: 讀取 a, b_array // 取得基底與指數陣列\n→ Step 2: 設定 mod = 1337\n→ Step 3: result ← 1 // 初始累積值\n→ Step 4: a_mod ← a mod mod // 先把 a 取模\n→ Step 5: For each digit d in b_array // 逐位處理指數\n    → Step 5.1: result ← powmod(result, 10, mod) // 把 result 提到 10 次方\n    → Step 5.2: tmp ← powmod(a_mod, d, mod) // 先算 a_mod 的 d 次方\n    → Step 5.3: result ← (result * tmp) mod mod // 合併\n→ End // 輸出結果\n\nAlso define powmod subroutine:\n\nStep X: Function powmod(base, exp, mod)\n    → Step X.1: result ← 1\n    → Step X.2: base ← base mod mod\n    → Step X.3: While exp > 0\n        → Decision: exp mod 2 == 1 ?\n            Yes → result ← (result * base) mod mod\n            No →\n        → base ← (base * base) mod mod\n        → exp ← exp // 2\n    → Step X.4: Return result\n\nBut we can inline or just refer to powmod.\n\nNeed to keep virtual code lines and explanations.\n\nLet's output as requested: each line with virtual code step and // explanation. Use arrow \"→\". Provide nested lines with indentation? The format shows indentation for nested decisions. Use spaces for indentation.\n\nMake sure each line ends with // explanation.\n\nWe'll include Start and End. For subroutine, maybe separate block? Use separate steps with Start/End of function? Provide clarity.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 a, b_array // 取得基底 a 與指數陣列 b  \n→ Step 2: mod ← 1337 // 設定模數  \n→ Step 3: result ← 1 // 初始化累積值  \n→ Step 4: a_mod ← a mod mod // 先把 a 取模，簡化後續計算  \n→ Step 5: For 每個 digit d 在 b_array // 逐位處理指數  \n  → Step 5.1: result ← powmod(result, 10, mod) // 把目前 result 提到 10 次方  \n  → Step 5.2: tmp ← powmod(a_mod, d, mod) // 計算 a_mod 的 d 次方  \n  → Step 5.3: result ← (result * tmp) mod mod // 合併兩個模運算結果  \nEnd // 輸出 result 即為 a^b mod 1337  \n\n//-------------------  \nFunction powmod(base, exp, mod) // 對 base 進行 exp 次方後取模  \n  → Step 1: result ← 1  \n  → Step 2: base ← base mod mod  \n  → Step 3: While exp > 0  \n    → Decision: exp mod 2 == 1 ? // 判斷 exp 是否為奇數  \n      Yes → result ← (result * base) mod mod // 若奇數則乘上 base  \n      No → // 直接跳過  \n      ↓  \n      base ← (base * base) mod mod // base 平方  \n      exp ← exp // 2 // 除以 2  \n  → Step 4: Return result // 回傳 powmod 的結果  \nEnd // powmod 函式結束",
      "generated_code": "import sys\nimport re\n\nMOD = 1337\n\ndef super_pow(a, b_digits):\n    \"\"\"計算 a^b mod 1337，b_digits 為指數的各位數字（從高位到低位）。\"\"\"\n    result = 1\n    for digit in b_digits:\n        # 先把 result 提到 10 次方，再乘上 a 的 digit 次方\n        result = (pow(result, 10, MOD) * pow(a, digit, MOD)) % MOD\n    return result\n\ndef parse_input(text):\n    \"\"\"從輸入文字中解析出 a 與 b 的數值。\"\"\"\n    # 找出 a 的值\n    a_match = re.search(r\"a\\s*=\\s*(\\d+)\", text)\n    if not a_match:\n        raise ValueError(\"無法解析 a 的值\")\n    a = int(a_match.group(1))\n\n    # 找出 b 的值（陣列）\n    b_match = re.search(r\"b\\s*=\\s*\\[(.*?)\\]\", text)\n    if not b_match:\n        raise ValueError(\"無法解析 b 的值\")\n    # 取出逗號分隔的每個數字，去除空白並轉成 int\n    b_str = b_match.group(1)\n    if b_str.strip() == \"\":\n        b_digits = []\n    else:\n        b_digits = [int(d.strip()) for d in b_str.split(',')]\n    return a, b_digits\n\ndef main():\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        return\n    a, b_digits = parse_input(input_text)\n    result = super_pow(a, b_digits)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 2, b = [3]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "success": true,
          "output": "1024"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode466.json",
    "problem_index_in_file": 0,
    "title": "Count The Repetitions",
    "description_snippet": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for solving the problem: given s1, s2, n1, n2. str1 = s1 repeated n1 times, str2 = s2 repeated n2 times. We need max m such that str2 repeated m times can be obtained as subsequence of str1.\n\nThis is similar to Leetcode 466? Actually similar to problem 466 \"Count The Repetitions\". So we need to implement algorithm using cycle detection. The pseudocode: compute how many s2's we can get from each s1 repetition, track states of position in s2. Use dictionary to record when a particular index in s2 repeats with same number of s1 used. Then compute number of s2 per cycle. Finally compute total m = (n1 / cycle_length) * s2_per_cycle + remainder.\n\nWe need produce step by step pseudocode.\n\nLet's craft pseudocode lines.\n\nWe'll start: Start\n\n→ Step: Read s1, s2, n1, n2 // input\n\n→ Step: Initialize counter for s1_index = 0, s2_index = 0, count_s2 = 0 // counters\n\n→ Step: Create map seen // map from s2_index to (s1_used, count_s2)\n\n→ Step: Loop while s1_used < n1 // iterate over each repetition of s1\n\n   Inside loop:\n\n   → Step: For each char in s1 // iterate characters\n\n       → Decision: If char == s2[s2_index] ?\n\n          Yes → Step: s2_index++ // advance in s2\n\n          No → Step: continue\n\n       → Decision: If s2_index == len(s2) ?\n\n          Yes → Step: count_s2++ // completed one s2\n\n          Yes → Step: s2_index = 0 // reset for next\n\n   → Step: s1_used++ // finished one s1 repetition\n\n   → Decision: If s2_index seen before ?\n\n       Yes → Step: previous = seen[s2_index] // (prev_s1, prev_count)\n\n       Yes → Step: period_s1 = s1_used - prev_s1 // cycle length\n\n       Yes → Step: period_s2 = count_s2 - prev_count // s2 per cycle\n\n       Yes → Step: remaining_s1 = n1 - s1_used\n\n       Yes → Step: cycles = remaining_s1 // period_s1\n\n       Yes → Step: count_s2 += cycles * period_s2\n\n       Yes → Step: s1_used += cycles * period_s1\n\n       Yes → Step: Continue loop // skip to after cycle\n\n   → Step: Record seen[s2_index] = (s1_used, count_s2)\n\nEnd // finish\n\n→ Step: result = count_s2 / n2 // integer division\n\n→ Step: Output result // maximum m\n\nWe need to output with format: each line \"虛擬碼步驟 // 解釋\".\n\nWe need to include arrows and decision indentations. We can use indentation with spaces. Use \"Decision:\" and \"Yes →\", \"No →\".\n\nWe must not output actual code, only virtual code steps.\n\nLet's produce lines accordingly.\n\nMake sure to include \"Start\" and \"End\".\n\nLet's produce full pseudocode. Ensure each line ends with \" // ...\" Explanation.\n\nWe must use arrow symbol for transitions. Use \"→\".\n\nAlso for nested decision, we indent with spaces. Let's produce.\n\nLet's write each line. Ensure no actual code, just pseudo.\n\nWe'll produce as block:\n\nStart // 程式開始\n\n→ Step: 讀取 s1, s2, n1, n2 // 取得輸入\n\n→ Step: 初始化 s1_used = 0, s2_index = 0, count_s2 = 0 // 計數器\n\n→ Step: 建立空字典 seen // 用來記錄 s2_index 的先前狀態\n\n→ Decision: s1_used < n1? // 是否還有 s1 重複可處理\n\n    Yes →\n\n        → Step: 循環遍歷 s1 中的每個字元 // 逐字符比對\n\n            → Decision: char == s2[s2_index]? // 匹配字元\n\n                Yes → s2_index++ // 移動到 s2 的下一個位置\n\n                No  → // 不匹配，跳過\n\n            → Decision: s2_index == len(s2)? // 是否完成一個 s2\n\n                Yes →\n\n                    → Step: count_s2++ // 完成一個 s2 的計數\n\n                    → Step: s2_index = 0 // 重置為 s2 起始\n\n                No  →\n\n        → Step: s1_used++ // 完成一個 s1 的處理\n\n        → Decision: s2_index 在 seen 中? // 是否遇到相同的 s2_index\n\n            Yes →\n\n                → Step: prev_s1, prev_count ← seen[s2_index] // 取前一次狀態\n\n                → Step: period_s1 = s1_used - prev_s1 // 循環長度\n\n                → Step: period_s2 = count_s2 - prev_count // 每個循環得到的 s2 數量\n\n                → Step: remaining_s1 = n1 - s1_used // 剩餘的 s1 重複\n\n                → Step: cycles = remaining_s1 // period_s1 // 需要跳過的完整循環數\n\n                → Step: count_s2 += cycles * period_s2 // 加上跳過循環得到的 s2\n\n                → Step: s1_used += cycles * period_s1 // 更新已處理的 s1 次數\n\n                → Step: // 跳過剩餘部分，直接進入下一次判斷\n\n            No  →\n\n                → Step: seen[s2_index] = (s1_used, count_s2) // 記錄目前狀態\n\n→ End // 程式執行結束\n\n→ Step: result = count_s2 // n2 // 計算可以得到的最大 m\n\n→ Step: 輸出 result // 輸出答案\n\nBut we need to follow the formatting exactly: Each line \"虛擬碼步驟 // 解釋\". So we should not have nested lines as \"Decision:\" with indentation? We can use lines with indentation but still each line ends with // explanation.\n\nWe must include arrow for transitions between steps. For decisions, use \"Decision:\" and \"Yes →\", \"No →\".\n\nLet's produce final answer accordingly. Ensure no actual code.\n\nAlso we need to mention \"Start\" line.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 讀取 s1、s2、n1、n2 // 取得輸入資料  \n→ Step: 初始化 s1_used = 0、s2_index = 0、count_s2 = 0 // 設定計數器  \n→ Step: 建立空字典 seen // 用於記錄 s2_index 的狀態  \n\n→ Decision: s1_used < n1? // 是否還有 s1 重複要處理？  \n Yes →  \n  → Step: 依序遍歷 s1 的每個字元 // 逐字比對  \n    → Decision: 字元 == s2[s2_index]? // 匹配 s2  \n     Yes → s2_index++ // 進入 s2 的下一個位置  \n     No → // 不匹配，直接跳過  \n    → Decision: s2_index == len(s2)? // 完成一個 s2？  \n     Yes →  \n      → Step: count_s2++ // 完成一個 s2 的計數  \n      → Step: s2_index = 0 // 重置為 s2 開頭  \n     No → // 尚未完成  \n  → Step: s1_used++ // 完成一個 s1 的處理  \n  → Decision: s2_index 在 seen 中? // 是否遇到相同的 s2_index？  \n   Yes →  \n    → Step: prev_s1, prev_count ← seen[s2_index] // 取前一次記錄  \n    → Step: period_s1 = s1_used - prev_s1 // 循環長度（s1 次數）  \n    → Step: period_s2 = count_s2 - prev_count // 循環內得到的 s2 數量  \n    → Step: remaining_s1 = n1 - s1_used // 剩餘的 s1 次數  \n    → Step: cycles = remaining_s1 // period_s1 // 要跳過的完整循環數  \n    → Step: count_s2 += cycles * period_s2 // 加上跳過循環得到的 s2 數量  \n    → Step: s1_used += cycles * period_s1 // 更新已處理的 s1 次數  \n    → // 跳過已計算的循環，直接進入下一判斷  \n   No →  \n    → Step: seen[s2_index] = (s1_used, count_s2) // 記錄此狀態  \n\nEnd // 程式執行結束  \n\n→ Step: result = count_s2 // n2 // 計算最大可得到的 m  \n→ Step: 輸出 result // 將答案輸出",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if n1 == 0:\n            return 0\n\n        s1_count = 0          # 已經處理的 s1 次數\n        s2_count = 0          # 已經獲得的 s2 次數\n        index = 0             # s2 的目前位置\n        recall = dict()       # 記錄每個 index 先前的 (s1_count, s2_count)\n\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n            if index in recall:\n                prev_s1, prev_s2 = recall[index]\n                # 先行區段\n                pre_loop = (prev_s1, prev_s2)\n                # 循環區段\n                loop = (s1_count - prev_s1, s2_count - prev_s2)\n                break\n            else:\n                recall[index] = (s1_count, s2_count)\n        else:\n            # 沒有找到循環，直接返回\n            return s2_count // n2\n\n        # 先行區段貢獻\n        ans = pre_loop[1]\n        # 循環區段可重複次數\n        cycles = (n1 - pre_loop[0]) // loop[0]\n        ans += cycles * loop[1]\n        # 余數部分重新模擬\n        rest = (n1 - pre_loop[0]) % loop[0]\n        index_rest = index\n        for _ in range(rest):\n            for ch in s1:\n                if ch == s2[index_rest]:\n                    index_rest += 1\n                    if index_rest == len(s2):\n                        index_rest = 0\n                        ans += 1\n        return ans // n2\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取 s1, s2 (字串) 與 n1, n2 (整數)\n    strs = re.findall(r'\"([^\"]*)\"', data)\n    nums = re.findall(r'\\d+', data)\n    if len(strs) < 2 or len(nums) < 2:\n        return\n    s1, s2 = strs[0], strs[1]\n    n1, n2 = int(nums[0]), int(nums[1])\n    sol = Solution()\n    result = sol.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode526.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement",
    "description_snippet": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudo-code steps to count beautiful arrangements for given n. Classic problem: Count the number of valid permutations where for each position i, perm[i] divides i or i divides perm[i]. Use backtracking with bitmask, recursion, or DFS. Provide line-by-line virtual code.\n\nWe must output only virtual code lines, each followed by // explanation. Use Start, End, Decision, etc. Provide steps: initialize count, define recursive function. Use bitmask to track used numbers. At each depth i, iterate over numbers 1..n, if not used and satisfies condition, recurse. When i > n, increment count. Finally return count.\n\nSo produce virtual code lines. Each line: \"Start // 程式開始執行\" etc. Use arrow lines: \"→\". For decisions, \"Decision:\".\n\nWe need to be careful about formatting. Each line must have the step text, space, // explanation. Use arrow \"→\" before steps. Use \"Yes →\" etc. We need to include Start and End.\n\nWe should include comments in Chinese, as user requested Traditional Chinese. Provide explanation in Chinese.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: 接收輸入 n // 取得整數 n\n\nLine 3: → Step 2: 初始化 count = 0 // 用於累計美麗排列數量\n\nLine 4: → Step 3: 定義遞迴函數 DFS(position, usedMask) // position 代表目前位置，usedMask 標記已使用數字\n\nLine 5:     → Decision: 如果 position > n? // 判斷是否已安排完所有位置\n\nLine 6:         Yes → Step 4: count = count + 1 // 完成一個美麗排列，累加計數\n\nLine 7:         No → Step 5: 迭代 num 從 1 到 n // 嘗試所有候選數字\n\nLine 8:             → Decision: 如果 bit of num 在 usedMask 已設置? // 判斷 num 是否已被使用\n\nLine 9:                 Yes → Step 6: 繼續下一個 num // 跳過已使用的數字\n\nLine 10:                No → Decision: 如果 (num % position == 0) 或 (position % num == 0)? // 檢查美麗條件\n\nLine 11:                    Yes → Step 7: 呼叫 DFS(position + 1, usedMask | (1 << (num-1))) // 選擇 num 並遞迴\n\nLine 12:                    No → Step 8: 繼續下一個 num // 不符合條件，嘗試其他數字\n\nLine 13: → Step 9: 呼叫 DFS(1, 0) // 從位置 1 開始搜尋\n\nLine 14: → Step 10: 回傳 count // 返回美麗排列總數\n\nLine 15: End // 程式執行結束\n\nCheck formatting: We need arrows for steps: \"→\". For decisions: \"Decision:\". For Yes/No: \"Yes →\", \"No →\". For nested lines, maybe indent with spaces.\n\nMake sure each line ends with // explanation. Use Chinese.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入 n // 取得整數 n  \n→ Step 2: 初始化 count = 0 // 用於累計美麗排列數量  \n→ Step 3: 定義遞迴函數 DFS(position, usedMask) // position 代表目前位置，usedMask 標記已使用數字  \n  → Decision: 如果 position > n? // 判斷是否已安排完所有位置  \n   Yes → Step 4: count = count + 1 // 完成一個美麗排列，累加計數  \n   No → Step 5: 迭代 num 從 1 到 n // 嘗試所有候選數字  \n    → Decision: 如果 bit of num 在 usedMask 已設置? // 判斷 num 是否已被使用  \n     Yes → Step 6: 繼續下一個 num // 跳過已使用的數字  \n     No → Decision: 如果 (num % position == 0) 或 (position % num == 0)? // 檢查美麗條件  \n      Yes → Step 7: 呼叫 DFS(position + 1, usedMask | (1 << (num-1))) // 選擇 num 並遞迴  \n      No → Step 8: 繼續下一個 num // 不符合條件，嘗試其他數字  \n→ Step 9: 呼叫 DFS(1, 0) // 從位置 1 開始搜尋  \n→ Step 10: 回傳 count // 返回美麗排列總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom functools import lru_cache\n\ndef count_beautiful_arrangements(n: int) -> int:\n    @lru_cache(None)\n    def dfs(pos: int, used: int) -> int:\n        if pos > n:\n            return 1\n        total = 0\n        for num in range(1, n + 1):\n            if not (used >> (num - 1)) & 1:           # num 尚未使用\n                if num % pos == 0 or pos % num == 0:   # 美麗條件\n                    total += dfs(pos + 1, used | (1 << (num - 1)))\n        return total\n    return dfs(1, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        n = int(data)\n        print(count_beautiful_arrangements(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode324.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Sort II",
    "description_snippet": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation, using arrows and structure. It's a wiggle sort problem: reorder so that nums[0] < nums[1] > nums[2] < nums[3] etc. Approach: iterate through array, for odd index, ensure nums[i-1] < nums[i] > nums[i+1] by swapping if necessary. But typical algorithm: for i from 1 to n-1: if (i%2==1 && nums[i-1] >= nums[i]) swap; if (i%2==0 && nums[i-1] <= nums[i]) swap. Let's produce virtual code. Ensure structure: Start, Steps, Decision, etc.\n\nWe will produce a flowchart-like pseudo-code, each line with explanation. We must not output actual code. Use 虛擬碼步驟 and // explanation.\n\nLet's produce:\n\nStart // program start\n\n→ Step 1: 初始化 n 為 nums 的長度 // 獲取陣列長度\n\n→ Decision: n 是否小於等於 1? // 若只有一個元素，已滿足條件\n\n    Yes → End // 程式結束\n\n    No  → Step 2: 從 i = 1 開始，遍歷到 n-1 // 進行遍歷\n\n→ Step 3: If i is odd (i % 2 == 1) and nums[i-1] >= nums[i] then swap(nums[i-1], nums[i]) // 使奇數位成大於前後\n\n→ Step 4: Else if i is even (i % 2 == 0) and nums[i-1] <= nums[i] then swap(nums[i-1], nums[i]) // 使偶數位成小於前後\n\n→ Step 5: i ← i + 1 // 進行下一個索引\n\n→ Decision: i 是否小於 n? // 判斷是否還有元素\n\n    Yes → Step 3 // 回到條件判斷\n\n    No  → End // 完成\n\nEnd // 程式結束\n\nBut need to adhere to \"逐行\" output with virtual code arrow. Use Start, End, Decision: with Yes→, No→. Each line with explanation after //.\n\nAlso each step is a line. So we might separate each step into separate lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 n 為 nums 的長度 // 取得陣列長度  \n→ Decision: n 是否小於等於 1? // 若只有一個元素，已滿足條件  \n Yes → End // 直接結束  \n No  → Step 2: 從 i = 1 開始，遍歷到 n-1 // 開始逐位檢查  \n→ Step 3: 如果 i 是奇數且 nums[i-1] ≥ nums[i] 則 swap(nums[i-1], nums[i]) // 奇數位應為「大於」前後  \n→ Step 4: 否則若 i 是偶數且 nums[i-1] ≤ nums[i] 則 swap(nums[i-1], nums[i]) // 偶數位應為「小於」前後  \n→ Step 5: i ← i + 1 // 前進到下一個索引  \n→ Decision: i 是否小於 n? // 是否還有元素待處理  \n Yes → Step 3 // 重新進行判斷  \n No  → End // 迴圈結束，程式執行結束  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Rearranges nums in-place so that nums[0] < nums[1] > nums[2] < nums[3] ...\n        \"\"\"\n        n = len(nums)\n        # Sort the array first\n        nums.sort()\n        # Split into two halves, reverse each half\n        half = (n + 1) // 2\n        left = nums[:half][::-1]      # larger elements for odd indices\n        right = nums[half:][::-1]     # smaller elements for even indices\n        # Place elements back into original array\n        nums[::2] = left\n        nums[1::2] = right\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses input string of the form 'nums = [1,2,3]' or just '[1,2,3]'.\n    Returns the corresponding list of integers.\n    \"\"\"\n    data = data.strip()\n    # Search for a list literal\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        try:\n            return eval(match.group())\n        except Exception:\n            pass\n    # Fallback: try to evaluate the entire input\n    try:\n        return eval(data)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    if isinstance(nums, list):\n        Solution().wiggleSort(nums)\n        print(nums)\n    else:\n        print([])",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "success": true,
          "output": "[1, 6, 1, 5, 1, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "success": true,
          "output": "[2, 3, 1, 3, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode32.json",
    "problem_index_in_file": 0,
    "title": "Longest Valid Parentheses",
    "description_snippet": "Given a string containing just the characters '(' and ')', return the length of the longest valid (w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for longest valid parentheses problem. Provide step-by-step virtual code with explanation. Use Start, End, Decision, Yes/No. Use arrows. Provide each line with \"→\" for steps, \"Decision:\" lines, etc.\n\nWe need to produce algorithm: Use stack or DP or two-pass scanning. Let's choose stack approach: push index of last unmatched '(' or -1 sentinel. Then iterate through characters, for each '(' push index, for ')' pop stack; if stack empty push current index; else compute current length = i - stack.top(); update max. That's typical.\n\nWe need to present as virtual code lines.\n\nLet's produce lines:\n\nStart // start\n→ Step 1: Initialize stack with -1 // sentinel for base index\n→ Step 2: Initialize maxLen = 0 // to store longest length\n→ Step 3: For each character at index i in string // iterate through string\n    → Decision: 如果 s[i] 為 '('? // check if left parenthesis\n        Yes → Step 4: push i onto stack // push index\n        No  → Step 5: pop stack // remove matching index\n            → Decision: 如果 stack 為空? // after pop, check stack empty\n                Yes → Step 6: push i onto stack // no matching, set new base\n                No  → Step 7: currentLen = i - stack.top() // calculate length\n                      → Step 8: 更新 maxLen = max(maxLen, currentLen) // update max\n→ End // end\n\nWe need to use \"Yes →\" and \"No →\". Also indentation maybe but not required.\n\nWe should ensure each line ends with \"// explanation\".\n\nAlso note the virtual code step lines should use \"→\" arrow for steps, \"Decision:\" for decisions.\n\nMake sure no actual code, just virtual steps. Also we should use consistent style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 stack 為 [-1] // 以 -1 作為基準索引，方便計算長度  \n→ Step 2: 初始化 maxLen 為 0 // 用來記錄目前找到的最長有效括號長度  \n→ Step 3: 對於字串中每個字元，索引為 i  \n    → Decision: s[i] 是否為 '('? // 判斷是左括號還是右括號  \n        Yes → Step 4: 將 i 推入 stack // 左括號對應其索引  \n        No  → Step 5: 從 stack 彈出一個索引 // 與上一個未匹配的左括號配對  \n            → Decision: stack 是否為空? // 若已無未匹配左括號  \n                Yes → Step 6: 將 i 推入 stack // 以此右括號作為新的基準索引  \n                No  → Step 7: currentLen ← i - stack.top() // 計算從最近未配對左括號到現在的距離  \n                      → Step 8: maxLen ← max(maxLen, currentLen) // 更新最長長度  \n→ End // 程式執行結束，maxLen 為結果的長度",
      "generated_code": "import sys\n\ndef longest_valid_parentheses(s: str) -> int:\n    \"\"\"\n    Return the length of the longest well‑formed parentheses substring.\n    Uses a stack to keep track of indices of unmatched '(' and a sentinel -1.\n    \"\"\"\n    stack = [-1]          # sentinel for the base index\n    max_len = 0\n\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        else:  # char == ')'\n            if stack:\n                stack.pop()\n            # If the stack is empty after popping, push current index as new base\n            if not stack:\n                stack.append(i)\n            else:\n                # Current valid substring length is distance from current index to\n                # the index on top of the stack (which is the last unmatched '(')\n                max_len = max(max_len, i - stack[-1])\n\n    return max_len\n\nif __name__ == \"__main__\":\n    # Read all input, strip whitespace\n    raw_input = sys.stdin.read().strip()\n\n    # If input contains an assignment like 's = \"(())\"', extract the right side\n    if '=' in raw_input:\n        _, rhs = raw_input.split('=', 1)\n        s = rhs.strip()\n    else:\n        s = raw_input\n\n    # Remove surrounding quotes if present\n    if s.startswith('\"') and s.endswith('\"'):\n        s = s[1:-1]\n    elif s.startswith(\"'\") and s.endswith(\"'\"):\n        s = s[1:-1]\n\n    # Compute and print the answer\n    result = longest_valid_parentheses(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"(()\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \")()())\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode565.json",
    "problem_index_in_file": 0,
    "title": "Array Nesting",
    "description_snippet": "You are given an integer array nums of length n where nums is a permutation of the numbers in the ra...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: given array nums of length n permutation of 0..n-1, for each starting index k, build set s[k] by following indices until a duplicate occurs, basically compute cycle length from that starting point, but we need the maximum cycle length. Since nums is a permutation, the graph is a collection of cycles covering all nodes. The longest cycle length equals the maximum cycle length. So algorithm: iterate through indices, maintain visited array; for each unvisited index, traverse until return to visited; count length; update max.\n\nWe produce virtual code line by line. Must use structure: Start, End, Decision etc. Provide brief explanation after //.\n\nLet's produce lines:\n\nStart // Start\n→ Declare array nums (given)\n→ Declare n = length of nums\n→ Initialize visited array of size n with false\n→ Initialize maxLen = 0\n→ Decision: Are there any indices i from 0 to n-1? // loop start\n   Yes → Step: For i = 0 to n-1 // iterate each index\n       → Decision: if visited[i] == true? // skip already processed\n           Yes → No-op // already part of a processed cycle\n           No  → Step: Set current = i // start new cycle\n                 → Step: Set count = 0 // cycle length counter\n                 → Decision: while visited[current] == false? // traverse until hit visited\n                     Yes → Step: visited[current] = true // mark as visited\n                         → Step: count = count + 1 // increment length\n                         → Step: current = nums[current] // move to next index\n                     No  → No-op // exit loop\n                 → Decision: if count > maxLen? // update max\n                     Yes → Step: maxLen = count\n                     No  → No-op\n       → End of for loop\n→ End // end of algorithm\n→ Output maxLen // return longest length\n\nNeed to produce each line with the arrow and explanation.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step: n = length of nums // 取得陣列長度\n→ Step: visited[0..n-1] = false // 初始化訪問標記\n→ Step: maxLen = 0 // 儲存目前最大集合長度\n\n→ Decision: 有索引 i 從 0 到 n-1? // 啟動外層迴圈\n    Yes → For i = 0 to n-1 // 逐一檢查每個索引\n        → Decision: visited[i] 為 true? // 已處理過的節點\n            Yes → // 跳過\n            No  → Step: current = i // 開始新循環\n                  → Step: count = 0 // 計數器清零\n                  → Decision: visited[current] 為 false? // 尚未訪問\n                      Yes → Step: visited[current] = true // 標記已訪問\n                          → Step: count = count + 1 // 增加長度\n                          → Step: current = nums[current] // 移動到下一個索引\n                      No  → // 重複節點，結束循環\n                  → Decision: count > maxLen? // 更新最大長度\n                      Yes → Step: maxLen = count\n                      No  → // 不更新\n        → // 結束 for i\n→ End // 程式結束\n→ Step: return maxLen // 回傳最長集合長度\n\nNeed to use \"→ Decision:\" and \"Yes →\" and \"No →\" lines.\n\nEnsure each line ends with comment.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: n = length of nums // 取得陣列長度  \n→ Step: visited[0..n-1] = false // 初始化訪問標記  \n→ Step: maxLen = 0 // 儲存目前最大集合長度  \n\n→ Decision: 有索引 i 從 0 到 n-1? // 啟動外層迴圈  \n    Yes → Step: for i = 0 to n-1 // 逐一檢查每個索引  \n        → Decision: visited[i] 為 true? // 已處理過的節點  \n            Yes → // 跳過  \n            No  → Step: current = i // 開始新循環  \n                  → Step: count = 0 // 計數器清零  \n                  → Decision: visited[current] 為 false? // 尚未訪問  \n                      Yes → Step: visited[current] = true // 標記已訪問  \n                          → Step: count = count + 1 // 增加長度  \n                          → Step: current = nums[current] // 移動到下一個索引  \n                      No  → // 重複節點，結束循環  \n                  → Decision: count > maxLen? // 更新最大長度  \n                      Yes → Step: maxLen = count // 設為新最大值  \n                      No  → // 不更新  \n        → // 結束 for i  \n→ End // 程式結束  \n→ Step: return maxLen // 回傳最長集合長度",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def arrayNesting(self, nums):\n        \"\"\"\n        Find the maximum length of a set formed by repeatedly following\n        indices in the permutation until a duplicate is encountered.\n        \"\"\"\n        visited = [False] * len(nums)\n        max_len = 0\n\n        for i in range(len(nums)):\n            if not visited[i]:\n                count = 0\n                current = i\n                while not visited[current]:\n                    visited[current] = True\n                    current = nums[current]\n                    count += 1\n                max_len = max(max_len, count)\n\n        return max_len\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 從輸入中提取所有整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    # 執行演算法並輸出結果\n    solution = Solution()\n    print(solution.arrayNesting(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,4,0,3,1,6,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode706.json",
    "problem_index_in_file": 0,
    "title": "Design HashMap",
    "description_snippet": "Design a HashMap without using any built-in hash table libraries.\n\nImplement the MyHashMap class:\n\nM...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines, each with a brief explanation. Should be in Traditional Chinese. Must use arrow notation. Use Start, End, Decision. Use steps like Initialize array, hash function, collision handling with chaining, etc. Provide put, get, remove operations.\n\nLet's produce a step-by-step pseudocode. Ensure each line ends with // 解釋.\n\nUse Start // 程式開始\n→ Step 1: Define bucket count // number of buckets\n→ Step 2: Create array of lists // each bucket holds key-value pairs\n→ Step 3: Implement hash(key) = key mod bucketCount // simple hash\n→ Step 4: put(key,value)\n   -> Compute index = hash(key)\n   -> For each node in bucket[index]\n       -> If node.key == key\n           -> node.value = value // update\n           -> return\n   -> Append new node(key,value) to bucket[index] // insert\n→ Step 5: get(key)\n   -> Compute index = hash(key)\n   -> For each node in bucket[index]\n       -> If node.key == key\n           -> return node.value\n   -> return -1\n→ Step 6: remove(key)\n   -> Compute index = hash(key)\n   -> For each node in bucket[index] with index j\n       -> If node.key == key\n           -> Remove node from list\n           -> return\n→ End // 程式結束\n\nBut need to keep structure with Decision for loops? We can use Decision: if exists.\n\nAlso need to mention bucket as array of linked list. Provide each step.\n\nLet's format lines with arrow and explanation.\n\nMake sure each line uses '→' or 'Yes →', 'No →', 'Decision:'. We'll use loops as decisions.\n\nWe'll create pseudo-code for class MyHashMap with constructor, put, get, remove.\n\nUse:\n\nStart // 程式開始\n\n→ MyHashMap() // 建構子：初始化空 HashMap\n   → Step 1: bucketCount ← 1000 // 固定桶數\n   → Step 2: buckets ← new Array[bucketCount] // 建立桶陣列\n   → For i from 0 to bucketCount-1\n       → buckets[i] ← new List // 每桶為鏈表\n\n→ put(key, value) // 插入或更新鍵值對\n   → idx ← hash(key)\n   → Decision: 是否在桶 idx 內存在 key? // 檢查是否已存在\n       Yes → For each node in buckets[idx]\n           → Decision: node.key == key?\n               Yes → node.value ← value // 更新值\n               No  → // 繼續\n       No  → Append new Node(key, value) to buckets[idx] // 新增\n\n→ get(key) // 查詢鍵對應值\n   → idx ← hash(key)\n   → Decision: 是否在桶 idx 內存在 key? // 遍歷查找\n       Yes → For each node in buckets[idx]\n           → Decision: node.key == key?\n               Yes → Return node.value // 找到返回值\n               No  → // 繼續\n       No  → Return -1 // 未找到\n\n→ remove(key) // 刪除鍵\n   → idx ← hash(key)\n   → Decision: 是否在桶 idx 內存在 key? // 遍歷刪除\n       Yes → For each node in buckets[idx] with index j\n           → Decision: node.key == key?\n               Yes → Remove node at index j from list\n               No  → // 繼續\n       No  → // 無操作\n\n→ End // 程式結束\n\nNeed to make each line a single step. Might combine loops but keep each line separate. Ensure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ MyHashMap() // 建構子：初始化空 HashMap\n    → bucketCount ← 1000 // 設定固定桶數\n    → buckets ← new Array[bucketCount] // 建立桶陣列\n    → For i from 0 to bucketCount-1\n        → buckets[i] ← new List // 每桶為鏈表\n→ put(key, value) // 插入或更新 (key, value) 對\n    → idx ← hash(key) // 計算桶索引\n    → Decision: 是否在 buckets[idx] 中已有 key? // 檢查是否已存在\n        Yes → For each node in buckets[idx]\n            → Decision: node.key == key?\n                Yes → node.value ← value // 更新已存在的值\n                No  → // 繼續遍歷\n        No  → Append new Node(key, value) to buckets[idx] // 新增鍵值對\n→ get(key) // 查詢 key 對應的值\n    → idx ← hash(key) // 計算桶索引\n    → Decision: 是否在 buckets[idx] 中有 key? // 遍歷查找\n        Yes → For each node in buckets[idx]\n            → Decision: node.key == key?\n                Yes → Return node.value // 找到則返回值\n                No  → // 繼續遍歷\n        No  → Return -1 // 未找到則返回 -1\n→ remove(key) // 刪除 key 對應的鍵值對\n    → idx ← hash(key) // 計算桶索引\n    → Decision: 是否在 buckets[idx] 中有 key? // 遍歷刪除\n        Yes → For each node in buckets[idx] with index j\n            → Decision: node.key == key?\n                Yes → Remove node at index j from list // 刪除節點\n                No  → // 繼續遍歷\n        No  → // 若不存在則無操作\n→ End // 程式結束\n```",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyHashMap:\n    def __init__(self):\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        return key % self.size\n\n    def put(self, key: int, value: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)\n                return\n        bucket.append((key, value))\n\n    def get(self, key: int) -> int:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return -1\n\n    def remove(self, key: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket.pop(i)\n                return\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyHashMap\":\n            obj = MyHashMap()\n            res.append(None)\n        elif op == \"put\":\n            obj.put(*arg)\n            res.append(None)\n        elif op == \"get\":\n            res.append(obj.get(*arg))\n        elif op == \"remove\":\n            obj.remove(*arg)\n            res.append(None)\n    print(json.dumps(res))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]",
          "expected_output": "[null, null, null, 1, -1, null, 1, null, -1]",
          "success": true,
          "output": "[null, null, null, 1, -1, null, 1, null, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode399.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Division",
    "description_snippet": "You are given an array of variable pairs equations and an array of real numbers values, where equati...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step-by-step with explanations. Should not produce actual code but pseudo. Use Start, End, Decision, etc. Should include steps: Build graph, DFS for queries. Provide each line. Let's craft. Use arrows. Provide each line with explanation. Should handle queries. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化圖結構 // 建立字典，鍵為變數，值為鄰接列表  \n→ Step 2: 對每個方程 (Ai, Bi, values[i])  \n    → 子步 2a: 若 Ai 不在圖中，加入 Ai → 空列表  \n    → 子步 2b: 若 Bi 不在圖中，加入 Bi → 空列表  \n    → 子步 2c: 在 Ai 的鄰接列表加入 (Bi, values[i]) // Ai / Bi = values[i]  \n    → 子步 2d: 在 Bi 的鄰接列表加入 (Ai, 1/values[i]) // Bi / Ai = 1/values[i]  \n→ Step 3: 定義函式 DFS(start, target, acc) → 目標是尋找從 start 到 target 的乘積 acc  \n    → Decision: 如果 start == target  \n        Yes → Return acc // 找到，返回累積乘積  \n        No → Decision: 如果 start 已訪問過  \n            Yes → Return -1.0 // 循環，無法繼續  \n            No → 標記 start 為已訪問  \n            → 對每個 (neighbor, weight) 在 start 的鄰接列表  \n                → Decision: 如果 DFS(neighbor, target, acc * weight) != -1.0  \n                    Yes → Return 該值 // 找到路徑，返回結果  \n                    No → 繼續搜尋  \n            → Return -1.0 // 所有路徑嘗試完仍未找到  \n→ Step 4: 對每個查詢 (Cj, Dj)  \n    → Decision: 如果 Cj 或 Dj 不在圖中  \n        Yes → Step 4a: 設定答案為 -1.0 // 變數未定義  \n        No → Step 4b: 呼叫 DFS(Cj, Dj, 1.0) 並將返回值存為答案  \n→ Step 5: 收集所有答案到結果陣列  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        # Build graph: variable -> {neighbor: weight}\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        # Depth‑first search to find product from src to dst\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        result = []\n        for u, v in queries:\n            result.append(dfs(u, v, set()))\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses input in the format:\n    equations = [[...], ...], values = [...], queries = [[...], ...]\n    \"\"\"\n    pattern = r'equations\\s*=\\s*(\\[.*?\\]),\\s*values\\s*=\\s*(\\[.*?\\]),\\s*queries\\s*=\\s*(\\[.*?\\])'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    equations = ast.literal_eval(match.group(1))\n    values = ast.literal_eval(match.group(2))\n    queries = ast.literal_eval(match.group(3))\n    return equations, values, queries\n\ndef main():\n    raw = sys.stdin.read()\n    equations, values, queries = parse_input(raw)\n    solver = Solution()\n    answers = solver.calcEquation(equations, values, queries)\n    # Format output: list of numbers with 5 decimal places\n    output = '[' + ','.join(f'{x:.5f}' for x in answers) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpe3xqd9sb.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmpe3xqd9sb.py\", line 49, in main\n    equations, values, queries = parse_input(raw)\n                                 ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe3xqd9sb.py\", line 44, in parse_input\n    queries = ast.literal_eval(match.group(3))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"c\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpo33s14q3.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmpo33s14q3.py\", line 49, in main\n    equations, values, queries = parse_input(raw)\n                                 ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpo33s14q3.py\", line 44, in parse_input\n    queries = ast.literal_eval(match.group(3))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"c\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp4_4vjj_1.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmp4_4vjj_1.py\", line 49, in main\n    equations, values, queries = parse_input(raw)\n                                 ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4_4vjj_1.py\", line 44, in parse_input\n    queries = ast.literal_eval(match.group(3))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode707.json",
    "problem_index_in_file": 0,
    "title": "Design Linked List",
    "description_snippet": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation, no real code. Outline design of singly linked list.\n\nWe need to include class initialization, get, addAtHead, addAtTail, addAtIndex, deleteAtIndex. For each operation produce steps.\n\nUse virtual steps. For example: Start MyLinkedList initialization sets head = null, size = 0. Use singly linked list.\n\nImplement get: check index bounds, traverse nodes.\n\nAddAtHead: create new node, set next to head, head = new node, size++.\n\nAddAtTail: create new node, if head null, set head to new; else traverse to tail, set tail.next = new; size++.\n\nAddAtIndex: if index > size return; if index==0 addAtHead; else if index==size addAtTail; else traverse to node before index, insert.\n\nDeleteAtIndex: if index out of bounds return; if index==0 set head=head.next; else traverse to node before index, skip next; size--.\n\nNeed to produce each line with explanation. Use arrows and decisions. Should we separate each method? We'll produce lines sequentially for the class definition.\n\nWe should use virtual code structure with Start, End, Decision. For methods maybe use Start Method name etc.\n\nLet's produce:\n\nStart MyLinkedList class // start of class\n→ Step: 初始化 head = null, size = 0 // initialize attributes\n\nThen method get: Start get(index) // etc. Provide decisions.\n\nWe need to be consistent.\n\nLet's produce for each method.\n\nOk.\n...done thinking.\n\nStart MyLinkedList // 開始定義 MyLinkedList 類別\n→ Step: 初始化 head = null, size = 0 // 設置鏈表頭為空，長度為 0\n→ Step: 定義 Node 類，具有 val, next // 定義節點結構，單向鏈表\nEnd MyLinkedList // 結束類別定義\n\nStart get(index) // get 方法開始\n→ Decision: 如果 index < 0 或 index >= size? // 檢查索引是否合法\n    Yes → Step: 返回 -1 // 索引無效，返回 -1\n    No  → Step: node = head // 從頭節點開始\n        → Step: cnt = 0 // 計數器初始化\n        → Decision: cnt < index? // 迴圈到目標索引\n            Yes → Step: node = node.next // 移動到下一節點\n                  → Step: cnt++ // 計數器加 1\n                  → Decision: cnt < index? // 仍未達到索引\n                      Yes → Go to 上一步\n                      No  → Step: 返回 node.val // 找到節點，返回其值\nEnd get // get 方法結束\n\nStart addAtHead(val) // addAtHead 方法開始\n→ Step: newNode = Node(val) // 創建新節點\n→ Step: newNode.next = head // 新節點指向舊頭\n→ Step: head = newNode // 新節點成為頭\n→ Step: size++ // 長度加 1\nEnd addAtHead // 方法結束\n\nStart addAtTail(val) // addAtTail 方法開始\n→ Decision: head == null? // 判斷鏈表是否為空\n    Yes → Step: head = Node(val) // 空鏈表，直接設為頭\n          → Step: size++ // 長度加 1\n    No  → Step: node = head // 非空，從頭開始\n          → Decision: node.next != null? // 找到尾節點\n              Yes → Step: node = node.next // 移動到下一節點\n                    → Decision: node.next != null? // 繼續尋找\n                        Yes → Go to 上一步\n                        No  → Step: node.next = Node(val) // 在尾部添加\n                              → Step: size++ // 長度加 1\nEnd addAtTail // 方法結束\n\nStart addAtIndex(index, val) // addAtIndex 方法開始\n→ Decision: index < 0 OR index > size? // 檢查索引合法性\n    Yes → Step: 返回 // 無效索引不插入\n    No  → Decision: index == 0? // 插入到頭部\n        Yes → Step: addAtHead(val) // 直接調用 addAtHead\n        No  → Decision: index == size? // 插入到尾部\n            Yes → Step: addAtTail(val) // 直接調用 addAtTail\n            No  → Step: node = head // 從頭節點開始\n                → Step: cnt = 0\n                → Decision: cnt < index-1? // 找到目標前一節點\n                    Yes → Step: node = node.next\n                          → Step: cnt++ \n                          → Decision: cnt < index-1? \n                              Yes → Go to 上一步\n                              No  → Step: newNode = Node(val)\n                                    → Step: newNode.next = node.next\n                                    → Step: node.next = newNode\n                                    → Step: size++ // 長度加 1\nEnd addAtIndex // 方法結束\n\nStart deleteAtIndex(index) // deleteAtIndex 方法開始\n→ Decision: index < 0 OR index >= size? // 檢查索引合法性\n    Yes → Step: 返回 // 無效索引不刪除\n    No  → Decision: index == 0? // 刪除頭節點\n        Yes → Step: head = head.next // 將頭指向第二節點\n              → Step: size-- // 長度減 1\n        No  → Step: node = head // 從頭節點開始\n              → Step: cnt = 0\n              → Decision: cnt < index-1? // 找到目標前一節點\n                  Yes → Step: node = node.next\n                        → Step: cnt++ \n                        → Decision: cnt < index-1? \n                            Yes → Go to 上一步\n                            No  → Step: node.next = node.next.next // 跳過目標節點\n                                  → Step: size-- // 長度減 1\nEnd deleteAtIndex // 方法結束\n\nEnd MyLinkedList // 完整的 MyLinkedList 虛擬碼結束",
      "generated_code": "import sys\nimport json\n\nclass MyLinkedList:\n    class Node:\n        def __init__(self, val=0):\n            self.val = val\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def get(self, index: int):\n        if index < 0 or index >= self.size:\n            return -1\n        cur = self.head\n        for _ in range(index):\n            cur = cur.next\n        return cur.val\n\n    def addAtHead(self, val: int):\n        node = self.Node(val)\n        node.next = self.head\n        self.head = node\n        self.size += 1\n\n    def addAtTail(self, val: int):\n        node = self.Node(val)\n        if not self.head:\n            self.head = node\n        else:\n            cur = self.head\n            while cur.next:\n                cur = cur.next\n            cur.next = node\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int):\n        if index < 0 or index > self.size:\n            return\n        if index == 0:\n            self.addAtHead(val)\n            return\n        node = self.Node(val)\n        cur = self.head\n        for _ in range(index - 1):\n            cur = cur.next\n        node.next = cur.next\n        cur.next = node\n        self.size += 1\n\n    def deleteAtIndex(self, index: int):\n        if index < 0 or index >= self.size:\n            return\n        if index == 0:\n            self.head = self.head.next\n        else:\n            cur = self.head\n            for _ in range(index - 1):\n                cur = cur.next\n            cur.next = cur.next.next\n        self.size -= 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        # 若輸入不足兩行，直接退出\n        sys.exit(0)\n    commands = json.loads(data[0])\n    arguments = json.loads(data[1])\n\n    obj = None\n    results = []\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"MyLinkedList\":\n            obj = MyLinkedList()\n            results.append(None)  # constructor returns null\n        elif cmd == \"addAtHead\":\n            obj.addAtHead(*args)\n            results.append(None)\n        elif cmd == \"addAtTail\":\n            obj.addAtTail(*args)\n            results.append(None)\n        elif cmd == \"addAtIndex\":\n            obj.addAtIndex(*args)\n            results.append(None)\n        elif cmd == \"deleteAtIndex\":\n            obj.deleteAtIndex(*args)\n            results.append(None)\n        elif cmd == \"get\":\n            ret = obj.get(*args)\n            results.append(ret)\n        else:\n            # 若出現未知方法，直接跳過\n            results.append(None)\n\n    # 將結果轉成 JSON 風格的字串\n    out = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(out)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]",
          "expected_output": "[null, null, null, null, 2, null, 3]",
          "success": true,
          "output": "[null, null, null, null, 2, null, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode481.json",
    "problem_index_in_file": 0,
    "title": "Magical String",
    "description_snippet": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code to compute number of 1's in first n numbers of magical string s. We need algorithm. Classic problem: Magical String or \"magical string\" from Leetcode. Approach: generate string until length >= n, count ones. Use two pointers: one for current index in s (to append counts), another for writing. Keep array s. Start with [1,2,2]. Then i=2 (pointer to read). While length < n: current = s[i]; nextCount = s[i]; for j in range(nextCount): append s[writeIndex] (which is the other number? Actually the rule: we are building the run-length sequence: we append current number (which is nextCount) times? Wait, algorithm: We maintain an array s where each element is the length of a run. We maintain pointer to read run lengths and pointer to write values. Initially s = [1,2,2]. The pattern: we read s[i] which gives count. We append count times the current number (which toggles between 1 and 2). Implementation: We use variable current = 1; i=2; while len(s)<n: for _ in range(s[i]): s.append(current); current = 3-current; i+=1.\n\nCount ones: we can count while building, but we need up to n. So we can count after building truncated to n. We'll produce virtual code accordingly.\n\nWe need to produce step-by-step pseudocode with explanation lines. Use structure Start, End, Decision. Provide each step. Let's design.\n\n1. Start\n2. 初始化 s = [1,2,2] // 基本魔法串開頭\n3. Set current = 1 // 下一個要寫入的數字\n4. Set i = 2 // 讀取指標，指向 s[2] 的 2\n5. Set countOnes = 0 // 1 的個數\n6. 如果 n <= len(s) // 已經足夠長，直接統計前 n 個\n   Yes → 取前 n 個並計算 1 的個數 // 直接計算\n   No → Loop\n7. Loop While len(s) < n\n   -> Decision: 若 s[-1] 為 1? // 判斷目前最後一個元素\n   ...\nBut we might not need that decision. Let's design simple.\n\nIn loop:\n- Append current number s[i] times\n- During each append, if current==1 and len(s)<=n, increment countOnes\n- Toggle current between 1 and 2\n- Increment i\n\nAfter loop, if len(s)>n, we might have appended beyond n. But we counted only up to n. So after loop, return countOnes.\n\nLet's produce step lines with explanations. Use arrows.\n\nLet's produce as:\n\nStart\n→ Step 1: 初始化 s = [1,2,2] // 開始的三個數\n→ Step 2: current = 1 // 下一個寫入的數字為 1\n→ Step 3: i = 2 // 讀取指標指向 s[2] 的 2\n→ Step 4: countOnes = 0 // 1 的總數\n→ Decision: n <= len(s)? // 已經到足夠長度\n    Yes → Step 5: For idx in 0..n-1: if s[idx]==1 countOnes++ // 直接計算\n    No  → Step 6: While len(s) < n:\n        → Step 7: repeat = s[i] // 讀取當前 run 長度\n        → Step 8: For j in 1..repeat:\n            → Step 9: s.append(current) // 加入新的數字\n            → Decision: current==1 and len(s) <= n? // 是否計數\n                Yes → countOnes++ // 1 的數目增加\n                No  → Skip\n        → Step 10: current = 3 - current // 切換 1 <-> 2\n        → Step 11: i++ // 移動到下一個 run\n→ End // 返回 countOnes\n\nBut need more precise: After loop, we have countOnes computed. Output. Provide final step.\n\nLet's output each line with comment.\n\nOk.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: s = [1,2,2] // 初始魔法字串的三個數字\n→ Step 2: current = 1 // 下一個要寫入的數字是 1\n→ Step 3: i = 2 // 讀取指標，指向 s[2]（值為 2）\n→ Step 4: countOnes = 0 // 1 的總數，初始為 0\n→ Decision: n <= len(s) ? // 已經足夠長度，可直接統計\n    Yes → Step 5: For idx = 0 to n-1:\n        → Step 6: If s[idx] == 1 Then countOnes++ // 直接計算前 n 個 1\n        → Step 7: End For\n    No  → Step 8: While len(s) < n:\n        → Step 9: repeat = s[i] // 讀取當前跑長度\n        → Step 10: For j = 1 to repeat:\n            → Step 11: s.append(current) // 將 current 加入字串\n            → Decision: current == 1 AND len(s) <= n ? // 是否要計數\n                Yes → countOnes++ // 1 的數目增加\n                No  → Skip\n        → Step 12: current = 3 - current // 切換 1 <-> 2\n        → Step 13: i++ // 移動到下一個 run 長度\n        → End While\n→ End // 程式執行結束，countOnes 為前 n 個數字中 1 的個數\n```\n\n此虛擬碼逐行建立並擴充魔法字串，並在填寫過程中即時計算 1 的個數，最終得到前 n 個位置中 1 的總數。",
      "generated_code": "import sys\nimport re\n\ndef magical_string_ones(n: int) -> int:\n    \"\"\"Return the number of 1's in the first n elements of the magical string.\"\"\"\n    if n == 0:\n        return 0\n    if n <= 3:\n        # The first three elements are 1, 2, 2, so only one '1'.\n        return 1\n\n    s = [1, 2, 2]        # 初始魔法字串\n    head = 2             # 指向要擴充的 run 長度\n    num = 1              # 下一個要寫入的數字（1 或 2）\n\n    while len(s) < n:\n        # 把 num 重複 s[head] 次加入字串\n        s.extend([num] * s[head])\n        num = 3 - num    # 1 <-> 2 互換\n        head += 1\n\n    # 只計算前 n 個元素中的 1\n    return s[:n].count(1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n    result = magical_string_ones(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode200.json",
    "problem_index_in_file": 0,
    "title": "Number of Islands",
    "description_snippet": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with step-by-step explanation in Chinese. Use Start, Decision etc. Need to produce algorithm for counting islands: DFS/BFS. We'll generate virtual code lines. Should not output actual code. Provide each line with explanation. We'll write maybe something like:\n\nStart\n→ Step 1: 初始化 islands = 0\n→ Step 2: 遍歷每個格子 (i, j)\n    → Decision: 如果 grid[i][j] == '1'?\n        Yes → Step 3: islands += 1\n        → Step 4: 呼叫 DFS 或 BFS 清除連通區域\n        No → skip\n→ Step 5: Return islands\n\nBut we need to include steps for DFS procedure. Provide pseudo code inside. Use arrows. We need each line with explanation.\n\nLet's create a detailed pseudo code:\n\nStart\n→ Step 1: 設定 islands = 0\n→ Step 2: 取得行數 rows, 列數 cols\n→ Step 3: 創建方向陣列 dirs = [(1,0),(-1,0),(0,1),(0,-1)]\n→ Step 4: 建立迴圈遍歷每個格子 i in 0..rows-1, j in 0..cols-1\n    → Decision: grid[i][j] == '1'?\n        Yes →\n            → Step 5: islands += 1\n            → Step 6: 呼叫 DFS(i,j)\n        No → 無操作\n→ Step 7: 回傳 islands\n\nDFS function (as virtual step)\n→ Function DFS(x, y)\n    → Decision: x 或 y 越界或 grid[x][y] != '1'?\n        Yes → Return\n        No →\n            → Step 8: grid[x][y] = '0' // 標記為已訪問\n            → Step 9: 迭代 dirs\n                → Step 10: 呼叫 DFS(x+dx, y+dy)\n→ End\n\nBut we need to express each line in the format: \"虛擬碼步驟 // 解釋\". Use \"Start\" and \"End\". Use \"Decision:\" lines. Use arrow for Yes → and No →.\n\nWe'll need to maintain indentation for nested blocks. Use proper indentation.\n\nThe problem: Use Start/End, Step numbers. We need to produce each line separately.\n\nLet's produce.\n\nWe'll also need to produce explanation for each line. The explanation should be concise and intuitive.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 設定 islands = 0 // 初始化島嶼計數器\n→ Step 2: 取得 rows = grid 的行數, cols = grid 的列數 // 獲取格子尺寸\n→ Step 3: 定義 dirs = [(1,0),(-1,0),(0,1),(0,-1)] // 方向向量，方便鄰接探索\n→ Step 4: 循環遍歷每個格子 (i, j) // 主遍歷循環\n    → Decision: grid[i][j] == '1' ? // 判斷該格子是否為未被訪問的陸地\n        Yes → Step 5: islands += 1 // 發現新島嶼，計數加一\n        Yes → Step 6: DFS(i, j) // 從此格子開始深度優先搜索，標記整個島嶼\n        No  → // 若不是陸地，跳過\n→ Step 7: 回傳 islands // 返回島嶼總數\nEnd // 程式執行結束\n\nNow we need DFS function pseudo-code. Could be:\n\n→ Function DFS(x, y) // 定義深度優先搜索函式\n    → Decision: x < 0 或 x >= rows 或 y < 0 或 y >= cols 或 grid[x][y] != '1' ?\n        Yes → Return // 超出邊界或非陸地，終止遞歸\n        No  → Step 8: grid[x][y] = '0' // 標記已訪問\n        No  → Step 9: 迭代每個方向 (dx, dy) in dirs\n            → Step 10: DFS(x+dx, y+dy) // 進行遞歸搜索鄰接格子\n\nBut we need to integrate this inside the flow. We can treat the DFS as a separate subroutine; we can use \"→ Function DFS(x, y) // ...\".\n\nLet's produce with proper formatting.\n\nThe pseudo code must follow the arrow structure. For DFS we need to use \"→\" and indentation.\n\nLet's produce final answer with lines.\n\nWe need to keep each line as \"虛擬碼步驟 // 解釋\".\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 islands = 0 // 初始化島嶼計數器  \n→ Step 2: 取得 rows = grid 的行數, cols = grid 的列數 // 獲取格子尺寸  \n→ Step 3: 定義 dirs = [(1,0),(-1,0),(0,1),(0,-1)] // 方向向量，方便鄰接探索  \n→ Step 4: 循環遍歷每個格子 (i, j) // 主遍歷循環  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: grid[i][j] == '1' ? // 判斷該格子是否為未被訪問的陸地  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: islands += 1 // 發現新島嶼，計數加一  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: DFS(i, j) // 從此格子開始深度優先搜索，標記整個島嶼  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 若不是陸地，跳過  \n→ Step 7: 回傳 islands // 返回島嶼總數  \nEnd // 程式執行結束  \n\n// ---------- DFS 子程序 ----------  \n→ Function DFS(x, y) // 定義深度優先搜索函式  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: x < 0 或 x >= rows 或 y < 0 或 y >= cols 或 grid[x][y] != '1' ? // 檢查邊界或非陸地  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return // 超出邊界或不是陸地，結束遞歸  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 8: grid[x][y] = '0' // 標記為已訪問，避免重複計算  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: 迭代每個方向 (dx, dy) in dirs // 遍歷四個鄰接方向  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 10: DFS(x+dx, y+dy) // 遞歸探索鄰接格子  \n\n// ---------- 程式結束 ----------  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n\n        def dfs(i: int, j: int) -> None:\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return\n            if grid[i][j] == '0' or visited[i][j]:\n                return\n            visited[i][j] = True\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    dfs(i, j)\n                    count += 1\n        return count\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n    # Extract the right-hand side of \"grid = ...\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    try:\n        grid = ast.literal_eval(expr)\n    except Exception:\n        grid = []\n    solution = Solution()\n    print(solution.numIslands(grid))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode762.json",
    "problem_index_in_file": 0,
    "title": "Prime Number of Set Bits in Binary Representation",
    "description_snippet": "Given two integers left and right, return the count of numbers in the inclusive range [left, right] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. The requirement: \"Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation.\" So we need to iterate from left to right, count bits, check prime, increment.\n\nWe need to produce a virtual code with arrows and explanation. Use steps: Start, Decision, etc. Also include function definition? Likely yes. Use pseudo code.\n\nWe need to output line by line. Each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe must not output actual code. So use pseudo. Use Start and End. Use Decision: and arrow.\n\nLet's outline steps:\n\n- Start\n- Step 1: 定義輸入左、右\n- Step 2: 初始化計數器 count = 0\n- Step 3: 初始化數字 current = left\n- Decision: current <= right? \n  - Yes: \n    - Step 4: 計算 current 的 set bits -> bitCount\n    - Decision: bitCount 是質數? \n      - Yes: Step 5: count++\n      - No: (none)\n    - Step 6: current++\n    - Go back to Decision current <= right?\n  - No: Step 7: Return count\n- End\n\nAlso need a helper function to check prime. Might implement as separate step:\n\n- Step 8: 定義函式 isPrime(n): 判斷 n 是否質數\n  - Decision: n < 2? No -> False\n  - For i in 2..sqrt(n): if n % i == 0 -> False\n  - True\n\nBut since virtual code, we can show decision inside.\n\nLet's produce with arrow.\n\nMake sure each line has \"虛擬碼步驟\" + space + comment.\n\nE.g.:\n\nStart // 程式開始執行\n→ Step 1: 接收 left, right // 取得區間範圍\n→ Step 2: count ← 0 // 初始化計數\n→ Step 3: current ← left // 設定起始數\n→ Decision: current ≤ right? // 判斷是否還在區間內\n    Yes → Step 4: bitCount ← CountSetBits(current) // 計算當前數的置位數\n    Yes → Decision: isPrime(bitCount)? // 判斷置位數是否為質數\n        Yes → Step 5: count ← count + 1 // 若為質數則計數加一\n        No  → (無操作) // 若非質數則不變\n    Yes → Step 6: current ← current + 1 // 移至下一數\n    Yes → GoBack // 返回決策點\n    No  → Step 7: Return count // 輸出結果\nEnd // 程式結束\n\nNeed to add definition of CountSetBits and isPrime:\n\nBut maybe we can inline.\n\nAdd steps before main loop:\n\n→ Step 0: 定義函式 CountSetBits(n): // 計算 n 的二進位 1 的個數\n    ←  ... but need details.\n\nBetter to include simple pseudo:\n\n→ Step 0: 函式 CountSetBits(n): // 回傳 n 的置位數\n    → sum ← 0\n    → while n > 0:\n        → if n mod 2 == 1: sum ← sum + 1\n        → n ← n // 2\n    → return sum\n\nBut we cannot output actual code. Use pseudo.\n\nAlternatively just mention \"CountSetBits\" as built-in.\n\nAlso define isPrime.\n\nAdd those as separate steps.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 定義函式 CountSetBits(n) // 回傳 n 的 1 位數  \n    → Step 0.1: sum ← 0  \n    → Step 0.2: while n > 0  \n        → Step 0.2.1: if n mod 2 == 1 then sum ← sum + 1  \n        → Step 0.2.2: n ← n // 2  \n    → Step 0.3: return sum // 結束計算  \n→ Step 1: 定義函式 isPrime(x) // 判斷 x 是否質數  \n    → Step 1.1: if x < 2 then return False  \n    → Step 1.2: for i from 2 to floor(sqrt(x))  \n        → Step 1.2.1: if x mod i == 0 then return False  \n    → Step 1.3: return True // x 為質數  \n→ Step 2: 接收 left, right // 取得區間範圍  \n→ Step 3: count ← 0 // 初始化計數器  \n→ Step 4: current ← left // 設定起始數  \n→ Decision: current ≤ right? // 是否還在區間內  \n    Yes → Step 5: bitCount ← CountSetBits(current) // 計算目前數字的置位數  \n    Yes → Decision: isPrime(bitCount)? // 判斷置位數是否為質數  \n        Yes → Step 6: count ← count + 1 // 若為質數則計數加一  \n        No  → (無操作) // 若非質數則保持不變  \n    Yes → Step 7: current ← current + 1 // 移至下一數  \n    Yes → GoBack // 返回「Decision: current ≤ right?」  \n    No  → Step 8: return count // 輸出結果  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    \"\"\"Return the count of numbers in [left, right] whose binary\n    representation contains a prime number of set bits.\"\"\"\n    # Predefined set of prime numbers that can appear as bit counts for 32‑bit ints\n    primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}\n    count = 0\n    for num in range(left, right + 1):\n        # Count 1s in the binary representation\n        bits = bin(num).count('1')\n        if bits in primes:\n            count += 1\n    return count\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract all integer values from the input string\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        # Not enough numbers provided; nothing to compute\n        print(0)\n        return\n    left, right = int(nums[0]), int(nums[1])\n    result = count_prime_set_bits(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 6, right = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 10, right = 15",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode215.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in an Array",
    "description_snippet": "Given an integer array nums and an integer k, return the k^th largest element in the array.\n\nNote th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The algorithm: find kth largest without sorting. Use min-heap of size k or quickselect. Let's pick min-heap approach: iterate array, push element, if heap size>k, pop. After loop, root is kth largest. Provide steps: start, input array and k, create min-heap, for each number, insert, if size>k pop, after loop, output heap.peek. End.\n\nLet's format as required.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 整數陣列 nums 與 整數 k // 從使用者處取得陣列與參數  \n→ Step 2: 初始化 空的最小堆 heap // 用來保持目前最大的 k 個元素  \n→ Decision: 遍歷陣列 nums? // 檢查是否還有元素要處理  \n    Yes → Step 3: 將 nums[i] 插入 heap // 把目前元素加入堆中  \n    Yes → Step 4: 如果 heap 大小 > k? // 堆裡多於 k 個元素需要移除最小值  \n        Yes → Step 5: 從 heap 中移除根節點 (最小值) // 保持堆大小為 k  \n    Yes → Decision: 繼續遍歷下個元素?  \n        Yes → 返回 Step 3  \n        No → 轉到 Step 6  \n    No → 轉到 Step 6  \n→ Step 6: 取出 heap 根節點 // 堆頂即為第 k 大元素  \n→ Step 7: 輸出 取出的元素 // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport heapq\n\nclass Solution:\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        利用最小堆（size = k）來維護目前最大的 k 個元素。\n        1. 把前 k 個元素放進堆並 heapify。\n        2. 之後的每個元素若大於堆頂（最小值），則把堆頂移除並加入新元素。\n        3. 完成後堆頂即為第 k 大元素。\n        \"\"\"\n        heap = nums[:k]\n        heapq.heapify(heap)\n        for num in nums[k:]:\n            if num > heap[0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, num)\n        return heap[0]\n\ndef parse_input(text: str):\n    \"\"\"\n    解析輸入文字，例如：\n    'nums = [3,2,1,5,6,4], k = 2'\n    會回傳 ( [3,2,1,5,6,4], 2 )\n    \"\"\"\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, text)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    nums_str, k_str = match.group(1), match.group(2)\n    nums = eval(nums_str)          # 將字串轉成 list\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    nums, k = parse_input(raw_input)\n    result = Solution().findKthLargest(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode318.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Word Lengths",
    "description_snippet": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines with comments. The algorithm: iterate over words, compute bitmask of letters. Use nested loops, keep max product. Return 0 if none. Steps: Start, read input words, compute masks, nested loops, check mask AND, compute product, update max, end. Provide explanation each line. Use virtual code arrows. Let's craft.\n\nAlso maybe handle length, etc. Use simple pseudocode. No actual code. Just lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: words ← 輸入字串陣列 // 取得輸入的字串陣列  \n→ Step 2: masks ← 空陣列 // 用來存每個字串的 26 個字母位掩碼  \n→ Decision: 若 words 非空? // 確認有字串可處理  \n  Yes → → Step 3: 對每個 word 在 words 中執行  \n     → Step 4: mask ← 0 // 初始位掩碼  \n     → 對每個字元 c 在 word 中執行  \n      → Step 5: mask ← mask OR (1 << (c - 'a')) // 設置對應位  \n      → End  \n     → Step 6: 將 mask 加入 masks // 保存該字串的位掩碼  \n     → End  \n     → End  \n  No → → Step 7: Return 0 // 若沒有字串，直接返回 0  \n    → End  \n→ Step 8: maxProduct ← 0 // 初始化最大乘積  \n→ Step 9: 對 i 從 0 到 length(words)-1 執行  \n  → Step 10: 對 j 從 i+1 到 length(words)-1 執行  \n    → Decision: 若 masks[i] AND masks[j] == 0? // 判斷兩字串無共同字母  \n      Yes → → Step 11: product ← length(words[i]) * length(words[j]) // 計算乘積  \n       → Step 12: 若 product > maxProduct?  \n        Yes → → Step 13: maxProduct ← product // 更新最大值  \n        No → → Step 14: // 無需更新  \n        End  \n      No → → Step 15: // 有共同字母，跳過  \n       End  \n    → End  \n  → End  \n→ Step 16: Return maxProduct // 輸出最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProduct(self, words):\n        \"\"\"計算兩個不含相同字母的字串長度乘積之最大值。\"\"\"\n        n = len(words)\n        # 先把每個字串轉成 26 位的位掩碼\n        masks = [0] * n\n        for i, word in enumerate(words):\n            mask = 0\n            for ch in word:\n                mask |= 1 << (ord(ch) - ord('a'))\n            masks[i] = mask\n\n        max_prod = 0\n        # 二重迴圈找出所有不重複字母的組合\n        for i in range(n):\n            for j in range(i + 1, n):\n                if masks[i] & masks[j] == 0:  # 沒有共同字母\n                    prod = len(words[i]) * len(words[j])\n                    if prod > max_prod:\n                        max_prod = prod\n        return max_prod\n\ndef main():\n    \"\"\"從 stdin 讀取字串陣列，計算並輸出最大乘積。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入形式為 words = [...], 去掉前面的關鍵字\n    if data.startswith('words'):\n        _, rest = data.split('=', 1)\n        data = rest.strip()\n\n    # 解析字串陣列，安全使用 literal_eval\n    try:\n        words = ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，直接嘗試 json 解析\n        import json\n        words = json.loads(data)\n\n    sol = Solution()\n    result = sol.maxProduct(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode698.json",
    "problem_index_in_file": 0,
    "title": "Partition to K Equal Sum Subsets",
    "description_snippet": "Given an integer array nums and an integer k, return true if it is possible to divide this array int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: partition array into k equal sum subsets. So typical solution: backtracking with bitmask or visited array, sorting, pruning. Provide step-by-step pseudocode lines with explanation. Use Start, End, Decision, arrow. Each line: \"虛擬碼步驟 // 解釋\". Must be line-by-line, no real code, just structure. Use arrows →. Use Decision: If condition? with Yes → and No → sub-steps. The algorithm: compute sum, if sum%k != 0 return false. target = sum/k. Sort nums descending. visited array. Define backtrack(startIndex, kRemaining, currentSum). If kRemaining==1 return true (remaining numbers must sum to target). If currentSum==target: return backtrack(0, kRemaining-1, 0). Loop i from startIndex to n-1: if not visited[i] and currentSum+nums[i]<=target: visited[i]=true; if backtrack(i+1, kRemaining, currentSum+nums[i]) return true; visited[i]=false; if currentSum==0 or currentSum+nums[i]==target return false (pruning). return false. Then in main: call backtrack(0, k, 0). Return result.\n\nWe produce virtual code line by line. Use arrows, decisions. Let's outline lines:\n\nStart\n→ Step 1: 計算陣列總和 sum // 取得 nums 的總和\n→ Decision: 如果 sum % k ≠ 0? // 檢查是否能整除 k\n    Yes → Step 2: 回傳 false // 若不能整除，無法分組\n    No  → Step 3: 設定目標子集和 target = sum / k // 每個子集的目標和\n→ Step 4: 對 nums 進行降序排序 // 先放大數進行剪枝\n→ Step 5: 初始化 visited 陣列為 false // 標記每個元素是否已被分配\n→ Step 6: 呼叫 backtrack(0, k, 0) // 開始遞迴分配\n→ End // 程式結束\n\nNow define backtrack function:\n\n→ Decision: 定義 backtrack(start, kLeft, current) // start: 下一個可嘗試的索引，kLeft: 仍需分配的子集數，current: 當前子集已累積的和\n    → Step 7: Decision: 如果 kLeft == 1? // 最後一組自動滿足\n        Yes → Step 8: 回傳 true // 只剩一組，剩下的元素必定合目標和\n        No  →\n            → Decision: 如果 current == target? // 本組已達目標和，開始下一組\n                Yes → Step 9: 回傳 backtrack(0, kLeft - 1, 0) // 重新開始下個子集\n                No  →\n                    → Decision: 如果 current > target? // 超過目標和，直接失敗\n                        Yes → Step 10: 回傳 false\n                        No  →\n                            → Step 11: 循環 i from start to n-1 // 嘗試每個未被訪問的元素\n                                → Decision: 如果 visited[i] 或 current + nums[i] > target? // 已用或會超過目標\n                                    Yes → continue // 跳過此元素\n                                    No  →\n                                        → Step 12: visited[i] = true // 選擇此元素\n                                        → Step 13: Decision: 如果 backtrack(i + 1, kLeft, current + nums[i])? // 進一步遞迴\n                                            Yes → Step 14: 回傳 true // 找到成功分配\n                                            No  →\n                                                → Step 15: visited[i] = false // 取消選擇\n                                                → Decision: 如果 current == 0 或 current + nums[i] == target? // 前一個子集開始或剛好滿目標\n                                                    Yes → Step 16: 回傳 false // 這個分支不可能成功，剪枝\n                                                    No  →\n                                                        → continue // 試下一個元素\n                            → Step 17: 回傳 false // 所有嘗試失敗\n\nBut we need to output each line as a virtual code line. Use arrows and decisions with nested lines. Each line should be a single line of virtual code with explanation.\n\nNeed to format: \"Step X: ...\" maybe use Step numbers. Use arrow at start for each line after Start. For decisions, indent? They didn't specify indent, but example shows indentation of Yes → lines.\n\nWe need to represent nested decisions. Use indentation maybe with tabs. Use \"→ Decision:\" lines and then nested \"Yes →\" \"No →\". Let's replicate style.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Step 1: 計算陣列總和 sum // 取得 nums 的總和\n→ Decision: 如果 sum % k ≠ 0? // 檢查是否能整除 k\n    Yes → Step 2: 回傳 false // 若不能整除，無法分組\n    No  → Step 3: 設定目標子集和 target = sum / k // 每個子集的目標和\n→ Step 4: 對 nums 進行降序排序 // 先放大數進行剪枝\n→ Step 5: 初始化 visited 陣列為 false // 標記每個元素是否已被分配\n→ Step 6: 呼叫 backtrack(0, k, 0) // 開始遞迴分配\n→ End // 程式結束\n\nNow define backtrack:\n\n→ Step 7: 定義函式 backtrack(start, kLeft, current) // start: 下一個可嘗試的索引，kLeft: 仍需分配的子集數，current: 當前子集已累積的和\n    → Decision: 如果 kLeft == 1? // 最後一組自動滿足\n        Yes → Step 8: 回傳 true // 只剩一組，剩下的元素必定合目標和\n        No  →\n            → Decision: 如果 current == target? // 本組已達目標和，開始下一組\n                Yes → Step 9: 回傳 backtrack(0, kLeft - 1, 0) // 重新開始下個子集\n                No  →\n                    → Decision: 如果 current > target? // 超過目標和，直接失敗\n                        Yes → Step 10: 回傳 false\n                        No  →\n                            → Step 11: 循環 i from start 到 n-1 // 嘗試每個未被訪問的元素\n                                → Decision: 如果 visited[i] 或 current + nums[i] > target? // 已用或會超過目標\n                                    Yes → continue // 跳過此元素\n                                    No  →\n                                        → Step 12: visited[i] = true // 選擇此元素\n                                        → Step 13: Decision: 如果 backtrack(i + 1, kLeft, current + nums[i])? // 進一步遞迴\n                                            Yes → Step 14: 回傳 true // 找到成功分配\n                                            No  →\n                                                → Step 15: visited[i] = false // 取消選擇\n                                                → Decision: 如果 current == 0 或 current + nums[i] == target? // 前一個子集開始或剛好滿目標\n                                                    Yes → Step 16: 回傳 false // 這個分支不可能成功，剪枝\n                                                    No  →\n                                                        → continue // 試下一個元素\n                            → Step 17: 回傳 false // 所有嘗試失敗\n\nBut line 17 inside backtrack maybe should be after loop: \"回傳 false\". We have to ensure indentation.\n\nLet's craft final answer: Each line as described, with \"→\" arrow at start of step lines, and \"Decision:\" lines with indentation.\n\nWe need to output only virtual code lines and explanation. No code. Use no backticks? Example shows no backticks. We'll follow that.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算陣列總和 sum // 取得 nums 的總和  \n→ Decision: 如果 sum % k ≠ 0? // 檢查是否能整除 k  \n  Yes → Step 2: 回傳 false // 若不能整除，無法分組  \n  No  → Step 3: 設定目標子集和 target = sum / k // 每個子集的目標和  \n→ Step 4: 對 nums 進行降序排序 // 先放大數進行剪枝  \n→ Step 5: 初始化 visited 陣列為 false // 標記每個元素是否已被分配  \n→ Step 6: 呼叫 backtrack(0, k, 0) // 開始遞迴分配  \n→ End // 程式結束  \n\n→ Step 7: 定義函式 backtrack(start, kLeft, current) // start: 下一個可嘗試的索引，kLeft: 仍需分配的子集數，current: 當前子集已累積的和  \n  → Decision: 如果 kLeft == 1? // 最後一組自動滿足  \n   Yes → Step 8: 回傳 true // 只剩一組，剩下的元素必定合目標和  \n   No  →  \n    → Decision: 如果 current == target? // 本組已達目標和，開始下一組  \n     Yes → Step 9: 回傳 backtrack(0, kLeft - 1, 0) // 重新開始下個子集  \n     No  →  \n      → Decision: 如果 current > target? // 超過目標和，直接失敗  \n       Yes → Step 10: 回傳 false  \n       No  →  \n        → Step 11: 循環 i from start 到 n-1 // 嘗試每個未被訪問的元素  \n         → Decision: 如果 visited[i] 或 current + nums[i] > target? // 已用或會超過目標  \n          Yes → continue // 跳過此元素  \n          No  →  \n           → Step 12: visited[i] = true // 選擇此元素  \n           → Step 13: Decision: 如果 backtrack(i + 1, kLeft, current + nums[i])? // 進一步遞迴  \n            Yes → Step 14: 回傳 true // 找到成功分配  \n            No  →  \n             → Step 15: visited[i] = false // 取消選擇  \n             → Decision: 如果 current == 0 或 current + nums[i] == target? // 前一個子集開始或剛好滿目標  \n              Yes → Step 16: 回傳 false // 這個分支不可能成功，剪枝  \n              No  →  \n               → continue // 試下一個元素  \n            → Step 17: 回傳 false // 所有嘗試失敗",
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        total = sum(nums)\n        if total % k != 0:\n            return False\n        target = total // k\n        n = len(nums)\n        nums.sort(reverse=True)\n        # any element larger than target makes partition impossible\n        if nums[0] > target:\n            return False\n\n        visited = [False] * n\n\n        def backtrack(k_remaining: int, start: int, curr_sum: int) -> bool:\n            if k_remaining == 1:  # last group must automatically satisfy\n                return True\n            if curr_sum == target:\n                # current subset finished, start next subset\n                return backtrack(k_remaining - 1, 0, 0)\n            prev = -1  # to skip duplicates\n            for i in range(start, n):\n                if visited[i] or curr_sum + nums[i] > target or nums[i] == prev:\n                    continue\n                visited[i] = True\n                if backtrack(k_remaining, i + 1, curr_sum + nums[i]):\n                    return True\n                visited[i] = False\n                # pruning: if this element starts a subset or fills it exactly,\n                # no need to try further elements at this level\n                if curr_sum == 0 or curr_sum + nums[i] == target:\n                    return False\n                prev = nums[i]\n            return False\n\n        return backtrack(k, 0, 0)\n\ndef parse_input(data: str):\n    \"\"\"Parse input like 'nums = [4,3,2,3,5,2,1], k = 4'.\"\"\"\n    nums_match = re.search(r'\\[([^\\]]+)\\]', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not k_match:\n        raise ValueError(\"Input format is incorrect.\")\n    nums_str = nums_match.group(1)\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    k = int(k_match.group(1))\n    return nums, k\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums, k = parse_input(input_data)\n    sol = Solution()\n    result = sol.canPartitionKSubsets(nums, k)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,3,5,2,1], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode740.json",
    "problem_index_in_file": 0,
    "title": "Delete and Earn",
    "description_snippet": "You are given an integer array nums. You want to maximize the number of points you get by performing...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Problem is similar to House Robber on values. Approach: count frequencies of each number. Then DP: dp[x] = max(dp[x-1], dp[x-2]+x*count[x]). Start from min to max. End returns dp[maxVal].\n\nWe produce step by step virtual code. Need Start, End, decisions. Let's craft.\n\nStart\n→ Step 1: 初始化 frequency map freq // 建立每個數字出現次數\n→ Step 2: 找到最大數字 maxVal // 方便後續 DP 迭代\n→ Step 3: 建立 dp 陣列長度 maxVal+1 並設定 dp[0] = 0 // dp[0] 無法拿任何點\n→ Decision: 是否 maxVal >= 1? // 若有 1 以後處理\n    Yes → Step 4: 設定 dp[1] = freq[1]*1 // 第一個數字的獲利\n    No  → Step 5: End // 沒有數字直接結束\n→ Step 6: 從 2 到 maxVal 迭代\n    → Decision: 是否 nums[i-1] 需要考慮? // dp[i] 計算\n        Yes → Step 7: dp[i] = max(dp[i-1], dp[i-2] + i*freq[i]) // 決定保留或刪除 i\n        No  → Step 8: dp[i] = dp[i-1] // 若 freq[i]==0\n→ Step 9: 返回 dp[maxVal] // 最大獲利\n\nNeed proper virtual code syntax: Use \"→\" and \"Decision:\" and \"Yes →\" etc. Provide explanation after //.\n\nLet's produce each line accordingly. Ensure each line has single step.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 計算每個數字的出現頻率並存入 freq map // 便於後續點數計算\n→ Step 2: 確定最大數字 maxVal // DP 迭代至此\n→ Step 3: 初始化 dp 陣列長度 maxVal+1 並設 dp[0] = 0 // 基本狀態\n→ Decision: maxVal 是否 ≥ 1? // 需要處理第一個數字\n    Yes → Step 4: 設定 dp[1] = freq[1] * 1 // 只拿 1 的點數\n    No  → End // 若沒有任何數字直接結束\n→ Step 5: 從 i = 2 到 maxVal 進行迭代 // DP 主循環\n    → Decision: freq[i] 是否 > 0? // 是否有數字 i\n        Yes → Step 6: dp[i] = max(dp[i-1], dp[i-2] + i * freq[i]) // 決定是否取 i\n        No  → Step 7: dp[i] = dp[i-1] // 無數字 i，保留上一個結果\n→ Step 8: 回傳 dp[maxVal] // 最大可獲得點數\nEnd // 程式執行結束\n\nCheck each line formatting: need \"→\" before Step lines, \"Decision:\" lines. Indentation optional. Should follow format. Also after each line explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算每個數字的出現頻率並存入 freq map // 便於後續點數計算  \n→ Step 2: 確定最大數字 maxVal // 讓 DP 只需迭代到此  \n→ Step 3: 初始化 dp 陣列長度 maxVal+1 並設 dp[0] = 0 // 基本狀態  \n→ Decision: maxVal 是否 ≥ 1? // 判斷是否需要處理數字 1  \n Yes → Step 4: 設定 dp[1] = freq[1] * 1 // 只拿 1 的點數  \n No  → End // 若沒有任何數字直接結束  \n→ Step 5: 從 i = 2 到 maxVal 進行迭代 // DP 主循環  \n → Decision: freq[i] 是否 > 0? // 判斷是否有數字 i  \n  Yes → Step 6: dp[i] = max(dp[i-1], dp[i-2] + i * freq[i]) // 決定是否取 i  \n  No  → Step 7: dp[i] = dp[i-1] // 無數字 i，保留上一個結果  \n→ Step 8: 回傳 dp[maxVal] // 最大可獲得點數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def deleteAndEarn(self, nums):\n        if not nums:\n            return 0\n        count = Counter(nums)\n        max_num = max(nums)\n        dp = [0] * (max_num + 1)\n        dp[1] = count.get(1, 0) * 1\n        for i in range(2, max_num + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2] + count.get(i, 0) * i)\n        return dp[max_num]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        nums = []\n    else:\n        nums = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.deleteAndEarn(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "[2,2,3,3,3,4]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode66.json",
    "problem_index_in_file": 0,
    "title": "Plus One",
    "description_snippet": "You are given a large integer represented as an integer array digits, where each digits[i] is the it...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line. We need to follow output format exactly: each line \"虛擬碼步驟 // 解釋\". Use arrow etc. We need to handle adding one to large integer represented as array digits. We need to start Start. Then we need to iterate from end to start. We need to handle carry. Steps: set carry = 1; for i from len-1 to 0: sum = digits[i] + carry; if sum >=10 then digits[i] = sum-10; carry =1; else digits[i] = sum; carry=0; break? Actually after break we need to skip remaining indices, but we can just continue but if carry=0 break loop. After loop, if carry still 1, insert 1 at beginning. Then return digits. Then End.\n\nLet's produce. Use arrow for decisions. Example:\n\nStart // 程式開始執行\n→ Step 1: Initialize carry = 1 // 先設定進位為 1，表示加 1\n→ Step 2: Set i = length(digits) - 1 // 從最右位開始處理\n→ Decision: 是否已經處理完所有位? // 判斷是否還有位數需要處理\n    Yes → End // 所有位已處理完畢，跳至結束\n    No → Step 3: sum = digits[i] + carry // 將當前位與進位相加\n    → Decision: sum >= 10? // 判斷是否需要進位\n        Yes → Step 4: digits[i] = sum - 10 // 將位數調整為 0-9\n                → Step 5: carry = 1 // 產生進位\n        No  → Step 6: digits[i] = sum // 位數不超過 9，直接存入\n                → Step 7: carry = 0 // 不再進位\n    → Step 8: i = i - 1 // 移動到下一位\n→ Decision: carry == 1? // 處理完所有位後還有進位\n    Yes → Step 9: insert 1 at position 0 of digits // 在最前面插入 1\n    No  → Step 10: // 無進位，保持原陣列\n→ End // 程式執行結束\n\nBut need to be exactly \"虛擬碼步驟\" then space then \"// 解釋\". The arrow lines should start with \"→ \". The decision lines indent with spaces? In example, they used indentation of 4 spaces then \"Yes →\". Let's replicate. Use four spaces before Yes →. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: carry = 1 // 設定進位為 1，代表加 1\n→ Step 2: i = length(digits) - 1 // 從右端最少重要位開始\n→ Decision: i < 0? // 是否已處理完所有位？\n    Yes → End // 完成所有位數處理，跳至結束\n    No  → Step 3: sum = digits[i] + carry // 將當前位加上進位\n        → Decision: sum >= 10? // 判斷是否需要進位\n            Yes → Step 4: digits[i] = sum - 10 // 將位數調回 0-9\n                    → Step 5: carry = 1 // 設定進位為 1\n            No  → Step 6: digits[i] = sum // 位數不超過 9\n                    → Step 7: carry = 0 // 無進位\n        → Step 8: i = i - 1 // 移動到前一位\n→ Decision: carry == 1? // 迴圈結束後還有進位嗎？\n    Yes → Step 9: insert 1 at index 0 of digits // 在最前面插入 1\n    No  → // 無進位，保持現有陣列\nEnd // 程式執行結束\n\nCheck indentation: In example, they used 4 spaces before Yes→ etc. We'll do same.\n\nWe must ensure no actual code output. We just produce lines. Use arrow. Provide Chinese explanations. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: carry = 1 // 設定進位為 1，代表加 1  \n→ Step 2: i = length(digits) - 1 // 從右端最少重要位開始  \n→ Decision: i < 0? // 是否已處理完所有位？  \n    Yes → End // 完成所有位數處理，跳至結束  \n    No → Step 3: sum = digits[i] + carry // 將當前位加上進位  \n        → Decision: sum >= 10? // 判斷是否需要進位  \n            Yes → Step 4: digits[i] = sum - 10 // 將位數調回 0-9  \n                    → Step 5: carry = 1 // 設定進位為 1  \n            No → Step 6: digits[i] = sum // 位數不超過 9  \n                    → Step 7: carry = 0 // 無進位  \n        → Step 8: i = i - 1 // 移動到前一位  \n→ Decision: carry == 1? // 迴圈結束後還有進位嗎？  \n    Yes → Step 9: insert 1 at index 0 of digits // 在最前面插入 1  \n    No → // 無進位，保持現有陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits\n\ndef read_digits_from_input():\n    \"\"\"\n    Reads stdin and extracts the integer list.\n    Supports inputs like:\n        digits = [1,2,3]\n    or just:\n        [1,2,3]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return []\n    # Find the first '[' and the last ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        return []\n    list_str = data[start:end+1]\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    digits = read_digits_from_input()\n    if digits:\n        result = Solution().plusOne(digits)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "digits = [1,2,3]",
          "expected_output": "[1,2,4]",
          "success": true,
          "output": "[1, 2, 4]"
        },
        {
          "example_index": 1,
          "input": "digits = [4,3,2,1]",
          "expected_output": "[4,3,2,2]",
          "success": true,
          "output": "[4, 3, 2, 2]"
        },
        {
          "example_index": 2,
          "input": "digits = [9]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode646.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Pair Chain",
    "description_snippet": "You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.\n\nA pair...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo code steps for longest chain of pairs. This is classic dynamic programming or greedy? For longest chain, we can sort by right endpoint and use greedy to choose next pair with left greater than last chosen right. That yields maximum chain length? For intervals with no overlapping allowed. That is longest chain with pair ordering. It's like maximum number of non-overlapping intervals. Greedy works: sort by right ascending, then pick pairs sequentially. So algorithm: sort pairs by right; initialize count=0, current_end=-inf; iterate pairs sorted: if pair.left > current_end: count++; current_end = pair.right. return count.\n\nThus virtual code lines accordingly.\n\nWe need to produce lines with step arrow and explanation. Each line: \"Start // 程式開始執行\" etc. We'll need steps:\n\n1. Start\n2. → Step 1: 輸入 pairs // 獲取輸入的 pairs 陣列\n3. → Step 2: 對 pairs 按 right 值升序排序 // 先按右端排序\n4. → Step 3: 初始化 chain_len = 0, last_end = -∞ // 準備計算\n5. → Step 4: 遍歷 sorted pairs // 逐一檢查\n6.   → Decision: 如果 current_pair.left > last_end? // 是否可以連接\n        Yes → Step 5: chain_len++ // 成功連接，長度加一\n        Yes → Step 6: last_end = current_pair.right // 更新最後右端\n        No  → Step 7: 跳過此 pair // 不連接，忽略\n7. → Step 8: 返回 chain_len // 結果\n\nBut we need to keep line numbering and arrow notation? Format example uses \"→ Step 1:\" etc. For decisions, use \"Decision:\" lines.\n\nAlso must ensure each line ends with \"// 解釋/說明\".\n\nAlso need to use \"Yes →\", \"No →\" for branching. In sample, they used indentation? They used lines under Decision with indentation.\n\nWe need to match that style.\n\nLet's produce lines accordingly.\n\nAlso use Start, End at end.\n\nLet's produce.\n\nNeed to include arrow at each step.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入 pairs // 獲取輸入的 pairs 陣列\n→ Step 2: 對 pairs 按 right 值升序排序 // 先按右端排序，便於後續選擇\n→ Step 3: 初始化 chain_len = 0, last_end = -∞ // 計算長度與上一次選擇的右端\n→ Step 4: 遍歷 sorted pairs // 逐一檢查每個 pair 是否可連接\n    → Decision: 如果 current_pair.left > last_end? // 判斷能否連接\n        Yes → Step 5: chain_len++ // 成功連接，長度加一\n        Yes → Step 6: last_end = current_pair.right // 更新最後右端為本 pair 的右端\n        No  → Step 7: // 跳過此 pair，不做任何變化\n→ Step 8: 返回 chain_len // 輸出最長連鎖長度\nEnd // 程式執行結束\n\nBut we need to ensure each line has \"虛擬碼步驟\" and \" // 解釋/說明\". We have included explanation after comment.\n\nHowever \"Step 7\" comment says \" // 跳過此 pair，不做任何變化\". That's fine.\n\nBut we need to keep \"Yes → Step 5\" etc. In sample they used indentation lines under Decision.\n\nWe may use similar. Also each line must end with // 解釋. Yes.\n\nAlso \"Decision:\" line should have // 解釋.\n\nLet's adjust:\n\nStart // 程式開始執行\n→ Step 1: 輸入 pairs // 獲取輸入的 pairs 陣列\n→ Step 2: 對 pairs 按 right 值升序排序 // 先按右端排序，便於後續選擇\n→ Step 3: 初始化 chain_len = 0, last_end = -∞ // 計算長度與上一次選擇的右端\n→ Step 4: 遍歷 sorted pairs // 逐一檢查每個 pair 是否可連接\n    → Decision: 如果 current_pair.left > last_end? // 判斷能否連接\n        Yes → Step 5: chain_len++ // 成功連接，長度加一\n        Yes → Step 6: last_end = current_pair.right // 更新最後右端為本 pair 的右端\n        No  → Step 7: // 跳過此 pair，不做任何變化\n→ Step 8: 返回 chain_len // 輸出最長連鎖長度\nEnd // 程式執行結束\n\nBut we need each line to be separate line. Indentation for decision branch lines. They used tabs or spaces. We'll use 4 spaces.\n\nWe should ensure that each line is \"虛擬碼步驟\" then space then comment. Our lines above are okay.\n\nBut we might include \"Step 4: 遍歷 sorted pairs // 逐一檢查每個 pair 是否可連接\" and then indented Decision line. Good.\n\nBut note \"No → Step 7: // 跳過此 pair，不做任何變化\". We need a Step 7 content. Might just leave blank after colon.\n\nAlternatively \"No → Step 7: // 跳過此 pair，不做任何變化\".\n\nHowever the format expects \"虛擬碼步驟\" after No →. So \"Step 7:\" may not need to include anything after colon. But we can still include comment after slash.\n\nLet's adjust: \"No → Step 7: // 跳過此 pair，不做任何變化\". This is okay.\n\nNow we must ensure the Start and End lines also have comments.\n\nNow deliver final answer.\n\nAlso might add that we use -∞ representation maybe -1 or negative infinity.\n\nBut keep explanation short.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 pairs // 取得輸入的 pairs 陣列  \n→ Step 2: 對 pairs 按 right 值升序排序 // 先按右端排序，方便後續選擇  \n→ Step 3: 初始化 chain_len = 0, last_end = -∞ // 設定鏈長度與上一次選擇的右端  \n→ Step 4: 遍歷 sorted pairs // 逐一檢查每個 pair 是否可連接  \n  → Decision: 如果 current_pair.left > last_end? // 判斷能否連接  \n   Yes → Step 5: chain_len++ // 成功連接，長度加一  \n   Yes → Step 6: last_end = current_pair.right // 更新最後右端為本 pair 的右端  \n   No → Step 7: // 跳過此 pair，不做任何變化  \n→ Step 8: 返回 chain_len // 輸出最長連鎖長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入格式為 \"pairs = [[...]]\" 或 \"pairs=[[...]]\" 等，去除前導文字\n    if data.startswith('pairs'):\n        parts = data.split('=', 1)\n        if len(parts) == 2:\n            data = parts[1].strip()\n\n    # 轉成 Python 物件，使用 ast.literal_eval 以避免 eval 的安全風險\n    pairs = ast.literal_eval(data)\n\n    # 依右端升序排序，這樣 greedy 可以取得最大長度\n    pairs.sort(key=lambda x: x[1])\n\n    curr_end = float('-inf')\n    chain_len = 0\n    for left, right in pairs:\n        if left > curr_end:\n            curr_end = right\n            chain_len += 1\n\n    # 將答案輸出到標準輸出\n    print(chain_len)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pairs = [[1,2],[2,3],[3,4]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "pairs = [[1,2],[7,8],[4,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode472.json",
    "problem_index_in_file": 0,
    "title": "Concatenated Words",
    "description_snippet": "Given an array of strings words (without duplicates), return all the concatenated words in the given...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code. The problem: given array of strings words (unique), find all concatenated words formed by at least two shorter words from list. Typical solution: sort words by length, use a Trie or hash set, DP per word. Virtual steps: Start, Build Trie or set, iterate sorted words, for each word check if can be segmented into at least two words, if yes add to result. At the end End. Include Decision nodes.\n\nWe need to output line by line: virtual code step + // explanation. Use arrow → for steps, Decision: for if conditions, Yes →, No →. Use Start, End. Also need to show building data structure.\n\nLet's craft.\n\nStep 1: Start.\n\nStep 2: Initialize empty set wordSet.\n\nStep 3: Sort words by length ascending.\n\nStep 4: Initialize empty list result.\n\nStep 5: For each word in sorted words:\n\n- Decision: if word length is 0? skip.\n\n- Decision: if word can be segmented into at least two words? Use DP.\n\n- Yes → add word to result and wordSet.\n\n- No → add word to wordSet only.\n\nNeed to define segmentation check: DP array of bool of size len+1. dp[0]=True. For i from 1 to len, for j from 0 to i-1, if dp[j] and substring j,i in wordSet, dp[i]=True, break. After loop, if dp[len] and at least two words used? The dp ensures at least one segmentation; but we need at least two words. We can check by ensuring that we can segment using at least two words: we can count splits. Simpler: When checking substrings, we can skip whole word itself; we can check if dp[len] and length>0. But to ensure at least two words, we can check that the word is not empty and we found segmentation where i!=len? Actually segmentation ensures at least one split. For word like \"aaaa\" with words [\"a\",\"aa\",\"aaaa\"] sorted; if we process \"a\" first, then \"aa\", then \"aaaa\" can be \"aa\"+\"aa\" or \"a\"+\"aaa\"? We can ensure we don't use the word itself as the only component. In DP, we only use existing words from wordSet which doesn't contain current word yet, so segmentation will require at least two words.\n\nThus DP works. After segmentation, add to result.\n\nAlso after processing each word, add to wordSet to allow future words to use it.\n\nWe need to produce virtual code lines: Use arrow for loops, decisions, etc.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 wordSet // 用於快速查找已處理的單字\n→ Step 2: 將 words 按長度升序排序 // 確保短字先處理，便於分割\n→ Step 3: 建立空列表 result // 儲存符合條件的連接字\n→ Step 4: For 每個 word 依序在 sortedWords // 逐一檢查每個單字\n    → Decision: 若 word 為空字串? // 直接跳過\n        Yes → Continue // 空字無需處理\n        No  → \n            → Step 5: 初始化布林陣列 dp[0..len(word)] 並將 dp[0]=True // dp[i] 表示前 i 個字可被分割\n            → Step 6: For i 1..len(word) // 檢查所有分割點\n                → Decision: 是否存在 j < i 使得 dp[j] 且 substring(j,i) 在 wordSet? // 檢查前半段可分且後半段已知字\n                    Yes → \n                        → Step 7: 設置 dp[i] = True // 這個位置可分割\n                        → Step 8: Break // 找到一個合法分割即可\n                    No → // 仍然繼續檢查其他 j\n            → Step 9: Decision: dp[len(word)] 為 True? // 是否完整可分割\n                Yes → \n                    → Step 10: 加入 word 至 result // 符合條件的連接字\n                No → // 不符合條件，略過\n            → Step 11: 加入 word 至 wordSet // 之後的字可使用此字進行分割\n→ End // 程式結束\n\nWe need to ensure every line is formatted: `虛擬碼步驟 // 解釋`. Use `→` before each step, Decision lines separate.\n\nWe might also use indentation: In example they used indentation for nested steps. Let's replicate.\n\nWe must output exactly each line. For decisions, they used: `Decision: ...` then indent and Yes→, No→ lines.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 wordSet // 用於快速查找已處理的單字  \n→ Step 2: 將 words 按長度升序排序 // 確保短字先處理，便於分割  \n→ Step 3: 建立空列表 result // 儲存符合條件的連接字  \n→ Step 4: For 每個 word 依序在 sortedWords // 逐一檢查每個單字  \n    → Decision: 若 word 為空字串? // 直接跳過  \n        Yes → Continue // 空字無需處理  \n        No →  \n            → Step 5: 初始化布林陣列 dp[0..len(word)] 並將 dp[0]=True // dp[i] 表示前 i 個字可被分割  \n            → Step 6: For i 1..len(word) // 檢查所有分割點  \n                → Decision: 是否存在 j < i 使得 dp[j] 且 substring(j,i) 在 wordSet? // 檢查前半段可分且後半段已知字  \n                    Yes →  \n                        → Step 7: 設置 dp[i] = True // 這個位置可分割  \n                        → Step 8: Break // 找到一個合法分割即可  \n                    No → // 仍然繼續檢查其他 j  \n            → Step 9: Decision: dp[len(word)] 為 True? // 是否完整可分割  \n                Yes →  \n                    → Step 10: 加入 word 至 result // 符合條件的連接字  \n                No → // 不符合條件，略過  \n            → Step 11: 加入 word 至 wordSet // 之後的字可使用此字進行分割  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 用於快速查找已處理的單字\n        word_set = set(words)\n        # 將單字按長度升序排序，短字先處理\n        words_sorted = sorted(words, key=len)\n        result = []\n\n        for word in words_sorted:\n            if not word:               # 空字直接跳過\n                continue\n            # 先把目前單字從集合中移除，避免把自己當作部件\n            word_set.discard(word)\n            # 動態規劃：dp[i] 表示前 i 個字母能否被分割\n            dp = [False] * (len(word) + 1)\n            dp[0] = True\n            for i in range(1, len(word) + 1):\n                for j in range(i):\n                    if not dp[j]:\n                        continue\n                    if word[j:i] in word_set:\n                        dp[i] = True\n                        break\n            # 如果完整單字能被分割（且至少使用兩個子字），則加入結果\n            if dp[len(word)]:\n                result.append(word)\n            # 把目前單字重新加入集合，供後續單字使用\n            word_set.add(word)\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 取得單字列表，支援 'words = [...]' 或直接 '[...]' 的輸入格式\n    try:\n        if '=' in raw_input:\n            _, list_part = raw_input.split('=', 1)\n            list_part = list_part.strip()\n        else:\n            list_part = raw_input\n        words_list = ast.literal_eval(list_part)\n    except Exception:\n        # 若解析失敗，直接終止\n        sys.exit()\n\n    solution = Solution()\n    concatenated_words = solution.findAllConcatenatedWordsInADict(words_list)\n    print(concatenated_words)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        },
        {
          "example_index": 1,
          "input": "words = [\"cat\",\"dog\",\"catdog\"]",
          "expected_output": "[\"catdog\"]",
          "success": true,
          "output": "['catdog']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode341.json",
    "problem_index_in_file": 0,
    "title": "Flatten Nested List Iterator",
    "description_snippet": "You are given a nested list of integers nestedList. Each element is either an integer or a list whos...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a NestedIterator class with constructor, next, hasNext, flatten logic. Use virtual code syntax. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use Start End. Should explain each step. Provide steps of algorithm: use stack to store iterators, flatten on demand. Steps: initialization: push iterator of nestedList onto stack. hasNext: while stack not empty: peek top; if top has next: get element; if element is integer: set nextInt = element; return true; else: push iterator of list onto stack; else: pop stack. next: return nextInt. Also need to handle storing next value. Could use variable. Provide steps for methods.\n\nLet's produce line-by-line.\n\nWe should include steps for class definition? We can start with Start // 程式開始執行.\n\nWe'll create pseudo-code for class NestedIterator:\n\n- Start\n- → Step 1: Define class NestedIterator // 定義類別\n- → Step 2: Constructor receives nestedList // 初始化\n- → Step 3: 初始化 stack with iterator of nestedList // 放入堆疊\n- → Step 4: nextInt = None // 用於暫存下一個整數\n- → Step 5: define hasNext() // 判斷是否還有整數\n- → Step 6: While stack not empty // 迴圈\n- → Step 7: top = stack.peek() // 取最頂迭代器\n- → Step 8: If top.hasNext() // 有下一項\n- → Step 9: element = top.next() // 取得元素\n- → Step 10: If element.isInteger() // 是整數\n- → Step 11: nextInt = element.getInteger() // 記錄\n- → Step 12: return True // 有下個整數\n- → Step 13: Else // 是列表\n- → Step 14: stack.push(element.getList().iterator()) // 推進新迭代器\n- → Step 15: Else // top已無元素\n- → Step 16: stack.pop() // 從堆疊移除\n- → Step 17: End while // 重複\n- → Step 18: return False // 沒有下個整數\n- → Step 19: define next() // 取得下個整數\n- → Step 20: return nextInt // 回傳\n- End\n\nNeed to include explanation per line. Ensure each line includes \"虛擬碼步驟 // 解釋\". Provide arrow format. Use \"Start\", \"End\". Let's produce.\n\nWe need to ensure we use proper format: each line: `虛擬碼步驟 // 解釋`. For decisions, use `Decision:`. Use \"Yes →\", \"No →\". We might incorporate decision within loop: \"Decision: top.hasNext()?\" But simpler to express with if/else.\n\nUse \"Decision:\" for if. Example:\n\n`Decision: stack not empty?` then Yes→ ... No→ End while.\n\nBut easier: while loop with condition. Provide step: `Decision: stack not empty?`.\n\nLet's craft:\n\nStart\n→ Step 1: Define class NestedIterator // 定義迭代器類別\n→ Step 2: Constructor NestedIterator(List<NestedInteger> nestedList) // 建構子接收巢狀列表\n→ Step 3: 初始化 stack ← new Stack<Iterator<NestedInteger>>() // 堆疊儲存迭代器\n→ Step 4: stack.push(nestedList.iterator()) // 將外層迭代器推入堆疊\n→ Step 5: nextInt ← null // 暫存下一個整數\n→ Step 6: Define hasNext() // 判斷是否還有下一個整數\n→ Decision: stack not empty? // 是否還有未處理的迭代器\n    Yes →\n        → Step 7: top ← stack.peek() // 取得最頂迭代器\n        → Decision: top.hasNext()? // 迭代器還有元素嗎？\n            Yes →\n                → Step 8: element ← top.next() // 取得下一項\n                → Decision: element.isInteger()? // 是整數還是列表？\n                    Yes →\n                        → Step 9: nextInt ← element.getInteger() // 記錄整數\n                        → Step 10: return True // 找到下個整數\n                    No →\n                        → Step 11: stack.push(element.getList().iterator()) // 推進子列表迭代器\n                        → Step 12: // 回到 Decision: top.hasNext()? 迴圈繼續\n            No →\n                → Step 13: stack.pop() // 移除已完成的迭代器\n                → Step 14: // 回到 Decision: stack not empty? 迴圈繼續\n→ Step 15: return False // 沒有更多整數\n→ Step 16: Define next() // 取得下個整數\n→ Step 17: return nextInt // 回傳已儲存的整數\nEnd\n\nEnsure each line has arrow and comment. Provide proper formatting. Use \"→\" before steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class NestedIterator // 定義 NestedIterator 迭代器類別  \n→ Step 2: Constructor NestedIterator(List<NestedInteger> nestedList) // 建構子接收巢狀列表  \n→ Step 3: 初始化 stack ← new Stack<Iterator<NestedInteger>>() // 堆疊儲存迭代器  \n→ Step 4: stack.push(nestedList.iterator()) // 將外層迭代器推入堆疊  \n→ Step 5: nextInt ← null // 暫存下一個整數  \n→ Step 6: Define hasNext() // 判斷是否還有下一個整數  \n→ Decision: stack not empty? // 是否還有未處理的迭代器  \n    Yes →  \n        → Step 7: top ← stack.peek() // 取得最頂迭代器  \n        → Decision: top.hasNext()? // 迭代器還有元素嗎？  \n            Yes →  \n                → Step 8: element ← top.next() // 取得下一項  \n                → Decision: element.isInteger()? // 是整數還是列表？  \n                    Yes →  \n                        → Step 9: nextInt ← element.getInteger() // 記錄整數  \n                        → Step 10: return True // 找到下個整數  \n                    No →  \n                        → Step 11: stack.push(element.getList().iterator()) // 推進子列表迭代器  \n                        → Step 12: // 回到 Decision: top.hasNext()? 迴圈繼續  \n            No →  \n                → Step 13: stack.pop() // 移除已完成的迭代器  \n                → Step 14: // 回到 Decision: stack not empty? 迴圈繼續  \n→ Step 15: return False // 沒有更多整數  \n→ Step 16: Define next() // 取得下個整數  \n→ Step 17: return nextInt // 回傳已儲存的整數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass NestedIterator:\n    def __init__(self, nestedList):\n        \"\"\"初始化，將巢狀列表展平成一維列表，並設置索引。\"\"\"\n        self.flat = []\n        self._flatten(nestedList)\n        self.index = 0\n\n    def _flatten(self, item):\n        \"\"\"遞迴將任何巢狀結構轉換為整數列表。\"\"\"\n        # 如果是整數，直接加入\n        if isinstance(item, int):\n            self.flat.append(item)\n        # 如果是 Python list，遞迴處理每個元素\n        elif isinstance(item, list):\n            for sub in item:\n                self._flatten(sub)\n        # 如果是 NestedInteger 物件（可能帶有 isInteger 等方法）\n        else:\n            if hasattr(item, 'isInteger'):\n                if item.isInteger():\n                    self.flat.append(item.getInteger())\n                else:\n                    for sub in item.getList():\n                        self._flatten(sub)\n\n    def next(self):\n        \"\"\"返回下一個整數並移動索引。\"\"\"\n        val = self.flat[self.index]\n        self.index += 1\n        return val\n\n    def hasNext(self):\n        \"\"\"判斷是否還有未遍歷的整數。\"\"\"\n        return self.index < len(self.flat)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，預期形如 \"nestedList = [[1,1],2,[1,1]]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    nested_list = ast.literal_eval(expr.strip())\n\n    iterator = NestedIterator(nested_list)\n    result = []\n    while iterator.hasNext():\n        result.append(iterator.next())\n\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nestedList = [[1,1],2,[1,1]]",
          "expected_output": "[1,1,2,1,1]",
          "success": true,
          "output": "[1, 1, 2, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "nestedList = [1,[4,[6]]]",
          "expected_output": "[1,4,6]",
          "success": true,
          "output": "[1, 4, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode485.json",
    "problem_index_in_file": 0,
    "title": "Max Consecutive Ones",
    "description_snippet": "Given a binary array nums, return the maximum number of consecutive 1's in the array....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with steps, arrows, decisions, etc. Problem: given binary array, return max consecutive 1s. We'll produce steps: start, initialize maxCount, currentCount, iterate through array, if element is 1 then increment currentCount else update maxCount and reset currentCount, after loop update maxCount, output result. End. Use \"→\" arrows. Ensure each line: Virtual code step + space + // explanation. Provide decision structure? No decision but maybe \"Decision: 如果 nums[i] == 1?\" with Yes and No branches. We'll produce loops and conditions.\n\nLet's produce lines:\n\nStart // 開始程式\n→ Step 1: 設定 maxCount ← 0 // 初始最大連續 1 的數量\n→ Step 2: 設定 currentCount ← 0 // 當前連續 1 的數量\n→ Step 3: 迭代 i 從 0 到 nums.length - 1 // 遍歷整個陣列\n    → Decision: 如果 nums[i] == 1? // 判斷當前元素是否為 1\n        Yes → Step 4: currentCount ← currentCount + 1 // 連續 1 增加\n        No  → Decision: 如果 currentCount > maxCount? // 目前已結束一段連續 1，更新最大值\n            Yes → Step 5: maxCount ← currentCount // 更新最大值\n            No  → Step 6: // 何不更新，保持現有 maxCount\n        → Step 7: currentCount ← 0 // 重新計算新的連續 1\n→ Decision: 如果 currentCount > maxCount? // 循環結束後仍可能有更長連續 1\n    Yes → Step 8: maxCount ← currentCount // 更新最大值\n    No  → Step 9: // 不需要更新\n→ Step 10: 回傳 maxCount // 回傳結果\nEnd // 程式結束\n\nBut we need each line unique and not indented? They want \"→\" arrows, but may include nested indentation for clarity. We'll keep indentation to show substeps but each line still must be a line. Use \"→\" for each step. For decisions, use \"Decision:\" and then Yes → and No → lines.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: maxCount ← 0 // 初始化最大連續 1 的計數\n→ Step 2: currentCount ← 0 // 初始化當前連續 1 的計數\n→ Step 3: 迴圈 i = 0 從 0 到 nums.length-1 // 遍歷陣列\n    → Decision: nums[i] == 1? // 判斷元素是否為 1\n        Yes → Step 4: currentCount ← currentCount + 1 // 增加連續 1\n        No  → Decision: currentCount > maxCount? // 檢查是否需要更新最大值\n            Yes → Step 5: maxCount ← currentCount // 更新最大值\n            No  → // 不更新\n        → Step 6: currentCount ← 0 // 重置連續計數\n→ Decision: currentCount > maxCount? // 迴圈結束後檢查最後一段連續 1\n    Yes → Step 7: maxCount ← currentCount // 更新最大值\n    No  → // 無需更新\n→ Step 8: return maxCount // 回傳結果\nEnd // 程式結束\n\nMake sure each line ends with // explanation. The Decision lines also need explanation after comment. Eg: \"Decision: nums[i] == 1? // 判斷當前元素是否為 1\". For Yes and No lines, we need explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: maxCount ← 0 // 初始化最大連續 1 的計數  \n→ Step 2: currentCount ← 0 // 初始化當前連續 1 的計數  \n→ Step 3: 迴圈 i = 0 從 0 到 nums.length-1 // 遍歷整個陣列  \n  → Decision: nums[i] == 1? // 判斷當前元素是否為 1  \n   Yes → Step 4: currentCount ← currentCount + 1 // 連續 1 的計數加 1  \n   No  → Decision: currentCount > maxCount? // 判斷是否需要更新最大值  \n    Yes → Step 5: maxCount ← currentCount // 更新最大連續 1 的數量  \n    No  → // 目前最大值已足夠，無需更新  \n   → Step 6: currentCount ← 0 // 重置連續 1 的計數  \n→ Decision: currentCount > maxCount? // 迴圈結束後檢查最後一段連續 1  \n  Yes → Step 7: maxCount ← currentCount // 若更長，更新最大值  \n  No  → // 最長連續 1 已在 maxCount，無需變動  \n→ Step 8: return maxCount // 回傳最大的連續 1 數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_max_consecutive_ones(nums):\n    \"\"\"回傳陣列中 1 的最大連續數量。\"\"\"\n    max_count = 0\n    current = 0\n    for num in nums:\n        if num == 1:\n            current += 1\n            if current > max_count:\n                max_count = current\n        else:\n            current = 0\n    return max_count\n\ndef parse_input(raw_input: str):\n    \"\"\"將 'nums = [1,0,1]' 之類的字串解析為 list[int]。\"\"\"\n    # 找到等號並取右側\n    if '=' in raw_input:\n        _, part = raw_input.split('=', 1)\n    else:\n        part = raw_input\n    part = part.strip()\n    # 使用 literal_eval 以安全方式解析\n    return ast.literal_eval(part)\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    nums = parse_input(raw)\n    result = find_max_consecutive_ones(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,0,1,1,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode453.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode step by step for solving the problem: given an array nums of size n, we want minimum moves to make all equal by incrementing n-1 elements by 1 per move. Equivalent to decrementing one element by 1 each move. Minimum moves equals sum(nums) - n * min(nums). So algorithm: find min, compute sum, answer = sum - min*n. But we must produce pseudocode in required format: Start, steps, decisions, etc. Each line: \"虛擬碼步驟 // 解釋\". Must use arrows →, Yes→ No→ etc. Should be step by step, maybe we can include a loop to compute sum and min. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums 與其大小 n // 從使用者處取得陣列與長度  \n→ Step 2: 初始化變數 sum ← 0, minVal ← +∞ // 用於累計總和與追蹤最小值  \n→ Step 3: 從 i = 0 到 n-1 逐一處理每個元素 // 開始遍歷陣列  \n  → Decision: 如果 nums[i] < minVal? // 判斷目前元素是否為新的最小值  \n   Yes → minVal ← nums[i] // 更新最小值  \n   No → // 無需更新  \n  → sum ← sum + nums[i] // 累加總和  \n→ Step 4: 計算 moves ← sum - minVal * n // 根據公式得到最小移動次數  \n→ Step 5: 輸出 moves // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minMoves(self, nums):\n        \"\"\"\n        計算將所有元素變成相同所需的最小步數。\n        每一步可以把 n-1 個元素加 1，相當於把某個元素減 1。\n        所以最小步數等於總和減去最小值乘以元素個數。\n        \"\"\"\n        return sum(nums) - min(nums) * len(nums)\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中擷取所有整數，支持負數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        return\n    # 計算並輸出結果\n    solution = Solution()\n    print(solution.minMoves(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode225.json",
    "problem_index_in_file": 0,
    "title": "Implement Stack using Queues",
    "description_snippet": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should suppo...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output pseudo code line by line with explanations. Implement stack using two queues. We'll propose algorithm: use q1 as main queue. For push, enqueue to q1. For pop/top, need to move all but last element to q2, get last element, then swap queues. For empty: check q1 empty.\n\nWrite pseudo steps: Start class, constructors, etc.\n\nLet's craft lines:\n\nStart // Start program\n\n→ Step: Define class MyStack // define stack class\n\n→ Step: Declare queue1 ← new Queue // primary queue\n\n→ Step: Declare queue2 ← new Queue // auxiliary queue\n\n→ Step: // push operation\n\n→ Step: Method push(x):\n\n→ Step: → queue1.enqueue(x) // add element to back\n\n→ Step: // pop operation\n\n→ Step: Method pop():\n\n→ Step: → While queue1.size() > 1:\n\n→ Step: → → temp ← queue1.dequeue() // remove front\n\n→ Step: → → queue2.enqueue(temp) // enqueue to auxiliary\n\n→ Step: → topElement ← queue1.dequeue() // remove last element, it's the top\n\n→ Step: → Swap(queue1, queue2) // make queue2 the new primary\n\n→ Step: → Return topElement // return popped value\n\n→ Step: // top operation\n\n→ Step: Method top():\n\n→ Step: → While queue1.size() > 1:\n\n→ Step: → → temp ← queue1.dequeue()\n\n→ Step: → → queue2.enqueue(temp)\n\n→ Step: → topElement ← queue1.dequeue()\n\n→ Step: → queue2.enqueue(topElement) // reinsert to maintain state\n\n→ Step: → Swap(queue1, queue2)\n\n→ Step: → Return topElement\n\n→ Step: // empty operation\n\n→ Step: Method empty():\n\n→ Step: → Return queue1.isEmpty() // check if primary queue empty\n\n→ End // end of class\n\nBut we need to follow arrow format: e.g., \"→ Step: ...\". Provide explanation after //.\n\nAlso include Decision for empty check maybe. But simple return. But we can add Decision for pop if empty? We can add check. But not necessary.\n\nWe need to output only pseudo code lines. Use \"Start\" \"End\". Use \"Decision:\" for conditional. Provide explanation after //.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義類別 MyStack // 建立自訂堆疊類別  \n→ Step: 宣告 queue1 ← 新建 Queue // 主佇列，用於存放所有元素  \n→ Step: 宣告 queue2 ← 新建 Queue // 次佇列，暫存元素以實現 pop/top  \n→ Step: // push 操作  \n→ Step: Method push(x): // 定義 push 方法  \n→ Step: → queue1.enqueue(x) // 把元素 x 放到 queue1 的尾端（堆疊頂部）  \n→ Step: // pop 操作  \n→ Step: Method pop(): // 定義 pop 方法  \n→ Step: → Decision: queue1.isEmpty()? // 檢查是否為空  \n→ Step:     Yes → Return -1 // 若空，返回錯誤值（可自行處理）  \n→ Step:     No  →  \n→ Step:         While queue1.size() > 1: // 將前面所有元素移到 queue2  \n→ Step:             → temp ← queue1.dequeue() // 從 queue1 前端取出元素  \n→ Step:             → queue2.enqueue(temp) // 將其放入 queue2  \n→ Step:         topElement ← queue1.dequeue() // queue1 的最後一個元素即堆疊頂部  \n→ Step:         Swap(queue1, queue2) // 交換兩個佇列，使 queue1 成為新的主佇列  \n→ Step:         → Return topElement // 回傳被彈出的元素  \n→ Step: // top 操作  \n→ Step: Method top(): // 定義 top 方法  \n→ Step: → Decision: queue1.isEmpty()? // 檢查是否為空  \n→ Step:     Yes → Return -1 // 若空，返回錯誤值  \n→ Step:     No  →  \n→ Step:         While queue1.size() > 1: // 移動前面所有元素到 queue2  \n→ Step:             → temp ← queue1.dequeue()  \n→ Step:             → queue2.enqueue(temp)  \n→ Step:         topElement ← queue1.dequeue() // 抓取堆疊頂部元素  \n→ Step:         queue2.enqueue(topElement) // 將頂部元素重新放回 queue2 以保持狀態  \n→ Step:         Swap(queue1, queue2) // 交換佇列，恢復 queue1 為主佇列  \n→ Step:         → Return topElement // 回傳頂部元素  \n→ Step: // empty 操作  \n→ Step: Method empty(): // 定義 empty 方法  \n→ Step: → Return queue1.isEmpty() // 若主佇列為空則堆疊為空  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x):\n        self.q1.append(x)\n\n    def pop(self):\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top = self.q1.popleft()\n        self.q1, self.q2 = self.q2, self.q1\n        return top\n\n    def top(self):\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top = self.q1.popleft()\n        self.q2.append(top)\n        self.q1, self.q2 = self.q2, self.q1\n        return top\n\n    def empty(self):\n        return not self.q1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data.startswith(\"Input \"):\n        data = data[6:]\n    # Find two list literals\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) < 2:\n        sys.exit(0)\n    ops = ast.literal_eval(lists[0])\n    args = ast.literal_eval(lists[1])\n\n    stack = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            stack = MyStack()\n            results.append(None)\n        elif op == \"push\":\n            stack.push(arg[0] if arg else None)\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop() if stack else None)\n        elif op == \"top\":\n            results.append(stack.top() if stack else None)\n        elif op == \"empty\":\n            results.append(stack.empty() if stack else None)\n\n    # Format output like LeetCode's expected string\n    out = []\n    for val in results:\n        if val is None:\n            out.append(\"null\")\n        elif isinstance(val, bool):\n            out.append(\"true\" if val else \"false\")\n        else:\n            out.append(str(val))\n    print(f\"[{', '.join(out)}]\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpjlhjud4q.py\", line 45, in <module>\n    args = ast.literal_eval(lists[1])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode279.json",
    "problem_index_in_file": 0,
    "title": "Perfect Squares",
    "description_snippet": "Given an integer n, return the least number of perfect square numbers that sum to n.\n\nA perfect squa...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for solving the \"Perfect Squares\" problem: given n, find least number of perfect squares that sum to n. This is classic dynamic programming or BFS.\n\nWe need to produce step-by-step pseudocode in the required format: each line \"虛擬碼步驟\" plus space plus comment. Use arrows →, Decision: etc. Should not output actual code, only virtual steps.\n\nWe need to consider algorithm: BFS from 0 to n, each step subtract square numbers. Or DP: dp[0]=0, dp[i] = min(dp[i - square] + 1). For BFS, we can do: queue start 0, visited set, step level count. When we reach n, return level. That yields minimal number of squares.\n\nLet's produce pseudocode using BFS. Outline:\n\nStart\n→ Initialize queue with 0\n→ Initialize visited set with 0\n→ Initialize level = 0\n→ Decision: If queue empty? // no, start loop\n→ While queue not empty:\n    → Decision: If queue front equals n? // reached target\n        Yes → Return level // answer\n        No → Process node\n    → For each square <= n:\n        → Compute next = current + square\n        → Decision: If next > n or visited contains next? // skip\n            Yes → continue\n            No → Enqueue next; add to visited\n    → After processing all nodes at current level, increment level\n→ End\n\nAlso need to compute squares list.\n\nWe need to produce each step on a separate line, with arrow and comment.\n\nWe need to use \"Start\", \"End\". Use Decision: for decisions.\n\nWe must not output code, only the virtual steps. Let's produce.\n\nWe may also include generating squares. Let's add a step: compute list of squares <= n before BFS.\n\nAlso may need to handle base case n==0? Return 0.\n\nLet's produce.\n\nWe must be mindful of format: each line \"虛擬碼步驟\" + space + comment. Use arrows \"→\" at beginning of line. For \"Start\" and \"End\", no arrow. For \"Decision:\" lines we need indent. Use indentation spaces maybe. In example, they used indentation for nested. We should mimic.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: n 是否為 0? // 檢查特殊情況\n    Yes → Step: 輸出 0 // n 為 0 時最少 0 個平方數\n    No  → Step: 先建立一個陣列 squares，包含所有小於等於 n 的平方數 // 方便後續迭代\n→ Step: 初始化佇列 queue，加入 0 // 0 表示目前和為 0 的狀態\n→ Step: 初始化集合 visited，加入 0 // 避免重複訪問同一個和\n→ Step: 設定 level = 0 // 代表目前使用的平方數個數\n→ Decision: queue 是否為空? // 開始 BFS 迴圈\n    Yes → End // 若 queue 空且未找到，表示錯誤結束\n    No  → Step: 開始 BFS 循環\n→ While queue 不為空: // 主循環\n    → Step: 取出 queue 的第一個元素 current // 當前和\n    → Decision: current 是否等於 n? // 判斷是否已達目標\n        Yes → Step: 輸出 level // 找到最少平方數，結束\n        No  → Step: 針對每個 square 在 squares:\n            → Decision: current + square 是否大於 n 或已訪問? // 篩除無效或重複\n                Yes → Step: continue // 跳過此 square\n                No  → Step: 計算 next = current + square // 新的和\n                    → Step: 將 next 加入 queue // 下一層節點\n                    → Step: 將 next 加入 visited // 標記已訪問\n    → Decision: 所有 current 層已處理完? // 完成本層 BFS\n        Yes → Step: level += 1 // 進入下一層，平方數個數 +1\n        No  → Step: 進入下一輪 while\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_squares(n: int) -> int:\n    \"\"\"Return the least number of perfect square numbers that sum to n.\"\"\"\n    # dp[i] 表示數字 i 最少需要的完全平方數個數\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n\n    return dp[n]\n\ndef main() -> None:\n    # 從標準輸入讀取所有文字\n    raw_input = sys.stdin.read()\n\n    # 取得輸入中的第一個整數\n    match = re.search(r'\\d+', raw_input)\n    if not match:\n        return\n    n = int(match.group())\n\n    # 計算答案並輸出\n    result = num_squares(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 13",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode330.json",
    "problem_index_in_file": 0,
    "title": "Patching Array",
    "description_snippet": "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for Minimum Patches Problem. Use greedy approach: maintain covered range [1, maxReach]. Iterate array and patch as needed. Provide step-by-step virtual code.\n\nWe need to output line by line with arrow. Should include Start, End, Decision, Step etc. Use `→` arrows. Provide explanation after `//`. No actual code.\n\nLet's produce.\n\nLine1: Start\n\nLine2: → Initialize patchCount = 0 // count patches\n\nLine3: → Initialize maxReach = 1 // current max sum reachable\n\nLine4: → Initialize index = 0 // pointer to nums\n\nLine5: → Initialize n // target\n\nLine6: → While maxReach <= n // until we can reach n\n\nInside loop:\n\nDecision: if index < len(nums) and nums[index] <= maxReach // if current array element <= reachable range\n\nYes → maxReach += nums[index] // extend reach by adding array element\n\nNo → maxReach += maxReach // patch: add element equal to current reach\n\npatchCount += 1 // one patch added\n\nindex +=1 // move to next element if used\n\nAfter loop End\n\nReturn patchCount\n\nNeed each line with arrow accordingly.\n\nLet's craft step-by-step.\n\nUse decision indentation. Use arrow indentation as shown.\n\nAlso note start, end lines.\n\nWe must include step lines for each action.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize patchCount = 0 // 先設定補丁數量為 0  \n→ Initialize maxReach = 1 // 目前可達到的最大總和初始為 1  \n→ Initialize index = 0 // 設定陣列指標為 0  \n→ Initialize n // 目標上限，已由使用者給定  \n→ While maxReach <= n // 只要還沒覆蓋到 n，就繼續處理  \n  Decision: 是否存在 nums[index] 且 nums[index] <= maxReach? // 判斷目前元素是否在可達範圍內  \n   Yes → maxReach += nums[index] // 若可用，將此元素加入可覆蓋範圍  \n    index += 1 // 移動到下一個陣列元素  \n   No  → maxReach += maxReach // 若不可用，新增一個值為 current maxReach 的補丁  \n    patchCount += 1 // 補丁數量加一  \n    index += 1 // 即使補丁，仍視為「使用」一個位置以保持迴圈進展  \nEnd // 程式執行結束，回傳 patchCount\n\n// 輸出 patchCount 即為最小補丁數量。",
      "generated_code": "import sys\n\nclass Solution:\n    def minPatches(self, nums, n):\n        patches = 0          # 補丁數量\n        miss = 1             # 目前最小無法達到的數字\n        i = 0                # nums 的索引\n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss\n                patches += 1\n        return patches\n\ndef parse_input(data: str):\n    \"\"\"將形如 'nums = [1,3], n = 6' 的字串解析為 (nums, n)。\"\"\"\n    parts = [p.strip() for p in data.split(',')]\n    nums = None\n    n = None\n    for part in parts:\n        key, value = part.split('=', 1)\n        key = key.strip()\n        value = value.strip()\n        if key == 'nums':\n            nums = eval(value)          # 解析列表\n        elif key == 'n':\n            n = int(value)\n    return nums, n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums, n = parse_input(data)\n    solution = Solution()\n    result = solution.minPatches(nums, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3], n = 6",
          "expected_output": "1",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpdse82b8k.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpdse82b8k.py\", line 36, in main\n    nums, n = parse_input(data)\n              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdse82b8k.py\", line 27, in parse_input\n    nums = eval(value)          # 解析列表\n           ^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,10], n = 20",
          "expected_output": "2",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp5yw1zgvr.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmp5yw1zgvr.py\", line 36, in main\n    nums, n = parse_input(data)\n              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5yw1zgvr.py\", line 27, in parse_input\n    nums = eval(value)          # 解析列表\n           ^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,2], n = 5",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpiql9yrkb.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpiql9yrkb.py\", line 36, in main\n    nums, n = parse_input(data)\n              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpiql9yrkb.py\", line 27, in parse_input\n    nums = eval(value)          # 解析列表\n           ^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode210.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule II",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step, for algorithm: topological sort using DFS or Kahn. Provide explanation. Each line with `虛擬碼步驟` + ` // 解釋`. Use arrows and Decision.\n\nWe need to produce a flowchart-like virtual code.\n\nLet's design: Start, create graph adjacency list, indegree array. For each prerequisite pair, add edge, increment indegree. Then use queue for zero indegree. While queue not empty: pop, add to result, decrement indegree of neighbors, if becomes zero push. After loop, if result length==numCourses return result else empty.\n\nLet's output each line. Use `Start // 程式開始執行`. Use `→` to indent. Use `Decision:` etc. Provide explanation in Chinese.\n\nEnsure each line has code step and comment. Use `Start` at top, `End` at bottom.\n\nLet's produce lines:\n\nStart\n→ Step 1: Initialize graph adjacency list for all courses // 建立鄰接表\n→ Step 2: Initialize indegree array with zeros // 初始化入度\n→ Step 3: For each pair [a,b] in prerequisites:\n    → Add a to graph[b] // 把 a 加入 b 的鄰接表\n    → Increment indegree[a] // a 的入度 +1\n→ Decision: 是否所有課程入度都已計算? // 確保已處理所有前置關係\n    Yes → Step 4: Initialize empty queue // 用來存入度為 0 的節點\n    No  → Step 3 // (實際上這個決定可忽略，因為已完成迴圈)\n→ Step 5: For each course i from 0 to numCourses-1:\n    → If indegree[i] == 0:\n        → Enqueue i // 入度為0的課程加入佇列\n→ Decision: 佇列是否為空? // 判斷是否還有可處理課程\n    Yes → End // 若空則結束（此時可能檢查是否完成）\n    No  → Step 6: Dequeue node u // 取出佇列頭\n→ Step 7: Append u to result list // 記錄完成順序\n→ Step 8: For each neighbor v in graph[u]:\n        → Decrement indegree[v] // v 的入度減1\n        → If indegree[v] == 0:\n            → Enqueue v // 若入度為0加入佇列\n→ Step 9: 回到 Decision: 佇列是否為空? // 重複處理\n→ Decision: result list長度 == numCourses? // 檢查是否所有課程都已安排\n    Yes → Return result // 回傳課程順序\n    No  → Return empty list // 無法完成所有課程\n\nBut need format line by line. Use indentation by arrow but still each line separate. Provide decisions with nested lines maybe.\n\nLet's produce each line:\n\nStart // 程式開始執行\n→ Step 1: 初始化 graph 為空的鄰接表，尺寸為 numCourses // 建立課程圖\n→ Step 2: 初始化 indegree 為全 0 陣列，長度為 numCourses // 追蹤入度\n→ Step 3: 對 prerequisites 中每對 [a,b]：\n    → Step 3.1: graph[b].add(a) // 將 a 加到 b 的鄰接表\n    → Step 3.2: indegree[a] += 1 // a 的入度加 1\n→ Step 4: 初始化 queue 為空佇列 // 用來存入度為 0 的課程\n→ Decision: 迴圈是否完成? // (實際上已完成) 直接跳過\n→ Step 5: 對 i 從 0 到 numCourses-1：\n    → Decision: indegree[i] == 0?\n        Yes → Enqueue i // 入度為 0 的課程加入佇列\n        No  → Next i\n→ Decision: queue 是否為空?\n    Yes → End // 如果無可處理課程結束\n    No  → Step 6: Dequeue u // 取出佇列頭\n→ Step 7: result.add(u) // 將課程加入完成順序\n→ Step 8: 對 v 在 graph[u]：\n    → indegree[v] -= 1 // v 的入度減 1\n    → Decision: indegree[v] == 0?\n        Yes → Enqueue v // 若入度為 0，加入佇列\n        No  → 只進行減 1\n→ Step 9: 回到 Decision: queue 是否為空? // 重複循環\n→ Decision: result.length == numCourses?\n    Yes → Return result // 成功完成所有課程\n    No  → Return empty array // 無法完成\n\nBut each line must not have nested indent lines? In example they indent nested lines with spaces but still each line. We can do each as separate line but use indentation spaces.\n\nLet's produce each step with arrow arrow. Use indentation spaces.\n\nNeed to keep formatting: `→` arrow and maybe `Decision:` lines with sub-lines.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 graph 為空的鄰接表，尺寸為 numCourses // 建立課程圖\n→ Step 2: 初始化 indegree 為全 0 陣列，長度為 numCourses // 追蹤每門課的入度\n→ Step 3: 對 prerequisites 中每對 [a,b]：\n    → Step 3.1: graph[b].add(a) // 把 a 加到 b 的鄰接表\n    → Step 3.2: indegree[a] += 1 // a 的入度加 1\n→ Step 4: 初始化 queue 為空佇列 // 用來存入度為 0 的課程\n→ Step 5: 對 i 從 0 到 numCourses-1：\n    → Decision: indegree[i] == 0?\n        Yes → Enqueue i // 入度為 0 的課程加入佇列\n        No  → Next i\n→ Decision: queue 是否為空?\n    Yes → End // 若佇列已空，結束（此時檢查是否完成）\n    No  → Step 6: Dequeue u // 取出佇列頭的課程\n→ Step 7: result.add(u) // 將課程加入完成順序\n→ Step 8: 對 v 在 graph[u]：\n    → indegree[v] -= 1 // v 的入度減 1\n    → Decision: indegree[v] == 0?\n        Yes → Enqueue v // 若入度為 0，加入佇列\n        No  → 只進行減 1\n→ Step 9: 回到 Decision: queue 是否為空? // 重複循環\n→ Decision: result.length == numCourses?\n    Yes → Return result // 成功完成所有課程，返回順序\n    No  → Return empty array // 無法完成所有課程，返回空陣列\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form:\n       numCourses = X, prerequisites = [[a,b], ...]\n    \"\"\"\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    num_courses = int(num_match.group(1)) if num_match else 0\n\n    prereq_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data, re.S)\n    prereq_str = prereq_match.group(1) if prereq_match else '[]'\n    prerequisites = eval(prereq_str)  # safe for the given input format\n\n    return num_courses, prerequisites\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    numCourses, prerequisites = parse_input(raw)\n    solution = Solution()\n    result = solution.findOrder(numCourses, prerequisites)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "success": true,
          "output": "[0, 1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode516.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Subsequence",
    "description_snippet": "Given a string s, find the longest palindromic subsequence's length in s.\n\nA subsequence is a sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing longest palindromic subsequence length in a string s. Provide step-by-step using arrow notation. Provide explanation comments.\n\nWe need to compute DP. Steps: input string, initialize DP matrix size n x n, base case DP[i][i] = 1, then for length from 2 to n, for i from 0 to n-len, j = i+len-1: if s[i]==s[j] DP[i][j] = DP[i+1][j-1]+2 else DP[i][j] = max(DP[i+1][j], DP[i][j-1]). Finally result DP[0][n-1].\n\nLet's craft step-by-step. We'll include Start, End.\n\nLet's produce each line with virtual code: \"Start\", \"→ Step 1: Input string s // 取得輸入字串\", \"→ Step 2: Let n = length of s // 獲取字串長度\", \"→ Step 3: Create 2D array DP[n][n] initialized to 0 // 初始化動態規劃表\", \"→ Step 4: For i from 0 to n-1: DP[i][i] = 1 // 單字符為回文長度1\", \"→ Step 5: For len from 2 to n: // 計算子字串長度\", \"    → Decision: len ≤ n? // 迴圈控制\", \"        Yes → For i from 0 to n-len: j = i+len-1 // 子字串起點和終點\", \"            → Decision: s[i] == s[j]? // 判斷兩端字符是否相同\", \"                Yes → DP[i][j] = DP[i+1][j-1] + 2 // 加兩個字符\", \"                No → DP[i][j] = max(DP[i+1][j], DP[i][j-1]) // 取最大\", \"End\".\n\nNeed to use correct arrow notation. Provide explanation comment after each line.\n\nAlso mention output.\n\n\"→ Step 6: Output DP[0][n-1] // 最長回文子序列長度\".\n\nAdd End.\n\nLet's format accordingly. Use one line per step. Indentation can be indicated with spaces. Use arrow in code. For nested steps, we can indent with 4 spaces maybe.\n\nMake sure each line has \"虛擬碼步驟\" and comment after space //.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者取得輸入字串  \n→ Step 2: 取得字串長度 n = len(s) // 獲取字串長度  \n→ Step 3: 建立 DP[n][n] 初始化為 0 // 初始化動態規劃表格  \n→ Step 4: For i = 0 到 n-1: DP[i][i] = 1 // 單個字符本身即為回文，長度為 1  \n→ Step 5: For len = 2 到 n: // 逐長度處理子字串  \n    → Decision: len ≤ n? // 控制迴圈範圍  \n        Yes → For i = 0 到 n - len:  \n            → 計算 j = i + len - 1 // 子字串右端點  \n            → Decision: s[i] == s[j]? // 檢查兩端字符是否相同  \n                Yes → DP[i][j] = DP[i+1][j-1] + 2 // 兩端相同，長度加 2  \n                No  → DP[i][j] = max(DP[i+1][j], DP[i][j-1]) // 取左右子問題最大值  \n→ Step 6: 輸出 DP[0][n-1] // 最長回文子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef longest_palindrome_subseq(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 可能包含外層引號，移除\n    if data and ((data[0] == '\"' and data[-1] == '\"') or (data[0] == \"'\" and data[-1] == \"'\")):\n        data = data[1:-1]\n    result = longest_palindrome_subseq(data)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode4.json",
    "problem_index_in_file": 0,
    "title": "Median of Two Sorted Arrays",
    "description_snippet": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find median of two sorted arrays with O(log(m+n)) time. That's classic binary search on partition. We need to output each line with comment. Use Start, End, Decision. Provide lines like:\n\nStart // Begin\n\n→ Step 1: 確保 nums1 為較小陣列 // To keep binary search on shorter array\n\n→ Step 2: 設定 low=0, high=len(nums1)\n\n→ Decision: low <= high? // Continue binary search\n\n    Yes → Step 3: 計算 partitionX = (low+high)//2 // Partition index in nums1\n\n    → Step 4: 計算 partitionY = (len(nums1)+len(nums2)+1)//2 - partitionX // Partition index in nums2\n\n    → Decision: partitionX < len(nums1) AND nums2[partitionY-1] > nums1[partitionX] ? // Need to move partitionX right\n\n        Yes → Step 5: low = partitionX + 1 // Increase low\n\n        No → Decision: partitionX > 0 AND nums1[partitionX-1] > nums2[partitionY] ? // Need to move left\n\n            Yes → Step 6: high = partitionX - 1 // Decrease high\n\n            No → Step 7: 計算 maxLeft = max(nums1[partitionX-1] if partitionX>0 else -∞, nums2[partitionY-1] if partitionY>0 else -∞) // 左邊最大值\n\n            → Step 8: 計算 minRight = min(nums1[partitionX] if partitionX<len(nums1) else +∞, nums2[partitionY] if partitionY<len(nums2) else +∞) // 右邊最小值\n\n            → Decision: (len(nums1)+len(nums2)) % 2 == 1? // Odd total length\n\n                Yes → Step 9: return maxLeft // median is maxLeft\n\n                No  → Step 10: return (maxLeft + minRight) / 2.0 // median is average\n\n    End // exit\n\nNeed to include End. And maybe Step to output result. We also need to mention variables etc.\n\nThe user asked to not output actual code, only virtual steps. Use arrows etc.\n\nWe must maintain formatting exactly: each line has virtual code and comment. Use arrow as given.\n\nLet's craft.\n\nAlso note \"Start\" and \"End\" lines.\n\nMake sure to use \"→\" for normal step lines. Use \"Decision:\" lines with Yes→ and No→.\n\nLet's produce steps line by line.\n\nWe'll use the example format.\n\nBe mindful that each line is separate, not grouping multi-line decisions incorrectly.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 A = nums1, B = nums2 // 將兩個陣列分別命名  \n→ Decision: len(A) > len(B)? // 確保 A 為較短陣列  \n Yes → Step 2: 交換 A 與 B // 若 A 更長，交換以降低搜尋範圍  \n No  → Step 2: 繼續 // A 已是較短陣列  \n→ Step 3: low = 0, high = len(A) // 初始化二分搜尋指標  \n→ Decision: low <= high? // 是否還有搜尋空間  \n Yes → Step 4: partitionA = (low + high) // 2 // A 的分割點  \n  → Step 5: partitionB = (len(A) + len(B) + 1) // 2 - partitionA // B 的分割點  \n  → Decision: partitionA < len(A) AND B[partitionB-1] > A[partitionA]? // 需要把 A 的分割點往右移  \n   Yes → Step 6: low = partitionA + 1 // 調整低指標  \n   No  → Decision: partitionA > 0 AND A[partitionA-1] > B[partitionB]? // 需要把 A 的分割點往左移  \n    Yes → Step 7: high = partitionA - 1 // 調整高指標  \n    No  → Step 8: maxLeft = max( A[partitionA-1] if partitionA > 0 else -∞ , B[partitionB-1] if partitionB > 0 else -∞ ) // 左側最大值  \n     → Step 9: minRight = min( A[partitionA] if partitionA < len(A) else +∞ , B[partitionB] if partitionB < len(B) else +∞ ) // 右側最小值  \n      → Decision: (len(A) + len(B)) % 2 == 1? // 總長奇數?  \n       Yes → Step 10: return maxLeft // 奇數時中位數為左側最大值  \n       No  → Step 11: return (maxLeft + minRight) / 2.0 // 偶數時中位數為左右平均值  \n       End  \n      End  \n     End  \n   End  \n  End  \n End  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        Find the median of two sorted arrays in O(log(min(m,n))) time.\n        \"\"\"\n        if not nums1 and not nums2:\n            return 0.0\n\n        # Ensure nums1 is the smaller array to keep binary search bounds small.\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        total = m + n\n        half = (total + 1) // 2  # Size of the left partition\n\n        low, high = 0, m\n        while low <= high:\n            i = (low + high) // 2          # Partition in nums1\n            j = half - i                   # Partition in nums2\n\n            nums1_left = nums1[i - 1] if i > 0 else float('-inf')\n            nums1_right = nums1[i] if i < m else float('inf')\n            nums2_left = nums2[j - 1] if j > 0 else float('-inf')\n            nums2_right = nums2[j] if j < n else float('inf')\n\n            # Check if we have found the correct partition\n            if nums1_left <= nums2_right and nums2_left <= nums1_right:\n                if total % 2:\n                    return max(nums1_left, nums2_left)   # Odd total length\n                else:\n                    return (max(nums1_left, nums2_left) + min(nums1_right, nums2_right)) / 2.0\n            elif nums1_left > nums2_right:\n                high = i - 1      # Move left in nums1\n            else:\n                low = i + 1       # Move right in nums1\n\n        # If the function hasn't returned inside the loop, the input was invalid.\n        raise ValueError(\"Input arrays are not sorted or are invalid.\")\n\nif __name__ == \"__main__\":\n    # Read entire stdin and extract the two lists.\n    data = sys.stdin.read()\n    # Regex patterns to capture the list representations.\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[.*?\\])', data)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[.*?\\])', data)\n\n    nums1 = ast.literal_eval(nums1_match.group(1)) if nums1_match else []\n    nums2 = ast.literal_eval(nums2_match.group(1)) if nums2_match else []\n\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    # Print with 5 decimal places as required.\n    print(f\"{median:.5f}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "success": true,
          "output": "2.00000"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "expected_output": "2.50000",
          "success": true,
          "output": "2.50000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode201.json",
    "problem_index_in_file": 0,
    "title": "Bitwise AND of Numbers Range",
    "description_snippet": "Given two integers left and right that represent the range [left, right], return the bitwise AND of ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for problem: compute bitwise AND of all numbers in inclusive range [left, right]. This is Leetcode 201. Approach: find common prefix of left and right by shifting right until equal. Count shifts, then left << shift.\n\nWe'll produce step-by-step pseudocode with decisions.\n\nUse Start, End, Decision: with Yes →, No → etc.\n\nWe need to output line by line, each line: virtual code step [space] // explanation. Use arrows.\n\nLet's write.\n\nLine 1: Start // 程式開始執行\nLine 2: → Input left, right // 取得兩個整數\nLine 3: → shiftCount = 0 // 記錄右移的次數\nLine 4: → Decision: 左右差距 > 0? // 若 left 與 right 不同，需找共同前綴\n   Yes → while left != right: // 當兩者不同時\n        → left = left >> 1 // 右移 left\n        → right = right >> 1 // 右移 right\n        → shiftCount = shiftCount + 1 // 右移次數累加\n   No → (skip loop)\nLine 5: → result = left << shiftCount // 將共同前綴左移回去\nLine 6: → Output result // 回傳結果\nEnd // 程式執行結束\n\nNeed to follow exact format: each line ends with // explanation.\n\nAlso, indentation: Use spaces and arrows. Decision block indentation may have indent, but it's still one line? The example shows indentation for nested decisions. We'll produce similar.\n\nUse \"Decision: If left != right?\" maybe.\n\nLet's craft lines.\n\nLine 4: → Decision: left != right? // 判斷兩數是否相同，若不同則進行位移\n   Yes → while left != right: // 當 left 與 right 不同時進入迴圈\n        → left = left >> 1 // 右移 left 的位元\n        → right = right >> 1 // 右移 right 的位元\n        → shiftCount = shiftCount + 1 // 記錄右移次數\n   No → // 當 left == right 時跳過迴圈\n\nNeed to keep each line as separate step. In example, nested lines are separate lines with indentation. We'll produce separate lines.\n\nLet's enumerate each step as separate line.\n\nWe'll include indentation for clarity.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input left, right // 取得兩個整數  \n→ shiftCount = 0 // 記錄右移的次數  \n→ Decision: left != right? // 判斷兩數是否相同，若不同則進行位移  \n Yes → while left != right: // 當 left 與 right 不同時進入迴圈  \n  → left = left >> 1 // 右移 left 的位元  \n  → right = right >> 1 // 右移 right 的位元  \n  → shiftCount = shiftCount + 1 // 記錄右移次數  \n No → // 當 left == right 時跳過迴圈  \n→ result = left << shiftCount // 將共同前綴左移回去得到最終 AND 值  \n→ Output result // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        shift = 0\n        while left < right:\n            left >>= 1\n            right >>= 1\n            shift += 1\n        return left << shift\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract all integers from the input, regardless of formatting\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        # Not enough data to compute\n        return\n    left, right = nums[0], nums[1]\n    sol = Solution()\n    result = sol.rangeBitwiseAnd(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 5, right = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 0, right = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "left = 1, right = 2147483647",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode313.json",
    "problem_index_in_file": 0,
    "title": "Super Ugly Number",
    "description_snippet": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the output format. The problem: find nth super ugly number given n and array primes. Classic DP with pointers. Virtual code steps: Start, initialize array ugly[0..n-1] with 1, pointers idx[primes] all 0, compute next values, etc. Provide explanation comments.\n\nWe must not output actual code, only virtual steps with arrows. Use Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". We need to format each line exactly: 虛擬碼步驟 + space + // + space + explanation.\n\nWe need to output step-by-step. Use arrow \"→\" before step description. Decision lines with Yes → and No →.\n\nLet's write steps:\n\nStart // 程式開始執行\n→ Step 1: 初始化陣列 ugly[0..n-1]，設 ugly[0] = 1 // 建立儲存超醜數的陣列，首項為 1\n→ Step 2: 初始化指標 idx[0..len(primes)-1]，全部設為 0 // 每個質因數的指標指向目前候選位置\n→ Decision: n 是否等於 1? // 若只需要第一個超醜數\n    Yes → Step 3: 返回 ugly[0] // 直接回傳 1\n    No  → Step 4: 進入主迴圈 for i from 1 to n-1 // 循環計算剩餘超醜數\n→ Step 4.1: 計算候選數 nextVal[i] = min( ugly[idx[j]] * primes[j] for all j ) // 取所有指標指向的候選值的最小值\n→ Step 4.2: 設置 ugly[i] = nextVal[i] // 將最小值存入超醜數陣列\n→ Step 4.3: Decision: 是否有多個指標指向相同的最小值? // 檢查重複候選\n    Yes → Step 4.3.1: For each j where ugly[idx[j]] * primes[j] == nextVal[i], idx[j]++ // 所有等於最小值的指標移動\n    No  → Step 4.3.2: idx[0]++ // 這裡示例，實際會移動所有符合的指標\n→ End // 完成 n 個超醜數，程式結束\n\nWe need more precise steps. But must keep format. Each line with \"虛擬碼步驟\" e.g., \"Start\", \"→ Step 1: ...\" etc. Need to ensure no actual code but explanation. Provide each step as a line. Use \"Decision:\" lines with indentation for Yes/No. Use \"→\" before steps.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化陣列 ugly[0..n-1]，設 ugly[0] = 1 // 建立儲存超醜數的陣列，首項為 1  \n→ Step 2: 初始化指標 idx[0..len(primes)-1]，全部設為 0 // 每個質因數的指標指向目前候選位置  \n→ Decision: n 是否等於 1? // 若只需要第一個超醜數  \n  Yes → Step 3: 返回 ugly[0] // 直接回傳 1  \n  No  → Step 4: 進入主迴圈 for i from 1 to n-1 // 循環計算剩餘超醜數  \n→ Step 4.1: 計算候選數 nextVal = min( ugly[idx[j]] * primes[j] for all j ) // 取所有指標指向的候選值的最小值  \n→ Step 4.2: 設置 ugly[i] = nextVal // 將最小值存入超醜數陣列  \n→ Step 4.3: Decision: 是否有多個指標指向相同的最小值? // 檢查重複候選  \n  Yes → Step 4.3.1: 對每個 j，若 ugly[idx[j]] * primes[j] == nextVal，則 idx[j]++ // 所有等於最小值的指標移動  \n  No  → Step 4.3.2: idx[0]++ // 這裡示例，實際會移動所有符合的指標  \n→ End // 完成 n 個超醜數，程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthSuperUglyNumber(self, n, primes):\n        if n == 1:\n            return 1\n        ugly = [1] * n\n        indices = [0] * len(primes)\n        values = primes[:]  # current candidate for each prime\n\n        for i in range(1, n):\n            next_ugly = min(values)\n            ugly[i] = next_ugly\n            for j, val in enumerate(values):\n                if val == next_ugly:\n                    indices[j] += 1\n                    values[j] = ugly[indices[j]] * primes[j]\n        return ugly[-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract all integers from the input\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        return\n    n = nums[0]\n    primes = nums[1:]\n    sol = Solution()\n    result = sol.nthSuperUglyNumber(n, primes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12, primes = [2,7,13,19]",
          "expected_output": "32",
          "success": true,
          "output": "32"
        },
        {
          "example_index": 1,
          "input": "n = 1, primes = [2,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode448.json",
    "problem_index_in_file": 0,
    "title": "Find All Numbers Disappeared in an Array",
    "description_snippet": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: \"Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.\"\n\nWe should produce step-by-step virtual code with explanations. No actual code. Use the arrow and decision structure. Should produce the algorithm maybe marking visited numbers by negative marking. The problem is typical \"Find All Numbers Disappeared in an Array\" LeetCode 448.\n\nWe need to produce virtual code with steps, each line includes virtual code + // explanation. Format like:\n\nStart\n→ Step 1: 初始化結果空陣列 result // ...\n→ Step 2: 迭代 nums 設定索引 i\n   → Decision: ...\nAnd so on.\n\nBut must be careful: use virtual code lines, not actual code. Use arrow \"→\". Each step on new line.\n\nLet's design algorithm: \n\n1. Start\n2. Initialize result list empty\n3. For each number x in nums:\n   Mark index abs(x)-1 in nums as negative to indicate presence\n4. For i from 0 to n-1:\n   If nums[i] > 0, then i+1 missing, add to result\n5. Return result\n6. End\n\nAlso we might mention complexity.\n\nLet's produce in step-by-step lines.\n\nWe must maintain the structure: Start, Decision:, Yes →, No →, End.\n\nLet's craft.\n\nWe can use Decision for loops and condition. Eg:\n\n→ Decision: 迭代 nums? Yes → Step 2: ...\nBut loops can be represented as Step and inside Decision.\n\nBetter: Use Step 1: 初始化, Step 2: 迭代 nums, inside Decision: if index negative.\n\nBut we can incorporate marking. Use Step 2: For each num in nums, mark presence. Decision: if abs(num)-1 < n? Actually guarantee.\n\nSimplify.\n\nAlso we need to produce step to gather missing numbers.\n\nWill produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空陣列 // 準備儲存缺失的數字\n→ Step 2: 迭代 nums 進行標記 // 將每個數字映射到對應索引並標記為負數\n   → Decision: 是否已經標記過? // 檢查索引位置是否為負\n       Yes → Step 3: 跳過 // 已標記，直接進下一個\n       No  → Step 4: 把索引位置設為負數 // 標記存在\n→ Step 5: 迭代索引 i 從 0 到 n-1 // 找出未被標記的索引\n   → Decision: nums[i] 正? // 正數表示對應數字缺失\n       Yes → Step 6: 把 i+1 加入 result // 將缺失的數字加入結果\n       No  → Step 7: 跳過 // 已標記，忽略\n→ Step 8: 返回 result // 完成\nEnd // 程式執行結束\n\nBut we need to incorporate the marking using abs, because we may modify numbers during iteration. So in Step 4 we should do nums[abs(num)-1] = -abs(nums[abs(num)-1]).\n\nBut we should keep virtual code simple: \"將 nums[abs(num)-1] 設為負數\" is enough.\n\nAlso need to show index extraction: \"num = abs(num)\" etc.\n\nLet's refine:\n\nStep 2: For each num in nums:\n   idx = abs(num) - 1\n   nums[idx] = -abs(nums[idx])\n\nBut we can break into steps:\n\nStep 2a: 計算 idx = abs(num) - 1\nStep 2b: 把 nums[idx] 設為負數\n\nBut we can keep in same line.\n\nLet's produce.\n\nAlso include decision for marking: we may skip if already negative. But we can just set anyway; negative negative yields negative. So we don't need decision. But for clarity we can show step: if nums[idx] > 0 then set negative else skip. But not necessary.\n\nLet's keep simple.\n\nNow produce final output.\n\nMake sure each line includes \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe'll not use quotes around code, just plain words.\n\nLet's craft lines.\n\nAlso use arrow \"→\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空陣列 // 用來儲存所有缺失的數字\n→ Step 2: 迭代 nums，對每個 num 執行標記操作 // 把每個出現在 nums 的數字映射到對應索引並標記\n    → Decision: 是否已經標記過? // 檢查對應索引位置是否已為負數\n        Yes → Step 3: 跳過 // 已標記，直接進下一個\n        No  → Step 4: 把 nums[abs(num)-1] 設為負數 // 標記該數字已出現\n→ Step 5: 迭代索引 i 從 0 到 n-1 // 找出未被標記的索引\n    → Decision: nums[i] 正? // 正數表示對應數字缺失\n        Yes → Step 6: 把 i+1 加入 result // 將缺失的數字加入結果\n        No  → Step 7: 跳過 // 已被標記，忽略\n→ Step 8: 返回 result // 將缺失數字列表作為輸出\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDisappearedNumbers(self, nums):\n        n = len(nums)\n        for num in nums:\n            index = abs(num) - 1\n            nums[index] = -abs(nums[index])\n        return [i + 1 for i in range(n) if nums[i] > 0]\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    solution = Solution()\n    result = solution.findDisappearedNumbers(nums)\n    print('[' + ','.join(map(str, result)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[5,6]",
          "success": true,
          "output": "[5,6]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode273.json",
    "problem_index_in_file": 0,
    "title": "Integer to English Words",
    "description_snippet": "Convert a non-negative integer num to its English words representation....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for converting non-negative integer to English words. Must use Start, Decision, arrow. Provide line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols. Should not include actual code. Should structure algorithm: maybe break number into billions, millions, thousands, hundreds, tens, units. Provide mapping arrays for ones, teens, tens, thousands. Then iterative process.\n\nLet's produce steps:\n\nStart\n→ Define arrays: ones, teens, tens, thousands // mapping words\n→ Decision: 如果 num == 0? // check zero\n    Yes → Output 'Zero' // return\n    No  → Continue\n→ Step: Initialize result = '' // accumulate\n→ Step: Set values for billions, millions, thousands, hundreds // num / etc.\n→ For each scale in [billions, millions, thousands, hundreds]:\n    → Decision: 如果 scale value > 0? // skip if zero\n        Yes → ProcessSegment(scale value, result) // convert 1-999\n        No  → Skip\n→ Step: Process remaining num (less than 1000) // same\n→ End // return result trimmed\n\nNeed to include ProcessSegment steps: break into hundreds, tens, units. Use Decision for hundreds > 0, tens >=10, etc.\n\nLet's structure:\n\nDefine function ProcessSegment(n):\n    // n between 0 and 999\n    → Decision: 如果 n >= 100? // hundreds\n        Yes → Append ones[n/100] + \" Hundred\" // add hundreds word\n        No  → Skip\n    → Decision: 如果 n % 100 >= 20? // tens\n        Yes → Append tens[(n%100)/10] // tens word\n        No  → Skip\n    → Decision: 如果 10 <= n % 100 <= 19? // teens\n        Yes → Append teens[n%100 -10]\n        No  → \n    → Decision: 如果 n % 10 > 0? // units\n        Yes → Append ones[n%10]\n        No  → Skip\n    → If segment added: Append space\n\nNeed to add scale word (Billion, Million, Thousand, etc.) after segment.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義詞彙表 ones, teens, tens, thousands // 文字映射\n→ Decision: 如果 num == 0? // 檢查是否為零\n    Yes → Step 2: 輸出 'Zero' // 返回結果\n    No  → Step 3: 初始化 result 為空字串 // 存放文字結果\n→ Step 4: 計算 billion, million, thousand, remainder // 切割數字\n→ Decision: 如果 billion > 0? // 有億位\n    Yes → Step 5: 呼叫 ProcessSegment(billion) // 轉換 1-999\n    No  → Skip\n→ Decision: 如果 million > 0? // 有萬萬位\n    Yes → Step 6: 呼叫 ProcessSegment(million)\n    No  → Skip\n→ Decision: 如果 thousand > 0? // 有千位\n    Yes → Step 7: 呼叫 ProcessSegment(thousand)\n    No  → Skip\n→ Step 8: 處理 remainder (小於 1000) // 最後三位\n→ End // 回傳 result\n\nBut need ProcessSegment details. Should be separate steps maybe with label ProcessSegment. Provide sub steps.\n\nLet's include:\n\n→ Start ProcessSegment(n) // 處理 1-999\n    → Decision: n >= 100? // 有百位\n        Yes → Append ones[n/100] + \" Hundred\" // 加上百位字\n        No  → Skip\n    → Decision: (n % 100) >= 20? // 十位大於等於 20\n        Yes → Append tens[(n%100)/10] // 加上十位字\n        No  → Skip\n    → Decision: 10 <= (n%100) <= 19? // 十一到十九\n        Yes → Append teens[(n%100)-10] // 加上特殊十字\n        No  → Skip\n    → Decision: (n % 10) > 0? // 有個位\n        Yes → Append ones[n%10] // 加上個位字\n        No  → Skip\n    → Append space // 以空格分隔\n    → End // 返回\n\nBut we need to integrate scale word after ProcessSegment: e.g., after segment add thousands[scaleIndex].\n\nBetter: In main loop, after ProcessSegment, append scale word.\n\nLet's produce:\n\n→ Decision: 如果 billion > 0?\n    Yes → Step 5: 呼叫 ProcessSegment(billion) // 轉換億位\n        → Append 'Billion' // 加上億的單位\n    No  → Skip\nSimilar for million, thousand.\n\nLet's craft final output lines accordingly.\n\nRemember format: \"虛擬碼步驟 // 解釋\"\n\nWe need to use arrow \"→\" before each step except maybe Start and End.\n\nLet's produce lines.\n\nAlso include indentation for sub-decisions? In example they used indenting but we can just add spaces. For clarity.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義詞彙表 ones, teens, tens, thousands // 建立數字與文字對應表  \n→ Decision: 如果 num == 0? // 檢查是否為零  \n  Yes → Step 2: 輸出 'Zero' // 回傳 'Zero'  \n  No  → Step 3: 初始化 result 為空字串 // 存放最終文字結果  \n→ Step 4: 計算 billion, million, thousand, remainder // 將 num 切割成億、萬、千、百以下各段  \n→ Decision: 如果 billion > 0? // 有億位數  \n  Yes → Step 5: 呼叫 ProcessSegment(billion) // 轉換 1-999 的億位段  \n    → Append 'Billion' // 加上億的單位詞  \n  No  → Skip  \n→ Decision: 如果 million > 0? // 有萬萬位數  \n  Yes → Step 6: 呼叫 ProcessSegment(million)  \n    → Append 'Million' // 加上萬萬的單位詞  \n  No  → Skip  \n→ Decision: 如果 thousand > 0? // 有千位數  \n  Yes → Step 7: 呼叫 ProcessSegment(thousand)  \n    → Append 'Thousand' // 加上千的單位詞  \n  No  → Skip  \n→ Step 8: 處理 remainder (小於 1000) // 最後三位數字  \n  → 呼叫 ProcessSegment(remainder) // 轉換百以下的段  \n→ End // 回傳 result，程式結束  \n\nProcessSegment(n) // 處理 1-999 的段  \n → Decision: n >= 100? // 是否有百位  \n  Yes → Append ones[n / 100] + \" Hundred\" // 加上百位詞  \n  No  → Skip  \n → Decision: (n % 100) >= 20? // 十位是否 >= 20  \n  Yes → Append tens[(n % 100) / 10] // 加上十位詞  \n  No  → Skip  \n → Decision: 10 <= (n % 100) <= 19? // 十一到十九的特殊處理  \n  Yes → Append teens[(n % 100) - 10] // 加上特殊十字詞  \n  No  → Skip  \n → Decision: (n % 10) > 0? // 是否有個位  \n  Yes → Append ones[n % 10] // 加上個位詞  \n  No  → Skip  \n → Append space // 段結束後加入空格分隔  \n → End // 回傳段文字結果",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\",\n                 \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n\n        def two(num: int) -> str:\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            return tens[num // 10] + (\" \" + ones[num % 10] if num % 10 else \"\")\n\n        def three(num: int) -> str:\n            h = num // 100\n            rest = num % 100\n            part = \"\"\n            if h:\n                part += ones[h] + \" Hundred\"\n            if rest:\n                part += (\" \" if part else \"\") + two(rest)\n            return part\n\n        billion = num // 1_000_000_000\n        million = (num % 1_000_000_000) // 1_000_000\n        thousand = (num % 1_000_000) // 1_000\n        rest = num % 1_000\n\n        parts = []\n        if billion:\n            parts.append(three(billion) + \" Billion\")\n        if million:\n            parts.append(three(million) + \" Million\")\n        if thousand:\n            parts.append(three(thousand) + \" Thousand\")\n        if rest:\n            parts.append(three(rest))\n\n        return \" \".join(parts)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    num = int(nums[0])\n    sol = Solution()\n    result = sol.numberToWords(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 123",
          "expected_output": "\"One Hundred Twenty Three\"",
          "success": true,
          "output": "One Hundred Twenty Three"
        },
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "success": true,
          "output": "Twelve Thousand Three Hundred Forty Five"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "success": true,
          "output": "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode632.json",
    "problem_index_in_file": 0,
    "title": "Smallest Range Covering Elements from K Lists",
    "description_snippet": "You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Problem: find smallest range covering at least one number from each k lists. Classic algorithm: use min-heap to track current min among current pointers, track max of current values. Iterate through all elements? Actually use pointers for each list, push first element into min-heap with list index and element index. Track current max. While heap not empty: pop min, compute range [min, currentMax], update best if smaller. Then advance pointer for that list: if next exists, push next element, update currentMax; else break.\n\nEdge cases. Complexity O(N log k). Need to output step by step.\n\nWe'll output virtual code lines with \"Start\", \"→ Step X: ...\" etc. Use decisions for updating best. Use variable names: k = number of lists. lists: L[0..k-1]. heap: min-heap. pointers: idx[i]. currentMax. bestRange = [bestLow, bestHigh], bestSize.\n\nImplement.\n\nWe'll produce each line with explanation. Ensure each line has virtual code step and comment. Use arrows. No actual code. Provide steps. Use decision structure for comparison.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定變數 k = 列表數量 // 取得輸入列表數量  \n→ Step 2: 為每個列表 i 初始化指標 idx[i] = 0 // 指向各列表的第一個元素  \n→ Step 3: 建立最小堆 heap，並將每個列表的首項 (lists[i][0], i, 0) 插入堆中 // 準備同步追蹤各列表的最小值  \n→ Step 4: 計算 currentMax = max(lists[i][0]) for all i // 取得目前堆中所有元素的最大值  \n→ Step 5: 設定 bestRange = [bestLow, bestHigh] = [∞, -∞]，bestSize = ∞ // 初始化最佳範圍  \n\n→ Decision: while heap 非空? // 只要堆中還有元素可處理  \n Yes → Step 6: pop (minVal, listIdx, elemIdx) = heap.pop() // 取出當前最小值及其來源  \n  → Step 7: 計算 currentSize = currentMax - minVal // 目前範圍長度  \n  → Decision: currentSize < bestSize? 或 currentSize == bestSize 且 minVal < bestLow? // 判斷是否更新最佳範圍  \n   Yes → Step 8: bestLow = minVal; bestHigh = currentMax; bestSize = currentSize // 更新最佳範圍  \n   No → No action // 當前範圍不佳  \n  → Step 9: 檢查下一個元素 nextIdx = elemIdx + 1 是否在 lists[listIdx] 內？  \n   Yes → Step 10: nextVal = lists[listIdx][nextIdx]; heap.push((nextVal, listIdx, nextIdx)) // 把下一個元素加入堆  \n    → Decision: nextVal > currentMax?  \n     Yes → Step 11: currentMax = nextVal // 更新全局最大值  \n     No → No action // currentMax 保持不變  \n   No → Step 12: break // 該列表已無更多元素，終止循環  \n\nEnd // 程式執行結束  \n→ Output bestRange = [bestLow, bestHigh] // 輸出最小範圍",
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass Solution:\n    def smallestRange(self, nums):\n        \"\"\"\n        Find the smallest range that includes at least one number from each list.\n        \"\"\"\n        heap = []\n        max_val = float('-inf')\n        # 初始化堆和全局最大值\n        for i, lst in enumerate(nums):\n            heapq.heappush(heap, (lst[0], i, 0))  # (值, 列表索引, 列表內索引)\n            max_val = max(max_val, lst[0])\n\n        best_size = float('inf')\n        best_low, best_high = -1, -1\n\n        while heap:\n            min_val, list_idx, elem_idx = heapq.heappop(heap)\n\n            # 更新最佳範圍\n            current_size = max_val - min_val\n            if current_size < best_size or (current_size == best_size and min_val < best_low):\n                best_size = current_size\n                best_low, best_high = min_val, max_val\n\n            # 將同一列表的下一個元素放入堆\n            if elem_idx + 1 < len(nums[list_idx]):\n                next_val = nums[list_idx][elem_idx + 1]\n                heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n                if next_val > max_val:\n                    max_val = next_val\n            else:\n                # 目前列表已無更多元素，無法再擴展範圍\n                break\n\n        return [best_low, best_high]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入字串，預期格式如 \"nums = [[...], [...], ...]\"\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception as e:\n        # 如果解析失敗，直接輸出錯誤訊息並結束\n        print(f\"Error parsing input: {e}\")\n        return\n\n    solution = Solution()\n    result = solution.smallestRange(nums)\n\n    # 依據題目要求輸出 [a,b] 的格式（無空格）\n    print(f'[{result[0]},{result[1]}]')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]",
          "expected_output": "[20,24]",
          "success": true,
          "output": "[20,24]"
        },
        {
          "example_index": 1,
          "input": "nums = [[1,2,3],[1,2,3],[1,2,3]]",
          "expected_output": "[1,1]",
          "success": true,
          "output": "[1,1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode567.json",
    "problem_index_in_file": 0,
    "title": "Permutation in String",
    "description_snippet": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code to solve: given s1, s2, return true if s2 contains any permutation of s1. Classic sliding window with frequency counts.\n\nWe must produce lines like \"Start // 程式開始執行\" etc. Each line with virtual code step, arrow etc.\n\nWe should show steps: calculate lengths, handle edge cases, create frequency map for s1, sliding window of length s1 over s2, maintain counts, compare when match count equals 26? But could use map.\n\nSimplify: use array of size 26 for lowercase letters. Steps: if s1 longer than s2 return false. Initialize freq[26] =0; for each char in s1 freq[char]++. Then sliding window of size len1 over s2: maintain window freq array, when char enters, decrement, when char leaves increment? Actually maintain counts difference. But simpler: keep window freq and compare arrays each time? That's O(n*26). But still fine.\n\nBetter: keep matchCount: number of characters where window freq equals target freq. We'll produce steps accordingly.\n\nBut we only need virtual code, not actual code. Provide each line with explanation.\n\nWe'll produce steps like:\n\nStart // 程式開始執行\n→ Step 1: 取得 s1 長度 len1 和 s2 長度 len2 // 獲取兩個字串長度\n→ Decision: 如果 len1 > len2? // s1 不能比 s2 長\n    Yes → Step 2: 回傳 false // s2 無法包含 s1 的排列\n    No  → Step 3: 初始化 freq[26] 為 0 // 建立 26 個字母頻率表\n    No → Step 4: 對 s1 逐字增加 freq[char] // 計算 s1 的字母頻率\n\nNow sliding window:\n\n→ Step 5: 初始化窗口 freqWindow[26] 為 0 // 用於 s2 的滑動窗口\n→ Step 6: 先填充 s2 前 len1 個字元進 freqWindow // 形成第一個窗口\n\nWe need to compute matchCount.\n\n→ Step 7: 計算 matchCount = 0 // 兩個頻率表相同的字母數量\n→ Step 8: 對每個字母 i 從 0 到 25:\n        If freq[i] == freqWindow[i] → matchCount++ // 若相等則計數\n\n→ Decision: 如果 matchCount == 26? // 所有字母頻率相同\n    Yes → Step 9: 回傳 true // 找到排列\n    No → Step 10: 循環 i 從 len1 到 len2-1:\n        // 移動窗口\n        1. 設 newChar = s2[i], outChar = s2[i-len1]\n        2. 如果 newChar == outChar → 只需更新 freqWindow[newChar] ;  // 但在虛擬碼中簡化\n        3. 否則\n            → Step 11: 更新 freqWindow[outChar]++ // 出去的字母頻率加一\n            → Step 12: 更新 freqWindow[newChar]-- // 進來的字母頻率減一\n        4. 對 newChar, outChar 進行 matchCount 調整：\n            → Step 13: 如果 freq[outChar] == freqWindow[outChar] → matchCount-- // 失去匹配\n            → Step 14: 如果 freq[outChar] == freqWindow[outChar]-1 → matchCount++ // 恢復匹配\n            → Step 15: 同理對 newChar 調整\n        5. Decision: 如果 matchCount == 26? // 窗口匹配\n            Yes → Step 16: 回傳 true\n    End 循環\n→ Step 17: 回傳 false // 整個 s2 沒有找到\nEnd // 程式結束\n\nBut we might simplify to avoid complex matchCount adjustments: we can just compare arrays each step. That is simpler.\n\nLet's adopt simpler approach: After each slide, compare arrays. Complexity O(n*26). That's fine.\n\nSo after step 10: for each window, we compare freq and freqWindow. If equal, return true.\n\nThus we don't need matchCount.\n\nLet's write steps:\n\nStart\n→ Step 1: len1 = s1.length, len2 = s2.length\n→ Decision: if len1 > len2 then\n    Yes → Step 2: return false\n    No → Step 3: init target[26] = 0\n→ Step 4: for each char c in s1: target[c-'a']++\n→ Step 5: init window[26] = 0\n→ Step 6: for i=0 to len1-1: window[s2[i]-'a']++\n→ Step 7: Decision: if window == target then\n    Yes → Step 8: return true\n    No → Step 9: for i=len1 to len2-1:\n        1. addChar = s2[i]\n        2. removeChar = s2[i-len1]\n        3. window[addChar-'a']++\n        4. window[removeChar-'a']--\n        5. Decision: if window == target then\n            Yes → Step 10: return true\n    End for\n→ Step 11: return false\nEnd\n\nWe'll produce each step line with explanation.\n\nNow we need arrow format: \"Start // ...\" Then \"→ Step 1: ...\" etc. Decision with arrows and indentation. Use \"Yes →\" \"No →\" lines.\n\nMake sure each line has a space between virtual code and comment.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 s1 的長度 len1 與 s2 的長度 len2 // 獲取兩個字串長度  \n→ Decision: 如果 len1 大於 len2? // s1 不能比 s2 長  \n  Yes → Step 2: 回傳 false // s2 無法包含 s1 的排列  \n  No → Step 3: 初始化 26 個字母頻率表 target[26] 為 0 // 建立 s1 的字母頻率表  \n→ Step 4: 對 s1 的每個字元 c: target[c - 'a']++ // 計算 s1 的字母頻率  \n→ Step 5: 初始化 26 個字母頻率表 window[26] 為 0 // 用於 s2 的滑動窗口  \n→ Step 6: 對 s2 的前 len1 個字元 i: window[s2[i] - 'a']++ // 形成第一個窗口  \n→ Decision: 如果 window 與 target 相等? // 第一個窗口是否已是 s1 的排列  \n  Yes → Step 7: 回傳 true // 找到匹配  \n  No → Step 8: 循環 i 從 len1 到 len2-1  \n    1. 新字元 addChar = s2[i]  \n    2. 被移除字元 removeChar = s2[i - len1]  \n    3. window[addChar - 'a']++ // 加入新字元  \n    4. window[removeChar - 'a']-- // 移除舊字元  \n    5. Decision: 如果 window 與 target 相等? // 窗口是否已是 s1 的排列  \n      Yes → Step 9: 回傳 true // 找到匹配  \n    End 循環  \n→ Step 10: 回傳 false // 整個 s2 沒有找到 s1 的任何排列  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        len1, len2 = len(s1), len(s2)\n        if len1 > len2:\n            return False\n\n        target = [0] * 26\n        for ch in s1:\n            target[ord(ch) - 97] += 1\n\n        window = [0] * 26\n        for i in range(len1):\n            window[ord(s2[i]) - 97] += 1\n\n        if window == target:\n            return True\n\n        for i in range(len1, len2):\n            window[ord(s2[i]) - 97] += 1\n            window[ord(s2[i - len1]) - 97] -= 1\n            if window == target:\n                return True\n\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract strings inside double quotes\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        s1, s2 = parts[0], parts[1]\n    else:\n        # Fallback: assume two lines\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            s1, s2 = lines[0], lines[1]\n        else:\n            s1 = s2 = \"\"\n\n    sol = Solution()\n    result = sol.checkInclusion(s1, s2)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode89.json",
    "problem_index_in_file": 0,
    "title": "Gray Code",
    "description_snippet": "An n-bit gray code sequence is a sequence of 2^n integers where:\n\nEvery integer is in the inclusive ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code to produce a Gray code sequence. Should not output actual code. Use Start, End, Decision, etc. For Gray code generation: standard algorithm: iterative reflection. Steps: initialize sequence [0], for i from 0 to n-1: prefix 0 to current, prefix 1 to reversed current, combine.\n\nWe must produce virtual code lines: Start, Step 1: input n, Step 2: compute total = 2^n, Step 3: initialize sequence = [0], Step 4: loop i from 0 to n-1, Step 5: create new list, Step 6: prefix 0 to each in current, Step 7: prefix 1 to reversed current, Step 8: combine, Step 9: return sequence, End.\n\nAdd decisions if any: maybe decide if n==0? but n>=1? Could include decision. Also compute power: Decision: if n==0? etc. But not necessary.\n\nAlso could include check if n <= 0. But it's fine.\n\nAdd comments. Use arrow.\n\nLet's write.\n\nWe need each line: `虛擬碼步驟 // 解釋/說明`.\n\nLet's produce.\n\nRemember arrow formatting: `→ Step ...`.\n\nAdd indentation for decisions. Use `Decision:` lines.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者處取得 n 的值  \n→ Decision: n 是否小於 0? // 檢查輸入是否合法  \n    Yes → Step 2: 回傳空序列 // 若 n 為負數，直接結束  \n    No  → Step 3: 計算總數 total ← 2^n // 先算出序列長度  \n→ Step 4: 初始化 grayCode ← [0] // 開始時只有 0  \n→ Step 5: 循環 i 從 0 到 n-1  \n    → Decision: i 是否小於 n?  \n        Yes → Step 6: 取 current ← grayCode // 拷貝目前序列  \n        → Step 7: 建立 newList ← 空列表 // 用來組合新序列  \n        → Step 8: 對 current 內每個數值 num  \n            → Step 9: 加入 newList ← 0 << (n-1-i) | num // 前綴 0  \n        → Step 10: 取 current 內每個數值 num（倒序）  \n            → Step 11: 加入 newList ← 1 << (n-1-i) | num // 前綴 1  \n        → Step 12: grayCode ← newList // 更新為新序列  \n        → Step 13: i ← i + 1 // 下一輪迴圈  \n        No  → End of Loop // 迴圈結束  \n→ Step 14: 回傳 grayCode // 傳回完整的 Gray Code 序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef gray_code(n: int):\n    \"\"\"產生 n 位 Gray code 序列.\"\"\"\n    result = [0]\n    for i in range(n):\n        add = 1 << i\n        # 對目前序列反轉後加上高位 1，並拼接到原序列\n        result += [x + add for x in reversed(result)]\n    return result\n\ndef parse_input(text: str) -> int:\n    \"\"\"從輸入文字中擷取第一個出現的整數.\"\"\"\n    match = re.search(r'\\d+', text)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    return int(match.group())\n\ndef main():\n    data = sys.stdin.read()\n    n = parse_input(data)\n    seq = gray_code(n)\n    # 格式化輸出為 [0,1,3,2] 的形式（無空格）\n    output = '[' + ','.join(str(x) for x in seq) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,3,2]",
          "success": true,
          "output": "[0,1,3,2]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0,1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode16.json",
    "problem_index_in_file": 0,
    "title": "3Sum Closest",
    "description_snippet": "Given an integer array nums of length n and an integer target, find three integers in nums such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode with arrow style, Step by step. For the 3Sum Closest problem. Steps: sort array, loop i from 0 to n-3, two-pointer left=i+1 right=n-1, compute sum, update closest if abs diff smaller. If sum==target return target, if sum<target left++ else right--. End. Need to start/End. Each line with explanation. Use Decision. Format: Start, then steps with arrow. Use indentation for Decision branches? They use indentation in example. We'll mirror. Each line: `虛擬碼步驟 // 解釋`. Need \"Start\" line. Let's produce. Use arrow \"→\". Decision lines.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將 nums 依升序排序 // 為了能用雙指標技巧，先把陣列排序\n→ Step 2: 初始化 closest ← nums[0] + nums[1] + nums[2] // 設定初始最接近值為前三個數之和\n→ Decision: n < 3? // 檢查是否至少有三個數字\n    Yes → Step 3: 回傳 closest // 若不足三個，直接回傳初始值\n    No  → \n→ For i ← 0 to n-3 // 主迴圈，選定第一個數\n    → Step 4: left ← i + 1; right ← n - 1 // 設定兩個指標分別指向 i 之後的最左、最右\n    → While left < right // 雙指標搜尋\n        → Step 5: currentSum ← nums[i] + nums[left] + nums[right] // 計算三數之和\n        → Decision: abs(currentSum - target) < abs(closest - target)? // 判斷是否更接近目標\n            Yes → Step 6: closest ← currentSum // 更新最接近值\n            No  → \n        → Decision: currentSum == target? // 若恰好等於目標，直接回傳\n            Yes → Step 7: 回傳 target // 找到最優解，結束程式\n            No  →\n        → Decision: currentSum < target? // 若和小於目標，左指標往右移以增加和\n            Yes → Step 8: left ← left + 1 // 移動左指標\n            No  → Step 9: right ← right - 1 // 否則右指標往左移以減少和\n→ End // 程式執行結束，回傳最接近的三數之和即可\n\n(Note: 在虛擬碼中，“回傳”指示結束並輸出結果。)",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        closest = nums[0] + nums[1] + nums[2]  # 初始最接近值\n        for i in range(n - 2):\n            left, right = i + 1, n - 1\n            while left < right:\n                current = nums[i] + nums[left] + nums[right]\n                if abs(current - target) < abs(closest - target):\n                    closest = current\n                if current < target:\n                    left += 1\n                elif current > target:\n                    right -= 1\n                else:\n                    return current  # 已經等於目標值，直接回傳\n        return closest\n\ndef parse_input(text: str):\n    \"\"\"將形如 'nums = [-1,2,1,-4], target = 1' 的字串轉成 (nums, target)。\"\"\"\n    # 移除所有換行與多餘空白\n    text = text.replace('\\n', ' ').strip()\n    # 轉換為可 eval 的 dict 格式\n    text = text.replace('nums =', 'nums:').replace('target =', 'target:')\n    try:\n        data = eval('{' + text + '}')\n    except Exception:\n        # 若 eval 失敗，試著用正則抓取\n        nums = list(map(int, re.findall(r'nums\\s*=\\s*\\[([^\\]]*)\\]', text)[0].split(',')))\n        target = int(re.search(r'target\\s*=\\s*(-?\\d+)', text).group(1))\n        return nums, target\n    return data['nums'], data['target']\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw.strip():\n        return\n    nums, target = parse_input(raw)\n    sol = Solution()\n    result = sol.threeSumClosest(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,2,1,-4], target = 1",
          "expected_output": "2",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp9jystdl3.py\", line 30, in parse_input\n    data = eval('{' + text + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums' is not defined\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp9jystdl3.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp9jystdl3.py\", line 42, in main\n    nums, target = parse_input(raw)\n                   ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9jystdl3.py\", line 33, in parse_input\n    nums = list(map(int, re.findall(r'nums\\s*=\\s*\\[([^\\]]*)\\]', text)[0].split(',')))\n                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,0], target = 1",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmprj494a0t.py\", line 30, in parse_input\n    data = eval('{' + text + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums' is not defined\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmprj494a0t.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmprj494a0t.py\", line 42, in main\n    nums, target = parse_input(raw)\n                   ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprj494a0t.py\", line 33, in parse_input\n    nums = list(map(int, re.findall(r'nums\\s*=\\s*\\[([^\\]]*)\\]', text)[0].split(',')))\n                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode747.json",
    "problem_index_in_file": 0,
    "title": "Largest Number At Least Twice of Others",
    "description_snippet": "You are given an integer array nums where the largest integer is unique.\n\nDetermine whether the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code with line-by-line explanation. We must not output actual code. Just pseudocode with arrows. The requirement: each line: virtual code step + space + // explanation. Must use Start, End, Decision:, arrow. Use Yes→, No→. Use the format. So we need to produce something like:\n\nStart\n→ Step 1: 初始化最大值和次大值為 -∞, maxIndex = -1\n→ Step 2: 循環遍歷 nums, 更新最大值和次大值及其索引\n→ Decision: 最大值是否至少是次大值的两倍? \n    Yes → Return maxIndex\n    No  → Return -1\nEnd\n\nBut we need to be more detailed: we must compute second largest. We need to also check for unique largest.\n\nWe can do:\n\nStart\n→ Step 1: Set max1 = -∞, max2 = -∞, idx = -1 // 初始最大、次大和索引\n→ Step 2: For each element a in nums with index i:\n    → Decision: a > max1?\n        Yes → max2 = max1; max1 = a; idx = i\n        No  → Decision: a > max2?\n            Yes → max2 = a\n            No  → // do nothing\n→ Decision: max1 >= 2 * max2 ?\n    Yes → Step 3: Return idx\n    No  → Step 4: Return -1\nEnd\n\nAdd comments. Must ensure each line has // explanation. Provide proper indentation for decisions.\n\nAlso note unique largest condition: Since largest unique, we assume only one max1. So we don't need to check duplicates.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化最大值 max1 = -∞，次大值 max2 = -∞，最大值索引 idx = -1 // 準備追蹤最大、次大與其位置  \n→ Step 2: 遍歷 nums，對每個元素 a (索引 i)  \n    → Decision: a > max1? // 判斷是否為新的最大值  \n        Yes → max2 = max1; max1 = a; idx = i // 更新次大值、最大值與索引  \n        No → Decision: a > max2? // 若不是最大值，檢查是否為新的次大值  \n            Yes → max2 = a // 更新次大值  \n            No  → // 無需更新，繼續迭代  \n→ Decision: max1 >= 2 * max2? // 判斷最大值是否至少是每個其他數的兩倍  \n    Yes → Step 3: 回傳 idx // 最大值符合條件，返回其索引  \n    No  → Step 4: 回傳 -1 // 最大值不符合條件，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def dominantIndex(self, nums):\n        \"\"\"\n        Return the index of the largest element if it is at least twice as large\n        as every other element; otherwise return -1.\n        \"\"\"\n        if not nums:                     # 空陣列直接回傳 -1\n            return -1\n\n        max_num = max(nums)               # 找到最大值\n        max_index = nums.index(max_num)   # 最大值的索引\n\n        # 檢查其它數字是否都不大於 max_num / 2\n        for i, num in enumerate(nums):\n            if i != max_index and max_num < 2 * num:\n                return -1\n        return max_index\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容，假設輸入為類似 \"[3,6,1,0]\" 的字串\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        # 轉成 Python 物件，安全使用 literal_eval\n        nums = ast.literal_eval(raw_input)\n    else:\n        nums = []\n\n    sol = Solution()\n    result = sol.dominantIndex(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,6,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode65.json",
    "problem_index_in_file": 0,
    "title": "Valid Number",
    "description_snippet": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numb...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that check if string s is a valid number, following the definition. We must output line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. Provide steps for validation: trim spaces, parse sign, digits, dot, exponent. We need to cover integer, decimal, exponent. Provide decision branching.\n\nWe need to output structured pseudo-code.\n\nLet's outline steps:\n\nStart\n→ Trim whitespace from s // remove leading/trailing spaces\n→ Check if empty string → No → return false\n→ Parse optional sign at beginning\n→ Parse integer part digits\n→ Parse optional fractional part:\n    If '.' present:\n        parse digits after '.' maybe optional\n→ After parsing numeric part, if there are remaining chars:\n    If 'e' or 'E' present:\n        parse exponent part: optional sign, integer digits\n    else → return false\n→ Validate conditions: at least one digit in integer or fraction part\n→ Ensure no leftover characters\n→ Return true\n\nWe should produce decision nodes.\n\nWe also need to handle cases where there is dot but no digits before, e.g., \".9\". Accept if digits after dot.\n\nAlso cases like \"4.\" valid. So at least one digit overall.\n\nEdge cases: \"1e\" invalid because exponent must have digits.\n\nSo we need to track flags: hasDigits, hasDot, hasExpDigits.\n\nPseudo-code lines with arrows and decisions.\n\nWe produce step lines: e.g., \"Start // 程式開始執行\". Use \"→\".\n\nWe need to produce a step per line. It's fine.\n\nLet's write:\n\nStart // 程式開始執行\n→ Trim s // 去除首尾空白\n→ Decision: s 為空? // 檢查字串是否為空\n    Yes → Return false // 空字串不是有效數字\n    No → Continue\n→ ParseOptionalSign() // 解析前置符號\n→ ParseDigits() // 解析連續數字，設定 hasDigits\n→ Decision: s 中是否有 '.'? // 檢查是否有小數點\n    Yes → ParseFraction() // 解析小數點後的數字\n    No → Continue\n→ Decision: s 中是否有 'e' 或 'E'? // 檢查指數符號\n    Yes → ParseExponent() // 解析指數部分\n    No → Continue\n→ Decision: 是否剩餘未解析字符? // 檢查是否已經全部解析\n    Yes → Return false // 多餘字符使其無效\n    No → Continue\n→ Decision: 是否至少有一個數字? // 確保整體包含數字\n    Yes → Return true // 合法數字\n    No → Return false // 只有符號或小數點無數字\n\nNeed to include substeps for ParseOptionalSign, ParseDigits, ParseFraction, ParseExponent. Each as step lines.\n\nWe must include explanations for each step.\n\nLet's produce full lines.\n\nMake sure to use arrows and decisions properly.\n\nWe may also include inner decisions: e.g., in ParseDigits: while digit; else no digits.\n\nBut we can keep simple.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Trim s // 去除首尾空白  \n→ Decision: s 為空? // 檢查字串是否為空  \n  Yes → Return false // 空字串不是有效數字  \n  No → Continue  \n→ ParseOptionalSign() // 解析前置符號（+ 或 -）  \n  Step: 如果 s 的第一個字符是 '+' 或 '-'，移除該字符  \n  // 只處理符號，並移到下個字符  \n→ ParseDigits() // 解析連續數字，設定 hasDigits  \n  Step: 從目前位置開始，讀取所有連續數字並累計 countDigits  \n  // 若沒有數字，countDigits 為 0  \n→ Decision: s 中是否有 '.'? // 檢查是否有小數點  \n  Yes → ParseFraction() // 解析小數點後的數字  \n    Step: 移除 '.'  \n    Step: 從目前位置開始，讀取所有連續數字並累計 countFractionDigits  \n    // 可為 0，允許形式如 '4.' 或 '.9'  \n  No → Continue  \n→ Decision: s 中是否有 'e' 或 'E'? // 檢查指數符號  \n  Yes → ParseExponent() // 解析指數部分  \n    Step: 移除 'e' 或 'E'  \n    Step: 解析可選的符號 (+ 或 -)  \n    Step: 從目前位置開始，讀取所有連續數字並累計 countExpDigits  \n    // 指數必須至少有一個數字  \n  No → Continue  \n→ Decision: 是否剩餘未解析字符? // 檢查是否已經全部解析  \n  Yes → Return false // 多餘字符使其無效  \n  No → Continue  \n→ Decision: 是否至少有一個數字? // 確保整體包含數字  \n  Yes → Return true // 合法數字  \n  No → Return false // 只有符號或小數點無數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        s = s.strip()\n        if not s:\n            return False\n\n        num_seen = False\n        dot_seen = False\n        e_seen = False\n\n        for i, char in enumerate(s):\n            if char.isdigit():\n                num_seen = True\n            elif char == '.':\n                if dot_seen or e_seen:\n                    return False\n                dot_seen = True\n            elif char in ('e', 'E'):\n                if e_seen or not num_seen:\n                    return False\n                e_seen = True\n                num_seen = False\n            elif char in ('+', '-'):\n                if i == 0:\n                    continue\n                # sign must follow an exponent\n                if s[i - 1] not in ('e', 'E'):\n                    return False\n            else:\n                return False\n\n        return num_seen\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    # Attempt to extract the string inside quotes if present\n    start = raw_input.find('\"')\n    end = raw_input.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        s = raw_input[start + 1:end]\n    else:\n        s = raw_input\n\n    sol = Solution()\n    result = sol.isNumber(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"0\"",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "s = \"e\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        },
        {
          "example_index": 2,
          "input": "s = \".\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode121.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou wan...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Each line has \"虛擬碼步驟\" then space then comment. Use Start, End, Decision, arrows.\n\nWe need algorithm: single pass, track min price, max profit. So steps: Start, Input array, Initialize minPrice=∞, maxProfit=0, iterate i from 0 to n-1: current price, if current < minPrice, update minPrice; else compute profit = current - minPrice; if profit>maxProfit, update maxProfit; after loop output maxProfit. End.\n\nUse decision structure: Decision: if current < minPrice? Yes→update minPrice No→ compute profit etc. Use decision nested. Provide each step.\n\nWe must produce \"虛擬碼步驟\" like \"→ Step 1: 初始化 minPrice, maxProfit\". Provide arrow before each step. Provide decisions with Yes → No →. Ensure lines each.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入價格陣列 prices // 取得股價資料\n→ Step 2: 設定 minPrice = +∞ // 初始最小價\n→ Step 3: 設定 maxProfit = 0 // 初始最大利潤\n→ Step 4: 循環 i 從 0 到 len(prices)-1 // 遍歷每天價格\n    → Decision: 如果 prices[i] 小於 minPrice? // 判斷是否為新最低價\n        Yes → Step 5: minPrice = prices[i] // 更新最低價\n        No  → Decision: 如果 prices[i] - minPrice 大於 maxProfit? // 計算利潤\n            Yes → Step 6: maxProfit = prices[i] - minPrice // 更新最大利潤\n            No  → Step 7: // 不更新，保持現有最大利潤\n→ Step 8: 輸出 maxProfit // 回傳最優利潤\nEnd // 程式執行結束\n\nEnsure each line has virtual code then comment.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入價格陣列 prices // 取得股價資料  \n→ Step 2: 設定 minPrice = +∞ // 初始最小價  \n→ Step 3: 設定 maxProfit = 0 // 初始最大利潤  \n→ Step 4: 循環 i 從 0 到 len(prices)-1 // 遍歷每天價格  \n  → Decision: 如果 prices[i] 小於 minPrice? // 判斷是否為新最低價  \n   Yes → Step 5: minPrice = prices[i] // 更新最低價  \n   No  → Decision: 如果 prices[i] - minPrice 大於 maxProfit? // 計算利潤  \n    Yes → Step 6: maxProfit = prices[i] - minPrice // 更新最大利潤  \n    No  → Step 7: // 不更新，保持現有最大利潤  \n→ Step 8: 輸出 maxProfit // 回傳最優利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n        min_price = prices[0]\n        max_profit = 0\n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        return max_profit\n\ndef parse_input(input_str: str):\n    \"\"\"\n    將輸入字串轉成價格清單。\n    支援兩種常見格式：\n      1. 直接提供列表，例如 '[7,1,5,3,6,4]'\n      2. 以關鍵字 'prices = [7,1,5,3,6,4]' 的形式提供\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    # 若包含 '='，取等號右邊的內容\n    if '=' in input_str:\n        _, rhs = input_str.split('=', 1)\n        input_str = rhs.strip()\n    # 用 ast.literal_eval 解析安全的字面量\n    try:\n        prices = ast.literal_eval(input_str)\n    except Exception:\n        # 若解析失敗，回傳空清單\n        prices = []\n    # 若解析後不是 list，亦視為空清單\n    if not isinstance(prices, list):\n        prices = []\n    return prices\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    prices_list = parse_input(raw_input)\n    sol = Solution()\n    result = sol.maxProfit(prices_list)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode44.json",
    "problem_index_in_file": 0,
    "title": "Wildcard Matching",
    "description_snippet": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for wildcard pattern matching. Should be line by line. Use Start, End, Decision, etc. Provide explanation in Chinese. Should not produce actual code. Just pseudo steps.\n\nNeed to outline algorithm. Could use DP or recursion with memo. Use DP 2D table with n+1 by m+1. Steps: start, read input, initialize dp[0][0]=true. For i from 0 to n: for j from 0 to m: if pattern[j-1]=='*' then dp[i][j] = dp[i][j-1] or (i>0 and dp[i-1][j]); else if i>0 and (pattern[j-1]==s[i-1] or pattern[j-1]=='?') then dp[i][j]=dp[i-1][j-1]; else false. Finally return dp[n][m]. Or could use recursion. Provide steps accordingly.\n\nMake sure to follow format. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. For loops: \"Loop i from 0 to n:\". Use decision lines.\n\nLet's craft lines.\n\nStart // 開始執行\n→ Read input string s and pattern p // 取得使用者輸入\n→ Let n = length(s), m = length(p) // 取得長度\n→ Initialize 2D boolean array dp[n+1][m+1] // 動態規劃表\n→ Set dp[0][0] = true // 空字符串與空模式匹配\n→ For i from 0 to n: // 初始化第一列\n    → For j from 0 to m:\n        → Decision: 如果 j==0? // 第一個字符\n            Yes → dp[i][j] = false // 只有空模式能匹配空字符串\n            No → Continue // 其他情況\n→ For i from 0 to n:\n    → For j from 1 to m: // 注意 j從1開始因為dp索引\n        → Decision: 如果 pattern[j-1] == '*'? // '*'處理\n            Yes →\n                → Decision: 如果 i==0? // '*'匹配空序列\n                    Yes → dp[i][j] = dp[i][j-1] // 只看左邊\n                    No  →\n                        → Decision: dp[i-1][j] 是否為 true? // '*'匹配至少一個字符\n                            Yes → dp[i][j] = true\n                            No  → dp[i][j] = dp[i][j-1] // 只看左邊\n                // 以上即處理 '*'\n            No →\n                → Decision: 如果 i==0? // 沒有字符可匹配\n                    Yes → dp[i][j] = false\n                    No →\n                        → Decision: pattern[j-1] == s[i-1] 或 pattern[j-1] == '?'? // 匹配單字符\n                            Yes → dp[i][j] = dp[i-1][j-1]\n                            No  → dp[i][j] = false\n→ End // 返回結果\n→ Return dp[n][m] // 判斷整個字符串是否匹配\n\nBut we need to output line by line. We need to maintain structure. Might simplify loops. Provide steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read input string s and pattern p // 取得使用者輸入的字串與模式  \n→ Let n = length(s), m = length(p) // 計算字串與模式的長度  \n→ Initialize 2D boolean array dp[n+1][m+1] // 建立 DP 表格  \n→ Set dp[0][0] = true // 空字串與空模式匹配  \n→ For i from 0 to n: // 初始化第一列 (第一行已在上一步完成)  \n    → For j from 0 to m:  \n        → Decision: 是否為 i==0 且 j>0? // 只有空字串能匹配空模式  \n            Yes → dp[0][j] = false // 其餘情況為 false  \n            No → Continue // 不處理  \n→ For i from 0 to n:  \n    → For j from 1 to m: // 從 j=1 開始，因為 j=0 已初始化  \n        → Decision: pattern[j-1] == '*'? // '*' 的特別處理  \n            Yes →  \n                → Decision: i==0? // '*' 只匹配空序列  \n                    Yes → dp[i][j] = dp[i][j-1] // 只看左邊的值  \n                    No  →  \n                        → Decision: dp[i-1][j] 為 true? // '*' 匹配至少一個字符  \n                            Yes → dp[i][j] = true // 兩種情況都成立  \n                            No  → dp[i][j] = dp[i][j-1] // 只看左邊的值  \n            No →  \n                → Decision: i==0? // 無字符可匹配  \n                    Yes → dp[i][j] = false  \n                    No →  \n                        → Decision: pattern[j-1] == s[i-1] 或 pattern[j-1] == '?'? // 單字符匹配  \n                            Yes → dp[i][j] = dp[i-1][j-1] // 取對角線值  \n                            No  → dp[i][j] = false // 不匹配  \n→ End // 程式執行結束  \n→ Return dp[n][m] // 回傳整個字串是否與模式完全匹配",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # Initialize first row for patterns that can match empty string\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        # Fill DP table\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '?':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                else:\n                    dp[i][j] = False\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"Extract s and p from the input data.\n    Supports formats:\n        s = \"aa\", p = \"a\"\n        aa a\n        aa\n        a\n    \"\"\"\n    # Try to capture quoted substrings first\n    quoted = re.findall(r'\"(.*?)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # Fallback: split by whitespace or comma\n    tokens = re.split(r'[\\s,]+', data.strip())\n    tokens = [t for t in tokens if t]\n    if len(tokens) >= 2:\n        return tokens[0], tokens[1]\n    if len(tokens) == 1:\n        return tokens[0], ''\n    return '', ''\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    s, p = parse_input(raw)\n    sol = Solution()\n    result = sol.isMatch(s, p)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"cb\", p = \"?a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode216.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum III",
    "description_snippet": "Find all valid combinations of k numbers that sum up to n such that the following conditions are tru...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. We need to explain. Virtual code with arrows, Start, End, Decision, etc. Need to produce algorithm: backtracking to find combinations of numbers 1-9 choose k numbers sum n, each used at most once. No duplicates, combinations can be any order. So we produce steps: Start, initialize result list, call recursive function search(start, remaining, current). In recursion: if len(current) == k and remaining == 0 -> add to result. If len(current) == k or remaining < 0 -> return. For i from start to 9: if i <= remaining, choose i, recurse with i+1, remaining-i, current+[i]. After loop end, End. Also include explanation each line. Should be clear.\n\nUse virtual code style. Use arrow \"→\" to indicate next step. Use indentation for decisions. Provide short explanation after //.\n\nWe need to ensure no actual code, only virtual code. Use \"Start\", \"End\". Use \"Decision:\". Use \"Yes →\", \"No →\". Provide lines.\n\nAlso the algorithm uses backtracking.\n\nLet's produce.\n\nAlso maybe include steps: Start; Define result list; Call DFS; DFS definition; base case check; loop; recursion; end. Use virtual code.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的結果列表 results // 用來儲存所有合法組合  \n→ Step 2: 呼叫搜尋函式 Search(start = 1, remaining = n, current = []) // 從 1 開始搜尋  \n→ Decision: 進入 Search(start, remaining, current) // 進入遞迴搜尋  \n  Yes → Step 3: 如果 current 長度等於 k 且 remaining 為 0 →  \n    → Step 4: 把 current 複製加入 results // 找到一組合法組合  \n    → Step 5: 返回 // 結束此路徑  \n  No → Step 6: 如果 current 長度等於 k 或 remaining < 0 →  \n    → Step 7: 返回 // 已滿或剩餘負數，無法繼續  \n  No → Step 8: 循環 i 從 start 到 9 逐一嘗試  \n    → Decision: i 是否小於等於 remaining? // 是否可選取此數字  \n     Yes → Step 9: 將 i 加入 current，呼叫 Search(start = i+1, remaining = remaining-i, current) // 遞迴搜尋下一層  \n     No → Step 10: 跳過此 i // 不能選取，移至下一個  \n    → Loop End // 完成所有 i 的嘗試  \n→ End // 程式執行結束，results 為所有合法組合\n\n---  \n**說明**  \n- `Search` 為遞迴函式，使用回溯法探索所有組合。  \n- `start` 確保每個數字只被使用一次，並避免重複組合。  \n- `remaining` 追蹤尚未達到目標和的剩餘值。  \n- `current` 保存目前已選擇的數字列表。  \n- `results` 最終收集所有符合條件的組合。",
      "generated_code": "import sys\nimport re\n\ndef combinationSum3(k: int, n: int):\n    \"\"\"\n    找出所有從 1~9 中挑出 k 個不重複數字，使其和為 n 的組合。\n    使用回溯法（DFS）逐層嘗試每個可能的數字。\n    \"\"\"\n    results = []\n\n    def backtrack(start: int, path: list[int], total: int):\n        # 既選到 k 個數字又正好等於目標和，將此組合加入結果\n        if len(path) == k and total == n:\n            results.append(path[:])\n            return\n        # 如果已經超過 k 個或總和已經大於目標，直接回溯\n        if len(path) > k or total > n:\n            return\n\n        # 從 current start 開始嘗試 1~9（只要不超過目標和）\n        for i in range(start, 10):\n            if i > n - total:   # 沒必要再試大於剩餘和的數字\n                break\n            path.append(i)\n            backtrack(i + 1, path, total + i)\n            path.pop()\n\n    backtrack(1, [], 0)\n    return results\n\n\ndef main() -> None:\n    \"\"\"\n    主函式：從 stdin 讀取輸入，解析 k 與 n，計算並輸出結果。\n    輸入示例：k = 3, n = 7\n    輸出示例：[[1, 2, 4]]\n    \"\"\"\n    data = sys.stdin.read()\n    # 抓取所有整數，假設前兩個分別是 k 與 n\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        k, n = map(int, nums[:2])\n        result = combinationSum3(k, n)\n        print(result)\n    else:\n        # 若輸入格式不符，直接輸出空列表\n        print([])\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 3, n = 7",
          "expected_output": "[[1,2,4]]",
          "success": true,
          "output": "[[1, 2, 4]]"
        },
        {
          "example_index": 1,
          "input": "k = 3, n = 9",
          "expected_output": "[[1,2,6],[1,3,5],[2,3,4]]",
          "success": true,
          "output": "[[1, 2, 6], [1, 3, 5], [2, 3, 4]]"
        },
        {
          "example_index": 2,
          "input": "k = 4, n = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode721.json",
    "problem_index_in_file": 0,
    "title": "Accounts Merge",
    "description_snippet": "Given a list of accounts where each element accounts[i] is a list of strings, where the first elemen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for merging accounts. Each step with explanation.\n\nWe'll produce algorithm: Use union-find or graph BFS/DFS. We'll implement union-find mapping email to root.\n\nPseudo:\n\nStart\n→ Step 1: Initialize parent map empty\n→ Step 2: For each account, for each email, set parent[email] = email if not set\n→ Step 3: For each account, union first email with others\n→ Step 4: Build dict root to list of emails\n→ Step 5: For each email, find root and append email to dict[root]\n→ Step 6: For each root, sort emails, prepend name (use mapping email to name)\n→ Step 7: Append to result\nEnd\n\nWe need to incorporate explanation lines. We'll format with arrow, decision etc. Use \"Decision:\" for find root? maybe not needed.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 parent // 用來存每個 email 的代表元\n→ Step 2: 建立空字典 nameMap // 存 email 與對應姓名的映射\n→ Step 3: 建立空字典 rootEmails // 存合併後的 email 集合\n→ Decision: 逐筆遍歷 accounts 列表? // 檢查是否還有帳號待處理\n    Yes → Step 4: 取出 accounts[i] // 取得單筆帳號資料\n        → Step 5: 設定 name = accounts[i][0] // 取姓名\n        → Step 6: 取出 emails = accounts[i][1:] // 取所有 email\n        → Step 7: 逐筆遍歷 emails\n            → Step 8: 若 email 未在 parent 中, 設定 parent[email] = email // 初始化父節點\n            → Step 9: 設定 nameMap[email] = name // 存儲姓名對應\n        → Step 10: 若 emails 不為空, 設定 firstEmail = emails[0] // 取第一個 email\n        → Step 11: 逐筆遍歷 emails[1:]\n            → Step 12: Union(firstEmail, email) // 合併兩個 email 到同一集合\n        → Decision: 轉回外層循環? // 回到下一筆帳號\n            Yes → Continue\n            No → End // 所有帳號已處理完\n→ Step 13: 逐筆遍歷所有 email 在 parent 中\n    → Step 14: 取得 root = Find(email) // 找到代表元\n    → Step 15: 若 root 不在 rootEmails 中, 建立空列表 rootEmails[root]\n    → Step 16: 將 email 加入 rootEmails[root] // 建立代表元對應的 email 集合\n→ Decision: 是否有代表元要處理? // 檢查 rootEmails 是否為空\n    Yes → Step 17: 建立空列表 result // 存儲最終結果\n    → Step 18: 逐筆遍歷 rootEmails 中的每一個 (root, emailsList)\n        → Step 19: 排序 emailsList // 按字母序排列\n        → Step 20: 取得 name = nameMap[root] // 代表元對應的姓名\n        → Step 21: 組合帳號 = [name] + emailsList // 先姓名後 email\n        → Step 22: 將帳號 append 到 result\n    → Step 23: 回傳 result // 輸出合併後帳號列表\n    No → Step 24: 回傳空列表 // 若無帳號，返回空結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            if x not in parent:\n                parent[x] = x\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                # union first_email with current email\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        sys.exit()\n\n    # Remove possible leading variable assignment\n    if '=' in data:\n        _, data = data.split('=', 1)\n    data = data.strip()\n\n    # Parse the accounts list safely\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception as e:\n        print(\"[]\")\n        sys.exit()\n\n    sol = Solution()\n    merged_accounts = sol.accountsMerge(accounts)\n    print(merged_accounts)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "expected_output": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "success": true,
          "output": "[['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com']]"
        },
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode763.json",
    "problem_index_in_file": 0,
    "title": "Partition Labels",
    "description_snippet": "You are given a string s. We want to partition the string into as many parts as possible so that eac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps to partition string s such that each letter appears in at most one part, maximize number of parts. Standard Leetcode problem 763 Partition Labels. Approach: For each character, record last occurrence index. Then iterate, track current max last index as end. When i reaches end, we cut. Output sizes. So pseudocode: start, read s. Build map lastPos for each char to last index. Initialize result list. start=0, end=0. For i from 0 to len-1: end = max(end, lastPos[s[i]]). If i==end: size = end - start +1 append to result; start = i+1. End loop. End. Provide step-by-step lines. Use arrow, decision. Must not output actual code. So lines like:\n\nStart // start program\n→ Step 1: 初始化 lastPos 字典 // 记录每个字母最后一次出现的位置\n→ Step 2: 遍历字符串 s 的每个字符，更新 lastPos // 为每个字符存入其最大索引\n→ Step 3: 初始化 result 列表、start、end 为 0 // 用于存放分段长度和跟踪范围\n→ Step 4: 迭代 i 从 0 到 s.length-1 // 逐字符检查\n    → Decision: 更新 end 为 max(end, lastPos[s[i]]) // 取当前字符最后出现的位置\n    → Decision: 如果 i == end? // 判断是否到达一个分割点\n        Yes → Step 5: 计算分段长度 size = end - start + 1\n        Yes → Step 6: 将 size 添加到 result\n        Yes → Step 7: 更新 start = i + 1 // 开始下一个分段\n        No → Continue // 继续遍历\n→ Step 8: 输出 result 列表 // 返回所有分段长度\nEnd // 结束程序\n\nMake sure each line includes code step and comment. Ensure arrow format with indentation. Provide exactly these lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 lastPos 字典 // 记录每个字母最后一次出现的位置  \n→ Step 2: 遍历字符串 s 的每个字符，更新 lastPos // 为每个字符存入其最大索引  \n→ Step 3: 初始化 result 列表、start、end 为 0 // 用于存放分段长度和跟踪范围  \n→ Step 4: 迭代 i 从 0 到 s.length-1 // 逐字符检查  \n    → Decision: 更新 end 为 max(end, lastPos[s[i]]) // 取当前字符最后出现的位置  \n    → Decision: 如果 i == end? // 判断是否到达一个分割点  \n        Yes → Step 5: 计算分段长度 size = end - start + 1  \n        Yes → Step 6: 将 size 添加到 result  \n        Yes → Step 7: 更新 start = i + 1 // 开始下一个分段  \n        No → Continue // 继续遍历  \n→ Step 8: 输出 result 列表 // 返回所有分段长度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef partition_labels(s: str):\n    \"\"\"\n    Partition string s into the maximum number of parts so that\n    each letter appears in at most one part.\n    \"\"\"\n    # 记录每个字符最后一次出现的位置\n    last = {c: i for i, c in enumerate(s)}\n    partitions = []\n    start = end = 0\n    # 遍历字符串，更新当前可结束位置\n    for i, c in enumerate(s):\n        end = max(end, last[c])\n        # 当指针到达可结束位置时，形成一个分割\n        if i == end:\n            partitions.append(i - start + 1)\n            start = i + 1\n    return partitions\n\ndef read_input():\n    \"\"\"\n    读取标准输入，支持两种格式：\n    1. 仅字符串，如：ababcbacadefegdehijhklij\n    2. 赋值语句，如：s = \"ababcbacadefegdehijhklij\"\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 尝试匹配形如 s = \"...\" 或 s = '...' 的赋值语句\n    match = re.search(r's\\s*=\\s*[\"\\'](.*?)[\"\\']', data)\n    if match:\n        return match.group(1)\n    # 直接返回去除首尾空白的字符串\n    return data\n\nif __name__ == \"__main__\":\n    s = read_input()\n    result = partition_labels(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ababcbacadefegdehijhklij\"",
          "expected_output": "[9,7,8]",
          "success": true,
          "output": "[9, 7, 8]"
        },
        {
          "example_index": 1,
          "input": "s = \"eccbbbbdec\"",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode126.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder II",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, for algorithm to find all shortest transformation sequences (Word Ladder II). Use BFS to find shortest distances, then DFS or backtracking to build sequences. Provide pseudo-code steps.\n\nWe must output in specified format: each line: \"虛擬碼步驟 // 解釋\". Include arrow symbols, Start, End, Decision etc. Provide line by line.\n\nWe need to outline algorithm steps: Start, initialize set of words, check endWord in set else return empty, BFS to compute distances, then DFS to build paths, etc.\n\nWe need to show each step.\n\nLet's craft pseudo-code:\n\nStart\n→ Step 1: Convert wordList to set wordSet // for O(1) lookup\n→ Decision: If endWord not in wordSet? // if target not present, no path\n    Yes → Step 2: Return empty list // no transformation\n→ Step 3: Initialize queue with beginWord, distance map with beginWord:0\n→ Step 4: While queue not empty: // BFS to find shortest distances\n    → Step 5: Dequeue currentWord\n    → Step 6: For each position i in currentWord:\n        → Step 7: For each letter 'a' to 'z':\n            → Step 8: Generate nextWord by replacing i-th letter\n            → Decision: If nextWord in wordSet? // valid word\n                Yes → Step 9: If nextWord not in distance map:\n                    → Step 10: distance[nextWord] = distance[currentWord]+1\n                    → Step 11: Enqueue nextWord\n                No → Step 12: If distance[nextWord] == distance[currentWord]+1:\n                    → Step 13: // already found shortest path to nextWord, keep\n                    // no action needed\n    // end for loops\n// end while\n→ Step 14: If endWord not in distance map: // no path\n    → Step 15: Return empty list\n→ Step 16: Initialize results list\n→ Step 17: Define DFS(currentWord, path):\n    → Decision: If currentWord == endWord? // reached target\n        Yes → Step 18: Append copy of path to results\n        No → Step 19: For each position i in currentWord:\n            → Step 20: For each letter 'a' to 'z':\n                → Step 21: Generate nextWord\n                → Decision: If nextWord in wordSet AND distance[nextWord]==distance[currentWord]+1:\n                    Yes → Step 22: Append nextWord to path\n                    → Step 23: DFS(nextWord, path)\n                    → Step 24: Remove last word from path // backtrack\n→ Step 25: Call DFS(beginWord, [beginWord])\n→ End // return results\n\nBut we need arrow formatting for decisions and branches. Use 'Decision: ...' with Yes →, No →.\n\nWe also need to indicate BFS loop and DFS recursion as steps.\n\nBetter to group loops but each step line: \"→ Step X: ...\" For loops, we can use \"→ Decision: ...\".\n\nMake sure each line has explanation.\n\nWe need to be careful to keep lines not too many but enough to reflect logic.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 wordList 轉成字典 set wordSet // 方便 O(1) 查找  \n→ Decision: endWord 是否在 wordSet? // 檢查是否可到達  \n Yes → Step 2: 直接回傳空清單 // 無法完成轉換  \n→ Step 3: 建立 queue，將 beginWord 放進去，並設定 distance[beginWord] = 0 // BFS 初始化  \n→ Step 4: 建立距離 map distance // 記錄每個字到 beginWord 的最短距離  \n→ Step 5: 開始 BFS 迴圈：While queue 不為空 // 找到最短距離  \n → Step 6: 從 queue 取出 currentWord  \n → Step 7: For i 從 0 到 currentWord.length-1 // 逐字位變更  \n  → Step 8: For letter 取 'a' 到 'z'  \n   → Step 9: 產生 nextWord，將 i 位置改為 letter // 生成相鄰字  \n   → Decision: nextWord 是否在 wordSet? // 是否為有效字  \n    Yes → Step 10: If nextWord 不在 distance 中  \n     → Step 11: 設定 distance[nextWord] = distance[currentWord] + 1  \n     → Step 12: 將 nextWord 加入 queue  \n    No → Step 13: 如果 distance[nextWord] == distance[currentWord] + 1  \n     → Step 14: // 已經以最短距離找到，忽略重複路徑  \n     // 無需任何動作  \n    // loop 結束  \n  // loop 結束  \n // loop 結束  \n→ Decision: endWord 是否在 distance? // 是否有路徑到達 endWord  \n Yes → Step 15: 初始化 results 清單 // 用來儲存所有最短序列  \n No → Step 16: 回傳空清單 // 沒有可行序列  \n→ Step 17: 定義遞迴函式 DFS(currentWord, path) // 建立所有最短路徑  \n → Decision: currentWord == endWord? // 是否已到目標  \n  Yes → Step 18: 把 path 的拷貝加入 results // 存入一條完整序列  \n  No → Step 19: For i 從 0 到 currentWord.length-1  \n   → Step 20: For letter 取 'a' 到 'z'  \n    → Step 21: 產生 nextWord，將 i 位置改為 letter  \n    → Decision: nextWord 在 wordSet 且 distance[nextWord] == distance[currentWord] + 1? // 是否是合法下一步且距離正確  \n     Yes → Step 22: 把 nextWord 加到 path  \n     → Step 23: 呼叫 DFS(nextWord, path) // 深度優先搜尋下一層  \n     → Step 24: 從 path 移除最後一個字 // 回溯回上一層  \n     // loop 結束  \n  // loop 結束  \n // if 結束  \n→ Step 25: 呼叫 DFS(beginWord, [beginWord]) // 從起始字開始搜尋  \nEnd // 程式執行結束，結果已在 results 中回傳",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS to find shortest distance and record parents\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        if endWord not in parents:\n            return []\n\n        # DFS to build all shortest paths\n        res = []\n\n        def dfs(current, path):\n            if current == beginWord:\n                res.append([beginWord] + path[::-1])\n                return\n            for prev in parents[current]:\n                dfs(prev, path + [prev])\n\n        dfs(endWord, [])\n        return res\n\ndef parse_input(s):\n    # Convert the input string to a dictionary literal\n    s = s.strip()\n    if not s:\n        return {}\n    # Replace '=' with ':' to form a valid dict syntax\n    s_dict = '{' + s.replace('=', ':') + '}'\n    # Use literal_eval to safely evaluate\n    return ast.literal_eval(s_dict)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    params = parse_input(data)\n    beginWord = params.get(\"beginWord\")\n    endWord = params.get(\"endWord\")\n    wordList = params.get(\"wordList\", [])\n\n    sol = Solution()\n    result = sol.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpx1_3dagc.py\", line 58, in <module>\n    params = parse_input(data)\n             ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx1_3dagc.py\", line 54, in parse_input\n    return ast.literal_eval(s_dict)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7585746f79d0>"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpu4x6phv6.py\", line 58, in <module>\n    params = parse_input(data)\n             ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu4x6phv6.py\", line 54, in parse_input\n    return ast.literal_eval(s_dict)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7064c6bff950>"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode436.json",
    "problem_index_in_file": 0,
    "title": "Find Right Interval",
    "description_snippet": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode. The problem: Given array intervals, each interval has unique start. For each interval, find the index j where start_j >= end_i and start_j minimized. If none, -1. Classic LeetCode problem: \"Find Right Interval\".\n\nApproach: Build list of (start, index). Sort by start. For each interval i, binary search for first start >= end_i. Record j index or -1.\n\nSo pseudocode steps: start, build array of pairs, sort, iterate, binary search, output result array.\n\nWe need line by line Virtual Code. Let's produce steps.\n\nWe need to use arrow notation. For binary search, we can write decision steps. Let's produce pseudocode lines:\n\nStart // start\n→ Step 1: 將每個 interval 的 start 與其原始索引存入 pairs 列表 // 建立 (start, index) 列表\n→ Step 2: 按 start 升序排序 pairs // 方便二分搜尋\n→ Step 3: 初始化結果陣列 result 為長度 intervals 的 -1 // 預設所有為 -1\n→ Step 4: 針對每個 interval i (0 到 n-1) 做如下：\n    → Step 4.1: 目標值 target = intervals[i].end // 需要找的最小 start >= end\n    → Step 4.2: 執行 binarySearchOnPairs(target) 返回最小 index k\n        → Decision: 是否找到符合條件的 start?\n            Yes → Step 4.2.a: result[i] = pairs[k].index // 取對應原始索引\n            No  → Step 4.2.b: result[i] stays -1 // 無可用 interval\n→ End // 完成\n\nWe also need to specify binary search logic.\n\nAdd step for binary search:\n\n→ Step 5: binarySearchOnPairs(target):\n    → Set low=0, high=pairs.length-1\n    → While low <= high:\n        → mid = (low+high)//2\n        → Decision: pairs[mid].start < target?\n            Yes → low = mid+1 // 搜尋右半\n            No  → high = mid-1 // 搜尋左半\n    → Decision: low < pairs.length?\n        Yes → return low // low 指向第一個 >= target\n        No  → return -1 // 沒有\n\nBut we have to integrate inside Step 4.2.\n\nBut per requirement, each line must be in the format: \"虛擬碼步驟 // 解釋\". So we need each line with arrow etc.\n\nAlso need to indicate \"Start\" and \"End\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 pairs 為空清單 // 用來存放 (start, 原始索引)  \n→ Decision: 是否將所有 intervals 加入 pairs?  \n    Yes → Step 2: 對於每個 i 從 0 到 n-1, 執行  \n        → Step 2.a: 將 (intervals[i].start, i) 加入 pairs // 將 start 與索引配對  \n    No  → // 這裡永遠為 Yes，因為必須處理所有 intervals  \n→ Step 3: 對 pairs 按照 start 升序排序 // 方便後續二分搜尋  \n→ Step 4: 建立 result 為長度 n 的陣列，初值為 -1 // 預設每個 interval 的右 interval 為不存在  \n→ Decision: 是否需要對每個 interval i 做搜尋?  \n    Yes → Step 5: 對於每個 i 從 0 到 n-1, 執行  \n        → Step 5.a: 設定 target = intervals[i].end // 需要找到的最小 start  \n        → Step 5.b: 執行 binarySearchOnPairs(target) 並將回傳值存於 idx  \n            → Decision: idx 是否等於 -1?  \n                Yes → Step 5.b.1: result[i] 保持 -1 // 無法找到符合條件的 interval  \n                No  → Step 5.b.2: result[i] = pairs[idx].index // 取得對應的原始索引  \n    No  → // 不會執行，因為必須處理所有 intervals  \n→ Step 6: 輸出 result // 回傳每個 interval 的右 interval 索引  \n→ End // 程式執行結束  \n\n// ---------- 二分搜尋輔助函式 ----------\n→ Function binarySearchOnPairs(target): // 找到最小的 start >= target  \n    → Step 6.1: low = 0, high = pairs.length - 1  \n    → Step 6.2: while low <= high, 執行  \n        → mid = (low + high) // 2  \n        → Decision: pairs[mid].start < target?  \n            Yes → Step 6.2.a: low = mid + 1 // 目標在右半區  \n            No  → Step 6.2.b: high = mid - 1 // 目標在左半區  \n    → Decision: low < pairs.length?  \n        Yes → return low // low 為第一個 start >= target  \n        No  → return -1 // 沒有符合條件的 start",
      "generated_code": "import sys\nimport ast\nimport bisect\n\nclass Solution:\n    def findRightInterval(self, intervals):\n        # 建立開始時間對應索引的列表，並按開始時間排序\n        starts = sorted((interval[0], i) for i, interval in enumerate(intervals))\n        res = []\n        # 逐一對每個 interval 找到最小的 start >= end\n        for interval in intervals:\n            target = interval[1]\n            idx = bisect.bisect_left(starts, (target, -1))\n            if idx < len(starts):\n                res.append(starts[idx][1])\n            else:\n                res.append(-1)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 如果輸入以 \"intervals =\" 開頭，去掉前綴\n    if data.lower().startswith(\"intervals\"):\n        first_bracket = data.find(\"[\")\n        if first_bracket != -1:\n            data = data[first_bracket:]\n    intervals = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.findRightInterval(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2]]",
          "expected_output": "[-1]",
          "success": true,
          "output": "[-1]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[3,4],[2,3],[1,2]]",
          "expected_output": "[-1,0,1]",
          "success": true,
          "output": "[-1, 0, 1]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,4],[2,3],[3,4]]",
          "expected_output": "[-1,2,-1]",
          "success": true,
          "output": "[-1, 2, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode517.json",
    "problem_index_in_file": 0,
    "title": "Super Washing Machines",
    "description_snippet": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps to solve the problem: equalize dresses across machines. This is Leetcode 517. The logic: compute total, check divisible by n. Then iterate over machines, accumulate net balance: sum of differences between current and avg. Track max of abs(prefix sum) and max of (prefix sum - minprefix). Actually solution: For each machine i, compute net = sum_{j<=i} (machines[j] - avg). Then moves = max(abs(net), max_net). But typical: answer = max(abs(net), max_net) where max_net = max(net - minNet). Implementation: maintain cur, maxMoves, minMoves. Or simpler: answer = max(max(cur), -min(cur)) while cur is prefix sum. So produce pseudo-code.\n\nWe must output each line with arrow etc. Provide explanations. Provide pseudo-code only, no actual code. Use arrow, Decision.\n\nLet's craft.\n\nSteps:\n\nStart\n→ Step 1: n = length of machines // 机器数量\n→ Decision: if sum(machines) % n != 0? // 检查是否能平均\n    Yes → Step 2: return -1 // 不可平均\n    No  → Step 3: avg = sum(machines) / n // 每台平均衣物数\n→ Step 4: cur = 0 // 前缀平衡\n→ Step 5: maxMoves = 0 // 记录所需最大移动次数\n→ Step 6: minMoves = 0 // 记录最小平衡值\n→ For i from 0 to n-1: // 遍历每台机器\n    → Step 7: cur = cur + machines[i] - avg // 更新前缀平衡\n    → Decision: if cur > maxMoves? // 更新最大正平衡\n        Yes → maxMoves = cur\n        No → (none)\n    → Decision: if cur < minMoves? // 更新最小平衡\n        Yes → minMoves = cur\n        No → (none)\n→ Step 8: result = max(maxMoves, -minMoves) // 需要的最小移动次数\n→ End // 返回结果\n\nBut we must use arrow notation and decisions with Yes-> and No->.\n\nAlso need to include loops? We can express loop: → Loop: For each machine // iterate. We'll use Step 6: For each machine i from 0 to n-1 // loop. And inside arrow lines.\n\nBetter to keep consistent with examples: They use arrows for steps; decision with indent.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: n ← length(machines) // 取得機器總數\n→ Step 2: total ← sum(machines) // 計算總衣物數\n→ Decision: 如果 total mod n ≠ 0? // 檢查是否能平均分配\n    Yes → Step 3: return -1 // 無法平均，直接返回\n    No  → Step 4: avg ← total / n // 每台機器應有的衣物數\n→ Step 5: cur ← 0 // 前缀平衡累積\n→ Step 6: maxBal ← 0 // 正平衡的最大值\n→ Step 7: minBal ← 0 // 負平衡的最小值\n→ Loop: i從0到n-1 // 遍歷每台機器\n    → Step 8: cur ← cur + machines[i] - avg // 更新前缀平衡\n    → Decision: 如果 cur > maxBal? // 更新最大正平衡\n        Yes → maxBal ← cur\n        No  → (無)\n    → Decision: 如果 cur < minBal? // 更新最小負平衡\n        Yes → minBal ← cur\n        No  → (無)\n→ Step 9: result ← max(maxBal, -minBal) // 所需最小移動次數\n→ End // 程式結束\n\nNeed to use \"→\" after each step. Provide explanation after each.\n\nEnsure each line ends with comment after //. Provide explanation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(machines) // 取得機器總數  \n→ Step 2: total ← sum(machines) // 計算總衣物數  \n→ Decision: 如果 total mod n ≠ 0? // 檢查是否能平均分配  \n Yes → Step 3: return -1 // 無法平均，直接返回  \n No  → Step 4: avg ← total / n // 每台機器應有的衣物數  \n→ Step 5: cur ← 0 // 前缀平衡累積，表示目前前面機器多餘或不足的衣物數  \n→ Step 6: maxBal ← 0 // 正平衡的最大值，代表最多需移動的衣物數  \n→ Step 7: minBal ← 0 // 負平衡的最小值，代表最多需接收的衣物數  \n→ Loop: i從0到n-1 // 遍歷每台機器  \n  → Step 8: cur ← cur + machines[i] - avg // 更新前缀平衡  \n  → Decision: 如果 cur > maxBal? // 更新最大正平衡  \n   Yes → maxBal ← cur  \n   No  → (無操作)  \n  → Decision: 如果 cur < minBal? // 更新最小負平衡  \n   Yes → minBal ← cur  \n   No  → (無操作)  \n→ Step 9: result ← max(maxBal, -minBal) // 所需最小移動次數為正負平衡中的最大絕對值  \n→ End // 程式結束，返回 result",
      "generated_code": "import sys\nimport ast\n\ndef find_min_moves(machines):\n    total = sum(machines)\n    n = len(machines)\n    if total % n != 0:\n        return -1\n    avg = total // n\n    cum_diff = 0\n    res = 0\n    for load in machines:\n        diff = load - avg\n        cum_diff += diff\n        res = max(res, abs(cum_diff), diff)\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    machines = ast.literal_eval(data)\n    print(find_min_moves(machines))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,0,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,2,0]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode657.json",
    "problem_index_in_file": 0,
    "title": "Robot Return to Origin",
    "description_snippet": "There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanations in Chinese. Each line: virtual code step + space + // explanation. Use arrows and structure Start, Decision, etc.\n\nWe need to cover reading string, iterating, moving counters, checking final coordinates equal zero. Provide pseudocode. Provide each line. Ensure format.\n\nWe will produce something like:\n\nStart // 程式開始執行\n→ Step 1: 設定 x = 0, y = 0 // 初始化位置為原點\n→ Step 2: 讀取輸入字串 moves // 莫比\n\n→ Decision: 如果 moves 為空? // 若沒有移動則直接判斷\n    Yes → Step 3: 回傳 true // 空字串代表仍在原點\n    No  → Loop: 對於每個 char c in moves // 遍歷所有移動指令\n\nInside loop: Decision: if c == 'R' then x +=1 else if 'L' x -=1 else if 'U' y +=1 else if 'D' y -=1.\n\nAfter loop: Decision: 如果 x==0 且 y==0? // 檢查是否回到原點\n    Yes → Step 4: 回傳 true\n    No  → Step 5: 回傳 false\nEnd // 程式結束\n\nBut we need to format each line as \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe need to keep one arrow per step. Use \"→ Step ...\". Also use Decision with Yes → and No →.\n\nWe need to produce each line separately.\n\nWe should show loop with Indentation? But it's virtual code; we can show a Loop step with a nested block of decision arrows.\n\nMake sure to follow format: each line separated.\n\nLet's produce.\n\nNote: The requirement: Use virtual code arrows (→, Yes →, No →) and structure Start, End, Decision:.\n\nThus we need to structure:\n\nStart\n→ Step 1: ...\n→ Step 2: ...\n→ Decision: ...\n    Yes → ...\n    No  → ...\nLoop: ...\n    → Decision: ...\n        Yes → ...\n        No  → ...\n...\n\nBut \"Loop:\" maybe not allowed? They didn't mention a Loop keyword. We can use Decision: if index < length? or we can represent iteration as Step: 迭代每個指令.\n\nWe can do: → Step 3: 迭代 moves 中每個字符 // For loop\n\nInside: we need decision for each direction. That can be nested decisions.\n\nSo final pseudocode:\n\nStart // 程式開始執行\n→ Step 1: 設定 x = 0, y = 0 // 初始化坐標\n→ Step 2: 讀取字符串 moves // 獲取移動序列\n→ Decision: 如果 moves 為空? // 檢查是否有指令\n    Yes → Step 3: 回傳 true // 空序列直接回到原點\n    No  → Step 4: 迭代每個字符 c in moves // 遍歷指令\n        → Decision: 如果 c == 'R'? // 右移\n            Yes → Step 5: x += 1 // X 加 1\n            No  → Decision: 如果 c == 'L'? // 左移\n                Yes → Step 6: x -= 1 // X 減 1\n                No  → Decision: 如果 c == 'U'? // 上移\n                    Yes → Step 7: y += 1 // Y 加 1\n                    No  → Decision: 如果 c == 'D'? // 下移\n                        Yes → Step 8: y -= 1 // Y 減 1\n                        No  → Step 9: // 非法字符，忽略或錯誤處理\n→ Decision: 如果 x == 0 且 y == 0? // 最後位置判斷\n    Yes → Step 10: 回傳 true // 回到原點\n    No  → Step 11: 回傳 false // 未回到原點\nEnd // 程式結束\n\nNeed to keep each line separate. Ensure each line has \"虛擬碼步驟\" then space then // 解釋. Use arrows accordingly.\n\nLet's format accordingly.\n\nWe need to ensure that each line is separate. For nested decisions, we can indent lines, but the format might still be accepted.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 x = 0, y = 0 // 初始化坐標為原點\n→ Step 2: 讀取字符串 moves // 取得移動序列\n→ Decision: 如果 moves 為空? // 檢查是否有指令\n    Yes → Step 3: 回傳 true // 空序列直接回到原點\n    No  → Step 4: 迭代每個字符 c in moves // 遍歷指令\n        → Decision: 如果 c == 'R'? // 右移\n            Yes → Step 5: x += 1 // X 加 1\n            No  → Decision: 如果 c == 'L'? // 左移\n                Yes → Step 6: x -= 1 // X 減 1\n                No  → Decision: 如果 c == 'U'? // 上移\n                    Yes → Step 7: y += 1 // Y 加 1\n                    No  → Decision: 如果 c == 'D'? // 下移\n                        Yes → Step 8: y -= 1 // Y 減 1\n                        No  → Step 9: // 非法字符，忽略或錯誤處理\n→ Decision: 如果 x == 0 且 y == 0? // 最後位置判斷\n    Yes → Step 10: 回傳 true // 回到原點\n    No  → Step 11: 回傳 false // 未回到原點\nEnd // 程式結束\n\nCheck that each line includes \"虛擬碼步驟\" and //解釋. The arrow lines start with \"→\". Good.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 x = 0, y = 0 // 初始化坐標為原點  \n→ Step 2: 讀取字符串 moves // 取得移動序列  \n→ Decision: 如果 moves 為空? // 檢查是否有指令  \n  Yes → Step 3: 回傳 true // 空序列直接回到原點  \n  No  → Step 4: 迭代每個字符 c in moves // 遍歷指令  \n    → Decision: 如果 c == 'R'? // 右移  \n     Yes → Step 5: x += 1 // X 加 1  \n     No  → Decision: 如果 c == 'L'? // 左移  \n      Yes → Step 6: x -= 1 // X 減 1  \n      No  → Decision: 如果 c == 'U'? // 上移  \n       Yes → Step 7: y += 1 // Y 加 1  \n       No  → Decision: 如果 c == 'D'? // 下移  \n        Yes → Step 8: y -= 1 // Y 減 1  \n        No  → Step 9: // 非法字符，忽略或錯誤處理  \n→ Decision: 如果 x == 0 且 y == 0? // 最後位置判斷  \n  Yes → Step 10: 回傳 true // 回到原點  \n  No  → Step 11: 回傳 false // 未回到原點  \nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = y = 0\n        for move in moves:\n            if move == 'U':\n                y += 1\n            elif move == 'D':\n                y -= 1\n            elif move == 'L':\n                x -= 1\n            elif move == 'R':\n                x += 1\n        return x == 0 and y == 0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 預期輸入形如: moves = \"UD\"\n    if '\"' in data:\n        first = data.find('\"')\n        second = data.find('\"', first + 1)\n        moves = data[first + 1:second]\n    else:\n        moves = data\n    result = Solution().judgeCircle(moves)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "moves = \"UD\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "moves = \"LL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode738.json",
    "problem_index_in_file": 0,
    "title": "Monotone Increasing Digits",
    "description_snippet": "An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisf...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for algorithm: given n, find largest number <= n with monotone increasing digits. Classic LeetCode problem 738. Approach: convert to string, iterate from left to right, find first position where digits decrease (i.e., s[i] > s[i+1]), decrement s[i], set all following digits to '9', but also need to handle chain effect: after decrement, maybe s[i] becomes less than previous digit, so need to propagate backwards. Implementation: convert to char array, loop i from 1 to len-1: if s[i-1] > s[i], then decrement s[i-1], set all j from i to len-1 to '9', and then go back while i-1 > 0 and s[i-1] > s[i-2], decrement s[i-1], set rest to '9', etc. Simpler: iterate from right to left, find first index where s[i] < s[i-1], decrement s[i-1] and set all after to '9', and continue moving left if needed. Finally convert back to integer.\n\nWe need to provide pseudocode line-by-line with explanation. Use Start, End, Decision: etc. The algorithm steps:\n\nStart\n→ Convert n to string digits array\n→ Set len = length\n→ i = 1\n→ Decision: If i < len? else End\n   ... Actually need loop while i < len.\nWe can express loop with Decision and branches.\n\nWe should produce pseudocode with arrows. Each line has virtual code then // explanation.\n\nLet's produce:\n\nStart // Program start\n→ Step 1: Convert input integer n to string representation strN // 获得数字的字符数组\n→ Step 2: Convert strN to array digits // 方便逐位操作\n→ Step 3: Let len = length of digits // 记录长度\n→ Step 4: Set i = 1 // 从第二位开始检查\n→ Decision: i < len? // 是否还有后续位需要检查\n    Yes → Decision: digits[i-1] > digits[i]? // 判断前后位是否递减\n        Yes → Step 5: Decrement digits[i-1] by 1 // 把前一位减一\n        → Step 6: Set j = i to len-1, set digits[j] = '9' // 其后位全部变为9\n        → Step 7: While i-1 > 0 and digits[i-1] > digits[i-2]? // 继续向左校正\n            Yes → i = i-1 // 退回上一位\n            → Step 5: Decrement digits[i-1] by 1 // 再次减一\n            → Step 6: Set j = i to len-1, set digits[j] = '9' // 后位全部9\n            → Step 4: Set i = i-1 // 回到循环判断\n            No  → Step 4: Set i = i-1 // 继续外层循环\n        No  → Step 4: Set i = i+1 // 前后位不递减，继续检查下一位\n    No → Step 8: Convert digits array back to integer result // 形成最终数值\n→ End // 程序结束\n\nBut we need line-by-line: each line must have code + comment. Use arrow for steps. We need to maintain indentation for decisions.\n\nBetter to use:\n\nStart // 程式開始執行\n→ Step 1: strN = Convert n to string // 取得 n 的字串表示\n→ Step 2: digits = Array of characters from strN // 方便逐位操作\n→ Step 3: len = length of digits // 取得位數\n→ Step 4: i = 1 // 從第二位開始檢查\n→ Decision: i < len? // 還有後續位需要檢查嗎？\n    Yes → Decision: digits[i-1] > digits[i]? // 前一位是否大於後一位？\n        Yes → Step 5: digits[i-1] = digits[i-1] - 1 // 前一位減一\n        → Step 6: j = i\n        → Decision: j <= len-1? // 後續位是否還有？\n            Yes → digits[j] = '9' // 設為9\n            → j = j + 1\n            No  → Step 7: // 完成後續位設定\n        → Step 8: // 需要向左檢查是否還有不合法？\n        → While i-1 > 0 AND digits[i-1] > digits[i-2]?\n            Yes → i = i-1\n            → Step 5: digits[i-1] = digits[i-1] - 1\n            → Step 6: j = i\n            → Decision: j <= len-1?\n                Yes → digits[j] = '9'\n                → j = j + 1\n                No  → // done\n            → i = i-1\n            No  → // no more correction\n        → i = i-1 // 回到外層循環判斷\n    No → i = i + 1 // 前後位合法，檢查下一位\n    // loop back to decision i < len?\n...\n\nBut maybe simpler: use for loop but still expressed via Decision.\n\nSimplify: Use while loop:\n\n→ Step 9: While i < len? // 迴圈開始\n    Decision: digits[i-1] > digits[i]? // 檢查是否遞減\n        Yes → // reduce and set tail to 9\n        No → i = i + 1\n\nBetter to produce simpler pseudocode:\n\nStart\n→ Step 1: digits = list of n's digits\n→ Step 2: len = length of digits\n→ Step 3: i = 1\n→ Decision: i < len?\n    Yes → Decision: digits[i-1] > digits[i]?\n        Yes →\n            Step 4: digits[i-1] = digits[i-1] - 1\n            Step 5: For j from i to len-1, digits[j] = 9\n            Step 6: While i-1 > 0 and digits[i-1] > digits[i-2]?\n                Yes → i = i-1\n                → Step 4: digits[i-1] = digits[i-1] - 1\n                → Step 5: For j from i to len-1, digits[j] = 9\n                → Step 6: // loop again\n                No → // exit while\n            Step 7: i = i-1\n        No → i = i + 1\n    No → Step 8: result = integer formed by digits\n→ End\n\nNeed to ensure each line is a step, no loops? We can still express loops as Decision with Yes and No, maybe use while.\n\nBut requirement: Use virtual code with arrows and Decision. So we can use a Decision that loops: e.g., Decision: i < len? then within Yes part we handle decrement else increment. At end of Yes part, we go back to decision (like \"→ Decision: i < len?\"). So we can produce an explicit \"→ Decision: i < len? // continue loop\" after actions.\n\nSimilarly for inner while: we can use Decision again.\n\nLet's produce final output: each line is a step. Use arrow for each step. For decisions we include Yes and No branches indented. Each line includes virtual code and comment.\n\nWe need to produce clear step-by-step. Let's craft:\n\nStart // 程式開始執行\n→ Step 1: digits = Convert n to array of digits // 將 n 轉成數字陣列\n→ Step 2: len = length of digits // 取得位數\n→ Step 3: i = 1 // 從第二位開始檢查\n→ Decision: i < len? // 是否還有後續位需要檢查？\n    Yes → Decision: digits[i-1] > digits[i]? // 前一位是否大於後一位？\n        Yes → Step 4: digits[i-1] = digits[i-1] - 1 // 前一位減一\n        → Step 5: j = i\n        → Decision: j <= len-1? // 後續位是否還有？\n            Yes → digits[j] = '9' // 設為9\n            → j = j + 1\n            No  → // 已經處理完所有後續位\n        → Step 6: // 向左檢查是否還需調整\n        → Decision: i-1 > 0 AND digits[i-1] > digits[i-2]? // 仍有遞減？\n            Yes → i = i-1 // 回到上一位\n            → Step 4: digits[i-1] = digits[i-1] - 1\n            → Step 5: j = i\n            → Decision: j <= len-1?\n                Yes → digits[j] = '9'\n                → j = j + 1\n                No  →\n            → Step 6: // 重新檢查是否還需往左\n            → Decision: i-1 > 0 AND digits[i-1] > digits[i-2]? // 仍有遞減？\n                Yes → // 這裡可以重複，為簡化略去迴圈\n                No  → // 結束向左調整\n        No  → // 前後位合法，繼續往右\n        → i = i + 1\n    No → // 沒有更多位需要檢查，完成\n→ Step 7: result = Convert digits back to integer // 形成最終結果\n→ End // 程式執行結束\n\nBut the above includes nested decisions and maybe not fully looped. Need to ensure we show that after each decision we go back to start of loop. But requirement is to produce step-by-step pseudocode; we can summarise loops with Decision.\n\nBut better to produce a more concise pseudocode:\n\nStart\n→ Step 1: digits = list of n's digits\n→ Step 2: len = length of digits\n→ Step 3: i = 1\n→ Decision: i < len?\n    Yes → Decision: digits[i-1] > digits[i]?\n        Yes →\n            Step 4: digits[i-1] = digits[i-1] - 1\n            Step 5: For j from i to len-1, digits[j] = 9\n            Step 6: While i-1 > 0 AND digits[i-1] > digits[i-2]?\n                Yes → i = i-1\n                → Step 4: digits[i-1] = digits[i-1] - 1\n                → Step 5: For j from i to len-1, digits[j] = 9\n                → Step 6: // loop again\n                No  →\n            Step 7: i = i-1\n        No  → i = i + 1\n    No  → Step 8: result = integer from digits\n→ End\n\nThis shows loops but some decisions.\n\nWe need each line: code and comment. Use arrow \"→\" for each step. For decision lines we need indentation and sub-branches.\n\nWe need to show nested decision lines properly with indentation.\n\nLet's produce final answer accordingly. Use indentation spaces for sub-branches. Ensure each line is separated by newline.\n\nWe need to include \"Start\" and \"End\".\n\nLet's output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: digits = List(n) // 把整數 n 轉成數字陣列\n→ Step 2: len = Length(digits) // 取得位數\n→ Step 3: i = 1 // 從第二位開始檢查\n→ Decision: i < len? // 是否還有後續位需要檢查？\n    Yes → Decision: digits[i-1] > digits[i]? // 前一位是否大於後一位？\n        Yes →\n            Step 4: digits[i-1] = digits[i-1] - 1 // 前一位減一\n            Step 5: j = i\n            → Decision: j <= len-1? // 後續位還有嗎？\n                Yes → digits[j] = 9 // 設為9\n                → j = j + 1\n                No  → // 所有後續位已設為9\n            Step 6: // 需要往左檢查是否還有不合法\n            → Decision: i-1 > 0 AND digits[i-1] > digits[i-2]? // 還有遞減？\n                Yes → i = i - 1\n                → Step 4: digits[i-1] = digits[i-1] - 1\n                → Step 5: j = i\n                → Decision: j <= len-1?\n                    Yes → digits[j] = 9\n                    → j = j + 1\n                    No  → // 後續位已設為9\n                → Step 6: // 重新檢查左邊是否還有遞減\n                → Decision: i-1 > 0 AND digits[i-1] > digits[i-2]?\n                    Yes → // 重複同樣步驟（可迴圈化）\n                    No  → // 左邊已合法\n                No  → // 前後位合法，繼續往右\n                → i = i + 1\n        No  → i = i + 1 // 前後位合法，檢查下一位\n    No  → Step 7: result = Integer(digits) // 把陣列轉回整數\n→ End // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef monotone_increasing(n: int) -> int:\n    \"\"\"\n    Return the largest integer <= n whose digits are monotone increasing\n    (each digit <= next digit).\n    \"\"\"\n    digits = list(str(n))\n    i = 1\n    # 找到第一個不遞增的位置\n    while i < len(digits) and digits[i] >= digits[i - 1]:\n        i += 1\n    # 若存在不遞增的部分，做調整\n    if i < len(digits):\n        # 從後往前，將遞減的位置減一，並向左檢查是否還需要調整\n        while i > 0 and digits[i] < digits[i - 1]:\n            digits[i - 1] = str(int(digits[i - 1]) - 1)\n            i -= 1\n        # 把後面所有位設成 9\n        for j in range(i + 1, len(digits)):\n            digits[j] = '9'\n    return int(''.join(digits))\n\ndef main() -> None:\n    \"\"\"\n    讀取 stdin，取得整數 n，計算結果並輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入中抓取第一個整數（可能帶符號）\n    match = re.search(r'(-?\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n    result = monotone_increasing(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "n = 1234",
          "expected_output": "1234",
          "success": true,
          "output": "1234"
        },
        {
          "example_index": 2,
          "input": "n = 332",
          "expected_output": "299",
          "success": true,
          "output": "299"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode729.json",
    "problem_index_in_file": 0,
    "title": "My Calendar I",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code for the described problem. It's typical MyCalendar problem. We need to produce step-by-step virtual code with explanation after each line. Use Start, End, Decision, arrows. Provide each step. Let's design algorithm: Use balanced BST or list of intervals. For simplicity, maintain a sorted list of intervals. In book, check for overlaps: iterate intervals to find insertion point. Complexity O(N). Virtual code should show steps.\n\nWe will produce something like:\n\nStart\n→ Initialize calendar as empty list of intervals // create empty list\n→ Method book(start, end) // function to add event\n    → Decision: 是否有與已存儲事件重疊? // check overlap\n        → Decision: 迭代每個事件 i in calendar\n            → Decision: start < i.end && end > i.start? // overlapping condition\n                Yes → Step: Return false // cannot book\n                No → continue\n        → Step: Insert new interval (start, end) into calendar maintaining order\n        → Step: Return true\nEnd\n\nBut must be \"逐行\" with arrow for each line. Use indentation for decisions.\n\nAlso, use \"→\" for sequential steps, \"Decision:\" for condition. Use \"Yes →\" and \"No →\" under decisions.\n\nLet's craft more detailed pseudocode lines.\n\nStart // Program start\n→ Step 1: Create an empty list called events // store intervals\n\nDefine Method book(start, end) // attempt to add event\n    → Decision: Is events list empty? // quick check\n        Yes → Step 2: Add interval (start, end) to events // no conflict\n        No  → Decision: Does new event overlap any existing?\n            → Step 3: For each event (s, e) in events\n                → Decision: start < e AND end > s ? // check intersection\n                    Yes → Step 4: Return false // overlap found\n                    No  → Step 5: Continue loop // no overlap with this event\n            → Step 6: Insert (start, end) into events at correct position // keep sorted\n            → Step 7: Return true // booking successful\nEnd // Program end\n\nBut need arrow indentation.\n\nWe can express as:\n\nStart // 程式開始執行\n→ Step 1: events ← empty list // 初始化事件列表\n→ Step 2: Define Function book(start, end) // 定義預約方法\n    → Decision: events is empty? // 快速判斷是否已有事件\n        Yes → Step 3: events.add( (start, end) ) // 直接加入\n        No  → Decision: 是否有重疊事件? // 需要檢查所有已存在的事件\n            → Step 4: For each (s, e) in events\n                → Decision: start < e AND end > s? // 交集判斷\n                    Yes → Step 5: Return false // 發現重疊，放棄加入\n                    No  → Step 6: Continue loop // 無重疊，繼續檢查下一個\n            → Step 7: Insert (start, end) into events // 添加新事件\n            → Step 8: Return true // 成功加入\n→ End // 程式結束\n\nBut we need to use \"→\" arrow for sequential steps, \"Decision:\" for decision lines. Also \"Yes →\" and \"No →\" inside decisions.\n\nWe can include indentation with spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: events ← empty list // 初始化空的事件列表  \n→ Step 2: 定義函式 book(start, end) // 開始實作預約方法  \n  → Decision: events 是否為空？ // 先檢查是否已存在任何事件  \n   Yes → Step 3: events.add( (start, end) ) // 空列表直接加入  \n   No  → Decision: 有無與現有事件重疊？ // 需要檢查所有已存在的區間  \n    → Step 4: For each (s, e) in events  \n     → Decision: start < e AND end > s? // 判斷兩區間是否有交集  \n      Yes → Step 5: Return false // 發現重疊，拒絕加入並返回失敗  \n      No  → Step 6: Continue loop // 無重疊，檢查下一個事件  \n    → Step 7: Insert (start, end) into events // 所有檢查完畢後加入新事件  \n    → Step 8: Return true // 成功加入，返回成功  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyCalendar:\n    def __init__(self):\n        self.bookings = []\n\n    def book(self, start, end):\n        for s, e in self.bookings:\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Find the end of the first list (commands)\n    first_end = data.find(']')\n    cmd_str = data[:first_end + 1]\n    rest = data[first_end + 1:].lstrip(',').strip()\n    param_str = rest\n\n    # Replace single quotes with double quotes for JSON parsing\n    commands = json.loads(cmd_str.replace(\"'\", \"\\\"\"))\n    params = json.loads(param_str.replace(\"'\", \"\\\"\"))\n\n    obj = None\n    results = []\n\n    for idx, cmd in enumerate(commands):\n        if cmd == \"MyCalendar\":\n            obj = MyCalendar()\n            results.append(None)  # constructor returns null\n        else:\n            # params list aligns with commands after the first one\n            param = params[idx - 1]\n            if cmd == \"book\":\n                result = obj.book(param[0], param[1])\n                results.append(result)\n            else:\n                # Unsupported method; append None\n                results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpc2mw_0g6.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpc2mw_0g6.py\", line 41, in main\n    result = obj.book(param[0], param[1])\n                      ~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode278.json",
    "problem_index_in_file": 0,
    "title": "First Bad Version",
    "description_snippet": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for binary search to find first bad version. Use Start, Decision, Yes, No. Provide explanation per line. We'll describe algorithm: left=1 right=n while left<right: mid=(left+right)//2 if isBad(mid) then right=mid else left=mid+1. Return left. Use minimal API calls. We'll produce step by step. Use arrow and indentation. Provide comments. Use \"Step 1: 初始化 left, right\". We'll use \"Decision: while left < right?\" then branches. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 1, right = n // 初始化搜尋區間  \n→ Decision: while left < right? // 判斷是否還有區間未搜尋完  \n  Yes → Step 2: mid = (left + right) // 2 // 取中點  \n  → Step 3: 呼叫 isBadVersion(mid) // 檢查中點是否為壞版本  \n  → Decision: isBadVersion(mid) 為 true? // 中點是壞版本嗎？  \n    Yes → Step 4: right = mid // 將搜尋區間縮小到左半部（包含 mid）  \n    No  → Step 5: left = mid + 1 // 中點是好版本，搜尋右半部（不含 mid）  \n  → 回到 Decision: while left < right? // 重新判斷搜尋條件  \n  No → Step 6: return left // left 已經指向第一個壞版本  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# Global variable to store the first bad version\nBAD_VERSION = None\n\ndef isBadVersion(version: int) -> bool:\n    \"\"\"API that tells whether a version is bad.\"\"\"\n    return version >= BAD_VERSION\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        \"\"\"Binary search to find the first bad version.\"\"\"\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    # Read entire input (e.g., \"n = 5, bad = 4\")\n    raw_input = sys.stdin.read()\n    # Extract all integers from the input\n    nums = list(map(int, re.findall(r'\\d+', raw_input)))\n    if len(nums) < 2:\n        raise ValueError(\"Input must contain n and bad version numbers.\")\n    n, bad = nums[0], nums[1]\n    BAD_VERSION = bad\n\n    solution = Solution()\n    result = solution.firstBadVersion(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode81.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array II",
    "description_snippet": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for searching in a rotated sorted array with duplicates, typical problem LeetCode 81. We need to use binary search with handling duplicates.\n\nWe must produce step-by-step virtual code lines. Use Start, End, Decision, Step etc. Provide explanation per line. Need to ensure each line has the format: `虛擬碼步驟 // 解釋/說明`.\n\nWe need to handle array length n. Use left=0, right=n-1. While left <= right: mid = left + (right-left)/2. If nums[mid]==target return true. Else if nums[left]==nums[mid]==nums[right], we increment left++ and right-- to skip duplicates. Else if left part sorted: if nums[left] <= nums[mid], then if target in [nums[left], nums[mid]) then right=mid-1 else left=mid+1. Else right part sorted: if target in (nums[mid], nums[right]] then left=mid+1 else right=mid-1. After loop return false.\n\nLet's produce virtual code lines accordingly. Ensure each line ends with // explanation. Provide arrow lines accordingly.\n\nWe need to incorporate decision arrows.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: left ← 0 // 左指標初始化\n→ Step 3: right ← n - 1 // 右指標初始化\n\n→ Decision: left <= right? // 判斷是否還有搜尋範圍\n    Yes → Step 4: mid ← left + (right - left) / 2 // 計算中間索引\n    → Decision: nums[mid] == target? // 檢查中間是否為目標\n        Yes → End // 找到目標，結束程式\n        No → Decision: nums[left] == nums[mid] AND nums[mid] == nums[right]? // 兩端與中間相等時無法判斷排序\n            Yes → Step 5: left ← left + 1 // 去除左端重複\n            → Step 6: right ← right - 1 // 去除右端重複\n            → Decision: left <= right? // 重新進入主迴圈\n                Yes → (loop back to Decision: left <= right)\n                No  → End // 範圍縮小後無目標，結束\n            No  → Decision: nums[left] <= nums[mid]? // 左半段有序\n                Yes → Decision: nums[left] <= target < nums[mid]? // 目標在左半段\n                    Yes → Step 7: right ← mid - 1 // 搜尋左半段\n                    No  → Step 8: left ← mid + 1 // 搜尋右半段\n                No  → Decision: nums[mid] < target <= nums[right]? // 目標在右半段\n                    Yes → Step 9: left ← mid + 1 // 搜尋右半段\n                    No  → Step 10: right ← mid - 1 // 搜尋左半段\n    No → End // left > right，未找到目標\n\nBut we need proper indentation. Let's produce each line with arrow. Provide decision lines with \"Decision:\" etc.\n\nNeed to ensure each line has a single \"虛擬碼步驟\" and explanation.\n\nWe should maybe avoid nested indentation beyond a few levels. But we can indent with tabs or spaces? The format example uses indentation with spaces. We'll use spaces for readability. Use \"Decision:\" lines indent appropriately.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: left ← 0 // 初始化左指標  \n→ Step 3: right ← n - 1 // 初始化右指標  \n\n→ Decision: left <= right? // 判斷是否仍有搜尋範圍  \n&nbsp;&nbsp;Yes → Step 4: mid ← left + (right - left) / 2 // 計算中間索引  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: nums[mid] == target? // 檢查中間是否為目標  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → End // 找到目標，結束程式  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: nums[left] == nums[mid] AND nums[mid] == nums[right]? // 兩端與中間相等時無法判斷排序  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: left ← left + 1 // 去除左端重複  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: right ← right - 1 // 去除右端重複  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: left <= right? // 重新檢查範圍  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → (loop back to Decision: left <= right)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → End // 範圍縮小後未找到目標  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: nums[left] <= nums[mid]? // 判斷左半段是否有序  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: nums[left] <= target < nums[mid]? // 目標是否在左半段  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: right ← mid - 1 // 搜尋左半段  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 8: left ← mid + 1 // 搜尋右半段  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: nums[mid] < target <= nums[right]? // 目標是否在右半段  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 9: left ← mid + 1 // 搜尋右半段  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 10: right ← mid - 1 // 搜尋左半段  \n&nbsp;&nbsp;No → End // left > right，未找到目標，結束程式",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\ndef parse_input(data):\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*([-\\d]+)', data)\n    nums = ast.literal_eval(nums_match.group(1)) if nums_match else []\n    target = int(target_match.group(1)) if target_match else None\n    return nums, target\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums, target = parse_input(data)\n    result = Solution().search(nums, target)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,5,6,0,0,1,2], target = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [2,5,6,0,0,1,2], target = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode648.json",
    "problem_index_in_file": 0,
    "title": "Replace Words",
    "description_snippet": "In English, we have a concept called root, which can be followed by some other word to form another ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanations, no real code. Steps: read dictionary roots, build trie maybe, split sentence, for each word find minimal prefix root from dictionary that matches the word start. Replace word with root or keep unchanged. Return sentence.\n\nWe'll output lines with virtual code steps using Start, End, Decision. Use arrows. Provide explanation comments.\n\nLet's craft lines:\n\nStart\n→ Step 1: 建立字典映射或前綴樹 // 用於快速查找根\n→ Decision: 如果使用前綴樹? // 根據實作選擇\n    Yes → Step 2: 建立 Trie 以根為節點\n    No → Step 3: 將根集合存入 Set 以供後續搜尋\n→ Step 4: 將句子拆分為單詞列表 // 以空格分割\n→ Step 5: 初始化結果列表 // 用於存放替換後單詞\n→ Step 6: 逐一處理每個單詞\n    → Decision: 詞首是否存在符合的根?\n        Yes → Step 7: 取得所有可匹配的根\n            → Decision: 若多個根\n                Yes → Step 8: 選擇最短長度根\n                No  → Step 9: 直接使用唯一根\n            → Step 10: 將單詞替換為所選根\n        No  → Step 11: 保留原單詞\n    → Step 12: 將處理後單詞加入結果列表\n→ Step 13: 將結果列表拼接回句子 // 用空格連接\n→ End // 回傳處理後句子\n\nNeed to ensure each line includes '虛擬碼步驟' + ' // 解釋'. We'll number steps? Not necessary.\n\nMake sure to include arrows and indentation for decisions. Provide short explanations.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立根字典的搜尋結構 // 方便快速找出以某字串開頭的根  \n→ Decision: 是否使用前綴樹？ // 若字典較大則建議用 Trie  \n  Yes → Step 2: 初始化 Trie，將所有根插入其中  \n  No → Step 3: 將所有根存入 Set，待後續逐字串搜尋  \n→ Step 4: 以空格將輸入句子拆成單詞列表 // 以單詞為單位處理  \n→ Step 5: 初始化空結果列表 // 用於收集處理後的單詞  \n→ Step 6: 針對列表中的每個單詞執行以下流程  \n  → Decision: 詞前是否存在符合的根？ // 檢查是否能被替換  \n    Yes → Step 7: 找出所有可匹配的根（長度 ≤ 詞長）  \n     → Decision: 有多個匹配根？  \n      Yes → Step 8: 選擇字串長度最短的根 // 優先最短根  \n      No → Step 9: 直接採用該唯一根  \n     → Step 10: 用選定的根替換整個單詞  \n    No → Step 11: 仍保持原單詞不變  \n  → Step 12: 把替換後的單詞加入結果列表  \n→ Step 13: 把結果列表以空格連接回為一個句子 // 產生最終輸出  \nEnd // 程式執行結束並回傳處理後句子",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def replaceWords(self, dictionary, sentence):\n        trie = {}\n        END = True  # marker for end of a root\n\n        # 建立 Trie\n        for root in dictionary:\n            node = trie\n            for ch in root:\n                node = node.setdefault(ch, {})\n            node[END] = root\n\n        def replace(word):\n            node = trie\n            for ch in word:\n                if ch not in node:\n                    break\n                node = node[ch]\n                if END in node:\n                    return node[END]\n            return word\n\n        return ' '.join(map(replace, sentence.split()))\n\ndef parse_input(text: str):\n    \"\"\"\n    解析輸入文字，支援兩種格式：\n    1. dictionary = [...], sentence = \"...\"\n    2. 兩行分別為 dictionary 列表與 sentence 字串\n    \"\"\"\n    pattern = r'dictionary\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*sentence\\s*=\\s*\"([^\"]*)\"'\n    m = re.search(pattern, text)\n    if m:\n        dict_str = m.group(1)\n        sentence = m.group(2)\n        dictionary = ast.literal_eval(dict_str)\n        return dictionary, sentence\n    else:\n        lines = [line.strip() for line in text.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            dictionary = ast.literal_eval(lines[0])\n            sentence = lines[1]\n            return dictionary, sentence\n        else:\n            # 如果格式仍不符，直接回傳空值\n            return [], \"\"\n\ndef main():\n    raw_input = sys.stdin.read()\n    dictionary, sentence = parse_input(raw_input)\n    sol = Solution()\n    result = sol.replaceWords(dictionary, sentence)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"",
          "expected_output": "\"the cat was rat by the bat\"",
          "success": true,
          "output": "the cat was rat by the bat"
        },
        {
          "example_index": 1,
          "input": "dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"",
          "expected_output": "\"a a b c\"",
          "success": true,
          "output": "a a b c"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode435.json",
    "problem_index_in_file": 0,
    "title": "Non-overlapping Intervals",
    "description_snippet": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: Given intervals, remove minimal intervals to make non-overlapping. Classic solution: sort by end, greedily keep non-overlap, count removed = n - keep. Steps: Start, Input intervals, Sort by end ascending, Initialize keep=0, prev_end = -inf, For each interval sorted: if interval.start >= prev_end: keep++, prev_end=interval.end; else removed++. Then output removed. Provide each line with explanation.\n\nFollow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows: \"→\". Use Decision. Provide Start End. No actual code. Use Chinese.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 intervals // 取得所有區間的列表  \n→ Decision: intervals 為空? // 判斷是否有區間  \n Yes → Step 2: 輸出 0 // 空列表不需要移除任何區間  \n No  → Step 3: 對 intervals 按 end 升序排序 // 以結束時間為主排序，方便贪心選擇  \n→ Step 4: 設 prev_end 為 -∞，keep 為 0 // 初始化上一個已保留區間的結束位置與保留數量  \n→ Step 5: 對每個區間 current 依序進行  \n  Decision: current.start >= prev_end? // 判斷是否與上一個保留區間不重疊  \n   Yes → Step 6: keep += 1 // 保留此區間  \n     prev_end = current.end // 更新上一個保留區間的結束位置  \n   No  → Step 7: // 不能保留此區間，視為要移除  \n     // 不改變 prev_end，只繼續檢查下一個  \n→ Step 8: 計算 removed = intervals.length - keep // 需要移除的區間數 = 總數量減去保留數量  \n→ Step 9: 輸出 removed // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"\n        Greedy algorithm to find the minimum number of intervals to remove\n        so that the remaining intervals are non‑overlapping.\n        \"\"\"\n        if not intervals:\n            return 0\n\n        # Sort intervals by end time\n        intervals.sort(key=lambda x: x[1])\n        # Keep the first interval\n        end = intervals[0][1]\n        keep = 1\n\n        # Iterate through the rest\n        for start, _ in intervals[1:]:\n            if start >= end:      # no overlap\n                end = _\n                keep += 1\n\n        # Number to remove = total - keep\n        return len(intervals) - keep\n\ndef parse_intervals(raw: str):\n    \"\"\"\n    Parse the input string which can be of the form\n    'intervals = [[1,2],[2,3]]' or just a list literal.\n    \"\"\"\n    raw = raw.strip()\n    if raw.startswith(\"intervals\"):\n        _, expr = raw.split(\"=\", 1)\n        raw = expr.strip()\n    return ast.literal_eval(raw)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    intervals = parse_intervals(data)\n    result = Solution().eraseOverlapIntervals(intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[1,2],[1,2]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode710.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Blacklist",
    "description_snippet": "You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines, each with explanation, not actual code. Use virtual code steps: Start, End, Decision, etc. Provide step by step algorithm: mapping technique using mapping of banned numbers to available ones. We need to handle initialization and pick. We can outline algorithm: count m = n - blacklist.length; create mapping dictionary. For each b in blacklist less than m, map to next available index starting from m upwards that is not in blacklist. pick: generate random r in [0,m-1], if r in map, return map[r] else return r. Provide pseudocode accordingly.\n\nWe should not output actual code, but steps. Need to incorporate algorithmic steps: In init, compute mapping, etc. Use virtual code constructs: Start, Decision, Step. Also use arrow. Provide each line: Virtual code step + comment. Ensure each line starts with \"Start\" or \"→ Step\" etc. Also we need to separate initialization and pick maybe as separate procedures: Solution constructor and pick method.\n\nThus produce steps:\n\nStart of constructor: compute m = n - length(blacklist). etc. Provide mapping logic.\n\nAlso maybe use pseudo code like:\n\n→ Step: Compute m //  ...\n\n→ Step: Initialize empty map\n\n→ Step: Build set of blacklist for quick lookup\n\n→ Step: For each b in blacklist:\n\nDecision: If b < m?\n\nYes → Step: While cur >= n or cur in blacklist: cur++ // find next valid\n\n→ Step: map[b] = cur\n\nNo -> do nothing\n\nAlso after mapping done.\n\nThen pick method:\n\nStart pick\n\n→ Step: Generate random r in [0, m-1]\n\n→ Decision: If r in map?\n\nYes → Step: Return map[r]\n\nNo → Step: Return r\n\nEnd pick\n\nEnd\n\nNow produce final output with each line having virtual code step + comment. Use arrow for lines inside methods. Use \"→\" to indicate next step.\n\nMake sure to maintain structure.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Constructor: Solution(n, blacklist) // 初始化物件，設定範圍與黑名單  \n→ Step: m ← n − length(blacklist) // 可選取的數量 = 總數量 - 黑名單長度  \n→ Step: blacklistSet ← Set(blacklist) // 轉換成集合便於 O(1) 查詢  \n→ Step: mapping ← EmptyMap() // 建立黑名單小於 m 的映射表  \n→ Step: cur ← m // 從 m 開始尋找可用的替代數字  \n→ Step: For each b in blacklist: // 逐一處理黑名單數字  \n  Decision: 如果 b < m? // 只映射小於 m 的數字  \n   Yes → Step: While cur ∈ blacklistSet: cur ← cur + 1 // 跳過所有黑名單數字",
      "generated_code": "import sys\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # 需要挑選的合法數字總數\n        self.size = n - len(blacklist)\n        # 將黑名單轉成集合，方便 O(1) 查詢\n        black_set = set(blacklist)\n        # 用來搜尋可用的映射目標\n        last = n - 1\n        # 將小於 size 的黑名單數字映射到合法範圍之外的空位\n        self.mapping = {}\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # 在合法範圍 [0, size-1] 隨機挑選一個索引\n        idx = random.randint(0, self.size - 1)\n        # 若該索引在映射表中，則回傳映射目標；否則回傳本身\n        return self.mapping.get(idx, idx)\n\ndef main():\n    # 讀取兩行輸入：操作名稱列表和對應參數列表\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = eval(data[0])\n    args = eval(data[1])\n\n    result = []\n    sol = None\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            # 建構子，參數本身是一個列表\n            sol = Solution(*args[i])\n            result.append(None)  # 建構子回傳值為 null\n        else:\n            # 其它方法，直接呼叫\n            method = getattr(sol, op)\n            res = method(*args[i])\n            result.append(res)\n\n    # 輸出結果，None 會被轉成 JSON 的 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,6,1,1,0,4,1]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 6, 1, 1, 0, 4, 1]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode677.json",
    "problem_index_in_file": 0,
    "title": "Map Sum Pairs",
    "description_snippet": "Design a map that allows you to do the following:\n\nMaps a string key to a given value.\nReturns the s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. The user wants a MapSum class that can insert key-value pairs and sum prefixes. The typical solution is a Trie with stored sums. Provide pseudocode. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc.\n\nWe need to produce code for class MapSum with methods, use data structures: TrieNode with children map and sum value. Also maintain a map of key to value for overriding.\n\nLet's outline pseudocode:\n\nStart\nDefine class MapSum\n→ Define inner class TrieNode\n    → children: map char to TrieNode\n    → sum: int // cumulative sum of values of all keys passing through this node\n→ Declare root: TrieNode\n→ Declare dict: map string to int // store current key values\n\n→ Constructor MapSum()\n    → root ← new TrieNode()\n    → dict ← new map\n\n→ Method insert(key, val)\n    → oldVal ← dict.get(key, 0)\n    → delta ← val - oldVal\n    → dict[key] ← val\n    → node ← root\n    → node.sum ← node.sum + delta\n    → For each ch in key\n        → If node.children[ch] not exists, create new TrieNode\n        → node ← node.children[ch]\n        → node.sum ← node.sum + delta\n    → End for\n\n→ Method sum(prefix)\n    → node ← root\n    → For each ch in prefix\n        → If node.children[ch] not exists, return 0\n        → node ← node.children[ch]\n    → End for\n    → Return node.sum\n\nEnd // end of class\n\nWe need to output each line with explanation. Use \"→\" for steps. Use Decision if necessary but not needed heavily. Ensure format: \"虛擬碼步驟 // 解釋\". Let's produce.\n\nWe also need to include class and methods lines.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class MapSum // 定義 MapSum 類別  \n    → Define inner class TrieNode // 內部 Trie 節點結構  \n        → children ← map<char, TrieNode>() // 儲存子節點  \n        → sum ← 0 // 透過此節點的總值  \n    → root ← new TrieNode() // 建立根節點  \n    → dict ← map<string, int>() // 儲存鍵到其最新值的映射  \n\n→ Constructor MapSum() // 初始化函式  \n    → // root 與 dict 已於類別層級初始化  \n\n→ Method insert(key, val) // 插入或更新鍵值對  \n    → oldVal ← dict.get(key, 0) // 取得舊值，若不存在則為 0  \n    → delta ← val - oldVal // 計算值變化量  \n    → dict[key] ← val // 更新鍵對應的新值  \n\n    → node ← root // 從根節點開始  \n    → node.sum ← node.sum + delta // 更新根節點的總和  \n\n    → For each ch in key // 遍歷鍵的每個字符  \n        → If node.children[ch] not exists // 若子節點不存在  \n            → node.children[ch] ← new TrieNode() // 創建新節點  \n        → node ← node.children[ch] // 移動到子節點  \n        → node.sum ← node.sum + delta // 更新此節點的總和  \n    → End for  \n\n→ Method sum(prefix) // 取得前綴總和  \n    → node ← root // 從根節點開始  \n    → For each ch in prefix // 遍歷前綴的每個字符  \n        → If node.children[ch] not exists // 若不存在此路徑  \n            → Return 0 // 無匹配鍵，總和為 0  \n        → node ← node.children[ch] // 移動到子節點  \n    → End for  \n    → Return node.sum // 回傳前綴所對應節點的總和  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MapSum:\n    def __init__(self):\n        self.root = {}            # root node of the trie\n        self.val_map = {}         # map of key to its current value\n\n    def insert(self, key: str, val: int) -> None:\n        \"\"\"Insert or update a key with the given value.\"\"\"\n        old_val = self.val_map.get(key, 0)\n        diff = val - old_val          # change to propagate through the trie\n        self.val_map[key] = val\n\n        node = self.root\n        node.setdefault('_sum', 0)\n        node['_sum'] += diff          # update sum at root\n\n        for ch in key:                # walk through each character\n            node = node.setdefault(ch, {})\n            node.setdefault('_sum', 0)\n            node['_sum'] += diff      # update sum at this node\n\n    def sum(self, prefix: str) -> int:\n        \"\"\"Return the sum of all values of keys that start with the given prefix.\"\"\"\n        node = self.root\n        for ch in prefix:\n            if ch not in node:\n                return 0\n            node = node[ch]\n        return node.get('_sum', 0)\n\ndef main() -> None:\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Wrap the two lists into a tuple for safe literal evaluation\n    data = '(' + data + ')'\n    ops, args_list = ast.literal_eval(data)\n\n    ms = MapSum()\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"insert\":\n            key, val = args[0], int(args[1])\n            ms.insert(key, val)\n            results.append(None)          # insert returns null\n        elif op == \"sum\":\n            prefix = args[0]\n            results.append(ms.sum(prefix))\n        else:\n            # Unsupported operation, ignore\n            results.append(None)\n\n    # Output results in JSON format (None -> null)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "success": true,
          "output": "[null, null, 3, null, 5]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode137.json",
    "problem_index_in_file": 0,
    "title": "Single Number II",
    "description_snippet": "Given an integer array nums where every element appears three times except for one, which appears ex...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve problem: find element that appears once while all others appear three times. Approach: bitwise counting. Use two integers ones, twos. For each num: twos = twos | (ones & num); ones = ones ^ num; common_bit_mask = ~(ones & twos); ones &= common_bit_mask; twos &= common_bit_mask. Return ones. Complexity O(n). Memory O(1).\n\nWe must output virtual code line by line with explanation. Use arrow syntax: Start, Decision, etc. Let's produce lines:\n\nStart\n→ Step 1: 初始化 ones = 0 // 记录出现次数为 1 的位\n→ Step 2: 初始化 twos = 0 // 记录出现次数为 2 的位\n→ Step 3: 对每个 num in nums 循环 // 遍历数组\n   → Step 4: 更新 twos: twos = twos | (ones & num) // 将同时在 ones 和 num 的位标记为出现两次\n   → Step 5: 更新 ones: ones = ones ^ num // 将 num 的位在 ones 中取反\n   → Step 6: 计算 mask = ~(ones & twos) // 找到已经出现三次的位\n   → Step 7: 清除这些位: ones = ones & mask // 清除 ones 中已出现三次的位\n   → Step 8: 清除这些位: twos = twos & mask // 清除 twos 中已出现三次的位\n→ Step 9: 返回 ones // ones 中保留的就是出现一次的数\nEnd\n\nWe need to use arrow notation and Decision? Not necessary. Maybe include Start and End. We need to produce virtual code line by line. Provide explanation after //.\n\nWe can also include decision if needed but not required. Let's output as described.\n\nEnsure each line uses '→' or 'Decision:'. No extra spaces except required. Provide explanation each line. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 ones = 0 // 记录出现一次的位  \n→ Step 2: 初始化 twos = 0 // 记录出现两次的位  \n→ Step 3: 对 nums 中的每个 num 循环 // 遍历数组  \n   → Step 4: twos = twos | (ones & num) // 将同时在 ones 与 num 中的位标记为出现两次  \n   → Step 5: ones = ones ^ num // 对当前 num 的位与 ones 做异或，更新一次出现的位  \n   → Step 6: mask = ~(ones & twos) // 找出已经出现三次的位的补码掩码  \n   → Step 7: ones = ones & mask // 清除 ones 中已出现三次的位  \n   → Step 8: twos = twos & mask // 清除 twos 中已出现三次的位  \n→ Step 9: 返回 ones // ones 中剩下的位即为唯一出现一次的数  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def singleNumber(self, nums):\n        # 使用兩個整數來記錄位出現一次和兩次的情況\n        ones, twos = 0, 0\n        for num in nums:\n            # 更新 ones：將 num 的位與現在的 ones 做 XOR，並去掉已經出現兩次的位\n            ones = (ones ^ num) & ~twos\n            # 更新 twos：將 num 的位與現在的 twos 做 XOR，並去掉已經出現一次的位\n            twos = (twos ^ num) & ~ones\n        return ones\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 從輸入中擷取所有整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    result = Solution().singleNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "success": true,
          "output": "99"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode478.json",
    "problem_index_in_file": 0,
    "title": "Generate Random Point in a Circle",
    "description_snippet": "Given the radius and the position of the center of a circle, implement the function randPoint which ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. The algorithm: generate uniform random point in circle. We can use method: generate random radius r = sqrt(rand()) * radius, random angle theta uniform [0, 2π). Then x = x_center + r cosθ, y = y_center + r sinθ. Return [x, y].\n\nWe need to include class Solution, constructor, method randPoint. Use virtual code, arrow, decisions. No real code.\n\nWe'll produce steps: Start, Step: initialize radius, center. Step: generate random number between 0 and 1 for u. Step: compute r = sqrt(u) * radius. Step: generate random angle between 0 and 2π: v = rand() etc. Step: compute x = x_center + r * cos(theta). Step: compute y = y_center + r * sin(theta). Step: return [x, y]. End.\n\nWe might include Decision: None.\n\nWe need to use the arrow syntax: Start, → Step etc.\n\nWe must not output actual code, just virtual steps.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 Solution(radius, x_center, y_center) // 儲存圓半徑與圓心座標  \n→ Step 2: 呼叫 randPoint() // 需要產生一個隨機點  \n→ Step 3: 產生 uniform 亂數 u ∈ [0, 1) // 用於決定距離半徑  \n→ Decision: 若 u 為負? // 這裡只為示範安全檢查  \n  Yes → Step 4: 將 u 設為 0 // 防止負值  \n  No  → Step 4: 直接使用 u  \n→ Step 5: 計算隨機半徑 r = sqrt(u) * radius // 使點均勻分佈於圓內  \n→ Step 6: 產生 uniform 亂數 v ∈ [0, 2π) // 用於決定角度  \n→ Step 7: 計算角度 θ = v // 直接使用 v 作為 θ  \n→ Step 8: 計算 x = x_center + r * cos(θ) // 將極座標轉為直角座標  \n→ Step 9: 計算 y = y_center + r * sin(θ) // 同上  \n→ Step 10: 回傳點 [x, y] // 形成所需的結果陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 使用極座標生成均勻分布點\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit(0)\n    # 第一行：操作名稱列表，第二行：對應的參數列表\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)          # constructor returns null\n        else:\n            method = getattr(obj, op)\n            res = method(*arg)\n            results.append(res)\n    # 輸出為 JSON，Python 的 None 會自動轉成 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.6082024665250262,0.7795307778407599],[-0.1944342436209476,0.493750960475461],[0.11936215674323206,-0.7604018976811475]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.6082024665250262, 0.7795307778407599], [-0.1944342436209476, 0.493750960475461], [0.11936215674323206, -0.7604018976811475]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode77.json",
    "problem_index_in_file": 0,
    "title": "Combinations",
    "description_snippet": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for generating all k-combinations from 1..n. Use recursion/backtracking. Provide line-by-line steps with comments. No actual code. Use arrow syntax. Should include Start, End, Decision, etc.\n\nNeed to output virtual code steps with explanation. Provide step labels. Use recursion function generate(start, combo). We'll have a global result list.\n\nWe need to produce steps like:\n\nStart\n→ Step: Initialize result list\n→ Step: Call backtrack(1, [])\n→ Decision: if combo length == k?\n   Yes → Step: Append copy of combo to result\n   No → For i from start to n:\n          → Step: Add i to combo\n          → Step: Call backtrack(i+1, combo)\n          → Step: Remove last element from combo\nEnd\n\nBut each line must contain \"虛擬碼步驟\" + space + \"// 解釋\". Should be in Chinese. Use \"Start // 程式開始執行\". Also arrow arrow symbol. Let's craft.\n\nMake sure each line ends with comment. Use arrow arrow. Use indentation maybe? We can indent inside decisions.\n\nWe need to produce a sequential listing. For decisions we might show sub-lines with indentation.\n\nWe can present each line sequentially. For nested steps, we can indent by spaces maybe. The example uses indentation with 4 spaces.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step: 初始化結果列表 result = [] // 用於存放所有組合\n→ Step: 定義遞迴函式 backtrack(start, combo) // backtrack 用於產生組合\n→   → Decision: 若 combo 长度 == k? // 判斷是否已完成一組組合\n→     Yes → Step: 將 combo 複製並加入 result // 成功組合加入結果\n→     No  → Step: 循環 i 從 start 到 n // 嘗試將每個未選的數字加入\n→         → Step: combo.append(i) // 選取 i\n→         → Step: backtrack(i+1, combo) // 深入遞迴\n→         → Step: combo.pop() // 回溯，移除 i\n→ Step: 呼叫 backtrack(1, []) // 開始遞迴，從 1 開始\n→ Step: 返回 result // 回傳所有組合\nEnd // 程式執行結束\n\nBut the requirement: \"每行必須包含：虛擬碼步驟 + 空格 + // 解釋/說明\". Should each line have arrow? The example uses \"→ Step 1:\" etc. So we can mimic that. We can have Step 1: define result. Step 2: define backtrack. Step 3: call backtrack. etc.\n\nLet's create numbered steps:\n\nStart // 程式開始執行\n→ Step 1: 定義空列表 result = [] // 存放所有組合\n→ Step 2: 定義遞迴函式 backtrack(start, combo) // 用於產生組合\n→   Decision: 如果 combo 长度 == k? // 判斷是否已組成 k 個數\n→     Yes → Step 3: result.append(combo.copy()) // 將完成的組合加入結果\n→     No  → Step 4: 循環 i 從 start 到 n // 逐一嘗試加入下一個數\n→         → Step 5: combo.append(i) // 加入 i\n→         → Step 6: backtrack(i+1, combo) // 進一步遞迴\n→         → Step 7: combo.pop() // 回溯，移除 i\n→ Step 8: backtrack(1, []) // 從 1 開始遞迴\n→ Step 9: 返回 result // 回傳所有組合\nEnd // 程式結束\n\nWe must ensure each line ends with comment.\n\nCheck each line: Start // 程式開始執行\n→ Step 1: ... // comment\n→ Step 2: ... // comment\n→   Decision: ... // comment\n-> Yes → Step 3: ... // comment\n-> No  → Step 4: ... // comment\nThen Step 5 etc. Should we indent? We can indent lines under Decision with spaces.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義空列表 result = [] // 用於儲存所有生成的組合\n→ Step 2: 定義遞迴函式 backtrack(start, combo) // backtrack 將從 start 開始遞迴產生組合\n→   Decision: 如果 combo 長度等於 k? // 檢查是否已完成一個 k 元組合\n→     Yes → Step 3: result.append(combo.copy()) // 把完整組合加入結果列表\n→     No  → Step 4: 循環 i 從 start 到 n // 逐個嘗試將未選的數字加入\n→         → Step 5: combo.append(i) // 選取 i 並加入目前組合\n→         → Step 6: backtrack(i + 1, combo) // 進一步遞迴以生成更長的組合\n→         → Step 7: combo.pop() // 回溯：移除剛剛加入的 i，恢復原狀\n→ Step 8: backtrack(1, []) // 從 1 開始，啟動遞迴搜尋\n→ Step 9: 返回 result // 回傳所有生成的 k 元組合\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\ndef combine(n: int, k: int):\n    \"\"\"生成從 1~n 中選取 k 個數字的所有組合。\"\"\"\n    res = []\n\n    def backtrack(start: int, path: list):\n        # 若已選到 k 個數字，則加入結果\n        if len(path) == k:\n            res.append(path[:])\n            return\n        # 從 start 開始嘗試每個剩餘數字\n        for i in range(start, n + 1):\n            path.append(i)          # 選取 i\n            backtrack(i + 1, path)  # 進一步遞迴\n            path.pop()              # 回溯，移除 i\n\n    backtrack(1, [])                # 從 1 開始遞迴\n    return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有內容\n    data = sys.stdin.read()\n    # 把所有整數找出來，假設輸入形式類似 \"n = 4, k = 2\"\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    # 取前兩個整數作為 n 和 k\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n    else:\n        n, k = 0, 0\n\n    # 計算所有組合\n    result = combine(n, k)\n    # 以無空格的 JSON 格式輸出\n    print(json.dumps(result, separators=(',', ':')))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4, k = 2",
          "expected_output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
          "success": true,
          "output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode365.json",
    "problem_index_in_file": 0,
    "title": "Water and Jug Problem",
    "description_snippet": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Ret...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a virtual code algorithm step-by-step. The problem: two jugs capacities x,y, infinite water supply, can fill, empty, pour. Determine if target can be reached. Classic solution: use gcd. Condition: target <= x + y and target % gcd(x,y) == 0. So algorithm: compute gcd of x,y, check conditions. Steps: Start, get x,y,target, compute gcd via Euclidean algorithm, check conditions, output result. The code should be virtual code: use arrows, Decision, etc.\n\nWe must produce each line with virtual code step followed by comment. No real code. Use structure Start, →, Decision: etc. Provide simple steps.\n\nLet's design:\n\nStart // start\n\n→ Step 1: Input x, y, target // read capacities and target\n\n→ Decision: If target > x + y? // cannot exceed total capacity\n\n   Yes → Step 2: Return False // impossible\n\n   No → (continue)\n\n→ Step 3: Compute gcd of x and y // using Euclidean algorithm\n\n   -> we might break into steps: Step 3.1: Set a = x, b = y\n\n   -> Decision: While b != 0? // Euclidean loop\n\n        Yes → Step 3.2: Set temp = a mod b\n\n        Step 3.3: Set a = b\n\n        Step 3.4: Set b = temp\n\n        No → (exit loop)\n\n   -> Step 3.5: Set gcd = a\n\n→ Decision: If target % gcd == 0? // divisibility check\n\n    Yes → Step 4: Return True\n\n    No → Step 4: Return False\n\nEnd // finish\n\nAdd comments. Use arrows appropriately. Ensure each line has // comment. Let's produce. Use correct formatting. Ensure each step line. Let's do.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input x, y, target // 讀取兩個水桶容量與目標量\n→ Decision: target > x + y? // 檢查目標是否超過兩桶總容量\n    Yes → Step 2: Return False // 若超過，無法達成，直接結束\n    No  → // 目標在可達範圍內，繼續\n→ Step 3.1: Set a = x, b = y // 初始化歐幾里得算法的變數\n→ Decision: b ≠ 0? // 判斷是否需要繼續計算 GCD\n    Yes → Step 3.2: Set temp = a mod b // 取得餘數\n    → Step 3.3: Set a = b // 更新 a 為 b\n    → Step 3.4: Set b = temp // 更新 b 為先前的餘數\n    No  → // b 為 0，退出循環\n→ Step 3.5: Set gcd = a // a 現為兩數的 GCD\n→ Decision: target mod gcd == 0? // 判斷目標是否為 GCD 的倍數\n    Yes → Step 4: Return True // 可達成目標\n    No  → Step 4: Return False // 無法達成目標\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canMeasureWater(self, x: int, y: int, target: int) -> bool:\n        # 計算兩個數的最大公因數\n        def gcd(a: int, b: int) -> int:\n            while b != 0:\n                a, b = b, a % b\n            return a\n\n        # 若目標量超過兩桶總容量，無法達成\n        if target > x + y:\n            return False\n        # 目標量必須是最大公因數的倍數\n        return target % gcd(x, y) == 0\n\ndef main():\n    # 讀取整個輸入，並提取所有整數\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 3:\n        # 若輸入格式不符，直接結束\n        return\n    x, y, target = nums\n    solution = Solution()\n    result = solution.canMeasureWater(x, y, target)\n    # 輸出小寫字串，符合範例要求\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 3, y = 5, target = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = 2, y = 6, target = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 1, y = 2, target = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode689.json",
    "problem_index_in_file": 0,
    "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
    "description_snippet": "Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a pseudo-code for the problem: given array nums, integer k, find 3 non-overlapping subarrays of length k with maximum total sum, return starting indices lexicographically smallest.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use arrow and Decision, Start, End. Provide step-by-step. We can produce a DP approach: precompute sum of windows of length k. Use dynamic programming to store best left indices for two subarrays and then compute best third.\n\nWe will provide pseudo-code lines accordingly. Each line maybe multi-step: but we must produce per line.\n\nOk let's craft steps.\n\nStart\n→ Compute prefix sums for nums // to get window sums in O(1)\n→ Build array sum[0..n-k] where sum[i] = sum of nums[i:i+k] // each window sum\n→ Initialize array left[0..n-k] to store best index up to i for single subarray // best left index\n→ For i=0 to n-k:\n    if sum[i] > sum[left[i-1]]: left[i] = i\n    else left[i] = left[i-1] // lexicographically smallest if equal\n// left[i] gives index of max sum subarray within [0,i]\n→ Initialize array left2[0..n-k] to store best pair indices up to i (first and second) // store first index of pair\n→ For i=0 to n-k:\n    // consider second subarray starting at i\n    // first subarray must end before i (i-k)\n    if i >= k:\n        prev = left[i-k] // best first subarray before i\n        pairSum = sum[prev] + sum[i]\n        // Compare with previous best pair sum\n        // Need to keep track of best pair sum up to i\n        // Use array pairSumVal[0..n-k] to store sum value\n        // and pairFirstIdx[0..n-k] to store first index\n        // Actually we can compute pairBestVal and pairFirstIdx arrays\n        // Let's define pairBestVal[i] = max pair sum up to i\n        // pairFirstIdx[i] = first index of that pair\n        // For i<k, set pairBestVal[i]= -inf\n        // For i>=k:\n        // candidate sum = sum[prev] + sum[i]\n        // compare with pairBestVal[i-1]\n        // if candidate > pairBestVal[i-1] or equal and prev < pairFirstIdx[i-1] then update\n    // else skip\n    // set pairBestVal[i] and pairFirstIdx[i] accordingly\n→ After left2 ready, compute answer\n→ Initialize bestTotal = -inf, ans = []\n→ For i=2*k to n-k: // i is start index of third subarray\n    // third subarray starts at i\n    // second subarray must start <= i-k\n    // pair index from pairFirstIdx[i-k] gives first and second starts\n    // total = sum[pairFirstIdx[i-k]] + sum[secondIdx] + sum[i]\n    // secondIdx = ??? we need to store second index for pair. We can store pairSecondIdx[i] too\n    // Let's store pairSecondIdx[i] = start index of second subarray for best pair up to i\n    // Then compute total\n    // If total > bestTotal or equal and lexicographically smaller ans then update\n→ End\n\nBut to keep simple, we can store pairInfo: best pair up to i has first start f, second start s, sum v.\n\nImplement accordingly.\n\nWe'll produce pseudo-code lines with decision etc.\n\nLet's craft final lines. Use \"Decision:\" for branches.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Compute prefixSum[0..n] where prefixSum[0]=0, prefixSum[i+1]=prefixSum[i]+nums[i] // 建立前綴和以便快速取得任何長度 k 的區段和  \n→ 建立 sum[0..n-k]  \n    → For i=0 to n-k:  \n        sum[i] = prefixSum[i+k] - prefixSum[i] // sum[i] 為以 i 為起點、長度 k 的子陣列和  \n→ Decision: 是否需要處理 n < 3*k?  \n    Yes → End // 如果整個陣列長度不足三個子陣列長度，無法找出答案  \n    No  →  \n→ 建立 leftBest[0..n-k] 用以儲存到 i 為止的最大單個子陣列的起點  \n    → For i=0 to n-k:  \n        → Decision: i==0?  \n            Yes → leftBest[i] = 0 // 第一個子陣列起點為 0  \n            No  →  \n                → Decision: sum[i] > sum[leftBest[i-1]]?  \n                    Yes → leftBest[i] = i // 新子陣列和更大  \n                    No  →  \n                        → Decision: sum[i] == sum[leftBest[i-1]]?  \n                            Yes → leftBest[i] = leftBest[i-1] // 和相等，保持最小起點  \n                            No  → leftBest[i] = leftBest[i-1] // 舊的更大  \n→ 建立 pairBestVal[0..n-k], pairFirst[0..n-k], pairSecond[0..n-k]  \n    → For i=0 to n-k:  \n        → Decision: i < k?  \n            Yes → pairBestVal[i] = -∞ // 無法形成兩個子陣列  \n            No  →  \n                → prev = leftBest[i-k] // 第一個子陣列必須結束於 i-k-1  \n                → candidateVal = sum[prev] + sum[i] // 第二個子陣列以 i 為起點  \n                → Decision: candidateVal > pairBestVal[i-1]?  \n                    Yes → pairBestVal[i] = candidateVal  \n                        pairFirst[i] = prev  \n                        pairSecond[i] = i  \n                    No  →  \n                        → Decision: candidateVal == pairBestVal[i-1]?  \n                            Yes → → Decision: prev < pairFirst[i-1]?  \n                                Yes → pairBestVal[i] = candidateVal  \n                                    pairFirst[i] = prev  \n                                    pairSecond[i] = i // 選擇 lexicographically 更小的第一個起點  \n                                No  → pairBestVal[i] = pairBestVal[i-1]  \n                                    pairFirst[i] = pairFirst[i-1]  \n                                    pairSecond[i] = pairSecond[i-1]  \n                            No  → pairBestVal[i] = pairBestVal[i-1]  \n                                pairFirst[i] = pairFirst[i-1]  \n                                pairSecond[i] = pairSecond[i-1]  \n→ 建立 answer[3]，bestTotal = -∞  \n→ For i=2*k to n-k: // i 為第三個子陣列的起點  \n    → firstIdx = pairFirst[i-k] // 最佳第一、第二子陣列的第一個起點  \n    → secondIdx = pairSecond[i-k] // 第二個子陣列的起點  \n    → currentTotal = sum[firstIdx] + sum[secondIdx] + sum[i] // 三個子陣列的總和  \n    → Decision: currentTotal > bestTotal?  \n        Yes → bestTotal = currentTotal  \n            answer = [firstIdx, secondIdx, i] // 更新答案  \n        No  → → Decision: currentTotal == bestTotal?  \n            Yes → → Decision: [firstIdx, secondIdx, i] lexicographically < answer?  \n                Yes → answer = [firstIdx, secondIdx, i] // 同樣總和，選取字典序最小的  \n            No → // do nothing  \n→ End // 程式執行結束，answer 為三個子陣列起點的列表",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums, k):\n        n = len(nums)\n        if n < 3 * k:\n            return []\n\n        # Step 1: Compute sums of all windows of length k\n        w_len = n - k + 1\n        w = [0] * w_len\n        s = sum(nums[:k])\n        w[0] = s\n        for i in range(1, w_len):\n            s += nums[i + k - 1] - nums[i - 1]\n            w[i] = s\n\n        # Step 2: For each position i, store best left index (max sum up to i)\n        left = [0] * w_len\n        best = 0\n        for i in range(w_len):\n            if w[i] > w[best]:\n                best = i\n            left[i] = best\n\n        # Step 3: For each position i, store best right index (max sum from i to end)\n        right = [0] * w_len\n        best = w_len - 1\n        for i in range(w_len - 1, -1, -1):\n            if w[i] >= w[best]:\n                best = i\n            right[i] = best\n\n        # Step 4: Iterate over middle subarray start index j\n        best_total = -1\n        answer = []\n        for j in range(k, w_len - k):\n            i = left[j - k]\n            l = right[j + k]\n            total = w[i] + w[j] + w[l]\n            if total > best_total:\n                best_total = total\n                answer = [i, j, l]\n\n        return answer\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses input like: 'nums = [1,2,1,2,6,7,5,1], k = 2'\n    or similar formats and returns (nums, k).\n    \"\"\"\n    # Try direct split by 'k ='\n    if 'k =' in data:\n        nums_part, k_part = data.split('k =', 1)\n        nums_str = nums_part.split('=', 1)[1].strip()\n        k_str = k_part.strip()\n        nums = ast.literal_eval(nums_str)\n        k = int(k_str)\n        return nums, k\n\n    # Fallback: regex search for list and integer\n    nums_match = re.search(r'\\[.*?\\]', data)\n    nums = ast.literal_eval(nums_match.group())\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if not k_match:\n        # maybe just integer after comma\n        k_match = re.search(r',\\s*(\\d+)', data)\n    k = int(k_match.group(1))\n    return nums, k\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    nums, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.maxSumOfThreeSubarrays(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,2,6,7,5,1], k = 2",
          "expected_output": "[0,3,5]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,3,5]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,3,5]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,2,1,2,1,2,1], k = 2",
          "expected_output": "[0,2,4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,4]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,2,4]'\nRaw Got:      '[]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode680.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome II",
    "description_snippet": "Given a string s, return true if the s can be palindrome after deleting at most one character from i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, line by line, with explanation, following format. The requirement: \"Given a string s, return true if the s can be palindrome after deleting at most one character from it.\" So we produce a virtual code algorithm.\n\nWe'll output:\n\nStart // start\n→ Step 1: 初始化左右指標 left=0, right=len(s)-1 // pointers\n→ Decision: 左右指標相遇或交叉? // if done\n    Yes → Step 2: 返回 True // palindrome\n    No  → Step 3: 如果 s[left]==s[right]? // check match\n        Yes → 左右指標同時向內移動\n        No  → Decision: 是否已經刪除過字符? // flag\n            Yes → Step 4: 返回 False // already deleted once\n            No  → Decision: 嘗試刪除左字符? // Check sub-palindrome\n                Yes → If s[left+1..right] 是 palindrome? -> True\n                No  → Decision: 嘗試刪除右字符?\n                    Yes → If s[left..right-1] 是 palindrome? -> True\n                    No → 返回 False\n\nWe need to use arrow syntax. Use \"Decision:\" lines, \"Yes →\", \"No →\".\n\nAlso we need to include function to check palindrome of substring. But we can implement within. We'll include sub-step to check palindrome via function call.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定左指標 left = 0, 右指標 right = s.length - 1 // 初始指向字符串兩端\n→ Decision: left >= right? // 檢查是否已遍歷完所有字符\n    Yes → Step 2: return true // 已經是回文，直接回傳\n    No  → Step 3: 如果 s[left] == s[right]? // 前後字符是否相同\n        Yes → 左右指標同時移動 (left++ ; right--) // 匹配，繼續往內部檢查\n        No  → Decision: 是否已刪除過一次字符? // 標誌 deleted 變數\n            Yes → Step 4: return false // 已經刪過一次，無法再刪，返回失敗\n            No  → Decision: 是否可以通過刪除左側字符形成回文? // 嘗試左刪\n                Yes → If isPalindrome(s, left+1, right) return true // 子串是回文，成功\n                No  → Decision: 是否可以通過刪除右側字符形成回文? // 嘗試右刪\n                    Yes → If isPalindrome(s, left, right-1) return true // 子串是回文，成功\n                    No → Step 5: return false // 兩種刪除皆失敗，返回失敗\n→ Function isPalindrome(s, i, j) // 檢查子串 s[i..j] 是否為回文\n    → Step 6: While i < j\n        → Decision: s[i] == s[j]? // 檢查對稱字符\n            Yes → i++ ; j-- // 移動到下一對\n            No → return false // 不相等即非回文\n    → Step 7: return true // 完全相等，為回文\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        \"\"\"\n        判斷給定字串是否能在刪除至多一次字符後成為回文。\n        \"\"\"\n        # 檢查子串 s[i:j+1] 是否為回文\n        def is_palindrome_range(i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] != s[j]:\n                # 兩種可能：刪除左邊或右邊的字符\n                return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1)\n            i += 1\n            j -= 1\n        return True\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，格式可能是\n    # s = \"aba\" 或直接給字串\n    raw_input = sys.stdin.read().strip()\n\n    # 解析輸入字串\n    if raw_input.startswith(\"s =\"):\n        # 取得等號右側的內容\n        part = raw_input.split(\"=\", 1)[1].strip()\n        # 去除可能的雙引號\n        if part.startswith('\"') and part.endswith('\"'):\n            s = part[1:-1]\n        else:\n            s = part\n    else:\n        # 直接使用整行資料，去除雙引號\n        s = raw_input.strip('\"')\n\n    # 產生答案並輸出\n    solution = Solution()\n    result = solution.validPalindrome(s)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aba\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"abca\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"abc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode730.json",
    "problem_index_in_file": 0,
    "title": "Count Different Palindromic Subsequences",
    "description_snippet": "Given a string s, return the number of different non-empty palindromic subsequences in s. Since the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm: count distinct palindromic subsequences. Standard DP with 4D or 2D and handling duplicates. Approach: dp[l][r] = number of distinct palindromic subsequences in s[l..r]. Recurrence: if s[l]==s[r], then dp[l][r] = dp[l+1][r] + dp[l][r-1] + 1; else dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]. But need to handle duplicates when same char appears inside. The known solution: maintain next and prev arrays, and adjust with -dp[l+1][r-1] when duplicates.\n\nBetter: For each l,r with s[l]==s[r], find next[l] and prev[r] positions of same char. If next[l] > r-1 => no duplicate inside => dp[l][r] = dp[l+1][r] + dp[l][r-1] + 1. Else if next[l]==prev[r] => exactly one duplicate inside => dp[l][r] = dp[l+1][r] + dp[l][r-1] + 1. Else => at least two duplicates inside => dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]. Actually known recurrence: \nif s[l]==s[r]:\n  if next[l]==prev[r]:\n     dp[l][r] = dp[l+1][r-1]*2 + 2\n  else:\n     dp[l][r] = dp[l+1][r-1]*2 + 1\nelse:\n  dp[l][r] = dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1]\nBut careful with modulo.\n\nWe'll output virtual steps accordingly.\n\nNeed to generate virtual code lines with arrows and explanation. Provide steps: read string, compute next and prev arrays, initialize dp matrix, iterate over length, compute dp using recurrence, mod adjustments, output result.\n\nWe'll not output actual code, just virtual. Let's craft.\n\nWe will use variables: n, s, nextIdx[], prevIdx[], dp[n][n], mod.\n\nAlso we will need loops: for i from 0 to n-1: dp[i][i] =1.\n\nThen for len from 2 to n: for l from 0 to n-len: r=l+len-1; compute.\n\nUse mod operations.\n\nOk produce virtual code.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s // 從使用者取得要處理的字串\n→ Step 2: 計算字串長度 n = s.length // 取得字串長度\n→ Step 3: 初始化陣列 nextIdx[n], prevIdx[n] // 用於快速查找相同字元的下一個/上一個位置\n→ Step 4: for i from 0 to n-1: \n    → Step 4a: nextIdx[i] = n // 預設為 n，表示後面沒有相同字元\n    → Step 4b: prevIdx[i] = -1 // 預設為 -1，表示前面沒有相同字元\n→ Step 5: 建立 map charToLastPos // 暫存每個字元最近一次出現的位置\n→ Step 6: for i from 0 to n-1:\n    → Step 6a: c = s[i]\n    → Step 6b: if c in charToLastPos: nextIdx[charToLastPos[c]] = i // 設定前一次相同字元的下一個位置為現在的位置\n    → Step 6c: prevIdx[i] = charToLastPos.get(c, -1) // 取得前一次相同字元的位置\n    → Step 6d: charToLastPos[c] = i // 更新最近一次出現的位置\n→ Step 7: 定義常數 MOD = 1_000_000_007 // 取模數\n→ Step 8: 初始化二維陣列 dp[n][n] 為 0 // dp[l][r] 表示子字串 s[l..r] 的不同回文子序列數\n→ Step 9: for i from 0 to n-1:\n    → Step 9a: dp[i][i] = 1 // 單字元本身即為一個回文子序列\n→ Step 10: for length from 2 to n: // 逐段長度遍歷\n    → Step 10a: for l from 0 to n-length:\n        → Step 10a1: r = l + length - 1 // 子字串結束位置\n        → Step 10a2: if s[l] == s[r]: // 首尾字元相同\n            → Step 10a2a: if nextIdx[l] > r-1: // 子字串內沒有相同字元\n                → Step 10a2a1: dp[l][r] = (dp[l+1][r] + dp[l][r-1] + 1) mod MOD // +1 為以兩端字元包住的新回文\n            → Step 10a2b: else if nextIdx[l] == prevIdx[r]: // 內部恰好只有一個相同字元\n                → Step 10a2b1: dp[l][r] = (dp[l+1][r] + dp[l][r-1] + 1) mod MOD\n            → Step 10a2c: else: // 內部至少有兩個相同字元\n                → Step 10a2c1: dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1] + MOD) mod MOD\n        → Step 10a3: else: // 首尾字元不同\n            → Step 10a3a: dp[l][r] = (dp[l+1][r] + dp[l][r-1] - dp[l+1][r-1] + MOD) mod MOD\n→ Step 11: 輸出 dp[0][n-1] // 回傳整個字串的不同回文子序列數\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支援 \"s = \\\"string\\\"\" 或單純輸入字串\n    if data.startswith('s ='):\n        first_quote = data.find('\"')\n        second_quote = data.find('\"', first_quote + 1)\n        if first_quote != -1 and second_quote != -1:\n            s = data[first_quote + 1:second_quote]\n        else:\n            first_quote = data.find(\"'\")\n            second_quote = data.find(\"'\", first_quote + 1)\n            if first_quote != -1 and second_quote != -1:\n                s = data[first_quote + 1:second_quote]\n            else:\n                s = data\n    else:\n        s = data\n\n    MOD = 10**9 + 7\n    n = len(s)\n    if n == 0:\n        print(0)\n        return\n\n    # 1. 計算每個位置相同字元的下一個/上一個位置\n    next_idx = [n] * n\n    prev_idx = [-1] * n\n    last_pos = {}\n    for i, ch in enumerate(s):\n        if ch in last_pos:\n            next_idx[last_pos[ch]] = i\n        prev_idx[i] = last_pos.get(ch, -1)\n        last_pos[ch] = i\n\n    # 2. 初始化 DP 表\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1  # 單字元本身就是回文\n\n    # 3. 填表，長度從 2 到 n\n    for length in range(2, n + 1):\n        for l in range(0, n - length + 1):\n            r = l + length - 1\n            if s[l] == s[r]:\n                nl = next_idx[l]\n                pr = prev_idx[r]\n                if nl > r - 1:  # 子字串內沒有相同字元\n                    dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] + 1) % MOD\n                elif nl == pr:  # 內部恰好只有一個相同字元\n                    dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] + 1) % MOD\n                else:  # 內部至少兩個相同字元\n                    dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1]) % MOD\n            else:  # 首尾字元不同\n                dp[l][r] = (dp[l + 1][r] + dp[l][r - 1] - dp[l + 1][r - 1]) % MOD\n\n    result = dp[0][n - 1] % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '9'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '9'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '1625'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '1625'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode5.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Substring",
    "description_snippet": "Given a string s, return the longest palindromic substring in s....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for algorithm: find longest palindromic substring. Use center expansion approach. Steps: input s, initialize bestStart, bestLen, loop over each center index i, expand for odd and even. Update best. Finally return substring. Each line with \"→ Step...\" etc. Also include Start, End. Use decision arrows. Provide concise explanation after //.\n\nLet's craft lines.\n\nStart // 程式開始執行\n→ Input s // 取得輸入字串\n→ If s 為空? // 判斷字串是否為空\n    Yes → Return \"\" // 空字串返回空\n    No  → // 繼續執行\n→ Initialize bestStart = 0, bestLen = 1 // 設定最長回文起點與長度\n→ For each index i from 0 to len(s)-1: // 遍歷所有可能的中心\n    → ExpandOdd: left = i, right = i // 奇數長度回文中心\n    → While left >=0 and right < len(s) and s[left]==s[right]:\n        → If right-left+1 > bestLen:\n            → Update bestStart = left, bestLen = right-left+1 // 更新最佳回文\n        → left--, right++ // 進一步擴展\n    → ExpandEven: left = i, right = i+1 // 偶數長度回文中心\n    → While left >=0 and right < len(s) and s[left]==s[right]:\n        → If right-left+1 > bestLen:\n            → Update bestStart = left, bestLen = right-left+1\n        → left--, right++ \n→ Return s.substring(bestStart, bestStart+bestLen) // 取得最長回文子字串\nEnd // 程式執行結束\n\nWe must add arrows and decision. Use indentation maybe? The format uses \"→\" preceding step. For decisions use \"Decision:\".\n\nLet's rewrite with Decision lines.\n\nStart // 程式開始執行\n→ Step 1: Input s // 取得輸入字串\n→ Decision: s 為空? // 判斷字串是否為空\n    Yes → Step 2: Return \"\" // 空字串返回空\n    No  → // 繼續執行\n→ Step 3: 初始化 bestStart = 0, bestLen = 1 // 設定最長回文起點與長度\n→ For i in 0..len(s)-1: // 遍歷每個索引作為中心\n    → Step 4: 左 = i, 右 = i // 奇數長度中心\n    → While 左>=0 且 右< len(s) 且 s[左]==s[右]: // 擴展奇數中心\n        → Decision: 右-左+1 > bestLen? // 判斷是否更長\n            Yes → Step 5: bestStart = 左, bestLen = 右-左+1 // 更新最佳\n            No  → // 不中斷\n        → 左--, 右++ // 擴展\n    → Step 6: 左 = i, 右 = i+1 // 偶數長度中心\n    → While 左>=0 且 右< len(s) 且 s[左]==s[右]: // 擴展偶數中心\n        → Decision: 右-左+1 > bestLen? // 判斷是否更長\n            Yes → Step 7: bestStart = 左, bestLen = 右-左+1\n            No  → // 不中斷\n        → 左--, 右++ // 擴展\n→ Step 8: Return s.substring(bestStart, bestStart+bestLen) // 取得最長回文子字串\nEnd // 程式執行結束\n\nNeed to keep format lines: each line with \"→\" and step number maybe optional. They show arrow before step, not necessarily number. We'll keep step names like \"Step 1:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者取得輸入字串  \n→ Decision: s 為空? // 檢查字串是否為空  \n Yes → Step 2: 回傳空字串 \"\" // 空字串直接返回  \n No  → // 繼續執行  \n\n→ Step 3: 初始化 bestStart = 0, bestLen = 1 // 設定最長回文起點與長度  \n\n→ For i in 0 .. len(s)-1: // 逐一將每個索引作為中心  \n → Step 4: 左 = i, 右 = i // 奇數長度回文的中心設定  \n → While 左 >= 0 且 右 < len(s) 且 s[左] == s[右]: // 擴展奇數中心  \n   → Decision: 右 - 左 + 1 > bestLen? // 判斷是否更長  \n    Yes → Step 5: bestStart = 左, bestLen = 右 - 左 + 1 // 更新最佳回文  \n    No  → // 不更新  \n   → 左--, 右++ // 進一步擴展  \n\n → Step 6: 左 = i, 右 = i + 1 // 偶數長度回文的中心設定  \n → While 左 >= 0 且 右 < len(s) 且 s[左] == s[右]: // 擴展偶數中心  \n   → Decision: 右 - 左 + 1 > bestLen? // 判斷是否更長  \n    Yes → Step 7: bestStart = 左, bestLen = 右 - 左 + 1 // 更新最佳回文  \n    No  → // 不更新  \n   → 左--, 右++ // 進一步擴展  \n\n→ Step 8: 回傳 s.substring(bestStart, bestStart + bestLen) // 取得最長回文子字串  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef longest_palindrome(s: str) -> str:\n    \"\"\"\n    Find the longest palindromic substring in s using center expansion.\n    \"\"\"\n    if not s:\n        return \"\"\n\n    best_start, best_len = 0, 1  # initial best palindrome\n\n    for i in range(len(s)):\n        # odd-length palindrome (center at i)\n        left, right = i, i\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            if right - left + 1 > best_len:\n                best_start, best_len = left, right - left + 1\n            left -= 1\n            right += 1\n\n        # even-length palindrome (center between i and i+1)\n        left, right = i, i + 1\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            if right - left + 1 > best_len:\n                best_start, best_len = left, right - left + 1\n            left -= 1\n            right += 1\n\n    return s[best_start:best_start + best_len]\n\nif __name__ == \"__main__\":\n    # Read all input data\n    data = sys.stdin.read().strip()\n\n    # Extract the string argument (handles formats like \"s = 'babad'\" or just the raw string)\n    match = re.search(r\"['\\\"](.*?)['\\\"]\", data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data  # fallback if no quotes found\n\n    result = longest_palindrome(s)\n    # Print the result surrounded by single quotes as shown in the examples\n    print(f\"'{result}'\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "success": true,
          "output": "'bab'"
        },
        {
          "example_index": 1,
          "input": "s = 'cbbd'",
          "expected_output": "'bb'",
          "success": true,
          "output": "'bb'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode454.json",
    "problem_index_in_file": 0,
    "title": "4Sum II",
    "description_snippet": "Given four integer arrays A, B, C, and D all of length n, return the number of tuples (i, j, k, l) s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the output format. The user: four integer arrays A, B, C, D of length n. We need to return the number of quadruples (i,j,k,l) with sum zero.\n\nWe need to produce algorithm. Classic 4Sum Count problem: use hashmap for sums of pairs (A[i]+B[j]) -> count. Then for each pair from C and D, look up -(C[k]+D[l]) and accumulate counts. Complexity O(n^2).\n\nNeed to produce step-by-step virtual code: Start, input arrays, compute n, compute pair sums for A,B, store in map, compute pairs for C,D and look up, accumulate count, output result.\n\nWe need to use arrow syntax: \"→ Step X: ...\" etc. Each line includes virtual code and explanation comment. Must be lines only. Format: each line \"虛擬碼步驟 // 解釋/說明\".\n\nAlso must use Decision and Yes→ etc if needed.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: 設定 n ← length of A // 獲取陣列長度\n→ Step 2: 建立空哈希表 pairCount // 用於儲存 A[i]+B[j] 的出現次數\n→ Step 3: 循環 i 從 0 到 n-1 // 產生 A[i]+B[j] 的所有組合\n    → Step 4: 循環 j 從 0 到 n-1\n        → Step 5: sum ← A[i] + B[j] // 計算 A[i]+B[j]\n        → Step 6: 若 sum 已在 pairCount 中則 pairCount[sum] ← pairCount[sum] + 1 否則 pairCount[sum] ← 1 // 更新計數\n→ Step 7: 設定 count ← 0 // 結果累加器\n→ Step 8: 循環 k 從 0 到 n-1 // 產生 C[k]+D[l] 的所有組合\n    → Step 9: 循環 l 從 0 到 n-1\n        → Step 10: target ← -(C[k] + D[l]) // 需要的補數\n        → Decision: 若 target 在 pairCount 中?\n            Yes → Step 11: count ← count + pairCount[target] // 累加符合的四元組數\n            No  → Step 12: // 無匹配，繼續\n→ Step 13: 輸出 count // 回傳最終結果\nEnd // 程式結束\n\nBut we need to format each line: \"虛擬碼步驟 // 解釋/說明\". Also need arrow characters. They want \"Start\", \"End\", \"Decision:\" etc. The arrow syntax: \"→ Step 1: ...\" and for decision: \"Decision: ...\". For nested steps, we may indent or use arrow. But format may not strictly require indentation. We'll just add indentation for readability but each line still starts with \"→\". We need to include \"→ Step ...\" etc. For decision we do \"→ Decision: 如果 ...?\" then \"Yes → ...\" and \"No → ...\".\n\nMake sure each line has the comment after //. The comment includes short explanation.\n\nLet's produce final answer accordingly. Ensure we follow requirements: no real code, only virtual steps. Use arrow.\n\nWe need to keep line breaks.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n ← length of A // 取得陣列長度  \n→ Step 2: 建立空哈希表 pairCount // 用來儲存 A[i]+B[j] 的出現次數  \n→ Step 3: 循環 i 從 0 到 n-1 // 產生所有 A[i] 與 B[j] 的組合  \n    → Step 4: 循環 j 從 0 到 n-1  \n        → Step 5: sum ← A[i] + B[j] // 計算 A[i]+B[j]  \n        → Step 6: 若 sum 已在 pairCount 中?  \n            Yes → Step 7: pairCount[sum] ← pairCount[sum] + 1 // 更新計數  \n            No  → Step 8: pairCount[sum] ← 1 // 新增計數  \n→ Step 9: 設定 count ← 0 // 結果累加器  \n→ Step 10: 循環 k 從 0 到 n-1 // 產生所有 C[k] 與 D[l] 的組合  \n    → Step 11: 循環 l 從 0 到 n-1  \n        → Step 12: target ← -(C[k] + D[l]) // 需要的補數  \n        → Decision: 是否存在 pairCount[target]?  \n            Yes → Step 13: count ← count + pairCount[target] // 累加符合的四元組數  \n            No  → Step 14: // 無匹配，繼續  \n→ Step 15: 輸出 count // 回傳最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef four_sum_count(A, B, C, D):\n    \"\"\"Count quadruples (i, j, k, l) with A[i]+B[j]+C[k]+D[l] == 0.\"\"\"\n    # Count sums of all pairs from A and B\n    ab_counts = Counter(a + b for a in A for b in B)\n    total = 0\n    # For each pair from C and D, look for the complementary sum in ab_counts\n    for c in C:\n        for d in D:\n            total += ab_counts.get(-(c + d), 0)\n    return total\n\ndef parse_input(s):\n    \"\"\"\n    Parse input in the form:\n    'A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]'\n    \"\"\"\n    pattern = r'A\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*B\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*C\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*D\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, s.strip())\n    if not match:\n        return [], [], [], []\n    A = eval(match.group(1))\n    B = eval(match.group(2))\n    C = eval(match.group(3))\n    D = eval(match.group(4))\n    return A, B, C, D\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    input_data = sys.stdin.read()\n    A, B, C, D = parse_input(input_data)\n    result = four_sum_count(A, B, C, D)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "A = [0], B = [0], C = [0], D = [0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode50.json",
    "problem_index_in_file": 0,
    "title": "Pow(x, n)",
    "description_snippet": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n)....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for pow(x, n) computing x^n. Use steps, decision, start end. Provide in Chinese Traditional. Each line: virtual step + space + // explanation.\n\nWe need to decide algorithm: likely exponentiation by squaring. So steps: Start, check n=0 return 1. If n<0? maybe compute inverse. But requirement didn't specify negative. We'll include handling negative.\n\nPseudo:\n\nStart\n→ Step 1: 設定 result = 1, base = x, exponent = n // 初始化\n→ Decision: exponent 0? // Check\n    Yes → Step 2: 輸出 result // 結果為1\n    No  → Decision: exponent 負? // 處理負數\n        Yes → Step 3: base = 1 / base // 取倒數\n             → Step 4: exponent = -exponent // 取正\n        No  → // exponent 正\n→ Loop: 直到 exponent = 0\n    Decision: exponent 奇? // 判斷\n        Yes → Step 5: result = result * base // 乘以基底\n    Yes → // continue\n    → Step 6: base = base * base // 平方基底\n    → Step 7: exponent = exponent // 2 // 整除\nReturn result\nEnd\n\nNeed to format with arrows: Start, Step, Decision, Yes →, No →.\n\nMake sure each line has \"虛擬碼步驟\" and explanation comment. Use indentation? In example they indent inside decision? Not necessary but can.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 result = 1, base = x, exponent = n // 初始化變數\n→ Decision: exponent 等於 0? // 檢查是否為 0\n    Yes → Step 2: 輸出 result // 回傳 1\n    No  → Decision: exponent 小於 0? // 處理負指數\n        Yes → Step 3: base = 1 / base // 取倒數\n             → Step 4: exponent = -exponent // 轉為正數\n        No  → // exponent 為正，直接執行迴圈\n→ Decision: exponent 大於 0? // 進入乘方迴圈\n    Yes →\n        → Decision: exponent 為奇數? // 判斷奇偶\n            Yes → Step 5: result = result * base // result 乘以基底\n            No  →\n        → Step 6: base = base * base // 基底平方\n        → Step 7: exponent = exponent // 2 // 整除\n        → Decision: exponent 大於 0? // 判斷是否繼續\n            Yes → 回到上一層迴圈\n            No  → Step 8: 輸出 result // 回傳結果\n    No → Step 8: 輸出 result // 若 exponent 為 0（此情況已在前面處理）\nEnd // 程式結束\n\nBut need to use \"Yes →\" \"No →\". In example they indent nested decisions.\n\nLet's craft clean structure.\n\nBetter:\n\nStart // 程式開始執行\n→ Step 1: result ← 1, base ← x, exponent ← n // 初始化變數\n→ Decision: exponent = 0? // 判斷是否為 0\n    Yes → Step 2: 輸出 result // 回傳 1\n    No  → Decision: exponent < 0? // 處理負指數\n        Yes → Step 3: base ← 1 / base // 取倒數\n             → Step 4: exponent ← -exponent // 轉為正\n        No  → // exponent 為正，繼續\n→ Loop: // 乘方迴圈\n    Decision: exponent > 0? // 是否還有指數\n        Yes →\n            Decision: exponent 是奇數? // 判斷奇偶\n                Yes → Step 5: result ← result * base // 乘以基底\n                No  →\n            Step 6: base ← base * base // 基底平方\n            Step 7: exponent ← exponent // 2 // 整除\n            → // 迴圈回到決策\n        No  → Step 8: 輸出 result // 完成，回傳結果\nEnd // 程式結束\n\nEnsure each line has comment.\n\nLet's write each line accordingly.\n\nWe need arrow \"→\" at start of each step except Start. Use indentation? In example they indent nested lines.\n\nI'll produce as:\n\nStart // 程式開始執行\n→ Step 1: result ← 1, base ← x, exponent ← n // 初始化變數\n→ Decision: exponent = 0? // 判斷指數是否為 0\n    Yes → Step 2: 輸出 result // 回傳 1\n    No  → Decision: exponent < 0? // 判斷是否為負指數\n        Yes → Step 3: base ← 1 / base // 取倒數\n             → Step 4: exponent ← -exponent // 轉為正數\n        No  → // exponent 為正，繼續後續\n→ Decision: exponent > 0? // 進入乘方迴圈\n    Yes →\n        → Decision: exponent 是奇數? // 判斷奇偶\n            Yes → Step 5: result ← result * base // 乘以基底\n            No  →\n        → Step 6: base ← base * base // 基底平方\n        → Step 7: exponent ← exponent // 2 // 整除\n        → // 迴圈結束後回到 Decision\n    No  → Step 8: 輸出 result // 回傳結果\nEnd // 程式結束\n\nBut we need \"→\" before each line; we already have.\n\nAlso each line must have explanation comment after space. Ensure no extra formatting.\n\nLet's finalize.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 1, base ← x, exponent ← n // 初始化結果、基底與指數變數  \n→ Decision: exponent = 0? // 判斷指數是否為 0  \n    Yes → Step 2: 輸出 result // 回傳 1（任何數的 0 次方）  \n    No → Decision: exponent < 0? // 判斷是否為負指數  \n        Yes → Step 3: base ← 1 / base // 取倒數以處理負指數  \n              → Step 4: exponent ← -exponent // 轉為正數  \n        No → // exponent 為正，直接進入迴圈  \n→ Decision: exponent > 0? // 進入乘方迴圈  \n    Yes →  \n        → Decision: exponent 是奇數? // 判斷奇偶  \n            Yes → Step 5: result ← result * base // 乘以基底  \n            No → // 若為偶數，跳過此步驟  \n        → Step 6: base ← base * base // 基底平方  \n        → Step 7: exponent ← exponent // 2 // 整除 2  \n        → // 迴圈回到 Decision  \n    No → Step 8: 輸出 result // 完成計算，回傳結果  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        \"\"\"\n        Compute x raised to the power n using fast exponentiation.\n        Handles negative exponents by taking the reciprocal of x.\n        \"\"\"\n        if n == 0:\n            return 1.0\n        if n < 0:\n            x = 1.0 / x\n            n = -n\n\n        result = 1.0\n        current_base = x\n        while n > 0:\n            if n & 1:          # 如果 n 是奇數\n                result *= current_base\n            current_base *= current_base  # 平方基底\n            n >>= 1            # n 除以 2\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，預期格式類似 \"x = 2.00000, n = 10\"\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 用正則表達式找出所有數字（含負號和小數點）\n    numbers = re.findall(r'[-+]?\\d*\\.?\\d+', data)\n    if len(numbers) < 2:\n        raise ValueError(\"輸入格式不符合要求：應包含 x 和 n\")\n\n    x_value = float(numbers[0])\n    n_value = int(float(numbers[1]))  # 若輸入為 \"10\" 或 \"10.0\" 都能正確轉換\n\n    sol = Solution()\n    result = sol.myPow(x_value, n_value)\n\n    # 輸出結果，保留五位小數\n    print(f\"{result:.5f}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 2.00000, n = 10",
          "expected_output": "1024.00000",
          "success": true,
          "output": "1024.00000"
        },
        {
          "example_index": 1,
          "input": "x = 2.10000, n = 3",
          "expected_output": "9.26100",
          "success": true,
          "output": "9.26100"
        },
        {
          "example_index": 2,
          "input": "x = 2.00000, n = -2",
          "expected_output": "0.25000",
          "success": true,
          "output": "0.25000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode8.json",
    "problem_index_in_file": 0,
    "title": "String to Integer (atoi)",
    "description_snippet": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe al...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode with comments per line. Use structure: Start, Decision, etc. Must not output real code. Provide step-by-step algorithm described. Use arrow. Need to cover whitespace skip, sign detection, conversion, rounding. Ensure 32-bit signed int bounds.\n\nLet's craft lines:\n\nStart\n→ Step 1: Initialize idx = 0, n = length of s // index pointer\n→ Step 2: While idx < n and s[idx] is space → idx++ // skip leading spaces\n→ Decision: idx == n? // if reached end after spaces\n    Yes → Step 3: Return 0 // no digits\n    No  → Step 4: Determine sign\nStep 4: If s[idx] == '+' then sign = 1, idx++ // positive\n    Else If s[idx] == '-' then sign = -1, idx++ // negative\n    Else sign = 1 // default\n→ Step 5: Initialize num = 0 // accumulate digits\n→ Decision: idx == n? // if no more chars\n    Yes → Step 6: Return 0 // no digits\n    No  → Step 7: While idx < n and s[idx] is digit\n        → Step 8: If num > (INT_MAX - digit) / 10? // overflow detection? We'll just build then clamp later\n        → Step 9: num = num * 10 + digit\n        → Step 10: idx++\n→ Step 11: num = num * sign // apply sign\n→ Decision: num < INT_MIN? // clamp\n    Yes → Step 12: num = INT_MIN\n    No  → Decision: num > INT_MAX?\n        Yes → Step 13: num = INT_MAX\n        No  → Step 14: // within range\n→ Step 15: Return num\nEnd\n\nWe need to include explanation comments. Also define INT_MAX = 2^31-1, INT_MIN = -2^31. Use Step numbers.\n\nAlso ensure arrow formatting consistent. Use \"→\" between steps. Use \"Decision:\" for conditions. For nested decisions use indent.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 idx = 0，n = s 的長度 // 設定索引與字符串長度  \n→ Step 2: 迴圈 While idx < n 且 s[idx] 為空白字元 → idx++ // 跳過前導空白  \n→ Decision: idx == n? // 所有字元都是空白？  \n  Yes → Step 3: 回傳 0 // 沒有任何有效字元  \n  No  → Step 4: 確定符號  \n     若 s[idx] 為 '+' → sign = 1，idx++ // 正號  \n     否則若 s[idx] 為 '-' → sign = -1，idx++ // 負號  \n     否則 sign = 1 // 默認為正號  \n→ Step 5: 初始化 num = 0 // 用於累積數字  \n→ Decision: idx == n? // 立即結束？  \n  Yes → Step 6: 回傳 0 // 無數字可讀  \n  No  → Step 7: 讀取數字  \n     While idx < n 且 s[idx] 為數位  \n      → Step 8: digit = s[idx] - '0'  \n      → Step 9: num = num * 10 + digit // 累積  \n      → Step 10: idx++  \n→ Step 11: num = num * sign // 加上符號  \n→ Decision: num < INT_MIN? // 是否小於 -2^31？  \n  Yes → Step 12: num = INT_MIN // 截斷到下限  \n  No  → Decision: num > INT_MAX? // 是否大於 2^31-1？  \n     Yes → Step 13: num = INT_MAX // 截斷到上限  \n     No  → Step 14: // 數值已在合法範圍內  \n→ Step 15: 回傳 num // 結束並回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        # Step 1: remove leading whitespace\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        # Step 2: determine sign\n        sign = 1\n        index = 0\n        if s[0] == '+':\n            index += 1\n        elif s[0] == '-':\n            sign = -1\n            index += 1\n\n        # Step 3: accumulate digits\n        result = 0\n        while index < len(s) and s[index].isdigit():\n            result = result * 10 + int(s[index])\n            index += 1\n\n        # Step 4: apply sign\n        result *= sign\n\n        # Step 5: clamp to 32‑bit signed integer range\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n        return result\n\nif __name__ == \"__main__\":\n    # Read all input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Extract the string value. If it contains quotes, take the first quoted part.\n    match = re.search(r'\"(.*?)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # Fallback: use the whole input after stripping possible 's =' prefix\n        s = raw_input\n        s = s.split('=', 1)[-1].strip()\n        if s.startswith('\"') and s.endswith('\"'):\n            s = s[1:-1]\n\n    solution = Solution()\n    result = solution.myAtoi(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"42\"",
          "expected_output": "42",
          "success": true,
          "output": "42"
        },
        {
          "example_index": 1,
          "input": "s = \" -042\"",
          "expected_output": "-42",
          "success": true,
          "output": "-42"
        },
        {
          "example_index": 2,
          "input": "s = \"1337c0d3\"",
          "expected_output": "1337",
          "success": true,
          "output": "1337"
        },
        {
          "example_index": 3,
          "input": "s = \"0-1\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 4,
          "input": "s = \"words and 987\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode151.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String",
    "description_snippet": "Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-spa...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Virtual code with arrows. Must be in Traditional Chinese. Should follow format.\n\nWe need algorithm: trim s, split by spaces, filter empty, reverse list, join with space.\n\nWe'll produce Start, Step, Decision, End. Provide comments.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: input s // 取得輸入字串\n→ Step 2: trim = Trim(s) // 去除前後空白\n→ Decision: 是否為空字串? // 判斷是否還有內容\n    Yes → Step 3: return \"\" // 若空則回傳空字串\n    No → Step 4: words = Split(trim, \" \") // 以空白分割\n    → Step 5: filtered = Filter(words, w -> w ≠ \"\") // 移除多餘空字串\n    → Step 6: reversed = Reverse(filtered) // 反轉單字順序\n    → Step 7: result = Join(reversed, \" \") // 以單個空白連接\n    → Step 8: return result // 回傳結果\nEnd // 程式結束\n\nAdd explanations after each line. Also ensure each line has the pattern: `虛擬碼步驟 [space] // 解釋`.\n\nWe'll produce each line exactly with one space before //.\n\nAlso include arrow notation as specified: \"→\".\n\nLet's create final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: input s // 取得使用者輸入的字串  \n→ Step 2: trimmed = Trim(s) // 去除字串前後的空格  \n→ Decision: trimmed 是否為空字串? // 檢查字串是否已被完全清除  \n  Yes → Step 3: return \"\" // 若空則直接回傳空字串  \n  No → Step 4: words = Split(trimmed, \" \") // 以空白分割字串為單字陣列  \n  → Step 5: filtered = Filter(words, w → w ≠ \"\") // 去除因多個空白而產生的空元素  \n  → Step 6: reversed = Reverse(filtered) // 將單字陣列順序倒轉  \n  → Step 7: result = Join(reversed, \" \") // 用單一空格重新連接倒轉後的單字  \n  → Step 8: return result // 回傳最終字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        # 去除首尾空格並以空格分割，過濾掉多餘空格\n        words = s.strip().split()\n        # 反轉順序後用單一空格連接\n        return ' '.join(words[::-1])\n\ndef main() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 若輸入格式類似於「s = \"the sky is blue\"」則取等號右邊的部分\n    if data.startswith('s') and '=' in data:\n        _, s = data.split('=', 1)\n        s = s.strip()\n    else:\n        s = data\n\n    # 去除可能存在的包圍引號\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n\n    solution = Solution()\n    result = solution.reverseWords(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"the sky is blue\"",
          "expected_output": "\"blue is sky the\"",
          "success": true,
          "output": "blue is sky the"
        },
        {
          "example_index": 1,
          "input": "s = \"  hello world  \"",
          "expected_output": "\"world hello\"",
          "success": true,
          "output": "world hello"
        },
        {
          "example_index": 2,
          "input": "s = \"a good   example\"",
          "expected_output": "\"example good a\"",
          "success": true,
          "output": "example good a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode27.json",
    "problem_index_in_file": 0,
    "title": "Remove Element",
    "description_snippet": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code in Traditional Chinese, following format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows and structure.\n\nWe need to design algorithm: typical two-pointer: keep writeIndex, iterate readIndex over array, if nums[readIndex] != val, set nums[writeIndex] = nums[readIndex], writeIndex++. After loop, return writeIndex. Provide steps with decisions.\n\nLet's produce step-by-step pseudo-code. Should include Start, End, Decision, steps. Ensure each line includes // explanation. Use arrows \"→\".\n\nWe need to show loop iteration. For loop we can use \"→ Step: 初始化 writeIndex = 0\" etc. Use \"Decision:\" for condition check.\n\nLet's produce something like:\n\nStart\n→ Step 1: 設定 writeIndex = 0 // 初始化寫入指標\n→ Step 2: 設定 readIndex = 0 // 初始化讀取指標\n→ Decision: readIndex < nums.length? // 是否還有元素可讀\n    Yes → Step 3: 讀取 current = nums[readIndex] // 取得目前元素\n    → Decision: current == val? // 是否等於要移除的值\n        Yes → Step 4: readIndex++ // 等於，跳過此元素\n        No  → Step 5: nums[writeIndex] = current // 複製到寫入位置\n        → Step 6: writeIndex++ // 移動寫入指標\n        → Step 7: readIndex++ // 移動讀取指標\n    No → Step 8: Return writeIndex // 所有元素處理完畢，回傳不等於 val 的數量\nEnd\n\nBut need arrow formatting: Use \"→\" before each step. And Decision lines also with arrow? Example shows:\n\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2...\n    No  → Decision: ...\n\nSo we need to indent Yes/No lines maybe. Provide each line as separate with // explanation. Use \"Yes →\" and \"No →\".\n\nMake sure each line has a single virtual code step and comment. Provide line for Decision and Yes/No steps.\n\nAlso need to include Start and End.\n\nLet's craft final output. Ensure Chinese comments. Ensure step names in Chinese.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 writeIndex = 0 // 初始化寫入指標，指向要放置非 val 元素的起始位置  \n→ Step 2: 設定 readIndex = 0 // 初始化讀取指標，從陣列起始處遍歷每個元素  \n→ Decision: readIndex < nums.length? // 是否還有未處理的元素？  \n    Yes → Step 3: 讀取 current = nums[readIndex] // 取得目前讀取位置的元素  \n    → Decision: current == val? // 這個元素是否是要移除的值？  \n        Yes → Step 4: readIndex++ // 是，跳過此元素，直接往後移動讀取指標  \n        No  → Step 5: nums[writeIndex] = current // 否，將此元素複製到 writeIndex 位置  \n        → Step 6: writeIndex++ // 移動寫入指標，準備寫入下一個非 val 元素  \n        → Step 7: readIndex++ // 讀取指標往後移動，繼續下一輪判斷  \n    No → Step 8: Return writeIndex // 所有元素已處理完畢，回傳非 val 元素的個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除 nums 中所有等於 val 的元素，返回剩餘元素的個數 k。\n        方法：雙指針，slow 指向寫入位置，fast 指向讀取位置。\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從字串中擷取 nums 列表和 val 整數\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    val_match  = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not val_match:\n        raise ValueError(\"輸入格式不正確\")\n\n    nums = ast.literal_eval(nums_match.group(1))\n    val  = int(val_match.group(1))\n\n    # 呼叫解法\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 製作輸出字串\n    output_elements = [str(x) for x in nums[:k]] + ['_'] * (len(nums) - k)\n    output_str = f\"{k}, nums = [{','.join(output_elements)}]\"\n    print(output_str)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "success": true,
          "output": "2, nums = [2,2,_,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "success": true,
          "output": "5, nums = [0,1,3,0,4,_,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode357.json",
    "problem_index_in_file": 0,
    "title": "Count Numbers with Unique Digits",
    "description_snippet": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (step-by-step pseudocode) for counting numbers with unique digits up to 10^n. The algorithm: count numbers with unique digits less than 10^n inclusive. Actually standard Leetcode problem: count numbers with unique digits. Approach: For n=0 => 1. For n>0: result=1 (for 0). For i from1 to n: result += 9 * perm(9, i-1). Implementation: use factorial or multiplication.\n\nSo we produce virtual code step by step with arrows. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, loops. Provide per line explanation.\n\nLet's produce:\n\nStart\n→ Step 1: 輸入 n // 使用者輸入整數\n→ Decision: n == 0? // 檢查 n 是否為 0\n    Yes → Step 2: 輸出 1 // 只有數字 0\n    No → Step 3: 初始化 result = 1 // 包含數字 0\n→ Step 4: 初始化 perm = 9 // 用於計算 9P(k)\n→ Step 5: for i = 1 to n do // 逐位計算\n        → Step 6: result += 9 * perm // 加上當前位數的唯一數字組合\n        → Decision: i < n? // 是否還有更高位\n            Yes → Step 7: perm *= (10 - i) // 更新排列數\n            No → // loop ends\n→ End // 輸出結果\n\nNeed to ensure loops etc.\n\nMake each line with virtual code arrow. Use \"→\" to indent lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 從使用者取得整數 n  \n→ Decision: n == 0? // 檢查是否為 0  \n  Yes → Step 2: 輸出 1 // 只有數字 0 的情況  \n  No → Step 3: 初始化 result = 1 // result 先包含 0  \n→ Step 4: 初始化 perm = 9 // perm 用於計算 9P(k)  \n→ Step 5: for i = 1 to n do // 逐位計算可用數字數量  \n  → Step 6: result += 9 * perm // 加上第 i 位的唯一數字組合  \n  → Decision: i < n? // 是否還有更高位需要計算  \n    Yes → Step 7: perm *= (10 - i) // 更新 perm 為 9P(i)  \n    No → // 繼續下一行  \n→ End // 輸出結果並結束程式",
      "generated_code": "import sys\nimport re\n\ndef count_numbers_with_unique_digits(n: int) -> int:\n    \"\"\"\n    Count all numbers with unique digits where 0 <= x < 10^n.\n    \"\"\"\n    if n == 0:\n        return 1  # only number 0\n\n    n = min(n, 10)          # after 10 digits, digits must repeat\n    result = 1              # include 0\n    perm = 1                # P(9, i-1) for the current length i\n\n    for i in range(1, n + 1):\n        result += 9 * perm\n        perm *= (10 - i)   # prepare P(9, i) for the next length\n\n    return result\n\ndef main() -> None:\n    \"\"\"\n    Read integer n from stdin, compute the result and print it.\n    \"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    print(count_numbers_with_unique_digits(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "success": true,
          "output": "91"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode392.json",
    "problem_index_in_file": 0,
    "title": "Is Subsequence",
    "description_snippet": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\nA subsequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the algorithm. We should explain step by step, including Start, End, Decision, loops. Should be concise. The algorithm: two pointers i and j. Iterate over t while j < s length, i pointer for s, j for t. For each char in t, if matches s[i], increment i. At end if i == s length then true else false. Edge cases: empty s => true. We need to produce line by line with arrows, etc.\n\nWe will output lines:\n\nStart\n→ Initialize indices i=0, j=0\n→ Decision: i == len(s)? // check if s already fully matched (empty case)\n  Yes → Step 1: Return true\n  No → Step 2: While j < len(t):\n     → Decision: j == len(t)? // if t exhausted\n       Yes → Step 3: Return i == len(s)\n       No  → Step 4: If t[j] == s[i]: increment i\n     → Increment j\n→ End\n\nBut we need to use arrow properly.\n\nBetter to show loop structure:\n\nDecision: i < len(s) and j < len(t) ?\n\nBut we can do while loop:\n\n→ While j < len(t):\n    → Decision: t[j] == s[i]?\n        Yes → i = i + 1\n    → j = j + 1\n→ Decision: i == len(s)? // after loop\n    Yes → Return true\n    No  → Return false\n\nEdge case for s empty:\n\nDecision: len(s) == 0? // if s empty\n    Yes → Return true\n\nOk.\n\nAlso we can mention Start, End.\n\nLet's format.\n\nWe'll ensure each line has a virtual code step and comment.\n\nWe need to use arrow \"→\" at start of step lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: len(s) == 0? // 檢查 s 是否為空字串  \n    Yes → Step 1: Return true // 空字串永遠是 t 的子序列  \n    No → Step 2: Initialize i = 0, j = 0 // 建立兩個指標，分別指向 s 與 t  \n→ While j < len(t): // 逐字串遍歷 t  \n    → Decision: t[j] == s[i]? // 檢查目前 t 字元是否與 s 的下個目標字元相同  \n        Yes → i = i + 1 // 若相同，移至 s 的下一個字元  \n    → j = j + 1 // 移動到 t 的下一個字元  \n→ Decision: i == len(s)? // 判斷是否已經匹配完 s 的全部字元  \n    Yes → Step 3: Return true // s 完全為 t 的子序列  \n    No → Step 4: Return false // 未匹配完，故非子序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        \"\"\"Return True if s is a subsequence of t, else False.\"\"\"\n        if not s:  # empty string is always a subsequence\n            return True\n        idx = 0\n        for char in t:\n            if char == s[idx]:\n                idx += 1\n                if idx == len(s):\n                    return True\n        return False\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input string to extract s and t.\n    Supports formats:\n      - s = \"abc\", t = \"ahbgdc\"\n      - s = \"abc\"\n        t = \"ahbgdc\"\n    \"\"\"\n    # Try to find two quoted strings separated by comma\n    m = re.search(r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*t\\s*=\\s*\"([^\"]*)\"', data)\n    if m:\n        return m.group(1), m.group(2)\n\n    # Fallback: each line contains one assignment\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    s = t = \"\"\n    for line in lines:\n        if line.lower().startswith('s'):\n            m = re.search(r's\\s*=\\s*\"([^\"]*)\"', line, re.IGNORECASE)\n            if m:\n                s = m.group(1)\n        elif line.lower().startswith('t'):\n            m = re.search(r't\\s*=\\s*\"([^\"]*)\"', line, re.IGNORECASE)\n            if m:\n                t = m.group(1)\n    return s, t\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    s, t = parse_input(data)\n    sol = Solution()\n    result = sol.isSubsequence(s, t)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\", t = \"ahbgdc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"axc\", t = \"ahbgdc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode91.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways",
    "description_snippet": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code for decoding problem, similar to Leetcode 91. We output line by line with comments. Use virtual code syntax as per guidelines: Start, End, Decision. Provide steps: input string s, if empty return 0? Actually if s empty, return 0? Problem typically says non-empty. We'll include check.\n\nWe'll create DP array, iterate over string, for each position i compute ways. Use DP[0]=1 base. For each i from 1 to n: if s[i-1] != '0', dp[i] += dp[i-1]. If i>=2 and substring s[i-2:i] between 10 and 26 inclusive, dp[i] += dp[i-2]. After loop return dp[n].\n\nLet's produce pseudo code lines accordingly with explanation comments. Use arrow syntax. We'll include variable names: n, dp, i, substring. Use string indexing.\n\nWe must not output actual code. Just pseudo. Provide lines with explanation. Use \"Decision:\" for if statements. Provide \"Yes →\" etc. Let's craft.\n\nWe'll produce:\n\nStart // 程式開始\n\n→ Step 1: n ← length(s) // 取得輸入字串長度\n\n→ Decision: If n == 0? // 檢查字串是否為空\n\n    Yes → Step 2: Return 0 // 空字串無合法解碼\n\n    No  →\n\n→ Step 3: dp ← array of size n+1 // 動態規劃陣列\n\n→ Step 4: dp[0] ← 1 // 空前綴字串的解碼方式為1\n\n→ Decision: If s[0] == '0'? // 首位為0無合法解碼\n\n    Yes → Step 5: Return 0\n\n    No  →\n\n→ Step 6: dp[1] ← 1 // 首位非0，單字解碼一種方式\n\n→ Step 7: For i ← 2 to n // 逐字處理剩餘位置\n\n        → Decision: If s[i-1] != '0'? // 單字解碼合法\n\n            Yes → Step 8: dp[i] ← dp[i] + dp[i-1] // 加上單字方式\n\n            No  → Step 8: dp[i] ← dp[i] + 0 // 不變（可省略）\n\n        → Decision: If s[i-2] != '0' AND 10 ≤ int(s[i-2:i]) ≤ 26? // 兩字組合法\n\n            Yes → Step 9: dp[i] ← dp[i] + dp[i-2] // 加上雙字方式\n\n            No  → Step 9: dp[i] ← dp[i] + 0 // 不變\n\n    End For // 完成循環\n\n→ Step 10: Return dp[n] // 最終解碼方式數\n\nEnd // 程式結束\n\nBut we need to output each line with \"虛擬碼步驟\" + space + \"// 解釋\". Use \"→\" for next step. Should show indentation. Use \"Decision:\" lines as per example. Provide arrows inside decisions: \"Yes →\" etc. We need to include \"Step\" prefix.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: n ← length(s) // 取得輸入字串長度  \n→ Decision: 如果 n 為 0? // 檢查字串是否為空  \n  Yes → Step 2: Return 0 // 空字串無合法解碼  \n  No  →  \n→ Step 3: dp ← array of size n+1 // 建立動態規劃陣列  \n→ Step 4: dp[0] ← 1 // 空前綴字串的解碼方式為 1  \n→ Decision: 如果 s[0] 為 '0'? // 首位為 0 時無合法解碼  \n  Yes → Step 5: Return 0  \n  No  →  \n→ Step 6: dp[1] ← 1 // 首位非 0，單字解碼有 1 種方式  \n→ Step 7: For i ← 2 to n // 逐字處理剩餘位置  \n  → Decision: 如果 s[i-1] ≠ '0'? // 單字解碼合法  \n    Yes → Step 8: dp[i] ← dp[i] + dp[i-1] // 加上單字方式  \n    No  → Step 8: dp[i] ← dp[i] // 無變化（可省略）  \n  → Decision: 如果 s[i-2] ≠ '0' 且 10 ≤ int(s[i-2:i]) ≤ 26? // 兩字組合法  \n    Yes → Step 9: dp[i] ← dp[i] + dp[i-2] // 加上雙字方式  \n    No  → Step 9: dp[i] ← dp[i] // 無變化  \n  End For // 完成循環  \n→ Step 10: Return dp[n] // 最終解碼方式數  \nEnd // 程式結束",
      "generated_code": "import sys\n\ndef num_decodings(s: str) -> int:\n    \"\"\"Return the number of ways to decode the digit string s.\"\"\"\n    if not s or s[0] == '0':\n        return 0\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1           # 空前綴字串的解碼方式\n    dp[1] = 1           # 首位非 0，單字解碼有 1 種方式\n    for i in range(2, n + 1):\n        # 單字解碼\n        if s[i - 1] != '0':\n            dp[i] += dp[i - 1]\n        # 雙字解碼\n        two_digit = int(s[i - 2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有字元，抽取其中的數字\n    data = sys.stdin.read()\n    s = ''.join(ch for ch in data if ch.isdigit())\n    print(num_decodings(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"12\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"226\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"06\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode649.json",
    "problem_index_in_file": 0,
    "title": "Dota2 Senate",
    "description_snippet": "In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudo-code step by step. Problem: similar to \"Dota2 Senate\" from Leetcode. Need algorithm: use queue for each party. Count remaining, ban. We need pseudo-code lines with arrows. Let's craft steps.\n\nWe need to output only the virtual code lines and explanations.\n\nWe must not output actual code. Just pseudo steps.\n\nLet's design:\n\nStart\n→ Initialize two queues RQueue and DQueue with indices of R and D senators\n→ Initialize remainingR = count of R, remainingD = count of D\n→ While remainingR > 0 AND remainingD > 0\n    → Decision: is RQueue front index < DQueue front index?\n        Yes → Step: R senator bans D senator\n            → Remove front of DQueue\n            → Decrement remainingD\n            → Enqueue new index for R senator: frontIndex + n\n            → Remove front of RQueue\n            → Increment remainingR? Actually remainingR stays same? Wait: after ban, R senator still active; remainingR unchanged; but we enqueue new index to continue cycle.\n        No  → Step: D senator bans R senator\n            → Remove front of RQueue\n            → Decrement remainingR\n            → Enqueue new index for D senator: frontIndex + n\n            → Remove front of DQueue\n→ Decision: if remainingR > 0? // only Radiant remains\n    Yes → End // Radiant wins\n    No  → End // Dire wins\n\nNeed to mention that n = length of senate string.\n\nAlso need to handle initial indices.\n\nWe must include comments in Chinese.\n\nLet's produce line by line.\n\nWe should include indentation? The format example uses indentation for Decision branches. We'll follow.\n\nLet's produce.\n\nNote: Use `Start` and `End`. Use `Decision:` etc.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n ← senate 字串長度 // 取得參賽者總數  \n→ Step 2: 建立兩個隊列 RQueue, DQueue // 分別儲存 Radiant 與 Dire 參賽者的索引  \n→ Step 3: 遍歷 senate，若 senate[i] 為 'R' 則 enqueue i 至 RQueue，否則 enqueue i 至 DQueue // 初始化兩個隊列  \n→ Step 4: 設定 remainingR ← RQueue 大小 // Radiant 仍有權力的人數  \n→ Step 5: 設定 remainingD ← DQueue 大小 // Dire 仍有權力的人數  \n→ Decision: 當 remainingR > 0 且 remainingD > 0 時 // 仍有兩方同時活躍  \n    → Step 6: 判斷 RQueue 前端索引 < DQueue 前端索引？ // 哪個參賽者先行  \n        Yes → Step 7: Radiant 參賽者 bans Dire 參賽者  \n            → Step 7a: 取出 DQueue 前端索引 dIdx  \n            → Step 7b: decrement remainingD // Dire 失去一名參賽者  \n            → Step 7c: 將 RQueue 前端索引 rIdx + n enqueue 回 RQueue // Radiant 參賽者在下一輪再次參與  \n            → Step 7d: 移除 RQueue 前端索引 rIdx // 已處理完成  \n        No  → Step 8: Dire 參賽者 bans Radiant 參賽者  \n            → Step 8a: 取出 RQueue 前端索引 rIdx  \n            → Step 8b: decrement remainingR // Radiant 失去一名參賽者  \n            → Step 8c: 將 DQueue 前端索引 dIdx + n enqueue 回 DQueue // Dire 參賽者在下一輪再次參與  \n            → Step 8d: 移除 DQueue 前端索引 dIdx // 已處理完成  \n→ Decision: 若 remainingR > 0？ // Radiant 是否仍有參賽者  \n    Yes → Step 9: 輸出 \"Radiant\" // Radiant 宣布勝利  \n    No  → Step 10: 輸出 \"Dire\" // Dire 宣布勝利  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import deque\n\ndef predict_party_victory(senate: str) -> str:\n    n = len(senate)\n    radiant = deque()\n    dire = deque()\n    for i, s in enumerate(senate):\n        if s == 'R':\n            radiant.append(i)\n        else:\n            dire.append(i)\n    while radiant and dire:\n        r_index = radiant.popleft()\n        d_index = dire.popleft()\n        if r_index < d_index:\n            radiant.append(r_index + n)\n        else:\n            dire.append(d_index + n)\n    return \"Radiant\" if radiant else \"Dire\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the senate string from input like: senate = \"RD\"\n    if '\"' in data:\n        start = data.find('\"')\n        end = data.rfind('\"')\n        senate_str = data[start+1:end]\n    elif \"'\" in data:\n        start = data.find(\"'\")\n        end = data.rfind(\"'\")\n        senate_str = data[start+1:end]\n    else:\n        senate_str = data.replace(\" \", \"\").replace(\"\\n\", \"\")\n    result = predict_party_victory(senate_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "senate = \"RD\"",
          "expected_output": "\"Radiant\"",
          "success": true,
          "output": "Radiant"
        },
        {
          "example_index": 1,
          "input": "senate = \"RDD\"",
          "expected_output": "\"Dire\"",
          "success": true,
          "output": "Dire"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode523.json",
    "problem_index_in_file": 0,
    "title": "Continuous Subarray Sum",
    "description_snippet": "Given an integer array nums and an integer k, return true if nums has a good subarray or false other...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: Given array nums and integer k, return true if any subarray of length>=2 has sum multiple of k. Standard algorithm uses prefix sums mod k and map of first index of each mod. Iterate, compute prefix sum mod k, check if mod seen before and length>=2 (i - firstIndex >= 2). Special case k=0: need subarray of length>=2 with sum zero. We can handle by checking any adjacent pair sums to zero? Actually for k=0, we need subarray sum = 0, so we can use map of cumulative sum. We can use prefix sums and look for same sum again with distance >=2.\n\nWe'll produce virtual code lines accordingly. Use steps: Start, Step 1: initialize map, Step 2: iterate over array computing prefix sum and mod, Step 3: decision: if mod in map and index - map[mod] >= 2 return true. Step 4: if not, store first occurrence. After loop, return false. For k=0, handle separately: use prefix sums and check same sum difference >=2. We'll add if k == 0 branch at start.\n\nWe'll produce lines. Use virtual code syntax: `Start`, `→ Step 1`, etc. Include decisions.\n\nMake sure each line has `虛擬碼步驟` and comment. We'll output in Traditional Chinese.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 k 等於 0? // 判斷特殊情況  \n    Yes → Step 1: 初始化 mapSum ← {} // 以累加和作為鍵，存放首次出現的索引  \n    → Step 2: 設定 prefixSum ← 0  \n    → Step 3: 從 i = 0 到 nums.length - 1 迴圈  \n        → Step 4: prefixSum ← prefixSum + nums[i] // 更新累加和  \n        → Decision: 如果 prefixSum 在 mapSum 中且 i - mapSum[prefixSum] >= 2? // 相同和且距離至少 2  \n            Yes → Step 5: Return true // 找到符合條件的子陣列  \n            No  → Decision: 如果 prefixSum 不在 mapSum 中? // 第一次出現此累加和  \n                Yes → Step 6: mapSum[prefixSum] ← i // 記錄索引  \n                No  → Step 7: 跳過 (已記錄)  \n    → Step 8: Return false // 迴圈結束仍未找到  \n    End // 完成 k=0 的處理  \n    No → Step 9: 初始化 mapMod ← {} // 存放餘數第一次出現的索引  \n    → Step 10: 設定 prefixSum ← 0  \n    → Step 11: 從 i = 0 到 nums.length - 1 迴圈  \n        → Step 12: prefixSum ← prefixSum + nums[i] // 更新累加和  \n        → Step 13: 計算 mod ← ((prefixSum % k) + k) % k // 取正餘數避免負數  \n        → Decision: 如果 mod 在 mapMod 中且 i - mapMod[mod] >= 2? // 相同餘數且距離至少 2  \n            Yes → Step 14: Return true // 找到符合條件的子陣列  \n            No  → Decision: 如果 mod 不在 mapMod 中? // 第一次出現此餘數  \n                Yes → Step 15: mapMod[mod] ← i // 記錄索引  \n                No  → Step 16: 跳過 (已記錄)  \n    → Step 17: Return false // 迴圈結束仍未找到  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkSubarraySum(self, nums, k):\n        # map from remainder to earliest index\n        mod_map = {0: -1}\n        total = 0\n        for i, num in enumerate(nums):\n            total += num\n            if k != 0:\n                total %= k\n            if total in mod_map:\n                if i - mod_map[total] > 1:  # length at least 2\n                    return True\n            else:\n                mod_map[total] = i\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 找到第一個 ']'，其前面是陣列字串\n    idx = data.find(']')\n    array_str = data[:idx+1]\n    k_str = data[idx+2:].strip()  # 跳過 '],'\n    nums = ast.literal_eval(array_str)\n    k = int(k_str)\n    sol = Solution()\n    result = sol.checkSubarraySum(nums, k)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[23,2,4,6,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "[23,2,6,4,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "[23,2,6,4,7], 13",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode41.json",
    "problem_index_in_file": 0,
    "title": "First Missing Positive",
    "description_snippet": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for algorithm to find smallest missing positive integer in O(n) time and O(1) space. That's classic \"first missing positive\" problem. Steps: first reorder array by placing each number in its correct index if possible, using cycle sort. Then iterate to find first index where value != index+1. Return index+1. Edge: if all positions correct, return n+1.\n\nWe need to produce virtual code lines with \"Start\", \"→ Step: ...\", \"Decision: ...\", etc. Provide explanation after each line.\n\nWe'll generate virtual code lines with arrow and step description. Provide explanation in Chinese.\n\nLet's outline:\n\nStart\n→ Step 1: n = length(nums) // get array size\n→ Decision: 是否有元素? Yes/No -> if No, return 1 (since no positive)\n→ Step 2: For i from 0 to n-1 // iterate each element\n    → Decision: 如果 nums[i] 在 [1,n] 且 nums[i] != nums[nums[i]-1]?\n        Yes → Step 3: Swap nums[i] 與 nums[nums[i]-1] // put number in correct position\n        No → continue next i\n→ Step 4: For i from 0 to n-1\n    → Decision: nums[i] != i+1 ?\n        Yes → Step 5: Return i+1 // first missing positive\n→ Step 6: Return n+1 // all positions filled\n\nBut we need to produce \"Step\" lines in order. We might combine loops into steps but each loop iteration may be represented as step. But we should provide conceptual steps, not each iteration. But we need to represent loops as \"For i in 0..n-1: ...\". Might use \"Step: For i in 0 to n-1\" and then nested decisions.\n\nUse virtual code arrows: \"→\" for each step, indent for nested steps. Also Decision lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: n = length(nums) // 取得陣列長度\n→ Decision: n == 0? // 判斷陣列是否為空\n    Yes → Step 2: Return 1 // 空陣列最小正整數為 1\n    No  →  // 繼續執行\n→ Step 3: For i = 0 to n-1 // 遍歷每個元素\n    → Decision: nums[i] 在 [1, n] 且 nums[i] != nums[nums[i]-1]? // 檢查是否可以移到正確位置\n        Yes → Step 4: Swap(nums[i], nums[nums[i]-1]) // 交換至正確索引\n        No  → // 不需要交換，繼續下一個 i\n→ Step 5: For i = 0 to n-1 // 再次遍歷檢查缺失值\n    → Decision: nums[i] != i+1? // 判斷是否為正確位置\n        Yes → Step 6: Return i+1 // 找到最小缺失正整數\n        No  → // 繼續下一個 i\n→ Step 7: Return n+1 // 若所有位置都正確，缺失值為 n+1\nEnd // 程式執行結束\n\nNeed to include explanations after each line.\n\nAlso note \"Swap\" line. Provide explanation \"交換兩個位置的值\".\n\nMake sure each line has \"虛擬碼步驟\" and explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length(nums) // 取得陣列長度  \n→ Decision: n == 0? // 判斷陣列是否為空  \n  Yes → Step 2: Return 1 // 空陣列最小正整數為 1  \n  No  →  // 繼續執行  \n→ Step 3: For i = 0 to n-1 // 遍歷每個元素  \n  → Decision: nums[i] 在 [1, n] 且 nums[i] != nums[nums[i]-1]? // 檢查是否可以移到正確位置  \n   Yes → Step 4: Swap(nums[i], nums[nums[i]-1]) // 交換至正確索引  \n   No  → // 不需要交換，繼續下一個 i  \n→ Step 5: For i = 0 to n-1 // 再次遍歷檢查缺失值  \n  → Decision: nums[i] != i+1? // 判斷是否為正確位置  \n   Yes → Step 6: Return i+1 // 找到最小缺失正整數  \n   No  → // 繼續下一個 i  \n→ Step 7: Return n+1 // 若所有位置都正確，缺失值為 n+1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        Find the smallest positive integer that does not appear in the array.\n        The algorithm runs in O(n) time and uses O(1) extra space.\n        \"\"\"\n        n = len(nums)\n        # Place each number in its right position if possible\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                # swap nums[i] with nums[nums[i]-1]\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n        # The first index where the number is wrong is the missing positive\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n\n        # All positions correct; missing number is n + 1\n        return n + 1\n\ndef parse_input(raw):\n    \"\"\"\n    Parse the input string to extract the list of integers.\n    Supports formats like:\n        nums = [1, 2, 0]\n        [1, 2, 0]\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return []\n\n    # If the input contains an '=' sign, take the part after it\n    if '=' in raw:\n        raw = raw.split('=', 1)[1].strip()\n\n    try:\n        # Use ast.literal_eval for safety\n        return ast.literal_eval(raw)\n    except Exception:\n        # If parsing fails, return empty list\n        return []\n\nif __name__ == \"__main__\":\n    # Read all data from stdin\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    result = Solution().firstMissingPositive(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,0]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [3,4,-1,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [7,8,9,11,12]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode551.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record I",
    "description_snippet": "You are given a string s representing an attendance record for a student where each character signif...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese, line by line, with arrow syntax. Use Start, End, Decision. Provide explanation. No actual code. Just steps. Use 虛擬碼步驟. Provide explanation after space. Each line like \"Start // 程式開始執行\". Use arrow \"→ Step\". Need to include decisions. Let's design algorithm:\n\n- Input s string.\n- Initialize absentCount = 0\n- Initialize consecutiveLate = 0\n- For each char in s:\n    - if char == 'A': absentCount += 1\n    - if char == 'L': consecutiveLate += 1; if consecutiveLate >= 3: return false\n    - else (char == 'P'): consecutiveLate = 0\n- After loop: if absentCount < 2: return true else false.\n\nIn virtual code: need loops. Represent loop: \"→ Loop over each character in s // 遍歷字串中的每個字符\". Inside: decision for char. Use nested decisions. Might need to check 'L' consecutive.\n\nUse \"Decision: 是否為 'A'?\". Then if yes increment. Else Decision: 是否為 'L'? Then if yes, inc consecutiveLate, check >=3; else (P) reset consecutiveLate.\n\nAfter loop: Decision: 是否缺席 < 2? If yes, return true else false.\n\nNeed to represent return true/false. Use \"→ Step: Return true\". Or \"→ Step: Return false\". Use arrows.\n\nAlso we might need to break early when consecutiveLate >=3. Use Decision inside loop: if consecutiveLate >= 3: return false. So we need a step: \"Decision: consecutiveLate >= 3? // 判斷連續遲到是否達到3天\". If Yes -> return false.\n\nImplement accordingly.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step: 輸入字串 s // 取得出勤記錄\n→ Step: 初始化 absentCount ← 0 // 記錄缺席天數\n→ Step: 初始化 consecutiveLate ← 0 // 記錄連續遲到天數\n→ Loop: 遍歷 s 中的每個字符 // 處理每一天的出勤狀態\n    → Decision: 字符為 'A'? // 檢查是否缺席\n        Yes → Step: absentCount ← absentCount + 1 // 增加缺席計數\n        No  → Decision: 字符為 'L'? // 檢查是否遲到\n            Yes → Step: consecutiveLate ← consecutiveLate + 1 // 增加連續遲到計數\n                → Decision: consecutiveLate ≥ 3? // 判斷是否達到三天遲到\n                    Yes → Step: Return false // 不符合獎勵條件，提前結束\n                    No  → Step: 繼續循環 // 繼續檢查下一個字符\n            No  → Step: consecutiveLate ← 0 // 重置連續遲到計數，因為是正點\n→ Decision: absentCount < 2? // 最後檢查缺席天數是否少於2天\n    Yes → Step: Return true // 滿足所有條件，符合獎勵\n    No  → Step: Return false // 缺席天數不符合條件\nEnd // 程式執行結束\n\nCheck format: each line \"→\" for steps, decisions. Need indentation maybe. It's fine.\n\nAlso we might want \"Loop:\" line with arrow. Provide explanation. Use \"→ Loop: 遍歷\". That is okay.\n\nWe must ensure no actual code, just virtual steps. Use \"←\" assignment arrow. Use \"→\" for steps. Use \"Decision:\" lines. Use \"Yes →\" and \"No →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 輸入字串 s // 取得出勤記錄  \n→ Step: 初始化 absentCount ← 0 // 記錄缺席天數  \n→ Step: 初始化 consecutiveLate ← 0 // 記錄連續遲到天數  \n→ Loop: 遍歷 s 中的每個字符 // 處理每一天的出勤狀態  \n → Decision: 字符為 'A'? // 檢查是否缺席  \n  Yes → Step: absentCount ← absentCount + 1 // 增加缺席計數  \n  No → Decision: 字符為 'L'? // 檢查是否遲到  \n   Yes → Step: consecutiveLate ← consecutiveLate + 1 // 增加連續遲到計數  \n    → Decision: consecutiveLate ≥ 3? // 判斷是否達到三天遲到  \n     Yes → Step: Return false // 不符合獎勵條件，提前結束  \n     No → Step: 繼續循環 // 繼續檢查下一個字符  \n   No → Step: consecutiveLate ← 0 // 重置連續遲到計數，因為是正點  \n→ Decision: absentCount < 2? // 最後檢查缺席天數是否少於2天  \n Yes → Step: Return true // 滿足所有條件，符合獎勵  \n No → Step: Return false // 缺席天數不符合條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        \"\"\"\n        判斷學生是否符合獎勵條件：\n        1. 缺席天數 < 2\n        2. 連續遲到天數不等於 3\n        \"\"\"\n        return s.count('A') <= 1 and 'LLL' not in s\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料，去除可能的引號與空白\n    raw_input = sys.stdin.read().strip()\n    s = raw_input.strip('\"').strip(\"'\")\n    \n    solution = Solution()\n    result = solution.checkRecord(s)\n    \n    # 按題目要求輸出 'true' 或 'false'\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"PPALLP\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"PPALLL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode26.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step with explanations. Problem: remove duplicates from sorted array in-place, return k. Standard two-pointer approach. We'll produce steps: initialize slow=0, iterate fast from 1 to n-1, if nums[fast]!=nums[slow], increment slow, set nums[slow]=nums[fast]. After loop, k=slow+1. Return k.\n\nWe need to produce each line of virtual code with explanation. Use Start, End, Decision, etc. We must not output actual code. Use arrows. Let's produce.\n\nWe might include steps:\n\nStart // Start of algorithm\n→ Step 1: n ← length(nums) // Get array length\n→ Decision: If n == 0? // Edge case empty array\n    Yes → Step 2: Return 0 // No elements, unique count 0\n    No → Continue\n→ Step 3: slow ← 0 // Index of last unique element\n→ Step 4: For fast from 1 to n-1 // Iterate through array\n    → Decision: If nums[fast] != nums[slow]?\n        Yes → slow ← slow + 1 // Move slow pointer\n               nums[slow] ← nums[fast] // Place new unique\n        No → // Do nothing, duplicate\n→ Step 5: k ← slow + 1 // Total unique count\n→ Step 6: Return k // Return count\nEnd // End of algorithm\n\nNeed to include explanations per line. We'll follow format: each line: \"虛擬碼步驟 // 解釋\". Ensure each line separate. Use arrow as per format. Provide step numbering. Let's craft.\n\nAlso we need to use arrow for each step: \"→ Step X: ...\". Use Decision: with Yes/No lines indented.\n\nWe must keep each line separate, no actual code.\n\nLet's craft output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: n == 0? // 檢查陣列是否為空  \n  Yes → Step 2: Return 0 // 空陣列無重複項，回傳 0  \n  No  → // 繼續執行  \n→ Step 3: slow ← 0 // slow 指標指向目前唯一元素的最後一個位置  \n→ Step 4: For fast from 1 to n-1 // 逐一檢查剩餘元素  \n  → Decision: nums[fast] ≠ nums[slow]? // 新元素是否不等於現有唯一元素  \n    Yes → slow ← slow + 1 // 移動 slow 指標  \n     nums[slow] ← nums[fast] // 把新的唯一元素放到 slow 的位置  \n    No  → // duplicate，忽略  \n→ Step 5: k ← slow + 1 // k 為唯一元素的個數  \n→ Step 6: Return k // 回傳唯一元素數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef removeDuplicates(nums):\n    \"\"\"移除已排序陣列中的重複元素，回傳唯一元素數量 k。\n    nums 在原地被修改，前 k 個位置為唯一元素。\n    \"\"\"\n    if not nums:\n        return 0\n\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1\n\ndef main():\n    \"\"\"從標準輸入讀取陣列，執行移除重複，輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中抽取列表\n    lbracket = data.find('[')\n    rbracket = data.rfind(']')\n    if lbracket != -1 and rbracket != -1:\n        nums = ast.literal_eval(data[lbracket:rbracket+1])\n    else:\n        # 若輸入已是純列表表達式\n        nums = ast.literal_eval(data)\n\n    k = removeDuplicates(nums)\n\n    # 產生輸出字串，後面用 '_' 佔位\n    elements = [str(nums[i]) for i in range(k)]\n    elements.extend(['_'] * (len(nums) - k))\n    out_list = '[' + ','.join(elements) + ']'\n    print(f\"{k}, nums = {out_list}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "success": true,
          "output": "2, nums = [1,2,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "success": true,
          "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode414.json",
    "problem_index_in_file": 0,
    "title": "Third Maximum Number",
    "description_snippet": "Given an integer array nums, return the third distinct maximum number in this array. If the third ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step according to the description: return third distinct maximum in an array; if not exist return maximum.\n\nWe need to produce each line: virtual code step + space + // explanation. Use arrow \"→\" and decisions.\n\nWe must not output actual code.\n\nWe need to cover the logic: iterate array, maintain first, second, third max distinct values; handle duplicates. At the end check if third exists.\n\nSo we produce virtual code steps:\n\nStart\n→ Step 1: 初始化 first, second, third 為 null // 將三個最大值設為空\n→ Step 2: 對 nums 中每個 num 做迴圈 // 遍歷整個陣列\n    → Decision: 是否已經存在第一個最大值? // 判斷 first 是否為空\n        Yes → Step 3: 如果 first 是 null 或 num > first, then update\n            → Step 4: 更新 first, second, third // shift values\n            → Step 5: 繼續下一個 num // continue loop\n        No → Step 6: If num != first and (second is null or num > second)\n            → Step 7: 更新 second, third\n            → Step 8: 繼續下一個 num\n        ...\nBut need to maintain distinctness. We'll do logic: if num equals any of first, second, third skip.\n\nSimpler: maintain set of distinct values, add num; keep only top 3 sorted; but virtual code not actual.\n\nWe can propose: Use a set to track distinct values; then after loop find third max.\n\nBut to avoid complexity, we can illustrate algorithm:\n\n- Use a set to keep distinct numbers\n- After loop, if set size < 3 return max of set\n- else return third largest\n\nWe'll produce steps accordingly.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化空集合 distinctSet // 用來儲存不同的數字\n→ Step 2: 對 nums 中每個 num 做迴圈 // 遍歷每個數字\n    → Step 3: 把 num 加入 distinctSet // 只儲存不重複的值\n→ Step 4: 如果 distinctSet 的大小小於 3\n    → Step 5: 返回 distinctSet 的最大值 // 沒有第三個最大值時返回最大\n    → End\n→ Step 6: 將 distinctSet 轉為可排序的集合 sortedSet 並遞增排序 // 方便取得第三個最大\n→ Step 7: 取得 sortedSet 的倒數第三個元素 // 第三大的數\n→ Step 8: 返回該元素 // 結果\nEnd\n\nBut we must include decision arrows.\n\nLet's adjust: Use Decision block after Step 4. So:\n\nStart\n→ Step 1: 初始化 distinctSet 為空集合 // 存放不重複數字\n→ Step 2: 對 nums 中每個 num 進行迴圈 // 遍歷陣列\n    → Step 3: 加入 num 至 distinctSet // 集合自動去重\n→ Step 4: Decision: distinctSet 大小是否小於 3? // 判斷是否缺少第三個最大值\n    Yes → Step 5: 返回 distinctSet 的最大值 // 若不足三個，回傳最大\n    No  → Step 6: 將 distinctSet 排序至 sortedList // 由小到大\n        → Step 7: 返回 sortedList[ sortedList.size - 3 ] // 第三大的數\nEnd\n\nWe also need to show arrow for Yes and No.\n\nThus final output should include each line with virtual code + // explanation.\n\nWe should ensure each line starts with \"Start\" or \"→\" and \"Decision:\" etc. Use arrow accordingly.\n\nLet's format exactly as requested.\n\nWe need to use 虛擬碼步驟 + space + // 解釋/說明.\n\nWe will not include actual code.\n\nWe'll output lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 distinctSet 為空集合 // 用來儲存所有不重複的數字\n→ Step 2: 對 nums 中每個 num 進行迴圈 // 遍歷整個陣列\n    → Step 3: 將 num 加入 distinctSet // 集合會自動忽略重複項\n→ Decision: distinctSet 的大小小於 3? // 判斷是否缺少第三個最大值\n    Yes → Step 4: 返回 distinctSet 的最大值 // 若不足三個，回傳最大值\n    No  → Step 5: 將 distinctSet 轉為有序列表 sortedList // 由小到大排序\n        → Step 6: 返回 sortedList[ sortedList.size - 3 ] // 第三大的數\nEnd // 程式執行結束\n\nWe need to ensure indentation is correct: lines after decision have indentation and arrows. Use arrow for each.\n\nWe need to ensure each line is separate. Should we include \"Decision:\" line with arrow? Yes.\n\nWe should use \"Decision:\" block: \"Decision: ...\" then indent lines for Yes and No.\n\nThus final answer.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 distinctSet 為空集合 // 用來儲存所有不重複的數字  \n→ Step 2: 對 nums 中每個 num 進行迴圈 // 遍歷整個陣列  \n  → Step 3: 將 num 加入 distinctSet // 集合會自動忽略重複項  \n→ Decision: distinctSet 的大小小於 3? // 判斷是否缺少第三個最大值  \n  Yes → Step 4: 返回 distinctSet 的最大值 // 若不足三個，回傳最大值  \n  No → Step 5: 將 distinctSet 轉為有序列表 sortedList // 由小到大排序  \n    → Step 6: 返回 sortedList[ sortedList.size - 3 ] // 第三大的數  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def thirdMax(self, nums):\n        first = second = third = float('-inf')\n        nums_set = set(nums)\n        for num in nums_set:\n            if num > first:\n                third = second\n                second = first\n                first = num\n            elif num > second:\n                third = second\n                second = num\n            elif num > third:\n                third = num\n        return third if len(nums_set) >= 3 else first\n\ndef main():\n    import sys\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入格式，如 \"nums = [1,2,3]\"\n    if '=' in data:\n        _, nums_part = data.split('=', 1)\n        nums_part = nums_part.strip()\n    else:\n        nums_part = data.strip()\n    try:\n        import ast\n        nums = ast.literal_eval(nums_part)\n    except Exception:\n        nums = eval(nums_part, {\"__builtins__\": None}, {})\n    sol = Solution()\n    result = sol.thirdMax(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,2,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode639.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways II",
    "description_snippet": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n'A' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solution: counting decodings with '*' wildcard. This is Leetcode 639. We'll produce pseudocode lines with explanation. Provide step by step DP. Use mod 1e9+7. Steps: initialize dp0=1, dp1 based on first char. Then iterate over string. For each char, compute ways1 (single char) and ways2 (two char). Use helper functions for counts. Provide pseudo logic. Let's produce virtual code lines.\n\nWe need \"逐行\" lines: Start, Step 1 etc. Provide explanation.\n\nLet's craft.\n\nStart // 程式開始\n\n→ Step 1: 定義 MOD = 1e9+7 // 模數\n\n→ Step 2: 初始化 dp_prev2 = 1 // dp[i-2] (empty string)\n→ Step 3: 根據 s[0] 計算 dp_prev1 // dp[1]，取決於第一個字符\n    Yes → Step 4: 如果 s[0] == '*' → dp_prev1 = 9 // 1~9\n    No  → Decision: 如果 s[0] == '0'? // 無法解碼\n        Yes → Step 5: dp_prev1 = 0\n        No  → Step 6: dp_prev1 = 1 // 單個有效數字\n\n→ Step 7: 迭代 i from 1 to len(s)-1 // 處理剩餘字符\n    → Decision: 如果 i == 1? // 只需一個迴圈\n        No → continue\n\nBut better structure: for i in range(1, n):\n\nInside loop compute ways_single, ways_double.\n\nDefine helper function countSingle(c): if c=='*':9 else if c=='0':0 else 1\n\nDefine helper function countDouble(c1,c2):\n\n- If c1=='*' and c2=='*': 15 // 11-19(9) + 21-26(6)\n- If c1=='*' and c2!='*': if c2 in '0'-'6': 2 else if c2 in '7'-'9':1\n- If c1!='*' and c2=='*': if c1=='1':9 else if c1=='2':6 else 0\n- Else: check if int(c1c2) between 10 and 26 inclusive ->1 else 0\n\nWe'll produce that.\n\nAfter computing ways, dp_curr = (ways_single*dp_prev1 + ways_double*dp_prev2)%MOD\n\nUpdate dp_prev2=dp_prev1; dp_prev1=dp_curr\n\nAfter loop return dp_prev1\n\nLet's produce each line.\n\nNeed to use 虛擬碼箭頭. Let's follow pattern.\n\nWe'll produce lines with indentation for decisions.\n\nLet's craft.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: MOD ← 1000000007 // 定義模數\n→ Step 2: n ← length(s) // 取得字串長度\n→ Step 3: dpPrev2 ← 1 // dp[i-2]，對空字串為 1\n→ Decision: n == 0? // 空字串的解碼方式\n    Yes → End // 回傳 1\n    No  → // 繼續執行\n→ Step 4: // 計算第一個字符的單字節解碼方式\n    Decision: s[0] == '*'? // '*' 可以代表 1~9\n        Yes → dpPrev1 ← 9\n        No  → Decision: s[0] == '0'? // '0' 沒有映射\n            Yes → dpPrev1 ← 0\n            No  → dpPrev1 ← 1\n→ Step 5: // 迭代處理後續字符\n    → For i from 1 to n-1\n        → Step 6: c1 ← s[i-1] // 前一個字符\n        → Step 7: c2 ← s[i]   // 當前字符\n        → Step 8: // 計算單字節解碼數\n            Decision: c2 == '*'?\n                Yes → single ← 9\n                No  → Decision: c2 == '0'? // '0' 不能獨立解碼\n                    Yes → single ← 0\n                    No  → single ← 1\n        → Step 9: // 計算雙字節解碼數\n            Decision: c1 == '*' and c2 == '*'? // ** -> 15 種 (11-19,21-26)\n                Yes → double ← 15\n                No  → Decision: c1 == '*'? // 1* 或 2*\n                    Yes → Decision: c2 <= '6'? // 1x 允許 1~6; 2x 允許 1~6\n                        Yes → double ← 2\n                        No  → double ← 1\n                    No  → Decision: c2 == '*'? // *2 或 *3... 等\n                        Yes → double ← 0 // 這種情況不會發生\n                        No  → // c1 != '*', c2 != '*'\n                            Decision: 10 <= int(c1c2) <= 26? // 兩位數有效\n                                Yes → double ← 1\n                                No  → double ← 0\n        → Step 10: // 更新 DP\n            curr ← (single * dpPrev1 + double * dpPrev2) mod MOD\n        → Step 11: dpPrev2 ← dpPrev1 // 移動索引\n        → Step 12: dpPrev1 ← curr\n→ Step 13: End // 程式結束\n    // 回傳最終解碼方式\n    → Return dpPrev1\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        MOD = 10**9 + 7\n        n = len(s)\n        if n == 0:\n            return 0\n        # dp[i] 表示前 i 個字符的解碼方式數量\n        dp0 = 1  # dp[i-2]\n        # 第一個字符\n        if s[0] == '*':\n            dp1 = 9\n        elif s[0] == '0':\n            dp1 = 0\n        else:\n            dp1 = 1\n        for i in range(1, n):\n            c1 = s[i-1]\n            c2 = s[i]\n            # 單字符解碼\n            if c2 == '*':\n                single = 9\n            elif c2 == '0':\n                single = 0\n            else:\n                single = 1\n            # 雙字符解碼\n            if c1 == '*' and c2 == '*':\n                double = 15  # 11-19 (9) + 21-26 (6)\n            elif c1 == '*':\n                double = 2 if c2 <= '6' else 1\n            elif c2 == '*':\n                if c1 == '1':\n                    double = 9\n                elif c1 == '2':\n                    double = 6\n                else:\n                    double = 0\n            else:\n                val = int(c1 + c2)\n                double = 1 if 10 <= val <= 26 else 0\n            curr = (single * dp1 + double * dp0) % MOD\n            dp0, dp1 = dp1, curr\n        return dp1 % MOD\n\ndef parse_input(raw: str) -> str:\n    \"\"\"提取輸入字串，支持 's = \"*\"' 等格式。\"\"\"\n    m = re.search(r'[\"\\'](.*?)[\"\\']', raw)\n    if m:\n        return m.group(1)\n    # 若無引號，直接去除首尾空白與雙單引號\n    return raw.strip().strip('\"\\'')\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    print(Solution().numDecodings(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"*\"",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "s = \"1*\"",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 2,
          "input": "s = \"2*\"",
          "expected_output": "15",
          "success": true,
          "output": "15"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode367.json",
    "problem_index_in_file": 0,
    "title": "Valid Perfect Square",
    "description_snippet": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The user wants to check if a positive integer is a perfect square without sqrt. So we can use binary search or Newton method. Provide steps.\n\nWe should output each line: \"Start // 程式開始執行\" etc. Steps: input num, set left=1, right=num, loop while left<=right: mid=(left+right)/2, product=mid*mid. If product==num return true. If product< num left=mid+1 else right=mid-1. After loop return false.\n\nAlternatively we can use integer math only. Use 64-bit? The steps.\n\nLet's produce virtual code. We must use arrow for each step.\n\nAlso need to show decisions: Decision: product==num? etc.\n\nWe need to not output actual code. Just virtual pseudocode.\n\nWe must be mindful of steps: input variable, start loop, compute mid, compute product, decide etc. Use End.\n\nLet's output lines.\n\nWe need to include \"Yes →\" and \"No →\" inside decisions. Use indentation for nested decisions. Example:\n\nDecision: If left <= right? Yes → ... No → ... etc.\n\nBut we can use a while loop structure: Decision: left <= right? Yes → compute mid. Then inside compute product, decision product == num? Yes → return true, No → decision product < num? Yes → left=mid+1, No → right=mid-1. Then loop back to decision left <= right.\n\nLet's produce that.\n\nLet's ensure each line includes \"虛擬碼步驟\" and comment. For example:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入正整數 num // 取得待檢查的數值\n\n→ Decision: 是否設定 left <= right? // 準備進入搜尋迴圈\n\n    Yes → Step 2: 計算 mid = (left + right) / 2 // 取中點作為試探值\n\n    Step 3: 計算 product = mid * mid // 取得 mid 的平方\n\n    Decision: product == num? // 判斷是否已找到平方根\n\n        Yes → Step 4: 回傳 true // 找到完美平方\n\n        No  → Decision: product < num? // 判斷是否需要往右調整\n\n            Yes → Step 5: left = mid + 1 // 往右移動搜尋範圍\n\n            No  → Step 6: right = mid - 1 // 往左移動搜尋範圍\n\n    // 循環回到 Decision: 是否設定 left <= right?\n\nEnd // 結束程式\n\nBut we need to include the while loop structure.\n\nLet's produce a more formal pseudo: use Decision for left <= right.\n\nAdd after each step.\n\nNeed to include \"Start\" and \"End\".\n\nLet's output each line with arrow or indentation.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 num // 取得待檢查的數值  \n→ Step 2: 設定 left = 1, right = num // 建立搜尋範圍  \n→ Decision: left <= right? // 檢查是否還有搜尋空間  \n Yes → Step 3: mid = (left + right) / 2 // 取中點作為試探值  \n  Step 4: product = mid * mid // 計算 mid 的平方  \n  Decision: product == num? // 判斷是否已找到平方根  \n   Yes → Step 5: 回傳 true // 找到完美平方，結束搜尋  \n   No  → Decision: product < num? // 判斷是否需往右調整搜尋範圍  \n    Yes → Step 6: left = mid + 1 // 往右移動搜尋範圍  \n    No  → Step 7: right = mid - 1 // 往左移動搜尋範圍  \n  // 重新回到 Decision: left <= right?  \n No  → Step 8: 回傳 false // 搜尋完畢仍未找到，非完美平方  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        \"\"\"\n        判斷正整數 num 是否為完美平方。\n        先處理簡單情況，然後使用二分搜尋。\n        \"\"\"\n        if num < 2:           # 0 和 1 本身就是完美平方\n            return True\n\n        left, right = 2, num // 2\n        while left <= right:\n            mid = (left + right) // 2\n            guess = mid * mid\n            if guess == num:          # 找到精確平方根\n                return True\n            elif guess > num:         # 估算值太大，向左搜尋\n                right = mid - 1\n            else:                     # 估算值太小，向右搜尋\n                left = mid + 1\n        return False\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 取出第一個出現的整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    num = int(match.group())\n\n    sol = Solution()\n    result = sol.isPerfectSquare(num)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "num = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode53.json",
    "problem_index_in_file": 0,
    "title": "Maximum Subarray",
    "description_snippet": "Given an integer array nums, find the subarray with the largest sum, and return its sum....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line, with explanation. The algorithm: Kadane's algorithm. Steps: Initialize max_current = max_global = nums[0]; iterate from i=1 to len-1: max_current = max(nums[i], max_current + nums[i]); if max_current > max_global: update; return max_global. Also handle empty array? But assume at least one element. Provide lines with arrow and explanation.\n\nLet's produce:\n\nStart // start\n→ Step 1: If nums is empty → Decision: Return 0? or handle error. But we can just assume not empty.\n\nBetter: We can include Decision to check if empty: Yes → End with 0; No → Continue.\n\nBut requirement: find subarray with largest sum and return sum. For empty array maybe 0.\n\nI'll create.\n\nStart\n→ Step 1: If nums is empty → Decision: If empty? // check array\n    Yes → Step 2: Return 0 // no elements\n    No  → Step 3: Initialize max_current and max_global to nums[0] // set initial values\n→ Step 4: For i from 1 to len(nums)-1 // iterate through array\n    → Step 5: max_current = max(nums[i], max_current + nums[i]) // decide to start new subarray or extend\n    → Decision: If max_current > max_global? // update global max\n        Yes → Step 6: max_global = max_current // update largest sum\n        No  → // do nothing\n→ Step 7: Return max_global // final result\nEnd\n\nBut need format: Use arrow for steps, and Decision: etc. Each line has \"虛擬碼步驟\" + \" // 解釋\".\n\nWe need to output lines exactly with arrow etc.\n\nLet's write:\n\nStart // 程式開始執行\n→ Decision: 如果 nums 為空? // 檢查陣列是否為空\n    Yes → Step 1: 返回 0 // 空陣列直接回傳 0\n    No  → Step 2: 將 max_current 與 max_global 設為 nums[0] // 初始化\n→ Step 3: 從 i = 1 到 nums.length - 1 迭代 // 遍歷陣列\n    → Step 4: max_current = max(nums[i], max_current + nums[i]) // 決定是否從當前元素重新開始\n    → Decision: 如果 max_current > max_global? // 檢查是否更新全域最大\n        Yes → Step 5: max_global = max_current // 更新最大和\n        No  → // 保持原值\n→ Step 6: 返回 max_global // 回傳最大子陣列和\nEnd // 程式執行結束\n\nEnsure each line uses arrow (→). Decision lines indent. Provide explanation after //.\n\nLet's ensure no actual code. Virtual code steps are not actual code but pseudo.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 nums 為空? // 檢查陣列是否為空  \n  Yes → Step 1: 返回 0 // 空陣列直接回傳 0  \n  No  → Step 2: 將 max_current 與 max_global 設為 nums[0] // 初始化  \n→ Step 3: 從 i = 1 到 nums.length - 1 迭代 // 遍歷陣列  \n  → Step 4: max_current = max(nums[i], max_current + nums[i]) // 決定是否從當前元素重新開始  \n  → Decision: 如果 max_current > max_global? // 檢查是否更新全域最大  \n    Yes → Step 5: max_global = max_current // 更新最大和  \n    No  → // 保持原值  \n→ Step 6: 返回 max_global // 回傳最大子陣列和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_subarray(nums):\n    \"\"\"\n    Kadane's algorithm to find the maximum subarray sum.\n    \"\"\"\n    if not nums:\n        return 0\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取數組字串，支持形如 \"nums = [...]\" 或直接 \"[...]\"\n    if '=' in data:\n        nums_str = data.split('=', 1)[1].strip()\n    else:\n        nums_str = data\n    # 使用安全解析方法得到實際列表\n    nums = ast.literal_eval(nums_str)\n    result = max_subarray(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [5,4,-1,7,8]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode14.json",
    "problem_index_in_file": 0,
    "title": "Longest Common Prefix",
    "description_snippet": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. The task: find longest common prefix string among array of strings. If none, return empty string. We need to produce step-by-step pseudo-code with explanations. Format: each line: virtual step + space + // explanation. Use Start, End, Decision:, arrow. Example. Should be line by line. Use arrows → for steps. Use Decision: with Yes → and No →. Provide virtual code for function. So likely:\n\nStart\n→ Step 1: If array empty, return \"\" // check no input\n→ Step 2: Set prefix = first string // use as initial prefix\n→ Step 3: For each string in array starting from second:\n   → Decision: Does current string contain prefix as starting part? // check\n        Yes → continue // nothing\n        No  → Step 4: While prefix not a prefix of current string:\n                 → Decision: prefix length > 0? \n                      Yes → Step 5: Remove last character from prefix // shrink\n                      No  → Step 6: Return \"\" // no common prefix\n           // After while, move to next string\n→ End // return prefix\n\nWe need to produce each step as separate line. Might need to indent sub-steps. Use indentation? Not required but can use nested.\n\nWe'll produce each step as a separate line. Use arrows and Decision. We'll number steps maybe but not necessary. Provide explanation after //.\n\nWe need to output in Traditional Chinese. Use Chinese for explanations. Provide virtual code and explanation. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 是否有輸入字串陣列？ // 檢查陣列是否為空  \n  Yes → Step 1: 設定 prefix 為陣列第一個字串 // 初始共同前綴為第一個字串  \n  No  → Step 2: 回傳 \"\" // 若陣列空則沒有公共前綴  \n→ Step 3: 從陣列第二個字串開始逐個檢查 // 進入比對迴圈  \n  Decision: 目前字串是否以 prefix 為前綴？ // 檢查是否完全符合  \n   Yes → Step 4: 進行下一個字串 // 符合則保持 prefix  \n   No  → Step 5: While 目前字串不以 prefix 為前綴 // 需要縮短 prefix  \n     Decision: prefix 仍有字元？ // 檢查是否可以再縮短  \n      Yes → Step 6: 移除 prefix 最後一個字元 // 逐步縮短  \n      No  → Step 7: 回傳 \"\" // 沒有共同前綴  \n      // loop 重複檢查，直到 prefix 成為前綴或空  \n     // 結束 while 循環  \n     → Step 8: 進行下一個字串 // 繼續比對剩餘字串  \n→ Step 9: 回傳 prefix // 所有字串比對完成，輸出最長公共前綴  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef longest_common_prefix(strs):\n    \"\"\"Return the longest common prefix among all strings in strs.\"\"\"\n    if not strs:          # 若陣列為空，直接回傳空字串\n        return \"\"\n    prefix = strs[0]      # 初始共同前綴設為第一個字串\n    for s in strs[1:]:\n        # 若 s 不是以 prefix 為前綴，逐步縮短 prefix\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]   # 移除最後一個字元\n            if not prefix:         # prefix 已經空了，沒有公共前綴\n                return \"\"\n    return prefix\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"\")\n        return\n\n    # 若輸入以 'strs =' 開頭，移除前置文字\n    if data.startswith(\"strs\"):\n        idx = data.find(\"[\")\n        if idx != -1:\n            data = data[idx:]\n\n    # 解析為 list\n    try:\n        strs = ast.literal_eval(data)\n    except Exception:\n        strs = []\n\n    result = longest_common_prefix(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "expected_output": "\"fl\"",
          "success": true,
          "output": "fl"
        },
        {
          "example_index": 1,
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode72.json",
    "problem_index_in_file": 0,
    "title": "Edit Distance",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of operations required to convert word1...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with arrow and explanation. We need algorithm: edit distance dynamic programming. Steps: Start, input word1 word2, compute n,m, create DP table of size (n+1)x(m+1), initialize first row and col, iterate over i=1..n, j=1..m, compute cost min of delete, insert, replace, set dp[i][j], after loops output dp[n][m], End. Use virtual code syntax with arrows. Provide each line: step description + // explanation. Use indentation? The example shows indentation of decision branches. For loops, just list steps. Need to use virtual code steps with →. Use Decision when checking. So produce something like:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 word1, word2 // 取得兩個字串\n→ Step 2: 計算長度 n = len(word1), m = len(word2) // 取得字串長度\n→ Step 3: 初始化 dp 數組 (n+1)x(m+1) 為 0 // 建立 DP 表\n→ Decision: n 為 0? // 若 word1 為空\n    Yes → Step 4: 將 dp[0][j] = j for j in 0..m // 插入操作\n    No  → Decision: m 為 0? // 若 word2 為空\n        Yes → Step 5: 將 dp[i][0] = i for i in 0..n // 刪除操作\n        No  → Step 6: 進行 DP 填表 // 主迴圈\n...\n\nBut maybe simpler: after initializing, set first row/col straightforwardly, not decisions. Use loops.\n\nWe can just outline: Step 4: For i from 0 to n: dp[i][0] = i // 刪除所有字元\nStep 5: For j from 0 to m: dp[0][j] = j // 插入所有字元\nStep 6: For i 1..n: For j 1..m: compute min. Step 7: Output dp[n][m].\n\nThus produce virtual code lines. Let's format:\n\nStart // 程式開始執行\n→ Step 1: 讀取 word1, word2 // 取得輸入字串\n→ Step 2: 設定 n = len(word1), m = len(word2) // 取得長度\n→ Step 3: 建立 dp 數組 (n+1) x (m+1)，初始化為 0 // DP 表\n→ Step 4: For i = 0 to n: dp[i][0] = i // 刪除到空字串\n→ Step 5: For j = 0 to m: dp[0][j] = j // 插入到目標字串\n→ Step 6: For i = 1 to n: // 主迴圈\n    → For j = 1 to m:\n        → Decision: word1[i-1] == word2[j-1]?\n            Yes → dp[i][j] = dp[i-1][j-1] // 字符相同不需要操作\n            No  → dp[i][j] = min(\n                    dp[i-1][j] + 1,   // 刪除\n                    dp[i][j-1] + 1,   // 插入\n                    dp[i-1][j-1] + 1  // 替換\n                ) // 取最小操作數\n→ Step 7: 輸出 dp[n][m] // 結果\nEnd // 程式執行結束\n\nWe need to maintain the formatting with indentation and arrow. Use '→' inside loops? Example shows indentation for nested decisions. We'll indent inside For loops. Let's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取字串 word1, word2 // 取得兩個輸入字串\n→ Step 2: 設定 n = len(word1), m = len(word2) // 取得字串長度\n→ Step 3: 建立 dp 數組 (n+1) × (m+1)，初始化為 0 // 建立 DP 表\n→ Step 4: For i = 0 to n: dp[i][0] = i // 刪除所有字元到空字串\n→ Step 5: For j = 0 to m: dp[0][j] = j // 插入所有字元到目標字串\n→ Step 6: For i = 1 to n: // 主迴圈\n    → For j = 1 to m:\n        → Decision: word1[i-1] == word2[j-1]? // 檢查當前字符是否相同\n            Yes → dp[i][j] = dp[i-1][j-1] // 字符相同，無需操作\n            No  → dp[i][j] = min(\n                    dp[i-1][j] + 1,   // 刪除操作\n                    dp[i][j-1] + 1,   // 插入操作\n                    dp[i-1][j-1] + 1  // 替換操作\n                ) // 取最小操作數\n→ Step 7: 輸出 dp[n][m] // 返回最小編輯距離\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_distance(word1: str, word2: str) -> int:\n    \"\"\"計算兩個字串之間的最小編輯距離（插入、刪除、替換）。\"\"\"\n    m, n = len(word1), len(word2)\n    # 建立 (m+1) x (n+1) 的 DP 表，全部初始化為 0\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # 初始化第一列與第一行：將一個空字串轉換成另一個字串的成本\n    for i in range(m + 1):\n        dp[i][0] = i           # 刪除所有字元\n    for j in range(n + 1):\n        dp[0][j] = j           # 插入所有字元\n\n    # DP 填表\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]           # 字符相同，成本不變\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],     # 刪除\n                    dp[i][j - 1],     # 插入\n                    dp[i - 1][j - 1]  # 替換\n                )\n    return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入資料中提取兩個字串。\n    支援形如：\n        word1 = \"horse\", word2 = \"ros\"\n    或多行、不同排列方式，只要有兩個雙引號內的字串即可。\n    \"\"\"\n    # 找出所有被雙引號包住的子字串\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) < 2:\n        # 如果沒有找到，嘗試用等號分隔後去除空白與引號\n        parts = re.split(r'[,;]', data)\n        words = []\n        for part in parts:\n            if '=' in part:\n                key, val = part.split('=', 1)\n                words.append(val.strip().strip('\"').strip(\"'\"))\n        if len(words) >= 2:\n            return words[0], words[1]\n        raise ValueError(\"無法解析輸入，請確保包含兩個字串。\")\n    return matches[0], matches[1]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    word1, word2 = parse_input(raw_input)\n    result = min_distance(word1, word2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode765.json",
    "problem_index_in_file": 0,
    "title": "Couples Holding Hands",
    "description_snippet": "There are n couples sitting in 2n seats arranged in a row and want to hold hands.\n\nThe people and se...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines step by step for algorithm. Approach: Use union-find or graph. Classic solution: treat seat pairs as nodes, edges when two people from different couples are in same seat pair. Count cycles. The minimal swaps = sum (cycle size -1). Or algorithm using mapping seat to partner index. Steps:\n\n1. Build mapping person -> seat index.\n2. For each seat pair (i,i+1), find partners; if partner not in same pair, we need to swap to bring partner into pair. Use while loop to correct. Count swaps.\n\nLet's produce pseudocode with steps.\n\nWe'll output each line as specified. We'll use arrows. Let's craft steps:\n\nStart\n→ Build dict personSeat: for idx, person in row enumerate(row): personSeat[person] = idx\n→ Initialize swaps = 0\n→ For seat i from 0 to len(row)-1 step 2:\n    → partner = row[i] XOR 1 // get partner id\n    → partnerSeat = personSeat[partner]\n    → If partnerSeat != i+1: // not in right pair\n        → currentPartnerOfSeat = row[i+1]\n        → // Swap partner into i+1 seat\n        → row[i+1] = partner\n        → row[partnerSeat] = currentPartnerOfSeat\n        → Update personSeat[partner] = i+1\n        → Update personSeat[currentPartnerOfSeat] = partnerSeat\n        → swaps += 1\nEnd\n\nBut we need to include decision arrow.\n\nLet's write lines with Decision.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立 personSeat 映射，將每個人 ID 與座位編號對應 // 用於快速查找座位\n→ Step 2: 初始化 swaps 為 0 // 記錄交換次數\n→ For i 0 to 2n-2 step 2: // 逐對處理座位\n    → Decision: 這對座位中第二個座位是否已經是配對者？ // 檢查是否需要交換\n        Yes → Step 3: 跳過此對 // 已配對，無需交換\n        No → Step 4: 找到配對者的位置 partnerSeat = personSeat[partner] // partner 是 row[i] XOR 1\n            → Step 5: 取得目前第二個座位上的人 current = row[i+1]\n            → Step 6: 交換 partner 與 current 的座位\n                → row[i+1] = partner\n                → row[partnerSeat] = current\n            → Step 7: 更新 personSeat 映射\n                → personSeat[partner] = i+1\n                → personSeat[current] = partnerSeat\n            → Step 8: swaps += 1 // 記錄一次交換\n\nEnd // 程式結束\n\nBut need each line formatted with arrow and explanation. Use \"→\" arrow for steps, \"Decision:\" lines indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 personSeat 映射，將每個人 ID 與座位編號對應 // 用於快速查找座位  \n→ Step 2: 初始化 swaps 為 0 // 記錄交換次數  \n→ For i 0 到 2n-2 步長 2: // 逐對處理座位  \n  Decision: 這對座位中第二個座位是否已經是配對者？ // 檢查是否需要交換  \n   Yes → Step 3: 跳過此對 // 已配對，無需交換  \n   No → Step 4: 取得配對者 partner = row[i] XOR 1  \n    Step 5: partnerSeat = personSeat[partner] // 配對者目前座位編號  \n    Step 6: current = row[i+1] // 當前第二個座位上的人  \n    Step 7: 交換 partner 與 current 的座位  \n     row[i+1] = partner  \n     row[partnerSeat] = current  \n    Step 8: 更新 personSeat 映射  \n     personSeat[partner] = i+1  \n     personSeat[current] = partnerSeat  \n    Step 9: swaps += 1 // 記錄一次交換  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\ndef min_swaps_couples(row):\n    n = len(row)\n    pos = [0] * n\n    for i, person in enumerate(row):\n        pos[person] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] ^ 1\n        if row[i + 1] != partner:\n            partner_idx = pos[partner]\n            # swap the partner into the correct seat\n            row[i + 1], row[partner_idx] = row[partner_idx], row[i + 1]\n            # update positions after swap\n            pos[row[partner_idx]] = partner_idx\n            pos[row[i + 1]] = i + 1\n            swaps += 1\n    return swaps\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the list expression from input like \"row = [0,2,1,3]\"\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    # Safely evaluate the list\n    row = ast.literal_eval(data)\n\n    result = min_swaps_couples(row)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "row = [0,2,1,3]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "row = [3,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode374.json",
    "problem_index_in_file": 0,
    "title": "Guess Number Higher or Lower",
    "description_snippet": "We are playing the Guess Game. The game is as follows: \n\nI pick a number from 1 to n. You have to gu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for the Guess Game algorithm. It's basically binary search. Provide step-by-step with explanation. Must use Start, End, Decision. Provide each line with virtual code step and comment. Use arrows →. Provide each line. Ensure each line includes virtual code step and // explanation. Use indentation for decisions. Let's craft:\n\nStart\n→ Initialize low = 1 // lower bound\n→ Initialize high = n // upper bound\n→ Decision: while low <= high? // loop condition\n    Yes → Step: mid = low + (high - low) / 2 // middle guess\n    → Call guess(mid) // get result\n    → Decision: result == 0? // correct guess?\n        Yes → Step: return mid // found number\n        No  → Decision: result < 0? // guess higher than pick?\n            Yes → Step: high = mid - 1 // adjust high\n            No  → Step: low = mid + 1 // adjust low\n    No → End // when loop ends (shouldn't happen if input valid)\nEnd\n\nBut we need each line separated. Use indentation with spaces.\n\nAlso need to keep 'Decision:' for loops as well? We can use Decision: while low <= high? yes... but might use 'Decision: low <= high?'.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 1 // 設定搜尋區間下界  \n→ Step 2: high = n // 設定搜尋區間上界  \n→ Decision: low ≤ high? // 判斷是否還有區間可搜尋  \n    Yes → Step 3: mid = low + (high - low) / 2 // 計算中間數  \n    → Step 4: result = guess(mid) // 呼叫 API 取得回傳值  \n    → Decision: result == 0? // 判斷是否猜對  \n        Yes → Step 5: return mid // 回傳找到的數字  \n        No  → Decision: result < 0? // 判斷猜的數字是否比目標大  \n            Yes → Step 6: high = mid - 1 // 目標在左半區間，更新上界  \n            No  → Step 7: low = mid + 1 // 目標在右半區間，更新下界  \n    No → End // 迴圈結束，理論上不會到此（若輸入有效）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# 模擬 guess API：根據實際選擇的數字回傳結果\ndef make_guess_api(pick):\n    def guess(num):\n        if num > pick:\n            return -1   # 猜大了\n        elif num < pick:\n            return 1    # 猜小了\n        else:\n            return 0    # 猜對了\n    return guess\n\nclass Solution:\n    def guessNumber(self, n, guess):\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res < 0:  # 猜的大\n                right = mid - 1\n            else:          # 猜的小\n                left = mid + 1\n        return -1  # 這裡不會被執行到，因為輸入合法\n\ndef parse_input(text):\n    \"\"\"從輸入文字中抽取兩個整數，分別作為 n 和 pick。\"\"\"\n    nums = list(map(int, re.findall(r'-?\\d+', text)))\n    if len(nums) < 2:\n        raise ValueError(\"輸入中缺少足夠的數字\")\n    return nums[0], nums[1]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    n, pick = parse_input(raw_input)\n\n    # 建立模擬的 guess 函式\n    guess = make_guess_api(pick)\n\n    # 透過解法尋找答案\n    sol = Solution()\n    answer = sol.guessNumber(n, guess)\n\n    # 將答案輸出到 stdout\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10, pick = 6",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode18.json",
    "problem_index_in_file": 0,
    "title": "4Sum",
    "description_snippet": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code with explanations. The problem is 4Sum: find unique quadruplets. Steps: sort array, loop i, j, then two pointers left/right, check sum. Avoid duplicates by skipping same numbers. Use structure Start, Decision, etc. Provide each line as \"虛擬碼步驟 // 解釋\". Use arrows. No real code.\n\nLet's design steps:\n\nStart\n→ Step 1: Sort nums ascending // 排序以便使用雙指標\n→ Step 2: Initialize result list // 用於存儲四元組\n→ Decision: 如果 nums 長度 < 4? // 判斷是否能形成四元組\n    Yes → End // 太短直接結束\n    No  → Loop i from 0 to n-4 // 外層第一個指標\n        Decision: 如果 i > 0 且 nums[i] == nums[i-1]? // 去重第一層\n            Yes → Continue // 跳過重複的 i\n        → Loop j from i+1 to n-3 // 第二個指標\n            Decision: 如果 j > i+1 且 nums[j] == nums[j-1]? // 去重第二層\n                Yes → Continue // 跳過重複的 j\n            → Initialize left = j+1, right = n-1 // 第三、四個指標\n            → Decision: while left < right? // 雙指標搜尋\n                Yes →\n                    → Step 3: currentSum = nums[i]+nums[j]+nums[left]+nums[right] // 計算目前四數之和\n                    → Decision: 如果 currentSum == target? // 找到四元組\n                        Yes →\n                            → Step 4: Add [nums[i], nums[j], nums[left], nums[right]] to result // 儲存結果\n                            → Step 5: Increment left while left < right and nums[left]==nums[left-1] // 跳過重複左側\n                            → Step 6: Decrement right while left < right and nums[right]==nums[right+1] // 跳過重複右側\n                            → Step 7: left++ , right-- // 移動指標\n                        No →\n                            → Decision: 如果 currentSum < target? // 根據和調整指標\n                                Yes → left++ // 加大和\n                                No  → right-- // 減小和\n                No → // 退出 while\nEnd // 完成\n\nWe must format each line with the virtual code step then // explanation. Also use arrow. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 將陣列排序，方便後續使用雙指標與去重  \n→ Step 2: Initialize result list // 用於存放符合條件的四元組  \n→ Decision: 如果 nums 長度 < 4? // 判斷是否足夠形成四元組  \n    Yes → End // 長度不足，直接結束  \n    No  → Loop i from 0 to n-4 // 第一層指標，遍歷可能的第一個元素  \n        Decision: 如果 i > 0 且 nums[i] == nums[i-1]? // 去除第一層重複  \n            Yes → Continue // 跳過重複的 i  \n        → Loop j from i+1 to n-3 // 第二層指標，遍歷可能的第二個元素  \n            Decision: 如果 j > i+1 且 nums[j] == nums[j-1]? // 去除第二層重複  \n                Yes → Continue // 跳過重複的 j  \n            → Initialize left = j+1, right = n-1 // 第三、四個指標，準備雙指標搜尋  \n            → Decision: while left < right? // 當左指標小於右指標時持續搜尋  \n                Yes →  \n                    → Step 3: currentSum = nums[i]+nums[j]+nums[left]+nums[right] // 計算目前四數之和  \n                    → Decision: 如果 currentSum == target? // 是否找到合法四元組  \n                        Yes →  \n                            → Step 4: Add [nums[i], nums[j], nums[left], nums[right]] to result // 儲存結果  \n                            → Step 5: Increment left while left < right and nums[left]==nums[left-1] // 跳過左側重複元素  \n                            → Step 6: Decrement right while left < right and nums[right]==nums[right+1] // 跳過右側重複元素  \n                            → Step 7: left++ , right-- // 同時移動兩個指標繼續搜尋  \n                        No →  \n                            → Decision: 如果 currentSum < target? // 根據和調整指標  \n                                Yes → left++ // 加大和  \n                                No  → right-- // 減小和  \n                No → // 退出 while 循環  \nEnd // 程式執行結束，結果已存於 result 列表中。",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def fourSum(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    nums = []\n    target = 0\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if nums_match:\n        nums = ast.literal_eval(nums_match.group(1))\n    if target_match:\n        target = int(target_match.group(1))\n\n    result = Solution().fourSum(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "success": true,
          "output": "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "success": true,
          "output": "[[2, 2, 2, 2]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode509.json",
    "problem_index_in_file": 0,
    "title": "Fibonacci Number",
    "description_snippet": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The requirement: use arrow → and structure Start, End, Decision:, and comments. Provide each line with virtual code step and comment after space. Should be in Traditional Chinese. The user says: \"請根據**輸出格式要求**產生虛擬碼和逐行解釋\" So we need to produce a pseudo algorithm for computing Fibonacci number F(n). Should be straightforward iterative or recursive? We can choose iterative to avoid recursion overhead. Provide steps: Input n, set a=0, b=1, loop i from 2 to n, compute c = a+b, set a=b, b=c. At end output b if n>0 else a. Also handle n=0. Provide virtual code lines accordingly.\n\nLet's produce lines:\n\nStart\n→ Step 1: 讀取 n // 取得使用者輸入的數字\n→ Decision: 如果 n < 2? // 檢查 n 是否小於 2（即 0 或 1）\n    Yes → Step 2: 輸出 n // 若 n 為 0 或 1，直接輸出 n\n    No  → Step 3: 初始化 a ← 0, b ← 1 // 設定前兩個 Fibonacci 數\n→ Decision: 從 i ← 2 到 n? // 循環計算剩餘 Fibonacci 數\n    Yes → Step 4: c ← a + b // 計算下一個 Fibonacci\n        → Step 5: a ← b // 更新前一個數\n        → Step 6: b ← c // 更新目前數\n        → Step 7: i ← i + 1 // 進入下一次迴圈\n        → Back to Decision: 從 i ← 2 到 n?\n    No  → Step 8: 輸出 b // 迴圈結束，輸出最後的 Fibonacci\nEnd\n\nBut we need to include arrow notation like →, Yes →, No →. And \"Decision:\" lines.\n\nLet's format each line with \"→\". For the loop decision, we can have nested Decision: with Yes → ... No → ... We need \"Back to Decision: 從 i ← 2 到 n?\" maybe not necessary. But we can do like \"→ Decision: i <= n? // 循環判斷\" with Yes and No.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 取得使用者輸入的數字\n→ Decision: 如果 n < 2? // 判斷 n 是否為 0 或 1\n    Yes → Step 2: 輸出 n // 若 n 為 0 或 1，直接輸出 n\n    No  → Step 3: 初始化 a ← 0, b ← 1 // 設定前兩個 Fibonacci 數\n→ Decision: i ← 2; i <= n? // 初始化迴圈變數並判斷\n    Yes → Step 4: c ← a + b // 計算下一個 Fibonacci\n        → Step 5: a ← b // 更新前一個數\n        → Step 6: b ← c // 更新目前數\n        → Step 7: i ← i + 1 // 迴圈變數遞增\n        → Back to Decision: i <= n? // 重新進行迴圈判斷\n    No  → Step 8: 輸出 b // 迴圈結束，輸出最後的 Fibonacci\nEnd // 程式執行結束\n\nBut \"Back to Decision\" might not be needed; the structure can just loop within Decision block. But in pseudo code we need to show iterative loop. Let's keep simpler:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 取得使用者輸入的數字\n→ Decision: n < 2? // 判斷 n 是否為 0 或 1\n    Yes → Step 2: 輸出 n // 若 n 為 0 或 1，直接輸出 n\n    No  → Step 3: 初始化 a ← 0, b ← 1 // 設定前兩個 Fibonacci 數\n→ Decision: i ← 2; i <= n? // 初始化迴圈並判斷\n    Yes → Step 4: c ← a + b // 計算下一個 Fibonacci\n        → Step 5: a ← b // 更新前一個數\n        → Step 6: b ← c // 更新目前數\n        → Step 7: i ← i + 1 // 迴圈變數遞增\n        → Back to Decision: i <= n? // 重新進行迴圈判斷\n    No  → Step 8: 輸出 b // 迴圈結束，輸出最後的 Fibonacci\nEnd // 程式執行結束\n\nBut we need to keep format: each line \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nLet's ensure each line ends with comment. Also need to use arrow '→' for each step. For decisions we use \"Decision:\" and indent with Yes → etc. But we need to produce each line in sequence; we cannot indent within a line. But we can write as separate lines: For decision we could use \"Decision: n < 2?\" then next line \"Yes → Step 2: ...\" then \"No → Step 3: ...\" Similarly for loop.\n\nBut the requirement: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`).\" So we can produce lines as such. Each line can be either a decision line or a step line. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 取得使用者輸入的數字\n→ Decision: n < 2? // 判斷 n 是否為 0 或 1\nYes → Step 2: 輸出 n // 若 n 為 0 或 1，直接輸出 n\nNo  → Step 3: 初始化 a ← 0, b ← 1 // 設定前兩個 Fibonacci 數\n→ Decision: i ← 2; i <= n? // 初始化迴圈變數並判斷是否需要執行迴圈\nYes → Step 4: c ← a + b // 計算下一個 Fibonacci\n→ Step 5: a ← b // 更新前一個數\n→ Step 6: b ← c // 更新目前數\n→ Step 7: i ← i + 1 // 迴圈變數遞增\n→ Back to Decision: i <= n? // 重新判斷迴圈條件\nNo  → Step 8: 輸出 b // 迴圈結束，輸出最後的 Fibonacci\nEnd // 程式執行結束\n\nBut \"Back to Decision\" may not be necessary; we can just loop. But we can keep. However the requirement: \"逐行地產生對應的虛擬碼\" So each line should be separate. Might be okay. But the \"Back to Decision\" line is a bit unnatural. We can restructure loop as:\n\n→ Decision: i ← 2; i <= n? // 初始化迴圈變數並判斷\nYes → Step 4: c ← a + b // 計算下一個 Fibonacci\n→ Step 5: a ← b // 更新前一個數\n→ Step 6: b ← c // 更新目前數\n→ Step 7: i ← i + 1 // 迴圈變數遞增\n→ Decision: i <= n? // 重新判斷迴圈條件\nYes → … (repeat) Actually we'd need to loop back. But we can represent as a while loop: \"Decision: i <= n?\" then inside we have steps then loop back automatically. So we can just show as a nested Decision block.\n\nSimplify:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 取得使用者輸入的數字\n→ Decision: n < 2? // 判斷 n 是否為 0 或 1\nYes → Step 2: 輸出 n // 若 n 為 0 或 1，直接輸出 n\nNo  → Step 3: 初始化 a ← 0, b ← 1 // 設定前兩個 Fibonacci 數\n→ Decision: i ← 2; i <= n? // 初始化迴圈變數並判斷是否需要執行迴圈\nYes → Step 4: c ← a + b // 計算下一個 Fibonacci\n→ Step 5: a ← b // 更新前一個數\n→ Step 6: b ← c // 更新目前數\n→ Step 7: i ← i + 1 // 迴圈變數遞增\n→ Decision: i <= n? // 重新判斷迴圈條件\nYes → (回到 Step 4) // 迴圈繼續\nNo  → Step 8: 輸出 b // 迴圈結束，輸出最後的 Fibonacci\nEnd // 程式執行結束\n\nBut \"回到 Step 4\" not proper. Let's use \"Yes → Step 4: c ← a + b\" again, but that will be repeated. In pseudo code, it's okay to show that the loop will return to Step 4. But we need to maintain structure.\n\nAlternatively we can express as:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 取得使用者輸入的數字\n→ Decision: n < 2? // 判斷 n 是否為 0 或 1\nYes → Step 2: 輸出 n // 若 n 為 0 或 1，直接輸出 n\nNo  → Step 3: 初始化 a ← 0, b ← 1 // 設定前兩個 Fibonacci 數\n→ Decision: i ← 2; i <= n? // 初始化迴圈變數並判斷\nYes → Step 4: c ← a + b // 計算下一個 Fibonacci\n→ Step 5: a ← b // 更新前一個數\n→ Step 6: b ← c // 更新目前數\n→ Step 7: i ← i + 1 // 迴圈變數遞增\n→ Decision: i <= n? // 判斷是否繼續迴圈\n    Yes → Step 4 // 重新進行迴圈\n    No  → Step 8: 輸出 b // 迴圈結束，輸出最後的 Fibonacci\nEnd // 程式執行結束\n\nThis uses nested Decision with Yes→ Step 4 again to loop. It's fine.\n\nBut we must keep each line with arrow and comment. So we need to separate each line:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 取得使用者輸入的數字\n→ Decision: n < 2? // 判斷 n 是否為 0 或 1\nYes → Step 2: 輸出 n // 若 n 為 0 或 1，直接輸出 n\nNo  → Step 3: 初始化 a ← 0, b ← 1 // 設定前兩個 Fibonacci 數\n→ Decision: i ← 2; i <= n? // 初始化迴圈變數並判斷\nYes → Step 4: c ← a + b // 計算下一個 Fibonacci\n→ Step 5: a ← b // 更新前一個數\n→ Step 6: b ← c // 更新目前數\n→ Step 7: i ← i + 1 // 迴圈變數遞增\n→ Decision: i <= n? // 判斷是否繼續迴圈\nYes → Step 4 // 重新進行迴圈\nNo  → Step 8: 輸出 b // 迴圈結束，輸出最後的 Fibonacci\nEnd // 程式執行結束\n\nThis is okay. Each line is a step or decision. All comments are short. Let's produce that.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 取得使用者輸入的數字\n→ Decision: n < 2? // 判斷 n 是否為 0 或 1\nYes → Step 2: 輸出 n // 若 n 為 0 或 1，直接輸出 n\nNo  → Step 3: 初始化 a ← 0, b ← 1 // 設定前兩個 Fibonacci 數\n→ Decision: i ← 2; i <= n? // 初始化迴圈變數並判斷是否需要執行迴圈\nYes → Step 4: c ← a + b // 計算下一個 Fibonacci\n→ Step 5: a ← b // 更新前一個數\n→ Step 6: b ← c // 更新目前數\n→ Step 7: i ← i + 1 // 迴圈變數遞增\n→ Decision: i <= n? // 判斷是否繼續迴圈\nYes → Step 4 // 重新進行迴圈\nNo  → Step 8: 輸出 b // 迴圈結束，輸出最後的 Fibonacci\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef fib(n: int) -> int:\n    \"\"\"計算 F(n) 的 Fibonacci 數列值。\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 n，計算並輸出 F(n)。\"\"\"\n    data = sys.stdin.read().strip()\n    # 從輸入中搜尋第一個整數（可處理如 'n = 2' 的形式）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    print(fib(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode15.json",
    "problem_index_in_file": 0,
    "title": "3Sum",
    "description_snippet": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for finding all unique triplets that sum to zero, given array nums. Need to explain each line. Provide step-by-step algorithm: sort array, loop i, skip duplicates, two pointers left, right, adjust sum, etc. Must include Start, End, Decision. Use arrow syntax. Provide \"→\" for steps.\n\nWe should not output actual code, just virtual steps. Use simplified names like \"Step: Sort nums\". Provide explanation.\n\nWe should also mention duplicate avoidance. Ensure each line ends with \"// explanation\".\n\nLet's produce maybe about 25-30 lines.\n\nLet's produce:\n\nStart\n→ Step 1: Sort the array nums // sorting allows two-pointer traversal and duplicate handling\n→ Step 2: Initialize result list res // to store found triplets\n→ Step 3: For each index i from 0 to length-2 // choose first element of triplet\n    → Decision: If i>0 and nums[i]==nums[i-1]? // skip duplicate first elements\n        Yes → Continue // skip to next i\n        No  → // proceed\n    → Step 4: Set left = i+1, right = length-1 // pointers for remaining two numbers\n    → Decision: While left < right? // process remaining pairs\n        Yes →\n            → Step 5: Compute sum = nums[i] + nums[left] + nums[right] // current triplet sum\n            → Decision: If sum == 0? // found valid triplet\n                Yes →\n                    → Step 6: Add [nums[i], nums[left], nums[right]] to res // store triplet\n                    → Step 7: While left < right and nums[left]==nums[left+1]? // skip duplicate second element\n                        Yes → left++ // move left pointer\n                        No  → // stop skipping\n                    → Step 8: While left < right and nums[right]==nums[right-1]? // skip duplicate third element\n                        Yes → right-- // move right pointer\n                        No  → // stop skipping\n                    → Step 9: left++ // move to next potential second element\n                    → Step 10: right-- // move to next potential third element\n                No →\n                    → Decision: If sum < 0? // need larger sum\n                        Yes → left++ // move left pointer to increase sum\n                        No  → // sum > 0\n                            → Step 11: right-- // move right pointer to decrease sum\n        No → // left >= right, exit while\n→ End // algorithm finished, return res\n\nThat's the steps. Provide each line with explanation. Make sure each line ends with // explanation. Also include the arrow notation correctly. Use \"→\" before each step. For decisions use \"Decision: ...\". Use \"Yes →\" and \"No →\" for branches. Include indenting? The example shows indentation. So use spaces before lines for nested steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort the array nums // 先把數組排好序，方便雙指針掃描與去重\n→ Step 2: Initialize result list res // 用來存放所有符合條件的三元組\n→ Step 3: For each index i from 0 to length-2 // 選取第一個元素\n    → Decision: 如果 i>0 且 nums[i]==nums[i-1]? // 跳過重複的第一個元素\n        Yes → Continue // 跳過本次迭代\n        No  → // 繼續往下處理\n    → Step 4: Set left = i+1, right = length-1 // 設置第二、三個指針\n    → Decision: While left < right? // 對剩餘兩個位置進行雙指針掃描\n        Yes →\n            → Step 5: Compute sum = nums[i] + nums[left] + nums[right] // 計算目前三元組和\n            → Decision: 如果 sum == 0? // 找到符合條件的三元組\n                Yes →\n                    → Step 6: Add [nums[i], nums[left], nums[right]] to res // 把三元組加入結果\n                    → Step 7: While left < right 且 nums[left]==nums[left+1]? // 跳過重複的第二個元素\n                        Yes → left++ // 將 left 向右移動\n                        No  → // 結束跳過\n                    → Step 8: While left < right 且 nums[right]==nums[right-1]? // 跳過重複的第三個元素\n                        Yes → right-- // 將 right 向左移動\n                        No  → // 結束跳過\n                    → Step 9: left++ // 移動到下一個可能的第二個元素\n                    → Step 10: right-- // 移動到下一個可能的第三個元素\n                No →\n                    → Decision: 如果 sum < 0? // 和太小，需要更大的值\n                        Yes → left++ // 將 left 向右移動，增加和\n                        No  → // sum > 0，和太大\n                            → Step 11: right-- // 將 right 向左移動，減小和\n        No → // left >= right，結束雙指針循環\n→ End // 程式執行結束，返回 res",
      "generated_code": "import sys\n\nclass Solution:\n    def threeSum(self, nums):\n        \"\"\"找出所有不重複的三元組，使其和為 0。\"\"\"\n        nums.sort()                      # 先排序，方便雙指針和去重\n        res = []\n        n = len(nums)\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue                 # 跳過重複的第一個元素\n            left, right = i + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total == 0:\n                    res.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1        # 跳過重複的第二個元素\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1       # 跳過重複的第三個元素\n                    left += 1\n                    right -= 1\n                elif total < 0:\n                    left += 1           # 和太小，左指針往右移\n                else:\n                    right -= 1          # 和太大，右指針往左移\n        return res\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取列表。\"\"\"\n    data = data.strip()\n    if '=' in data:\n        # 例如 \"nums = [-1,0,1,2,-1,-4]\"\n        _, list_str = data.split('=', 1)\n        data = list_str.strip()\n    return eval(data)  # 直接 eval 解析為 list\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.threeSum(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,1,2,-1,-4]",
          "expected_output": "[[-1,-1,2],[-1,0,1]]",
          "success": true,
          "output": "[[-1, -1, 2], [-1, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,0,0]",
          "expected_output": "[[0,0,0]]",
          "success": true,
          "output": "[[0, 0, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode474.json",
    "problem_index_in_file": 0,
    "title": "Ones and Zeroes",
    "description_snippet": "You are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code in the described format for the problem: given array of binary strings strs, integers m, n, find size of largest subset with at most m zeros and n ones. This is typical DP (0-1 knapsack with two constraints). We'll produce pseudo-code steps. Must be line-by-line, with \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. Need to incorporate DP table initialization, iteration over strings, inner loops over counts descending.\n\nWe should keep steps understandable: Start, Input array and m,n, initialize DP table (m+1)*(n+1) zeros, iterate over each string, count zeros and ones, loop for i=m down to zeros, for j=n down to ones, update dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1). After processing all strings, result dp[m][n]. End.\n\nWe'll output each step line. Use \"→\" for steps.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 strs 與整數 m, n // 取得資料\n→ Step 2: 初始化 DP 二維陣列 dp[(m+1)][(n+1)] 為 0 // DP 表\n→ Decision: 是否已完成所有字串處理? // 檢查是否還有字串未處理\n    No  → Step 3: 取下一個字串 cur // 取字串\n    → Step 4: 計算 cur 中 0 的個數 zeros, 1 的個數 ones // 統計\n    → Decision: zeros > m 或 ones > n? // 若超過限制，直接跳過\n        Yes → Decision: 是否已處理完所有字串? // 判斷是否結束\n            No  → Jump back to Step 3 // 取下一個字串\n            Yes → End // 结束\n        No  → Step 5: 從 i=m down到 zeros // 逆向迴圈 0維\n        → Step 6: 從 j=n down到 ones // 逆向迴圈 1維\n        → Step 7: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新\n        → Decision: 是否已處理完所有字串? // 判斷是否結束\n            No  → Jump back to Step 3 // 取下一個字串\n            Yes → Step 8: 取得答案 result = dp[m][n] // 最終答案\n→ Step 9: 輸出 result // 顯示結果\nEnd // 程式執行結束\n\nBut need to ensure pseudo-code uses \"Decision:\" with indentation. We must keep consistent arrow usage. For loops we can express as \"→ Step 5: For i = m downto zeros\" but we also need inner j loop. The format uses arrow \"→\" and indentation to show decision branches.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 strs 與整數 m, n // 取得資料\n→ Step 2: 建立 dp[0..m][0..n] 且全部設為 0 // 初始化 DP 表\n→ Step 3: 設定 idx = 0 // 索引\n→ Decision: idx < strs.length? // 是否還有字串可處理\n    Yes → Step 4: cur = strs[idx] // 取出下一個字串\n    → Step 5: zeros = count of '0' in cur // 0 的數量\n    → Step 6: ones  = count of '1' in cur // 1 的數量\n    → Decision: zeros > m 或 ones > n? // 超過限制\n        Yes → Step 7: idx = idx + 1 // 跳過此字串\n        → Decision: idx < strs.length? // 判斷是否結束\n            Yes → 跳回 Step 3\n            No → End // 完成\n        No  → Step 8: For i = m downto zeros\n            → Step 9: For j = n downto ones\n                → Step 10: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新 DP\n            → Step 11: idx = idx + 1 // 移至下一字串\n            → Decision: idx < strs.length? // 判斷是否還有字串\n                Yes → 跳回 Step 3\n                No  → Step 12: result = dp[m][n] // 取得最大子集大小\n→ Step 13: 輸出 result // 顯示結果\nEnd // 程式執行結束\n\nBut the pseudo-code expects each line preceded by \"→\" except maybe \"Start\" and \"End\". Use \"Start\" and \"End\" lines without arrow. For inner loops we can still use arrow but indent? The format uses arrow and indentation for decisions but not loops. We can denote loops as separate steps.\n\nBetter produce a more linear flow:\n\nStart\n→ Step 1: 讀取 strs、m、n\n→ Step 2: 建立 dp[(m+1)][(n+1)] 初始化為 0\n→ Step 3: idx = 0\n→ Decision: idx < strs.length? // 是否還有字串\n    Yes → Step 4: cur = strs[idx]\n    → Step 5: zeros = count0(cur)\n    → Step 6: ones  = count1(cur)\n    → Decision: zeros > m 或 ones > n?\n        Yes → Step 7: idx = idx + 1\n        → Decision: idx < strs.length? // 判斷結束\n            Yes → 跳回 Step 3\n            No → End\n        No  → Step 8: For i = m downto zeros\n            → Step 9: For j = n downto ones\n                → Step 10: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)\n            → Step 11: idx = idx + 1\n            → Decision: idx < strs.length? \n                Yes → 跳回 Step 3\n                No  → Step 12: result = dp[m][n]\n→ Step 13: 輸出 result\nEnd\n\nBut step 13 will only run if we break out of the loop. We need to ensure flow. But this representation may be okay.\n\nThe format expects each line as \"虛擬碼步驟 // 解釋\". We need to keep them separate lines.\n\nLet's produce each step on a line with arrow or not.\n\nUse Chinese characters for explanation.\n\nWe need to include indentation for decision branches. The sample uses indentation spaces and arrow inside.\n\nLet's follow sample formatting:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 strs 與整數 m, n // 取得資料\n→ Step 2: 初始化 DP 二維陣列 dp[0..m][0..n] 為 0 // 初始化 DP 表\n→ Step 3: idx = 0 // 索引指向目前處理字串\n→ Decision: idx < strs.length? // 是否還有未處理字串\n    Yes → Step 4: cur = strs[idx] // 取出下一個字串\n    → Step 5: zeros = count of '0' in cur // 0 的數量\n    → Step 6: ones  = count of '1' in cur // 1 的數量\n    → Decision: zeros > m 或 ones > n? // 若超過限制則跳過\n        Yes → Step 7: idx = idx + 1 // 跳過此字串\n        → Decision: idx < strs.length? // 判斷是否結束\n            Yes → 跳回 Step 3\n            No  → End // 所有字串處理完畢\n        No  → Step 8: For i = m downto zeros\n            → Step 9: For j = n downto ones\n                → Step 10: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新 DP\n            → Step 11: idx = idx + 1 // 進入下一字串\n            → Decision: idx < strs.length? // 判斷是否仍有字串\n                Yes → 跳回 Step 3\n                No  → Step 12: result = dp[m][n] // 取得最大子集大小\n→ Step 13: 輸出 result // 顯示答案\nEnd // 程式結束\n\nBut \"跳回 Step 3\" isn't a virtual code line, we need actual step for loop back. We could use \"→ Step 3\" but it's repeated. Instead we can use \"→ Step 3: idx = idx\" maybe but that's unnatural. The sample uses \"Yes →\" and \"No →\" arrows for decision outcomes, but for loops we just have steps. For return to earlier step, we can just let the indentation flow continue; but the sample uses recursion.\n\nBetter to use explicit loop: For each string, we have loop outer.\n\nWe could restructure: Use \"→ Step 4: For each cur in strs\" but need inner loops. But pseudo-code line-by-line might get messy.\n\nAlternate approach: use while loop: Step 3: idx = 0 ; Step 4: While idx < strs.length: ... ; Step 11: idx++ ; Step 12: if idx >= strs.length break; else continue; But that might be okay.\n\nSimplify: Use explicit while loop and for loops.\n\nLet's produce:\n\nStart\n→ Step 1: 讀取 strs、m、n\n→ Step 2: 建立 dp 形狀 (m+1)×(n+1) 且全為 0\n→ Step 3: idx = 0\n→ Decision: idx < strs.length? // 有未處理字串\n    Yes → Step 4: cur = strs[idx]\n    → Step 5: zeros = count0(cur)\n    → Step 6: ones  = count1(cur)\n    → Decision: zeros > m 或 ones > n? // 超過限制\n        Yes → Step 7: idx = idx + 1\n        → Decision: idx < strs.length? // 判斷是否結束\n            Yes → 跳回 Step 3\n            No  → End\n        No  → Step 8: For i = m downto zeros\n            → Step 9: For j = n downto ones\n                → Step 10: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)\n            → Step 11: idx = idx + 1\n            → Decision: idx < strs.length?\n                Yes → 跳回 Step 3\n                No  → Step 12: result = dp[m][n]\n→ Step 13: 輸出 result\nEnd\n\nThis uses \"跳回 Step 3\" as explanatory but not actual pseudo-code. Might be okay? But maybe better to include actual \"→ Step 3\" again as separate line but the sample didn't use loop back; they just had linear flow.\n\nWe can instead restructure to avoid needing a loop back. Use a for loop:\n\n→ Step 3: For each cur in strs:\n    → Step 4: zeros = count0(cur)\n    → Step 5: ones = count1(cur)\n    → Decision: zeros > m 或 ones > n?\n        Yes → continue // skip this cur\n        No  → Step 6: For i = m downto zeros\n            → Step 7: For j = n downto ones\n                → Step 8: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)\nAfter loop ends, Step 9: result = dp[m][n]\n→ Step 10: 輸出 result\n\nBut we need to express \"continue\" or skip, which we can treat as decision outcome skipping rest.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取陣列 strs、整數 m 與 n // 取得輸入\n→ Step 2: 初始化 DP 二維陣列 dp[0..m][0..n] 為 0 // DP 表\n→ Step 3: For each cur in strs // 遍歷每個字串\n    → Step 4: zeros = count of '0' in cur // 0 的個數\n    → Step 5: ones  = count of '1' in cur // 1 的個數\n    → Decision: zeros > m 或 ones > n? // 是否超出限制\n        Yes → Continue // 跳過此字串\n        No  → Step 6: For i = m downto zeros\n            → Step 7: For j = n downto ones\n                → Step 8: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新\n→ Step 9: result = dp[m][n] // 取得最大子集大小\n→ Step 10: 輸出 result // 顯示答案\nEnd // 程式結束\n\nBut the format: each line must have \"虛擬碼步驟 // 解釋\". So we must not use \"continue\" as explanation. But we can keep \"Yes → Skip cur\" as explanation.\n\nHowever \"continue\" is not part of pseudo-code? It is. We can treat \"Continue\" as a step.\n\nLet's produce each line accordingly. Use arrow for loops? In sample, they use \"→ Decision:\" lines with indentation. They also use \"→ Step\" lines. For loops we can use \"→ Step\" with a comment indicating loop. But to avoid too many lines, we can combine loop lines.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取 strs、m、n // 取得輸入\n→ Step 2: 初始化 dp[0..m][0..n] 為 0 // DP 表\n→ Step 3: For 每個 cur in strs // 遍歷字串\n    → Step 4: zeros = count0(cur) // 0 的個數\n    → Step 5: ones = count1(cur) // 1 的個數\n    → Decision: zeros > m 或 ones > n? // 超過限制\n        Yes → Step 6: 跳過此字串 // continue\n        No  → Step 7: For i = m downto zeros\n            → Step 8: For j = n downto ones\n                → Step 9: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新\n→ Step 10: result = dp[m][n] // 取得最大子集大小\n→ Step 11: 輸出 result // 顯示答案\nEnd // 程式結束\n\nBut we need to ensure that after step 6 \"skip\" we return to next iteration. The pseudo-code line \"Step 6: 跳過此字串\" may suffice.\n\nWe can keep this format.\n\nNow produce final output exactly lines.\n\nMake sure to include the \"虛擬碼步驟\" with \"→\" arrow, and explanation after //.\n\nAlso include indentation as sample: inside decision branch indent with 4 spaces? They used 4 spaces before Yes/No arrows? They had:\n\nDecision: 如果數字大於 0? \n    Yes → Step ...\n    No  → Decision...\n\nSo we need to indent the Yes/No lines relative to Decision. We'll follow that.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取 strs、m、n // 取得輸入\n→ Step 2: 初始化 dp[0..m][0..n] 為 0 // DP 表\n→ Step 3: For 每個 cur in strs // 遍歷字串\n    → Step 4: zeros = count0(cur) // 0 的個數\n    → Step 5: ones = count1(cur) // 1 的個數\n    → Decision: zeros > m 或 ones > n? // 是否超出限制\n        Yes → Step 6: 跳過此字串 // continue\n        No  → Step 7: For i = m downto zeros\n            → Step 8: For j = n downto ones\n                → Step 9: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新\n→ Step 10: result = dp[m][n] // 取得最大子集大小\n→ Step 11: 輸出 result // 顯示答案\nEnd // 程式結束\n\nBut we need each line to be separate line, with indentation for nested lines. The decision branches indentation: yes and no lines should be indented relative to Decision. Then inside No branch we have nested loops, so indent further.\n\nAlso each step should have a number or name. In sample, they used \"Step 1:\", \"Decision:\" etc. We'll keep that.\n\nLet's final output with correct indentation:\n\nStart // 程式開始執行\n→ Step 1: 讀取 strs、m、n // 取得輸入\n→ Step 2: 初始化 dp[0..m][0..n] 為 0 // DP 表\n→ Step 3: For 每個 cur in strs // 遍歷字串\n    → Step 4: zeros = count0(cur) // 0 的個數\n    → Step 5: ones = count1(cur) // 1 的個數\n    → Decision: zeros > m 或 ones > n? // 是否超出限制\n        Yes → Step 6: 跳過此字串 // continue\n        No  → Step 7: For i = m downto zeros\n            → Step 8: For j = n downto ones\n                → Step 9: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新\n→ Step 10: result = dp[m][n] // 取得最大子集大小\n→ Step 11: 輸出 result // 顯示答案\nEnd // 程式結束\n\nCheck: All lines with arrow except Start and End? Actually Start has no arrow, End has no arrow. Others have arrow. Yes.\n\nNow produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 strs、m、n // 取得輸入  \n→ Step 2: 初始化 dp[0..m][0..n] 為 0 // DP 表  \n→ Step 3: For 每個 cur in strs // 遍歷字串  \n    → Step 4: zeros = count0(cur) // 0 的個數  \n    → Step 5: ones = count1(cur) // 1 的個數  \n    → Decision: zeros > m 或 ones > n? // 是否超出限制  \n        Yes → Step 6: 跳過此字串 // continue  \n        No → Step 7: For i = m downto zeros  \n            → Step 8: For j = n downto ones  \n                → Step 9: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新  \n→ Step 10: result = dp[m][n] // 取得最大子集大小  \n→ Step 11: 輸出 result // 顯示答案  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入格式：strs = [...], m = ..., n = ...\n    pattern = r'strs\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*m\\s*=\\s*(\\d+)\\s*,\\s*n\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        # 若輸入格式不符，直接結束\n        return\n    strs_str = match.group(1)\n    m_val = int(match.group(2))\n    n_val = int(match.group(3))\n    strs = ast.literal_eval(strs_str)\n\n    solution = Solution()\n    result = solution.findMaxForm(strs, m_val, n_val)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode227.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator II",
    "description_snippet": "Given a string s which represents an expression, evaluate this expression and return its value.\n\nThe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudocode) that evaluates a string expression with + - * /, integer division truncating toward zero. Standard algorithm: use stack for numbers, current number, sign. Iterate characters. When digit accumulate number. When operator or end, apply previous sign: if '+', push number; if '-', push -number; if '*', pop, multiply, push; if '/', pop, divide with trunc toward zero. After loop, sum stack. So produce line by line virtual code.\n\nWe should use Start, End, Decision, etc.\n\nLet's craft lines:\n\nStart // begin evaluation\n→ Step 1: Initialize stack, num = 0, sign = '+'\n→ Step 2: For each char c in string s with index i from 0 to len(s)-1:\n    → Decision: If c is digit? // accumulate number\n        Yes → num = num * 10 + int(c)\n        No → Decision: If c is space? // skip\n            Yes → Continue loop\n            No → Decision: If c is operator? // handle previous sign\n                Yes → Step 3: If sign == '+': push num to stack\n                    Step 4: Else if sign == '-': push -num to stack\n                    Step 5: Else if sign == '*': temp = stack.pop(); push temp * num\n                    Step 6: Else if sign == '/': temp = stack.pop(); push truncate(temp / num)\n                No → Continue loop\n    → Decision: If i == len(s)-1? // after last char, process final number same as operator\n        Yes → (same as above)\nEnd // compute sum\n→ Step 7: result = 0\n→ For each val in stack: result += val\n→ Return result\n\nBut we must produce line by line with arrow and comments.\n\nLet's write more concise but clear. Use indentation: we can use spaces for indent but must be clear. We'll show nested decisions with indentation.\n\nWe should ensure each line has virtual code and comment.\n\nLet's produce.\n\nUse \"→\" for each line except Start and End. Use Decision: lines for if.\n\nWe'll represent loops like \"→ Loop over characters\" but we need to show structure.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Initialize stack = [], num = 0, sign = '+'\n\n→ For i from 0 to length(s)-1: // 逐字遍歷字串\n\n    → Decision: if s[i] is digit? // 累計數字\n\n        Yes → num = num * 10 + int(s[i]) // 將字元轉為數字並累加\n\n        No  → Decision: if s[i] == ' '? // 空白跳過\n\n            Yes → Continue // 忽略空白\n\n            No  → Decision: if s[i] in '+-*/'? // 遇到運算符\n\n                Yes → Decision: if sign == '+'? // 依舊符號處理前一個數字\n\n                    Yes → stack.append(num) // 加號: 直接入棧\n\n                    No  → Decision: if sign == '-'? // 減號\n\n                        Yes → stack.append(-num) // 入負數\n\n                        No  → Decision: if sign == '*'? // 乘號\n\n                            Yes → temp = stack.pop(); stack.append(temp * num) // 乘\n\n                            No  → Decision: if sign == '/'? // 除號\n\n                                Yes → temp = stack.pop(); stack.append(truncate(temp / num)) // 除\n\n                No  → Continue // 若不是符號，直接繼續\n\n                // 處理完符號後，更新符號\n                → sign = s[i]\n\n                → num = 0\n\n    // 若到最後一個字元，需處理最後一個數字\n    → Decision: if i == length(s)-1? // 最後一個數字還未處理\n\n        Yes → Decision: if sign == '+'? // 同前面邏輯\n\n            Yes → stack.append(num)\n\n            No  → Decision: if sign == '-'\n\n                Yes → stack.append(-num)\n\n                No  → Decision: if sign == '*'\n\n                    Yes → temp = stack.pop(); stack.append(temp * num)\n\n                    No  → Decision: if sign == '/'\n\n                        Yes → temp = stack.pop(); stack.append(truncate(temp / num))\n\nEnd // 先計算結果\n\n→ result = 0\n\n→ For each value v in stack: result = result + v\n\n→ Return result\n\nWe need to ensure each line has the arrow and comment. But the above has indentation lines with \"→\" but some lines have no \"→\" because we need each line to start with \"→\". In the example, they used indentation within the Decision block but each line still starts with arrow? Example from prompt: \n\n```\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n```\n\nSo we can indent using spaces before arrow for sub-steps. Let's replicate.\n\nThus each line starts with some spaces maybe, but always with arrow \"→\". Use \"→\" at start of each non-Start/End line, indent with spaces accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize stack = [], num = 0, sign = '+' // 初始棧、數字與符號  \n\n→ For i from 0 to length(s)-1: // 逐字遍歷字串  \n  → Decision: if s[i] is digit? // 累計數字  \n    Yes → num = num * 10 + int(s[i]) // 把字元轉成數字並累加  \n    No → Decision: if s[i] == ' '? // 空白忽略  \n      Yes → Continue // 跳過空白  \n      No → Decision: if s[i] in '+-*/'? // 遇到運算符  \n       Yes → Decision: if sign == '+'? // 處理上一個數字  \n         Yes → stack.append(num) // 加號：直接入棧  \n         No → Decision: if sign == '-'? // 減號  \n           Yes → stack.append(-num) // 入負數  \n           No → Decision: if sign == '*'? // 乘號  \n             Yes → temp = stack.pop(); stack.append(temp * num) // 乘  \n             No → Decision: if sign == '/'? // 除號  \n               Yes → temp = stack.pop(); stack.append(truncate(temp / num)) // 除  \n               No → Continue  \n             // 完成符號處理後，更新符號  \n            → sign = s[i]  \n            → num = 0  \n            No → Continue // 不是運算符，直接繼續  \n\n  → Decision: if i == length(s)-1? // 最後一個數字還未處理  \n    Yes → Decision: if sign == '+'? // 同前面邏輯  \n      Yes → stack.append(num)  \n      No → Decision: if sign == '-'?  \n        Yes → stack.append(-num)  \n        No → Decision: if sign == '*'?  \n          Yes → temp = stack.pop(); stack.append(temp * num)  \n          No → Decision: if sign == '/'?  \n            Yes → temp = stack.pop(); stack.append(truncate(temp / num))  \n\nEnd // 完成遍歷後開始計算結果  \n→ result = 0  \n→ For each value v in stack: result = result + v // 將棧內所有值相加  \n→ Return result // 傳回最終計算結果",
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        \"\"\"計算包含 + - * / 的整數運算式，除法向 0 截斷\"\"\"\n        stack = []\n        num = 0\n        sign = '+'\n        s += '+'                     # 方便一次性處理最後一個數字\n        for c in s:\n            if c.isdigit():          # 累計多位數\n                num = num * 10 + int(c)\n            elif c in '+-*/':        # 遇到運算符，先處理前一個數字\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    top = stack.pop()\n                    # 向 0 截斷的除法\n                    if top < 0:\n                        stack.append(-(-top // num))\n                    else:\n                        stack.append(top // num)\n                sign = c          # 更新符號\n                num = 0           # 重置數字\n        return sum(stack)\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取表達式，輸出其值\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 允許輸入類型：s = \"3+2*2\" 或直接 3+2*2\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    # 去除可能的外圍引號\n    if (expr.startswith('\"') and expr.endswith('\"')) or \\\n       (expr.startswith(\"'\") and expr.endswith(\"'\")):\n        expr = expr[1:-1]\n    solution = Solution()\n    result = solution.calculate(expr)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3+2*2\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \" 3/2 \"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \" 3+5 / 2 \"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode673.json",
    "problem_index_in_file": 0,
    "title": "Number of Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the number of longest increasing subsequences.\n\nNotice that the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, using arrow and explanation. The algorithm: typical LIS counting dynamic programming.\n\nWe need to write steps in virtual code with Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow arrow to indicate flow. Use Decision.\n\nWe need to design steps: Input array, length n. Initialize arrays length n for LIS length and count. For i from 0 to n-1: set len[i] = 1, count[i] = 1. Then nested loop j from 0 to i-1: if nums[j] < nums[i]: if len[j]+1 > len[i]: update len[i], count[i] = count[j]; else if len[j]+1 == len[i]: count[i] += count[j]. After loops, find maxLen = max(len). Sum counts for indices where len == maxLen. Output sum.\n\nAlso handle empty array return 0.\n\nLet's produce virtual code step by step. Need to use \"Start\", \"End\". Use arrows \"→\" and decisions \"Decision:\".\n\nWe can include loops using \"Loop: i=0 to n-1\". Might need to represent loops in pseudo.\n\nWe must keep each line with arrow? The format example uses \"→ Step 1:\" etc. For loops maybe \"→ Loop i from 0 to n-1:\".\n\nLet's produce:\n\nStart\n→ Input: nums // 取得輸入陣列\n→ Decision: 如果 nums 為空? // 檢查陣列是否為空\n    Yes → Output 0 // 空陣列沒有子序列\n    No → Assign n = length of nums // n 為陣列長度\n→ Initialise: length[0..n-1] = 1, count[0..n-1] = 1 // 每個位置初始長度與計數為 1\n→ Loop i from 0 to n-1: // 外層遍歷每個元素\n    → Loop j from 0 to i-1: // 內層比較前面元素\n        → Decision: nums[j] < nums[i]? // 是否能形成遞增子序列\n            Yes →\n                → Decision: length[j] + 1 > length[i]? // 新長度是否更長\n                    Yes →\n                        → Update length[i] = length[j] + 1 // 更新更長的長度\n                        → Update count[i] = count[j] // 計數由 j 的計數決定\n                    No →\n                        → Decision: length[j] + 1 == length[i]? // 是否相等\n                            Yes →\n                                → Update count[i] = count[i] + count[j] // 加上另一種方式\n                            No → // 不做任何事\n→ After loops: // 取得最大長度與總計\n    → Find maxLen = max(length[0..n-1]) // 最大子序列長度\n    → Sum count[i] for all i where length[i] == maxLen → total // 計算總數\n→ Output total // 回傳結果\nEnd\n\nWe need each line \"虛擬碼步驟 // 解釋\".\n\nEnsure each line starts with maybe \"→\" or \"Start\". For nested steps, indent maybe but still start with arrow.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums // 取得輸入的整數陣列  \n→ Decision: 如果 nums 為空? // 檢查陣列是否為空  \n  Yes → Output 0 // 空陣列沒有任何子序列，直接回傳 0  \n  No  → Assign n = length of nums // 計算陣列長度  \n→ Initialise: length[0..n-1] = 1, count[0..n-1] = 1 // 每個位置初始長度與計數為 1  \n→ Loop i from 0 to n-1: // 外層遍歷每個元素  \n  → Loop j from 0 to i-1: // 內層比較前面元素  \n   → Decision: nums[j] < nums[i]? // 是否能以 nums[i] 為尾端形成遞增子序列  \n    Yes →  \n     → Decision: length[j] + 1 > length[i]? // 新長度是否比現有長度更長  \n      Yes →  \n       → Update length[i] = length[j] + 1 // 更新更長的子序列長度  \n       → Update count[i] = count[j] // 計數由 j 的計數決定  \n      No →  \n       → Decision: length[j] + 1 == length[i]? // 是否相等  \n        Yes →  \n         → Update count[i] = count[i] + count[j] // 加上另一種等長子序列的計數  \n        No → // 不需要任何更新  \n  → // i 的迴圈結束  \n→ // 所有 i、j 的迴圈結束  \n→ Find maxLen = max(length[0..n-1]) // 找出最長遞增子序列長度  \n→ Sum count[i] for all i where length[i] == maxLen → total // 取得該長度的子序列總數  \n→ Output total // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findNumberOfLIS(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        lengths = [1] * n          # LIS length ending at i\n        counts = [1] * n           # number of LIS ending at i\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if lengths[j] + 1 > lengths[i]:\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                    elif lengths[j] + 1 == lengths[i]:\n                        counts[i] += counts[j]\n\n        longest = max(lengths)\n        return sum(c for l, c in zip(lengths, counts) if l == longest)\n\ndef main():\n    data = sys.stdin.read()\n    nums = []\n\n    # 尝试提取形如 \"nums = [...]\" 的列表\n    m = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if m:\n        try:\n            nums = ast.literal_eval(m.group(1))\n        except Exception:\n            pass\n\n    # 若未成功，直接提取所有整数\n    if not nums:\n        nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    solution = Solution()\n    result = solution.findNumberOfLIS(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode686.json",
    "problem_index_in_file": 0,
    "title": "Repeated String Match",
    "description_snippet": "Given two strings a and b, return the minimum number of times you should repeat string a so that str...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code step-by-step explanation.\n\nWe need algorithm: minimal repeats of a such that b is substring of repeated a. Approach: compute repeats needed: at least ceil(len(b)/len(a)). Then check repeated string of length repeats * len(a) + maybe one more repeat to cover edge where b crosses boundary.\n\nPseudo steps:\n\nStart\n→ Step1: Compute lenA = length of a, lenB = length of b\n→ Step2: Compute minRepeats = ceil(lenB / lenA) // minimal repeats to cover b length\n→ Step3: Build repeated string s = repeat a minRepeats times\n→ Step4: If b is substring of s: return minRepeats\n→ Step5: Build s2 = repeat a (minRepeats + 1) times\n→ Step6: If b is substring of s2: return minRepeats + 1\n→ Step7: return -1\n\nEdge case: a or b empty? Assume non-empty. We'll mention check.\n\nImplement virtual code accordingly.\n\nUse Decision branches for substring checks.\n\nAlso we need to produce explanation per line. Use arrow symbol. Format each line with '虛擬碼步驟 // 解釋'.\n\nLet's craft lines.\n\nStart // 程式開始執行\n→ Step 1: lenA ← Length(a) // 取得字串 a 的長度\n→ Step 2: lenB ← Length(b) // 取得字串 b 的長度\n→ Decision: If lenA == 0? // 檢查 a 是否為空字串\n    Yes → Step 3: Return -1 // 空字串無法產生任何子字串\n    No → Continue\n→ Step 4: minRep ← Ceil(lenB / lenA) // 以 a 的長度覆蓋 b 的最小重複次數\n→ Step 5: s ← Repeat(a, minRep) // 將 a 重複 minRep 次\n→ Decision: If b is substring of s? // 判斷 b 是否在 s 內\n    Yes → Step 6: Return minRep // 成功，回傳最小重複次數\n    No → Continue\n→ Step 7: s2 ← Repeat(a, minRep + 1) // 再多重複一次以覆蓋跨界情況\n→ Decision: If b is substring of s2? // 再次判斷\n    Yes → Step 8: Return minRep + 1 // 成功，回傳 minRep+1\n    No → Step 9: Return -1 // 兩種情況均不符合，返回 -1\nEnd // 程式執行結束\n\nMake sure to use \"虛擬碼步驟\" words; each line start with arrow. For Decision lines we indent sublines? The example uses indentation. We can mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: lenA ← Length(a) // 取得字串 a 的長度  \n→ Step 2: lenB ← Length(b) // 取得字串 b 的長度  \n→ Decision: 如果 lenA == 0? // 檢查 a 是否為空字串  \n  Yes → Step 3: Return -1 // 空字串無法產生任何子字串，直接返回 -1  \n  No → (繼續)  \n→ Step 4: minRep ← Ceil(lenB / lenA) // 計算至少要重複多少次 a 才能覆蓋 b 的長度  \n→ Step 5: s ← Repeat(a, minRep) // 把 a 重複 minRep 次  \n→ Decision: 如果 b 是 s 的子字串? // 判斷 b 是否已在已生成的串中  \n  Yes → Step 6: Return minRep // 成功，回傳最小重複次數  \n  No → (繼續)  \n→ Step 7: s2 ← Repeat(a, minRep + 1) // 再多重複一次以處理跨界情況  \n→ Decision: 如果 b 是 s2 的子字串? // 再次判斷  \n  Yes → Step 8: Return minRep + 1 // 成功，回傳 minRep + 1  \n  No → Step 9: Return -1 // 兩種情況均不符合，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def repeatedStringMatch(self, A: str, B: str) -> int:\n        \"\"\"\n        Return the minimal number of times A must be repeated\n        so that B becomes a substring of the repeated string.\n        If impossible, return -1.\n        \"\"\"\n        len_a = len(A)\n        len_b = len(B)\n\n        # If A is empty, B can never be a substring unless B is also empty\n        if len_a == 0:\n            return -1 if len_b > 0 else 0\n\n        # Minimum repetitions needed to cover the length of B\n        min_rep = (len_b + len_a - 1) // len_a\n\n        # Build the string with minimal repetitions\n        repeated = A * min_rep\n        if B in repeated:\n            return min_rep\n\n        # Check one more repetition to cover cross-boundary cases\n        repeated += A\n        if B in repeated:\n            return min_rep + 1\n\n        return -1\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n\n    # Parse the input format: a = \"string\", b = \"string\"\n    match = re.search(r'a\\s*=\\s*\"([^\"]*)\"\\s*,\\s*b\\s*=\\s*\"([^\"]*)\"', data)\n    if not match:\n        # Fallback: try a simpler split if quotes are omitted\n        parts = data.split(',')\n        a = parts[0].split('=')[1].strip()\n        b = parts[1].split('=')[1].strip()\n    else:\n        a, b = match.group(1), match.group(2)\n\n    sol = Solution()\n    result = sol.repeatedStringMatch(a, b)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"abcd\", b = \"cdabcdab\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = \"a\", b = \"aa\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode152.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product Subarray",
    "description_snippet": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for maximum product subarray. Use DP tracking max and min product up to current index. Steps: initialize maxProd, minProd, result with first element. Iterate from index 1. For each num, if negative swap maxProd/minProd. Update maxProd = max(num, maxProd * num). minProd = min(num, minProd * num). Update result = max(result, maxProd). End loop. Return result.\n\nProvide line by line virtual code with explanations.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 取得輸入數列  \n→ Decision: nums 是否為空？  \n    Yes → Step 2: 回傳 0 // 空陣列直接回傳 0  \n    No →  \n→ Step 3: 設定 maxProd = nums[0] // 以第一個數字作為初始最大積  \n→ Step 4: 設定 minProd = nums[0] // 以第一個數字作為初始最小積  \n→ Step 5: 設定 result  = nums[0] // 初始結果為第一個數字  \n→ Step 6: 從 i = 1 開始遍歷 nums // 從第二個元素開始處理  \n    → Loop: i < nums.length  \n        → Step 7: num = nums[i] // 取目前元素  \n        → Decision: num < 0? // 檢查是否為負數  \n            Yes → Step 8: swap(maxProd, minProd) // 乘以負數會把最大變成最小  \n            No →  \n        → Step 9: maxProd = max(num, maxProd * num) // 更新最大積  \n        → Step 10: minProd = min(num, minProd * num) // 更新最小積  \n        → Step 11: result = max(result, maxProd) // 可能更新整體最大結果  \n    → End Loop  \n→ Step 12: 回傳 result // 回傳最大子陣列積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProduct(self, nums):\n        \"\"\"\n        找到 nums 的子陣列中乘積最大的值。\n        使用動態規劃，同時跟蹤到目前位置的最大乘積和最小乘積。\n        \"\"\"\n        if not nums:\n            return 0\n\n        max_prod = min_prod = result = nums[0]\n\n        for num in nums[1:]:\n            if num < 0:\n                # 乘以負數會把最大乘積變成最小，反之亦然\n                max_prod, min_prod = min_prod, max_prod\n\n            max_prod = max(num, max_prod * num)\n            min_prod = min(num, min_prod * num)\n\n            result = max(result, max_prod)\n\n        return result\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中提取陣列\n    # 例如 \"nums = [2,3,-2,4]\" 或只是一個列表字串 \"[2,3,-2,4]\"\n    nums_match = re.search(r'\\[.*?\\]', data)\n    if nums_match:\n        nums = eval(nums_match.group(0))\n    else:\n        nums = []\n\n    sol = Solution()\n    print(sol.maxProduct(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-2,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [-2,0,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode494.json",
    "problem_index_in_file": 0,
    "title": "Target Sum",
    "description_snippet": "You are given an integer array nums and an integer target.\n\nYou want to build an expression out of n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: given array nums and target, find number of expressions by assigning +/- signs to each integer, evaluating to target. Essentially classic target sum DP/backtracking.\n\nWe output each line with \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision etc. We must not output real code, only virtual steps.\n\nWe need step-by-step algorithm: maybe recursive DFS with memoization or DP using hashmap. We'll outline:\n\nStart\n→ Step 1: Initialize memoization map // store results for (index, current sum)\n→ Decision: if index == length of nums? // base case\n   Yes → Step 2: If current sum == target then return 1 else return 0\n   No  → Step 3: If (index, current sum) in memo then return memo value\n→ Step 4: CountPlus = DFS(index+1, current sum + nums[index]) // adding '+'\n→ Step 5: CountMinus = DFS(index+1, current sum - nums[index]) // adding '-'\n→ Step 6: Result = CountPlus + CountMinus\n→ Step 7: memo[(index,current sum)] = Result\n→ Step 8: Return Result\nEnd\n\nAlso we need initial call with index 0, sum 0.\n\nLet's produce lines accordingly.\n\nMake sure each line is virtual code with arrow. Example: \"→ Step 1: 建立快取 map(index,sum) -> count\" etc.\n\nLet's produce lines exactly. Use \"Start // 程式開始執行\".\n\nLet's produce.\n\nAlso need initial call: maybe Step 0: return DFS(0,0). We can treat that as Step 1.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化快取 Memo：字典型態，鍵為 (index, currentSum)，值為符合條件的表達式數量 // 用於避免重複計算  \n→ Step 2: 呼叫 DFS(0, 0) // 從索引 0 開始，初始累加和為 0  \n→ Decision: DFS(index, currentSum) 內部  \n    → If index == nums.length? // 檢查是否已處理完所有數字  \n        Yes → Step 3: 若 currentSum == target? // 判斷累加和是否等於目標值  \n            Yes → Step 4: 回傳 1 // 找到一個合法表達式  \n            No  → Step 5: 回傳 0 // 不是合法表達式  \n        No  → Step 6: 若 (index, currentSum) 已在 Memo 中? // 檢查快取  \n            Yes → Step 7: 回傳 Memo[(index, currentSum)] // 直接回傳快取值  \n            No  → Step 8: 進行遞迴計算  \n                → Step 9: CountPlus = DFS(index + 1, currentSum + nums[index]) // 加上 '+'  \n                → Step 10: CountMinus = DFS(index + 1, currentSum - nums[index]) // 加上 '-'  \n                → Step 11: Result = CountPlus + CountMinus // 合計兩種選擇  \n                → Step 12: Memo[(index, currentSum)] = Result // 將結果存入快取  \n                → Step 13: 回傳 Result // 回傳計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findTargetSumWays(self, nums, target):\n        dp = defaultdict(int)\n        dp[0] = 1\n        for num in nums:\n            next_dp = defaultdict(int)\n            for s in dp:\n                next_dp[s + num] += dp[s]\n                next_dp[s - num] += dp[s]\n            dp = next_dp\n        return dp[target]\n\ndef parse_input(input_str):\n    # Extract list of numbers\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', input_str)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', input_str)\n    if not nums_match or not target_match:\n        raise ValueError(\"Invalid input format\")\n    nums = ast.literal_eval(nums_match.group(1))\n    target = int(target_match.group(1))\n    return nums, target\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    nums, target = parse_input(data)\n    sol = Solution()\n    result = sol.findTargetSumWays(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1], target = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode447.json",
    "problem_index_in_file": 0,
    "title": "Number of Boomerangs",
    "description_snippet": "You are given n points in the plane that are all distinct, where points[i] = [x_i, y_i]. A boomerang...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanation for counting boomerangs. Steps: For each point i, compute distances to others, count frequency. For each distance with count c, add c*(c-1) to answer. Use loops. Use structure Start, End, Decision. Provide virtual steps. Should include arrow, etc. Provide line by line. Let's craft. Use maybe variables: n, points, answer, i, j, distanceMap, dist. Use loops: for i from 0 to n-1, initialize map, for j from 0 to n-1, if j==i skip else compute dx,dy,dist, increment map[dist]. After inner loop, for each count in map, answer += count*(count-1). Return answer. Use decision to skip self. Provide explanation. Let's format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 answer = 0 // 用來累計所有雙曲線數量  \n→ Step 2: 取得 n = points 的長度 // 獲得點的數目  \n→ Step 3: 循環 i 從 0 到 n-1 // 每個點作為「起點」  \n    → Step 4: 初始化 distanceMap 為空字典 // 儲存起點到其他點的距離頻數  \n    → Step 5: 循環 j 從 0 到 n-1 // 檢查所有其他點  \n        → Decision: 如果 i 等於 j? // 防止自己算距離  \n            Yes → Continue // 跳過本次迴圈  \n            No →  \n                → Step 6: 計算 dx = points[i][0] - points[j][0] // x 方向差  \n                → Step 7: 計算 dy = points[i][1] - points[j][1] // y 方向差  \n                → Step 8: 計算 dist = dx*dx + dy*dy // 使用平方距離避免平方根  \n                → Step 9: 更新 distanceMap[dist] = distanceMap.get(dist, 0) + 1 // 计数  \n    → Step 10: 對 distanceMap 的每個 count 值  \n        → Step 11: answer = answer + count * (count - 1) // 每組距離可組合的雙曲線數  \n→ Step 12: 返回 answer // 完成結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef count_boomerangs(points):\n    \"\"\"計算雙曲線的數量，時間複雜度 O(n^2)\"\"\"\n    total = 0\n    for x1, y1 in points:\n        dist_count = defaultdict(int)\n        for x2, y2 in points:\n            if (x1, y1) != (x2, y2):\n                d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n                dist_count[d] += 1\n        for cnt in dist_count.values():\n            total += cnt * (cnt - 1)\n    return total\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整行資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 找出第一個 '['，從那裡開始解析成 list\n    start = raw_input.find('[')\n    if start == -1:\n        print(0)\n        sys.exit(0)\n    points_str = raw_input[start:]\n    try:\n        points = ast.literal_eval(points_str)\n    except Exception:\n        # 若解析失敗，直接輸出 0\n        print(0)\n        sys.exit(0)\n\n    # 若輸入不是二維列表，直接輸出 0\n    if not isinstance(points, list) or not all(isinstance(p, list) and len(p) == 2 for p in points):\n        print(0)\n        sys.exit(0)\n\n    result = count_boomerangs(points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[0,0],[1,0],[2,0]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,1],[2,2],[3,3]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "points = [[1,1]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode384.json",
    "problem_index_in_file": 0,
    "title": "Shuffle an Array",
    "description_snippet": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps describing algorithm for array shuffle: solution class with constructor, reset, shuffle. Use Fisher-Yates algorithm. Provide step-by-step pseudo code. Each line: virtual code step + explanation.\n\nWe need to output lines with Start, End etc.\n\nWe need to use arrow '→', Decision:, etc. Also maintain the structure.\n\nLet's produce:\n\nStart // program start\n→ Step 1: 定義類別 Solution // 定義Solution類別\n→ Step 2: 成員變量 original, current // 存儲原始陣列和工作陣列\n\nConstructor:\n\n→ Step 3: Constructor(nums): // 構造函數\n    → Step 4: original ← copy of nums // 保存原始陣列\n    → Step 5: current ← copy of nums // 初始化工作陣列\n    → Step 6: return // 结束构造\n\nreset method:\n\n→ Step 7: reset(): // 重置方法\n    → Step 8: current ← copy of original // 恢復原始陣列\n    → Step 9: return current // 返回重置後陣列\n\nshuffle method:\n\n→ Step 10: shuffle(): // 洗牌方法\n    → Step 11: n ← length of current // 取得陣列長度\n    → Decision: n > 1? // 檢查陣列長度是否大於1\n        Yes → Loop i from 0 to n-1 // 逐個位置\n            → Decision: i == n-1? // 最後一個元素不需要交換\n                No → Step 12: j ← random integer in [i, n-1] // 隨機選擇交換位置\n                → Step 13: swap current[i] with current[j] // 交換元素\n                Yes → Step 14: continue // 跳過最後一步\n        No → Step 15: return current // 長度<=1直接返回\n    → Step 16: return current // 返回洗牌後陣列\n\nEnd\n\nBut we need to use \"→\" arrows and \"Decision:\" etc.\n\nAlso need to show Start and End.\n\nEnsure each line ends with \"// 解釋\".\n\nLet's produce more formal step by step:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類\n→ Step 2: 定義成員變量 original, current // 存原始陣列與工作陣列\n→ Step 3: Constructor(nums): // 建構子接收陣列\n    → Step 4: original ← copy(nums) // 複製輸入為原始陣列\n    → Step 5: current ← copy(nums) // 初始化工作陣列\n    → Step 6: return // 結束建構\n→ Step 7: reset(): // 重置方法\n    → Step 8: current ← copy(original) // 將工作陣列設回原始陣列\n    → Step 9: return current // 回傳重置後陣列\n→ Step 10: shuffle(): // 洗牌方法\n    → Step 11: n ← len(current) // 取得陣列長度\n    → Decision: n <= 1? // 若陣列長度小於等於1\n        Yes → Step 12: return current // 直接回傳\n        No  → Step 13: for i from 0 to n-1 // 遍歷每個位置\n            → Decision: i == n-1? // 最後一個位置不需要處理\n                Yes → Step 14: continue // 跳過\n                No  → Step 15: j ← random integer between i and n-1 // 隨機選取交換索引\n                    → Step 16: swap current[i], current[j] // 交換元素\n    → Step 17: return current // 回傳洗牌後陣列\nEnd // 程式結束\n\nBut need to maintain the arrow formatting. Use \"→\" before each step, and \"Decision:\" for decisions.\n\nEnsure each line ends with // explanation.\n\nLet's format properly:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 定義成員變量 original, current // 儲存原始陣列與工作陣列\n→ Step 3: Constructor(nums): // 建構子接收陣列\n    → Step 4: original ← copy(nums) // 複製輸入陣列為原始陣列\n    → Step 5: current ← copy(nums) // 初始化工作陣列為同一內容\n    → Step 6: return // 完成建構\n→ Step 7: reset(): // 重置方法\n    → Step 8: current ← copy(original) // 把工作陣列還原為原始陣列\n    → Step 9: return current // 回傳重置後陣列\n→ Step 10: shuffle(): // 洗牌方法\n    → Step 11: n ← len(current) // 取得陣列長度\n    → Decision: n <= 1? // 是否需要洗牌\n        Yes → Step 12: return current // 長度 <=1 直接回傳\n        No  → Step 13: for i from 0 to n-1 // 遍歷每個索引\n            → Decision: i == n-1? // 最後一個位置不需處理\n                Yes → Step 14: continue // 跳過\n                No  → Step 15: j ← random integer in [i, n-1] // 隨機選擇交換位置\n                    → Step 16: swap current[i], current[j] // 交換元素\n    → Step 17: return current // 回傳洗牌後陣列\nEnd // 程式結束\n\nBut arrow indentation: we used spaces. But format requires \"→\" before each step, including inside decision branches.\n\nWe can also use indentation lines for clarity but not necessary.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 定義成員變量 original, current // 儲存原始陣列與工作陣列  \n\n→ Step 3: Constructor(nums): // 建構子接收陣列  \n  → Step 4: original ← copy(nums) // 複製輸入陣列為原始陣列  \n  → Step 5: current ← copy(nums) // 初始化工作陣列為同一內容  \n  → Step 6: return // 完成建構  \n\n→ Step 7: reset(): // 重置方法  \n  → Step 8: current ← copy(original) // 把工作陣列還原為原始陣列  \n  → Step 9: return current // 回傳重置後陣列  \n\n→ Step 10: shuffle(): // 洗牌方法  \n  → Step 11: n ← len(current) // 取得陣列長度  \n  → Decision: n <= 1? // 是否需要洗牌  \n   Yes → Step 12: return current // 長度 <=1 直接回傳  \n   No  → Step 13: for i from 0 to n-1 // 遍歷每個索引  \n     → Decision: i == n-1? // 最後一個位置不需處理  \n      Yes → Step 14: continue // 跳過  \n      No  → Step 15: j ← random integer in [i, n-1] // 隨機選擇交換位置  \n        → Step 16: swap current[i], current[j] // 交換元素  \n  → Step 17: return current // 回傳洗牌後陣列  \n\nEnd // 程式結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)  # 保存原始陣列\n        self.nums = list(nums)      # 工作陣列，初始化為原始陣列\n\n    def reset(self):\n        \"\"\"重置並返回原始陣列\"\"\"\n        self.nums = list(self.original)\n        return self.nums\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 洗牌演算法返回一個隨機排列\"\"\"\n        arr = list(self.nums)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef split_top_level(s: str):\n    \"\"\"\n    把「['Solution', ...], [[[1, 2, 3]], [], [], []]」這樣的字串\n    拆成兩部分：前面是命令列表，後面是對應的參數列表。\n    \"\"\"\n    depth = 0\n    for idx, ch in enumerate(s):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            return s[:idx].strip(), s[idx + 1 :].strip()\n    return s.strip(), None\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    cmd_str, arg_str = split_top_level(data)\n    commands = json.loads(cmd_str)\n    arguments = json.loads(arg_str)\n\n    result = []\n    obj = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            result.append(None)           # 建構子回傳 null\n        elif cmd == \"reset\":\n            result.append(obj.reset())\n        elif cmd == \"shuffle\":\n            result.append(obj.shuffle())\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[None,[2,1,3],[1,2,3],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[None, [2, 1, 3], [1, 2, 3], [2, 3, 1]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode405.json",
    "problem_index_in_file": 0,
    "title": "Convert a Number to Hexadecimal",
    "description_snippet": "Given a 32-bit integer num, return a string representing its hexadecimal representation. For negativ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the algorithm to convert 32-bit integer to hex string, negative handled via two's complement, no built-in methods, lowercase, no leading zeros except zero itself. Must produce virtual code step-by-step with explanations. Use Start, End, Decision, arrows. Also handle negative: for negative, treat as unsigned 32-bit representation: num & 0xFFFFFFFF or just while loop with unsigned shift? Since we cannot use built-in. But can use bitwise operations.\n\nLet's design steps:\n\nStart\n→ Step 1: if num == 0 → output \"0\" and End\n→ Step 2: If num < 0 → num = num + 2^32 // convert to unsigned\n→ Step 3: Initialize empty string result\n→ Step 4: While num > 0:\n    → Decision: Check num % 16? But mod not allowed? We can use num & 15 to get remainder\n    → Step 5: remainder = num & 15\n    → Step 6: Map remainder to hex char (0-9 a-f). Can use conditional mapping or array.\n    → Step 7: Prepend char to result (or build reverse then reverse)\n    → Step 8: num = num >> 4 (unsigned shift). For signed shift if negative? But num is non-negative now.\n→ Step 9: Output result\nEnd\n\nNeed to show mapping maybe with decision chain.\n\nLet's produce virtual code.\n\nBe careful with Start, End. Use arrow lines. Provide explanation comments after each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 num 是否為 0 // 判斷是否為零，直接返回  \n    Yes → Step 2: 輸出 \"0\" // 零的十六進制表示  \n    No  → → Step 3: 檢查 num 是否為負數 // 若負，先轉成 unsigned 32 位表示  \n        Yes → Step 4: num = num + 2^32 // 兩's complement 將負數轉為正整數  \n        No  → → Step 5: 繼續執行 // 正數保持不變  \n→ Step 6: 建立空字串 result // 用來儲存十六進制字符  \n→ Decision: num > 0? // 循環直到全部位數處理完  \n    Yes → → Step 7: remainder = num & 15 // 取得最低 4 位（相當於 mod 16）  \n    → Step 8: 將 remainder 轉為字符 ch // 0-9 對應 '0'-'9'，10-15 對應 'a'-'f'  \n        Decision: remainder < 10?  \n            Yes → ch = '0' + remainder // 數字轉字符  \n            No  → ch = 'a' + (remainder - 10) // 十六進制字母轉字符  \n    → Step 9: result = ch + result // 在前面加入新字符（逆序構造）  \n    → Step 10: num = num >> 4 // 右移 4 位，處理下一個 nibble  \n    → Decision: num > 0? // 檢查是否還有位需要處理  \n        Yes → 回到 Step 7  \n        No  → → Step 11: 輸出 result // 完整十六進制字符串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def toHex(self, num: int) -> str:\n        \"\"\"Convert a 32‑bit signed integer to its hexadecimal string representation.\"\"\"\n        if num == 0:\n            return \"0\"\n\n        # Handle negative numbers using two's complement (32‑bit)\n        if num < 0:\n            num += 1 << 32  # equivalent to num + 2**32\n\n        res = \"\"\n        while num:\n            # Get the lowest 4 bits (equivalent to num % 16)\n            rem = num & 15\n            # Map the remainder to a hex character\n            if rem < 10:\n                ch = chr(ord('0') + rem)\n            else:\n                ch = chr(ord('a') + rem - 10)\n            # Prepend the character (build string in reverse order)\n            res = ch + res\n            # Shift right by 4 bits to process the next nibble\n            num >>= 4\n\n        return res\n\ndef main() -> None:\n    # Read entire input from stdin\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # Extract the first integer found in the input\n    match = re.search(r'[-]?\\d+', data)\n    if not match:\n        return\n\n    num = int(match.group(0))\n    solution = Solution()\n    # Print the hexadecimal representation\n    print(solution.toHex(num))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 26",
          "expected_output": "1a",
          "success": true,
          "output": "1a"
        },
        {
          "example_index": 1,
          "input": "num = -1",
          "expected_output": "ffffffff",
          "success": true,
          "output": "ffffffff"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode722.json",
    "problem_index_in_file": 0,
    "title": "Remove Comments",
    "description_snippet": "Given a C++ program, remove comments from it. The program source is an array of strings source where...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code flow that given source array removes comments. Outline: iterate lines, maintain in_block flag. For each line, process char by char. Build output string. When encounter \"//\" outside block -> break line processing. When encounter \"/*\" outside block -> set flag. When in block, look for \"*/\" to end. After line processed, if not empty and not inside block (or we may include content even if block continues?) Actually if line ends while still in block, we skip rest of that line entirely. So at end of line, if output_str non-empty, add to result. Also if output_str empty -> skip. After processing all lines, return result.\n\nWe need to produce virtual code lines. Let's produce pseudo code:\n\nStart\n→ Decision: 是否有輸入 source? (Assume yes)\n    → Step: 初始化結果列表 res ← 空\n    → Step: in_block ← False\n    → For each line in source (index i from 0 to n-1)\n        → Step: current_line ← source[i]\n        → Step: i ← 0\n        → Step: line_buffer ← 空\n        → While i < len(current_line)\n            → Decision: in_block? \n                Yes → Decision: current_line[i:i+2] == \"*/\"?\n                    Yes → in_block ← False\n                          i ← i + 2\n                    No  → i ← i + 1   // skip character inside block\n                No  → Decision: current_line[i:i+2] == \"//\"?\n                    Yes → Break   // rest of line ignored\n                    No  → Decision: current_line[i:i+2] == \"/*\"?\n                        Yes → in_block ← True\n                              i ← i + 2\n                        No  → Step: line_buffer += current_line[i]\n                              i ← i + 1\n        → Decision: line_buffer 非空? \n            Yes → Step: res.append(line_buffer)\n            No  →  // do nothing\n→ End // 返回 res\n\nNeed to output with virtual code style: Start, End, Step, Decision, Yes→, No→. Ensure each line ends with // 解釋. Provide each step line.\n\nLet's craft it. Ensure use of arrow arrow. Use \"→\" after Start, etc. Use indentation? We can just indent with spaces. Use \"Yes →\" and \"No →\". Use \"Decision:\" lines. Provide explanation after comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 初始化結果列表 res ← 空 // 建立一個空列表存放處理後的行\n→ Step: in_block ← False // 標記是否目前處於區塊註解中\n→ For 每行 i 在 source 之中 // 逐行遍歷原始程式碼\n    → Step: current_line ← source[i] // 取得目前處理的行\n    → Step: i ← 0 // 設定字符指標\n    → Step: line_buffer ← 空 // 用來儲存去註解後的內容\n    → While i < len(current_line) // 逐字符掃描\n        → Decision: in_block? // 判斷目前是否處於區塊註解\n            Yes →\n                → Decision: current_line[i:i+2] == \"*/\"? // 判斷區塊註解結束符號\n                    Yes →\n                        → Step: in_block ← False // 結束區塊註解\n                        → Step: i ← i + 2 // 跳過 \"*/\"\n                    No →\n                        → Step: i ← i + 1 // 在區塊註解內，忽略此字符\n            No →\n                → Decision: current_line[i:i+2] == \"//\"? // 判斷行註解符號\n                    Yes →\n                        → Step: Break // 跳出 while，剩餘行都忽略\n                    No →\n                        → Decision: current_line[i:i+2] == \"/*\"? // 判斷區塊註解開始符號\n                            Yes →\n                                → Step: in_block ← True // 開始區塊註解\n                                → Step: i ← i + 2 // 跳過 \"/*\"\n                            No →\n                                → Step: line_buffer += current_line[i] // 將字符加入輸出緩衝區\n                                → Step: i ← i + 1 // 移動到下一字符\n    → Decision: line_buffer 非空? // 檢查行處理後是否有可輸出內容\n        Yes →\n            → Step: res.append(line_buffer) // 將非空行加入結果列表\n        No → // 若空行，則不加入結果\nEnd // 程式執行結束，返回 res 作為最終去註解後的程式碼列表",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n        new_line = []\n\n        for line in source:\n            i = 0\n            if not in_block:\n                new_line = []\n            while i < len(line):\n                if not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '*':\n                    in_block = True\n                    i += 1  # skip '*'\n                elif in_block and i + 1 < len(line) and line[i] == '*' and line[i + 1] == '/':\n                    in_block = False\n                    i += 1  # skip '/'\n                elif not in_block and i + 1 < len(line) and line[i] == '/' and line[i + 1] == '/':\n                    break  # line comment, skip rest\n                elif not in_block:\n                    new_line.append(line[i])\n                i += 1\n            if new_line and not in_block:\n                res.append(''.join(new_line))\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect format: source = [ ... ]\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    try:\n        source = ast.literal_eval(expr)\n    except Exception:\n        source = []\n    sol = Solution()\n    result = sol.removeComments(source)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]",
          "expected_output": "[\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]",
          "success": true,
          "output": "['int main()', '{ ', '  ', 'int a, b, c;', 'a = b + c;', '}']"
        },
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "success": true,
          "output": "['ab']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode292.json",
    "problem_index_in_file": 0,
    "title": "Nim Game",
    "description_snippet": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with explanation after //.\n\nProblem: Nim game with 1-3 stones removal, who takes last wins. Classic: win if n % 4 != 0. So algorithm: if n mod 4 == 0 then false else true. But we need virtual code.\n\nNeed to use virtual code structure with arrows etc. Should be step by step. Start, input n, compute remainder, decision, return true/false.\n\nWe need to output each line with virtual code step, space, // explanation.\n\nAlso use virtual arrows: →, Yes →, No →. Use Decision:.\n\nExample format.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 取得堆疊中的石子數量\n→ Step 2: 計算 n mod 4 // 計算石子數除以 4 的餘數\n→ Decision: 是否餘數為 0? // 判斷能否勝利\n    Yes → Step 3: 返回 false // 若餘數為 0，無法勝利\n    No  → Step 4: 返回 true // 若餘數不為 0，可勝利\nEnd // 程式執行結束\n\nBut we need to ensure each line includes step description and // explanation. We need to include arrows for each step. For Decision we indent the Yes/No branches. Use indentation to show structure.\n\nAlso each line is a virtual code step. The Decision line itself is a step. The Yes and No lines are sub-steps.\n\nMake sure to include \"→\" before each step.\n\nThe lines:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n // 取得堆疊中的石子數量\n→ Step 2: 計算 n mod 4 // 計算石子數除以 4 的餘數\n→ Decision: 是否餘數為 0? // 判斷能否勝利\n    Yes → Step 3: 返回 false // 若餘數為 0，無法勝利\n    No  → Step 4: 返回 true // 若餘數不為 0，可勝利\nEnd // 程式執行結束\n\nWe need to make sure indentation uses spaces before Yes and No lines. The example uses \"    Yes →\". So same.\n\nAlso note: The step numbering is \"Step 1\", etc. That's fine.\n\nWe also might consider alternative variable names: n. But okay.\n\nReturn false/true as booleans.\n\nThe output lines must be exactly like that. Ensure no extra text.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n // 取得堆疊中的石子數量  \n→ Step 2: 計算 n mod 4 // 計算石子數除以 4 的餘數  \n→ Decision: 是否餘數為 0? // 判斷能否勝利  \n Yes → Step 3: 返回 false // 若餘數為 0，無法勝利  \n No  → Step 4: 返回 true // 若餘數不為 0，可勝利  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 若輸入類似 \"n = 4\"，取等號右側的數字\n    if '=' in raw_input:\n        _, value = raw_input.split('=', 1)\n        n = int(value.strip())\n    else:\n        # 直接以整數輸入為主\n        n = int(raw_input)\n\n    # Nim 的規則：若石子數為 4 的倍數，先手必輸\n    can_win = n % 4 != 0\n\n    # 將結果輸出成 'true' 或 'false'\n    print('true' if can_win else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode263.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number",
    "description_snippet": "An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.\n\nGiv...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments, in Traditional Chinese. Provide steps. Let's craft. Need start, decision, loop. Approach: divide n by 2,3,5 repeatedly. Check if remaining 1. Also handle n <=0 false. Let's produce steps.\n\nUse virtual code: Start, → Step 1: if n <= 0? etc.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得要判斷的數字\n→ Decision: 如果 n <= 0? // Ugly number 必須是正整數\n    Yes → Step 2: 返回 false // 非正數不是 Ugly\n    No  →\n→ Step 3: 對每個質因子 2,3,5 做除法 // 逐步消除合法質因子\n        → Step 3.1: While n % 2 == 0 → n = n / 2 // 消除 2\n        → Step 3.2: While n % 3 == 0 → n = n / 3 // 消除 3\n        → Step 3.3: While n % 5 == 0 → n = n / 5 // 消除 5\n→ Decision: 如果 n == 1? // 剩餘 1 表示只含 2,3,5\n    Yes → Step 4: 返回 true // 是 Ugly 數\n    No  → Step 5: 返回 false // 含有其他質因子\nEnd // 程式執行結束\n\nBut need virtual code syntax. Use arrow, decisions. Format: Use \"→ Step\" etc.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得要判斷的數字  \n→ Decision: 如果 n <= 0? // Ugly 數必為正整數  \n    Yes → Step 2: 返回 false // 非正數不是 Ugly 數  \n    No →  \n→ Step 3: 循環移除合法質因子 2, 3, 5  \n    → Step 3.1: While n % 2 == 0 → n = n / 2 // 消除所有 2 的因子  \n    → Step 3.2: While n % 3 == 0 → n = n / 3 // 消除所有 3 的因子  \n    → Step 3.3: While n % 5 == 0 → n = n / 5 // 消除所有 5 的因子  \n→ Decision: 如果 n == 1? // 所有質因子已被移除，僅剩 1  \n    Yes → Step 4: 返回 true // 是 Ugly 數  \n    No  → Step 5: 返回 false // 含有其他質因子，非 Ugly 數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isUgly(self, n: int) -> bool:\n        \"\"\"\n        判斷正整數 n 是否為 Ugly 數。\n        Ugly 數的質因子只能是 2、3、5。\n        \"\"\"\n        if n <= 0:\n            return False\n        for p in (2, 3, 5):\n            while n % p == 0:\n                n //= p\n        return n == 1\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入、處理並輸出結果。\n    支援輸入形如 'n = 6' 或 '6' 等格式。\n    \"\"\"\n    data = sys.stdin.read()\n    # 從輸入中擷取第一個整數\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n\n    sol = Solution()\n    result = sol.isUgly(n)\n    # 輸出小寫 'true' / 'false'\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode78.json",
    "problem_index_in_file": 0,
    "title": "Subsets",
    "description_snippet": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all subsets of a unique integer array. Use virtual code structure. Each line: step + comment. Use Start, End, Decision: etc.\n\nWe need to describe algorithm, likely backtracking. Use iterative or recursion. Provide steps.\n\nLet's outline:\n\nStart\n\n→ Step 1: Initialize result list with empty set\n\n→ Step 2: Define recursive function dfs(index, current_subset)\n\n→ Decision: If index == length(nums)?\n\nYes → Step 3: Append copy of current_subset to result\n\nNo → Step 4: Include current element\n\n→ Step 5: Call dfs(index+1, current_subset + [nums[index]])\n\n→ Step 6: Exclude current element\n\n→ Step 7: Call dfs(index+1, current_subset)\n\n→ End recursion\n\n→ Call dfs(0, [])\n\n→ End // return result\n\nBut we must include comments. Each line with arrow etc.\n\nLet's produce each line with \"→\" or \"Decision:\".\n\nBe careful to use virtual code arrows consistent with example: \"→ Step X:\" or \"Decision:\" with \"Yes →\" \"No →\".\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize result = [ [] ] // 用來存所有子集，先放空集\n\n→ Step 2: Define function dfs(idx, subset) // 參數 idx 為目前考慮的數位索引，subset 為已經選取的子集\n\n→ Decision: 如果 idx 等於 nums.length? // 判斷是否已處理完所有元素\n\n    Yes → Step 3: Append copy of subset to result // 把目前形成的子集加入結果\n\n    No → Step 4: Include nums[idx] into subset // 先選擇把當前元素加入子集\n\n        → Step 5: Call dfs(idx + 1, subset ∪ {nums[idx]}) // 進行遞迴\n\n    No  → Step 6: Exclude nums[idx] from subset // 不選取當前元素\n\n        → Step 7: Call dfs(idx + 1, subset) // 進行遞迴\n\n→ End // 退出函式\n\n→ Step 8: Call dfs(0, []) // 從第一個元素開始\n\n→ End // 程式結束，結果在 result\n\nBut need each line with \"虛擬碼步驟 [space] // 解釋\". Let's produce accordingly.\n\nHowever, we must follow the output format: Each line: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nMake sure to use \"→\" arrow before each step, \"Decision:\" etc.\n\nWe should not combine lines with \"Yes →\" and \"No →\" into same line? Example in sample: they use indent. Let's mimic.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize result = [ [] ] // 用來存所有子集，先放空集\n\n→ Step 2: Define function dfs(idx, subset) // idx 是目前索引，subset 為已選取子集\n\n→ Decision: idx 等於 nums.length? // 判斷是否處理完所有元素\n\n    Yes → Step 3: Append copy of subset to result // 把完整子集加入結果\n\n    No  → Step 4: Include nums[idx] into subset // 選取當前元素\n\n        → Step 5: Call dfs(idx + 1, subset ∪ {nums[idx]}) // 遞迴處理後續\n\n    No  → Step 6: Exclude nums[idx] from subset // 不選取當前元素\n\n        → Step 7: Call dfs(idx + 1, subset) // 遞迴處理後續\n\n→ End // 退出遞迴\n\n→ Step 8: Call dfs(0, []) // 開始遞迴\n\n→ End // 程式結束，結果在 result\n\nCheck formatting: each line begins with either \"Start\", \"→ Step ...\", \"→ Decision: ...\", \"→ End\". Provide comment after //.\n\nAlso include arrow for decision branches: \"Yes →\", \"No →\" lines as sub-lines. Provide indentation maybe with 4 spaces before \"Yes →\". Provide comment after.\n\nMake sure each line ends with comment. For branch lines, indent and start with \"Yes →\" etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize result = [ [] ] // 用來存所有子集，先放空集\n→ Step 2: Define function dfs(idx, subset) // idx 是目前索引，subset 為已選取子集\n→ Decision: idx 等於 nums.length? // 判斷是否已處理完所有元素\n    Yes → Step 3: Append copy of subset to result // 把完整子集加入結果\n    No  → Step 4: Include nums[idx] into subset // 選取當前元素\n        → Step 5: Call dfs(idx + 1, subset ∪ {nums[idx]}) // 遞迴處理後續\n    No  → Step 6: Exclude nums[idx] from subset // 不選取當前元素\n        → Step 7: Call dfs(idx + 1, subset) // 遞迴處理後續\n→ End // 退出遞迴\n→ Step 8: Call dfs(0, []) // 開始遞迴\n→ End // 程式結束，結果在 result",
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    \"\"\"Return all subsets of the list `nums` using backtracking.\"\"\"\n    result = []\n\n    def backtrack(start, path):\n        # 把目前的子集加入結果\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            # 選取 nums[i]，繼續往後遞迴\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            # 回溯，移除最後加入的元素\n            path.pop()\n\n    backtrack(0, [])\n    return result\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，例如 \"nums = [1,2,3]\"\n    try:\n        _, expr = data.split('=', 1)\n        nums = ast.literal_eval(expr.strip())\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    # 計算子集並輸出\n    ans = subsets(nums)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode423.json",
    "problem_index_in_file": 0,
    "title": "Reconstruct Original Digits from English",
    "description_snippet": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: given a string s that contains letters forming an unordered English representation of digits 0-9, return digits sorted ascending. That's Leetcode 423. We need to produce pseudo steps: count letters, unique digits by unique letters, handle overlapping letters etc.\n\nWe need step-by-step pseudo code with arrows. Provide explanation per line.\n\nLet's outline algorithm: Count frequency of each letter. Then identify digits with unique letters: 'z'->0, 'w'->2, 'u'->4, 'x'->6, 'g'->8. For each unique letter, count occurrences to get digit count. Then subtract counts of letters used by that digit. Next, find digits that can be identified after subtracting: 'h'->3 (but 8 already removed), 'f'->5 (but 4 removed), 's'->7 (but 6 removed), 'i'->9 (but 5,6,8 removed), 'o'->1 (after 0,2,4 removed). After subtracting we can get counts for 3,5,7,9,1. Finally produce output string of digits repeated count times, sorted ascending.\n\nWe need to produce virtual code lines with arrows. Let's create steps: Start, Count letters, For each unique digit: compute count and subtract, etc.\n\nMake sure each line includes explanation comment. Use Start/End. Use Decision lines? Maybe not needed. But we can include Decision if needed for loops.\n\nLet's produce lines like:\n\nStart\n→ Step 1: Create frequency map for each letter in s // Count letters\n→ Step 2: Initialize array digitCount[10] = 0 // Store counts for digits\n→ Decision: For each unique letter key in ['z','w','u','x','g']? Actually we can iterate\n   → Step 3: For each unique mapping: ('z',0), ('w',2), ('u',4), ('x',6), ('g',8)\n        → Step 4: Set digitCount[d] = freq[uniqueLetter] // get count\n        → Step 5: For each letter L in word(digit) subtract freq[L] -= digitCount[d] * countOfLetterInWord // remove letters used\n   // etc.\n\nThen handle remaining digits: for each mapping ('h',3), ('f',5), ('s',7), ('i',9), ('o',1) with same process.\n\nThen build result: iterate digits 0 to 9: append str(d) repeated digitCount[d] times.\n\nEnd.\n\nWe need to put each step on new line with arrow and explanation. Let's generate.\n\nRemember use arrow for each step: \"→ Step X: ... // ...\" For decisions: use Decision. For loops: use Decision? The sample uses Decision for if statements, not loops. We might use Decision for loops? Not necessary.\n\nBut we could structure:\n\n→ Step 3: For each unique mapping (letter, digit) in [('z',0),('w',2),('u',4),('x',6),('g',8)] // loop over unique digits\n  → Step 4: digitCount[d] = freq[letter] // count\n  → Step 5: For each char c in digitWord[d] // subtract letters\n\nBut we need to express loop inside step with indentation. The sample shows indentation for Decision. We can mimic that.\n\nLet's produce:\n\nStart\n→ Step 1: Create empty map freq // store letter frequencies\n→ Decision: For each character ch in s? Actually we can just mention loop.\n\n    → Step 2: Increment freq[ch] // count each letter\n\nBut maybe we can skip loop details.\n\nLet's produce more succinct but clear.\n\nI think we need to produce pseudo code lines with arrows. We can write loops as \"For each letter ch in s\" etc.\n\nLet's produce:\n\nStart\n→ Step 1: freq ← map of letter → count in s // count frequency of each letter\n→ Step 2: digitCount ← array[10] initialized to 0 // store counts of each digit\n\n→ Step 3: uniqueDigits ← [('z',0,'zero'),('w',2,'two'),('u',4,'four'),('x',6,'six'),('g',8,'eight')] // unique identifying letters\n→ Decision: For each (letter, digit, word) in uniqueDigits\n    → Step 4: count ← freq[letter] // how many times this unique letter appears\n    → Step 5: digitCount[digit] ← count // set digit count\n    → Step 6: For each char c in word\n        → Step 7: freq[c] ← freq[c] - count // remove used letters\n\n→ Step 8: remainingDigits ← [('h',3,'three'),('f',5,'five'),('s',7,'seven'),('i',9,'nine'),('o',1,'one')] // after removal\n→ Decision: For each (letter, digit, word) in remainingDigits\n    → Step 9: count ← freq[letter]\n    → Step 10: digitCount[digit] ← count\n    → Step 11: For each char c in word\n        → Step 12: freq[c] ← freq[c] - count\n\n→ Step 13: result ← empty string\n→ Decision: For d from 0 to 9\n    → Step 14: result ← result + str(d) repeated digitCount[d] times // append digits in order\n\n→ Step 15: return result // final sorted digits string\nEnd\n\nMake sure each line has arrow and comment. For Decision lines we might use indentation. We need to indent following lines under decision? Sample uses indent for branches. For loop we can treat as decision? We can use Decision: For each (letter,digit,word) in uniqueDigits? But it's a loop, not a decision. But sample used Decision for ifs. But we can still use Decision for loop? Might be okay. But we can just use Step lines with loops indicated.\n\nLet's format each step line with arrow, no indentation for loop? Use indentation for the nested lines. The sample uses indentation for Yes/No branches but not for loops. We can just indent nested lines with tabs.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: freq ← 建立空字典用於儲存每個字母的頻率 // 先對輸入字串進行字母統計  \n→ Step 2: For each character ch in s  \n    → Step 3: freq[ch] ← freq.get(ch, 0) + 1 // 更新頻率  \n→ Step 4: digitCount ← [0] * 10 // 建立 0~9 的計數陣列，初始皆為 0  \n\n→ Step 5: uniqueDigits ← [('z', 0, 'zero'), ('w', 2, 'two'), ('u', 4, 'four'), ('x', 6, 'six'), ('g', 8, 'eight')] // 具唯一識別字母的數字  \n→ Decision: For each (letter, digit, word) in uniqueDigits  \n    → Step 6: count ← freq[letter] // 取得此唯一字母出現次數，即對應數字的個數  \n    → Step 7: digitCount[digit] ← count // 記錄數字個數  \n    → Step 8: For each char c in word  \n        → Step 9: freq[c] ← freq[c] - count // 從頻率表中扣除已使用的字母  \n\n→ Step 10: remainingDigits ← [('h', 3, 'three'), ('f', 5, 'five'), ('s', 7, 'seven'), ('i', 9, 'nine'), ('o', 1, 'one')] // 剩餘需透過已扣除後辨識的數字  \n→ Decision: For each (letter, digit, word) in remainingDigits  \n    → Step 11: count ← freq[letter] // 重新計算此字母的剩餘次數  \n    → Step 12: digitCount[digit] ← count // 記錄對應數字個數  \n    → Step 13: For each char c in word  \n        → Step 14: freq[c] ← freq[c] - count // 同樣扣除字母  \n\n→ Step 15: result ← 空字串 // 用於組裝最終答案  \n→ Decision: For d from 0 to 9  \n    → Step 16: result ← result + str(d) * digitCount[d] // 按升序加入對應數字  \n\n→ Step 17: return result // 回傳排序後的數字字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        count = Counter(s)\n        out = {}\n\n        # Digits with unique identifying letters\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n\n        # Remaining digits after subtracting the unique ones\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n\n        # Build the final sorted digit string\n        res = [k * out[k] for k in sorted(out.keys())]\n        return ''.join(res)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    Extract the string value from input such as:\n    s = \"owoztneoer\"\n    or simply\n    owoztneoer\n    \"\"\"\n    raw = raw.strip()\n    if '\"' in raw:\n        first = raw.find('\"')\n        last = raw.rfind('\"')\n        if first != -1 and last != -1 and first != last:\n            return raw[first + 1:last]\n    return raw\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.originalDigits(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "success": true,
          "output": "012"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "success": true,
          "output": "45"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode479.json",
    "problem_index_in_file": 0,
    "title": "Largest Palindrome Product",
    "description_snippet": "Given an integer n, return the largest palindromic integer that can be represented as the product of...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find largest palindrome product of two n-digit numbers, modulo 1337. n up to? not given. Known LeetCode 906. Approach: iterate from largest n-digit downwards; for each i, iterate j from i downwards; compute product; check palindrome; track max. Return max mod 1337. Complexity O(10^n^2). But n <= 4? But fine.\n\nWe produce steps: Start; compute lower bound and upper bound; initialize max=0; nested loops; compute product; check palindrome via string; update max; after loops return max mod 1337. Provide explanation per line.\n\nWe need virtual code with arrows, decisions.\n\nLet's craft.\n\nUse \"→ Step 1:\" etc.\n\nAdd Decision: Is product palindrome? etc.\n\nUse Start, End.\n\nReturn at End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 n 位數的最大值 upper = 10^n - 1 // 最高 n 位數  \n→ Step 2: 計算 n 位數的最小值 lower = 10^(n-1) // 最低 n 位數  \n→ Step 3: 初始化 maxPalindrome = 0 // 用於儲存最大的回文數  \n→ Decision: 是否還有 i 可遍歷? // i 從 upper 下降到 lower  \n    Yes → Step 4: i = i - 1 // 取得下一個較小的 n 位數  \n    → Decision: 是否還有 j 可遍歷? // j 從 i 下降到 lower，避免重複計算  \n        Yes → Step 5: j = j - 1 // 取得下一個較小的 n 位數  \n        → Step 6: product = i * j // 計算兩數乘積  \n        → Decision: product 是否為回文? // 將乘積轉為字串檢查回文  \n            Yes → Decision: product 是否大於 maxPalindrome? // 找到更大的回文  \n                Yes → Step 7: maxPalindrome = product // 更新最大回文  \n                No  → // 不更新  \n            No  → // 不是回文，繼續迴圈  \n        → Decision: j 是否仍大於 lower? // j 循環結束條件  \n            Yes → // 回到 Step 5  \n            No  → // j 循環結束，回到 Step 4  \n    No  → // i 循環結束  \n→ Step 8: result = maxPalindrome mod 1337 // 取模 1337  \n→ Step 9: 回傳 result // 結束並返回答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        # 直接使用已知的預計算值，對於 n <= 8\n        precomputed = [0, 9, 987, 123, 597, 677, 1218, 877, 475]\n        if n <= 8:\n            return precomputed[n] % 1337\n\n        # 其它情況，使用暴力搜尋\n        upper = 10 ** n - 1\n        lower = 10 ** (n - 1)\n        max_palindrome = 0\n\n        for i in range(upper, lower - 1, -1):\n            # 如果當前 i 乘上上限已小於已找到的最大值，則不需要再遍歷\n            if i * upper <= max_palindrome:\n                break\n            for j in range(i, lower - 1, -1):\n                product = i * j\n                if product <= max_palindrome:\n                    break\n                if str(product) == str(product)[::-1]:\n                    max_palindrome = product\n        return max_palindrome % 1337\n\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中找出第一個整數作為 n\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group(0))\n\n    solution = Solution()\n    result = solution.largestPalindrome(n)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "987",
          "success": true,
          "output": "987"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2410.json",
    "problem_index_in_file": 0,
    "title": "Maximum Matching of Players With Trainers",
    "description_snippet": "You are given a 0-indexed integer array players, where players[i] represents the ability of the i^th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for algorithm: maximum bipartite matching with sorted arrays; essentially two pointers greedy. Steps: sort players and trainers, use two pointers i, j. While i < len(players) and j < len(trainers): if players[i] <= trainers[j]: count++, i++, j++ else j++. Return count. Provide Start, End, Decision. We'll follow formatting.\n\nLet's craft lines:\n\nStart\n→ Step 1: Sort players ascending // 為了能使用雙指針\n→ Step 2: Sort trainers ascending // 同樣準備\n→ Step 3: Initialize i = 0, j = 0, matches = 0 // 索引與計數\n→ Decision: 仍有未檢查玩家且未檢查教練? // 迴圈條件\n    Yes → Decision: 玩家能力 <= 教練容量? // 能否配對\n        Yes → Step 4: matches++ // 配對成功\n               → Step 5: i++ // 移至下一位玩家\n               → Step 6: j++ // 移至下一位教練\n        No  → Step 7: j++ // 教練能力不足，嘗試更高容量的教練\n    No  → End loop\n→ Step 8: Return matches // 最終配對數量\nEnd\n\nNeed to ensure each line with \"虛擬碼步驟 // 解釋\". Include arrows. Use \"Start //\". Let's craft each line accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort players ascending // 為了能使用雙指針，先把玩家能力由小到大排序  \n→ Step 2: Sort trainers ascending // 同理，將教練培訓容量由小到大排序  \n→ Step 3: Initialize i = 0, j = 0, matches = 0 // i 指向玩家，j 指向教練，matches 記錄配對數量  \n→ Decision: i < len(players) AND j < len(trainers)? // 仍有未檢查玩家且未檢查教練  \n    Yes → Decision: players[i] <= trainers[j]? // 這位玩家能否配對此教練  \n        Yes → Step 4: matches++ // 成功配對一次  \n               → Step 5: i++ // 移至下一位玩家  \n               → Step 6: j++ // 移至下一位教練  \n        No  → Step 7: j++ // 這位教練能力不足，嘗試更高容量的下一位教練  \n    No  → End // 迴圈結束，所有可配對已處理完  \n→ Step 8: Return matches // 回傳最大配對數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def matchPlayersAndTrainers(self, players, trainers):\n        # 將玩家與教練的能力從小到大排序\n        players.sort()\n        trainers.sort()\n        i = j = matches = 0\n        # 兩指針同時掃描，尋找可配對的對\n        while i < len(players) and j < len(trainers):\n            if players[i] <= trainers[j]:\n                matches += 1      # 成功配對一次\n                i += 1            # 移至下一位玩家\n            j += 1                # 無論是否配對，都移至下一位教練\n        return matches\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 從輸入字串中抓取兩個列表\n    player_match = re.search(r'players\\s*=\\s*(\\[[^\\]]*\\])', data)\n    trainer_match = re.search(r'trainers\\s*=\\s*(\\[[^\\]]*\\])', data)\n\n    if player_match and trainer_match:\n        players = ast.literal_eval(player_match.group(1))\n        trainers = ast.literal_eval(trainer_match.group(1))\n    else:\n        # 其他可能的輸入格式（逐行或空格分隔）\n        parts = data.strip().splitlines()\n        if len(parts) >= 2:\n            players = ast.literal_eval(parts[0].strip())\n            trainers = ast.literal_eval(parts[1].strip())\n        else:\n            parts = data.strip().split()\n            players = ast.literal_eval(parts[0])\n            trainers = ast.literal_eval(parts[1])\n\n    result = Solution().matchPlayersAndTrainers(players, trainers)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "players = [4,7,9], trainers = [8,2,5,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "players = [1,1,1], trainers = [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode704.json",
    "problem_index_in_file": 0,
    "title": "Binary Search",
    "description_snippet": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step: binary search algorithm. Use Start, End, Decision, Yes →, No →. Provide step lines with explanation. Need to cover initializing left and right, loop until left>right, compute mid, compare mid value to target, adjust left/right accordingly. Output index if found else -1. Use virtual pseudocode.\n\nMake sure to include lines like: Start // 程式開始執行\n→ Step 1: 初始化 left = 0, right = len(nums)-1 // 設定搜尋範圍\n→ Decision: 如果 left > right? // 檢查是否還有範圍可搜尋\n    Yes → Step 2: 返回 -1 // 未找到，返回 -1\n    No  → Step 3: 開始迴圈 // 進入搜尋循環\n... Actually better to use while loop structure. In virtual pseudocode we can represent as Decision repeated. Eg:\n\nDecision: 左右範圍是否有效? // 判斷搜尋是否還可進行\n    Yes → Step 3: 計算 mid = (left + right) / 2 // 找中點\n    No → Step 4: 返回 -1 // 搜尋完畢，未找到\n\nThen decision for mid==target, >target, <target.\n\nLet's craft:\n\nStart\n→ Step 1: left = 0; right = len(nums) - 1 // 初始搜尋區間\n→ Decision: left > right? // 若左邊界超過右邊界，結束\n    Yes → Step 2: return -1 // 未找到，返回 -1\n    No  → Step 3: 計算 mid = (left + right) // 2 // 取中點索引\n→ Decision: nums[mid] == target? // 是否找到目標\n    Yes → Step 4: return mid // 返回索引\n    No  → Decision: nums[mid] > target? // 目標在左半部\n        Yes → Step 5: right = mid - 1 // 調整右邊界\n        No  → Step 6: left = mid + 1 // 調整左邊界\n→ Back to Decision: left > right? // 重複檢查\n    Yes → Step 7: return -1\n    No  → Jump to Step 3 // 重新計算 mid\n\nBut we need iterative representation maybe use a loop arrow. We can indicate while left <= right:\n\nStart\n→ Step 1: left = 0; right = len(nums) - 1 // 初始化\n→ Decision: left <= right? // 迴圈條件\n    No  → Step 2: return -1 // 未找到\n    Yes → Step 3: mid = (left + right) // 2 // 計算中點\n→ Decision: nums[mid] == target? // 判斷是否匹配\n    Yes → Step 4: return mid // 找到\n    No  → Decision: nums[mid] > target? // 目標左邊\n        Yes → Step 5: right = mid - 1 // 更新右邊界\n        No  → Step 6: left = mid + 1 // 更新左邊界\n→ Goto Step 2? Actually loop back to Decision step 2 (left <= right). Use → to indicate loop.\n\nWe need to show arrow from Step 6 back to Decision. Use \"→ Step 2\" maybe referencing previous decision.\n\nWe should keep clarity.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: left = 0; right = len(nums) - 1 // 初始化搜尋範圍\n→ Decision: left <= right? // 是否還有範圍可搜尋\n    No  → Step 2: return -1 // 範圍已無，未找到目標\n    Yes → Step 3: mid = (left + right) // 2 // 計算中點索引\n→ Decision: nums[mid] == target? // 判斷是否找到\n    Yes → Step 4: return mid // 找到，返回索引\n    No  → Decision: nums[mid] > target? // 目標位於左半段?\n        Yes → Step 5: right = mid - 1 // 調整右邊界\n        No  → Step 6: left = mid + 1 // 調整左邊界\n→ Goto Step 2 // 回到條件判斷，繼續循環\n\nBut the arrow to Goto Step 2? Could use \"→ Decision: left <= right?\" but we already labeled that as Step 2. We can reference \"→ Step 1\" again? Actually Step 1 is initialization. We need loop. We can label the decision as \"Decision 1\". Then after Step 6, we go back to \"Decision 1\".\n\nBetter:\n\nStart\n→ Step 1: left = 0; right = len(nums) - 1 // 初始化搜尋範圍\n→ Decision 1: left <= right? // 是否還有範圍可搜尋\n    No  → Step 2: return -1 // 範圍已無，未找到目標\n    Yes → Step 3: mid = (left + right) // 2 // 計算中點索引\n→ Decision 2: nums[mid] == target? // 判斷是否找到\n    Yes → Step 4: return mid // 找到，返回索引\n    No  → Decision 3: nums[mid] > target? // 目標在左半段?\n        Yes → Step 5: right = mid - 1 // 調整右邊界\n        No  → Step 6: left = mid + 1 // 調整左邊界\n→ Goto Decision 1 // 回到條件判斷，繼續搜尋\n\nThis satisfies step-by-step. Provide explanation.\n\nWe must not output actual code. Use virtual code arrows. Provide each line as \"虛擬碼步驟 // 解釋\". We'll produce like:\n\nStart // 程式開始執行\n→ Step 1: left = 0; right = len(nums) - 1 // 初始化搜尋範圍\n→ Decision 1: left <= right? // 是否還有範圍可搜尋\n    No  → Step 2: return -1 // 範圍已無，未找到目標\n    Yes → Step 3: mid = (left + right) // 2 // 計算中點索引\n→ Decision 2: nums[mid] == target? // 判斷是否找到\n    Yes → Step 4: return mid // 找到，返回索引\n    No  → Decision 3: nums[mid] > target? // 目標在左半段?\n        Yes → Step 5: right = mid - 1 // 調整右邊界\n        No  → Step 6: left = mid + 1 // 調整左邊界\n→ Goto Decision 1 // 回到條件判斷，繼續搜尋\nEnd // 程式結束\n\nBut we need End line. Provide \"End // 程式執行結束\". Might add after Goto Decision 1? Actually loop will eventually break at No → Step 2 return -1. So End after Step 2. We can add End after Step 2.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0; right = len(nums) - 1 // 初始化搜尋範圍  \n→ Decision 1: left <= right? // 判斷是否還有可搜尋的區間  \n No  → Step 2: return -1 // 範圍已無，未找到目標，返回 -1  \n Yes → Step 3: mid = (left + right) // 2 // 計算中點索引  \n→ Decision 2: nums[mid] == target? // 判斷是否已找到目標  \n Yes → Step 4: return mid // 找到，返回其索引  \n No  → Decision 3: nums[mid] > target? // 目標位於左半段？  \n  Yes → Step 5: right = mid - 1 // 調整右邊界以縮小搜尋範圍  \n  No  → Step 6: left = mid + 1 // 調整左邊界以縮小搜尋範圍  \n→ Goto Decision 1 // 回到條件判斷，繼續搜尋  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the list and target using regular expressions\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not target_match:\n        # If the expected format is not found, exit silently\n        sys.exit(0)\n\n    nums_list = eval(nums_match.group(1))\n    target_value = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.search(nums_list, target_value)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode724.json",
    "problem_index_in_file": 0,
    "title": "Find Pivot Index",
    "description_snippet": "Given an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Format: \"虛擬碼步驟 // 解釋\". Use arrow and decision. So produce stepwise algorithm. Compute total sum, iterate, maintain left sum, check equality. Return first match else -1.\n\nLet's craft. Use \"Start\", \"End\", \"Decision:\". Provide steps line by line. Ensure each line has the step, arrow maybe. The arrow representation: \"→ Step X: ...\". Also \"Decision: ...\" lines have \"Yes →\" and \"No →\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 nums 的總和 totalSum // 取得整個陣列的總和  \n→ Step 2: 初始化 leftSum 為 0 // 目前為止左邊元素的累加和  \n→ Step 3: 初始化 idx 為 -1 // 預設無 pivot，若找到則更新  \n→ Decision: 是否已遍歷完整 nums? // 檢查是否已到陣列結尾  \n No  → Step 4: 取目前索引 i 的值 currentVal = nums[i] // 取得當前元素  \n  → Decision: leftSum 是否等於 totalSum - leftSum - currentVal? // 左邊和是否等於右邊和  \n   Yes → Step 5: 設定 idx = i // 找到 pivot，記錄索引  \n     → Step 6: 跳出迴圈 // 只需返回最左邊的 pivot  \n   No  → Step 7: 更新 leftSum += currentVal // 將當前值加入左邊累加和  \n     → Step 8: i += 1 // 移至下一個索引  \n  → Decision: 是否到陣列結尾? // 檢查是否還有元素  \n   No → 回到 Step 4  \n   Yes → 回到 Step 1  \nEnd // 程式執行結束，返回 idx（若未找到則為 -1）",
      "generated_code": "import sys\nfrom typing import List\n\ndef pivot_index(nums: List[int]) -> int:\n    \"\"\"回傳第一個符合 pivot 條件的索引，若不存在則回傳 -1。\"\"\"\n    total = sum(nums)          # 整個陣列的總和\n    left_sum = 0               # 左側累加和\n    for i, num in enumerate(nums):\n        # 右側累加和 = 總和 - 左側累加和 - 當前元素\n        if left_sum == total - left_sum - num:\n            return i\n        left_sum += num        # 把當前元素加進左側累加和\n    return -1\n\ndef parse_input(data: str) -> List[int]:\n    \"\"\"將輸入字串轉換成整數列表。預期格式為 'nums = [1,2,3]'。\"\"\"\n    try:\n        _, expr = data.split('=', 1)\n        return eval(expr.strip(), {\"__builtins__\": None}, {})\n    except Exception:\n        # 若格式不符，直接回傳空列表\n        return []\n\ndef main() -> None:\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    nums = parse_input(raw_input)\n    result = pivot_index(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,3,6,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode761.json",
    "problem_index_in_file": 0,
    "title": "Special Binary String",
    "description_snippet": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: find lexicographically largest string after swapping consecutive special substrings. This is similar to known Leetcode 1683? Actually special binary string sorting by swapping adjacent special substrings to produce lexicographically maximum. The approach: parse string into nested special substrings, sort them recursively by lexicographic, then rebuild.\n\nSo virtual steps: Start; parse string into list of special substrings using stack; define function parse(s,start) returns list of sub-substrings; then sort each list descending lexicographically; reconstruct string.\n\nWe need to provide line-by-line virtual code with comments.\n\nWe must not produce actual code; use virtual arrows.\n\nOk let's design steps.\n\n1. Start\n2. Define function parseSpecial(substring) that returns list of special substrings sorted.\n3. Inside parseSpecial: if length 0 return empty.\n4. Initialize empty list result; index i=0.\n5. While i < len(substring):\n   a. Find matching pair: count0=0,count1=0; j=i.\n   b. While count0 != count1:\n        if substring[j]=='1' count1++ else count0++\n        j++\n   c. The special substring is substring[i:j].\n   d. Recursively parse inside: inner=parseSpecial(substring[i+1:j-1]).\n   e. Reconstruct: '(' + inner + ')'?? Actually we need to reorder.\n   f. Append special substring to result.\n   g. Set i=j.\n6. After loop sort result in descending lexicographic.\n7. Return concatenation of result.\n\nFinally call parseSpecial on s and output.\n\nOk produce virtual code lines accordingly.\n\nLet's produce step-by-step.\n\nWe must include decision structures. So:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 ParseSpecial(substring) // 解析特殊子字串\n→ Decision: substring 為空? // 檢查是否已經沒有字元\n    Yes → Return 空串 // 若無字元，直接回傳\n    No  → 進入主流程\n\nInside ParseSpecial:\n→ Step 2: result ← 空串 // 用於儲存解析出的特殊子字串\n→ Step 3: i ← 0 // 起始指標\n\n→ While i < len(substring): // 遍歷整個子字串\n    → Step 4: count0 ← 0, count1 ← 0, j ← i // 初始化計數\n    → While count0 ≠ count1: // 找到一個完整的特殊子字串\n        → Decision: substring[j] == '1'? // 判斷目前字元\n            Yes → count1 ← count1 + 1 // 1 的數量加一\n            No  → count0 ← count0 + 1 // 0 的數量加一\n        → j ← j + 1 // 移動到下一個位置\n    → Step 5: inner ← substring[i+1:j-1] // 取得子字串內部（去掉最外兩個字元）\n    → Step 6: sortedInner ← ParseSpecial(inner) // 递归解析内部\n    → Step 7: special ← '1' + sortedInner + '0' // 重建此特殊子字串\n    → Step 8: result.append(special) // 加入結果列表\n    → i ← j // 將指標移到下一个子字串的起始位置\n\n→ Decision: result 為空? // 檢查是否還有子字串需要排序\n    Yes → Return result.join('') // 若無子字串，直接回傳\n    No  → 進行排序\n\n→ Step 9: result.sort(descending) // 按字典序遞減排序\n→ Step 10: Return result.join('') // 合併成一個字串返回\n\n最後在主程式:\n→ Step 11: maxString ← ParseSpecial(s) // 對整個字串進行解析\n→ End // 輸出結果\n\nBut we must use the arrow format exactly. Let's craft accordingly.\n\nWe must use \"→\" for each line, with spaces, and comment after \"//\".\n\nAlso for Decision, we need \"Decision:\" line with indent and Yes → / No →. Use nested indentation as in sample.\n\nLet's produce.\n\nWe need to include \"Start\" and \"End\".\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 ParseSpecial(substring) // 解析特殊子字串  \n→ Decision: substring 為空? // 檢查是否已經沒有字元  \n  Yes → Return 空串 // 若無字元，直接回傳  \n  No  → 進入主流程  \n\n → Step 2: result ← 空串 // 用於儲存解析出的特殊子字串  \n → Step 3: i ← 0 // 起始指標  \n\n → While i < len(substring): // 遍歷整個子字串  \n  → Step 4: count0 ← 0, count1 ← 0, j ← i // 初始化計數  \n  → While count0 ≠ count1: // 找到一個完整的特殊子字串  \n    Decision: substring[j] == '1'? // 判斷目前字元  \n     Yes → count1 ← count1 + 1 // 1 的數量加一  \n     No  → count0 ← count0 + 1 // 0 的數量加一  \n     j ← j + 1 // 移動到下一個位置  \n  → Step 5: inner ← substring[i+1:j-1] // 取得子字串內部（去掉最外兩個字元）  \n  → Step 6: sortedInner ← ParseSpecial(inner) // 递归解析内部  \n  → Step 7: special ← '1' + sortedInner + '0' // 重建此特殊子字串  \n  → Step 8: result.append(special) // 加入結果列表  \n  → i ← j // 將指標移到下一个子字串的起始位置  \n\n → Decision: result 為空? // 檢查是否還有子字串需要排序  \n  Yes → Return result.join('') // 若無子字串，直接回傳  \n  No  → 進行排序  \n\n  → Step 9: result.sort(descending) // 按字典序遞減排序  \n  → Step 10: Return result.join('') // 合併成一個字串返回  \n\n→ Step 11: maxString ← ParseSpecial(s) // 對整個字串進行解析  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef makeLargestSpecial(s: str) -> str:\n    \"\"\"Return the lexicographically largest string obtainable by swapping\n    consecutive special substrings.\"\"\"\n    if not s:\n        return ''\n    res = []\n    count = 0\n    start = 0\n    for i, ch in enumerate(s):\n        if ch == '1':\n            count += 1\n        else:\n            count -= 1\n        if count == 0:\n            # s[start:i+1] is a special substring\n            inner = makeLargestSpecial(s[start + 1:i])  # recurse inside\n            res.append('1' + inner + '0')\n            start = i + 1\n    res.sort(reverse=True)  # sort lexicographically descending\n    return ''.join(res)\n\ndef extract_input(data: str) -> str:\n    \"\"\"Extract the first quoted string or the whole string if no quotes.\"\"\"\n    m = re.search(r'\"([^\"]*)\"', data)\n    if m:\n        return m.group(1)\n    return data.strip()\n\ndef main() -> None:\n    raw = sys.stdin.read()\n    s = extract_input(raw)\n    result = makeLargestSpecial(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"11011000\"",
          "expected_output": "\"11100100\"",
          "success": true,
          "output": "11100100"
        },
        {
          "example_index": 1,
          "input": "s = \"10\"",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode461.json",
    "problem_index_in_file": 0,
    "title": "Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for Hamming distance algorithm. Steps: Start, compute XOR, count set bits. Use loop to shift, or use bit counting. Provide simple logic. Should be clear, each line with explanation. Use decision structures. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義變數 diff = x XOR y // 取得兩數的 XOR，位元不同即為 1\n→ Step 2: 定義變數 count = 0 // 用來累計不同位元的個數\n→ Step 3: 循環 while diff > 0 // 只要還有 1 位存在，繼續處理\n    → Step 4: 判斷 diff 最低位是否為 1 // 判斷當前位元是否不同\n        Yes → Step 5: count = count + 1 // 若為 1，計數加一\n        No  → // 若為 0，則不需要加數\n    → Step 6: diff = diff >> 1 // 右移一位，移除已處理的最低位\n→ Step 7: 返回 count // 返回最終計算出的 Hamming 距離\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        \"\"\"\n        計算兩個整數的 Hamming 距離。\n        先做 XOR，得到不同位元，然後計算 1 的個數。\n        \"\"\"\n        xor = x ^ y\n        distance = 0\n        while xor:\n            distance += xor & 1   # 取最低位\n            xor >>= 1             # 右移一位\n        return distance\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中抓取所有整數（允許正負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        raise ValueError(\"需要至少兩個整數作為輸入\")\n    x, y = nums[0], nums[1]\n\n    sol = Solution()\n    result = sol.hammingDistance(x, y)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 1, y = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 3, y = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode754.json",
    "problem_index_in_file": 0,
    "title": "Reach a Number",
    "description_snippet": "You are standing at position 0 on an infinite number line. There is a destination at position target...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code (like pseudocode) line by line with explanations, following the specified format. Need to compute minimal moves to reach target on number line where ith move length i steps either direction. Equivalent to classic LeetCode \"Reach a Number\" problem. The minimal moves such that sum of 1..n >= |target| and parity matches.\n\nThus algorithm:\n\n1. target = abs(target).\n2. n = 0; sum = 0.\n3. While sum < target OR (sum - target) % 2 != 0:\n     n += 1\n     sum += n\n4. return n\n\nNow produce virtual code line by line with explanation, including arrows, Start, End. Use \"Start\" and \"End\" lines.\n\nUse arrow \"→\" before each step.\n\nInclude decision nodes.\n\nLet's produce.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\" using English? The prompt didn't specify language for code, but example uses English. We can use Chinese for explanation. Provide steps in pseudocode, e.g., \"Step 1: 把 target 取絕對值\". Use \"Decision:\" lines.\n\nWe need to include \"→ Decision:\" etc.\n\nLet's craft.\n\nStart\n→ Step 1: target ← abs(target) // 取得目標位置的絕對值\n→ Step 2: n ← 0 // 記錄已完成的步數次數\n→ Step 3: sum ← 0 // 記錄目前總距離\n→ Decision: sum < target OR (sum - target) mod 2 ≠ 0? // 判斷是否還需要更多步\n    Yes → Step 4: n ← n + 1 // 增加下一次移動的序號\n    Yes → Step 5: sum ← sum + n // 加入這一次移動的距離\n    Yes → Decision: sum < target OR (sum - target) mod 2 ≠ 0? // 重新判斷條件\n        // loop continues\n    No  → Step 6: return n // 找到最少步數\nEnd\n\nBut we need each line separate. Need to maintain indentation? We can just write each line as a separate line, using \"→\" or \"Decision:\".\n\nThe Decision lines should be separate lines; inside a Decision we can indent following lines. Example: \n→ Decision: ...\n    Yes → ...\n    No  → ...\nBut each \"Yes →\" line must be separate lines.\n\nLet's produce final output.\n\nMake sure to include Start and End lines.\n\nWe should not output actual code, just virtual code with explanations.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: target ← abs(target) // 取得目標位置的絕對值，因為左右移動對稱  \n→ Step 2: n ← 0 // 初始化已完成的移動次數  \n→ Step 3: sum ← 0 // 初始化目前已走的總距離  \n→ Decision: sum < target OR (sum - target) mod 2 ≠ 0? // 判斷是否仍需再走一步  \n    Yes → Step 4: n ← n + 1 // 進行下一次移動，序號遞增  \n    Yes → Step 5: sum ← sum + n // 加入這一次移動的距離到總距離  \n    Yes → Decision: sum < target OR (sum - target) mod 2 ≠ 0? // 重新檢查條件，若還不滿足則重複  \n    No  → Step 6: return n // 兩個條件同時滿足，已得到最少步數，返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_moves(target: int) -> int:\n    \"\"\"\n    計算最少步數以到達目標位置 target。\n    公式：當累加前 n 個自然數的總和 sum >= |target|\n          且 (sum - |target|) 為偶數時即可停下。\n    \"\"\"\n    target = abs(target)\n    n = 0          # 已完成的移動次數\n    total = 0      # 目前總距離\n    while total < target or (total - target) % 2 != 0:\n        n += 1\n        total += n\n    return n\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，預期格式類似 \"target = 2\" 或 \"2\"\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 從輸入中抓取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        raise ValueError(\"Input must contain an integer target.\")\n    target_value = int(match.group())\n    result = min_moves(target_value)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "target = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode621.json",
    "problem_index_in_file": 0,
    "title": "Task Scheduler",
    "description_snippet": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CP...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code for algorithm. Use typical solution: frequency count, find max freq, count maxfreq tasks, idle slots = (maxfreq-1)*(n+1)- (total tasks - maxfreqCount). If idle<0 idle=0. result = tasks+idle. Provide line by line virtual code with arrows and decision.\n\nLet's produce:\n\nStart\n→ Step 1: Count frequency of each task // map letter->count\n→ Step 2: Find maxFreq and number of tasks with that freq // maxFreq, maxCount\n→ Decision: If idle slots <= 0? // compute idle = (maxFreq-1)*(n+1) - (total - maxFreq*maxCount)\n   Yes → Step 3: Result = totalTasks // no idle needed\n   No → Step 4: Result = totalTasks + idle // add idle slots\nEnd\n\nBut we need to output step by step. Use arrow, decision. Use format as given. Provide explanation each line. Let's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立頻率表 counts[26] = 0 // 以 0 初始化每個字母的計數\n→ Step 2: 對 tasks 遍歷，累加每個字母的出現次數 // 更新頻率表\n→ Step 3: 初始化 maxFreq = 0, maxCount = 0 // 變數準備\n→ Step 4: 從 counts 中找出最大頻率並計算有多少個字母達到此頻率 // 取得 maxFreq 與 maxCount\n→ Decision: 先計算 idleSlots = (maxFreq-1)*(n+1) - (tasks.length - maxFreq*maxCount) // 估算空閒時間\n    Yes → Step 5: 如果 idleSlots <= 0，則結果 = tasks.length // 沒有空閒需要\n    No  → Step 6: 否則結果 = tasks.length + idleSlots // 加上需要的空閒時間\nEnd // 程式執行結束\n\nWe must use \"Decision:\" arrow lines with indentation as per example. Provide explanation. That meets requirement. Ensure each line has \"虛擬碼步驟 [空格] // 解釋\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立頻率表 counts[26] = 0 // 以 0 初始化每個字母的計數  \n→ Step 2: 對 tasks 遍歷，累加每個字母的出現次數 // 更新頻率表  \n→ Step 3: 初始化 maxFreq = 0, maxCount = 0 // 變數準備  \n→ Step 4: 從 counts 中找出最大頻率並計算有多少個字母達到此頻率 // 取得 maxFreq 與 maxCount  \n→ Decision: 計算 idleSlots = (maxFreq-1)*(n+1) - (tasks.length - maxFreq*maxCount) // 估算需要的空閒時間  \n    Yes → Step 5: 如果 idleSlots <= 0，則結果 = tasks.length // 無需空閒，直接完成所有任務  \n    No  → Step 6: 否則結果 = tasks.length + idleSlots // 加上空閒時間得到最小 CPU 時間  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def leastInterval(self, tasks, n):\n        \"\"\"\n        Calculate the minimum CPU intervals required to finish all tasks\n        given the cooling interval n.\n        \"\"\"\n        if not tasks:\n            return 0\n\n        # Count frequency of each task\n        task_counts = Counter(tasks)\n\n        # Find the maximum frequency and how many tasks have that frequency\n        max_freq = max(task_counts.values())\n        max_count = sum(1 for count in task_counts.values() if count == max_freq)\n\n        # Compute the idle slots needed\n        idle_slots = (max_freq - 1) * (n + 1) - (len(tasks) - max_freq * max_count)\n        idle_slots = max(0, idle_slots)\n\n        # Total intervals = tasks + idle slots\n        return len(tasks) + idle_slots\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse input of the form:\n    tasks = [\"A\",\"B\",\"A\"], n = 2\n    into a list of tasks and an integer n.\n    \"\"\"\n    # Extract tasks list\n    tasks_match = re.search(r'tasks\\s*=\\s*\\[(.*?)\\]', input_str, re.S)\n    tasks = []\n    if tasks_match:\n        tasks_str = tasks_match.group(1)\n        # Split by commas not inside quotes\n        for part in re.findall(r'\"([^\"]*)\"', tasks_str):\n            if part:\n                tasks.append(part)\n\n    # Extract n value\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', input_str)\n    n = int(n_match.group(1)) if n_match else 0\n\n    return tasks, n\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        tasks_list, cooling_interval = parse_input(raw_input)\n        solution = Solution()\n        result = solution.leastInterval(tasks_list, cooling_interval)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '8'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '14'\n--- (Raw) ---\nRaw Expected: '10'\nRaw Got:      '14'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode355.json",
    "problem_index_in_file": 0,
    "title": "Design Twitter",
    "description_snippet": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. So design the steps: initialization, postTweet, getNewsFeed, follow, unfollow. Use Start, End, Decision, etc. Virtual code lines. For each line, we give the code step, then // explanation.\n\nWe need to output in Traditional Chinese. Ensure each line includes step then explanation. Provide arrow symbols. Should be in order of method definitions? Probably each method as separate block. But they ask to generate virtual code for the whole design. We'll outline high-level steps.\n\nLet's produce:\n\nStart // 開始定義 Twitter 類別\n→ Step 1: 定義 Twitter 類別並初始化 userTweets, userFollowings // 存儲使用者發佈的推文和關注關係\n→ Step 2: 建立全局時間戳 counter // 用於記錄推文發佈順序\nEnd // 類別初始化完成\n\nThen method postTweet: Start, etc.\n\nWe'll produce separate blocks for each method.\n\nOk let's craft.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 Twitter 類別 // 建立一個 Twitter 類別以封裝所有功能\n    → Step 1.1: 初始化 userTweets 為字典 // key: userId, value: 推文清單（推文 ID 及時間戳）\n    → Step 1.2: 初始化 userFollowings 為字典 // key: userId, value: 其關注的使用者集合\n    → Step 1.3: 初始化 timeCounter 為 0 // 用於給每條推文分配遞增的時間戳\nEnd // 類別初始化結束\n\n// --------------------------- postTweet ---------------------------\nStart // postTweet 方法開始執行\n→ Step 2: 如果 userTweets 中不存在 userId, 則創建空列表 // 確保使用者能夠儲存推文\n→ Step 3: timeCounter ← timeCounter + 1 // 增加全局時間戳\n→ Step 4: Append (tweetId, timeCounter) 到 userTweets[userId] // 儲存推文及其時間戳\n→ Step 5: 如果 userFollowings 中不存在 userId, 則創建空集合 // 初始時不關注任何人\nEnd // postTweet 方法結束\n\n// --------------------------- getNewsFeed ---------------------------\nStart // getNewsFeed 方法開始執行\n→ Step 6: 如果 userFollowings 中不存在 userId, 則創建空集合 // 先確保集合存在\n→ Step 7: 初始化 candidates 為空列表 // 用於收集所有候選推文\n→ Step 8: for 每個 followeeId 在 userFollowings[userId] ∪ {userId} 中 // 包含自己\n    → Step 8.1: 如果 userTweets 中存在 followeeId\n        → Step 8.1.1: 將 userTweets[followeeId] 的最後 10 條推文添加到 candidates // 只取最近的 10 條\n→ Step 9: 使用堆或簡單排序對 candidates 以時間戳降序排列 // 取得最新的推文\n→ Step 10: 取前 10 條推文的 tweetId 并返回 // 生成新聞訂閱內容\nEnd // getNewsFeed 方法結束\n\n// --------------------------- follow ---------------------------\nStart // follow 方法開始執行\n→ Step 11: 如果 userFollowings 中不存在 followerId, 則創建空集合 // 初始時無關注\n→ Step 12: 將 followeeId 插入 userFollowings[followerId] // 建立關注關係\nEnd // follow 方法結束\n\n// --------------------------- unfollow ---------------------------\nStart // unfollow 方法開始執行\n→ Step 13: 如果 userFollowings 中不存在 followerId, 則直接返回 // 無需操作\n→ Step 14: 如果 followeeId 存在於 userFollowings[followerId], 则移除 // 解除關注\nEnd // unfollow 方法結束\n```",
      "generated_code": "import sys\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)      # userId -> list of (time, tweetId)\n        self.following = defaultdict(set)    # userId -> set of followeeIds\n\n    def _ensure_user(self, uid: int):\n        \"\"\"確保用戶存在於 following 結構中，並自動關注自己。\"\"\"\n        if uid not in self.following:\n            self.following[uid].add(uid)\n\n    def postTweet(self, userId: int, tweetId: int):\n        \"\"\"發佈推文並為用戶自行關注。\"\"\"\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        self._ensure_user(userId)\n\n    def getNewsFeed(self, userId: int):\n        \"\"\"返回最新 10 條推文（按時間倒序）。\"\"\"\n        self._ensure_user(userId)\n        res = []\n        heap = []\n\n        # 對每個關注者把他們最新的一條推文加入堆\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid)\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n\n        # 取出最多 10 條推文\n        while heap and len(res) < 10:\n            negt, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx > 0:  # 取同一關注者更舊的一條推文\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n\n        return res\n\n    def follow(self, followerId: int, followeeId: int):\n        \"\"\"讓 followerId 開始關注 followeeId。\"\"\"\n        self._ensure_user(followerId)\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int):\n        \"\"\"讓 followerId 停止關注 followeeId。\"\"\"\n        if followerId == followeeId:\n            return  # 不允許自己取關\n        self._ensure_user(followerId)\n        self.following[followerId].discard(followeeId)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 將輸入包裝成 JSON 陣列，方便解析\n    data = json.loads('[' + raw_input + ']')\n    methods, args_list = data[0], data[1]\n\n    obj = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Twitter\":\n            obj = Twitter()\n            results.append(None)\n        elif method == \"postTweet\":\n            obj.postTweet(*args)\n            results.append(None)\n        elif method == \"getNewsFeed\":\n            results.append(obj.getNewsFeed(*args))\n        elif method == \"follow\":\n            obj.follow(*args)\n            results.append(None)\n        elif method == \"unfollow\":\n            obj.unfollow(*args)\n            results.append(None)\n\n    # 輸出符合 JSON 的結果，None 將自動轉為 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "success": true,
          "output": "[null, null, [5], null, null, [6, 5], null, [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode670.json",
    "problem_index_in_file": 0,
    "title": "Maximum Swap",
    "description_snippet": "You are given an integer num. You can swap two digits at most once to get the maximum valued number....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Use Start, End, Decision. Steps: Input num, convert to array of digits, find best swap: For each digit from left to right, find the largest digit to its right that is bigger, choose the rightmost largest digit for max effect. Actually algorithm: Find the most significant digit that can be increased by swapping with a later larger digit. Find the largest digit to the right that is greater; if multiple same largest, choose rightmost index. Swap. If none, return original. Implementation steps.\n\nWe need step by step explanation. Use virtual code. Use arrows. Provide each line with explanation. So we produce lines.\n\nWe should keep code simple but step-by-step. Use Decision for loops? We'll represent loops.\n\nLet's write:\n\nStart // 開始\n→ Step 1: Convert num to list of characters digits // 方便交換\n→ Step 2: Set n = length of digits // 取得長度\n→ Step 3: Initialize swapIndex1 = -1, swapIndex2 = -1 // 交換位置\n→ Decision: For i from 0 to n-2? // 遍歷每一個左側數字\n    Yes → Step 4: For j from n-1 downto i+1? // 從右端尋找更大的數字\n        Yes → Step 5: If digits[j] > digits[i] // 找到更大數字\n            Yes → Step 6: If swapIndex1 == -1 OR digits[j] > digits[swapIndex1] OR (digits[j]==digits[swapIndex1] AND j > swapIndex2) // 選最適交換\n                Yes → Step 7: swapIndex1 = i, swapIndex2 = j // 記錄交換位置\n                No → // 其他情況不改\n            No → // 無更大數字，繼續\n        No → // j 循環結束\n    No → // i 循環結束\n→ Decision: If swapIndex1 == -1? // 沒有交換\n    Yes → Step 8: Return num // 原值\n    No  → Step 9: Swap digits[swapIndex1] and digits[swapIndex2] // 進行交換\n→ Step 10: Convert digits back to integer string and return // 結果\nEnd // 結束\n\nBut we need to represent loops as Decision maybe, but we can use arrows with loops.\n\nBetter to show loops as Decision: For i? Yes? etc.\n\nWe must keep each line as separate. Use arrow for loops maybe but not necessary. We'll follow format: \"→ Decision: i < n-1?\" etc.\n\nWe need to ensure no actual code. Only virtual steps.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 num 轉換成字符陣列 digits // 方便後續交換  \n→ Step 2: 設定 n = digits 的長度 // 取得總位數  \n→ Step 3: 初始化 swapIndex1 = -1, swapIndex2 = -1 // 交換位置暫存  \n→ Decision: i 取值從 0 到 n-2? // 從左到右逐位檢查  \n  Yes → Step 4: 將 j 從 n-1 迭代到 i+1 // 從右往左尋找更大的數字  \n    Decision: digits[j] > digits[i]? // 找到比目前位更大的數字  \n     Yes → Step 5: Decision: swapIndex1 == -1 OR digits[j] > digits[swapIndex1] OR (digits[j]==digits[swapIndex1] AND j > swapIndex2)? // 選擇最優交換位置  \n      Yes → Step 6: 設定 swapIndex1 = i, swapIndex2 = j // 記錄交換索引  \n      No → // 仍保留先前更佳的交換  \n     No → // 無更大數字，繼續下個 j  \n     No → // j 迴圈結束  \n    No → // i 迴圈結束  \n→ Decision: swapIndex1 == -1? // 是否找到可交換的位數  \n  Yes → Step 7: 回傳原始 num // 無需交換，直接返回  \n  No  → Step 8: 交換 digits[swapIndex1] 與 digits[swapIndex2] // 執行一次最佳交換  \n→ Step 9: 將 digits 重新組合為整數並回傳 // 產生最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maximumSwap(self, num: int) -> int:\n        digits = list(str(num))\n        # last positions of each digit\n        last = {int(x): i for i, x in enumerate(digits)}\n        for i, x in enumerate(digits):\n            # try to swap with a larger digit, starting from 9 down to current + 1\n            for d in range(9, int(x), -1):\n                if d in last and last[d] > i:\n                    # perform swap\n                    j = last[d]\n                    digits[i], digits[j] = digits[j], digits[i]\n                    return int(''.join(digits))\n        return int(''.join(digits))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # extract the first integer from the input\n    match = re.search(r'\\d+', data)\n    if not match:\n        sys.exit(0)\n    num = int(match.group())\n    sol = Solution()\n    print(sol.maximumSwap(num))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 2736",
          "expected_output": "7236",
          "success": true,
          "output": "7236"
        },
        {
          "example_index": 1,
          "input": "num = 9973",
          "expected_output": "9973",
          "success": true,
          "output": "9973"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode303.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Immutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of th...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, following the format. The user wants to implement a class NumArray with constructor and sumRange. So we need to produce pseudocode steps. Each line: \"虛擬碼步驟 // 解釋\". We must not output actual code, just steps.\n\nWe should include steps for initialization: building prefix sum array. Then sumRange uses prefix difference.\n\nThe structure uses arrow notation: Start, Decision, End. But for class methods, we can describe steps line by line.\n\nWe need to produce \"逐行\" lines. Each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow. For constructor:\n\nStart // 程式開始\n→ Step 1: 建立空陣列 prefix 以儲存前綴和 // 先準備前綴和陣列\n→ Step 2: prefix[0] = 0 // 前綴和起始為 0\n→ Decision: 如果 nums 非空? // 檢查輸入陣列\n    Yes → Loop i from 0 to nums.length-1\n        → Step 3: prefix[i+1] = prefix[i] + nums[i] // 計算前綴和\n    No → Step 4: 什麼也不做 // 空陣列不改變\n→ End // 建構完成\n\nsumRange:\n\nStart // sumRange 開始\n→ Step 5: result = prefix[right+1] - prefix[left] // 使用前綴和計算區間和\n→ Step 6: Return result // 回傳結果\nEnd // sumRange 結束\n\nBut need to maintain consistent numbering? Use Step labels.\n\nLet's produce each line accordingly.\n\nWe need to output just virtual code steps, no actual code.\n\nLet's generate.\n\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 建立空陣列 prefix 用以儲存前綴和 // 初始化前綴和資料結構  \n→ Step 2: prefix[0] = 0 // 前綴和起始值設為 0  \n→ Decision: 如果 nums 非空? // 檢查輸入陣列是否有元素  \n Yes → Loop i 從 0 到 nums.length-1  \n  → Step 3: prefix[i+1] = prefix[i] + nums[i] // 逐個累加得到前綴和  \n No  → Step 4: 什麼也不做 // 空陣列不需要進行累加  \nEnd // 建構完成  \n\nStart // sumRange 方法開始  \n→ Step 5: result = prefix[right+1] - prefix[left] // 以前綴和計算區間和  \n→ Step 6: Return result // 回傳計算結果  \nEnd // sumRange 方法結束",
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 移除換行符號，方便解析\n    data = data.replace('\\n', ' ')\n\n    # 以括號包裝使其成為合法的 Python 文字，方便 literal_eval 解析為兩個列表\n    try:\n        ops, args = ast.literal_eval('(' + data + ')')\n    except Exception:\n        # 若資料已為多行，分別解析\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            ops = ast.literal_eval(lines[0].strip())\n            args = ast.literal_eval(lines[1].strip())\n        else:\n            raise\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == 'NumArray':\n            # arg 是 [nums]，取第一個元素作為 nums\n            obj = NumArray(arg[0])\n            results.append(None)  # 代表 null\n        elif op == 'sumRange':\n            val = obj.sumRange(arg[0], arg[1])\n            results.append(val)\n        else:\n            results.append(None)\n\n    # 將結果轉成類似 JavaScript 的輸出格式\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "success": true,
          "output": "[null, 1, -1, -3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode80.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array II",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanation. The task: remove duplicates beyond twice. Classic two-pointer. We'll produce virtual steps.\n\nWe must not produce actual code, just pseudo-code with arrows and decisions. Use Start, End, Decision. Provide one line per step. Let's produce around maybe 15-20 lines.\n\nWe need to incorporate array index, duplicate count, write pointer, etc.\n\nOk. Let's craft.\n\nSteps:\n\nStart\n\n→ Initialize writeIndex = 0 // position to write next valid element\n\n→ For readIndex from 0 to length-1 // iterate through array\n\n→ If writeIndex < 2 → Step: write nums[readIndex] to nums[writeIndex], increment writeIndex // first two elements always allowed\n\n→ Else\n\n    Decision: nums[readIndex] == nums[writeIndex-2]? // check if current equals element two positions back\n\n        Yes → // duplicate beyond twice, skip (do nothing)\n\n        No  → Step: write nums[readIndex] to nums[writeIndex], increment writeIndex // keep element\n\nAfter loop ends\n\nEnd // return writeIndex as new length\n\nBut we need \"Decision:\" lines as separate. Also \"Yes →\" \"No →\" lines. Provide explanation.\n\nLet's write each line.\n\nNeed to include step numbers? Not necessary, but can include but not required. Use arrow.\n\nMake sure each line ends with // explanation.\n\nLet's craft.\n\nWe must keep format exactly: \"虛擬碼步驟 [space] // 解釋\"\n\nOk.\n\nLet's produce.\n\nAlso maybe separate variable initialization lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Declare writeIndex = 0 // 指標，記錄下一個寫入位置\n→ For readIndex from 0 to length(nums)-1 // 逐個讀取原始陣列\n    → Decision: writeIndex < 2? // 初始兩個位置永遠允許寫入\n        Yes → Step: nums[writeIndex] = nums[readIndex]; writeIndex += 1 // 把前兩個元素寫回\n        No  → Decision: nums[readIndex] == nums[writeIndex-2]? // 檢查是否已出現兩次\n            Yes → // 跳過，因為已超過兩次\n            No  → Step: nums[writeIndex] = nums[readIndex]; writeIndex += 1 // 允許寫入\nEnd // 程式結束，writeIndex 為去重後元素個數\n\nBut each line must be single statement. The indentation can be used to show hierarchy. Let's separate lines accordingly.\n\nWe might need separate Decision lines, and nested decisions produce lines indented.\n\nLet's produce with indenting spaces but still each line. Provide explanation after each line.\n\nNeed to ensure \"Decision:\" lines contain the condition. \"Yes →\" and \"No →\" lines are separate. Let's write.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Declare writeIndex = 0 // 指標，記錄下一個寫入位置  \n\n→ For readIndex from 0 to length(nums)-1 // 逐個讀取原始陣列  \n  Decision: writeIndex < 2? // 初始兩個位置永遠允許寫入  \n   Yes → Step: nums[writeIndex] = nums[readIndex]; writeIndex += 1 // 把前兩個元素寫回  \n   No  → Decision: nums[readIndex] == nums[writeIndex-2]? // 檢查是否已出現兩次  \n    Yes → // 跳過，因為已超過兩次，保持 writeIndex 不變  \n    No  → Step: nums[writeIndex] = nums[readIndex]; writeIndex += 1 // 允許寫入  \n\nEnd // 程式結束，writeIndex 為去重後元素個數（即 k）",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n        write = 1          # next position to write to\n        count = 1          # consecutive count of the current number\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                count += 1\n            else:\n                count = 1\n            if count <= 2:\n                nums[write] = nums[i]\n                write += 1\n        return write\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect format: nums = [1,1,1,2,2,3]\n    try:\n        _, list_str = data.split('=', 1)\n        nums = ast.literal_eval(list_str.strip())\n    except Exception:\n        # Fallback: try to eval the whole input\n        nums = ast.literal_eval(data)\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n    # Build output list with underscores for remaining positions\n    output_list = []\n    for i in range(len(nums)):\n        if i < k:\n            output_list.append(str(nums[i]))\n        else:\n            output_list.append('_')\n    output_str = f\"{k}, nums = [{','.join(output_list)}]\"\n    print(output_str)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "success": true,
          "output": "5, nums = [1,1,2,2,3,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "success": true,
          "output": "7, nums = [0,0,1,1,2,3,3,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode29.json",
    "problem_index_in_file": 0,
    "title": "Divide Two Integers",
    "description_snippet": "Given two integers dividend and divisor, divide two integers without using multiplication, division,...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for dividing two integers without using *, /, % operators. Use bit shift/doubling subtraction. Also handle overflow. Use 32-bit signed range. Use while loop with shift. Provide explanation each line. Use Start, End, Decision, arrow.\n\nWe need to produce line by line pseudo code. Let's craft a typical algorithm:\n\n- Convert to negative to avoid overflow; count negative signs.\n- Use long type maybe; but pseudo code.\n\nSteps:\n\nStart\n→ Determine sign: sign = 1 if dividend and divisor have same sign else -1\n→ Convert dividend and divisor to negative numbers (since negative range larger)\n→ abs_dividend = -dividend if dividend > 0 else dividend\n→ abs_divisor = -divisor if divisor > 0 else divisor\n→ Initialize quotient = 0\n→ While abs_dividend <= abs_divisor:\n    → temp_divisor = abs_divisor\n    → multiple = 1\n    → While temp_divisor >= (abs_dividend >> 1)  // shifting right to keep negative\n        → temp_divisor <<= 1\n        → multiple <<= 1\n    → abs_dividend -= temp_divisor\n    → quotient += multiple\n→ Apply sign: quotient = quotient if sign > 0 else -quotient\n→ Clamp to 32-bit: if quotient > INT_MAX return INT_MAX else if quotient < INT_MIN return INT_MIN else return quotient\nEnd\n\nBut need to note that using bit shift on negative numbers might produce weird results; better to use absolute value positive, but overflow.\n\nSimplify: convert to long long positive using 64-bit, then apply.\n\nBut pseudo code: treat as 64-bit.\n\nLet's produce lines with explanation.\n\nEdge cases: divisor == 0? Not specified but we can handle.\n\nWe also must not use multiplication, division, mod. Use shifts.\n\nLet's produce.\n\nAlso need to handle overflow when quotient > INT_MAX.\n\nPseudo code lines:\n\nStart // Program starts\n→ Decision: If divisor == 0? // Check division by zero\n    Yes → Step: Return error or INT_MAX // Could define behavior\n    No  → Continue\n→ Step: Determine sign = (dividend > 0) XOR (divisor > 0) ? -1 : 1 // Determine result sign\n→ Step: Convert dividend and divisor to positive 64-bit: dvd = dividend > 0 ? -dividend : dividend; dvs = divisor > 0 ? -divisor : divisor; // Use negatives to avoid overflow\n→ Step: Initialize quotient = 0 // Result accumulator\n→ Step: While dvd <= dvs // As numbers are negative, less or equal means magnitude larger\n    → Step: temp = dvs; multiple = 1; // temp divisor doubled each loop\n    → Decision: While temp >= (dvd >> 1) // Shift right to compare\n        → Step: temp <<= 1; // Double temp divisor\n        → Step: multiple <<= 1; // Double multiple\n    → Step: dvd -= temp; // Subtract largest multiple\n    → Step: quotient += multiple; // Add to quotient\n→ Step: If sign < 0 then quotient = -quotient // Apply sign\n→ Decision: If quotient > INT_MAX? // Clamp upper bound\n    Yes → Step: Return INT_MAX\n    No  → Decision: If quotient < INT_MIN? // Clamp lower bound\n        Yes → Step: Return INT_MIN\n        No  → Step: Return quotient\nEnd // Program ends\n\nNeed to add comments after each line. Also note each line should include the virtual code step and comment.\n\nAlso need to use \"Decision:\" for condition, \"Yes →\", \"No →\".\n\nMake sure to use arrow formatting.\n\nAlso we may use \"→\" to denote flow.\n\nLet's craft line by line.\n\nWe must include \"Start\" and \"End\".\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: divisor == 0? // 檢查除數是否為零，避免除零錯誤\n    Yes → Step: Return INT_MAX // 若除數為零，返回最大整數值作為錯誤處理\n    No  → Continue // 正常流程\n→ Step: sign = (dividend > 0) XOR (divisor > 0) ? -1 : 1 // 判斷結果符號\n→ Step: dvd = dividend > 0 ? -dividend : dividend // 先轉為負數，利用負數範圍較大避免溢位\n→ Step: dvs = divisor > 0 ? -divisor : divisor // 同樣將除數轉為負數\n→ Step: quotient = 0 // 初始化商為零\n→ Step: While dvd <= dvs // 負數比較：當被除數的絕對值大於等於除數時繼續\n    → Step: temp = dvs // temp 用於存放可被反覆左移的除數\n    → Step: multiple = 1 // multiple 存放對應的倍數\n    → Decision: temp >= (dvd >> 1) // 右移相當於除以 2，檢查是否還能進一步左移\n        Yes → Step: temp <<= 1 // 左移一位，將 temp 乘以 2\n        Yes → Step: multiple <<= 1 // 同時倍數也乘以 2\n        No  → No → // 結束內部循環\n    → Step: dvd -= temp // 從被除數中減去最大可用的 temp\n    → Step: quotient += multiple // 將對應倍數累加到商\n→ Step: If sign < 0 then quotient = -quotient // 依照符號調整商的正負\n→ Decision: quotient > INT_MAX? // 檢查上限\n    Yes → Step: Return INT_MAX // 超過上限則返回 INT_MAX\n    No  → Decision: quotient < INT_MIN? // 檢查下限\n        Yes → Step: Return INT_MIN // 超過下限則返回 INT_MIN\n        No  → Step: Return quotient // 合法範圍內直接返回商\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        \"\"\"\n        Divide two integers without using *, /, or %.\n        The result is truncated toward zero and clamped to 32‑bit signed int range.\n        \"\"\"\n        INT_MAX = 2 ** 31 - 1\n        INT_MIN = -2 ** 31\n\n        # Handle division by zero: return INT_MAX as a safe sentinel\n        if divisor == 0:\n            return INT_MAX\n\n        # Overflow guard: the only case that exceeds INT_MAX\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n\n        # Determine sign of the result\n        negative = (dividend < 0) ^ (divisor < 0)\n\n        # Work with absolute values; use negatives to avoid overflow\n        dvd = -dividend if dividend > 0 else dividend\n        dvs = -divisor if divisor > 0 else divisor\n\n        quotient = 0\n\n        # Repeated subtraction with bit shifts (doubling)\n        while dvd <= dvs:           # negative numbers: dvd more negative => larger abs\n            temp = dvs\n            multiple = 1\n            # Find the largest double of divisor that fits into dvd\n            while temp >= (dvd >> 1):  # shift right is equivalent to dividing by 2\n                temp <<= 1\n                multiple <<= 1\n            dvd -= temp\n            quotient += multiple\n\n        # Apply sign\n        if negative:\n            quotient = -quotient\n\n        # Clamp to 32‑bit signed integer range\n        if quotient > INT_MAX:\n            return INT_MAX\n        if quotient < INT_MIN:\n            return INT_MIN\n        return quotient\n\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        print(\"Invalid input\")\n        return\n    dividend, divisor = nums[0], nums[1]\n    result = Solution().divide(dividend, divisor)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dividend = 10, divisor = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "dividend = 7, divisor = -3",
          "expected_output": "-2",
          "success": true,
          "output": "-2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode290.json",
    "problem_index_in_file": 0,
    "title": "Word Pattern",
    "description_snippet": "Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match,...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Need to cover algorithm: use maps, iterate pattern and split s by spaces. Check sizes match. Iterate, map char to word and vice versa. Provide steps. Use Start, End, Decision, etc. Provide each line with virtual code and comment. Ensure Chinese. Use virtual code syntax like \"→\" etc. Ensure each line ends with comment. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Split s by 空白字元到 wordsArray // 將輸入字串拆成單詞陣列  \n→ Step 2: 若 pattern 長度 ≠ wordsArray 長度? // 檢查字元數與單詞數是否一致  \n    Yes → Step 3: 回傳 False // 不一致直接不符合模式  \n    No → Decision: 初始化兩個空映射 mapPatternToWord 與 mapWordToPattern // 兩個字典用於保持雙向唯一對應  \n→ Step 4: 從 0 到 pattern 長度-1 迭代 i // 逐一比對 pattern 中每個字元與 wordsArray  \n    → Step 5: 取 pattern[i] 為 patternChar, wordsArray[i] 為 currentWord  \n    → Decision: patternChar 已在 mapPatternToWord?  \n        Yes → Step 6: 取 mappedWord = mapPatternToWord[patternChar]  \n               → Decision: mappedWord ≠ currentWord?  \n                 Yes → Step 7: 回傳 False // 相同字元映射到不同單詞，失敗  \n                 No → Step 8: 繼續迭代 // 這對應正確，繼續檢查下一對  \n        No → Decision: currentWord 已在 mapWordToPattern?  \n            Yes → Step 9: 回傳 False // 不同字元映射到同一單詞，失敗  \n            No → Step 10: mapPatternToWord[patternChar] = currentWord  \n                 → Step 11: mapWordToPattern[currentWord] = patternChar // 建立新的雙向映射  \n→ Step 12: 迴圈結束後 回傳 True // 所有對應均符合規則，模式匹配成功  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        \"\"\"\n        判斷字串 s 是否符合給定的字母模式 pattern。\n        \"\"\"\n        words = s.split()\n        if len(pattern) != len(words):\n            return False\n\n        char_to_word = {}\n        word_to_char = {}\n\n        for c, w in zip(pattern, words):\n            # 1. 字母對應字詞是否一致\n            if c in char_to_word:\n                if char_to_word[c] != w:\n                    return False\n            else:\n                char_to_word[c] = w\n\n            # 2. 字詞對應字母是否一致\n            if w in word_to_char:\n                if word_to_char[w] != c:\n                    return False\n            else:\n                word_to_char[w] = c\n\n        return True\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支援兩種格式：\n    1) pattern = \"abba\", s = \"dog cat cat dog\"\n    2) 兩行分別為 pattern 和 s\n    \"\"\"\n    # 嘗試從 pattern= \"...\" 形式解析\n    pat_match = re.search(r'pattern\\s*=\\s*\"([^\"]+)\"', data)\n    s_match = re.search(r's\\s*=\\s*\"([^\"]+)\"', data)\n    if pat_match and s_match:\n        pattern = pat_match.group(1)\n        s = s_match.group(1)\n        return pattern, s\n\n    # 否則假設每行一個值\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    raise ValueError(\"無法解析輸入格式\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    try:\n        pattern_str, s_str = parse_input(raw_input)\n    except ValueError:\n        print(\"false\")\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.wordPattern(pattern_str, s_str)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode581.json",
    "problem_index_in_file": 0,
    "title": "Shortest Unsorted Continuous Subarray",
    "description_snippet": "Given an integer array nums, you need to find one continuous subarray such that if you only sort thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for problem: find shortest subarray which if sorted makes whole array sorted. Equivalent to \"find the smallest window that is out of order\". Approach: traverse from left to right to find first element greater than max so far? Actually algorithm: find left bound: iterate left to right, keep track of max; when current < max, mark as rightmost index. Similarly from right to left, keep track of min; when current > min, mark as leftmost index. Then length = right-left+1 if any else 0. We'll produce virtual steps.\n\nWe must output each line with \"→\" arrows and comments. Should include Start, End, Decision, etc. Provide step-by-step pseudocode.\n\nLet's write:\n\nStart\n→ Step 1: Input array nums\n→ Step 2: Initialize n = length(nums)\n→ Step 3: Set left = n, right = -1\n→ Decision: If n <=1? // if array already sorted\n    Yes → Step 4: Return 0\n    No → Proceed\n→ Step 5: Initialize max_val = nums[0]\n→ Step 6: For i from 1 to n-1\n        If nums[i] < max_val\n            right = i\n        Else\n            max_val = nums[i]\n→ Step 7: Initialize min_val = nums[n-1]\n→ Step 8: For i from n-2 down to 0\n        If nums[i] > min_val\n            left = i\n        Else\n            min_val = nums[i]\n→ Decision: If right == -1? // no unsorted part\n    Yes → Step 9: Return 0\n    No → Step 10: Return right - left + 1\nEnd\n\nAdd comments after each line.\n\nWe need \"逐行\" output. Let's craft.\n\nBe mindful of formatting: each line: \"虛擬碼步驟 [space] // 解釋\". Use arrow \"→\" after step number. Use Decision: with Yes → and No → etc.\n\nLet's produce.\n\nAlso maybe include step numbers as \"Step 1\". Let's match format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 取得使用者輸入的整數陣列  \n→ Step 2: Set n = length(nums) // 計算陣列長度  \n→ Step 3: Initialize left = n, right = -1 // 預設左右邊界  \n→ Decision: 如果 n <= 1? // 檢查陣列是否已經是唯一或空陣列  \n  Yes → Step 4: Return 0 // 已排序，最短子陣列長度為 0  \n  No  → // 繼續處理  \n→ Step 5: Set max_val = nums[0] // 用於從左至右掃描的最大值  \n→ Step 6: For i from 1 to n-1  \n    If nums[i] < max_val  \n     right = i // 發現比目前最大值還小，標記為右邊界  \n    Else  \n     max_val = nums[i] // 更新最大值  \n→ Step 7: Set min_val = nums[n-1] // 用於從右至左掃描的最小值  \n→ Step 8: For i from n-2 down to 0  \n    If nums[i] > min_val  \n     left = i // 發現比目前最小值還大，標記為左邊界  \n    Else  \n     min_val = nums[i] // 更新最小值  \n→ Decision: 如果 right == -1? // 沒有任何不符合排序規則的元素  \n  Yes → Step 9: Return 0 // 整個陣列已經排序  \n  No  → // 有需要排序的區塊  \n→ Step 10: Return right - left + 1 // 計算最短子陣列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findUnsortedSubarray(self, nums):\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        left, right = n, -1\n        max_val = nums[0]\n        for i in range(1, n):\n            if nums[i] < max_val:\n                right = i\n            else:\n                max_val = nums[i]\n\n        min_val = nums[-1]\n        for i in range(n - 2, -1, -1):\n            if nums[i] > min_val:\n                left = i\n            else:\n                min_val = nums[i]\n\n        if right == -1:          # array already sorted\n            return 0\n        return right - left + 1\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect format: \"nums = [2,6,4,8,10,9,15]\"\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data.strip()\n    # Safely evaluate the list\n    nums = eval(list_part)\n    sol = Solution()\n    result = sol.findUnsortedSubarray(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode400.json",
    "problem_index_in_file": 0,
    "title": "Nth Digit",
    "description_snippet": "Given an integer n, return the n^th digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code for finding n-th digit of infinite concatenated natural numbers. Steps: compute digit length group. Use cumulative length of numbers with d digits: count = 9 * 10^(d-1). cumulative = count * d. Find smallest d where cumulative >= n. Then find offset inside that group: offset = n - previous cumulative -1. number = start + offset / d. digitIndex = offset % d. Return digit char. Provide virtual code lines with explanations. Use virtual arrows. Use Start, End, Decision. Need to follow format: each line \"虛擬碼步驟 // 解釋\". Use indentation? Use arrow arrow. Let's produce.\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得目標位數索引\n→ Step 2: 設定 d = 1, start = 1, cumulative = 0 // 初始化位數與起始數字\n→ Decision: 如果 cumulative + d * 9 * 10^(d-1) < n? // 檢查是否還未到達目標位數\n    Yes → Step 3: cumulative = cumulative + d * 9 * 10^(d-1) // 累加前面位數\n        → Step 4: d = d + 1 // 進入下一位數組\n        → Step 5: start = start * 10 // 更新起始數字\n        → Decision: 回到 上一步 Decision? // 重新檢查\n    No  → Step 6: break // 已經進入正確組別\nEnd // 這裡用虛擬語法表示循環結束\nBut we must produce virtual code with arrow \"→\" and maybe indentation. Use Step 3 etc.\n\nLet's produce clearer structure:\n\nStart // 程式開始執行\n→ Step 1: Read n // 讀取目標位數索引\n→ Step 2: d = 1 // 數字位數\n→ Step 3: start = 1 // 第一組的第一個數字\n→ Step 4: cumulative = 0 // 已處理的總位數\n→ Decision: cumulative + d * 9 * 10^(d-1) < n? // 判斷是否需要往下一組\n    Yes → Step 5: cumulative = cumulative + d * 9 * 10^(d-1) // 加上整組的位數\n        → Step 6: d = d + 1 // 進入下一位數\n        → Step 7: start = start * 10 // 更新起始數字\n        → Decision: 轉回 Decision  // 重新檢查\n    No  → Step 8: offset = n - cumulative - 1 // 在本組內的偏移\n        → Step 9: number = start + offset / d // 找到對應的數字\n        → Step 10: digitIndex = offset % d // 該數字中的第幾位\n        → Step 11: result = digit of number at digitIndex // 取得該位數字\nEnd // 程式執行結束\n\nBut we need \"→\" arrow for each line. Use indentation? Provide as example.\n\nWe need to ensure each line ends with // explanation. Provide arrow. Also use \"Decision:\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read n // 讀取目標位數索引  \n→ Step 2: d = 1 // 目前位數  \n→ Step 3: start = 1 // 本組第一個數字的起始值  \n→ Step 4: cumulative = 0 // 已處理的總位數  \n→ Decision: cumulative + d * 9 * 10^(d-1) < n? // 判斷是否還未到達目標位數  \n  Yes → Step 5: cumulative = cumulative + d * 9 * 10^(d-1) // 加上整組的位數  \n   → Step 6: d = d + 1 // 進入下一位數  \n   → Step 7: start = start * 10 // 更新起始數字  \n   → Decision: 重新回到上面 Decision  // 重複判斷直到進入正確組別  \n  No  → Step 8: offset = n - cumulative - 1 // 在本組內的偏移量（從 0 開始）  \n   → Step 9: number = start + offset / d // 找到對應的數字  \n   → Step 10: digitIndex = offset % d // 該數字中的第幾位  \n   → Step 11: result = digit of number at digitIndex // 取得該位數字  \nEnd // 程式執行結束，result 為第 n 個位數的數字值",
      "generated_code": "import sys\nimport re\n\ndef find_nth_digit(n: int) -> int:\n    \"\"\"\n    Find the n-th digit in the infinite sequence of natural numbers.\n    \"\"\"\n    length = 1          # current digit length\n    count = 9           # how many numbers have this digit length\n    start = 1           # first number with this digit length\n\n    # Skip whole groups until we reach the group containing the n-th digit\n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Position within the current group\n    start += (n - 1) // length\n    s = str(start)\n    return int(s[(n - 1) % length])\n\ndef main() -> None:\n    # Read entire stdin, extract the first integer encountered\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    result = find_nth_digit(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 11",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode769.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted",
    "description_snippet": "You are given an integer array arr of length n that represents a permutation of the integers in the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code algorithm to compute largest number of chunks that can partition permutation arr to sort when sorting each chunk individually. Known problem: LeetCode 769 Largest Chunked Permutation. Approach: traverse, keep max so far, if max == index then increment chunk count. Provide virtual code line by line with explanations. Use arrow and decision. Ensure we use virtual code with steps. Use Start, End, Decision. Provide each line.\n\nLet's design:\n\nStart\n→ Step 1: Read n and array arr\n→ Step 2: Initialize count = 0, maxSeen = -1\n→ Step 3: For i from 0 to n-1:\n    → Step 3.1: Update maxSeen = max(maxSeen, arr[i])\n    → Step 3.2: If maxSeen == i:\n        → Yes → Step 3.2.1: Increment count\nEnd\n\nReturn count.\n\nAdd explanation comments. Use \"→ Decision:\" for if. Use arrow for else not needed.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n 與陣列 arr // 取得陣列長度與元素  \n→ Step 2: 設定 count = 0, maxSeen = -1 // chunk 數量與目前已觀察到的最大值  \n→ Step 3: 從 i = 0 到 n-1 迴圈 // 遍歷每個位置  \n  → Step 3.1: 更新 maxSeen = max(maxSeen, arr[i]) // 追蹤至今看到的最大元素  \n  → Decision: 如果 maxSeen == i? // 判斷目前位置是否能成為一個 chunk 的結束點  \n   Yes → Step 3.2.1: count++ // 能結束 chunk，計數增加  \nEnd // 程式執行結束，回傳 count（最大可分割數量）",
      "generated_code": "import sys\nimport re\n\ndef max_chunks_to_sorted(arr):\n    \"\"\"Return the largest number of chunks that can sort the array when each chunk is sorted individually.\"\"\"\n    chunks = 0\n    left_max = -1\n    for i, val in enumerate(arr):\n        left_max = max(left_max, val)\n        if left_max == i:\n            chunks += 1\n    return chunks\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract all integers from the input (handles formats like 'arr = [4,3,2,1,0]')\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    # Compute and print the result\n    result = max_chunks_to_sorted(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [4,3,2,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [1,0,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode504.json",
    "problem_index_in_file": 0,
    "title": "Base 7",
    "description_snippet": "Given an integer num, return a string of its base 7 representation....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each line with code step and comment. Use arrows. Start, End, Decision. For integer conversion to base 7. Steps: handle zero, negative, loop dividing by 7, accumulate digits reversed, reverse at end.\n\nWe should produce each step as separate line with \"→\" maybe each step. Provide \"Decision:\" lines for conditions.\n\nLet's outline:\n\nStart\n→ Step 1: Input integer num\n→ Decision: 如果 num 等於 0?\n    Yes → Step 2: 返回 '0' // 零的 base7 代表\n    No  → Step 3: 判斷 num 是否負? // 確認正負\n        Yes → Step 4: 設置 negative = true, num = -num\n        No  → Step 4: 設置 negative = false\n→ Step 5: 初始化 result 為空字符串\n→ Decision: num > 0? // 確保 num 有剩餘\n    Yes → Step 6: 循環\n        Step 6a: digit = num % 7\n        Step 6b: result = char_of(digit) + result // prepend digit\n        Step 6c: num = num // 7\n        Step 6d: 回到 Decision\n    No  → 跳出循環\n→ Decision: negative? \n    Yes → Step 7: result = '-' + result\n    No  → Step 7: result unchanged\n→ Step 8: 返回 result\nEnd\n\nNeed to ensure each line has \"→\" preceding. Use Step labels. Include comments. Also arrow inside loop? We'll have a sub-step. Might use indentation with arrow. We'll produce each step line individually. For loop, we can represent as \"→ Decision: num > 0?\" etc. Let's produce.\n\nAlso maybe we should add \"→ Step 6a\" etc. But we can keep numbering.\n\nLet's write.\n\nAlso ensure each line contains code and comment. Provide in Chinese.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 num // 取得使用者輸入的數值  \n→ Decision: 如果 num 等於 0? // 檢查是否為零  \n Yes → Step 2: 返回 '0' // 零的 base‑7 形式為字串 \"0\"  \n No  → Step 3: 判斷 num 是否為負? // 確認數字正負  \n  Yes → Step 4: 設置 negative = true, num = -num // 轉為正數處理  \n  No  → Step 4: 設置 negative = false // 保持正數  \n→ Step 5: 初始化 result 為空字串 // 用來存放轉換後的位數  \n→ Decision: num > 0? // 確保還有剩餘數字  \n Yes → Step 6a: digit = num % 7 // 取得最低位  \n  → Step 6b: result = char_of(digit) + result // 以字串前綴方式累加  \n  → Step 6c: num = num // 7 // 去掉已處理的位  \n  → Decision: num > 0? // 重複循環直至 num 為 0  \n   Yes → 回到 Step 6a  \n   No  → 跳出循環  \n No  → 跳過循環  \n→ Decision: negative? // 判斷是否需要加上負號  \n Yes → Step 7: result = '-' + result // 在前面加上負號  \n No  → Step 7: result 不變 // 直接使用現有字串  \n→ Step 8: 返回 result // 輸出最終的 base‑7 字串  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def convertToBase7(self, num: int) -> str:\n        \"\"\"\n        把整數 num 轉換成 7 進制的字串表示。\n        \"\"\"\n        # 0 的特殊情況\n        if num == 0:\n            return \"0\"\n\n        # 判斷符號，並把 num 轉成正整數處理\n        negative = num < 0\n        num = abs(num)\n\n        digits = []\n        # 逐位取餘數，累積到 list，最後反轉即可\n        while num > 0:\n            digits.append(str(num % 7))\n            num //= 7\n\n        # 如果是負數，先把負號放到最後，再倒序拼接\n        if negative:\n            digits.append('-')\n\n        # 逆序拼接得到最終字串\n        return ''.join(reversed(digits))\n\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，將輸入字串轉為整數，呼叫 convertToBase7，並輸出結果。\n    \"\"\"\n    import sys\n\n    data = sys.stdin.read().strip()\n    if not data:\n        return  # 空輸入直接返回\n\n    try:\n        num = int(data)\n    except ValueError:\n        # 如果輸入不是合法整數，直接結束\n        return\n\n    solver = Solution()\n    result = solver.convertToBase7(num)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "100",
          "expected_output": "\"202\"",
          "success": true,
          "output": "202"
        },
        {
          "example_index": 1,
          "input": "-7",
          "expected_output": "\"-10\"",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode460.json",
    "problem_index_in_file": 0,
    "title": "LFU Cache",
    "description_snippet": "Design and implement a data structure for a Least Frequently Used (LFU) cache.\n\nImplement the LFUCac...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for LFU cache. Provide line-by-line with explanation, using arrows, decision, etc. No actual code. Provide structure: Start, then initialize capacity, structures, get, put, helper functions for eviction, freq map, key map, etc. Provide O(1). Use two hash maps: key->(value,freq, node pointer), freq->DLL of keys. Also maintain minFreq. Virtual code steps: initialize, get, put, update freq, eviction. We produce lines like:\n\nStart // begin\n→ Step 1: Initialize capacity, minFreq, keyMap, freqMap // etc\n\nWe'll produce fairly detailed pseudocode.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 capacity, minFreq = 0 // 儲存快取容量與目前最小使用頻率  \n→ Step 2: 建立 keyMap: key → {value, freq, node} // 快取主映射，存值、頻率與鏈表節點指標  \n→ Step 3: 建立 freqMap: freq → DoublyLinkedList // 以頻率為鍵，對應雙向鏈表儲存同頻率鍵，保持最近使用順序  \n\n// ---------- Get 操作 ----------\n→ Step 4: get(key) // 取得指定鍵的值  \n    → Decision: 若 key 不在 keyMap? // 檢查鍵是否存在  \n        Yes → Step 5: return -1 // 鍵不存在，回傳 -1  \n        No  → Step 6: node = keyMap[key].node // 取得節點  \n        → Step 7: value = keyMap[key].value // 取得值  \n        → Step 8: updateFrequency(key) // 更新頻率並重排鏈表  \n        → Step 9: return value // 回傳取得的值  \n\n// ---------- Put 操作 ----------\n→ Step 10: put(key, value) // 插入或更新鍵值  \n    → Decision: 若 capacity == 0? // 空容量時直接返回  \n        Yes → Step 11: return // 無操作  \n    → Decision: 若 key 存在於 keyMap?  \n        Yes →  \n            → Step 12: keyMap[key].value = value // 更新值  \n            → Step 13: updateFrequency(key) // 更新頻率  \n        No →  \n            → Decision: keyMap.size() == capacity? // 是否已滿？  \n                Yes →  \n                    → Step 14: lfuKey = freqMap[minFreq].tail.key // 最舊的最小頻率鍵  \n                    → Step 15: remove(lfuKey) // 失效並刪除  \n                No → // 未滿，不需失效  \n            → Step 16: insertNewKey(key, value) // 新增鍵  \n\n// ---------- 更新頻率 ----------\n→ Step 17: updateFrequency(key) // 針對存取鍵更新頻率  \n    → Step 18: currFreq = keyMap[key].freq  \n    → Step 19: node = keyMap[key].node  \n    → Step 20: freqMap[currFreq].remove(node) // 從舊頻率鏈表移除節點  \n    → Decision: freqMap[currFreq].isEmpty()? // 該頻率鏈表是否空？  \n        Yes → Step 21: delete freqMap[currFreq] // 刪除空鏈表  \n        No  → // 保留  \n    → Step 22: newFreq = currFreq + 1  \n    → Step 23: keyMap[key].freq = newFreq // 更新頻率  \n    → Decision: freqMap[newFreq] 存在?  \n        No → Step 24: freqMap[newFreq] = new DoublyLinkedList() // 新建鏈表  \n    → Step 25: freqMap[newFreq].addFront(node) // 加入新頻率鏈表頭部，保持最近使用  \n    → Decision: currFreq == minFreq AND freqMap[currFreq] 空?  \n        Yes → Step 26: minFreq = newFreq // 更新最小頻率  \n        No  → // minFreq 不變  \n\n// ---------- 新增鍵 ----------\n→ Step 27: insertNewKey(key, value) // 直接插入鍵  \n    → Step 28: node = new DLLNode(key) // 建立鏈表節點  \n    → Step 29: keyMap[key] = {value, freq:1, node} // 新鍵映射，頻率初始 1  \n    → Step 30: minFreq = 1 // 重新設定最小頻率  \n    → Decision: freqMap[1] 存在?  \n        No → Step 31: freqMap[1] = new DoublyLinkedList() // 新建頻率 1 鏈表  \n    → Step 32: freqMap[1].addFront(node) // 加入鏈表頭部  \n\n// ---------- 刪除鍵 ----------\n→ Step 33: remove(key) // 刪除指定鍵  \n    → Step 34: node = keyMap[key].node  \n    → Step 35: freq = keyMap[key].freq  \n    → Step 36: freqMap[freq].remove(node) // 從頻率鏈表移除節點  \n    → Decision: freqMap[freq].isEmpty()?  \n        Yes → Step 37: delete freqMap[freq] // 刪除空鏈表  \n    → Step 38: delete keyMap[key] // 刪除主映射  \n    → Decision: freq == minFreq AND freqMap[minFreq] 空?  \n        Yes → Step 39: // minFreq 將被更新於下次 insert 或 updateFrequency  \n            // 這裡保持不變，因為新插入會重設為 1  \n        No  → // 保留  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current freq list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next freq list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict the least frequently used key\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key with freq 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    try:\n        ops, args_list = ast.literal_eval(data)\n    except Exception:\n        # Fallback if the input is not a valid Python literal\n        ops, args_list = json.loads(data)\n\n    cache = None\n    results = []\n    for op, args in zip(ops, args_list):\n        if op == \"LFUCache\":\n            cache = LFUCache(args[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(args[0], args[1])\n            results.append(None)\n        elif op == \"get\":\n            val = cache.get(args[0])\n            results.append(val)\n    # Output as JSON array (None -> null)\n    print(json.dumps(results, separators=(\", \", \": \")))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "success": true,
          "output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode241.json",
    "problem_index_in_file": 0,
    "title": "Different Ways to Add Parentheses",
    "description_snippet": "Given a string expression of numbers and operators, return all possible results from computing all t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given expression string like \"2*3-4*5\", compute all possible results from different groupings of operations (binary tree). This is classic Leetcode \"Different Ways to Add Parentheses\". Approach: recursion with memoization. Steps: parse string into tokens (numbers and operators). Use DFS compute results for segment [l,r]. Memo dict mapping (l,r) to list of results. For each operator index in segment, compute left and right recursively, combine with operator. Base case when l==r: return number.\n\nWe need to output step-by-step virtual code. Provide each line with comment. Use Start, End, Decision. Use arrow for flow.\n\nWe must not output actual code, only virtual code lines. We'll produce high-level algorithm steps. Let's outline:\n\nStart\n→ Step 1: 定義函數 compute(l,r) // 計算子表達式 [l,r] 的所有結果\n→ Decision: l==r? // 檢查是否只有一個數字\n    Yes → Step 2: 返回 數字 tokens[l] // 單數字情況\n    No  → Step 3: 檢查 memo (l,r) // 若已計算則直接返回\n        Yes → Step 4: 返回 memo[(l,r)] // 取記錄\n        No  → Step 5: 初始化 results list // 收集結果\n        → Step 6: 循環 i from l+1 to r-1 step 2 // i 指向運算子\n            → Step 7: left = compute(l,i-1) // 左子結果\n            → Step 8: right = compute(i+1,r) // 右子結果\n            → Decision: tokens[i] 是 '+'? // 根據運算子類型\n                Yes → Step 9: 對每 a in left, b in right, results.add(a+b)\n                No → Decision: tokens[i] 是 '-'?\n                    Yes → Step 10: results.add(a-b)\n                    No → Step 11: results.add(a*b)\n            → End of for loop\n        → Step 12: memo[(l,r)] = results // 記錄\n        → Step 13: 返回 results\n→ End of compute function\n→ Step 14: 將表達式拆分為 tokens // 數字和運算子列表\n→ Step 15: 結果 = compute(0, len(tokens)-1) // 計算整個表達式\n→ End // 返回結果\n\nWe need to use virtual code with arrows, decisions. Provide each step line. For decisions with branches we indent. Use \"→\" arrow to indicate next step, and \"Decision:\" lines. Indentation: we can indent lines under decisions with spaces.\n\nLet's write.\n\nAlso we need to explain each line: use comment // 解釋. So each line is like \"Start // 程式開始執行\".\n\nWe'll produce.\n\nNote: We should represent function definitions and loops as steps. Use \"→ Function compute(l,r)\". Indentation: For loops we can do \"→ For i from l+1 to r-1 step 2\". Indent subsequent lines under For.\n\nAlso note for memo: \"→ If memo contains (l,r)\". Use Decision.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Function compute(l, r) // 計算子表達式範圍 [l, r] 的所有可能結果\n    → Decision: l == r? // 判斷是否只有一個數字\n        Yes → Return tokens[l] // 單個數字直接回傳\n        No  → Decision: memo contains (l, r)? // 檢查是否已計算\n            Yes → Return memo[(l, r)] // 取出已存的結果\n            No  → Step: results ← [] // 初始化結果列表\n            → For i from l+1 to r-1 step 2 // i 指向運算子位置\n                → Step: left ← compute(l, i-1) // 計算左子表達式\n                → Step: right ← compute(i+1, r) // 計算右子表達式\n                → Decision: tokens[i] == '+'? // 根據運算子類型\n                    Yes → For a in left\n                            For b in right\n                                Append (a + b) to results // 加法組合\n                    No → Decision: tokens[i] == '-'?\n                        Yes → For a in left\n                                For b in right\n                                    Append (a - b) to results // 減法組合\n                        No → For a in left\n                                For b in right\n                                    Append (a * b) to results // 乘法組合\n            → Step: memo[(l, r)] ← results // 記錄計算結果\n            → Return results // 返回此範圍的所有結果\n→ End Function // compute 函式結束\n→ Step: tokens ← Split expression into numbers and operators // 解析輸入字串為數字及符號列表\n→ Step: all_results ← compute(0, len(tokens)-1) // 計算整個表達式\n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef diff_ways_to_compute(expression: str):\n    \"\"\"回傳所有可能的計算結果。\"\"\"\n    memo = {}\n\n    def helper(expr: str):\n        if expr in memo:\n            return memo[expr]\n\n        results = []\n        # 遍歷字串，找出運算子\n        for i, ch in enumerate(expr):\n            if ch in '+-*':\n                left = helper(expr[:i])\n                right = helper(expr[i+1:])\n                for l in left:\n                    for r in right:\n                        if ch == '+':\n                            results.append(l + r)\n                        elif ch == '-':\n                            results.append(l - r)\n                        else:\n                            results.append(l * r)\n\n        # 若沒有運算子，表示 expr 只是一個數字\n        if not results:\n            results.append(int(expr))\n        memo[expr] = results\n        return results\n\n    return helper(expression)\n\n\ndef main():\n    # 從標準輸入讀取內容，並嘗試提取 expression 字串\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 先試著找 \"expression = ...\" 的形式\n    match = re.search(r'expression\\s*=\\s*([\"\\'])(.*?)\\1', raw_input)\n    if match:\n        expr = match.group(2)\n    else:\n        # 如果沒有該格式，直接去除可能的引號\n        expr = raw_input.strip('\"\\'')\n    # 計算結果並輸出\n    results = diff_ways_to_compute(expr)\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[2,0]",
          "success": true,
          "output": "[2, 0]"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-10,-14,-10,10]",
          "success": true,
          "output": "[-34, -10, -14, -10, 10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode260.json",
    "problem_index_in_file": 0,
    "title": "Single Number III",
    "description_snippet": "Given an integer array nums, in which exactly two elements appear only once and all the other elemen...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: find two unique numbers in array where others appear twice. Classic XOR approach. Steps: XOR all numbers to get xor = a ^ b. Find rightmost set bit. Partition array into two groups based on that bit and XOR each to get a and b. Provide virtual code lines with explanation. Use Start, End, Decision, etc. Provide step-by-step. Ensure each line has virtual code step + // explanation. Use arrow lines. Should be plain text.\n\nLet's craft:\n\nStart // program starts\n\n→ Step 1: XORAll = 0 // 初始化 XOR 存儲\n\n→ Step 2: For each num in nums: XORAll = XORAll XOR num // 求所有元素的 XOR，得到 a^b\n\n→ Step 3: Find rightmost set bit mask = XORAll AND (-XORAll) // 找到 a 和 b 的不同位\n\n→ Decision: 如果 mask == 0? // 理論上不可能，但做健全檢查\n    Yes → End // 结束，無需處理\n    No  → proceed\n\n→ Step 4: uniq1 = 0 // 初始化第一個唯一數\n→ Step 5: uniq2 = 0 // 初始化第二個唯一數\n\n→ Step 6: For each num in nums:\n    Decision: 如果 (num AND mask) != 0? // 根據 mask 分組\n        Yes → uniq1 = uniq1 XOR num // 將位為 1 的分組 XOR\n        No  → uniq2 = uniq2 XOR num // 其餘分組 XOR\n\n→ Step 7: Output [uniq1, uniq2] // 返回兩個唯一元素\n\nEnd // 程式結束\n\nAdd explanations. Each line ends with //.\n\nMake sure to include arrow for decision branches. Use arrow for each step. Provide only virtual code. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: XORAll = 0 // 初始化 XOR 儲存變數  \n→ Step 2: For each num in nums: XORAll = XORAll XOR num // 把所有數字 XOR，得到 a ^ b  \n→ Step 3: mask = XORAll AND (-XORAll) // 找到 a 和 b 不同的最低有效位  \n→ Decision: 如果 mask == 0? // 理論上不會發生，但做健全檢查  \n    Yes → End // 結束，無需進一步處理  \n    No  → // 繼續後續步驟  \n→ Step 4: uniq1 = 0 // 初始化第一個唯一數  \n→ Step 5: uniq2 = 0 // 初始化第二個唯一數  \n→ Step 6: For each num in nums:  \n    Decision: 如果 (num AND mask) != 0? // 根據 mask 將數字分成兩組  \n        Yes → uniq1 = uniq1 XOR num // 組中數字 XOR 得到 a  \n        No  → uniq2 = uniq2 XOR num // 另一組數字 XOR 得到 b  \n→ Step 7: Output [uniq1, uniq2] // 回傳兩個唯一元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        xor = 0\n        for num in nums:\n            xor ^= num\n\n        # 找到 xor 的最右邊 1\n        diff_bit = xor & -xor\n\n        a = b = 0\n        for num in nums:\n            if num & diff_bit:\n                a ^= num\n            else:\n                b ^= num\n        return [a, b]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 從輸入中提取列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1:\n        nums_str = data[start:end+1]\n    else:\n        nums_str = data  # 假設輸入本身就是列表字串\n\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # 如果解析失敗，直接退出\n        sys.exit()\n\n    result = Solution().singleNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,3,2,5]",
          "expected_output": "[3,5]",
          "success": true,
          "output": "[3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0]",
          "expected_output": "[-1,0]",
          "success": true,
          "output": "[-1, 0]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,1]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode224.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator",
    "description_snippet": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and r...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode but not actual code). Must follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows and decision structure. The task: implement a basic calculator for string expression. Basic operations: +, -, *, / and parentheses. No eval. So algorithm: Use two stacks: values and operators. Scan string char by char. Use helper to apply operator. Need to handle spaces.\n\nWe produce pseudocode lines.\n\nWe need to adhere to format example: Start // 程式開始執行. Then arrow lines.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Initialize two stacks: values and ops // 用於存儲數值和運算符\n\nLine 3: → 定義函式 precedence(op) // 返回運算符優先級\n\nLine 4: → 定義函式 applyOp() // 從堆疊取兩個數值和運算符，計算並推回結果\n\nLine 5: → 轉換輸入字符串 s 為字符序列，去除空格 // 為了方便逐字符處理\n\nLine 6: → Decision: 是否已到結尾? // 開始遍歷字符\n\nNow we need to handle each char: digits may form numbers, parentheses, operators.\n\nWe'll use loop: While idx < len(s)\n\nInside loop:\n\nDecision: 当前字符是 '('? // If left parenthesis\n\nYes → Push '(' onto ops // 進入括號\n\nNo → Decision: 当前字符是 ')'?\n\nYes → While top of ops != '(' → applyOp() // 釋放括號內運算\n\n→ Pop '('\n\nNo → Decision: 当前字符是數字?\n\nYes → Accumulate full number until non-digit // handle multi-digit\n\n→ Push number onto values\n\nNo → Decision: 当前字符是運算符 (+,-,*,/)?\n\nYes → While ops not empty AND precedence(top op) >= precedence(current) AND top op != '(' → applyOp() // Resolve higher/equal precedence\n\n→ Push current operator onto ops\n\nNo → // ignore (e.g., spaces)\n\nAfter loop: While ops not empty → applyOp()\n\nResult = top of values\n\nEnd\n\nWe need to write each line accordingly.\n\nLet's produce step-by-step.\n\nWe should use indentation? In example, they use indentation for nested decisions. We'll follow similar style.\n\nAlso ensure each line ends with // explanation. Use arrow \"→\" after each step.\n\nLet's generate.\n\nWe need to start with Start.\n\nWe'll produce each step line.\n\nAlso we may need to define helper functions at top.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize two stacks: values and ops // 用於存儲數值和運算符  \n→ 定義函式 precedence(op) // 回傳運算符優先級：'*'/'/' = 2，'+'/'-' = 1  \n→ 定義函式 applyOp() // 從 ops 取運算符，從 values 取兩個數值，計算後推回 values  \n→ 將輸入字串 s 去除空白，並轉為字符序列 chars // 方便逐字符處理  \n→ 初始化索引 idx ← 0 // 位置指標  \n→ Decision: idx < length(chars) ? // 開始遍歷字符  \n    Yes → Decision: chars[idx] == '(' ? // 左括號  \n        Yes → Push '(' onto ops // 進入括號區段  \n        No → Decision: chars[idx] == ')' ? // 右括號  \n            Yes → While top of ops != '(' → applyOp() // 計算括號內所有運算  \n                → Pop '(' from ops // 移除左括號  \n            No → Decision: chars[idx] 是數字? // 數字字符  \n                Yes → Initialize num ← 0 // 整數累積  \n                    → While idx < length(chars) AND chars[idx] 是數字 → num ← num*10 + int(chars[idx]); idx ← idx + 1  \n                → Push num onto values // 將完整數值入棧  \n                → idx ← idx - 1 // 退回到最後一個非數字字符  \n            No → Decision: chars[idx] 是運算符 (+, -, *, /) ? // 運算符字符  \n                Yes → While ops not empty AND precedence(top of ops) >= precedence(chars[idx]) AND top of ops != '('  \n                    → applyOp() // 先計算高優先級或相同優先級運算  \n                → Push chars[idx] onto ops // 推入當前運算符  \n                No → // 其他字符（如空格）不處理  \n        idx ← idx + 1 // 移動至下一個字符  \n        No → // 遍歷結束  \n→ While ops not empty → applyOp() // 處理剩餘運算符  \n→ Result ← Top of values // 最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        # Two stacks: values for numbers, ops for operators\n        values, ops = [], []\n\n        # Helper to get precedence\n        def precedence(op: str) -> int:\n            if op in ('+', '-'):\n                return 1\n            if op in ('*', '/'):\n                return 2\n            return 0\n\n        # Helper to apply top operator on top two values\n        def apply_op():\n            right = values.pop()\n            left = values.pop()\n            op = ops.pop()\n            if op == '+':\n                values.append(left + right)\n            elif op == '-':\n                values.append(left - right)\n            elif op == '*':\n                values.append(left * right)\n            elif op == '/':\n                # Integer division truncating toward zero\n                values.append(int(left / right))\n\n        i, n = 0, len(s)\n        while i < n:\n            ch = s[i]\n            if ch == ' ':\n                i += 1\n                continue\n            if ch == '(':\n                ops.append(ch)\n                i += 1\n            elif ch == ')':\n                while ops and ops[-1] != '(':\n                    apply_op()\n                ops.pop()  # pop '('\n                i += 1\n            elif ch.isdigit():\n                num = 0\n                while i < n and s[i].isdigit():\n                    num = num * 10 + int(s[i])\n                    i += 1\n                values.append(num)\n            else:  # operator\n                while ops and ops[-1] != '(' and precedence(ops[-1]) >= precedence(ch):\n                    apply_op()\n                ops.append(ch)\n                i += 1\n\n        while ops:\n            apply_op()\n\n        return values[0]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if '=' in raw_input:\n        # Expect format like s = \"expression\"\n        _, expr_part = raw_input.split('=', 1)\n        expr = expr_part.strip()\n        if expr.startswith('\"') and expr.endswith('\"'):\n            expr = expr[1:-1]\n        elif expr.startswith(\"'\") and expr.endswith(\"'\"):\n            expr = expr[1:-1]\n    else:\n        expr = raw_input\n\n    solution = Solution()\n    result = solution.calculate(expr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode561.json",
    "problem_index_in_file": 0,
    "title": "Array Partition",
    "description_snippet": "Given an integer array nums of 2n integers, group these integers into n pairs (a_1, b_1), (a_2, b_2)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: maximize sum of min of pairs. Known solution: sort array ascending, then pair adjacent elements (since sorted, min of pair is the first element). Sum over every second element. Steps: sort, iterate i=0 to len-1 step 2, sum += nums[i]. Return sum.\n\nWe need to produce lines like:\n\nStart\n→ Step 1: Input array nums // ...\n\nDecision? maybe check if empty? but problem guarantee 2n integers. But include check for length>0.\n\nWe need to produce \"虛擬碼步驟\" in Chinese? Likely yes, Chinese explanation. Use English in virtual code? Could use steps in Chinese? The format uses \"虛擬碼步驟\" like \"Step 1: ...\" We'll keep as \"Step 1: sort nums ascending\". Use arrow.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort nums in non-decreasing order // 對數組進行排序\n→ Step 2: Initialize sum = 0 // 用於累加結果\n→ Step 3: For i from 0 to length(nums)-1 with step 2 // 每隔一個元素選取一次\n    → Step 4: sum = sum + nums[i] // 將當前元素加到總和，因為它是 min(ai, bi)\n→ End // 回傳 sum // 回傳最大化後的總和\n\nWe might include Decision: If nums is empty? But not necessary.\n\nBetter to show loop with Decision maybe: Decision: i < length? But it's okay.\n\nLet's produce output with each line separate and explanation comment after //.\n\nMake sure to include arrow formatting \"→\".\n\nAlso ensure Start and End labels. Provide Step numbers.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums in non-decreasing order // 對整數陣列進行升序排序  \n→ Step 2: Initialize sum = 0 // 建立累加變數用於儲存結果  \n→ Step 3: For i from 0 to length(nums)-1 with step 2 // 每兩個相鄰元素取一次，索引從 0 開始  \n  → Step 4: sum = sum + nums[i] // 由於排序後相鄰對中的最小值是前一個元素，直接累加  \n→ End // 回傳 sum // 返回最大化的 min(ai, bi) 總和",
      "generated_code": "import sys\nimport ast\n\ndef array_pair_sum(nums):\n    \"\"\"\n    將整數陣列排序後，依序取每兩個相鄰元素中的第一個（即 min）累加。\n    \"\"\"\n    nums.sort()\n    return sum(nums[::2])\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入字串為列表\n    nums = ast.literal_eval(data)\n\n    # 計算並輸出結果\n    result = array_pair_sum(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,4,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "[6,2,6,5,1,2]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode55.json",
    "problem_index_in_file": 0,
    "title": "Jump Game",
    "description_snippet": "You are given an integer array nums. You are initially positioned at the array's first index, and ea...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the \"Jump Game\" problem. Use steps: start, input array, initialize maxReach, loop over array, update maxReach, check if current index > maxReach => false, after loop return true. Provide line-by-line with comments. Use Start, End, Decision etc. Should be in Traditional Chinese. Let's craft.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows → and Decision. Ensure structure. Provide maybe step names.\n\nLet's produce.\n\nWe'll have:\n\nStart\n→ Step 1: Input array nums // 從使用者或函式取得整數陣列\n→ Step 2: maxReach = 0 // 最高可達索引初始化為 0\n→ Step 3: For i from 0 to length(nums)-1 // 逐個遍歷陣列\n    → Decision: 如果 i > maxReach? // 當當前索引已超過能達到的最遠距離\n        Yes → Step 4: Return false // 代表無法到達最後一個索引\n        No  → Step 5: maxReach = max(maxReach, i + nums[i]) // 更新能達到的最遠距離\n    → Decision: 如果 maxReach >= length(nums)-1? // 早期成功判斷\n        Yes → Step 6: Return true // 已能到達或超過最後一個索引\n        No  → Continue // 仍需遍歷\nEnd // 函式結束\n\nNeed to include proper indentation. Use arrow lines. Also ensure each line ends with comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 取得整數陣列  \n→ Step 2: maxReach = 0 // 初始化最大可達索引  \n→ Step 3: For i from 0 to length(nums)-1 // 逐個遍歷陣列  \n  → Decision: 如果 i > maxReach? // 檢查當前索引是否已超出可達範圍  \n   Yes → Step 4: Return false // 無法到達最後一個索引，結束並回傳 false  \n   No → Step 5: maxReach = max(maxReach, i + nums[i]) // 更新最大可達索引  \n  → Decision: 如果 maxReach >= length(nums)-1? // 早期判斷是否已能到達最後一個索引  \n   Yes → Step 6: Return true // 能夠到達，結束並回傳 true  \n   No → Continue // 繼續迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def canJump(self, nums):\n        \"\"\"判斷是否能從首位跳到最後一位\"\"\"\n        max_reach = 0\n        for i, jump in enumerate(nums):\n            if i > max_reach:          # 當前位置已超過能達到的最遠距離\n                return False\n            max_reach = max(max_reach, i + jump)  # 更新能達到的最遠距離\n        return True\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    \n    # 找出第一個 [] 包含的陣列字串\n    match = re.search(r'\\[.*?\\]', raw_input)\n    if not match:\n        print(\"false\")  # 若找不到陣列，直接回傳 false\n        sys.exit(0)\n    \n    nums_str = match.group(0)\n    try:\n        nums = ast.literal_eval(nums_str)   # 轉成 Python list\n    except Exception:\n        print(\"false\")\n        sys.exit(0)\n    \n    sol = Solution()\n    result = sol.canJump(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,0,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode220.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate III",
    "description_snippet": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indice...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation. It's like algorithm to solve \"Contains Duplicate III\". Approach: sliding window with balanced BST or TreeSet (or a sorted list). Since it's virtual code, we can use structure like \"for i in 0..n-1: check within window\". Provide step-by-step. Use Start, End, Decision. Use arrows and Yes/No. Also use virtual code step labels. Provide explanation after each line.\n\nWe need to not output actual code but a high-level pseudocode. We can use \"Insert into TreeSet\", \"Remove from TreeSet\", \"Floor\", \"Ceiling\". Let's produce. We'll start with Start, step 1: create an empty sorted multiset. Step 2: iterate index i. Step 3: before insertion, check if any element within valueDiff in set. Use floor/ceil. Decision: if floor exists and abs(nums[i] - floor) <= valueDiff or ceil similarly. If found, return true. Then insert nums[i]. Then if window size > indexDiff, remove nums[i-indexDiff-1]. After loop, return false. End.\n\nMake sure each line ends with // explanation. Use arrow.\n\nLet's produce.\n\nAlso include decisions and branches. Provide explanation accordingly.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的有序多重集合 S // 用來維持滑動視窗內的元素，便於快速查找相鄰值  \n→ Step 2: 設定變數 n ← nums 的長度 // 方便後續迴圈遍歷  \n→ For i 從 0 到 n-1 迴圈 // 逐一檢查每個索引  \n  → Decision: 如果 S 內存在值 x 使得 abs(x - nums[i]) ≤ valueDiff? // 查找是否已有滿足值差的元素  \n    Yes → Return true // 找到合法對，直接結束  \n    No → // 未找到，繼續處理  \n     → Step 3: 將 nums[i] 插入 S // 把目前元素加入滑動窗口  \n     → Decision: 若 i ≥ indexDiff + 1? // 判斷窗口是否超過允許的索引差  \n      Yes → Step 4: 移除 nums[i - indexDiff - 1] 從 S // 把最舊的元素移除，保持窗口大小  \n      No → // 窗口未超過，無需移除  \n→ End // 循環結束，若未返回 true  \n→ Return false // 沒有任何符合條件的索引對，回傳假  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        if k <= 0 or t < 0:\n            return False\n        window = SortedList()\n        for i, num in enumerate(nums):\n            # Find the first element not less than num - t\n            pos = window.bisect_left(num - t)\n            if pos < len(window) and abs(window[pos] - num) <= t:\n                return True\n            window.add(num)\n            if len(window) > k:\n                # Remove the element that is now out of the sliding window\n                window.remove(nums[i - k])\n        return False\n\ndef parse_input(data: str):\n    \"\"\"Parse input in the form:\n       'nums = [1,2,3,1], indexDiff = 3, valueDiff = 0'\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums = ast.literal_eval(nums_match.group(1)) if nums_match else []\n\n    index_match = re.search(r'indexDiff\\s*=\\s*(-?\\d+)', data)\n    index_diff = int(index_match.group(1)) if index_match else 0\n\n    value_match = re.search(r'valueDiff\\s*=\\s*(-?\\d+)', data)\n    value_diff = int(value_match.group(1)) if value_match else 0\n\n    return nums, index_diff, value_diff\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    nums, index_diff, value_diff = parse_input(raw_input)\n    sol = Solution()\n    result = sol.containsNearbyAlmostDuplicate(nums, index_diff, value_diff)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmptn_se8_p.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpgrhn2ff_.py\", line 4, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode229.json",
    "problem_index_in_file": 0,
    "title": "Majority Element II",
    "description_snippet": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for Boyer-Moore majority vote algorithm for k=3 threshold. Steps: candidate1, count1, candidate2, count2. Loop through array, update. Then verify counts. Provide Start, End, Decision. Each line with explanation. Use arrow format. Ensure no actual code. Use 逐行. Provide for each line \"→\" etc.\n\nWe need to produce code that finds all elements that appear more than floor(n/3). So algorithm: initialize two candidates and counts zero. Iterate array: if num==cand1 -> count1++ ; else if num==cand2 -> count2++ ; else if count1==0 -> cand1=num, count1=1 ; else if count2==0 -> cand2=num, count2=1 ; else count1--, count2--. After first pass, reset counts to 0. Second pass count occurrences of cand1 and cand2. Then create result list: if count1 > n/3 add cand1; if count2 > n/3 add cand2. Output.\n\nLet's produce pseudocode lines:\n\nStart\n→ Step 1: Initialize candidate1, candidate2 to null and count1, count2 to 0 // 初始兩個候選值與計數\n→ Step 2: For each element num in array // 第一遍遍歷\n    → Decision: num equals candidate1? // 判斷是否與候選1相同\n        Yes → Increment count1 // 增加候選1計數\n        No  → Decision: num equals candidate2? // 判斷是否與候選2相同\n            Yes → Increment count2 // 增加候選2計數\n            No  → Decision: count1 equals 0? // 候選1空位？\n                Yes → Set candidate1 = num, count1 = 1 // 新候選1\n                No  → Decision: count2 equals 0? // 候選2空位？\n                    Yes → Set candidate2 = num, count2 = 1 // 新候選2\n                    No  → Decrement count1, decrement count2 // 兩計數都減一\n→ Step 3: Reset count1 and count2 to 0 // 重新計算真實頻次\n→ Step 4: For each element num in array // 第二遍遍歷\n    → Decision: num equals candidate1? // 若等候選1\n        Yes → Increment count1 // 計數\n        No  → Decision: num equals candidate2? // 若等候選2\n            Yes → Increment count2 // 計數\n            No  → No action // 不是兩候選\n→ Step 5: Initialize result list // 儲存符合條件的元素\n→ Decision: count1 > floor(n/3)? // 檢查候選1頻次\n    Yes → Append candidate1 to result // 加入列表\n    No  → No action\n→ Decision: count2 > floor(n/3)? // 檢查候選2頻次\n    Yes → Append candidate2 to result // 加入列表\n    No  → No action\n→ Step 6: Output result list // 輸出所有超過 ⌊n/3⌋ 次的元素\nEnd\n\nBut we need to format each line with \"→\" and \"Decision:\" accordingly. For decisions with nested, use indentation and arrows.\n\nWe need to include the arrows like \"→ Decision:\" and inside \"Yes →\", \"No →\".\n\nMake sure each line contains the pseudocode step and a comment.\n\nAlso we need to output all lines, each line ended with \"// ...\".\n\nOk let's craft.\n\nMake sure we use \"Start\" and \"End\" as per format.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 candidate1, candidate2 為空，count1, count2 為 0 // 設定初始候選值與計數\n→ Step 2: 對陣列中的每個元素 num 進行遍歷 // 第一輪遍歷，用於找候選值\n    → Decision: num == candidate1? // 判斷是否與候選1相同\n        Yes → Increment count1 // 如果相同，增加候選1計數\n        No  → Decision: num == candidate2? // 判斷是否與候選2相同\n            Yes → Increment count2 // 如果相同，增加候選2計數\n            No  → Decision: count1 == 0? // 候選1位置是否為空\n                Yes → Set candidate1 = num, count1 = 1 // 設置新的候選1\n                No  → Decision: count2 == 0? // 候選2位置是否為空\n                    Yes → Set candidate2 = num, count2 = 1 // 設置新的候選2\n                    No  → Decrement count1, count2 // 兩計數同時減一\n→ Step 3: 重置 count1, count2 為 0 // 重新準備計算真實出現次數\n→ Step 4: 對陣列中的每個元素 num 進行第二遍遍歷 // 重新計算候選值的實際頻次\n    → Decision: num == candidate1? // 檢查是否為候選1\n        Yes → Increment count1 // 計算候選1實際次數\n        No  → Decision: num == candidate2? // 檢查是否為候選2\n            Yes → Increment count2 // 計算候選2實際次數\n            No  → No operation // 不是候選值，忽略\n→ Step 5: 初始化空的 result 列表 // 用於儲存符合條件的元素\n→ Decision: count1 > ⌊n/3⌋? // 判斷候選1是否超過閾值\n    Yes → Append candidate1 to result // 加入結果列表\n    No  → No action // 不符合條件\n→ Decision: count2 > ⌊n/3⌋? // 判斷候選2是否超過閾值\n    Yes → Append candidate2 to result // 加入結果列表\n    No  → No action // 不符合條件\n→ Step 6: 輸出 result 列表 // 顯示所有出現次數超過 ⌊n/3⌋ 的元素\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def majorityElement(self, nums):\n        if not nums:\n            return []\n        # 初始化候選人和計數\n        candidate1 = candidate2 = None\n        count1 = count2 = 0\n\n        # 第一遍：找出最多兩個候選人\n        for num in nums:\n            if candidate1 == num:\n                count1 += 1\n            elif candidate2 == num:\n                count2 += 1\n            elif count1 == 0:\n                candidate1, count1 = num, 1\n            elif count2 == 0:\n                candidate2, count2 = num, 1\n            else:\n                count1 -= 1\n                count2 -= 1\n\n        # 第二遍：確認候選人的實際出現次數\n        result = []\n        n = len(nums)\n        count1 = count2 = 0\n        for num in nums:\n            if num == candidate1:\n                count1 += 1\n            elif num == candidate2:\n                count2 += 1\n\n        # 檢查是否超過 ⌊n/3⌋\n        if count1 > n // 3:\n            result.append(candidate1)\n        if count2 > n // 3:\n            result.append(candidate2)\n\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 可能輸入形式為 \"nums = [3,2,3]\"\n    if data.lower().startswith('nums'):\n        idx = data.find('=')\n        if idx != -1:\n            data = data[idx + 1:].strip()\n\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        nums = eval(data, {})\n\n    sol = Solution()\n    res = sol.majorityElement(nums)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "[3]",
          "success": true,
          "output": "[3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode748.json",
    "problem_index_in_file": 0,
    "title": "Shortest Completing Word",
    "description_snippet": "Given a string licensePlate and an array of strings words, find the shortest completing word in word...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step, each line with arrow and comment. Let's design algorithm: 1) Process licensePlate to count letters ignoring case. 2) Iterate words array, find shortest word that covers counts. Keep best. 3) Return best. So produce virtual code. Need to adhere to format. Use Start, Decision, etc. Use → arrow. Provide each step.\n\nLet's craft lines:\n\nStart // Start\n→ Step 1: licenseCounts ← empty map // initialise letter frequency map\n→ Step 2: For each character c in licensePlate // iterate through licensePlate\n    → Decision: If c is a letter? // filter letters\n        Yes → Step 3: lc ← lower(c) // convert to lowercase\n        Yes → Step 4: licenseCounts[lc] ← licenseCounts.get(lc, 0) + 1 // increment count\n→ Step 5: bestWord ← \"\" // placeholder for best result\n→ Step 6: bestLength ← Infinity // length of bestWord\n→ Step 7: For each word in words // iterate words\n    → Step 8: wordCounts ← empty map // count letters in word\n    → Step 9: For each character d in word\n        → Step 10: lc_d ← lower(d)\n        → Step 11: wordCounts[lc_d] ← wordCounts.get(lc_d, 0) + 1\n    → Decision: If word satisfies licenseCounts? // check if word covers all counts\n        Yes → Decision: If length(word) < bestLength? // shorter than current best\n            Yes → Step 12: bestWord ← word // update best\n            Yes → Step 13: bestLength ← length(word) // update length\n            No  → No // do nothing if not shorter\n        No  → No // not satisfying\n→ Step 14: Return bestWord // final result\nEnd // End\n\nNeed to be careful with arrow formatting: each line start with \"→\" or \"Start\". Indent decisions. Use \"Yes →\" and \"No →\". Use \"Decision:\" line preceding decision lines. Provide comment after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: licenseCounts ← empty map // 建立空的字母頻率表  \n→ Step 2: For each character c in licensePlate // 逐字檢查 licensePlate  \n  → Decision: 如果 c 是字母? // 過濾掉非字母字符  \n   Yes → Step 3: lc ← lower(c) // 轉成小寫  \n   Yes → Step 4: licenseCounts[lc] ← licenseCounts.get(lc, 0) + 1 // 計數  \n→ Step 5: bestWord ← \"\" // 儲存目前最佳單字  \n→ Step 6: bestLength ← Infinity // 儲存最佳單字長度  \n→ Step 7: For each word in words // 遍歷所有候選單字  \n  → Step 8: wordCounts ← empty map // 以新表計算此單字的字母頻率  \n  → Step 9: For each character d in word  \n   → Step 10: lc_d ← lower(d) // 轉成小寫  \n   → Step 11: wordCounts[lc_d] ← wordCounts.get(lc_d, 0) + 1 // 計數  \n  → Decision: 此單字是否符合 licenseCounts? // 檢查所有必要字母及其出現次數  \n   Yes → Decision: length(word) < bestLength? // 是否比目前最佳更短  \n    Yes → Step 12: bestWord ← word // 更新最佳單字  \n    Yes → Step 13: bestLength ← length(word) // 更新最佳長度  \n    No  → No // 若不更短，保持目前最佳  \n   No  → No // 不符合要求，忽略此單字  \n→ Step 14: Return bestWord // 回傳最短符合條件的單字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport collections\n\nclass Solution:\n    def shortestCompletingWord(self, licensePlate, words):\n        # Count required letters (case-insensitive)\n        plate_count = collections.Counter(\n            c.lower() for c in licensePlate if c.isalpha()\n        )\n        best_word = None\n        for word in words:\n            # Count letters in current word\n            word_count = collections.Counter(word.lower())\n            # Check if all required letters are satisfied\n            if all(word_count[c] >= plate_count[c] for c in plate_count):\n                # Update best word if shorter or first found\n                if best_word is None or len(word) < len(best_word):\n                    best_word = word\n        return best_word\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract licensePlate string and words list from input text.\n    Expected format: 'licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]'\n    \"\"\"\n    # Extract licensePlate value\n    lp_match = re.search(r'licensePlate\\s*=\\s*\"([^\"]*)\"', data)\n    license_plate = lp_match.group(1) if lp_match else \"\"\n\n    # Extract words list\n    words_match = re.search(r'words\\s*=\\s*(\\[.*\\])', data, re.DOTALL)\n    words_str = words_match.group(1) if words_match else \"[]\"\n    try:\n        words = eval(words_str, {\"__builtins__\": None}, {})\n    except Exception:\n        words = []\n\n    return license_plate, words\n\ndef main():\n    # Read entire stdin\n    data = sys.stdin.read()\n    license_plate, words = parse_input(data)\n\n    sol = Solution()\n    result = sol.shortestCompletingWord(license_plate, words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]",
          "expected_output": "\"steps\"",
          "success": true,
          "output": "steps"
        },
        {
          "example_index": 1,
          "input": "licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]",
          "expected_output": "\"pest\"",
          "success": true,
          "output": "pest"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode136.json",
    "problem_index_in_file": 0,
    "title": "Single Number",
    "description_snippet": "Given a non-empty array of integers nums, every element appears twice except for one. Find that sing...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: find the single element in array where all others appear twice. We want linear runtime, constant space. The known solution: XOR all elements. Each pair cancels, leaving single.\n\nWe need to output virtual code steps line by line, with explanations. Format: Start // etc. Use arrow symbols, Decision, etc. Provide step names. So we produce something like:\n\nStart // start\n→ Step 1: Set result = 0 // initialize XOR accumulator\n→ Step 2: For each num in nums: // iterate array\n    → Step 2.1: result = result XOR num // accumulate XOR\n→ Step 3: Return result // final single element\nEnd\n\nBut also we may incorporate some decision: maybe early exit? But typical XOR approach no decisions. But we can include a decision: if array length is 1? Then return that. But not necessary. We can include decision: if nums length==1? return element. That still linear. But they didn't mention requirement to handle single element. We can just do loop.\n\nWe must adhere to format: each line: \"虛擬碼步驟 // 解釋\". Each step must be separated. Use arrow for each step.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result = 0 // 用於累積 XOR 結果\n→ Step 2: 循環遍歷 nums 中每個 num // 逐一處理每個數字\n    → Step 2.1: result = result XOR num // 將數字與累積結果做 XOR\n→ Step 3: 輸出 result // result 即為唯一不重複的數字\nEnd // 程式執行結束\n\nWe need to include decisions? Not necessary.\n\nBut we can add decision: if nums 為空? But problem says non-empty.\n\nAdd Decision: If nums length == 1? return that. Let's incorporate:\n\n→ Decision: nums 長度是否等於 1? // 檢查是否只有一個元素\n    Yes → Step 2a: Return nums[0] // 單元素直接返回\n    No  → Step 2: 循環...\n\nBut format uses Decision: if ...? with Yes → and No →. So incorporate.\n\nThus final output.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: nums 長度是否等於 1? // 檢查是否只有一個元素  \n  Yes → Step 1a: Return nums[0] // 單元素直接回傳  \n  No  → Step 1: 初始化 result = 0 // 用於累積 XOR 結果  \n→ Step 2: 循環遍歷 nums 中每個 num // 逐一處理每個數字  \n  → Step 2.1: result = result XOR num // 將數字與累積結果做 XOR  \n→ Step 3: Return result // result 即為唯一不重複的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 取出方括號中的列表字串\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n    else:\n        list_str = data\n    list_str = list_str.strip()\n\n    # 轉換為 Python list\n    nums = ast.literal_eval(list_str)\n\n    # 計算並輸出答案\n    sol = Solution()\n    print(sol.singleNumber(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,1,2,1,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1991.json",
    "problem_index_in_file": 0,
    "title": "Find the Middle Index in Array",
    "description_snippet": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line with explanations. Provide algorithm: compute total sum, iterate i, track left sum, compare left sum with total-left-sum-left? Actually right sum = total - leftSum - nums[i]. So check if leftSum == rightSum. Return i when found. If none, return -1. Provide virtual steps: Start, compute total, set leftSum=0, iterate i from 0 to n-1, check condition, update leftSum, else continue. End. Use Decision steps. Provide explanation after each line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 nums 的總和 total = sum(nums) // 先求出整個陣列的和  \n→ Step 2: 初始化 leftSum = 0 // 左側累加值，起始為 0  \n→ Step 3: 初始化 index = -1 // 預設沒有符合條件的索引，若找到則更新  \n→ Decision: 迴圈 i 從 0 到 nums.length - 1? // 開始遍歷每個索引  \n  Yes → Step 4: 計算 rightSum = total - leftSum - nums[i] // 右側和排除當前元素  \n                       // 右側和 = 總和 - 左側和 - 當前值  \n  → Decision: leftSum == rightSum? // 檢查當前索引是否為中點  \n       Yes → Step 5: 設定 index = i // 找到左最小中點，記錄索引",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMiddleIndex(self, nums):\n        \"\"\"找出最左側的中點索引，若不存在則回傳 -1\"\"\"\n        total = sum(nums)          # 整個陣列的總和\n        left_sum = 0               # 左側已累加的和\n        for i, num in enumerate(nums):\n            # 右側和 = 總和 - 左側和 - 當前元素\n            if left_sum == total - left_sum - num:\n                return i            # 找到最左的中點\n            left_sum += num         # 更新左側和\n        return -1                   # 沒有符合條件的索引\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析格式為 \"nums = [ ... ]\"\n    try:\n        # 找到等號後的部分並解析成列表\n        nums_str = data.split('=', 1)[1].strip()\n        nums = ast.literal_eval(nums_str)\n        if not isinstance(nums, list):\n            raise ValueError\n    except Exception:\n        print(\"輸入格式錯誤\")\n        sys.exit(1)\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.findMiddleIndex(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-1,8,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,-1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,5]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode520.json",
    "problem_index_in_file": 0,
    "title": "Detect Capital",
    "description_snippet": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll le...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with arrows and decision nodes. The requirement: For a given string word, determine if capital usage is correct: either all letters capital, all letters not capital, or only first letter capital.\n\nWe need to produce pseudocode step by step with explanations. Each line with `虛擬碼步驟 // 解釋`. Should use Start, Decision:, → etc. Let's outline:\n\nStart\n→ Step 1: Initialize variables length = length of word; allUpper = true; allLower = true; firstUpper = false\n\n→ Decision: word empty? (maybe not needed, but can treat)\nYes → End with false maybe? But we can skip.\n\n→ Step 2: For each character c in word:\n   → Decision: c is uppercase? // check\n     Yes → if index==0 then firstUpper=true else allUpper=false\n     No  → if index==0 then firstUpper=false else allLower=false\n\n→ Step 3: After loop, decide: if (allUpper) or (allLower) or (firstUpper && allLowerForRest?) Actually we need to ensure first letter capital only. So we track firstUpper and rest all lower. We can use variable restLower = true if all rest lower.\n\nAlternatively simpler: Check conditions:\n- allUpper: check if word equals uppercase of itself\n- allLower: check if word equals lowercase of itself\n- firstUpper: check if first char is uppercase and rest are lowercase.\n\nSo virtual code can do these checks separately. We'll produce steps accordingly.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: Set len = length(word) // 取得字串長度\n→ Decision: len == 0? // 空字串處理\n    Yes → End // 返回 false (或根據需求)\n    No  → Continue\n→ Step 2: Initialize flagAllUpper = true // 代表目前所有字母均為大寫\n→ Step 3: Initialize flagAllLower = true // 代表目前所有字母均為小寫\n→ Step 4: Initialize flagFirstUpperOnly = true // 代表目前第一個字母大寫且其餘小寫\n→ Step 5: For i from 0 to len-1:\n   → Decision: char = word[i] // 取得第 i 個字元\n   → Decision: isUpper(char)?\n        Yes → if i > 0 then flagAllUpper = false; // 從第二個字元開始若大寫就不是全部大寫\n              else flagFirstUpperOnly = flagFirstUpperOnly // 第一個字母大寫保持\n        No  → if i == 0 then flagAllUpper = false; // 第一個字母不是大寫就不是全部大寫\n              else flagAllLower = false; // 之後小寫保持\n   → Decision: isLower(char)?\n        Yes → if i == 0 then flagFirstUpperOnly = false; // 第一個字母不是小寫就不是第一個大寫\n              else flagAllLower = flagAllLower // 之後小寫保持\n        No  → // 若不是小寫（已在上面處理），不改變\n   // Actually simpler: just use two flags\n→ Step 6: After loop, Decision: if flagAllUpper or flagAllLower or flagFirstUpperOnly? // 判斷三種合法情況\n    Yes → Step 7: Return true // 用法正確\n    No  → Step 8: Return false // 用法錯誤\nEnd\n\nBut we might produce more simplified pseudocode: Use string methods. But as per requirement, we can just step by step.\n\nLet's produce lines accordingly with arrows.\n\nWe need to include arrows `→`, `Yes →`, `No →`. Provide explanation after `//`.\n\nLet's produce the final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: len ← length(word) // 取得字串長度  \n→ Decision: len == 0? // 檢查字串是否為空  \n  Yes → End // 空字串視為不合法，直接結束  \n  No  → Continue  \n→ Step 2: flagAllUpper ← true // 初始假設所有字母均為大寫  \n→ Step 3: flagAllLower ← true // 初始假設所有字母均為小寫  \n→ Step 4: flagFirstUpperOnly ← true // 初始假設只有首字母大寫且其餘小寫  \n→ Step 5: For i ← 0 to len-1: // 逐字元檢查  \n   c ← word[i] // 取得第 i 個字元  \n   Decision: isUpper(c)? // 判斷是否為大寫字母  \n    Yes → If i > 0 then flagAllUpper ← false // 從第二個字母起若有大寫，則不是全大寫",
      "generated_code": "import sys\n\nclass Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        \"\"\"\n        檢查字串 word 的大小寫使用是否正確：\n        1. 全部大寫\n        2. 全部小寫\n        3. 只有第一個字母大寫，其餘小寫\n        \"\"\"\n        return word.isupper() or word.islower() or word.istitle()\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 去除前後空白及換行\n    raw_input = raw_input.strip()\n    # 若輸入被引號包住，去掉引號\n    if len(raw_input) >= 2 and ((raw_input[0] == '\"' and raw_input[-1] == '\"') or\n                                (raw_input[0] == \"'\" and raw_input[-1] == \"'\")):\n        word = raw_input[1:-1]\n    else:\n        word = raw_input\n\n    solution = Solution()\n    result = solution.detectCapitalUse(word)\n    # 將布林值轉為小寫字串輸出\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"USA\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"FlaG\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode171.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Number",
    "description_snippet": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode that converts Excel column title to number. We need step-by-step with arrow.\n\nLet's produce pseudocode:\n\nStart\n→ Step: Initialize result = 0 // accumulate number\n→ Step: For each character ch in columnTitle // iterate over letters\n→ Step: value = ch ASCII - 'A' + 1 // map A->1\n→ Step: result = result * 26 + value // shift left base 26\n→ End\n→ Step: Output result // final column number\n\nWe might also include input reading, but the description just wants logic.\n\nWe need to use virtual code with arrows, Decision maybe not needed.\n\nLet's format accordingly. Use Start, End.\n\nLet's produce:\n\nStart // 開始執行\n→ Step 1: 設定 result ← 0 // 初始化結果\n→ Step 2: 對 columnTitle 的每個字元 ch 執行 // 逐字處理\n→ Step 3: 計算 value ← (ASCII(ch) - ASCII('A')) + 1 // 取得字母對應數值\n→ Step 4: 更新 result ← result × 26 + value // 進位累加\n→ End // 完成\n→ Step 5: 回傳 result // 輸出最終欄號\n\nAdd explanations.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 result ← 0 // 初始化結果變數  \n→ Step 2: 對 columnTitle 的每個字元 ch 執行 // 逐字母處理  \n→ Step 3: 計算 value ← (ASCII(ch) - ASCII('A')) + 1 // 把字母映射成 1~26  \n→ Step 4: 更新 result ← result × 26 + value // 進位累加，得到當前列號  \n→ End // 完成所有字母處理  \n→ Step 5: 回傳 result // 將最終列號輸出給呼叫方",
      "generated_code": "import sys\n\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        \"\"\"把 Excel 欄位標題轉成對應的列號。\"\"\"\n        result = 0\n        for ch in columnTitle:\n            result = result * 26 + (ord(ch) - ord('A') + 1)\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 從輸入字串中抽取實際的標題\n    first_quote = data.find(\"'\")\n    last_quote = data.rfind(\"'\")\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        column_title = data[first_quote + 1:last_quote]\n    else:\n        # 直接去除前導文字與空格\n        column_title = data.replace(\"columnTitle =\", \"\").strip()\n\n    sol = Solution()\n    print(sol.titleToNumber(column_title))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnTitle = 'A'",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "columnTitle = 'AB'",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 2,
          "input": "columnTitle = 'ZY'",
          "expected_output": "701",
          "success": true,
          "output": "701"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode39.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum",
    "description_snippet": "Given an array of distinct integers candidates and a target integer target, return a list of all uni...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for combination sum problem. Use backtracking, with recursion and pruning. Output lines with arrow. Let's produce steps:\n\nStart\n→ Sort candidates // optional\n→ Step 1: Define function backtrack(startIndex, currentCombination, currentSum) // recursive\n→ Decision: If currentSum == target? // base case\n    Yes → Step 2: Add a copy of currentCombination to result // record combination\n    No → Decision: If currentSum > target? // pruning\n        Yes → Step 3: Return // sum exceeded\n        No  → Loop i from startIndex to length-1\n                → Step 4: Append candidates[i] to currentCombination // choose number\n                → Step 5: backtrack(i, currentCombination, currentSum + candidates[i]) // allow reuse\n                → Step 6: Remove last element from currentCombination // backtrack\nEnd\nFinally output result\n\nNeed line-by-line format.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort candidates // 對候選數字進行排序，方便後續剪枝  \n→ Step 2: 初始化結果 list res = [] // 用來存放所有符合條件的組合  \n\n→ Step 3: 定義遞迴函式 backtrack(startIndex, currentCombination, currentSum)  \n → Decision: 如果 currentSum == target? // 檢查是否已達到目標和  \n  Yes → Step 4: 把 currentCombination 的複本加入 res // 收集一組有效組合  \n  No → Decision: 如果 currentSum > target? // 超過目標和，剪枝  \n   Yes → Step 5: 返回 // 直接結束此分支  \n   No → Loop i 從 startIndex 到 candidates.length-1  \n    → Step 6: currentCombination.append(candidates[i]) // 選擇候選數字  \n    → Step 7: backtrack(i, currentCombination, currentSum + candidates[i]) // 允許重複使用同一數字  \n    → Step 8: currentCombination.pop() // 回溯，移除最後選擇的數字  \n\n→ Step 9: 呼叫 backtrack(0, [], 0) // 從索引 0 開始，空組合，和為 0  \n→ Step 10: 返回 res // 回傳所有獨特組合  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef combination_sum(candidates, target):\n    \"\"\"\n    找出所有候選數字組合，使其和等於 target。\n    允許同一個數字重複使用，並且輸出為列表列表。\n    \"\"\"\n    res = []\n\n    def backtrack(start, path, total):\n        # 若已達到目標和，將組合加入結果\n        if total == target:\n            res.append(list(path))\n            return\n        # 若總和已超過目標，直接回溯\n        if total > target:\n            return\n        # 從 current index 開始嘗試加入候選數字\n        for i in range(start, len(candidates)):\n            path.append(candidates[i])\n            backtrack(i, path, total + candidates[i])  # i 允許重複\n            path.pop()  # 回溯\n\n    backtrack(0, [], 0)\n    return res\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 解析 \"candidates = [..], target = ..\" 的格式\n    pattern = r\"candidates\\s*=\\s*(\\[.*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)\"\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        # 如果格式不符合，直接輸出空列表\n        print([])\n        sys.exit(0)\n\n    # 取得候選數列和目標值\n    candidates_str, target_str = match.group(1), match.group(2)\n    # 使用 eval 解析列表，因為列表中可能有負數或空格\n    candidates = eval(candidates_str)\n    target = int(target_str)\n\n    # 計算結果\n    result = combination_sum(candidates, target)\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "success": true,
          "output": "[[2, 2, 3], [7]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "success": true,
          "output": "[[2, 2, 2, 2], [2, 3, 3], [3, 5]]"
        },
        {
          "example_index": 2,
          "input": "candidates = [2], target = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode525.json",
    "problem_index_in_file": 0,
    "title": "Contiguous Array",
    "description_snippet": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode in requested format, no real code. The algorithm: we convert 0 to -1, then find longest subarray with sum 0. Use hash map of prefix sum to earliest index. We'll produce steps.\n\nWe'll output in Chinese. Each line: 虛擬碼步驟 [space] // 解釋. Use arrows. Include Start and End. Ensure each step.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個字典 map，鍵為前綴和，值為該和第一次出現的索引 // 用於記錄每個前綴和第一次出現的位置  \n→ Step 2: 將 map[0] 設為 -1 // 方便處理從起始索引開始的子陣列  \n→ Step 3: 設置變量 preSum = 0，maxLen = 0 // preSum 用於累積前綴和，maxLen 記錄最大子陣列長度  \n→ Step 4: 對於每個索引 i 從 0 到 nums.length - 1 執行  \n    → Decision: 如果 nums[i] 為 0? // 判斷當前元素是 0 需要轉為 -1  \n        Yes → Step 5: preSum = preSum - 1 // 0 轉為 -1，更新前綴和  \n        No  → Step 6: preSum = preSum + 1 // 1 轉為 +1，更新前綴和  \n    → Decision: preSum 是否已在 map 中? // 判斷這個前綴和是否曾出現過  \n        Yes → Step 7: 計算子陣列長度 len = i - map[preSum] // 兩個相同前綴和之間的子陣列總和為 0  \n            → Decision: len 大於 maxLen?  \n                Yes → Step 8: maxLen = len // 更新最大長度  \n                No  → Step 9: 何不需要更新  \n        No  → Step 10: map[preSum] = i // 第一次出現此前綴和，記錄索引  \n→ Step 11: 回傳 maxLen // 結束計算並輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxLength(self, nums):\n        # 使用字典記錄前綴和第一次出現的索引\n        count_map = {0: -1}\n        max_len = 0\n        count = 0\n        for i, num in enumerate(nums):\n            # 將 0 轉為 -1，1 轉為 +1\n            count += 1 if num == 1 else -1\n            if count in count_map:\n                # 兩個相同前綴和之間的子陣列總和為 0\n                max_len = max(max_len, i - count_map[count])\n            else:\n                # 第一次出現此前綴和\n                count_map[count] = i\n        return max_len\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit(0)\n    # 解析輸入字串為列表\n    nums = ast.literal_eval(data)\n    result = Solution().findMaxLength(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[0,1,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,1,1,1,1,1,0,0,0]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode207.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for checking if all courses can be finished given prerequisites, basically check for cycle in directed graph. Use DFS or Kahn's algorithm. Let's use DFS with recursion stack. Provide step-by-step virtual code. Use Start, Decision, etc.\n\nWe must output each line with virtual code step and comment.\n\nWe must not output actual code. Just virtual steps.\n\nLet's create steps:\n\nStart\n→ Input numCourses, prerequisites // read inputs\n→ Initialize adjacency list adjacency ← empty list of lists // adjacency lists for graph\n→ For each pair [a,b] in prerequisites: add b to adjacency of a? Actually need adjacency: edge b->a? Since need to take b before a. For DFS cycle detection, we can build graph from a to b? Usually we want edges from a to b meaning a depends on b. For cycle detection we need to traverse dependencies: if a depends on b, we need to traverse to b. So adjacency a -> b. Let's do that.\n→ Decision: If adjacency list empty? // if no prerequisites, return true\n→ Use arrays visited, recStack // to track visited and recursion stack\n→ For each course from 0 to numCourses-1: if not visited, DFS(course)\n→ DFS(course): set visited[course]=true, recStack[course]=true\n→ For each neighbor in adjacency[course]: // dependency\n    Decision: If not visited[neighbor]? // unvisited neighbor\n        Yes → DFS(neighbor)\n        No → Decision: If recStack[neighbor]? // back edge\n            Yes → Return cycleFound = true\n→ After exploring neighbors, set recStack[course]=false\n→ Return cycleFound flag\n→ Decision: If cycleFound? // if cycle detected\n    Yes → Output false\n    No → Output true\nEnd\n\nWe need to format as per specification: each line includes virtual code step then comment. Use arrow \"→\" for flow. Use Decision: etc.\n\nNeed to use \"Start\" and \"End\".\n\nAlso include comments after //.\n\nEnsure each line exactly one step.\n\nWe should include the logic for returning false/true.\n\nLet's write out step lines.\n\nBe mindful to include \"Yes →\" and \"No →\" under decisions.\n\nLet's start.\n\nLine 1: Start // 程式開始執行\nLine 2: → Input numCourses, prerequisites // 讀取課程數量與前置關係\n\nLine 3: → Initialize adjacency ← empty list of lists of size numCourses // 建立鄰接表\n\nLine 4: → For each pair [a,b] in prerequisites: add b to adjacency[a] // 建立從課程到其前置課程的邊\n\nLine 5: → Decision: 如果 prerequisites 為空? // 無前置關係可直接完成\n\nLine 6:     Yes → Output true // 沒有依賴，課程可全部完成\n\nLine 7:     No  → Continue // 有前置關係，進行循環檢測\n\nLine 8: → Initialize visited ← array[0..numCourses-1] of false // 記錄節點是否已被訪問\n\nLine 9: → Initialize recStack ← array[0..numCourses-1] of false // 記錄當前 DFS 路徑上的節點\n\nLine 10: → Initialize cycleFound ← false // 旗標，是否發現循環\n\nLine 11: → For course from 0 to numCourses-1: // 遍歷所有課程\n\nLine 12:     Decision: 如果 visited[course] 為 false? // 尚未探索的節點\n\nLine 13:         Yes → DFS(course) // 執行深度優先搜尋\n\nLine 14: → Decision: 如果 cycleFound 為 true? // 是否已發現循環\n\nLine 15:     Yes → Output false // 無法完成所有課程\n\nLine 16:     No  → Output true // 能完成所有課程\n\nLine 17: End // 程式結束\n\nNow we need to detail DFS. The DFS can be a subroutine. We need to produce lines for DFS. Use virtual subroutine.\n\nLet's include subroutine definition:\n\nLine 18: → Subroutine DFS(course): // 定義 DFS 檢測循環\n\nLine 19:     → visited[course] ← true // 標記節點已訪問\n\nLine 20:     → recStack[course] ← true // 加入當前路徑\n\nLine 21:     → For each neighbor in adjacency[course]: // 依賴課程\n\nLine 22:         Decision: 如果 visited[neighbor] 為 false? // 未訪問的前置課程\n\nLine 23:             Yes → DFS(neighbor) // 深度優先遞迴\n\nLine 24:             No  → Decision: 如果 recStack[neighbor] 為 true? // 從前置課程返回的路徑上已有節點\n\nLine 25:                 Yes → cycleFound ← true // 發現循環\n\nLine 26:     → recStack[course] ← false // 從路徑移除，完成節點探索\n\nLine 27: End Subroutine // 子程序結束\n\nNeed to adjust indentation? The format doesn't require actual indentation; but to show hierarchy we may show lines after decision with indentation. Use space for indent.\n\nLet's ensure each line ends with // explanation.\n\nAlso ensure we don't repeat output false/true too many times.\n\nLet's assemble final output.\n\nMake sure each line separate. Use no extra punctuation except what needed.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input numCourses, prerequisites // 讀取課程數量與前置關係  \n\n→ Initialize adjacency ← empty list of lists of size numCourses // 建立鄰接表  \n\n→ For each pair [a,b] in prerequisites: add b to adjacency[a] // 建立從課程到其前置課程的邊  \n\n→ Decision: 如果 prerequisites 為空? // 無前置關係可直接完成  \n  Yes → Output true // 沒有依賴，課程可全部完成  \n  No  → Continue // 有前置關係，進行循環檢測  \n\n→ Initialize visited ← array[0..numCourses-1] of false // 記錄節點是否已被訪問  \n\n→ Initialize recStack ← array[0..numCourses-1] of false // 記錄當前 DFS 路徑上的節點  \n\n→ Initialize cycleFound ← false // 旗標，是否發現循環  \n\n→ For course from 0 to numCourses-1: // 遍歷所有課程  \n  Decision: 如果 visited[course] 為 false? // 尚未探索的節點  \n    Yes → DFS(course) // 執行深度優先搜尋  \n\n→ Decision: 如果 cycleFound 為 true? // 是否已發現循環  \n  Yes → Output false // 無法完成所有課程  \n  No  → Output true // 能完成所有課程  \n\nEnd // 程式結束  \n\n→ Subroutine DFS(course): // 定義 DFS 檢測循環  \n  → visited[course] ← true // 標記節點已訪問  \n  → recStack[course] ← true // 加入當前路徑  \n  → For each neighbor in adjacency[course]: // 依賴課程  \n    Decision: 如果 visited[neighbor] 為 false? // 未訪問的前置課程  \n      Yes → DFS(neighbor) // 深度優先遞迴  \n      No  → Decision: 如果 recStack[neighbor] 為 true? // 從前置課程返回的路徑上已有節點  \n          Yes → cycleFound ← true // 發現循環  \n  → recStack[course] ← false // 從路徑移除，完成節點探索  \nEnd Subroutine // 子程序結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        # Build graph and indegree list\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # Queue all courses with no prerequisites\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return visited == numCourses\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract all integers from the input\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if not numbers:\n        print(\"false\")\n        return\n\n    numCourses = numbers[0]\n    rest = numbers[1:]\n\n    prerequisites = []\n    for i in range(0, len(rest), 2):\n        if i + 1 < len(rest):\n            prerequisites.append([rest[i], rest[i + 1]])\n\n    solution = Solution()\n    result = solution.canFinish(numCourses, prerequisites)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode459.json",
    "problem_index_in_file": 0,
    "title": "Repeated Substring Pattern",
    "description_snippet": "Given a string s, check if it can be constructed by taking a substring of it and appending multiple ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, not actual code. For the problem: given string s, check if can be constructed by taking a substring of it and appending multiple copies. Equivalent to check if s is a repeated substring pattern. Approach: check length n, iterate i from 1 to n/2, if n % i == 0 and substring 0..i repeated n/i times equals s. Or using KMP failure function: s + s find first occurrence of s in (s + s)[1:-1] etc.\n\nWe must output step-by-step pseudocode with arrows and comments. Each line: \"虛擬碼步驟\" then comment. Use Start, End, Decision. Provide \"→\" arrow.\n\nWe need to include steps: start, input s, compute length, iterate over possible substring lengths, check divisibility, build repeated string or compare slices, if match return true, else after loop return false.\n\nLet's create. Ensure each line includes // explanation.\n\nLet's produce.\n\nAlso we can use decision for each iteration. Provide indentation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 從使用者或測試資料取得字串  \n→ Step 2: 計算 s 的長度 n // n = s.length()  \n→ Decision: n 是否為 1? // 單字元無法重複成子字串  \n  Yes → Step 3: 回傳 False // 直接結束  \n  No → Step 4: 設定 flag 為 False // 預設未找到重複子字串  \n→ Step 5: 從 i = 1 到 n/2 迭代 // i 為潛在子字串長度  \n  → Decision: n mod i 是否為 0? // n 必須能被子字串長度整除  \n    Yes → Step 6: 取子字串 sub = s[0:i] // 取得前 i 個字元作為候選子字串  \n     → Step 7: 建立重複字串 repeat = sub.repeat(n/i) // 重複子字串直到長度 n  \n     → Decision: repeat 是否等於 s? // 檢查重複後是否與原字串相同  \n       Yes → Step 8: 設定 flag 為 True 並跳出迴圈 // 找到合法子字串，結束迴圈  \n       No → Step 9: 繼續下一個 i // 不符合，嘗試下一個子字串長度  \n    No → Step 10: 繼續下一個 i // n 不能被 i 整除，跳過  \n→ Step 11: 回傳 flag // 若 flag 為 True 則可構造，否則不可構造  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef repeated_substring_pattern(s: str) -> bool:\n    \"\"\"判斷字串 s 是否能由某個子字串重複多次構成。\"\"\"\n    n = len(s)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:                     # 子字串長度必須能整除總長度\n            if s[:i] * (n // i) == s:     # 重複子字串後與原字串相同\n                return True\n    return False\n\ndef solve() -> None:\n    \"\"\"從標準輸入讀取字串，輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出字串中的內容（支援 \"s = \\\"abc\\\"\" 或直接輸入 abc）\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有雙引號，直接去除等號與空白\n        if '=' in data:\n            s = data.split('=', 1)[1].strip()\n        else:\n            s = data\n\n    result = repeated_substring_pattern(s)\n    # 輸出為小寫字串 'true' 或 'false'\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"abcabcabcabc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode528.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Weight",
    "description_snippet": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith in...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: implement class with constructor storing cumulative sums and pickIndex using random number and binary search. Provide step by step.\n\nNo actual code, just steps with arrow and comments.\n\nWe'll structure:\n\nStart\n→ Step: Calculate cumulative weight array cum where cum[i] = sum_{0..i} w[i]\n→ Step: Store total weight total = cum[last]\n→ End constructor\n\nMethod pickIndex:\n→ Step: Generate random number r between 0 (inclusive) and total (exclusive)\n→ Step: Binary search cum to find smallest index with cum[idx] > r\n→ Step: Return idx\nEnd\n\nWe need to include decision arrows maybe.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 建立累積權重陣列 cum，cum[i] = w[0] + w[1] + … + w[i] // 計算每個索引的累積總重量  \n→ Step: 記錄總重量 total = cum[w.length - 1] // 方便後續隨機數的範圍設定  \nEnd // 建構子完成  \n\n// pickIndex() 方法  \nStart // pickIndex() 呼叫時開始  \n→ Step: 產生隨機數 r，範圍 0 ≤ r < total // 以總重量為上界生成隨機數  \n→ Decision: r 是否小於 cum[0] ? // 判斷是否落在第一個區間  \n    Yes → Step: 回傳 0 // 若 r 低於第一個累積值，直接回傳索引 0  \n    No  → Step: BinarySearch(cum, r) // 否則進行二分搜尋以定位正確區間  \n→ Step: 在 BinarySearch 中，找到最小 idx 使得 cum[idx] > r // 搜尋條件  \n→ Step: 回傳 idx // 找到符合條件的索引  \nEnd // pickIndex() 執行結束  \n\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立累積和 prefix_sum\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 產生 1~total 的隨機整數\n        target = random.randint(1, self.total)\n        # 二分搜尋找最小索引，使 prefix_sum[idx] >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，移除前後空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 將輸入包裝成一個有效的 JSON\n    data = json.loads('[' + raw_input + ']')\n    commands, args = data[0], data[1]\n\n    res = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            # 建構子，arg 為列表，取第一個元素作為 w\n            obj = Solution(arg[0])\n            res.append(None)  # 建構子回傳 null\n        else:\n            # 呼叫對應方法\n            method = getattr(obj, cmd)\n            result = method()\n            res.append(result)\n\n    # 將結果輸出為 JSON 字串\n    print(json.dumps(res))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "success": true,
          "output": "[null, 0]"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "success": true,
          "output": "[null, 1, 1, 1, 1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode394.json",
    "problem_index_in_file": 0,
    "title": "Decode String",
    "description_snippet": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line by line. The algorithm: use stack to decode. Steps: iterate characters, if digit accumulate number, if '[' push current result and count onto stack, reset current string. If letter append to current string. If ']' pop count and previous string, repeat current string count times, append to previous string, set as current. Finally output current string.\n\nWe need to use arrow syntax. Each line with comment. Use Start, End, Decision. Provide step lines. Let's produce a reasonable set. Use indentation maybe with indentation spaces? The example shows spaces but not indentation. We can just indent by spaces.\n\nWe should produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化空棧和空字串 // 建立資料結構\n\nBut the pseudo-code may need to show loops. Use Decision: if char is digit? etc.\n\nWe need to include arrows: \"→\". Use \"Decision:\" lines for if. Use \"Yes →\" and \"No →\" under decision.\n\nOk produce. Use variable names: stack, result, num, temp. Use char loop. Use pseudo-code.\n\nLet's produce step by step.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空棧 stack 和空字串 current // 用來儲存已解碼的字串\n→ Step 2: 初始化變數 num = 0 // 用來累積遇到的數字\n→ Step 3: 逐字元遍歷輸入字串 s\n    → Decision: 字元是數字? // 判斷是否為重複次數的數字\n        Yes → Step 4: num = num * 10 + int(字元) // 累積完整的 k 值\n        No  → Decision: 字元是 '['? // 開始一個新的編碼區塊\n            Yes → Step 5: 把 (current, num) 推入 stack // 儲存前一層結果與重複次數\n                → Step 6: current = \"\" // 重置為新區塊的字串\n                → Step 7: num = 0 // 重置數字累積\n            No  → Decision: 字元是 ']'? // 結束當前編碼區塊\n                Yes → Step 8: (prev, repeat) = stack.pop() // 取出前一層資訊\n                    → Step 9: current = prev + current * repeat // 重複並拼接回前一層\n                No  → Step 10: current = current + 字元 // 普通字元直接加入 current\n→ End // 程式執行結束，current 為完整解碼結果\n\n--- 逐行解釋完畢 ---",
      "generated_code": "import sys\nimport re\n\ndef decode_string(s: str) -> str:\n    \"\"\"Decode an encoded string using a stack-based approach.\"\"\"\n    stack = []          # stack stores tuples (previous_string, repeat_count)\n    num = 0             # current number being parsed\n    cur = \"\"            # current decoded string segment\n\n    for ch in s:\n        if ch.isdigit():\n            # Build the full number (handles multi-digit repeat counts)\n            num = num * 10 + int(ch)\n        elif ch == '[':\n            # Start a new segment: push current context onto the stack\n            stack.append((cur, num))\n            cur = \"\"\n            num = 0\n        elif ch == ']':\n            # End of current segment: pop and combine\n            prev, repeat = stack.pop()\n            cur = prev + cur * repeat\n        else:\n            # Regular character, append to current segment\n            cur += ch\n\n    return cur\n\ndef main() -> None:\n    # Read the entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the encoded string from the input.\n    # Handles cases like: s = \"3[a]2[bc]\" or just 3[a]2[bc]\n    m = re.search(r'\"(.*?)\"', data)\n    if m:\n        encoded = m.group(1)\n    else:\n        encoded = data\n        encoded = encoded.replace(\"s =\", \"\").replace(\"s=\", \"\").strip()\n\n    result = decode_string(encoded)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3[a]2[bc]\"",
          "expected_output": "\"aaabcbc\"",
          "success": true,
          "output": "aaabcbc"
        },
        {
          "example_index": 1,
          "input": "s = \"3[a2[c]]\"",
          "expected_output": "\"accaccacc\"",
          "success": true,
          "output": "accaccacc"
        },
        {
          "example_index": 2,
          "input": "s = \"2[abc]3[cd]ef\"",
          "expected_output": "\"abcabccdcdcdef\"",
          "success": true,
          "output": "abcabccdcdcdef"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode191.json",
    "problem_index_in_file": 0,
    "title": "Number of 1 Bits",
    "description_snippet": "Given a positive integer n, write a function that returns the number of set bits in its binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. Steps: Start, Step 1: input n, Step 2: initialize count=0, Step 3: while n > 0: if n & 1 == 1: count++ ; n = n >> 1 ; Decision inside while: maybe using Decision: If n == 0? or just while loop. We need to use Decision structure as per format. Provide arrow.\n\nLet's design:\n\nStart\n→ Step 1: 輸入正整數 n // 取得輸入\n→ Step 2: 設定 count = 0 // 初始化計數\n→ Decision: 是否 n == 0? // 判斷是否已經完成\n    Yes → Step 3: 回傳 count // 回傳結果\n    No  → Step 4: 判斷最低位是否為 1 // 檢查\n        Yes → Step 5: count = count + 1 // 計數\n        No  → Step 6: count = count // 不變 (可省略)\n    → Step 7: n = n >> 1 // 右移\n    → Go back to Decision: 是否 n == 0? // 重複\n\nBut need to maintain arrow and Decision. Use while loop represented as Decision that loops back. We can use End at final.\n\nBetter:\n\nStart\n→ Step 1: 輸入正整數 n // 取得輸入\n→ Step 2: 設定 count = 0 // 初始化計數\n→ Decision: n 是否為 0? // 判斷是否結束\n    Yes → Step 3: 回傳 count // 完成\n    No  → Decision: n 的最低位為 1? // 檢查最低位\n        Yes → Step 4: count = count + 1 // 加一\n        No  → Step 5: count = count // 無需變更 (可選)\n    → Step 6: n = n >> 1 // 右移\n    → Go back to Decision: n 是否為 0? // 迴圈\n\nBut need \"→\" lines for each step, including Decision: \"Decision:\" lines.\n\nWe can incorporate loop by referencing decision at the end with arrow pointing back.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入正整數 n // 取得輸入值\n→ Step 2: 設定 count = 0 // 初始化計數\n→ Decision: n 是否為 0? // 檢查是否已處理完所有位元\n    Yes → Step 3: 回傳 count // 結束並輸出計數\n    No  → Decision: n 的最低位為 1? // 判斷目前位元\n        Yes → Step 4: count = count + 1 // 計數加一\n        No  → Step 5: count = count // 不變 (保持不動)\n    → Step 6: n = n >> 1 // 右移至下一位元\n    → 回到上一 Decision: n 是否為 0? // 迴圈至決策\n\nBut need \"→\" arrow preceding each line after Step 6.\n\nWe need to indicate \"→ 回到上一 Decision: n 是否為 0?\" maybe using \"→ Decision: n 是否為 0?\" again.\n\nWe can embed inside the Decision block: after Step 6, arrow to Decision again.\n\nMaybe structure:\n\nStart\n→ Step 1\n→ Step 2\n→ Decision: n == 0?\n    Yes → Step 3\n    No  → Decision: n & 1 == 1?\n        Yes → Step 4\n        No  → Step 5\n    → Step 6\n    → Go back to Decision: n == 0? // but we can just put arrow to Decision again.\n\nBut in format, we can't have \"Go back\" line. We need arrow line that refers to the earlier Decision. We can write \"→ Decision: n 是否為 0?\" again. That will create a loop. That is fine.\n\nSo after Step 6, we put \"→ Decision: n 是否為 0?\" to repeat.\n\nAfter Step 3 we end? we can use End line.\n\nAfter Step 6 loop we eventually reach Decision Yes branch and step 3 then End.\n\nSo we add End after Step 3.\n\nLet's write final code accordingly.\n\nAlso we can simplify: skip Step 5 because count remains same. But for clarity we can include Step 5.\n\nWe need to ensure each line ends with comment.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 n // 取得輸入值  \n→ Step 2: 設定 count = 0 // 初始化計數  \n→ Decision: n 是否為 0? // 檢查是否已處理完所有位元  \n Yes → Step 3: 回傳 count // 結束並輸出計數  \n No  → Decision: n 的最低位為 1? // 判斷目前位元  \n  Yes → Step 4: count = count + 1 // 計數加一  \n  No  → Step 5: count = count // 不變 (保持不動)  \n → Step 6: n = n >> 1 // 右移至下一位元  \n → Decision: n 是否為 0? // 重新檢查，形成迴圈  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef hamming_weight(n: int) -> int:\n    \"\"\"Return the number of set bits (Hamming weight) of n.\"\"\"\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef main() -> None:\n    # 讀取整個輸入，可能包含字串 \"n = 11\" 等形式\n    data = sys.stdin.read()\n    # 從文字中抓取第一個整數（允許負號，雖然題目只給正整數）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = hamming_weight(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 128",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2147483645",
          "expected_output": "30",
          "success": true,
          "output": "30"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1337.json",
    "problem_index_in_file": 0,
    "title": "The K Weakest Rows in a Matrix",
    "description_snippet": "You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civili...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, with explanation. Should not output actual code. Use Start, End, Decision. Should cover algorithm: For each row, count soldiers (binary sorted row). Use binary search or iterate. Then create list of pairs (count, index). Sort by count ascending, index ascending. Then take first k indices. Output indices.\n\nWe produce each line: \"Start // 程式開始執行\" etc.\n\nUse arrows. Each line includes code step description, then // explanation.\n\nOk. Provide step by step. Ensure each line uses arrow symbol. Use \"→\" to indicate steps. For decisions, use \"Decision:\".\n\nWe'll produce maybe about 15-20 lines. Let's do.\n\nLet's begin.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空列表 rowsInfo // 用來儲存每行的士兵數與索引  \n→ Decision: 是否已處理完所有行? // 判斷是否完成迴圈  \n    Yes → Step 2: 對 rowsInfo 進行排序，鍵值為 (士兵數, 行索引) // 先依士兵數升序，再依索引升序  \n        → Step 3: 取前 k 個元素的行索引，存入 result // 得到最弱的 k 行索引  \n        → Step 4: 輸出 result // 回傳答案  \n    No  → Step 5: 讀取下一行的數組 row // 取得第 i 行的數據  \n        → Step 6: 使用二分搜尋計算 row 中 1 的個數 soldierCount // 由於 1 只在左側，二分搜尋效率高  \n            → Step 7: 將 (soldierCount, 行索引) 添加到 rowsInfo // 以便後續排序  \n            → Step 8: 迴圈回到 Decision 以檢查是否還有行未處理  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # 計算每行中的 1 的個數，使用二分搜尋，因為 1 只會在左側\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        # 建立 (士兵數, 行索引) 的列表\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        # 先按士兵數升序，再按行索引升序\n        soldiers.sort()\n        # 取前 k 個行索引\n        return [idx for _, idx in soldiers[:k]]\n\ndef main():\n    # 從 stdin 讀取整段文字\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 轉換輸入為可以直接 eval 的格式\n    # 原始輸入可能是 \"mat = [[...]], k = 3\"\n    data = data.replace('mat = ', '').replace(' k = ', ',')\n    # 使用 literal_eval 以避免 eval 的安全風險\n    mat, k = ast.literal_eval(data)\n\n    sol = Solution()\n    result = sol.kWeakestRows(mat, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmphzkkhgl7.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmphzkkhgl7.py\", line 34, in main\n    mat, k = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]],,3\n                                                                  ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpxqejfiky.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmpxqejfiky.py\", line 34, in main\n    mat, k = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]],,2\n                                              ^\nSyntaxError: invalid syntax"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode753.json",
    "problem_index_in_file": 0,
    "title": "Cracking the Safe",
    "description_snippet": "There is a safe protected by a password. The password is a sequence of n digits where each digit can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating minimal length string that ensures password appears as substring of length n over alphabet [0,k-1]. That's classic De Bruijn sequence of order n over k symbols. Minimal length is k^n + n -1? Actually De Bruijn cycle length k^n, and if we output cycle plus n-1 initial characters to linearize to contain all substrings. So output sequence length k^n + n -1 minimal. The algorithm: construct de Bruijn sequence via recursive algorithm: de Bruijn(k,n). Implementation using DFS (preferential sequence). Steps: initialize array a[0..k*n] maybe. Use recursive function db(t,p). Then after building sequence, output string plus first n-1 characters. Provide steps. Should produce virtual code with decisions etc. We need to produce virtual code step by step with explanation per line. Not actual code. Use arrow etc.\n\nWe will produce:\n\nStart // start\n→ Step 1: Set up parameters k, n // input\n→ Step 2: Initialize array a[0..k*n] to 0 // storage\n→ Step 3: Initialize empty sequence seq // output\n→ Step 4: Define recursive function db(t,p)\n    → Decision: If t > n? // base case\n        Yes → Append first p elements of a to seq // record\n        No → For j from 0 to k-1\n                Set a[t] = j\n                If j < a[t-p] then\n                    db(t+1, p)\n                Else\n                    db(t+1, t)\n→ Step 5: Call db(1,1) // start recursion\n→ Step 6: Convert seq to string // digits\n→ Step 7: Append first n-1 digits of seq to end // linearize\n→ Step 8: Return result // final string\nEnd // done\n\nBut need to use format: \"虛擬碼步驟 // 解釋\" lines. Use arrows etc. Let's produce accordingly. Provide each line. Use spaces between arrow and code. For decisions indent with Yes/No lines. We need to produce step by step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入參數 k 與 n // 指定字母表大小與密碼長度  \n→ Step 2: 建立長度為 k·n 的整數陣列 a 並全部設為 0 // 用於遞迴中的輔助儲存  \n→ Step 3: 初始化空序列 seq 用於收集 De Bruijn 序列  \n→ Step 4: 定義遞迴函式 db(t, p)  \n  → Decision: t > n? // t 超過 n 時完成一次子序列  \n   Yes → Append a[1…p] 到 seq // 將前 p 個數字加入結果序列  \n   No → For j 在 0 到 k−1 之間  \n     Set a[t] = j // 先設定第 t 位為 j  \n     Decision: j < a[t−p]? // 判斷是否要維持 p 的長度  \n      Yes → db(t+1, p) // 繼續使用相同 p  \n      No  → db(t+1, t) // 重新設定 p 為 t  \n→ Step 5: 呼叫 db(1, 1) // 開始遞迴建構 De Bruijn 序列  \n→ Step 6: 將 seq 轉換為字元串 res // 形成長度為 k^n 的循環序列  \n→ Step 7: 取 res 的前 n−1 個字元並附加至 res 的尾端 // 形成線性化序列  \n→ Step 8: 回傳 res // 最終得到最短能解鎖的輸入字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef crack_safe(n: int, k: int) -> str:\n    seen = set()\n    res = []\n\n    def dfs(node: str):\n        for x in map(str, range(k)):\n            nei = node + x\n            if nei not in seen:\n                seen.add(nei)\n                dfs(nei[1:])          # move window\n                res.append(x)\n\n    start = \"0\" * (n - 1)\n    dfs(start)\n    return \"\".join(res) + start\n\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = crack_safe(n, k)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 2, k = 2",
          "expected_output": "\"01100\"",
          "success": true,
          "output": "01100"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode172.json",
    "problem_index_in_file": 0,
    "title": "Factorial Trailing Zeroes",
    "description_snippet": "Given an integer n, return the number of trailing zeroes in n!. \n\nNote that n! = n * (n - 1) * (n - ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: count factors of 5 in factorial: sum floor(n/5)+floor(n/25)+... until zero. Steps: Start, input n, initialize count=0, temp=n, loop while temp>0: temp = temp // 5, count += temp, loop. Output count, End. Provide each line with explanation.\n\nWe need to use structure: Start, → Step, Decision, Yes → etc.\n\nWe can produce:\n\nStart\n→ Step 1: 輸入整數 n // 取得使用者輸入的整數\n→ Step 2: 初始化變數 count = 0 // 用於累計尾零數量\n→ Step 3: 初始化 temp = n // 用於計算 5 的倍數\n→ Decision: temp > 0? // 判斷是否還有可除的 5\n    Yes → Step 4: temp = temp // 5 // 取得下一層 5 的整數商\n    Yes → Step 5: count = count + temp // 將該層 5 的倍數加入總數\n    Yes → Decision: temp > 0? // 重複迴圈\n    No  → Step 6: 輸出 count // 輸出尾零總數\nEnd\n\nBut we need arrow formatting with Yes →, No →. We need proper indentation. Also need to include the decision branch with Yes and No. We can use a loop by repeating Decision: temp > 0? Yes -> loop back to Step 4; No -> output.\n\nLet's structure:\n\nStart\n→ Step 1: 輸入整數 n\n→ Step 2: 初始化 count = 0\n→ Step 3: 初始化 temp = n\n→ Decision: temp > 0? // 檢查是否還有 5 的倍數\n    Yes → Step 4: temp = temp // 5\n    Yes → Step 5: count = count + temp\n    Yes → Decision: temp > 0? // 迴圈回到條件判斷\n    No  → Step 6: 輸出 count\nEnd\n\nBut the Decision: temp > 0? branch uses Yes to loop back. We need a way to indicate looping. In pseudo we can use `→ Step 4` as part of loop. The arrow could be like:\n\nYes → Step 4: temp = temp // 5\n    → Step 5: count = count + temp\n    → Decision: temp > 0? // repeat\n\nBut it's better to express as while loop:\n\nDecision: temp > 0?\n    Yes → Step 4: temp = temp // 5\n          → Step 5: count = count + temp\n          → Decision: temp > 0? // loop\n    No → Step 6: 輸出 count\n\nBut indentation may cause confusion. According to format, each line after Decision should be indented? The example shows indentation: 4 spaces. Use same.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得使用者輸入的整數\n→ Step 2: 初始化變數 count = 0 // 用於累計尾零數量\n→ Step 3: 初始化變數 temp = n // 用於計算 5 的倍數\n→ Decision: temp > 0? // 檢查是否還有可除的 5\n    Yes → Step 4: temp = temp // 5 // 取得下一層 5 的整數商\n        Yes → Step 5: count = count + temp // 將該層 5 的倍數加入總數\n            Yes → Decision: temp > 0? // 迴圈回到條件判斷\n    No  → Step 6: 輸出 count // 輸出尾零總數\nEnd // 程式執行結束\n\nBut the indentation of the \"Yes\" lines: We could nest: After Yes, we list next steps, each further nested. The example uses indentation to represent nested flows. We need to maintain clarity.\n\nAlternatively we can use a while loop representation:\n\nStart\n→ Step 1: 輸入整數 n\n→ Step 2: 初始化 count = 0\n→ Step 3: 初始化 temp = n\n→ Decision: temp > 0?\n    Yes → Step 4: temp = temp // 5\n        → Step 5: count = count + temp\n            → Decision: temp > 0? // loop\n    No  → Step 6: 輸出 count\nEnd\n\nBetter: after Step 5, we go back to Decision. Use \"→ Decision\" as part of loop. But we need to indicate that it loops.\n\nWe could also use a loop pseudo:\n\nStart\n→ Step 1: 輸入整數 n\n→ Step 2: 初始化 count = 0\n→ Step 3: 初始化 temp = n\n→ While temp > 0:\n    → Step 4: temp = temp // 5\n    → Step 5: count = count + temp\n→ Step 6: 輸出 count\nEnd\n\nBut format requires Decision and Yes/No. Use Decision: temp > 0? then Yes -> loop; No -> output. So need to represent loop by returning to Decision.\n\nWe can add a line: → Decision: temp > 0? // 檢查是否還有 5 的倍數 (loop start)\n    Yes → Step 4...\n    ... after Step 5, we need to go back to Decision. We can just indicate that after Step 5 we return to Decision by \"→ Decision: temp > 0?\" with same indentation? In the example, inside the Decision block, we have nested Decision. That should suffice.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得使用者輸入的整數\n→ Step 2: 初始化 count = 0 // 用於累計尾零數量\n→ Step 3: 初始化 temp = n // 用於計算 5 的倍數\n→ Decision: temp > 0? // 檢查是否還有可除的 5\n    Yes → Step 4: temp = temp // 5 // 取得下一層 5 的整數商\n        → Step 5: count = count + temp // 將該層 5 的倍數加入總數\n            → Decision: temp > 0? // 迴圈回到條件判斷\n    No  → Step 6: 輸出 count // 輸出尾零總數\nEnd // 程式執行結束\n\nThis seems fine.\n\nCheck formatting: each line must contain \"虛擬碼步驟\" then space then comment.\n\nAlso need to start with \"Start\". Use \"Start\" alone? Example uses \"Start\". So we use \"Start\" alone? They had \"Start // 程式開始執行\". So we will use same.\n\nAlso \"End // 程式執行結束\".\n\nOk. Provide output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得使用者輸入的整數  \n→ Step 2: 初始化 count = 0 // 用於累計尾零數量  \n→ Step 3: 初始化 temp = n // 用於計算 5 的倍數  \n→ Decision: temp > 0? // 檢查是否還有可除的 5  \n  Yes → Step 4: temp = temp // 5 // 取得下一層 5 的整數商  \n    → Step 5: count = count + temp // 將該層 5 的倍數加入總數  \n     → Decision: temp > 0? // 迴圈回到條件判斷  \n  No  → Step 6: 輸出 count // 輸出尾零總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        \"\"\"Return the number of trailing zeros in n!.\"\"\"\n        count = 0\n        while n > 0:\n            n //= 5\n            count += n\n        return count\n\ndef main() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中擷取第一個整數\n    match = re.search(r'-?\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    result = sol.trailingZeroes(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode720.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary",
    "description_snippet": "Given an array of strings words representing an English Dictionary, return the longest word in words...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for that problem. Steps: read array, sort lexicographically then by length? Actually we want longest word that can be built by adding characters one by one where each prefix is also in list. Approach: sort words by length ascending and lexicographically. Use set to store built words. Iterate sorted words: if word length 1 or all prefixes exist. Then add to set. Keep track of best answer: longest length then lexicographically smallest. At end return best. Need virtual code. We'll use steps like Start, sort, initialize set, for each word, check prefix, etc.\n\nLet's produce line by line.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by length ascending, then lexicographical order // 先根據長度升序，長度相同則按字典序排序，方便逐步構建  \n→ Step 2: Initialize an empty Set builtWords // 用於儲存已成功構建的單詞  \n→ Step 3: Initialize bestWord = \"\" // 儲存目前符合條件且最長的單詞  \n→ Step 4: For each word in sorted words: // 逐個檢查每個單詞  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 如果 word.length == 1? // 單字符單詞自動可構建  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Add word to builtWords // 加入已構建集合  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 如果 builtWords contains all prefixes of word? // 檢查所有前綴是否已存在  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Add word to builtWords // 成功構建，加入集合  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Continue // 失敗，跳過此單詞  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 如果 word can be added to builtWords? // 只有已構建的單詞才進一步比較答案  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: 如果 word.length > bestWord.length? // 先比長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Set bestWord = word // 更長則更新  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 如果 word.length == bestWord.length AND word < bestWord? // 同長度且字典序更小  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Set bestWord = word // 更新為更小字典序  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Continue // 保持現有答案  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Continue // 該單詞無法構建，忽略  \n→ Step 5: Return bestWord // 輸出符合條件的最長、字典序最小的單詞  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def longestWord(self, words):\n        \"\"\"\n        Find the longest word that can be built one character at a time\n        by other words in the list. If multiple answers exist,\n        return the lexicographically smallest one.\n        \"\"\"\n        word_set = set(words)\n        longest = \"\"\n\n        for word in words:\n            # Check if all prefixes of this word are present\n            valid = True\n            for k in range(1, len(word)):\n                if word[:k] not in word_set:\n                    valid = False\n                    break\n            if not valid:\n                continue\n\n            # Update answer based on length and lexicographical order\n            if len(word) > len(longest) or (len(word) == len(longest) and word < longest):\n                longest = word\n\n        return longest\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Extract the list part from the input (e.g., words = [\"a\",\"b\",\"c\"])\n    match = re.search(r'\\[.*\\]', raw_input, re.DOTALL)\n    if not match:\n        print(\"\")\n        sys.exit()\n\n    list_str = match.group(0)\n    try:\n        words = ast.literal_eval(list_str)\n    except Exception:\n        print(\"\")\n        sys.exit()\n\n    # Ensure the data is a list of strings\n    if not isinstance(words, list) or not all(isinstance(w, str) for w in words):\n        print(\"\")\n        sys.exit()\n\n    solution = Solution()\n    result = solution.longestWord(words)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]",
          "expected_output": "world",
          "success": true,
          "output": "world"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]",
          "expected_output": "apple",
          "success": true,
          "output": "apple"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode131.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code, but a flow of algorithm. The problem: Given string s, find all palindrome partitionings. Classic backtracking.\n\nWe need to produce virtual code lines with comments. Use Start, End, Decision etc.\n\nWe need to list step by step: Start, Input s, Prepare result list, define helper function backtrack(start, currentPartition). At each call, if start == len(s), add current partition copy to result. Else iterate i from start to len(s)-1: substring s[start:i+1]; if palindrome, append to current partition, backtrack(i+1, ...), then pop. End.\n\nWe need to use virtual code arrows etc.\n\nWe need to produce each line with explanation. Each line with \"→\" arrow? According to format: lines like \"→ Step 1: ... // explanation\". Start and End are separate lines.\n\nWe need to show decision branches.\n\nLet's craft.\n\nLine 1: Start // Program starts.\n\nLine 2: → Input: s // Acquire the input string.\n\nLine 3: → Initialize result list // Prepare storage for all partitions.\n\nLine 4: → Define function backtrack(start, path) // Helper to explore partitions.\n\nLine 5: Decision: if start == len(s)? // Check if we reached end.\n\n    Yes → Step: Add copy of path to result // Completed a partition.\n\n    No → Step: For i from start to len(s)-1 // Explore substrings.\n\nLine 6: → Substring = s[start:i+1] // Extract candidate.\n\nLine 7: Decision: isPalindrome(Substring)? // Verify.\n\n    Yes → Step: Append Substring to path // Include substring.\n\n    → Call backtrack(i+1, path) // Recurse for remaining part.\n\n    → Remove last element from path // Backtrack.\n\n    No → Step: Continue loop // Skip non-palindrome.\n\nLine 8: End of for loop.\n\nLine 9: End of function.\n\nLine 10: Call backtrack(0, []) // Start recursion.\n\nLine 11: → Return result // Output all partitions.\n\nLine 12: End // Program ends.\n\nWe need each line with explanation. Use \"→\" for steps.\n\nWe might need to indent decision branches.\n\nLet's format.\n\nWe need each line as:\n\nStart // 程式開始執行\n→ Input s // ...\n\nWe need to include \"Decision:\" lines.\n\nThe example uses indentation for nested lines. We'll mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: s // 取得要切割的字串  \n→ Initialize result ← [] // 用來儲存所有符合條件的切割方式  \n\n→ 定義 function backtrack(start, path) // 回溯探索的協助函式  \n    Decision: 如果 start == len(s)? // 判斷是否已經走完整個字串  \n        Yes → Append copy of path to result // 將完整切割加入結果  \n        No  →  \n            → for i in range(start, len(s)) // 逐一嘗試以 i 為結尾的子字串  \n                → substring ← s[start:i+1] // 取出候選子字串  \n                Decision: substring 是 palindrome? // 檢查是否為回文  \n                    Yes →  \n                        → Append substring to path // 加入目前切割  \n                        → backtrack(i+1, path) // 針對剩餘部分繼續遞迴  \n                        → Remove last element from path // 回溯，移除剛才加入的子字串  \n                    No  →  // 子字串不是回文，直接跳過  \n                        → Continue // 進入下一個 i  \n\n→ End // backtrack 函式結束  \n\n→ Call backtrack(0, []) // 從字串開始位置開始遞迴探索  \n→ Return result // 回傳所有合法的回文切割組合  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def partition(self, s: str):\n        res = []\n\n        # Helper to check palindrome\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n\n        # Backtracking DFS\n        def dfs(start: int, path: list):\n            if start == len(s):\n                res.append(path[:])          # 完成一個合法切割，加入結果\n                return\n            for end in range(start + 1, len(s) + 1):   # 以 end 為結尾位置\n                sub = s[start:end]\n                if is_palindrome(sub):\n                    dfs(end, path + [sub])    # 包含此子字串繼續遞迴\n\n        dfs(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    content = sys.stdin.read().strip()\n    # 解析輸入：若存在雙引號則取引號內的字串\n    if '\"' in content:\n        first = content.find('\"')\n        second = content.find('\"', first + 1)\n        s = content[first + 1:second]\n    else:\n        # 若未包含雙引號，直接使用整行輸入\n        s = content\n\n    solution = Solution()\n    result = solution.partition(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
          "success": true,
          "output": "[['a', 'a', 'b'], ['aa', 'b']]"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode43.json",
    "problem_index_in_file": 0,
    "title": "Multiply Strings",
    "description_snippet": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for multiplying two large numbers represented as strings without using BigInteger or direct conversion to int. Standard approach: simulate manual multiplication: for each digit of num2 from right to left, multiply num1 digits, accumulate with offset, handle carry, add to result string. We need to produce steps like Start, Step 1: reverse strings or convert to arrays, Step 2: initialize result array of size len1+len2, Step 3: nested loops to multiply digits, accumulate in array, Step 4: handle carry, Step 5: build result string skipping leading zeros, End.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision structures if needed. Provide concise explanation.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step 1: 定義長度 len1 = num1.length, len2 = num2.length // 取得兩個字串長度\n\n→ Step 2: 建立長度為 len1+len2 的整數陣列 result，全部初始化為 0 // 儲存每位乘積暫存\n\n→ Decision: 如果 num1 為 \"0\" 或 num2 為 \"0\"? // 快速處理乘以 0\n\n    Yes → Step 3: 回傳 \"0\" // 結果為 0\n\n    No → ... // 進一步運算\n\n→ Step 4: 從右到左遍歷 num2 的每個位數 idx2\n\n→   Step 5: 取 num2.charAt(idx2) 為 digit2，轉為整數 d2 // 取得當前位數\n\n→   Step 6: 從右到左遍歷 num1 的每個位數 idx1\n\n→     Step 7: 取 num1.charAt(idx1) 為 digit1，轉為整數 d1\n\n→     Step 8: 計算 prod = d1 * d2 // 兩位數相乘\n\n→     Step 9: 累加至 result[idx1+idx2+1]，因為右移一位對應到索引 +1\n\n→     Step 10: result[idx1+idx2] += prod / 10 // 將十位數進位到左側\n\n→ Step 11: 建立 StringBuilder sb // 用於拼接結果\n\n→ Decision: 從左至右遍歷 result 陣列，尋找第一個非零索引 start\n\n    Yes → Step 12: 從 start 開始到結尾，將 result[i] 加到 sb // 拼接每位數\n\n    No → Step 13: sb.append('0') // 所有位都是 0，結果為 0\n\n→ Step 14: 回傳 sb.toString() // 回傳乘積字串\n\nEnd // 程式結束\n\nWe need to format with arrows and decisions properly. Ensure each line has \"虛擬碼步驟 // 解釋\".\n\nUse \"Start\" and \"End\".\n\nLet's produce each line. Ensure decisions indentation.\n\nWe can use \"Decision:\" lines and indent Yes/No. We'll include the arrow before each step. For decisions, we show Yes and No branches with arrows.\n\nLet's format:\n\nStart // 程式開始\n\n→ Step 1: len1 = num1.length; len2 = num2.length // 取得兩個字串長度\n\n→ Step 2: result = new int[len1 + len2] // 建立暫存乘積陣列，大小足以容納最大位數\n\n→ Decision: 如果 num1 == \"0\" 或 num2 == \"0\"? // 檢查是否有乘以 0 的情況\n\n    Yes → Step 3: return \"0\" // 直接回傳 0\n\n    No  → // 進一步執行乘法\n\n→ Step 4: for idx2 from len2-1 down to 0 // 依次遍歷 num2 的每位\n\n→   Step 5: d2 = num2.charAt(idx2) - '0' // 取得 num2 的當前位數\n\n→   Step 6: for idx1 from len1-1 down to 0 // 依次遍歷 num1 的每位\n\n→     Step 7: d1 = num1.charAt(idx1) - '0' // 取得 num1 的當前位數\n\n→     Step 8: prod = d1 * d2 // 兩位數相乘\n\n→     Step 9: sum = result[idx1 + idx2 + 1] + prod // 加入已存的值\n\n→     Step 10: result[idx1 + idx2 + 1] = sum % 10 // 設定單位位\n\n→     Step 11: result[idx1 + idx2] += sum / 10 // 將十位進位加到左側\n\n→ Step 12: sb = new StringBuilder() // 用於拼接最終字串\n\n→ Decision: 找到 result 的第一個非零索引 start // 去除前導零\n\n    Yes → Step 13: for i from start to result.length-1 sb.append(result[i]) // 拼接每位\n\n    No  → Step 14: sb.append('0') // 所有位都是零\n\n→ Step 15: return sb.toString() // 回傳乘積字串\n\nEnd // 程式結束\n\nMake sure each line ends with \"// 解釋\".\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: len1 = num1.length; len2 = num2.length // 取得兩個字串長度\n→ Step 2: result = new int[len1 + len2] // 建立暫存乘積陣列，大小足以容納最大位數\n→ Decision: 如果 num1 == \"0\" 或 num2 == \"0\"? // 檢查是否有乘以 0 的情況\n    Yes → Step 3: return \"0\" // 直接回傳 0\n    No  → // 進一步執行乘法\n→ Step 4: for idx2 from len2-1 down to 0 // 依次遍歷 num2 的每位\n→   Step 5: d2 = num2.charAt(idx2) - '0' // 取得 num2 的當前位數\n→   Step 6: for idx1 from len1-1 down to 0 // 依次遍歷 num1 的每位\n→     Step 7: d1 = num1.charAt(idx1) - '0' // 取得 num1 的當前位數\n→     Step 8: prod = d1 * d2 // 兩位數相乘\n→     Step 9: sum = result[idx1 + idx2 + 1] + prod // 加入已存的值\n→     Step 10: result[idx1 + idx2 + 1] = sum % 10 // 設定單位位\n→     Step 11: result[idx1 + idx2] += sum / 10 // 將十位進位加到左側\n→ Step 12: sb = new StringBuilder() // 用於拼接最終字串\n→ Decision: 找到 result 的第一個非零索引 start // 去除前導零\n    Yes → Step 13: for i from start to result.length-1 sb.append(result[i]) // 拼接每位\n    No  → Step 14: sb.append('0') // 所有位都是零\n→ Step 15: return sb.toString() // 回傳乘積字串\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # Quick return if either operand is zero\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        # Result can have at most m + n digits\n        pos = [0] * (m + n)\n\n        # Multiply each digit and add to pos array\n        for i in range(m - 1, -1, -1):\n            d1 = ord(num1[i]) - ord('0')\n            for j in range(n - 1, -1, -1):\n                d2 = ord(num2[j]) - ord('0')\n                mul = d1 * d2\n                p1, p2 = i + j, i + j + 1\n                s = mul + pos[p2]\n                pos[p2] = s % 10          # unit digit\n                pos[p1] += s // 10        # carry to left\n\n        # Convert pos array to string, skipping leading zeros\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result or '0'\n\ndef main() -> None:\n    # Read entire stdin\n    data = sys.stdin.read()\n\n    # Try to extract numbers enclosed in single quotes\n    nums = re.findall(r\"'(\\d+)'\", data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # Fallback: split by whitespace or comma\n        parts = re.split(r'[, \\n]+', data.strip())\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            return  # insufficient input\n\n    sol = Solution()\n    print(sol.multiply(num1, num2))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "success": true,
          "output": "56088"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode539.json",
    "problem_index_in_file": 0,
    "title": "Minimum Time Difference",
    "description_snippet": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference b...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Each line: virtual code step, space, // explanation. Use arrows and structure. Must follow the example style. Should produce a step-by-step algorithm.\n\nNeed to describe steps: parse times, convert to minutes, sort, compute differences, handle wrap-around, track min. Use decision points.\n\nLet's produce lines like:\n\nStart\n→ Step 1: 初始化空陣列 minutes // 用來存時間的分鐘數\n→ Decision: 對每個時間字串進行迴圈\n    → Step 2: 解析 \"HH:MM\" 為 hours, minutes // 分解時間\n    → Step 3: 轉換成總分鐘 num = hours * 60 + minutes // 轉成整數\n    → Step 4: 將 num 加入 minutes 陣列 // 儲存\nEnd // 完成轉換\n\nThen sort array.\n\n→ Step 5: 排序 minutes 陣列升序 // 為了方便計算差距\n\nCompute min difference:\n\n→ Step 6: 設 minDiff = Infinity // 初始最大值\n\n→ Decision: 對每個 i 從 0 到 length-2 進行迴圈\n    → Step 7: diff = minutes[i+1] - minutes[i] // 相鄰時間差\n    → Decision: diff < minDiff?\n        Yes → Step 8: minDiff = diff // 更新最小差距\n        No  → (nothing)\n\nWrap-around diff: between last and first + 24*60\n\n→ Step 9: wrapDiff = (minutes[0] + 24*60) - minutes[last] // 往前加一天\n→ Decision: wrapDiff < minDiff?\n    Yes → Step 10: minDiff = wrapDiff\n\n→ Step 11: return minDiff // 最小時間差\n\nEnd\n\nMake sure format uses Start End, arrows, decisions with Yes No.\n\nNeed each line separate. Provide explanations after //. Use the sample style.\n\nLet's construct. Ensure to use correct indentation? The sample uses spaces before Yes→ etc. We'll use indentation for decision blocks.\n\nWe'll produce each line.\n\nAlso maybe need variable names. Keep concise.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空陣列 minutes // 用來存時間的分鐘數  \n→ Decision: 對每個時間字串進行迴圈? // 逐一處理輸入時間  \n    → Step 2: 解析 \"HH:MM\" 為 hours, minutes // 分解小時與分鐘  \n    → Step 3: 轉換成總分鐘 num = hours * 60 + minutes // 轉為單一數值  \n    → Step 4: 將 num 加入 minutes 陣列 // 儲存分鐘數  \n→ Step 5: 排序 minutes 陣列升序 // 方便後續差距計算  \n→ Step 6: 設 minDiff = Infinity // 初始最小差距  \n→ Decision: 對每個 i 從 0 到 length-2 進行迴圈? // 計算相鄰差距  \n    → Step 7: diff = minutes[i+1] - minutes[i] // 相鄰時間差  \n    → Decision: diff < minDiff?  \n        Yes → Step 8: minDiff = diff // 更新最小差距  \n        No  → (無操作) // 保持目前最小值  \n→ Step 9: wrapDiff = (minutes[0] + 24*60) - minutes[last] // 先後時間差  \n→ Decision: wrapDiff < minDiff?  \n    Yes → Step 10: minDiff = wrapDiff // 更新最小差距  \n    No  → (無操作) // 保持目前最小值  \n→ Step 11: return minDiff // 回傳最小分鐘差距  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinDifference(self, timePoints):\n        \"\"\"\n        Compute the minimum difference in minutes between any two time points.\n        \"\"\"\n        minutes = []\n        # Convert each \"HH:MM\" string to total minutes since midnight\n        for t in timePoints:\n            h, m = map(int, t.split(':'))\n            minutes.append(h * 60 + m)\n\n        # Sort the minutes to make difference calculation trivial\n        minutes.sort()\n\n        # Initialize with a large number\n        min_diff = float('inf')\n\n        # Compare adjacent times in the sorted list\n        for i in range(1, len(minutes)):\n            diff = minutes[i] - minutes[i - 1]\n            if diff < min_diff:\n                min_diff = diff\n\n        # Account for the wrap‑around difference between the last and first time\n        wrap_diff = 1440 - (minutes[-1] - minutes[0])\n        if wrap_diff < min_diff:\n            min_diff = wrap_diff\n\n        return min_diff\n\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Safely evaluate the input string to get the list of time points\n    try:\n        time_points = ast.literal_eval(data)\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    # Compute and output the minimum difference\n    result = Solution().findMinDifference(time_points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"23:59\",\"00:00\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[\"00:00\",\"23:59\",\"00:00\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode665.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Array",
    "description_snippet": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with steps. No actual code. Steps: Start, iterate array, count violations, if >1 return false, else if one violation at index i, adjust either left or right to be non-decreasing, check. Provide explanation. Use arrows and decisions. Ensure each line has virtual code step + comment. Use Start, End, Decision. Use Yes → and No →. Provide step lines. Probably need to use 0-based. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 counter = 0 // 記錄發現的降序對數  \n→ Step 2: 設定 idx = -1 // 儲存第一次降序對的位置  \n→ Step 3: 從 i = 0 到 n-2 迭代 // 檢查每個相鄰對  \n→ Decision: 如果 nums[i] > nums[i+1]? // 判斷是否為降序對  \n  Yes → Step 4: counter++ // 計數器加一  \n      Decision: 如果 counter > 1? // 是否已超過一次  \n      Yes → Step 5: return false // 兩次以上必定不行  \n      No → Step 6: idx = i // 記錄降序對的位置  \n  No → Step 7: 繼續迴圈 // 正常情況無需處理  \n→ Step 8: Decision: 如果 counter == 0? // 完全非降序  \n  Yes → Step 9: return true // 已是非遞減陣列  \n  No → Step 10: // 有一次降序對，嘗試修正  \n    Decision: 如果 nums[idx-1] <= nums[idx+1]? // 可否調整左側元素  \n      Yes → Step 11: return true // 只需要調整左側即可  \n      No → Step 12: Decision: 如果 nums[idx] <= nums[idx+2]? // 可否調整右側元素  \n       Yes → Step 13: return true // 調整右側即可  \n       No → Step 14: return false // 兩側都無法修正  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def checkPossibility(self, nums):\n        \"\"\"檢查是否能通過最多修改一個元素使陣列變為非遞減。\"\"\"\n        count = 0\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i - 1]:\n                count += 1\n                if count > 1:\n                    return False\n                # 若 i == 1 或 nums[i] >= nums[i-2]，可以把前一個元素改成 nums[i]\n                if i == 1 or nums[i] >= nums[i - 2]:\n                    nums[i - 1] = nums[i]\n                else:\n                    # 否則把目前元素改成前一個\n                    nums[i] = nums[i - 1]\n        return True\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取數字列表。\"\"\"\n    # 找出第一個以 [ 開頭、] 結尾的子字串\n    match = re.search(r'\\[.*?\\]', data)\n    if match:\n        # 使用 eval 解析字串為 Python list（假設輸入安全）\n        return eval(match.group(0))\n    # 若沒有明確的 list 格式，直接 eval 整個輸入\n    return eval(data)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    nums = parse_input(raw_input)\n    result = Solution().checkPossibility(nums)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,2,3]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode446.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices II - Subsequence",
    "description_snippet": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n\nA sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line for problem: count arithmetic subsequences in array. It's known Leetcode 446. Approach: DP with map difference to count of subsequences ending at index with that difference. For each pair i<j, diff = nums[j]-nums[i], then prevCount = dp[i][diff], then dp[j][diff] += prevCount+1 (the +1 accounts for new subsequence of length 2). The result counts sequences length>=3 so we add prevCount to answer. Implementation details. Need to produce virtual code step by step with explanations.\n\nWe must use the specified format: each line \"虛擬碼步驟 // 解釋\".\n\nUse arrows, Start, End, Decision. We should include loops.\n\nOk produce. Let's draft.\n\nStart // Start program\n→ Step 1: 定義 nums 與 length n // 從輸入取得陣列\n→ Step 2: 初始化 dp 為 n 個空字典 // 用於儲存每個索引的差值對應計數\n→ Step 3: 初始化 answer 為 0 // 結果累加\n→ Decision: n < 3? // 若長度不足 3，無序列可計算\n    Yes → Step 4: Return answer // 直接回傳 0\n    No  →\n→ Step 5: 外層循環 i 從 0 到 n-1 // 遍歷前面元素\n    → Step 6: 內層循環 j 從 i+1 到 n-1 // 對每個後續元素\n        → Step 7: 計算 diff = nums[j] - nums[i] // 差值\n        → Step 8: 取得 prevCount = dp[i].get(diff, 0) // 以前 i 為結尾且差值為 diff 的序列數\n        → Step 9: 更新 dp[j][diff] += prevCount + 1 // 新增以 j 結尾的長度2及以上序列\n        → Step 10: answer += prevCount // 只計算長度≥3 的序列\n→ Step 11: Return answer // 完成\nEnd // 程式結束\n\nBut we need arrow lines as \"→ Step ...\". Also we need Decision block lines indentation. Let's align.\n\nAlso we must not include code. Just virtual steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 nums 與長度 n // 取得輸入陣列及其長度  \n→ Step 2: 初始化 dp 為 n 個空字典 // 每個索引儲存 {差值: 計數}  \n→ Step 3: 初始化 answer 為 0 // 儲存符合條件的等差子序列數目  \n→ Decision: n < 3? // 若陣列長度不足 3，無法形成等差子序列  \n Yes → Step 4: Return answer // 直接回傳 0  \n No  →  \n→ Step 5: 外層循環 i 從 0 到 n-1 // 遍歷所有前面元素  \n → Step 6: 內層循環 j 從 i+1 到 n-1 // 與每個後續元素配對  \n  → Step 7: 計算 diff = nums[j] - nums[i] // 兩個元素之差  \n  → Step 8: 取得 prevCount = dp[i].get(diff, 0) // 以 i 結尾且差值為 diff 的序列數  \n  → Step 9: 更新 dp[j][diff] += prevCount + 1 // 新增以 j 結尾的長度 2 以上序列  \n  → Step 10: answer += prevCount // 只將長度 ≥ 3 的序列加入答案  \n→ Step 11: Return answer // 回傳最終計數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        dp = [defaultdict(int) for _ in range(n)]\n        total = 0\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                count = dp[j][diff]\n                dp[i][diff] += count + 1\n                total += count\n        return total\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入轉成 list，支援「nums = [...」或直接 [...」兩種格式\n    if data.startswith(\"nums\"):\n        _, list_part = data.split(\"=\", 1)\n        nums = ast.literal_eval(list_part.strip())\n    else:\n        nums = ast.literal_eval(data)\n    result = Solution().numberOfArithmeticSlices(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,4,6,8,10]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [7,7,7,7,7]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode309.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode with line-by-line comments. For Leetcode \"Best Time to Buy and Sell Stock with Cooldown\". We need virtual code steps with decisions. Use Start, End, Decision. Use arrows.\n\nWe need to produce steps: iterate days, maintain states: hold, sold, rest? Classic DP: dp[i][0] = max(dp[i-1][0], dp[i-1][2]); dp[i][1] = max(dp[i-1][1], dp[i-1][0] - price[i]); dp[i][2] = dp[i-1][1] + price[i]; final answer max(dp[n-1][0], dp[n-1][2]). But virtual steps should be simpler: iterate days, compute new values.\n\nWe must output each line with virtual code and comment. Use arrows. Use \"Decision:\" for if statements. Use \"Yes →\" and \"No →\".\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 定義 n 為 prices 長度 // 取得陣列長度\n→ Decision: 如果 n <= 1? // 檢查是否足夠交易\n    Yes → Step 2: 回傳 0 // 只有一天無法盈利\n    No  → Step 3: 初始化 hold, sold, rest 變數 // 設定初始狀態\n        rest ← 0 // 未持股且不在冷卻\n        hold ← -prices[0] // 第一天買入股價\n        sold ← INT_MIN // 無法即時賣出\n\n→ Step 4: 從第 1 天開始迭代至第 n-1 天 // 逐日處理\n    → For i 從 1 到 n-1 進行\n        → Step 5: tempHold ← max(hold, rest - prices[i]) // 持股狀態\n            // 保持之前持股或今天買入\n        → Step 6: tempSold ← hold + prices[i] // 賣出狀態\n            // 若今天賣出\n        → Step 7: tempRest ← max(rest, sold) // 冷卻或持續休息\n            // 既不買也不賣\n        → Step 8: hold ← tempHold // 更新持股\n        → Step 9: sold ← tempSold // 更新賣出\n        → Step10: rest ← tempRest // 更新休息\n\n→ Step11: 回傳 max(rest, sold) // 最終最大利潤\nEnd // 程式執行結束\n\nBut need arrows per line. Let's format as required:\n\nStart // 程式開始執行\n→ Step 1: n ← len(prices) // 取得陣列長度\n→ Decision: n <= 1? // 是否只有一天\n    Yes → Step 2: return 0 // 直接回傳零利潤\n    No  → Step 3: rest ← 0 // 初始未持股且非冷卻\n        → rest ← 0 // 冷卻狀態為 0\n        → hold ← -prices[0] // 第一天買入股價\n        → sold ← -INF // 初始賣出狀態不可用\n\nBut we need arrow per line; we can't nest multiple statements in same line unless we separate them. We might have to write multiple lines for initialization.\n\nLet's design:\n\nStart // 程式開始執行\n→ Step 1: n ← len(prices) // 取得陣列長度\n→ Decision: n <= 1? // 只剩一日無法交易\n    Yes → Step 2: return 0 // 回傳 0 利潤\n    No  → Step 3: rest ← 0 // 初始化不持股且非冷卻\n        → Step 4: hold ← -prices[0] // 初始化持股狀態\n        → Step 5: sold ← -∞ // 初始化賣出狀態為負無限\n\nBut the indentation: Each step after decision should be separate lines with arrow? In example, they used indentation for nested steps but still separate lines. So we can mimic.\n\nContinue:\n\n→ Step 6: for i from 1 to n-1 // 逐日迭代\n    → Step 7: tempHold ← max(hold, rest - prices[i]) // 決定持股\n    → Step 8: tempSold ← hold + prices[i] // 賣出今天\n    → Step 9: tempRest ← max(rest, sold) // 休息或冷卻\n    → Step10: hold ← tempHold // 更新持股\n    → Step11: sold ← tempSold // 更新賣出\n    → Step12: rest ← tempRest // 更新休息\n\n→ Step13: return max(rest, sold) // 最大利潤\n\nEnd // 程式結束\n\nWe also need to use \"Decision:\" for if statements. Also maybe we can show \"Yes →\" \"No →\". Provide comments.\n\nAlso we need arrow notation: \"→\" preceding each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← len(prices) // 取得股票價格陣列長度  \n→ Decision: n <= 1? // 只有一日或更少，無法完成交易  \n  Yes → Step 2: return 0 // 直接回傳 0 利潤  \n  No  → Step 3: rest ← 0 // 初始化不持股且不處於冷卻期  \n   → Step 4: hold ← -prices[0] // 第一天買入股價，持股狀態  \n   → Step 5: sold ← -∞ // 初始賣出狀態不可用，設為負無限  \n\n→ Step 6: for i from 1 to n-1 // 逐日迭代處理每一天的價格  \n  → Step 7: tempHold ← max(hold, rest - prices[i]) // 保持持股或今天買入  \n  → Step 8: tempSold ← hold + prices[i] // 若今天賣出，計算利潤  \n  → Step 9: tempRest ← max(rest, sold) // 既不買也不賣，進入或保持冷卻  \n  → Step10: hold ← tempHold // 更新持股狀態  \n  → Step11: sold ← tempSold // 更新賣出狀態  \n  → Step12: rest ← tempRest // 更新休息/冷卻狀態  \n\n→ Step13: return max(rest, sold) // 回傳最終最大利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef maxProfit(prices):\n    \"\"\"\n    計算在允許冷卻日的情況下能獲得的最大利潤。\n    \"\"\"\n    if not prices:\n        return 0\n\n    # 兩種持股/不持股的狀態\n    hold = -prices[0]   # 持有股票的最大收益\n    sold = 0            # 剛賣出股票的最大收益\n    rest = 0            # 不持有股票且未剛賣出的最大收益\n\n    for price in prices[1:]:\n        prev_sold = sold                # 先記住前一天的 sold\n        sold = hold + price             # 今天賣出\n        hold = max(hold, rest - price)  # 今天持有或買入\n        rest = max(rest, prev_sold)     # 今天休息或從 sold 回到 rest\n\n    return max(sold, rest)\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n    # 抓取所有整數，支援負號\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # 若沒有數字，直接輸出 0\n    if not nums:\n        print(0)\n        return\n\n    prices = nums          # 直接把抓到的數字作為價格陣列\n    result = maxProfit(prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,2,3,0,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "prices = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode275.json",
    "problem_index_in_file": 0,
    "title": "H-Index II",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation per line. Need binary search. Array sorted non-descending. h-index defined as maximum h such that citations[i] >= h for at least h papers. Equivalent: find largest h such that citations[n-h] >= h. Because sorted ascending, last h elements with citations >= h. Binary search over h from 0 to n. Implementation: low=0, high=n. while low<high: mid = ceil((low+high+1)/2) to avoid infinite loop. if citations[n-mid] >= mid then low=mid else high=mid-1. Return low.\n\nWe produce virtual steps lines. Let's format accordingly. Use Start, End, Decision. Provide explanation after //. Each step include \"虛擬碼步驟\". We'll use English for virtual code but can use Chinese. We'll use e.g. \"Start\" etc. Provide algorithm. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(citations) // 取得數組長度  \n→ Step 2: low ← 0 // 初始化搜尋下限  \n→ Step 3: high ← n // 初始化搜尋上限  \n→ Decision: 是否還有搜尋區間? // 檢查 low < high  \n    Yes → Step 4: mid ← ceil((low + high + 1) / 2) // 計算中間值，向上取整避免無窮迴圈  \n    → Decision: citations[n - mid] ≥ mid? // 檢查中間位置是否符合 h 指標條件  \n        Yes → Step 5: low ← mid // 有足夠被引用，搜尋更大的 h  \n        No  → Step 6: high ← mid - 1 // 不足，縮小搜尋區間  \n    ← Step 7: 從 Decision 1 重新判斷 // 重複 binary search  \n← Step 8: 返回 low // low 為最大的 h 值，滿足 h‑index 條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def hIndex(self, citations):\n        \"\"\"\n        Binary search on a sorted ascending list to find the largest h such that\n        at least h papers have >= h citations.\n        \"\"\"\n        n = len(citations)\n        low, high = 0, n\n        while low < high:\n            # 向上取整，避免無窮迴圈\n            mid = (low + high + 1) // 2\n            # citations[n - mid] 是排序後，從右邊數起第 mid 個元素\n            if citations[n - mid] >= mid:\n                low = mid  # 可能更大，將 lower bound 調高\n            else:\n                high = mid - 1  # 不夠，將 upper bound 調低\n        return low\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式，例如 \"citations = [0,1,3,5,6]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # 安全地評估表達式，限制可用名稱\n    try:\n        citations = eval(expr, {\"__builtins__\": None}, {})\n    except Exception:\n        # 若評估失敗，直接使用 eval 但仍允許 Python 標準語法\n        citations = eval(expr)\n\n    sol = Solution()\n    result = sol.hIndex(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode403.json",
    "problem_index_in_file": 0,
    "title": "Frog Jump",
    "description_snippet": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. The problem: frog crossing river stones. Classic Leetcode \"Frog Jump\". We need algorithm steps. Probably use DFS with memoization or DP. Provide virtual pseudocode steps. Each line: \"Step: ...\" + comment.\n\nWe need structure: Start, Steps, Decision, etc.\n\nLet's outline:\n\nStart\n→ Build set of stone positions for O(1) lookup\n→ Define recursive function DFS(current_index, last_jump)\n    → If current_index == last stone index, return true\n    → If memo[current_index][last_jump] exists, return memo\n    → For next_jump in {last_jump-1, last_jump, last_jump+1} if >0\n         → target_pos = stones[current_index] + next_jump\n         → If target_pos in stone_set\n              → next_index = index of target_pos (maybe use map)\n              → If DFS(next_index, next_jump) return true\n    → memo[current_index][last_jump] = false\n    → return false\n→ Call DFS(0, 0?) Actually first jump must be 1. So start with last_jump=0? Actually first jump must be 1, so we call DFS(0,0) and handle next_jump=1. Or simpler: start at index0, last_jump=0 then handle next=1. We'll just handle base case.\n\nBut we need steps line by line. Could do iterative DP as well. But recursion easier.\n\nWe need to maintain map from stone position to index for O(1). Use dictionary.\n\nWe need memoization: maybe use dict key (index, last_jump). For virtual code we can mention.\n\nLet's craft steps:\n\nStart\n→ Initialize stones array, stone_set, pos_to_index map\n→ Define memo dictionary\n→ Define recursive function solve(i, k) // i index, k last jump\n    → If i == last index: return true\n    → If (i,k) in memo: return memo[(i,k)]\n    → For next_k in [k-1, k, k+1]:\n        → If next_k <= 0: continue\n        → target = stones[i] + next_k\n        → If target in stone_set:\n            → j = pos_to_index[target]\n            → If solve(j, next_k): memo[(i,k)] = true; return true\n    → memo[(i,k)] = false; return false\n→ Return solve(0,0) // first jump must be 1 handled inside loop\n\nBut we need to show each line as a step, not function definition? The output requires each line with virtual code step and comment. We can present function lines as separate steps.\n\nWe need to use arrow for steps. Use indentation? Use \"→\" for steps and decisions. For decisions, \"Decision:\".\n\nWe'll produce something like:\n\nStart // 程式開始\n→ Initialize stones array, stone_set, pos_to_index map // 設置石頭位置、集合與索引映射\n→ Initialize memo dictionary // 用於儲存子問題結果\n→ Define recursive function solve(i, k) // i: 当前石头索引，k: 上一次跳跃长度\n    → Decision: i == last_index? // 判断是否已到达最后石头\n        Yes → Return true // 到达终点，成功\n        No  → // 继续搜索\n    → Decision: (i,k) in memo? // 检查是否已计算过\n        Yes → Return memo[(i,k)] // 返回缓存结果\n        No  → // 需要计算\n    → For next_k in [k-1, k, k+1]:\n        → Decision: next_k > 0? // 跳跃长度必须正\n            Yes → target = stones[i] + next_k // 计算目标位置\n                → Decision: target in stone_set? // 判断目标位置是否有石头\n                    Yes → j = pos_to_index[target] // 获取目标石头索引\n                        → Decision: solve(j, next_k)? // 递归尝试下一跳\n                            Yes → memo[(i,k)] = true; Return true // 找到通路\n                            No  → Continue loop // 继续尝试其他跳跃长度\n                    No  → Continue loop // 无石头，跳过\n            No  → Continue loop // 跳跃长度不合法\n    → memo[(i,k)] = false; Return false // 所有跳跃都失败\n→ Decision: solve(0,0)? // 从起始石头开始，初始跳跃长度设为0\n    Yes → Output true // 可以过河\n    No  → Output false // 无法过河\nEnd // 程式結束\n\nBut we must ensure each line as per format: \"虛擬碼步驟 [空格] // 解釋/說明\". Use \"→\" arrow before steps, \"Decision:\" for decision, \"Yes →\", \"No →\" for branches. Use indentation? Might use spaces to indicate nested structure. The example shows indentation with spaces.\n\nLet's follow format:\n\nStart // 程式開始執行\n→ Initialize stones array, stone_set, pos_to_index map // 初始化石頭位置、集合與索引映射\n→ Initialize memo dictionary // 用於儲存子問題結果\n→ Define recursive function solve(i, k) // i: 当前石頭索引，k: 上一次跳躍長度\n    → Decision: i == last_index? // 判斷是否已到達最後石頭\n        Yes → Return true // 成功到達終點\n        No  → // 繼續搜尋\n    → Decision: (i,k) in memo? // 檢查是否已計算過\n        Yes → Return memo[(i,k)] // 返回快取結果\n        No  → // 需要計算\n    → For next_k in [k-1, k, k+1]:\n        → Decision: next_k > 0? // 跳躍長度必須正\n            Yes → target = stones[i] + next_k // 計算目標位置\n                → Decision: target in stone_set? // 判斷目標位置是否有石頭\n                    Yes → j = pos_to_index[target] // 獲取目標石頭索引\n                        → Decision: solve(j, next_k)? // 递归尝试下一跳\n                            Yes → memo[(i,k)] = true; Return true // 找到通路\n                            No  → Continue loop // 继续尝试其他跳跃长度\n                    No  → Continue loop // 無石頭，跳過\n            No  → Continue loop // 跳躍長度不合法\n    → memo[(i,k)] = false; Return false // 所有跳躍都失敗\n→ Decision: solve(0,0)? // 從起始石頭開始，初始跳躍長度設為0\n    Yes → Output true // 可以過河\n    No  → Output false // 無法過河\nEnd // 程式執行結束\n\nWe need to ensure we use \"→\" before each step. In decisions, use \"Decision:\" etc. Also we must avoid using actual code keywords like \"Return\" maybe considered actual code? But virtual code fine. We just need pseudo. It's fine.\n\nWe also need \"Start\" and \"End\" lines. Should we include them with arrow? Example shows \"Start\" at line without arrow. Then \"→\" for steps. Let's replicate. Also indentation for nested lines uses spaces. We can use 4 spaces for indentation. Let's produce.\n\nLet's output final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize stones array, stone_set, pos_to_index map // 初始化石頭位置、集合與索引映射  \n→ Initialize memo dictionary // 用於儲存子問題結果  \n\n→ Define recursive function solve(i, k) // i: 現在石頭索引，k: 上一次跳躍長度  \n    → Decision: i == last_index? // 判斷是否已到達最後石頭  \n        Yes → Return true // 成功到達終點  \n        No  → // 繼續搜尋  \n\n    → Decision: (i,k) in memo? // 檢查是否已計算過  \n        Yes → Return memo[(i,k)] // 返回快取結果  \n        No  → // 需要計算  \n\n    → For next_k in [k-1, k, k+1]:  \n        → Decision: next_k > 0? // 跳躍長度必須正  \n            Yes → target = stones[i] + next_k // 計算目標位置  \n                → Decision: target in stone_set? // 判斷目標位置是否有石頭  \n                    Yes → j = pos_to_index[target] // 獲取目標石頭索引  \n                        → Decision: solve(j, next_k)? // 递归尝试下一跳  \n                            Yes → memo[(i,k)] = true; Return true // 找到通路  \n                            No  → Continue loop // 继续尝试其他跳跃长度  \n                    No  → Continue loop // 無石頭，跳過  \n            No  → Continue loop // 跳躍長度不合法  \n\n    → memo[(i,k)] = false; Return false // 所有跳躍都失敗  \n\n→ Decision: solve(0,0)? // 從起始石頭開始，初始跳躍長度設為0  \n    Yes → Output true // 可以過河  \n    No  → Output false // 無法過河  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def canCross(self, stones):\n        stone_set = set(stones)\n        last_stone = stones[-1]\n        # 记录每个石头可到达的跳跃长度集合\n        jumps = {stone: set() for stone in stones}\n        jumps[stones[0]].add(0)  # 初始位置不算跳跃\n\n        for stone in stones:\n            for k in jumps[stone]:\n                for step in (k - 1, k, k + 1):\n                    if step > 0 and stone + step in stone_set:\n                        jumps[stone + step].add(step)\n\n        return bool(jumps[last_stone])\n\nif __name__ == \"__main__\":\n    # 读取全部输入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 从输入中提取列表\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        stones_str = match.group()\n    else:\n        stones_str = data\n\n    try:\n        stones = ast.literal_eval(stones_str)\n    except Exception:\n        print(\"false\")\n        sys.exit(0)\n\n    solution = Solution()\n    print(\"true\" if solution.canCross(stones) else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stones = [0,1,3,5,6,8,12,17]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "stones = [0,1,2,3,4,8,9,11]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  }
]